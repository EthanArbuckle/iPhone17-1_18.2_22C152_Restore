uint64_t sub_1B63861B4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  int v11;
  signed int v12;
  _OWORD v14[2];
  uint64_t v15;
  _OWORD v16[2];
  uint64_t v17;

  if ((*(uint64_t (**)(void))(*(void *)(a2 + 8) + 48))()) {
    sub_1B6BF3528(a3, a4, a5, a1, a2, 1);
  }
  v11 = *(_DWORD *)(v5 + 24);
  swift_retain();
  v17 = 0;
  memset(v16, 0, sizeof(v16));
  v15 = 0;
  memset(v14, 0, sizeof(v14));
  v12 = sub_1B637F628(v11, a1, a2, 0, 0, (uint64_t)v16, (uint64_t)v14);
  swift_release();
  sub_1B6386458((uint64_t)v14);
  sub_1B6386458((uint64_t)v16);
  return sub_1B63B325C(a3, a4, a5, v12);
}

uint64_t sub_1B63862D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  if (a1) {
    uint64_t v7 = sub_1B6E31F28() ^ a7;
  }
  if (a3) {
    v7 ^= sub_1B6E31F28();
  }
  sub_1B638651C(a5, (uint64_t)&v16);
  if (v17)
  {
    sub_1B62C15C4(&v16, (uint64_t)v18);
    sub_1B62C14BC(v18, v19);
    swift_getDynamicType();
    v7 ^= sub_1B6E31F28();
    uint64_t v11 = v19;
    uint64_t v12 = v20;
    sub_1B62C14BC(v18, v19);
    (*(uint64_t (**)(uint64_t, uint64_t))(v12 + 16))(v11, v12);
    _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v18);
  }
  else
  {
    sub_1B6386458((uint64_t)&v16);
  }
  sub_1B638651C(a6, (uint64_t)&v16);
  if (v17)
  {
    sub_1B62C15C4(&v16, (uint64_t)v18);
    sub_1B62C14BC(v18, v19);
    swift_getDynamicType();
    v7 ^= sub_1B6E31F28();
    uint64_t v13 = v19;
    uint64_t v14 = v20;
    sub_1B62C14BC(v18, v19);
    (*(uint64_t (**)(uint64_t, uint64_t))(v14 + 16))(v13, v14);
    _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v18);
  }
  else
  {
    sub_1B6386458((uint64_t)&v16);
  }
  return v7;
}

uint64_t sub_1B6386458(uint64_t a1)
{
  sub_1B63864B4();
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

void sub_1B63864B4()
{
  if (!qword_1EB97E850)
  {
    sub_1B62C5560(255, (unint64_t *)&qword_1EB97E840);
    unint64_t v0 = sub_1B6E324B8();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB97E850);
    }
  }
}

uint64_t sub_1B638651C(uint64_t a1, uint64_t a2)
{
  sub_1B63864B4();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

uint64_t destroy for FunctionConstant.Key(uint64_t a1)
{
  return sub_1B62D66CC(*(void *)a1, *(void *)(a1 + 8), *(unsigned char *)(a1 + 16));
}

uint64_t getEnumTagSinglePayload for CachedLocationMapping(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x3E && *(unsigned char *)(a1 + 40)) {
    return (*(_DWORD *)a1 + 62);
  }
  unsigned int v3 = (*(unsigned char *)(a1 + 24) & 0x3C | (*(unsigned __int8 *)(a1 + 24) >> 6)) ^ 0x3F;
  if (v3 >= 0x3D) {
    unsigned int v3 = -1;
  }
  return v3 + 1;
}

uint64_t sub_1B63865E0()
{
  return 0;
}

void *_s3VFX8VFXSceneC14ScriptFunctionVwCP_0(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  a1[2] = a2[2];
  swift_bridgeObjectRetain();
  return a1;
}

double vfx_script_clock_time(void *a1)
{
  return *(double *)(*a1 + OBJC_IVAR____TtC3VFX13EntityManager_clock + 48);
}

uint64_t destroy for Scheduler.Job()
{
  swift_unknownObjectRelease();

  return swift_release();
}

uint64_t initializeWithCopy for Scheduler.Job(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v3;
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 56);
  *(unsigned char *)(a1 + 72) = *(unsigned char *)(a2 + 72);
  *(_WORD *)(a1 + 73) = *(_WORD *)(a2 + 73);
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 76);
  uint64_t v4 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v4;
  swift_unknownObjectRetain();
  swift_retain();
  return a1;
}

BOOL sub_1B63866F4()
{
  return *(_DWORD *)(*(void *)(v0 + 16) + 80) == *(_DWORD *)(*(void *)(v0 + 16) + 56);
}

uint64_t sub_1B638670C()
{
  return *(unsigned int *)(*(void *)(v0 + 16) + 56);
}

uint64_t storeEnumTagSinglePayload for CachedLocationMapping(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x3D)
  {
    *(_OWORD *)(result + 8) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(void *)result = a2 - 62;
    if (a3 >= 0x3E) {
      *(unsigned char *)(result + 40) = 1;
    }
  }
  else
  {
    if (a3 >= 0x3E) {
      *(unsigned char *)(result + 40) = 0;
    }
    if (a2)
    {
      *(void *)result = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      *(unsigned char *)(result + 24) = 4 * (((-a2 >> 2) & 0xF) - 16 * a2);
    }
  }
  return result;
}

uint64_t destroy for LocationMapping(uint64_t a1)
{
  return sub_1B62C6AE0(*(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), *(unsigned char *)(a1 + 24));
}

uint64_t destroy for QueryManager.QueryInfo()
{
  swift_release();
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t destroy for MetalFunctionReflection.Arg()
{
  return swift_release();
}

uint64_t sub_1B63867E4(uint64_t a1)
{
  return sub_1B62C305C(a1, *v1);
}

uint64_t sub_1B63867F8()
{
  return sub_1B6E33698();
}

uint64_t sub_1B6386824()
{
  return swift_deallocClassInstance();
}

uint64_t sub_1B6386834()
{
  swift_bridgeObjectRelease();

  return swift_deallocClassInstance();
}

void sub_1B638686C(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1F4188790](a1, a2);
  uint64_t v3 = v2;
  uint64_t v191 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = swift_retain();
  uint64_t v5 = sub_1B636E574(v4);
  char v7 = v6;
  swift_release();
  if ((v7 & 1) == 0)
  {
    sub_1B63304A4(v5, (uint64_t)&v178);
    char v8 = BYTE8(v182);
    if (BYTE8(v182) != 2 && *(float *)&v178 > 0.0)
    {
      uint64_t v9 = *(void *)(v3 + OBJC_IVAR____TtC3VFX13EntityManager_renderer);
      if (v9)
      {
        int v77 = v178;
        uint64_t v73 = v179;
        int v75 = DWORD1(v182);
        int v76 = v182;
        uint64_t v10 = v180;
        long long v74 = v181;
        swift_retain();
        RGTextureDescriptor.init()((uint64_t)v100);
        sub_1B6388B3C(v9 + 624, (uint64_t)v172);
        sub_1B6388B3C((uint64_t)v172, (uint64_t)v173);
        if (sub_1B6388C10(v173) == 1) {
          goto LABEL_63;
        }
        uint64_t v11 = v173[1];
        uint64_t ObjectType = swift_getObjectType();
        uint64_t v13 = *(double (**)(uint64_t, uint64_t))(v11 + 72);
        swift_unknownObjectRetain();
        double v14 = v13(ObjectType, v11);
        swift_unknownObjectRelease();
        sub_1B6388B3C(v9 + 624, (uint64_t)v170);
        sub_1B6388B3C((uint64_t)v170, (uint64_t)v171);
        if (sub_1B6388C10(v171) == 1) {
          goto LABEL_63;
        }
        uint64_t v78 = (uint64_t)v14;
        uint64_t v15 = v171[1];
        long long v85 = v105;
        uint64_t v87 = v106;
        uint64_t v82 = v104;
        char v80 = v103;
        char v16 = v102;
        int v17 = v101;
        uint64_t v18 = swift_getObjectType();
        uint64_t v19 = *(void (**)(uint64_t, uint64_t))(v15 + 72);
        swift_unknownObjectRetain();
        v19(v18, v15);
        double v21 = v20;
        swift_unknownObjectRelease();
        uint64_t v22 = *(void *)(v9 + 408);
        __int16 v116 = v78;
        __int16 v117 = (uint64_t)v21;
        int v118 = v17;
        char v119 = 1;
        char v120 = v16;
        char v121 = v80;
        uint64_t v122 = v22;
        uint64_t v123 = v82;
        long long v124 = xmmword_1B6E500D0;
        long long v125 = v85;
        uint64_t v126 = v87;
        int v127 = v107;
        if (sub_1B638D61C() <= 1) {
          goto LABEL_29;
        }
        char v23 = *(unsigned char *)(v3 + OBJC_IVAR____TtC3VFX13EntityManager_isInPrepare);
        uint64_t v24 = *(void *)(v9 + 272);
        sub_1B6383E40((uint64_t)v174);
        uint64_t v25 = *(void *)(*(void *)(*(void *)(v24 + 16) + 264) + 40);
        uint64_t v26 = *(void *)(v25 + 16);
        swift_retain();
        swift_retain();
        if (v26)
        {
          uint64_t v27 = v174[1];
          uint64_t v28 = v174[0];
          swift_bridgeObjectRetain();
          uint64_t v29 = sub_1B62B2CE0(v28, v27);
          if (v30)
          {
            v31 = *(void **)(*(void *)(v25 + 56) + 8 * v29);
            swift_unknownObjectRetain();
            sub_1B62C7BF4((uint64_t)v174);
            swift_release();
            sub_1B62C7BF4((uint64_t)v174);
            swift_release();
            unsigned int v32 = 0;
LABEL_13:
            sub_1B6383E40((uint64_t)v175);
            swift_retain();
            v33 = (void *)sub_1B6330D9C((uint64_t)v175, 1, 0, 2);
            sub_1B62C7BF4((uint64_t)v175);
            swift_release();
            if (v33)
            {
              v72 = v31;
              uint64_t v83 = v8 & 1;
              swift_getObjectType();
              uint64_t v34 = sub_1B638D6C0() - 3;
              if (v73 < v34) {
                uint64_t v34 = v73;
              }
              if (v34 <= 2) {
                uint64_t v34 = 2;
              }
              uint64_t v86 = v34;
              uint64_t v35 = *(void *)(v9 + 264);
              swift_retain();
              RGTextureDescriptorFromMTLTexture(v33, (uint64_t)&v178);
              uint64_t v108 = v178;
              __int16 v109 = v179;
              char v110 = BYTE2(v179);
              long long v111 = v180;
              long long v112 = v181;
              long long v113 = v182;
              uint64_t v114 = v183;
              int v115 = v184;
              if (*(void *)(*(void *)(v35 + 40) + 16)) {
                sub_1B62B2CE0(0x4D545F4D4F4F4C42, 0xE900000000000050);
              }
              v36 = (void *)sub_1B6331208(0x4D545F4D4F4F4C42, 0xE900000000000050, &v108);
              swift_release();
              uint64_t v88 = (uint64_t)v36;
              long long v94 = 0u;
              long long v95 = 0u;
              long long v96 = 0u;
              long long v97 = 0u;
              id v93 = objc_msgSend(v36, sel_pixelFormat);
              uint64_t v98 = 0;
              uint64_t v99 = 1;
              long long v155 = v74;
              v154[0] = v77;
              int v156 = v76;
              int v157 = v75;
              *(void *)&long long v158 = 0xD000000000000010;
              *((void *)&v158 + 1) = 0x80000001B6F396F0;
              uint64_t v37 = MEMORY[0x1E4FBC860];
              uint64_t v160 = 0;
              uint64_t v159 = 0;
              *(_OWORD *)&v161[8] = xmmword_1B6EA9A10;
              *(void *)v161 = MEMORY[0x1E4FBC860];
              uint64_t v162 = 0;
              *(void *)&long long v163 = 0;
              *((void *)&v163 + 1) = MEMORY[0x1E4FBC860];
              long long v168 = 0u;
              long long v169 = 0u;
              long long v166 = 0u;
              long long v167 = 0u;
              long long v164 = 0u;
              long long v165 = 0u;
              v190[2] = *(_OWORD *)v161;
              v190[1] = 0u;
              v190[0] = v158;
              memset(&v190[5], 0, 96);
              v190[4] = v163;
              v190[3] = 0xEF646C6F68736572;
              sub_1B62D853C(0, (unint64_t *)&qword_1EB985580, (uint64_t)&type metadata for FunctionConstant, MEMORY[0x1E4FBBE00]);
              uint64_t v38 = swift_allocObject();
              *(_OWORD *)(v38 + 16) = xmmword_1B6E77050;
              *(_OWORD *)(v38 + 32) = xmmword_1B6EA9A20;
              *(unsigned char *)(v38 + 48) = 0;
              *(void *)(v38 + 64) = v32;
              *(_OWORD *)(v38 + 72) = 0u;
              *(_OWORD *)(v38 + 88) = 0u;
              *(_OWORD *)(v38 + 104) = 0u;
              *(void *)(v38 + 120) = 0;
              *(unsigned char *)(v38 + 128) = 13;
              memset(v186, 0, sizeof(v186));
              __int16 v187 = 256;
              v188[1] = 0;
              v188[0] = 0;
              v188[2] = 2;
              memset(&v188[3], 0, 24);
              sub_1B62D5ED4((uint64_t *)v190, &v93, 0, 0, v38, (uint64_t)v186, 3, (uint64_t)v188, (uint64_t)v176, 1, 1);
              sub_1B638A224((uint64_t *)&v158);
              swift_retain();
              unint64_t v39 = sub_1B638A310((uint64_t)v176, 0);
              v41 = v40;
              unint64_t v79 = 0;
              if (v39 >= 3)
              {
                unint64_t v39 = swift_unknownObjectRetain();
                unint64_t v79 = v39;
              }
              sub_1B630B7D8(v39, v41);
              swift_release();
              *(void *)&long long v141 = 0xD000000000000010;
              *((void *)&v141 + 1) = 0x80000001B6F396F0;
              uint64_t v143 = 0;
              uint64_t v142 = 0;
              *(void *)&long long v144 = v37;
              *((void *)&v144 + 1) = 0xD000000000000011;
              unint64_t v145 = 0x80000001B6F4A480;
              uint64_t v146 = 0;
              *(void *)&long long v147 = 0;
              *((void *)&v147 + 1) = v37;
              long long v148 = 0u;
              long long v149 = 0u;
              long long v150 = 0u;
              long long v151 = 0u;
              long long v152 = 0u;
              long long v153 = 0u;
              v189[2] = v144;
              v189[1] = 0u;
              v189[0] = v141;
              memset(&v189[5], 0, 96);
              v189[4] = v147;
              v189[3] = 0x80000001B6F4A480;
              uint64_t v42 = swift_allocObject();
              *(_OWORD *)(v42 + 16) = xmmword_1B6E77050;
              *(_OWORD *)(v42 + 32) = xmmword_1B6EA9A30;
              *(unsigned char *)(v42 + 48) = 0;
              *(void *)(v42 + 64) = v83;
              *(_OWORD *)(v42 + 72) = 0u;
              *(_OWORD *)(v42 + 88) = 0u;
              *(_OWORD *)(v42 + 104) = 0u;
              *(void *)(v42 + 120) = 0;
              *(unsigned char *)(v42 + 128) = 13;
              sub_1B62D5ED4((uint64_t *)v189, &v93, 0, 0, v42, (uint64_t)v186, 3, (uint64_t)v188, (uint64_t)v177, 1, 1);
              sub_1B638A224((uint64_t *)&v141);
              swift_retain();
              unint64_t v43 = sub_1B638A310((uint64_t)v177, 0);
              v45 = v44;
              unint64_t v81 = 0;
              if (v43 >= 3)
              {
                unint64_t v43 = swift_unknownObjectRetain();
                unint64_t v81 = v43;
              }
              sub_1B630B7D8(v43, v45);
              swift_release();
              *(void *)&long long v128 = 0xD000000000000010;
              *((void *)&v128 + 1) = 0x80000001B6F396F0;
              *(void *)&long long v131 = v37;
              *((void *)&v131 + 1) = 0xD00000000000001DLL;
              uint64_t v130 = 0;
              uint64_t v129 = 0;
              unint64_t v132 = 0x80000001B6F4A4A0;
              uint64_t v133 = 0;
              *(void *)&long long v134 = 0;
              *((void *)&v134 + 1) = v37;
              long long v135 = 0u;
              long long v136 = 0u;
              long long v137 = 0u;
              long long v138 = 0u;
              long long v139 = 0u;
              long long v140 = 0u;
              v185[2] = v131;
              v185[1] = 0u;
              v185[0] = v128;
              memset(&v185[5], 0, 96);
              v185[4] = v134;
              v185[3] = 0x80000001B6F4A4A0;
              uint64_t v46 = swift_allocObject();
              *(_OWORD *)(v46 + 16) = xmmword_1B6E76B30;
              *(_OWORD *)(v46 + 32) = xmmword_1B6EA9A30;
              *(unsigned char *)(v46 + 48) = 0;
              *(void *)(v46 + 64) = v83;
              *(_OWORD *)(v46 + 72) = 0u;
              *(_OWORD *)(v46 + 88) = 0u;
              *(_OWORD *)(v46 + 104) = 0u;
              *(void *)(v46 + 120) = 0;
              *(unsigned char *)(v46 + 128) = 13;
              *(_OWORD *)(v46 + 144) = xmmword_1B6EA9A40;
              *(unsigned char *)(v46 + 160) = 0;
              *(void *)(v46 + 176) = 1;
              *(_OWORD *)(v46 + 184) = 0u;
              *(_OWORD *)(v46 + 200) = 0u;
              *(_OWORD *)(v46 + 216) = 0u;
              *(void *)(v46 + 232) = 0;
              *(unsigned char *)(v46 + 240) = 13;
              sub_1B62D5ED4((uint64_t *)v185, &v93, 0, 0, v46, (uint64_t)v186, 3, (uint64_t)v188, (uint64_t)&v178, 1, 1);
              sub_1B638A224((uint64_t *)&v128);
              swift_retain();
              unint64_t v47 = sub_1B638A310((uint64_t)&v178, 0);
              v49 = v48;
              uint64_t v84 = 0;
              if (v47 >= 3)
              {
                unint64_t v47 = swift_unknownObjectRetain();
                uint64_t v84 = v47;
              }
              sub_1B630B7D8(v47, v49);
              swift_release();
              if (v23)
              {
                swift_unknownObjectRelease();
                swift_unknownObjectRelease();
                swift_unknownObjectRelease();
LABEL_56:
                sub_1B638CE7C(&v178);
                sub_1B638CE7C(v177);
                sub_1B638CE7C(v176);
                swift_retain();
                v70 = (void *)sub_1B62963B0(0x4D545F4D4F4F4C42, 0xE900000000000050);
                if (v70)
                {
                  sub_1B628A1EC(v70);
                  swift_unknownObjectRelease();
                  swift_release();
                  swift_release();
                  swift_unknownObjectRelease();
                  swift_unknownObjectRelease();
                  swift_unknownObjectRelease();
                  return;
                }
                if (qword_1EB9852D0 != -1) {
                  swift_once();
                }
                v89[0] = 0;
                v89[1] = 0xE000000000000000;
                swift_retain();
                sub_1B6E328C8();
                swift_bridgeObjectRelease();
                int v71 = sub_1B6E32148();
                if (qword_1EB9854F8 != -1) {
                  swift_once();
                }
                v89[0] = 0;
                swift_retain();
                sub_1B6B33E34(v71, v89, 0xD00000000000001ELL, 0x80000001B6F4A540);
                swift_unknownObjectRelease();
                swift_release();
                swift_release();
                swift_unknownObjectRelease();
                swift_unknownObjectRelease();
                swift_release();
                goto LABEL_29;
              }
              if (v79 && v81 && v84)
              {
                v50 = *(void **)(v9 + 368);
                swift_unknownObjectRetain();
                swift_unknownObjectRetain();
                swift_unknownObjectRetain();
                if (v50)
                {
                  swift_unknownObjectRetain();
                  v51 = (void *)sub_1B6E31768();
                  objc_msgSend(v50, sel_pushDebugGroup_, v51);

                  swift_unknownObjectRelease();
                }
                uint64_t v52 = swift_unknownObjectRetain();
                v53 = sub_1B633483C(v52, 2, 0, 2, 0, 0);
                swift_unknownObjectRelease();
                sub_1B6388754(0x6C6F687365726854, 0xE900000000000064, v53);
                uint64_t v54 = sub_1B6388ED8(0);
                if (v54)
                {
                  v55 = (void *)v54;
                  swift_unknownObjectRetain();
                  sub_1B638963C((uint64_t)v90);
                  swift_getObjectType();
                  objc_msgSend(v55, sel_setRenderPipelineState_, v79);
                  objc_msgSend(v55, sel_setFragmentTexture_atIndex_, v72, 0);
                  *(void *)v92 = v10;
                  objc_msgSend(v55, sel_setFragmentBytes_length_atIndex_, v92, 8, 0);
                  sub_1B6389C1C(1);
                  sub_1B6388C28();

                  swift_unknownObjectRelease();
                }
                else
                {
                }
                for (uint64_t i = 1; i != v86; ++i)
                {
                  swift_unknownObjectRetain_n();
                  id v58 = (id)sub_1B6388608();
                  if (!v58) {
                    id v58 = objc_msgSend(objc_allocWithZone(MEMORY[0x1E4F352E0]), sel_init);
                  }
                  v59 = v58;
                  sub_1B6388228();
                  id v60 = objc_msgSend(v59, sel_colorAttachments);
                  id v61 = objc_msgSend(v60, sel_objectAtIndexedSubscript_, 0);

                  objc_msgSend(v61, sel_setTexture_, v88);
                  objc_msgSend(v61, sel_setLoadAction_, 2);
                  objc_msgSend(v61, sel_setStoreAction_, 1);
                  objc_msgSend(v61, sel_setClearColor_, 0.0, 0.0, 0.0, 0.0);
                  objc_msgSend(v61, sel_setLevel_, i);
                  swift_unknownObjectRelease_n();

                  sub_1B6388754(0x706D61536E776F44, 0xEE0072756C42656CLL, v59);
                  uint64_t v62 = sub_1B6388ED8(0);
                  if (v62)
                  {
                    v57 = (void *)v62;
                    swift_unknownObjectRetain();
                    sub_1B638963C((uint64_t)v91);
                    swift_getObjectType();
                    objc_msgSend(v57, sel_setRenderPipelineState_, v81);
                    objc_msgSend(v57, sel_setFragmentTexture_atIndex_, v88, 0);
                    v92[0] = (float)(i - 1);
                    objc_msgSend(v57, sel_setFragmentBytes_length_atIndex_, v92, 4, 0);
                    sub_1B6389C1C(1);
                    sub_1B6388C28();

                    swift_unknownObjectRelease();
                  }
                  else
                  {
                  }
                }
                uint64_t v63 = v86 - 2;
                do
                {
                  swift_unknownObjectRetain_n();
                  id v64 = (id)sub_1B6388608();
                  if (!v64) {
                    id v64 = objc_msgSend(objc_allocWithZone(MEMORY[0x1E4F352E0]), sel_init);
                  }
                  v65 = v64;
                  sub_1B6388228();
                  id v66 = objc_msgSend(v65, sel_colorAttachments);
                  id v67 = objc_msgSend(v66, sel_objectAtIndexedSubscript_, 0);

                  objc_msgSend(v67, sel_setTexture_, v33);
                  objc_msgSend(v67, sel_setLoadAction_, 2);
                  objc_msgSend(v67, sel_setStoreAction_, 1);
                  objc_msgSend(v67, sel_setClearColor_, 0.0, 0.0, 0.0, 0.0);
                  objc_msgSend(v67, sel_setLevel_, v63);
                  swift_unknownObjectRelease_n();

                  sub_1B6388754(0x656C706D61537055, 0xEC00000072756C42, v65);
                  uint64_t v68 = sub_1B6388ED8(0);
                  if (v68)
                  {
                    v69 = (void *)v68;
                    swift_unknownObjectRetain();
                    sub_1B638963C((uint64_t)v92);
                    sub_1B638A0FC(v69, v84, v63, v86, v88, (uint64_t)v33, (uint64_t)v154);
                    sub_1B6388C28();

                    swift_unknownObjectRelease();
                  }
                  else
                  {
                  }
                  --v63;
                }
                while (v63 != -1);
                if (*(void *)(v9 + 368))
                {
                  objc_msgSend((id)swift_unknownObjectRetain(), sel_popDebugGroup);
                  swift_unknownObjectRelease();
                }
                swift_unknownObjectRelease_n();
                swift_unknownObjectRelease_n();
                swift_unknownObjectRelease_n();
                goto LABEL_56;
              }
              while (1)
              {
LABEL_63:
                sub_1B6E32BE8();
                __break(1u);
              }
            }
            swift_unknownObjectRelease();
LABEL_29:
            swift_release();
            return;
          }
          sub_1B62C7BF4((uint64_t)v174);
        }
        swift_release();
        sub_1B62C7BF4((uint64_t)v174);
        swift_release();
        swift_retain();
        v31 = sub_1B6330614();
        swift_release();
        unsigned int v32 = *(unsigned __int8 *)(v9 + 600);
        goto LABEL_13;
      }
    }
  }
}

uint64_t MurmurHash2(unsigned __int8 *a1, int a2, int a3)
{
  unsigned int v3 = a3 ^ a2;
  if (a2 < 4)
  {
    int v5 = a2;
  }
  else
  {
    do
    {
      int v4 = *(_DWORD *)a1;
      a1 += 4;
      unsigned int v3 = (1540483477 * ((1540483477 * v4) ^ ((1540483477 * v4) >> 24))) ^ (1540483477 * v3);
      int v5 = a2 - 4;
      BOOL v6 = a2 > 7;
      a2 -= 4;
    }
    while (v6);
  }
  switch(v5)
  {
    case 1:
      goto LABEL_10;
    case 2:
LABEL_9:
      v3 ^= a1[1] << 8;
LABEL_10:
      unsigned int v3 = 1540483477 * (v3 ^ *a1);
      return (1540483477 * (v3 ^ (v3 >> 13))) ^ ((1540483477 * (v3 ^ (v3 >> 13))) >> 15);
    case 3:
      v3 ^= a1[2] << 16;
      goto LABEL_9;
  }
  return (1540483477 * (v3 ^ (v3 >> 13))) ^ ((1540483477 * (v3 ^ (v3 >> 13))) >> 15);
}

uint64_t ecs_stack_allocator_push_snapshot(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  uint64_t v2 = *(unsigned int *)(result + 536);
  uint64_t v3 = result + 16 * v2;
  *(void *)(v3 + 24) = *(void *)result;
  *(_DWORD *)(v3 + 32) = v1;
  *(_DWORD *)(result + 536) = v2 + 1;
  return result;
}

uint64_t ecs_stack_allocator_pop_snapshot(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 536);
  if (v1)
  {
    unsigned int v2 = v1 - 1;
    *(_DWORD *)(result + 536) = v2;
    *(void *)(result + 16) = *(unsigned int *)(result + 16 * v2 + 32);
  }
  return result;
}

void *ecs_stack_allocator_allocate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = (a3 + *(void *)(a1 + 16) - 1) & -a3;
  uint64_t v5 = v4 + a2;
  if ((unint64_t)(v4 + a2) <= *(void *)(a1 + 8))
  {
    *(void *)(a1 + 16) = v5;
    return (void *)(*(void *)a1 + v4);
  }
  else
  {
    unint64_t v7 = (v5 - 1) | ((unint64_t)(v5 - 1) >> 1) | (((v5 - 1) | ((unint64_t)(v5 - 1) >> 1)) >> 2);
    unint64_t v8 = v7 | (v7 >> 4) | ((v7 | (v7 >> 4)) >> 8);
    unint64_t v9 = v8 | (v8 >> 16);
    unint64_t v10 = v9 + 1;
    uint64_t v11 = malloc_type_aligned_alloc(0x20uLL, (v9 & 0xFFFFFFFFFFFFFFE0) + 64, 0x61E8937BuLL);
    *uint64_t v11 = *(void *)a1;
    result = v11 + 4;
    *(void *)a1 = result;
    *(void *)(a1 + 8) = v10;
    *(void *)(a1 + 16) = a2;
    uint64_t v13 = *(unsigned int *)(a1 + 536);
    if (v13)
    {
      double v14 = (_DWORD *)(a1 + 32);
      do
      {
        *((void *)v14 - 1) = result;
        *double v14 = 0;
        v14 += 4;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

void *ecs_stack_allocator_deallocate(void *result, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = result[2];
  if (v3 >= a3 && ((*result + v3 - a3) ^ a2) <= 7) {
    result[2] = a2 - *result;
  }
  return result;
}

void memset_pattern16_nocache(void *__b, const void *__pattern16, size_t __len)
{
  if ((__b & 0xF) != 0)
  {
    memset_pattern16(__b, __pattern16, __len);
  }
  else if (__len >= 0x10)
  {
    uint64_t v3 = 0;
    long long v4 = *(_OWORD *)__pattern16;
    do
      *((_OWORD *)__b + v3++) = v4;
    while (__len >> 4 > v3);
  }
}

uint64_t memset_pattern8_nocache(uint64_t result, uint64_t *a2, unint64_t a3)
{
  if (a3 >= 8)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *a2;
    do
      *(void *)(result + 8 * v3++) = v4;
    while (a3 >> 3 > v3);
  }
  return result;
}

double vfx_counters_update(uint64_t a1, unsigned int a2, double result)
{
  if (a1)
  {
    int v3 = *(_DWORD *)(a1 + 112) % *(_DWORD *)(a1 + 116) + *(_DWORD *)(a1 + 116) * a2;
    uint64_t v4 = *(void *)(a1 + 88);
    result = *(double *)(v4 + 8 * v3) + result;
    *(double *)(v4 + 8 * v3) = result;
    uint64_t v5 = *(void *)(a1 + 40) + 24 * a2;
    ++*(_DWORD *)(v5 + 8);
  }
  return result;
}

void *vfx_allocate_memory_entry@<X0>(size_t a1@<X0>, size_t a2@<X1>, task_t a3@<W2>, uint64_t a4@<X8>)
{
  mach_vm_address_t address = 0;
  memory_object_size_t size = (a1 + a2 - 1) & -(uint64_t)a2;
  *(void *)object_handle = 0;
  unint64_t v8 = (ipc_space_t *)MEMORY[0x1E4F14960];
  if (!mach_make_memory_entry_64(*MEMORY[0x1E4F14960], &size, 0, 401411, object_handle, 0))
  {
    if (mach_vm_map(*v8, &address, size, 0, 1442840579, object_handle[0], 0, 0, 3, 3, 1u))
    {
      mach_vm_address_t v9 = address;
    }
    else
    {
      if (a3 - 1 <= 0xFFFFFFFD)
      {
        if (mach_memory_entry_ownership(object_handle[0], a3, 4, 0))
        {
          sub_1B6B34168(16);
        }
        else
        {
          mach_port_deallocate(*v8, object_handle[0]);
          object_handle[0] = 0;
        }
      }
      result = (void *)MEMORY[0x1BA9B8880](*v8, address, 0, &object_handle[1]);
      mach_vm_address_t v9 = address;
      if (!result)
      {
        char v11 = 0;
        memory_object_size_t v12 = size;
        *(void *)a4 = address;
        *(void *)(a4 + 8) = v12;
        *(_DWORD *)(a4 + 16) = object_handle[0];
        goto LABEL_15;
      }
    }
    if (v9) {
      mach_vm_deallocate(*v8, v9, size);
    }
  }
  if (object_handle[0]) {
    mach_port_deallocate(*v8, object_handle[0]);
  }
  result = malloc_type_aligned_alloc(a2, a1, 0xB6DE8191uLL);
  if (!result) {
    abort();
  }
  *(void *)a4 = result;
  *(void *)(a4 + 8) = a1;
  char v11 = 1;
  *(_DWORD *)(a4 + 16) = 0;
LABEL_15:
  *(unsigned char *)(a4 + 20) = v11;
  return result;
}

uint64_t memset_pattern4_nocache(uint64_t result, int *a2, unint64_t a3)
{
  if (a3 >= 4)
  {
    uint64_t v3 = 0;
    int v4 = *a2;
    do
      *(_DWORD *)(result + 4 * v3++) = v4;
    while (a3 >> 2 > v3);
  }
  return result;
}

uint64_t vfx_script_string_copy(void *a1, void *a2)
{
  uint64_t v2 = a2[1];
  *a1 = *a2;
  a1[1] = v2;
  swift_bridgeObjectRetain();

  return swift_bridgeObjectRelease();
}

uint64_t vfx_swift_deimmortalize(uint64_t result)
{
  *(void *)(result + 8) = 0x100000003;
  return result;
}

double RGTextureDescriptorMakeDefault@<D0>(uint64_t a1@<X8>)
{
  *(void *)a1 = 0x1000100000000;
  *(_WORD *)(a1 + 8) = 257;
  *(unsigned char *)(a1 + 10) = 1;
  *(_OWORD *)(a1 + 16) = xmmword_1B6E95940;
  *(void *)(a1 + 32) = 2;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 72) = 84148994;
  return result;
}

void RGTextureDescriptorFillMTLDescriptor(unsigned __int16 *a1, void *a2)
{
  id v3 = a2;
  if (*a1 <= 1u) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = *a1;
  }
  id v42 = v3;
  objc_msgSend_setWidth_(v3, v4, v6, v5);
  unint64_t v10 = *((void *)a1 + 3);
  if (v10 - 5 > 1)
  {
    if (v10 < 2 || a1[1] <= 1u) {
      objc_msgSend_setHeight_(v42, v7, 1, v9);
    }
    else {
      objc_msgSend_setHeight_(v42, v7, a1[1], v9);
    }
  }
  else
  {
    uint64_t v11 = objc_msgSend_width(v42, v7, v8, v9);
    objc_msgSend_setHeight_(v42, v12, v11, v13);
  }
  if (*((void *)a1 + 3) == 7 && a1[2] > 1u) {
    objc_msgSend_setDepth_(v42, v14, a1[2], v15);
  }
  else {
    objc_msgSend_setDepth_(v42, v14, 1, v15);
  }
  if (*((unsigned __int8 *)a1 + 8) <= 1u) {
    objc_msgSend_setMipmapLevelCount_(v42, v16, 1, v17);
  }
  else {
    objc_msgSend_setMipmapLevelCount_(v42, v16, *((unsigned __int8 *)a1 + 8), v17);
  }
  uint64_t v20 = *((void *)a1 + 3);
  if ((v20 == 8 || v20 == 4) && *((unsigned __int8 *)a1 + 9) > 1u) {
    objc_msgSend_setSampleCount_(v42, v18, *((unsigned __int8 *)a1 + 9), v19);
  }
  else {
    objc_msgSend_setSampleCount_(v42, v18, 1, v19);
  }
  unint64_t v23 = *((void *)a1 + 3);
  if (v23 <= 8 && ((1 << v23) & 0x14A) != 0 && a1[3] > 1u) {
    objc_msgSend_setArrayLength_(v42, v21, a1[3], v22);
  }
  else {
    objc_msgSend_setArrayLength_(v42, v21, 1, v22);
  }
  objc_msgSend_setTextureType_(v42, v24, *((void *)a1 + 3), v25);
  objc_msgSend_setPixelFormat_(v42, v26, *((void *)a1 + 2), v27);
  objc_msgSend_setCpuCacheMode_(v42, v28, *((void *)a1 + 6), v29);
  objc_msgSend_setStorageMode_(v42, v30, *((void *)a1 + 4), v31);
  objc_msgSend_setHazardTrackingMode_(v42, v32, *((void *)a1 + 8), v33);
  objc_msgSend_setUsage_(v42, v34, *((void *)a1 + 5), v35);
  objc_msgSend_setAllowGPUOptimizedContents_(v42, v36, *((unsigned __int8 *)a1 + 10), v37);
  objc_msgSend_setCompressionType_(v42, v38, *((void *)a1 + 7), v39);
  objc_msgSend_setSwizzle_(v42, v40, *((unsigned int *)a1 + 18), v41);
}

void sub_1B63880E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1B6388108(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 4176) & 0x100) != 0)
  {
    uint64_t v2 = 0;
    uint64_t v3 = a1 + 1344;
    do
    {
      int v4 = *(void **)(v3 + v2);
      if (v4) {

      }
      v2 += 8;
    }
    while (v2 != 1024);
    uint64_t v5 = 0;
    uint64_t v6 = a1 + 2992;
    do
    {
      unint64_t v7 = *(void **)(v6 + v5);
      if (v7) {

      }
      v5 += 8;
    }
    while (v5 != 1024);
  }
}

void vfx_uniform_grid_create()
{
}

uint64_t CFX::RG::ResourceIdentifier::ResourceIdentifier(uint64_t this, __int16 a2, __int16 a3, int a4)
{
  *(_WORD *)this = a2;
  *(_WORD *)(this + 2) = a3;
  *(_DWORD *)(this + 4) = a4;
  return this;
}

{
  *(_WORD *)this = a2;
  *(_WORD *)(this + 2) = a3;
  *(_DWORD *)(this + 4) = a4;
  return this;
}

uint64_t vfx_uniform_grid_destroy(uint64_t result)
{
  if (result)
  {
    sub_1B6390264(result);
    JUMPOUT(0x1BA9B6D80);
  }
  return result;
}

id sub_1B6388228()
{
  uint64_t v1 = 0;
  do
  {
    uint64_t v2 = v1 + 1;
    id v3 = objc_msgSend(v0, sel_colorAttachments);
    id v4 = objc_msgSend(v3, sel_objectAtIndexedSubscript_, v1);

    objc_msgSend(v4, sel_setTexture_, 0);
    objc_msgSend(v4, sel_setLoadAction_, 2);
    objc_msgSend(v4, sel_setStoreAction_, 0);
    objc_msgSend(v4, sel_setStoreActionOptions_, 0);
    objc_msgSend(v4, sel_setLevel_, 0);
    objc_msgSend(v4, sel_setSlice_, 0);
    objc_msgSend(v4, sel_setDepthPlane_, 0);
    objc_msgSend(v4, sel_setResolveTexture_, 0);
    objc_msgSend(v4, sel_setResolveLevel_, 0);
    objc_msgSend(v4, sel_setResolveDepthPlane_, 0);
    objc_msgSend(v4, sel_setResolveSlice_, 0);
    objc_msgSend(v4, sel_setLoadAction_, 0);
    objc_msgSend(v4, sel_setStoreAction_, 1);
    objc_msgSend(v4, sel_setClearColor_, 0.0, 0.0, 0.0, 1.0);

    uint64_t v1 = v2;
  }
  while (v2 != 8);
  id v5 = objc_msgSend(v0, sel_depthAttachment);
  objc_msgSend(v5, sel_setTexture_, 0);
  objc_msgSend(v5, sel_setLoadAction_, 2);
  objc_msgSend(v5, sel_setStoreAction_, 0);
  objc_msgSend(v5, sel_setStoreActionOptions_, 0);
  objc_msgSend(v5, sel_setLevel_, 0);
  objc_msgSend(v5, sel_setSlice_, 0);
  objc_msgSend(v5, sel_setDepthPlane_, 0);
  objc_msgSend(v5, sel_setResolveTexture_, 0);
  objc_msgSend(v5, sel_setResolveLevel_, 0);
  objc_msgSend(v5, sel_setResolveDepthPlane_, 0);
  objc_msgSend(v5, sel_setResolveSlice_, 0);
  objc_msgSend(v5, sel_setDepthResolveFilter_, 0);
  objc_msgSend(v5, sel_setClearDepth_, 1.0);

  id v6 = objc_msgSend(v0, sel_stencilAttachment);
  objc_msgSend(v6, sel_setTexture_, 0);
  objc_msgSend(v6, sel_setLoadAction_, 2);
  objc_msgSend(v6, sel_setStoreAction_, 0);
  objc_msgSend(v6, sel_setStoreActionOptions_, 0);
  objc_msgSend(v6, sel_setLevel_, 0);
  objc_msgSend(v6, sel_setSlice_, 0);
  objc_msgSend(v6, sel_setDepthPlane_, 0);
  objc_msgSend(v6, sel_setResolveTexture_, 0);
  objc_msgSend(v6, sel_setResolveLevel_, 0);
  objc_msgSend(v6, sel_setResolveDepthPlane_, 0);
  objc_msgSend(v6, sel_setResolveSlice_, 0);
  objc_msgSend(v6, sel_setStencilResolveFilter_, 0);
  objc_msgSend(v6, sel_setClearStencil_, 0);

  return objc_msgSend(v0, sel_setVisibilityResultBuffer_, 0);
}

uint64_t sub_1B6388608()
{
  if (!(*v0 >> 62))
  {
    if (*(void *)((*v0 & 0xFFFFFFFFFFFFFF8) + 0x10)) {
      goto LABEL_3;
    }
    return 0;
  }
  swift_bridgeObjectRetain();
  uint64_t v3 = sub_1B6E32C18();
  swift_bridgeObjectRelease();
  if (!v3) {
    return 0;
  }
LABEL_3:
  uint64_t result = sub_1B63886DC(sub_1B6C167C0);
  if (!result)
  {
    if (*v0 >> 62)
    {
      swift_bridgeObjectRetain();
      uint64_t v2 = sub_1B6E32C18();
      swift_bridgeObjectRelease();
    }
    else
    {
      uint64_t v2 = *(void *)((*v0 & 0xFFFFFFFFFFFFFF8) + 0x10);
    }
    return sub_1B69F0184(v2 - 1);
  }
  return result;
}

uint64_t sub_1B63886DC(uint64_t (*a1)(uint64_t))
{
  uint64_t v3 = *v1;
  int isUniquelyReferenced_nonNull_bridgeObject = swift_isUniquelyReferenced_nonNull_bridgeObject();
  *uint64_t v1 = v3;
  if (!isUniquelyReferenced_nonNull_bridgeObject || v3 < 0 || (v3 & 0x4000000000000000) != 0)
  {
    uint64_t v3 = a1(v3);
    *uint64_t v1 = v3;
  }
  uint64_t v5 = v3 & 0xFFFFFFFFFFFFFF8;
  uint64_t v6 = *(void *)((v3 & 0xFFFFFFFFFFFFFF8) + 0x10) - 1;
  uint64_t v7 = *(void *)((v3 & 0xFFFFFFFFFFFFFF8) + 8 * v6 + 0x20);
  *(void *)(v5 + 16) = v6;
  sub_1B6E31C48();
  return v7;
}

uint64_t sub_1B6388754(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = v3;
  uint64_t v6 = *(void **)(v3 + 392);
  if (v6 && (id v7 = v6, v8 = sub_1B638CFAC(a3), v7, v8))
  {
    id v9 = a3;
    MEMORY[0x1BA9B3870]();
    if (*(void *)((*(void *)(v4 + 400) & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(void *)((*(void *)(v4 + 400) & 0xFFFFFFFFFFFFFF8)
                                                                                        + 0x18) >> 1)
      sub_1B6E31C78();
    sub_1B6E31CC8();
    return sub_1B6E31C48();
  }
  else
  {
    sub_1B6388C28();
    uint64_t v11 = *(void **)(v4 + 392);
    *(void *)(v4 + 392) = a3;
    id v12 = a3;

    **(void **)(v4 + 496) = 0;
    swift_unknownObjectRelease();
    id v13 = objc_msgSend((id)sub_1B6388D70(), sel_renderCommandEncoderWithDescriptor_, v12);
    if (v13)
    {
      double v14 = v13;
      swift_getObjectType();
      uint64_t v15 = (void *)sub_1B6E31768();
      objc_msgSend(v14, sel_setLabel_, v15);

      *(void *)(v4 + 376) = v14;
      swift_unknownObjectRetain();
      swift_unknownObjectRelease();
      char v16 = *(void **)(v4 + 496);
      *char v16 = objc_msgSend(objc_allocWithZone((Class)type metadata accessor for RenderCommandEncoder()), sel_initWithEncoder_, v14);
      swift_unknownObjectRelease();
      sub_1B6388B3C(v4 + 624, (uint64_t)v33);
      sub_1B6388B3C((uint64_t)v33, (uint64_t)v34);
      if (sub_1B6388C10(v34) == 1)
      {
        uint64_t v17 = 0;
      }
      else
      {
        uint64_t v18 = *(void *)(v4 + 632);
        uint64_t ObjectType = swift_getObjectType();
        uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t))(v18 + 160);
        swift_unknownObjectRetain();
        uint64_t v17 = (void *)v20(ObjectType, v18);
        swift_unknownObjectRelease();
      }
      if (**(void **)(v4 + 496))
      {
        swift_getObjectType();
        int v21 = *(_DWORD *)(v4 + 24) & 1;
        swift_unknownObjectRetain();
        sub_1B6389180(v17, v21);
        swift_unknownObjectRelease();
      }
      *(double *)v22.i64 = sub_1B638904C();
      float64x2_t v24 = vcvtq_f64_f32(*(float32x2_t *)v22.f32);
      float64x2_t v25 = vcvt_hight_f64_f32(v22);
      if ((_BYTE)v17)
      {
        float64x2_t v30 = v24;
        float64x2_t v31 = v25;
        int8x16_t v26 = (int8x16_t)xmmword_1B6E4F360;
        if (v17 == 1) {
          int8x16_t v26 = (int8x16_t)xmmword_1B6E87200;
        }
        float32x4_t v28 = (float32x4_t)v26;
        v26.i32[0] = 1;
        v23.i32[0] = (int)v17;
        float32x4_t v29 = (float32x4_t)vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(v23, v26), 0), (int8x16_t)xmmword_1B6E87210, (int8x16_t)xmmword_1B6E4F360);
        sub_1B638BF80(0, (unint64_t *)&unk_1E9DD0C80, (uint64_t (*)(uint64_t))type metadata accessor for MTLViewport, MEMORY[0x1E4FBBE00]);
        uint64_t v27 = swift_allocObject();
        *(_OWORD *)(v27 + 16) = xmmword_1B6E76B30;
        *(float64x2_t *)(v27 + 32) = vaddq_f64(vmulq_f64(v31, vcvtq_f64_f32(*(float32x2_t *)v28.f32)), v30);
        *(float64x2_t *)(v27 + 48) = vmulq_f64(v31, vcvt_hight_f64_f32(v28));
        *(_OWORD *)(v27 + 64) = xmmword_1B6E500C0;
        *(float64x2_t *)(v27 + 80) = vaddq_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v29.f32), v31), v30);
        *(float64x2_t *)(v27 + 96) = vmulq_f64(vcvt_hight_f64_f32(v29), v31);
        *(_OWORD *)(v27 + 112) = xmmword_1B6E500C0;
        sub_1B6E32318();
        swift_unknownObjectRelease();
        swift_bridgeObjectRelease();
      }
      else
      {
        v32[0] = v24;
        v32[1] = v25;
        v32[2] = xmmword_1B6E500C0;
        objc_msgSend(v14, sel_setViewport_, v32);
        swift_unknownObjectRelease();
      }
      return swift_unknownObjectRelease();
    }
    else
    {
      uint64_t result = sub_1B6E32BE8();
      __break(1u);
    }
  }
  return result;
}

uint64_t sub_1B6388B3C(uint64_t a1, uint64_t a2)
{
  sub_1B6388BC4(0, (unint64_t *)&unk_1EB9852B0, (uint64_t)&type metadata for Renderer.CurrentRenderContext, MEMORY[0x1E4FBB718]);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

void sub_1B6388BC4(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t (*a4)(void, uint64_t))
{
  if (!*a2)
  {
    unint64_t v5 = a4(0, a3);
    if (!v6) {
      atomic_store(v5, a2);
    }
  }
}

uint64_t sub_1B6388C10(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v1) = -1;
  }
  return (v1 + 1);
}

void sub_1B6388C28()
{
  if (!*(void *)(v0 + 376)) {
    goto LABEL_10;
  }
  if (swift_dynamicCastObjCProtocolConditional())
  {
    if (!**(void **)(v0 + 496)) {
      goto LABEL_8;
    }
    objc_msgSend((id)swift_unknownObjectRetain(), sel_endEncoding);
    **(void **)(v0 + 496) = 0;
    swift_unknownObjectRelease();
  }
  else
  {
    if (!swift_dynamicCastObjCProtocolConditional()) {
      goto LABEL_8;
    }
    **(void **)(v0 + 496) = 0;
  }
  swift_unknownObjectRelease();
LABEL_8:
  uint64_t v1 = *(void **)(v0 + 376);
  if (v1)
  {
    objc_msgSend(v1, sel_endEncoding);
    *(void *)(v0 + 376) = 0;
    swift_unknownObjectRelease();
  }
LABEL_10:
  uint64_t v2 = *(void **)(v0 + 392);
  if (v2)
  {
    id v3 = v2;
    MEMORY[0x1BA9B3870](v3, v4);
    if (*(void *)((*(void *)(v0 + 400) & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(void *)((*(void *)(v0 + 400) & 0xFFFFFFFFFFFFFF8)
                                                                                        + 0x18) >> 1)
      sub_1B6E31C78();
    sub_1B6E31CC8();
    sub_1B6E31C48();

    unint64_t v5 = *(void **)(v0 + 392);
    *(void *)(v0 + 392) = 0;
  }
}

uint64_t sub_1B6388D70()
{
  if (*(void *)(v0 + 368))
  {
    uint64_t v1 = *(void **)(v0 + 368);
LABEL_5:
    swift_unknownObjectRetain();
    return (uint64_t)v1;
  }
  id v2 = objc_msgSend(*(id *)(v0 + 312), sel_commandBuffer);
  if (v2)
  {
    uint64_t v1 = v2;
    sub_1B6E328F8();
    id v3 = (void *)sub_1B6E31768();
    swift_bridgeObjectRelease();
    objc_msgSend(v1, sel_setLabel_, v3);

    sub_1B637AE10(v1);
    *(void *)(v0 + 368) = v1;
    swift_unknownObjectRetain();
    swift_unknownObjectRelease();
    goto LABEL_5;
  }
  sub_1B6E328C8();
  swift_bridgeObjectRelease();
  sub_1B6E328F8();
  sub_1B6E31948();
  swift_bridgeObjectRelease();
  uint64_t result = sub_1B6E32BE8();
  __break(1u);
  return result;
}

uint64_t sub_1B6388ED0()
{
  return *(unsigned __int8 *)(v0 + 89);
}

uint64_t sub_1B6388ED8(uint64_t a1)
{
  uint64_t v2 = v1;
  if (!*(void *)(*(void *)(v1 + 496) + 8 * a1))
  {
    if (*(void *)(v1 + 376))
    {
      uint64_t v4 = swift_dynamicCastObjCProtocolConditional();
      if (v4)
      {
        unint64_t v5 = (void *)v4;
        swift_unknownObjectRetain();
        id v6 = objc_msgSend(v5, sel_renderCommandEncoder);
        sub_1B6E33098();
        sub_1B6E31948();
        swift_bridgeObjectRelease();
        sub_1B6E31948();
        id v7 = (void *)sub_1B6E31768();
        swift_bridgeObjectRelease();
        objc_msgSend(v6, sel_setLabel_, v7, a1, 0x646F636E45627573, 0xEB000000005B7265, &unk_1F108FFD8);

        uint64_t v8 = *(void *)(v2 + 496);
        *(void *)(v8 + 8 * a1) = objc_msgSend(objc_allocWithZone((Class)type metadata accessor for RenderCommandEncoder()), sel_initWithEncoder_, v6);
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
      }
    }
  }
  return *(void *)(*(void *)(v2 + 496) + 8 * a1);
}

double sub_1B638904C()
{
  id v1 = objc_msgSend(v0, sel_colorAttachments);
  id v2 = objc_msgSend(v1, sel_objectAtIndexedSubscript_, 0);

  if (objc_msgSend(v2, sel_texture))
  {
    uint64_t v3 = sub_1B6389254((uint64_t)objc_msgSend(v2, sel_level));
    uint64_t v5 = v4;

    swift_unknownObjectRelease();
    v6.i64[0] = v3;
  }
  else
  {

    id v7 = objc_msgSend(v0, sel_depthAttachment);
    if (!objc_msgSend(v7, sel_texture))
    {

      v6.i64[0] = 0;
      return *(double *)v6.i64;
    }
    uint64_t v8 = sub_1B6389254((uint64_t)objc_msgSend(v7, sel_level));
    uint64_t v5 = v9;

    swift_unknownObjectRelease();
    v6.i64[0] = v8;
  }
  v6.i64[1] = v5;
  v6.i64[0] = vcvt_hight_f32_f64(0, vcvtq_f64_s64(v6)).u64[0];
  return *(double *)v6.i64;
}

id sub_1B6389180(id result, char a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  if ((_BYTE)result)
  {
    if (result == 1) {
      long long v3 = xmmword_1B6E4F270;
    }
    else {
      long long v3 = xmmword_1B6E50D20;
    }
    long long v4 = v3;
    return objc_msgSend(v2, sel_setVertexAmplificationCount_viewMappings_, 2, &v4);
  }
  else if (a2)
  {
    return objc_msgSend(v2, sel_setVertexAmplificationCount_viewMappings_, 1, 0);
  }
  return result;
}

uint64_t sub_1B6389254(uint64_t a1)
{
  unint64_t v3 = (unint64_t)objc_msgSend(v1, sel_textureType);
  if (v3 <= 8)
  {
    if (((1 << v3) & 0x17C) != 0)
    {
      uint64_t v4 = (uint64_t)objc_msgSend(v1, sel_width);
      if (a1 < -64)
      {
LABEL_4:
        objc_msgSend(v1, sel_height);
        uint64_t v5 = 1;
        uint64_t v6 = 1;
LABEL_25:
        uint64_t v8 = v5;
LABEL_39:
        uint64_t v17 = 1;
LABEL_40:
        sub_1B638955C(v8, v6, v17, &v29);
        return v29;
      }
      if (a1 <= 64)
      {
        if (a1 < 0)
        {
          if ((unint64_t)a1 <= 0xFFFFFFFFFFFFFFC0) {
            goto LABEL_4;
          }
          uint64_t v9 = v4 << -(char)a1;
        }
        else
        {
          uint64_t v9 = v4 >> a1;
          if ((unint64_t)a1 >= 0x40) {
            uint64_t v9 = v4 >> 63;
          }
        }
      }
      else
      {
        uint64_t v9 = v4 >> 63;
      }
      if (v9 <= 1) {
        uint64_t v5 = 1;
      }
      else {
        uint64_t v5 = v9;
      }
      uint64_t v10 = (uint64_t)objc_msgSend(v1, sel_height);
      uint64_t v11 = v10 >> 63;
      uint64_t v12 = v10 << -(char)a1;
      uint64_t v13 = v10 >> a1;
      if ((unint64_t)a1 >= 0x40) {
        uint64_t v13 = v10 >> 63;
      }
      if (a1 >= 0) {
        uint64_t v12 = v13;
      }
      if (a1 <= 64) {
        uint64_t v11 = v12;
      }
      if (v11 <= 1) {
        uint64_t v6 = 1;
      }
      else {
        uint64_t v6 = v11;
      }
      goto LABEL_25;
    }
    if (((1 << v3) & 3) != 0)
    {
      uint64_t v7 = (uint64_t)objc_msgSend(v1, sel_width);
      if (a1 < -64)
      {
LABEL_7:
        uint64_t v8 = 1;
LABEL_38:
        uint64_t v6 = 1;
        goto LABEL_39;
      }
      if (a1 <= 64)
      {
        if (a1 < 0)
        {
          if ((unint64_t)a1 <= 0xFFFFFFFFFFFFFFC0) {
            goto LABEL_7;
          }
          uint64_t v18 = v7 << -(char)a1;
        }
        else
        {
          uint64_t v18 = v7 >> a1;
          if ((unint64_t)a1 >= 0x40) {
            uint64_t v18 = v7 >> 63;
          }
        }
      }
      else
      {
        uint64_t v18 = v7 >> 63;
      }
      if (v18 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = v18;
      }
      goto LABEL_38;
    }
    uint64_t v14 = (uint64_t)objc_msgSend(v1, sel_width);
    if (a1 < -64) {
      goto LABEL_27;
    }
    if (a1 <= 64)
    {
      if (a1 < 0)
      {
        if ((unint64_t)a1 <= 0xFFFFFFFFFFFFFFC0)
        {
LABEL_27:
          objc_msgSend(v1, sel_height);
          objc_msgSend(v1, sel_depth);
          uint64_t v15 = 1;
          uint64_t v16 = 1;
          uint64_t v17 = 1;
LABEL_65:
          uint64_t v8 = v16;
          uint64_t v6 = v15;
          goto LABEL_40;
        }
        uint64_t v19 = v14 << -(char)a1;
      }
      else
      {
        uint64_t v19 = v14 >> a1;
        if ((unint64_t)a1 >= 0x40) {
          uint64_t v19 = v14 >> 63;
        }
      }
    }
    else
    {
      uint64_t v19 = v14 >> 63;
    }
    if (v19 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v19;
    }
    uint64_t v21 = (uint64_t)objc_msgSend(v1, sel_height);
    uint64_t v22 = v21 >> 63;
    uint64_t v23 = v21 << -(char)a1;
    uint64_t v24 = v21 >> a1;
    if ((unint64_t)a1 >= 0x40) {
      uint64_t v24 = v21 >> 63;
    }
    if (a1 >= 0) {
      uint64_t v23 = v24;
    }
    if (a1 <= 64) {
      uint64_t v22 = v23;
    }
    if (v22 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = v22;
    }
    uint64_t v25 = (uint64_t)objc_msgSend(v1, sel_depth);
    uint64_t v26 = v25 >> 63;
    uint64_t v27 = v25 << -(char)a1;
    uint64_t v28 = v25 >> a1;
    if ((unint64_t)a1 >= 0x40) {
      uint64_t v28 = v25 >> 63;
    }
    if (a1 >= 0) {
      uint64_t v27 = v28;
    }
    if (a1 <= 64) {
      uint64_t v26 = v27;
    }
    if (v26 <= 1) {
      uint64_t v17 = 1;
    }
    else {
      uint64_t v17 = v26;
    }
    goto LABEL_65;
  }
  uint64_t result = sub_1B6E32BE8();
  __break(1u);
  return result;
}

uint64_t sub_1B638955C@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = result;
  a4[1] = a2;
  a4[2] = a3;
  return result;
}

double sub_1B6389568@<D0>(uint64_t a1@<X8>)
{
  *(void *)&double result = 256;
  *(_OWORD *)a1 = xmmword_1B6EA0BD0;
  *(void *)(a1 + 16) = 1;
  return result;
}

uint64_t sub_1B6389580@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  *a3 = result;
  a3[1] = a2;
  a3[2] = 1;
  return result;
}

int64x2_t sub_1B6389590@<Q0>(int64x2_t *a1@<X8>)
{
  int64x2_t result = vdupq_n_s64(1uLL);
  *a1 = result;
  a1[1].i64[0] = 1;
  return result;
}

int64x2_t sub_1B63895A4@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = a1;
  int64x2_t result = vdupq_n_s64(1uLL);
  *(int64x2_t *)(a2 + 8) = result;
  return result;
}

double sub_1B63895B8@<D0>(uint64_t a1@<X8>)
{
  *(void *)&double result = 128;
  *(_OWORD *)a1 = xmmword_1B6EC0EE0;
  *(void *)(a1 + 16) = 1;
  return result;
}

uint64_t type metadata accessor for RenderCommandEncoder()
{
  return self;
}

double sub_1B638963C@<D0>(uint64_t a1@<X8>)
{
  id v2 = v1;
  id v4 = objc_msgSend(v1, sel_colorAttachments);
  id v5 = objc_msgSend(v4, sel_objectAtIndexedSubscript_, 0);

  id v6 = objc_msgSend(v5, sel_texture);
  if (!v6)
  {
    id v7 = objc_msgSend(v2, sel_depthAttachment);
    id v6 = objc_msgSend(v7, sel_texture);
  }
  id v8 = objc_msgSend(v2, sel_colorAttachments);
  id v9 = objc_msgSend(v8, sel_objectAtIndexedSubscript_, 0);

  id v10 = objc_msgSend(v9, sel_texture);
  if (v10)
  {
    id v49 = objc_msgSend(v10, sel_pixelFormat);
    swift_unknownObjectRelease();
  }
  else
  {
    id v49 = 0;
  }
  id v11 = objc_msgSend(v2, sel_colorAttachments);
  id v12 = objc_msgSend(v11, sel_objectAtIndexedSubscript_, 1);

  id v13 = objc_msgSend(v12, sel_texture);
  if (v13)
  {
    id v48 = objc_msgSend(v13, sel_pixelFormat);
    swift_unknownObjectRelease();
  }
  else
  {
    id v48 = 0;
  }
  id v14 = objc_msgSend(v2, sel_colorAttachments);
  id v15 = objc_msgSend(v14, sel_objectAtIndexedSubscript_, 2);

  id v16 = objc_msgSend(v15, sel_texture);
  if (v16)
  {
    id v47 = objc_msgSend(v16, sel_pixelFormat);
    swift_unknownObjectRelease();
  }
  else
  {
    id v47 = 0;
  }
  id v17 = objc_msgSend(v2, sel_colorAttachments);
  id v18 = objc_msgSend(v17, sel_objectAtIndexedSubscript_, 3);

  id v19 = objc_msgSend(v18, sel_texture);
  if (v19)
  {
    id v46 = objc_msgSend(v19, sel_pixelFormat);
    swift_unknownObjectRelease();
  }
  else
  {
    id v46 = 0;
  }
  id v20 = objc_msgSend(v2, sel_colorAttachments);
  id v21 = objc_msgSend(v20, sel_objectAtIndexedSubscript_, 4);

  id v22 = objc_msgSend(v21, sel_texture);
  if (v22)
  {
    id v45 = objc_msgSend(v22, sel_pixelFormat);
    swift_unknownObjectRelease();
  }
  else
  {
    id v45 = 0;
  }
  id v23 = objc_msgSend(v2, sel_colorAttachments);
  id v24 = objc_msgSend(v23, sel_objectAtIndexedSubscript_, 5);

  id v25 = objc_msgSend(v24, sel_texture);
  if (v25)
  {
    id v44 = objc_msgSend(v25, sel_pixelFormat);
    swift_unknownObjectRelease();
  }
  else
  {
    id v44 = 0;
  }
  id v26 = objc_msgSend(v2, sel_colorAttachments);
  id v27 = objc_msgSend(v26, sel_objectAtIndexedSubscript_, 6);

  id v28 = objc_msgSend(v27, sel_texture);
  if (v28)
  {
    id v29 = objc_msgSend(v28, sel_pixelFormat);
    swift_unknownObjectRelease();
  }
  else
  {
    id v29 = 0;
  }
  id v30 = objc_msgSend(v2, sel_colorAttachments);
  id v31 = objc_msgSend(v30, sel_objectAtIndexedSubscript_, 7);

  id v32 = objc_msgSend(v31, sel_texture);
  if (v32)
  {
    id v33 = objc_msgSend(v32, (SEL)&selRef_objectForKey_);
    swift_unknownObjectRelease();
  }
  else
  {
    id v33 = 0;
  }
  id v34 = objc_msgSend(v2, sel_depthAttachment);
  id v35 = objc_msgSend(v34, sel_texture);

  if (v35)
  {
    id v36 = objc_msgSend(v35, (SEL)&selRef_objectForKey_);
    swift_unknownObjectRelease();
  }
  else
  {
    id v36 = 0;
  }
  id v37 = objc_msgSend(v2, sel_stencilAttachment);
  id v38 = objc_msgSend(v37, sel_texture);

  if (!v38)
  {
    id v39 = 0;
    if (v6) {
      goto LABEL_32;
    }
LABEL_34:
    uint64_t v40 = 1;
    goto LABEL_35;
  }
  id v39 = objc_msgSend(v38, (SEL)&selRef_objectForKey_);
  swift_unknownObjectRelease();
  if (!v6) {
    goto LABEL_34;
  }
LABEL_32:
  uint64_t v40 = (uint64_t)objc_msgSend(v6, sel_sampleCount);
LABEL_35:
  sub_1B6389BE4((uint64_t)v49, (uint64_t)v48, (uint64_t)v47, (uint64_t)v46, (uint64_t)v45, (uint64_t)v44, (uint64_t)v29, (uint64_t)v33, v50, (uint64_t)v36, (uint64_t)v39, 0, v40);
  swift_unknownObjectRelease();
  long long v41 = v50[3];
  *(_OWORD *)(a1 + 32) = v50[2];
  *(_OWORD *)(a1 + 48) = v41;
  *(_OWORD *)(a1 + 64) = v50[4];
  *(void *)(a1 + 80) = v51;
  double result = *(double *)v50;
  long long v43 = v50[1];
  *(_OWORD *)a1 = v50[0];
  *(_OWORD *)(a1 + 16) = v43;
  return result;
}

uint64_t sub_1B6389BE4@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, void *a9@<X8>, uint64_t a10, uint64_t a11, char a12, uint64_t a13)
{
  if (a10 == 260) {
    uint64_t v13 = 260;
  }
  else {
    uint64_t v13 = 0;
  }
  *a9 = result;
  a9[1] = a2;
  if (a12) {
    a11 = v13;
  }
  a9[2] = a3;
  a9[3] = a4;
  a9[4] = a5;
  a9[5] = a6;
  a9[6] = a7;
  a9[7] = a8;
  a9[8] = a10;
  a9[9] = a11;
  a9[10] = a13;
  return result;
}

id sub_1B6389C1C(uint64_t a1)
{
  return objc_msgSend(v1, sel_drawPrimitives_vertexStart_vertexCount_instanceCount_, 3, 0, 3, a1);
}

void vfx_deallocate_memory_entry(uint64_t a1)
{
  id v2 = *(void **)a1;
  if (*(unsigned char *)(a1 + 20))
  {
    free(*(void **)a1);
  }
  else
  {
    if (v2) {
      mach_vm_deallocate(*MEMORY[0x1E4F14960], (mach_vm_address_t)v2, *(void *)(a1 + 8));
    }
    mach_port_name_t v3 = *(_DWORD *)(a1 + 16);
    if (v3 + 1 >= 2) {
      mach_port_deallocate(*MEMORY[0x1E4F14960], v3);
    }
  }
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = 0;
}

void *CStackAllocatorAllocateAligned(uint64_t *a1, size_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *a1;
  while (1)
  {
    uint64_t v5 = *(unsigned int *)(v4 + 12);
    uint64_t v6 = *(void *)v4 + v5;
    id v7 = (void *)((a3 - 1 + v6) & -a3);
    if ((unint64_t)v7 + a2 - v6 <= (*(_DWORD *)(v4 + 8) - v5)) {
      break;
    }
    uint64_t v4 = *(void *)(v4 + 16);
    if (!v4) {
      operator new();
    }
  }
  *(_DWORD *)(v4 + 12) = a2 + v7 - *(_DWORD *)v4;
  if (a4 == 2)
  {
    memset(v7, 255, a2);
  }
  else if (a4 == 1)
  {
    bzero(v7, a2);
  }
  return v7;
}

void *ecs_stack_allocator_create(uint64_t a1)
{
  unint64_t v1 = (a1 + 31) & 0xFFFFFFFFFFFFFFE0;
  double result = malloc_type_aligned_alloc(0x20uLL, (v1 + 575) & 0xFFFFFFFFFFFFFFE0, 0x61E8937BuLL);
  uint64_t v3 = 0;
  void *result = result + 68;
  result[1] = v1;
  result[2] = 0;
  *((_DWORD *)result + 134) = 0;
  do
  {
    uint64_t v4 = (char *)&result[v3];
    *((void *)v4 + 3) = 0;
    *((_DWORD *)v4 + 8) = 0;
    v3 += 2;
  }
  while (v3 != 64);
  return result;
}

uint64_t RGMTLComputeCommandEncoderDispatchOnGrid3D(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = objc_msgSend_threadExecutionWidth(a2, (const char *)a2, a3, a4);
  unint64_t v11 = objc_msgSend_maxTotalThreadsPerThreadgroup(a2, v8, v9, v10);
  id v15 = objc_msgSend_device(a2, v12, v13, v14);
  if (objc_msgSend_supportsFamily_(v15, v16, 3003, v17))
  {
    long long v28 = *(_OWORD *)a3;
    uint64_t v29 = *(void *)(a3 + 16);
    v27[0] = v7;
    v27[1] = v11 / v7;
    v27[2] = 1;
    return objc_msgSend_dispatchThreads_threadsPerThreadgroup_(a1, v18, (uint64_t)&v28, (uint64_t)v27);
  }
  else
  {
    unint64_t v20 = *(void *)(a3 + 8);
    if (v7 >= *(void *)a3) {
      unint64_t v21 = *(void *)a3;
    }
    else {
      unint64_t v21 = v7;
    }
    if (v7 >= v20) {
      unint64_t v22 = *(void *)(a3 + 8);
    }
    else {
      unint64_t v22 = v7;
    }
    unint64_t v23 = *(void *)(a3 + 16);
    if (v7 >= v23) {
      unint64_t v24 = *(void *)(a3 + 16);
    }
    else {
      unint64_t v24 = v7;
    }
    while (v22 * v24 * v21 > v11)
    {
      if (v21 <= v22 || v21 <= v24)
      {
        if (v22 > v24) {
          v22 >>= 1;
        }
        else {
          v24 >>= 1;
        }
      }
      else
      {
        v21 >>= 1;
      }
    }
    v26[0] = (*(void *)a3 + v21 - 1) / v21;
    v26[1] = (v20 + v22 - 1) / v22;
    v26[2] = (v23 + v24 - 1) / v24;
    v25[0] = v21;
    v25[1] = v22;
    v25[2] = v24;
    return objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(a1, v18, (uint64_t)v26, (uint64_t)v25);
  }
}

void prof_commit()
{
  if (byte_1E9E498C9)
  {
    uint64_t v0 = currentThreadProfiler_0();
    uint64_t v1 = *(void *)(v0 + 16);
    uint64_t v2 = v0 + 56 * v1;
    if (!*(_WORD *)(v2 + 76) && (*(_DWORD *)(v0 + 56 * v1 + 40) || *(_DWORD *)(v2 + 24)))
    {
      if (!byte_1E9E498C8)
      {
        uint64_t v1 = ((_WORD)v1 + 1) & 0x1FF;
        *(void *)(v0 + 16) = v1;
      }
      uint64_t v3 = v0 + 56 * v1 + 24;
      sub_1B6DA8B68(v3);
    }
  }
}

id sub_1B638A0FC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  swift_getObjectType();
  objc_msgSend(a1, sel_setRenderPipelineState_, a2);
  if (a4 - 2 == a3) {
    uint64_t v14 = a5;
  }
  else {
    uint64_t v14 = a6;
  }
  objc_msgSend(a1, sel_setFragmentTexture_atIndex_, v14, 0);
  objc_msgSend(a1, sel_setFragmentTexture_atIndex_, a5, 1);
  *(float *)&uint64_t v15 = (float)(a3 + 1);
  *((float *)&v15 + 1) = (float)a3;
  v17[0] = v15;
  objc_msgSend(a1, sel_setFragmentBytes_length_atIndex_, v17, 8, 0);
  objc_msgSend(a1, sel_setFragmentBytes_length_atIndex_, a7, 48, 1);
  return sub_1B6389C1C(1);
}

uint64_t *sub_1B638A224(uint64_t *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[10];
  uint64_t v5 = a1[11];
  uint64_t v7 = a1[16];
  uint64_t v8 = a1[15];
  sub_1B6312CF0(*a1, a1[1]);
  sub_1B6312CF0(v2, v3);
  sub_1B6312CF0(v4, v5);
  sub_1B6312CF0(v8, v7);
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  return a1;
}

uint64_t sub_1B638A310(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v4 = v2;
  char v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v3;
  uint64_t v165 = *MEMORY[0x1E4F143B8];
  sub_1B638BF2C(0, (unint64_t *)&unk_1EB980390, MEMORY[0x1E4FBCFE8]);
  uint64_t v12 = MEMORY[0x1F4188790](v10 - 8, v11);
  uint64_t v14 = (char *)&v124 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12, v15);
  uint64_t v132 = (uint64_t)&v124 - v16;
  long long v17 = *(_OWORD *)(v9 + 144);
  long long v146 = *(_OWORD *)(v9 + 128);
  long long v147 = v17;
  long long v148 = *(_OWORD *)(v9 + 160);
  long long v18 = *(_OWORD *)(v9 + 80);
  v143[2] = *(_OWORD *)(v9 + 64);
  v144[0] = v18;
  long long v19 = *(_OWORD *)(v9 + 96);
  long long v145 = *(_OWORD *)(v9 + 112);
  v144[1] = v19;
  long long v20 = *(_OWORD *)(v9 + 16);
  v142[0] = *(_OWORD *)v9;
  v142[1] = v20;
  long long v21 = *(_OWORD *)(v9 + 32);
  v143[1] = *(_OWORD *)(v9 + 48);
  v143[0] = v21;
  unint64_t v22 = (uint64_t (*)(void, uint64_t))MEMORY[0x1E4FBB718];
  sub_1B6312FE4((uint64_t)v142, (uint64_t)v155, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, MEMORY[0x1E4FBB718]);
  sub_1B6312FE4((uint64_t)v155, (uint64_t)v160, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, v22);
  if (!v161)
  {
    unint64_t v23 = (uint64_t (*)(void, uint64_t))MEMORY[0x1E4FBB718];
    sub_1B6312FE4((uint64_t)&v145 + 8, (uint64_t)v149, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, MEMORY[0x1E4FBB718]);
    sub_1B6312FE4((uint64_t)v149, (uint64_t)v163, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, v23);
    if (!v164)
    {
      if (qword_1EB9852D0 != -1) {
        swift_once();
      }
      swift_retain();
      int v56 = sub_1B6E32148();
      if (qword_1EB9854F8 != -1) {
        swift_once();
      }
      v156[0] = 0;
      swift_retain();
      sub_1B6B33E34(v56, v156, 0xD000000000000048, 0x80000001B6F35220);
      swift_release();
      swift_release();
      return 1;
    }
  }
  unint64_t v24 = (void *)swift_unknownObjectRetain();
  uint64_t v25 = sub_1B62D6D98(v24);
  swift_unknownObjectRelease();
  uint64_t v26 = v25 ^ v8 & 1;
  uint64_t v27 = v2 + OBJC_IVAR____TtC3VFX11ShaderCache_lock;
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v2 + OBJC_IVAR____TtC3VFX11ShaderCache_lock + 24));
  if (*(unsigned char *)(v2 + 88))
  {
    sub_1B67A2BD0(v156);
    if ((v8 & 1) == 0) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v28 = *(void *)(v2 + 40);
    if (*(void *)(v28 + 16) && (unint64_t v29 = sub_1B62C1A30(v25 ^ v8 & 1), (v30 & 1) != 0))
    {
      sub_1B6312FE4(*(void *)(v28 + 56) + 832 * v29, (uint64_t)v140, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
      sub_1B6312FE4((uint64_t)v140, (uint64_t)v156, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
      double v31 = nullsub_1(v156);
      sub_1B638BC0C(v140, sub_1B638C2D4, v31);
    }
    else
    {
      sub_1B67A2BD0(v156);
      if ((v8 & 1) == 0)
      {
        uint64_t v33 = *(void *)(v4 + 40);
        if (*(void *)(v33 + 16))
        {
          unint64_t v34 = sub_1B62C1A30(v25 ^ 1);
          if (v35)
          {
            sub_1B6312FE4(*(void *)(v33 + 56) + 832 * v34, (uint64_t)v137, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
            sub_1B6312FE4((uint64_t)v137, (uint64_t)&v138, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
            double v36 = nullsub_1(&v138);
            sub_1B638BC0C(v137, sub_1B638C2D4, v36);
            id v37 = &v138;
LABEL_15:
            sub_1B638BDDC((uint64_t)v37, (uint64_t)v140);
            id v32 = (uint64_t *)v140;
            goto LABEL_16;
          }
        }
LABEL_14:
        id v37 = v156;
        goto LABEL_15;
      }
    }
  }
  id v32 = v156;
LABEL_16:
  sub_1B638BDDC((uint64_t)v32, (uint64_t)v141);
  uint64_t v38 = *(void *)(v4 + 64);
  if (*(void *)(v38 + 16) && (unint64_t v39 = sub_1B62C1A30(v26), (v40 & 1) != 0)) {
    int v41 = *(unsigned __int8 *)(*(void *)(v38 + 56) + v39);
  }
  else {
    int v41 = 0;
  }
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v27 + 24));
  if ((*(unsigned char *)(v4 + 88) & 1) != 0 || !v41)
  {
    sub_1B638BDDC((uint64_t)v141, (uint64_t)v140);
    if (sub_1B638C4D4((uint64_t)v140) == 1)
    {
      id v131 = v8;
      if ((v6 & 1) == 0) {
        goto LABEL_29;
      }
      if (qword_1EB985520 != -1) {
        swift_once();
      }
      if ((byte_1EB985230 & 1) != 0
        || (id v44 = (uint64_t (*)(void, uint64_t))MEMORY[0x1E4FBB718],
            sub_1B6312FE4((uint64_t)&v145 + 8, (uint64_t)v154, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, MEMORY[0x1E4FBB718]), sub_1B6312FE4((uint64_t)v154, (uint64_t)v134, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, v44), v134[1]))
      {
LABEL_29:
        sub_1B6312FE4((uint64_t)v143 + 8, (uint64_t)v153, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, MEMORY[0x1E4FBB718]);
        swift_retain();
        sub_1B63124DC((uint64_t *)v9);
        sub_1B63127F0(v153, (void (*)(void, void, void, void, void))sub_1B6312ABC);
        id v130 = sub_1B67A286C((uint64_t)v153, v4, v9);
        uint64_t v132 = v27;
        sub_1B638CE7C((uint64_t *)v9);
        swift_release();
        sub_1B63127F0(v153, (void (*)(void, void, void, void, void))sub_1B6312CF0);
        uint64_t v57 = MEMORY[0x1E4FBB1A0];
        sub_1B67A2C0C((uint64_t)&v148, (uint64_t)&v152, (unint64_t *)&qword_1EB980318, (unint64_t *)&qword_1EB9802F0, MEMORY[0x1E4FBB1A0]);
        sub_1B67A2C0C((uint64_t)&v152, (uint64_t)&v162, (unint64_t *)&qword_1EB980318, (unint64_t *)&qword_1EB9802F0, v57);
        uint64_t v58 = v162;
        if (v162)
        {
          swift_retain();
          sub_1B63124DC((uint64_t *)v9);
          sub_1B6399A44((uint64_t)&v152);
          uint64_t v129 = (void *)sub_1B67A2744(v58, v4, v9);
          sub_1B638CE7C((uint64_t *)v9);
          swift_release();
          sub_1B62D8C3C((uint64_t)&v152);
        }
        else
        {
          uint64_t v129 = 0;
        }
        uint64_t v88 = (uint64_t (*)(void, uint64_t))MEMORY[0x1E4FBB718];
        sub_1B6312FE4((uint64_t)&v145 + 8, (uint64_t)v151, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, MEMORY[0x1E4FBB718]);
        long long v128 = v146;
        uint64_t v127 = *((void *)&v147 + 1);
        sub_1B6312FE4((uint64_t)v151, (uint64_t)v135, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, v88);
        if (v136)
        {
          sub_1B6312FE4((uint64_t)v144, (uint64_t)v150, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, MEMORY[0x1E4FBB718]);
          swift_retain();
          sub_1B63124DC((uint64_t *)v9);
          sub_1B63127F0(v150, (void (*)(void, void, void, void, void))sub_1B6312ABC);
          id v125 = sub_1B67A29D4((uint64_t)v150, v4, v9);
          sub_1B638CE7C((uint64_t *)v9);
          swift_release();
          sub_1B63127F0(v150, (void (*)(void, void, void, void, void))sub_1B6312CF0);
          swift_retain();
          sub_1B63124DC((uint64_t *)v9);
          swift_unknownObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_unknownObjectRetain();
          v91 = &unk_1EB985000;
          id v93 = sub_1B67A29D4((uint64_t)v151, v4, v9);
          sub_1B638CE7C((uint64_t *)v9);
          swift_release();
          sub_1B63127F0(v151, (void (*)(void, void, void, void, void))sub_1B6312CF0);
          *((void *)&v128 + 1) = sub_1B6796F9C(v9, (uint64_t)v125, (uint64_t)v93, (uint64_t)v130, v129);
          swift_unknownObjectRelease();
          swift_unknownObjectRelease();
          swift_bridgeObjectRelease();
          *(void *)&long long v128 = 0;
        }
        else
        {
          swift_retain();
          sub_1B63124DC((uint64_t *)v9);
          sub_1B63127F0(v155, (void (*)(void, void, void, void, void))sub_1B6312ABC);
          v91 = (void *)&unk_1EB985000;
          id v92 = sub_1B67A29D4((uint64_t)v155, v4, v9);
          sub_1B638CE7C((uint64_t *)v9);
          swift_release();
          sub_1B63127F0(v155, (void (*)(void, void, void, void, void))sub_1B6312CF0);
          *(void *)&long long v128 = sub_1B6290DE0(v9, v92, v130, (uint64_t)v129);
          swift_unknownObjectRelease();
          swift_bridgeObjectRelease();
          *((void *)&v128 + 1) = 0;
        }
        uint64_t v94 = sub_1B628EC80();
        unint64_t v96 = v95;
        if (v131) {
          long long v97 = "makeRenderPipelineRefl";
        }
        else {
          long long v97 = "makeRenderPipeline";
        }
        if (v131) {
          uint64_t v98 = 22;
        }
        else {
          uint64_t v98 = 18;
        }
        sub_1B6384D58(v97, v98, 2u, v94, v96, v26, (uint64_t)v137);
        uint64_t v99 = *(void (**)(uint64_t *))(v4 + OBJC_IVAR____TtC3VFX11ShaderCache_onShaderCompilation);
        uint64_t v126 = v26;
        if (v99)
        {
          if (v99 == (void (*)(uint64_t *))1)
          {
            if (v91[90] != -1) {
              swift_once();
            }
            v156[0] = 0;
            v156[1] = 0xE000000000000000;
            swift_retain();
            sub_1B6E328C8();
            uint64_t v138 = v156[0];
            uint64_t v139 = v156[1];
            sub_1B6E31948();
            memcpy(v156, (const void *)v9, 0x328uLL);
            sub_1B6E32B18();
            uint64_t v100 = v138;
            uint64_t v101 = v139;
            int v102 = sub_1B6E32148();
            if (qword_1EB9854F8 != -1) {
              swift_once();
            }
            v156[0] = 0;
            swift_retain();
            sub_1B6B33E34(v102, v156, v100, v101);
            swift_release();
            swift_bridgeObjectRelease();
            swift_release();
            uint64_t v26 = v126;
          }
          else
          {
            char v103 = *(os_unfair_lock_s **)(v132 + 24);
            swift_retain();
            os_unfair_lock_lock(v103);
            v156[3] = (uint64_t)&type metadata for RenderPipelineDescriptor;
            v156[0] = swift_allocObject();
            memcpy((void *)(v156[0] + 16), (const void *)v9, 0x328uLL);
            sub_1B63124DC((uint64_t *)v9);
            v99(v156);
            _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v156);
            os_unfair_lock_unlock(v103);
            sub_1B67A21D4((unint64_t)v99);
          }
        }
        uint64_t v104 = (void *)*((void *)&v128 + 1);
        if (*((void *)&v128 + 1))
        {
          swift_getObjectType();
          id v105 = v104;
          id v43 = (id)sub_1B6E32398();
          long long v111 = v110;

          uint64_t v112 = v132;
LABEL_90:
          long long v113 = *(os_unfair_lock_s **)(v112 + 24);
          uint64_t v114 = v112;
          id v115 = v111;
          os_unfair_lock_lock(v113);
          sub_1B6312D54(v111, v4, v126, (uint64_t)v43, (void *)v9);
          os_unfair_lock_unlock(v113);

          __int16 v116 = *(os_unfair_lock_s **)(v114 + 24);
          os_unfair_lock_lock(v116);
          sub_1B6385318(v4 + 96);
          os_unfair_lock_unlock(v116);

          sub_1B63852E0((uint64_t)v137);
          swift_unknownObjectRelease();
          return (uint64_t)v43;
        }
        if ((void)v128)
        {
          uint64_t v106 = *(void **)(v4 + 16);
          v156[0] = 0;
          uint64_t v138 = 0;
          id v131 = (id)v128;
          id v43 = objc_msgSend(v106, sel_newRenderPipelineStateWithDescriptor_options_reflection_error_);
          int v107 = (void *)v138;
          long long v111 = (void *)v156[0];
          id v108 = (id)v156[0];
          id v109 = v107;
          uint64_t v112 = v132;
          if (v43)
          {
            sub_1B6385698((uint64_t)v131, (SEL *)&selRef_addRenderPipelineFunctionsWithDescriptor_error_);

            goto LABEL_90;
          }
          int v118 = v109;
          char v119 = (void *)sub_1B6E30D78();

          swift_willThrow();
          id v120 = v131;

          char v121 = *(os_unfair_lock_s **)(v112 + 24);
          os_unfair_lock_lock(v121);
          sub_1B6385318(v4 + 96);
          os_unfair_lock_unlock(v121);

          sub_1B63852E0((uint64_t)v137);
          swift_unknownObjectRelease();
          uint64_t v26 = v126;
        }
        else
        {
          sub_1B6312FE4((uint64_t)v155, (uint64_t)v157, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, MEMORY[0x1E4FBB718]);
          uint64_t v112 = v132;
          if (v158)
          {
            uint64_t v117 = v159;
            swift_unknownObjectRetain();
          }
          else
          {
            uint64_t v117 = 0;
          }
          sub_1B67A2B7C();
          char v119 = (void *)swift_allocError();
          *(void *)uint64_t v122 = 0xD000000000000015;
          *(void *)(v122 + 8) = 0x80000001B6F352D0;
          *(void *)(v122 + 16) = v117;
          *(unsigned char *)(v122 + 24) = 0;
          swift_willThrow();
          uint64_t v123 = *(os_unfair_lock_s **)(v112 + 24);
          os_unfair_lock_lock(v123);
          sub_1B6385318(v4 + 96);
          os_unfair_lock_unlock(v123);
          sub_1B63852E0((uint64_t)v137);
          swift_unknownObjectRelease();
        }
        if (qword_1EB9852D0 != -1) {
          swift_once();
        }
        v156[0] = 0;
        v156[1] = 0xE000000000000000;
        swift_retain();
        sub_1B6E328C8();
        sub_1B6E31948();
        uint64_t v138 = (uint64_t)v119;
        sub_1B62C5560(0, (unint64_t *)&qword_1EB980E40);
        sub_1B6E32B18();
        uint64_t v45 = v156[0];
        uint64_t v46 = v156[1];
        int v47 = sub_1B6E32148();
        if (qword_1EB9854F8 != -1) {
          swift_once();
        }
        v156[0] = 0;
        swift_retain();
        sub_1B6B33E34(v47, v156, v45, v46);
        swift_release();
        swift_bridgeObjectRelease();
        swift_release();
        id v48 = *(os_unfair_lock_s **)(v112 + 24);
        os_unfair_lock_lock(v48);
        uint64_t v138 = (uint64_t)v119;
        sub_1B67A2C00((uint64_t)&v138);
        sub_1B6312FE4((uint64_t)&v138, (uint64_t)v156, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
        id v49 = v119;
        char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
        uint64_t v133 = *(void *)(v4 + 40);
        *(void *)(v4 + 40) = 0x8000000000000000;
        sub_1B63131C0((uint64_t)v156, v26, isUniquelyReferenced_nonNull_native);
        *(void *)(v4 + 40) = v133;
        swift_bridgeObjectRelease();
        char v51 = swift_isUniquelyReferenced_nonNull_native();
        uint64_t v133 = *(void *)(v4 + 64);
        *(void *)(v4 + 64) = 0x8000000000000000;
        sub_1B67E50E4(0, v26, v51);
        *(void *)(v4 + 64) = v133;
        swift_bridgeObjectRelease();
        os_unfair_lock_unlock(v48);

        return 1;
      }
      v69 = dispatch_group_create();
      dispatch_group_enter(v69);
      v70 = *(os_unfair_lock_s **)(v27 + 24);
      os_unfair_lock_lock(v70);
      uint64_t v138 = (uint64_t)v69;
      sub_1B67A2D70((uint64_t)&v138);
      sub_1B6312FE4((uint64_t)&v138, (uint64_t)v156, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
      int v71 = v69;
      char v72 = swift_isUniquelyReferenced_nonNull_native();
      v137[0] = *(void *)(v4 + 40);
      *(void *)(v4 + 40) = 0x8000000000000000;
      sub_1B63131C0((uint64_t)v156, v26, v72);
      *(void *)(v4 + 40) = v137[0];
      swift_bridgeObjectRelease();
      os_unfair_lock_unlock(v70);
      uint64_t v73 = v132;
      sub_1B6E31DC8();
      uint64_t v74 = sub_1B6E31DE8();
      (*(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)(v74 - 8) + 56))(v73, 0, 1, v74);
      uint64_t v75 = swift_allocObject();
      *(void *)(v75 + 16) = v71;
      *(void *)(v75 + 24) = v4;
      memcpy((void *)(v75 + 32), (const void *)v9, 0x328uLL);
      *(unsigned char *)(v75 + 840) = v131 & 1;
      *(void *)(v75 + 848) = v26;
      int v76 = v71;
      swift_retain();
      sub_1B63124DC((uint64_t *)v9);
      if (qword_1EB9852D0 != -1) {
        swift_once();
      }
      uint64_t v77 = qword_1EB9854F8;
      swift_retain();
      if (v77 != -1) {
        swift_once();
      }
      uint64_t v78 = qword_1EB997FF0;
      swift_retain();
      swift_release();
      unint64_t v79 = (void (*)(uint64_t))MEMORY[0x1E4FBCFE8];
      uint64_t v80 = v132;
      sub_1B639956C(v132, (uint64_t)v14, (unint64_t *)&unk_1EB980390, MEMORY[0x1E4FBCFE8]);
      unint64_t v81 = (void *)swift_allocObject();
      v81[2] = 0;
      v81[3] = 0;
      v81[4] = v78;
      v81[5] = &unk_1E9DCFF90;
      v81[6] = v75;
      sub_1B67A1908((uint64_t)v14, (uint64_t)&unk_1E9DCFF98, (uint64_t)v81);

      swift_release();
      sub_1B6399510(v80, (unint64_t *)&unk_1EB980390, v79);
      return 0;
    }
    sub_1B6312FE4((uint64_t)v140, (uint64_t)v156, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
    int v52 = sub_1B6313160((uint64_t)v156);
    if (v52)
    {
      if (v52 == 1)
      {
        nullsub_1(v156);
        id v43 = *v53;
        id v54 = v53[102];
        swift_unknownObjectRetain();
        sub_1B638BC0C(v141, sub_1B638C4E8, v55);
        return (uint64_t)v43;
      }
      double v60 = nullsub_1(v156);
    }
    else
    {
      double v59 = nullsub_1(v156);
      if (v6)
      {
        sub_1B638BC0C(v141, sub_1B638C4E8, v59);
        return 0;
      }
      sub_1B638BDDC((uint64_t)v141, (uint64_t)&v138);
      sub_1B638BC0C(&v138, sub_1B638C2D4, v61);
      CACurrentMediaTime();
      sub_1B6E321D8();
      uint64_t v62 = *(os_unfair_lock_s **)(v27 + 24);
      os_unfair_lock_lock(v62);
      uint64_t v63 = *(void *)(v4 + 40);
      if (*(void *)(v63 + 16) && (unint64_t v64 = sub_1B62C1A30(v26), (v65 & 1) != 0))
      {
        sub_1B6312FE4(*(void *)(v63 + 56) + 832 * v64, (uint64_t)v134, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
        sub_1B6312FE4((uint64_t)v134, (uint64_t)v135, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
        double v66 = nullsub_1(v135);
        sub_1B638BC0C(v134, sub_1B638C2D4, v66);
      }
      else
      {
        sub_1B67A2BD0(v135);
      }
      sub_1B638BDDC((uint64_t)v135, (uint64_t)v137);
      os_unfair_lock_unlock(v62);
      sub_1B638BDDC((uint64_t)v137, (uint64_t)v135);
      if (sub_1B638C4D4((uint64_t)v135) == 1)
      {
        uint64_t v68 = v141;
      }
      else
      {
        sub_1B6312FE4((uint64_t)v135, (uint64_t)v134, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
        if (sub_1B6313160((uint64_t)v134) == 1)
        {
          double v82 = nullsub_1(v134);
          uint64_t v84 = v83;
          sub_1B638BC0C(v141, sub_1B638C4E8, v82);
          sub_1B638BC0C(v141, sub_1B638C4E8, v85);
          id v43 = *v84;
          id v86 = v84[102];
          swift_unknownObjectRetain();
          sub_1B638BC0C(v137, sub_1B638C4E8, v87);
          return (uint64_t)v43;
        }
        double v89 = nullsub_1(v134);
        sub_1B638BC0C(v141, sub_1B638C4E8, v89);
        uint64_t v68 = v137;
      }
      sub_1B638BC0C(v68, sub_1B638C4E8, v67);
    }
    sub_1B638BC0C(v141, sub_1B638C4E8, v60);
    return 1;
  }
  sub_1B638BC0C(v141, sub_1B638C4E8, v42);
  return 2;
}

#error "1B638BDB4: call analysis failed (funcsize=116)"

uint64_t sub_1B638BDDC(uint64_t a1, uint64_t a2)
{
  sub_1B638BE6C(0, qword_1EB97DD08, &qword_1EB97DD00, (uint64_t)&type metadata for ShaderCache.RenderPipeline, (uint64_t (*)(void, uint64_t))type metadata accessor for ShaderCache.Status);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

void sub_1B638BE6C(uint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t (*a5)(void, uint64_t))
{
  if (!*a2)
  {
    sub_1B63130BC(255, a3, a4, a5);
    unint64_t v6 = sub_1B6E324B8();
    if (!v7) {
      atomic_store(v6, a2);
    }
  }
}

void sub_1B638BEC8(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B638BF2C(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    unint64_t v4 = sub_1B6E324B8();
    if (!v5) {
      atomic_store(v4, a2);
    }
  }
}

void sub_1B638BF80(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B638BFE4(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    unint64_t v4 = sub_1B6E324B8();
    if (!v5) {
      atomic_store(v4, a2);
    }
  }
}

void sub_1B638C038(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B638C09C(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B638C100(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    unint64_t v4 = sub_1B6E324B8();
    if (!v5) {
      atomic_store(v4, a2);
    }
  }
}

void sub_1B638C154(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B638C1B8(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B638C21C(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B638C280(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    unint64_t v4 = sub_1B6E324B8();
    if (!v5) {
      atomic_store(v4, a2);
    }
  }
}

id sub_1B638C2D4(id result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  int v18 = LOBYTE(STACK[0x3D8]);
  if (v18 == 2)
  {
    return result;
  }
  if (v18 != 1)
  {
    if (LOBYTE(STACK[0x3D8])) {
      return result;
    }
    return result;
  }
  unint64_t v24 = (void *)STACK[0x3D0];
  swift_unknownObjectRetain();
  sub_1B6312ABC(a2, a3);
  sub_1B6312ABC(a7, a8);
  sub_1B6312ABC(a12, a13);
  sub_1B6312ABC(a17, a18);
  id v23 = v24;
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();

  return (id)swift_retain();
}

uint64_t sub_1B638C4D4(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int8 *)(a1 + 824);
  if (v1 > 2) {
    return (v1 ^ 0xFF) + 1;
  }
  else {
    return 0;
  }
}

void sub_1B638C4E8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  int v18 = LOBYTE(STACK[0x5C8]);
  if (v18 != 255)
  {
    unint64_t v48 = STACK[0x5C0];
    unint64_t v19 = STACK[0x5B8];
    unint64_t v20 = STACK[0x5B0];
    unint64_t v21 = STACK[0x5A8];
    unint64_t v22 = STACK[0x5A0];
    unint64_t v23 = STACK[0x598];
    unint64_t v24 = STACK[0x590];
    unint64_t v25 = STACK[0x588];
    unint64_t v26 = STACK[0x580];
    unint64_t v27 = STACK[0x578];
    unint64_t v28 = STACK[0x570];
    unint64_t v29 = STACK[0x568];
    unint64_t v30 = STACK[0x560];
    unint64_t v31 = STACK[0x558];
    unint64_t v32 = STACK[0x550];
    unint64_t v33 = STACK[0x548];
    unint64_t v34 = STACK[0x540];
    unint64_t v35 = STACK[0x538];
    unint64_t v36 = STACK[0x530];
    unint64_t v37 = STACK[0x528];
    unint64_t v38 = STACK[0x520];
    unint64_t v39 = STACK[0x518];
    unint64_t v40 = STACK[0x510];
    unint64_t v41 = STACK[0x508];
    unint64_t v42 = STACK[0x500];
    unint64_t v43 = STACK[0x4F8];
    unint64_t v44 = STACK[0x4F0];
    unint64_t v45 = STACK[0x4E8];
    unint64_t v49 = STACK[0x4E0];
    unint64_t v46 = STACK[0x4D8];
    unint64_t v47 = STACK[0x4D0];
    LOBYTE(STACK[0x5C8]) = v18;
    STACK[0x5C0] = v48;
    STACK[0x5B8] = v19;
    STACK[0x5B0] = v20;
    STACK[0x5A8] = v21;
    STACK[0x5A0] = v22;
    STACK[0x598] = v23;
    STACK[0x590] = v24;
    STACK[0x588] = v25;
    STACK[0x580] = v26;
    STACK[0x578] = v27;
    STACK[0x570] = v28;
    STACK[0x568] = v29;
    STACK[0x560] = v30;
    STACK[0x558] = v31;
    STACK[0x550] = v32;
    STACK[0x548] = v33;
    STACK[0x540] = v34;
    STACK[0x538] = v35;
    STACK[0x530] = v36;
    STACK[0x528] = v37;
    STACK[0x520] = v38;
    STACK[0x518] = v39;
    STACK[0x510] = v40;
    STACK[0x508] = v41;
    STACK[0x500] = v42;
    STACK[0x4F8] = v43;
    STACK[0x4F0] = v44;
    STACK[0x4E8] = v45;
    STACK[0x4E0] = v49;
    STACK[0x4D8] = v46;
    STACK[0x4D0] = v47;
    sub_1B6312B20(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
  }
}

void prof_beginFlame(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (byte_1E9E498C9)
  {
    uint64_t v6 = currentThreadProfiler_0();
    uint64_t v7 = *(void *)(v6 + 16);
    uint64_t v8 = v6 + 56 * v7 + 24;
    switch(byte_1E9DDA458)
    {
      case 1:
        uint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
        break;
      case 3:
        uint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 4, 15, 10, 6));
        break;
      case 2:
        uint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 6));
        break;
      default:
        uint64_t StatusReg = mach_absolute_time();
        break;
    }
    uint64_t v10 = v6 + 56 * v7;
    int v13 = *(unsigned __int16 *)(v10 + 76);
    uint64_t v11 = (_WORD *)(v10 + 76);
    int v12 = v13;
    int v14 = *((_DWORD *)v11 - 1);
    unsigned int v15 = *(_DWORD *)v8;
    __int16 v16 = v13;
    unsigned int v17 = *(_DWORD *)v8;
    if ((*(_DWORD *)v8 + 1) > *(_DWORD *)(v8 + 4))
    {
      sub_1B6DA8BE0((unsigned int *)v8);
      unsigned int v17 = *(_DWORD *)v8;
      __int16 v16 = *v11;
    }
    unint64_t v18 = *(void *)(v8 + 8) + ((unint64_t)v17 << 6);
    *(void *)unint64_t v18 = a1;
    *(void *)(v18 + 8) = a2;
    *(void *)(v18 + 16) = a3;
    *(void *)(v18 + 24) = StatusReg;
    *(void *)(v18 + 32) = 0;
    *(_DWORD *)(v18 + 40) = v14;
    *(_DWORD *)(v18 + 44) = v12;
    *(void *)(v18 + 48) = 0;
    *(unsigned char *)(v18 + 56) = 0;
    ++*(_DWORD *)v8;
    *((_DWORD *)v11 - 1) = v15;
    *uint64_t v11 = v16 + 1;
  }
}

void prof_endFlame()
{
  if (byte_1E9E498C9)
  {
    if (byte_1E9DDA458 == 1)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 2));
    }
    else if (byte_1E9DDA458 == 3)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 4, 15, 10, 6));
    }
    else
    {
      unint64_t StatusReg = byte_1E9DDA458 == 2 ? _ReadStatusReg(ARM64_SYSREG(3, 3, 14, 0, 6)) : mach_absolute_time();
    }
    uint64_t v1 = currentThreadProfiler_0();
    uint64_t v2 = *(void *)(v1 + 16);
    uint64_t v3 = v1 + 56 * v2;
    int v6 = *(unsigned __int16 *)(v3 + 76);
    unint64_t v4 = (_WORD *)(v3 + 76);
    __int16 v5 = v6;
    if (!v6
      || (uint64_t v7 = v1 + 56 * v2,
          unint64_t v8 = *(void *)(v7 + 32) + ((unint64_t)*(unsigned int *)(v7 + 72) << 6),
          *(void *)(v8 + 32) = StatusReg,
          *(_DWORD *)(v7 + 72) = *(_DWORD *)(v8 + 40),
          __int16 v9 = v5 - 1,
          (*unint64_t v4 = v9) == 0))
    {
      if (!byte_1E9E498C8)
      {
        uint64_t v2 = ((_WORD)v2 + 1) & 0x1FF;
        *(void *)(v1 + 16) = v2;
      }
      uint64_t v10 = v1 + 56 * v2 + 24;
      sub_1B6DA8B68(v10);
    }
  }
}

uint64_t CFX::RG::ResourceIdentifier::finalColor(CFX::RG::ResourceIdentifier *this)
{
  return 0xEF6F57C624392439;
}

void RGTextureDescriptorFromMTLTexture(void *a1@<X0>, uint64_t a2@<X8>)
{
  id v3 = a1;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  id v49 = v3;
  *(_WORD *)a2 = objc_msgSend_width(v3, v4, v5, v6);
  *(_WORD *)(a2 + 2) = objc_msgSend_height(v49, v7, v8, v9);
  *(_WORD *)(a2 + 4) = objc_msgSend_depth(v49, v10, v11, v12);
  *(_WORD *)(a2 + 6) = objc_msgSend_arrayLength(v49, v13, v14, v15);
  *(unsigned char *)(a2 + 8) = objc_msgSend_mipmapLevelCount(v49, v16, v17, v18);
  *(unsigned char *)(a2 + 9) = objc_msgSend_sampleCount(v49, v19, v20, v21);
  *(unsigned char *)(a2 + 10) = objc_msgSend_allowGPUOptimizedContents(v49, v22, v23, v24);
  *(void *)(a2 + 16) = objc_msgSend_pixelFormat(v49, v25, v26, v27);
  *(void *)(a2 + 24) = objc_msgSend_textureType(v49, v28, v29, v30);
  *(void *)(a2 + 32) = objc_msgSend_storageMode(v49, v31, v32, v33);
  *(void *)(a2 + 40) = objc_msgSend_usage(v49, v34, v35, v36);
  *(void *)(a2 + 48) = objc_msgSend_cpuCacheMode(v49, v37, v38, v39);
  *(void *)(a2 + 56) = objc_msgSend_compressionType(v49, v40, v41, v42);
  *(void *)(a2 + 64) = objc_msgSend_hazardTrackingMode(v49, v43, v44, v45);
  *(_DWORD *)(a2 + 72) = objc_msgSend_swizzle(v49, v46, v47, v48);
}

void sub_1B638CDEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

float sample_curve(uint64_t a1, float a2)
{
  float v2 = *(float *)(a1 + 144) + (float)(fminf(fmaxf(a2, 0.0), 1.0) * *(float *)(a1 + 140));
  signed int v3 = vcvtms_s32_f32(v2);
  float v4 = v2 - floorf(v2);
  uint64_t v5 = (float *)(a1 + 4 * v3);
  return (float)((float)(*v5 + *v5)
               + (float)((float)((float)(v5[1] - *(v5 - 1))
                               + (float)((float)((float)((float)((float)((float)(v5[1] * 4.0) + (float)(*(v5 - 1) * 2.0))
                                                               + (float)(*v5 * -5.0))
                                                       - v5[2])
                                               + (float)((float)((float)(v5[2] + (float)((float)(*v5 - v5[1]) * 3.0))
                                                               - *(v5 - 1))
                                                       * v4))
                                       * v4))
                       * v4))
       * 0.5;
}

uint64_t *sub_1B638CE7C(uint64_t *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = a1[6];
  uint64_t v4 = a1[10];
  uint64_t v5 = a1[11];
  uint64_t v7 = a1[16];
  uint64_t v8 = a1[15];
  sub_1B6312CF0(*a1, a1[1]);
  sub_1B6312CF0(v2, v3);
  sub_1B6312CF0(v4, v5);
  sub_1B6312CF0(v8, v7);
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_release();
  return a1;
}

uint64_t vfx_counters_null()
{
  return 0;
}

void radix_sort_float(uint64_t a1, uint64_t a2)
{
}

BOOL vfx_counters_is_null(uint64_t a1)
{
  return a1 == 0;
}

void *dlsym_default(char *__symbol)
{
  return dlsym((void *)0xFFFFFFFFFFFFFFFELL, __symbol);
}

BOOL sub_1B638CFAC(void *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = 0;
  while (1)
  {
    id v5 = objc_msgSend(v2, sel_colorAttachments);
    id v6 = objc_msgSend(v5, sel_objectAtIndexedSubscript_, v4);

    id v7 = objc_msgSend(a1, sel_colorAttachments);
    id v8 = objc_msgSend(v7, sel_objectAtIndexedSubscript_, v4);

    LOBYTE(v7) = sub_1B638D11C(v8);
    if ((v7 & 1) == 0) {
      break;
    }
    if (++v4 == 8)
    {
      id v9 = objc_msgSend(v2, sel_depthAttachment);
      id v10 = objc_msgSend(a1, sel_depthAttachment);
      BOOL v11 = sub_1B638D11C(v10);

      if (v11)
      {
        id v12 = objc_msgSend(v2, sel_stencilAttachment);
        id v13 = objc_msgSend(a1, sel_stencilAttachment);
        BOOL v14 = sub_1B638D11C(v13);

        return v14;
      }
      return 0;
    }
  }
  return 0;
}

BOOL sub_1B638D11C(void *a1)
{
  id v3 = objc_msgSend(v1, sel_texture);
  id v4 = objc_msgSend(a1, sel_texture);
  id v5 = v4;
  if (v3)
  {
    swift_unknownObjectRelease();
    if (!v5) {
      return 0;
    }
    swift_unknownObjectRelease();
    if (v3 != v5) {
      return 0;
    }
  }
  else if (v4)
  {
    goto LABEL_6;
  }
  id v6 = objc_msgSend(v1, sel_loadAction);
  if (v6 != objc_msgSend(a1, sel_loadAction)) {
    return 0;
  }
  id v7 = objc_msgSend(v1, sel_storeAction);
  if (v7 != objc_msgSend(a1, sel_storeAction)) {
    return 0;
  }
  id v8 = objc_msgSend(v1, sel_level);
  if (v8 != objc_msgSend(a1, sel_level)) {
    return 0;
  }
  id v9 = objc_msgSend(v1, sel_resolveTexture);
  id v10 = objc_msgSend(a1, sel_resolveTexture);
  id v11 = v10;
  if (v9)
  {
    swift_unknownObjectRelease();
    if (v11)
    {
      swift_unknownObjectRelease();
      return v9 == v11;
    }
    return 0;
  }
  if (v10)
  {
LABEL_6:
    swift_unknownObjectRelease();
    return 0;
  }
  return 1;
}

float vfx_sampler1d_make@<S0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, uint64_t a6@<X8>)
{
  uint64_t v6 = a3 - 1;
  if (v6 > 9) {
    int v7 = 2;
  }
  else {
    int v7 = dword_1B6E503B0[v6];
  }
  *(float *)a6 = (float)a2;
  *(_DWORD *)(a6 + 4) = a2 - 1;
  *(_DWORD *)(a6 + 8) = v7;
  uint64_t v8 = (uint64_t)*(&off_1F0FBA888 + 40 * a5 + 10 * a4 + a3);
  *(_DWORD *)(a6 + 12) = v7 - v7 * a2;
  *(void *)(a6 + 16) = a1;
  *(void *)(a6 + 24) = v8;
  float result = 0.5 / (float)a2;
  *(float *)(a6 + 32) = result;
  return result;
}

uint64_t CFX::RG::TextureDescriptorReference::TextureDescriptorReference(uint64_t this)
{
  *(unsigned char *)this = 0;
  *(unsigned char *)(this + 2) = 0;
  *(unsigned char *)(this + 4) = 0;
  *(unsigned char *)(this + 6) = 0;
  *(unsigned char *)(this + 8) = 0;
  *(unsigned char *)(this + 10) = 0;
  *(unsigned char *)(this + 12) = 0;
  *(unsigned char *)(this + 14) = 0;
  *(unsigned char *)(this + 24) = 0;
  *(unsigned char *)(this + 32) = 0;
  *(unsigned char *)(this + 40) = 0;
  *(unsigned char *)(this + 48) = 0;
  *(unsigned char *)(this + 56) = 0;
  *(unsigned char *)(this + 64) = 0;
  *(unsigned char *)(this + 72) = 0;
  *(unsigned char *)(this + 80) = 0;
  *(unsigned char *)(this + 88) = 0;
  *(unsigned char *)(this + 96) = 0;
  *(unsigned char *)(this + 104) = 0;
  *(unsigned char *)(this + 112) = 0;
  *(unsigned char *)(this + 120) = 0;
  *(unsigned char *)(this + 128) = 0;
  *(unsigned char *)(this + 136) = 0;
  *(unsigned char *)(this + 140) = 0;
  *(_WORD *)(this + 20) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 144) = 1065353216;
  *(void *)(this + 152) = 0x1AED1AED1AEDLL;
  return this;
}

void CFX::RG::RenderGraphProvider::~RenderGraphProvider(CFX::RG::RenderGraphProvider *this)
{
  uint64_t v2 = *((unsigned int *)this + 2);
  if (v2)
  {
    id v3 = (void **)*((void *)this + 2);
    uint64_t v4 = 8 * v2;
    do
    {
      id v5 = *v3++;
      (*(void (**)(void *))(*(void *)v5 + 40))(v5);
      free(v5);
      v4 -= 8;
    }
    while (v4);
  }
  if (*((_DWORD *)this + 7)) {
    free(*((void **)this + 4));
  }
  if (*((_DWORD *)this + 3)) {
    free(*((void **)this + 2));
  }
}

double CFX::RG::RenderGraphProvider::RenderGraphProvider(CFX::RG::RenderGraphProvider *this)
{
  *(void *)this = "";
  double result = 0.0;
  *((void *)this + 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *((_WORD *)this + 20) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *((void *)this + 6) = 1;
  return result;
}

{
  double result;

  *(void *)this = "";
  double result = 0.0;
  *((void *)this + 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *((_WORD *)this + 20) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *((void *)this + 6) = 1;
  return result;
}

double CFX::RG::RenderGraphProvider::RenderGraphProvider(CFX::RG::RenderGraphProvider *this, const char *a2)
{
  *(void *)this = a2;
  double result = 0.0;
  *((void *)this + 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *((_WORD *)this + 20) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *((void *)this + 6) = 1;
  return result;
}

{
  double result;

  *(void *)this = a2;
  double result = 0.0;
  *((void *)this + 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 2) = (char *)this + 24;
  *((_WORD *)this + 20) = 0;
  *((void *)this + 4) = (char *)this + 40;
  *((void *)this + 6) = 1;
  return result;
}

uint64_t CFX::RG::RenderGraphProvider::resolve(uint64_t a1, uint64_t a2, uint64_t a3)
{
  prof_beginFlame((uint64_t)"resolve", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/VFXRenderGraph/Sources/RenderGraphProvider.mm", 22);
  uint64_t v6 = sub_1B6DABD90(a2, a1 + 8, a3);
  *(unsigned char *)(a1 + 40) = v6;
  prof_endFlame();
  return v6;
}

void sub_1B638D4F8(_Unwind_Exception *a1)
{
}

unsigned int *CStackAllocatorPushFrame(unsigned int *result)
{
  uint64_t v1 = result[140];
  if (v1 != 31)
  {
    result[140] = v1 + 1;
    unsigned int v2 = *(_DWORD *)(*(void *)result + 12);
    id v3 = &result[4 * v1];
    *((void *)v3 + 6) = *(void *)result;
    v3[14] = v2;
  }
  return result;
}

uint64_t CStackAllocatorPopFrame(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 560) - 1;
  *(_DWORD *)(a1 + 560) = v2;
  uint64_t v3 = a1 + 16 * v2;
  uint64_t v6 = *(void *)(v3 + 48);
  uint64_t v4 = v3 + 48;
  uint64_t v5 = v6;
  int v7 = *(_DWORD *)(v4 + 8);
  *(_DWORD *)(v6 + 12) = v7;
  uint64_t v8 = a1 + 8;
  if (v7) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v5 == v8;
  }
  if (v9) {
    uint64_t v10 = v5;
  }
  else {
    uint64_t v10 = *(void *)(v5 + 16);
  }
  uint64_t result = sub_1B6DC7330(a1, v10);
  if (v5 == v8 && !*(_DWORD *)(v10 + 12))
  {
    mach_vm_size_t v12 = *(unsigned int *)(v10 + 8);
    if (*(_DWORD *)(a1 + 40) > v12)
    {
      id v13 = (vm_map_t *)MEMORY[0x1E4F14960];
      mach_vm_deallocate(*MEMORY[0x1E4F14960], *(void *)v10, v12);
      vm_size_t v14 = ((*MEMORY[0x1E4F14B00] - 1) | (*(_DWORD *)(a1 + 40) - 1)) + 1;
      *(_DWORD *)(v10 + 8) = v14;
      uint64_t result = vm_allocate(*v13, (vm_address_t *)v10, v14, 1);
    }
  }
  *(void *)uint64_t v4 = 0;
  *(_DWORD *)(v4 + 8) = 0;
  return result;
}

uint64_t sub_1B638D61C()
{
  unint64_t v1 = *((void *)v0 + 3);
  if (v1 > 8) {
    return 1;
  }
  if (((1 << v1) & 0x63) != 0)
  {
    unsigned int v2 = *v0;
  }
  else
  {
    if (((1 << v1) & 0x11C) != 0)
    {
      unsigned int v2 = *v0;
      unsigned int v3 = v0[1];
    }
    else
    {
      unsigned int v2 = *v0;
      unsigned int v3 = v0[1];
      if (v0[2] > v3) {
        unsigned int v3 = v0[2];
      }
    }
    if (v3 > v2) {
      unsigned int v2 = v3;
    }
  }
  return (uint64_t)(float)(floorf(log2f(fmaxf((float)v2, 1.0))) + 1.0);
}

uint64_t sub_1B638D6C0()
{
  unint64_t v1 = (unint64_t)objc_msgSend(v0, sel_textureType);
  if (v1 > 8) {
    return 1;
  }
  if (((1 << v1) & 0x63) != 0)
  {
    id v3 = objc_msgSend(v0, sel_width);
  }
  else if (((1 << v1) & 0x11C) != 0)
  {
    id v2 = objc_msgSend(v0, sel_width);
    id v3 = objc_msgSend(v0, sel_height);
    if ((uint64_t)v3 <= (uint64_t)v2) {
      id v3 = v2;
    }
  }
  else
  {
    id v5 = objc_msgSend(v0, sel_width);
    id v6 = objc_msgSend(v0, sel_height);
    id v7 = objc_msgSend(v0, sel_depth);
    if ((uint64_t)v7 <= (uint64_t)v6) {
      id v8 = v6;
    }
    else {
      id v8 = v7;
    }
    if ((uint64_t)v8 <= (uint64_t)v5) {
      id v3 = v5;
    }
    else {
      id v3 = v8;
    }
  }
  return (uint64_t)(float)(floorf(log2f(fmaxf((float)(uint64_t)v3, 1.0))) + 1.0);
}

_OWORD *sub_1B638D7DC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  sub_1B62B5820();
  MEMORY[0x1F4188790](v8 - 8, v9);
  id v11 = (char *)&v20 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (*(void *)(a3 + 16))
  {
    swift_bridgeObjectRetain();
    uint64_t v12 = sub_1B62B2CE0(a1, a2);
    if (v13)
    {
      uint64_t v14 = *(void *)(*(void *)(a3 + 56) + 8 * v12);
      swift_retain();
      swift_bridgeObjectRelease();
      sub_1B633D260(*(void *)(v14 + 16), *(void *)(v14 + 32), (uint64_t *)&v20);
      swift_release();
      return sub_1B62B57A8(&v20, a4);
    }
    swift_bridgeObjectRelease();
  }
  if (qword_1EB9852D0 != -1) {
    swift_once();
  }
  *(void *)&long long v20 = 0;
  *((void *)&v20 + 1) = 0xE000000000000000;
  swift_retain();
  sub_1B6E328C8();
  swift_bridgeObjectRelease();
  *(void *)&long long v20 = 0xD000000000000029;
  *((void *)&v20 + 1) = 0x80000001B6F3DCD0;
  sub_1B6E31948();
  sub_1B6E31948();
  long long v16 = v20;
  uint64_t v17 = sub_1B6E32148();
  *(void *)&long long v20 = 1;
  sub_1B6B33B70(v17, v16, *((uint64_t *)&v16 + 1), (uint64_t *)&v20);
  swift_release();
  swift_bridgeObjectRelease();
  uint64_t v21 = MEMORY[0x1E4FBB550];
  *(void *)&long long v20 = 0;
  uint64_t v18 = sub_1B6E31118();
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v18 - 8) + 56))(v11, 1, 1, v18);
  type metadata accessor for Bindings.Value();
  uint64_t v19 = swift_allocObject();
  sub_1B6911FD0(&v20, 1, 0, (uint64_t)v11, 0, 0, 1, 0, 1u, 0, 1u, 0, 0, 0, 0, 0);
  sub_1B633D260(*(void *)(v19 + 16), *(void *)(v19 + 32), a4);
  return (_OWORD *)swift_release();
}

_OWORD *sub_1B638DA74@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X8>)
{
  return sub_1B638D7DC(a1, a2, *v3, a3);
}

uint64_t vfx_counters_get_default_ring_capacity()
{
  return 120;
}

void vfx_counters_create()
{
}

uint64_t vfx_counters_add_counter(uint64_t a1, const char *a2, char a3, char a4, unsigned int a5)
{
  if (!a1) {
    return 0;
  }
  LOBYTE(v10) = *a2;
  if (*a2)
  {
    int v11 = 0;
    int v12 = 63689;
    unsigned int v13 = 1;
    do
    {
      int v11 = v12 * v11 + (char)v10;
      v12 *= 378551;
      int v10 = a2[v13++];
    }
    while (v10);
  }
  else
  {
    int v11 = 0;
  }
  unsigned int v34 = v11;
  uint64_t v15 = sub_1B6DA98BC((void *)a1, &v34);
  if (v15) {
    return *((unsigned int *)v15 + 5);
  }
  uint64_t v16 = *(void *)(a1 + 72);
  if (*(void *)(a1 + 64) == v16)
  {
    unint64_t v17 = *(void *)(a1 + 56);
    uint64_t v19 = *(void *)(a1 + 40);
    uint64_t v18 = *(void **)(a1 + 48);
    uint64_t v14 = ((uint64_t)v18 - v19) / 24;
    if ((unint64_t)v18 >= v17)
    {
      if ((unint64_t)(v14 + 1) > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - v19) >> 3);
      uint64_t v22 = 2 * v21;
      if (2 * v21 <= v14 + 1) {
        uint64_t v22 = v14 + 1;
      }
      if (v21 >= 0x555555555555555) {
        unint64_t v23 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v23 = v22;
      }
      if (v23) {
        uint64_t v24 = (char *)sub_1B6428204(a1 + 56, v23);
      }
      else {
        uint64_t v24 = 0;
      }
      unint64_t v25 = &v24[24 * v14];
      uint64_t v26 = &v24[24 * v23];
      *(void *)unint64_t v25 = 0;
      *((void *)v25 + 1) = 0;
      *((void *)v25 + 2) = 0;
      long long v20 = v25 + 24;
      unint64_t v28 = *(char **)(a1 + 40);
      uint64_t v27 = *(char **)(a1 + 48);
      if (v27 != v28)
      {
        do
        {
          long long v29 = *(_OWORD *)(v27 - 24);
          *((void *)v25 - 1) = *((void *)v27 - 1);
          *(_OWORD *)(v25 - 24) = v29;
          v25 -= 24;
          v27 -= 24;
        }
        while (v27 != v28);
        uint64_t v27 = *(char **)(a1 + 40);
      }
      *(void *)(a1 + 40) = v25;
      *(void *)(a1 + 48) = v20;
      *(void *)(a1 + 56) = v26;
      if (v27) {
        operator delete(v27);
      }
    }
    else
    {
      *uint64_t v18 = 0;
      v18[1] = 0;
      long long v20 = v18 + 3;
      v18[2] = 0;
    }
    *(void *)(a1 + 48) = v20;
  }
  else
  {
    uint64_t v14 = *(unsigned int *)(v16 - 4);
    *(void *)(a1 + 72) = v16 - 4;
  }
  uint64_t v30 = strdup(a2);
  uint64_t v31 = *(void *)(a1 + 40) + 24 * v14;
  *(void *)uint64_t v31 = v30;
  *(_DWORD *)(v31 + 8) = 0;
  unsigned int v32 = v34 | 0xFF000000;
  if (a5) {
    unsigned int v32 = a5;
  }
  *(_DWORD *)(v31 + 12) = v32;
  *(unsigned char *)(v31 + 16) = a4;
  *(unsigned char *)(v31 + 17) = a3;
  uint64_t v35 = &v34;
  *((_DWORD *)sub_1B6DA9970(a1, &v34, (uint64_t)&unk_1B6E4FDF8, &v35) + 5) = v14;
  sub_1B65C0424(a1 + 88, *(unsigned int *)(a1 + 116) + ((uint64_t)(*(void *)(a1 + 96) - *(void *)(a1 + 88)) >> 3));
  return v14;
}

void meshopt_initialize()
{
  uint64_t v0 = 0;
  v4[1] = *MEMORY[0x1E4F143B8];
  do
  {
    uint64_t v1 = 0;
    int v2 = 0;
    do
    {
      if ((v0 >> v1)) {
        char v3 = v2;
      }
      else {
        char v3 = 0x80;
      }
      *((unsigned char *)v4 + v1) = v3;
      v2 += (v0 >> v1++) & 1;
    }
    while (v1 != 8);
    qword_1EB995730[v0] = v4[0];
    byte_1EB9885F8[v0++] = v2;
  }
  while (v0 != 256);
}

uint64_t sub_1B638DE70@<X0>(unsigned __int8 *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t result = sub_1B638DE9C(*a1);
  *a2 = result;
  return result;
}

uint64_t sub_1B638DE9C(uint64_t result)
{
  if ((result & 0xFC) != 0) {
    return 4;
  }
  else {
    return result;
  }
}

uint64_t sub_1B638DEB0()
{
  uint64_t v1 = v0[4];
  char v3 = (void *)v0[2];
  unint64_t v2 = v0[3];
  if (v0[5] >= 1) {
    swift_arrayDestroy();
  }
  ecs_stack_allocator_deallocate(v3, v2, 48 * v1);
  ecs_stack_allocator_pop_snapshot(v0[2]);

  return swift_deallocClassInstance();
}

uint64_t destroy for VertexLayout()
{
  return swift_release();
}

void sub_1B638DF34(float32x4_t *a1@<X0>, _OWORD *a2@<X8>)
{
  *(double *)&long long v3 = sub_1B638DF64(*a1, 0.5);
  *a2 = v3;
}

double sub_1B638DF64(float32x4_t a1, float a2)
{
  *(void *)&double result = vmulq_n_f32(a1, a2).u64[0];
  return result;
}

uint64_t initializeWithCopy for BindingPropertyDescription.BindingInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  uint64_t v5 = *(void *)(a2 + 32);
  swift_bridgeObjectRetain();
  if (v5)
  {
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(void *)(a1 + 32) = v5;
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
  }
  else
  {
    *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
    *(void *)(a1 + 40) = *(void *)(a2 + 40);
  }
  return a1;
}

uint64_t getEnumTagSinglePayload for AnyType.AssetReferenceKind(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFD) {
    goto LABEL_17;
  }
  if (a2 + 3 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 3) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 3;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 3;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 4;
  int v8 = v6 - 4;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

uint64_t storeEnumTagSinglePayload for ScriptLocation.EntityLocator(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(unsigned char *)(result + 16) = 0;
    *(void *)double result = a2 - 254;
    *(void *)(result + 8) = 0;
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 17) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 17) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 16) = -(char)a2;
    }
  }
  return result;
}

uint64_t sub_1B638E0C8()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B638E128()
{
  unint64_t result = qword_1EB97E3C8;
  if (!qword_1EB97E3C8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97E3C8);
  }
  return result;
}

uint64_t sub_1B638E180()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B638E1E0()
{
  unint64_t result = qword_1EB97DA98;
  if (!qword_1EB97DA98)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97DA98);
  }
  return result;
}

uint64_t sub_1B638E234()
{
  uint64_t v3 = *v0;
  swift_task_dealloc();
  uint64_t v1 = *(uint64_t (**)(void))(v3 + 8);
  return v1();
}

uint64_t destroy for BufferArgument(uint64_t a1)
{
  return sub_1B62E6BD4(*(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24), *(unsigned char *)(a1 + 32));
}

uint64_t _s3VFX11EntityCoderVwCP_0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t getEnumTagSinglePayload for TextureCache.WeakStorage.CPU(uint64_t a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *(unsigned char *)(a1 + 128)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  unint64_t v2 = *(void *)(a1 + 120);
  if (v2 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

uint64_t destroy for BufferSlice()
{
  return swift_unknownObjectRelease();
}

uint64_t getEnumTagSinglePayload for TextureCache.WeakStorage.GPU(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0x7FFFFFFF && *(unsigned char *)(a1 + 24)) {
    return (*(_DWORD *)a1 + 0x7FFFFFFF);
  }
  unint64_t v3 = *(void *)(a1 + 8);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  int v4 = v3 - 1;
  if (v4 < 0) {
    int v4 = -1;
  }
  return (v4 + 1);
}

id VFXREDrawCall.init()()
{
  *(void *)&v0[OBJC_IVAR___VFXREDrawCall_drawCall] = 0;
  uint64_t v1 = &v0[OBJC_IVAR___VFXREDrawCall_aabb];
  *(_OWORD *)uint64_t v1 = xmmword_1B6E4F370;
  *((void *)v1 + 2) = 0;
  *((void *)v1 + 3) = 0;
  v0[OBJC_IVAR___VFXREDrawCall__isDepthOnly] = 0;
  v0[OBJC_IVAR___VFXREDrawCall__writesColor] = 0;
  v0[OBJC_IVAR___VFXREDrawCall__writesSeparateDepth] = 0;
  v0[OBJC_IVAR___VFXREDrawCall__needsLinearDepth] = 0;
  v0[OBJC_IVAR___VFXREDrawCall__drawsForBlur] = 0;
  v0[OBJC_IVAR___VFXREDrawCall__isAdditive] = 0;
  *(_DWORD *)&v0[OBJC_IVAR___VFXREDrawCall__materialType] = 0;
  uint64_t v2 = OBJC_IVAR___VFXREDrawCall_reProvidedBuffers;
  unint64_t v3 = v0;
  uint64_t v4 = sub_1B638E5B0((uint64_t)&unk_1F0F626F8);
  swift_arrayDestroy();
  *(void *)&v0[v2] = v4;
  uint64_t v5 = OBJC_IVAR___VFXREDrawCall_reProvidedTextures;
  uint64_t v6 = sub_1B638E5B0((uint64_t)&unk_1F0F62698);
  swift_arrayDestroy();
  *(void *)&v3[v5] = v6;
  BOOL v7 = &v3[OBJC_IVAR___VFXREDrawCall_handler];
  *BOOL v7 = 0;
  v7[1] = 0;
  int v8 = &v3[OBJC_IVAR___VFXREDrawCall_renderPassName];
  *int v8 = 0;
  v8[1] = 0xE000000000000000;
  v3[OBJC_IVAR___VFXREDrawCall_renderPassIdentifier] = -1;
  uint64_t v9 = &v3[OBJC_IVAR___VFXREDrawCall_emitterIdentifier];
  *uint64_t v9 = 0;
  v9[1] = 0xE000000000000000;

  v11.receiver = v3;
  v11.super_class = (Class)type metadata accessor for VFXREDrawCall();
  return objc_msgSendSuper2(&v11, sel_init);
}

uint64_t sub_1B638E5B0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t result = sub_1B6E31EF8();
  uint64_t v8 = result;
  if (v2)
  {
    uint64_t v4 = (uint64_t *)(a1 + 40);
    do
    {
      uint64_t v5 = *(v4 - 1);
      uint64_t v6 = *v4;
      swift_bridgeObjectRetain();
      sub_1B638E648(&v7, v5, v6);
      swift_bridgeObjectRelease();
      v4 += 2;
      --v2;
    }
    while (v2);
    return v8;
  }
  return result;
}

uint64_t sub_1B638E648(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *v3;
  sub_1B6E33918();
  swift_bridgeObjectRetain();
  sub_1B6E318B8();
  uint64_t v8 = sub_1B6E33988();
  uint64_t v9 = -1 << *(unsigned char *)(v7 + 32);
  unint64_t v10 = v8 & ~v9;
  if ((*(void *)(v7 + 56 + ((v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10))
  {
    uint64_t v11 = *(void *)(v7 + 48);
    int v12 = (void *)(v11 + 16 * v10);
    BOOL v13 = *v12 == a2 && v12[1] == a3;
    if (v13 || (sub_1B6E334B8() & 1) != 0)
    {
LABEL_7:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      uint64_t v14 = (uint64_t *)(*(void *)(*v3 + 48) + 16 * v10);
      uint64_t v15 = v14[1];
      *a1 = *v14;
      a1[1] = v15;
      swift_bridgeObjectRetain();
      return 0;
    }
    uint64_t v17 = ~v9;
    while (1)
    {
      unint64_t v10 = (v10 + 1) & v17;
      if (((*(void *)(v7 + 56 + ((v10 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v10) & 1) == 0) {
        break;
      }
      uint64_t v18 = (void *)(v11 + 16 * v10);
      BOOL v19 = *v18 == a2 && v18[1] == a3;
      if (v19 || (sub_1B6E334B8() & 1) != 0) {
        goto LABEL_7;
      }
    }
  }
  swift_bridgeObjectRelease();
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v21 = *v3;
  *unint64_t v3 = 0x8000000000000000;
  swift_bridgeObjectRetain();
  sub_1B638E7F8(a2, a3, v10, isUniquelyReferenced_nonNull_native);
  *unint64_t v3 = v21;
  swift_bridgeObjectRelease();
  *a1 = a2;
  a1[1] = a3;
  return 1;
}

uint64_t sub_1B638E7F8(uint64_t result, uint64_t a2, unint64_t a3, char a4)
{
  uint64_t v5 = v4;
  uint64_t v8 = result;
  unint64_t v9 = *(void *)(*v4 + 16);
  unint64_t v10 = *(void *)(*v4 + 24);
  if (v10 <= v9 || (a4 & 1) == 0)
  {
    if (a4)
    {
      sub_1B67EC63C();
    }
    else
    {
      if (v10 > v9)
      {
        uint64_t result = sub_1B67F0608();
        goto LABEL_22;
      }
      sub_1B67F2AC0();
    }
    uint64_t v11 = *v4;
    sub_1B6E33918();
    sub_1B6E318B8();
    uint64_t result = sub_1B6E33988();
    uint64_t v12 = -1 << *(unsigned char *)(v11 + 32);
    a3 = result & ~v12;
    uint64_t v13 = v11 + 56;
    if ((*(void *)(v11 + 56 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3))
    {
      uint64_t v14 = *(void *)(v11 + 48);
      uint64_t v15 = (void *)(v14 + 16 * a3);
      BOOL v16 = *v15 == v8 && v15[1] == a2;
      if (v16 || (uint64_t result = sub_1B6E334B8(), (result & 1) != 0))
      {
LABEL_21:
        uint64_t result = sub_1B6E33828();
        __break(1u);
      }
      else
      {
        uint64_t v17 = ~v12;
        while (1)
        {
          a3 = (a3 + 1) & v17;
          if (((*(void *)(v13 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3) & 1) == 0) {
            break;
          }
          uint64_t v18 = (void *)(v14 + 16 * a3);
          if (*v18 != v8 || v18[1] != a2)
          {
            uint64_t result = sub_1B6E334B8();
            if ((result & 1) == 0) {
              continue;
            }
          }
          goto LABEL_21;
        }
      }
    }
  }
LABEL_22:
  uint64_t v20 = *v5;
  *(void *)(*v5 + 8 * (a3 >> 6) + 56) |= 1 << a3;
  uint64_t v21 = (uint64_t *)(*(void *)(v20 + 48) + 16 * a3);
  *uint64_t v21 = v8;
  v21[1] = a2;
  ++*(void *)(v20 + 16);
  return result;
}

uint64_t type metadata accessor for VFXREDrawCall()
{
  return self;
}

unint64_t vfx_script_clock_simulation_index(void *a1)
{
  unint64_t result = *(void *)(*a1 + OBJC_IVAR____TtC3VFX13EntityManager_clock + 24);
  if ((result & 0x8000000000000000) != 0 || HIDWORD(result))
  {
    unint64_t result = sub_1B6E32BD8();
    __break(1u);
  }
  return result;
}

unsigned char *_s3VFX11AddressModeOwst_0(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFC)
  {
    unsigned int v6 = ((a2 - 253) >> 8) + 1;
    void *result = a2 + 3;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        break;
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          void *result = a2 + 3;
        break;
    }
  }
  return result;
}

uint64_t destroy for GraphEntityComponentPropertyReferences()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

unsigned char *storeEnumTagSinglePayload for MotionDistribution(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFD)
  {
    unsigned int v6 = ((a2 - 254) >> 8) + 1;
    void *result = a2 + 2;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        break;
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          void *result = a2 + 2;
        break;
    }
  }
  return result;
}

unsigned char *storeEnumTagSinglePayload for EmissionOrder(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 3 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 3) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFD) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFC)
  {
    unsigned int v6 = ((a2 - 253) >> 8) + 1;
    void *result = a2 + 3;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        break;
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          void *result = a2 + 3;
        break;
    }
  }
  return result;
}

uint64_t sub_1B638ED44()
{
  return swift_release();
}

uint64_t sub_1B638ED4C()
{
  return swift_release();
}

uint64_t sub_1B638ED54()
{
  return swift_release();
}

uint64_t sub_1B638ED5C()
{
  return swift_release();
}

uint64_t sub_1B638ED64()
{
  return swift_release();
}

uint64_t sub_1B638ED6C()
{
  return swift_release();
}

uint64_t sub_1B638ED74()
{
  return swift_release();
}

uint64_t sub_1B638ED7C()
{
  return swift_release();
}

uint64_t sub_1B638ED84()
{
  return swift_release();
}

uint64_t sub_1B638ED8C()
{
  return swift_release();
}

uint64_t sub_1B638ED94()
{
  return swift_release();
}

uint64_t sub_1B638ED9C()
{
  return swift_release();
}

uint64_t sub_1B638EDA4()
{
  return swift_release();
}

uint64_t sub_1B638EDAC()
{
  return swift_release();
}

uint64_t sub_1B638EDB4()
{
  return swift_release();
}

uint64_t sub_1B638EDBC()
{
  return swift_release();
}

uint64_t sub_1B638EDC4()
{
  return swift_release();
}

uint64_t sub_1B638EDCC()
{
  return swift_release();
}

uint64_t sub_1B638EDD4()
{
  return swift_release();
}

uint64_t sub_1B638EDDC()
{
  return swift_release();
}

uint64_t sub_1B638EDE4()
{
  return swift_release();
}

uint64_t sub_1B638EDEC()
{
  return swift_release();
}

uint64_t sub_1B638EDF4()
{
  return swift_release();
}

uint64_t sub_1B638EDFC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE0C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE1C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE2C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE3C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE4C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE5C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE6C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE7C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE8C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EE9C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EEAC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EEBC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EECC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EEDC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EEEC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EEFC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EF0C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EF1C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EF2C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EF3C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EF4C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EF5C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t sub_1B638EF6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_1B638EF98(a1, a2, a3, MEMORY[0x1E4FBBF60]);
}

uint64_t sub_1B638EF98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void))
{
  unint64_t v4 = a4();
  return v4 | ((HIDWORD(v4) & 1) << 32);
}

uint64_t destroy for MetalFunctionReflection()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t storeEnumTagSinglePayload for TextureCache.WeakStorage.GPU(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x7FFFFFFE)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(void *)unint64_t result = a2 - 0x7FFFFFFF;
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 24) = 1;
    }
  }
  else
  {
    if (a3 >= 0x7FFFFFFF) {
      *(unsigned char *)(result + 24) = 0;
    }
    if (a2) {
      *(void *)(result + 8) = a2;
    }
  }
  return result;
}

uint64_t getEnumTagSinglePayload for TextureCache.CacheEntry(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFD && *(unsigned char *)(a1 + 153)) {
    return (*(_DWORD *)a1 + 253);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 152);
  if (v3 <= 3) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t sub_1B638F0BC()
{
  swift_release();
  if (v0[4])
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
  }
  if (v0[9])
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
  }
  if (v0[14])
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
  }
  if (v0[19])
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
    swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_release();

  return MEMORY[0x1F4186498](v0, 832, 7);
}

uint64_t sub_1B638F1A4()
{
  uint64_t v3 = *v0;
  swift_task_dealloc();
  uint64_t v1 = *(uint64_t (**)(void))(v3 + 8);
  return v1();
}

uint64_t sub_1B638F29C()
{
  return sub_1B6E33658();
}

uint64_t sub_1B638F2B4()
{
  return swift_deallocClassInstance();
}

void *sub_1B638F2C4(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  unsigned int v6 = *(void **)(a1 + 16);
  swift_arrayDestroy();

  return ecs_stack_allocator_deallocate(v6, a2, a4);
}

uint64_t sub_1B638F31C@<X0>(unsigned __int8 *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t result = sub_1B638F348(*a1);
  *a2 = result;
  return result;
}

uint64_t sub_1B638F348(uint64_t result)
{
  if (result >= 5u) {
    return 5;
  }
  else {
    return result;
  }
}

uint64_t sub_1B638F35C(uint64_t a1, uint64_t a2, void (*a3)(void))
{
  a3(*(void *)(a1 + 8));

  return swift_bridgeObjectRelease();
}

uint64_t destroy for GraphEntityComponentPropertyReferences.DirectPropertyAssignment(uint64_t a1, uint64_t a2)
{
  return sub_1B638F35C(a1, a2, MEMORY[0x1E4FBC898]);
}

uint64_t initializeWithCopy for TextureCache.WeakStorage.GPU(uint64_t a1, uint64_t a2)
{
  swift_unknownObjectWeakCopyInit();
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(void *)(a1 + 16) = v4;
  swift_unknownObjectRetain();
  return a1;
}

uint64_t destroy for MaterialRuntime(uint64_t a1)
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_release();

  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();

  return swift_unknownObjectRelease();
}

uint64_t sub_1B638F4B4()
{
  swift_unknownObjectRelease();
  swift_release();
  swift_release();

  return MEMORY[0x1F4186498](v0, 56, 7);
}

void sub_1B638F4FC(uint64_t a1)
{
  uint64_t v2 = sub_1B638F554();
  if (v2 && *(void *)(v2 + 24) == a1)
  {
    sub_1B638F728(1, 1);
  }
}

void *sub_1B638F554()
{
  if (qword_1EB988700 != -1) {
    dispatch_once(&qword_1EB988700, &unk_1F0FB5F28);
  }
  uint64_t v0 = pthread_getspecific(qword_1EB995F88);
  if (!v0)
  {
    uint64_t v0 = malloc_type_calloc(0x38uLL, 1uLL, 0x8757DDA3uLL);
    *((void *)v0 + 2) = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    *((unsigned char *)v0 + 32) = 0;
    pthread_setspecific(qword_1EB995F88, v0);
    sub_1B65C2580(1);
    os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB9965C8);
    uint64_t v1 = (void *)qword_1EB995F90;
    *((void *)v0 + 1) = qword_1EB995F90;
    if (v1) {
      *uint64_t v1 = v0;
    }
    qword_1EB995F90 = (uint64_t)v0;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB9965C8);
    if (!*((void *)v0 + 3))
    {
      Current = CFRunLoopGetCurrent();
      CFRunLoopMode v3 = CFRunLoopCopyCurrentMode(Current);
      uint64_t v4 = CFRunLoopObserverCreate(0, 0xA0uLL, 1u, 2000000, (CFRunLoopObserverCallBack)sub_1B638F4FC, 0);
      *((void *)v0 + 3) = v4;
      if (v4) {
        CFRunLoopAddObserver(Current, v4, (CFRunLoopMode)*MEMORY[0x1E4F1D410]);
      }
      if (v3)
      {
        if (*((void *)v0 + 3) && v3 != (CFRunLoopMode)*MEMORY[0x1E4F1D418])
        {
          if (!qword_1E9DDBC68 && CFEqual(v3, @"UITrackingRunLoopMode"))
          {
            qword_1E9DDBC68 = (uint64_t)CFRetain(v3);
            CFRunLoopAddObserver(Current, *((CFRunLoopObserverRef *)v0 + 3), v3);
          }
          if (v3 != (CFRunLoopMode)qword_1E9DDBC68) {
            CFRunLoopAddObserver(Current, *((CFRunLoopObserverRef *)v0 + 3), v3);
          }
        }
        CFRelease(v3);
      }
    }
  }
  return v0;
}

__n128 initializeWithCopy for ShapeDistribution(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u8[0] = a2[1].n128_u8[0];
  *a1 = result;
  return result;
}

void sub_1B638F728(int a1, int a2)
{
  if (!a2 || sub_1B638F7FC())
  {
    prof_beginFlame((uint64_t)"_CFXTransactionFlush", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/Transactions/CFXTransaction.c", 1027);
    if (a1)
    {
      if (qword_1EB9954E0 != -1) {
        dispatch_once(&qword_1EB9954E0, &unk_1F0FB6F28);
      }
      dispatch_async((dispatch_queue_t)qword_1EB9954D8, &unk_1F0FB6E88);
    }
    else
    {
      if (qword_1EB9954E0 != -1) {
        dispatch_once(&qword_1EB9954E0, &unk_1F0FB6F28);
      }
      dispatch_async_and_wait((dispatch_queue_t)qword_1EB9954D8, &unk_1F0FB6E88);
    }
    prof_endFlame();
  }
}

uint64_t sub_1B638F7FC()
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1EB9965C8);
  uint64_t v0 = qword_1EB995F90;
  if (qword_1EB995F90)
  {
    while (1)
    {
      uint64_t v1 = *(void *)(v0 + 40);
      if (v1)
      {
        uint64_t v2 = *(void *)(v1 + 32);
        if (v2)
        {
          if ((*(unsigned char *)(v2 + 60) & 2) != 0 || *(double *)(v2 + 40) != 0.0) {
            break;
          }
        }
      }
      uint64_t v0 = *(void *)(v0 + 8);
      if (!v0) {
        goto LABEL_7;
      }
    }
    uint64_t v3 = 1;
  }
  else
  {
LABEL_7:
    uint64_t v3 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1EB9965C8);
  return v3;
}

uint64_t storeEnumTagSinglePayload for Entity(uint64_t result, int a2, int a3)
{
  if (a2)
  {
    *(void *)__n128 result = (a2 - 1);
    if (!a3) {
      return result;
    }
    char v3 = 1;
  }
  else
  {
    if (!a3) {
      return result;
    }
    char v3 = 0;
  }
  *(unsigned char *)(result + 8) = v3;
  return result;
}

uint64_t sub_1B638F8A4()
{
  uint64_t v3 = *v0;
  swift_task_dealloc();
  swift_task_dealloc();
  swift_release();
  uint64_t v1 = *(uint64_t (**)(void))(v3 + 8);
  return v1();
}

uint64_t sub_1B638F9D8()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B638FA38()
{
  unint64_t result = qword_1EB97F078;
  if (!qword_1EB97F078)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F078);
  }
  return result;
}

uint64_t getEnumTagSinglePayload for DirtyReadPolicy(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFE) {
    goto LABEL_17;
  }
  if (a2 + 2 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 2) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 2;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 2;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 3;
  int v8 = v6 - 3;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

unsigned __int8 *sub_1B638FB1C@<X0>(unsigned __int8 *result@<X0>, unsigned char *a2@<X8>)
{
  unsigned int v2 = *result;
  if (v2 >= 3) {
    LOBYTE(v2) = 3;
  }
  *a2 = v2;
  return result;
}

uint64_t initializeWithTake for TextureCache.WeakStorage.GPU(uint64_t a1, uint64_t a2)
{
  uint64_t result = swift_unknownObjectWeakTakeInit();
  uint64_t v4 = *(void *)(a2 + 16);
  *(void *)(result + 8) = *(void *)(a2 + 8);
  *(void *)(result + 16) = v4;
  return result;
}

uint64_t storeEnumTagSinglePayload for TextureCache.CacheEntry(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFC)
  {
    *(_OWORD *)(result + 136) = 0u;
    *(_OWORD *)(result + 120) = 0u;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(unsigned char *)(result + 152) = 0;
    *(void *)uint64_t result = a2 - 253;
    if (a3 >= 0xFD) {
      *(unsigned char *)(result + 153) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFD) {
      *(unsigned char *)(result + 153) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 152) = -(char)a2;
    }
  }
  return result;
}

uint64_t sub_1B638FBCC()
{
  return MEMORY[0x1F4188298](sub_1B62A2784, 0, 0);
}

uint64_t sub_1B638FBE8()
{
  swift_release();
  return MEMORY[0x1F41881D0](v0 + 656, v0 + 4808, sub_1B638FBCC, v0 + 16);
}

uint64_t sub_1B638FC6C()
{
  return MEMORY[0x1F4188298](sub_1B638FBE8, 0, 0);
}

uint64_t sub_1B638FC88()
{
  uint64_t v1 = *(void *)(*(void *)v0 + 2672);
  *(void *)(*(void *)v0 + 5096) = v1;
  if (v1) {
    uint64_t v2 = sub_1B679B08C;
  }
  else {
    uint64_t v2 = sub_1B63850F8;
  }
  return MEMORY[0x1F4188298](v2, 0, 0);
}

uint64_t destroy for Bindings.Value.EnumInfo()
{
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t sub_1B638FDD8()
{
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();

  return swift_deallocClassInstance();
}

uint64_t sub_1B638FE68()
{
  sub_1B638FE9C();

  return swift_deallocClassInstance();
}

uint64_t sub_1B638FE9C()
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = *(void *)(v0 + 128);
  if (v2) {
    Swift::Int v3 = v2 - *(void *)(v0 + 136);
  }
  else {
    Swift::Int v3 = 0;
  }
  if (*(void *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_counters)) {
    vfx_counters.add(_:_:)(*(_DWORD *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_counters + 56), v3);
  }
  if (*(void *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_counters)) {
    vfx_counters.add(_:_:)(*(_DWORD *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_counters + 52), -1);
  }
  if (*(void *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_counters)) {
    vfx_counters.add(_:_:)(*(_DWORD *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_counters + 44), *(void *)(v0 + 240) - *(void *)(v0 + 232));
  }
  if (*(void *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_counters)) {
    vfx_counters.add(_:_:)(*(_DWORD *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_counters + 48), *(void *)(v0 + 232) - *(void *)(v0 + 240));
  }
  sub_1B6390078(*(void *)(v0 + 256), *(void *)(v0 + 240));
  uint64_t v4 = *(void *)(v0 + 144);
  uint64_t v5 = *(void *)(v0 + 152);
  int v6 = *(_DWORD *)(v0 + 160);
  char v7 = *(unsigned char *)(v0 + 164);
  int v8 = *(char **)(v1 + 152);
  swift_retain();
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *(void *)(v1 + 152) = v8;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    int v8 = sub_1B68C0634(0, *((void *)v8 + 2) + 1, 1, v8);
    *(void *)(v1 + 152) = v8;
  }
  unint64_t v11 = *((void *)v8 + 2);
  unint64_t v10 = *((void *)v8 + 3);
  if (v11 >= v10 >> 1) {
    int v8 = sub_1B68C0634(v10 > 1, v11 + 1, 1, v8);
  }
  *((void *)v8 + 2) = v11 + 1;
  uint64_t v12 = &v8[24 * v11];
  *((void *)v12 + 4) = v4;
  *((void *)v12 + 5) = v5;
  *((_DWORD *)v12 + 12) = v6;
  v12[52] = v7;
  *(void *)(v1 + 152) = v8;
  swift_release();
  uint64_t v13 = *(void **)(v0 + 192);
  if (v13)
  {
    uint64_t v14 = *(void **)(v0 + 208);
    free(v13);
    free(v14);
  }
  MEMORY[0x1BA9B84C0](*(void *)(v0 + 344), -1, -1);
  MEMORY[0x1BA9B84C0](*(void *)(v0 + 376), -1, -1);
  swift_release();
  swift_release();
  swift_release();
  return v0;
}

uint64_t sub_1B6390078(uint64_t result, uint64_t a2)
{
  if (a2 != result)
  {
    uint64_t v3 = *(void *)(v2 + 56);
    uint64_t v4 = *(void *)(v3 + 16);
    if (v4)
    {
      swift_retain();
      swift_retain_n();
      swift_retain();
      uint64_t v5 = v3 + 56;
      do
      {
        sub_1B633B0E8();
        v5 += 40;
        --v4;
      }
      while (v4);
      swift_release();
      swift_release();
      return swift_release_n();
    }
  }
  return result;
}

uint64_t getEnumTagSinglePayload for EntityManager.State(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFC) {
    goto LABEL_17;
  }
  if (a2 + 4 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 4) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 4;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 4;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 4;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 5;
  int v8 = v6 - 5;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

uint64_t destroy for RenderStates()
{
  swift_unknownObjectRelease();

  return swift_unknownObjectRelease();
}

void sub_1B639020C(simd_float4x4 *a1@<X0>, simd_float4x4 *a2@<X8>)
{
  *a2 = j____invert_f4(*a1);
}

__n128 initializeWithTake for ComputePipelineDescriptor(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t sub_1B6390264(uint64_t a1)
{
  free(*(void **)(a1 + 120));
  *(void *)(a1 + 120) = 0;
  unint64_t v9 = (void **)(a1 + 288);
  sub_1B639030C(&v9);
  int v2 = *(void **)(a1 + 264);
  if (v2)
  {
    *(void *)(a1 + 272) = v2;
    operator delete(v2);
  }
  long long v3 = *(void **)(a1 + 240);
  if (v3)
  {
    *(void *)(a1 + 248) = v3;
    operator delete(v3);
  }
  long long v4 = *(void **)(a1 + 216);
  if (v4)
  {
    *(void *)(a1 + 224) = v4;
    operator delete(v4);
  }
  uint64_t v5 = *(void **)(a1 + 192);
  if (v5)
  {
    *(void *)(a1 + 200) = v5;
    operator delete(v5);
  }
  unsigned int v6 = *(void **)(a1 + 168);
  if (v6)
  {
    *(void *)(a1 + 176) = v6;
    operator delete(v6);
  }
  BOOL v7 = *(void **)(a1 + 144);
  if (v7)
  {
    *(void *)(a1 + 152) = v7;
    operator delete(v7);
  }
  return a1;
}

void sub_1B639030C(void ***a1)
{
  int v2 = *a1;
  if (*v2)
  {
    sub_1B6427AF4((uint64_t *)v2);
    long long v3 = **a1;
    operator delete(v3);
  }
}

uint64_t sub_1B6390360(uint64_t a1)
{
  long long v4 = *(int **)(v1 + 16);
  uint64_t v5 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v5;
  *uint64_t v5 = v2;
  v5[1] = sub_1B638E3C8;
  unsigned int v6 = (uint64_t (*)(uint64_t, int *))((char *)&dword_1E9DCFEF0 + dword_1E9DCFEF0);
  return v6(a1, v4);
}

uint64_t sub_1B6390418(uint64_t a1, int *a2)
{
  unsigned int v6 = (uint64_t (*)(uint64_t))((char *)a2 + *a2);
  long long v4 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v4;
  *long long v4 = v2;
  v4[1] = sub_1B638F878;
  return v6(a1);
}

uint64_t sub_1B63904F4()
{
  if (qword_1EB9811B0 != -1) {
    swift_once();
  }
  *(void *)(v0 + 16) = *(void *)(v0 + 32);
  uint64_t v1 = swift_task_alloc();
  *(void *)(v0 + 56) = v1;
  *(_OWORD *)(v1 + 16) = *(_OWORD *)(v0 + 40);
  swift_retain();
  uint64_t v2 = (void *)swift_task_alloc();
  *(void *)(v0 + 64) = v2;
  *uint64_t v2 = v0;
  v2[1] = sub_1B638F8A4;
  uint64_t v3 = *(void *)(v0 + 24);
  return MEMORY[0x1F41881B8](v3, v0 + 16, &unk_1E9DCFF08, v1, 0, 0, 0xD000000000000014, 0x80000001B6F34EA0);
}

uint64_t sub_1B6390658(uint64_t a1)
{
  uint64_t v4 = *(void *)(v1 + 48);
  uint64_t v5 = swift_task_alloc();
  long long v6 = *(_OWORD *)(v1 + 32);
  *(void *)(v2 + 16) = v5;
  *(void *)uint64_t v5 = v2;
  *(void *)(v5 + 8) = sub_1B638E3C8;
  *(void *)(v5 + 48) = v4;
  *(_OWORD *)(v5 + 32) = v6;
  *(void *)(v5 + 24) = a1;
  return MEMORY[0x1F4188298](sub_1B63904F4, 0, 0);
}

uint64_t sub_1B639071C(uint64_t a1)
{
  uint64_t v4 = *(int **)(v1 + 16);
  uint64_t v5 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v5;
  *uint64_t v5 = v2;
  v5[1] = sub_1B638E3C8;
  uint64_t v8 = (uint64_t (*)(uint64_t))((char *)v4 + *v4);
  long long v6 = (void *)swift_task_alloc();
  v5[2] = v6;
  *long long v6 = v5;
  v6[1] = sub_1B638F1A4;
  return v8(a1);
}

uint64_t type metadata accessor for VFXScene(uint64_t a1)
{
  return sub_1B633A29C(a1, (uint64_t *)&unk_1EB9812C0);
}

uint64_t sub_1B6390860(void *a1, void *a2, _OWORD *a3)
{
  uint64_t v4 = v3;
  *(unsigned char *)(v3 + 32) = 0;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 88) = 0u;
  *(_OWORD *)(v3 + 104) = 0u;
  *(_OWORD *)(v3 + 120) = 0u;
  *(_OWORD *)(v3 + 136) = 0u;
  uint64_t v8 = (_DWORD *)swift_slowAlloc();
  *uint64_t v8 = 0;
  *(void *)(v3 + 152) = "Renderer.renderOutputs";
  *(void *)(v3 + 160) = 22;
  *(unsigned char *)(v3 + 168) = 2;
  *(void *)(v3 + 176) = v8;
  uint64_t v9 = (_DWORD *)swift_slowAlloc();
  *uint64_t v9 = 0;
  *(void *)(v3 + 184) = "Renderer.uploadLock";
  *(void *)(v3 + 192) = 19;
  *(unsigned char *)(v3 + 200) = 2;
  uint64_t v10 = MEMORY[0x1E4FBC860];
  *(void *)(v4 + 208) = v9;
  *(void *)(v4 + 216) = v10;
  *(void *)(v4 + 224) = v10;
  *(unsigned char *)(v4 + 304) = 0;
  *(_DWORD *)(v4 + 320) = 0;
  *(unsigned char *)(v4 + 324) = 1;
  unint64_t v11 = (_DWORD *)swift_slowAlloc();
  *unint64_t v11 = 0;
  *(void *)(v4 + 328) = "unscheduledCommandBuffersLock";
  *(void *)(v4 + 336) = 29;
  *(unsigned char *)(v4 + 344) = 2;
  uint64_t v12 = MEMORY[0x1E4FBC870];
  *(void *)(v4 + 352) = v11;
  *(void *)(v4 + 360) = v12;
  *(_OWORD *)(v4 + 368) = 0u;
  *(_OWORD *)(v4 + 384) = 0u;
  *(void *)(v4 + 400) = v10;
  *(_OWORD *)(v4 + 408) = 0u;
  *(_OWORD *)(v4 + 424) = 0u;
  *(_OWORD *)(v4 + 440) = 0u;
  *(_OWORD *)(v4 + 456) = 0u;
  *(_OWORD *)(v4 + 472) = 0u;
  *(void *)(v4 + 488) = 1;
  *(void *)(v4 + 512) = v10;
  *(void *)(v4 + 528) = dispatch_semaphore_create(3);
  sub_1B637B628(v46);
  sub_1B6388B3C((uint64_t)v46, v4 + 624);
  *(void *)(v4 + 784) = v10;
  uint64_t v13 = (void *)sub_1B6E31C98();
  v13[2] = 3;
  v13[5] = 0;
  v13[6] = 0;
  v13[4] = 0;
  *(void *)(v4 + 792) = v13;
  *(void *)(v4 + 824) = 0;
  *(void *)(v4 + 832) = 0;
  *(void *)(v4 + 816) = 0;
  *(void *)(v4 + 840) = sub_1B639A2F4(v10);
  *(void *)(v4 + 848) = sub_1B639A64C(v10);
  if (a1)
  {
    uint64_t v14 = a1;
  }
  else
  {
    if (a2) {
      id v15 = objc_msgSend(a2, sel_device);
    }
    else {
      id v15 = MTLCreateSystemDefaultDevice();
    }
    uint64_t v14 = v15;
  }
  *(void *)(v4 + 16) = v14;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  BOOL v16 = (void *)swift_slowAlloc();
  *(void *)(v4 + 496) = v16;
  *(void *)(v4 + 504) = 1;
  *BOOL v16 = 0;
  uint64_t v17 = objc_msgSend((id)swift_unknownObjectRetain(), sel_supportsVertexAmplificationCount_, 2);
  if (objc_msgSend(v14, sel_supportsFamily_, 5001)) {
    v17 |= 2uLL;
  }
  if (objc_msgSend(v14, sel_supportsMeshShaders)) {
    uint64_t v18 = v17 | 4;
  }
  else {
    uint64_t v18 = v17;
  }
  unsigned int v19 = objc_msgSend(v14, sel_supportsDepthClipMode);
  swift_unknownObjectRelease();
  uint64_t v20 = v18 | 8;
  if (!v19) {
    uint64_t v20 = v18;
  }
  *(void *)(v4 + 24) = v20;
  uint64_t v21 = *(void **)(v4 + 16);
  *(void *)(v4 + 520) = objc_msgSend(objc_allocWithZone(MEMORY[0x1E4F353B0]), sel_initWithDevice_, v21);
  *(void *)(v4 + 280) = objc_msgSend(v14, sel_newBufferWithLength_options_, 1024, 0);
  if (a2)
  {
    id v22 = a2;
  }
  else
  {
    id v22 = objc_msgSend(v21, sel_newCommandQueue);
    unint64_t v23 = (void *)sub_1B6E31768();
    objc_msgSend(v22, sel_setLabel_, v23);
  }
  *(void *)(v4 + 312) = v22;
  swift_unknownObjectRetain();
  sub_1B6395274(v22);
  uint64_t v24 = swift_unknownObjectRetain();
  uint64_t v25 = sub_1B63BCCA4(v24);
  swift_unknownObjectRelease();
  *(void *)(v4 + 232) = v25;
  uint64_t v26 = swift_unknownObjectRetain();
  uint64_t v27 = sub_1B63BB61C(v26);
  swift_unknownObjectRelease();
  *(void *)(v4 + 240) = v27;
  uint64_t v28 = swift_unknownObjectRetain();
  uint64_t v29 = sub_1B63B69BC(v28);
  swift_unknownObjectRelease();
  *(void *)(v4 + 248) = v29;
  uint64_t v30 = *(void *)(v4 + 16);
  sub_1B63BC3F8();
  swift_allocObject();
  uint64_t v31 = swift_unknownObjectRetain();
  *(void *)(v4 + 264) = sub_1B63BC458(v31);
  type metadata accessor for ColorRampCache();
  uint64_t v32 = swift_allocObject();
  uint64_t v33 = MEMORY[0x1E4FBC860];
  *(void *)(v32 + 16) = sub_1B6399F50(MEMORY[0x1E4FBC860]);
  *(void *)(v32 + 24) = sub_1B6390E70(v33);
  swift_weakInit();
  *(void *)(v4 + 800) = v32;
  type metadata accessor for CurveCache();
  uint64_t v34 = swift_allocObject();
  *(void *)(v34 + 16) = sub_1B6390E70(v33);
  swift_weakInit();
  *(void *)(v4 + 808) = v34;
  uint64_t v35 = (uint64_t)objc_msgSend(v14, sel_minConstantBufferAlignmentBytes);
  if (v35 <= 16) {
    uint64_t v36 = 16;
  }
  else {
    uint64_t v36 = v35;
  }
  type metadata accessor for BufferPool();
  swift_allocObject();
  swift_unknownObjectRetain();
  *(void *)(v4 + 288) = sub_1B6390F3C(0x6F507265646E6552, 0xEA00000000006C6FLL, v30, 0, v36);
  swift_allocObject();
  swift_unknownObjectRetain();
  *(void *)(v4 + 296) = sub_1B6390F3C(0x617246656C6F6857, 0xEE006C6F6F50656DLL, v30, 0, v36);
  uint64_t v37 = *(void *)(v4 + 312);
  uint64_t v38 = *(void *)(v4 + 232);
  uint64_t v39 = (objc_class *)type metadata accessor for GPUHelper();
  unint64_t v40 = (char *)objc_allocWithZone(v39);
  *(void *)&v40[OBJC_IVAR____TtC3VFX9GPUHelper_shaderCache] = v38;
  *(void *)&v40[OBJC_IVAR____TtC3VFX9GPUHelper_device] = v30;
  *(void *)&v40[OBJC_IVAR____TtC3VFX9GPUHelper_commandQueue] = v37;
  v45.receiver = v40;
  v45.super_class = v39;
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_retain();
  *(void *)(v4 + 256) = objc_msgSendSuper2(&v45, sel_init);
  long long v41 = a3[3];
  *(_OWORD *)(v4 + 568) = a3[2];
  *(_OWORD *)(v4 + 584) = v41;
  *(_OWORD *)(v4 + 600) = a3[4];
  long long v42 = a3[1];
  *(_OWORD *)(v4 + 536) = *a3;
  *(_OWORD *)(v4 + 552) = v42;
  type metadata accessor for RenderGraph();
  swift_allocObject();
  unint64_t v43 = sub_1B63BCF58();
  *(void *)(v4 + 272) = v43;
  v43[2] = v4;
  swift_weakAssign();
  swift_weakAssign();
  swift_weakAssign();
  sub_1B6382348();
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  return v4;
}

void *sub_1B6390E70(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return (void *)MEMORY[0x1E4FBC868];
  }
  sub_1B67F9B2C();
  uint64_t v3 = (void *)sub_1B6E32C58();
  uint64_t v4 = (uint64_t *)(a1 + 40);
  do
  {
    uint64_t v5 = *(v4 - 1);
    uint64_t v6 = *v4;
    unint64_t v7 = sub_1B62C1A30(v5);
    *(void *)((char *)v3 + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v7;
    uint64_t v8 = 8 * v7;
    *(void *)(v3[6] + v8) = v5;
    *(void *)(v3[7] + v8) = v6;
    ++v3[2];
    swift_unknownObjectRetain();
    v4 += 2;
    --v1;
  }
  while (v1);
  return v3;
}

uint64_t sub_1B6390F3C(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  unint64_t v11 = (_DWORD *)swift_slowAlloc();
  *unint64_t v11 = 0;
  *(void *)(v5 + 32) = "BufferPool";
  *(void *)(v5 + 40) = 10;
  *(unsigned char *)(v5 + 48) = 2;
  uint64_t v12 = MEMORY[0x1E4FBC860];
  *(void *)(v5 + 56) = v11;
  *(void *)(v5 + 64) = v12;
  *(void *)(v5 + 72) = v12;
  *(void *)(v5 + 80) = 0;
  *(void *)(v5 + 104) = 0;
  *(void *)(v5 + 112) = 0;
  *(void *)(v5 + 120) = v12;
  *(unsigned char *)(v5 + 136) = 1;
  *(void *)(v5 + 16) = a3;
  *(void *)(v5 + 88) = a1;
  *(void *)(v5 + 96) = a2;
  swift_unknownObjectRetain();
  uint64_t v13 = swift_slowAlloc();
  *(void *)(v5 + 144) = v13;
  *(void *)(v5 + 152) = 1;
  *(void *)(v13 + 8) = 0;
  *(void *)(v13 + 16) = 0;
  *(void *)uint64_t v13 = 0;
  *(_OWORD *)(v13 + 32) = 0u;
  *(_OWORD *)(v13 + 48) = 0u;
  *(_OWORD *)(v13 + 64) = 0u;
  *(_OWORD *)(v13 + 80) = 0u;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 120;
  bzero((void *)(v14 + 32), 0x3C0uLL);
  swift_unknownObjectRelease();
  *(void *)(v5 + 120) = v14;
  swift_bridgeObjectRelease();
  *(unsigned char *)(v5 + 24) = a4;
  *(void *)(v5 + 128) = a5;
  return v5;
}

uint64_t getEnumTagSinglePayload for TextureCache.StorageKind(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFF) {
    goto LABEL_17;
  }
  if (a2 + 1 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 1) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 1;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 1;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 2;
  int v8 = v6 - 2;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

uint64_t sub_1B63910D8()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B6391138()
{
  unint64_t result = qword_1EB97F870;
  if (!qword_1EB97F870)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F870);
  }
  return result;
}

uint64_t initializeWithCopy for ParticleColorOverLife(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(_WORD *)(a1 + 24) = *(_WORD *)(a2 + 24);
  *(void *)(a1 + 28) = *(void *)(a2 + 28);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t sub_1B63911DC()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B639123C()
{
  unint64_t result = qword_1EB97F688;
  if (!qword_1EB97F688)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F688);
  }
  return result;
}

uint64_t sub_1B6391290()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B63912F0()
{
  unint64_t result = qword_1EB97F450;
  if (!qword_1EB97F450)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F450);
  }
  return result;
}

uint64_t sub_1B6391344()
{
  uint64_t v1 = *v0;
  unsigned __int8 v2 = *((unsigned char *)v0 + 4);
  sub_1B6E33918();
  sub_1B6391394((uint64_t)v4, v1 | ((unint64_t)v2 << 32));
  return sub_1B6E33988();
}

uint64_t sub_1B6391394(uint64_t a1, uint64_t a2)
{
  if ((a2 & 0x100000000) != 0) {
    return sub_1B6E33928();
  }
  sub_1B6E33928();
  return sub_1B6E33958();
}

uint64_t sub_1B6391400(uint64_t a1)
{
  return a1;
}

uint64_t destroy for PrivateCommandQueue.Operation(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int8 *)(a1 + 40);
  if (v1 >= 5) {
    unsigned int v1 = *(_DWORD *)a1 + 5;
  }
  if ((v1 & 0xFFFFFFFE) == 2) {
    return _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0(a1);
  }
  return a1;
}

uint64_t sub_1B639147C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  if (*(void *)(a1 + 16) == 1)
  {
    sub_1B63B2978(a1 + 32, (uint64_t)v40);
    sub_1B639192C((uint64_t)v40, (uint64_t)v38);
    switch(v39)
    {
      case 1:
        long long v10 = v38[0];
        sub_1B639192C((uint64_t)v40, (uint64_t)v34);
        unint64_t v11 = v41;
        uint64_t v12 = v42;
        uint64_t v13 = v43;
        uint64_t v35 = v41;
        uint64_t v36 = v42;
        uint64_t v37 = v43;
        sub_1B6391400((uint64_t)v34);
        sub_1B6660D84(v10, *((uint64_t *)&v10 + 1), v11, v12, v13, v2, *(unsigned char *)(v2 + 112));
        goto LABEL_11;
      case 2:
        sub_1B62C15C4(v38, (uint64_t)v34);
        uint64_t v14 = v41;
        uint64_t v15 = v42;
        uint64_t v16 = v43;
        int v17 = *(_DWORD *)(a2 + 24);
        swift_retain();
        sub_1B62C1550((uint64_t)v34, (uint64_t)v32);
        uint64_t v31 = 0;
        memset(v30, 0, sizeof(v30));
        signed int v18 = sub_1B637F628(v17, 0, 0, 0, 0, (uint64_t)v32, (uint64_t)v30);
        swift_release();
        uint64_t v19 = MEMORY[0x1E4FBB718];
        sub_1B6B28984((uint64_t)v30, (uint64_t)&qword_1EB97E850, (uint64_t)sub_1B63B8BE4, MEMORY[0x1E4FBB718], (uint64_t (*)(void))sub_1B63BDE98);
        sub_1B6B28984((uint64_t)v32, (uint64_t)&qword_1EB97E850, (uint64_t)sub_1B63B8BE4, v19, (uint64_t (*)(void))sub_1B63BDE98);
        sub_1B63B325C(v14, v15, v16, v18);
        _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v34);
        goto LABEL_9;
      case 3:
        sub_1B62C15C4(v38, (uint64_t)v34);
        uint64_t v20 = v41;
        uint64_t v21 = v42;
        uint64_t v22 = v43;
        int v23 = *(_DWORD *)(a2 + 24);
        swift_retain();
        uint64_t v33 = 0;
        memset(v32, 0, sizeof(v32));
        sub_1B62C1550((uint64_t)v34, (uint64_t)v30);
        signed int v24 = sub_1B637F628(v23, 0, 0, 0, 0, (uint64_t)v32, (uint64_t)v30);
        swift_release();
        uint64_t v25 = MEMORY[0x1E4FBB718];
        sub_1B6B28984((uint64_t)v30, (uint64_t)&qword_1EB97E850, (uint64_t)sub_1B63B8BE4, MEMORY[0x1E4FBB718], (uint64_t (*)(void))sub_1B63BDE98);
        sub_1B6B28984((uint64_t)v32, (uint64_t)&qword_1EB97E850, (uint64_t)sub_1B63B8BE4, v25, (uint64_t (*)(void))sub_1B63BDE98);
        sub_1B63B325C(v20, v21, v22, v24);
        _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v34);
LABEL_11:
        uint64_t result = sub_1B63B28BC((uint64_t)v40, (uint64_t (*)(void))sub_1B63B29DC);
        *(void *)(v2 + 152) += *(void *)(a2 + 240) - *(void *)(a2 + 232);
        return result;
      case 4:
        sub_1B6B1BAEC(LOBYTE(v38[0]), v41, v42, v43);
        return sub_1B63B28BC((uint64_t)v40, (uint64_t (*)(void))sub_1B63B29DC);
      case 5:
        sub_1B639192C((uint64_t)v40, (uint64_t)v34);
        uint64_t v26 = v41;
        uint64_t v27 = v42;
        uint64_t v28 = v43;
        uint64_t v35 = v41;
        uint64_t v36 = v42;
        uint64_t v37 = v43;
        if (v41)
        {
          sub_1B6391400((uint64_t)v34);
          sub_1B6B1BA20(v26, v27, v28);
          uint64_t result = sub_1B63B28BC((uint64_t)v40, (uint64_t (*)(void))sub_1B63B29DC);
          uint64_t v29 = *(void *)(v3 + 160) + v28;
        }
        else
        {
          sub_1B6391400((uint64_t)v34);
          sub_1B6660CA8(*(void *)(a2 + 232), *(void *)(a2 + 240));
          uint64_t result = sub_1B63B28BC((uint64_t)v40, (uint64_t (*)(void))sub_1B63B29DC);
          uint64_t v29 = *(void *)(a2 + 240) - *(void *)(a2 + 232) + *(void *)(v3 + 160);
        }
        *(void *)(v3 + 160) = v29;
        return result;
      default:
        long long v5 = v38[0];
        sub_1B639192C((uint64_t)v40, (uint64_t)v34);
        unsigned int v6 = v41;
        uint64_t v7 = v42;
        uint64_t v8 = v43;
        uint64_t v35 = v41;
        uint64_t v36 = v42;
        uint64_t v37 = v43;
        sub_1B6391400((uint64_t)v34);
        sub_1B63861B4(v5, *((uint64_t *)&v5 + 1), v6, v7, v8);
LABEL_9:
        uint64_t result = sub_1B63B28BC((uint64_t)v40, (uint64_t (*)(void))sub_1B63B29DC);
        *(void *)(v2 + 144) += *(void *)(a2 + 240) - *(void *)(a2 + 232);
        break;
    }
  }
  else
  {
    return sub_1B6B1D1B4(a1, (void *)a2);
  }
  return result;
}

uint64_t sub_1B639192C(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t initializeWithCopy for PrivateCommandQueue.Operation(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(unsigned __int8 *)(a2 + 40);
  if (v3 >= 5) {
    unsigned int v3 = *(_DWORD *)a2 + 5;
  }
  switch(v3)
  {
    case 0u:
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(unsigned char *)(a1 + 40) = 0;
      return a1;
    case 1u:
      *(_OWORD *)a1 = *(_OWORD *)a2;
      char v5 = 1;
      goto LABEL_10;
    case 2u:
      long long v6 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v6;
      (**(void (***)(uint64_t))(v6 - 8))(a1);
      char v5 = 2;
      goto LABEL_10;
    case 3u:
      long long v7 = *(_OWORD *)(a2 + 24);
      *(_OWORD *)(a1 + 24) = v7;
      (**(void (***)(uint64_t))(v7 - 8))(a1);
      char v5 = 3;
      goto LABEL_10;
    case 4u:
      *(unsigned char *)a1 = *(unsigned char *)a2;
      char v5 = 4;
LABEL_10:
      *(unsigned char *)(a1 + 40) = v5;
      break;
    default:
      long long v4 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)(a1 + 16) = v4;
      *(_OWORD *)(a1 + 25) = *(_OWORD *)(a2 + 25);
      break;
  }
  return a1;
}

uint64_t sub_1B6391AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t *a11, uint64_t a12, void *a13, int a14, __int16 a15, __int16 a16, char a17)
{
  uint64_t v21 = a1;
  char v22 = a17;
  uint64_t v69 = *(void *)(a1 + 128);
  swift_retain();
  uint64_t v23 = a3 - a2;
  if (a3 != a2)
  {
    uint64_t v24 = *(void *)(a5[5] + 24);
    uint64_t v25 = *(void *)(v24 + 16);
    uint64_t v68 = a5;
    if (v25)
    {
      uint64_t v64 = a6;
      uint64_t v65 = a3;
      uint64_t v66 = v21;
      uint64_t v26 = v24 + 32;
      uint64_t v27 = *(void *)(a6 + 24);
      uint64_t v28 = *(void *)(v27 + 16);
      uint64_t v29 = (void *)(v27 + 56);
      swift_retain();
      for (uint64_t i = 0; i != v25; ++i)
      {
        if (v28)
        {
          uint64_t v31 = (uint64_t *)(v26 + 40 * i);
          uint64_t v32 = *v31;
          uint64_t v34 = v31[2];
          uint64_t v33 = v31[3];
          int v35 = *((unsigned __int8 *)v31 + 32);
          uint64_t v36 = v29;
          uint64_t v37 = v28;
          while (*(v36 - 3) != v32)
          {
            v36 += 5;
            if (!--v37) {
              goto LABEL_4;
            }
          }
          if (!a9 || v32 != a9)
          {
            uint64_t v38 = (const void *)(a12 + v33 + *a11 * v34);
            char v39 = (void *)(v69 + *v36 + v34 * a2);
            Swift::Int v40 = v34 * v23;
            if (v35)
            {
              memmove(v39, v38, v34 * v23);
            }
            else
            {
              sub_1B6391F80((uint64_t)v38, (uint64_t)v39, v23);
              a5 = v68;
            }
            uint64_t v41 = a5[2] + OBJC_IVAR____TtC3VFX13EntityManager_counters;
            if (*(void *)v41) {
              vfx_counters.add(_:_:)(*(_DWORD *)(v41 + 64), v40);
            }
          }
        }
LABEL_4:
        ;
      }
      swift_release();
      a3 = v65;
      uint64_t v21 = v66;
      a6 = v64;
      char v22 = a17;
    }
    if (a9)
    {
      uint64_t v42 = *(void *)(a6 + 24);
      uint64_t v43 = *(void *)(v42 + 16);
      if (v43)
      {
        uint64_t v44 = (unsigned char *)(v42 + 64);
        while (*((void *)v44 - 4) != a9)
        {
          v44 += 40;
          if (!--v43) {
            goto LABEL_23;
          }
        }
      }
      else
      {
LABEL_23:
        v70[0] = 0;
        v70[1] = 0xE000000000000000;
        a5 = v70;
        sub_1B6E328C8();
        sub_1B6E31948();
        sub_1B6E33B48();
        uint64_t v21 = v45;
        sub_1B6E31948();
        swift_bridgeObjectRelease();
        sub_1B6E31948();
        type metadata accessor for EntityClass();
        sub_1B6E32B18();
        sub_1B6E32BE8();
        __break(1u);
      }
      uint64_t v46 = *((void *)v44 - 2);
      if (*v44 == 1)
      {
        memmove((void *)(v69 + *((void *)v44 - 1) + v46 * a2), (const void *)(a7 + *a13 * v46), v46 * v23);
      }
      else
      {
        sub_1B6391F80(a7 + *a13 * v46, v69 + *((void *)v44 - 1) + v46 * a2, v23);
        a5 = v68;
      }
    }
    if ((a5[23] & 1) == 0)
    {
      uint64_t v47 = 0;
      uint64_t v48 = a5[21];
      uint64_t v49 = a5[2];
      do
      {
        __int16 v50 = a2 + v47;
        uint64_t v51 = v47 + 1;
        uint64_t v52 = *(void *)(v49 + OBJC_IVAR____TtC3VFX13EntityManager__entries) + 12 * *(int *)(v48 + 4 * (v47 + *a11));
        *(_DWORD *)uint64_t v52 = *(_DWORD *)(v21 + 188);
        *(_WORD *)(v52 + 4) = v50;
        *(_WORD *)(v52 + 6) = a15;
        uint64_t v47 = v51;
      }
      while (v23 != v51);
    }
    *a13 += v23;
    uint64_t v53 = *a11;
    *a11 += v23;
    if (v22)
    {
      uint64_t v54 = *(void *)(v21 + 192);
      if (v54) {
        sub_1B6BFB3E4(a2, a3, 0, 0, 1, v54, *(void *)(v21 + 200), *(void *)(v21 + 208));
      }
      sub_1B63658B4(*(void *)(v21 + 40), v21, a2, a3);
    }
    else if (*(unsigned char *)(a6 + 212) == 1)
    {
      uint64_t v55 = a5[24];
      uint64_t v56 = a5[26];
      uint64_t v57 = *(void *)(v21 + 192);
      uint64_t v58 = a2;
      uint64_t v59 = v53;
      uint64_t v60 = *(void *)(v21 + 208);
      do
      {
        uint64_t v61 = *(void *)(v55 + 8 * (v59 >> 6));
        if (((1 << v59) & v61) != 0)
        {
          *(void *)(v55 + 8 * (v59 >> 6)) = v61 & ~(1 << v59);
          *(void *)(v57 + 8 * (v58 >> 6)) |= 1 << v58;
        }
        ++v58;
        ++v59;
      }
      while (a3 != v58);
      do
      {
        uint64_t v62 = *(void *)(v56 + 8 * (v53 >> 6));
        if (((1 << v53) & v62) != 0)
        {
          *(void *)(v56 + 8 * (v53 >> 6)) = v62 & ~(1 << v53);
          *(void *)(v60 + 8 * (a2 >> 6)) |= 1 << a2;
        }
        ++a2;
        ++v53;
      }
      while (a3 != a2);
    }
  }

  return swift_release();
}

uint64_t sub_1B6391F80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F41845F0](a1, a3, a2);
}

uint64_t destroy for ParticleColorInit()
{
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t sub_1B6391FCC@<X0>(unsigned __int8 *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t result = sub_1B6391FF8(*a1);
  *a2 = result;
  return result;
}

uint64_t sub_1B6391FF8(uint64_t result)
{
  if (result >= 7u) {
    return 7;
  }
  else {
    return result;
  }
}

uint64_t destroy for StringCodingKeys()
{
  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for StringCodingKeys(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v3;
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t sub_1B6392054()
{
  return *(void *)v0;
}

uint64_t sub_1B6392060()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B63920C0()
{
  unint64_t result = qword_1EB97ECA0;
  if (!qword_1EB97ECA0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97ECA0);
  }
  return result;
}

uint64_t sub_1B6392114()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B6392174()
{
  unint64_t result = qword_1EB97EA08;
  if (!qword_1EB97EA08)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97EA08);
  }
  return result;
}

void destroy for ShaderFileAsset(uint64_t a1)
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v2 = *(void **)(a1 + 32);
}

uint64_t getEnumTagSinglePayload for RenderContext(uint64_t *a1, int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0 && *((unsigned char *)a1 + 144)) {
    return *(_DWORD *)a1 + 0x80000000;
  }
  uint64_t v2 = *a1;
  if ((unint64_t)*a1 >= 0xFFFFFFFF) {
    LODWORD(v2) = -1;
  }
  return (v2 + 1);
}

unsigned char *sub_1B639225C@<X0>(unsigned char *result@<X0>, char *a2@<X8>)
{
  if (*result == 1) {
    char v2 = 1;
  }
  else {
    char v2 = 2;
  }
  if (*result) {
    char v3 = v2;
  }
  else {
    char v3 = 0;
  }
  *a2 = v3;
  return result;
}

uint64_t destroy for ShaderCache.SpecializedFunction()
{
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t sub_1B63922D0()
{
  char v2 = *(unsigned char *)(v0 + 840);
  uint64_t v3 = *(void *)(v0 + 848);
  uint64_t v4 = swift_task_alloc();
  long long v5 = *(_OWORD *)(v0 + 16);
  *(void *)(v1 + 16) = v4;
  *(void *)uint64_t v4 = v1;
  *(void *)(v4 + 8) = sub_1B638E234;
  *(void *)(v4 + 4856) = v3;
  *(unsigned char *)(v4 + 3569) = v2;
  *(void *)(v4 + 4848) = v0 + 32;
  *(_OWORD *)(v4 + 4832) = v5;
  return MEMORY[0x1F4188298](sub_1B63120B0, 0, 0);
}

uint64_t sub_1B639239C()
{
  uint64_t v1 = *(void **)(v0 + 32);
  uint64_t v2 = v1[20];
  if (v2)
  {
    uint64_t v3 = *(void *)(v0 + 40);
    uint64_t v5 = v1[21];
    uint64_t v4 = v1[22];
    *(void *)(v0 + 48) = v4;
    if (v4) {
      uint64_t v6 = v4;
    }
    else {
      uint64_t v6 = MEMORY[0x1E4FBC860];
    }
    swift_bridgeObjectRetain();
    uint64_t v7 = sub_1B62F3064(0, (unint64_t *)&unk_1EB9804C0);
    uint64_t v8 = swift_task_alloc();
    *(void *)(v0 + 56) = v8;
    *(void *)(v8 + 16) = v2;
    *(void *)(v8 + 24) = v3;
    *(void *)(v8 + 32) = v5;
    *(void *)(v8 + 40) = v6;
    *(unsigned char *)(v8 + 48) = 1;
    sub_1B62D8B50(0, &qword_1EB980348, (unint64_t *)&unk_1EB9804C0, (uint64_t)&protocolRef_MTLFunction, MEMORY[0x1E4FBB320]);
    uint64_t v10 = v9;
    unint64_t v11 = (void *)swift_task_alloc();
    *(void *)(v0 + 64) = v11;
    *unint64_t v11 = v0;
    v11[1] = sub_1B679B950;
    return MEMORY[0x1F4188080](v0 + 16, v7, v10, 0, 0, &unk_1E9DCFFF8, v8, v7);
  }
  else
  {
    **(void **)(v0 + 24) = 0;
    uint64_t v12 = *(uint64_t (**)(void))(v0 + 8);
    return v12();
  }
}

uint64_t sub_1B6392578(uint64_t a1)
{
  uint64_t v4 = v1 + 16;
  uint64_t v5 = *(void *)(v1 + 824);
  uint64_t v6 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v6;
  *uint64_t v6 = v2;
  v6[1] = sub_1B638E3C8;
  v6[4] = v4;
  v6[5] = v5;
  v6[3] = a1;
  return MEMORY[0x1F4188298](sub_1B639239C, 0, 0);
}

uint64_t sub_1B6392638()
{
  **(void **)(v0 + 16) = *(void *)(v0 + 32);
  return (*(uint64_t (**)(void))(v0 + 8))();
}

uint64_t sub_1B639265C(uint64_t a1)
{
  uint64_t v4 = *v2;
  uint64_t v5 = *v2;
  swift_task_dealloc();
  if (v1)
  {
    uint64_t v6 = *(uint64_t (**)(void))(v5 + 8);
    return v6();
  }
  else
  {
    *(void *)(v4 + 32) = a1;
    return MEMORY[0x1F4188298](sub_1B6392638, 0, 0);
  }
}

uint64_t sub_1B63927A8()
{
  *(void *)(*(void *)v1 + 664) = v0;
  swift_task_dealloc();
  if (v0) {
    uint64_t v2 = sub_1B67961CC;
  }
  else {
    uint64_t v2 = sub_1B638420C;
  }
  return MEMORY[0x1F4188298](v2, 0, 0);
}

uint64_t sub_1B63928BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  *(void *)(v6 + 504) = a4;
  *(void *)(v6 + 512) = v5;
  *(unsigned char *)(v6 + 65) = a5;
  *(void *)(v6 + 488) = a2;
  *(void *)(v6 + 496) = a3;
  *(void *)(v6 + 480) = a1;
  sub_1B638BF2C(0, (unint64_t *)&unk_1EB980390, MEMORY[0x1E4FBCFE8]);
  *(void *)(v6 + 520) = swift_task_alloc();
  *(void *)(v6 + 528) = swift_task_alloc();
  return MEMORY[0x1F4188298](sub_1B629E2CC, 0, 0);
}

double (*sub_1B6392984(void *a1))(void)
{
  uint64_t v2 = v1;
  uint64_t v4 = (uint64_t)(a1 + 1);
  sub_1B6392A14(v2, (uint64_t)(a1 + 1));
  sub_1B6392A14(v4, (uint64_t)a1);
  if (*a1) {
    return nullsub_1;
  }
  else {
    return j_nullsub_1;
  }
}

uint64_t sub_1B6392A14(uint64_t a1, uint64_t a2)
{
  sub_1B6392AA4(0, (unint64_t *)&unk_1EB980100, &qword_1EB9800F8, MEMORY[0x1E4FBC150], MEMORY[0x1E4FBB078]);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

void sub_1B6392AA4(uint64_t a1, unint64_t *a2, unint64_t *a3, uint64_t a4, uint64_t (*a5)(void, uint64_t))
{
  if (!*a2)
  {
    sub_1B68EAB9C(255, a3, a4, a5);
    unint64_t v6 = sub_1B6E324B8();
    if (!v7) {
      atomic_store(v6, a2);
    }
  }
}

void *vfx_script_color_ramp_destroy(uint64_t a1, unint64_t a2)
{
  return sub_1B638F2C4(a1, a2, (uint64_t)&type metadata for ColorRamp, 0x18uLL);
}

uint64_t vfx_script_get_iteration_range(uint64_t result, _DWORD *a2, _DWORD *a3)
{
  uint64_t v3 = *(void *)(result + 32);
  *a2 = *(void *)(result + 24);
  *a3 = v3;
  return result;
}

_DWORD *initializeBufferWithCopyOfBuffer for AudioAnalyzer(_DWORD *result, _DWORD *a2)
{
  void *result = *a2;
  return result;
}

uint64_t initializeBufferWithCopyOfBuffer for REFrameConfiguration(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *(_WORD *)(result + 8) = *((_WORD *)a2 + 4);
  *(void *)unint64_t result = v2;
  return result;
}

uint64_t sub_1B6392B5C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (a4)
  {
    sub_1B62C5560(0, (unint64_t *)&qword_1EB980E40);
    uint64_t v6 = swift_allocError();
    *uint64_t v7 = a4;
    id v8 = a4;
    return MEMORY[0x1F4188208](v4, v6);
  }
  else
  {
    uint64_t v10 = *(void **)(*(void *)(v4 + 64) + 40);
    *uint64_t v10 = a2;
    v10[1] = a3;
    swift_unknownObjectRetain();
    id v11 = a3;
    return MEMORY[0x1F4188200](v4);
  }
}

uint64_t getEnumTagSinglePayload for TextureCPURuntime.Slice(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 64)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t getEnumTagSinglePayload for Entity(uint64_t a1, int a2)
{
  if (a2 && *(unsigned char *)(a1 + 8)) {
    return (*(_DWORD *)a1 + 1);
  }
  else {
    return 0;
  }
}

uint64_t sub_1B6392C70()
{
  if (qword_1EB9811B0 != -1) {
    swift_once();
  }
  *(void *)(v0 + 64) = *(void *)(v0 + 80);
  uint64_t v1 = swift_task_alloc();
  *(void *)(v0 + 104) = v1;
  *(_OWORD *)(v1 + 16) = *(_OWORD *)(v0 + 88);
  swift_retain();
  uint64_t v2 = (void *)swift_task_alloc();
  *(void *)(v0 + 112) = v2;
  *uint64_t v2 = v0;
  v2[1] = sub_1B6399274;
  return MEMORY[0x1F41881B8](v0 + 16, v0 + 64, &unk_1E9DCFF60, v1, 0, 0, 0xD000000000000014, 0x80000001B6F34EA0);
}

uint64_t sub_1B6392DD4(uint64_t a1)
{
  uint64_t v4 = v1[2];
  uint64_t v5 = v1[3];
  uint64_t v6 = v1[4];
  uint64_t v7 = v1[5];
  uint64_t v8 = v1[6];
  uint64_t v9 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v9;
  *uint64_t v9 = v2;
  v9[1] = sub_1B638E3C8;
  uint64_t v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((char *)&dword_1E9DCFF40
                                                                                     + dword_1E9DCFF40);
  return v10(a1, v4, v5, v6, v7, v8);
}

uint64_t sub_1B6392EB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)(v6 + 64) = a1;
  uint64_t v10 = (void *)swift_task_alloc();
  *(void *)(v6 + 72) = v10;
  *uint64_t v10 = v6;
  v10[1] = sub_1B6399400;
  v10[11] = a5;
  v10[12] = a6;
  v10[9] = v6 + 16;
  v10[10] = a4;
  return MEMORY[0x1F4188298](sub_1B6392C70, 0, 0);
}

void *sub_1B6392F78(uint64_t a1)
{
  sub_1B63931C4(0, (unint64_t *)&qword_1EB97F380, (void (*)(uint64_t))type metadata accessor for GraphScriptingConfig.ScriptInfo);
  uint64_t v3 = v2;
  uint64_t v4 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2, v5);
  uint64_t v7 = (unsigned int *)((char *)&v20 - v6);
  uint64_t v8 = *(void *)(a1 + 16);
  if (!v8) {
    return (void *)MEMORY[0x1E4FBC868];
  }
  sub_1B63966C0(0, (unint64_t *)&qword_1EB980700, (void (*)(uint64_t))type metadata accessor for GraphScriptingConfig.ScriptInfo, (void (*)(void))sub_1B67FC164);
  uint64_t v9 = (void *)sub_1B6E32C58();
  uint64_t v10 = (uint64_t)v7 + *(int *)(v3 + 48);
  uint64_t v11 = a1 + ((*(unsigned __int8 *)(v4 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  uint64_t v12 = *(void *)(v4 + 72);
  do
  {
    sub_1B67FBEA8(v11, (uint64_t)v7, (uint64_t)&qword_1EB97F380, (uint64_t)type metadata accessor for GraphScriptingConfig.ScriptInfo, (uint64_t)&type metadata for GraphScriptingConfig.EvaluationMode, (uint64_t (*)(void, uint64_t, uint64_t, uint64_t))sub_1B63931C4);
    uint64_t v13 = *v7;
    unsigned __int8 v21 = *((unsigned char *)v7 + 4);
    unsigned __int8 v14 = v21;
    unint64_t v15 = sub_1B69FAA7C(v13 | ((unint64_t)v21 << 32));
    *(void *)((char *)v9 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v15;
    uint64_t v16 = v9[6] + 8 * v15;
    *(_DWORD *)uint64_t v16 = v13;
    *(unsigned char *)(v16 + 4) = v14;
    uint64_t v17 = v9[7];
    uint64_t v18 = type metadata accessor for GraphScriptingConfig.ScriptInfo();
    sub_1B67FA020(v10, v17 + *(void *)(*(void *)(v18 - 8) + 72) * v15, (uint64_t (*)(void))type metadata accessor for GraphScriptingConfig.ScriptInfo);
    ++v9[2];
    v11 += v12;
    --v8;
  }
  while (v8);
  return v9;
}

void sub_1B63931C4(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v5) {
      atomic_store(TupleTypeMetadata2, a2);
    }
  }
}

void sub_1B6393230(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v5) {
      atomic_store(TupleTypeMetadata2, a2);
    }
  }
}

uint64_t sub_1B63932A0()
{
  return swift_deallocClassInstance();
}

uint64_t sub_1B63932BC(char a1, uint64_t a2, uint64_t (*a3)(uint64_t))
{
  uint64_t v4 = v3;
  if ((a1 & 1) == 0) {
    return a3(v3 + 104);
  }
  swift_retain();
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v9 = *(void *)(v3 + 96);
  uint64_t v18 = *(void *)(v4 + 96);
  *(void *)(v4 + 96) = 0x8000000000000000;
  unint64_t v10 = sub_1B69FA754(a2);
  char v12 = v11;
  uint64_t v13 = *(void *)(v9 + 16) + ((v11 & 1) == 0);
  if (*(void *)(v9 + 24) >= v13)
  {
    if ((isUniquelyReferenced_nonNull_native & 1) == 0)
    {
      sub_1B6ACB73C();
      uint64_t v9 = v18;
    }
  }
  else
  {
    sub_1B6AB53C4(v13, isUniquelyReferenced_nonNull_native);
    uint64_t v9 = v18;
    unint64_t v14 = sub_1B69FA754(a2);
    if ((v12 & 1) != (v15 & 1))
    {
      type metadata accessor for ComponentsDataChunk();
      uint64_t result = sub_1B6E33838();
      __break(1u);
      return result;
    }
    unint64_t v10 = v14;
  }
  *(void *)(v4 + 96) = v9;
  swift_bridgeObjectRelease();
  uint64_t v16 = *(void **)(v4 + 96);
  swift_bridgeObjectRetain();
  if ((v12 & 1) == 0)
  {
    sub_1B636A55C(v10, a2, MEMORY[0x1E4FBC860], v16);
    swift_retain();
  }
  uint64_t v17 = v16[7];
  swift_bridgeObjectRelease();
  a3(v17 + 8 * v10);

  return swift_release();
}

double sub_1B6393444(uint64_t a1)
{
  *(void *)&double result = sub_1B63B2A48(a1, *(void *)(v1 + 16), *(void *)(v1 + 24), *(unsigned char *)(v1 + 32), *(void *)(v1 + 40), *(void *)(v1 + 48)).n128_u64[0];
  return result;
}

uint64_t sub_1B6393458()
{
  swift_release();

  return swift_deallocClassInstance();
}

uint64_t sub_1B6393490(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F41863F8](a1, a2, a3, 32);
}

uint64_t _s3VFX9ColorRampVwCP_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t sub_1B63934DC()
{
  uint64_t result = swift_checkMetadataState();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

uint64_t getEnumTagSinglePayload for ForceField_LEGACY.Kind(unsigned __int8 *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 < 0xFA) {
    goto LABEL_17;
  }
  if (a2 + 6 >= 0xFFFF00) {
    int v2 = 4;
  }
  else {
    int v2 = 2;
  }
  if ((a2 + 6) >> 8 < 0xFF) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  if (v3 == 4)
  {
    int v4 = *(_DWORD *)(a1 + 1);
    if (v4) {
      return (*a1 | (v4 << 8)) - 6;
    }
  }
  else
  {
    if (v3 == 2)
    {
      int v4 = *(unsigned __int16 *)(a1 + 1);
      if (!*(_WORD *)(a1 + 1)) {
        goto LABEL_17;
      }
      return (*a1 | (v4 << 8)) - 6;
    }
    int v4 = a1[1];
    if (a1[1]) {
      return (*a1 | (v4 << 8)) - 6;
    }
  }
LABEL_17:
  unsigned int v6 = *a1;
  BOOL v7 = v6 >= 7;
  int v8 = v6 - 7;
  if (!v7) {
    int v8 = -1;
  }
  return (v8 + 1);
}

uint64_t sub_1B63935FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F41863F8](a1, a2, a3, 24);
}

unsigned char *storeEnumTagSinglePayload for ParticleSortMode(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 6 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 6) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFA) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xF9)
  {
    unsigned int v6 = ((a2 - 250) >> 8) + 1;
    void *result = a2 + 6;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        break;
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          void *result = a2 + 6;
        break;
    }
  }
  return result;
}

uint64_t initializeWithCopy for ColorRampsState(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  return a1;
}

uint64_t sub_1B6393718()
{
  return swift_initClassMetadata2();
}

uint64_t initializeWithCopy for EmitterRuntime(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  *(_WORD *)(a1 + 49) = *(_WORD *)(a2 + 49);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(unsigned char *)(a1 + 68) = *(unsigned char *)(a2 + 68);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  *(void *)(a1 + 120) = *(void *)(a2 + 120);
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a2 + 128);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a2 + 129);
  long long v3 = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 145) = *(_OWORD *)(a2 + 145);
  *(_OWORD *)(a1 + 136) = v3;
  uint64_t v4 = *(void *)(a2 + 176);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(void *)(a1 + 176) = v4;
  *(unsigned char *)(a1 + 184) = *(unsigned char *)(a2 + 184);
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
  *(unsigned char *)(a1 + 216) = *(unsigned char *)(a2 + 216);
  *(void *)(a1 + 220) = *(void *)(a2 + 220);
  uint64_t v5 = *(void *)(a2 + 232);
  *(unsigned char *)(a1 + 240) = *(unsigned char *)(a2 + 240);
  *(void *)(a1 + 232) = v5;
  uint64_t v15 = *(void *)(a2 + 256);
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  *(void *)(a1 + 256) = v15;
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  *(unsigned char *)(a1 + 272) = *(unsigned char *)(a2 + 272);
  *(void *)(a1 + 280) = *(void *)(a2 + 280);
  *(_OWORD *)(a1 + 288) = *(_OWORD *)(a2 + 288);
  uint64_t v6 = *(void *)(a2 + 312);
  *(void *)(a1 + 304) = *(void *)(a2 + 304);
  *(void *)(a1 + 312) = v6;
  *(_OWORD *)(a1 + 320) = *(_OWORD *)(a2 + 320);
  uint64_t v7 = *(void *)(a2 + 344);
  *(void *)(a1 + 336) = *(void *)(a2 + 336);
  *(void *)(a1 + 344) = v7;
  uint64_t v8 = *(void *)(a2 + 360);
  *(void *)(a1 + 352) = *(void *)(a2 + 352);
  *(void *)(a1 + 360) = v8;
  long long v9 = *(_OWORD *)(a2 + 384);
  *(_OWORD *)(a1 + 368) = *(_OWORD *)(a2 + 368);
  *(_OWORD *)(a1 + 384) = v9;
  uint64_t v10 = *(void *)(a2 + 408);
  *(void *)(a1 + 400) = *(void *)(a2 + 400);
  *(void *)(a1 + 408) = v10;
  uint64_t v11 = *(void *)(a2 + 424);
  *(void *)(a1 + 416) = *(void *)(a2 + 416);
  *(void *)(a1 + 424) = v11;
  *(_OWORD *)(a1 + 432) = *(_OWORD *)(a2 + 432);
  *(void *)(a1 + 448) = *(void *)(a2 + 448);
  *(_DWORD *)(a1 + 456) = *(_DWORD *)(a2 + 456);
  long long v12 = *(_OWORD *)(a2 + 480);
  *(_OWORD *)(a1 + 464) = *(_OWORD *)(a2 + 464);
  *(_OWORD *)(a1 + 480) = v12;
  uint64_t v13 = *(void *)(a2 + 504);
  *(void *)(a1 + 496) = *(void *)(a2 + 496);
  *(void *)(a1 + 504) = v13;
  *(void *)(a1 + 512) = *(void *)(a2 + 512);
  *(void *)(a1 + 520) = *(void *)(a2 + 520);
  *(void *)(a1 + 528) = *(void *)(a2 + 528);
  *(void *)(a1 + 536) = *(void *)(a2 + 536);
  *(void *)(a1 + 544) = *(void *)(a2 + 544);
  *(void *)(a1 + 552) = *(void *)(a2 + 552);
  *(void *)(a1 + 560) = *(void *)(a2 + 560);
  *(void *)(a1 + 568) = *(void *)(a2 + 568);
  *(void *)(a1 + 576) = *(void *)(a2 + 576);
  *(void *)(a1 + 584) = *(void *)(a2 + 584);
  *(void *)(a1 + 592) = *(void *)(a2 + 592);
  *(void *)(a1 + 600) = *(void *)(a2 + 600);
  *(void *)(a1 + 608) = *(void *)(a2 + 608);
  *(void *)(a1 + 616) = *(void *)(a2 + 616);
  *(void *)(a1 + 624) = *(void *)(a2 + 624);
  *(void *)(a1 + 632) = *(void *)(a2 + 632);
  *(void *)(a1 + 640) = *(void *)(a2 + 640);
  *(void *)(a1 + 648) = *(void *)(a2 + 648);
  swift_retain();
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_retain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  swift_retain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  return a1;
}

uint64_t sub_1B6393AE8()
{
  vfx_uniform_grid_destroy(*(void *)(v0 + 16));

  return swift_deallocClassInstance();
}

uint64_t initializeWithCopy for ShaderFileAsset(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v3;
  uint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v4;
  long long v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 32) = v7;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  id v5 = (id)v7;
  return a1;
}

uint64_t assignWithTake for RenderContext(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  uint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v4;
  *(unsigned char *)(a1 + 32) = *(unsigned char *)(a2 + 32);
  uint64_t v5 = a1 + 40;
  uint64_t v6 = a2 + 40;
  if (*(void *)(a1 + 64)) {
    _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0(a1 + 40);
  }
  long long v7 = *(_OWORD *)(v6 + 16);
  *(_OWORD *)uint64_t v5 = *(_OWORD *)v6;
  *(_OWORD *)(v5 + 16) = v7;
  *(void *)(v5 + 32) = *(void *)(v6 + 32);
  uint64_t v8 = *(void *)(a1 + 80);
  uint64_t v9 = *(void *)(a2 + 80);
  if (v8 == 1) {
    goto LABEL_10;
  }
  if (v9 == 1)
  {
    uint64_t v10 = sub_1B6AB252C;
  }
  else
  {
    if (!v8) {
      goto LABEL_10;
    }
    if (v9)
    {
      *(void *)(a1 + 80) = v9;
      swift_unknownObjectRelease();
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      swift_unknownObjectRelease();
      goto LABEL_11;
    }
    uint64_t v10 = sub_1B6AB246C;
  }
  sub_1B6AB2584(a1 + 80, (uint64_t (*)(void))v10);
LABEL_10:
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
LABEL_11:
  uint64_t v11 = *(void *)(a2 + 96);
  if (*(void *)(a1 + 96) == 1)
  {
LABEL_14:
    *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    goto LABEL_16;
  }
  if (v11 == 1)
  {
    sub_1B6AB2584(a1 + 96, (uint64_t (*)(void))sub_1B6AB25E4);
    goto LABEL_14;
  }
  *(void *)(a1 + 96) = v11;
  swift_unknownObjectRelease();
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
LABEL_16:
  uint64_t v12 = *(void *)(a2 + 120);
  if (*(void *)(a1 + 120) != 1)
  {
    if (v12 != 1)
    {
      *(void *)(a1 + 120) = v12;
      swift_unknownObjectRelease();
      *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
      return a1;
    }
    sub_1B6AB2584(a1 + 120, (uint64_t (*)(void))sub_1B6AB25E4);
  }
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  return a1;
}

uint64_t _s3VFX8VFXSceneC30applicationWillEnterForegroundyyFZ_0()
{
  if (qword_1EB97D5F0 != -1) {
    swift_once();
  }
  objc_msgSend((id)qword_1EB997960, sel_lock);
  if (qword_1EB97E3F8 != -1) {
    swift_once();
  }
  uint64_t v0 = qword_1EB997A98;
  unint64_t v1 = (void *)qword_1EB997960;
  swift_bridgeObjectRetain();
  objc_msgSend(v1, sel_unlock);
  uint64_t v2 = *(void *)(v0 + 16);
  if (v2)
  {
    for (uint64_t i = v0 + 32; ; i += 8)
    {
      sub_1B6AA00F8(i, (uint64_t)v13);
      uint64_t Strong = swift_weakLoadStrong();
      if (!Strong) {
        goto LABEL_9;
      }
      uint64_t v5 = Strong;
      uint64_t v6 = Strong + OBJC_IVAR____TtC3VFX13EntityManager_backgroundingSignalLock;
      os_unfair_lock_lock(*(os_unfair_lock_t *)(Strong + OBJC_IVAR____TtC3VFX13EntityManager_backgroundingSignalLock + 24));
      uint64_t v7 = OBJC_IVAR____TtC3VFX13EntityManager_applicationInBackground;
      if (*(unsigned char *)(v5 + OBJC_IVAR____TtC3VFX13EntityManager_applicationInBackground)) {
        break;
      }
      char v8 = *(unsigned char *)(v5 + OBJC_IVAR____TtC3VFX13EntityManager_sceneInBackground);
      os_unfair_lock_unlock(*(os_unfair_lock_t *)(v6 + 24));
      if (v8) {
        goto LABEL_14;
      }
LABEL_8:
      swift_release();
LABEL_9:
      sub_1B6AA018C((uint64_t)v13);
      if (!--v2) {
        return swift_bridgeObjectRelease();
      }
    }
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v6 + 24));
LABEL_14:
    os_unfair_lock_lock(*(os_unfair_lock_t *)(v6 + 24));
    *(unsigned char *)(v5 + v7) = 0;
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v6 + 24));
    uint64_t v9 = *(void *)(v5 + OBJC_IVAR____TtC3VFX13EntityManager_runtimeThread);
    if (v9)
    {
      swift_retain();
      os_unfair_recursive_lock_lock_with_options();
      *(unsigned char *)(v9 + 152) = 0;
      os_unfair_recursive_lock_lock_with_options();
      char v10 = *(unsigned char *)(v9 + 152);
      os_unfair_recursive_lock_unlock();
      if ((v10 & 1) == 0)
      {
        uint64_t v11 = *(void *)(v9 + 16);
        objc_msgSend(*(id *)(v11 + 16), sel_lock);
        *(unsigned char *)(v11 + 24) = 1;
        objc_msgSend(*(id *)(v11 + 16), sel_signal);
        objc_msgSend(*(id *)(v11 + 16), sel_unlock);
      }
      os_unfair_recursive_lock_unlock();
      swift_release();
    }
    goto LABEL_8;
  }

  return swift_bridgeObjectRelease();
}

uint64_t sub_1B6393F9C()
{
  *(void *)(v1 + 5000) = v0;
  if (v0) {
    uint64_t v2 = sub_1B679A6D8;
  }
  else {
    uint64_t v2 = sub_1B6290D0C;
  }
  return MEMORY[0x1F4188298](v2, 0, 0);
}

uint64_t sub_1B6393FD0()
{
  v1[623] = v0;
  if (v0)
  {
    return MEMORY[0x1F4188298](sub_1B679A1EC, 0, 0);
  }
  else
  {
    v1[624] = v1[601];
    swift_unknownObjectRetain();
    return MEMORY[0x1F41881E0](v1 + 162, v1 + 603, sub_1B6393F9C, v1 + 242);
  }
}

uint64_t sub_1B639409C()
{
  v1[621] = v0;
  if (v0)
  {
    return MEMORY[0x1F41881D0](v1 + 2, v1 + 343, sub_1B6799D80, v1 + 242);
  }
  else
  {
    v1[622] = v1[343];
    swift_unknownObjectRetain();
    return MEMORY[0x1F41881E0](v1 + 82, v1 + 601, sub_1B6393FD0, v1 + 242);
  }
}

uint64_t sub_1B6394170(uint64_t a1)
{
  uint64_t v4 = *v2;
  *(void *)(*v2 + 400) = v1;
  swift_task_dealloc();
  if (v1)
  {
    uint64_t v5 = sub_1B67A3E20;
  }
  else
  {
    *(void *)(v4 + 408) = a1;
    uint64_t v5 = sub_1B639416C;
  }
  return MEMORY[0x1F4188298](v5, 0, 0);
}

uint64_t sub_1B6394298(uint64_t a1)
{
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v5 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v5;
  *uint64_t v5 = v2;
  v5[1] = sub_1B638E3C8;
  v5[44] = v4;
  v5[45] = v1 + 24;
  v5[43] = a1;
  return MEMORY[0x1F4188298](sub_1B6297D70, 0, 0);
}

uint64_t sub_1B6394358(uint64_t a1)
{
  uint64_t v4 = *(void *)(v1 + 16);
  uint64_t v5 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v5;
  *uint64_t v5 = v2;
  v5[1] = sub_1B638E3C8;
  v5[44] = v4;
  v5[45] = v1 + 24;
  v5[43] = a1;
  return MEMORY[0x1F4188298](sub_1B6297B60, 0, 0);
}

uint64_t sub_1B6394418()
{
  if (v0[10])
  {
    uint64_t v1 = swift_unknownObjectRetain();
    MEMORY[0x1BA9B3870](v1);
    if (*(void *)((v0[9] & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(void *)((v0[9] & 0xFFFFFFFFFFFFFF8) + 0x18) >> 1) {
      sub_1B6E31C78();
    }
    sub_1B6E31CC8();
    sub_1B6E31C48();
    swift_unknownObjectRelease();
    uint64_t v2 = (void *)swift_task_alloc();
    v0[23] = v2;
    *uint64_t v2 = v0;
    v2[1] = sub_1B63945B8;
    uint64_t v3 = v0[20];
    return MEMORY[0x1F4187E48](v0 + 10, 0, 0, v3, v0 + 11);
  }
  else
  {
    uint64_t v4 = (void *)v0[12];
    (*(void (**)(void, void))(v0[21] + 8))(v0[22], v0[20]);
    *uint64_t v4 = v0[9];
    swift_task_dealloc();
    swift_task_dealloc();
    swift_task_dealloc();
    uint64_t v5 = (uint64_t (*)(void))v0[1];
    return v5();
  }
}

uint64_t sub_1B63945B8()
{
  swift_task_dealloc();
  if (v0)
  {
    swift_bridgeObjectRelease();
    uint64_t v1 = sub_1B6796A70;
  }
  else
  {
    uint64_t v1 = sub_1B6394418;
  }
  return MEMORY[0x1F4188298](v1, 0, 0);
}

uint64_t sub_1B63946D0()
{
  *(void *)(*(void *)v1 + 640) = v0;
  swift_task_dealloc();
  if (v0) {
    uint64_t v2 = sub_1B6796068;
  }
  else {
    uint64_t v2 = sub_1B6385810;
  }
  return MEMORY[0x1F4188298](v2, 0, 0);
}

uint64_t sub_1B63947E4()
{
  uint64_t v1 = v0;
  unint64_t v2 = *(void *)(v0 + 72);
  if (v2 >> 62)
  {
    swift_bridgeObjectRetain();
    uint64_t v3 = sub_1B6E32C18();
    swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v3 = *(void *)((v2 & 0xFFFFFFFFFFFFFF8) + 0x10);
  }
  swift_retain();
  uint64_t v4 = sub_1B6394A98(0, v3, v1);
  char v6 = v5;
  uint64_t result = swift_release();
  if ((v6 & 1) == 0)
  {
    if (*(unsigned char *)(v1 + 24) == 1)
    {
      if (qword_1EB9852D0 != -1) {
        swift_once();
      }
      uint64_t v8 = *(void *)(v1 + 96);
      uint64_t v11 = *(void *)(v1 + 88);
      uint64_t v12 = v8;
      swift_retain();
      swift_bridgeObjectRetain();
      sub_1B6E316E8();
      sub_1B638491C();
      sub_1B6E31A38();
      sub_1B6E31948();
      swift_bridgeObjectRelease();
      sub_1B6E31948();
      sub_1B6E33098();
      sub_1B6E31948();
      swift_bridgeObjectRelease();
      sub_1B6E31948();
      sub_1B6E328C8();
      swift_bridgeObjectRelease();
      sub_1B6E33098();
      sub_1B6E31948();
      swift_bridgeObjectRelease();
      sub_1B6E31948();
      swift_bridgeObjectRelease();
      uint64_t v9 = v11;
      int v10 = sub_1B6E32168();
      if (qword_1EB9854F8 != -1) {
        swift_once();
      }
      uint64_t v11 = 0;
      swift_retain();
      sub_1B6B33E34(v10, &v11, v9, v12);
      swift_release();
      swift_bridgeObjectRelease();
      swift_release();
    }
    sub_1B62FFAD8(v4);
    return swift_unknownObjectRelease();
  }
  return result;
}

uint64_t sub_1B6394A98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2) {
    return 0;
  }
  uint64_t v3 = a1;
  if (a1 + 1 != a2)
  {
    uint64_t v3 = a1;
    uint64_t v6 = a1;
    uint64_t v7 = a1;
    do
    {
      uint64_t v8 = *(void *)(a3 + 72);
      if ((v8 & 0xC000000000000001) != 0)
      {
        swift_bridgeObjectRetain();
        uint64_t v9 = (void *)MEMORY[0x1BA9B4580](v6 + 1, v8);
        swift_bridgeObjectRelease();
      }
      else
      {
        uint64_t v9 = *(void **)(v8 + 8 * v6 + 40);
        swift_unknownObjectRetain();
      }
      id v10 = objc_msgSend(v9, sel_length);
      swift_unknownObjectRelease();
      uint64_t v11 = *(void *)(a3 + 72);
      if ((v11 & 0xC000000000000001) != 0)
      {
        swift_bridgeObjectRetain();
        uint64_t v12 = (void *)MEMORY[0x1BA9B4580](v7, v11);
        swift_bridgeObjectRelease();
      }
      else
      {
        uint64_t v12 = *(void **)(v11 + 8 * v7 + 32);
        swift_unknownObjectRetain();
      }
      id v13 = objc_msgSend(v12, sel_length);
      swift_unknownObjectRelease();
      if ((uint64_t)v10 < (uint64_t)v13)
      {
        uint64_t v3 = v6 + 1;
        uint64_t v7 = v6 + 1;
      }
      ++v6;
    }
    while (a2 - 1 != v6);
  }
  return v3;
}

float vfx_script_clock_delta_time(void *a1)
{
  return *(float *)(*a1 + OBJC_IVAR____TtC3VFX13EntityManager_clock + 64);
}

uint64_t vfx_script_get_arguments_buffer(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t vfx_script_color_ramp_copy(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  char v3 = *(unsigned char *)(a2 + 16);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v2;
  *(unsigned char *)(a1 + 16) = v3;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t vfx_swift_release_dealloc(void *a1)
{
  return (*(uint64_t (**)(void))(*a1 - 16))();
}

void CFX::RG::RenderGraphContext::RenderGraphContext()
{
}

void sub_1B6394DD8(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;
  sub_1B6DB9064(v6);
  sub_1B6DB9064(v5);
  sub_1B6DB90A4(v3);
  if (*(_DWORD *)(v1 + 76)) {
    free(*(void **)(v1 + 80));
  }
  sub_1B6DB9064(v2);
  _Unwind_Resume(a1);
}

void CStackAllocatorCreate()
{
}

uint64_t CFX::GPUResourceManager::GPUResourceManager(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 280) = a2;
  sub_1B63F72E4(a1 + 288, 32);
  return a1;
}

void sub_1B639500C(_Unwind_Exception *a1)
{
  sub_1B6DB9064(v7);
  CFX::BufferPool::~BufferPool(v8);
  CFX::BufferPool::~BufferPool(v6);
  sub_1B6DC7544(v5);
  sub_1B6DBD624(v4);
  sub_1B6DBD624(v3);
  sub_1B6DBD5A8(v2);
  sub_1B6DBD5A8(v1);
  _Unwind_Resume(a1);
}

void sub_1B6395078()
{
}

void sub_1B6395080()
{
}

void sub_1B6395088()
{
}

uint64_t CFX::BufferPool::BufferPool(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 12) = 0;
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 16) = a1 + 24;
  *(void *)(a1 + 32) = a3;
  if (a3) {
    a4 = 1;
  }
  sub_1B6DC44BC((unsigned int *)(a1 + 8), a4);
  return a1;
}

void sub_1B63950E4(_Unwind_Exception *a1)
{
  sub_1B6DC4968(v1);
  _Unwind_Resume(a1);
}

void CScratchAllocatorCreate()
{
}

uint64_t vfx_script_texture_sample1d(uint64_t a1)
{
  if ((unint64_t)a1 > 1) {
    return sub_1B6C3D9C8(a1);
  }
  return a1;
}

void vfx_script_curve_evaluate(uint64_t a1, float a2)
{
}

void *vfx_script_curve_destroy(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = *(void **)(a1 + 16);
  sub_1B665D590();
  swift_arrayDestroy();

  return ecs_stack_allocator_deallocate(v3, a2, 0x19uLL);
}

void *vfx_script_curve_create(uint64_t a1, char *a2, char *a3, uint64_t a4)
{
  uint64_t v7 = ecs_stack_allocator_allocate(*(void *)(a1 + 16), 25, 8);
  uint64_t v8 = sub_1B629AA38(a2, a4);
  uint64_t v9 = sub_1B629AA38(a3, a4);
  *uint64_t v7 = v8;
  v7[1] = v9;
  v7[2] = 0;
  *((unsigned char *)v7 + 24) = 1;
  return v7;
}

BOOL vfx_script_clock_is_first_frame(void *a1)
{
  uint64_t v1 = *a1 + OBJC_IVAR____TtC3VFX13EntityManager_clock;
  uint64_t v3 = *(void *)(v1 + 8);
  uint64_t v2 = *(void *)(v1 + 16);
  return v3 == 1 && v2 == 0;
}

void sub_1B6395274(void *a1)
{
  id v15 = a1;
  if ((_UIApplicationIsExtension() & 1) != 0
    || (objc_msgSend__applicationKeyWindow(MEMORY[0x1E4FB1F48], v1, v2, v3),
        uint64_t v4 = objc_claimAutoreleasedReturnValue(),
        int isHostedInAnotherProcess = objc_msgSend__isHostedInAnotherProcess(v4, v5, v6, v7),
        v4,
        isHostedInAnotherProcess))
  {
    id v9 = v15;
    if (objc_msgSend_getBackgroundGPUPriority(v9, v10, v11, v12) == 3) {
      objc_msgSend_setBackgroundGPUPriority_(v9, v13, 2, v14);
    }
  }
}

uint64_t sub_1B6395308()
{
  uint64_t v1 = sub_1B6E30F48();
  uint64_t v2 = *(void *)(v1 - 8);
  uint64_t v3 = *(unsigned __int8 *)(v2 + 80);
  uint64_t v4 = (v3 + 16) & ~v3;
  uint64_t v5 = v3 | 7;
  unint64_t v6 = ((((*(void *)(v2 + 64) + v4 + 7) & 0xFFFFFFFFFFFFFFF8) + 65) & 0xFFFFFFFFFFFFFFF8) + 8;
  (*(void (**)(uint64_t, uint64_t))(v2 + 8))(v0 + v4, v1);
  swift_release();

  return MEMORY[0x1F4186498](v0, v6, v5);
}

uint64_t sub_1B63953B4()
{
  swift_release();
  swift_release();

  return MEMORY[0x1F4186498](v0, 40, 7);
}

__n128 initializeWithCopy for TextureOptions(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 42) = *(_OWORD *)(a2 + 42);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

__n128 initializeWithCopy for BlendingStates(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  long long v4 = *(_OWORD *)(a2 + 32);
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = v3;
  *(_OWORD *)(a1 + 32) = v4;
  *(__n128 *)a1 = result;
  return result;
}

__n128 initializeWithCopy for TesselationDescriptor(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 32) = v3;
  *(__n128 *)a1 = result;
  return result;
}

uint64_t initializeBufferWithCopyOfBuffer for AudioController(uint64_t result, __int16 *a2)
{
  __int16 v2 = *a2;
  *(unsigned char *)(result + 2) = *((unsigned char *)a2 + 2);
  *(_WORD *)__n128 result = v2;
  return result;
}

__n128 initializeWithTake for ParticleColorOverLife(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(__n128 *)a1 = result;
  *(_OWORD *)(a1 + 16) = v3;
  return result;
}

__n128 initializeWithTake for GraphScriptingConfig(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)a2;
  *(_OWORD *)(a1 + 11) = *(_OWORD *)(a2 + 11);
  *(__n128 *)a1 = result;
  return result;
}

uint64_t RGMTLComputeCommandEncoderDispatchOnGrid1D(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t v7 = objc_msgSend_maxTotalThreadsPerThreadgroup(a2, (const char *)a2, a3, a4);
  uint64_t v11 = objc_msgSend_device(a2, v8, v9, v10);
  if (objc_msgSend_supportsFamily_(v11, v12, 3003, v13))
  {
    uint64_t v22 = a3;
    int64x2_t v23 = vdupq_n_s64(1uLL);
    unint64_t v20 = v7;
    int64x2_t v21 = v23;
    return objc_msgSend_dispatchThreads_threadsPerThreadgroup_(a1, v14, (uint64_t)&v22, (uint64_t)&v20);
  }
  else
  {
    unint64_t v18 = (a3 + v7 - 1) / v7;
    int64x2_t v19 = vdupq_n_s64(1uLL);
    unint64_t v16 = v7;
    int64x2_t v17 = v19;
    return objc_msgSend_dispatchThreadgroups_threadsPerThreadgroup_(a1, v14, (uint64_t)&v18, (uint64_t)&v16);
  }
}

uint64_t sub_1B639553C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  uint64_t v6 = a5(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(a1, v6);
  return a1;
}

uint64_t sub_1B639559C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  sub_1B62D8750(0, a2, a3, MEMORY[0x1E4FBB718]);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8))(a1, v4);
  return a1;
}

uint64_t sub_1B639560C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  sub_1B62F7E24(0, a2, a3, MEMORY[0x1E4FBB718]);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8))(a1, v4);
  return a1;
}

uint64_t sub_1B639567C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  uint64_t v6 = a5(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(a1, v6);
  return a1;
}

uint64_t sub_1B63956DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  uint64_t v6 = a5(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(a1, v6);
  return a1;
}

uint64_t sub_1B639573C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  uint64_t v6 = a5(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(a1, v6);
  return a1;
}

uint64_t sub_1B639579C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t (*a5)(void))
{
  uint64_t v6 = a5(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8))(a1, v6);
  return a1;
}

uint64_t sub_1B63957FC(uint64_t a1)
{
  return sub_1B6395818(a1, *(uint64_t (**)(void))(v1 + 16));
}

uint64_t sub_1B6395818(uint64_t a1, uint64_t (*a2)(void))
{
  return a2();
}

uint64_t sub_1B6395840(uint64_t a1)
{
  return sub_1B63957FC(a1);
}

void sub_1B6395858()
{
  if (!qword_1EB980EF8)
  {
    sub_1B6395A28(255, (unint64_t *)&qword_1EB980EF0, (uint64_t (*)(void))sub_1B6645830, MEMORY[0x1E4FBB470], MEMORY[0x1E4FBC2F8]);
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v1) {
      atomic_store(TupleTypeMetadata2, (unint64_t *)&qword_1EB980EF8);
    }
  }
}

void sub_1B63958F8(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t, void, unint64_t))
{
  if (!*a2)
  {
    unint64_t v6 = sub_1B6645830();
    unint64_t v7 = a3(a1, MEMORY[0x1E4FBB470], v6);
    if (!v8) {
      atomic_store(v7, a2);
    }
  }
}

void sub_1B639595C(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t, void, unint64_t))
{
  if (!*a2)
  {
    unint64_t v6 = sub_1B6645830();
    unint64_t v7 = a3(a1, MEMORY[0x1E4FBB470], v6);
    if (!v8) {
      atomic_store(v7, a2);
    }
  }
}

void sub_1B63959C0(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395A28(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395A90(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395AF8(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395B60(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395BC8(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395C30(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395C98(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t, void, unint64_t))
{
  if (!*a2)
  {
    unint64_t v6 = sub_1B6645830();
    unint64_t v7 = a3(a1, MEMORY[0x1E4FBB470], v6);
    if (!v8) {
      atomic_store(v7, a2);
    }
  }
}

void sub_1B6395CFC(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395D64()
{
  if (!qword_1EB980ED0)
  {
    sub_1B6395A28(255, (unint64_t *)&qword_1EB980EF0, (uint64_t (*)(void))sub_1B6645830, MEMORY[0x1E4FBB470], MEMORY[0x1E4FBC2F8]);
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v1) {
      atomic_store(TupleTypeMetadata2, (unint64_t *)&qword_1EB980ED0);
    }
  }
}

void sub_1B6395E08(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395E70(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395ED8(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t, void, unint64_t))
{
  if (!*a2)
  {
    unint64_t v6 = sub_1B6645830();
    unint64_t v7 = a3(a1, MEMORY[0x1E4FBB470], v6);
    if (!v8) {
      atomic_store(v7, a2);
    }
  }
}

void sub_1B6395F3C(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6395FA4(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B639600C(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B6396074()
{
  if (!qword_1EB980E60)
  {
    sub_1B6313370(255, &qword_1EB980E58, MEMORY[0x1E4FBC150], MEMORY[0x1E4FBB718]);
    sub_1B6E30F48();
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v1) {
      atomic_store(TupleTypeMetadata2, (unint64_t *)&qword_1EB980E60);
    }
  }
}

void sub_1B6396108()
{
  if (!qword_1EB980DA8)
  {
    sub_1B6C44F54(255, (unint64_t *)&qword_1EB980EF8, (void (*)(uint64_t))sub_1B62AADE8);
    unint64_t v0 = sub_1B6E330A8();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB980DA8);
    }
  }
}

void sub_1B6396184()
{
  if (!qword_1EB980B70)
  {
    sub_1B637ED20(255, &qword_1EB97E870, (unint64_t *)&qword_1EB97E840);
    unint64_t v0 = sub_1B6E330A8();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB980B70);
    }
  }
}

uint64_t sub_1B63961F4(char a1, int64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    int64_t v8 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if (v8 <= a2) {
      int64_t v8 = a2;
    }
    if (v7 < a2) {
      a2 = v8;
    }
    else {
      a2 = v7;
    }
  }
  int64_t v9 = *((void *)a4 + 2);
  if (a2 <= v9) {
    int64_t v10 = *((void *)a4 + 2);
  }
  else {
    int64_t v10 = a2;
  }
  if (v10)
  {
    sub_1B6396108();
    uint64_t v11 = (char *)swift_allocObject();
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 1;
    }
    *((void *)v11 + 2) = v9;
    *((void *)v11 + 3) = 2 * (v13 >> 5);
  }
  else
  {
    uint64_t v11 = (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v14 = v11 + 32;
  id v15 = a4 + 32;
  size_t v16 = 32 * v9;
  if (a1)
  {
    if (v11 != a4 || v14 >= &v15[v16]) {
      memmove(v14, v15, v16);
    }
    *((void *)a4 + 2) = 0;
  }
  else
  {
    if (v15 < &v14[v16] && v14 < &v15[v16])
    {
      uint64_t result = sub_1B6E32C88();
      __break(1u);
      return result;
    }
    memcpy(v14, v15, v16);
  }
  swift_release();
  return (uint64_t)v11;
}

uint64_t sub_1B6396334(char a1, int64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    int64_t v8 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if (v8 <= a2) {
      int64_t v8 = a2;
    }
    if (v7 < a2) {
      a2 = v8;
    }
    else {
      a2 = v7;
    }
  }
  int64_t v9 = *((void *)a4 + 2);
  if (a2 <= v9) {
    int64_t v10 = *((void *)a4 + 2);
  }
  else {
    int64_t v10 = a2;
  }
  if (v10)
  {
    sub_1B62D9BF8(0, (unint64_t *)&unk_1EB980D80, MEMORY[0x1E4FBC150], MEMORY[0x1E4FBBE00]);
    uint64_t v11 = (char *)swift_allocObject();
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 29;
    }
    *((void *)v11 + 2) = v9;
    *((void *)v11 + 3) = 2 * (v13 >> 2);
  }
  else
  {
    uint64_t v11 = (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v14 = v11 + 32;
  id v15 = a4 + 32;
  if (a1)
  {
    if (v11 != a4 || v14 >= &v15[4 * v9]) {
      memmove(v14, v15, 4 * v9);
    }
    *((void *)a4 + 2) = 0;
  }
  else
  {
    if (v15 < &v14[4 * v9] && v14 < &v15[4 * v9])
    {
      uint64_t result = sub_1B6E32C88();
      __break(1u);
      return result;
    }
    memcpy(v14, v15, 4 * v9);
  }
  swift_release();
  return (uint64_t)v11;
}

uint64_t sub_1B639649C(char a1, int64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    int64_t v7 = v6 >> 1;
    int64_t v8 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if (v8 <= a2) {
      int64_t v8 = a2;
    }
    if (v7 < a2) {
      a2 = v8;
    }
    else {
      a2 = v7;
    }
  }
  int64_t v9 = *((void *)a4 + 2);
  if (a2 <= v9) {
    int64_t v10 = *((void *)a4 + 2);
  }
  else {
    int64_t v10 = a2;
  }
  if (v10)
  {
    sub_1B62CCD30();
    uint64_t v11 = (char *)swift_allocObject();
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 17;
    }
    *((void *)v11 + 2) = v9;
    *((void *)v11 + 3) = 2 * (v13 >> 4);
  }
  else
  {
    uint64_t v11 = (char *)MEMORY[0x1E4FBC860];
  }
  uint64_t v14 = v11 + 32;
  id v15 = a4 + 32;
  if (a1)
  {
    if (v11 != a4 || v14 >= &v15[16 * v9]) {
      memmove(v14, v15, 16 * v9);
    }
    *((void *)a4 + 2) = 0;
  }
  else
  {
    if (v15 < &v14[16 * v9] && v14 < &v15[16 * v9])
    {
      uint64_t result = sub_1B6E32C88();
      __break(1u);
      return result;
    }
    memcpy(v14, v15, 16 * v9);
  }
  swift_release();
  return (uint64_t)v11;
}

void *sub_1B63965E0(uint64_t a1, uint64_t a2)
{
  return sub_1B62FFDC4(a1, a2, (unint64_t *)&unk_1EB985590, (uint64_t)&type metadata for RenderVariantDescriptor);
}

void sub_1B63965F4(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void), uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v9 = a3();
    unint64_t v10 = a5(a1, a4, v9);
    if (!v11) {
      atomic_store(v10, a2);
    }
  }
}

void sub_1B639665C()
{
  if (!qword_1EB980740)
  {
    unint64_t v0 = sub_1B6E32C68();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB980740);
    }
  }
}

void sub_1B63966C0(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t), void (*a4)(void))
{
  if (!*a2)
  {
    a3(255);
    a4();
    unint64_t v6 = sub_1B6E32C68();
    if (!v7) {
      atomic_store(v6, a2);
    }
  }
}

void sub_1B6396740(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t, ValueMetadata *, uint64_t, unint64_t))
{
  if (!*a2)
  {
    uint64_t v6 = type metadata accessor for GraphScriptingConfig.ScriptInfo();
    unint64_t v7 = sub_1B67FC164();
    unint64_t v8 = a3(a1, &type metadata for GraphScriptingConfig.EvaluationMode, v6, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B63967B4(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t), void (*a4)(void))
{
  if (!*a2)
  {
    a3(255);
    a4();
    unint64_t v6 = sub_1B6E32C68();
    if (!v7) {
      atomic_store(v6, a2);
    }
  }
}

void sub_1B6396834()
{
  if (!qword_1EB9806E0)
  {
    type metadata accessor for TextureCache.TextureKey();
    sub_1B6366304((unint64_t *)&unk_1EB97E310, (void (*)(uint64_t))type metadata accessor for TextureCache.TextureKey);
    unint64_t v0 = sub_1B6E32C68();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB9806E0);
    }
  }
}

void sub_1B63968D0()
{
  if (!qword_1EB9806D8)
  {
    type metadata accessor for TextureCache.TextureKey();
    sub_1B67E9628((unint64_t *)&unk_1EB97E310, (void (*)(uint64_t))type metadata accessor for TextureCache.TextureKey);
    unint64_t v0 = sub_1B6E32C68();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB9806D8);
    }
  }
}

void sub_1B639696C()
{
  if (!qword_1EB985540)
  {
    sub_1B67F9AD8();
    unint64_t v0 = sub_1B6E32C68();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB985540);
    }
  }
}

unint64_t sub_1B63969D0(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4 = (void **)v3;
  unint64_t v8 = (void *)*v3;
  unint64_t v9 = sub_1B62C1A30(a2);
  char v11 = v10;
  uint64_t v12 = v8[3];
  uint64_t v13 = v8[2] + ((v10 & 1) == 0);
  if (v12 >= v13 && (a3 & 1) != 0)
  {
LABEL_6:
    uint64_t v14 = *v4;
    if (v11)
    {
LABEL_7:
      uint64_t v15 = v14[7];
      unint64_t result = swift_bridgeObjectRelease();
      *(void *)(v15 + 8 * v9) = a1;
      return result;
    }
    goto LABEL_10;
  }
  if (v12 >= v13 && (a3 & 1) == 0)
  {
    sub_1B6AD634C();
    goto LABEL_6;
  }
  sub_1B6AC670C(v13, a3 & 1);
  unint64_t v17 = sub_1B62C1A30(a2);
  if ((v11 & 1) != (v18 & 1))
  {
    unint64_t result = sub_1B6E33838();
    __break(1u);
    return result;
  }
  unint64_t v9 = v17;
  uint64_t v14 = *v4;
  if (v11) {
    goto LABEL_7;
  }
LABEL_10:

  return sub_1B636A55C(v9, a2, a1, v14);
}

uint64_t sub_1B6396AEC(unint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  a4[(a1 >> 6) + 8] |= 1 << a1;
  *(void *)(a4[6] + 8 * a1) = a2;
  uint64_t result = sub_1B63BCC48(a3, a4[7] + 56 * a1);
  ++a4[2];
  return result;
}

uint64_t sub_1B6396B50(unint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  a4[(a1 >> 6) + 8] |= 1 << a1;
  uint64_t v8 = a4[6];
  uint64_t v9 = type metadata accessor for TextureCache.TextureKey();
  uint64_t result = sub_1B6365F60(a2, v8 + *(void *)(*(void *)(v9 - 8) + 72) * a1, (uint64_t (*)(void))type metadata accessor for TextureCache.TextureKey);
  *(void *)(a4[7] + 8 * a1) = a3;
  ++a4[2];
  return result;
}

unint64_t sub_1B6396BFC(unint64_t result, char a2, uint64_t a3, void *a4)
{
  a4[(result >> 6) + 8] |= 1 << result;
  *(unsigned char *)(a4[6] + result) = a2;
  *(void *)(a4[7] + 8 * result) = a3;
  ++a4[2];
  return result;
}

unint64_t sub_1B6396C38(unint64_t result, uint64_t a2)
{
  int64_t v3 = result;
  uint64_t v4 = a2 + 64;
  uint64_t v5 = -1 << *(unsigned char *)(a2 + 32);
  unint64_t v6 = (result + 1) & ~v5;
  if (((1 << v6) & *(void *)(a2 + 64 + 8 * (v6 >> 6))) != 0)
  {
    uint64_t v7 = ~v5;
    uint64_t result = sub_1B6E327C8();
    if ((*(void *)(v4 + 8 * (v6 >> 6)) & (1 << v6)) != 0)
    {
      unint64_t v8 = (result + 1) & v7;
      do
      {
        uint64_t v9 = *(void *)(a2 + 48);
        char v10 = (_DWORD *)(v9 + 4 * v6);
        uint64_t result = MEMORY[0x1BA9B5560](*(void *)(a2 + 40), *v10, 4);
        unint64_t v11 = result & v7;
        if (v3 >= (uint64_t)v8)
        {
          if (v11 >= v8 && v3 >= (uint64_t)v11)
          {
LABEL_16:
            uint64_t v14 = (_DWORD *)(v9 + 4 * v3);
            if (v3 != v6 || v14 >= v10 + 1) {
              *uint64_t v14 = *v10;
            }
            uint64_t v15 = *(void *)(a2 + 56);
            size_t v16 = (void *)(v15 + 8 * v3);
            unint64_t v17 = (void *)(v15 + 8 * v6);
            if (v3 != v6 || (int64_t v3 = v6, v16 >= v17 + 1))
            {
              *size_t v16 = *v17;
              int64_t v3 = v6;
            }
          }
        }
        else if (v11 >= v8 || v3 >= (uint64_t)v11)
        {
          goto LABEL_16;
        }
        unint64_t v6 = (v6 + 1) & v7;
      }
      while (((*(void *)(v4 + ((v6 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v6) & 1) != 0);
    }
    char v18 = (uint64_t *)(v4 + 8 * ((unint64_t)v3 >> 6));
    uint64_t v19 = *v18;
    uint64_t v20 = (-1 << v3) - 1;
  }
  else
  {
    char v18 = (uint64_t *)(v4 + 8 * (result >> 6));
    uint64_t v20 = *v18;
    uint64_t v19 = (-1 << result) - 1;
  }
  *char v18 = v20 & v19;
  --*(void *)(a2 + 16);
  ++*(_DWORD *)(a2 + 36);
  return result;
}

uint64_t sub_1B6396DCC(uint64_t a1, char a2)
{
  int64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_1B62B3C14(0, &qword_1EB981280, (void (*)(uint64_t))sub_1B62CB664);
  uint64_t v6 = sub_1B6E32C38();
  uint64_t v7 = v6;
  if (!*(void *)(v5 + 16)) {
    goto LABEL_35;
  }
  uint64_t v30 = v3;
  uint64_t v8 = 0;
  uint64_t v9 = (uint64_t *)(v5 + 64);
  uint64_t v10 = 1 << *(unsigned char *)(v5 + 32);
  uint64_t v28 = -1 << v10;
  uint64_t v29 = v10;
  if (v10 < 64) {
    uint64_t v11 = ~(-1 << v10);
  }
  else {
    uint64_t v11 = -1;
  }
  unint64_t v12 = v11 & *(void *)(v5 + 64);
  int64_t v13 = (unint64_t)(v10 + 63) >> 6;
  uint64_t v14 = v6 + 64;
  while (1)
  {
    if (v12)
    {
      unint64_t v20 = __clz(__rbit64(v12));
      v12 &= v12 - 1;
      unint64_t v21 = v20 | (v8 << 6);
      goto LABEL_21;
    }
    uint64_t v22 = v8 + 1;
    if (v8 + 1 >= v13) {
      goto LABEL_29;
    }
    unint64_t v23 = v9[v22];
    if (!v23)
    {
      uint64_t v22 = v8 + 2;
      if (v8 + 2 >= v13) {
        goto LABEL_29;
      }
      unint64_t v23 = v9[v22];
      if (!v23)
      {
        uint64_t v22 = v8 + 3;
        if (v8 + 3 >= v13) {
          goto LABEL_29;
        }
        unint64_t v23 = v9[v22];
        if (!v23) {
          break;
        }
      }
    }
LABEL_20:
    unint64_t v12 = (v23 - 1) & v23;
    unint64_t v21 = __clz(__rbit64(v23)) + (v22 << 6);
    uint64_t v8 = v22;
LABEL_21:
    uint64_t v24 = *(void *)(*(void *)(v5 + 48) + 8 * v21);
    long long v31 = *(_OWORD *)(*(void *)(v5 + 56) + 16 * v21);
    if ((a2 & 1) == 0) {
      swift_retain();
    }
    uint64_t v15 = sub_1B6E33908();
    uint64_t v16 = -1 << *(unsigned char *)(v7 + 32);
    unint64_t v17 = v15 & ~v16;
    unint64_t v18 = v17 >> 6;
    if (((-1 << v17) & ~*(void *)(v14 + 8 * (v17 >> 6))) != 0)
    {
      unint64_t v19 = __clz(__rbit64((-1 << v17) & ~*(void *)(v14 + 8 * (v17 >> 6)))) | v17 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      unint64_t v25 = (unint64_t)(63 - v16) >> 6;
      do
      {
        if (v18 + 1 == v25) {
          unint64_t v18 = 0;
        }
        else {
          ++v18;
        }
        uint64_t v26 = *(void *)(v14 + 8 * v18);
      }
      while (v26 == -1);
      unint64_t v19 = __clz(__rbit64(~v26)) + (v18 << 6);
    }
    *(void *)(v14 + ((v19 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v19;
    *(void *)(*(void *)(v7 + 48) + 8 * v19) = v24;
    *(_OWORD *)(*(void *)(v7 + 56) + 16 * v19) = v31;
    ++*(void *)(v7 + 16);
  }
  while (v13 - 4 != v8)
  {
    unint64_t v23 = *(void *)(v5 + 96 + 8 * v8++);
    if (v23)
    {
      uint64_t v22 = v8 + 3;
      goto LABEL_20;
    }
  }
LABEL_29:
  if (a2)
  {
    int64_t v3 = v30;
    if (v29 >= 64) {
      bzero((void *)(v5 + 64), 8 * v13);
    }
    else {
      *uint64_t v9 = v28;
    }
    *(void *)(v5 + 16) = 0;
LABEL_35:
    uint64_t result = swift_release();
  }
  else
  {
    uint64_t result = swift_release();
    int64_t v3 = v30;
  }
  *int64_t v3 = v7;
  return result;
}

uint64_t sub_1B639707C(uint64_t a1, char a2)
{
  int64_t v3 = v2;
  uint64_t v5 = *v2;
  sub_1B63967B4(0, (unint64_t *)&unk_1EB9806F0, (void (*)(uint64_t))type metadata accessor for EntityClass, (void (*)(void))sub_1B63BAEE0);
  uint64_t v6 = sub_1B6E32C38();
  uint64_t v7 = v6;
  if (!*(void *)(v5 + 16)) {
    goto LABEL_35;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 1 << *(unsigned char *)(v5 + 32);
  if (v9 < 64) {
    uint64_t v10 = ~(-1 << v9);
  }
  else {
    uint64_t v10 = -1;
  }
  unint64_t v11 = v10 & *(void *)(v5 + 64);
  uint64_t v12 = v6 + 64;
  uint64_t v28 = (void *)(v5 + 64);
  int64_t v29 = (unint64_t)(v9 + 63) >> 6;
  while (1)
  {
    if (v11)
    {
      unint64_t v18 = __clz(__rbit64(v11));
      v11 &= v11 - 1;
      unint64_t v19 = v18 | (v8 << 6);
      goto LABEL_21;
    }
    uint64_t v20 = v8 + 1;
    if (v8 + 1 >= v29) {
      goto LABEL_29;
    }
    unint64_t v21 = v28[v20];
    if (!v21)
    {
      uint64_t v20 = v8 + 2;
      if (v8 + 2 >= v29) {
        goto LABEL_29;
      }
      unint64_t v21 = v28[v20];
      if (!v21)
      {
        uint64_t v20 = v8 + 3;
        if (v8 + 3 >= v29) {
          goto LABEL_29;
        }
        unint64_t v21 = v28[v20];
        if (!v21) {
          break;
        }
      }
    }
LABEL_20:
    unint64_t v11 = (v21 - 1) & v21;
    unint64_t v19 = __clz(__rbit64(v21)) + (v20 << 6);
    uint64_t v8 = v20;
LABEL_21:
    char v22 = *(unsigned char *)(*(void *)(v5 + 48) + v19);
    uint64_t v23 = *(void *)(*(void *)(v5 + 56) + 8 * v19);
    if ((a2 & 1) == 0) {
      swift_retain();
    }
    sub_1B6E33918();
    sub_1B6E33938();
    uint64_t v13 = sub_1B6E33988();
    uint64_t v14 = -1 << *(unsigned char *)(v7 + 32);
    unint64_t v15 = v13 & ~v14;
    unint64_t v16 = v15 >> 6;
    if (((-1 << v15) & ~*(void *)(v12 + 8 * (v15 >> 6))) != 0)
    {
      unint64_t v17 = __clz(__rbit64((-1 << v15) & ~*(void *)(v12 + 8 * (v15 >> 6)))) | v15 & 0x7FFFFFFFFFFFFFC0;
    }
    else
    {
      unint64_t v24 = (unint64_t)(63 - v14) >> 6;
      do
      {
        if (v16 + 1 == v24) {
          unint64_t v16 = 0;
        }
        else {
          ++v16;
        }
        uint64_t v25 = *(void *)(v12 + 8 * v16);
      }
      while (v25 == -1);
      unint64_t v17 = __clz(__rbit64(~v25)) + (v16 << 6);
    }
    *(void *)(v12 + ((v17 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v17;
    *(unsigned char *)(*(void *)(v7 + 48) + v17) = v22;
    *(void *)(*(void *)(v7 + 56) + 8 * v17) = v23;
    ++*(void *)(v7 + 16);
  }
  while (v29 - 4 != v8)
  {
    unint64_t v21 = *(void *)(v5 + 96 + 8 * v8++);
    if (v21)
    {
      uint64_t v20 = v8 + 3;
      goto LABEL_20;
    }
  }
LABEL_29:
  if (a2)
  {
    uint64_t v26 = 1 << *(unsigned char *)(v5 + 32);
    int64_t v3 = v2;
    if (v26 >= 64) {
      bzero(v28, ((unint64_t)(v26 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
    }
    else {
      *uint64_t v28 = -1 << v26;
    }
    *(void *)(v5 + 16) = 0;
LABEL_35:
    uint64_t result = swift_release();
  }
  else
  {
    uint64_t result = swift_release();
    int64_t v3 = v2;
  }
  *int64_t v3 = v7;
  return result;
}

uint64_t sub_1B6397374(uint64_t a1, char a2)
{
  int64_t v3 = v2;
  uint64_t v5 = type metadata accessor for TextureCache.TextureKey();
  uint64_t v6 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5 - 8, v7);
  uint64_t v9 = (char *)&v25 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v10 = *v2;
  sub_1B6396834();
  unint64_t v11 = (void *)sub_1B6E32C38();
  if (!*(void *)(v10 + 16)) {
    goto LABEL_27;
  }
  uint64_t v26 = v3;
  uint64_t v12 = 1 << *(unsigned char *)(v10 + 32);
  uint64_t v13 = (void *)(v10 + 64);
  uint64_t v14 = -1;
  if (v12 < 64) {
    uint64_t v14 = ~(-1 << v12);
  }
  unint64_t v15 = v14 & *(void *)(v10 + 64);
  int64_t v16 = (unint64_t)(v12 + 63) >> 6;
  swift_retain();
  uint64_t v17 = 0;
  uint64_t v27 = v10 + 96;
  int64_t v28 = v16 - 4;
  while (1)
  {
    if (v15)
    {
      unint64_t v18 = __clz(__rbit64(v15));
      v15 &= v15 - 1;
      unint64_t v19 = v18 | (v17 << 6);
      goto LABEL_19;
    }
    uint64_t v20 = v17 + 1;
    if (v17 + 1 >= v16) {
      goto LABEL_21;
    }
    unint64_t v21 = v13[v20];
    if (!v21)
    {
      uint64_t v20 = v17 + 2;
      if (v17 + 2 >= v16) {
        goto LABEL_21;
      }
      unint64_t v21 = v13[v20];
      if (!v21)
      {
        uint64_t v20 = v17 + 3;
        if (v17 + 3 >= v16) {
          goto LABEL_21;
        }
        unint64_t v21 = v13[v20];
        if (!v21) {
          break;
        }
      }
    }
LABEL_18:
    unint64_t v15 = (v21 - 1) & v21;
    unint64_t v19 = __clz(__rbit64(v21)) + (v20 << 6);
    uint64_t v17 = v20;
LABEL_19:
    uint64_t v22 = *(void *)(v10 + 48) + *(void *)(v6 + 72) * v19;
    if (a2) {
      sub_1B6365F60(v22, (uint64_t)v9, (uint64_t (*)(void))type metadata accessor for TextureCache.TextureKey);
    }
    else {
      sub_1B6366C70(v22, (uint64_t)v9, (uint64_t (*)(void))type metadata accessor for TextureCache.TextureKey);
    }
    sub_1B6AC7D50((uint64_t)v9, *(void *)(*(void *)(v10 + 56) + 8 * v19), v11);
  }
  while (v28 != v17)
  {
    unint64_t v21 = *(void *)(v27 + 8 * v17++);
    if (v21)
    {
      uint64_t v20 = v17 + 3;
      goto LABEL_18;
    }
  }
LABEL_21:
  swift_release();
  if (a2)
  {
    uint64_t v23 = 1 << *(unsigned char *)(v10 + 32);
    int64_t v3 = v26;
    if (v23 >= 64) {
      bzero((void *)(v10 + 64), ((unint64_t)(v23 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8);
    }
    else {
      *uint64_t v13 = -1 << v23;
    }
    *(void *)(v10 + 16) = 0;
LABEL_27:
    uint64_t result = swift_release();
  }
  else
  {
    uint64_t result = swift_release();
    int64_t v3 = v26;
  }
  *int64_t v3 = v11;
  return result;
}

uint64_t sub_1B6397618(uint64_t a1)
{
  int64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = MEMORY[0x1E4FBC860];
  if (v1)
  {
    uint64_t v11 = MEMORY[0x1E4FBC860];
    sub_1B6397778(0, v1, 0);
    sub_1B6395D64();
    sub_1B6395858();
    uint64_t v4 = a1 + 48;
    do
    {
      swift_dynamicCast();
      uint64_t v2 = v11;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        sub_1B6397778(0, *(void *)(v11 + 16) + 1, 1);
        uint64_t v2 = v11;
      }
      unint64_t v6 = *(void *)(v2 + 16);
      unint64_t v5 = *(void *)(v2 + 24);
      if (v6 >= v5 >> 1)
      {
        sub_1B6397778(v5 > 1, v6 + 1, 1);
        uint64_t v2 = v11;
      }
      *(void *)(v2 + 16) = v6 + 1;
      uint64_t v7 = v2 + 32 * v6;
      *(_OWORD *)(v7 + 32) = v9;
      *(_DWORD *)(v7 + 48) = v10;
      v4 += 32;
      --v1;
    }
    while (v1);
  }
  return v2;
}

uint64_t sub_1B639775C(uint64_t a1)
{
  return sub_1B637EB2C(a1, &qword_1EB97E870, (unint64_t *)&qword_1EB97E840);
}

uint64_t sub_1B6397778(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_1B63961F4(a1, a2, a3, *v3);
  *int64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1B6397798(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_1B6396334(a1, a2, a3, *v3);
  *int64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1B63977B8(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_1B639649C(a1, a2, a3, *v3);
  *int64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1B63977D8(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_1B637EDB8(a1, a2, a3, *v3, (void (*)(void))sub_1B62D2B64);
  *int64_t v3 = (char *)result;
  return result;
}

uint64_t sub_1B639780C(char a1, int64_t a2, char a3)
{
  uint64_t result = sub_1B637EDB8(a1, a2, a3, *v3, (void (*)(void))sub_1B6396184);
  *int64_t v3 = (char *)result;
  return result;
}

char *sub_1B6397840(char a1, uint64_t a2, char a3, char *a4)
{
  if (a3)
  {
    unint64_t v6 = *((void *)a4 + 3);
    uint64_t v7 = v6 >> 1;
    int64_t v8 = v6 & 0xFFFFFFFFFFFFFFFELL;
    if (v8 <= a2) {
      int64_t v8 = a2;
    }
    if (v7 < a2) {
      a2 = v8;
    }
    else {
      a2 = v7;
    }
  }
  uint64_t v9 = *((void *)a4 + 2);
  if (a2 <= v9) {
    uint64_t v10 = *((void *)a4 + 2);
  }
  else {
    uint64_t v10 = a2;
  }
  if (v10)
  {
    sub_1B62CB1E8(0, (unint64_t *)&unk_1EB980D30, MEMORY[0x1E4FBB470], MEMORY[0x1E4FBBE00]);
    uint64_t v11 = (char *)swift_allocObject();
    int64_t v12 = j__malloc_size(v11);
    uint64_t v13 = v12 - 32;
    if (v12 < 32) {
      uint64_t v13 = v12 - 29;
    }
    *((void *)v11 + 2) = v9;
    *((void *)v11 + 3) = 2 * (v13 >> 2);
    uint64_t v14 = v11 + 32;
    if (a1) {
      goto LABEL_14;
    }
LABEL_22:
    sub_1B62B7DBC(0, v9, v14, (uint64_t)a4);
    goto LABEL_23;
  }
  uint64_t v11 = (char *)MEMORY[0x1E4FBC860];
  uint64_t v14 = (char *)(MEMORY[0x1E4FBC860] + 32);
  if ((a1 & 1) == 0) {
    goto LABEL_22;
  }
LABEL_14:
  if (v11 != a4 || v14 >= &a4[4 * v9 + 32]) {
    memmove(v14, a4 + 32, 4 * v9);
  }
  *((void *)a4 + 2) = 0;
LABEL_23:
  swift_bridgeObjectRelease();
  return v11;
}

void *sub_1B6397958(char a1, uint64_t a2, char a3, void *a4)
{
  return sub_1B62C5708(a1, a2, a3, a4, (unint64_t *)&qword_1EB980B60, (unint64_t *)&qword_1EB97E840);
}

char *sub_1B6397974(uint64_t a1, uint64_t a2, char *__dst, uint64_t a4)
{
  uint64_t v4 = a2 - a1;
  if (a2 - a1 < 0
    || ((v6 = (char *)(a4 + 32 + 96 * a1), uint64_t v7 = &__dst[96 * v4], v8 = a4 + 32 + 96 * a2, v6 < v7)
      ? (BOOL v9 = v8 > (unint64_t)__dst)
      : (BOOL v9 = 0),
        v9))
  {
    uint64_t result = (char *)sub_1B6E32C88();
    __break(1u);
  }
  else
  {
    memcpy(__dst, v6, 96 * v4);
    return v7;
  }
  return result;
}

uint64_t sub_1B6397A60(uint64_t result, unint64_t a2, unint64_t a3, char a4)
{
  int v6 = a2;
  uint64_t v7 = result;
  unint64_t v8 = HIDWORD(a2);
  unint64_t v9 = *(void *)(*v4 + 16);
  unint64_t v10 = *(void *)(*v4 + 24);
  if (v10 > v9 && (a4 & 1) != 0) {
    goto LABEL_15;
  }
  if (a4)
  {
    sub_1B67EB3C8();
  }
  else
  {
    if (v10 > v9)
    {
      uint64_t result = sub_1B67EFB5C();
LABEL_15:
      uint64_t v18 = *v4;
      *(void *)(*v4 + 8 * (a3 >> 6) + 56) |= 1 << a3;
      uint64_t v19 = *(void *)(v18 + 48) + 16 * a3;
      *(void *)uint64_t v19 = v7;
      *(_DWORD *)(v19 + 8) = v6;
      *(_DWORD *)(v19 + 12) = v8;
      ++*(void *)(v18 + 16);
      return result;
    }
    sub_1B67F1964();
  }
  uint64_t v11 = *v4;
  sub_1B6E33918();
  sub_1B6E33958();
  sub_1B6E33958();
  uint64_t result = sub_1B6E33988();
  uint64_t v12 = -1 << *(unsigned char *)(v11 + 32);
  a3 = result & ~v12;
  if (((*(void *)(v11 + 56 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3) & 1) == 0) {
    goto LABEL_15;
  }
  uint64_t v13 = ~v12;
  while (1)
  {
    uint64_t v14 = *(void *)(v11 + 48) + 16 * a3;
    int v16 = *(_DWORD *)(v14 + 8);
    int v15 = *(_DWORD *)(v14 + 12);
    if (v16 == v6 && v15 == v8) {
      break;
    }
    a3 = (a3 + 1) & v13;
    if (((*(void *)(v11 + 56 + ((a3 >> 3) & 0xFFFFFFFFFFFFFF8)) >> a3) & 1) == 0) {
      goto LABEL_15;
    }
  }
  uint64_t result = sub_1B6E33828();
  __break(1u);
  return result;
}

id sub_1B6397BCC(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(v2, sel_newBufferWithLength_options_, a1, a2);
}

void sub_1B6397C10(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v5) {
      atomic_store(TupleTypeMetadata2, a2);
    }
  }
}

void sub_1B6397C7C(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v5) {
      atomic_store(TupleTypeMetadata2, a2);
    }
  }
}

void sub_1B6397CE8(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

uint64_t sub_1B6397D4C()
{
  return sub_1B6980464(*(void *)(v0 + 16), *(uint64_t (**)(void))(v0 + 24));
}

uint64_t sub_1B6397D58()
{
  return (*(uint64_t (**)(void))(v0 + 24))();
}

uint64_t sub_1B6397D80(uint64_t a1, uint64_t a2)
{
  if (qword_1EB9852D0 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB9854F8;
  swift_retain();
  if (v5 != -1) {
    swift_once();
  }
  uint64_t v6 = qword_1EB997FF0;
  swift_retain();
  swift_release();
  uint64_t v7 = (void *)swift_allocObject();
  v7[2] = v6;
  v7[3] = a1;
  v7[4] = a2;
  v10[4] = sub_1B6397D58;
  v10[5] = v7;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 1107296256;
  v10[2] = sub_1B639AA00;
  v10[3] = &unk_1F0FBA1F8;
  unint64_t v8 = _Block_copy(v10);
  swift_retain();
  swift_retain();
  swift_release();
  objc_msgSend(v2, sel_addOperationWithBlock_, v8);
  _Block_release(v8);
  return swift_release();
}

float sub_1B6397F04()
{
  int64_t v1 = v0;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int64x2_t v17 = vdupq_n_s64(0x3FA999999999999AuLL);
  long long v18 = xmmword_1B6EC1AE0;
  if (qword_1EB97DA30 != -1) {
    swift_once();
  }
  uint64_t v2 = CGColorCreate((CGColorSpaceRef)qword_1EB997920, (const CGFloat *)v17.i64);
  CGColorRef CopyByMatchingToColorSpace = CGColorCreateCopyByMatchingToColorSpace(v0, kCGRenderingIntentDefault, v2, 0);
  if (CopyByMatchingToColorSpace)
  {
    CGColorRef v4 = CopyByMatchingToColorSpace;
    long double v5 = *(double *)(sub_1B6E320F8() + 32);

    swift_bridgeObjectRelease();
  }
  else
  {

    long double v5 = 0.05;
  }
  __asm { FMOV            V0.2D, #0.5 }
  int64x2_t v17 = _Q0;
  long long v18 = xmmword_1B6EC1AF0;
  uint64_t v11 = CGColorCreate((CGColorSpaceRef)qword_1EB997920, (const CGFloat *)v17.i64);
  CGColorRef v12 = CGColorCreateCopyByMatchingToColorSpace(v1, kCGRenderingIntentDefault, v11, 0);
  if (v12)
  {
    CGColorRef v13 = v12;
    long double v14 = *(double *)(sub_1B6E320F8() + 32);

    swift_bridgeObjectRelease();
  }
  else
  {

    long double v14 = 0.5;
  }
  double v15 = log(v5);
  return floor((-2.99573227 / v15 + -0.693147181 / log(v14)) * 0.5 * 100.0 + 0.5) / 100.0;
}

uint64_t _sSo14MTLPixelFormatV3VFXE11descriptionSSvg_0(uint64_t a1)
{
  uint64_t result = 0x6D726F6E553861;
  switch(a1)
  {
    case 0:
      return 0x64696C61766E69;
    case 1:
      return result;
    case 10:
      return 0x6D726F6E553872;
    case 12:
      return 0x6D726F6E533872;
    case 13:
      return 0x746E69553872;
    case 14:
      return 0x746E69533872;
    case 20:
      unsigned int v3 = 1429614962;
      return v3 | 0x6D726F6E00000000;
    case 22:
      unsigned int v3 = 1396060530;
      return v3 | 0x6D726F6E00000000;
    case 23:
      unsigned int v4 = 1429614962;
      return v4 | 0x746E6900000000;
    case 24:
      unsigned int v4 = 1396060530;
      return v4 | 0x746E6900000000;
    case 25:
      unsigned int v5 = 1177956722;
      return v5 | 0x74616F6C00000000;
    case 30:
      unsigned int v3 = 1429759858;
      return v3 | 0x6D726F6E00000000;
    case 32:
      unsigned int v3 = 1396205426;
      return v3 | 0x6D726F6E00000000;
    case 33:
      unsigned int v4 = 1429759858;
      return v4 | 0x746E6900000000;
    case 34:
      unsigned int v4 = 1396205426;
      return v4 | 0x746E6900000000;
    case 53:
      unsigned int v4 = 1429353330;
      return v4 | 0x746E6900000000;
    case 54:
      unsigned int v4 = 1395798898;
      return v4 | 0x746E6900000000;
    case 55:
      unsigned int v5 = 1177695090;
      return v5 | 0x74616F6C00000000;
    case 60:
      return 0x726F6E5536316772;
    case 62:
      return 0x726F6E5336316772;
    case 63:
      unsigned int v6 = 909207410;
      return v6 | 0x746E695500000000;
    case 64:
      unsigned int v7 = 909207410;
      return v7 | 0x746E695300000000;
    case 65:
      unsigned int v8 = 909207410;
      return v8 | 0x616F6C4600000000;
    case 70:
      unsigned int v9 = 1633838962;
      return v9 | 0x6F6E553800000000;
    case 71:
      unsigned int v10 = 1633838962;
      return v10 | 0x6F6E553800000000;
    case 72:
      return 0x6F6E533861626772;
    case 73:
      uint64_t v11 = 0x553861626772;
      return v11 & 0xFFFFFFFFFFFFLL | 0x6E69000000000000;
    case 74:
      uint64_t v11 = 0x533861626772;
      return v11 & 0xFFFFFFFFFFFFLL | 0x6E69000000000000;
    case 80:
      unsigned int v9 = 1634887522;
      return v9 | 0x6F6E553800000000;
    case 81:
      unsigned int v10 = 1634887522;
      return v10 | 0x6F6E553800000000;
    case 90:
      unsigned int v12 = 828532594;
      return v12 | 0x5532613000000000;
    case 91:
      return 0x5532613031626772;
    case 92:
      return 0x4630316231316772;
    case 93:
      uint64_t v13 = 0x356539626772;
      return v13 & 0xFFFFFFFFFFFFLL | 0x6C46000000000000;
    case 94:
      unsigned int v12 = 829581154;
      return v12 | 0x5532613000000000;
    case 103:
      unsigned int v6 = 842229618;
      return v6 | 0x746E695500000000;
    case 104:
      unsigned int v7 = 842229618;
      return v7 | 0x746E695300000000;
    case 105:
      unsigned int v8 = 842229618;
      return v8 | 0x616F6C4600000000;
    case 110:
      return 0x6E55363161626772;
    case 112:
      return 0x6E53363161626772;
    case 113:
      uint64_t v14 = 0x363161626772;
      return v14 & 0xFFFFFFFFFFFFLL | 0x6955000000000000;
    case 114:
      uint64_t v15 = 0x363161626772;
      return v15 & 0xFFFFFFFFFFFFLL | 0x6953000000000000;
    case 115:
      uint64_t v13 = 0x363161626772;
      return v13 & 0xFFFFFFFFFFFFLL | 0x6C46000000000000;
    case 123:
      uint64_t v14 = 0x323361626772;
      return v14 & 0xFFFFFFFFFFFFLL | 0x6955000000000000;
    case 124:
      uint64_t v15 = 0x323361626772;
      return v15 & 0xFFFFFFFFFFFFLL | 0x6953000000000000;
    case 125:
      uint64_t v13 = 0x323361626772;
      return v13 & 0xFFFFFFFFFFFFLL | 0x6C46000000000000;
    case 186:
      uint64_t v16 = 0x345F63747361;
      return v16 & 0xFFFFFFFFFFFFLL | 0x3478000000000000;
    case 187:
      uint64_t v16 = 0x355F63747361;
      return v16 & 0xFFFFFFFFFFFFLL | 0x3478000000000000;
    case 188:
      uint64_t v17 = 0x355F63747361;
      return v17 & 0xFFFFFFFFFFFFLL | 0x3578000000000000;
    case 189:
      uint64_t v17 = 0x365F63747361;
      return v17 & 0xFFFFFFFFFFFFLL | 0x3578000000000000;
    case 190:
      uint64_t v18 = 0x365F63747361;
      return v18 & 0xFFFFFFFFFFFFLL | 0x3678000000000000;
    case 192:
      uint64_t v17 = 0x385F63747361;
      return v17 & 0xFFFFFFFFFFFFLL | 0x3578000000000000;
    case 193:
      uint64_t v18 = 0x385F63747361;
      return v18 & 0xFFFFFFFFFFFFLL | 0x3678000000000000;
    case 194:
      return 0x3878385F63747361;
    case 195:
      return 0x7830315F63747361;
    case 196:
      return 0x7830315F63747361;
    case 197:
      return 0x7830315F63747361;
    case 198:
      return 0x7830315F63747361;
    case 199:
      return 0x7832315F63747361;
    case 200:
      return 0x7832315F63747361;
    case 204:
      uint64_t v19 = 0x345F63747361;
      return v19 & 0xFFFFFFFFFFFFLL | 0x3478000000000000;
    case 205:
      uint64_t v19 = 0x355F63747361;
      return v19 & 0xFFFFFFFFFFFFLL | 0x3478000000000000;
    case 206:
      uint64_t v20 = 0x355F63747361;
      goto LABEL_87;
    case 207:
      uint64_t v20 = 0x365F63747361;
      goto LABEL_87;
    case 208:
      uint64_t v21 = 0x365F63747361;
      goto LABEL_89;
    case 210:
      uint64_t v20 = 0x385F63747361;
LABEL_87:
      uint64_t result = v20 & 0xFFFFFFFFFFFFLL | 0x3578000000000000;
      break;
    case 211:
      uint64_t v21 = 0x385F63747361;
LABEL_89:
      uint64_t result = v21 & 0xFFFFFFFFFFFFLL | 0x3678000000000000;
      break;
    case 212:
      uint64_t result = 0x3878385F63747361;
      break;
    case 213:
      uint64_t result = 0x7830315F63747361;
      break;
    case 214:
      uint64_t result = 0x7830315F63747361;
      break;
    case 215:
      uint64_t result = 0x7830315F63747361;
      break;
    case 216:
      uint64_t result = 0x7830315F63747361;
      break;
    case 217:
      uint64_t result = 0x7832315F63747361;
      break;
    case 218:
      uint64_t result = 0x7832315F63747361;
      break;
    case 252:
      uint64_t result = 0x4632336874706564;
      break;
    case 253:
      uint64_t result = 0x386C69636E657473;
      break;
    case 260:
      uint64_t result = 0xD000000000000015;
      break;
    case 552:
      uint64_t result = 0x785F303161726762;
      break;
    case 553:
      uint64_t result = 0x785F303161726762;
      break;
    case 554:
      uint64_t result = 0x72785F3031726762;
      break;
    case 555:
      uint64_t result = 0x72785F3031726762;
      break;
    default:
      MTLPixelFormatGetInfo();
      uint64_t result = sub_1B6E31968();
      break;
  }
  return result;
}

uint64_t sub_1B6398884(uint64_t result)
{
  switch(result)
  {
    case 71:
      uint64_t result = 70;
      break;
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 147:
    case 148:
    case 149:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 157:
    case 158:
    case 159:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 167:
    case 168:
    case 169:
    case 170:
    case 171:
    case 172:
    case 173:
    case 174:
    case 175:
    case 176:
    case 177:
    case 178:
    case 179:
    case 180:
    case 181:
    case 182:
    case 183:
    case 184:
    case 185:
    case 191:
      return result;
    case 81:
      uint64_t result = 80;
      break;
    case 186:
      uint64_t result = 204;
      break;
    case 187:
      uint64_t result = 205;
      break;
    case 188:
      uint64_t result = 206;
      break;
    case 189:
      uint64_t result = 207;
      break;
    case 190:
      uint64_t result = 208;
      break;
    case 192:
      uint64_t result = 210;
      break;
    case 193:
      uint64_t result = 211;
      break;
    case 194:
      uint64_t result = 212;
      break;
    case 195:
      uint64_t result = 213;
      break;
    case 196:
      uint64_t result = 214;
      break;
    case 197:
      uint64_t result = 215;
      break;
    case 198:
      uint64_t result = 216;
      break;
    case 199:
      uint64_t result = 217;
      break;
    case 200:
      uint64_t result = 218;
      break;
    default:
      if (result == 11) {
        uint64_t result = 10;
      }
      break;
  }
  return result;
}

void sub_1B6398940()
{
  if (!qword_1EB980540)
  {
    type metadata accessor for simd_float4x4(255);
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v1) {
      atomic_store(TupleTypeMetadata2, (unint64_t *)&qword_1EB980540);
    }
  }
}

void type metadata accessor for OSLogType(uint64_t a1)
{
}

uint64_t sub_1B63989B8(uint64_t a1, unint64_t *a2)
{
  uint64_t result = *a2;
  if (!*a2)
  {
    self;
    uint64_t result = swift_getObjCClassMetadata();
    atomic_store(result, a2);
  }
  return result;
}

id sub_1B63989F4(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = v2;
  v15[1] = *(id *)MEMORY[0x1E4F143B8];
  unsigned int v6 = (void *)sub_1B6E30E78();
  v15[0] = 0;
  id v7 = objc_msgSend(v3, sel_initWithURL_options_error_, v6, a2, v15);

  id v8 = v15[0];
  if (v7)
  {
    uint64_t v9 = sub_1B6E30F48();
    unsigned int v10 = *(void (**)(uint64_t, uint64_t))(*(void *)(v9 - 8) + 8);
    id v11 = v8;
    v10(a1, v9);
  }
  else
  {
    id v12 = v15[0];
    sub_1B6E30D78();

    swift_willThrow();
    uint64_t v13 = sub_1B6E30F48();
    (*(void (**)(uint64_t, uint64_t))(*(void *)(v13 - 8) + 8))(a1, v13);
  }
  return v7;
}

uint64_t sub_1B6398B48(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a3)
  {
    sub_1B62C5560(0, (unint64_t *)&qword_1EB980E40);
    uint64_t v5 = swift_allocError();
    *unsigned int v6 = a3;
    id v7 = a3;
    return MEMORY[0x1F4188208](v3, v5);
  }
  else
  {
    **(void **)(*(void *)(v3 + 64) + 40) = a2;
    swift_unknownObjectRetain();
    return MEMORY[0x1F4188200](v3);
  }
}

uint64_t sub_1B6398C10(uint64_t a1, uint64_t a2)
{
  sub_1B62D8B50(0, (unint64_t *)&qword_1EB980450, (unint64_t *)&qword_1EB980440, (uint64_t)&protocolRef_MTLLibrary, MEMORY[0x1E4FBB718]);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t sub_1B6398CA0(_DWORD *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v4 = a3;
  unint64_t v7 = HIDWORD(a3);
  uint64_t v8 = *v3;
  sub_1B6E33918();
  sub_1B6E33958();
  sub_1B6E33958();
  uint64_t v9 = sub_1B6E33988();
  uint64_t v10 = -1 << *(unsigned char *)(v8 + 32);
  unint64_t v11 = v9 & ~v10;
  if ((*(void *)(v8 + 56 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11))
  {
    uint64_t v12 = ~v10;
    while (1)
    {
      uint64_t v13 = *(void *)(v8 + 48) + 16 * v11;
      int v15 = *(_DWORD *)(v13 + 8);
      int v14 = *(_DWORD *)(v13 + 12);
      if (v15 == v4 && v14 == v7) {
        break;
      }
      unint64_t v11 = (v11 + 1) & v12;
      if (((*(void *)(v8 + 56 + ((v11 >> 3) & 0xFFFFFFFFFFFFFF8)) >> v11) & 1) == 0) {
        goto LABEL_8;
      }
    }
    uint64_t result = 0;
    uint64_t v20 = (_DWORD *)(*(void *)(*v3 + 48) + 16 * v11);
    LODWORD(a2) = *v20;
    LODWORD(v17) = v20[1];
    LODWORD(v4) = v20[2];
    LODWORD(v7) = v20[3];
  }
  else
  {
LABEL_8:
    unint64_t v17 = HIDWORD(a2);
    char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
    uint64_t v21 = *v3;
    *uint64_t v3 = 0x8000000000000000;
    sub_1B6397A60(a2, v4, v11, isUniquelyReferenced_nonNull_native);
    *uint64_t v3 = v21;
    swift_bridgeObjectRelease();
    uint64_t result = 1;
  }
  *a1 = a2;
  a1[1] = v17;
  a1[2] = v4;
  a1[3] = v7;
  return result;
}

float sub_1B6398DEC@<S0>(float *a1@<X0>, _DWORD *a2@<X8>)
{
  float result = *a1;
  *a2 = *(_DWORD *)a1;
  return result;
}

uint64_t sub_1B6398DF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_1B6E31DE8();
  uint64_t v6 = *(void *)(v5 - 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v6 + 48))(a1, 1, v5) != 1)
  {
    sub_1B6E31DD8();
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(a1, v5);
    if (!*(void *)(a3 + 16)) {
      return swift_task_create();
    }
    goto LABEL_3;
  }
  sub_1B6399510(a1, (unint64_t *)&unk_1EB980390, MEMORY[0x1E4FBCFE8]);
  if (*(void *)(a3 + 16))
  {
LABEL_3:
    swift_getObjectType();
    swift_unknownObjectRetain();
    sub_1B6E31D98();
    swift_unknownObjectRelease();
  }
  return swift_task_create();
}

uint64_t sub_1B6398F90()
{
  uint64_t v1 = *(void *)(v0 + 32);
  uint64_t v3 = *(void *)(v0 + 56);
  uint64_t v2 = *(void *)(v0 + 64);
  long long v4 = *(_OWORD *)(v0 + 40);
  *(_OWORD *)uint64_t v2 = *(_OWORD *)(v0 + 16);
  *(void *)(v2 + 16) = v1;
  *(_OWORD *)(v2 + 24) = v4;
  *(void *)(v2 + 40) = v3;
  return (*(uint64_t (**)(void))(v0 + 8))();
}

uint64_t sub_1B6398FC8()
{
  *(void *)(*(void *)v1 + 80) = v0;
  swift_task_dealloc();
  if (v0) {
    uint64_t v2 = sub_1B67A2100;
  }
  else {
    uint64_t v2 = sub_1B6398F90;
  }
  return MEMORY[0x1F4188298](v2, 0, 0);
}

uint64_t sub_1B63990DC(uint64_t a1)
{
  uint64_t v4 = *(int **)(v1 + 16);
  uint64_t v5 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v5;
  *uint64_t v5 = v2;
  v5[1] = sub_1B638E3C8;
  uint64_t v6 = (uint64_t (*)(uint64_t, int *))((char *)&dword_1E9DCFF58 + dword_1E9DCFF58);
  return v6(a1, v4);
}

uint64_t sub_1B6399194(uint64_t a1, int *a2)
{
  *(void *)(v2 + 64) = a1;
  uint64_t v5 = (uint64_t (*)(uint64_t))((char *)a2 + *a2);
  uint64_t v3 = (void *)swift_task_alloc();
  *(void *)(v2 + 72) = v3;
  *uint64_t v3 = v2;
  v3[1] = sub_1B6398FC8;
  return v5(v2 + 16);
}

uint64_t sub_1B6399274()
{
  uint64_t v2 = *v1;
  *(void *)(v2 + 120) = v0;
  swift_task_dealloc();
  swift_release();
  swift_task_dealloc();
  if (v0)
  {
    return MEMORY[0x1F4188298](sub_1B67A2B64, 0, 0);
  }
  else
  {
    uint64_t v3 = *(void *)(v2 + 72);
    uint64_t v4 = *(void *)(v2 + 32);
    uint64_t v5 = *(void *)(v2 + 56);
    long long v6 = *(_OWORD *)(v2 + 40);
    *(_OWORD *)uint64_t v3 = *(_OWORD *)(v2 + 16);
    *(void *)(v3 + 16) = v4;
    *(_OWORD *)(v3 + 24) = v6;
    *(void *)(v3 + 40) = v5;
    unint64_t v7 = *(uint64_t (**)(void))(v2 + 8);
    return v7();
  }
}

uint64_t sub_1B6399400()
{
  uint64_t v2 = *v1;
  uint64_t v3 = *v1;
  swift_task_dealloc();
  if (!v0)
  {
    uint64_t v4 = *(_OWORD **)(v2 + 64);
    long long v5 = *(_OWORD *)(v2 + 16);
    long long v6 = *(_OWORD *)(v2 + 48);
    v4[1] = *(_OWORD *)(v2 + 32);
    void v4[2] = v6;
    *uint64_t v4 = v5;
  }
  unint64_t v7 = *(uint64_t (**)(void))(v3 + 8);
  return v7();
}

uint64_t sub_1B6399510(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  sub_1B638BF2C(0, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8))(a1, v4);
  return a1;
}

uint64_t sub_1B639956C(uint64_t a1, uint64_t a2, unint64_t *a3, void (*a4)(uint64_t))
{
  sub_1B638BF2C(0, a3, a4);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16))(a2, a1, v6);
  return a2;
}

uint64_t sub_1B63995D8(unint64_t *a1, void (*a2)(uint64_t), void (*a3)(void))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    a3();
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1B6399648(unint64_t *a1, unint64_t *a2)
{
  uint64_t result = *a1;
  if (!result)
  {
    sub_1B63996E0();
    sub_1B6CD9518(a2, (unint64_t *)&qword_1EB980EF0, MEMORY[0x1E4FBC2F8]);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

void sub_1B63996E0()
{
  if (!qword_1EB980360)
  {
    sub_1B633F640(255, (unint64_t *)&qword_1EB980EF0, (uint64_t (*)(void))sub_1B6645830, MEMORY[0x1E4FBB470], MEMORY[0x1E4FBC2F8]);
    unint64_t v0 = sub_1B6E31D18();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB980360);
    }
  }
}

uint64_t sub_1B6399770(unint64_t *a1)
{
  uint64_t result = *a1;
  if (!result)
  {
    sub_1B666BE6C(255, (unint64_t *)&qword_1EB980320, MEMORY[0x1E4FBB470], MEMORY[0x1E4FBB320]);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1B63997F4(unint64_t *a1)
{
  uint64_t result = *a1;
  if (!result)
  {
    sub_1B62D84A4(255, (unint64_t *)&qword_1EB980320, MEMORY[0x1E4FBB470], MEMORY[0x1E4FBB320]);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

uint64_t sub_1B6399878(unint64_t *a1)
{
  uint64_t result = *a1;
  if (!result)
  {
    sub_1B6399A70(255, (unint64_t *)&qword_1EB980320);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

void sub_1B63998E8(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

unint64_t sub_1B639994C()
{
  unint64_t result = qword_1EB980268;
  if (!qword_1EB980268)
  {
    sub_1B62D85D4(255, &qword_1EB980260, (uint64_t)&type metadata for GraphScriptingConfig.ScriptArg, MEMORY[0x1E4FBB320]);
    sub_1B687B958();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB980268);
  }
  return result;
}

void sub_1B63999E0(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

uint64_t sub_1B6399A44(uint64_t a1)
{
  return a1;
}

void sub_1B6399A70(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    unint64_t v3 = sub_1B6E31D18();
    if (!v4) {
      atomic_store(v3, a2);
    }
  }
}

uint64_t sub_1B6399AB8(uint64_t a1)
{
  unint64_t v3 = *v1;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    unint64_t v3 = sub_1B6C16680((uint64_t)v3);
  }
  uint64_t v4 = *((void *)v3 + 2) - 1;
  if (v4 - a1 < 0)
  {
    uint64_t result = sub_1B6E32C88();
    __break(1u);
  }
  else
  {
    long long v5 = &v3[24 * a1];
    uint64_t v6 = *((void *)v5 + 4);
    memmove(v5 + 32, v5 + 56, 24 * (v4 - a1));
    *((void *)v3 + 2) = v4;
    *uint64_t v1 = v3;
    return v6;
  }
  return result;
}

uint64_t sub_1B6399BB8(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a2 - a1;
  uint64_t v6 = *(void **)v2;
  uint64_t v7 = *(void *)(*(void *)v2 + 16);
  uint64_t v8 = v7 - (a2 - a1);
  int isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  if (!isUniquelyReferenced_nonNull_native || v8 > v6[3] >> 1)
  {
    if (v7 <= v8) {
      uint64_t v10 = v8;
    }
    else {
      uint64_t v10 = v7;
    }
    uint64_t v6 = sub_1B68C0C6C(isUniquelyReferenced_nonNull_native, v10, 1, v6);
  }
  sub_1B63B29DC();
  uint64_t result = swift_arrayDestroy();
  if (a2 == a1) {
    goto LABEL_10;
  }
  uint64_t v12 = v6[2] - a2;
  if (v12 >= 0)
  {
    uint64_t result = (uint64_t)memmove(&v6[9 * a1 + 4], &v6[9 * a2 + 4], 72 * v12);
    v6[2] -= v5;
LABEL_10:
    *(void *)uint64_t v2 = v6;
    return result;
  }
  uint64_t result = sub_1B6E32C88();
  __break(1u);
  return result;
}

uint64_t sub_1B6399CE4(uint64_t a1)
{
  uint64_t v2 = v1;
  unint64_t v3 = sub_1B62C1A30(a1);
  if ((v4 & 1) == 0) {
    return 0;
  }
  unint64_t v5 = v3;
  int isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v7 = *v1;
  uint64_t v10 = *v2;
  *uint64_t v2 = 0x8000000000000000;
  if (!isUniquelyReferenced_nonNull_native)
  {
    sub_1B6AD634C();
    uint64_t v7 = v10;
  }
  uint64_t v8 = *(void *)(*(void *)(v7 + 56) + 8 * v5);
  sub_1B628A428(v5, v7);
  *uint64_t v2 = v7;
  swift_bridgeObjectRelease();
  return v8;
}

void *sub_1B6399D7C(uint64_t a1)
{
  sub_1B6396074();
  uint64_t v3 = v2;
  uint64_t v4 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2, v5);
  uint64_t v7 = (unsigned int *)((char *)&v20 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0));
  uint64_t v8 = *(void *)(a1 + 16);
  if (!v8) {
    return (void *)MEMORY[0x1E4FBC868];
  }
  sub_1B67FA58C();
  uint64_t v9 = (void *)sub_1B6E32C58();
  uint64_t v10 = (char *)v7 + *(int *)(v3 + 48);
  uint64_t v11 = a1 + ((*(unsigned __int8 *)(v4 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80));
  uint64_t v12 = *(void *)(v4 + 72);
  do
  {
    sub_1B67FB520(v11, (uint64_t)v7, (uint64_t (*)(void))sub_1B6396074);
    uint64_t v13 = *v7;
    unsigned __int8 v21 = *((unsigned char *)v7 + 4);
    unsigned __int8 v14 = v21;
    unint64_t v15 = sub_1B69FAC48(v13 | ((unint64_t)v21 << 32));
    *(void *)((char *)v9 + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v15;
    uint64_t v16 = v9[6] + 8 * v15;
    *(_DWORD *)uint64_t v16 = v13;
    *(unsigned char *)(v16 + 4) = v14;
    uint64_t v17 = v9[7];
    uint64_t v18 = sub_1B6E30F48();
    (*(void (**)(unint64_t, char *, uint64_t))(*(void *)(v18 - 8) + 32))(v17 + *(void *)(*(void *)(v18 - 8) + 72) * v15, v10, v18);
    ++v9[2];
    v11 += v12;
    --v8;
  }
  while (v8);
  return v9;
}

void *sub_1B6399F50(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return (void *)MEMORY[0x1E4FBC868];
  }
  sub_1B67F9BA4();
  uint64_t v3 = (void *)sub_1B6E32C58();
  uint64_t v4 = (_OWORD *)(a1 + 32);
  do
  {
    long long v5 = v4[5];
    *(_OWORD *)&v26[16] = v4[4];
    *(_OWORD *)&v26[32] = v5;
    long long v6 = v4[7];
    *(_OWORD *)&v26[48] = v4[6];
    long long v27 = v6;
    long long v7 = v4[1];
    *(_OWORD *)unint64_t v24 = *v4;
    *(_OWORD *)&v24[16] = v7;
    long long v8 = v4[3];
    long long v25 = v4[2];
    *(_OWORD *)uint64_t v26 = v8;
    uint64_t v9 = *(void *)v24;
    unint64_t v10 = sub_1B62C1A30(*(uint64_t *)v24);
    *(void *)((char *)v3 + ((v10 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v10;
    *(void *)(v3[6] + 8 * v10) = v9;
    uint64_t v11 = v3[7] + 120 * v10;
    uint64_t v12 = *(void *)&v24[24];
    char v13 = v25;
    __int16 v14 = *(_WORD *)v26;
    char v15 = v26[2];
    uint64_t v16 = *(void *)&v26[56];
    uint64_t v17 = *((void *)&v27 + 1);
    uint64_t v18 = *((void *)&v25 + 1);
    long long v19 = *(_OWORD *)&v26[8];
    long long v20 = *(_OWORD *)&v26[24];
    long long v21 = *(_OWORD *)&v26[40];
    int v22 = v27;
    *(_OWORD *)uint64_t v11 = *(_OWORD *)&v24[8];
    *(void *)(v11 + 16) = v12;
    *(unsigned char *)(v11 + 24) = v13;
    *(void *)(v11 + 32) = v18;
    *(_WORD *)(v11 + 40) = v14;
    *(unsigned char *)(v11 + 42) = v15;
    *(_OWORD *)(v11 + 48) = v19;
    *(_OWORD *)(v11 + 64) = v20;
    *(_OWORD *)(v11 + 80) = v21;
    *(void *)(v11 + 96) = v16;
    *(_DWORD *)(v11 + 104) = v22;
    *(void *)(v11 + 112) = v17;
    ++v3[2];
    sub_1B67F9C0C((uint64_t)v24);
    v4 += 8;
    --v1;
  }
  while (v1);
  return v3;
}

void *sub_1B639A0A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return (void *)MEMORY[0x1E4FBC868];
  }
  sub_1B67FC1B8();
  uint64_t v3 = (void *)sub_1B6E32C58();
  uint64_t v4 = (_OWORD *)(a1 + 48);
  do
  {
    uint64_t v5 = *((void *)v4 - 2);
    uint64_t v6 = *((void *)v4 - 1);
    long long v7 = *v4;
    v4 += 2;
    unint64_t v8 = sub_1B62C1A30(v5);
    *(void *)((char *)v3 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v8;
    *(void *)(v3[6] + 8 * v8) = v5;
    uint64_t v9 = v3[7] + 24 * v8;
    *(void *)uint64_t v9 = v6;
    *(_OWORD *)(v9 + 8) = v7;
    ++v3[2];
    swift_unknownObjectRetain();
    --v1;
  }
  while (v1);
  return v3;
}

void *sub_1B639A184(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    sub_1B67F9C44(0, (unint64_t *)&unk_1EB980780, (uint64_t)&qword_1EB97D7F0, (uint64_t)&protocolRef_MTLTexture_0, (void (*)(uint64_t, uint64_t, uint64_t))sub_1B62F3064);
    uint64_t v2 = (void *)sub_1B6E32C58();
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      swift_retain();
      uint64_t v4 = (uint64_t *)(a1 + 48);
      do
      {
        uint64_t v5 = *(v4 - 2);
        uint64_t v6 = *(v4 - 1);
        uint64_t v7 = *v4;
        v4 += 3;
        swift_bridgeObjectRetain();
        swift_unknownObjectRetain();
        unint64_t v8 = sub_1B62B2CE0(v5, v6);
        *(void *)((char *)v2 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v8;
        uint64_t v9 = (uint64_t *)(v2[6] + 16 * v8);
        *uint64_t v9 = v5;
        v9[1] = v6;
        *(void *)(v2[7] + 8 * v8) = v7;
        ++v2[2];
        --v3;
      }
      while (v3);
      swift_release();
    }
  }
  else
  {
    uint64_t v2 = (void *)MEMORY[0x1E4FBC868];
  }
  swift_bridgeObjectRelease();
  return v2;
}

void *sub_1B639A2B4(uint64_t a1)
{
  return sub_1B62A6D54(a1, &qword_1E9DD08F8, (void (*)(uint64_t))type metadata accessor for SceneAssetRegistryEntry);
}

void *sub_1B639A2D4(uint64_t a1)
{
  return sub_1B62A6D54(a1, &qword_1E9DD0548, (void (*)(uint64_t))_s11MetadataSetCMa);
}

void *sub_1B639A2F4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return (void *)MEMORY[0x1E4FBC868];
  }
  sub_1B63966C0(0, &qword_1E9DD0890, (void (*)(uint64_t))sub_1B67FA2B8, (void (*)(void))sub_1B67FA338);
  uint64_t v3 = (void *)sub_1B6E32C58();
  uint64_t v4 = (uint64_t *)(a1 + 56);
  do
  {
    uint64_t v5 = *(v4 - 1);
    uint64_t v6 = *v4;
    uint64_t v7 = *(v4 - 3);
    uint64_t v8 = *(v4 - 2);
    unint64_t v9 = sub_1B62BE38C(v7);
    *(void *)((char *)v3 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v9;
    *(void *)(v3[6] + 8 * v9) = v7;
    unint64_t v10 = (void *)(v3[7] + 24 * v9);
    *unint64_t v10 = v8;
    v10[1] = v5;
    v10[2] = v6;
    ++v3[2];
    swift_unknownObjectRetain();
    v4 += 4;
    --v1;
  }
  while (v1);
  return v3;
}

void *sub_1B639A414(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return (void *)MEMORY[0x1E4FBC868];
  }
  sub_1B67F7E94();
  uint64_t v3 = (void *)sub_1B6E32C58();
  uint64_t v4 = a1 + 32;
  do
  {
    sub_1B67F7830(v4, (uint64_t)&v11, &qword_1E9DD05C0);
    uint64_t v5 = v11;
    unsigned int v6 = v12;
    unsigned int v7 = v13;
    unint64_t v8 = sub_1B69FABB0(v11, v12 | ((unint64_t)v13 << 32));
    *(void *)((char *)v3 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v8;
    uint64_t v9 = v3[6] + 16 * v8;
    *(void *)uint64_t v9 = v5;
    *(_DWORD *)(v9 + 8) = v6;
    *(_DWORD *)(v9 + 12) = v7;
    sub_1B67F7F4C((uint64_t)&v14, v3[7] + 48 * v8);
    ++v3[2];
    v4 += 64;
    --v1;
  }
  while (v1);
  return v3;
}

void *sub_1B639A530(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return (void *)MEMORY[0x1E4FBC868];
  }
  sub_1B67F7FA8();
  uint64_t v3 = (void *)sub_1B6E32C58();
  uint64_t v4 = a1 + 32;
  do
  {
    sub_1B67F7830(v4, (uint64_t)&v11, &qword_1E9DD05D0);
    uint64_t v5 = v11;
    unsigned int v6 = v12;
    unsigned int v7 = v13;
    unint64_t v8 = sub_1B69FABB0(v11, v12 | ((unint64_t)v13 << 32));
    *(void *)((char *)v3 + ((v8 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v8;
    uint64_t v9 = v3[6] + 16 * v8;
    *(void *)uint64_t v9 = v5;
    *(_DWORD *)(v9 + 8) = v6;
    *(_DWORD *)(v9 + 12) = v7;
    sub_1B67F7AF0((uint64_t)&v14, v3[7] + 96 * v8);
    ++v3[2];
    v4 += 112;
    --v1;
  }
  while (v1);
  return v3;
}

void *sub_1B639A64C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (!v1) {
    return (void *)MEMORY[0x1E4FBC868];
  }
  sub_1B67FA204();
  uint64_t v3 = (void *)sub_1B6E32C58();
  uint64_t v4 = (uint64_t *)(a1 + 56);
  do
  {
    uint64_t v5 = *v4;
    char v6 = *((unsigned char *)v4 + 8);
    uint64_t v7 = v4[2];
    long long v15 = *(_OWORD *)(v4 + 3);
    uint64_t v8 = v4[5];
    char v9 = *((unsigned char *)v4 + 48);
    *(void *)uint64_t v16 = *(v4 - 3);
    *(_OWORD *)&v16[8] = *((_OWORD *)v4 - 1);
    *(void *)&v16[24] = v5;
    char v17 = v6;
    unint64_t v10 = sub_1B69FB2A8((uint64_t)v16);
    *(void *)((char *)v3 + ((v10 >> 3) & 0x1FFFFFFFFFFFFFF8) + 64) |= 1 << v10;
    uint64_t v11 = v3[6] + 40 * v10;
    long long v12 = *(_OWORD *)&v16[16];
    *(_OWORD *)uint64_t v11 = *(_OWORD *)v16;
    *(_OWORD *)(v11 + 16) = v12;
    *(unsigned char *)(v11 + 32) = v17;
    uint64_t v13 = v3[7] + 40 * v10;
    *(void *)uint64_t v13 = v7;
    *(_OWORD *)(v13 + 8) = v15;
    *(void *)(v13 + 24) = v8;
    *(unsigned char *)(v13 + 32) = v9;
    ++v3[2];
    swift_unknownObjectRetain();
    swift_unknownObjectRetain();
    v4 += 10;
    --v1;
  }
  while (v1);
  return v3;
}

void *sub_1B639A78C(uint64_t a1)
{
  sub_1B6397C10(0, &qword_1EB97D988, MEMORY[0x1E4F276F0]);
  uint64_t v3 = v2;
  uint64_t v4 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2, v5);
  uint64_t v7 = (char *)v22 - v6;
  if (*(void *)(a1 + 16))
  {
    sub_1B67FA7A4();
    uint64_t v8 = sub_1B6E32C58();
    char v9 = (void *)v8;
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      uint64_t v11 = &v7[*(int *)(v3 + 48)];
      uint64_t v12 = v8 + 64;
      unint64_t v13 = (*(unsigned __int8 *)(v4 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80);
      v22[1] = a1;
      uint64_t v14 = a1 + v13;
      uint64_t v15 = *(void *)(v4 + 72);
      swift_retain();
      do
      {
        sub_1B67FA95C(v14, (uint64_t)v7, &qword_1EB97D988, MEMORY[0x1E4F276F0]);
        unint64_t v16 = sub_1B69FB364((uint64_t)v7);
        *(void *)(v12 + ((v16 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v16;
        uint64_t v17 = v9[6];
        uint64_t v18 = sub_1B6E30F48();
        (*(void (**)(unint64_t, char *, uint64_t))(*(void *)(v18 - 8) + 32))(v17 + *(void *)(*(void *)(v18 - 8) + 72) * v16, v7, v18);
        long long v19 = (void *)(v9[7] + 16 * v16);
        uint64_t v20 = *((void *)v11 + 1);
        *long long v19 = *(void *)v11;
        v19[1] = v20;
        ++v9[2];
        v14 += v15;
        --v10;
      }
      while (v10);
      swift_release();
    }
  }
  else
  {
    char v9 = (void *)MEMORY[0x1E4FBC868];
  }
  swift_bridgeObjectRelease();
  return v9;
}

unint64_t sub_1B639A9AC()
{
  unint64_t result = qword_1EB9800A8;
  if (!qword_1EB9800A8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB9800A8);
  }
  return result;
}

uint64_t sub_1B639AA00(uint64_t a1)
{
  uint64_t v1 = *(void (**)(uint64_t))(a1 + 32);
  uint64_t v2 = swift_retain();
  v1(v2);

  return swift_release();
}

void sub_1B639AA44(uint64_t a1, unint64_t *a2, uint64_t (*a3)(void, uint64_t, void, void))
{
  if (!*a2)
  {
    unint64_t v4 = a3(0, MEMORY[0x1E4FBC848] + 8, MEMORY[0x1E4FBC248], MEMORY[0x1E4FBC278]);
    if (!v5) {
      atomic_store(v4, a2);
    }
  }
}

void sub_1B639AAAC()
{
  if (!qword_1EB985530)
  {
    sub_1B62E17B4();
    unint64_t v0 = sub_1B6E31388();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB985530);
    }
  }
}

uint64_t type metadata accessor for VFXLoader()
{
  return self;
}

double sub_1B639AB38()
{
  *(_DWORD *)(v0 + 16) = 0;
  *(void *)&double result = 16777217;
  *(_DWORD *)(v0 + 20) = 16777217;
  *(void *)(v0 + 24) = 0;
  *(void *)(v0 + 32) = 0;
  return result;
}

void (*sub_1B639AB54(uint64_t a1, unint64_t a2, void *a3, unint64_t a4, unint64_t a5))(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t v299 = a5;
  unint64_t v325 = a2;
  id v326 = a3;
  uint64_t v293 = a1;
  uint64_t v292 = *v5;
  sub_1B63BDFB4(0, (unint64_t *)&qword_1EB9857F0, MEMORY[0x1E4F276F0]);
  MEMORY[0x1F4188790](v7 - 8, v8);
  v295 = (char *)&v282 - v9;
  uint64_t v313 = type metadata accessor for BundleInfo();
  uint64_t v290 = *(void *)(v313 - 8);
  MEMORY[0x1F4188790](v313, v10);
  uint64_t v297 = (uint64_t)&v282 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12, v13);
  uint64_t v310 = (uint64_t)&v282 - v14;
  MEMORY[0x1F4188790](v15, v16);
  uint64_t v311 = (uint64_t)&v282 - v17;
  uint64_t v291 = v18;
  MEMORY[0x1F4188790](v19, v20);
  v327 = (uint64_t *)((char *)&v282 - v21);
  uint64_t v22 = sub_1B6E312D8();
  uint64_t v23 = *(void *)(v22 - 8);
  uint64_t v319 = v22;
  uint64_t v320 = v23;
  MEMORY[0x1F4188790](v22, v24);
  v286 = (char *)&v282 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v26, v27);
  unint64_t v309 = (unint64_t)&v282 - v28;
  MEMORY[0x1F4188790](v29, v30);
  v303 = (char *)&v282 - v31;
  MEMORY[0x1F4188790](v32, v33);
  v304 = (char *)&v282 - v34;
  MEMORY[0x1F4188790](v35, v36);
  v302 = (char *)&v282 - v37;
  MEMORY[0x1F4188790](v38, v39);
  v285 = (char *)&v282 - v40;
  MEMORY[0x1F4188790](v41, v42);
  v294 = (char *)&v282 - v43;
  MEMORY[0x1F4188790](v44, v45);
  v287 = (char *)&v282 - v46;
  MEMORY[0x1F4188790](v47, v48);
  v307 = (char *)&v282 - v49;
  uint64_t v50 = sub_1B6E30F48();
  uint64_t v316 = *(void *)(v50 - 8);
  uint64_t v317 = v50;
  MEMORY[0x1F4188790](v50, v51);
  v300 = (char *)&v282 - ((v52 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v288 = v52;
  MEMORY[0x1F4188790](v53, v54);
  v315 = (char *)&v282 - v55;
  uint64_t v56 = sub_1B6E31288();
  uint64_t v57 = *(void *)(v56 - 8);
  MEMORY[0x1F4188790](v56, v58);
  v298 = (char *)&v282 - ((v59 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v60, v61);
  unint64_t v322 = (unint64_t)&v282 - v62;
  MEMORY[0x1F4188790](v63, v64);
  v306 = (char *)&v282 - v65;
  MEMORY[0x1F4188790](v66, v67);
  v308 = (char *)&v282 - v68;
  MEMORY[0x1F4188790](v69, v70);
  v305 = (char *)&v282 - v71;
  MEMORY[0x1F4188790](v72, v73);
  v289 = (char *)&v282 - v74;
  MEMORY[0x1F4188790](v75, v76);
  v301 = (char *)&v282 - v77;
  MEMORY[0x1F4188790](v78, v79);
  v296 = (char *)&v282 - v80;
  MEMORY[0x1F4188790](v81, v82);
  v312 = (char *)&v282 - v83;
  MEMORY[0x1F4188790](v84, v85);
  double v87 = (char *)&v282 - v86;
  MEMORY[0x1F4188790](v88, v89);
  v91 = (char *)&v282 - v90;
  if (qword_1EB97FF40 != -1) {
    swift_once();
  }
  uint64_t v92 = sub_1B6E312C8();
  uint64_t v93 = sub_1B6385660(v92, (uint64_t)qword_1EB997E68);
  unint64_t v314 = a4;
  unint64_t v94 = a4 + OBJC_IVAR____TtC3VFX13EntityManager_signpostID;
  unint64_t v95 = *(void (**)(char *, unint64_t, uint64_t))(v57 + 16);
  v95(v91, v94, v56);
  uint64_t v324 = v93;
  unint64_t v96 = sub_1B6E312A8();
  os_signpost_type_t v97 = sub_1B6E322B8();
  if (sub_1B6E323F8())
  {
    v95(v87, (unint64_t)v91, v56);
    uint64_t v98 = v87;
    uint64_t v99 = v56;
    uint64_t v100 = (uint8_t *)swift_slowAlloc();
    *(_WORD *)uint64_t v100 = 0;
    os_signpost_id_t v101 = sub_1B6E31278();
    _os_signpost_emit_with_name_impl(&dword_1B6287000, v96, v97, v101, "VFXLoader.load", "", v100, 2u);
    int v102 = v100;
    uint64_t v56 = v99;
    double v87 = v98;
    MEMORY[0x1BA9B84C0](v102, -1, -1);

    (*(void (**)(char *, uint64_t))(v57 + 8))(v98, v56);
  }
  else
  {
  }
  uint64_t v318 = v57 + 16;
  v95(v87, (unint64_t)v91, v56);
  sub_1B6E31308();
  swift_allocObject();
  uint64_t v103 = sub_1B6E312F8();
  id v105 = *(void (**)(char *, uint64_t))(v57 + 8);
  uint64_t v104 = v57 + 8;
  v323 = v105;
  v105(v91, v56);
  uint64_t v106 = v329;
  uint64_t v328 = v103;
  int v107 = (void (*)(char *, char *, uint64_t))v95;
  id v108 = v326;
  if (v326)
  {
    v315 = (char *)v95;
    id v109 = v326;
    uint64_t v110 = v325;
  }
  else
  {
    uint64_t v121 = (uint64_t)v315;
    uint64_t v110 = v325;
    (*(void (**)(char *, unint64_t, uint64_t))(v316 + 16))(v315, v325, v317);
    id v122 = objc_allocWithZone(MEMORY[0x1E4F28CF0]);
    id v123 = sub_1B63989F4(v121, 0);
    if (v106)
    {
      uint64_t v284 = v104;
      uint64_t v124 = sub_1B6E312A8();
      id v125 = v312;
      sub_1B6E312E8();
      int v126 = sub_1B6E322A8();
      if (sub_1B6E323F8())
      {
        LODWORD(v329) = v126;
        v283 = v87;
        swift_retain();
        uint64_t v127 = v307;
        sub_1B6E31318();
        swift_release();
        uint64_t v129 = v319;
        uint64_t v128 = v320;
        if ((*(unsigned int (**)(char *, uint64_t))(v320 + 88))(v127, v319) == *MEMORY[0x1E4FBD340])
        {
          id v130 = "[Error] Interval already ended";
        }
        else
        {
          (*(void (**)(char *, uint64_t))(v128 + 8))(v127, v129);
          id v130 = "";
        }
        int v157 = v312;
        double v87 = v283;
        v107(v283, v312, v56);
        uint64_t v158 = (uint8_t *)swift_slowAlloc();
        *(_WORD *)uint64_t v158 = 0;
        os_signpost_id_t v159 = sub_1B6E31278();
        _os_signpost_emit_with_name_impl(&dword_1B6287000, v124, (os_signpost_type_t)v329, v159, "VFXLoader.load", v130, v158, 2u);
        MEMORY[0x1BA9B84C0](v158, -1, -1);

        uint64_t v160 = v157;
        goto LABEL_82;
      }

      long long v151 = v125;
LABEL_93:
      v323(v151, v56);
      return (void (*)(uint64_t, int, uint64_t))swift_release();
    }
    id v109 = v123;
    v315 = (char *)v107;
    id v108 = v326;
  }
  id v111 = v108;
  id v112 = v109;
  long long v113 = v327;
  sub_1B6D183D0(v110, v109, v327);
  if (v106)
  {

    uint64_t v114 = sub_1B6E312A8();
    id v115 = (char *)v322;
    sub_1B6E312E8();
    os_signpost_type_t v116 = sub_1B6E322A8();
    if (sub_1B6E323F8())
    {
      uint64_t v329 = v106;
      swift_retain();
      unint64_t v117 = v309;
      sub_1B6E31318();
      swift_release();
      uint64_t v119 = v319;
      uint64_t v118 = v320;
      if ((*(unsigned int (**)(unint64_t, uint64_t))(v320 + 88))(v117, v319) == *MEMORY[0x1E4FBD340])
      {
        id v120 = "[Error] Interval already ended";
      }
      else
      {
        (*(void (**)(unint64_t, uint64_t))(v118 + 8))(v117, v119);
        id v120 = "";
      }
      long long v146 = (char *)v322;
      ((void (*)(char *, unint64_t, uint64_t))v315)(v87, v322, v56);
      uint64_t v147 = v56;
      long long v148 = (uint8_t *)swift_slowAlloc();
      *(_WORD *)long long v148 = 0;
      os_signpost_id_t v149 = sub_1B6E31278();
      _os_signpost_emit_with_name_impl(&dword_1B6287000, v114, v116, v149, "VFXLoader.load", v120, v148, 2u);
      MEMORY[0x1BA9B84C0](v148, -1, -1);

      long long v150 = v323;
      v323(v146, v147);
      v150(v87, v147);
      return (void (*)(uint64_t, int, uint64_t))swift_release();
    }
    goto LABEL_22;
  }

  int v131 = v321[19];
  uint64_t v132 = v311;
  sub_1B6D1CFC0((uint64_t)v113, v311);
  if (v131 == 1)
  {
    sub_1B67E9670(v132);
    uint64_t v133 = v310;
  }
  else
  {
    int v134 = *(unsigned __int8 *)(v314 + OBJC_IVAR____TtC3VFX13EntityManager_isVFX2);
    int v135 = *(unsigned __int8 *)(v132 + *(int *)(v313 + 32));
    sub_1B67E9670(v132);
    BOOL v136 = v134 == v135;
    long long v113 = v327;
    uint64_t v133 = v310;
    if (!v136)
    {
      sub_1B67CD358();
      swift_allocError();
      *(void *)uint64_t v137 = 0xD000000000000052;
      *(void *)(v137 + 8) = 0x80000001B6F53450;
      *(unsigned char *)(v137 + 16) = 96;
      swift_willThrow();

      sub_1B67E9670((uint64_t)v113);
      uint64_t v114 = sub_1B6E312A8();
      id v115 = v306;
      sub_1B6E312E8();
      os_signpost_type_t v138 = sub_1B6E322A8();
      if ((sub_1B6E323F8() & 1) == 0)
      {
LABEL_22:

        v323(v115, v56);
        return (void (*)(uint64_t, int, uint64_t))swift_release();
      }
      uint64_t v284 = v104;
      swift_retain();
      uint64_t v139 = v303;
      sub_1B6E31318();
      swift_release();
      uint64_t v141 = v319;
      uint64_t v140 = v320;
      if ((*(unsigned int (**)(char *, uint64_t))(v320 + 88))(v139, v319) == *MEMORY[0x1E4FBD340])
      {
        uint64_t v142 = "[Error] Interval already ended";
      }
      else
      {
        (*(void (**)(char *, uint64_t))(v140 + 8))(v139, v141);
        uint64_t v142 = "";
      }
      v215 = v315;
      v214 = v87;
      v216 = &v334;
      goto LABEL_77;
    }
  }
  int v143 = v321[19];
  sub_1B6D1CFC0((uint64_t)v113, v133);
  id v326 = v112;
  if (v143 == 1)
  {
    long long v144 = (int *)v313;
    char v145 = *(unsigned char *)(v133 + *(int *)(v313 + 28)) ^ 1;
  }
  else
  {
    char v145 = 0;
    long long v144 = (int *)v313;
  }
  sub_1B67E9670(v133);
  unint64_t v152 = v314;
  *(unsigned char *)(v314 + 48) = v145 & 1;
  *(unsigned char *)(*(void *)(v152 + OBJC_IVAR____TtC3VFX13EntityManager_scheduler) + 16) = v145 & 1;
  uint64_t v153 = v144[7];
  unint64_t v322 = v144[6];
  uint64_t v154 = *(uint64_t *)((char *)v113 + v322);
  long long v155 = v308;
  if (*((unsigned char *)v113 + v153) == 1)
  {
    if (v154 >= 1106)
    {
      if ((unint64_t)v154 < 0x7D6) {
        char v156 = 1;
      }
      else {
        char v156 = 2;
      }
    }
    else
    {
      char v156 = 0;
    }
  }
  else
  {
    char v156 = 3;
  }
  uint64_t v161 = (uint64_t *)((char *)v113 + v144[10]);
  uint64_t v162 = v161[1];
  uint64_t v284 = v104;
  v283 = v87;
  if (v162)
  {
    uint64_t v163 = *v161;
    uint64_t v164 = v162;
  }
  else
  {
    uint64_t v164 = 0xEB00000000747369;
    uint64_t v163 = 0x6C702E656E656373;
    switch(v156)
    {
      case 1:
        break;
      case 2:
        uint64_t v164 = 0xEC0000006E696278;
        uint64_t v163 = 0x66762E656E656373;
        break;
      default:
        uint64_t v164 = 0xEA00000000006E6FLL;
        uint64_t v163 = 0x736A2E656E656373;
        break;
    }
  }
  swift_bridgeObjectRetain();
  uint64_t v165 = (char *)objc_msgSend(v326, sel_fileWrappers);
  if (v165)
  {
    sub_1B63989B8(0, &qword_1EB9804F0);
    uint64_t v166 = sub_1B6E314C8();

    if (*(void *)(v166 + 16))
    {
      swift_bridgeObjectRetain();
      uint64_t v167 = sub_1B62B2CE0(v163, v164);
      if (v168)
      {
        uint64_t v165 = *(char **)(*(void *)(v166 + 56) + 8 * v167);
        long long v169 = v165;
      }
      else
      {
        uint64_t v165 = 0;
      }
      swift_bridgeObjectRelease();
    }
    else
    {
      uint64_t v165 = 0;
    }
    swift_bridgeObjectRelease();
  }
  swift_bridgeObjectRetain();
  int v170 = sub_1B6D1D0F4();
  if (v170 == 5)
  {
    uint64_t v331 = 0;
    unint64_t v332 = 0xE000000000000000;
    sub_1B6E328C8();
    swift_bridgeObjectRelease();
    uint64_t v331 = 0xD000000000000018;
    unint64_t v332 = 0x80000001B6F534B0;
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    uint64_t v171 = v331;
    unint64_t v172 = v332;
    sub_1B67CD358();
    swift_allocError();
    *(void *)uint64_t v173 = v171;
    *(void *)(v173 + 8) = v172;
    *(unsigned char *)(v173 + 16) = 96;
    swift_willThrow();

    sub_1B67E9670((uint64_t)v327);
    uint64_t v114 = sub_1B6E312A8();
    sub_1B6E312E8();
    os_signpost_type_t v138 = sub_1B6E322A8();
    if (sub_1B6E323F8())
    {
      swift_retain();
      v174 = v304;
      sub_1B6E31318();
      swift_release();
      uint64_t v176 = v319;
      uint64_t v175 = v320;
      if ((*(unsigned int (**)(char *, uint64_t))(v320 + 88))(v174, v319) == *MEMORY[0x1E4FBD340])
      {
        uint64_t v142 = "[Error] Interval already ended";
      }
      else
      {
        (*(void (**)(char *, uint64_t))(v175 + 8))(v174, v176);
        uint64_t v142 = "";
      }
      double v87 = v283;
      v214 = v283;
LABEL_80:
      v217 = v155;
      uint64_t v218 = v56;
      v215 = v315;
      goto LABEL_81;
    }
    goto LABEL_72;
  }
  LODWORD(v313) = v170;
  if (!v165 || (id v177 = objc_msgSend(v165, sel_regularFileContents)) == 0)
  {
    uint64_t v331 = 0;
    unint64_t v332 = 0xE000000000000000;
    sub_1B6E328C8();
    swift_bridgeObjectRelease();
    uint64_t v331 = 0x742064656C696166;
    unint64_t v332 = 0xEF2064616F6C206FLL;
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    uint64_t v208 = v331;
    unint64_t v209 = v332;
    sub_1B67CD358();
    swift_allocError();
    *(void *)uint64_t v210 = v208;
    *(void *)(v210 + 8) = v209;
    *(unsigned char *)(v210 + 16) = 96;
    swift_willThrow();

    sub_1B67E9670((uint64_t)v327);
    uint64_t v114 = sub_1B6E312A8();
    long long v151 = v305;
    sub_1B6E312E8();
    os_signpost_type_t v138 = sub_1B6E322A8();
    if (sub_1B6E323F8())
    {
      swift_retain();
      v211 = v302;
      sub_1B6E31318();
      swift_release();
      uint64_t v213 = v319;
      uint64_t v212 = v320;
      if ((*(unsigned int (**)(char *, uint64_t))(v320 + 88))(v211, v319) == *MEMORY[0x1E4FBD340])
      {
        uint64_t v142 = "[Error] Interval already ended";
      }
      else
      {
        (*(void (**)(char *, uint64_t))(v212 + 8))(v211, v213);
        uint64_t v142 = "";
      }
      double v87 = v283;
      v214 = v283;
      long long v155 = v305;
      goto LABEL_80;
    }
    goto LABEL_92;
  }
  uint64_t v178 = v177;
  v308 = v165;
  v312 = (char *)v56;
  swift_bridgeObjectRelease();
  uint64_t v310 = sub_1B6E30FD8();
  unint64_t v309 = v179;

  uint64_t v181 = *v327;
  uint64_t v180 = v327[1];
  uint64_t v182 = qword_1EB9852D0;
  swift_bridgeObjectRetain();
  if (v182 != -1) {
    swift_once();
  }
  uint64_t v329 = 0;
  uint64_t v331 = 0;
  unint64_t v332 = 0xE000000000000000;
  swift_retain();
  sub_1B6E328C8();
  swift_bridgeObjectRelease();
  uint64_t v331 = 91;
  unint64_t v332 = 0xE100000000000000;
  uint64_t v333 = 2048;
  sub_1B6E33098();
  sub_1B6E31948();
  swift_bridgeObjectRelease();
  sub_1B6E31948();
  swift_bridgeObjectRetain();
  uint64_t v311 = v181;
  sub_1B6E31948();
  swift_bridgeObjectRelease();
  sub_1B6E31948();
  uint64_t v333 = v154;
  sub_1B6E33098();
  sub_1B6E31948();
  swift_bridgeObjectRelease();
  sub_1B6E31948();
  sub_1B6E30EF8();
  sub_1B6E31948();
  swift_bridgeObjectRelease();
  sub_1B6E31948();
  uint64_t v183 = v331;
  uint64_t v184 = v332;
  int v185 = sub_1B6E32168();
  if (qword_1EB9854F8 != -1) {
    swift_once();
  }
  uint64_t v331 = 0;
  swift_retain();
  sub_1B6B33E34(v185, &v331, v183, v184);
  swift_release();
  swift_bridgeObjectRelease();
  swift_release();
  if (v154 >= 2049)
  {
    uint64_t v331 = 0;
    unint64_t v332 = 0xE000000000000000;
    swift_retain();
    sub_1B6E328C8();
    sub_1B6E31948();
    sub_1B6E31948();
    uint64_t v333 = 2048;
    sub_1B6E33098();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    uint64_t v333 = v154;
    sub_1B6E33098();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    uint64_t v186 = v331;
    uint64_t v187 = v332;
    int v188 = sub_1B6E32168();
    uint64_t v331 = 0;
    swift_retain();
    sub_1B6B33E34(v188, &v331, v186, v187);
    swift_release();
    swift_bridgeObjectRelease();
    swift_release();
    uint64_t v331 = 0;
    unint64_t v332 = 0xE000000000000000;
    sub_1B6E328C8();
    sub_1B6E31948();
    sub_1B6E31948();
    uint64_t v333 = v154;
    sub_1B6E33098();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    uint64_t v333 = 2048;
    sub_1B6E33098();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    uint64_t v190 = v331;
    unint64_t v189 = v332;
    uint64_t v191 = v321;
    if ((v321[22] & 1) == 0)
    {
      swift_bridgeObjectRelease();
      sub_1B67CD358();
      swift_allocError();
      *(void *)uint64_t v248 = v190;
      *(void *)(v248 + 8) = v189;
      *(unsigned char *)(v248 + 16) = -96;
      swift_willThrow();
      sub_1B62C2360(v310, v309);

      sub_1B67E9670((uint64_t)v327);
      uint64_t v114 = sub_1B6E312A8();
      v249 = v296;
      sub_1B6E312E8();
      os_signpost_type_t v203 = sub_1B6E322A8();
      if ((sub_1B6E323F8() & 1) == 0)
      {

        long long v151 = v249;
        uint64_t v56 = (uint64_t)v312;
        goto LABEL_93;
      }
      swift_retain();
      v250 = v287;
      sub_1B6E31318();
      swift_release();
      uint64_t v252 = v319;
      uint64_t v251 = v320;
      int v253 = (*(uint64_t (**)(char *, uint64_t))(v320 + 88))(v250, v319);
      uint64_t v56 = (uint64_t)v312;
      if (v253 == *MEMORY[0x1E4FBD340])
      {
        v207 = "[Error] Interval already ended";
      }
      else
      {
        (*(void (**)(char *, uint64_t))(v251 + 8))(v250, v252);
        v207 = "";
      }
      v273 = v283;
      ((void (*)(char *, char *, uint64_t))v315)(v283, v249, v56);
      goto LABEL_108;
    }
    uint64_t v331 = 0;
    unint64_t v332 = 0xE000000000000000;
    sub_1B6E328C8();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    uint64_t v192 = v331;
    unint64_t v193 = v332;
    sub_1B67CD358();
    uint64_t v194 = swift_allocError();
    *(void *)uint64_t v195 = v192;
    *(void *)(v195 + 8) = v193;
    *(unsigned char *)(v195 + 16) = -96;
    v196 = (void *)*((void *)v191 + 3);
    *((void *)v191 + 3) = v194;
  }
  v197 = v327;
  uint64_t v198 = *(uint64_t *)((char *)v327 + v322);
  uint64_t v199 = v320;
  if (v198 <= 1025)
  {
    uint64_t v331 = 0;
    unint64_t v332 = 0xE000000000000000;
    sub_1B6E328C8();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    uint64_t v333 = v198;
    sub_1B6E33098();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    uint64_t v333 = 1026;
    sub_1B6E33098();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    uint64_t v200 = v331;
    unint64_t v201 = v332;
    sub_1B67CD358();
    swift_allocError();
    *(void *)uint64_t v202 = v200;
    *(void *)(v202 + 8) = v201;
    *(unsigned char *)(v202 + 16) = -64;
    swift_willThrow();
    sub_1B62C2360(v310, v309);

    sub_1B67E9670((uint64_t)v197);
    uint64_t v114 = sub_1B6E312A8();
    long long v155 = v301;
    sub_1B6E312E8();
    os_signpost_type_t v203 = sub_1B6E322A8();
    char v204 = sub_1B6E323F8();
    uint64_t v56 = (uint64_t)v312;
    if ((v204 & 1) == 0)
    {
LABEL_72:

      long long v151 = v155;
      goto LABEL_93;
    }
    swift_retain();
    v205 = v294;
    sub_1B6E31318();
    swift_release();
    uint64_t v206 = v319;
    if ((*(unsigned int (**)(char *, uint64_t))(v199 + 88))(v205, v319) == *MEMORY[0x1E4FBD340])
    {
      v207 = "[Error] Interval already ended";
    }
    else
    {
      (*(void (**)(char *, uint64_t))(v199 + 8))(v205, v206);
      v207 = "";
    }
    v273 = v283;
    v249 = v301;
    ((void (*)(char *, char *, uint64_t))v315)(v283, v301, v56);
LABEL_108:
    v274 = (uint8_t *)swift_slowAlloc();
    *(_WORD *)v274 = 0;
    os_signpost_id_t v275 = sub_1B6E31278();
    _os_signpost_emit_with_name_impl(&dword_1B6287000, v114, v203, v275, "VFXLoader.load", v207, v274, 2u);
    MEMORY[0x1BA9B84C0](v274, -1, -1);

    v276 = v323;
    v323(v249, v56);
    v276(v273, v56);
    return (void (*)(uint64_t, int, uint64_t))swift_release();
  }
  swift_getKeyPath();
  uint64_t v222 = *(void *)(v314 + 176);
  swift_retain();
  uint64_t v223 = v329;
  v224 = (void *)sub_1B6B3A580((uint64_t)&type metadata for AssetManagerInstance, (uint64_t)&off_1F0F7FB58, v222, (void (*)(void *__return_ptr, uint64_t))sub_1B67CB5C0);
  uint64_t v225 = v223;
  swift_release();
  swift_release();
  unint64_t v226 = v299;
  uint64_t v227 = v317;
  if (v224)
  {
    uint64_t v329 = v223;
    v228 = v300;
    sub_1B6E30EA8();
    uint64_t v229 = v316;
    uint64_t v230 = (uint64_t)v295;
    (*(void (**)(char *, char *, uint64_t))(v316 + 16))(v295, v228, v227);
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v229 + 56))(v230, 0, 1, v227);
    sub_1B6CE0AD8(v230, v226 | ((HIDWORD(v226) & 1) << 32));

    v231 = v228;
    uint64_t v225 = v329;
    (*(void (**)(char *, uint64_t))(v229 + 8))(v231, v227);
  }
  BOOL v232 = v226 == 0;
  unint64_t v233 = (v226 & 0x100000000) >> 32;
  if ((v226 & 0x100000000) != 0) {
    unint64_t v234 = 0;
  }
  else {
    unint64_t v234 = v226;
  }
  v235 = v321;
  int v236 = v321[21];
  int v237 = v321[20];
  int v238 = v321[19];
  v239 = v327;
  uint64_t v240 = *(uint64_t *)((char *)v327 + v322);
  LODWORD(v307) = v233 & 1 | (v226 == 0);
  LOBYTE(v331) = v233 & 1 | (v226 == 0);
  unint64_t v322 = v234;
  uint64_t v241 = v310;
  unint64_t v242 = v309;
  v243 = sub_1B6C76418(v310, v309, v313, v236, v237, v238, v234 | ((unint64_t)((v233 | v232) & 1) << 32), v240, 0);
  uint64_t v56 = (uint64_t)v312;
  if (v225)
  {
    sub_1B67E9670((uint64_t)v239);

    sub_1B62C2360(v241, v242);
    swift_bridgeObjectRelease();
    uint64_t v114 = sub_1B6E312A8();
    long long v151 = v298;
    sub_1B6E312E8();
    os_signpost_type_t v138 = sub_1B6E322A8();
    if (sub_1B6E323F8())
    {
      swift_retain();
      v244 = v286;
      sub_1B6E31318();
      swift_release();
      uint64_t v246 = v319;
      uint64_t v245 = v320;
      if ((*(unsigned int (**)(char *, uint64_t))(v320 + 88))(v244, v319) == *MEMORY[0x1E4FBD340])
      {
        uint64_t v142 = "[Error] Interval already ended";
      }
      else
      {
        (*(void (**)(char *, uint64_t))(v245 + 8))(v244, v246);
        uint64_t v142 = "";
      }
      v215 = v315;
      double v87 = v283;
      v214 = v283;
      v216 = (uint64_t *)&v330;
LABEL_77:
      long long v155 = (char *)*(v216 - 32);
      v217 = v155;
      uint64_t v218 = v56;
LABEL_81:
      ((void (*)(char *, char *, uint64_t))v215)(v214, v217, v218);
      v219 = (uint8_t *)swift_slowAlloc();
      *(_WORD *)v219 = 0;
      os_signpost_id_t v220 = sub_1B6E31278();
      _os_signpost_emit_with_name_impl(&dword_1B6287000, v114, v138, v220, "VFXLoader.load", v142, v219, 2u);
      MEMORY[0x1BA9B84C0](v219, -1, -1);

      uint64_t v160 = v155;
LABEL_82:
      v221 = v323;
      v323(v160, v56);
      v221(v87, v56);
      return (void (*)(uint64_t, int, uint64_t))swift_release();
    }
LABEL_92:

    goto LABEL_93;
  }
  v254 = v243;
  uint64_t v329 = 0;

  sub_1B62C2360(v241, v242);
  *((void *)v235 + 4) = v254;
  swift_release();
  sub_1B6D1CFC0((uint64_t)v239, v297);
  uint64_t v255 = v316;
  (*(void (**)(char *, unint64_t, uint64_t))(v316 + 16))(v300, v325, v317);
  unint64_t v256 = (*(unsigned __int8 *)(v290 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v290 + 80);
  unint64_t v314 = (v256 + v291 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v257 = (v256 + v291 + 15) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v258 = (*(unsigned __int8 *)(v255 + 80) + v257 + 8) & ~(unint64_t)*(unsigned __int8 *)(v255 + 80);
  unint64_t v259 = (v288 + v258 + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v325 = (v259 + 23) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v260 = (v325 + 15) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v261 = swift_allocObject();
  sub_1B6887628(v297, v261 + v256);
  unint64_t v262 = v261 + v314;
  *(_DWORD *)unint64_t v262 = v322;
  *(unsigned char *)(v262 + 4) = (_BYTE)v307;
  *(void *)(v261 + v257) = v235;
  (*(void (**)(unint64_t, char *, uint64_t))(v255 + 32))(v261 + v258, v300, v317);
  v263 = (void *)(v261 + v259);
  void *v263 = v311;
  v263[1] = v180;
  *(void *)(v261 + v325) = v326;
  *(void *)(v261 + v260) = v292;
  sub_1B6887628((uint64_t)v327, v293);
  swift_retain();
  v264 = sub_1B6E312A8();
  v265 = v289;
  sub_1B6E312E8();
  os_signpost_type_t v266 = sub_1B6E322A8();
  if (sub_1B6E323F8())
  {
    swift_retain();
    v267 = v285;
    sub_1B6E31318();
    swift_release();
    uint64_t v269 = v319;
    uint64_t v268 = v320;
    int v270 = (*(uint64_t (**)(char *, uint64_t))(v320 + 88))(v267, v319);
    v271 = v312;
    if (v270 == *MEMORY[0x1E4FBD340])
    {
      v272 = "[Error] Interval already ended";
    }
    else
    {
      (*(void (**)(char *, uint64_t))(v268 + 8))(v267, v269);
      v272 = "";
    }
    v277 = v283;
    ((void (*)(char *, char *, char *))v315)(v283, v265, v271);
    v278 = (uint8_t *)swift_slowAlloc();
    *(_WORD *)v278 = 0;
    os_signpost_id_t v279 = sub_1B6E31278();
    _os_signpost_emit_with_name_impl(&dword_1B6287000, v264, v266, v279, "VFXLoader.load", v272, v278, 2u);
    v280 = v312;
    MEMORY[0x1BA9B84C0](v278, -1, -1);

    v281 = (void (*)(char *, char *))v323;
    v323(v265, (uint64_t)v280);
    v281(v277, v280);
  }
  else
  {

    v323(v265, (uint64_t)v312);
  }
  swift_release();
  return sub_1B6D1FA3C;
}

void sub_1B639CD84()
{
  sub_1B6397CE8(319, (unint64_t *)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718]);
  if (v0 <= 0x3F) {
    swift_updateClassMetadata2();
  }
}

uint64_t type metadata accessor for VFXEffect()
{
  uint64_t result = qword_1EB9812B0;
  if (!qword_1EB9812B0) {
    return swift_getSingletonMetadata();
  }
  return result;
}

id sub_1B639CF1C()
{
  uint64_t v1 = v0;
  uint64_t v2 = &v0[OBJC_IVAR____TtC3VFX9VFXEffect_effectID];
  *(_DWORD *)uint64_t v2 = 0;
  v2[4] = 1;
  uint64_t v3 = &v0[OBJC_IVAR____TtC3VFX9VFXEffect_url];
  uint64_t v4 = sub_1B6E30F48();
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 56))(v3, 1, 1, v4);
  uint64_t v5 = &v1[OBJC_IVAR____TtC3VFX9VFXEffect_rootEntity];
  *(void *)uint64_t v5 = 0;
  v5[8] = 1;
  *(void *)&v1[OBJC_IVAR____TtC3VFX9VFXEffect_entityObject] = 0;
  swift_unknownObjectWeakInit();
  *(void *)&v1[OBJC_IVAR____TtC3VFX9VFXEffect_delegate] = 0;
  *(void *)&v1[OBJC_IVAR____TtC3VFX9VFXEffect_version] = 0;
  uint64_t v6 = OBJC_IVAR____TtC3VFX9VFXEffect_onEffectRestartSubject;
  sub_1B639AA44(0, (unint64_t *)&qword_1EB980098, MEMORY[0x1E4F1AB88]);
  swift_allocObject();
  uint64_t v7 = v1;
  *(void *)&v1[v6] = sub_1B6E31378();
  *(void *)&v7[OBJC_IVAR____TtC3VFX9VFXEffect_cancellables] = MEMORY[0x1E4FBC870];
  v7[OBJC_IVAR____TtC3VFX9VFXEffect__enabled] = 1;
  v7[OBJC_IVAR____TtC3VFX9VFXEffect__tombstoned] = 0;
  swift_unknownObjectWeakAssign();
  *(_DWORD *)uint64_t v2 = 0;
  v2[4] = 1;
  uint64_t v8 = &v7[OBJC_IVAR____TtC3VFX9VFXEffect_name];
  *(void *)uint64_t v8 = 0;
  *((void *)v8 + 1) = 0xE000000000000000;

  v10.receiver = v7;
  v10.super_class = (Class)type metadata accessor for VFXEffect();
  return objc_msgSendSuper2(&v10, sel_init);
}

char *sub_1B639D0D0(uint64_t a1, unint64_t a2)
{
  uint64_t v46 = type metadata accessor for BundleInfo();
  MEMORY[0x1F4188790](v46, v4);
  uint64_t v6 = (char *)&v45 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7, v8);
  uint64_t v47 = (uint64_t)&v45 - v9;
  id v10 = objc_msgSend(objc_allocWithZone(v2), sel_init);
  swift_unknownObjectWeakAssign();
  uint64_t v11 = (char *)v10;
  int v12 = sub_1B6299E70(0xFFFFFFFF);
  uint64_t v13 = (unsigned int *)&v11[OBJC_IVAR____TtC3VFX9VFXEffect_effectID];
  *uint64_t v13 = v12 ^ 0x80000000;
  *((unsigned char *)v13 + 4) = 0;
  uint64_t v14 = sub_1B6E30E58();
  uint64_t v15 = (uint64_t *)&v11[OBJC_IVAR____TtC3VFX9VFXEffect_name];
  *uint64_t v15 = v14;
  v15[1] = v16;
  swift_bridgeObjectRelease();
  uint64_t v17 = &v11[OBJC_IVAR____TtC3VFX9VFXEffect_url];
  sub_1B63956DC((uint64_t)&v11[OBJC_IVAR____TtC3VFX9VFXEffect_url], (uint64_t)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718], (uint64_t (*)(void))sub_1B6397CE8);
  uint64_t v18 = sub_1B6E30F48();
  uint64_t v19 = *(void *)(v18 - 8);
  (*(void (**)(char *, unint64_t, uint64_t))(v19 + 16))(v17, a2, v18);
  uint64_t v48 = v19;
  uint64_t v49 = v18;
  (*(void (**)(char *, void, uint64_t, uint64_t))(v19 + 56))(v17, 0, 1, v18);
  unint64_t v20 = sub_1B639D66C();
  uint64_t v21 = *v13;
  int v22 = *((unsigned __int8 *)v13 + 4);
  swift_retain();
  LOBYTE(v53) = v22;
  if (v22) {
    uint64_t v23 = 0;
  }
  else {
    uint64_t v23 = v21;
  }
  unint64_t v50 = a2;
  uint64_t v24 = v51;
  uint64_t v25 = sub_1B639AB54((uint64_t)v6, a2, 0, v20, v23 | ((unint64_t)v22 << 32));
  if (v24)
  {

    swift_release();
    swift_release();
    (*(void (**)(unint64_t, uint64_t))(v48 + 8))(v50, v49);
  }
  else
  {
    uint64_t v26 = v25;
    uint64_t v27 = (uint64_t)v6;
    uint64_t v28 = v47;
    sub_1B6887628(v27, v47);
    v26(v20, 7, 0);
    uint64_t v51 = 0;
    uint64_t v30 = v46;
    if ((v22 & 1) == 0)
    {
      uint64_t v31 = *(void **)(v20 + 176);
      swift_retain();
      uint64_t v32 = v51;
      uint64_t v33 = sub_1B6304AB4((uint64_t)&type metadata for EffectsRegistry, (uint64_t)&off_1F0F685A0, v31);
      swift_release();
      uint64_t v53 = v33;
      uint64_t v34 = sub_1B67EA3D8(&v52, v21);
      uint64_t v35 = v53;
      MEMORY[0x1F4188790](v34, v36);
      *(&v45 - 2) = v35;
      uint64_t v37 = *(void **)(v20 + 176);
      MEMORY[0x1F4188790](v38, v39);
      *(&v45 - 2) = (uint64_t)sub_1B6914E48;
      *(&v45 - 1) = v40;
      swift_retain();
      uint64_t v28 = v47;
      sub_1B636E6CC((uint64_t)&type metadata for EffectsRegistry, (uint64_t)&off_1F0F685A0, v37, (void (*)(uint64_t))sub_1B63957FC);
      uint64_t v51 = v32;
      swift_release();
      swift_bridgeObjectRelease();
    }
    swift_release();
    uint64_t v41 = *(void *)(v28 + *(int *)(v30 + 24));
    sub_1B67E9670(v28);
    swift_release();
    swift_release();
    *(void *)&v11[OBJC_IVAR____TtC3VFX9VFXEffect_version] = v41;
    uint64_t v53 = sub_1B6B5BF60();
    uint64_t v42 = swift_allocObject();
    swift_unknownObjectUnownedInit();
    uint64_t v43 = swift_allocObject();
    *(void *)(v43 + 16) = sub_1B6B6587C;
    *(void *)(v43 + 24) = v42;
    uint64_t v44 = (uint64_t (*)(void, uint64_t, void, void))MEMORY[0x1E4F1AAE0];
    sub_1B639AA44(0, &qword_1EB980090, MEMORY[0x1E4F1AAE0]);
    sub_1B6B5D2B4(&qword_1EB980FB8, &qword_1EB980090, v44);
    sub_1B6E313C8();
    swift_release();
    swift_release();
    sub_1B6E31348();
    swift_release();
    sub_1B6B5CA00();

    (*(void (**)(unint64_t, uint64_t))(v48 + 8))(v50, v49);
  }
  return v11;
}

uint64_t sub_1B639D66C()
{
  uint64_t v1 = MEMORY[0x1BA9B8670](v0 + OBJC_IVAR____TtC3VFX9VFXEffect_scene);
  if (v1)
  {
    uint64_t v2 = (void *)v1;
    uint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC3VFX8VFXScene_entityManager);
    swift_retain();

    return v3;
  }
  else
  {
    sub_1B6E328C8();
    sub_1B6E31948();
    sub_1B6E33098();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    uint64_t result = sub_1B6E32BE8();
    __break(1u);
  }
  return result;
}

uint64_t sub_1B639D7BC()
{
  uint64_t v0 = swift_allocObject();
  sub_1B6296B18();
  return v0;
}

const char *sub_1B639D7F4()
{
  return "LOD";
}

uint64_t type metadata accessor for GPUHelper()
{
  return self;
}

uint64_t sub_1B639D82C()
{
  uint64_t result = type metadata accessor for Scheduler();
  qword_1EB997EA0 = result;
  return result;
}

uint64_t sub_1B639D850@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1B639D8D4(a1);
  if (!v2)
  {
    *(void *)a2 = result;
    *(void *)(a2 + 8) = v5;
    *(unsigned char *)(a2 + 16) = v6;
  }
  return result;
}

unint64_t sub_1B639D880()
{
  unint64_t result = qword_1EB97FFE0;
  if (!qword_1EB97FFE0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97FFE0);
  }
  return result;
}

uint64_t sub_1B639D8D4(void *a1)
{
  sub_1B6395F3C(0, &qword_1EB980AD0, (uint64_t (*)(void))sub_1B639DD40, (uint64_t)&type metadata for ColorRamp.CodingKeys, MEMORY[0x1E4FBBDC0]);
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(v3 - 8);
  MEMORY[0x1F4188790](v3, v6);
  uint64_t v8 = (char *)&v11 - v7;
  uint64_t v9 = a1[3];
  sub_1B62C14BC(a1, v9);
  sub_1B639DD40();
  sub_1B6E33A48();
  if (v1)
  {
    _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)a1);
  }
  else
  {
    sub_1B63996E0();
    char v12 = 0;
    sub_1B6399648(&qword_1EB980368, (unint64_t *)&qword_1EB97D210);
    sub_1B6E32DF8();
    uint64_t v9 = v13;
    sub_1B6399A70(0, (unint64_t *)&qword_1EB980320);
    char v12 = 1;
    sub_1B6399878((unint64_t *)&qword_1EB980328);
    swift_bridgeObjectRetain();
    sub_1B6E32DF8();
    char v12 = 2;
    sub_1B639DC98();
    swift_bridgeObjectRetain();
    sub_1B6E32DF8();
    (*(void (**)(char *, uint64_t))(v5 + 8))(v8, v4);
    _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)a1);
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  return v9;
}

uint64_t sub_1B639DC38()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B639DC98()
{
  unint64_t result = qword_1EB97FFD0;
  if (!qword_1EB97FFD0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97FFD0);
  }
  return result;
}

unint64_t sub_1B639DCEC()
{
  unint64_t result = qword_1EB97FFC0;
  if (!qword_1EB97FFC0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97FFC0);
  }
  return result;
}

unint64_t sub_1B639DD40()
{
  unint64_t result = qword_1EB97FFA8;
  if (!qword_1EB97FFA8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97FFA8);
  }
  return result;
}

void sub_1B639DD94()
{
  sub_1B638BFE4(319, (unint64_t *)&qword_1EB9857F0, MEMORY[0x1E4F276F0]);
  if (v0 <= 0x3F) {
    swift_updateClassMetadata2();
  }
}

void sub_1B639DEB4()
{
  sub_1B639DED4(*(id **)(v0 + 16), *(void **)(v0 + 24), *(void *)(v0 + 32), *(void ***)(v0 + 40));
}

void sub_1B639DED4(id *a1, void *a2, uint64_t a3, void **a4)
{
  uint64_t v9 = sub_1B6E30F48();
  uint64_t v10 = *(void *)(v9 - 8);
  MEMORY[0x1F4188790](v9, v11);
  uint64_t v13 = (char *)&v21 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  type metadata accessor for VFXEffect();
  (*(void (**)(char *, uint64_t, uint64_t))(v10 + 16))(v13, a3, v9);
  uint64_t v14 = a2;
  uint64_t v15 = sub_1B639D0D0((uint64_t)v14, (unint64_t)v13);
  if (v4)
  {

    uint64_t v16 = *a4;
    *a4 = v4;
  }
  else
  {
    uint64_t v17 = v15;

    id v18 = *a1;
    *a1 = v17;

    uint64_t v19 = &v14[OBJC_IVAR____TtC3VFX8VFXScene_effects];
    id v20 = *a1;
    MEMORY[0x1BA9B3870]();
    if (*(void *)((*(void *)v19 & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(void *)((*(void *)v19 & 0xFFFFFFFFFFFFFF8)
                                                                                 + 0x18) >> 1)
      sub_1B6E31C78();
    sub_1B6E31CC8();
    sub_1B6E31C48();
  }
}

uint64_t dispatch thunk of VFXScene.addEffect(from:)()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x3C0))();
}

void sub_1B639E0C0(uint64_t a1)
{
  uint64_t v2 = 0;
  id v3 = 0;
  v1[4] = a1;
  v1[5] = &v2;
  sub_1B63BA2B0(sub_1B639DEB4, (uint64_t)v1);
  if (v2)
  {
    swift_willThrow();
  }
}

uint64_t type metadata accessor for VFXScene.LoadOptions(uint64_t a1)
{
  return sub_1B633A29C(a1, (uint64_t *)&unk_1EB981AC8);
}

id VFXScene.LoadOptions.init()()
{
  v0[OBJC_IVAR___VFXSceneLoadOptions_isAuthoringWorld] = 0;
  v0[OBJC_IVAR___VFXSceneLoadOptions_isVFX2] = 0;
  v0[OBJC_IVAR___VFXSceneLoadOptions_enableRuntimeScriptCompilation] = 0;
  v0[OBJC_IVAR___VFXSceneLoadOptions_allowLoadingFromFuture] = 0;
  v0[OBJC_IVAR___VFXSceneLoadOptions_setupAsTemplate] = 0;
  v0[OBJC_IVAR___VFXSceneLoadOptions_automaticallyPrepareScene] = 1;
  v0[OBJC_IVAR___VFXSceneLoadOptions_setupAsyncRuntime] = 0;
  *(void *)&v0[OBJC_IVAR___VFXSceneLoadOptions_world] = 0;
  *(void *)&v0[OBJC_IVAR___VFXSceneLoadOptions_asyncRuntimeLock] = 0;
  v0[OBJC_IVAR___VFXSceneLoadOptions_loadBindingsMetadata] = 1;
  v0[OBJC_IVAR___VFXSceneLoadOptions_enableParallelDecoding] = 1;
  v0[OBJC_IVAR___VFXSceneLoadOptions_setupRenderer] = 1;
  *(void *)&v0[OBJC_IVAR___VFXSceneLoadOptions_colorPixelFormat] = 0;
  *(void *)&v0[OBJC_IVAR___VFXSceneLoadOptions_depthPixelFormat] = 0;
  v0[OBJC_IVAR___VFXSceneLoadOptions_enableDeferredRendering] = 2;
  v0[OBJC_IVAR___VFXSceneLoadOptions_internalPixelFormatDepth] = 1;
  v0[OBJC_IVAR___VFXSceneLoadOptions_useGammaBlending] = 0;
  v0[OBJC_IVAR___VFXSceneLoadOptions_doNotClearRenderOutput] = 0;
  *(void *)&v0[OBJC_IVAR___VFXSceneLoadOptions_device] = 0;
  *(void *)&v0[OBJC_IVAR___VFXSceneLoadOptions_commandQueue] = 0;
  uint64_t v1 = &v0[OBJC_IVAR___VFXSceneLoadOptions_clientID];
  *uint64_t v1 = 0;
  v1[1] = 0;
  uint64_t v2 = &v0[OBJC_IVAR___VFXSceneLoadOptions_metalLibraryURL];
  uint64_t v3 = sub_1B6E30F48();
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v3 - 8) + 56))(v2, 1, 1, v3);
  *(void *)&v0[OBJC_IVAR___VFXSceneLoadOptions_systemRegistrationOptions] = 3179529;
  uint64_t v4 = OBJC_IVAR___VFXSceneLoadOptions_counterStorage;
  uint64_t v5 = v0;
  *(void *)&v0[v4] = vfx_counters_null();
  *(_DWORD *)&v5[OBJC_IVAR___VFXSceneLoadOptions_peerPid] = -1;
  *(_DWORD *)&v5[OBJC_IVAR___VFXSceneLoadOptions_peerTaskIdentity] = 0;
  v5[OBJC_IVAR___VFXSceneLoadOptions_loadPrecompiledScripts] = 1;

  v7.receiver = v5;
  v7.super_class = (Class)type metadata accessor for VFXScene.LoadOptions(0);
  return objc_msgSendSuper2(&v7, sel_init);
}

uint64_t dispatch thunk of VFXScene.LoadOptions.clientID.setter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x328))();
}

uint64_t sub_1B639E3C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(v2 + OBJC_IVAR___VFXSceneLoadOptions_clientID);
  *uint64_t v3 = a1;
  v3[1] = a2;
  return swift_bridgeObjectRelease();
}

uint64_t dispatch thunk of VFXScene.LoadOptions.loadBindingsMetadata.setter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x208))();
}

uint64_t sub_1B639E418(uint64_t result)
{
  *(unsigned char *)(v1 + OBJC_IVAR___VFXSceneLoadOptions_loadBindingsMetadata) = result;
  return result;
}

uint64_t dispatch thunk of VFXScene.LoadOptions.setupAsTemplate.setter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x190))();
}

uint64_t sub_1B639E464(uint64_t result)
{
  *(unsigned char *)(v1 + OBJC_IVAR___VFXSceneLoadOptions_setupAsTemplate) = result;
  return result;
}

uint64_t dispatch thunk of VFXScene.LoadOptions.metalLibraryURL.setter()
{
  return (*(uint64_t (**)(void))((*MEMORY[0x1E4FBC8C8] & *v0) + 0x340))();
}

uint64_t sub_1B639E4B0(uint64_t a1)
{
  return sub_1B63BE06C(a1, v1 + OBJC_IVAR___VFXSceneLoadOptions_metalLibraryURL);
}

uint64_t type metadata accessor for Renderer()
{
  return self;
}

void *sub_1B639E4E4(void *a1, uint64_t a2, uint64_t a3)
{
  id v6 = objc_msgSend(*(id *)(v3 + 16), sel_newTextureWithDescriptor_, a1);
  if (v6)
  {
    objc_super v7 = v6;
    sub_1B6331FD0((uint64_t)v6);
    if (a3) {
      uint64_t v8 = (void *)sub_1B6E31768();
    }
    else {
      uint64_t v8 = 0;
    }
    objc_msgSend(v7, sel_setLabel_, v8);
  }
  else
  {
    if (qword_1EB9852D0 != -1) {
      swift_once();
    }
    swift_retain();
    sub_1B6E328C8();
    swift_bridgeObjectRelease();
    v12[1] = 0x80000001B6F4A600;
    swift_bridgeObjectRetain();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    id v9 = objc_msgSend(a1, sel_description);
    sub_1B6E31798();

    sub_1B6E31948();
    swift_bridgeObjectRelease();
    int v10 = sub_1B6E32148();
    if (qword_1EB9854F8 != -1) {
      swift_once();
    }
    v12[0] = 0;
    swift_retain();
    sub_1B6B33E34(v10, v12, 0xD00000000000001BLL, 0x80000001B6F4A600);
    swift_release();
    swift_bridgeObjectRelease();
    swift_release();
    return 0;
  }
  return v7;
}

uint64_t type metadata accessor for OSLogger()
{
  return self;
}

unsigned char *storeEnumTagSinglePayload for Language(unsigned char *result, unsigned int a2, unsigned int a3)
{
  if (a3 + 2 >= 0xFFFF00) {
    int v3 = 4;
  }
  else {
    int v3 = 2;
  }
  if ((a3 + 2) >> 8 < 0xFF) {
    unsigned int v4 = 1;
  }
  else {
    unsigned int v4 = v3;
  }
  if (a3 >= 0xFE) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  if (a2 > 0xFD)
  {
    unsigned int v6 = ((a2 - 254) >> 8) + 1;
    char *result = a2 + 2;
    switch(v5)
    {
      case 1:
        result[1] = v6;
        break;
      case 2:
        *(_WORD *)(result + 1) = v6;
        break;
      case 3:
LABEL_23:
        __break(1u);
        break;
      case 4:
        *(_DWORD *)(result + 1) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    switch(v5)
    {
      case 1:
        result[1] = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      case 2:
        *(_WORD *)(result + 1) = 0;
        goto LABEL_17;
      case 3:
        goto LABEL_23;
      case 4:
        *(_DWORD *)(result + 1) = 0;
        if (!a2) {
          return result;
        }
        goto LABEL_18;
      default:
LABEL_17:
        if (a2) {
LABEL_18:
        }
          char *result = a2 + 2;
        break;
    }
  }
  return result;
}

uint64_t sub_1B639E7FC()
{
  return sub_1B6E31B98();
}

uint64_t sub_1B639E85C@<X0>(unsigned char *a1@<X8>)
{
  uint64_t result = sub_1B639E934();
  *a1 = result;
  return result;
}

unint64_t sub_1B639E88C()
{
  unint64_t result = qword_1EB97FF10;
  if (!qword_1EB97FF10)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97FF10);
  }
  return result;
}

unint64_t sub_1B639E8E0()
{
  unint64_t result = qword_1EB97FF08;
  if (!qword_1EB97FF08)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97FF08);
  }
  return result;
}

uint64_t sub_1B639E934()
{
  unint64_t v0 = sub_1B6E32CC8();
  swift_bridgeObjectRelease();
  if (v0 >= 3) {
    return 3;
  }
  else {
    return v0;
  }
}

uint64_t sub_1B639E980()
{
  type metadata accessor for DrawCall();
  uint64_t v0 = swift_allocObject();
  uint64_t result = sub_1B630041C();
  qword_1EB9979D0 = v0;
  return result;
}

uint64_t sub_1B639E9BC(uint64_t a1, void (*a2)(void), uint64_t *a3)
{
  a2();
  uint64_t v4 = swift_allocObject();
  sub_1B639AAAC();
  swift_allocObject();
  uint64_t result = sub_1B6E31378();
  *(void *)(v4 + 16) = result;
  *a3 = v4;
  return result;
}

char *sub_1B639EA20(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  int v3 = (char *)MEMORY[0x1E4FBC860];
  uint64_t v4 = sub_1B629CE28(0, v2, 0, MEMORY[0x1E4FBC860]);
  uint64_t v5 = sub_1B6397840(0, v2, 0, v3);
  if (v2)
  {
    swift_bridgeObjectRetain();
    unsigned int v6 = (_DWORD *)(a1 + 48);
    do
    {
      long long v7 = *((_OWORD *)v6 - 1);
      int v8 = *v6;
      unint64_t v10 = *((void *)v4 + 2);
      unint64_t v9 = *((void *)v4 + 3);
      if (v10 >= v9 >> 1)
      {
        long long v15 = *((_OWORD *)v6 - 1);
        uint64_t v13 = sub_1B629CE28(v9 > 1, v10 + 1, 1, v4);
        long long v7 = v15;
        uint64_t v4 = v13;
      }
      *((void *)v4 + 2) = v10 + 1;
      *(_OWORD *)&v4[16 * v10 + 32] = v7;
      unint64_t v12 = *((void *)v5 + 2);
      unint64_t v11 = *((void *)v5 + 3);
      if (v12 >= v11 >> 1) {
        uint64_t v5 = sub_1B6397840(v11 > 1, v12 + 1, 1, v5);
      }
      *((void *)v5 + 2) = v12 + 1;
      *(_DWORD *)&v5[4 * v12 + 32] = v8;
      v6 += 8;
      --v2;
    }
    while (v2);
    swift_bridgeObjectRelease();
  }
  return v4;
}

uint64_t sub_1B639EB5C@<X0>(char a1@<W0>, char a2@<W1>, char a3@<W2>, char a4@<W3>, char a5@<W4>, uint64_t a6@<X8>)
{
  long long v7 = v6;
  unint64_t v12 = *v6;
  uint64_t v13 = (uint64_t)*v6 + 41;
  uint64_t v14 = (*v6)[8];
  unint64_t v15 = v12[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76900;
  *(void *)(inited + 32) = &type metadata for WorldTransform;
  *(void *)(inited + 40) = &off_1F0F67798;
  *(void *)(inited + 48) = &type metadata for LODRenderer;
  *(void *)(inited + 56) = &off_1F0F55948;
  *(void *)(inited + 64) = &type metadata for LODState;
  *(void *)(inited + 72) = &off_1F0FA4738;
  *(void *)(inited + 80) = &type metadata for ModelRenderer;
  *(void *)(inited + 88) = &off_1F0F60300;
  *(void *)(inited + 96) = &type metadata for Parent;
  *(void *)(inited + 104) = &off_1F0FA04A8;
  if (v15 > 0xF)
  {
    uint64_t v35 = sub_1B62F79D4((char *)(v13 + v14), v15 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v35;
  }
  uint64_t v17 = v12[10];
  int64_t v18 = v12[11];
  sub_1B62D853C(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v19 = swift_initStackObject();
  *(_OWORD *)(v19 + 16) = xmmword_1B6E76900;
  *(unsigned char *)(v19 + 32) = a1;
  *(unsigned char *)(v19 + 33) = a2;
  *(unsigned char *)(v19 + 34) = a3;
  *(unsigned char *)(v19 + 35) = a4;
  *(unsigned char *)(v19 + 36) = a5;
  if (v18)
  {
    uint64_t v35 = sub_1B62F7C94((char *)(v13 + v17), v18);
    sub_1B62F81D8(v19);
    uint64_t v19 = v35;
    unint64_t v20 = *(void *)(v35 + 16);
  }
  else
  {
    unint64_t v20 = 5;
  }
  uint64_t v21 = (uint64_t)*v7 + 41;
  int v22 = (char *)(v21 + (*v7)[12]);
  unint64_t v23 = (unint64_t)(*v7)[13] >> 4;
  uint64_t v24 = (char *)(v21 + (*v7)[14]);
  uint64_t v25 = (*v7)[15] / 0x18u;
  int v26 = *((_DWORD *)v7 + 2);
  char v27 = *((unsigned char *)v7 + 12);
  uint64_t v28 = v7[4];
  uint64_t v29 = v7[2];
  char v30 = *((unsigned char *)v7 + 24);
  uint64_t v31 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v19 + 32), v20, v22, v23, v24, v25);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a6 = v31;
  *(_DWORD *)(a6 + 8) = v26;
  *(unsigned char *)(a6 + 12) = v27;
  *(_WORD *)(a6 + 13) = v36;
  *(unsigned char *)(a6 + 15) = v37;
  *(void *)(a6 + 16) = v29;
  *(unsigned char *)(a6 + 24) = v30;
  *(_DWORD *)(a6 + 25) = v35;
  *(_DWORD *)(a6 + 28) = *(_DWORD *)((char *)&v35 + 3);
  *(void *)(a6 + 32) = v28;
  return result;
}

uint64_t sub_1B639EDD8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F93A4(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E85730;
  *(void *)(inited + 32) = &type metadata for SpotLight;
  *(void *)(inited + 40) = &off_1F0FA9D60;
  *(void *)(inited + 48) = &type metadata for WorldTransform;
  *(void *)(inited + 56) = &off_1F0F67798;
  *(void *)(inited + 64) = &type metadata for Color;
  *(void *)(inited + 72) = &off_1F0F9ED50;
  *(void *)(inited + 80) = &type metadata for Shadow;
  *(void *)(inited + 88) = &off_1F0FA1928;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 4;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 4;
  *(_DWORD *)(v12 + 32) = 50529027;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  unint64_t v20 = v2[4];
  uint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B639F020@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F93A4(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E85730;
  *(void *)(inited + 32) = &type metadata for DirectionalLight;
  *(void *)(inited + 40) = &off_1F0F6BC38;
  *(void *)(inited + 48) = &type metadata for WorldTransform;
  *(void *)(inited + 56) = &off_1F0F67798;
  *(void *)(inited + 64) = &type metadata for Color;
  *(void *)(inited + 72) = &off_1F0F9ED50;
  *(void *)(inited + 80) = &type metadata for Shadow;
  *(void *)(inited + 88) = &off_1F0FA1928;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 4;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 4;
  *(_DWORD *)(v12 + 32) = 50529027;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  unint64_t v20 = v2[4];
  uint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B639F268@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F93A4(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E85730;
  *(void *)(inited + 32) = &type metadata for PointLight;
  *(void *)(inited + 40) = &off_1F0F536F0;
  *(void *)(inited + 48) = &type metadata for WorldTransform;
  *(void *)(inited + 56) = &off_1F0F67798;
  *(void *)(inited + 64) = &type metadata for Color;
  *(void *)(inited + 72) = &off_1F0F9ED50;
  *(void *)(inited + 80) = &type metadata for Shadow;
  *(void *)(inited + 88) = &off_1F0FA1928;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 4;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 4;
  *(_DWORD *)(v12 + 32) = 50529027;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  unint64_t v20 = v2[4];
  uint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B639F4B0@<X0>(char a1@<W0>, char a2@<W1>, char a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v6 = v5;
  unint64_t v11 = *v5;
  uint64_t v12 = (uint64_t)*v5 + 41;
  uint64_t v13 = (*v5)[8];
  unint64_t v14 = v11[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E85730;
  *(void *)(inited + 32) = &type metadata for Position;
  *(void *)(inited + 40) = &off_1F0FA6F58;
  *(void *)(inited + 48) = &type metadata for LODRenderer;
  *(void *)(inited + 56) = &off_1F0F55948;
  *(void *)(inited + 64) = &type metadata for LODState;
  *(void *)(inited + 72) = &off_1F0FA4738;
  *(void *)(inited + 80) = &type metadata for ModelRenderer;
  *(void *)(inited + 88) = &off_1F0F60300;
  if (v14 > 0xF)
  {
    uint64_t v33 = sub_1B62F79D4((char *)(v12 + v13), v14 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v33;
  }
  uint64_t v16 = v11[10];
  int64_t v17 = v11[11];
  sub_1B62D853C(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v18 = swift_initStackObject();
  *(_OWORD *)(v18 + 16) = xmmword_1B6E85730;
  *(unsigned char *)(v18 + 32) = a1;
  *(unsigned char *)(v18 + 33) = a2;
  *(unsigned char *)(v18 + 34) = a3;
  *(unsigned char *)(v18 + 35) = a4;
  if (v17)
  {
    uint64_t v33 = sub_1B62F7C94((char *)(v12 + v16), v17);
    sub_1B62F81D8(v18);
    uint64_t v18 = v33;
    unint64_t v19 = *(void *)(v33 + 16);
  }
  else
  {
    unint64_t v19 = 4;
  }
  uint64_t v20 = (uint64_t)*v6 + 41;
  uint64_t v21 = (char *)(v20 + (*v6)[12]);
  unint64_t v22 = (unint64_t)(*v6)[13] >> 4;
  uint64_t v23 = (char *)(v20 + (*v6)[14]);
  uint64_t v24 = (*v6)[15] / 0x18u;
  int v25 = *((_DWORD *)v6 + 2);
  char v26 = *((unsigned char *)v6 + 12);
  char v27 = v6[4];
  uint64_t v28 = v6[2];
  char v29 = *((unsigned char *)v6 + 24);
  uint64_t v30 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v18 + 32), v19, v21, v22, v23, v24);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a5 = v30;
  *(_DWORD *)(a5 + 8) = v25;
  *(unsigned char *)(a5 + 12) = v26;
  *(_WORD *)(a5 + 13) = v34;
  *(unsigned char *)(a5 + 15) = v35;
  *(void *)(a5 + 16) = v28;
  *(unsigned char *)(a5 + 24) = v29;
  *(_DWORD *)(a5 + 25) = v33;
  *(_DWORD *)(a5 + 28) = *(_DWORD *)((char *)&v33 + 3);
  *(void *)(a5 + 32) = v27;
  return result;
}

uint64_t sub_1B639F710@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F927C(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77D10;
  *(void *)(inited + 32) = &type metadata for Position;
  *(void *)(inited + 40) = &off_1F0FA6F58;
  *(void *)(inited + 48) = &type metadata for Orientation;
  *(void *)(inited + 56) = &off_1F0F56120;
  *(void *)(inited + 64) = &type metadata for LookAt;
  *(void *)(inited + 72) = &off_1F0FA00B0;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 3;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 3;
  *(_WORD *)(v12 + 32) = 771;
  *(unsigned char *)(v12 + 34) = 3;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  unint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  uint64_t v20 = v2[4];
  uint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B639F948@<X0>(char a1@<W0>, char a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  int64_t v10 = *v4;
  uint64_t v11 = (uint64_t)*v4 + 41;
  uint64_t v12 = (*v4)[8];
  unint64_t v13 = v10[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77D10;
  *(void *)(inited + 32) = &type metadata for LocalAABB;
  *(void *)(inited + 40) = &off_1F0FA8CF0;
  *(void *)(inited + 48) = &type metadata for WorldTransform;
  *(void *)(inited + 56) = &off_1F0F67798;
  *(void *)(inited + 64) = &type metadata for WorldAABB;
  *(void *)(inited + 72) = &off_1F0FAABA0;
  if (v13 > 0xF)
  {
    uint64_t v31 = sub_1B62F79D4((char *)(v11 + v12), v13 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v31;
  }
  uint64_t v15 = v10[10];
  int64_t v16 = v10[11];
  sub_1B62D8328(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v17 = swift_initStackObject();
  *(_OWORD *)(v17 + 16) = xmmword_1B6E77D10;
  *(unsigned char *)(v17 + 32) = a1;
  *(unsigned char *)(v17 + 33) = a2;
  *(unsigned char *)(v17 + 34) = a3;
  if (v16)
  {
    uint64_t v31 = sub_1B62F7C94((char *)(v11 + v15), v16);
    sub_1B62F81D8(v17);
    uint64_t v17 = v31;
    unint64_t v18 = *(void *)(v31 + 16);
  }
  else
  {
    unint64_t v18 = 3;
  }
  uint64_t v19 = (uint64_t)*v5 + 41;
  uint64_t v20 = (char *)(v19 + (*v5)[12]);
  unint64_t v21 = (unint64_t)(*v5)[13] >> 4;
  char v22 = (char *)(v19 + (*v5)[14]);
  uint64_t v23 = (*v5)[15] / 0x18u;
  int v24 = *((_DWORD *)v5 + 2);
  char v25 = *((unsigned char *)v5 + 12);
  __int16 v26 = v5[4];
  char v27 = v5[2];
  char v28 = *((unsigned char *)v5 + 24);
  uint64_t v29 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v17 + 32), v18, v20, v21, v22, v23);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a4 = v29;
  *(_DWORD *)(a4 + 8) = v24;
  *(unsigned char *)(a4 + 12) = v25;
  *(_WORD *)(a4 + 13) = v32;
  *(unsigned char *)(a4 + 15) = v33;
  *(void *)(a4 + 16) = v27;
  *(unsigned char *)(a4 + 24) = v28;
  *(_DWORD *)(a4 + 25) = v31;
  *(_DWORD *)(a4 + 28) = *(_DWORD *)((char *)&v31 + 3);
  *(void *)(a4 + 32) = v26;
  return result;
}

uint64_t sub_1B639FB88@<X0>(char a1@<W0>, char a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  int64_t v10 = *v4;
  uint64_t v11 = (uint64_t)*v4 + 41;
  uint64_t v12 = (*v4)[8];
  unint64_t v13 = v10[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77D10;
  *(void *)(inited + 32) = &type metadata for SkinnedMeshBinding;
  *(void *)(inited + 40) = &off_1F0F7A8E8;
  *(void *)(inited + 48) = &type metadata for MeshModel;
  *(void *)(inited + 56) = &off_1F0FA9050;
  *(void *)(inited + 64) = &type metadata for WorldTransform;
  *(void *)(inited + 72) = &off_1F0F67798;
  if (v13 > 0xF)
  {
    uint64_t v31 = sub_1B62F79D4((char *)(v11 + v12), v13 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v31;
  }
  uint64_t v15 = v10[10];
  int64_t v16 = v10[11];
  sub_1B62D8328(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v17 = swift_initStackObject();
  *(_OWORD *)(v17 + 16) = xmmword_1B6E77D10;
  *(unsigned char *)(v17 + 32) = a1;
  *(unsigned char *)(v17 + 33) = a2;
  *(unsigned char *)(v17 + 34) = a3;
  if (v16)
  {
    uint64_t v31 = sub_1B62F7C94((char *)(v11 + v15), v16);
    sub_1B62F81D8(v17);
    uint64_t v17 = v31;
    unint64_t v18 = *(void *)(v31 + 16);
  }
  else
  {
    unint64_t v18 = 3;
  }
  uint64_t v19 = (uint64_t)*v5 + 41;
  uint64_t v20 = (char *)(v19 + (*v5)[12]);
  unint64_t v21 = (unint64_t)(*v5)[13] >> 4;
  char v22 = (char *)(v19 + (*v5)[14]);
  uint64_t v23 = (*v5)[15] / 0x18u;
  int v24 = *((_DWORD *)v5 + 2);
  char v25 = *((unsigned char *)v5 + 12);
  __int16 v26 = v5[4];
  char v27 = v5[2];
  char v28 = *((unsigned char *)v5 + 24);
  uint64_t v29 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v17 + 32), v18, v20, v21, v22, v23);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a4 = v29;
  *(_DWORD *)(a4 + 8) = v24;
  *(unsigned char *)(a4 + 12) = v25;
  *(_WORD *)(a4 + 13) = v32;
  *(unsigned char *)(a4 + 15) = v33;
  *(void *)(a4 + 16) = v27;
  *(unsigned char *)(a4 + 24) = v28;
  *(_DWORD *)(a4 + 25) = v31;
  *(_DWORD *)(a4 + 28) = *(_DWORD *)((char *)&v31 + 3);
  *(void *)(a4 + 32) = v26;
  return result;
}

uint64_t sub_1B639FDC8@<X0>(char a1@<W0>, char a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  int64_t v10 = *v4;
  uint64_t v11 = (uint64_t)*v4 + 41;
  uint64_t v12 = (*v4)[8];
  unint64_t v13 = v10[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77D10;
  *(void *)(inited + 32) = &type metadata for EmitterDescription;
  *(void *)(inited + 40) = &off_1F0F76688;
  *(void *)(inited + 48) = &type metadata for EmitterRuntime;
  *(void *)(inited + 56) = &off_1F0F63FA8;
  *(void *)(inited + 64) = &type metadata for WorldAABB;
  *(void *)(inited + 72) = &off_1F0FAABA0;
  if (v13 > 0xF)
  {
    uint64_t v31 = sub_1B62F79D4((char *)(v11 + v12), v13 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v31;
  }
  uint64_t v15 = v10[10];
  int64_t v16 = v10[11];
  sub_1B62D8328(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v17 = swift_initStackObject();
  *(_OWORD *)(v17 + 16) = xmmword_1B6E77D10;
  *(unsigned char *)(v17 + 32) = a1;
  *(unsigned char *)(v17 + 33) = a2;
  *(unsigned char *)(v17 + 34) = a3;
  if (v16)
  {
    uint64_t v31 = sub_1B62F7C94((char *)(v11 + v15), v16);
    sub_1B62F81D8(v17);
    uint64_t v17 = v31;
    unint64_t v18 = *(void *)(v31 + 16);
  }
  else
  {
    unint64_t v18 = 3;
  }
  uint64_t v19 = (uint64_t)*v5 + 41;
  uint64_t v20 = (char *)(v19 + (*v5)[12]);
  unint64_t v21 = (unint64_t)(*v5)[13] >> 4;
  char v22 = (char *)(v19 + (*v5)[14]);
  uint64_t v23 = (*v5)[15] / 0x18u;
  int v24 = *((_DWORD *)v5 + 2);
  char v25 = *((unsigned char *)v5 + 12);
  __int16 v26 = v5[4];
  char v27 = v5[2];
  char v28 = *((unsigned char *)v5 + 24);
  uint64_t v29 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v17 + 32), v18, v20, v21, v22, v23);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a4 = v29;
  *(_DWORD *)(a4 + 8) = v24;
  *(unsigned char *)(a4 + 12) = v25;
  *(_WORD *)(a4 + 13) = v32;
  *(unsigned char *)(a4 + 15) = v33;
  *(void *)(a4 + 16) = v27;
  *(unsigned char *)(a4 + 24) = v28;
  *(_DWORD *)(a4 + 25) = v31;
  *(_DWORD *)(a4 + 28) = *(_DWORD *)((char *)&v31 + 3);
  *(void *)(a4 + 32) = v26;
  return result;
}

uint64_t sub_1B63A0008@<X0>(char a1@<W0>, char a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  int64_t v10 = *v4;
  uint64_t v11 = (uint64_t)*v4 + 41;
  uint64_t v12 = (*v4)[8];
  unint64_t v13 = v10[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77D10;
  *(void *)(inited + 32) = &type metadata for ProjectionMatrix;
  *(void *)(inited + 40) = &off_1F0F6EF58;
  *(void *)(inited + 48) = &type metadata for PointOfView;
  *(void *)(inited + 56) = &off_1F0F56610;
  *(void *)(inited + 64) = &type metadata for WorldTransform;
  *(void *)(inited + 72) = &off_1F0F67798;
  if (v13 > 0xF)
  {
    uint64_t v31 = sub_1B62F79D4((char *)(v11 + v12), v13 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v31;
  }
  uint64_t v15 = v10[10];
  int64_t v16 = v10[11];
  sub_1B62D8328(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v17 = swift_initStackObject();
  *(_OWORD *)(v17 + 16) = xmmword_1B6E77D10;
  *(unsigned char *)(v17 + 32) = a1;
  *(unsigned char *)(v17 + 33) = a2;
  *(unsigned char *)(v17 + 34) = a3;
  if (v16)
  {
    uint64_t v31 = sub_1B62F7C94((char *)(v11 + v15), v16);
    sub_1B62F81D8(v17);
    uint64_t v17 = v31;
    unint64_t v18 = *(void *)(v31 + 16);
  }
  else
  {
    unint64_t v18 = 3;
  }
  uint64_t v19 = (uint64_t)*v5 + 41;
  uint64_t v20 = (char *)(v19 + (*v5)[12]);
  unint64_t v21 = (unint64_t)(*v5)[13] >> 4;
  char v22 = (char *)(v19 + (*v5)[14]);
  uint64_t v23 = (*v5)[15] / 0x18u;
  int v24 = *((_DWORD *)v5 + 2);
  char v25 = *((unsigned char *)v5 + 12);
  __int16 v26 = v5[4];
  char v27 = v5[2];
  char v28 = *((unsigned char *)v5 + 24);
  uint64_t v29 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v17 + 32), v18, v20, v21, v22, v23);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a4 = v29;
  *(_DWORD *)(a4 + 8) = v24;
  *(unsigned char *)(a4 + 12) = v25;
  *(_WORD *)(a4 + 13) = v32;
  *(unsigned char *)(a4 + 15) = v33;
  *(void *)(a4 + 16) = v27;
  *(unsigned char *)(a4 + 24) = v28;
  *(_DWORD *)(a4 + 25) = v31;
  *(_DWORD *)(a4 + 28) = *(_DWORD *)((char *)&v31 + 3);
  *(void *)(a4 + 32) = v26;
  return result;
}

uint64_t sub_1B63A0248@<X0>(char a1@<W0>, char a2@<W1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5 = v4;
  int64_t v10 = *v4;
  uint64_t v11 = (uint64_t)*v4 + 41;
  uint64_t v12 = (*v4)[8];
  unint64_t v13 = v10[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77D10;
  *(void *)(inited + 32) = &type metadata for WorldTransform;
  *(void *)(inited + 40) = &off_1F0F67798;
  *(void *)(inited + 48) = &type metadata for LastFrameWorldTransform;
  *(void *)(inited + 56) = &off_1F0F8F510;
  *(void *)(inited + 64) = &type metadata for SmoothMotion;
  *(void *)(inited + 72) = &off_1F0F5C588;
  if (v13 > 0xF)
  {
    uint64_t v31 = sub_1B62F79D4((char *)(v11 + v12), v13 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v31;
  }
  uint64_t v15 = v10[10];
  int64_t v16 = v10[11];
  sub_1B62D8328(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v17 = swift_initStackObject();
  *(_OWORD *)(v17 + 16) = xmmword_1B6E77D10;
  *(unsigned char *)(v17 + 32) = a1;
  *(unsigned char *)(v17 + 33) = a2;
  *(unsigned char *)(v17 + 34) = a3;
  if (v16)
  {
    uint64_t v31 = sub_1B62F7C94((char *)(v11 + v15), v16);
    sub_1B62F81D8(v17);
    uint64_t v17 = v31;
    unint64_t v18 = *(void *)(v31 + 16);
  }
  else
  {
    unint64_t v18 = 3;
  }
  uint64_t v19 = (uint64_t)*v5 + 41;
  uint64_t v20 = (char *)(v19 + (*v5)[12]);
  unint64_t v21 = (unint64_t)(*v5)[13] >> 4;
  char v22 = (char *)(v19 + (*v5)[14]);
  uint64_t v23 = (*v5)[15] / 0x18u;
  int v24 = *((_DWORD *)v5 + 2);
  char v25 = *((unsigned char *)v5 + 12);
  __int16 v26 = v5[4];
  char v27 = v5[2];
  char v28 = *((unsigned char *)v5 + 24);
  uint64_t v29 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v17 + 32), v18, v20, v21, v22, v23);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a4 = v29;
  *(_DWORD *)(a4 + 8) = v24;
  *(unsigned char *)(a4 + 12) = v25;
  *(_WORD *)(a4 + 13) = v32;
  *(unsigned char *)(a4 + 15) = v33;
  *(void *)(a4 + 16) = v27;
  *(unsigned char *)(a4 + 24) = v28;
  *(_DWORD *)(a4 + 25) = v31;
  *(_DWORD *)(a4 + 28) = *(_DWORD *)((char *)&v31 + 3);
  *(void *)(a4 + 32) = v26;
  return result;
}

uint64_t sub_1B63A0488@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for LocalAABB;
  *(void *)(inited + 40) = &off_1F0FA8CF0;
  *(void *)(inited + 48) = &type metadata for WorldTransform;
  *(void *)(inited + 56) = &off_1F0F67798;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 2;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 2;
  *(_WORD *)(v12 + 32) = 771;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  unint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  int64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  uint64_t v20 = v2[4];
  unint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A06A8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for Velocity;
  *(void *)(inited + 40) = &off_1F0FA7C80;
  *(void *)(inited + 48) = &type metadata for ParticleAffectedByGlobalFluidSolver2DSolver;
  *(void *)(inited + 56) = &off_1F0F9DF90;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 2;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 2;
  *(_WORD *)(v12 + 32) = 771;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  unint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  int64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  uint64_t v20 = v2[4];
  unint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A08C8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for Position;
  *(void *)(inited + 40) = &off_1F0FA6F58;
  *(void *)(inited + 48) = &type metadata for SineMoveAction;
  *(void *)(inited + 56) = &off_1F0F66640;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 2;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 2;
  *(_WORD *)(v12 + 32) = 771;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  unint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  int64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  uint64_t v20 = v2[4];
  unint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A0AE8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for Scale;
  *(void *)(inited + 40) = &off_1F0F9F580;
  *(void *)(inited + 48) = &type metadata for TransientOriginScale;
  *(void *)(inited + 56) = &off_1F0F843D8;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 2;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 2;
  *(_WORD *)(v12 + 32) = 771;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  unint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  int64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  uint64_t v20 = v2[4];
  unint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A0D08@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for Color;
  *(void *)(inited + 40) = &off_1F0F9ED50;
  *(void *)(inited + 48) = &type metadata for TransientOriginColor;
  *(void *)(inited + 56) = &off_1F0F84300;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 2;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 2;
  *(_WORD *)(v12 + 32) = 771;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  unint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  int64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  uint64_t v20 = v2[4];
  unint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A0F28@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for ParticleFluidSolver2DSolver;
  *(void *)(inited + 40) = &off_1F0F97DC8;
  *(void *)(inited + 48) = &type metadata for WorldTransform;
  *(void *)(inited + 56) = &off_1F0F67798;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 2;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 2;
  *(_WORD *)(v12 + 32) = 771;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  unint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  int64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  uint64_t v20 = v2[4];
  unint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A1148@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = type metadata accessor for SceneKitRenderer(0);
  uint64_t v5 = *v2;
  uint64_t v6 = *v2 + 41;
  uint64_t v7 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v8 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = v4;
  *(void *)(inited + 40) = &off_1F0F6F400;
  *(void *)(inited + 48) = &type metadata for WorldTransform;
  *(void *)(inited + 56) = &off_1F0F67798;
  if (v8 > 0xF)
  {
    uint64_t v26 = sub_1B62F79D4((char *)(v6 + v7), v8 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v26;
  }
  uint64_t v10 = *(unsigned __int16 *)(v5 + 20);
  int64_t v11 = *(unsigned __int16 *)(v5 + 22);
  unint64_t v12 = 2;
  uint64_t v13 = sub_1B6E31C98();
  *(void *)(v13 + 16) = 2;
  *(_WORD *)(v13 + 32) = 771;
  if (v11)
  {
    uint64_t v26 = sub_1B62F7C94((char *)(v6 + v10), v11);
    sub_1B62F81D8(v13);
    uint64_t v13 = v26;
    unint64_t v12 = *(void *)(v26 + 16);
  }
  uint64_t v14 = *v2 + 41;
  unint64_t v15 = (char *)(v14 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v16 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  uint64_t v17 = (char *)(v14 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v18 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v19 = *((_DWORD *)v2 + 2);
  char v20 = *((unsigned char *)v2 + 12);
  uint64_t v21 = v2[4];
  uint64_t v22 = v2[2];
  char v23 = *((unsigned char *)v2 + 24);
  uint64_t v24 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v12, v15, v16, v17, v18);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v24;
  *(_DWORD *)(a1 + 8) = v19;
  *(unsigned char *)(a1 + 12) = v20;
  *(_WORD *)(a1 + 13) = v27;
  *(unsigned char *)(a1 + 15) = v28;
  *(void *)(a1 + 16) = v22;
  *(unsigned char *)(a1 + 24) = v23;
  *(_DWORD *)(a1 + 25) = v26;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v26 + 3);
  *(void *)(a1 + 32) = v21;
  return result;
}

uint64_t sub_1B63A136C@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for WorldTransform;
  *(void *)(inited + 40) = &off_1F0F67798;
  *(void *)(inited + 48) = &type metadata for LastFrameWorldTransform;
  *(void *)(inited + 56) = &off_1F0F8F510;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 2;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 2;
  *(_WORD *)(v12 + 32) = 771;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  unint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  char v20 = v2[4];
  uint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A158C@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for PointOfCulling;
  *(void *)(inited + 40) = &off_1F0F64F58;
  *(void *)(inited + 48) = &type metadata for Position;
  *(void *)(inited + 56) = &off_1F0FA6F58;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 2;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 2;
  *(_WORD *)(v12 + 32) = 771;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  unint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  char v20 = v2[4];
  uint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A17AC@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B62F9218(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for RotateAction;
  *(void *)(inited + 40) = &off_1F0F5B268;
  *(void *)(inited + 48) = &type metadata for Orientation;
  *(void *)(inited + 56) = &off_1F0F56120;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 2;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 2;
  *(_WORD *)(v12 + 32) = 771;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  unint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  char v20 = v2[4];
  uint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A19CC@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  unint64_t v8 = *v3;
  uint64_t v9 = (uint64_t)*v3 + 41;
  uint64_t v10 = (*v3)[8];
  unint64_t v11 = v8[9];
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for Material;
  *(void *)(inited + 40) = &off_1F0FA6678;
  *(void *)(inited + 48) = &type metadata for VertexLayoutCollection;
  *(void *)(inited + 56) = &off_1F0F8E708;
  if (v11 > 0xF)
  {
    uint64_t v29 = sub_1B62F79D4((char *)(v9 + v10), v11 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v29;
  }
  uint64_t v13 = v8[10];
  int64_t v14 = v8[11];
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v15 = swift_initStackObject();
  *(_OWORD *)(v15 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v15 + 32) = a1;
  *(unsigned char *)(v15 + 33) = a2;
  if (v14)
  {
    uint64_t v29 = sub_1B62F7C94((char *)(v9 + v13), v14);
    sub_1B62F81D8(v15);
    uint64_t v15 = v29;
    unint64_t v16 = *(void *)(v29 + 16);
  }
  else
  {
    unint64_t v16 = 2;
  }
  uint64_t v17 = (uint64_t)*v4 + 41;
  int v18 = (char *)(v17 + (*v4)[12]);
  unint64_t v19 = (unint64_t)(*v4)[13] >> 4;
  char v20 = (char *)(v17 + (*v4)[14]);
  uint64_t v21 = (*v4)[15] / 0x18u;
  int v22 = *((_DWORD *)v4 + 2);
  char v23 = *((unsigned char *)v4 + 12);
  uint64_t v24 = v4[4];
  uint64_t v25 = v4[2];
  char v26 = *((unsigned char *)v4 + 24);
  uint64_t v27 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v15 + 32), v16, v18, v19, v20, v21);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v27;
  *(_DWORD *)(a3 + 8) = v22;
  *(unsigned char *)(a3 + 12) = v23;
  *(_WORD *)(a3 + 13) = v30;
  *(unsigned char *)(a3 + 15) = v31;
  *(void *)(a3 + 16) = v25;
  *(unsigned char *)(a3 + 24) = v26;
  *(_DWORD *)(a3 + 25) = v29;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v29 + 3);
  *(void *)(a3 + 32) = v24;
  return result;
}

uint64_t sub_1B63A1C20@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  unint64_t v8 = *v3;
  uint64_t v9 = (uint64_t)*v3 + 41;
  uint64_t v10 = (*v3)[8];
  unint64_t v11 = v8[9];
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for Skybox;
  *(void *)(inited + 40) = &off_1F0FA1C28;
  *(void *)(inited + 48) = &type metadata for IBLGenerator;
  *(void *)(inited + 56) = &off_1F0F5A668;
  if (v11 > 0xF)
  {
    uint64_t v29 = sub_1B62F79D4((char *)(v9 + v10), v11 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v29;
  }
  uint64_t v13 = v8[10];
  int64_t v14 = v8[11];
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v15 = swift_initStackObject();
  *(_OWORD *)(v15 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v15 + 32) = a1;
  *(unsigned char *)(v15 + 33) = a2;
  if (v14)
  {
    uint64_t v29 = sub_1B62F7C94((char *)(v9 + v13), v14);
    sub_1B62F81D8(v15);
    uint64_t v15 = v29;
    unint64_t v16 = *(void *)(v29 + 16);
  }
  else
  {
    unint64_t v16 = 2;
  }
  uint64_t v17 = (uint64_t)*v4 + 41;
  int v18 = (char *)(v17 + (*v4)[12]);
  unint64_t v19 = (unint64_t)(*v4)[13] >> 4;
  char v20 = (char *)(v17 + (*v4)[14]);
  uint64_t v21 = (*v4)[15] / 0x18u;
  int v22 = *((_DWORD *)v4 + 2);
  char v23 = *((unsigned char *)v4 + 12);
  uint64_t v24 = v4[4];
  uint64_t v25 = v4[2];
  char v26 = *((unsigned char *)v4 + 24);
  uint64_t v27 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v15 + 32), v16, v18, v19, v20, v21);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v27;
  *(_DWORD *)(a3 + 8) = v22;
  *(unsigned char *)(a3 + 12) = v23;
  *(_WORD *)(a3 + 13) = v30;
  *(unsigned char *)(a3 + 15) = v31;
  *(void *)(a3 + 16) = v25;
  *(unsigned char *)(a3 + 24) = v26;
  *(_DWORD *)(a3 + 25) = v29;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v29 + 3);
  *(void *)(a3 + 32) = v24;
  return result;
}

uint64_t sub_1B63A1E74@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = type metadata accessor for SceneKitRenderer(0);
  uint64_t v9 = *v4;
  uint64_t v10 = *v4 + 41;
  uint64_t v11 = *(unsigned __int16 *)(*v4 + 16);
  unint64_t v12 = *(unsigned __int16 *)(*v4 + 18);
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for SceneKitAssetInstance;
  *(void *)(inited + 40) = &off_1F0F8AC88;
  *(void *)(inited + 48) = v8;
  *(void *)(inited + 56) = &off_1F0F6F400;
  if (v12 > 0xF)
  {
    uint64_t v30 = sub_1B62F79D4((char *)(v10 + v11), v12 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v30;
  }
  uint64_t v14 = *(unsigned __int16 *)(v9 + 20);
  int64_t v15 = *(unsigned __int16 *)(v9 + 22);
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v16 = swift_initStackObject();
  *(_OWORD *)(v16 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v16 + 32) = a1;
  *(unsigned char *)(v16 + 33) = a2;
  if (v15)
  {
    uint64_t v30 = sub_1B62F7C94((char *)(v10 + v14), v15);
    sub_1B62F81D8(v16);
    uint64_t v16 = v30;
    unint64_t v17 = *(void *)(v30 + 16);
  }
  else
  {
    unint64_t v17 = 2;
  }
  uint64_t v18 = *v4 + 41;
  unint64_t v19 = (char *)(v18 + *(unsigned __int16 *)(*v4 + 24));
  unint64_t v20 = (unint64_t)*(unsigned __int16 *)(*v4 + 26) >> 4;
  uint64_t v21 = (char *)(v18 + *(unsigned __int16 *)(*v4 + 28));
  uint64_t v22 = *(unsigned __int16 *)(*v4 + 30) / 0x18u;
  int v23 = *((_DWORD *)v4 + 2);
  char v24 = *((unsigned char *)v4 + 12);
  uint64_t v25 = v4[4];
  uint64_t v26 = v4[2];
  char v27 = *((unsigned char *)v4 + 24);
  uint64_t v28 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v16 + 32), v17, v19, v20, v21, v22);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v28;
  *(_DWORD *)(a3 + 8) = v23;
  *(unsigned char *)(a3 + 12) = v24;
  *(_WORD *)(a3 + 13) = v31;
  *(unsigned char *)(a3 + 15) = v32;
  *(void *)(a3 + 16) = v26;
  *(unsigned char *)(a3 + 24) = v27;
  *(_DWORD *)(a3 + 25) = v30;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v30 + 3);
  *(void *)(a3 + 32) = v25;
  return result;
}

uint64_t sub_1B63A20CC@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = (uint64_t)*v3 + 41;
  uint64_t v10 = (*v3)[8];
  unint64_t v11 = v8[9];
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for TextureShaderAsset;
  *(void *)(inited + 40) = &off_1F0F7B240;
  *(void *)(inited + 48) = &type metadata for TextureGPURuntime;
  *(void *)(inited + 56) = &off_1F0F74BD8;
  if (v11 > 0xF)
  {
    uint64_t v29 = sub_1B62F79D4((char *)(v9 + v10), v11 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v29;
  }
  uint64_t v13 = v8[10];
  int64_t v14 = v8[11];
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v15 = swift_initStackObject();
  *(_OWORD *)(v15 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v15 + 32) = a1;
  *(unsigned char *)(v15 + 33) = a2;
  if (v14)
  {
    uint64_t v29 = sub_1B62F7C94((char *)(v9 + v13), v14);
    sub_1B62F81D8(v15);
    uint64_t v15 = v29;
    unint64_t v16 = *(void *)(v29 + 16);
  }
  else
  {
    unint64_t v16 = 2;
  }
  uint64_t v17 = (uint64_t)*v4 + 41;
  uint64_t v18 = (char *)(v17 + (*v4)[12]);
  unint64_t v19 = (unint64_t)(*v4)[13] >> 4;
  unint64_t v20 = (char *)(v17 + (*v4)[14]);
  uint64_t v21 = (*v4)[15] / 0x18u;
  int v22 = *((_DWORD *)v4 + 2);
  char v23 = *((unsigned char *)v4 + 12);
  char v24 = v4[4];
  uint64_t v25 = v4[2];
  char v26 = *((unsigned char *)v4 + 24);
  uint64_t v27 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v15 + 32), v16, v18, v19, v20, v21);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v27;
  *(_DWORD *)(a3 + 8) = v22;
  *(unsigned char *)(a3 + 12) = v23;
  *(_WORD *)(a3 + 13) = v30;
  *(unsigned char *)(a3 + 15) = v31;
  *(void *)(a3 + 16) = v25;
  *(unsigned char *)(a3 + 24) = v26;
  *(_DWORD *)(a3 + 25) = v29;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v29 + 3);
  *(void *)(a3 + 32) = v24;
  return result;
}

uint64_t sub_1B63A2320@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = (uint64_t)*v3 + 41;
  uint64_t v10 = (*v3)[8];
  unint64_t v11 = v8[9];
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for TextureCPURuntime;
  *(void *)(inited + 40) = &off_1F0F74A98;
  *(void *)(inited + 48) = &type metadata for TextureRequireGPURepresentation;
  *(void *)(inited + 56) = &off_1F0F9AFB0;
  if (v11 > 0xF)
  {
    uint64_t v29 = sub_1B62F79D4((char *)(v9 + v10), v11 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v29;
  }
  uint64_t v13 = v8[10];
  int64_t v14 = v8[11];
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v15 = swift_initStackObject();
  *(_OWORD *)(v15 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v15 + 32) = a1;
  *(unsigned char *)(v15 + 33) = a2;
  if (v14)
  {
    uint64_t v29 = sub_1B62F7C94((char *)(v9 + v13), v14);
    sub_1B62F81D8(v15);
    uint64_t v15 = v29;
    unint64_t v16 = *(void *)(v29 + 16);
  }
  else
  {
    unint64_t v16 = 2;
  }
  uint64_t v17 = (uint64_t)*v4 + 41;
  uint64_t v18 = (char *)(v17 + (*v4)[12]);
  unint64_t v19 = (unint64_t)(*v4)[13] >> 4;
  unint64_t v20 = (char *)(v17 + (*v4)[14]);
  uint64_t v21 = (*v4)[15] / 0x18u;
  int v22 = *((_DWORD *)v4 + 2);
  char v23 = *((unsigned char *)v4 + 12);
  char v24 = v4[4];
  uint64_t v25 = v4[2];
  char v26 = *((unsigned char *)v4 + 24);
  uint64_t v27 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v15 + 32), v16, v18, v19, v20, v21);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v27;
  *(_DWORD *)(a3 + 8) = v22;
  *(unsigned char *)(a3 + 12) = v23;
  *(_WORD *)(a3 + 13) = v30;
  *(unsigned char *)(a3 + 15) = v31;
  *(void *)(a3 + 16) = v25;
  *(unsigned char *)(a3 + 24) = v26;
  *(_DWORD *)(a3 + 25) = v29;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v29 + 3);
  *(void *)(a3 + 32) = v24;
  return result;
}

uint64_t sub_1B63A2574@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = (uint64_t)*v3 + 41;
  uint64_t v10 = (*v3)[8];
  unint64_t v11 = v8[9];
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for TextureFileAsset;
  *(void *)(inited + 40) = &off_1F0F6F940;
  *(void *)(inited + 48) = &type metadata for TextureCPURuntime;
  *(void *)(inited + 56) = &off_1F0F74A98;
  if (v11 > 0xF)
  {
    uint64_t v29 = sub_1B62F79D4((char *)(v9 + v10), v11 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v29;
  }
  uint64_t v13 = v8[10];
  int64_t v14 = v8[11];
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v15 = swift_initStackObject();
  *(_OWORD *)(v15 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v15 + 32) = a1;
  *(unsigned char *)(v15 + 33) = a2;
  if (v14)
  {
    uint64_t v29 = sub_1B62F7C94((char *)(v9 + v13), v14);
    sub_1B62F81D8(v15);
    uint64_t v15 = v29;
    unint64_t v16 = *(void *)(v29 + 16);
  }
  else
  {
    unint64_t v16 = 2;
  }
  uint64_t v17 = (uint64_t)*v4 + 41;
  uint64_t v18 = (char *)(v17 + (*v4)[12]);
  unint64_t v19 = (unint64_t)(*v4)[13] >> 4;
  unint64_t v20 = (char *)(v17 + (*v4)[14]);
  uint64_t v21 = (*v4)[15] / 0x18u;
  int v22 = *((_DWORD *)v4 + 2);
  char v23 = *((unsigned char *)v4 + 12);
  char v24 = v4[4];
  uint64_t v25 = v4[2];
  char v26 = *((unsigned char *)v4 + 24);
  uint64_t v27 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v15 + 32), v16, v18, v19, v20, v21);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v27;
  *(_DWORD *)(a3 + 8) = v22;
  *(unsigned char *)(a3 + 12) = v23;
  *(_WORD *)(a3 + 13) = v30;
  *(unsigned char *)(a3 + 15) = v31;
  *(void *)(a3 + 16) = v25;
  *(unsigned char *)(a3 + 24) = v26;
  *(_DWORD *)(a3 + 25) = v29;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v29 + 3);
  *(void *)(a3 + 32) = v24;
  return result;
}

uint64_t sub_1B63A27C8@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = (uint64_t)*v3 + 41;
  uint64_t v10 = (*v3)[8];
  unint64_t v11 = v8[9];
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for ProjectionMatrix;
  *(void *)(inited + 40) = &off_1F0F6EF58;
  *(void *)(inited + 48) = &type metadata for WorldTransform;
  *(void *)(inited + 56) = &off_1F0F67798;
  if (v11 > 0xF)
  {
    uint64_t v29 = sub_1B62F79D4((char *)(v9 + v10), v11 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v29;
  }
  uint64_t v13 = v8[10];
  int64_t v14 = v8[11];
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v15 = swift_initStackObject();
  *(_OWORD *)(v15 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v15 + 32) = a1;
  *(unsigned char *)(v15 + 33) = a2;
  if (v14)
  {
    uint64_t v29 = sub_1B62F7C94((char *)(v9 + v13), v14);
    sub_1B62F81D8(v15);
    uint64_t v15 = v29;
    unint64_t v16 = *(void *)(v29 + 16);
  }
  else
  {
    unint64_t v16 = 2;
  }
  uint64_t v17 = (uint64_t)*v4 + 41;
  uint64_t v18 = (char *)(v17 + (*v4)[12]);
  unint64_t v19 = (unint64_t)(*v4)[13] >> 4;
  unint64_t v20 = (char *)(v17 + (*v4)[14]);
  uint64_t v21 = (*v4)[15] / 0x18u;
  int v22 = *((_DWORD *)v4 + 2);
  char v23 = *((unsigned char *)v4 + 12);
  char v24 = v4[4];
  uint64_t v25 = v4[2];
  char v26 = *((unsigned char *)v4 + 24);
  uint64_t v27 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v15 + 32), v16, v18, v19, v20, v21);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v27;
  *(_DWORD *)(a3 + 8) = v22;
  *(unsigned char *)(a3 + 12) = v23;
  *(_WORD *)(a3 + 13) = v30;
  *(unsigned char *)(a3 + 15) = v31;
  *(void *)(a3 + 16) = v25;
  *(unsigned char *)(a3 + 24) = v26;
  *(_DWORD *)(a3 + 25) = v29;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v29 + 3);
  *(void *)(a3 + 32) = v24;
  return result;
}

uint64_t sub_1B63A2A1C@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = (uint64_t)*v3 + 41;
  uint64_t v10 = (*v3)[8];
  unint64_t v11 = v8[9];
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for WorldTransform;
  *(void *)(inited + 40) = &off_1F0F67798;
  *(void *)(inited + 48) = &type metadata for InverseWorldTransform;
  *(void *)(inited + 56) = &off_1F0F87E78;
  if (v11 > 0xF)
  {
    uint64_t v29 = sub_1B62F79D4((char *)(v9 + v10), v11 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v29;
  }
  uint64_t v13 = v8[10];
  int64_t v14 = v8[11];
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v15 = swift_initStackObject();
  *(_OWORD *)(v15 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v15 + 32) = a1;
  *(unsigned char *)(v15 + 33) = a2;
  if (v14)
  {
    uint64_t v29 = sub_1B62F7C94((char *)(v9 + v13), v14);
    sub_1B62F81D8(v15);
    uint64_t v15 = v29;
    unint64_t v16 = *(void *)(v29 + 16);
  }
  else
  {
    unint64_t v16 = 2;
  }
  uint64_t v17 = (uint64_t)*v4 + 41;
  uint64_t v18 = (char *)(v17 + (*v4)[12]);
  unint64_t v19 = (unint64_t)(*v4)[13] >> 4;
  unint64_t v20 = (char *)(v17 + (*v4)[14]);
  uint64_t v21 = (*v4)[15] / 0x18u;
  int v22 = *((_DWORD *)v4 + 2);
  char v23 = *((unsigned char *)v4 + 12);
  char v24 = v4[4];
  uint64_t v25 = v4[2];
  char v26 = *((unsigned char *)v4 + 24);
  uint64_t v27 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v15 + 32), v16, v18, v19, v20, v21);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v27;
  *(_DWORD *)(a3 + 8) = v22;
  *(unsigned char *)(a3 + 12) = v23;
  *(_WORD *)(a3 + 13) = v30;
  *(unsigned char *)(a3 + 15) = v31;
  *(void *)(a3 + 16) = v25;
  *(unsigned char *)(a3 + 24) = v26;
  *(_DWORD *)(a3 + 25) = v29;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v29 + 3);
  *(void *)(a3 + 32) = v24;
  return result;
}

uint64_t sub_1B63A2C70@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = type metadata accessor for MovieRuntime(0);
  uint64_t v9 = *v4;
  uint64_t v10 = *v4 + 41;
  uint64_t v11 = *(unsigned __int16 *)(*v4 + 16);
  unint64_t v12 = *(unsigned __int16 *)(*v4 + 18);
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for MovieFileAsset;
  *(void *)(inited + 40) = &off_1F0F64908;
  *(void *)(inited + 48) = v8;
  *(void *)(inited + 56) = &off_1F0F5A9C8;
  if (v12 > 0xF)
  {
    uint64_t v30 = sub_1B62F79D4((char *)(v10 + v11), v12 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v30;
  }
  uint64_t v14 = *(unsigned __int16 *)(v9 + 20);
  int64_t v15 = *(unsigned __int16 *)(v9 + 22);
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v16 = swift_initStackObject();
  *(_OWORD *)(v16 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v16 + 32) = a1;
  *(unsigned char *)(v16 + 33) = a2;
  if (v15)
  {
    uint64_t v30 = sub_1B62F7C94((char *)(v10 + v14), v15);
    sub_1B62F81D8(v16);
    uint64_t v16 = v30;
    unint64_t v17 = *(void *)(v30 + 16);
  }
  else
  {
    unint64_t v17 = 2;
  }
  uint64_t v18 = *v4 + 41;
  unint64_t v19 = (char *)(v18 + *(unsigned __int16 *)(*v4 + 24));
  unint64_t v20 = (unint64_t)*(unsigned __int16 *)(*v4 + 26) >> 4;
  uint64_t v21 = (char *)(v18 + *(unsigned __int16 *)(*v4 + 28));
  uint64_t v22 = *(unsigned __int16 *)(*v4 + 30) / 0x18u;
  int v23 = *((_DWORD *)v4 + 2);
  char v24 = *((unsigned char *)v4 + 12);
  uint64_t v25 = v4[4];
  uint64_t v26 = v4[2];
  char v27 = *((unsigned char *)v4 + 24);
  uint64_t v28 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v16 + 32), v17, v19, v20, v21, v22);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v28;
  *(_DWORD *)(a3 + 8) = v23;
  *(unsigned char *)(a3 + 12) = v24;
  *(_WORD *)(a3 + 13) = v31;
  *(unsigned char *)(a3 + 15) = v32;
  *(void *)(a3 + 16) = v26;
  *(unsigned char *)(a3 + 24) = v27;
  *(_DWORD *)(a3 + 25) = v30;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v30 + 3);
  *(void *)(a3 + 32) = v25;
  return result;
}

uint64_t sub_1B63A2EC8@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = (uint64_t)*v3 + 41;
  uint64_t v10 = (*v3)[8];
  unint64_t v11 = v8[9];
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for AudioFileAsset;
  *(void *)(inited + 40) = &off_1F0F62AE0;
  *(void *)(inited + 48) = &type metadata for AudioController;
  *(void *)(inited + 56) = &off_1F0F68028;
  if (v11 > 0xF)
  {
    uint64_t v29 = sub_1B62F79D4((char *)(v9 + v10), v11 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v29;
  }
  uint64_t v13 = v8[10];
  int64_t v14 = v8[11];
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v15 = swift_initStackObject();
  *(_OWORD *)(v15 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v15 + 32) = a1;
  *(unsigned char *)(v15 + 33) = a2;
  if (v14)
  {
    uint64_t v29 = sub_1B62F7C94((char *)(v9 + v13), v14);
    sub_1B62F81D8(v15);
    uint64_t v15 = v29;
    unint64_t v16 = *(void *)(v29 + 16);
  }
  else
  {
    unint64_t v16 = 2;
  }
  uint64_t v17 = (uint64_t)*v4 + 41;
  uint64_t v18 = (char *)(v17 + (*v4)[12]);
  unint64_t v19 = (unint64_t)(*v4)[13] >> 4;
  unint64_t v20 = (char *)(v17 + (*v4)[14]);
  uint64_t v21 = (*v4)[15] / 0x18u;
  int v22 = *((_DWORD *)v4 + 2);
  char v23 = *((unsigned char *)v4 + 12);
  char v24 = v4[4];
  uint64_t v25 = v4[2];
  char v26 = *((unsigned char *)v4 + 24);
  uint64_t v27 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v15 + 32), v16, v18, v19, v20, v21);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v27;
  *(_DWORD *)(a3 + 8) = v22;
  *(unsigned char *)(a3 + 12) = v23;
  *(_WORD *)(a3 + 13) = v30;
  *(unsigned char *)(a3 + 15) = v31;
  *(void *)(a3 + 16) = v25;
  *(unsigned char *)(a3 + 24) = v26;
  *(_DWORD *)(a3 + 25) = v29;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v29 + 3);
  *(void *)(a3 + 32) = v24;
  return result;
}

uint64_t sub_1B63A311C@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  sub_1B63396FC(0, (unint64_t *)&qword_1EB981060, type metadata accessor for MetalFunctionScript, (uint64_t)&off_1EB984EE8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptRuntime);
  uint64_t v9 = v8;
  uint64_t v10 = *v4;
  uint64_t v11 = *v4 + 41;
  uint64_t v12 = *(unsigned __int16 *)(*v4 + 16);
  unint64_t v13 = *(unsigned __int16 *)(*v4 + 18);
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = v9;
  *(void *)(inited + 40) = &off_1F0F61C20;
  *(void *)(inited + 48) = &type metadata for MetalScriptReflection;
  *(void *)(inited + 56) = &off_1F0F880E8;
  if (v13 > 0xF)
  {
    uint64_t v31 = sub_1B62F79D4((char *)(v11 + v12), v13 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v31;
  }
  uint64_t v15 = *(unsigned __int16 *)(v10 + 20);
  int64_t v16 = *(unsigned __int16 *)(v10 + 22);
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v17 = swift_initStackObject();
  *(_OWORD *)(v17 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v17 + 32) = a1;
  *(unsigned char *)(v17 + 33) = a2;
  if (v16)
  {
    uint64_t v31 = sub_1B62F7C94((char *)(v11 + v15), v16);
    sub_1B62F81D8(v17);
    uint64_t v17 = v31;
    unint64_t v18 = *(void *)(v31 + 16);
  }
  else
  {
    unint64_t v18 = 2;
  }
  uint64_t v19 = *v4 + 41;
  unint64_t v20 = (char *)(v19 + *(unsigned __int16 *)(*v4 + 24));
  unint64_t v21 = (unint64_t)*(unsigned __int16 *)(*v4 + 26) >> 4;
  int v22 = (char *)(v19 + *(unsigned __int16 *)(*v4 + 28));
  uint64_t v23 = *(unsigned __int16 *)(*v4 + 30) / 0x18u;
  int v24 = *((_DWORD *)v4 + 2);
  char v25 = *((unsigned char *)v4 + 12);
  uint64_t v26 = v4[4];
  uint64_t v27 = v4[2];
  char v28 = *((unsigned char *)v4 + 24);
  uint64_t v29 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v17 + 32), v18, v20, v21, v22, v23);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v29;
  *(_DWORD *)(a3 + 8) = v24;
  *(unsigned char *)(a3 + 12) = v25;
  *(_WORD *)(a3 + 13) = v32;
  *(unsigned char *)(a3 + 15) = v33;
  *(void *)(a3 + 16) = v27;
  *(unsigned char *)(a3 + 24) = v28;
  *(_DWORD *)(a3 + 25) = v31;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v31 + 3);
  *(void *)(a3 + 32) = v26;
  return result;
}

uint64_t sub_1B63A33AC@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = *v3;
  uint64_t v9 = (uint64_t)*v3 + 41;
  uint64_t v10 = (*v3)[8];
  unint64_t v11 = v8[9];
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for DrawCallComponent;
  *(void *)(inited + 40) = &off_1F0F70A08;
  *(void *)(inited + 48) = &type metadata for WorldAABB;
  *(void *)(inited + 56) = &off_1F0FAABA0;
  if (v11 > 0xF)
  {
    uint64_t v29 = sub_1B62F79D4((char *)(v9 + v10), v11 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v29;
  }
  uint64_t v13 = v8[10];
  int64_t v14 = v8[11];
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v15 = swift_initStackObject();
  *(_OWORD *)(v15 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v15 + 32) = a1;
  *(unsigned char *)(v15 + 33) = a2;
  if (v14)
  {
    uint64_t v29 = sub_1B62F7C94((char *)(v9 + v13), v14);
    sub_1B62F81D8(v15);
    uint64_t v15 = v29;
    unint64_t v16 = *(void *)(v29 + 16);
  }
  else
  {
    unint64_t v16 = 2;
  }
  uint64_t v17 = (uint64_t)*v4 + 41;
  unint64_t v18 = (char *)(v17 + (*v4)[12]);
  unint64_t v19 = (unint64_t)(*v4)[13] >> 4;
  unint64_t v20 = (char *)(v17 + (*v4)[14]);
  uint64_t v21 = (*v4)[15] / 0x18u;
  int v22 = *((_DWORD *)v4 + 2);
  char v23 = *((unsigned char *)v4 + 12);
  int v24 = v4[4];
  char v25 = v4[2];
  char v26 = *((unsigned char *)v4 + 24);
  uint64_t v27 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v15 + 32), v16, v18, v19, v20, v21);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v27;
  *(_DWORD *)(a3 + 8) = v22;
  *(unsigned char *)(a3 + 12) = v23;
  *(_WORD *)(a3 + 13) = v30;
  *(unsigned char *)(a3 + 15) = v31;
  *(void *)(a3 + 16) = v25;
  *(unsigned char *)(a3 + 24) = v26;
  *(_DWORD *)(a3 + 25) = v29;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v29 + 3);
  *(void *)(a3 + 32) = v24;
  return result;
}

uint64_t sub_1B63A3600@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = type metadata accessor for AudioPlayerComponent(0);
  uint64_t v9 = *v4;
  uint64_t v10 = *v4 + 41;
  uint64_t v11 = *(unsigned __int16 *)(*v4 + 16);
  unint64_t v12 = *(unsigned __int16 *)(*v4 + 18);
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = v8;
  *(void *)(inited + 40) = &off_1F0F7FCA8;
  *(void *)(inited + 48) = &type metadata for AudioAnalyzer;
  *(void *)(inited + 56) = &off_1F0F5DCD0;
  if (v12 > 0xF)
  {
    uint64_t v30 = sub_1B62F79D4((char *)(v10 + v11), v12 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v30;
  }
  uint64_t v14 = *(unsigned __int16 *)(v9 + 20);
  int64_t v15 = *(unsigned __int16 *)(v9 + 22);
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v16 = swift_initStackObject();
  *(_OWORD *)(v16 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v16 + 32) = a1;
  *(unsigned char *)(v16 + 33) = a2;
  if (v15)
  {
    uint64_t v30 = sub_1B62F7C94((char *)(v10 + v14), v15);
    sub_1B62F81D8(v16);
    uint64_t v16 = v30;
    unint64_t v17 = *(void *)(v30 + 16);
  }
  else
  {
    unint64_t v17 = 2;
  }
  uint64_t v18 = *v4 + 41;
  unint64_t v19 = (char *)(v18 + *(unsigned __int16 *)(*v4 + 24));
  unint64_t v20 = (unint64_t)*(unsigned __int16 *)(*v4 + 26) >> 4;
  uint64_t v21 = (char *)(v18 + *(unsigned __int16 *)(*v4 + 28));
  uint64_t v22 = *(unsigned __int16 *)(*v4 + 30) / 0x18u;
  int v23 = *((_DWORD *)v4 + 2);
  char v24 = *((unsigned char *)v4 + 12);
  uint64_t v25 = v4[4];
  uint64_t v26 = v4[2];
  char v27 = *((unsigned char *)v4 + 24);
  uint64_t v28 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v16 + 32), v17, v19, v20, v21, v22);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v28;
  *(_DWORD *)(a3 + 8) = v23;
  *(unsigned char *)(a3 + 12) = v24;
  *(_WORD *)(a3 + 13) = v31;
  *(unsigned char *)(a3 + 15) = v32;
  *(void *)(a3 + 16) = v26;
  *(unsigned char *)(a3 + 24) = v27;
  *(_DWORD *)(a3 + 25) = v30;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v30 + 3);
  *(void *)(a3 + 32) = v25;
  return result;
}

uint64_t sub_1B63A3858@<X0>(char a1@<W0>, char a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4 = v3;
  uint64_t v8 = type metadata accessor for AudioPlayerComponent(0);
  uint64_t v9 = *v4;
  uint64_t v10 = *v4 + 41;
  uint64_t v11 = *(unsigned __int16 *)(*v4 + 16);
  unint64_t v12 = *(unsigned __int16 *)(*v4 + 18);
  sub_1B62D41FC(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = v8;
  *(void *)(inited + 40) = &off_1F0F7FCA8;
  *(void *)(inited + 48) = &type metadata for AudioController;
  *(void *)(inited + 56) = &off_1F0F68028;
  if (v12 > 0xF)
  {
    uint64_t v30 = sub_1B62F79D4((char *)(v10 + v11), v12 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v30;
  }
  uint64_t v14 = *(unsigned __int16 *)(v9 + 20);
  int64_t v15 = *(unsigned __int16 *)(v9 + 22);
  sub_1B62D8374(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v16 = swift_initStackObject();
  *(_OWORD *)(v16 + 16) = xmmword_1B6E76B30;
  *(unsigned char *)(v16 + 32) = a1;
  *(unsigned char *)(v16 + 33) = a2;
  if (v15)
  {
    uint64_t v30 = sub_1B62F7C94((char *)(v10 + v14), v15);
    sub_1B62F81D8(v16);
    uint64_t v16 = v30;
    unint64_t v17 = *(void *)(v30 + 16);
  }
  else
  {
    unint64_t v17 = 2;
  }
  uint64_t v18 = *v4 + 41;
  unint64_t v19 = (char *)(v18 + *(unsigned __int16 *)(*v4 + 24));
  unint64_t v20 = (unint64_t)*(unsigned __int16 *)(*v4 + 26) >> 4;
  uint64_t v21 = (char *)(v18 + *(unsigned __int16 *)(*v4 + 28));
  uint64_t v22 = *(unsigned __int16 *)(*v4 + 30) / 0x18u;
  int v23 = *((_DWORD *)v4 + 2);
  char v24 = *((unsigned char *)v4 + 12);
  uint64_t v25 = v4[4];
  uint64_t v26 = v4[2];
  char v27 = *((unsigned char *)v4 + 24);
  uint64_t v28 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v16 + 32), v17, v19, v20, v21, v22);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a3 = v28;
  *(_DWORD *)(a3 + 8) = v23;
  *(unsigned char *)(a3 + 12) = v24;
  *(_WORD *)(a3 + 13) = v31;
  *(unsigned char *)(a3 + 15) = v32;
  *(void *)(a3 + 16) = v26;
  *(unsigned char *)(a3 + 24) = v27;
  *(_DWORD *)(a3 + 25) = v30;
  *(_DWORD *)(a3 + 28) = *(_DWORD *)((char *)&v30 + 3);
  *(void *)(a3 + 32) = v25;
  return result;
}

uint64_t sub_1B63A3AB0@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for Static;
  *(void *)(inited + 40) = &off_1F0FA1DB0;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 1;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 1;
  *(unsigned char *)(v12 + 32) = 3;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  unint64_t v20 = v2[4];
  uint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A3CBC@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for ParticleFluidSolver2DEmitter;
  *(void *)(inited + 40) = &off_1F0F992C8;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 1;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 1;
  *(unsigned char *)(v12 + 32) = 3;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  unint64_t v20 = v2[4];
  uint64_t v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A3EC8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB9811A0, type metadata accessor for TriggerScript, (uint64_t)&off_1EB984DC8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptStateRestoration);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F8E138;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A4110@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, &qword_1EB97F7C0, type metadata accessor for EmitterScript, (uint64_t)&off_1EB982298, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptStateRestoration);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F8E138;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A4358@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB97F7B0, type metadata accessor for SimpleScript, (uint64_t)&off_1EB982058, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptStateRestoration);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F8E138;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A45A0@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB97F7A0, type metadata accessor for ShaderScript, (uint64_t)&off_1EB981F10, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptStateRestoration);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F8E138;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A47E8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB97F790, type metadata accessor for GraphScript, (uint64_t)&off_1EB981C00, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptStateRestoration);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F8E138;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A4A30@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB97F780, type metadata accessor for ParticleUpdateScript, (uint64_t)&off_1EB983100, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptStateRestoration);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F8E138;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A4C78@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB981190, type metadata accessor for MetalFunctionScript, (uint64_t)&off_1EB984EE8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptStateRestoration);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F8E138;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A4EC0@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB97F770, type metadata accessor for ParticleInitScript, (uint64_t)&off_1EB982C10, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptStateRestoration);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F8E138;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A5108@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, &qword_1EB981130, type metadata accessor for TriggerScript, (uint64_t)&off_1EB984DC8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptCompileAttempt);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F836E8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A5350@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, &qword_1EB97F4E0, type metadata accessor for EmitterScript, (uint64_t)&off_1EB982298, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptCompileAttempt);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F836E8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A5598@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB97F4D0, type metadata accessor for SimpleScript, (uint64_t)&off_1EB982058, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptCompileAttempt);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F836E8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A57E0@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB97F4C0, type metadata accessor for ShaderScript, (uint64_t)&off_1EB981F10, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptCompileAttempt);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F836E8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A5A28@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, &qword_1EB97F4B8, type metadata accessor for GraphScript, (uint64_t)&off_1EB981C00, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptCompileAttempt);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F836E8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A5C70@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, &qword_1EB97F4B0, type metadata accessor for ParticleUpdateScript, (uint64_t)&off_1EB983100, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptCompileAttempt);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F836E8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A5EB8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB981120, type metadata accessor for MetalFunctionScript, (uint64_t)&off_1EB984EE8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptCompileAttempt);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F836E8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A6100@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  sub_1B62AC6A4(0, (unint64_t *)&unk_1EB97F4A0, type metadata accessor for ParticleInitScript, (uint64_t)&off_1EB982C10, (uint64_t (*)(uint64_t, uint64_t, uint64_t))type metadata accessor for ScriptCompileAttempt);
  uint64_t v5 = v4;
  uint64_t v6 = *v2;
  uint64_t v7 = *v2 + 41;
  uint64_t v8 = *(unsigned __int16 *)(*v2 + 16);
  unint64_t v9 = *(unsigned __int16 *)(*v2 + 18);
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v5;
  *(void *)(inited + 40) = &off_1F0F836E8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = *(unsigned __int16 *)(v6 + 20);
  int64_t v12 = *(unsigned __int16 *)(v6 + 22);
  unint64_t v13 = 1;
  uint64_t v14 = sub_1B6E31C98();
  *(void *)(v14 + 16) = 1;
  *(unsigned char *)(v14 + 32) = 3;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v14);
    uint64_t v14 = v27;
    unint64_t v13 = *(void *)(v27 + 16);
  }
  uint64_t v15 = *v2 + 41;
  uint64_t v16 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 24));
  unint64_t v17 = (unint64_t)*(unsigned __int16 *)(*v2 + 26) >> 4;
  int v18 = (char *)(v15 + *(unsigned __int16 *)(*v2 + 28));
  uint64_t v19 = *(unsigned __int16 *)(*v2 + 30) / 0x18u;
  int v20 = *((_DWORD *)v2 + 2);
  char v21 = *((unsigned char *)v2 + 12);
  uint64_t v22 = v2[4];
  uint64_t v23 = v2[2];
  char v24 = *((unsigned char *)v2 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v14 + 32), v13, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v25;
  *(_DWORD *)(a1 + 8) = v20;
  *(unsigned char *)(a1 + 12) = v21;
  *(_WORD *)(a1 + 13) = v28;
  *(unsigned char *)(a1 + 15) = v29;
  *(void *)(a1 + 16) = v23;
  *(unsigned char *)(a1 + 24) = v24;
  *(_DWORD *)(a1 + 25) = v27;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a1 + 32) = v22;
  return result;
}

uint64_t sub_1B63A6348@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TextureRenderTarget;
  *(void *)(inited + 40) = &off_1F0F7F560;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 1;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 1;
  *(unsigned char *)(v12 + 32) = 3;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  int v20 = v2[4];
  char v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A6554@<X0>(uint64_t a1@<X8>)
{
  return sub_1B636CBD8(type metadata accessor for SceneKitRenderer, (uint64_t)&off_1F0F6F400, a1);
}

uint64_t sub_1B63A65C8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for EmitterRuntime;
  *(void *)(inited + 40) = &off_1F0F63FA8;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 1;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 1;
  *(unsigned char *)(v12 + 32) = 3;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  int v20 = v2[4];
  char v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A67D4@<X0>(uint64_t a1@<X8>)
{
  return sub_1B636CBD8((uint64_t (*)(void))type metadata accessor for SDFFileAsset, (uint64_t)&off_1F0F5B460, a1);
}

uint64_t sub_1B63A6848@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for LODRenderer;
  *(void *)(inited + 40) = &off_1F0F55948;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 1;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 1;
  *(unsigned char *)(v12 + 32) = 3;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  int v20 = v2[4];
  char v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A6A54@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = v1;
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)*v1 + 41;
  uint64_t v6 = (*v1)[8];
  unint64_t v7 = v4[9];
  sub_1B636D998(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for IBLRuntime;
  *(void *)(inited + 40) = &off_1F0F52AC8;
  if (v7 > 0xF)
  {
    uint64_t v25 = sub_1B62F79D4((char *)(v5 + v6), v7 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v25;
  }
  uint64_t v9 = v4[10];
  int64_t v10 = v4[11];
  unint64_t v11 = 1;
  uint64_t v12 = sub_1B6E31C98();
  *(void *)(v12 + 16) = 1;
  *(unsigned char *)(v12 + 32) = 3;
  if (v10)
  {
    uint64_t v25 = sub_1B62F7C94((char *)(v5 + v9), v10);
    sub_1B62F81D8(v12);
    uint64_t v12 = v25;
    unint64_t v11 = *(void *)(v25 + 16);
  }
  uint64_t v13 = (uint64_t)*v2 + 41;
  uint64_t v14 = (char *)(v13 + (*v2)[12]);
  unint64_t v15 = (unint64_t)(*v2)[13] >> 4;
  uint64_t v16 = (char *)(v13 + (*v2)[14]);
  uint64_t v17 = (*v2)[15] / 0x18u;
  int v18 = *((_DWORD *)v2 + 2);
  char v19 = *((unsigned char *)v2 + 12);
  int v20 = v2[4];
  char v21 = v2[2];
  char v22 = *((unsigned char *)v2 + 24);
  uint64_t v23 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v12 + 32), v11, v14, v15, v16, v17);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a1 = v23;
  *(_DWORD *)(a1 + 8) = v18;
  *(unsigned char *)(a1 + 12) = v19;
  *(_WORD *)(a1 + 13) = v26;
  *(unsigned char *)(a1 + 15) = v27;
  *(void *)(a1 + 16) = v21;
  *(unsigned char *)(a1 + 24) = v22;
  *(_DWORD *)(a1 + 25) = v25;
  *(_DWORD *)(a1 + 28) = *(_DWORD *)((char *)&v25 + 3);
  *(void *)(a1 + 32) = v20;
  return result;
}

uint64_t sub_1B63A6C60@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for SetActive;
  *(void *)(inited + 40) = &off_1F0FA9878;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A6E68@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for Skeleton;
  *(void *)(inited + 40) = &off_1F0FA7780;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A7070@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for Bindings;
  *(void *)(inited + 40) = &off_1F0FA3538;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A7278@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for Parent;
  *(void *)(inited + 40) = &off_1F0FA04A8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A7480@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TextureRequireAnimationRepresentation;
  *(void *)(inited + 40) = &off_1F0F9D488;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A7688@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TextureRequireGPURepresentation;
  *(void *)(inited + 40) = &off_1F0F9AFB0;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A7890@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for SkeletalAnimationPlayer;
  *(void *)(inited + 40) = &off_1F0F91688;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A7A98@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TextureLoadingOptions;
  *(void *)(inited + 40) = &off_1F0F8BA48;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A7CA0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TextureArrayFileAsset;
  *(void *)(inited + 40) = &off_1F0F8B560;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A7EA8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for SceneKitAssetInstance;
  *(void *)(inited + 40) = &off_1F0F8AC88;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A80B0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for REMeshAssetPointCache;
  *(void *)(inited + 40) = &off_1F0F8A928;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A82B8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for MetalScriptReflection;
  *(void *)(inited + 40) = &off_1F0F880E8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A84C0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, type metadata accessor for ParticleUpdateScript, (uint64_t)&off_1F0F83030, a2);
}

uint64_t sub_1B63A8534@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for ParticleQuadRenderer;
  *(void *)(inited + 40) = &off_1F0F81DC8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A873C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for VideoCaptureRuntime;
  *(void *)(inited + 40) = &off_1F0F7F8B0;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A8944@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for PointCacheFromModel;
  *(void *)(inited + 40) = &off_1F0F7E448;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A8B4C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for PointCacheFileAsset;
  *(void *)(inited + 40) = &off_1F0F7E168;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A8D54@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, type metadata accessor for MetalFunctionScript, (uint64_t)&off_1F0F7CE60, a2);
}

uint64_t sub_1B63A8DC8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for AnimationTimeSource;
  *(void *)(inited + 40) = &off_1F0F7C308;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A8FD0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TexturePlaceholder;
  *(void *)(inited + 40) = &off_1F0F7AC30;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A91D8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for PrimitiveGenerator;
  *(void *)(inited + 40) = &off_1F0F7A488;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A93E0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, type metadata accessor for ParticleInitScript, (uint64_t)&off_1F0F79748, a2);
}

uint64_t sub_1B63A9454@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for MeshReferenceAsset;
  *(void *)(inited + 40) = &off_1F0F77318;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A965C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TextureNamedAsset;
  *(void *)(inited + 40) = &off_1F0F75140;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A9864@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TextureCPURuntime;
  *(void *)(inited + 40) = &off_1F0F74A98;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A9A6C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, (uint64_t (*)(void))sub_1B63B65C8, (uint64_t)&off_1F0F71A50, a2);
}

uint64_t sub_1B63A9AE0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, (uint64_t (*)(void))sub_1B63B667C, (uint64_t)&off_1F0F71A50, a2);
}

uint64_t sub_1B63A9B54@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, (uint64_t (*)(void))sub_1B63B6730, (uint64_t)&off_1F0F71A50, a2);
}

uint64_t sub_1B63A9BC8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B63AAA7C(a1, &qword_1EB97EEF8, (uint64_t (*)(void, void, _UNKNOWN **))type metadata accessor for KeyframeAnimation, (uint64_t)&off_1F0F71A50, a2);
}

uint64_t sub_1B63A9C44@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for ColorRampRuntime;
  *(void *)(inited + 40) = &off_1F0F6B7D8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63A9E4C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TextureFileData;
  *(void *)(inited + 40) = &off_1F0F6A9C8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AA054@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for ShaderFileAsset;
  *(void *)(inited + 40) = &off_1F0F6A3B8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AA25C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for WorldTransform;
  *(void *)(inited + 40) = &off_1F0F67798;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AA464@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for TextureCGImage;
  *(void *)(inited + 40) = &off_1F0F66BF8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AA66C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for SceneFileAsset;
  *(void *)(inited + 40) = &off_1F0F659A0;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AA874@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for MovieFileAsset;
  *(void *)(inited + 40) = &off_1F0F64908;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  uint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AAA7C@<X0>(char a1@<W0>, unint64_t *a2@<X1>, uint64_t (*a3)(void, void, _UNKNOWN **)@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v7 = v5;
  sub_1B636BBFC(0, a2, a3);
  uint64_t v11 = v10;
  uint64_t v12 = *v7;
  uint64_t v13 = *v7 + 41;
  uint64_t v14 = *(unsigned __int16 *)(*v7 + 16);
  unint64_t v15 = *(unsigned __int16 *)(*v7 + 18);
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = v11;
  *(void *)(inited + 40) = a4;
  if (v15 > 0xF)
  {
    uint64_t v33 = sub_1B62F79D4((char *)(v13 + v14), v15 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v33;
  }
  uint64_t v17 = *(unsigned __int16 *)(v12 + 20);
  int64_t v18 = *(unsigned __int16 *)(v12 + 22);
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v19 = swift_initStackObject();
  *(_OWORD *)(v19 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v19 + 32) = a1;
  if (v18)
  {
    uint64_t v33 = sub_1B62F7C94((char *)(v13 + v17), v18);
    sub_1B62F81D8(v19);
    uint64_t v19 = v33;
    unint64_t v20 = *(void *)(v33 + 16);
  }
  else
  {
    unint64_t v20 = 1;
  }
  uint64_t v21 = *v7 + 41;
  char v22 = (char *)(v21 + *(unsigned __int16 *)(*v7 + 24));
  unint64_t v23 = (unint64_t)*(unsigned __int16 *)(*v7 + 26) >> 4;
  char v24 = (char *)(v21 + *(unsigned __int16 *)(*v7 + 28));
  uint64_t v25 = *(unsigned __int16 *)(*v7 + 30) / 0x18u;
  int v26 = *((_DWORD *)v7 + 2);
  char v27 = *((unsigned char *)v7 + 12);
  uint64_t v28 = v7[4];
  uint64_t v29 = v7[2];
  char v30 = *((unsigned char *)v7 + 24);
  uint64_t v31 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v19 + 32), v20, v22, v23, v24, v25);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a5 = v31;
  *(_DWORD *)(a5 + 8) = v26;
  *(unsigned char *)(a5 + 12) = v27;
  *(_WORD *)(a5 + 13) = v34;
  *(unsigned char *)(a5 + 15) = v35;
  *(void *)(a5 + 16) = v29;
  *(unsigned char *)(a5 + 24) = v30;
  *(_DWORD *)(a5 + 25) = v33;
  *(_DWORD *)(a5 + 28) = *(_DWORD *)((char *)&v33 + 3);
  *(void *)(a5 + 32) = v28;
  return result;
}

uint64_t sub_1B63AAC84@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, type metadata accessor for TriggerScript, (uint64_t)&off_1F0F625E0, a2);
}

uint64_t sub_1B63AACF8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for SpaceOverride;
  *(void *)(inited + 40) = &off_1F0F61E58;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AAF00@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DE74(a1, &qword_1EB981070, (void (*)(uint64_t))type metadata accessor for TriggerScript, a2);
}

uint64_t sub_1B63AAF7C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DE74(a1, (unint64_t *)&unk_1EB97E750, (void (*)(uint64_t))type metadata accessor for EmitterScript, a2);
}

uint64_t sub_1B63AAFF8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DE74(a1, (unint64_t *)&unk_1EB97E740, (void (*)(uint64_t))type metadata accessor for SimpleScript, a2);
}

uint64_t sub_1B63AB074@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DE74(a1, (unint64_t *)&qword_1EB97E730, (void (*)(uint64_t))type metadata accessor for ShaderScript, a2);
}

uint64_t sub_1B63AB0F0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DE74(a1, (unint64_t *)&unk_1EB97E720, (void (*)(uint64_t))type metadata accessor for GraphScript, a2);
}

uint64_t sub_1B63AB16C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DE74(a1, &qword_1EB97E710, (void (*)(uint64_t))type metadata accessor for ParticleUpdateScript, a2);
}

uint64_t sub_1B63AB1E8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DE74(a1, (unint64_t *)&qword_1EB981060, (void (*)(uint64_t))type metadata accessor for MetalFunctionScript, a2);
}

uint64_t sub_1B63AB264@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DE74(a1, &qword_1EB97E700, (void (*)(uint64_t))type metadata accessor for ParticleInitScript, a2);
}

uint64_t sub_1B63AB2E0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for ModelRenderer;
  *(void *)(inited + 40) = &off_1F0F60300;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AB4E8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for MeshFileAsset;
  *(void *)(inited + 40) = &off_1F0F60058;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AB6F0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, type metadata accessor for EmitterScript, (uint64_t)&off_1F0F5EC90, a2);
}

uint64_t sub_1B63AB764@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for VideoCapture;
  *(void *)(inited + 40) = &off_1F0F5D668;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AB96C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for SmoothMotion;
  *(void *)(inited + 40) = &off_1F0F5C588;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63ABB74@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, type metadata accessor for SimpleScript, (uint64_t)&off_1F0F5C338, a2);
}

uint64_t sub_1B63ABBE8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, type metadata accessor for ShaderScript, (uint64_t)&off_1F0F5C080, a2);
}

uint64_t sub_1B63ABC5C@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for CurveRuntime;
  *(void *)(inited + 40) = &off_1F0F596D8;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63ABE64@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  return sub_1B636DC68(a1, type metadata accessor for GraphScript, (uint64_t)&off_1F0F55688, a2);
}

uint64_t sub_1B63ABED8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for ForceField;
  *(void *)(inited + 40) = &off_1F0F52620;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AC0E0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for ColorRampComponent;
  *(void *)(inited + 40) = &off_1F0F75B48;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AC2E8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for GraphEntityComponentPropertyReferences;
  *(void *)(inited + 40) = &off_1F0F9D9B0;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AC4F0@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for CurveComponent;
  *(void *)(inited + 40) = &off_1F0F63698;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AC6F8@<X0>(char a1@<W0>, uint64_t a2@<X8>)
{
  int v3 = v2;
  uint64_t v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for HiddenOrHasHiddenAncestor;
  *(void *)(inited + 40) = &off_1F0F51710;
  if (v9 > 0xF)
  {
    uint64_t v27 = sub_1B62F79D4((char *)(v7 + v8), v9 >> 4);
    sub_1B62F8084(inited);
    uint64_t inited = v27;
  }
  uint64_t v11 = v6[10];
  int64_t v12 = v6[11];
  sub_1B62D87E8(0, &qword_1EB980B40, (uint64_t)&type metadata for AccessControl, MEMORY[0x1E4FBBE00]);
  uint64_t v13 = swift_initStackObject();
  *(_OWORD *)(v13 + 16) = xmmword_1B6E77050;
  *(unsigned char *)(v13 + 32) = a1;
  if (v12)
  {
    uint64_t v27 = sub_1B62F7C94((char *)(v7 + v11), v12);
    sub_1B62F81D8(v13);
    uint64_t v13 = v27;
    unint64_t v14 = *(void *)(v27 + 16);
  }
  else
  {
    unint64_t v14 = 1;
  }
  uint64_t v15 = (uint64_t)*v3 + 41;
  uint64_t v16 = (char *)(v15 + (*v3)[12]);
  unint64_t v17 = (unint64_t)(*v3)[13] >> 4;
  int64_t v18 = (char *)(v15 + (*v3)[14]);
  uint64_t v19 = (*v3)[15] / 0x18u;
  int v20 = *((_DWORD *)v3 + 2);
  char v21 = *((unsigned char *)v3 + 12);
  char v22 = v3[4];
  unint64_t v23 = v3[2];
  char v24 = *((unsigned char *)v3 + 24);
  uint64_t v25 = sub_1B62C8668((char *)(inited + 32), *(void *)(inited + 16), (char *)(v13 + 32), v14, v16, v17, v18, v19);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v25;
  *(_DWORD *)(a2 + 8) = v20;
  *(unsigned char *)(a2 + 12) = v21;
  *(_WORD *)(a2 + 13) = v28;
  *(unsigned char *)(a2 + 15) = v29;
  *(void *)(a2 + 16) = v23;
  *(unsigned char *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 25) = v27;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)((char *)&v27 + 3);
  *(void *)(a2 + 32) = v22;
  return result;
}

uint64_t sub_1B63AC900(uint64_t a1, uint64_t a2)
{
  int v3 = v2;
  uint64_t v6 = sub_1B6E30F48();
  uint64_t v7 = *(void *)(v6 - 8);
  MEMORY[0x1F4188790](v6, v8);
  uint64_t v10 = (char *)&v18 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  swift_bridgeObjectRelease();
  v3[2] = a1;
  v3[3] = a2;
  uint64_t v11 = (void *)v3[4];
  if (v11)
  {
    uint64_t v12 = v3[5];
    uint64_t ObjectType = swift_getObjectType();
    uint64_t v19 = v6;
    unint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 8);
    swift_bridgeObjectRetain();
    id v15 = v11;
    v14(a1, a2, ObjectType, v12);
    swift_bridgeObjectRelease();

    a1 = sub_1B6E30E18();
    a2 = v16;
    (*(void (**)(char *, uint64_t))(v7 + 8))(v10, v19);
  }
  else
  {
    swift_bridgeObjectRetain();
  }
  uint64_t result = swift_bridgeObjectRelease();
  *int v3 = a1;
  v3[1] = a2;
  return result;
}

uint64_t *sub_1B63ACA80(uint64_t *result, void *a2, char a3, void *a4)
{
  uint64_t v4 = *result;
  if (*result)
  {
    uint64_t v7 = result;
    uint64_t v9 = result[1];
    uint64_t v8 = result[2];
    uint64_t v10 = result[14];
    uint64_t v48 = v10;
    uint64_t v11 = *(char **)(v10 + 16);
    if (v11)
    {
      swift_unknownObjectRetain();
      sub_1B6399A44((uint64_t)&v48);
      uint64_t v12 = (uint64_t *)(v10 + 48);
      id v38 = v11;
      uint64_t v13 = v11;
      uint64_t v14 = v4;
      do
      {
        uint64_t v41 = *v12;
        uint64_t v42 = *(v12 - 1);
        long long v40 = *(_OWORD *)(v12 + 1);
        id v15 = a2;
        uint64_t v16 = a4;
        uint64_t v17 = v12[3];
        uint64_t v18 = v12[4];
        uint64_t v19 = v12[5];
        uint64_t v20 = *(v12 - 2) + v9;
        swift_unknownObjectRetain();
        sub_1B638955C(0, 0, 0, &v46);
        uint64_t v21 = v47;
        long long v22 = v46;
        long long v46 = v40;
        uint64_t v47 = v17;
        a2 = v15;
        long long v44 = v22;
        uint64_t v45 = v21;
        uint64_t v37 = v18;
        a4 = v16;
        objc_msgSend(v16, sel_copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_, v14, v20, v42, v41, &v46, v15, v37, v19, &v44);
        swift_unknownObjectRelease();
        v12 += 8;
        --v13;
      }
      while (v13);
      sub_1B62D8C3C((uint64_t)&v48);
      if (v38 != objc_msgSend(v15, sel_arrayLength) || (a3 & 1) == 0) {
        return (uint64_t *)swift_unknownObjectRelease();
      }
    }
    else
    {
      uint64_t v43 = v9;
      swift_getObjectType();
      swift_unknownObjectRetain();
      uint64_t v23 = (uint64_t)objc_msgSend(a2, sel_depth);
      if (v23 <= 1) {
        uint64_t v24 = 1;
      }
      else {
        uint64_t v24 = v23;
      }
      uint64_t v25 = v8 / v24;
      uint64_t v26 = sub_1B6389254(0);
      uint64_t v28 = v27;
      uint64_t v30 = v29;
      uint64_t v31 = *((unsigned __int16 *)v7 + 16);
      uint64_t v32 = v7[6];
      if ((unint64_t)(v32 - 160) <= 0x3A && ((1 << (v32 + 96)) & 0x7FDF1FF7CFD54FFLL) != 0)
      {
        if ((unint64_t)(v32 - 186) > 0x20) {
          LODWORD(v33) = 1;
        }
        else {
          uint64_t v33 = qword_1B6EC4BE8[v32 - 186];
        }
        uint64_t v34 = 16 * (((int)v33 + (int)v31 - 1) / v33);
        swift_unknownObjectRetain();
      }
      else
      {
        swift_unknownObjectRetain();
        uint64_t v34 = sub_1B6368160(v32) * v31;
      }
      sub_1B638955C(0, 0, 0, &v46);
      uint64_t v35 = v47;
      long long v36 = v46;
      *(void *)&long long v46 = v26;
      *((void *)&v46 + 1) = v28;
      uint64_t v47 = v30;
      long long v44 = v36;
      uint64_t v45 = v35;
      objc_msgSend(a4, sel_copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_, v4, v43, v34, v25, &v46, a2, 0, 0, &v44);
      swift_unknownObjectRelease();
      if ((a3 & 1) == 0) {
        return (uint64_t *)swift_unknownObjectRelease();
      }
    }
    sub_1B63AF8CC(a2, a4);
    return (uint64_t *)swift_unknownObjectRelease();
  }
  return result;
}

void sub_1B63ACD54(void *a1@<X8>)
{
  *a1 = 0x3E656D616E6F6E3CLL;
  a1[1] = 0xE800000000000000;
}

uint64_t assignWithTake for GraphEntityComponentPropertyReferences(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  swift_bridgeObjectRelease();
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 56) = *(unsigned char *)(a2 + 56);
  return a1;
}

uint64_t sub_1B63ACDF8()
{
  return sub_1B63BD64C() & 1;
}

uint64_t type metadata accessor for LastFrameWorldTransformSystem_vfx1()
{
  return self;
}

uint64_t type metadata accessor for ParticleFluidSolver2DSolverSystem()
{
  return self;
}

uint64_t sub_1B63ACE68()
{
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v23 = qword_1EB997A18;
  int v24 = 0;
  char v25 = 2;
  uint64_t v26 = 0;
  char v27 = 2;
  uint64_t v28 = 0;
  swift_retain();
  sub_1B63A3CBC((uint64_t)v5);
  swift_release();
  long long v1 = v5[1];
  *(_OWORD *)(v0 + 16) = v5[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v6;
  uint64_t v17 = qword_1EB997A18;
  int v18 = 0;
  char v19 = 2;
  uint64_t v20 = 0;
  char v21 = 2;
  uint64_t v22 = 0;
  swift_retain();
  sub_1B63A0F28((uint64_t)v7);
  swift_release();
  long long v2 = v7[1];
  *(_OWORD *)(v0 + 56) = v7[0];
  *(_OWORD *)(v0 + 72) = v2;
  *(void *)(v0 + 88) = v8;
  uint64_t v11 = qword_1EB997A18;
  int v12 = 0;
  char v13 = 2;
  uint64_t v14 = 0;
  char v15 = 2;
  uint64_t v16 = 0;
  swift_retain();
  sub_1B63A06A8((uint64_t)v9);
  swift_release();
  long long v3 = v9[1];
  *(_OWORD *)(v0 + 96) = v9[0];
  *(_OWORD *)(v0 + 112) = v3;
  *(void *)(v0 + 128) = v10;
  return v0;
}

uint64_t sub_1B63ACFBC()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63ACE68();
  return v0;
}

const char *sub_1B63ACFF4()
{
  return "ParticleFluidSolver2DSolver";
}

void sub_1B63AD008()
{
  uint64_t v2 = *(void *)(v0 + 16);
  uint64_t v3 = *(void *)(v2 + 40);
  uint64_t v4 = *(void *)(v2 + 48);
  sub_1B62C14BC((void *)(v2 + 16), v3);
  sub_1B63BD5B4(v3, v4);
  if (!v1) {
    ++*(_DWORD *)(v2 + 80);
  }
}

uint64_t type metadata accessor for AnimationComputeLocalTimeSystem()
{
  return self;
}

uint64_t sub_1B63AD090()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B63A8DC8(2, (uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 16) = v3[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v4;
  return v0;
}

const char *sub_1B63AD158()
{
  return "AnimationComputeLocalTime";
}

uint64_t sub_1B63AD170(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  int v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for TextureClientPlaceholderSystem()
{
  return self;
}

uint64_t sub_1B63AD260()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v11 = qword_1EB997A18;
  int v12 = 0;
  char v13 = 2;
  uint64_t v14 = 0;
  char v15 = 2;
  uint64_t v16 = 0;
  swift_retain();
  sub_1B63A8FD0(1, (uint64_t)&v6);
  swift_release();
  int v1 = v7;
  char v2 = v8;
  uint64_t v3 = v10;
  uint64_t v4 = v9 | 4;
  *(void *)(v0 + 16) = v6;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  return v0;
}

const char *sub_1B63AD348()
{
  return "TextureClientPlaceholder";
}

uint64_t sub_1B63AD360(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  uint64_t v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t sub_1B63AD42C()
{
  return qword_1E9DD2FD8 - 10;
}

uint64_t type metadata accessor for ParticleSubSpawnAddStateSystem()
{
  return self;
}

uint64_t sub_1B63AD460()
{
  uint64_t v0 = swift_allocObject();
  sub_1B6296650();
  return v0;
}

const char *sub_1B63AD498()
{
  return "Sub Spawn Add State";
}

uint64_t sub_1B63AD4B0(uint64_t a1)
{
  return sub_1B63AD65C(a1);
}

uint64_t sub_1B63AD4D8@<X0>(uint64_t a1@<X1>, uint64_t *a2@<X8>)
{
  uint64_t v5 = sub_1B6E31808();
  MEMORY[0x1F4188790](v5 - 8, v6);
  uint64_t result = sub_1B62C345C(a1, v7);
  if (!v2)
  {
    unsigned int v9 = sub_1B63BD74C(0x60u);
    uint64_t v10 = sub_1B62C0B24(v9);
    unint64_t v12 = v11;
    sub_1B6E317E8();
    sub_1B62B9338();
    uint64_t v13 = sub_1B6E317C8();
    if (v14)
    {
      uint64_t v15 = v13;
      uint64_t v16 = v14;
      sub_1B62C2360(v10, v12);
      uint64_t result = swift_release();
      *a2 = v15;
      a2[1] = v16;
    }
    else
    {
      sub_1B6B17984();
      swift_allocError();
      *(_OWORD *)uint64_t v17 = xmmword_1B6E78210;
      *(unsigned char *)(v17 + 16) = 6;
      swift_willThrow();
      sub_1B62C2360(v10, v12);
      return swift_release();
    }
  }
  return result;
}

uint64_t sub_1B63AD65C(uint64_t a1)
{
  uint64_t result = sub_1B63AD4D8(a1, &v3);
  if (!v1) {
    return v3;
  }
  return result;
}

uint64_t sub_1B63AD694()
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v22 = qword_1EB997A18;
  int v23 = 0;
  char v24 = 2;
  uint64_t v25 = 0;
  char v26 = 2;
  uint64_t v27 = 0;
  swift_retain();
  sub_1B63A136C((uint64_t)v8);
  swift_release();
  long long v1 = v8[1];
  *(_OWORD *)(v0 + 16) = v8[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v9;
  uint64_t v16 = qword_1EB997A18;
  int v17 = 0;
  char v18 = 2;
  uint64_t v19 = 0;
  char v20 = 2;
  uint64_t v21 = 0;
  swift_retain();
  sub_1B629D424(1, 1, (uint64_t)v10);
  swift_release();
  sub_1B62F7B88(0, (unint64_t *)&qword_1EB980C70, (unint64_t *)&qword_1EB980000, (unint64_t *)&qword_1EB97FFF0);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for LastFrameWorldTransform;
  *(void *)(inited + 40) = &off_1F0F8F510;
  sub_1B62AD184(&v11);
  swift_setDeallocating();
  sub_1B62CA064((uint64_t)v10);
  int v3 = v12;
  char v4 = v13;
  uint64_t v5 = v15;
  uint64_t v6 = v14 | 4;
  *(void *)(v0 + 56) = v11;
  *(_DWORD *)(v0 + 64) = v3;
  *(unsigned char *)(v0 + 68) = v4;
  *(void *)(v0 + 72) = v6;
  *(unsigned char *)(v0 + 80) = 2;
  *(void *)(v0 + 88) = v5;
  return v0;
}

uint64_t sub_1B63AD85C()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63AD694();
  return v0;
}

uint64_t sub_1B63AD894()
{
  return (*(uint64_t (**)(void))(v0 + 112))();
}

const char *sub_1B63AD8A8()
{
  return "LastFrameWorldTransform";
}

uint64_t sub_1B63AD8BC()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 104))();
}

uint64_t type metadata accessor for KernelScriptReflectionSystem()
{
  return self;
}

uint64_t sub_1B63AD908()
{
  uint64_t v1 = v0;
  uint64_t v2 = sub_1B6E32228();
  uint64_t v3 = *(void *)(v2 - 8);
  MEMORY[0x1F4188790](v2, v4);
  uint64_t v6 = (char *)&v28 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = sub_1B6E321F8();
  MEMORY[0x1F4188790](v7 - 8, v8);
  uint64_t v9 = sub_1B6E31418();
  MEMORY[0x1F4188790](v9 - 8, v10);
  sub_1B63989B8(0, (unint64_t *)&qword_1EB97D1B0);
  sub_1B6E31408();
  sub_1B6E321E8();
  (*(void (**)(char *, void, uint64_t))(v3 + 104))(v6, *MEMORY[0x1E4FBCC58], v2);
  *(void *)(v1 + 16) = sub_1B6E32258();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v66 = qword_1EB997A18;
  int v67 = 0;
  char v68 = 2;
  uint64_t v69 = 0;
  char v70 = 2;
  uint64_t v71 = 0;
  swift_retain();
  sub_1B63AB1E8(1, (uint64_t)&v28);
  swift_release();
  int v11 = v29;
  char v12 = v30;
  uint64_t v13 = v32;
  uint64_t v14 = v31 | 4;
  *(void *)(v1 + 24) = v28;
  *(_DWORD *)(v1 + 32) = v11;
  *(unsigned char *)(v1 + 36) = v12;
  *(void *)(v1 + 40) = v14;
  *(unsigned char *)(v1 + 48) = 2;
  *(void *)(v1 + 56) = v13;
  uint64_t v60 = qword_1EB997A18;
  int v61 = 0;
  char v62 = 2;
  uint64_t v63 = 0;
  char v64 = 2;
  uint64_t v65 = 0;
  swift_retain();
  sub_1B63A311C(1, 1, (uint64_t)&v33);
  swift_release();
  int v15 = v34;
  char v16 = v35;
  uint64_t v17 = v37;
  uint64_t v18 = v36 | 4;
  *(void *)(v1 + 64) = v33;
  *(_DWORD *)(v1 + 72) = v15;
  *(unsigned char *)(v1 + 76) = v16;
  *(void *)(v1 + 80) = v18;
  *(unsigned char *)(v1 + 88) = 2;
  *(void *)(v1 + 96) = v17;
  uint64_t v54 = qword_1EB997A18;
  int v55 = 0;
  char v56 = 2;
  uint64_t v57 = 0;
  char v58 = 2;
  uint64_t v59 = 0;
  swift_retain();
  sub_1B636DA60(1, (uint64_t)&v38);
  swift_release();
  int v19 = v39;
  char v20 = v40;
  uint64_t v21 = v42;
  uint64_t v22 = v41 | 4;
  *(void *)(v1 + 104) = v38;
  *(_DWORD *)(v1 + 112) = v19;
  *(unsigned char *)(v1 + 116) = v20;
  *(void *)(v1 + 120) = v22;
  *(unsigned char *)(v1 + 128) = 2;
  *(void *)(v1 + 136) = v21;
  uint64_t v48 = qword_1EB997A18;
  int v49 = 0;
  char v50 = 2;
  uint64_t v51 = 0;
  char v52 = 2;
  uint64_t v53 = 0;
  swift_retain();
  sub_1B63A82B8(1, (uint64_t)&v43);
  swift_release();
  int v23 = v44;
  char v24 = v45;
  uint64_t v25 = v47;
  uint64_t v26 = v46 | 4;
  *(void *)(v1 + 144) = v43;
  *(_DWORD *)(v1 + 152) = v23;
  *(unsigned char *)(v1 + 156) = v24;
  *(void *)(v1 + 160) = v26;
  *(unsigned char *)(v1 + 168) = 2;
  *(void *)(v1 + 176) = v25;
  return v1;
}

uint64_t sub_1B63ADCC8()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63AD908();
  return v0;
}

const char *sub_1B63ADD00()
{
  return "MetalScriptReflection";
}

uint64_t destroy for Query()
{
  return swift_release();
}

uint64_t sub_1B63ADD20()
{
  return qword_1E9DD3010;
}

uint64_t type metadata accessor for TriggerScriptRunnerSystem()
{
  return self;
}

const char *sub_1B63ADD50()
{
  return "TriggerScriptRunnerSystem";
}

uint64_t type metadata accessor for PointCacheGeneratorSystem()
{
  return self;
}

uint64_t sub_1B63ADD88()
{
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v50 = qword_1EB997A18;
  int v51 = 0;
  char v52 = 2;
  uint64_t v53 = 0;
  char v54 = 2;
  uint64_t v55 = 0;
  swift_retain();
  sub_1B63A8B4C(1, (uint64_t)&v15);
  swift_release();
  int v1 = v16;
  char v2 = v17;
  uint64_t v3 = v19;
  uint64_t v4 = v18 | 4;
  *(void *)(v0 + 16) = v15;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  uint64_t v44 = qword_1EB997A18;
  int v45 = 0;
  char v46 = 2;
  uint64_t v47 = 0;
  char v48 = 2;
  uint64_t v49 = 0;
  swift_retain();
  sub_1B63A8944(1, (uint64_t)v20);
  swift_release();
  long long v5 = v20[1];
  *(_OWORD *)(v0 + 56) = v20[0];
  *(_OWORD *)(v0 + 72) = v5;
  *(void *)(v0 + 88) = v21;
  uint64_t v38 = qword_1EB997A18;
  int v39 = 0;
  char v40 = 2;
  uint64_t v41 = 0;
  char v42 = 2;
  uint64_t v43 = 0;
  swift_retain();
  sub_1B62943C0(1, (uint64_t)&v22);
  swift_release();
  int v6 = v23;
  char v7 = v24;
  uint64_t v8 = v26;
  uint64_t v9 = v25 | 4;
  *(void *)(v0 + 96) = v22;
  *(_DWORD *)(v0 + 104) = v6;
  *(unsigned char *)(v0 + 108) = v7;
  *(void *)(v0 + 112) = v9;
  *(unsigned char *)(v0 + 120) = 2;
  *(void *)(v0 + 128) = v8;
  uint64_t v32 = qword_1EB997A18;
  int v33 = 0;
  char v34 = 2;
  uint64_t v35 = 0;
  char v36 = 2;
  uint64_t v37 = 0;
  swift_retain();
  sub_1B63A80B0(1, (uint64_t)&v27);
  swift_release();
  int v10 = v28;
  char v11 = v29;
  uint64_t v12 = v31;
  uint64_t v13 = v30 | 4;
  *(void *)(v0 + 136) = v27;
  *(_DWORD *)(v0 + 144) = v10;
  *(unsigned char *)(v0 + 148) = v11;
  *(void *)(v0 + 152) = v13;
  *(unsigned char *)(v0 + 160) = 2;
  *(void *)(v0 + 168) = v12;
  return v0;
}

uint64_t sub_1B63ADF94()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63ADD88();
  return v0;
}

const char *sub_1B63ADFCC()
{
  return "PointCacheGeneratorSystem";
}

uint64_t type metadata accessor for RendererPostUpdateSystem()
{
  return self;
}

const char *sub_1B63AE008()
{
  return "RendererPostUpdateSystem";
}

uint64_t type metadata accessor for RenderGraphSystemCleanup()
{
  return self;
}

const char *sub_1B63AE040()
{
  return "RenderGraphCleanup";
}

uint64_t sub_1B63AE054()
{
  return qword_1E9DD3030 - 1;
}

uint64_t type metadata accessor for PrimitiveGeneratorSystem()
{
  return self;
}

uint64_t sub_1B63AE088()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v11 = qword_1EB997A18;
  int v12 = 0;
  char v13 = 2;
  uint64_t v14 = 0;
  char v15 = 2;
  uint64_t v16 = 0;
  swift_retain();
  sub_1B63A91D8(1, (uint64_t)&v6);
  swift_release();
  int v1 = v7;
  char v2 = v8;
  uint64_t v3 = v10;
  uint64_t v4 = v9 | 4;
  *(void *)(v0 + 16) = v6;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  return v0;
}

const char *sub_1B63AE170()
{
  return "PrimitiveGenerator";
}

uint64_t sub_1B63AE188(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  uint64_t v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for ParticleEmitterTransport()
{
  return self;
}

uint64_t sub_1B63AE278()
{
  type metadata accessor for ParticleEmitterTransport();
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B629AD2C(1, 2, (uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 16) = v3[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v4;
  return v0;
}

const char *sub_1B63AE344()
{
  return "ParticleEmitterTransport";
}

uint64_t sub_1B63AE35C(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  int v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t sub_1B63AE428(void *a1)
{
  return sub_1B628F3F4(a1);
}

uint64_t type metadata accessor for AssetManagerPathResolver()
{
  return self;
}

uint64_t type metadata accessor for SkeletonAnimationSystem()
{
  return self;
}

uint64_t sub_1B63AE488(uint64_t a1, uint64_t a2)
{
  return sub_1B636AFC8(a1, a2, 1, (void (*)(_OWORD *__return_ptr, uint64_t))sub_1B63A7890);
}

const char *sub_1B63AE4A4()
{
  return "SkeletonAnimationSystem";
}

uint64_t sub_1B63AE4BC(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  int v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

unint64_t sub_1B63AE588()
{
  unint64_t result = qword_1EB97D790;
  if (!qword_1EB97D790)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97D790);
  }
  return result;
}

unint64_t sub_1B63AE5E4()
{
  unint64_t result = qword_1EB97F868;
  if (!qword_1EB97F868)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F868);
  }
  return result;
}

unint64_t sub_1B63AE638()
{
  unint64_t result = qword_1EB97F860;
  if (!qword_1EB97F860)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F860);
  }
  return result;
}

uint64_t type metadata accessor for KeyframeAnimationSystem()
{
  return self;
}

uint64_t sub_1B63AE6B0()
{
  uint64_t v0 = swift_allocObject();
  sub_1B628B42C();
  return v0;
}

const char *sub_1B63AE6E8()
{
  return "KeyframeAnimations";
}

void sub_1B63AE700(uint64_t a1@<X8>)
{
  *(_WORD *)a1 = 257;
  *(unsigned char *)(a1 + 2) = 0;
}

void *initializeBufferWithCopyOfBuffer for CodeGenerationComponent(void *a1, void *a2)
{
  *a1 = *a2;
  swift_retain();
  return a1;
}

uint64_t sub_1B63AE744(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = v3;
  uint64_t v50 = a1;
  uint64_t v7 = sub_1B6E30F48();
  uint64_t v8 = *(void **)(v7 - 8);
  uint64_t v9 = v8[8];
  MEMORY[0x1F4188790](v7, v10);
  uint64_t v11 = (char *)&v39 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((*(void *)a2 & 0x100) != 0)
  {
    uint64_t v16 = 0;
    unint64_t v12 = *(void *)a2 & 0x104;
    long long v13 = 0uLL;
    __int16 v17 = 768;
    char v14 = -2;
    long long v15 = 0uLL;
  }
  else
  {
    unint64_t v12 = *(void *)a2 & 0x1FCLL;
    long long v13 = *(_OWORD *)(a2 + 8);
    char v14 = *(unsigned char *)(a2 + 24);
    long long v15 = *(_OWORD *)(a2 + 32);
    uint64_t v16 = *(void *)(a2 + 48);
    __int16 v17 = *(_WORD *)(a2 + 56);
  }
  unint64_t v69 = v12;
  long long v70 = v13;
  char v71 = v14;
  long long v72 = v15;
  uint64_t v73 = v16;
  __int16 v74 = v17;
  uint64_t v75 = a3;
  if (v12 >= 0x100)
  {
    uint64_t v18 = sub_1B6CFD2B4(v50, &v69, a3);
    if (!v3) {
      return (uint64_t)v18;
    }
    uint64_t v46 = v7;
    uint64_t v47 = v8;
    if (qword_1EB9852D0 != -1) {
      swift_once();
    }
    swift_getErrorValue();
    swift_retain();
    uint64_t v19 = sub_1B6E33868();
    uint64_t v21 = v20;
    int v22 = sub_1B6E32148();
    if (qword_1EB9854F8 != -1) {
      swift_once();
    }
    uint64_t v49 = (_OWORD *)a2;
    v51[0] = 0;
    swift_retain();
    sub_1B6B33E34(v22, v51, v19, v21);
    swift_release();
    swift_bridgeObjectRelease();
    swift_release();

    char v48 = 0;
    uint64_t v7 = v46;
    uint64_t v8 = v47;
    a3 = v75;
  }
  else
  {
    char v48 = v3;
    uint64_t v49 = (_OWORD *)a2;
  }
  uint64_t v47 = *(void **)(a3 + 240);
  ((void (*)(char *, uint64_t, uint64_t))v8[2])((char *)&v39 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0), v50, v7);
  uint64_t v23 = v7;
  unint64_t v24 = (*((unsigned __int8 *)v8 + 80) + 16) & ~(unint64_t)*((unsigned __int8 *)v8 + 80);
  unint64_t v25 = (v9 + v24 + 7) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v26 = swift_allocObject();
  ((void (*)(unint64_t, char *, uint64_t))v8[4])(v26 + v24, v11, v23);
  uint64_t v27 = (_OWORD *)(v26 + v25);
  int v28 = v49;
  long long v29 = v49[1];
  *uint64_t v27 = *v49;
  v27[1] = v29;
  v27[2] = v28[2];
  *(_OWORD *)((char *)v27 + 42) = *(_OWORD *)((char *)v28 + 42);
  *(void *)(v26 + ((v25 + 65) & 0xFFFFFFFFFFFFFFF8)) = v75;
  swift_retain();
  id v30 = v47;
  uint64_t v31 = v48;
  sub_1B63619EC(0, (uint64_t *)&v69, (uint64_t)sub_1B63AED18, v26, 0, 0, v52);
  if (v31)
  {
    swift_release();
    return (uint64_t)v30;
  }
  uint64_t v32 = (void *)v52[1];
  char v40 = (void *)v52[2];
  uint64_t v41 = (void *)v52[0];
  uint64_t v33 = v52[4];
  id v30 = (id)v52[5];
  uint64_t v50 = v52[6];
  uint64_t v47 = (void *)v52[8];
  char v48 = (void *)v52[7];
  uint64_t v45 = v52[10];
  uint64_t v46 = v52[9];
  uint64_t v44 = v52[11];
  uint64_t v34 = v52[13];
  uint64_t v42 = v52[3];
  uint64_t v43 = v52[12];
  uint64_t v35 = v52[14];
  swift_release();
  if (v34 < 0)
  {
    v53[0] = v41;
    v53[1] = v32;
    v53[2] = v40;
    char v54 = v42 & 1;
    uint64_t v55 = v33;
    __int16 v56 = (__int16)v30;
    char v57 = BYTE2(v30) & 1;
    uint64_t v58 = v50;
    uint64_t v59 = v48;
    uint64_t v60 = v47;
    uint64_t v61 = v46;
    uint64_t v62 = v45;
    uint64_t v63 = v44;
    uint64_t v64 = v43;
    __int16 v65 = v34;
    char v66 = BYTE2(v34);
    char v67 = BYTE3(v34);
    uint64_t v68 = v35;
    id v36 = sub_1B628B9D4(v53, (uint64_t *)v28, v75, 0);
    if (v36)
    {
      id v30 = v36;
    }
    else
    {
      sub_1B6D0ACA8();
      swift_allocError();
      *(void *)uint64_t v38 = 0xD000000000000017;
      *(void *)(v38 + 8) = 0x80000001B6F52670;
      *(unsigned char *)(v38 + 16) = 1;
      swift_willThrow();
    }
    sub_1B63BB57C((uint64_t)v52);
    return (uint64_t)v30;
  }
  uint64_t result = sub_1B6E32BE8();
  __break(1u);
  return result;
}

double sub_1B63AEC74@<D0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *(void *)(sub_1B6E30F48() - 8);
  unint64_t v4 = (*(unsigned __int8 *)(v3 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80);
  unint64_t v5 = (*(void *)(v3 + 64) + v4 + 7) & 0xFFFFFFFFFFFFFFF8;
  return sub_1B63B7EDC(v1 + v4, (CGColorSpace *)(v1 + v5), *(void *)(v1 + ((v5 + 65) & 0xFFFFFFFFFFFFFFF8)), a1);
}

double sub_1B63AED18@<D0>(uint64_t a1@<X8>)
{
  return sub_1B63AEC74(a1);
}

uint64_t sub_1B63AED30@<X0>(unint64_t a1@<X0>, CGColorSpace *a2@<X1>, size_t a3@<X2>, void *a4@<X8>)
{
  size_t v105 = a3;
  uint64_t v104 = a2;
  unint64_t v96 = a4;
  uint64_t v98 = sub_1B6E312D8();
  uint64_t v97 = *(void *)(v98 - 8);
  MEMORY[0x1F4188790](v98, v5);
  int v107 = (char *)v84 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v7, v8);
  unint64_t v95 = (char *)v84 - v9;
  uint64_t v10 = sub_1B6E30F48();
  uint64_t v11 = *(void *)(v10 - 8);
  MEMORY[0x1F4188790](v10, v12);
  char v14 = (char *)v84 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = sub_1B6E31288();
  uint64_t v111 = *(void *)(v15 - 8);
  MEMORY[0x1F4188790](v15, v16);
  id v108 = (char *)v84 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v18, v19);
  uint64_t v100 = (char *)v84 - v20;
  MEMORY[0x1F4188790](v21, v22);
  unint64_t v24 = (char *)v84 - v23;
  MEMORY[0x1F4188790](v25, v26);
  int v28 = (char *)v84 - v27;
  if (qword_1EB97FF40 != -1) {
    swift_once();
  }
  uint64_t v29 = sub_1B6E312C8();
  uint64_t v30 = sub_1B6385660(v29, (uint64_t)qword_1EB997E68);
  sub_1B6E312A8();
  sub_1B6E31268();
  RGTextureDescriptor.init()((uint64_t)&v127);
  size_t v116 = 0;
  uint64_t v114 = 0;
  uint64_t v115 = 0;
  unsigned __int8 v117 = 0;
  uint64_t v118 = v127;
  __int16 v119 = v128;
  unsigned __int8 v120 = v129;
  long long v121 = v130;
  long long v122 = v131;
  long long v123 = v132;
  uint64_t v124 = v133;
  __int32 v125 = v134;
  int v126 = (char *)MEMORY[0x1E4FBC860];
  uint64_t v31 = *(void (**)(char *, unint64_t, uint64_t))(v11 + 16);
  unint64_t v103 = a1;
  v31(v14, a1, v10);
  uint64_t v102 = v30;
  uint64_t v32 = sub_1B6E312A8();
  int v33 = sub_1B6E322B8();
  char v34 = sub_1B6E323F8();
  os_signpost_id_t v101 = v24;
  id v109 = v28;
  if (v34)
  {
    uint64_t v99 = *(void (**)(char *, char *, uint64_t))(v111 + 16);
    unint64_t v110 = (v111 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
    v99(v24, v28, v15);
    uint64_t v35 = (uint8_t *)swift_slowAlloc();
    uint64_t v36 = swift_slowAlloc();
    uint64_t v94 = v15;
    uint64_t v37 = v36;
    uint64_t v113 = v36;
    int v93 = v33;
    *(_DWORD *)uint64_t v35 = 136315138;
    uint64_t v38 = sub_1B6E30E08();
    uint64_t v112 = sub_1B6385A2C(v38, v39, &v113);
    unint64_t v24 = v101;
    sub_1B6E325A8();
    swift_bridgeObjectRelease();
    (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
    os_signpost_id_t v40 = sub_1B6E31278();
    _os_signpost_emit_with_name_impl(&dword_1B6287000, v32, (os_signpost_type_t)v93, v40, "loadTextureFromDisk", "URL: %s", v35, 0xCu);
    swift_arrayDestroy();
    uint64_t v41 = v37;
    uint64_t v15 = v94;
    MEMORY[0x1BA9B84C0](v41, -1, -1);
    uint64_t v42 = v35;
    int v28 = v109;
    MEMORY[0x1BA9B84C0](v42, -1, -1);

    uint64_t v43 = v99;
    (*(void (**)(char *, uint64_t))(v111 + 8))(v24, v15);
    unint64_t v44 = v110;
  }
  else
  {

    (*(void (**)(char *, uint64_t))(v11 + 8))(v14, v10);
    uint64_t v43 = *(void (**)(char *, char *, uint64_t))(v111 + 16);
    unint64_t v44 = (v111 + 16) & 0xFFFFFFFFFFFFLL | 0xE3BA000000000000;
  }
  uint64_t v45 = v107;
  unint64_t v110 = v44;
  v43(v24, v28, v15);
  sub_1B6E31308();
  swift_allocObject();
  sub_1B6E312F8();
  uint64_t v46 = v106;
  sub_1B63B5450(v103, v104, v105, 0, 1);
  char v48 = v108;
  if (v46)
  {
    uint64_t v49 = sub_1B6E312A8();
    sub_1B6E312E8();
    int v50 = sub_1B6E322A8();
    if (sub_1B6E323F8())
    {
      LODWORD(v107) = v50;
      swift_retain();
      sub_1B6E31318();
      swift_release();
      uint64_t v51 = v97;
      uint64_t v52 = v98;
      BOOL v53 = (*(unsigned int (**)(char *, uint64_t))(v97 + 88))(v45, v98) == *MEMORY[0x1E4FBD340];
      v84[1] = v46;
      char v54 = v43;
      if (v53)
      {
        char v66 = "[Error] Interval already ended";
      }
      else
      {
        (*(void (**)(char *, uint64_t))(v51 + 8))(v45, v52);
        char v66 = "";
      }
      char v67 = v101;
      uint64_t v68 = v108;
      v54(v101, v108, v15);
      uint64_t v69 = v15;
      long long v70 = (uint8_t *)swift_slowAlloc();
      *(_WORD *)long long v70 = 0;
      os_signpost_id_t v71 = sub_1B6E31278();
      _os_signpost_emit_with_name_impl(&dword_1B6287000, v49, (os_signpost_type_t)v107, v71, "loadTextureFromDisk", v66, v70, 2u);
      long long v72 = v70;
      uint64_t v15 = v69;
      MEMORY[0x1BA9B84C0](v72, -1, -1);

      uint64_t v64 = *(void (**)(char *, uint64_t))(v111 + 8);
      v64(v68, v69);
      v64(v67, v69);
    }
    else
    {

      uint64_t v64 = *(void (**)(char *, uint64_t))(v111 + 8);
      v64(v48, v15);
    }
    swift_release();
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    return ((uint64_t (*)(char *, uint64_t))v64)(v109, v15);
  }
  else
  {
    uint64_t v99 = v43;
    uint64_t v106 = v115;
    size_t v105 = v116;
    LODWORD(v104) = v117;
    uint64_t v55 = v118;
    LODWORD(v103) = v119;
    LODWORD(v94) = HIBYTE(v119);
    int v93 = v120;
    uint64_t v91 = *((void *)&v121 + 1);
    uint64_t v92 = v121;
    uint64_t v89 = *((void *)&v122 + 1);
    uint64_t v90 = v122;
    uint64_t v87 = *((void *)&v123 + 1);
    uint64_t v88 = v123;
    uint64_t v86 = v124;
    v47.i32[0] = v125;
    int16x8_t v85 = (int16x8_t)vmovl_u8(v47);
    __int16 v56 = v126;
    id v108 = v114;
    swift_unknownObjectRetain();
    int v107 = v56;
    swift_bridgeObjectRetain();
    char v57 = sub_1B6E312A8();
    uint64_t v58 = v100;
    sub_1B6E312E8();
    os_signpost_type_t v59 = sub_1B6E322A8();
    if (sub_1B6E323F8())
    {
      swift_retain();
      uint64_t v60 = v95;
      sub_1B6E31318();
      swift_release();
      uint64_t v61 = v97;
      uint64_t v62 = v98;
      if ((*(unsigned int (**)(char *, uint64_t))(v97 + 88))(v60, v98) == *MEMORY[0x1E4FBD340])
      {
        uint64_t v63 = "[Error] Interval already ended";
      }
      else
      {
        (*(void (**)(char *, uint64_t))(v61 + 8))(v60, v62);
        uint64_t v63 = "";
      }
      __int16 v74 = v101;
      v99(v101, v100, v15);
      uint64_t v75 = (uint8_t *)swift_slowAlloc();
      *(_WORD *)uint64_t v75 = 0;
      os_signpost_id_t v76 = sub_1B6E31278();
      _os_signpost_emit_with_name_impl(&dword_1B6287000, v57, v59, v76, "loadTextureFromDisk", v63, v75, 2u);
      MEMORY[0x1BA9B84C0](v75, -1, -1);

      __int16 v65 = *(void (**)(char *, uint64_t))(v111 + 8);
      v65(v100, v15);
      v65(v74, v15);
      int v28 = v109;
    }
    else
    {

      __int16 v65 = *(void (**)(char *, uint64_t))(v111 + 8);
      v65(v58, v15);
    }
    uint64_t v77 = v107;
    swift_bridgeObjectRelease();
    uint64_t v78 = v108;
    swift_unknownObjectRelease();
    swift_release();
    uint64_t result = ((uint64_t (*)(char *, uint64_t))v65)(v28, v15);
    uint64_t v79 = v96;
    uint64_t v80 = v106;
    *unint64_t v96 = v78;
    v79[1] = v80;
    v79[2] = v105;
    *((unsigned char *)v79 + 24) = (_BYTE)v104;
    v79[4] = v55;
    *((unsigned char *)v79 + 40) = v103;
    *((unsigned char *)v79 + 41) = v94;
    *((unsigned char *)v79 + 42) = v93;
    uint64_t v81 = v91;
    v79[6] = v92;
    v79[7] = v81;
    uint64_t v82 = v89;
    v79[8] = v90;
    v79[9] = v82;
    uint64_t v83 = v87;
    v79[10] = v88;
    v79[11] = v83;
    v79[12] = v86;
    *((_DWORD *)v79 + 26) = vmovn_s16(v85).u32[0];
    v79[14] = v77;
  }
  return result;
}

uint64_t sub_1B63AF8CC(void *a1, void *a2)
{
  uint64_t v4 = sub_1B6E31288();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4, v6);
  uint64_t v8 = &v30[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  MEMORY[0x1F4188790](v9, v10);
  uint64_t v12 = &v30[-v11];
  swift_getObjectType();
  uint64_t result = (uint64_t)objc_msgSend(a1, sel_mipmapLevelCount);
  if (result >= 2)
  {
    if (qword_1EB97FF40 != -1) {
      swift_once();
    }
    uint64_t v14 = sub_1B6E312C8();
    sub_1B6385660(v14, (uint64_t)qword_1EB997E68);
    sub_1B6E312A8();
    sub_1B6E31268();
    swift_unknownObjectRetain_n();
    uint64_t v15 = sub_1B6E312A8();
    int v16 = sub_1B6E322C8();
    if (sub_1B6E323F8())
    {
      int v31 = v16;
      uint64_t v32 = a2;
      uint64_t v33 = v4;
      (*(void (**)(unsigned char *, unsigned char *, uint64_t))(v5 + 16))(v8, v12, v4);
      uint64_t v17 = (uint8_t *)swift_slowAlloc();
      uint64_t v18 = swift_slowAlloc();
      uint64_t v35 = v18;
      *(_DWORD *)uint64_t v17 = 136315138;
      id v19 = objc_msgSend(a1, sel_label);
      if (v19)
      {
        uint64_t v20 = v19;
        uint64_t v21 = sub_1B6E31798();
        unint64_t v23 = v22;
      }
      else
      {
        uint64_t v21 = sub_1B6BBD79C();
        unint64_t v23 = v24;
      }
      uint64_t v34 = sub_1B6385A2C(v21, v23, &v35);
      sub_1B6E325A8();
      swift_unknownObjectRelease_n();
      swift_bridgeObjectRelease();
      os_signpost_id_t v25 = sub_1B6E31278();
      _os_signpost_emit_with_name_impl(&dword_1B6287000, v15, (os_signpost_type_t)v31, v25, "generateMipmap", "CB %s", v17, 0xCu);
      swift_arrayDestroy();
      MEMORY[0x1BA9B84C0](v18, -1, -1);
      MEMORY[0x1BA9B84C0](v17, -1, -1);

      uint64_t v4 = v33;
      (*(void (**)(unsigned char *, uint64_t))(v5 + 8))(v8, v33);
      a2 = v32;
    }
    else
    {

      swift_unknownObjectRelease_n();
    }
    uint64_t v26 = (char *)objc_msgSend(a1, sel_pixelFormat);
    if ((unint64_t)(v26 - 160) <= 0x3A && ((1 << (v26 + 96)) & 0x7FDF1FF7CFD54FFLL) != 0)
    {
      if (qword_1EB9852D0 != -1) {
        swift_once();
      }
      uint64_t v35 = 0;
      unint64_t v36 = 0xE000000000000000;
      swift_retain();
      sub_1B6E328C8();
      swift_bridgeObjectRelease();
      uint64_t v35 = 0xD000000000000023;
      unint64_t v36 = 0x80000001B6F52940;
      _sSo14MTLPixelFormatV3VFXE11descriptionSSvg_0((uint64_t)objc_msgSend(a1, sel_pixelFormat));
      sub_1B6E31948();
      swift_bridgeObjectRelease();
      uint64_t v27 = v35;
      uint64_t v28 = v36;
      int v29 = sub_1B6E32148();
      if (qword_1EB9854F8 != -1) {
        swift_once();
      }
      uint64_t v35 = 0;
      swift_retain();
      sub_1B6B33E34(v29, &v35, v27, v28);
      swift_release();
      swift_bridgeObjectRelease();
      swift_release();
    }
    else
    {
      objc_msgSend(a2, sel_generateMipmapsForTexture_, a1);
    }
    return (*(uint64_t (**)(unsigned char *, uint64_t))(v5 + 8))(v12, v4);
  }
  return result;
}

void sub_1B63AFD68()
{
  sub_1B638C038(319, (unint64_t *)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718]);
  if (v0 <= 0x3F) {
    swift_initStructMetadata();
  }
}

void *initializeBufferWithCopyOfBuffer for RenderGraphDiagnostics.RendererInfo(void *a1, void *a2)
{
  *a1 = *a2;
  swift_unknownObjectRetain();
  return a1;
}

uint64_t type metadata accessor for ParticleSubSpawnSystem()
{
  return self;
}

uint64_t sub_1B63AFEA4()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B629416C(1, 2, (uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 16) = v3[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v4;
  return v0;
}

uint64_t sub_1B63AFF70()
{
  return (*(uint64_t (**)(void))(v0 + 88))();
}

uint64_t sub_1B63AFF84()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 96))();
}

uint64_t sub_1B63AFFA8()
{
  return (*(uint64_t (**)(void))(*(void *)v0 + 112))();
}

const char *sub_1B63AFFD0()
{
  return "Sub Spawn";
}

uint64_t type metadata accessor for NoHeapTextureAllocator()
{
  return self;
}

uint64_t sub_1B63B0008()
{
  uint64_t v0 = swift_allocObject();
  sub_1B6296DBC();
  return v0;
}

const char *sub_1B63B0040()
{
  return "UpdateWorldAABB";
}

uint64_t type metadata accessor for TransparentRenderPass()
{
  return self;
}

uint64_t sub_1B63B0078()
{
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v7 = qword_1EB997A18;
  int v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  char v11 = 2;
  uint64_t v12 = 0;
  swift_retain();
  sub_1B63A33AC(1, 1, (uint64_t)v4);
  swift_release();
  sub_1B62C6034(0, (unint64_t *)&qword_1EB980B60, (unint64_t *)&qword_1EB97E840, (uint64_t)&protocol descriptor for ClassComponent, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 56) = &type metadata for DrawCallLayer;
  *(void *)(inited + 64) = &off_1F0F5E758;
  *(unsigned char *)(inited + 32) = 1;
  sub_1B62A1250(inited, (uint64_t)v5);
  swift_setDeallocating();
  sub_1B62C5560(0, (unint64_t *)&qword_1EB97E840);
  swift_arrayDestroy();
  sub_1B62CA064((uint64_t)v4);
  long long v2 = v5[1];
  *(_OWORD *)(v0 + 16) = v5[0];
  *(_OWORD *)(v0 + 32) = v2;
  *(void *)(v0 + 48) = v6;
  return v0;
}

uint64_t sub_1B63B01F8()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63B0078();
  return v0;
}

const char *sub_1B63B0230()
{
  return "TransparentRenderPass";
}

void sub_1B63B0248(uint64_t a1@<X8>)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 98;
  *(unsigned char *)(a1 + 24) = -2;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 56) = 768;
}

uint64_t type metadata accessor for TextureDownloadSystem()
{
  return self;
}

uint64_t sub_1B63B0294()
{
  uint64_t v0 = swift_allocObject();
  sub_1B62932D0();
  return v0;
}

const char *sub_1B63B02CC()
{
  return "TextureDownload";
}

uint64_t type metadata accessor for SceneComponentStorage()
{
  return self;
}

uint64_t sub_1B63B0308()
{
  long long v1 = (void *)swift_slowAlloc();
  *long long v1 = 0;
  *(void *)(v0 + 128) = "SceneComponentStorage";
  *(void *)(v0 + 136) = 21;
  *(unsigned char *)(v0 + 144) = 2;
  *(void *)(v0 + 152) = v1;
  uint64_t v2 = swift_slowAlloc();
  *(void *)(v0 + 16) = v2;
  *(void *)(v0 + 24) = v2 + 4096;
  uint64_t v3 = 0;
  *(void *)(v0 + 32) = swift_slowAlloc();
  *(void *)(v0 + 40) = 64;
  do
  {
    uint64_t v4 = *(void *)(v0 + 32) + v3;
    uint64_t v5 = (_DWORD *)swift_slowAlloc();
    *uint64_t v5 = 0;
    *(void *)uint64_t v4 = "SceneComponent lock";
    *(void *)(v4 + 8) = 19;
    *(unsigned char *)(v4 + 16) = 2;
    v3 += 32;
    *(void *)(v4 + 24) = v5;
  }
  while (v3 != 2048);
  sub_1B62CEB80(MEMORY[0x1E4FBC860], 0, 256, 0, (uint64_t)&v10);
  uint64_t v6 = v11;
  uint64_t v7 = v14;
  char v8 = v15;
  *(_OWORD *)(v0 + 48) = v10;
  *(void *)(v0 + 64) = v6;
  *(_OWORD *)(v0 + 72) = v12;
  *(_OWORD *)(v0 + 88) = v13;
  *(void *)(v0 + 104) = v7;
  *(unsigned char *)(v0 + 112) = v8;
  *(void *)(v0 + 120) = 0;
  return v0;
}

uint64_t type metadata accessor for PreUpdateCameraSystem()
{
  return self;
}

const char *sub_1B63B044C()
{
  return "PreUpdateCamera";
}

uint64_t sub_1B63B0460()
{
  return qword_1E9DD2FC0 - 2;
}

const char *sub_1B63B0470()
{
  return "PreRenderCamera";
}

uint64_t sub_1B63B0484()
{
  return qword_1E9DD2FF0 - 2;
}

double sub_1B63B0494@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  sub_1B63B04DC(a1, v6);
  if (!v2)
  {
    double result = *(double *)v6;
    long long v5 = v6[1];
    *(_OWORD *)a2 = v6[0];
    *(_OWORD *)(a2 + 16) = v5;
    *(_DWORD *)(a2 + 32) = v7;
  }
  return result;
}

uint64_t sub_1B63B04DC@<X0>(void *a1@<X0>, unsigned char *a2@<X8>)
{
  os_signpost_id_t v25 = a2;
  sub_1B6395A90(0, &qword_1EB980A20, (uint64_t (*)(void))sub_1B63B09BC, (uint64_t)&type metadata for ParticleColorOverLife.CodingKeys, MEMORY[0x1E4FBBDC0]);
  uint64_t v26 = *(void *)(v4 - 8);
  uint64_t v27 = v4;
  MEMORY[0x1F4188790](v4, v5);
  int v7 = (char *)&v24 - v6;
  sub_1B62D2A54(0, (unint64_t *)&unk_1EB980D90, (uint64_t (*)(uint64_t))sub_1B6395D64, MEMORY[0x1E4FBBE00]);
  uint64_t v8 = swift_allocObject();
  *(_OWORD *)(v8 + 16) = xmmword_1B6E76900;
  simd_float4 v28 = (simd_float4)xmmword_1B6E72D40;
  simd_float4 v9 = _simd_pow_f4((simd_float4)xmmword_1B6E976C0, (simd_float4)xmmword_1B6E72D40);
  v9.i32[3] = 0;
  *(simd_float4 *)(v8 + 32) = v9;
  *(_DWORD *)(v8 + 48) = 0;
  simd_float4 v10 = _simd_pow_f4((simd_float4)xmmword_1B6E976D0, v28);
  v10.i32[3] = 1.0;
  *(simd_float4 *)(v8 + 64) = v10;
  *(_DWORD *)(v8 + 80) = 1048576000;
  simd_float4 v11 = _simd_pow_f4((simd_float4)xmmword_1B6E976E0, v28);
  v11.i32[3] = 1.0;
  *(simd_float4 *)(v8 + 96) = v11;
  *(_DWORD *)(v8 + 112) = 1056964608;
  simd_float4 v12 = _simd_pow_f4((simd_float4)xmmword_1B6E976F0, v28);
  v12.i32[3] = 1.0;
  *(simd_float4 *)(v8 + 128) = v12;
  *(_DWORD *)(v8 + 144) = 1061158912;
  simd_float4 v13 = _simd_pow_f4((simd_float4)xmmword_1B6E97700, v28);
  v13.i32[3] = 0;
  *(simd_float4 *)(v8 + 160) = v13;
  *(_DWORD *)(v8 + 176) = 1065353216;
  uint64_t v14 = sub_1B6397618(v8);
  swift_setDeallocating();
  swift_deallocClassInstance();
  sub_1B639EA20(v14);
  swift_bridgeObjectRelease();
  sub_1B62C14BC(a1, a1[3]);
  sub_1B63B09BC();
  sub_1B6E33A48();
  if (v2)
  {
    _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)a1);
    swift_bridgeObjectRelease();
    return swift_bridgeObjectRelease();
  }
  else
  {
    uint64_t v15 = v26;
    char v32 = 0;
    sub_1B63BD348();
    sub_1B6E32DF8();
    __int32 v16 = v29;
    int v17 = HIDWORD(v29);
    char v32 = 1;
    sub_1B639D880();
    sub_1B6E32DF8();
    v28.i32[0] = v16;
    uint64_t v19 = v29;
    uint64_t v18 = v30;
    HIDWORD(v24) = v31;
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    LOBYTE(v29) = 2;
    char v20 = sub_1B6E32DA8();
    (*(void (**)(char *, uint64_t))(v15 + 8))(v7, v27);
    _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)a1);
    swift_bridgeObjectRelease();
    uint64_t result = swift_bridgeObjectRelease();
    uint64_t v22 = v18;
    unint64_t v23 = v25;
    *os_signpost_id_t v25 = v28.i8[0];
    *((_DWORD *)v23 + 1) = v17;
    *((void *)v23 + 1) = v19;
    *((void *)v23 + 2) = v22;
    v23[24] = BYTE4(v24);
    v23[25] = v20 & 1;
    *(void *)(v23 + 28) = 0xFFFFFFFFLL;
  }
  return result;
}

unint64_t sub_1B63B0914()
{
  unint64_t result = qword_1EB97F6A8;
  if (!qword_1EB97F6A8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F6A8);
  }
  return result;
}

unint64_t sub_1B63B0968()
{
  unint64_t result = qword_1EB97F6A0;
  if (!qword_1EB97F6A0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F6A0);
  }
  return result;
}

unint64_t sub_1B63B09BC()
{
  unint64_t result = qword_1EB97F698;
  if (!qword_1EB97F698)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F698);
  }
  return result;
}

double sub_1B63B0A10@<D0>(uint64_t a1@<X8>)
{
  *(void *)a1 = aligned_alloc(8uLL, 8uLL);
  *(void *)&double result = 1;
  *(_OWORD *)(a1 + 8) = xmmword_1B6E50D30;
  return result;
}

uint64_t destroy for FrameConstantsStorage(void *a1)
{
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  swift_unknownObjectRelease();
  if (a1[176])
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }
  if (a1[182])
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }
  if (a1[196])
  {
    swift_bridgeObjectRelease();
    swift_unknownObjectRelease();
    swift_unknownObjectRelease();
  }

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for FrameConstantsStorage(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  memcpy((void *)(a1 + 48), (const void *)(a2 + 48), 0x480uLL);
  *(void *)(a1 + 1200) = *(void *)(a2 + 1200);
  *(void *)(a1 + 1208) = *(void *)(a2 + 1208);
  *(void *)(a1 + 1216) = *(void *)(a2 + 1216);
  *(void *)(a1 + 1224) = *(void *)(a2 + 1224);
  *(void *)(a1 + 1232) = *(void *)(a2 + 1232);
  *(void *)(a1 + 1240) = *(void *)(a2 + 1240);
  *(void *)(a1 + 1248) = *(void *)(a2 + 1248);
  *(void *)(a1 + 1256) = *(void *)(a2 + 1256);
  *(void *)(a1 + 1264) = *(void *)(a2 + 1264);
  *(void *)(a1 + 1272) = *(void *)(a2 + 1272);
  *(_OWORD *)(a1 + 1280) = *(_OWORD *)(a2 + 1280);
  *(void *)(a1 + 1296) = *(void *)(a2 + 1296);
  *(void *)(a1 + 1304) = *(void *)(a2 + 1304);
  *(void *)(a1 + 1312) = *(void *)(a2 + 1312);
  *(unsigned char *)(a1 + 1320) = *(unsigned char *)(a2 + 1320);
  *(_DWORD *)(a1 + 1324) = *(_DWORD *)(a2 + 1324);
  uint64_t v14 = *(void *)(a2 + 1408);
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  if (v14)
  {
    *(void *)(a1 + 1328) = *(void *)(a2 + 1328);
    *(void *)(a1 + 1336) = *(void *)(a2 + 1336);
    *(void *)(a1 + 1344) = *(void *)(a2 + 1344);
    *(_OWORD *)(a1 + 1360) = *(_OWORD *)(a2 + 1360);
    *(_OWORD *)(a1 + 1376) = *(_OWORD *)(a2 + 1376);
    *(_OWORD *)(a1 + 1392) = *(_OWORD *)(a2 + 1392);
    *(void *)(a1 + 1408) = v14;
    *(void *)(a1 + 1416) = *(void *)(a2 + 1416);
    *(unsigned char *)(a1 + 1424) = *(unsigned char *)(a2 + 1424);
    *(_DWORD *)(a1 + 1428) = *(_DWORD *)(a2 + 1428);
    swift_unknownObjectRetain();
    swift_bridgeObjectRetain();
    swift_unknownObjectRetain();
    uint64_t v4 = *(void *)(a2 + 1456);
    if (v4) {
      goto LABEL_3;
    }
LABEL_6:
    long long v9 = *(_OWORD *)(a2 + 1448);
    *(_OWORD *)(a1 + 1432) = *(_OWORD *)(a2 + 1432);
    *(_OWORD *)(a1 + 1448) = v9;
    *(_OWORD *)(a1 + 1464) = *(_OWORD *)(a2 + 1464);
    uint64_t v5 = *(void *)(a2 + 1568);
    if (v5) {
      goto LABEL_4;
    }
LABEL_7:
    long long v10 = *(_OWORD *)(a2 + 1568);
    *(_OWORD *)(a1 + 1552) = *(_OWORD *)(a2 + 1552);
    *(_OWORD *)(a1 + 1568) = v10;
    *(void *)(a1 + 1584) = *(void *)(a2 + 1584);
    long long v11 = *(_OWORD *)(a2 + 1504);
    *(_OWORD *)(a1 + 1488) = *(_OWORD *)(a2 + 1488);
    *(_OWORD *)(a1 + 1504) = v11;
    long long v12 = *(_OWORD *)(a2 + 1536);
    *(_OWORD *)(a1 + 1520) = *(_OWORD *)(a2 + 1520);
    *(_OWORD *)(a1 + 1536) = v12;
    goto LABEL_8;
  }
  long long v6 = *(_OWORD *)(a2 + 1408);
  *(_OWORD *)(a1 + 1392) = *(_OWORD *)(a2 + 1392);
  *(_OWORD *)(a1 + 1408) = v6;
  *(void *)(a1 + 1424) = *(void *)(a2 + 1424);
  long long v7 = *(_OWORD *)(a2 + 1344);
  *(_OWORD *)(a1 + 1328) = *(_OWORD *)(a2 + 1328);
  *(_OWORD *)(a1 + 1344) = v7;
  long long v8 = *(_OWORD *)(a2 + 1376);
  *(_OWORD *)(a1 + 1360) = *(_OWORD *)(a2 + 1360);
  *(_OWORD *)(a1 + 1376) = v8;
  uint64_t v4 = *(void *)(a2 + 1456);
  if (!v4) {
    goto LABEL_6;
  }
LABEL_3:
  *(void *)(a1 + 1432) = *(void *)(a2 + 1432);
  *(_OWORD *)(a1 + 1440) = *(_OWORD *)(a2 + 1440);
  *(void *)(a1 + 1456) = v4;
  *(void *)(a1 + 1464) = *(void *)(a2 + 1464);
  *(unsigned char *)(a1 + 1472) = *(unsigned char *)(a2 + 1472);
  *(_DWORD *)(a1 + 1476) = *(_DWORD *)(a2 + 1476);
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  uint64_t v5 = *(void *)(a2 + 1568);
  if (!v5) {
    goto LABEL_7;
  }
LABEL_4:
  *(void *)(a1 + 1488) = *(void *)(a2 + 1488);
  *(void *)(a1 + 1496) = *(void *)(a2 + 1496);
  *(void *)(a1 + 1504) = *(void *)(a2 + 1504);
  *(_OWORD *)(a1 + 1520) = *(_OWORD *)(a2 + 1520);
  *(_OWORD *)(a1 + 1536) = *(_OWORD *)(a2 + 1536);
  *(_OWORD *)(a1 + 1552) = *(_OWORD *)(a2 + 1552);
  *(void *)(a1 + 1568) = v5;
  *(void *)(a1 + 1576) = *(void *)(a2 + 1576);
  *(unsigned char *)(a1 + 1584) = *(unsigned char *)(a2 + 1584);
  *(_DWORD *)(a1 + 1588) = *(_DWORD *)(a2 + 1588);
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
LABEL_8:
  *(void *)(a1 + 1592) = *(void *)(a2 + 1592);
  *(void *)(a1 + 1600) = *(void *)(a2 + 1600);
  *(_WORD *)(a1 + 1608) = *(_WORD *)(a2 + 1608);
  *(unsigned char *)(a1 + 1610) = *(unsigned char *)(a2 + 1610);
  swift_bridgeObjectRetain();
  return a1;
}

double sub_1B63B0E34@<D0>(uint64_t a1@<X8>)
{
  uint64_t v2 = MEMORY[0x1E4FBC860];
  uint64_t v3 = sub_1B639A0A0(MEMORY[0x1E4FBC860]);
  *(_DWORD *)a1 = -1;
  *(void *)(a1 + 4) = 0;
  *(void *)(a1 + 9) = 0;
  bzero((void *)(a1 + 20), 0x364uLL);
  *(void *)(a1 + 1184) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(_OWORD *)(a1 + 1152) = 0u;
  *(_OWORD *)(a1 + 1136) = 0u;
  *(_OWORD *)(a1 + 1120) = 0u;
  *(_OWORD *)(a1 + 1104) = 0u;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(_OWORD *)(a1 + 1008) = 0u;
  *(_OWORD *)(a1 + 1024) = 0u;
  *(_OWORD *)(a1 + 976) = 0u;
  *(_OWORD *)(a1 + 992) = 0u;
  *(_OWORD *)(a1 + 944) = 0u;
  *(_OWORD *)(a1 + 960) = 0u;
  *(_OWORD *)(a1 + 912) = 0u;
  *(_OWORD *)(a1 + 928) = 0u;
  *(_OWORD *)(a1 + 896) = 0u;
  *(void *)(a1 + 1216) = 0;
  *(_OWORD *)(a1 + 1200) = 0u;
  *(void *)(a1 + 1224) = v3;
  *(void *)(a1 + 1232) = 0;
  *(void *)(a1 + 1240) = v2;
  *(_OWORD *)(a1 + 1248) = 0u;
  *(_OWORD *)(a1 + 1264) = 0u;
  *(_OWORD *)(a1 + 1280) = 0u;
  *(void *)(a1 + 1296) = 0;
  *(void *)(a1 + 1304) = v2;
  *(void *)(a1 + 1312) = 0;
  *(unsigned char *)(a1 + 1320) = 0;
  *(_OWORD *)(a1 + 1324) = 0u;
  *(_OWORD *)(a1 + 1340) = 0u;
  *(_OWORD *)(a1 + 1356) = 0u;
  *(_OWORD *)(a1 + 1372) = 0u;
  *(_OWORD *)(a1 + 1388) = 0u;
  *(_OWORD *)(a1 + 1404) = 0u;
  *(_OWORD *)(a1 + 1420) = 0u;
  *(_OWORD *)(a1 + 1436) = 0u;
  *(_OWORD *)(a1 + 1452) = 0u;
  *(_OWORD *)(a1 + 1464) = 0u;
  *(_OWORD *)(a1 + 1584) = 0u;
  *(_OWORD *)(a1 + 1568) = 0u;
  *(_OWORD *)(a1 + 1552) = 0u;
  *(_OWORD *)(a1 + 1536) = 0u;
  *(_OWORD *)(a1 + 1520) = 0u;
  *(_OWORD *)(a1 + 1504) = 0u;
  *(_OWORD *)(a1 + 1488) = 0u;
  *(void *)(a1 + 1600) = 1065353216;
  *(_DWORD *)(a1 + 1607) = 0;
  return result;
}

uint64_t type metadata accessor for EmitterPrepareRuntime()
{
  return self;
}

uint64_t sub_1B63B0F68(uint64_t a1, uint64_t a2)
{
  return sub_1B636B0FC(a1, a2, (void (*)(void))type metadata accessor for EmitterPrepareRuntime, 256, (void (*)(void))sub_1B62A02EC);
}

const char *sub_1B63B0F98()
{
  return "EmitterPrepareRuntime";
}

uint64_t type metadata accessor for DrawCallDisposeSystem()
{
  return self;
}

uint64_t sub_1B63B0FD4()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B62A0EB4(1, (uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 16) = v3[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v4;
  return v0;
}

const char *sub_1B63B109C()
{
  return "DrawCall Dispose";
}

void *sub_1B63B10B0()
{
  uint64_t v1 = *v0;
  uint64_t v2 = v0[1];
  uint64_t v3 = v0[2];
  double result = (void *)MEMORY[0x1E4FBC860];
  uint64_t v21 = (void *)MEMORY[0x1E4FBC860];
  uint64_t v5 = *(void *)(v3 + 16);
  if (v5)
  {
    uint64_t v6 = v3 + 32;
    swift_retain();
    do
    {
      sub_1B6B3D7AC(v1, v2);
      sub_1B62C1550((uint64_t)v20, (uint64_t)v17);
      char v7 = v21;
      if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
      {
        char v7 = sub_1B6397958(0, v7[2] + 1, 1, v7);
        uint64_t v21 = v7;
      }
      unint64_t v9 = v7[2];
      unint64_t v8 = v7[3];
      if (v9 >= v8 >> 1) {
        uint64_t v21 = sub_1B6397958(v8 > 1, v9 + 1, 1, v7);
      }
      uint64_t v10 = v18;
      uint64_t v11 = v19;
      uint64_t v12 = sub_1B62C550C((uint64_t)v17, v18);
      MEMORY[0x1F4188790](v12, v12);
      uint64_t v14 = &v17[-((v13 + 15) & 0xFFFFFFFFFFFFFFF0) - 8];
      (*(void (**)(unsigned char *))(v15 + 16))(v14);
      sub_1B62C5608(v9, (uint64_t)v14, (uint64_t *)&v21, v10, v11);
      _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v17);
      _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v20);
      v6 += 40;
      --v5;
    }
    while (v5);
    swift_release();
    return v21;
  }
  return result;
}

void sub_1B63B1288()
{
  if (!qword_1EB97F5B0[0])
  {
    uint64_t v0 = (uint64_t (*)(uint64_t, void, unint64_t))MEMORY[0x1E4FBC2F8];
    sub_1B63958F8(255, (unint64_t *)&qword_1EB980EF0, MEMORY[0x1E4FBC2F8]);
    sub_1B6666340((unint64_t *)&unk_1EB980EE0, (unint64_t *)&qword_1EB980EF0, v0);
    unint64_t v1 = type metadata accessor for BasicAnimationRuntime();
    if (!v2) {
      atomic_store(v1, qword_1EB97F5B0);
    }
  }
}

void sub_1B63B133C()
{
  if (!qword_1EB97F5A8)
  {
    uint64_t v0 = (uint64_t (*)(uint64_t, void, unint64_t))MEMORY[0x1E4FBC2A8];
    sub_1B63958F8(255, (unint64_t *)&qword_1EB980EB0, MEMORY[0x1E4FBC2A8]);
    sub_1B6666340(&qword_1EB980EA8, (unint64_t *)&qword_1EB980EB0, v0);
    unint64_t v1 = type metadata accessor for BasicAnimationRuntime();
    if (!v2) {
      atomic_store(v1, (unint64_t *)&qword_1EB97F5A8);
    }
  }
}

void sub_1B63B13F0()
{
  if (!qword_1EB97F5A0)
  {
    uint64_t v0 = (uint64_t (*)(uint64_t, void, unint64_t))MEMORY[0x1E4FBC280];
    sub_1B63958F8(255, &qword_1EB980E90, MEMORY[0x1E4FBC280]);
    sub_1B6666340((unint64_t *)&unk_1EB980E80, &qword_1EB980E90, v0);
    unint64_t v1 = type metadata accessor for BasicAnimationRuntime();
    if (!v2) {
      atomic_store(v1, (unint64_t *)&qword_1EB97F5A0);
    }
  }
}

const char *sub_1B63B14A8()
{
  return "WireframeLayer";
}

uint64_t sub_1B63B14BC(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t (*a4)(uint64_t))
{
  sub_1B63BDD28(0, a3, a4, (uint64_t (*)(uint64_t, uint64_t))type metadata accessor for VFXObjectScriptsDiff.Diff);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v6 - 8) + 16))(a2, a1, v6);
  return a2;
}

uint64_t sub_1B63B153C(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t (*a4)(uint64_t), uint64_t (*a5)(uint64_t, uint64_t))
{
  sub_1B63999E0(0, a3, a4, a5);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v7 - 8) + 16))(a2, a1, v7);
  return a2;
}

uint64_t type metadata accessor for TextureDiscardSystem()
{
  return self;
}

uint64_t sub_1B63B15D0()
{
  uint64_t v0 = swift_allocObject();
  sub_1B62968C0();
  return v0;
}

const char *sub_1B63B1608()
{
  return "TextureDiscard";
}

uint64_t sub_1B63B1620()
{
  uint64_t v1 = v0;
  uint64_t v2 = sub_1B6E31418();
  MEMORY[0x1F4188790](v2 - 8, v3);
  uint64_t v4 = sub_1B6E32228();
  uint64_t v5 = *(void *)(v4 - 8);
  MEMORY[0x1F4188790](v4, v6);
  unint64_t v8 = &v17[-((v7 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v9 = sub_1B6E321F8();
  MEMORY[0x1F4188790](v9 - 8, v10);
  sub_1B6299DFC();
  *(void *)(v0 + 16) = 0;
  *(void *)(v0 + 24) = 0;
  sub_1B6E321E8();
  (*(void (**)(unsigned char *, void, uint64_t))(v5 + 104))(v8, *MEMORY[0x1E4FBCC68], v4);
  sub_1B6E313F8();
  *(void *)(v0 + 32) = sub_1B6E32258();
  *(void *)(v0 + 40) = objc_msgSend(objc_allocWithZone(MEMORY[0x1E4F28F08]), sel_init);
  uint64_t v11 = (_DWORD *)swift_slowAlloc();
  *uint64_t v11 = 0;
  *(void *)(v0 + 48) = "CompilationResult";
  *(void *)(v0 + 56) = 17;
  *(unsigned char *)(v0 + 64) = 2;
  *(void *)(v0 + 72) = v11;
  uint64_t v12 = MEMORY[0x1E4FBC860];
  *(void *)(v1 + 80) = sub_1B639A530(MEMORY[0x1E4FBC860]);
  *(void *)(v1 + 88) = sub_1B639A414(v12);
  sub_1B62A57B4((uint64_t)v17);
  memcpy((void *)(v1 + 96), v17, 0x148uLL);
  sub_1B62A4374((uint64_t)v18);
  memcpy((void *)(v1 + 424), v18, 0x148uLL);
  sub_1B6375BA4((uint64_t)v19);
  memcpy((void *)(v1 + 752), v19, 0x148uLL);
  sub_1B62A3298((uint64_t)v20);
  memcpy((void *)(v1 + 1080), v20, 0x148uLL);
  sub_1B62A2858((uint64_t)v21);
  memcpy((void *)(v1 + 1408), v21, 0x148uLL);
  sub_1B62A4D94((uint64_t)v22);
  memcpy((void *)(v1 + 1736), v22, 0x148uLL);
  sub_1B62ABF1C((uint64_t)v23);
  memcpy((void *)(v1 + 2064), v23, 0x148uLL);
  sub_1B62AB4FC((uint64_t)v24);
  memcpy((void *)(v1 + 2392), v24, 0x148uLL);
  id v13 = objc_msgSend(self, sel_standardUserDefaults);
  uint64_t v14 = (void *)sub_1B6E31768();
  LOBYTE(v8) = objc_msgSend(v13, sel_BOOLForKey_, v14);

  *(unsigned char *)(v1 + 2720) = v8 ^ 1;
  uint64_t v15 = *(void **)(v1 + 40);
  objc_msgSend(v15, sel_setUnderlyingQueue_, *(void *)(v1 + 32));
  objc_msgSend(v15, sel_setMaxConcurrentOperationCount_, 10);
  return v1;
}

uint64_t sub_1B63B19C8()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63B1620();
  return v0;
}

const char *sub_1B63B1A00()
{
  return "ScriptCompilerSystem";
}

uint64_t sub_1B63B1A18(uint64_t a1)
{
  *(void *)(v1 + 16) = a1;
  if (*(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_renderer)) {
    uint64_t v2 = swift_unknownObjectRetain();
  }
  else {
    uint64_t v2 = 0;
  }
  *(void *)(v1 + 24) = v2;

  return swift_unknownObjectRelease();
}

uint64_t assignWithTake for GraphScriptingConfig(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  swift_bridgeObjectRelease();
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(unsigned char *)(a1 + 25) = *(unsigned char *)(a2 + 25);
  *(unsigned char *)(a1 + 26) = *(unsigned char *)(a2 + 26);
  return a1;
}

char *sub_1B63B1AC8@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  double result = sub_1B6298408(a1);
  if (!v2)
  {
    *(_WORD *)a2 = (_WORD)result;
    *(void *)(a2 + 8) = v5;
    *(void *)(a2 + 16) = v6;
    *(unsigned char *)(a2 + 24) = v7 & 1;
    *(unsigned char *)(a2 + 25) = BYTE1(v7) & 1;
    *(unsigned char *)(a2 + 26) = BYTE2(v7) & 1;
  }
  return result;
}

void *sub_1B63B1B18@<X0>(uint64_t a1@<X8>)
{
  uint64_t v2 = MEMORY[0x1E4FBC860];
  uint64_t v3 = sub_1B62BAA04(MEMORY[0x1E4FBC860]);
  double result = sub_1B6392F78(v2);
  *(_WORD *)a1 = 513;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = result;
  *(_WORD *)(a1 + 24) = 1;
  *(unsigned char *)(a1 + 26) = 1;
  return result;
}

uint64_t sub_1B63B1B74()
{
  return sub_1B6E31B98();
}

uint64_t sub_1B63B1BD4@<X0>(unsigned char *a1@<X8>)
{
  uint64_t result = sub_1B63B1CAC();
  *a1 = result;
  return result;
}

unint64_t sub_1B63B1C04()
{
  unint64_t result = qword_1EB97F390;
  if (!qword_1EB97F390)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F390);
  }
  return result;
}

unint64_t sub_1B63B1C58()
{
  unint64_t result = qword_1EB97F388;
  if (!qword_1EB97F388)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F388);
  }
  return result;
}

uint64_t sub_1B63B1CAC()
{
  unint64_t v0 = sub_1B6E32CC8();
  swift_bridgeObjectRelease();
  if (v0 >= 7) {
    return 7;
  }
  else {
    return v0;
  }
}

unint64_t sub_1B63B1CF8@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t result = sub_1B628F248(a1);
  if (!v2)
  {
    *(_DWORD *)a2 = result;
    *(unsigned char *)(a2 + 4) = BYTE4(result) & 1;
  }
  return result;
}

uint64_t sub_1B63B1D2C(uint64_t a1, uint64_t a2)
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v4 = a1 + *(int *)(a2 + 40);
  uint64_t v5 = sub_1B6E31118();
  uint64_t v6 = *(void *)(v5 - 8);
  if (!(*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v6 + 48))(v4, 1, v5)) {
    (*(void (**)(uint64_t, uint64_t))(v6 + 8))(v4, v5);
  }

  return swift_release();
}

uint64_t sub_1B63B1E14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_1B687A518);
}

uint64_t sub_1B63B1E28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, sub_1B687A468);
}

uint64_t sub_1B63B1E3C(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v5 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v5;
  uint64_t v6 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)(a1 + 24) = v6;
  uint64_t v7 = *(void *)(a2 + 32);
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  uint64_t v8 = a3[10];
  __dst = (void *)(a1 + v8);
  uint64_t v9 = (const void *)(a2 + v8);
  *(void *)(a1 + 32) = v7;
  uint64_t v10 = sub_1B6E31118();
  uint64_t v11 = *(void *)(v10 - 8);
  int v17 = *(unsigned int (**)(const void *, uint64_t, uint64_t))(v11 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  if (v17(v9, 1, v10))
  {
    sub_1B62B5820();
    memcpy(__dst, v9, *(void *)(*(void *)(v12 - 8) + 64));
  }
  else
  {
    (*(void (**)(void *, const void *, uint64_t))(v11 + 16))(__dst, v9, v10);
    (*(void (**)(void *, void, uint64_t, uint64_t))(v11 + 56))(__dst, 0, 1, v10);
  }
  uint64_t v13 = a3[12];
  *(void *)(a1 + a3[11]) = *(void *)(a2 + a3[11]);
  uint64_t v14 = a1 + v13;
  uint64_t v15 = a2 + v13;
  *(void *)uint64_t v14 = *(void *)v15;
  *(unsigned char *)(v14 + 8) = *(unsigned char *)(v15 + 8);
  swift_retain();
  return a1;
}

void sub_1B63B1FDC(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B63B2040(uint64_t a1)
{
}

uint64_t sub_1B63B2074@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B62924F4(a1, a2);
}

uint64_t type metadata accessor for GraphScriptingConfig.ScriptInfo()
{
  uint64_t result = qword_1EB97F340;
  if (!qword_1EB97F340) {
    return swift_getSingletonMetadata();
  }
  return result;
}

unint64_t sub_1B63B20D8()
{
  unint64_t result = qword_1EB97F318;
  if (!qword_1EB97F318)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F318);
  }
  return result;
}

unint64_t sub_1B63B212C()
{
  unint64_t result = qword_1EB97F300;
  if (!qword_1EB97F300)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97F300);
  }
  return result;
}

uint64_t type metadata accessor for EmitterCullingSystem()
{
  return self;
}

uint64_t sub_1B63B21A4()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B639FDC8(1, 2, 1, (uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 16) = v3[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v4;
  return v0;
}

const char *sub_1B63B2274()
{
  return "EmitterCullingSystem";
}

uint64_t type metadata accessor for BasicAnimationSystem()
{
  return self;
}

const char *sub_1B63B22AC()
{
  return "BasicAnimations";
}

uint64_t type metadata accessor for AudioPlayerComponent(uint64_t a1)
{
  return sub_1B633A29C(a1, qword_1EB97F228);
}

uint64_t type metadata accessor for TransientPushSystem()
{
  return self;
}

uint64_t sub_1B63B2308()
{
  uint64_t v0 = swift_allocObject();
  sub_1B62ACA14();
  return v0;
}

const char *sub_1B63B2340()
{
  return "TransientPush";
}

uint64_t type metadata accessor for StaticToFixedSystem()
{
  return self;
}

uint64_t sub_1B63B2378()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  type metadata accessor for StaticToFixedSystem();
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v7 = qword_1EB997A18;
  int v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  char v11 = 2;
  uint64_t v12 = 0;
  swift_retain();
  sub_1B63A3AB0((uint64_t)v4);
  swift_release();
  sub_1B62F7B88(0, (unint64_t *)&qword_1EB980C70, (unint64_t *)&qword_1EB980000, (unint64_t *)&qword_1EB97FFF0);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for Fixed;
  *(void *)(inited + 40) = &off_1F0F9F050;
  sub_1B62AD184(v5);
  swift_setDeallocating();
  sub_1B62CA064((uint64_t)v4);
  long long v2 = v5[1];
  *(_OWORD *)(v0 + 16) = v5[0];
  *(_OWORD *)(v0 + 32) = v2;
  *(void *)(v0 + 48) = v6;
  return v0;
}

const char *sub_1B63B24E0()
{
  return "StaticToFixed";
}

uint64_t sub_1B63B24F8(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  uint64_t v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for SceneKitAssetSystem()
{
  return self;
}

uint64_t sub_1B63B25E8()
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v28 = qword_1EB997A18;
  int v29 = 0;
  char v30 = 2;
  uint64_t v31 = 0;
  char v32 = 2;
  uint64_t v33 = 0;
  swift_retain();
  sub_1B63A1E74(1, 2, (uint64_t)&v11);
  swift_release();
  int v1 = v12;
  char v2 = v13;
  uint64_t v3 = v15;
  uint64_t v4 = v14 | 4;
  *(void *)(v0 + 16) = v11;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  uint64_t v22 = qword_1EB997A18;
  int v23 = 0;
  char v24 = 2;
  uint64_t v25 = 0;
  char v26 = 2;
  uint64_t v27 = 0;
  swift_retain();
  sub_1B63A7EA8(1, (uint64_t)v16);
  swift_release();
  sub_1B638C154(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = type metadata accessor for SceneKitRenderer(0);
  *(void *)(inited + 40) = &off_1F0F6F400;
  sub_1B62AD184(&v17);
  swift_setDeallocating();
  sub_1B62CA064((uint64_t)v16);
  int v6 = v18;
  char v7 = v19;
  uint64_t v8 = v21;
  uint64_t v9 = v20 | 4;
  *(void *)(v0 + 56) = v17;
  *(_DWORD *)(v0 + 64) = v6;
  *(unsigned char *)(v0 + 68) = v7;
  *(void *)(v0 + 72) = v9;
  *(unsigned char *)(v0 + 80) = 2;
  *(void *)(v0 + 88) = v8;
  return v0;
}

uint64_t sub_1B63B27E8()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63B25E8();
  return v0;
}

const char *sub_1B63B2820()
{
  return "SceneKitAsset";
}

uint64_t type metadata accessor for ResourceUsageSystem()
{
  return self;
}

uint64_t sub_1B63B285C()
{
  uint64_t v0 = swift_allocObject();
  sub_1B629FD5C();
  return v0;
}

uint64_t type metadata accessor for PrivateCommandQueue()
{
  return self;
}

uint64_t sub_1B63B28BC(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_1B63B291C(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  sub_1B6CA5F14(0, a2, a3);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v4 - 8) + 8))(a1, v4);
  return a1;
}

uint64_t sub_1B63B2978(uint64_t a1, uint64_t a2)
{
  sub_1B63B29DC();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 16))(a2, a1, v4);
  return a2;
}

void sub_1B63B29DC()
{
  if (!qword_1EB97F200)
  {
    sub_1B6786014();
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v1) {
      atomic_store(TupleTypeMetadata2, (unint64_t *)&qword_1EB97F200);
    }
  }
}

__n128 sub_1B63B2A48(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = a3;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *(void *)(*(void *)a1 + 16);
  if (v10)
  {
    char v36 = a4;
    uint64_t v37 = a6;
    uint64_t v11 = *(void *)a1 + 32;
    swift_bridgeObjectRetain();
    uint64_t v12 = 0;
    while (2)
    {
      sub_1B639192C(v11, (uint64_t)v44);
      sub_1B639192C(a2, (uint64_t)v46);
      switch(BYTE8(v45))
      {
        case 1:
          sub_1B639192C((uint64_t)v44, (uint64_t)v43);
          if (v48 != 1) {
            goto LABEL_4;
          }
          goto LABEL_10;
        case 2:
          sub_1B639192C((uint64_t)v44, (uint64_t)v43);
          if (v48 == 2) {
            goto LABEL_15;
          }
          goto LABEL_3;
        case 3:
          sub_1B639192C((uint64_t)v44, (uint64_t)v43);
          if (v48 == 3)
          {
LABEL_15:
            sub_1B62C15C4(v43, (uint64_t)v40);
            sub_1B62C15C4((long long *)v46, (uint64_t)v39);
            uint64_t v15 = v41;
            uint64_t v16 = v42;
            sub_1B62C14BC(v40, v41);
            LOBYTE(v15) = sub_1B6B3D86C(v39, v15, v16);
            _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v39);
            _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v40);
            sub_1B6391400((uint64_t)v44);
            if (v15)
            {
LABEL_23:
              swift_bridgeObjectRelease();
              uint64_t v21 = sub_1B6B1B930();
              uint64_t v22 = *(void *)(v20 + 48);
              if (v22)
              {
                uint64_t v23 = *(void *)(v20 + 64);
                *(void *)(v22 + 8 * v23) = a3;
                *(void *)(v20 + 64) = v23 + 1;
              }
              ((void (*)(_OWORD *, void))v21)(v44, 0);
              return result;
            }
          }
          else
          {
LABEL_3:
            _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0((uint64_t)v43);
LABEL_4:
            sub_1B63B28BC((uint64_t)v44, (uint64_t (*)(void))sub_1B691F560);
          }
LABEL_5:
          ++v12;
          v11 += 72;
          if (v10 != v12) {
            continue;
          }
          swift_bridgeObjectRelease();
          a6 = v37;
          uint64_t v7 = a3;
          a4 = v36;
          break;
        case 4:
          sub_1B639192C((uint64_t)v44, (uint64_t)v43);
          if (v48 != 4) {
            goto LABEL_4;
          }
          int v17 = LOBYTE(v43[0]);
          int v18 = v46[0];
          sub_1B6391400((uint64_t)v44);
          if (v17 == v18) {
            goto LABEL_23;
          }
          goto LABEL_5;
        case 5:
          if (v48 != 5) {
            goto LABEL_4;
          }
          int8x16_t v19 = vorrq_s8(*(int8x16_t *)&v46[8], v47);
          if (*(void *)&vorr_s8(*(int8x8_t *)v19.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v19, v19, 8uLL)) | *(void *)v46) {
            goto LABEL_4;
          }
          sub_1B6391400((uint64_t)v44);
          goto LABEL_23;
        default:
          sub_1B639192C((uint64_t)v44, (uint64_t)v43);
          if (v48) {
            goto LABEL_4;
          }
LABEL_10:
          uint64_t v13 = *(void *)&v43[0];
          uint64_t v14 = *(void *)v46;
          sub_1B6391400((uint64_t)v44);
          if (v13 == v14) {
            goto LABEL_23;
          }
          goto LABEL_5;
      }
      break;
    }
  }
  uint64_t v25 = *(void *)(a5 + 232);
  uint64_t v26 = *(void *)(a5 + 240);
  uint64_t v27 = v26 - v25;
  uint64_t v28 = 8 * (v26 - v25);
  if (a4)
  {
    swift_retain();
    int v29 = (void *)sub_1B62FC4C8(v28, 8);
    swift_release();
  }
  else
  {
    int v29 = ecs_stack_allocator_allocate(*(void *)(a6 + 32), 8 * (v26 - v25), 8);
  }
  *int v29 = v7;
  sub_1B639192C(a2, (uint64_t)v44);
  *(void *)uint64_t v46 = v29;
  *(void *)&v46[8] = v27;
  *(void *)&v46[16] = 1;
  char v30 = *(void **)a1;
  if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
    char v30 = sub_1B68C0C6C(0, v30[2] + 1, 1, v30);
  }
  unint64_t v32 = v30[2];
  unint64_t v31 = v30[3];
  if (v32 >= v31 >> 1) {
    char v30 = sub_1B68C0C6C(v31 > 1, v32 + 1, 1, v30);
  }
  _OWORD v30[2] = v32 + 1;
  uint64_t v33 = &v30[9 * v32];
  *((_OWORD *)v33 + 2) = v44[0];
  __n128 result = (__n128)v44[1];
  long long v34 = v45;
  long long v35 = *(_OWORD *)v46;
  v33[12] = *(void *)&v46[16];
  *((_OWORD *)v33 + 4) = v34;
  *((_OWORD *)v33 + 5) = v35;
  *((__n128 *)v33 + 3) = result;
  *(void *)a1 = v30;
  return result;
}

uint64_t type metadata accessor for PrepareUpdateSystem()
{
  return self;
}

const char *sub_1B63B2E40()
{
  return "PrepareUpdate";
}

uint64_t type metadata accessor for PrepareRenderSystem()
{
  return self;
}

uint64_t sub_1B63B2E78()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v14 = qword_1EB997A18;
  int v15 = 0;
  char v16 = 2;
  uint64_t v17 = 0;
  char v18 = 2;
  uint64_t v19 = 0;
  swift_retain();
  sub_1B63A0008(1, 1, 1, (uint64_t)v4);
  swift_release();
  long long v1 = v4[1];
  *(_OWORD *)(v0 + 16) = v4[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v5;
  uint64_t v8 = qword_1EB997A18;
  int v9 = 0;
  char v10 = 2;
  uint64_t v11 = 0;
  char v12 = 2;
  uint64_t v13 = 0;
  swift_retain();
  sub_1B63A27C8(1, 1, (uint64_t)v6);
  swift_release();
  long long v2 = v6[1];
  *(_OWORD *)(v0 + 56) = v6[0];
  *(_OWORD *)(v0 + 72) = v2;
  *(void *)(v0 + 88) = v7;
  return v0;
}

const char *sub_1B63B2FA8()
{
  return "PrepareRender";
}

uint64_t sub_1B63B2FBC(uint64_t a1)
{
  long long v1 = *(void **)(a1 + 176);
  swift_retain();
  sub_1B636E270((uint64_t)&type metadata for FrameConstantsStorage, (uint64_t)&off_1F0F851A8, v1);

  return swift_release();
}

uint64_t type metadata accessor for PrepareLightsSystem()
{
  return self;
}

uint64_t sub_1B63B3048()
{
  uint64_t v0 = swift_allocObject();
  sub_1B6296FC0();
  return v0;
}

const char *sub_1B63B3080()
{
  return "PrepareLights";
}

uint64_t sub_1B63B3094(uint64_t a1)
{
  long long v1 = *(void **)(a1 + 176);
  swift_retain();
  sub_1B636E270((uint64_t)&type metadata for LightsUniforms, (uint64_t)&off_1F0F643E8, v1);

  return swift_release();
}

uint64_t sub_1B63B30FC()
{
  uint64_t result = swift_allocObject();
  *(void *)(result + 16) = "ParticleGPUDownload";
  *(void *)(result + 24) = 19;
  *(unsigned char *)(result + 32) = 2;
  *(void *)(result + 40) = 0;
  *(void *)(result + 48) = 0;
  return result;
}

uint64_t type metadata accessor for MeshReferenceSystem()
{
  return self;
}

uint64_t sub_1B63B3160(uint64_t a1, uint64_t a2)
{
  return sub_1B636B278(a1, a2, (void (*)(uint64_t *__return_ptr, uint64_t))sub_1B63A9454);
}

const char *sub_1B63B3178()
{
  return "MeshReference";
}

uint64_t sub_1B63B3190(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  int v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t sub_1B63B325C(uint64_t *a1, uint64_t a2, uint64_t a3, signed int a4)
{
  if (a1 && *(void *)(v4 + 240) - *(void *)(v4 + 232) > a3) {
    return sub_1B6BF2AEC(a1, a2, a3, a4, *(unsigned __int8 *)(v4 + 120), *(unsigned int *)(v4 + 28) | ((unint64_t)*(unsigned __int8 *)(v4 + 32) << 32), 0, 0);
  }
  if (!sub_1B63B4340(a4)) {
    return sub_1B628EEF4(*(void *)(v4 + 232), *(void *)(v4 + 240), a4, *(unsigned char *)(v4 + 120), *(unsigned int *)(v4 + 28) | ((unint64_t)*(unsigned __int8 *)(v4 + 32) << 32));
  }

  return sub_1B66603E4(a4);
}

void sub_1B63B3344(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v6 = a3;
  uint64_t v7 = a2;
  if (*(unsigned char *)(a1 + 210) != 1)
  {
    if (a2 != a3)
    {
      do
      {
        uint64_t v43 = v7;
        if (a4)
        {
          sub_1B63B3AAC(v7, *(void *)(a5 + 232));
          uint64_t v35 = v43;
        }
        else
        {
          sub_1B63B3AAC(v7, *(void *)(a5 + 256));
          uint64_t v35 = v43;
          ++*(void *)(a5 + 256);
        }
        uint64_t v36 = *(void *)(a5 + 232);
        if (*(void *)(a5 + 240) == v36) {
          uint64_t v37 = *(void *)(a5 + 240);
        }
        else {
          uint64_t v37 = v36 + 1;
        }
        uint64_t v38 = *(void *)(a5 + 248);
        if (v37 <= v38) {
          uint64_t v39 = *(void *)(a5 + 248);
        }
        else {
          uint64_t v39 = v37;
        }
        BOOL v40 = v35 < v38;
        uint64_t v41 = v35 + 1;
        *(void *)(a5 + 232) = v37;
        if (v40) {
          uint64_t v42 = v39;
        }
        else {
          uint64_t v42 = v38 + 1;
        }
        *(void *)(a5 + 248) = v42;
        uint64_t v7 = v41;
      }
      while (v6 != v41);
    }
    return;
  }
  uint64_t v8 = *(void *)(a5 + 56);
  uint64_t v93 = *(void *)(v8 + 16);
  if (v93)
  {
    uint64_t v9 = 256;
    if (a4) {
      uint64_t v9 = 232;
    }
    uint64_t v85 = v9;
    uint64_t v89 = *(void *)(a5 + 16);
    uint64_t v91 = v8 + 32;
    uint64_t v10 = a2 + 1;
    uint64_t v11 = a2 + 2;
    uint64_t v12 = a2 + 3;
    uint64_t v87 = a3 + 1;
    swift_retain();
    uint64_t v13 = a2;
    uint64_t v14 = 0;
    uint64_t v81 = v11;
    uint64_t v83 = v10;
    if (v10 >= v6) {
      uint64_t v15 = a2 + 1;
    }
    else {
      uint64_t v15 = v11;
    }
    if (v12 <= v6) {
      uint64_t v16 = v6;
    }
    else {
      uint64_t v16 = v12;
    }
    uint64_t v77 = v16;
    uint64_t v79 = v15;
    while (1)
    {
      uint64_t v17 = (uint64_t *)(v91 + 40 * v14);
      uint64_t v18 = *v17;
      uint64_t v96 = v14;
      uint64_t v19 = 0;
      if (v6 != v13) {
        break;
      }
LABEL_14:
      Swift::UInt32 v20 = *(_DWORD *)(v89 + 80 + OBJC_IVAR____TtC3VFX13EntityManager_counters);
      uint64_t v21 = sub_1B62F238C(v18);
      if (*(void *)(v89 + OBJC_IVAR____TtC3VFX13EntityManager_counters)) {
        vfx_counters.add(_:_:)(v20, v21 * v19);
      }
      uint64_t v14 = v96 + 1;
      uint64_t v6 = a3;
      uint64_t v13 = a2;
      if (v96 + 1 == v93)
      {
        swift_release();
        uint64_t v7 = a2;
        goto LABEL_68;
      }
    }
    uint64_t v23 = v17[2];
    uint64_t v22 = v17[3];
    uint64_t v24 = *(void *)(a5 + v85);
    BOOL v25 = v24 != v13;
    if (v24 == v13) {
      uint64_t v26 = v79;
    }
    else {
      uint64_t v26 = v13;
    }
    if (v24 == v13) {
      uint64_t v24 = v79;
    }
    if (v83 >= v6) {
      BOOL v25 = 1;
    }
    if (v81 >= v6) {
      BOOL v25 = 1;
    }
    uint64_t v27 = v6;
    if (v25) {
      uint64_t v28 = v26;
    }
    else {
      uint64_t v28 = v77;
    }
    if (v25) {
      uint64_t v29 = v24;
    }
    else {
      uint64_t v29 = v77;
    }
    uint64_t v30 = *(void *)(a5 + 240);
    while (1)
    {
      if (--v27 >= *(void *)(a5 + 248))
      {
        if (v27 < --v30)
        {
          sub_1B6B3BDDC(*(void *)(a5 + 128) + v22, *(void *)(a5 + 128) + v22 + *(void *)(a5 + 88) * v23, v27, v30, v18);
          uint64_t v13 = a2;
          ++v19;
        }
      }
      else
      {
        if (v29 >= v27) {
          goto LABEL_14;
        }
        sub_1B6B3BDDC(*(void *)(a5 + 128) + v22, *(void *)(a5 + 128) + v22 + *(void *)(a5 + 88) * v23, v27, v29, v18);
        ++v19;
        if (v29 + 1 == v28)
        {
          uint64_t v31 = v29 + 2;
          uint64_t v32 = v28 + 1;
          if (v28 + 1 < a3)
          {
            uint64_t v13 = a2;
            if (v31 == v32 && (v31 = v29 + 3, uint64_t v32 = v28 + 2, v28 + 2 < a3) && v31 == v32)
            {
              uint64_t v33 = v29 + 4;
              uint64_t v34 = v28 + 3;
              if (v28 + 3 < a3)
              {
                uint64_t v29 = v87 + v29 - v28;
                uint64_t v28 = a3;
                while (v33 == v34)
                {
                  uint64_t v34 = ++v33;
                  if (a3 == v33) {
                    goto LABEL_33;
                  }
                }
              }
              uint64_t v29 = v33;
              uint64_t v28 = v34;
            }
            else
            {
              uint64_t v29 = v31;
              uint64_t v28 = v32;
            }
            goto LABEL_33;
          }
          v29 += 2;
          ++v28;
        }
        else
        {
          ++v29;
        }
        uint64_t v13 = a2;
      }
LABEL_33:
      if (v27 == v13) {
        goto LABEL_14;
      }
    }
  }
LABEL_68:
  uint64_t v44 = *(void *)(a5 + 64);
  uint64_t v94 = *(void *)(v44 + 16);
  if (!v94) {
    goto LABEL_119;
  }
  uint64_t v45 = 256;
  if (a4) {
    uint64_t v45 = 232;
  }
  uint64_t v86 = v45;
  uint64_t v90 = *(void *)(a5 + 16);
  uint64_t v92 = v44 + 32;
  uint64_t v46 = v7 + 1;
  uint64_t v47 = v7 + 2;
  uint64_t v48 = v7 + 3;
  uint64_t v88 = v6 + 1;
  swift_retain();
  uint64_t v49 = a2;
  uint64_t v50 = 0;
  uint64_t v82 = v47;
  uint64_t v84 = v46;
  if (v46 >= v6) {
    uint64_t v51 = a2 + 1;
  }
  else {
    uint64_t v51 = v47;
  }
  if (v48 <= v6) {
    uint64_t v52 = v6;
  }
  else {
    uint64_t v52 = v48;
  }
  uint64_t v78 = v52;
  uint64_t v80 = v51;
  do
  {
    BOOL v53 = (uint64_t *)(v92 + 40 * v50);
    uint64_t v54 = v53[2];
    uint64_t v97 = v50;
    uint64_t v55 = 0;
    if (v6 != v49)
    {
      uint64_t v56 = *v53;
      uint64_t v57 = *(void *)(a5 + 128) + v53[3];
      uint64_t v58 = *(void *)(a5 + v86);
      BOOL v59 = v58 != v49;
      if (v58 == v49) {
        uint64_t v60 = v80;
      }
      else {
        uint64_t v60 = v49;
      }
      if (v58 == v49) {
        uint64_t v58 = v80;
      }
      if (v84 >= v6) {
        BOOL v59 = 1;
      }
      if (v82 >= v6) {
        BOOL v59 = 1;
      }
      uint64_t v61 = v6;
      if (v59) {
        uint64_t v62 = v60;
      }
      else {
        uint64_t v62 = v78;
      }
      if (v59) {
        uint64_t v63 = v58;
      }
      else {
        uint64_t v63 = v78;
      }
      uint64_t v64 = *(void *)(a5 + 240);
      do
      {
        if (--v61 >= *(void *)(a5 + 248))
        {
          if (v61 < --v64)
          {
            sub_1B6B3BE20(v57 + v61 * v54, v57 + v64 * v54, v56);
            uint64_t v49 = a2;
            ++v55;
          }
        }
        else
        {
          if (v63 >= v61) {
            break;
          }
          sub_1B6B3BE20(v57 + v61 * v54, v57 + v63 * v54, v56);
          ++v55;
          if (v63 + 1 == v62)
          {
            uint64_t v65 = v63 + 2;
            uint64_t v66 = v62 + 1;
            if (v62 + 1 < a3)
            {
              uint64_t v49 = a2;
              if (v65 == v66 && (v65 = v63 + 3, uint64_t v66 = v62 + 2, v62 + 2 < a3) && v65 == v66)
              {
                uint64_t v67 = v63 + 4;
                uint64_t v68 = v62 + 3;
                if (v62 + 3 < a3)
                {
                  uint64_t v63 = v88 + v63 - v62;
                  uint64_t v62 = a3;
                  while (v67 == v68)
                  {
                    uint64_t v68 = ++v67;
                    if (a3 == v67) {
                      goto LABEL_99;
                    }
                  }
                }
                uint64_t v63 = v67;
                uint64_t v62 = v68;
              }
              else
              {
                uint64_t v63 = v65;
                uint64_t v62 = v66;
              }
              continue;
            }
            v63 += 2;
            ++v62;
          }
          else
          {
            ++v63;
          }
          uint64_t v49 = a2;
        }
LABEL_99:
        ;
      }
      while (v61 != v49);
    }
    if (*(void *)(v90 + OBJC_IVAR____TtC3VFX13EntityManager_counters))
    {
      vfx_counters.add(_:_:)(*(_DWORD *)(v90 + 80 + OBJC_IVAR____TtC3VFX13EntityManager_counters), v55 * v54);
      uint64_t v49 = a2;
    }
    uint64_t v50 = v97 + 1;
    uint64_t v6 = a3;
  }
  while (v97 + 1 != v94);
  swift_release();
  uint64_t v7 = a2;
LABEL_119:
  if ((*(unsigned char *)(a5 + 184) & 1) == 0)
  {
    uint64_t v69 = *(void *)(a5 + 168);
    uint64_t v70 = *(void *)(a5 + 16);
    os_signpost_id_t v71 = *(os_unfair_lock_s **)(v70 + OBJC_IVAR____TtC3VFX13EntityManager_lock + 24);
    swift_retain();
    os_unfair_lock_lock(v71);
    swift_release();
    swift_retain();
    sub_1B66618EC(a2, v6, a4 & 1, a5, a5, v69);
    swift_release();
    long long v72 = *(os_unfair_lock_s **)(v70 + OBJC_IVAR____TtC3VFX13EntityManager_lock + 24);
    swift_retain();
    os_unfair_lock_unlock(v72);
    swift_release();
    uint64_t v7 = a2;
  }
  if (v7 != v6)
  {
    __int16 v74 = *(char **)(a5 + 232);
    uint64_t v73 = *(char **)(a5 + 240);
    uint64_t v75 = *(void *)(a5 + 248);
    os_signpost_id_t v76 = v73;
    do
    {
      if (v7 >= v75)
      {
        os_signpost_id_t v76 = &v74[(unint64_t)&v76[~(unint64_t)v74] & ~((uint64_t)&v76[~(unint64_t)v74] >> 63)];
      }
      else
      {
        if ((a4 & 1) == 0) {
          ++*(void *)(a5 + 256);
        }
        if (v76 == v74) {
          __int16 v74 = v76;
        }
        else {
          ++v74;
        }
      }
      ++v7;
    }
    while (v6 != v7);
    *(void *)(a5 + 232) = v74;
    *(void *)(a5 + 240) = v76;
    if (v73 != v76) {
      sub_1B666018C(v76, v73);
    }
  }
}

uint64_t sub_1B63B3A38(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LOBYTE(v5) = *(unsigned char *)(v3 + 96);
  return sub_1B6391AB0(a1, a2, a3, *(unsigned int *)(v3 + 16) | ((unint64_t)*(unsigned __int8 *)(v3 + 20) << 32), *(void **)(v3 + 24), *(void *)(v3 + 32), *(void *)(v3 + 40), *(void *)(v3 + 48), *(void *)(v3 + 56), *(void *)(v3 + 64), *(uint64_t **)(v3 + 72), *(void *)(v3 + 80), *(void **)(v3 + 88), v5, *(_DWORD *)(v3 + 100), HIWORD(*(_DWORD *)(v3 + 100)), *(unsigned char *)(v3 + 104));
}

void sub_1B63B3AAC(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    uint64_t v3 = v2;
    uint64_t v5 = a1;
    uint64_t v6 = a1 + 1;
    sub_1B6D661A0(*(void *)(v2 + 128), a2, a1 + 1);
    uint64_t v7 = *(void *)(v2 + 16);
    if (*(void *)(v7 + OBJC_IVAR____TtC3VFX13EntityManager_counters)) {
      vfx_counters.add(_:_:)(*(_DWORD *)(v7 + OBJC_IVAR____TtC3VFX13EntityManager_counters + 64), *(void *)(v3 + 72) * (v6 - a2));
    }
    if ((*(unsigned char *)(v3 + 184) & 1) == 0)
    {
      uint64_t v22 = v6;
      uint64_t v8 = *(void *)(v3 + 168);
      uint64_t v9 = *(os_unfair_lock_s **)(v7 + OBJC_IVAR____TtC3VFX13EntityManager_lock + 24);
      swift_retain();
      os_unfair_lock_lock(v9);
      swift_release();
      uint64_t v21 = v3;
      int v10 = *(_DWORD *)(v3 + 188);
      uint64_t v11 = (int32x2_t *)(v8 + 4 * v5 - 4);
      do
      {
        int32x2_t v12 = *v11;
        *uint64_t v11 = vrev64_s32(*v11);
        uint64_t v13 = *(void *)(v7 + OBJC_IVAR____TtC3VFX13EntityManager__entries);
        __int32 v23 = v12.i32[0];
        int v14 = *(_DWORD *)(v13 + 12 * v12.i32[0]);
        swift_retain();
        if (v14 == v10) {
          *(_WORD *)(v13 + 12 * v23 + 4) = v5;
        }
        --v5;
        swift_release();
        __int32 v15 = v11->i32[0];
        uint64_t v16 = *(void *)(v7 + OBJC_IVAR____TtC3VFX13EntityManager__entries);
        int v17 = *(_DWORD *)(v16 + 12 * v11->i32[0]);
        swift_retain();
        if (v17 == v10) {
          *(_WORD *)(v16 + 12 * v15 + 4) = v5;
        }
        swift_release();
        uint64_t v11 = (int32x2_t *)((char *)v11 - 4);
      }
      while (a2 != v5);
      uint64_t v18 = *(os_unfair_lock_s **)(v7 + OBJC_IVAR____TtC3VFX13EntityManager_lock + 24);
      swift_retain();
      os_unfair_lock_unlock(v18);
      swift_release();
      uint64_t v3 = v21;
      uint64_t v6 = v22;
    }
    uint64_t v19 = *(void *)(v3 + 192);
    if (v19)
    {
      uint64_t v20 = *(void *)(v3 + 208);
      sub_1B6647000(a2, v6, v19);
      sub_1B6647000(a2, v6, v20);
    }
  }
}

uint64_t sub_1B63B3CE8(void *a1)
{
  uint64_t v2 = v1;
  uint64_t v3 = a1;
  if (*(unsigned char *)(v1 + 121))
  {
    uint64_t v4 = *(void *)(v1 + 88);
    uint64_t v5 = *(void *)(v1 + 240);
    uint64_t v6 = a1[1] - *a1;
    if (v4 - v5 < v6)
    {
      uint64_t v7 = *(void *)(v1 + 256);
      if (v6 >= v4 - v5 + v7)
      {
        uint64_t v11 = *(void *)(v1 + 128);
        if (v11) {
          size_t v57 = *(void *)(v1 + 136) - v11;
        }
        else {
          size_t v57 = 0;
        }
        char v12 = 0;
        uint64_t v52 = a1[1] - *a1;
        do
        {
          uint64_t v13 = *(void *)(*(void *)(*(void *)(v2 + 40) + 16) + 32);
          int64_t v14 = *(void *)(v13 + 16);
          if (v14)
          {
            uint64_t v66 = MEMORY[0x1E4FBC860];
            swift_retain();
            sub_1B637ED84(0, v14, 0);
            sub_1B637ED20(0, (unint64_t *)&qword_1EB97EB00, (unint64_t *)&qword_1EB97EAE0);
            sub_1B637ED20(0, (unint64_t *)&qword_1EB980000, (unint64_t *)&qword_1EB97FFF0);
            for (uint64_t i = 0; i != v14; ++i)
            {
              long long v60 = *(_OWORD *)(v13 + 16 * i + 32);
              swift_dynamicCast();
              long long v58 = v67;
              uint64_t v16 = v66;
              if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0)
              {
                sub_1B637ED84(0, *(void *)(v66 + 16) + 1, 1);
                uint64_t v16 = v66;
              }
              unint64_t v18 = *(void *)(v16 + 16);
              unint64_t v17 = *(void *)(v16 + 24);
              if (v18 >= v17 >> 1)
              {
                sub_1B637ED84(v17 > 1, v18 + 1, 1);
                uint64_t v16 = v66;
              }
              *(void *)(v16 + 16) = v18 + 1;
              *(_OWORD *)(v16 + 16 * v18 + 32) = v58;
            }
            swift_release();
            uint64_t v2 = v55;
          }
          else
          {
            uint64_t v16 = MEMORY[0x1E4FBC860];
          }
          v57 *= 2;
          sub_1B62CEB80(v16, v57, 0, (*(unsigned char *)(v2 + 184) & 1) == 0, (uint64_t)&v67);
          long long v19 = v67;
          uint64_t v20 = v68;
          *(_OWORD *)uint64_t v21 = v69;
          *(_OWORD *)&v21[16] = *(_OWORD *)v70;
          uint64_t v59 = *(void *)&v70[16];
          char v54 = v71;
          if (v12)
          {
            swift_release();
            swift_release();
            swift_release();
          }
          char v12 = 1;
        }
        while (*(void *)&v21[16] - *(void *)(v2 + 240) < v52);
        uint64_t v49 = *(void *)(v2 + 16);
        task_t v22 = *(_DWORD *)(v49 + OBJC_IVAR____TtC3VFX13EntityManager_peerTaskIdentity);
        swift_retain();
        swift_retain();
        swift_retain();
        vfx_allocate_memory_entry(v57, 0x40uLL, v22, (uint64_t)&v67);
        uint64_t v23 = v67;
        int v53 = v68;
        char v50 = BYTE4(v68);
        uint64_t v56 = *((void *)&v67 + 1);
        uint64_t v24 = v67 + *((void *)&v67 + 1);
        if (!(void)v67) {
          uint64_t v24 = 0;
        }
        uint64_t v48 = v24;
        uint64_t v25 = *(void *)(v2 + 48);
        uint64_t v26 = *(void *)(v55 + 56);
        uint64_t v27 = *(void *)(v55 + 64);
        uint64_t v28 = *(void *)(v55 + 104);
        char v29 = *(unsigned char *)(v55 + 112);
        *(void *)&long long v67 = v25;
        *((void *)&v67 + 1) = v26;
        uint64_t v68 = v27;
        long long v69 = *(_OWORD *)(v55 + 72);
        *(_OWORD *)uint64_t v70 = *(_OWORD *)(v55 + 88);
        *(void *)&v70[16] = v28;
        char v71 = v29;
        uint64_t v46 = *(void *)(v55 + 256);
        uint64_t v47 = *(void *)(v55 + 128);
        uint64_t v45 = *(void *)(v55 + 240);
        long long v60 = v19;
        *(void *)&long long v61 = v20;
        *((void *)&v61 + 1) = *(void *)v21;
        long long v62 = *(_OWORD *)&v21[8];
        uint64_t v63 = *(void *)&v21[24];
        uint64_t v64 = v59;
        char v65 = v54;
        swift_retain();
        swift_retain();
        swift_retain();
        sub_1B6D66060(v47, v46, v45, 0, v23, (uint64_t)&v60);
        swift_release();
        uint64_t v2 = v55;
        swift_release();
        swift_release();
        swift_release();
        swift_release();
        swift_release();
        if (*(void *)(v49 + OBJC_IVAR____TtC3VFX13EntityManager_counters)) {
          vfx_counters.add(_:_:)(*(_DWORD *)(v49 + OBJC_IVAR____TtC3VFX13EntityManager_counters + 64), (*(void *)(v55 + 240) - *(void *)(v55 + 256)) * *(void *)(v55 + 72));
        }
        vfx_deallocate_memory_entry(v55 + 144);
        *(void *)(v55 + 144) = v23;
        *(void *)(v55 + 152) = v56;
        *(_DWORD *)(v55 + 160) = v53;
        *(unsigned char *)(v55 + 164) = v50;
        *(void *)(v55 + 128) = v23;
        *(void *)(v55 + 136) = v48;
        *(_OWORD *)(v55 + 48) = v19;
        *(void *)(v55 + 64) = v20;
        *(void *)(v55 + 72) = *(void *)v21;
        *(void *)(v55 + 80) = *(void *)&v21[8];
        *(void *)(v55 + 88) = *(void *)&v21[16];
        *(void *)(v55 + 96) = *(void *)&v21[24];
        *(void *)(v55 + 104) = v59;
        *(unsigned char *)(v55 + 112) = v54;
        swift_release();
        swift_release();
        swift_release();
        uint64_t v3 = a1;
      }
      else
      {
        uint64_t v8 = *(void *)(v1 + 64);
        char v9 = *(unsigned char *)(v1 + 112);
        long long v67 = *(_OWORD *)(v1 + 48);
        uint64_t v68 = v8;
        long long v69 = *(_OWORD *)(v1 + 72);
        *(void *)uint64_t v70 = v4;
        *(_OWORD *)&v70[8] = *(_OWORD *)(v1 + 96);
        char v71 = v9;
        sub_1B6D65F50(*(void *)(v1 + 128), v7, v5, 0);
        uint64_t v10 = *(void *)(v1 + 16) + OBJC_IVAR____TtC3VFX13EntityManager_counters;
        if (*(void *)v10) {
          vfx_counters.add(_:_:)(*(_DWORD *)(v10 + 64), (*(void *)(v1 + 240) - *(void *)(v1 + 256)) * *(void *)(v1 + 72));
        }
      }
      unint64_t v30 = *(void *)(v2 + 256);
      *(void *)(v2 + 256) = 0;
      *(void *)(v2 + 232) -= v30;
      int64x2_t v31 = vsubq_s64(*(int64x2_t *)(v2 + 240), vdupq_n_s64(v30));
      *(int64x2_t *)(v2 + 240) = v31;
      uint64_t v5 = v31.i64[0];
    }
  }
  else
  {
    uint64_t v5 = *(void *)(v1 + 240);
  }
  uint64_t v32 = *(void *)(v2 + 88);
  uint64_t v33 = *v3;
  if (v3[1] - *v3 >= v32 - v5) {
    uint64_t v34 = v32 - v5;
  }
  else {
    uint64_t v34 = v3[1] - *v3;
  }
  if (*(unsigned char *)(v2 + 184))
  {
    uint64_t v35 = v5;
    v5 += v34;
  }
  else
  {
    uint64_t v36 = *(void *)(v2 + 168);
    long long v37 = *((_OWORD *)v3 + 2);
    long long v60 = *((_OWORD *)v3 + 1);
    long long v61 = v37;
    long long v62 = *((_OWORD *)v3 + 3);
    if (v34)
    {
      do
      {
        uint64_t v38 = sub_1B6392984(&v67);
        int v40 = v39;
        ((void (*)(long long *, void))v38)(&v67, 0);
        ++v33;
        *(_DWORD *)(v36 + 4 * v5++) = v40;
        --v34;
      }
      while (v34);
      uint64_t v2 = v55;
      uint64_t v35 = *(void *)(v55 + 240);
      uint64_t v32 = *(void *)(v55 + 88);
    }
    else
    {
      uint64_t v35 = v5;
      uint64_t v2 = v55;
    }
  }
  *(void *)(v2 + 240) = v5;
  uint64_t v41 = *(void *)(v2 + 64);
  char v42 = *(unsigned char *)(v2 + 112);
  long long v67 = *(_OWORD *)(v2 + 48);
  uint64_t v68 = v41;
  long long v69 = *(_OWORD *)(v2 + 72);
  *(void *)uint64_t v70 = v32;
  *(_OWORD *)&v70[8] = *(_OWORD *)(v2 + 96);
  char v71 = v42;
  sub_1B62FCEB0(*(void *)(v2 + 128), v35, v5);
  uint64_t v43 = *(void *)(v2 + 16) + OBJC_IVAR____TtC3VFX13EntityManager_counters;
  if (*(void *)v43) {
    vfx_counters.add(_:_:)(*(_DWORD *)(v43 + 72), *(void *)(v2 + 72) * (v5 - v35));
  }
  ++*(_DWORD *)(v2 + 116);
  return v35;
}

BOOL sub_1B63B4340(int a1)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(v1 + 16) + 80) + 8 * a1 + 32);
  uint64_t v3 = *(void **)(v1 + 40);
  uint64_t v4 = v2[4];
  uint64_t v5 = v2[8];
  uint64_t v6 = v3[4];
  uint64_t v7 = v3[8];
  swift_retain();
  BOOL v8 = v5 == v7 && sub_1B6D663B8(v2[5], v3[5]) && sub_1B6D663B8(v4, v6);
  swift_release();
  return v8;
}

uint64_t type metadata accessor for VideoCaptureSystem()
{
  return self;
}

uint64_t sub_1B63B43F8()
{
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v20 = qword_1EB997A18;
  int v21 = 0;
  char v22 = 2;
  uint64_t v23 = 0;
  char v24 = 2;
  uint64_t v25 = 0;
  swift_retain();
  sub_1B63AB764(1, (uint64_t)&v7);
  swift_release();
  int v1 = v8;
  char v2 = v9;
  uint64_t v3 = v11;
  uint64_t v4 = v10 | 4;
  *(void *)(v0 + 16) = v7;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  uint64_t v14 = qword_1EB997A18;
  int v15 = 0;
  char v16 = 2;
  uint64_t v17 = 0;
  char v18 = 2;
  uint64_t v19 = 0;
  swift_retain();
  sub_1B63A873C(1, (uint64_t)v12);
  swift_release();
  long long v5 = v12[1];
  *(_OWORD *)(v0 + 56) = v12[0];
  *(_OWORD *)(v0 + 72) = v5;
  *(void *)(v0 + 88) = v13;
  return v0;
}

uint64_t sub_1B63B452C()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63B43F8();
  return v0;
}

const char *sub_1B63B4564()
{
  return "VideoCapture";
}

uint64_t sub_1B63B457C()
{
  return qword_1E9DD3020;
}

uint64_t type metadata accessor for SmoothMotionSystem()
{
  return self;
}

uint64_t sub_1B63B45AC()
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v16 = qword_1EB997A18;
  int v17 = 0;
  char v18 = 2;
  uint64_t v19 = 0;
  char v20 = 2;
  uint64_t v21 = 0;
  swift_retain();
  sub_1B63A0248(2, 1, 1, (uint64_t)v5);
  swift_release();
  long long v1 = v5[1];
  *(_OWORD *)(v0 + 16) = v5[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v6;
  uint64_t v10 = qword_1EB997A18;
  int v11 = 0;
  char v12 = 2;
  uint64_t v13 = 0;
  char v14 = 2;
  uint64_t v15 = 0;
  swift_retain();
  sub_1B63AB96C(1, (uint64_t)v7);
  swift_release();
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for LastFrameWorldTransform;
  *(void *)(inited + 40) = &off_1F0F8F510;
  sub_1B62AD184(v8);
  swift_setDeallocating();
  sub_1B62CA064((uint64_t)v7);
  long long v3 = v8[1];
  *(_OWORD *)(v0 + 56) = v8[0];
  *(_OWORD *)(v0 + 72) = v3;
  *(void *)(v0 + 88) = v9;
  return v0;
}

uint64_t sub_1B63B4740()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63B45AC();
  return v0;
}

const char *sub_1B63B4778()
{
  return "SmoothMotionSystem";
}

uint64_t type metadata accessor for SceneAssetRegistry()
{
  return self;
}

uint64_t type metadata accessor for SDFGeneratorSystem()
{
  return self;
}

uint64_t sub_1B63B47D8()
{
  uint64_t v0 = swift_allocObject();
  sub_1B6297F80();
  return v0;
}

const char *sub_1B63B4810()
{
  return "SDFGenerator";
}

uint64_t type metadata accessor for RotateActionSystem()
{
  return self;
}

uint64_t sub_1B63B484C(uint64_t a1, uint64_t a2, void (*a3)(_OWORD *__return_ptr, uint64_t))
{
  uint64_t v4 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v10 = qword_1EB997A18;
  int v11 = 0;
  char v12 = 2;
  uint64_t v13 = 0;
  char v14 = 2;
  uint64_t v15 = 0;
  uint64_t v5 = swift_retain();
  a3(v8, v5);
  swift_release();
  long long v6 = v8[1];
  *(_OWORD *)(v4 + 16) = v8[0];
  *(_OWORD *)(v4 + 32) = v6;
  *(void *)(v4 + 48) = v9;
  return v4;
}

uint64_t sub_1B63B4918(uint64_t a1, uint64_t a2)
{
  return sub_1B63B484C(a1, a2, (void (*)(_OWORD *__return_ptr, uint64_t))sub_1B63A17AC);
}

const char *sub_1B63B4930()
{
  return "RotateActionSystem";
}

uint64_t sub_1B63B4948(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  long long v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t sub_1B63B4A14()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B629AD2C(1, 2, (uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 16) = v3[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v4;
  return v0;
}

const char *sub_1B63B4AE0()
{
  return "ParticleSort";
}

uint64_t type metadata accessor for LensBlurPassSystem()
{
  return self;
}

uint64_t sub_1B63B4B18()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  type metadata accessor for LensBlurPassSystem();
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v1 = qword_1EB997A18;
  sub_1B629ACD8(0, (unint64_t *)&qword_1EB980C70, (void (*)(uint64_t))sub_1B6642FC0);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for ProjectionMatrix;
  *(void *)(inited + 40) = &off_1F0F6EF58;
  uint64_t v7 = v1;
  int v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  char v11 = 2;
  uint64_t v12 = 0;
  swift_retain();
  sub_1B62F776C(inited, 1, (uint64_t)v5);
  swift_setDeallocating();
  swift_release();
  long long v3 = v5[1];
  *(_OWORD *)(v0 + 16) = v5[0];
  *(_OWORD *)(v0 + 32) = v3;
  *(void *)(v0 + 48) = v6;
  return v0;
}

const char *sub_1B63B4C70()
{
  return "LensBlurPass";
}

uint64_t type metadata accessor for IBLGeneratorSystem()
{
  return self;
}

uint64_t sub_1B63B4CA8()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v11 = qword_1EB997A18;
  int v12 = 0;
  char v13 = 2;
  uint64_t v14 = 0;
  char v15 = 2;
  uint64_t v16 = 0;
  swift_retain();
  sub_1B63A1C20(1, 1, (uint64_t)&v6);
  swift_release();
  int v1 = v7;
  char v2 = v8;
  uint64_t v3 = v10;
  uint64_t v4 = v9 | 4;
  *(void *)(v0 + 16) = v6;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  return v0;
}

const char *sub_1B63B4D94()
{
  return "IBLGenerator";
}

uint64_t sub_1B63B4DAC(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  uint64_t v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for EventDisposeSystem()
{
  return self;
}

uint64_t sub_1B63B4E9C()
{
  uint64_t v0 = swift_allocObject();
  sub_1B628EAB8();
  return v0;
}

const char *sub_1B63B4ED4()
{
  return "Events Dispose";
}

uint64_t type metadata accessor for DepthPrepareSystem()
{
  return self;
}

const char *sub_1B63B4F10()
{
  return "Depth Prepare";
}

uint64_t type metadata accessor for DebugDrawingSystem()
{
  return self;
}

const char *sub_1B63B4F48()
{
  return "DebugDrawing";
}

uint64_t type metadata accessor for DebugCullingSystem()
{
  return self;
}

const char *sub_1B63B4F80()
{
  return "CullingDebug";
}

uint64_t sub_1B63B4F94(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 176);
  swift_retain();
  sub_1B636E270((uint64_t)&type metadata for DebugCullingSystemState, (uint64_t)&off_1F0F8EE00, v1);

  return swift_release();
}

uint64_t type metadata accessor for AssetCatalogSystem()
{
  return self;
}

uint64_t sub_1B63B5020()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v11 = qword_1EB997A18;
  int v12 = 0;
  char v13 = 2;
  uint64_t v14 = 0;
  char v15 = 2;
  uint64_t v16 = 0;
  swift_retain();
  sub_1B63A965C(1, (uint64_t)&v6);
  swift_release();
  int v1 = v7;
  char v2 = v8;
  uint64_t v3 = v10;
  uint64_t v4 = v9 | 4;
  *(void *)(v0 + 16) = v6;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  return v0;
}

const char *sub_1B63B5108()
{
  return "AssetCatalogSystem";
}

uint64_t sub_1B63B5120(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  swift_unknownObjectRetain();
  uint64_t result = swift_unknownObjectRelease();
  *(void *)(a1 + 16) = v3;
  return result;
}

uint64_t sub_1B63B5164(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + OBJC_IVAR____TtC3VFX13EntityManager_renderer))
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void **)(result + 176);
    MEMORY[0x1F4188790](result, a2);
    swift_retain();
    swift_retain();
    sub_1B636E6CC((uint64_t)&type metadata for AssetCatalog, (uint64_t)&off_1F0F59060, v4, (void (*)(uint64_t))sub_1B6395840);
    swift_release();
    uint64_t v5 = *(void *)(v2 + 16);
    uint64_t v6 = *(void *)(v3 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
    swift_getObjectType();
    uint64_t v7 = sub_1B62B6A60();
    char v8 = *(os_unfair_lock_s **)(v6 + 40);
    swift_retain_n();
    os_unfair_lock_lock(v8);
    sub_1B62B6A68(v3, v5);
    swift_release();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    sub_1B6369F00(v3, v7, v5);
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v6 + 40));
    swift_release();
    return swift_release_n();
  }
  return result;
}

uint64_t sub_1B63B52E8(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 != result)
  {
    char v4 = a2;
    char v5 = result;
    uint64_t v6 = result >> 6;
    uint64_t v7 = a2 >> 6;
    if (a2 >> 6 == result >> 6)
    {
      uint64_t v8 = (-1 << a2) ^ (-1 << result);
      uint64_t v7 = result >> 6;
    }
    else
    {
      if ((a2 >> 6) - (result >> 6) >= 2) {
        uint64_t result = (uint64_t)memset((void *)(a3 + 8 * v6 + 8), 255, 8 * (v7 + ~v6));
      }
      uint64_t v8 = ~(-1 << v4);
      *(void *)(a3 + 8 * v6) |= -1 << v5;
    }
    *(void *)(a3 + 8 * v7) |= v8;
  }
  return result;
}

uint64_t sub_1B63B53A8@<X0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = sub_1B628F754(a1);
  if (!v2)
  {
    *(_WORD *)a2 = result;
    *(unsigned char *)(a2 + 2) = BYTE2(result);
    *(unsigned char *)(a2 + 3) = BYTE3(result) & 1;
  }
  return result;
}

double sub_1B63B53EC@<D0>(_DWORD *a1@<X8>)
{
  *(void *)&double result = 16842752;
  *a1 = 16842752;
  return result;
}

unint64_t sub_1B63B53FC()
{
  unint64_t result = qword_1EB97EFE0;
  if (!qword_1EB97EFE0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97EFE0);
  }
  return result;
}

void sub_1B63B5450(unint64_t a1, CGColorSpace *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  size_t v95 = a3;
  uint64_t v91 = a4;
  uint64_t v92 = a5;
  uint64_t v93 = a2;
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  sub_1B638C1B8(0, (unint64_t *)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718]);
  MEMORY[0x1F4188790](v7 - 8, v8);
  uint64_t v10 = (char *)&v89 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v11, v12);
  uint64_t v14 = (char *)&v89 - v13;
  MEMORY[0x1F4188790](v15, v16);
  char v18 = (char *)&v89 - v17;
  MEMORY[0x1F4188790](v19, v20);
  uint64_t v22 = (char *)&v89 - v21;
  sub_1B6E30DF8();
  uint64_t v23 = sub_1B6E31828();
  uint64_t v25 = v24;
  swift_bridgeObjectRelease();
  if (v23 == 26230 && v25 == 0xE200000000000000 || (sub_1B6E334B8() & 1) != 0)
  {
    swift_bridgeObjectRelease();
    uint64_t v26 = sub_1B6E30F68();
    if (v5)
    {

      sub_1B6E32BE8();
      __break(1u);
      swift_release();
      swift_release();
      swift_unknownObjectRelease_n();
      __break(1u);
      swift_unknownObjectRelease_n();
      sub_1B62C2360(v25, a1);
      __break(1u);
    }
    else
    {
      unint64_t v28 = v27;
      uint64_t v29 = v26;
      switch(v27 >> 62)
      {
        case 1uLL:
          swift_unknownObjectRetain_n();
          sub_1B62FFBB0(v29, v28);
          sub_1B6D00D78((int)v29, v29 >> 32, v28 & 0x3FFFFFFFFFFFFFFFLL, (uint64_t)v94);
          sub_1B62C2360(v29, v28);
          break;
        case 2uLL:
          uint64_t v32 = *(void *)(v26 + 16);
          uint64_t v31 = *(void *)(v26 + 24);
          swift_unknownObjectRetain_n();
          swift_retain();
          swift_retain();
          sub_1B6D00D78(v32, v31, v28 & 0x3FFFFFFFFFFFFFFFLL, (uint64_t)v94);
          swift_release();
          swift_release();
          break;
        case 3uLL:
          *(void *)((char *)&v99 + 6) = 0;
          *(void *)&long long v99 = 0;
          swift_unknownObjectRetain_n();
          unint64_t v30 = (char *)&v99;
          goto LABEL_12;
        default:
          *(void *)&long long v99 = v26;
          WORD4(v99) = v27;
          BYTE10(v99) = BYTE2(v27);
          BYTE11(v99) = BYTE3(v27);
          BYTE12(v99) = BYTE4(v27);
          BYTE13(v99) = BYTE5(v27);
          swift_unknownObjectRetain_n();
          unint64_t v30 = (char *)&v99 + BYTE6(v28);
LABEL_12:
          sub_1B6BDF564((unsigned __int16 *)&v99, (uint64_t)v30, (uint64_t)v94);
          break;
      }
      sub_1B62C2360(v29, v28);
      swift_unknownObjectRelease_n();
    }
    return;
  }
  if (v23 == 7894123 && v25 == 0xE300000000000000)
  {
    swift_bridgeObjectRelease();
    goto LABEL_17;
  }
  char v33 = sub_1B6E334B8();
  swift_bridgeObjectRelease();
  if (v33)
  {
LABEL_17:
    uint64_t v34 = sub_1B6E30F68();
    if (!v5)
    {
      unint64_t v36 = v34;
      unint64_t v37 = v35;
      uint64_t v38 = sub_1B6E30F48();
      uint64_t v39 = *(void *)(v38 - 8);
      (*(void (**)(char *, unint64_t, uint64_t))(v39 + 16))(v22, a1, v38);
      (*(void (**)(char *, void, uint64_t, uint64_t))(v39 + 56))(v22, 0, 1, v38);
      sub_1B6C346E0(v36, v37, (uint64_t)v22, v93, v95);
      sub_1B639579C((uint64_t)v22, (uint64_t)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718], (uint64_t (*)(void))sub_1B638C1B8);
      sub_1B62C2360(v36, v37);
      return;
    }
    id v98 = v5;
    id v40 = v5;
    sub_1B62C55B0(0, (unint64_t *)&qword_1EB980E40);
    if (swift_dynamicCast())
    {
      if (v100 == 1)
      {
        CFDataRef v90 = 0;
        uint64_t v41 = v5;
        sub_1B6C3677C(v99, *((uint64_t *)&v99 + 1), 1u);
        if (qword_1EB9852D0 != -1) {
          swift_once();
        }
        uint64_t v96 = 0;
        unint64_t v97 = 0xE000000000000000;
        swift_retain();
        sub_1B6E328C8();
        sub_1B6E31948();
        sub_1B6E30E58();
        sub_1B6E31948();
        swift_bridgeObjectRelease();
        sub_1B6E31948();
        uint64_t v42 = v96;
        uint64_t v43 = v97;
        int v44 = sub_1B6E32148();
        if (qword_1EB9854F8 != -1) {
          swift_once();
        }
        uint64_t v96 = 0;
        swift_retain();
        sub_1B6B33E34(v44, &v96, v42, v43);
        swift_release();
        swift_bridgeObjectRelease();
        swift_release();
        CFURLRef v45 = (const __CFURL *)sub_1B6E30E78();
        uint64_t v46 = CGImageSourceCreateWithURL(v45, 0);

        if (v46)
        {
          CGImageRef ImageAtIndex = CGImageSourceCreateImageAtIndex(v46, 0, 0);
          if (ImageAtIndex)
          {
            uint64_t v48 = ImageAtIndex;
            uint64_t v49 = sub_1B6E30F48();
            uint64_t v50 = *(void *)(v49 - 8);
            (*(void (**)(char *, unint64_t, uint64_t))(v50 + 16))(v10, a1, v49);
            (*(void (**)(char *, void, uint64_t, uint64_t))(v50 + 56))(v10, 0, 1, v49);
            uint64_t v51 = v94;
            CFDataRef v52 = v90;
            sub_1B628D46C(v48, v93, v95, (size_t)v10, v91, v92);
            sub_1B639579C((uint64_t)v10, (uint64_t)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718], (uint64_t (*)(void))sub_1B638C1B8);
            if (v52 || (uint64_t v78 = *v51) == 0)
            {
            }
            else
            {
              sub_1B6E30E58();
              uint64_t v79 = (void *)sub_1B6E31768();
              swift_bridgeObjectRelease();
              objc_msgSend(v78, sel_setLabel_, v79);
            }
            goto LABEL_51;
          }
        }
        uint64_t v96 = 0;
        unint64_t v97 = 0xE000000000000000;
        sub_1B6E328C8();
        swift_bridgeObjectRelease();
        uint64_t v96 = 0xD000000000000018;
        unint64_t v97 = 0x80000001B6F52A50;
        sub_1B6E30F48();
        sub_1B6D0ACFC((unint64_t *)&qword_1E9DD0020, MEMORY[0x1E4F276F0]);
        sub_1B6E33098();
        sub_1B6E31948();
        swift_bridgeObjectRelease();
        uint64_t v75 = v96;
        unint64_t v76 = v97;
        sub_1B6D0ACA8();
        swift_allocError();
        *(void *)uint64_t v77 = v75;
        *(void *)(v77 + 8) = v76;
        *(unsigned char *)(v77 + 16) = 0;
        swift_willThrow();

LABEL_51:
        return;
      }
      sub_1B6C3677C(v99, *((uint64_t *)&v99 + 1), v100);
    }

    *(void *)&long long v99 = 0;
    *((void *)&v99 + 1) = 0xE000000000000000;
    sub_1B6E328C8();
    sub_1B6E31948();
    uint64_t v96 = (uint64_t)v5;
    sub_1B6E32B18();
    long long v56 = v99;
    sub_1B6D0ACA8();
    swift_allocError();
    *(_OWORD *)uint64_t v57 = v56;
    *(unsigned char *)(v57 + 16) = 0;
    swift_willThrow();

    return;
  }
  sub_1B6E30DF8();
  uint64_t v53 = sub_1B6E31828();
  uint64_t v55 = v54;
  swift_bridgeObjectRelease();
  if (v53 == 2053403509 && v55 == 0xE400000000000000)
  {
    swift_bridgeObjectRelease();
LABEL_35:
    uint64_t v59 = (void *)sub_1B6D0A3CC();
    if (v5) {
      return;
    }
    if (v59)
    {
      CFDataRef v60 = v59;
      long long v61 = CGImageSourceCreateWithData(v60, 0);
      if (v61)
      {
        long long v62 = v61;
        CFDataRef v90 = v60;
        CGImageRef v63 = CGImageSourceCreateImageAtIndex(v61, 0, 0);
        if (v63)
        {
          uint64_t v64 = v63;
          uint64_t v65 = sub_1B6E30F48();
          uint64_t v66 = *(void *)(v65 - 8);
          (*(void (**)(char *, unint64_t, uint64_t))(v66 + 16))(v18, a1, v65);
          (*(void (**)(char *, void, uint64_t, uint64_t))(v66 + 56))(v18, 0, 1, v65);
          long long v67 = v94;
          sub_1B628D46C(v64, v93, v95, (size_t)v18, v91, v92);
          sub_1B639579C((uint64_t)v18, (uint64_t)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718], (uint64_t (*)(void))sub_1B638C1B8);
          uint64_t v86 = *v67;
          if (*v67)
          {
            uint64_t v87 = (void *)sub_1B6E31768();
            swift_bridgeObjectRelease();
            objc_msgSend(v86, sel_setLabel_, v87);
          }
          else
          {
            swift_bridgeObjectRelease();
          }

          CFDataRef v88 = v90;
          return;
        }

        CFDataRef v60 = v90;
      }
      *(void *)&long long v99 = 0;
      *((void *)&v99 + 1) = 0xE000000000000000;
      sub_1B6E328C8();
      swift_bridgeObjectRelease();
      *(void *)&long long v99 = 0xD00000000000001BLL;
      *((void *)&v99 + 1) = 0x80000001B6F52AA0;
      sub_1B6E31948();
      swift_bridgeObjectRelease();
      long long v82 = v99;
      sub_1B6D0ACA8();
      swift_allocError();
      *(_OWORD *)uint64_t v83 = v82;
      *(unsigned char *)(v83 + 16) = 0;
      swift_willThrow();

      return;
    }
    *(void *)&long long v99 = 0;
    *((void *)&v99 + 1) = 0xE000000000000000;
    sub_1B6E328C8();
    swift_bridgeObjectRelease();
    *(void *)&long long v99 = 0xD000000000000026;
    *((void *)&v99 + 1) = 0x80000001B6F52A70;
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
LABEL_54:
    long long v80 = v99;
    sub_1B6D0ACA8();
    swift_allocError();
    *(_OWORD *)uint64_t v81 = v80;
    *(unsigned char *)(v81 + 16) = 0;
    swift_willThrow();
    return;
  }
  char v58 = sub_1B6E334B8();
  swift_bridgeObjectRelease();
  if (v58) {
    goto LABEL_35;
  }
  CFURLRef v68 = (const __CFURL *)sub_1B6E30E78();
  long long v69 = CGImageSourceCreateWithURL(v68, 0);

  if (!v69)
  {
LABEL_53:
    *(void *)&long long v99 = 0;
    *((void *)&v99 + 1) = 0xE000000000000000;
    sub_1B6E328C8();
    swift_bridgeObjectRelease();
    *(void *)&long long v99 = 0xD000000000000018;
    *((void *)&v99 + 1) = 0x80000001B6F52A50;
    sub_1B6E30F48();
    sub_1B6D0ACFC((unint64_t *)&qword_1E9DD0020, MEMORY[0x1E4F276F0]);
    sub_1B6E33098();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    goto LABEL_54;
  }
  CGImageRef v70 = CGImageSourceCreateImageAtIndex(v69, 0, 0);
  if (!v70)
  {

    goto LABEL_53;
  }
  char v71 = v70;
  uint64_t v72 = sub_1B6E30F48();
  uint64_t v73 = *(void *)(v72 - 8);
  (*(void (**)(char *, unint64_t, uint64_t))(v73 + 16))(v14, a1, v72);
  (*(void (**)(char *, void, uint64_t, uint64_t))(v73 + 56))(v14, 0, 1, v72);
  __int16 v74 = v94;
  sub_1B628D46C(v71, v93, v95, (size_t)v14, v91, v92);
  if (v5)
  {
    sub_1B639579C((uint64_t)v14, (uint64_t)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718], (uint64_t (*)(void))sub_1B638C1B8);
  }
  else
  {
    sub_1B639579C((uint64_t)v14, (uint64_t)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718], (uint64_t (*)(void))sub_1B638C1B8);
    uint64_t v84 = *v74;
    if (*v74)
    {
      sub_1B6E30E58();
      uint64_t v85 = (void *)sub_1B6E31768();
      swift_bridgeObjectRelease();
      objc_msgSend(v84, sel_setLabel_, v85);
    }
  }
}

uint64_t type metadata accessor for RenderGraphSystem()
{
  return self;
}

uint64_t sub_1B63B6530()
{
  uint64_t v0 = swift_allocObject();
  sub_1B62A0A70();
  return v0;
}

const char *sub_1B63B6568()
{
  return "RenderGraph";
}

uint64_t sub_1B63B657C()
{
  return qword_1E9DD2FF8 + 2;
}

uint64_t sub_1B63B658C()
{
  uint64_t result = swift_allocObject();
  *(unsigned char *)(result + 16) = 0;
  return result;
}

const char *sub_1B63B65B4()
{
  return "Post Processing";
}

void sub_1B63B65C8()
{
  if (!qword_1EB97EF10)
  {
    uint64_t v0 = (uint64_t (*)(uint64_t, void, unint64_t))MEMORY[0x1E4FBC2F8];
    sub_1B63958F8(255, (unint64_t *)&qword_1EB980EF0, MEMORY[0x1E4FBC2F8]);
    sub_1B6666340((unint64_t *)&unk_1EB980EE0, (unint64_t *)&qword_1EB980EF0, v0);
    unint64_t v1 = type metadata accessor for KeyframeAnimation();
    if (!v2) {
      atomic_store(v1, (unint64_t *)&qword_1EB97EF10);
    }
  }
}

void sub_1B63B667C()
{
  if (!qword_1EB97EF08)
  {
    uint64_t v0 = (uint64_t (*)(uint64_t, void, unint64_t))MEMORY[0x1E4FBC2A8];
    sub_1B63958F8(255, (unint64_t *)&qword_1EB980EB0, MEMORY[0x1E4FBC2A8]);
    sub_1B6666340(&qword_1EB980EA8, (unint64_t *)&qword_1EB980EB0, v0);
    unint64_t v1 = type metadata accessor for KeyframeAnimation();
    if (!v2) {
      atomic_store(v1, (unint64_t *)&qword_1EB97EF08);
    }
  }
}

void sub_1B63B6730()
{
  if (!qword_1EB97EF00)
  {
    uint64_t v0 = (uint64_t (*)(uint64_t, void, unint64_t))MEMORY[0x1E4FBC280];
    sub_1B63958F8(255, &qword_1EB980E90, MEMORY[0x1E4FBC280]);
    sub_1B6666340((unint64_t *)&unk_1EB980E80, &qword_1EB980E90, v0);
    unint64_t v1 = type metadata accessor for KeyframeAnimation();
    if (!v2) {
      atomic_store(v1, (unint64_t *)&qword_1EB97EF00);
    }
  }
}

uint64_t sub_1B63B67E4()
{
  *(unsigned char *)(v0 + 16) = 0;
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v31 = qword_1EB997A18;
  int v32 = 0;
  char v33 = 2;
  uint64_t v34 = 0;
  char v35 = 2;
  uint64_t v36 = 0;
  swift_retain();
  sub_1B63ABE64(1, (uint64_t)v9);
  swift_release();
  long long v1 = v9[1];
  *(_OWORD *)(v0 + 24) = v9[0];
  *(_OWORD *)(v0 + 40) = v1;
  *(void *)(v0 + 56) = v10;
  uint64_t v25 = qword_1EB997A18;
  int v26 = 0;
  char v27 = 2;
  uint64_t v28 = 0;
  char v29 = 2;
  uint64_t v30 = 0;
  swift_retain();
  sub_1B63AC2E8(1, (uint64_t)v11);
  swift_release();
  long long v2 = v11[1];
  *(_OWORD *)(v0 + 64) = v11[0];
  *(_OWORD *)(v0 + 80) = v2;
  *(void *)(v0 + 96) = v12;
  uint64_t v19 = qword_1EB997A18;
  int v20 = 0;
  char v21 = 2;
  uint64_t v22 = 0;
  char v23 = 2;
  uint64_t v24 = 0;
  swift_retain();
  sub_1B63A7070(3, (uint64_t)&v13);
  swift_release();
  int v3 = v14;
  char v4 = v15;
  char v5 = v17;
  uint64_t v6 = v18;
  uint64_t v7 = v16 | 1;
  *(void *)(v0 + 104) = v13;
  *(_DWORD *)(v0 + 112) = v3;
  *(unsigned char *)(v0 + 116) = v4;
  *(void *)(v0 + 120) = v7;
  *(unsigned char *)(v0 + 128) = v5;
  *(void *)(v0 + 136) = v6;
  return v0;
}

uint64_t sub_1B63B696C()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63B67E4();
  return v0;
}

const char *sub_1B63B69A4()
{
  return "GraphScriptRunner";
}

uint64_t sub_1B63B69BC(uint64_t a1)
{
  if (qword_1EB985518 != -1) {
    swift_once();
  }
  objc_msgSend((id)qword_1EB9852A0, sel_lock);
  if (qword_1EB985510 != -1) {
    swift_once();
  }
  long long v2 = off_1EB985508;
  if (!*((void *)off_1EB985508 + 2) || (unint64_t v3 = sub_1B62C1A30(a1), (v4 & 1) == 0))
  {
    __src[0] = 0;
    LOBYTE(__src[1]) = 1;
    sub_1B63B949C((uint64_t)__src);
LABEL_10:
    type metadata accessor for DepthStencilCache();
    uint64_t Strong = swift_allocObject();
    *(void *)(Strong + 24) = sub_1B67F5BC8(MEMORY[0x1E4FBC860]);
    swift_unknownObjectRetain();
    uint64_t v6 = (_DWORD *)swift_slowAlloc();
    *uint64_t v6 = 0;
    *(void *)(Strong + 32) = "lock DepthStencilCache";
    *(void *)(Strong + 40) = 22;
    *(unsigned char *)(Strong + 48) = 2;
    *(void *)(Strong + 56) = v6;
    *(void *)(Strong + 16) = a1;
    uint64_t v7 = (void *)swift_unknownObjectRetain();
    sub_1B6D2718C(v7, (uint64_t)__src);
    memcpy((void *)(Strong + 64), __src, 0x2D8uLL);
    swift_unknownObjectRelease();
    swift_weakInit();
    swift_weakAssign();
    sub_1B6AD9528((uint64_t)&v9, (uint64_t)v10);
    v10[8] = 0;
    sub_1B6CE0EB8((uint64_t)v10, a1);
    goto LABEL_11;
  }
  sub_1B63B9468(v2[7] + 8 * v3, (uint64_t)__src);
  LOBYTE(__src[1]) = 0;
  uint64_t Strong = swift_weakLoadStrong();
  sub_1B63B949C((uint64_t)__src);
  if (!Strong) {
    goto LABEL_10;
  }
LABEL_11:
  objc_msgSend((id)qword_1EB9852A0, sel_unlock);
  return Strong;
}

uint64_t type metadata accessor for DeferredRendering()
{
  return self;
}

const char *sub_1B63B6BC0()
{
  return "Deferred Rendering";
}

double sub_1B63B6BD4@<D0>(uint64_t a1@<X0>, void (*a2)(void)@<X3>, uint64_t a3@<X8>)
{
  *(void *)&long long v7 = 0;
  *((void *)&v7 + 1) = 0xE000000000000000;
  a2();
  _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0(a1);
  if (v3)
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
  }
  else
  {
    double result = *(double *)&v7;
    *(_OWORD *)a3 = v7;
    *(void *)(a3 + 16) = 0;
    *(void *)(a3 + 24) = 0xE000000000000000;
    *(_OWORD *)(a3 + 32) = 0uLL;
  }
  return result;
}

double sub_1B63B6C6C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_1B63B6BD4(a1, (void (*)(void))sub_1B63AE428, a2);
}

uint64_t sub_1B63B6C98()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v11 = qword_1EB997A18;
  int v12 = 0;
  char v13 = 2;
  uint64_t v14 = 0;
  char v15 = 2;
  uint64_t v16 = 0;
  swift_retain();
  sub_1B63AA054(1, (uint64_t)&v6);
  swift_release();
  int v1 = v7;
  char v2 = v8;
  uint64_t v3 = v10;
  uint64_t v4 = v9 | 4;
  *(void *)(v0 + 16) = v6;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  return v0;
}

const char *sub_1B63B6D80()
{
  return "ShaderFileSystem";
}

uint64_t sub_1B63B6D98(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  uint64_t v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for SceneKitRenderer(uint64_t a1)
{
  return sub_1B633A29C(a1, (uint64_t *)&unk_1EB97ED00);
}

uint64_t sub_1B63B6E84()
{
  uint64_t v1 = 0;
  uint64_t v11 = 0;
  unint64_t v12 = 0xE000000000000000;
  long long v2 = v0[1];
  long long v13 = *v0;
  long long v14 = v2;
  long long v3 = v0[3];
  long long v15 = v0[2];
  long long v16 = v3;
  do
  {
    long long v7 = v13;
    long long v8 = v14;
    long long v9 = v15;
    long long v10 = v16;
    if (*((void *)&v7 + v1))
    {
      *(void *)&long long v7 = v1;
      sub_1B6E33098();
      sub_1B6E31948();
      swift_bridgeObjectRelease();
      sub_1B6E31948();
      long long v7 = v13;
      long long v8 = v14;
      long long v9 = v15;
      long long v10 = v16;
      _sSo14MTLPixelFormatV3VFXE11descriptionSSvg_0(*((void *)&v7 + v1));
      sub_1B6E31948();
      swift_bridgeObjectRelease();
      sub_1B6E31948();
      sub_1B6E31948();
      swift_bridgeObjectRelease();
    }
    ++v1;
  }
  while (v1 != 8);
  uint64_t v4 = *((void *)v0 + 8);
  if (v4)
  {
    *(void *)&long long v7 = 0x3A6874706564;
    *((void *)&v7 + 1) = 0xE600000000000000;
    _sSo14MTLPixelFormatV3VFXE11descriptionSSvg_0(v4);
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
  }
  uint64_t v5 = *((void *)v0 + 9);
  if (v5)
  {
    *(void *)&long long v7 = 0x3A6C69636E657473;
    *((void *)&v7 + 1) = 0xE800000000000000;
    _sSo14MTLPixelFormatV3VFXE11descriptionSSvg_0(v5);
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
  }
  if (*((uint64_t *)v0 + 10) >= 2)
  {
    *(void *)&long long v7 = 0x3A4141534DLL;
    *((void *)&v7 + 1) = 0xE500000000000000;
    sub_1B6E33098();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
    sub_1B6E31948();
    swift_bridgeObjectRelease();
  }
  return v11;
}

unint64_t sub_1B63B70E8()
{
  unint64_t result = qword_1EB94A190;
  if (!qword_1EB94A190)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB94A190);
  }
  return result;
}

uint64_t type metadata accessor for OpaqueRenderPass()
{
  return self;
}

uint64_t sub_1B63B7160()
{
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v7 = qword_1EB997A18;
  int v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  char v11 = 2;
  uint64_t v12 = 0;
  swift_retain();
  sub_1B62A0EB4(1, (uint64_t)v4);
  swift_release();
  sub_1B62C6034(0, (unint64_t *)&qword_1EB980B60, (unint64_t *)&qword_1EB97E840, (uint64_t)&protocol descriptor for ClassComponent, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 56) = &type metadata for DrawCallLayer;
  *(void *)(inited + 64) = &off_1F0F5E758;
  *(unsigned char *)(inited + 32) = 0;
  sub_1B62A1250(inited, (uint64_t)v5);
  swift_setDeallocating();
  sub_1B62C5560(0, (unint64_t *)&qword_1EB97E840);
  swift_arrayDestroy();
  sub_1B62CA064((uint64_t)v4);
  long long v2 = v5[1];
  *(_OWORD *)(v0 + 16) = v5[0];
  *(_OWORD *)(v0 + 32) = v2;
  *(void *)(v0 + 48) = v6;
  return v0;
}

uint64_t sub_1B63B72D8()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63B7160();
  return v0;
}

const char *sub_1B63B7310()
{
  return "OpaqueRenderPass";
}

uint64_t sub_1B63B7324()
{
  return qword_1E9DD3000;
}

const char *sub_1B63B7334()
{
  return "MeshRenderSystem";
}

uint64_t type metadata accessor for InputClearSystem()
{
  return self;
}

uint64_t sub_1B63B7370()
{
  uint64_t result = swift_allocObject();
  *(void *)(result + 16) = qword_1E9DD3030;
  return result;
}

const char *sub_1B63B73A0()
{
  return "InputClearSystem";
}

uint64_t sub_1B63B73B4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 176);
  swift_retain();
  sub_1B636E270((uint64_t)&type metadata for InputStream, (uint64_t)&off_1F0F55798, v1);

  return swift_release();
}

uint64_t destroy for GraphScriptGroup()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t assignWithTake for GraphScriptGroup(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  swift_bridgeObjectRelease();
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  swift_bridgeObjectRelease();
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  swift_bridgeObjectRelease();
  return a1;
}

void *initializeWithCopy for GraphScriptGroup(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

void sub_1B63B7508(void *a1@<X8>)
{
  uint64_t v1 = qword_1EB97D6C0++;
  *a1 = MEMORY[0x1E4FBC860];
  a1[1] = v1;
  uint64_t v2 = MEMORY[0x1E4FBC870];
  a1[2] = MEMORY[0x1E4FBC870];
  a1[3] = v2;
}

uint64_t type metadata accessor for ForceFieldSystem()
{
  return self;
}

uint64_t sub_1B63B7558()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v7 = qword_1EB997A18;
  int v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  char v11 = 2;
  uint64_t v12 = 0;
  swift_retain();
  sub_1B63ABED8(1, (uint64_t)v4);
  swift_release();
  sub_1B62F927C(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for ForceFieldRuntime;
  *(void *)(inited + 40) = &off_1F0F70D00;
  sub_1B62AD00C(inited, (uint64_t)v5);
  swift_setDeallocating();
  sub_1B62CA064((uint64_t)v4);
  long long v2 = v5[1];
  *(_OWORD *)(v0 + 16) = v5[0];
  *(_OWORD *)(v0 + 32) = v2;
  *(void *)(v0 + 48) = v6;
  return v0;
}

uint64_t sub_1B63B76C0()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63B7558();
  return v0;
}

const char *sub_1B63B76F8()
{
  return "ForceField";
}

uint64_t sub_1B63B7710(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  uint64_t v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t sub_1B63B77E0(uint64_t a1)
{
  uint64_t v2 = *(void *)(v1 + 24);
  uint64_t v3 = *(void *)(v2 + 16);
  if (!v3) {
    return 0;
  }
  for (uint64_t i = (char *)(v2 + 96); (*i & 0x80000000) == 0 || *((void *)i - 8) != a1; i += 80)
  {
    if (!--v3) {
      return 0;
    }
  }
  return 1;
}

uint64_t sub_1B63B7824()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B63B7884()
{
  unint64_t result = qword_1EB97EBC0;
  if (!qword_1EB97EBC0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97EBC0);
  }
  return result;
}

unint64_t sub_1B63B78D8()
{
  unint64_t result = qword_1EB97EBB0;
  if (!qword_1EB97EBB0)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97EBB0);
  }
  return result;
}

uint64_t type metadata accessor for SetActiveSystem()
{
  return self;
}

uint64_t sub_1B63B7950()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v13 = qword_1EB997A18;
  int v14 = 0;
  char v15 = 2;
  uint64_t v16 = 0;
  char v17 = 2;
  uint64_t v18 = 0;
  swift_retain();
  sub_1B63A6C60(1, (uint64_t)&v7);
  swift_release();
  int v1 = v8;
  char v2 = v9;
  char v3 = v11;
  uint64_t v4 = v12;
  uint64_t v5 = v10 | 1;
  *(void *)(v0 + 16) = v7;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v5;
  *(unsigned char *)(v0 + 40) = v3;
  *(void *)(v0 + 48) = v4;
  return v0;
}

const char *sub_1B63B7A3C()
{
  return "SetActiveSystem";
}

uint64_t sub_1B63B7A54(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  uint64_t v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for SceneFileSystem()
{
  return self;
}

uint64_t sub_1B63B7B44(uint64_t a1, uint64_t a2)
{
  return sub_1B636B278(a1, a2, (void (*)(uint64_t *__return_ptr, uint64_t))sub_1B63AA66C);
}

const char *sub_1B63B7B5C()
{
  return "SceneFile";
}

uint64_t sub_1B63B7B74(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  uint64_t v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for HierarchySystem()
{
  return self;
}

uint64_t sub_1B63B7C64()
{
  uint64_t v0 = swift_allocObject();
  sub_1B629CE40();
  return v0;
}

uint64_t sub_1B63B7C9C()
{
  return (*(uint64_t (**)(void))(v0 + 136))();
}

const char *sub_1B63B7CB0()
{
  return "HierarchySystem";
}

uint64_t type metadata accessor for DebugInfoSystem()
{
  return self;
}

uint64_t sub_1B63B7CEC()
{
  uint64_t result = swift_allocObject();
  *(unsigned char *)(result + 16) = 1;
  return result;
}

const char *sub_1B63B7D18()
{
  return "Debug Info";
}

uint64_t type metadata accessor for CompositeSystem()
{
  return self;
}

const char *sub_1B63B7D54()
{
  return "Composite";
}

uint64_t type metadata accessor for ColorRampSystem()
{
  return self;
}

uint64_t sub_1B63B7D8C()
{
  uint64_t v0 = swift_allocObject();
  sub_1B6293708();
  return v0;
}

const char *sub_1B63B7DC4()
{
  return "ColorRampSystem";
}

uint64_t type metadata accessor for BloomPassSystem()
{
  return self;
}

const char *sub_1B63B7E00()
{
  return "BloomPass";
}

double sub_1B63B7E14@<D0>(uint64_t a1@<X8>)
{
  uint64_t v4 = *(void *)(sub_1B6E30F48() - 8);
  unint64_t v5 = (*(unsigned __int8 *)(v4 + 80) + 16) & ~(unint64_t)*(unsigned __int8 *)(v4 + 80);
  unint64_t v6 = (*(void *)(v4 + 64) + v5 + 7) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v7 = sub_1B63AE744(v1 + v5, v1 + v6, *(void *)(v1 + ((v6 + 65) & 0xFFFFFFFFFFFFFFF8)));
  if (!v2)
  {
    *(void *)a1 = v7;
    double result = 0.0;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
  }
  return result;
}

double sub_1B63B7EDC@<D0>(unint64_t a1@<X0>, CGColorSpace *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  sub_1B63AED30(a1, a2, *(void *)(a3 + 16), &v18);
  if (!v4)
  {
    uint64_t v7 = v19;
    uint64_t v8 = v20;
    uint64_t v9 = v21;
    uint64_t v10 = v27;
    uint64_t v11 = v29;
    uint64_t v12 = 0x10000;
    if (!v23) {
      uint64_t v12 = 0;
    }
    unint64_t v13 = v22 | (unint64_t)v12;
    unint64_t v14 = v28 | 0x8000000000000000;
    double result = *(double *)&v18;
    long long v15 = v24;
    long long v16 = v25;
    long long v17 = v26;
    *(_OWORD *)a4 = v18;
    *(void *)(a4 + 16) = v7;
    *(void *)(a4 + 24) = v8;
    *(void *)(a4 + 32) = v9;
    *(void *)(a4 + 40) = v13;
    *(_OWORD *)(a4 + 48) = v15;
    *(_OWORD *)(a4 + 64) = v16;
    *(_OWORD *)(a4 + 80) = v17;
    *(void *)(a4 + 96) = v10;
    *(void *)(a4 + 104) = v14;
    *(void *)(a4 + 112) = v11;
  }
  return result;
}

void destroy for TextureCache.CacheEntry.Loading(id *a1)
{
}

void **initializeBufferWithCopyOfBuffer for TextureCGImage(void **a1, void **a2)
{
  uint64_t v3 = *a2;
  *a1 = *a2;
  id v4 = v3;
  return a1;
}

uint64_t type metadata accessor for SkinningSystem()
{
  return self;
}

uint64_t sub_1B63B7FD0()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B639FB88(1, 1, 1, (uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 16) = v3[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v4;
  return v0;
}

const char *sub_1B63B80A0()
{
  return "Skinning";
}

uint64_t sub_1B63B80B8(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  int v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for SkeletonSystem()
{
  return self;
}

uint64_t sub_1B63B81A8(uint64_t a1, uint64_t a2)
{
  return sub_1B636AFC8(a1, a2, 3, (void (*)(_OWORD *__return_ptr, uint64_t))sub_1B63A6E68);
}

const char *sub_1B63B81C4()
{
  return "SkeletonSystem";
}

uint64_t sub_1B63B81DC(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  int v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for SineMoveSystem()
{
  return self;
}

uint64_t sub_1B63B82CC()
{
  uint64_t v0 = swift_allocObject();
  *(_DWORD *)(v0 + 16) = 0;
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B63A08C8((uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 24) = v3[0];
  *(_OWORD *)(v0 + 40) = v1;
  *(void *)(v0 + 56) = v4;
  return v0;
}

const char *sub_1B63B8398()
{
  return "SineMove";
}

uint64_t sub_1B63B83B0(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 24);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  int v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for SceneKitSystem()
{
  return self;
}

uint64_t sub_1B63B84A0()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v14 = qword_1EB997A18;
  int v15 = 0;
  char v16 = 2;
  uint64_t v17 = 0;
  char v18 = 2;
  uint64_t v19 = 0;
  swift_retain();
  sub_1B63A6554((uint64_t)v4);
  swift_release();
  long long v1 = v4[1];
  *(_OWORD *)(v0 + 16) = v4[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v5;
  uint64_t v8 = qword_1EB997A18;
  int v9 = 0;
  char v10 = 2;
  uint64_t v11 = 0;
  char v12 = 2;
  uint64_t v13 = 0;
  swift_retain();
  sub_1B63A1148((uint64_t)v6);
  swift_release();
  long long v2 = v6[1];
  *(_OWORD *)(v0 + 56) = v6[0];
  *(_OWORD *)(v0 + 72) = v2;
  *(void *)(v0 + 88) = v7;
  return v0;
}

const char *sub_1B63B85BC()
{
  return "SceneKit";
}

uint64_t type metadata accessor for MeshFileSystem()
{
  return self;
}

uint64_t sub_1B63B85F8()
{
  uint64_t v0 = swift_allocObject();
  sub_1B629F7C8();
  return v0;
}

const char *sub_1B63B8630()
{
  return "MeshFile";
}

uint64_t type metadata accessor for MaterialSystem()
{
  return self;
}

uint64_t sub_1B63B866C()
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v50 = qword_1EB997A18;
  int v51 = 0;
  char v52 = 2;
  uint64_t v53 = 0;
  char v54 = 2;
  uint64_t v55 = 0;
  swift_retain();
  sub_1B62949D8(1, (uint64_t)v15);
  swift_release();
  sub_1B62F9340(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for MaterialRuntime;
  *(void *)(inited + 40) = &off_1F0F68EA8;
  sub_1B62AD184(v16);
  swift_setDeallocating();
  sub_1B62CA064((uint64_t)v15);
  long long v2 = v16[1];
  *(_OWORD *)(v0 + 16) = v16[0];
  *(_OWORD *)(v0 + 32) = v2;
  *(void *)(v0 + 48) = v17;
  uint64_t v44 = qword_1EB997A18;
  int v45 = 0;
  char v46 = 2;
  uint64_t v47 = 0;
  char v48 = 2;
  uint64_t v49 = 0;
  swift_retain();
  sub_1B62D3230(4, 2, (uint64_t)v18);
  swift_release();
  long long v3 = v18[1];
  *(_OWORD *)(v0 + 56) = v18[0];
  *(_OWORD *)(v0 + 72) = v3;
  *(void *)(v0 + 88) = v19;
  uint64_t v38 = qword_1EB997A18;
  int v39 = 0;
  char v40 = 2;
  uint64_t v41 = 0;
  char v42 = 2;
  uint64_t v43 = 0;
  swift_retain();
  sub_1B629FB54(1, (uint64_t)&v20);
  swift_release();
  int v4 = v21;
  char v5 = v22;
  char v6 = v24;
  uint64_t v7 = v25;
  uint64_t v8 = v23 | 0x20;
  *(void *)(v0 + 96) = v20;
  *(_DWORD *)(v0 + 104) = v4;
  *(unsigned char *)(v0 + 108) = v5;
  *(void *)(v0 + 112) = v8;
  *(unsigned char *)(v0 + 120) = v6;
  *(void *)(v0 + 128) = v7;
  uint64_t v32 = qword_1EB997A18;
  int v33 = 0;
  char v34 = 2;
  uint64_t v35 = 0;
  char v36 = 2;
  uint64_t v37 = 0;
  swift_retain();
  sub_1B63A8534(1, (uint64_t)&v26);
  swift_release();
  int v9 = v27;
  char v10 = v28;
  char v11 = v30;
  uint64_t v12 = v31;
  uint64_t v13 = v29 | 0x20;
  *(void *)(v0 + 136) = v26;
  *(_DWORD *)(v0 + 144) = v9;
  *(unsigned char *)(v0 + 148) = v10;
  *(void *)(v0 + 152) = v13;
  *(unsigned char *)(v0 + 160) = v11;
  *(void *)(v0 + 168) = v12;
  return v0;
}

uint64_t sub_1B63B8910()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63B866C();
  return v0;
}

const char *sub_1B63B8948()
{
  return "MaterialSystem";
}

uint64_t sub_1B63B8960()
{
  return sub_1B6E31BC8();
}

unint64_t sub_1B63B89C0()
{
  unint64_t result = qword_1EB97E908;
  if (!qword_1EB97E908)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97E908);
  }
  return result;
}

unint64_t sub_1B63B8A14()
{
  unint64_t result = qword_1EB97E8F8;
  if (!qword_1EB97E8F8)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97E8F8);
  }
  return result;
}

uint64_t initializeWithCopy for LightsUniforms(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a2 + 48);
  *(_WORD *)(a1 + 49) = *(_WORD *)(a2 + 49);
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  return a1;
}

double sub_1B63B8AC8@<D0>(uint64_t a1@<X8>)
{
  *(_DWORD *)(a1 + 47) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t sub_1B63B8ADC()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B629AD2C(1, 1, (uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 16) = v3[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v4;
  return v0;
}

const char *sub_1B63B8BA8()
{
  return "VFX Debug";
}

uint64_t type metadata accessor for ColorRampCache()
{
  return self;
}

unint64_t sub_1B63B8BE4()
{
  unint64_t result = qword_1EB97E840;
  if (!qword_1EB97E840)
  {
    unint64_t result = swift_getExistentialTypeMetadata();
    atomic_store(result, (unint64_t *)&qword_1EB97E840);
  }
  return result;
}

void sub_1B63B8C3C()
{
  if (!qword_1EB97E818)
  {
    uint64_t v0 = (uint64_t (*)(uint64_t, void, unint64_t))MEMORY[0x1E4FBC2F8];
    sub_1B63958F8(255, (unint64_t *)&qword_1EB980EF0, MEMORY[0x1E4FBC2F8]);
    sub_1B6666340((unint64_t *)&unk_1EB980EE0, (unint64_t *)&qword_1EB980EF0, v0);
    unint64_t v1 = type metadata accessor for BasicAnimation();
    if (!v2) {
      atomic_store(v1, (unint64_t *)&qword_1EB97E818);
    }
  }
}

void sub_1B63B8CF0()
{
  if (!qword_1EB97E810)
  {
    uint64_t v0 = (uint64_t (*)(uint64_t, void, unint64_t))MEMORY[0x1E4FBC2A8];
    sub_1B63958F8(255, (unint64_t *)&qword_1EB980EB0, MEMORY[0x1E4FBC2A8]);
    sub_1B6666340(&qword_1EB980EA8, (unint64_t *)&qword_1EB980EB0, v0);
    unint64_t v1 = type metadata accessor for BasicAnimation();
    if (!v2) {
      atomic_store(v1, (unint64_t *)&qword_1EB97E810);
    }
  }
}

void sub_1B63B8DA4()
{
  if (!qword_1EB97E800)
  {
    uint64_t v0 = (uint64_t (*)(uint64_t, void, unint64_t))MEMORY[0x1E4FBC280];
    sub_1B63958F8(255, &qword_1EB980E90, MEMORY[0x1E4FBC280]);
    sub_1B6666340((unint64_t *)&unk_1EB980E80, &qword_1EB980E90, v0);
    unint64_t v1 = type metadata accessor for BasicAnimation();
    if (!v2) {
      atomic_store(v1, (unint64_t *)&qword_1EB97E800);
    }
  }
}

uint64_t assignWithTake for ShaderFileAsset(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  swift_bridgeObjectRelease();
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  swift_bridgeObjectRelease();
  uint64_t v5 = *(void *)(a2 + 40);
  int v6 = *(void **)(a1 + 32);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);

  *(void *)(a1 + 40) = v5;
  return a1;
}

void sub_1B63B8EC4(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0xE000000000000000;
  a1[2] = 0;
  a1[3] = 0xE000000000000000;
  a1[4] = 0;
  a1[5] = 0;
}

uint64_t sub_1B63B8ED8(uint64_t a1)
{
  return sub_1B639E9BC(a1, (void (*)(void))type metadata accessor for OSLogger, &qword_1EB997FF0);
}

ValueMetadata *type metadata accessor for WorldCounters()
{
  return &type metadata for WorldCounters;
}

uint64_t sub_1B63B8F08@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = result;
  if (result)
  {
    unsigned int v4 = sub_1B6A6C7A8();
    int v42 = vfx_counters.addCounter(name:scope:kind:color:)("CPU time", 8, 2, 0, 0, v4, v2);
    int v41 = vfx_counters.addCounter(name:scope:kind:)(0x6164705520555043, 0xEF656D6974206574, 0, 0, v2);
    int v40 = vfx_counters.addCounter(name:scope:kind:)(0x646E655220555043, 0xEF656D6974207265, 0, 0, v2);
    int v39 = vfx_counters.addCounter(name:scope:kind:)(0x656D697420555047, 0xE800000000000000, 0, 0, v2);
    int v38 = vfx_counters.addCounter(name:scope:kind:)(0x6164705520555047, 0xEF656D6974206574, 0, 0, v2);
    int v37 = vfx_counters.addCounter(name:scope:kind:)(0x646E655220555047, 0xEF656D6974207265, 0, 0, v2);
    int v36 = vfx_counters.addCounter(name:scope:kind:)(0x6574614C20555047, 0xEB0000000079636ELL, 0, 0, v2);
    int v35 = vfx_counters.addCounter(name:scope:kind:)(0x6552206B636F6C43, 0xEB00000000746573, 1, 1, v2);
    int v34 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000010, 0x80000001B6F44340, 0, 1, v2);
    int v33 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000012, 0x80000001B6F44360, 0, 1, v2);
    int v32 = vfx_counters.addCounter(name:scope:kind:)(0x4320797469746E45, 0xEC000000746E756FLL, 1, 1, v2);
    int v31 = vfx_counters.addCounter(name:scope:kind:)(0x6F43206B6E756843, 0xEB00000000746E75, 1, 1, v2);
    int v30 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000010, 0x80000001B6F44380, 1, 2, v2);
    int v29 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000016, 0x80000001B6F443A0, 0, 2, v2);
    int v28 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000015, 0x80000001B6F443C0, 0, 2, v2);
    int v5 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000019, 0x80000001B6F443E0, 0, 2, v2);
    int v6 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000021, 0x80000001B6F44400, 0, 2, v2);
    int v7 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000020, 0x80000001B6F44430, 0, 2, v2);
    int v8 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000017, 0x80000001B6F44460, 0, 2, v2);
    int v9 = vfx_counters.addCounter(name:scope:kind:)(0x3E2D206B6E756843, 0xED00006174614420, 0, 2, v2);
    int v10 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000019, 0x80000001B6F44480, 0, 2, v2);
    int v11 = vfx_counters.addCounter(name:scope:kind:)(0xD000000000000010, 0x80000001B6F444A0, 1, 1, v2);
    int v12 = vfx_counters.addCounter(name:scope:kind:)(0x2065727574786554, 0xED0000746E756F43, 1, 1, v2);
    unint64_t result = vfx_counters.addCounter(name:scope:kind:)(0x2065727574786554, 0xEE0079726F6D654DLL, 1, 2, v2);
    int v14 = v28;
    int v13 = v29;
    int v16 = v30;
    int v15 = v31;
    int v17 = v32;
    int v18 = v33;
    int v20 = v34;
    int v19 = v35;
    int v22 = v36;
    int v21 = v37;
    int v24 = v38;
    int v23 = v39;
    int v26 = v40;
    int v25 = v41;
    int v27 = v42;
  }
  else
  {
    int v27 = 0;
    int v25 = 0;
    int v26 = 0;
    int v23 = 0;
    int v24 = 0;
    int v21 = 0;
    int v22 = 0;
    int v19 = 0;
    int v20 = 0;
    int v18 = 0;
    int v17 = 0;
    int v15 = 0;
    int v16 = 0;
    int v13 = 0;
    int v14 = 0;
    int v5 = 0;
    int v6 = 0;
    int v7 = 0;
    int v8 = 0;
    int v9 = 0;
    int v10 = 0;
    int v11 = 0;
    int v12 = 0;
  }
  *(void *)a2 = v2;
  *(_DWORD *)(a2 + 8) = v27;
  *(_DWORD *)(a2 + 12) = v25;
  *(_DWORD *)(a2 + 16) = v26;
  *(_DWORD *)(a2 + 20) = v23;
  *(_DWORD *)(a2 + 24) = v24;
  *(_DWORD *)(a2 + 28) = v21;
  *(_DWORD *)(a2 + 32) = v22;
  *(_DWORD *)(a2 + 36) = v19;
  *(_DWORD *)(a2 + 40) = v20;
  *(_DWORD *)(a2 + 44) = v18;
  *(_DWORD *)(a2 + 48) = v17;
  *(_DWORD *)(a2 + 52) = v15;
  *(_DWORD *)(a2 + 56) = v16;
  *(_DWORD *)(a2 + 60) = v13;
  *(_DWORD *)(a2 + 64) = v14;
  *(_DWORD *)(a2 + 68) = v5;
  *(_DWORD *)(a2 + 72) = v6;
  *(_DWORD *)(a2 + 76) = v7;
  *(_DWORD *)(a2 + 80) = v8;
  *(_DWORD *)(a2 + 84) = v9;
  *(_DWORD *)(a2 + 88) = v10;
  *(_DWORD *)(a2 + 92) = v11;
  *(_DWORD *)(a2 + 96) = v12;
  *(_DWORD *)(a2 + 100) = result;
  return result;
}

uint64_t sub_1B63B9468(uint64_t a1, uint64_t a2)
{
  return sub_1B63B153C(a1, a2, (unint64_t *)&unk_1EB9854E0, (uint64_t (*)(uint64_t))type metadata accessor for DepthStencilCache, (uint64_t (*)(uint64_t, uint64_t))type metadata accessor for WeakReference);
}

uint64_t sub_1B63B949C(uint64_t a1)
{
  sub_1B63B952C(0, &qword_1EB9854F0, 255, (uint64_t (*)(uint64_t))sub_1B6CE27F0, MEMORY[0x1E4FBB718]);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

void sub_1B63B952C(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t (*a4)(uint64_t), uint64_t (*a5)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v8 = a4(a3);
    unint64_t v9 = a5(a1, v8);
    if (!v10) {
      atomic_store(v9, a2);
    }
  }
}

void sub_1B63B9590(uint64_t a1)
{
}

void sub_1B63B95C8(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t (*a4)(uint64_t), uint64_t (*a5)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v8 = a4(a3);
    unint64_t v9 = a5(a1, v8);
    if (!v10) {
      atomic_store(v9, a2);
    }
  }
}

void sub_1B63B962C(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t type metadata accessor for TextureSystem()
{
  return self;
}

uint64_t sub_1B63B96B0()
{
  uint64_t v0 = swift_allocObject();
  sub_1B62A1254();
  return v0;
}

const char *sub_1B63B96E8()
{
  return "TextureSystem";
}

id sub_1B63B9700(void *a1)
{
  return sub_1B63B9710(a1, *(unsigned char *)(v1 + 16), *(void *)(v1 + 24), *(void *)(v1 + 32), *(void *)(v1 + 40));
}

id sub_1B63B9710(void *a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((a2 & 1) != 0 || (id result = objc_msgSend(a1, sel_status), result == (id)5))
  {
    id result = (id)swift_weakLoadStrong();
    if (result)
    {
      unint64_t v9 = (void *)swift_allocObject();
      _OWORD v9[2] = a4;
      v9[3] = a3;
      v9[4] = a5;
      swift_retain();
      swift_bridgeObjectRetain();
      swift_retain();
      sub_1B69DECC8((uint64_t)sub_1B6D0B124, (uint64_t)v9);
      swift_release();
      return (id)swift_release();
    }
  }
  return result;
}

void *assignWithTake for TextureClient(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  swift_bridgeObjectRelease();
  return a1;
}

uint64_t type metadata accessor for SDFFileSystem()
{
  return self;
}

uint64_t sub_1B63B9850()
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  type metadata accessor for SDFFileSystem();
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v7 = qword_1EB997A18;
  int v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  char v11 = 2;
  uint64_t v12 = 0;
  swift_retain();
  sub_1B63A67D4((uint64_t)v4);
  swift_release();
  sub_1B636E080();
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for SDFRuntimeData;
  *(void *)(inited + 40) = &off_1F0F656C8;
  sub_1B62AD184(v5);
  swift_setDeallocating();
  sub_1B62CA064((uint64_t)v4);
  long long v2 = v5[1];
  *(_OWORD *)(v0 + 16) = v5[0];
  *(_OWORD *)(v0 + 32) = v2;
  *(void *)(v0 + 48) = v6;
  return v0;
}

const char *sub_1B63B9998()
{
  return "SDFFile";
}

uint64_t sub_1B63B99B0(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  uint64_t v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

void sub_1B63B9A7C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(v2 + 24);
  uint64_t v4 = (const void *)*MEMORY[0x1E4F1D418];
  v10[4] = a1;
  v10[5] = a2;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 1107296256;
  v10[2] = sub_1B639AA00;
  v10[3] = &unk_1F0FB7FA8;
  uint64_t v5 = _Block_copy(v10);
  uint64_t v6 = v3;
  swift_retain();
  swift_release();
  CFRunLoopPerformBlock(v6, v4, v5);
  _Block_release(v5);

  uint64_t v7 = *(void *)(v2 + 16);
  int v8 = *(void **)(v7 + OBJC_IVAR____TtCC3VFX13RunloopThreadP33_C5453D25073BE51EF98804DB40F9E2866Thread_currentRunloop);
  if (v8)
  {
    char v9 = v8;
    if (CFRunLoopIsWaiting(v9))
    {
      CFRunLoopSourceSignal(*(CFRunLoopSourceRef *)(v7
                                                  + OBJC_IVAR____TtCC3VFX13RunloopThreadP33_C5453D25073BE51EF98804DB40F9E2866Thread_runloopSource));
      CFRunLoopWakeUp(v9);
    }
  }
}

uint64_t sub_1B63B9B90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(v3 + 24) = 0;
  id v5 = objc_msgSend(objc_allocWithZone((Class)type metadata accessor for RunloopThread.Thread()), sel_init);
  *(void *)(v3 + 16) = v5;
  id v6 = v5;
  uint64_t v7 = (void *)sub_1B6E31768();
  swift_bridgeObjectRelease();
  objc_msgSend(v6, sel_setName_, v7);

  objc_msgSend(*(id *)(v3 + 16), sel_setQualityOfService_, a3);
  sub_1B6ADAA84();
  return v3;
}

uint64_t sub_1B63B9C44@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = v2;
  id v6 = *v2;
  uint64_t v7 = (uint64_t)*v2 + 41;
  uint64_t v8 = (*v2)[8];
  unint64_t v9 = v6[9];
  uint64_t v10 = sub_1B639775C(a1);
  uint64_t v11 = v10;
  if (v9 >= 0x10)
  {
    uint64_t v13 = (char *)(v7 + v8);
    uint64_t v14 = *(void *)(v11 + 16);
    uint64_t v15 = sub_1B62F79D4(v13, v9 >> 4);
    uint64_t v12 = v15;
    if (v14)
    {
      uint64_t v31 = v15;
      sub_1B62F8084(v11);
      uint64_t v12 = v31;
    }
    else
    {
      swift_bridgeObjectRelease();
    }
  }
  else
  {
    uint64_t v12 = v10;
  }
  uint64_t v16 = v6[10];
  int64_t v17 = v6[11];
  uint64_t v18 = sub_1B62F79C8(0, *(void *)(a1 + 16));
  uint64_t v19 = v18;
  if (v17)
  {
    int v20 = (char *)(v7 + v16);
    uint64_t v21 = *(void *)(v19 + 16);
    uint64_t v22 = sub_1B62F7C94(v20, v17);
    uint64_t v23 = v22;
    if (v21)
    {
      uint64_t v32 = v22;
      sub_1B62F81D8(v19);
      uint64_t v23 = v32;
    }
    else
    {
      swift_bridgeObjectRelease();
    }
  }
  else
  {
    uint64_t v23 = v18;
  }
  int v24 = *((_DWORD *)v3 + 2);
  char v25 = *((unsigned char *)v3 + 12);
  int v26 = v3[2];
  char v27 = *((unsigned char *)v3 + 24);
  int v30 = v3[4];
  uint64_t v28 = sub_1B62C8668((char *)(v12 + 32), *(void *)(v12 + 16), (char *)(v23 + 32), *(void *)(v23 + 16), (char *)(v7 + v6[12]), (unint64_t)v6[13] >> 4, (char *)(v7 + v6[14]), v6[15] / 0x18u);
  swift_bridgeObjectRelease();
  uint64_t result = swift_bridgeObjectRelease();
  *(void *)a2 = v28;
  *(_DWORD *)(a2 + 8) = v24;
  *(unsigned char *)(a2 + 12) = v25;
  *(void *)(a2 + 16) = v26;
  *(unsigned char *)(a2 + 24) = v27;
  *(void *)(a2 + 32) = v30;
  return result;
}

uint64_t type metadata accessor for GlobalsSystem()
{
  return self;
}

const char *sub_1B63B9DFC()
{
  return "GlobalsSystem";
}

unint64_t sub_1B63B9E10()
{
  unint64_t result = qword_1EB97E570;
  if (!qword_1EB97E570)
  {
    sub_1B62BB5E4(255, &qword_1EB97E578, (void (*)(void))sub_1B62A2730, (void (*)(void))sub_1B6878CE8);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97E570);
  }
  return result;
}

void sub_1B63B9EA0()
{
  if (!qword_1EB981058)
  {
    _s11MetadataSetCMa();
    sub_1B62BAC90(&qword_1EB981158, (void (*)(uint64_t))_s11MetadataSetCMa);
    sub_1B62BAC90(&qword_1EB981150, (void (*)(uint64_t))_s11MetadataSetCMa);
    unint64_t v0 = type metadata accessor for FastDictCoder();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB981058);
    }
  }
}

void sub_1B63B9F9C()
{
  if (!qword_1EB97E548)
  {
    type metadata accessor for GraphScriptingConfig.ScriptInfo();
    sub_1B687BCA8();
    sub_1B687BCFC();
    sub_1B67FC164();
    sub_1B62BAC90(&qword_1EB97F338, (void (*)(uint64_t))type metadata accessor for GraphScriptingConfig.ScriptInfo);
    sub_1B62BAC90(&qword_1EB97F330, (void (*)(uint64_t))type metadata accessor for GraphScriptingConfig.ScriptInfo);
    unint64_t v0 = type metadata accessor for FastDictCoder();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB97E548);
    }
  }
}

uint64_t sub_1B63BA0A8()
{
  uint64_t result = sub_1B6E31288();
  if (v1 <= 0x3F)
  {
    uint64_t result = type metadata accessor for ScriptingConfiguration();
    if (v2 <= 0x3F) {
      return swift_updateClassMetadata2();
    }
  }
  return result;
}

id sub_1B63BA2B0(void (*a1)(void), uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = OBJC_IVAR____TtC3VFX13EntityManager_runtimeThread;
  uint64_t v7 = *(void *)(v3 + OBJC_IVAR____TtC3VFX13EntityManager_runtimeThread);
  if (v7)
  {
    uint64_t v8 = *(_opaque_pthread_t **)(v7 + 144);
    swift_retain();
    unint64_t v9 = pthread_self();
    if (pthread_equal(v8, v9))
    {
      sub_1B63BADF0();
      a1();
      sub_1B69E214C(v3);
    }
    else
    {
      sub_1B688753C((void (*)(uint64_t))a1);
    }
    return (id)swift_release();
  }
  else
  {
    uint64_t v10 = OBJC_IVAR____TtC3VFX13EntityManager_syncLock;
    objc_msgSend(*(id *)(v3 + OBJC_IVAR____TtC3VFX13EntityManager_syncLock), sel_lock);
    if (*(void *)(v3 + v6))
    {
      sub_1B63BA2B0(a1, a2);
    }
    else
    {
      sub_1B63BADF0();
      a1();
      sub_1B69E214C(v3);
    }
    return objc_msgSend(*(id *)(v3 + v10), sel_unlock);
  }
}

void sub_1B63BA400(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t))
{
  if (os_unfair_lock_trylock(*(os_unfair_lock_t *)(a1 + 376)))
  {
    os_unfair_lock_lock(*(os_unfair_lock_t *)(a1 + 344));
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 376));
    if ((*(unsigned char *)(a1 + 121) & 1) != 0 || *(void *)(a1 + 240) < *(void *)(a1 + 88))
    {
      sub_1B63BACC8(a1, a3, a4);
      os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 344));
      return;
    }
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 344));
  }
  sub_1B6E32BE8();
  __break(1u);
}

uint64_t sub_1B63BA4F0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, __int16 a9, void *a10)
{
  int64_t v17 = *(os_unfair_lock_s **)(a1 + 376);
  swift_retain();
  if (os_unfair_lock_trylock(v17))
  {
    os_unfair_lock_lock(*(os_unfair_lock_t *)(a1 + 344));
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 376));
    if ((*(unsigned char *)(a1 + 121) & 1) != 0 || *(void *)(a1 + 240) < *(void *)(a1 + 88))
    {
      swift_retain();
      sub_1B62FC758(a1, a3, a4, a5, a6, a7, a8, a9, a10);
      swift_release();
      os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 344));
      return swift_release_n();
    }
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(a1 + 344));
  }
  swift_release_n();
  uint64_t result = sub_1B6E32BE8();
  __break(1u);
  return result;
}

void sub_1B63BA64C(signed int a1, unint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t))
{
  if (*(unsigned char *)(*(void *)(*(void *)(a4 + 80) + 8 * a1 + 32) + 200) == 1) {
    *(unsigned char *)(a4 + OBJC_IVAR____TtC3VFX13EntityManager_shouldNotifyEntityEvent) = 1;
  }
  os_unfair_lock_lock(*(os_unfair_lock_t *)(a4 + 128));
  uint64_t v12 = *(void *)(a4 + 96);
  uint64_t v13 = *(void *)(v12 + 40 * a1 + 32);
  uint64_t v14 = *(void *)(v13 + 16);
  if (v14)
  {
    uint64_t v15 = (int *)(v13 + 32);
    while (1)
    {
      uint64_t v16 = *v15++;
      uint64_t v17 = *(void *)(*(void *)(a4 + 136) + 32 + 8 * v16);
      if (*(void *)(v17 + 240) != *(void *)(v17 + 232)) {
        break;
      }
      if (!--v14) {
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    sub_1B6358028(a1);
    uint64_t v12 = *(void *)(a4 + 96);
  }
  uint64_t v18 = v12 + 40 * a1;
  uint64_t v19 = 36;
  if (a3) {
    uint64_t v19 = 32;
  }
  int v20 = *(_DWORD *)(v18 + v19 + 32);
  uint64_t v21 = HIDWORD(a2) & 1;
  if (v20 == -1)
  {
    uint64_t v22 = a2;
  }
  else
  {
    uint64_t v22 = a2;
    sub_1B68E7150(*(void *)(*(void *)(a4 + 136) + 8 * v20 + 32), a2 | (unint64_t)(v21 << 32), a5, a6, &v38);
    if (v38)
    {
      uint64_t v23 = *(os_unfair_lock_s **)(a4 + 128);
      os_unfair_lock_unlock(v23);
      return;
    }
  }
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(a4 + 128));
  int v24 = (void *)(a4 + 136);
  swift_retain();
  int v25 = sub_1B628A6F0((uint64_t *)(a4 + 136), a4, v22 | (v21 << 32), a1, a3 & 1);
  swift_release();
  int v26 = *(void **)(a4 + 96);
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  *(void *)(a4 + 96) = v26;
  if ((isUniquelyReferenced_nonNull_native & 1) == 0)
  {
    int v26 = sub_1B6C16694(v26);
    *(void *)(a4 + 96) = v26;
  }
  uint64_t v28 = v26 + 4;
  int v29 = (char **)&v26[5 * a1 + 4];
  if (a3)
  {
    int v30 = *v29;
    char v31 = swift_isUniquelyReferenced_nonNull_native();
    *int v29 = v30;
    uint64_t v32 = a6;
    if ((v31 & 1) == 0)
    {
      int v30 = sub_1B62B7EA0(0, *((void *)v30 + 2) + 1, 1, v30);
      *int v29 = v30;
    }
    unint64_t v34 = *((void *)v30 + 2);
    unint64_t v33 = *((void *)v30 + 3);
    if (v34 >= v33 >> 1)
    {
      int v30 = sub_1B62B7EA0(v33 > 1, v34 + 1, 1, v30);
      *int v29 = v30;
    }
    *((void *)v30 + 2) = v34 + 1;
    *(_DWORD *)&v30[4 * v34 + 32] = v25;
    LODWORD(v28[5 * a1 + 4]) = v25;
  }
  else
  {
    uint64_t v32 = a6;
    int v35 = &v28[5 * a1];
    uint64_t v36 = v35[1];
    sub_1B68E84A8(v36, v36, v25);
    v35[1] = v36 + 1;
    *((_DWORD *)v35 + 9) = v25;
  }
  LOBYTE(v28[5 * a1 + 3]) = 1;
  sub_1B63BA400(*(void *)(*v24 + 8 * v25 + 32), a3 & 1, a5, v32);
}

uint64_t sub_1B63BA93C(uint64_t result)
{
  uint64_t v2 = *(void *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_entityCapacity);
  uint64_t v3 = *(void *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager__entries);
  if (v2 - 1 != result)
  {
    uint64_t v4 = OBJC_IVAR____TtC3VFX13EntityManager_generationSalt;
    int v5 = result + 1;
    do
    {
      int v6 = *(_DWORD *)(v1 + v4);
      uint64_t v7 = (_DWORD *)(v3 + 12 * (v5 - 1));
      *uint64_t v7 = v5;
      v7[1] = -1;
      _OWORD v7[2] = v6;
      ++v5;
    }
    while (v2 != v5);
  }
  uint64_t v8 = v3 + 12 * v2;
  int v9 = *(_DWORD *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_generationSalt);
  *(void *)(v8 - 12) = -1;
  *(_DWORD *)(v8 - 4) = v9;
  *(_DWORD *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager_firstFreeIndex) = result;
  return result;
}

uint64_t sub_1B63BA9C0(char a1, char a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  sub_1B63998E8(0, (unint64_t *)&qword_1EB980BA0, (uint64_t (*)(uint64_t))sub_1B663C11C, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E76B30;
  *(void *)(inited + 32) = &type metadata for DrawCallComponent;
  *(void *)(inited + 40) = &off_1F0F709E8;
  *(void *)(inited + 48) = &type metadata for WorldAABB;
  *(void *)(inited + 56) = &off_1F0FAAB28;
  if (a2)
  {
    swift_bridgeObjectRetain();
    int v6 = (char *)inited;
    if ((swift_isUniquelyReferenced_nonNull_native() & 1) == 0) {
      int v6 = sub_1B62D1B88(0, 3, 1, (char *)inited);
    }
    unint64_t v8 = *((void *)v6 + 2);
    unint64_t v7 = *((void *)v6 + 3);
    if (v8 >= v7 >> 1) {
      int v6 = sub_1B62D1B88(v7 > 1, v8 + 1, 1, v6);
    }
    *((void *)v6 + 2) = v8 + 1;
    int v9 = &v6[16 * v8];
    *((void *)v9 + 4) = &type metadata for VFXDrawCallHandler;
    *((void *)v9 + 5) = &off_1F0F7B508;
    swift_bridgeObjectRelease();
    uint64_t inited = (uint64_t)v6;
  }
  sub_1B62C6034(0, (unint64_t *)&qword_1EB980B60, (unint64_t *)&qword_1EB97E840, (uint64_t)&protocol descriptor for ClassComponent, MEMORY[0x1E4FBBE00]);
  uint64_t v10 = swift_initStackObject();
  *(_OWORD *)(v10 + 16) = xmmword_1B6E77050;
  *(void *)(v10 + 56) = &type metadata for AnonymousEntity;
  *(void *)(v10 + 64) = &off_1F0F67E08;
  uint64_t v11 = sub_1B6397958(1, 2, 1, (void *)v10);
  int v25 = &type metadata for DrawCallLayer;
  int v26 = &off_1F0F5E758;
  LOBYTE(v24) = a1;
  _OWORD v11[2] = 2;
  sub_1B62C15C4(&v24, (uint64_t)(v11 + 9));
  uint64_t v12 = v2 + OBJC_IVAR____TtC3VFX13EntityManager_lock;
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v2 + OBJC_IVAR____TtC3VFX13EntityManager_lock + 24));
  uint64_t v13 = sub_1B637F1F8(inited);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  uint64_t v14 = sub_1B63B7CC4((uint64_t)v13, (uint64_t)v11);
  uint64_t v16 = v15;
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v17 = sub_1B637FE60(v14);
  if ((v18 & 1) != 0 || (unint64_t v19 = sub_1B63581E4(v16, v17), (v19 & 0x100000000) != 0))
  {
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    int v20 = sub_1B637C7BC(v14, v16, (uint64_t)v13, (uint64_t)v11);
    swift_bridgeObjectRelease_n();
  }
  else
  {
    int v20 = v19;
  }
  swift_bridgeObjectRelease();
  uint64_t v21 = *(void *)(*(void *)(v2 + 80) + 8 * v20 + 32);
  uint64_t v22 = *(os_unfair_lock_s **)(v12 + 24);
  swift_retain();
  os_unfair_lock_unlock(v22);
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  return v21;
}

uint64_t sub_1B63BACC8(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t))
{
  long long v6 = *(_OWORD *)(a2 + 16);
  v15[0] = *(_OWORD *)a2;
  v15[1] = v6;
  long long v7 = *(_OWORD *)(a2 + 48);
  id v15[2] = *(_OWORD *)(a2 + 32);
  v15[3] = v7;
  uint64_t v9 = sub_1B63B3CE8(v15);
  uint64_t v10 = *(void *)(a2 + 8);
  uint64_t v11 = v8 - v9;
  uint64_t v12 = v10 - *(void *)a2;
  if (v8 - v9 < 1)
  {
    if (v12 > 0 || v11 >= v12) {
      goto LABEL_9;
    }
  }
  else if (v12 < 0 || v12 >= (unint64_t)v11)
  {
LABEL_9:
    uint64_t v10 = v11 + *(void *)a2;
  }
  *(void *)a2 = v10;
  return a3(a1, v9, v8);
}

uint64_t sub_1B63BAD70(void *a1)
{
  return sub_1B63BAD88(a1);
}

uint64_t sub_1B63BAD88(void *a1)
{
  return sub_1B63BADA4(a1, *(void *)(v1 + 16));
}

uint64_t sub_1B63BADA4(void *a1, uint64_t a2)
{
  swift_retain();
  uint64_t result = swift_release();
  *a1 = a2;
  return result;
}

void sub_1B63BADF0()
{
  uint64_t v1 = *(uint64_t **)(v0 + OBJC_IVAR____TtC3VFX13EntityManager_commandQueues);
  if (v1)
  {
    uint64_t v2 = *(void *)(v0 + OBJC_IVAR____TtC3VFX13EntityManager_commandQueues + 8);
    if (v2)
    {
      uint64_t v3 = 8 * v2;
      do
      {
        uint64_t v4 = *v1++;
        ecs_stack_allocator_push_snapshot(*(void *)(v4 + 32));
        v3 -= 8;
      }
      while (v3);
    }
  }
  uint64_t v5 = *(void *)(v0 + 216);
  *(void *)(v0 + 216) = v5 + 1;
  if (!v5)
  {
    sub_1B6376EB8();
  }
}

void sub_1B63BAE78(void *a1@<X8>)
{
  *a1 = MEMORY[0x1E4FBC868];
}

unint64_t sub_1B63BAE8C()
{
  unint64_t result = qword_1EB97E410;
  if (!qword_1EB97E410)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97E410);
  }
  return result;
}

unint64_t sub_1B63BAEE0()
{
  unint64_t result = qword_1EB97E408;
  if (!qword_1EB97E408)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97E408);
  }
  return result;
}

uint64_t sub_1B63BAF34(uint64_t result)
{
  if (result != 0xFFFFFFFFLL
    && result << 32 >= (uint64_t)0xFFFFFFFF00000001
    && (int)result < *(void *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager__entries + 8))
  {
    uint64_t v2 = *(void *)(v1 + OBJC_IVAR____TtC3VFX13EntityManager__entries);
    if (HIDWORD(result) == -1 || *(_DWORD *)(v2 + 12 * (int)result + 8) == HIDWORD(result)) {
      return sub_1B635ACD8(*(uint64_t **)(*(void *)(v1 + 136) + 8 * *(int *)(v2 + 12 * (int)result) + 32));
    }
  }
  return result;
}

void sub_1B63BAFF0(void **a1)
{
}

void sub_1B63BB008(void **a1)
{
  sub_1B63BB024(a1, *(void **)(v1 + 16));
}

void sub_1B63BB024(void **a1, void *a2)
{
  uint64_t v4 = *a1;
  id v5 = a2;

  *a1 = a2;
}

void sub_1B63BB068()
{
  qword_1EB997A98 = MEMORY[0x1E4FBC860];
}

id sub_1B63BB07C()
{
  id result = objc_msgSend(objc_allocWithZone(MEMORY[0x1E4F28FD0]), sel_init);
  qword_1EB997960 = (uint64_t)result;
  return result;
}

uint64_t type metadata accessor for EmitterWarmup()
{
  return self;
}

uint64_t sub_1B63BB0D4()
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v16 = qword_1EB997A18;
  int v17 = 0;
  char v18 = 2;
  uint64_t v19 = 0;
  char v20 = 2;
  uint64_t v21 = 0;
  swift_retain();
  sub_1B629AD2C(1, 2, (uint64_t)v6);
  swift_release();
  long long v1 = v6[1];
  *(_OWORD *)(v0 + 16) = v6[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v7;
  uint64_t v2 = qword_1EB997A18;
  sub_1B62E0A98(0, (unint64_t *)&qword_1EB980C70, (uint64_t (*)(uint64_t))sub_1B6642FC0, MEMORY[0x1E4FBBE00]);
  uint64_t inited = swift_initStackObject();
  *(_OWORD *)(inited + 16) = xmmword_1B6E77050;
  *(void *)(inited + 32) = &type metadata for OldEvent;
  *(void *)(inited + 40) = &off_1F0FA6C00;
  uint64_t v10 = v2;
  int v11 = 0;
  char v12 = 2;
  uint64_t v13 = 0;
  char v14 = 2;
  uint64_t v15 = 0;
  swift_retain();
  sub_1B62F776C(inited, 1, (uint64_t)v8);
  swift_setDeallocating();
  swift_release();
  long long v4 = v8[1];
  *(_OWORD *)(v0 + 56) = v8[0];
  *(_OWORD *)(v0 + 72) = v4;
  *(void *)(v0 + 88) = v9;
  return v0;
}

uint64_t sub_1B63BB288(uint64_t a1, uint64_t a2)
{
  return sub_1B636B0FC(a1, a2, (void (*)(void))type metadata accessor for EmitterWarmup, 96, (void (*)(void))sub_1B63BB0D4);
}

const char *sub_1B63BB2B8()
{
  return "EmitterWarmup";
}

uint64_t type metadata accessor for CullingSystem()
{
  return self;
}

const char *sub_1B63BB2F4()
{
  return "Culling";
}

uint64_t sub_1B63BB308(uint64_t a1)
{
  uint64_t v2 = v1;
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v1 + 48));
  uint64_t v4 = *(void *)(v1 + 64);
  if (*(void *)(v4 + 16) && (unint64_t v5 = sub_1B62C1A30(a1), (v6 & 1) != 0))
  {
    uint64_t v7 = *(void *)(*(void *)(v4 + 56) + 8 * v5);
    swift_bridgeObjectRetain();
  }
  else
  {
    uint64_t v7 = 0;
  }
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v2 + 48));
  return v7;
}

void *sub_1B63BB378()
{
  return sub_1B63BB380(*(void (**)(void *__return_ptr))(v0 + 16));
}

void *sub_1B63BB380(void (*a1)(void *__return_ptr))
{
  a1(v2);
  return sub_1B6381B78(v2, (void (*)(void, void, void, void, void, void, void, void, void, void, void, void, void, void, void))sub_1B6381C38);
}

uint64_t sub_1B63BB408()
{
  uint64_t v1 = v0;
  os_unfair_lock_lock(*(os_unfair_lock_t *)(v0 + 48));
  uint64_t v2 = *(void *)(v0 + 144) + 1;
  *(void *)(v0 + 144) = v2;
  char isUniquelyReferenced_nonNull_native = swift_isUniquelyReferenced_nonNull_native();
  uint64_t v6 = *(void *)(v0 + 64);
  *(void *)(v0 + 64) = 0x8000000000000000;
  sub_1B63969D0(MEMORY[0x1E4FBC868], v2, isUniquelyReferenced_nonNull_native);
  *(void *)(v0 + 64) = v6;
  swift_bridgeObjectRelease();
  uint64_t v4 = *(void *)(v0 + 144);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v1 + 48));
  return v4;
}

__n128 initializeWithTake for TextureCache.WeakStorage.CPU(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = swift_unknownObjectWeakTakeInit();
  *(void *)(v3 + 8) = *(void *)(a2 + 8);
  *(_OWORD *)(v3 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(v3 + 32) = *(void *)(a2 + 32);
  *(_OWORD *)(v3 + 56) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(v3 + 72) = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(v3 + 88) = *(_OWORD *)(a2 + 88);
  *(_OWORD *)(v3 + 104) = *(_OWORD *)(a2 + 104);
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(v3 + 40) = result;
  *(void *)(v3 + 120) = *(void *)(a2 + 120);
  return result;
}

uint64_t storeEnumTagSinglePayload for TextureCache.WeakStorage.CPU(uint64_t result, int a2, int a3)
{
  if (a2 < 0)
  {
    *(void *)(result + 120) = 0;
    *(_OWORD *)(result + 104) = 0u;
    *(_OWORD *)(result + 88) = 0u;
    *(_OWORD *)(result + 72) = 0u;
    *(_OWORD *)(result + 56) = 0u;
    *(_OWORD *)(result + 40) = 0u;
    *(_OWORD *)(result + 24) = 0u;
    *(_OWORD *)(result + 8) = 0u;
    *(void *)__n128 result = a2 ^ 0x80000000;
    if (a3 < 0) {
      *(unsigned char *)(result + 128) = 1;
    }
  }
  else
  {
    if ((a3 & 0x80000000) == 0)
    {
      if (!a2) {
        return result;
      }
LABEL_8:
      *(void *)(result + 120) = (a2 - 1);
      return result;
    }
    *(unsigned char *)(result + 128) = 0;
    if (a2) {
      goto LABEL_8;
    }
  }
  return result;
}

uint64_t sub_1B63BB568(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_1B6BCA3B4);
}

uint64_t sub_1B63BB57C(uint64_t a1)
{
  return a1;
}

uint64_t sub_1B63BB5D8(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unint64_t a14)
{
  if (a4 >> 1 != 0xFFFFFFFF || a6 >> 17 || HIDWORD(a14)) {
    return sub_1B6381C38(result, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  }
  return result;
}

uint64_t sub_1B63BB61C(uint64_t a1)
{
  if (qword_1EB9853F0 != -1) {
    swift_once();
  }
  objc_msgSend((id)qword_1EB9853E0, sel_lock);
  if (qword_1EB9853D8 != -1) {
    swift_once();
  }
  uint64_t v2 = off_1EB9853C8;
  if (!*((void *)off_1EB9853C8 + 2) || (unint64_t v3 = sub_1B62C1A30(a1), (v4 & 1) == 0))
  {
    uint64_t v9 = 0;
    char v10 = 1;
    sub_1B63677B8((uint64_t)&v9, (uint64_t (*)(void))sub_1B63B9590);
LABEL_10:
    type metadata accessor for TextureCache();
    swift_allocObject();
    uint64_t v6 = (void *)swift_unknownObjectRetain();
    uint64_t Strong = sub_1B6BCB8C0(v6);
    swift_unknownObjectRelease();
    swift_weakInit();
    swift_weakAssign();
    sub_1B6365FC8((uint64_t)v8, (uint64_t)&v9, (uint64_t (*)(void))sub_1B63B962C);
    char v10 = 0;
    sub_1B6CE0D58((uint64_t)&v9, a1);
    goto LABEL_11;
  }
  sub_1B63675F4(v2[7] + 8 * v3, (uint64_t)&v9, (uint64_t (*)(void))sub_1B63B962C);
  char v10 = 0;
  uint64_t Strong = swift_weakLoadStrong();
  sub_1B63677B8((uint64_t)&v9, (uint64_t (*)(void))sub_1B63B9590);
  if (!Strong) {
    goto LABEL_10;
  }
LABEL_11:
  objc_msgSend((id)qword_1EB9853E0, sel_unlock);
  return Strong;
}

uint64_t sub_1B63BB7EC@<X0>(uint64_t a1@<X8>)
{
  uint64_t v3 = *(void *)(type metadata accessor for TextureCache.TextureKey() - 8);
  return sub_1B63BB860(*(void (**)(long long *__return_ptr, double))(v1 + 16), *(void *)(v1 + 32), v1 + ((*(unsigned __int8 *)(v3 + 80) + 40) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80)), a1);
}

uint64_t sub_1B63BB860@<X0>(void (*a1)(long long *__return_ptr, double)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v9 = type metadata accessor for TextureCache.TextureKey();
  double v11 = MEMORY[0x1F4188790](v9 - 8, v10);
  uint64_t v13 = (char *)&v18[-1] - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  a1(v19, v11);
  if (v4)
  {
    swift_unownedRetainStrong();
    os_unfair_lock_lock(*(os_unfair_lock_t *)(a2 + 48));
    sub_1B63675F4(a3, (uint64_t)v13, (uint64_t (*)(void))type metadata accessor for TextureCache.TextureKey);
    char v14 = sub_1B6366A74(v18, (uint64_t)v13);
    if (*(unsigned __int8 *)(v15 + 152) != 255) {
      sub_1B6BC970C(v4);
    }
    ((void (*)(void *, void))v14)(v18, 0);
    sub_1B63677B8((uint64_t)v13, (uint64_t (*)(void))type metadata accessor for TextureCache.TextureKey);
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(a2 + 48));
    swift_release();
    return swift_willThrow();
  }
  else
  {
    swift_unownedRetainStrong();
    sub_1B6BCAB5C(v19, a3);
    swift_release();
    return sub_1B63619BC(v19, a4);
  }
}

uint64_t type metadata accessor for SkyboxSystem()
{
  return self;
}

const char *sub_1B63BBA10()
{
  return "RenderSkybox";
}

uint64_t type metadata accessor for ShadowSystem()
{
  return self;
}

const char *sub_1B63BBA48()
{
  return "ShadowSystem";
}

uint64_t sub_1B63BBA5C()
{
  return qword_1E9DD2FF8 + 1;
}

uint64_t sub_1B63BBA6C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 176);
  swift_retain();
  sub_1B636E270((uint64_t)&type metadata for ShadowState, (uint64_t)&off_1F0F58468, v1);

  return swift_release();
}

uint64_t type metadata accessor for SDFFileAsset()
{
  uint64_t result = qword_1EB97E2A0;
  if (!qword_1EB97E2A0) {
    return swift_getSingletonMetadata();
  }
  return result;
}

uint64_t type metadata accessor for MovieRuntime(uint64_t a1)
{
  return sub_1B633A29C(a1, &qword_1EB97DFF8);
}

uint64_t type metadata accessor for LookAtSystem()
{
  return self;
}

uint64_t sub_1B63BBB64()
{
  uint64_t v0 = swift_allocObject();
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v5 = qword_1EB997A18;
  int v6 = 0;
  char v7 = 2;
  uint64_t v8 = 0;
  char v9 = 2;
  uint64_t v10 = 0;
  swift_retain();
  sub_1B639F710((uint64_t)v3);
  swift_release();
  long long v1 = v3[1];
  *(_OWORD *)(v0 + 16) = v3[0];
  *(_OWORD *)(v0 + 32) = v1;
  *(void *)(v0 + 48) = v4;
  return v0;
}

const char *sub_1B63BBC28()
{
  return "LookAtSystem";
}

uint64_t sub_1B63BBC40(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = *(void *)(a1 + OBJC_IVAR____TtC3VFX13EntityManager_queryManager);
  swift_getObjectType();
  uint64_t v5 = sub_1B62B6A60();
  int v6 = *(os_unfair_lock_s **)(v4 + 40);
  swift_retain_n();
  os_unfair_lock_lock(v6);
  sub_1B62B6A68(a1, v3);
  swift_release();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  sub_1B6369F00(a1, v5, v3);
  os_unfair_lock_unlock(*(os_unfair_lock_t *)(v4 + 40));
  return swift_release_n();
}

uint64_t type metadata accessor for HiddenSystem()
{
  return self;
}

uint64_t sub_1B63BBD30()
{
  uint64_t v0 = swift_allocObject();
  sub_1B629BEBC();
  return v0;
}

const char *sub_1B63BBD68()
{
  return "HiddenSystem";
}

unint64_t sub_1B63BBD88()
{
  unint64_t result = qword_1EB97DE58;
  if (!qword_1EB97DE58)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97DE58);
  }
  return result;
}

unint64_t sub_1B63BBDDC()
{
  unint64_t result = qword_1EB97DE50;
  if (!qword_1EB97DE50)
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97DE50);
  }
  return result;
}

void sub_1B63BBE30()
{
  sub_1B63BBE38(*(void **)(v0 + 16));
}

void sub_1B63BBE38(void *a1)
{
  id v2 = objc_msgSend(self, sel_currentRunLoop);
  objc_msgSend(a1, sel_addToRunLoop_forMode_, v2, *MEMORY[0x1E4F1C4B0]);
}

void sub_1B63BBEB8()
{
  uint64_t v1 = v0;
  type metadata accessor for DisplayLinkTarget();
  uint64_t v2 = swift_allocObject();
  swift_weakInit();
  swift_weakAssign();
  id v3 = objc_msgSend(self, sel_mainScreen);
  id v4 = objc_msgSend(v3, sel_displayLinkWithTarget_selector_, v2, sel_drawAndReturnError_);

  uint64_t v5 = *(void **)(v1 + 64);
  *(void *)(v1 + 64) = v4;

  int v6 = *(void **)(v1 + 64);
  if (v6)
  {
    id v7 = v6;
    objc_msgSend(v7, sel_setPaused_, objc_msgSend(v7, sel_isPaused));
    if (qword_1EB97D4A8 != -1) {
      swift_once();
    }
    uint64_t v8 = swift_allocObject();
    *(void *)(v8 + 16) = v7;
    id v9 = v7;
    sub_1B63B9A7C((uint64_t)sub_1B63BBE30, v8);
    swift_release();
    uint64_t v10 = self;
    id v11 = objc_msgSend(v10, sel_defaultCenter);
    objc_msgSend(v11, sel_addObserver_selector_name_object_, v1, sel__applicationDidEnterBackground_, *MEMORY[0x1E4FB2640], 0);

    id v12 = objc_msgSend(v10, sel_defaultCenter);
    objc_msgSend(v12, sel_addObserver_selector_name_object_, v1, sel__applicationWillEnterForeground_, *MEMORY[0x1E4FB2730], 0);
    swift_release();
  }
  else
  {
    sub_1B6E32BE8();
    __break(1u);
  }
}

uint64_t type metadata accessor for AssetManager()
{
  return self;
}

char *sub_1B63BC16C()
{
  *(void *)&v0[OBJC_IVAR____TtC3VFX12AssetManager_pathResolver] = 0;
  uint64_t v1 = OBJC_IVAR____TtC3VFX12AssetManager_effectIDToAssetsDirectory;
  *(void *)&v0[v1] = sub_1B6399D7C(MEMORY[0x1E4FBC860]);
  *(void *)&v0[OBJC_IVAR____TtC3VFX12AssetManager_authoringFileManager] = 0;
  v9.receiver = v0;
  v9.super_class = (Class)type metadata accessor for AssetManager();
  uint64_t v2 = (char *)objc_msgSendSuper2(&v9, sel_init);
  id v3 = (objc_class *)type metadata accessor for AssetManagerPathResolver();
  id v4 = objc_allocWithZone(v3);
  swift_unknownObjectWeakInit();
  swift_unknownObjectWeakAssign();
  v8.receiver = v4;
  v8.super_class = v3;
  id v5 = objc_msgSendSuper2(&v8, sel_init);
  int v6 = *(void **)&v2[OBJC_IVAR____TtC3VFX12AssetManager_pathResolver];
  *(void *)&v2[OBJC_IVAR____TtC3VFX12AssetManager_pathResolver] = v5;

  return v2;
}

uint64_t destroy for AssetCatalog()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return swift_unknownObjectRelease();
}

void *_s3VFX12AssetCatalogVwCP_0(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  a1[2] = a2[2];
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  return a1;
}

void *sub_1B63BC2D4()
{
  uint64_t v0 = MEMORY[0x1E4FBC860];
  uint64_t v1 = sub_1B639A184(MEMORY[0x1E4FBC860]);
  uint64_t v5 = v0;
  uint64_t v2 = (void *)sub_1B6E31768();
  id v3 = objc_msgSend(self, sel_bundleWithIdentifier_, v2);

  MEMORY[0x1BA9B3870]();
  if (*(void *)((v5 & 0xFFFFFFFFFFFFFF8) + 0x10) >= *(void *)((v5 & 0xFFFFFFFFFFFFFF8) + 0x18) >> 1) {
    sub_1B6E31C78();
  }
  sub_1B6E31CC8();
  sub_1B6E31C48();
  return v1;
}

void *sub_1B63BC3C8@<X0>(void *a1@<X8>)
{
  unint64_t result = sub_1B63BC2D4();
  *a1 = result;
  a1[1] = v3;
  a1[2] = v4;
  return result;
}

void sub_1B63BC3F8()
{
  if (!qword_1EB9853C0)
  {
    type metadata accessor for NoHeapTextureAllocator();
    unint64_t v0 = type metadata accessor for TexturePool();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB9853C0);
    }
  }
}

void *sub_1B63BC458(uint64_t a1)
{
  v1[4] = objc_msgSend(objc_allocWithZone(MEMORY[0x1E4F35330]), sel_init);
  uint64_t v3 = MEMORY[0x1E4FBC860];
  v1[5] = sub_1B639A184(MEMORY[0x1E4FBC860]);
  v1[2] = a1;
  type metadata accessor for NoHeapTextureAllocator();
  uint64_t v4 = (void *)swift_allocObject();
  swift_weakInit();
  v4[4] = 100;
  v4[5] = v3;
  v4[6] = sub_1B6390E70(v3);
  _OWORD v4[2] = a1;
  v1[3] = v4;
  swift_unknownObjectRetain();
  return v1;
}

void *initializeWithCopy for ShaderCache.SpecializedFunction(void *a1, void *a2)
{
  uint64_t v3 = a2[1];
  *a1 = *a2;
  a1[1] = v3;
  uint64_t v4 = a2[3];
  a1[2] = a2[2];
  a1[3] = v4;
  uint64_t v5 = a2[5];
  a1[4] = a2[4];
  a1[5] = v5;
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  swift_unknownObjectRetain();
  swift_unknownObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

uint64_t sub_1B63BC570()
{
  uint64_t v29 = v0;
  uint64_t v27 = v0 + 16;
  swift_release();
  uint64_t v1 = *(void **)(v0 + 5008);
  uint64_t v2 = *(void *)(v0 + 5000);
  uint64_t v3 = *(void *)(v0 + 4960);
  *(void *)(v0 + 5080) = v1;
  *(void *)(v0 + 5072) = 0;
  *(void *)(v0 + 5064) = v3;
  *(void *)(v0 + 5056) = &unk_1E9DCFFC8;
  *(_OWORD *)(v0 + 5024) = 0u;
  *(_OWORD *)(v0 + 5040) = 0u;
  *(void *)(v0 + 5016) = v2;
  uint64_t v4 = *(void *)(v0 + 4856);
  int v5 = *(unsigned __int8 *)(v0 + 3569);
  uint64_t v6 = *(void *)(v0 + 4840);
  if (*(unsigned char *)(v0 + 3569)) {
    id v7 = "asyncMakeRenderPipelineRefl";
  }
  else {
    id v7 = "asyncMakeRenderPipeline";
  }
  if (*(unsigned char *)(v0 + 3569)) {
    uint64_t v8 = 27;
  }
  else {
    uint64_t v8 = 23;
  }
  uint64_t v9 = sub_1B628EC80();
  sub_1B6384D58(v7, v8, 2u, v9, v10, v4, v0 + 4584);
  id v11 = *(void (**)(uint64_t))(v6 + OBJC_IVAR____TtC3VFX11ShaderCache_onShaderCompilation);
  if (v11)
  {
    if (v11 != (void (*)(uint64_t))1)
    {
      char v18 = *(void **)(v0 + 4848);
      uint64_t v19 = *(os_unfair_lock_s **)(*(void *)(v0 + 4840) + OBJC_IVAR____TtC3VFX11ShaderCache_lock + 24);
      swift_retain();
      os_unfair_lock_lock(v19);
      *(void *)(v0 + 2768) = &type metadata for RenderPipelineDescriptor;
      uint64_t v20 = swift_allocObject();
      *(void *)(v0 + 2744) = v20;
      memcpy((void *)(v20 + 16), v18, 0x328uLL);
      sub_1B63124DC((uint64_t *)v18);
      v11(v0 + 2744);
      _s3VFX14_BinaryDecoderC16SingleValueStoreVwxx_0(v0 + 2744);
      os_unfair_lock_unlock(v19);
      sub_1B67A21D4((unint64_t)v11);
      if (v1) {
        goto LABEL_15;
      }
      goto LABEL_22;
    }
    if (qword_1EB9852D0 != -1) {
      swift_once();
    }
    id v12 = *(const void **)(v0 + 4848);
    v28[0] = 0;
    v28[1] = 0xE000000000000000;
    swift_retain();
    sub_1B6E328C8();
    *(void *)(v0 + 16) = 0;
    *(void *)(v0 + 24) = 0xE000000000000000;
    sub_1B6E31948();
    memcpy((void *)(v0 + 2744), v12, 0x328uLL);
    sub_1B6E32B18();
    uint64_t v13 = *(void *)(v0 + 16);
    uint64_t v14 = *(void *)(v0 + 24);
    int v15 = sub_1B6E32148();
    if (qword_1EB9854F8 != -1) {
      swift_once();
    }
    v28[0] = 0;
    swift_retain();
    sub_1B6B33E34(v15, v28, v13, v14);
    swift_release();
    swift_bridgeObjectRelease();
    swift_release();
  }
  if (v1)
  {
LABEL_15:
    if (v5) {
      uint64_t v16 = 3;
    }
    else {
      uint64_t v16 = 0;
    }
    int v17 = *(void **)(*(void *)(v0 + 4840) + 16);
    *(void *)(v0 + 2640) = v0;
    *(void *)(v0 + 2680) = v27;
    *(void *)(v0 + 2648) = sub_1B638FC88;
    *(void *)(v0 + 2776) = swift_continuation_init();
    *(void *)(v0 + 2744) = MEMORY[0x1E4F143A8];
    *(void *)(v0 + 2752) = 0x40000000;
    *(void *)(v0 + 2760) = sub_1B6392C2C;
    *(void *)(v0 + 2768) = &unk_1E6145CD0;
    objc_msgSend(v17, sel_newRenderPipelineStateWithDescriptor_options_completionHandler_, v1, v16, v0 + 2744);
    return MEMORY[0x1F41881E8](v0 + 2640);
  }
LABEL_22:
  uint64_t v21 = (uint64_t (*)(void, uint64_t))MEMORY[0x1E4FBB718];
  sub_1B6312FE4(v0 + 4408, v0 + 4648, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, MEMORY[0x1E4FBB718]);
  sub_1B6312FE4(v0 + 4648, v0 + 4768, (unint64_t *)&qword_1EB97D6F0, (uint64_t)&type metadata for FunctionDescriptor, v21);
  if (*(void *)(v0 + 4776))
  {
    uint64_t v22 = *(void *)(v0 + 4792);
    swift_unknownObjectRetain();
  }
  else
  {
    uint64_t v22 = 0;
  }
  uint64_t v23 = *(void *)(v0 + 4840);
  sub_1B67A2B7C();
  *(void *)(v0 + 5112) = swift_allocError();
  *(void *)uint64_t v24 = 0xD000000000000015;
  *(void *)(v24 + 8) = 0x80000001B6F352D0;
  *(void *)(v24 + 16) = v22;
  *(unsigned char *)(v24 + 24) = 0;
  swift_willThrow();
  int v25 = *(os_unfair_lock_s **)(v23 + OBJC_IVAR____TtC3VFX11ShaderCache_lock + 24);
  os_unfair_lock_lock(v25);
  sub_1B6385318(v23 + 96);
  os_unfair_lock_unlock(v25);
  sub_1B63852E0(v0 + 4584);
  return MEMORY[0x1F41881D0](v0 + 1296, v0 + 4824, sub_1B6798378, v27);
}

uint64_t sub_1B63BCAA4(uint64_t a1)
{
  uint64_t v4 = (uint64_t *)(v1 + 16);
  uint64_t v5 = *(void *)(v1 + 56);
  uint64_t v6 = *(void *)(v1 + 64);
  char v7 = *(unsigned char *)(v1 + 72);
  uint64_t v8 = *(void *)(v1 + 80);
  uint64_t v9 = (void *)swift_task_alloc();
  *(void *)(v2 + 16) = v9;
  *uint64_t v9 = v2;
  v9[1] = sub_1B638E3C8;
  return sub_1B63BCB70(a1, v4, v5, v6, v7, v8);
}

uint64_t sub_1B63BCB70(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  *(unsigned char *)(v6 + 328) = a5;
  *(void *)(v6 + 248) = a3;
  *(void *)(v6 + 256) = a4;
  *(void *)(v6 + 232) = a1;
  *(void *)(v6 + 240) = a2;
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  *(void *)(v6 + 264) = a6;
  *(void *)(v6 + 272) = v7;
  *(void *)(v6 + 280) = v8;
  *(_OWORD *)(v6 + 288) = *((_OWORD *)a2 + 1);
  *(void *)(v6 + 304) = a2[4];
  return MEMORY[0x1F4188298](sub_1B6384040, 0, 0);
}

uint64_t sub_1B63BCBB8(uint64_t a1, uint64_t a2)
{
  return MEMORY[0x1F41868B0](a2, a1);
}

uint64_t sub_1B63BCBC8(uint64_t a1)
{
  sub_1B63130BC(0, &qword_1EB985318, (uint64_t)&type metadata for ShaderCache.ShaderCacheWeakReference, MEMORY[0x1E4FBB718]);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v2 - 8) + 8))(a1, v2);
  return a1;
}

uint64_t sub_1B63BCC48(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_1B63BCCA4(uint64_t a1)
{
  if (qword_1EB985298 != -1) {
    swift_once();
  }
  objc_msgSend((id)qword_1EB985288, sel_lock);
  if (qword_1EB985310 != -1) {
    swift_once();
  }
  uint64_t v2 = off_1EB985300;
  if (!*((void *)off_1EB985300 + 2) || (unint64_t v3 = sub_1B62C1A30(a1), (v4 & 1) == 0))
  {
    uint64_t v8 = 0;
    char v9 = 1;
    sub_1B63BCBC8((uint64_t)&v8);
LABEL_10:
    type metadata accessor for ShaderCache();
    swift_allocObject();
    uint64_t v6 = (void *)swift_unknownObjectRetain();
    uint64_t Strong = sub_1B6793DE8(v6);
    swift_weakInit();
    char v9 = 0;
    sub_1B6CE09A8((uint64_t)&v8, a1);
    goto LABEL_11;
  }
  sub_1B63BCBB8(v2[7] + 8 * v3, (uint64_t)&v8);
  char v9 = 0;
  uint64_t Strong = swift_weakLoadStrong();
  sub_1B63BCBC8((uint64_t)&v8);
  if (!Strong) {
    goto LABEL_10;
  }
LABEL_11:
  objc_msgSend((id)qword_1EB985288, sel_unlock);
  return Strong;
}

void sub_1B63BCE08(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B63BCE6C(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B63BCED0(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

uint64_t type metadata accessor for RenderGraph()
{
  return self;
}

void *sub_1B63BCF58()
{
  v0[2] = 0;
  v0[3] = 2;
  v0[4] = 0;
  v0[5] = 0;
  v0[6] = 115;
  uint64_t v1 = sub_1B6383A48(xmmword_1F0F56BA0);
  sub_1B63BCFC4();
  swift_arrayDestroy();
  v0[7] = v1;
  return v0;
}

void sub_1B63BCFC4()
{
  if (!qword_1EB9852F8)
  {
    TupleTypeMetadata2 = swift_getTupleTypeMetadata2();
    if (!v1) {
      atomic_store(TupleTypeMetadata2, (unint64_t *)&qword_1EB9852F8);
    }
  }
}

uint64_t type metadata accessor for MovieSystem()
{
  return self;
}

uint64_t sub_1B63BD050()
{
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v20 = qword_1EB997A18;
  int v21 = 0;
  char v22 = 2;
  uint64_t v23 = 0;
  char v24 = 2;
  uint64_t v25 = 0;
  swift_retain();
  sub_1B63AA874(1, (uint64_t)&v7);
  swift_release();
  int v1 = v8;
  char v2 = v9;
  uint64_t v3 = v11;
  uint64_t v4 = v10 | 4;
  *(void *)(v0 + 16) = v7;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  uint64_t v14 = qword_1EB997A18;
  int v15 = 0;
  char v16 = 2;
  uint64_t v17 = 0;
  char v18 = 2;
  uint64_t v19 = 0;
  swift_retain();
  sub_1B63A2C70(1, 1, (uint64_t)v12);
  swift_release();
  long long v5 = v12[1];
  *(_OWORD *)(v0 + 56) = v12[0];
  *(_OWORD *)(v0 + 72) = v5;
  *(void *)(v0 + 88) = v13;
  return v0;
}

uint64_t sub_1B63BD188()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63BD050();
  return v0;
}

const char *sub_1B63BD1C0()
{
  return "Movie";
}

uint64_t destroy for InputStream()
{
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();

  return swift_bridgeObjectRelease();
}

uint64_t initializeWithCopy for InputStream(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  uint64_t v3 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = v3;
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  return a1;
}

void sub_1B63BD27C(uint64_t a1@<X8>)
{
  *(void *)a1 = MEMORY[0x1E4FBC860];
  *(void *)(a1 + 8) = -1;
  *(void *)(a1 + 16) = 0;
  uint64_t v1 = MEMORY[0x1E4FBC870];
  *(void *)(a1 + 24) = MEMORY[0x1E4FBC870];
  *(void *)(a1 + 32) = v1;
  *(_WORD *)(a1 + 40) = 0;
}

uint64_t type metadata accessor for CurveSystem()
{
  return self;
}

uint64_t sub_1B63BD2C8()
{
  uint64_t v0 = swift_allocObject();
  sub_1B6292DF8();
  return v0;
}

const char *sub_1B63BD300()
{
  return "CurveSystem";
}

void sub_1B63BD318(void *a1@<X0>, uint64_t a2@<X8>)
{
  float v5 = sub_1B6292384(a1);
  if (!v2)
  {
    *(unsigned char *)a2 = v4;
    *(float *)(a2 + 4) = v5;
  }
}

unint64_t sub_1B63BD348()
{
  unint64_t result = qword_1EB97DAE0[0];
  if (!qword_1EB97DAE0[0])
  {
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, qword_1EB97DAE0);
  }
  return result;
}

uint64_t type metadata accessor for AudioSystem()
{
  return self;
}

uint64_t sub_1B63BD3C0()
{
  if (qword_1EB97DC28 != -1) {
    swift_once();
  }
  uint64_t v35 = qword_1EB997A18;
  int v36 = 0;
  char v37 = 2;
  uint64_t v38 = 0;
  char v39 = 2;
  uint64_t v40 = 0;
  swift_retain();
  sub_1B63A2EC8(1, 1, (uint64_t)&v11);
  swift_release();
  int v1 = v12;
  char v2 = v13;
  uint64_t v3 = v15;
  uint64_t v4 = v14 | 4;
  *(void *)(v0 + 16) = v11;
  *(_DWORD *)(v0 + 24) = v1;
  *(unsigned char *)(v0 + 28) = v2;
  *(void *)(v0 + 32) = v4;
  *(unsigned char *)(v0 + 40) = 2;
  *(void *)(v0 + 48) = v3;
  uint64_t v29 = qword_1EB997A18;
  int v30 = 0;
  char v31 = 2;
  uint64_t v32 = 0;
  char v33 = 2;
  uint64_t v34 = 0;
  swift_retain();
  sub_1B63A3858(2, 1, (uint64_t)&v16);
  swift_release();
  int v5 = v17;
  char v6 = v18;
  uint64_t v7 = v20;
  uint64_t v8 = v19 | 4;
  *(void *)(v0 + 56) = v16;
  *(_DWORD *)(v0 + 64) = v5;
  *(unsigned char *)(v0 + 68) = v6;
  *(void *)(v0 + 72) = v8;
  *(unsigned char *)(v0 + 80) = 2;
  *(void *)(v0 + 88) = v7;
  uint64_t v23 = qword_1EB997A18;
  int v24 = 0;
  char v25 = 2;
  uint64_t v26 = 0;
  char v27 = 2;
  uint64_t v28 = 0;
  swift_retain();
  sub_1B63A3600(1, 1, (uint64_t)v21);
  swift_release();
  long long v9 = v21[1];
  *(_OWORD *)(v0 + 96) = v21[0];
  *(_OWORD *)(v0 + 112) = v9;
  *(void *)(v0 + 128) = v22;
  return v0;
}

uint64_t sub_1B63BD564()
{
  uint64_t v0 = swift_allocObject();
  sub_1B63BD3C0();
  return v0;
}

const char *sub_1B63BD59C()
{
  return "Audio";
}

float sub_1B63BD5B4(uint64_t a1, uint64_t a2)
{
  unint64_t v5 = sub_1B639A9AC();
  char v6 = sub_1B63BD9F8(MEMORY[0x1E4FBB470], a1, MEMORY[0x1E4FBB470], a2);
  if (!v2)
  {
    float result = 0.0;
    if (v6)
    {
      sub_1B63BD844(a1, MEMORY[0x1E4FBB470], v5, (uint64_t)&v8);
      return v8;
    }
  }
  return result;
}

uint64_t sub_1B63BD64C()
{
  uint64_t v2 = v0[3];
  uint64_t v3 = v0[4];
  sub_1B62C14BC(v0, v2);
  unsigned __int8 v4 = (*(uint64_t (**)(void, uint64_t, uint64_t))(v3 + 8))(0, v2, v3);
  if (!v1)
  {
    if ((v4 & 0xE0) != 0)
    {
      uint64_t v6 = v4 & 0xE0;
      sub_1B6B17984();
      swift_allocError();
      *(void *)uint64_t v7 = &unk_1F0F51FB0;
      char v8 = 3;
    }
    else
    {
      if ((v4 & 0x10) != 0)
      {
        char v5 = v4 & 1;
        return v5 & 1;
      }
      sub_1B6B17984();
      swift_allocError();
      uint64_t v6 = 0;
      *(void *)uint64_t v7 = 16;
      char v8 = 4;
    }
    *(void *)(v7 + 8) = v6;
    *(unsigned char *)(v7 + 16) = v8;
    swift_willThrow();
  }
  return v5 & 1;
}

uint64_t sub_1B63BD74C(unsigned __int8 a1)
{
  uint64_t result = sub_1B62C3B5C();
  if (!v1)
  {
    char v4 = result;
    if ((result & 0xE0) == a1)
    {
      sub_1B62C4258();
      uint64_t result = v4 & 0x1F;
      if (result == 31) {
        return sub_1B6B14240();
      }
    }
    else
    {
      unsigned __int8 v5 = result & 0xE0;
      sub_1B6B18018(0, (unint64_t *)&unk_1EB980DB0, MEMORY[0x1E4FBBE00]);
      uint64_t v6 = swift_allocObject();
      *(_OWORD *)(v6 + 16) = xmmword_1B6E77050;
      *(unsigned char *)(v6 + 32) = a1;
      sub_1B6B17984();
      swift_allocError();
      *(void *)uint64_t v7 = v6;
      *(void *)(v7 + 8) = v5;
      *(unsigned char *)(v7 + 16) = 3;
      return swift_willThrow();
    }
  }
  return result;
}

uint64_t sub_1B63BD844@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X4>, uint64_t a4@<X8>)
{
  v18[1] = a4;
  uint64_t AssociatedTypeWitness = swift_getAssociatedTypeWitness();
  uint64_t v8 = *(void *)(AssociatedTypeWitness - 8);
  MEMORY[0x1F4188790](AssociatedTypeWitness, v9);
  uint64_t v11 = (char *)v18 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v12, v13);
  uint64_t v15 = (char *)v18 - v14;
  swift_getAssociatedConformanceWitness();
  uint64_t v16 = v18[3];
  uint64_t result = sub_1B62B01B4(AssociatedTypeWitness, a1, AssociatedTypeWitness);
  if (!v16)
  {
    (*(void (**)(char *, char *, uint64_t))(v8 + 16))(v11, v15, AssociatedTypeWitness);
    (*(void (**)(char *, uint64_t, uint64_t))(a3 + 40))(v11, a2, a3);
    return (*(uint64_t (**)(char *, uint64_t))(v8 + 8))(v15, AssociatedTypeWitness);
  }
  return result;
}

uint64_t sub_1B63BD9F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 48))(a2, a4);
  if (!v4)
  {
    char v7 = result;
    if ((result & 0xE0) == 0x40)
    {
      int v8 = result;
      if (result == 64) {
        return v8 != 64;
      }
      unsigned __int8 v9 = sub_1B62B00FC(a3);
      if (!v9) {
        return v8 != 64;
      }
      uint64_t v10 = v7 & 0xF;
      if (v10 == v9) {
        return v8 != 64;
      }
      unint64_t v14 = v9 | (unint64_t)(v10 << 8);
      sub_1B6B17984();
      swift_allocError();
      uint64_t v11 = 0;
      *(void *)uint64_t v12 = v14;
      char v13 = 5;
    }
    else
    {
      uint64_t v11 = result & 0xE0;
      sub_1B6B17984();
      swift_allocError();
      *(void *)uint64_t v12 = &unk_1F0F51F60;
      char v13 = 3;
    }
    *(void *)(v12 + 8) = v11;
    *(unsigned char *)(v12 + 16) = v13;
    return swift_willThrow();
  }
  return result;
}

uint64_t type metadata accessor for CurveCache()
{
  return self;
}

CGColorSpaceRef sub_1B63BDB3C()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
  qword_1EB997928 = (uint64_t)result;
  return result;
}

CGColorSpaceRef sub_1B63BDB68()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
  qword_1EB997920 = (uint64_t)result;
  return result;
}

uint64_t sub_1B63BDB94()
{
  uint64_t result = sub_1B6E31118();
  if (v1 <= 0x3F)
  {
    swift_initStructMetadata();
    return 0;
  }
  return result;
}

uint64_t type metadata accessor for BundleInfo()
{
  uint64_t result = qword_1EB97D470;
  if (!qword_1EB97D470) {
    return swift_getSingletonMetadata();
  }
  return result;
}

uint64_t type metadata accessor for BufferPool()
{
  return self;
}

uint64_t sub_1B63BDCC4(uint64_t a1, uint64_t a2)
{
  sub_1B62B5820();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40))(a2, a1, v4);
  return a2;
}

void sub_1B63BDD28(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B63BDD8C(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    unint64_t v4 = sub_1B6E324B8();
    if (!v5) {
      atomic_store(v4, a2);
    }
  }
}

void sub_1B63BDDE0(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    unint64_t v4 = sub_1B6E324B8();
    if (!v5) {
      atomic_store(v4, a2);
    }
  }
}

void sub_1B63BDE34(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B63BDE98(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B63BDEFC(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    unint64_t v4 = sub_1B6E324B8();
    if (!v5) {
      atomic_store(v4, a2);
    }
  }
}

void sub_1B63BDF50(uint64_t a1, unint64_t *a2, uint64_t (*a3)(uint64_t), uint64_t (*a4)(uint64_t, uint64_t))
{
  if (!*a2)
  {
    uint64_t v7 = a3(255);
    unint64_t v8 = a4(a1, v7);
    if (!v9) {
      atomic_store(v8, a2);
    }
  }
}

void sub_1B63BDFB4(uint64_t a1, unint64_t *a2, void (*a3)(uint64_t))
{
  if (!*a2)
  {
    a3(255);
    unint64_t v4 = sub_1B6E324B8();
    if (!v5) {
      atomic_store(v4, a2);
    }
  }
}

uint64_t sub_1B63BE008(uint64_t a1, uint64_t a2)
{
  sub_1B63BE100();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 24))(a2, a1, v4);
  return a2;
}

uint64_t sub_1B63BE06C(uint64_t a1, uint64_t a2)
{
  sub_1B638BEC8(0, (unint64_t *)&qword_1EB9857F0, MEMORY[0x1E4F276F0], MEMORY[0x1E4FBB718]);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 40))(a2, a1, v4);
  return a2;
}

void sub_1B63BE100()
{
  if (!qword_1EB9857F0)
  {
    sub_1B6E30F48();
    unint64_t v0 = sub_1B6E324B8();
    if (!v1) {
      atomic_store(v0, (unint64_t *)&qword_1EB9857F0);
    }
  }
}

unint64_t sub_1B63BE158()
{
  unint64_t result = qword_1EB97D980;
  if (!qword_1EB97D980)
  {
    sub_1B6E30F48();
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB97D980);
  }
  return result;
}

void *sub_1B63BE410(void *a1, CFX::CrossFrameResourceManager *this)
{
  uint64_t v4 = CFX::CrossFrameResourceManager::get(this, 0xD877AC05CAC46D3ELL);
  if (v4)
  {
    uint64_t v11 = v4;
    uint64_t v12 = *(void **)(v4 + 16);
  }
  else
  {
    uint64_t v11 = sub_1B63BE5B4(this, 0xD877AC05CAC46D3ELL);
    uint64_t v16 = objc_msgSend_resourceManager(a1, v13, v14, v15);
    char v18 = objc_msgSend_texture2DDescriptorWithPixelFormat_width_height_mipmapped_(MEMORY[0x1E4F35330], v17, 125, 32, 32, 0);
    objc_msgSend_setStorageMode_(v18, v19, 2, v20);
    objc_msgSend_setUsage_(v18, v21, 1, v22);
    uint64_t v12 = objc_msgSend_newTextureWithDescriptor_(v16, v23, (uint64_t)v18, v24);
    uint64_t v28 = objc_msgSend_device(a1, v25, v26, v27);
    int v30 = (const char *)(id)objc_msgSend_newBufferWithBytes_length_options_(v28, v29, (uint64_t)&unk_1B6E4B1E0, 0x4000, 0);
    uint64_t v34 = objc_msgSend_commandQueue(a1, v31, v32, v33);
    uint64_t v38 = objc_msgSend_commandBuffer(v34, v35, v36, v37);
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    sub_1B63BE63C(&v57, v38, 0, v39, v40, v41, v42, v43);
    sub_1B63BE6F4(&v57, v30, 0, v12, 0, 0);
    int v51 = v57;
    if (!v57)
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v45, v46, v47, v48, v49, v50, (uint64_t)"_encoder != nil");
      int v51 = v57;
    }
    objc_msgSend_endEncoding(v51, v44, v45, v46);
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    objc_msgSend_commit(v38, v52, v53, v54);
    uint64_t v55 = *(void **)(v11 + 16);
    if (v55 != v12)
    {
      if (v55) {

      }
      *(void *)(v11 + 16) = v12;
    }
  }
  if (!v12)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v5, v6, v7, v8, v9, v10, (uint64_t)"_ptr != NULL");
    return *(void **)(v11 + 16);
  }
  return v12;
}

uint64_t sub_1B63BE5B4(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void *sub_1B63BE63C(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"_encoder == nil");
  }
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"commandBuffer != nil");
  }
  *a1 = 0;
  a1[1] = 0;
  unint64_t result = objc_msgSend_blitCommandEncoder(a2, (const char *)a2, a3, a4);
  *a1 = result;
  a1[1] = a2;
  if (a3)
  {
    return objc_msgSend_setLabel_(result, v12, a3, v13);
  }
  return result;
}

uint64_t sub_1B63BE6F4(void **a1, const char *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6)
{
  objc_msgSend_pixelFormat(a4, a2, a3, (uint64_t)a4);
  unint64_t v12 = (unint64_t)sub_1B64D8100() >> 3;
  uint64_t v16 = objc_msgSend_width(a4, v13, v14, v15) * v12;
  uint64_t v20 = objc_msgSend_height(a4, v17, v18, v19) * v16;
  uint64_t v24 = objc_msgSend_width(a4, v21, v22, v23);
  uint64_t v28 = objc_msgSend_height(a4, v25, v26, v27);
  uint64_t v32 = objc_msgSend_depth(a4, v29, v30, v31);
  memset(v36, 0, sizeof(v36));
  uint64_t v33 = *a1;
  v37[0] = v24;
  v37[1] = v28;
  v37[2] = v32;
  return objc_msgSend_copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_(v33, v34, (uint64_t)a2, a3, v16, v20, v37, a4, a5, a6, v36);
}

uint64_t sub_1B63BE7D8(void *a1, CFX::CrossFrameResourceManager *this)
{
  uint64_t v10 = CFX::CrossFrameResourceManager::get(this, 0x2D6F9F4D8FCEC7B4);
  if (!v10)
  {
    uint64_t v10 = sub_1B63BE5B4(this, 0x2D6F9F4D8FCEC7B4);
    uint64_t v14 = objc_msgSend_resourceManager(a1, v11, v12, v13);
    uint64_t v16 = objc_msgSend_texture2DDescriptorWithPixelFormat_width_height_mipmapped_(MEMORY[0x1E4F35330], v15, 72, 256, 256, 0);
    objc_msgSend_setUsage_(v16, v17, 3, v18);
    uint64_t v21 = objc_msgSend_newTextureWithDescriptor_(v14, v19, (uint64_t)v16, v20);
    char v25 = objc_msgSend_commandQueue(a1, v22, v23, v24);
    uint64_t v29 = objc_msgSend_commandBuffer(v25, v26, v27, v28);
    v56[1] = v29;
    int v57 = 0;
    v56[0] = objc_alloc_init(RGCachedComputeCommandEncoder);
    objc_msgSend_loadWithCommandBuffer_label_(v56[0], v30, (uint64_t)v29, 0);
    v56[2] = 0;
    uint64_t v34 = objc_msgSend_resourceManager(a1, v31, v32, v33);
    uint64_t v37 = objc_msgSend_newComputePipelineStateWithFunctionName_(v34, v35, @"vfx_generate_grain", v36);
    uint64_t v38 = sub_1B653EFB8((uint64_t)v37);
    objc_msgSend_setComputePipelineState_(v56[0], v39, v38, v40);
    objc_msgSend_setTexture_atIndex_(v56[0], v41, v21, 0);
    objc_msgSend_dispatchOnTexture2D_(v56[0], v42, v21, v43);
    sub_1B63BE98C((uint64_t)v56, v44, v45, v46, v47, v48, v49, v50);

    objc_msgSend_commit(v29, v51, v52, v53);
    uint64_t v54 = *(void **)(v10 + 16);
    if (v54 != (void *)v21)
    {
      if (v54) {

      }
      *(void *)(v10 + 16) = v21;
    }
  }
  uint64_t result = *(void *)(v10 + 16);
  if (!result)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v4, v5, v6, v7, v8, v9, (uint64_t)"_ptr != NULL");
    return *(void *)(v10 + 16);
  }
  return result;
}

void sub_1B63BE970(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1B63BE98C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)a1;
  if (!v9)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"_encoder != nil");
    uint64_t v9 = *(void **)a1;
  }
  objc_msgSend_endEncoding(v9, a2, a3, a4);
  *(void *)(a1 + 8) = 0;
  uint64_t v12 = *(void **)a1;

  return objc_msgSend_setEncoder_(v12, v10, 0, v11);
}

void sub_1B63BE9FC(unsigned int a1, float32x2_t *a2, float a3)
{
  if (a1)
  {
    uint64_t v5 = 0;
    LODWORD(v3) = vcvtps_s32_f32(a3);
    uint64_t v6 = a1;
    unsigned int v7 = a1 - 1;
    double v8 = a3;
    if ((int)v3 >= 0) {
      int v9 = v3;
    }
    else {
      int v9 = -(int)v3;
    }
    int v51 = v9;
    int v10 = v9 + 1;
    uint64_t v11 = &a2[(int)v3 + (uint64_t)-(int)v3];
    do
    {
      if ((v3 & 0x80000000) == 0)
      {
        long long v52 = xmmword_1B6E4F1E0[3 * (int)v7 + v5];
        LODWORD(v12) = HIDWORD(*(void *)&xmmword_1B6E4F1E0[3 * (int)v7 + v5]);
        int v13 = -(int)v3;
        uint64_t v14 = v11;
        do
        {
          float v15 = (float)v13 * 1.1 / v8;
          float v16 = v15 * v15;
          float v53 = expf(v12 * (float)(v15 * v15));
          __float2 v17 = __sincosf_stret(*(float *)&v52 * v16);
          *v14++ = vmul_n_f32((float32x2_t)__PAIR64__(LODWORD(v17.__sinval), LODWORD(v17.__cosval)), v53);
          ++v13;
        }
        while (v10 != v13);
      }
      ++v5;
      v11 += 128;
    }
    while (v5 != v6);
    uint64_t v18 = 0;
    float v19 = 0.0;
    uint64_t v20 = a2;
    do
    {
      _D1 = a2[128 * v18 + (int)v3];
      uint64_t v22 = (float *)&xmmword_1B6E4F1E0[3 * (int)v7 + v18];
      float v23 = v22[2];
      double v24 = v22[3];
      float v19 = (float)(v19 + (float)(v23 * vmlas_n_f32(vmuls_lane_f32(-_D1.f32[1], _D1, 1), _D1.f32[0], _D1.f32[0])))
          + v24 * ((_D1.f32[0] + _D1.f32[0]) * _D1.f32[1]);
      if ((int)v3 >= 1)
      {
        double v25 = v23;
        double v26 = v25 + v25;
        double v27 = v24 + v24;
        uint64_t v28 = v3;
        uint64_t v29 = v20;
        do
        {
          float32x2_t v30 = *v29++;
          _V17.S[1] = v30.i32[1];
          float v32 = v19 + v26 * vmlas_n_f32(vmuls_lane_f32(-_D1.f32[1], v30, 1), _D1.f32[0], v30.f32[0]);
          __asm { FMLA            S18, S1, V17.S[1] }
          float v19 = v32 + v27 * _S18;
          --v28;
        }
        while (v28);
        double v38 = v25 * 4.0;
        double v39 = v24 * 4.0;
        do
        {
          uint64_t v40 = 0;
          _D16 = a2[128 * v18 + v28];
          float v42 = v19 + v26 * vmlas_n_f32(-(float)(_D16.f32[1] * _D1.f32[1]), _D1.f32[0], _D16.f32[0]);
          float v19 = v42 + v27 * vmlas_n_f32(vmuls_lane_f32(_D1.f32[0], _D16, 1), _D1.f32[1], _D16.f32[0]);
          do
          {
            _D19 = v20[v40];
            float v44 = v19 + v38 * vmlas_n_f32(vmuls_lane_f32(-_D16.f32[1], _D19, 1), _D16.f32[0], _D19.f32[0]);
            __asm { FMLA            S20, S16, V19.S[1] }
            float v19 = v44 + v39 * _S20;
            ++v40;
          }
          while (v3 != v40);
          ++v28;
        }
        while (v28 != v3);
      }
      ++v18;
      v20 += 128;
    }
    while (v18 != v6);
    uint64_t v46 = 0;
    float v47 = 1.0 / sqrtf(v19);
    uint64_t v48 = &a2[(int)v3 + (uint64_t)-(int)v3];
    do
    {
      int v49 = v3 + v51 + 1;
      uint64_t v50 = v48;
      if ((v3 & 0x80000000) == 0)
      {
        do
        {
          float32x2_t *v50 = vmul_n_f32(*v50, v47);
          ++v50;
          --v49;
        }
        while (v49);
      }
      ++v46;
      v48 += 128;
    }
    while (v46 != v6);
  }
}

uint64_t sub_1B63BECF0(void *a1, CFX::CrossFrameResourceManager *this, unsigned int a3, void *a4, float a5)
{
  v30[385] = *(float32x2_t *)MEMORY[0x1E4F143B8];
  unint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * ((unint64_t)a5 ^ 0x43C4F620D84108D1)) ^ ((0x9DDFEA08EB382D69
                                                                                  * ((unint64_t)a5 ^ 0x43C4F620D84108D1)) >> 47) ^ 0x43C4F620D84108D1);
  unint64_t v11 = 0x9DDFEA08EB382D69 * (v10 ^ (v10 >> 47));
  uint64_t v12 = a3;
  uint64_t v13 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v11 ^ ((0x9DDFEA08EB382D69 * (v11 ^ a3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v11 ^ a3)))) ^ ((0x9DDFEA08EB382D69 * (v11 ^ ((0x9DDFEA08EB382D69 * (v11 ^ a3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v11 ^ a3)))) >> 47));
  uint64_t v20 = CFX::CrossFrameResourceManager::get(this, v13);
  if (!v20)
  {
    uint64_t v20 = sub_1B63BEEB0(this, v13);
    MEMORY[0x1F4188790](v20, v21);
    sub_1B63BE9FC(a3, v30, a5);
    uint64_t v25 = objc_msgSend_resourceManager(a1, v22, v23, v24);
    uint64_t v26 = sub_1B653D6DC(v25, (const char *)v30, v12 << 10, 0);
    double v27 = *(void **)(v20 + 16);
    if (v27 != (void *)v26)
    {
      uint64_t v28 = v26;
      if (v27) {

      }
      *(void *)(v20 + 16) = v28;
    }
  }
  if (a4) {
    memcpy(a4, &xmmword_1B6E4F1E0[3 * v12 - 3], 16 * v12);
  }
  uint64_t result = *(void *)(v20 + 16);
  if (!result)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v14, v15, v16, v17, v18, v19, (uint64_t)"_ptr != NULL");
    return *(void *)(v20 + 16);
  }
  return result;
}

uint64_t sub_1B63BEEB0(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B63BEF38(CFX::CrossFrameResourceManager *a1)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, 0x5A81C135E3353BC9);
  if (!v2)
  {
    uint64_t v2 = sub_1B63BF00C(a1, 0x5A81C135E3353BC9);
    uint64_t v3 = sub_1B64AED1C();
    sub_1B65834BC(v3, @"--SimplifiedMaterial--", v4, v5, v6, v7, v8, v9);
    uint64_t v17 = sub_1B64AF43C(v3, v10, v11, v12, v13, v14, v15, v16);
    sub_1B6475724(v17, 2, v18, v19, v20, v21, v22, v23);
    uint64_t v24 = *(const void **)(v2 + 16);
    if (v24 != (const void *)v3)
    {
      if (v24) {
        CFRelease(v24);
      }
      *(void *)(v2 + 16) = v3;
    }
    sub_1B63C8F2C(v31, 1.0, 1.0, 1.0, 1.0);
    sub_1B64760E8(v17, 1, v31, v25, v26, v27, v28, v29);
  }
  return *(void *)(v2 + 16);
}

uint64_t sub_1B63BF00C(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void *sub_1B63BF094(void *a1)
{
  *a1 = &unk_1F0FB2F60;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B63BF0E0(void *a1)
{
  *a1 = &unk_1F0FB2F60;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B63BF14C(void *a1)
{
  *a1 = &unk_1F0FB2F40;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B63BF198(void *a1)
{
  *a1 = &unk_1F0FB2F40;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B63BF204(void *a1)
{
  *a1 = &unk_1F0FB2FC8;
  uint64_t v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_1B63BF250(void *a1)
{
  *a1 = &unk_1F0FB2FC8;
  uint64_t v1 = (const void *)a1[2];
  if (v1) {
    CFRelease(v1);
  }

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63BF74C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(__n128 **)(a1 + 32);
  memset(v9, 0, sizeof(v9));
  sub_1B63CE188(v8, (unsigned __int8 *)v9, a3, a4, a5, a6, a7, a8);
}

void sub_1B63BFA7C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_geometryRef(*(void **)(a1 + 32), a2, a3, a4);
  long long v12 = *(_OWORD *)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 56);
  sub_1B63CE188(v5, (unsigned __int8 *)&v12, v6, v7, v8, v9, v10, v11);
}

void *dlsym_self(char *__symbol)
{
  return dlsym((void *)0xFFFFFFFFFFFFFFFDLL, __symbol);
}

BOOL vfx_swift_is_immortal(uint64_t a1)
{
  return (~*(void *)(a1 + 8) & 0x80000000FFFFFFFFLL) == 0;
}

BOOL _vfx_swift_has_weak_ref(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  return (~v1 & 0x80000000FFFFFFFFLL) != 0 && v1 < 0;
}

BOOL sub_1B63BFC98(uint64_t a1)
{
  if (sub_1B649530C(a1)) {
    int v9 = sub_1B649535C(a1, v2, v3, v4, v5, v6, v7, v8);
  }
  else {
    int v9 = 0;
  }
  if (sub_1B6497178(a1) || ((sub_1B64952FC(a1, v10, v11, v12, v13, v14, v15, v16) | v9) & 1) != 0) {
    return 0;
  }
  int v24 = sub_1B6496680(a1, v17, v18, v19, v20, v21, v22, v23);
  if (v24 != 1 && v24 != 3)
  {
    if (v24 == 4) {
      return sub_1B64975FC(a1, v25, v26, v27, v28, v29, v30, v31) != 0;
    }
    return 0;
  }
  return sub_1B6495B40(a1, v25, v26, v27, v28, v29, v30, v31) > 0.0;
}

uint64_t sub_1B63BFD3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = sub_1B6496680(a1, a2, a3, a4, a5, a6, a7, a8);
  if ((v9 & 0xFFFFFFFB) == 0) {
    return 0;
  }
  int v17 = v9 - 1;
  uint64_t result = 1;
  switch(v17)
  {
    case 0:
    case 2:
      if (sub_1B6495B40(a1, v10, v11, v12, v13, v14, v15, v16) <= 0.0) {
        goto LABEL_9;
      }
      goto LABEL_4;
    case 1:
    case 4:
      return result;
    default:
LABEL_4:
      if (sub_1B649530C(a1)) {
        int v26 = sub_1B649535C(a1, v19, v20, v21, v22, v23, v24, v25);
      }
      else {
        int v26 = 0;
      }
      if (sub_1B6497178(a1)) {
LABEL_9:
      }
        uint64_t result = 1;
      else {
        uint64_t result = sub_1B64952FC(a1, v27, v28, v29, v30, v31, v32, v33) | v26;
      }
      break;
  }
  return result;
}

uint64_t sub_1B63BFE04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a2;
  uint64_t result = (uint64_t)sub_1B649F640(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v18 = result;
    uint64_t result = sub_1B63BFD3C(result, v11, v12, v13, v14, v15, v16, v17);
    if (result)
    {
      uint64_t v26 = *(unsigned int *)(a3 + 584);
      if (v26 <= 7)
      {
        *(_DWORD *)(a3 + 4 * v26 + 520) = v9;
        uint64_t result = sub_1B64951A8(v18, v19, v20, v21, v22, v23, v24, v25);
        *(_DWORD *)(a3 + 4 * (*(_DWORD *)(a3 + 584))++ + 552) = result;
      }
    }
  }
  return result;
}

uint64_t sub_1B63BFE78(const __CFDictionary *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 0x40000000;
  v10[2] = sub_1B63C00C8;
  v10[3] = &unk_1E6140A68;
  v10[5] = a3;
  void v10[6] = a1;
  v10[4] = &v11;
  sub_1B63BFF20(a1, a2, (uint64_t)v10, a4, a5, a6, a7, a8);
  uint64_t v8 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v8;
}

CFDictionaryRef sub_1B63BFF20(const __CFDictionary *result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v10 = result;
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  memset(v76, 0, sizeof(v76));
  memset(v75, 0, sizeof(v75));
  uint64_t v11 = *((unsigned int *)result + 146);
  if (v11)
  {
    for (uint64_t i = 0; i != v11; ++i)
    {
      unint64_t v13 = *((unsigned int *)result + i + 130);
      unsigned int v14 = (v13 & 0xFFFFFFF) - 1;
      uint64_t v15 = (char *)result + ((v13 >> 25) & 0x78);
      *((void *)v76 + i) = *(void *)(*((void *)v15 + 19) + 8 * v14);
      *((void *)v75 + i) = *(void *)(*((void *)v15 + 27) + 8 * v14);
    }
    return (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
  }
  else if (!(*((_DWORD *)result + 23) | *((_DWORD *)result + 22) | *((_DWORD *)result + 26) | *((_DWORD *)result + 27)))
  {
    uint64_t result = sub_1B63C19D8((uint64_t)a2, v11, a3, a4, a5, a6, a7, a8);
    if (result)
    {
      __int16 v74 = sub_1B6446354((uint64_t)a2, v16, v17, v18, v19, v20, v21, v22);
      CFDictionaryRef v30 = sub_1B649F640((uint64_t)v74, v23, v24, v25, v26, v27, v28, v29);
      if (sub_1B6446518((uint64_t)a2, v31, v32, v33, v34, v35, v36, v37))
      {
        uint64_t v45 = sub_1B6446564(a2, v38, v39, v40, v41, v42, v43, v44);
        sub_1B64455D8((uint64_t)a2, (uint64_t)v45, v46, v47, v48, v49, v50, v51);
      }
      else
      {
        uint64_t v59 = sub_1B6446308((uint64_t)a2, v38, v39, v40, v41, v42, v43, v44);
        long long v67 = sub_1B6446564(a2, v60, v61, v62, v63, v64, v65, v66);
        sub_1B64455D8((uint64_t)a2, (uint64_t)v67, v68, v69, v70, v71, v72, v73);
        if (!v59) {
          sub_1B6445F58((uint64_t)a2, 0, v53, v54, v55, v56, v57, v58);
        }
      }
      *((_DWORD *)v10 + 138) = sub_1B64951A8((uint64_t)v30, v52, v53, v54, v55, v56, v57, v58);
      return (const __CFDictionary *)(*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
    }
  }
  return result;
}

void *sub_1B63C00C8(void *result)
{
  uint64_t v1 = result[5];
  uint64_t v2 = (void *)result[6];
  if (*(void *)v1 == v2[69]
    && *(void *)(v1 + 8) == v2[70]
    && *(void *)(v1 + 16) == v2[71]
    && *(void *)(v1 + 24) == v2[72])
  {
    char v8 = 0;
  }
  else
  {
    uint64_t v6 = v2 + 69;
    long long v7 = v6[1];
    *(_OWORD *)uint64_t v1 = *v6;
    *(_OWORD *)(v1 + 16) = v7;
    char v8 = 1;
  }
  *(unsigned char *)(*(void *)(result[4] + 8) + 24) = v8;
  return result;
}

void *sub_1B63C0120(void *a1, size_t a2, size_t a3, size_t alignment)
{
  memptr = 0;
  malloc_type_posix_memalign(&memptr, alignment, a3, 0x3D13089FuLL);
  if (a2) {
    memcpy(memptr, a1, a2);
  }
  free(a1);
  return memptr;
}

void sub_1B63C0184(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  if (a2 >= 8)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong light type", a3, a4, a5, a6, a7, a8, (uint64_t)"type < kCFXLightEffectiveTypeCount");
  }
  else if (a2 == 4)
  {
    sub_1B647C968(*(void *)(a1 + 24), a3 + 1, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v11 = a1 + 4 * a2;
  unsigned int v14 = *(_DWORD *)(v11 + 112);
  unint64_t v13 = (_DWORD *)(v11 + 112);
  unsigned int v12 = v14;
  if (v14 <= v8)
  {
    if (v12) {
      size_t v15 = 2 * v12;
    }
    else {
      size_t v15 = 8;
    }
    uint64_t v16 = (void **)(a1 + 8 * a2);
    uint64_t v18 = v16 + 19;
    uint64_t v17 = v16[19];
    uint64_t v19 = v16 + 27;
    if (v17)
    {
      *uint64_t v18 = malloc_type_realloc(v17, 8 * v15, 0x2004093837F09uLL);
      v16[35] = malloc_type_realloc(v16[35], 8 * v15, 0x100004000313F17uLL);
      *uint64_t v19 = malloc_type_realloc(*v19, 8 * v15, 0x2004093837F09uLL);
      v16[43] = malloc_type_realloc(v16[43], v15, 0x100004077774924uLL);
      v16[51] = malloc_type_realloc(v16[51], v15, 0x100004077774924uLL);
      switch(a2)
      {
        case 2u:
          *(void *)(a1 + 472) = sub_1B63C0120(*(void **)(a1 + 472), 16 * *v13, 16 * v15, 0x10uLL);
          break;
        case 3u:
          *(void *)(a1 + 488) = sub_1B63C0120(*(void **)(a1 + 488), 48 * *v13, 48 * v15, 0x10uLL);
          break;
        case 5u:
          *(void *)(a1 + 496) = sub_1B63C0120(*(void **)(a1 + 496), 80 * *v13, 80 * v15, 0x10uLL);
          break;
        case 6u:
          *(void *)(a1 + 480) = sub_1B63C0120(*(void **)(a1 + 480), 16 * *v13, 16 * v15, 0x10uLL);
          break;
        default:
          break;
      }
    }
    else
    {
      *uint64_t v18 = malloc_type_calloc(8uLL, v15, 0xAD0AAE88uLL);
      v16[35] = malloc_type_calloc(8 * v15, 1uLL, 0x813033A4uLL);
      *uint64_t v19 = malloc_type_calloc(8uLL, v15, 0x879268EEuLL);
      v16[43] = malloc_type_calloc(1uLL, v15, 0xFBCFBD3FuLL);
      v16[51] = malloc_type_calloc(1uLL, v15, 0xDBA7E0E2uLL);
      switch(a2)
      {
        case 2u:
          uint64_t v20 = (void **)(a1 + 472);
          goto LABEL_20;
        case 3u:
          uint64_t v20 = (void **)(a1 + 488);
          size_t v21 = 48 * v15;
          unsigned int v22 = -288221644;
          goto LABEL_21;
        case 5u:
          uint64_t v20 = (void **)(a1 + 496);
          size_t v21 = 80 * v15;
          unsigned int v22 = 1112007933;
          goto LABEL_21;
        case 6u:
          uint64_t v20 = (void **)(a1 + 480);
LABEL_20:
          size_t v21 = 16 * v15;
          unsigned int v22 = 1159420904;
LABEL_21:
          malloc_type_posix_memalign(v20, 0x10uLL, v21, v22 | 0x100004000000000);
          break;
        default:
          break;
      }
    }
    *unint64_t v13 = v15;
  }
}

void sub_1B63C04CC(uint64_t a1, void *value)
{
  uint64_t v3 = (__CFSet **)(a1 + 116504);
  Mutable = *(__CFSet **)(a1 + 116504);
  if (!Mutable)
  {
    Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D548]);
    *uint64_t v3 = Mutable;
  }

  CFSetAddValue(Mutable, value);
}

void sub_1B63C0530(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = a3;
  int v11 = a2;
  uint64_t v13 = sub_1B64A01D4(a4, a2, a3, a4, (uint64_t)a5, a6, a7, a8);
  float v85 = sub_1B6495B40((uint64_t)a5, v14, v15, v16, v17, v18, v19, v20);
  uint64_t v28 = &a1[v11];
  *(void *)(v28[35] + 8 * v10) = sub_1B6495D3C((uint64_t)a5, v21, v22, v23, v24, v25, v26, v27);
  if (sub_1B649719C((uint64_t)a5, v29, v30, v31, v32, v33, v34, v35)
    || sub_1B6495B8C((uint64_t)a5, v36, v37, v38, v39, v40, v41, v42))
  {
    *(void *)(v28[35] + 8 * v10) = 0;
  }
  switch(v11)
  {
    case 2:
      uint64_t v43 = a1[59];
      long long v44 = *(_OWORD *)(v13 + 48);
      *((float *)&v44 + 3) = v85;
      goto LABEL_12;
    case 3:
      float v52 = sub_1B6495918((uint64_t)a5, v36, v37, v38, v39, v40, v41, v42) / 180.0 * 3.14159265 * 0.5;
      if (v85 <= 0.0) {
        float v53 = INFINITY;
      }
      else {
        float v53 = v85;
      }
      uint64_t v54 = a1[61] + 48 * v10;
      float32x4_t v84 = *(float32x4_t *)(v13 + 32);
      long long v86 = *(_OWORD *)(v13 + 48);
      float v55 = tanf(v52);
      int32x4_t v56 = (int32x4_t)vmulq_f32(v84, v84);
      v56.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v56, 2), vadd_f32(*(float32x2_t *)v56.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v56.i8, 1))).u32[0];
      float32x2_t v57 = vrsqrte_f32((float32x2_t)v56.u32[0]);
      float32x2_t v58 = vmul_f32(v57, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v57, v57)));
      float32x4_t v59 = vmulq_n_f32(vnegq_f32(v84), vmul_f32(v58, vrsqrts_f32((float32x2_t)v56.u32[0], vmul_f32(v58, v58))).f32[0]);
      *(float *)&unsigned int v60 = (float)(v55 * v55) + 1.0;
      float32x2_t v61 = vrsqrte_f32((float32x2_t)v60);
      float32x2_t v62 = vmul_f32(v61, vrsqrts_f32((float32x2_t)v60, vmul_f32(v61, v61)));
      *(_OWORD *)uint64_t v54 = v86;
      *(float32x4_t *)(v54 + 16) = v59;
      *(float *)(v54 + 32) = v53;
      *(float *)(v54 + 36) = v53 * v55;
      *(_DWORD *)(v54 + 40) = vmul_f32(v62, vrsqrts_f32((float32x2_t)v60, vmul_f32(v62, v62))).u32[0];
      *(float *)(v54 + 44) = v55;
      break;
    case 4:
      if (sub_1B64975FC((uint64_t)a5, v36, v37, v38, v39, v40, v41, v42)) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. wrong probe type", v45, v46, v47, v48, v49, v50, (uint64_t)"CFXLightGetProbeType(light) == kCFXLightProbeTypeIrradiance");
      }
      uint64_t v51 = a1[3];
      sub_1B647CA20(v51, v10, a4, (uint64_t)a5, v47, v48, v49, v50);
      break;
    case 5:
      if (sub_1B64975FC((uint64_t)a5, v36, v37, v38, v39, v40, v41, v42) != 1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. wrong probe type", v64, v65, v66, v67, v68, v69, (uint64_t)"CFXLightGetProbeType(light) == kCFXLightProbeTypeRadiance");
      }
      __n128 v70 = sub_1B6497AB4(a5, v63, v64, v65, v66, v67, v68, v69);
      v71.i64[0] = 0x3F0000003F000000;
      v71.i64[1] = 0x3F0000003F000000;
      float32x4_t v72 = vmulq_f32((float32x4_t)v70, v71);
      uint64_t v73 = a1[62] + 80 * v10;
      float32x4_t v74 = *(float32x4_t *)(v13 + 16);
      float32x4_t v75 = *(float32x4_t *)(v13 + 32);
      float32x4_t v76 = vmlaq_f32(vmlaq_f32(vmlaq_f32(*(float32x4_t *)(v13 + 48), (float32x4_t)0, v75), (float32x4_t)0, v74), (float32x4_t)0, *(float32x4_t *)v13);
      v76.i32[3] = 1.0;
      float32x4_t v77 = vmulq_f32(*(float32x4_t *)v13, *(float32x4_t *)v13);
      float32x4_t v78 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v77, 2), vaddq_f32(v77, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v77.f32, 1)));
      float32x4_t v79 = vmulq_f32(v74, v74);
      v78.f32[0] = sqrtf(v78.f32[0]);
      v79.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v79, 2), vaddq_f32(v79, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.f32, 1))).u64[0];
      v79.f32[0] = sqrtf(v79.f32[0]);
      float32x4_t v80 = vmulq_f32(v75, v75);
      v80.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v80, 2), vaddq_f32(v80, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v80.f32, 1))).u64[0];
      float32x4_t v81 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v78.f32, 0);
      v78.i32[1] = v79.i32[0];
      v80.f32[0] = sqrtf(v80.f32[0]);
      v78.i32[2] = v80.i32[0];
      float32x4_t v82 = vdivq_f32(*(float32x4_t *)v13, v81);
      float32x4_t v83 = vmulq_f32(v72, v78);
      v83.i32[3] = 0;
      *(float32x4_t *)uint64_t v73 = v76;
      *(float32x4_t *)(v73 + 16) = v82;
      *(float32x4_t *)(v73 + 32) = vdivq_f32(v74, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v79.f32, 0));
      *(float32x4_t *)(v73 + 48) = vdivq_f32(v75, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v80.f32, 0));
      *(float32x4_t *)(v73 + 64) = v83;
      break;
    case 6:
      long long v44 = *(_OWORD *)(v13 + 48);
      HIDWORD(v44) = 1120403456;
      uint64_t v43 = a1[60];
LABEL_12:
      *(_OWORD *)(v43 + 16 * v10) = v44;
      break;
    default:
      return;
  }
}

uint64_t sub_1B63C087C(uint64_t a1, unsigned int *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a3;
  CFDictionaryRef v10 = sub_1B649F640(*(void *)(a1 + 8 * *a2), (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  double v18 = sub_1B649609C((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17);
  int v19 = (int)*(float *)&v18;
  CFDictionaryRef v27 = sub_1B649F640(*(void *)(a1 + 8 * v9), v20, v21, v22, v23, v24, v25, v26);
  double v35 = sub_1B649609C((uint64_t)v27, v28, v29, v30, v31, v32, v33, v34);
  return ((int)*(float *)&v35 - v19);
}

void sub_1B63C08D0(unsigned int *a1)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  size_t v1 = a1[29194];
  if (v1)
  {
    unint64_t v103 = (float32x2_t *)(a1 + 29194);
    uint64_t v2 = 0;
    uint64_t v102 = a1 + 33886;
    do
    {
      __base[v2] = v2;
      ++v2;
    }
    while (v1 != v2);
    uint64_t v3 = a1 + 33868;
    qsort_r(__base, v1, 4uLL, a1 + 33868, (int (__cdecl *)(void *, const void *, const void *))sub_1B63C087C);
    CFDictionaryRef v11 = sub_1B649F640(*(void *)&v3[2 * __base[0]], v4, v5, v6, v7, v8, v9, v10);
    *(double *)&long long v26 = sub_1B649609C((uint64_t)v11, v12, v13, v14, v15, v16, v17, v18);
    uint64_t v27 = 0;
    *(float *)&long long v26 = (float)*(float *)&v26;
    long long v105 = v26;
    float v28 = 0.0;
    do
    {
      CFDictionaryRef v29 = sub_1B649F640(*(void *)&v3[2 * __base[v27]], v19, v20, v21, v22, v23, v24, v25);
      double v37 = sub_1B649609C((uint64_t)v29, v30, v31, v32, v33, v34, v35, v36);
      float v107 = *(float *)&v37;
      if (sub_1B6496680((uint64_t)v29, v38, v39, v40, v41, v42, v43, v44) == 1) {
        unsigned int v45 = 6;
      }
      else {
        unsigned int v45 = sub_1B64954A8((uint64_t)v29, v19, v20, v21, v22, v23, v24, v25);
      }
      ++v27;
      *((void *)&_Q0 + 1) = *((void *)&v105 + 1);
      float v28 = v28 + (float)((float)((float)(v107 / *(float *)&v105) * (float)v45) * (float)(v107 / *(float *)&v105));
    }
    while (v1 != v27);
    uint64_t v47 = 0;
    int v48 = 0;
    int v49 = 0;
    *(float *)&_Q0 = ceil(sqrt((double)vcvtps_u32_f32(v28)));
    DWORD1(_Q0) = ceilf((float)ceilf(v28) / *(float *)&_Q0);
    float32x2_t v50 = vmul_n_f32(*(float32x2_t *)&_Q0, *(float *)&v105);
    __asm { FMOV            V0.2S, #1.0 }
    float32x2_t v55 = vdiv_f32(*(float32x2_t *)&_Q0, v50);
    *(void *)&_Q0 = 0;
    float32x2_t v106 = v50;
    long long v108 = _Q0;
    while (1)
    {
      CFDictionaryRef v56 = sub_1B649F640(*(void *)&v3[2 * __base[v47]], v19, v20, v21, v22, v23, v24, v25);
      double v64 = sub_1B649609C((uint64_t)v56, v57, v58, v59, v60, v61, v62, v63);
      unsigned int v65 = *(float *)&v64;
      uint64_t v66 = __base[v47];
      a1[584 * v66 + 29779] = *(float *)&v64;
      float32x4_t v74 = (float32x4_t *)sub_1B649F640(*(void *)&v3[2 * v66], v67, v68, v69, v70, v71, v72, v73);
      if (sub_1B6496680((uint64_t)v74, v75, v76, v77, v78, v79, v80, v81) == 1)
      {
        unsigned __int32 v89 = 6;
      }
      else
      {
        unsigned __int32 v89 = sub_1B64954A8((uint64_t)v74, v82, v83, v84, v85, v86, v87, v88);
        if (!v89) {
          goto LABEL_26;
        }
      }
      float v90 = (float)v65;
      float32x2_t v91 = vmul_n_f32(v55, (float)v65);
      uint64_t v92 = v89;
      uint64_t v93 = __src;
      long long v94 = v108;
      do
      {
        *(float32x2_t *)&long long v95 = vmul_f32(v55, *(float32x2_t *)&v94);
        *((float32x2_t *)&v95 + 1) = v91;
        *uint64_t v93 = v95;
        float v96 = *(float *)&v94 + v90;
        if (v49)
        {
          uint64_t v97 = (v49 - 1);
          uint64_t v98 = *(void *)&__src[8 * v97 + 96];
          float v99 = *((float *)&v94 + 1) + v90;
          if (*((float *)&v98 + 1) == (float)(*((float *)&v94 + 1) + v90))
          {
            *(float *)&uint64_t v98 = *(float *)&v94 + v90;
            *(void *)&__src[8 * v97 + 96] = v98;
            goto LABEL_19;
          }
        }
        else
        {
          float v99 = *((float *)&v94 + 1) + v90;
        }
        *(void *)&__src[8 * v49++ + 96] = __PAIR64__(LODWORD(v99), LODWORD(v96));
LABEL_19:
        if (v96 == v106.f32[0])
        {
          float v100 = *((float *)&v94 + 1) + v90;
          if (v49 == 1)
          {
            int v49 = 0;
            LODWORD(v94) = 0;
            *((float *)&v94 + 1) = *((float *)&v94 + 1) + v90;
          }
          else
          {
            *(void *)&long long v94 = *(void *)&__src[8 * (v49 - 2) + 96];
            *((float *)&v94 + 1) = v100;
            --v49;
          }
        }
        else
        {
          *(float *)&long long v94 = *(float *)&v94 + v90;
        }
        ++v93;
        --v92;
      }
      while (v92);
      long long v108 = v94;
LABEL_26:
      sub_1B64988A8(v74, v89, __src, v84, v85, v86, v87, v88, v101);
      v48 += v89;
      if (++v47 == v1)
      {
        v103[2345] = v106;
        *uint64_t v102 = v48;
        return;
      }
    }
  }
}

void sub_1B63C0BD8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = (int *)(a1 + 116776);
  if (*(_DWORD *)(a1 + 116776) < 8u)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
    if (Value)
    {
      uint64_t v19 = *(void *)(a1 + 8 * (Value >> 28) + 408);
      uint64_t v20 = (Value & 0xFFFFFFF) - 1;
      if (!*(unsigned char *)(v19 + v20))
      {
        int v21 = *v9;
        int v22 = *v9 + 1;
        *uint64_t v9 = v22;
        *(void *)(a1 + 8 * v21 + 135472) = a2;
        *(unsigned char *)(v19 + v20) = v22;
        sub_1B63C08D0((unsigned int *)a1);
      }
    }
    else
    {
      sub_1B63F2F54(16, @"Error: The shadow node is not registered", v13, v14, v15, v16, v17, v18, a9);
    }
  }
  else if ((byte_1E9DDA4F0 & 1) == 0)
  {
    byte_1E9DDA4F0 = 1;
    sub_1B63F2F54(16, @"Error: Too many shadow caster lights at once. Limit is %d", a3, a4, a5, a6, a7, a8, 8);
  }
}

void sub_1B63C0CF0(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (Value)
  {
    uint64_t v17 = a1 + 8 * (Value >> 28);
    uint64_t v18 = *(void *)(v17 + 408);
    uint64_t v19 = (Value & 0xFFFFFFF) - 1;
    unsigned int v20 = *(unsigned __int8 *)(v18 + v19);
    if (*(unsigned char *)(v18 + v19))
    {
      unsigned int v21 = *(_DWORD *)(a1 + 116776);
      *(_DWORD *)(a1 + 116776) = v21 - 1;
      if (v21 > v20)
      {
        int v22 = (uint64_t *)(v17 + 408);
        uint64_t v23 = *(const void **)(a1 + 135472 + 8 * (v21 - 1));
        unsigned int v24 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v23);
        *(unsigned char *)((v24 & 0xFFFFFFF) + *(void *)(a1 + 8 * (v24 >> 28) + 408) - 1) = v20;
        *(void *)(a1 + 135472 + 8 * (v20 - 1)) = v23;
        uint64_t v18 = *v22;
      }
      *(unsigned char *)(v18 + v19) = 0;
      sub_1B63C08D0((unsigned int *)a1);
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: The shadow node is not registered", v11, v12, v13, v14, v15, v16, a9);
  }
}

void sub_1B63C0E00(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (Value)
  {
    unsigned int v19 = Value;
    CFDictionaryRef v20 = sub_1B649F640((uint64_t)a2, v12, v13, v14, v15, v16, v17, v18);
    uint64_t v21 = *(unsigned __int8 *)((v19 & 0xFFFFFFF) + *(void *)(a1 + 8 * (v19 >> 28) + 408) - 1);
    int v29 = sub_1B649535C((uint64_t)v20, v22, v23, v24, v25, v26, v27, v28);
    if (v21)
    {
      if (v29)
      {
        double v44 = sub_1B649609C((uint64_t)v20, v30, v31, v32, v33, v34, v35, v36);
        if (*(_DWORD *)(a1 + 2336 * (v21 - 1) + 119116) != *(float *)&v44
          || (int v45 = sub_1B6498974((uint64_t)v20, v37, v38, v39, v40, v41, v42, v43),
              v45 != sub_1B64954A8((uint64_t)v20, v46, v47, v48, v49, v50, v51, v52)))
        {
          sub_1B63C08D0((unsigned int *)a1);
        }
      }
      else
      {
        sub_1B63C0CF0(a1, a2, v31, v32, v33, v34, v35, v36, a9);
      }
    }
    else if (v29)
    {
      sub_1B63C0BD8(a1, a2, v31, v32, v33, v34, v35, v36, a9);
    }
  }
}

uint64_t sub_1B63C0F2C(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B63C0F5C(uint64_t a1)
{
  if (qword_1E9DDA500 != -1) {
    dispatch_once_f(&qword_1E9DDA500, &qword_1E9DDA4F8, (dispatch_function_t)sub_1B63C0F2C);
  }
  uint64_t v2 = sub_1B63C8D44(qword_1E9DDA4F8, 0x21170uLL);
  *(void *)(v2 + 16) = a1;
  *(void *)(v2 + 24) = sub_1B647C144();
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  *(void *)(v2 + 32) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, 0);
  *(void *)(v2 + 40) = CFDictionaryCreateMutable(v3, 0, 0, MEMORY[0x1E4F1D540]);
  *(void *)(v2 + 56) = CFDictionaryCreateMutable(v3, 0, 0, 0);
  uint64_t v4 = (const CFSetCallBacks *)MEMORY[0x1E4F1D548];
  *(void *)(v2 + 512) = CFSetCreateMutable(v3, 0, MEMORY[0x1E4F1D548]);
  CFMutableSetRef Mutable = CFSetCreateMutable(v3, 0, v4);
  uint64_t v6 = 0;
  *(void *)(v2 + 504) = Mutable;
  *(_DWORD *)(v2 + 116512) = -1;
  uint64_t v7 = v2 + 117024;
  do
  {
    for (uint64_t i = 0; i != 1536; i += 384)
      *(void *)(v7 + i) = sub_1B662DFF8();
    ++v6;
    v7 += 2336;
  }
  while (v6 != 8);
  return v2;
}

uint64_t sub_1B63C10B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = sub_1B6496680(a1, a2, a3, a4, a5, a6, a7, a8);
  float v24 = sub_1B6495B40(a1, v10, v11, v12, v13, v14, v15, v16);
  BOOL v26 = (LODWORD(v24) & 0x7FFFFFFF) == 0 || LODWORD(v24) == 2139095040;
  unsigned __int8 v27 = 0;
  switch(v9)
  {
    case 0:
      return v27;
    case 1:
      if (v26) {
        unsigned __int8 v27 = 1;
      }
      else {
        unsigned __int8 v27 = 2;
      }
      break;
    case 2:
      unsigned __int8 v27 = 1;
      break;
    case 3:
      unsigned __int8 v27 = 3;
      break;
    case 4:
      int v28 = sub_1B64975FC(a1, v17, v18, v19, v20, v21, v22, v23);
      if (v28)
      {
        if (v28 != 1) {
          goto LABEL_16;
        }
        unsigned __int8 v27 = 5;
      }
      else
      {
        unsigned __int8 v27 = 4;
      }
      break;
    case 5:
      unsigned __int8 v27 = 7;
      break;
    case 6:
      if (v26) {
        unsigned __int8 v27 = 1;
      }
      else {
        unsigned __int8 v27 = 6;
      }
      break;
    default:
LABEL_16:
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v18, v19, v20, v21, v22, v23, (uint64_t)"0");
      unsigned __int8 v27 = 8;
      break;
  }
  return v27;
}

void sub_1B63C11C8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  CFDictionaryRef v11 = sub_1B649F640((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!v11)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v13, v14, v15, v16, v17, v18, (uint64_t)"light");
    BOOL v26 = @"Warning: Should not register a node without light to the light system";
    int v27 = 0;
LABEL_9:
    sub_1B63F2F54(v27, (uint64_t)v26, v20, v21, v22, v23, v24, v25, a9);
    return;
  }
  uint64_t v19 = (__n128 *)v11;
  if (sub_1B64A3178((uint64_t)a2, v12, v13, v14, v15, v16, v17, v18)) {
    return;
  }
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2))
  {
    BOOL v26 = @"Error: Node is already registered to the light system";
    int v27 = 16;
    goto LABEL_9;
  }
  uint64_t v29 = sub_1B63C10B0((uint64_t)v19, v28, v20, v21, v22, v23, v24, v25);
  uint64_t v30 = a1 + 4 * v29;
  uint64_t v31 = *(unsigned int *)(v30 + 80);
  *(_DWORD *)(v30 + 80) = v31 + 1;
  sub_1B63C0184(a1, v29, v31, v32, v33, v34, v35, v36);
  uint64_t v37 = a1 + 8 * v29;
  *(void *)(*(void *)(v37 + 152) + 8 * v31) = a2;
  *(void *)(*(void *)(v37 + 216) + 8 * v31) = v19;
  sub_1B6497BD0((uint64_t)v19, v31 + 1, v38, v39, v40, v41, v42, v43);
  sub_1B63C0530((void *)a1, v29, v31, (uint64_t)a2, v19, v44, v45, v46);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, (const void *)(((int)v31 + 1) & 0xFFFFFFF | (v29 << 28)));
  if (sub_1B63BFD3C((uint64_t)v19, v47, v48, v49, v50, v51, v52, v53))
  {
    *(_DWORD *)(a1 + 584) = 0;
    *(_OWORD *)(a1 + 520) = 0u;
    *(_OWORD *)(a1 + 536) = 0u;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)sub_1B63BFE04, (void *)a1);
  }
  else if (!*(_DWORD *)(a1 + 588))
  {
    uint64_t v61 = *(void *)(a1 + 116440);
    if (v61) {
      sub_1B6452758(v61, v54, v55, v56, v57, v58, v59, v60);
    }
  }
  sub_1B63C13DC(a1);
  if (sub_1B6494714((uint64_t)v19, v62, v63, v64, v65, v66, v67, v68)) {
    sub_1B63C04CC(a1, v19);
  }
  if (sub_1B649535C((uint64_t)v19, v69, v70, v71, v72, v73, v74, v75))
  {
    sub_1B63C0BD8(a1, a2, v76, v77, v78, v79, v80, v81, a9);
  }
}

uint64_t sub_1B63C13DC(uint64_t result)
{
  uint64_t v1 = result;
  *(_DWORD *)(result + 588) = 0;
  for (uint64_t i = 2; i != 7; ++i)
  {
    uint64_t v3 = *(unsigned int *)(v1 + 4 * i + 80);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t result = *(void *)(*(void *)(v1 + 8 * i + 216) + v4);
        if (result)
        {
          uint64_t result = sub_1B63BFC98(result);
          if (result) {
            ++*(_DWORD *)(v1 + 588);
          }
        }
        v4 += 8;
      }
      while (v5 != v4);
    }
  }
  return result;
}

void sub_1B63C1468(uint64_t a1, const void *a2)
{
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (Value)
  {
    uint64_t v12 = Value;
    CFDictionaryRef v13 = sub_1B649F640((uint64_t)a2, v5, v6, v7, v8, v9, v10, v11);
    if (sub_1B649535C((uint64_t)v13, v14, v15, v16, v17, v18, v19, v20)) {
      sub_1B63C0CF0(a1, a2, v21, v22, v23, v24, v25, v26, v71);
    }
    uint64_t v27 = (v12 & 0xFFFFFFF) - 1;
    uint64_t v28 = v12 >> 28;
    uint64_t v29 = a1 + 4 * v28;
    uint64_t v30 = (*(_DWORD *)(v29 + 80) - 1);
    *(_DWORD *)(v29 + 80) = v30;
    if (v27 < v30)
    {
      uint64_t v31 = (void *)(a1 + 8 * v28);
      uint64_t v32 = v31[19];
      uint64_t v33 = *(const void **)(v32 + 8 * v30);
      uint64_t v34 = *(void *)(v31[27] + 8 * v30);
      *(void *)(v32 + 8 * v27) = v33;
      *(void *)(v31[27] + 8 * v27) = v34;
      *(unsigned char *)(v31[43] + v27) = *(unsigned char *)(v31[43] + v30);
      *(unsigned char *)(v31[51] + v27) = *(unsigned char *)(v31[51] + v30);
      *(unsigned char *)(v31[51] + v30) = 0;
      switch((int)v28)
      {
        case 2:
          uint64_t v35 = *(void *)(a1 + 472);
          goto LABEL_11;
        case 3:
          uint64_t v36 = *(void *)(a1 + 488);
          uint64_t v37 = (long long *)(v36 + 48 * v30);
          long long v38 = *v37;
          long long v39 = v37[2];
          uint64_t v40 = (_OWORD *)(v36 + 48 * v27);
          v40[1] = v37[1];
          v40[2] = v39;
          _OWORD *v40 = v38;
          break;
        case 4:
          sub_1B647CA20(*(void *)(a1 + 24), v27, (uint64_t)v33, v34, v23, v24, v25, v26);
          break;
        case 5:
          uint64_t v41 = *(void *)(a1 + 496);
          uint64_t v42 = (_OWORD *)(v41 + 80 * v27);
          uint64_t v43 = (_OWORD *)(v41 + 80 * v30);
          *uint64_t v42 = *v43;
          long long v44 = v43[1];
          long long v45 = v43[2];
          long long v46 = v43[4];
          v42[3] = v43[3];
          v42[4] = v46;
          v42[1] = v44;
          v42[2] = v45;
          sub_1B6497BD0(v34, (__int16)v12, v21, v34, v23, v24, v25, v26);
          break;
        case 6:
          uint64_t v35 = *(void *)(a1 + 480);
LABEL_11:
          *(_OWORD *)(v35 + 16 * v27) = *(_OWORD *)(v35 + 16 * v30);
          break;
        default:
          break;
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v33, v12);
    }
    if (v28 == 4) {
      sub_1B647C968(*(void *)(a1 + 24), v30, v21, v22, v23, v24, v25, v26);
    }
    uint64_t v47 = (uint64_t *)(a1 + 116440);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), a2);
    if (v13 && sub_1B63BFD3C((uint64_t)v13, v48, v49, v50, v51, v52, v53, v54))
    {
      *(_DWORD *)(a1 + 584) = 0;
      *(_OWORD *)(a1 + 520) = 0u;
      *(_OWORD *)(a1 + 536) = 0u;
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)sub_1B63BFE04, (void *)a1);
    }
    CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 512), a2);
    sub_1B63C13DC(a1);
    if (sub_1B6494714((uint64_t)v13, v55, v56, v57, v58, v59, v60, v61))
    {
      uint64_t v69 = *(__CFSet **)(a1 + 116504);
      if (v69) {
        CFSetRemoveValue(v69, v13);
      }
    }
    if (!*(_DWORD *)(a1 + 588))
    {
      uint64_t v70 = *v47;
      if (*v47)
      {
        sub_1B6452758(v70, v62, v63, v64, v65, v66, v67, v68);
      }
    }
  }
}

void sub_1B63C16D8(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B63BFD3C((uint64_t)a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8)) {
    goto LABEL_2;
  }
  unint64_t v10 = *(unsigned int *)(a1 + 584);
  if (v10)
  {
    if (*(const void **)(*(void *)(a1 + (((unint64_t)*(unsigned int *)(a1 + 520) >> 25) & 0x78) + 216)
                        + 8 * ((*(_DWORD *)(a1 + 520) & 0xFFFFFFFu) - 1)) == a2)
      goto LABEL_2;
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = v11;
      if (v10 - 1 == v11) {
        break;
      }
      CFDictionaryRef v13 = *(const void **)(*(void *)(a1
                                       + (((unint64_t)*(unsigned int *)(a1 + 524 + 4 * v11) >> 25) & 0x78)
                                       + 216)
                           + 8 * ((*(_DWORD *)(a1 + 524 + 4 * v11) & 0xFFFFFFFu) - 1));
      ++v11;
    }
    while (v13 != a2);
    if (v12 + 1 < v10)
    {
LABEL_2:
      *(_DWORD *)(a1 + 584) = 0;
      *(_OWORD *)(a1 + 520) = 0u;
      *(_OWORD *)(a1 + 536) = 0u;
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 32), (CFDictionaryApplierFunction)sub_1B63BFE04, (void *)a1);
    }
  }
  uint64_t v14 = *(__CFSet **)(a1 + 504);

  CFSetAddValue(v14, a2);
}

double sub_1B63C17D0(uint64_t a1)
{
  long long v17 = 0uLL;
  sub_1B63C8F2C((float *)&v17, 0.0, 0.0, 0.0, 1.0);
  uint64_t v11 = *(unsigned int *)(a1 + 80);
  if (v11)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 8 * v11;
    do
    {
      uint64_t v14 = *(float32x4_t **)(*(void *)(a1 + 216) + v12);
      if (v14)
      {
        sub_1B64972C4(v14, v2, v3, v4, v5, v6, v7, v8, v9, v10);
        v10.i32[0] = v2;
        *(float32x2_t *)v9.f32 = vadd_f32(*(float32x2_t *)&v17, v15);
        *(void *)&long long v17 = v9.i64[0];
        v9.f32[0] = *((float *)&v17 + 2) + *(float *)&v2;
        *((float *)&v17 + 2) = *((float *)&v17 + 2) + *(float *)&v2;
      }
      v12 += 8;
    }
    while (v13 != v12);
  }
  double result = *(double *)&v17;
  *(_OWORD *)(a1 + 64) = v17;
  return result;
}

uint64_t sub_1B63C1870(uint64_t a1)
{
  uint64_t v2 = 0;
  char v3 = 0;
  do
  {
    uint64_t v4 = a1 + 4 * v2;
    uint64_t v5 = *(unsigned int *)(v4 + 80);
    long long v44 = (unsigned int *)(v4 + 80);
    if (*(_DWORD *)(v4 + 80))
    {
      uint64_t v6 = 0;
      uint64_t v7 = a1 + 8 * v2;
      uint64_t v8 = (void *)(v7 + 216);
      float32x4_t v9 = (void *)(v7 + 152);
      do
      {
        float32x4_t v10 = *(__n128 **)(*v8 + 8 * v6);
        if (CFSetContainsValue(*(CFSetRef *)(a1 + 504), v10))
        {
          uint64_t v18 = *(const void **)(*v9 + 8 * v6);
          int v22 = sub_1B63C10B0((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17);
          if (v2 == v22)
          {
            sub_1B63C0530((void *)a1, v2, v6, (uint64_t)v18, v10, v19, v20, v21);
            sub_1B63C0E00(a1, v18, v23, v24, v25, v26, v27, v28, v43);
          }
          else
          {
            sub_1B63C1468(a1, v18);
            sub_1B63C11C8(a1, v18, v36, v37, v38, v39, v40, v41, v43);
            uint64_t v5 = *v44;
            --v6;
          }
          v3 |= v22 == 0;
          sub_1B649F3DC((uint64_t)v18, v29, v30, v31, v32, v33, v34, v35);
        }
        ++v6;
      }
      while (v6 < v5);
    }
    ++v2;
  }
  while (v2 != 8);
  sub_1B63C13DC(a1);
  return v3 & 1;
}

CFDictionaryRef sub_1B63C1998(int32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (vaddvq_s32(a1[5]) + a1[6].i32[2] + a1[6].i32[3] + a1[6].i32[1] + a1[6].i32[0] || a1[37].i32[2]) {
    return (const __CFDictionary *)1;
  }
  else {
    return sub_1B63C19D8(a2, a2, a3, a4, a5, a6, a7, a8);
  }
}

CFDictionaryRef sub_1B63C19D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B644558C(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = sub_1B64B2810(v9, 0);
  if (v10)
  {
    uint64_t v18 = v10;
    if (sub_1B6475F88(v10, v11, v12, v13, v14, v15, v16, v17) || sub_1B6477598(v18, v19, v20, v21, v22, v23, v24, v25)) {
      return 0;
    }
  }
  if (sub_1B64B38A0(v9, v11, v12, v13, v14, v15, v16, v17)) {
    return 0;
  }
  uint64_t v33 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (v9)
  {
    uint64_t v34 = (const void *)sub_1B64B1DD8(v9, @"triggerOptionsForRealtimeViewer");
    if (!v34) {
      uint64_t v34 = (const void *)*MEMORY[0x1E4F1CFC8];
    }
    CFTypeRef v35 = *v33;
    int v36 = CFEqual(v34, *v33);
    uint64_t v37 = v35;
    if (v36)
    {
      if (!v35) {
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v37 = (const void *)sub_1B64B1DD8(v9, @"defaultLight");
      if (!v37) {
        goto LABEL_16;
      }
    }
    if (CFEqual(v37, v35)) {
      return (const __CFDictionary *)1;
    }
  }
LABEL_16:
  CFDictionaryRef result = sub_1B64464A0(a1, @"defaultLight", v26, v27, v28, v29, v30, v31);
  if (result) {
    return (const __CFDictionary *)(CFEqual(result, *v33) != 0);
  }
  return result;
}

void sub_1B63C1AE8(uint64_t a1)
{
  if (CFSetGetCount(*(CFSetRef *)(a1 + 504)))
  {
    int v2 = sub_1B63C1870(a1);
    CFSetRemoveAllValues(*(CFMutableSetRef *)(a1 + 504));
    if (v2)
    {
      BOOL v3 = sub_1B63C8E84((float *)(a1 + 64));
      sub_1B63C17D0(a1);
      if (v3 != sub_1B63C8E84((float *)(a1 + 64)))
      {
        uint64_t v11 = *(void *)(a1 + 116440);
        if (v11)
        {
          sub_1B6452758(v11, v4, v5, v6, v7, v8, v9, v10);
        }
      }
    }
  }
}

void sub_1B63C1B8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = a1 + 116416;
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"lightingSpaceMatrix");
  }
  *(void *)(v11 + 16) = a3;
  uint64_t v12 = sub_1B644558C(a3, a2, a3, a4, a5, a6, a7, a8);
  *(void *)(v11 + 24) = sub_1B64B2864(v12, v13, v14, v15, v16, v17, v18, v19);
  *(unsigned char *)(v11 + 32) = 0;
  long long v20 = *(_OWORD *)(a2 + 48);
  float32x4_t v22 = *(float32x4_t *)a2;
  long long v21 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 116384) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 116400) = v20;
  *(float32x4_t *)(a1 + 116352) = v22;
  *(_OWORD *)(a1 + 116368) = v21;
  float32x4_t v23 = vmulq_f32(*(float32x4_t *)a2, *(float32x4_t *)a2);
  float32x4_t v24 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1)));
  float32x4_t v25 = vmulq_f32(*(float32x4_t *)(a2 + 16), *(float32x4_t *)(a2 + 16));
  v24.f32[0] = sqrtf(v24.f32[0]);
  float32x4_t v26 = vmulq_f32(*(float32x4_t *)(a2 + 32), *(float32x4_t *)(a2 + 32));
  v24.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v25, 2), vaddq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 1))).f32[0]);
  v24.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0]);
  float32x4_t v27 = vabsq_f32(v24);
  *(float *)uint64_t v11 = fmaxf(fmaxf(v27.f32[0], v27.f32[2]), v27.f32[1]);
  sub_1B63C1AE8(a1);
  for (uint64_t i = 1; i != 8; ++i)
  {
    uint64_t v32 = *(unsigned int *)(a1 + 4 * i + 80);
    if (v32)
    {
      uint64_t v33 = 0;
      uint64_t v34 = a1 + 8 * i;
      CFTypeRef v35 = (void *)(v34 + 152);
      int v36 = (void *)(v34 + 216);
      do
      {
        sub_1B63C0530((void *)a1, i, v33, *(void *)(*v35 + 8 * v33), *(__n128 **)(*v36 + 8 * v33), v28, v29, v30);
        ++v33;
      }
      while (v32 != v33);
    }
  }
  for (uint64_t j = 0; j != 7; ++j)
    bzero(*(void **)(a1 + 8 * j + 352), *(unsigned int *)(a1 + 4 * j + 84));
  bzero((void *)(a1 + 2680), 0x800uLL);
  bzero((void *)(a1 + 632), 0x800uLL);
  *(_DWORD *)(a1 + 624) = 0;
  uint64_t v44 = sub_1B6446254(a3, 0, v38, v39, v40, v41, v42, v43);
  *(void *)(v11 + 40) = v44;
  if (v44)
  {
    int v45 = sub_1B6446228(a3);
    uint64_t v46 = *(void *)(v11 + 40);
    *(unsigned char *)(v11 + 84) = (v45 & 0x100000) != 0;
    if (v46)
    {
      *(_DWORD *)(a1 + 116496) = 0;
      *(_OWORD *)(a1 + 116464) = 0u;
      *(_OWORD *)(a1 + 116480) = 0u;
    }
  }
  else
  {
    *(unsigned char *)(v11 + 84) = 0;
  }
  sub_1B63C17D0(a1);
  if (*(_DWORD *)(a1 + 96))
  {
    uint64_t v47 = *(void *)(a1 + 24);
    sub_1B647CC78(v47, a3);
  }
}

uint64_t sub_1B63C1DC8(uint64_t a1, void *a2, _DWORD *a3)
{
  *a2 = *(void *)(a1 + 592);
  *a3 = *(_DWORD *)(a1 + 600);
  return *(unsigned __int8 *)(a1 + 604);
}

uint64_t sub_1B63C1DE0(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

__n128 sub_1B63C1DEC@<Q0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v24 = 0;
  float32x4_t v25 = &v24;
  uint64_t v26 = 0x8000000000;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  uint64_t v33 = 0;
  sub_1B63C17D0(a1);
  long long v23 = *(_OWORD *)(a1 + 64);
  __int16 v6 = sub_1B63C8E84((float *)&v23);
  uint64_t v12 = v25;
  __int16 v13 = v25[3] & 0xFFFE | v6 ^ 1;
  *((_WORD *)v25 + 12) = v13;
  int v14 = *(_DWORD *)(a1 + 96);
  if (v14)
  {
    LOWORD(v14) = 8 * (sub_1B647E10C(*(void *)(a1 + 24)) & 7);
    uint64_t v12 = v25;
    __int16 v13 = *((_WORD *)v25 + 12);
  }
  __int16 v15 = v13 & 0xFFC7 | v14;
  *((_WORD *)v12 + 12) = v15;
  __int16 v16 = v15 & 0xFFFD | (2 * (*(_DWORD *)(a1 + 588) != 0));
  *((_WORD *)v12 + 12) = v16;
  *((_WORD *)v12 + 12) = v16 & 0xFFFB | (4 * (*(_DWORD *)(a1 + 100) != 0));
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 0x40000000;
  void v22[2] = sub_1B63C1FC8;
  v22[3] = &unk_1E6140A90;
  v22[4] = &v24;
  v22[5] = a1;
  sub_1B63BFF20((const __CFDictionary *)a1, a2, (uint64_t)v22, v7, v8, v9, v10, v11);
  uint64_t v17 = v25;
  long long v18 = *(_OWORD *)(v25 + 9);
  long long v19 = *(_OWORD *)(v25 + 13);
  *(_OWORD *)(a3 + 64) = *(_OWORD *)(v25 + 11);
  *(_OWORD *)(a3 + 80) = v19;
  *(void *)(a3 + 96) = v17[15];
  long long v20 = *(_OWORD *)(v17 + 5);
  *(_OWORD *)a3 = *(_OWORD *)(v17 + 3);
  *(_OWORD *)(a3 + 16) = v20;
  *(_OWORD *)(a3 + 32) = *(_OWORD *)(v17 + 7);
  *(_OWORD *)(a3 + 48) = v18;
  _Block_object_dispose(&v24, 8);
  return result;
}

BOOL sub_1B63C1F6C(uint64_t a1)
{
  return *(_DWORD *)(a1 + 588) != 0;
}

uint64_t sub_1B63C1F7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"lightingSystem");
  }
  return *(unsigned int *)(a1 + 100);
}

uint64_t sub_1B63C1FC8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(result + 32) + 8);
  long long v9 = *(_OWORD *)(*(void *)(result + 40) + 552);
  *(_OWORD *)(v8 + 44) = *(_OWORD *)(*(void *)(result + 40) + 568);
  *(_OWORD *)(v8 + 28) = v9;
  *(_WORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_WORD *)(*(void *)(*(void *)(result + 32) + 8)
                                                                            + 24) & 0xC03F | (a2 << 6);
  if (a2)
  {
    uint64_t v11 = result;
    uint64_t v12 = 0;
    uint64_t v13 = 8 * a2;
    do
    {
      __n128 result = sub_1B6495D3C(*(void *)(a4 + v12), a2, a3, a4, a5, a6, a7, a8);
      *(void *)(*(void *)(*(void *)(v11 + 32) + 8) + v12 + 64) = result;
      v12 += 8;
    }
    while (v13 != v12);
  }
  return result;
}

uint64_t sub_1B63C2058(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = 0;
  *a3 = 0u;
  a3[1] = 0u;
  do
  {
    uint64_t v12 = *(unsigned __int8 *)(a2 + v11);
    if (!*(unsigned char *)(a2 + v11)) {
      break;
    }
    if (v12 != 255 && *(_DWORD *)(a1 + 624) < v12) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Invalid runtime light index", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"((rInd > 0) && (rInd <= pipelineData->_runtimeLightsCount)) || (rInd == kDefaultRuntimeIndex)");
    }
    *((_DWORD *)a3 + v11++) = *(_DWORD *)(a1 + 4 * v12 + 4728);
  }
  while (v11 != 8);
  return v11;
}

void sub_1B63C2100(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = 0;
  unint64_t v12 = 0;
  while (1)
  {
    uint64_t v13 = *(unsigned __int8 *)(a2 + v12);
    if (!*(unsigned char *)(a2 + v12)) {
      break;
    }
    if (v13 == 255 || *(_DWORD *)(a1 + 624) >= v13)
    {
      a3[v12 + 1] = *(void *)(a1 + 624 + 8 * v13 + 2056);
      uint64_t v15 = a1 + 624 + 432 * v13 + 5136;
    }
    else
    {
      if ((byte_1E9DDA508 & 1) == 0)
      {
        byte_1E9DDA508 = 1;
        sub_1B63F2F54(16, @"Error: Invalid runtime light index", (uint64_t)a3, a4, a5, a6, a7, a8, v17);
      }
      uint64_t v15 = 0;
      a3[v12 + 1] = 0;
    }
    a3[v12++ + 9] = v15;
    ++v11;
    if (v12 == 8)
    {
      *a3 = 8;
      return;
    }
  }
  *a3 = v12;
  if (v12 <= 7)
  {
    do
    {
      __int16 v16 = &a3[v11];
      v16[1] = 0;
      v16[9] = 0;
      ++v11;
    }
    while (v11 != 8);
  }
}

uint64_t sub_1B63C220C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = 0; i != 8; ++i)
  {
    unsigned int v11 = *(unsigned __int8 *)(a2 + i);
    if (!*(unsigned char *)(a2 + i)) {
      break;
    }
    if (v11 == 255 || *(_DWORD *)(a1 + 624) >= v11)
    {
      if ((*(unsigned char *)(a1 + 432 * *(unsigned __int8 *)(a2 + i) + 5872) & 0x10) != 0) {
        return 1;
      }
    }
    else if ((byte_1E9DDA509 & 1) == 0)
    {
      byte_1E9DDA509 = 1;
      sub_1B63F2F54(16, @"Error: Invalid runtime light index", a3, a4, a5, a6, a7, a8, v14);
    }
  }
  return 0;
}

void sub_1B63C22BC(uint64_t a1)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1 + 116432;
  BOOL v3 = *(char **)(a1 + 116456);
  if (v3)
  {
    if (*(unsigned char *)(a1 + 604))
    {
      unsigned int v4 = *(_DWORD *)(a1 + 600);
      if (v4 >= 8) {
        unsigned int v4 = 8;
      }
      *(_DWORD *)(a1 + 4 * v4 + 116464) = 666;
    }
    sub_1B642F328(v3, (const void *)(a1 + 116464), 9u);
    if ((sub_1B6446228(*(void *)v2) & 0x100000) != 0)
    {
      long long v84 = xmmword_1B6E4F3A0;
      long long v85 = xmmword_1B6E4F390;
      uint64_t v67 = *(unsigned int *)(a1 + 84);
      if (v67)
      {
        for (uint64_t i = 0; i != v67; ++i)
        {
          long long v20 = (float32x4_t *)sub_1B64A01D4(*(void *)(*(void *)(a1 + 160) + 8 * i), v5, v6, v7, v8, v9, v10, v11);
          uint64_t v21 = *(void *)(a1 + 416);
          int v22 = *(unsigned __int8 *)(v21 + i);
          if (*(unsigned char *)(v21 + i))
          {
            v86[0] = *(_OWORD *)"fff?";
            v86[1] = unk_1B6E4F3D0;
            v86[2] = xmmword_1B6E4F3E0;
            v86[3] = unk_1B6E4F3F0;
            uint64_t v23 = *(void *)(*(void *)(a1 + 224) + 8 * i);
            BOOL v24 = sub_1B6495454(v23, v13, v14, v15, v16, v17, v18, v19);
            if (!v24)
            {
              uint64_t v26 = 1;
LABEL_14:
              uint64_t v27 = a1 + 2336 * (v22 - 1) + 116784;
              long long v28 = (float *)v86;
              do
              {
                if (v24)
                {
                  v83[0] = *(float32x4_t *)v28;
                  v83[0].i32[2] = 1056964608;
                  char v34 = sub_1B64984F0(v23, v13, v14, v15, v16, v17, v18, v19);
                  CFTypeRef v35 = *(uint64_t **)(v2 + 24);
                  if (v34) {
                    sub_1B642C85C(v35, *(void *)(v27 + 240), 0, v83[0].f32, v30, v31, v32, v33);
                  }
                  else {
                    sub_1B642AC18((uint64_t)v35, 0, (long long *)v83, v29, v30, v31, v32, v33, *(__n128 *)(v27 + 224));
                  }
                }
                sub_1B642B93C(*(uint64_t **)(v2 + 24), v27 + 256, 0, v28, v16, v17, v18, v19);
                float32x4_t v36 = *(float32x4_t *)(v27 + 368);
                v83[0] = *(float32x4_t *)(v27 + 352);
                v83[1] = v36;
                sub_1B642B7D4(*(void *)(v2 + 24), v83, v27, v28, v37, v38, v39, v40);
                v27 += 384;
                v28 += 4;
                --v26;
              }
              while (v26);
              goto LABEL_20;
            }
            unsigned int v25 = sub_1B64954A8(v23, v13, v14, v15, v16, v17, v18, v19);
            if (v25)
            {
              uint64_t v26 = v25;
              goto LABEL_14;
            }
          }
LABEL_20:
          int v41 = *(unsigned __int8 *)(*(void *)(a1 + 352) + i);
          int v47 = sub_1B6496680(*(void *)(*(void *)(a1 + 224) + 8 * i), v13, v14, v15, v16, v17, v18, v19);
          uint64_t v48 = *(void *)(v2 + 24);
          if (v41) {
            uint64_t v49 = &v84;
          }
          else {
            uint64_t v49 = &v85;
          }
          if (v47 == 2)
          {
            sub_1B642AA68(v48, (uint64_t)v20, (float *)v49, v42, v43, v44, v45, v46, (float32x4_t)0, (float32x4_t)xmmword_1B6E4F350);
          }
          else
          {
            sub_1B642AB40(v48, v20, (float *)v49, v42, v43, v44, v45, v46, (float32x4_t)xmmword_1B6E4F300, (float32x4_t)xmmword_1B6E4F310);
            sub_1B642AB40(*(void *)(v2 + 24), v20, (float *)v49, v50, v51, v52, v53, v54, (float32x4_t)xmmword_1B6E4F320, (float32x4_t)xmmword_1B6E4F330);
            sub_1B642AB40(*(void *)(v2 + 24), v20, (float *)v49, v55, v56, v57, v58, v59, (float32x4_t)xmmword_1B6E4F2E0, (float32x4_t)xmmword_1B6E4F340);
          }
        }
      }
      v79[0] = MEMORY[0x1E4F143A8];
      v79[1] = 0x40000000;
      v79[2] = sub_1B63C2750;
      v79[3] = &unk_1E6140AB0;
      uint64_t v82 = a1;
      long long v80 = v84;
      long long v81 = v85;
      unsigned int v60 = *(_DWORD *)(a1 + 88);
      if (v60) {
        sub_1B63C2750((uint64_t)v79, v60, v6, v7, *(void *)(a1 + 472), v9, v10, v11);
      }
      uint64_t v72 = MEMORY[0x1E4F143A8];
      uint64_t v73 = 0x40000000;
      uint64_t v74 = sub_1B63C27DC;
      uint64_t v75 = &unk_1E6140AD0;
      uint64_t v78 = a1;
      long long v76 = v84;
      long long v77 = v85;
      uint64_t v61 = *(unsigned int *)(a1 + 104);
      if (v61)
      {
        uint64_t v62 = 0;
        uint64_t v63 = *(void *)(a1 + 480);
        do
        {
          __n128 v64 = *(__n128 *)(v63 + 16 * v62);
          v64.n128_u32[3] = sqrtf(v64.n128_f32[3]);
          if (*(unsigned char *)(*(void *)(v78 + 392) + v62)) {
            uint64_t v65 = &v76;
          }
          else {
            uint64_t v65 = &v77;
          }
          sub_1B642AC18(*(void *)(v78 + 116456), 0, v65, v7, v8, v9, v10, v11, v64);
          ++v62;
        }
        while (v61 != v62);
      }
      v68[0] = MEMORY[0x1E4F143A8];
      v68[1] = 0x40000000;
      v68[2] = sub_1B63C28A0;
      v68[3] = &unk_1E6140AF0;
      uint64_t v71 = a1;
      long long v69 = v84;
      long long v70 = v85;
      unsigned int v66 = *(_DWORD *)(a1 + 92);
      if (v66) {
        sub_1B63C28A0((uint64_t)v68, v66, v6, v7, *(void *)(a1 + 488), v9, v10, v11);
      }
    }
  }
  if (*(_DWORD *)(a1 + 96)) {
    sub_1B647D614(*(void *)(a1 + 24));
  }
  *(void *)(v2 + 24) = 0;
  *(void *)uint64_t v2 = 0;
}

uint64_t sub_1B63C2724(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 88);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a2 + 16))(a2, v2, *(void *)(result + 168), *(void *)(result + 232), *(void *)(result + 472));
  }
  return result;
}

void sub_1B63C2750(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (long long *)(a1 + 32);
    unint64_t v12 = (long long *)(a1 + 48);
    uint64_t v13 = a2;
    do
    {
      uint64_t v14 = *(void *)(a1 + 64);
      if (*(unsigned char *)(*(void *)(v14 + 360) + v10)) {
        uint64_t v15 = v11;
      }
      else {
        uint64_t v15 = v12;
      }
      sub_1B642AC18(*(void *)(v14 + 116456), 0, v15, a4, a5, a6, a7, a8, *(__n128 *)(a5 + 16 * v10++));
    }
    while (v13 != v10);
  }
}

void sub_1B63C27DC(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (long long *)(a1 + 32);
    unint64_t v12 = (long long *)(a1 + 48);
    uint64_t v13 = a2;
    do
    {
      __n128 v14 = *(__n128 *)(a5 + 16 * v10);
      v14.n128_u32[3] = sqrtf(v14.n128_f32[3]);
      uint64_t v15 = *(void *)(a1 + 64);
      if (*(unsigned char *)(*(void *)(v15 + 392) + v10)) {
        uint64_t v16 = v11;
      }
      else {
        uint64_t v16 = v12;
      }
      sub_1B642AC18(*(void *)(v15 + 116456), 0, v16, a4, a5, a6, a7, a8, v14);
      ++v10;
    }
    while (v13 != v10);
  }
}

uint64_t sub_1B63C2874(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 92);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a2 + 16))(a2, v2, *(void *)(result + 176), *(void *)(result + 240), *(void *)(result + 488));
  }
  return result;
}

void sub_1B63C28A0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v9 = 0;
    uint64_t v10 = a1 + 32;
    uint64_t v11 = a1 + 48;
    uint64_t v12 = a5 + 32;
    uint64_t v13 = a2;
    do
    {
      long long v14 = *(_OWORD *)(v12 - 32);
      long long v15 = *(_OWORD *)(v12 - 16);
      v12 += 48;
      long long v18 = v15;
      long long v19 = v14;
      uint64_t v16 = *(void *)(a1 + 64);
      if (*(unsigned char *)(*(void *)(v16 + 368) + v9)) {
        uint64_t v17 = v10;
      }
      else {
        uint64_t v17 = v11;
      }
      sub_1B642CEA4(*(uint64_t **)(v16 + 116456), (uint64_t)&v19, (uint64_t)&v18, 0, v17, 0, a7, a8);
      ++v9;
    }
    while (v13 != v9);
  }
}

uint64_t sub_1B63C2948(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"lightingSystem");
  }
  return *(void *)(a1 + 24);
}

void sub_1B63C2994(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 56));

  sub_1B63C1AE8(a1);
}

uint64_t sub_1B63C29D4(uint64_t result, _OWORD *a2, float a3, float a4, uint64_t a5, long long *a6, long long *a7)
{
  long long v7 = a2[1];
  *(_OWORD *)(result + 116528) = *a2;
  *(_OWORD *)(result + 116544) = v7;
  long long v8 = a2[2];
  long long v9 = a2[3];
  long long v10 = a2[5];
  *(_OWORD *)(result + 116592) = a2[4];
  *(_OWORD *)(result + 116608) = v10;
  *(_OWORD *)(result + 116560) = v8;
  *(_OWORD *)(result + 116576) = v9;
  long long v11 = *a7;
  long long v12 = a7[1];
  long long v13 = a7[3];
  *(_OWORD *)(result + 116736) = a7[2];
  *(_OWORD *)(result + 116752) = v13;
  *(_OWORD *)(result + 116704) = v11;
  *(_OWORD *)(result + 116720) = v12;
  long long v14 = *a6;
  long long v15 = a6[1];
  long long v16 = a6[3];
  *(_OWORD *)(result + 116656) = a6[2];
  *(_OWORD *)(result + 116672) = v16;
  *(_OWORD *)(result + 116624) = v14;
  *(_OWORD *)(result + 116640) = v15;
  *(float *)(result + 116688) = a3;
  *(float *)(result + 116692) = a4;
  return result;
}

double sub_1B63C2A34()
{
  *(void *)&double result = 1056964608;
  return result;
}

double sub_1B63C2A48(__n128 a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6, __n128 a7, __n128 a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, __n128 a17, __n128 a18, __n128 a19, __n128 a20)
{
  unint64_t v20 = 0;
  __n128 v32 = a5;
  __n128 v33 = a6;
  __n128 v34 = a7;
  __n128 v35 = a8;
  float32x4_t v36 = 0u;
  float32x4_t v37 = 0u;
  float32x4_t v38 = 0u;
  float32x4_t v39 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v36 + v20) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F2C0, COERCE_FLOAT(*(_OWORD *)((char *)&v32 + v20))), (float32x4_t)xmmword_1B6E4F2D0, (float32x2_t)v32.n128_u64[v20 / 8], 1), (float32x4_t)xmmword_1B6E4F2E0, *(float32x4_t *)((char *)&v32 + v20), 2), (float32x4_t)xmmword_1B6E4F2F0, *(float32x4_t *)((char *)&v32 + v20), 3);
    v20 += 16;
  }
  while (v20 != 64);
  unint64_t v21 = 0;
  float32x4_t v22 = v36;
  float32x4_t v23 = v37;
  float32x4_t v24 = v38;
  float32x4_t v25 = v39;
  __n128 v32 = a1;
  __n128 v33 = a2;
  __n128 v34 = a3;
  __n128 v35 = a4;
  float32x4_t v36 = 0u;
  float32x4_t v37 = 0u;
  float32x4_t v38 = 0u;
  float32x4_t v39 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v36 + v21) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v22, COERCE_FLOAT(*(_OWORD *)((char *)&v32 + v21))), v23, (float32x2_t)v32.n128_u64[v21 / 8], 1), v24, *(float32x4_t *)((char *)&v32 + v21), 2), v25, *(float32x4_t *)((char *)&v32 + v21), 3);
    v21 += 16;
  }
  while (v21 != 64);
  unint64_t v26 = 0;
  float32x4_t v27 = v36;
  float32x4_t v28 = v37;
  float32x4_t v29 = v38;
  float32x4_t v30 = v39;
  __n128 v32 = a17;
  __n128 v33 = a18;
  __n128 v34 = a19;
  __n128 v35 = a20;
  float32x4_t v36 = 0u;
  float32x4_t v37 = 0u;
  float32x4_t v38 = 0u;
  float32x4_t v39 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v36 + v26) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v27, COERCE_FLOAT(*(_OWORD *)((char *)&v32 + v26))), v28, (float32x2_t)v32.n128_u64[v26 / 8], 1), v29, *(float32x4_t *)((char *)&v32 + v26), 2), v30, *(float32x4_t *)((char *)&v32 + v26), 3);
    v26 += 16;
  }
  while (v26 != 64);
  return *(double *)v36.i64;
}

void sub_1B63C2B60(uint64_t a1, unsigned int a2, float a3, float a4, float a5)
{
  uint64_t v6 = a2 + 1;
  if (a2 == -1)
  {
    LODWORD(v6) = 0;
LABEL_6:
    uint64_t v16 = v6;
    do
    {
      *(_DWORD *)(a1 + 4 * v16) = *(_DWORD *)(a1 + 4 * (v16 - 1));
      ++v16;
    }
    while (v16 != 5);
    return;
  }
  uint64_t v9 = 0;
  float v10 = a4 - a3;
  float v11 = (float)a2;
  float v12 = a4 / a3;
  do
  {
    float v13 = (float)v9 / v11;
    float v14 = a3 + (float)(v10 * v13);
    float v15 = powf(v12, v13);
    *(float *)(a1 + 4 * v9++) = (float)(v15 * a3) + (float)(a5 * (float)(v14 - (float)(v15 * a3)));
  }
  while (v6 != v9);
  if (v6 <= 4) {
    goto LABEL_6;
  }
}

double sub_1B63C2C1C(__n128 a1, __n128 a2)
{
  uint64_t v2 = 0;
  double v3 = (float)-a2.n128_f32[2];
  if (a1.n128_f32[2] < a2.n128_f32[2]) {
    double v4 = (float)-a1.n128_f32[2];
  }
  else {
    double v4 = v3 + 1.0;
  }
  double v5 = v3 - v4;
  *(float *)&unsigned int v6 = 1.0 / v5;
  *(void *)&long long v7 = 0;
  *((void *)&v7 + 1) = v6;
  float64x2_t v8 = vcvtq_f64_f32((float32x2_t)a1.n128_u64[0]);
  float64x2_t v9 = vcvtq_f64_f32((float32x2_t)a2.n128_u64[0]);
  *(float32x2_t *)&v8.f64[0] = vcvt_f32_f64(vdivq_f64(vnegq_f64(vaddq_f64(v8, v9)), vsubq_f64(v9, v8)));
  *(float *)v9.f64 = v3 / v5;
  *(void *)&v8.f64[1] = __PAIR64__(1.0, LODWORD(v9.f64[0]));
  _OWORD v11[2] = v7;
  v11[3] = v8;
  memset(v12, 0, sizeof(v12));
  do
  {
    v12[v2] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(v11[v2])), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)&v11[v2], 1), (float32x4_t)xmmword_1B6E4F340, (float32x4_t)v11[v2], 2), (float32x4_t)xmmword_1B6E4F360, (float32x4_t)v11[v2], 3);
    ++v2;
  }
  while (v2 != 4);
  return *(double *)v12;
}

void sub_1B63C2D24(uint64_t a1, uint64_t a2, float32x4_t a3, float32x4_t a4)
{
  uint64_t v213 = *MEMORY[0x1E4F143B8];
  float32x4_t v6 = *(float32x4_t *)(a1 + 336);
  int8x16_t v7 = *(int8x16_t *)(a1 + 272);
  int8x16_t v8 = *(int8x16_t *)(a1 + 288);
  float32x4_t v9 = (float32x4_t)vextq_s8(vextq_s8(v8, v8, 0xCuLL), v8, 8uLL);
  float32x4_t v10 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), v7, 0xCuLL);
  float32x4_t v11 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), v8, 0xCuLL);
  float32x4_t v12 = (float32x4_t)vextq_s8(vextq_s8(v7, v7, 0xCuLL), v7, 8uLL);
  float32x4_t v13 = vmlaq_f32(vmulq_f32(v12, vnegq_f32(v11)), v10, v9);
  float32x4_t v14 = vmulq_f32(v6, v13);
  int32x2_t v15 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v14, 2), vaddq_f32(v14, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.f32, 1))).u64[0];
  if (*(float *)v15.i32 != 0.0)
  {
    float32x4_t v16 = *(float32x4_t *)(a1 + 336);
    v16.f32[0] = -v6.f32[3];
    int8x16_t v17 = *(int8x16_t *)(a1 + 288);
    *(float *)v17.i32 = -*(float *)&v8.i32[3];
    int8x16_t v18 = *(int8x16_t *)(a1 + 272);
    *(float *)v18.i32 = -*(float *)&v7.i32[3];
    float32x4_t v19 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v18, v18, 0xCuLL), v18, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v17, (int32x4_t)v17), v17, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), v18, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v17, v17, 0xCuLL), v17, 8uLL));
    float32x4_t v20 = *(float32x4_t *)(a1 + 336);
    v20.f32[1] = -v6.f32[3];
    int8x16_t v21 = *(int8x16_t *)(a1 + 288);
    *(float *)&v21.i32[1] = -*(float *)&v8.i32[3];
    int32x4_t v22 = (int32x4_t)vmulq_f32(v16, v19);
    int8x16_t v23 = *(int8x16_t *)(a1 + 272);
    *(float *)&v23.i32[1] = -*(float *)&v7.i32[3];
    int32x4_t v24 = (int32x4_t)vmulq_f32(v20, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v23, v23, 0xCuLL), v23, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v21, (int32x4_t)v21), v21, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v23, (int32x4_t)v23), v23, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v21, v21, 0xCuLL), v21, 8uLL)));
    *(float32x2_t *)v20.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v22.i8, *(int32x2_t *)v24.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v22.i8, *(int32x2_t *)v24.i8));
    float32x4_t v25 = (float32x4_t)vzip2q_s32(v22, v24);
    *(float32x2_t *)v25.f32 = vadd_f32(*(float32x2_t *)v25.f32, *(float32x2_t *)v20.f32);
    float32x4_t v26 = *(float32x4_t *)(a1 + 336);
    v26.f32[2] = -v6.f32[3];
    int8x16_t v27 = *(int8x16_t *)(a1 + 288);
    *(float *)&v27.i32[2] = -*(float *)&v8.i32[3];
    int8x16_t v28 = *(int8x16_t *)(a1 + 272);
    *(float *)&v28.i32[2] = -*(float *)&v7.i32[3];
    float32x4_t v29 = vmulq_f32(v26, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v28, v28, 0xCuLL), v28, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27), v27, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), v28, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v27, v27, 0xCuLL), v27, 8uLL)));
    v25.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).u32[0];
    v208[0] = vdivq_f32(v25, (float32x4_t)vdupq_lane_s32(v15, 0));
  }
  int8x16_t v30 = *(int8x16_t *)(a1 + 256);
  float32x4_t v31 = (float32x4_t)vextq_s8(vextq_s8(v30, v30, 0xCuLL), v30, 8uLL);
  float32x4_t v32 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), v30, 0xCuLL);
  float32x4_t v33 = vmlaq_f32(vmulq_f32(v9, vnegq_f32(v32)), v11, v31);
  float32x4_t v34 = vmulq_f32(v6, v33);
  int32x2_t v35 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32(v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).u64[0];
  if (*(float *)v35.i32 != 0.0)
  {
    float32x4_t v36 = v6;
    v36.f32[0] = -v6.f32[3];
    int8x16_t v37 = *(int8x16_t *)(a1 + 256);
    *(float *)v37.i32 = -*(float *)&v30.i32[3];
    int8x16_t v38 = v8;
    *(float *)v38.i32 = -*(float *)&v8.i32[3];
    float32x4_t v39 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v38, v38, 0xCuLL), v38, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v37, (int32x4_t)v37), v37, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v38, (int32x4_t)v38), v38, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v37, v37, 0xCuLL), v37, 8uLL));
    float32x4_t v40 = v6;
    v40.f32[1] = -v6.f32[3];
    int8x16_t v41 = *(int8x16_t *)(a1 + 256);
    *(float *)&v41.i32[1] = -*(float *)&v30.i32[3];
    int32x4_t v42 = (int32x4_t)vmulq_f32(v36, v39);
    int8x16_t v43 = v8;
    *(float *)&v43.i32[1] = -*(float *)&v8.i32[3];
    int32x4_t v44 = (int32x4_t)vmulq_f32(v40, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v43, v43, 0xCuLL), v43, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), v41, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v43, (int32x4_t)v43), v43, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v41, v41, 0xCuLL), v41, 8uLL)));
    *(float32x2_t *)v40.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v42.i8, *(int32x2_t *)v44.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v42.i8, *(int32x2_t *)v44.i8));
    float32x4_t v45 = (float32x4_t)vzip2q_s32(v42, v44);
    *(float32x2_t *)v45.f32 = vadd_f32(*(float32x2_t *)v45.f32, *(float32x2_t *)v40.f32);
    float32x4_t v46 = v6;
    v46.f32[2] = -v6.f32[3];
    int8x16_t v47 = *(int8x16_t *)(a1 + 256);
    *(float *)&v47.i32[2] = -*(float *)&v30.i32[3];
    int8x16_t v48 = v8;
    *(float *)&v48.i32[2] = -*(float *)&v8.i32[3];
    float32x4_t v49 = vmulq_f32(v46, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v48, v48, 0xCuLL), v48, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v47, (int32x4_t)v47), v47, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v48, (int32x4_t)v48), v48, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v47, v47, 0xCuLL), v47, 8uLL)));
    v45.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).u32[0];
    v208[1] = vdivq_f32(v45, (float32x4_t)vdupq_lane_s32(v35, 0));
  }
  int8x16_t v50 = *(int8x16_t *)(a1 + 304);
  float32x4_t v51 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v50, (int32x4_t)v50), v50, 0xCuLL);
  float32x4_t v52 = (float32x4_t)vextq_s8(vextq_s8(v50, v50, 0xCuLL), v50, 8uLL);
  float32x4_t v53 = vmlaq_f32(vmulq_f32(v52, vnegq_f32(v10)), v51, v12);
  float32x4_t v54 = vmulq_f32(v6, v53);
  int32x2_t v55 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 2), vaddq_f32(v54, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 1))).u64[0];
  if (*(float *)v55.i32 != 0.0)
  {
    float32x4_t v56 = v6;
    v56.f32[0] = -v6.f32[3];
    int8x16_t v57 = v7;
    *(float *)v57.i32 = -*(float *)&v7.i32[3];
    int8x16_t v58 = *(int8x16_t *)(a1 + 304);
    *(float *)v58.i32 = -*(float *)&v50.i32[3];
    float32x4_t v59 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v58, v58, 0xCuLL), v58, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v57, (int32x4_t)v57), v57, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v58, (int32x4_t)v58), v58, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v57, v57, 0xCuLL), v57, 8uLL));
    float32x4_t v60 = v6;
    v60.f32[1] = -v6.f32[3];
    int8x16_t v61 = v7;
    *(float *)&v61.i32[1] = -*(float *)&v7.i32[3];
    int32x4_t v62 = (int32x4_t)vmulq_f32(v56, v59);
    int8x16_t v63 = *(int8x16_t *)(a1 + 304);
    *(float *)&v63.i32[1] = -*(float *)&v50.i32[3];
    int32x4_t v64 = (int32x4_t)vmulq_f32(v60, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v63, v63, 0xCuLL), v63, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v61, (int32x4_t)v61), v61, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v63, (int32x4_t)v63), v63, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v61, v61, 0xCuLL), v61, 8uLL)));
    *(float32x2_t *)v60.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v62.i8, *(int32x2_t *)v64.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v62.i8, *(int32x2_t *)v64.i8));
    float32x4_t v65 = (float32x4_t)vzip2q_s32(v62, v64);
    *(float32x2_t *)v65.f32 = vadd_f32(*(float32x2_t *)v65.f32, *(float32x2_t *)v60.f32);
    float32x4_t v66 = v6;
    v66.f32[2] = -v6.f32[3];
    int8x16_t v67 = v7;
    *(float *)&v67.i32[2] = -*(float *)&v7.i32[3];
    int8x16_t v68 = *(int8x16_t *)(a1 + 304);
    *(float *)&v68.i32[2] = -*(float *)&v50.i32[3];
    float32x4_t v69 = vmulq_f32(v66, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v68, v68, 0xCuLL), v68, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v67, (int32x4_t)v67), v67, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v68, (int32x4_t)v68), v68, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v67, v67, 0xCuLL), v67, 8uLL)));
    v65.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 2), vaddq_f32(v69, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 1))).u32[0];
    v208[2] = vdivq_f32(v65, (float32x4_t)vdupq_lane_s32(v55, 0));
  }
  float32x4_t v70 = vmlaq_f32(vmulq_f32(v31, vnegq_f32(v51)), v32, v52);
  float32x4_t v71 = vmulq_f32(v6, v70);
  int32x2_t v72 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 2), vaddq_f32(v71, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 1))).u64[0];
  if (*(float *)v72.i32 != 0.0)
  {
    float32x4_t v73 = v6;
    v73.f32[0] = -v6.f32[3];
    int8x16_t v74 = v50;
    *(float *)v74.i32 = -*(float *)&v50.i32[3];
    int8x16_t v75 = v30;
    *(float *)v75.i32 = -*(float *)&v30.i32[3];
    int32x4_t v76 = (int32x4_t)vmulq_f32(v73, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v75, v75, 0xCuLL), v75, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v74, (int32x4_t)v74), v74, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v75, (int32x4_t)v75), v75, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v74, v74, 0xCuLL), v74, 8uLL)));
    float32x4_t v77 = v6;
    v77.f32[1] = -v6.f32[3];
    int8x16_t v78 = v50;
    *(float *)&v78.i32[1] = -*(float *)&v50.i32[3];
    int8x16_t v79 = v30;
    *(float *)&v79.i32[1] = -*(float *)&v30.i32[3];
    int32x4_t v80 = (int32x4_t)vmulq_f32(v77, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v79, v79, 0xCuLL), v79, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v78, (int32x4_t)v78), v78, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v79, (int32x4_t)v79), v79, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v78, v78, 0xCuLL), v78, 8uLL)));
    *(float32x2_t *)v78.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v76.i8, *(int32x2_t *)v80.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v76.i8, *(int32x2_t *)v80.i8));
    float32x4_t v81 = (float32x4_t)vzip2q_s32(v76, v80);
    *(float32x2_t *)v81.f32 = vadd_f32(*(float32x2_t *)v81.f32, *(float32x2_t *)v78.i8);
    v6.f32[2] = -v6.f32[3];
    int8x16_t v82 = v50;
    *(float *)&v82.i32[2] = -*(float *)&v50.i32[3];
    int8x16_t v83 = v30;
    *(float *)&v83.i32[2] = -*(float *)&v30.i32[3];
    float32x4_t v84 = vmulq_f32(v6, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v83, v83, 0xCuLL), v83, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v82, (int32x4_t)v82), v82, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v83, (int32x4_t)v83), v83, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v82, v82, 0xCuLL), v82, 8uLL)));
    v81.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v84, 2), vaddq_f32(v84, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v84.f32, 1))).u32[0];
    v208[3] = vdivq_f32(v81, (float32x4_t)vdupq_lane_s32(v72, 0));
  }
  float32x4_t v85 = *(float32x4_t *)(a1 + 320);
  float32x4_t v86 = vmulq_f32(v13, v85);
  int32x2_t v87 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v86, 2), vaddq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v86.f32, 1))).u64[0];
  if (*(float *)v87.i32 != 0.0)
  {
    float32x4_t v88 = *(float32x4_t *)(a1 + 320);
    v88.f32[0] = -v85.f32[3];
    int8x16_t v89 = v8;
    *(float *)v89.i32 = -*(float *)&v8.i32[3];
    int8x16_t v90 = v7;
    *(float *)v90.i32 = -*(float *)&v7.i32[3];
    float32x4_t v91 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v90, v90, 0xCuLL), v90, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v89, (int32x4_t)v89), v89, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v90, (int32x4_t)v90), v90, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v89, v89, 0xCuLL), v89, 8uLL));
    float32x4_t v92 = *(float32x4_t *)(a1 + 320);
    v92.f32[1] = -v85.f32[3];
    int8x16_t v93 = v8;
    *(float *)&v93.i32[1] = -*(float *)&v8.i32[3];
    int32x4_t v94 = (int32x4_t)vmulq_f32(v91, v88);
    int8x16_t v95 = v7;
    *(float *)&v95.i32[1] = -*(float *)&v7.i32[3];
    int32x4_t v96 = (int32x4_t)vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v95, v95, 0xCuLL), v95, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v93, (int32x4_t)v93), v93, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v95, (int32x4_t)v95), v95, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v93, v93, 0xCuLL), v93, 8uLL)), v92);
    *(float32x2_t *)v92.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v94.i8, *(int32x2_t *)v96.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v94.i8, *(int32x2_t *)v96.i8));
    float32x4_t v97 = (float32x4_t)vzip2q_s32(v94, v96);
    *(float32x2_t *)v97.f32 = vadd_f32(*(float32x2_t *)v97.f32, *(float32x2_t *)v92.f32);
    float32x4_t v98 = *(float32x4_t *)(a1 + 320);
    v98.f32[2] = -v85.f32[3];
    int8x16_t v99 = v8;
    *(float *)&v99.i32[2] = -*(float *)&v8.i32[3];
    int8x16_t v100 = v7;
    *(float *)&v100.i32[2] = -*(float *)&v7.i32[3];
    float32x4_t v101 = vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v100, v100, 0xCuLL), v100, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v99, (int32x4_t)v99), v99, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v100, (int32x4_t)v100), v100, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v99, v99, 0xCuLL), v99, 8uLL)), v98);
    v97.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v101, 2), vaddq_f32(v101, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v101.f32, 1))).u32[0];
    v208[4] = vdivq_f32(v97, (float32x4_t)vdupq_lane_s32(v87, 0));
  }
  float32x4_t v102 = vmulq_f32(v33, v85);
  float32x4_t v103 = vaddq_f32(v102, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v102.f32, 1));
  int32x2_t v104 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v102, 2), v103).u64[0];
  if (*(float *)v104.i32 != 0.0)
  {
    float32x4_t v105 = v85;
    v105.f32[0] = -v85.f32[3];
    int8x16_t v106 = v30;
    *(float *)v106.i32 = -*(float *)&v30.i32[3];
    int8x16_t v107 = v8;
    *(float *)v107.i32 = -*(float *)&v8.i32[3];
    int32x4_t v108 = (int32x4_t)vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v107, v107, 0xCuLL), v107, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v106, (int32x4_t)v106), v106, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v107, (int32x4_t)v107), v107, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v106, v106, 0xCuLL), v106, 8uLL)), v105);
    float32x4_t v109 = v85;
    v109.f32[1] = -v85.f32[3];
    int8x16_t v110 = v30;
    *(float *)&v110.i32[1] = -*(float *)&v30.i32[3];
    int8x16_t v111 = v8;
    *(float *)&v111.i32[1] = -*(float *)&v8.i32[3];
    int32x4_t v112 = (int32x4_t)vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v111, v111, 0xCuLL), v111, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v110, (int32x4_t)v110), v110, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v111, (int32x4_t)v111), v111, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v110, v110, 0xCuLL), v110, 8uLL)), v109);
    *(float32x2_t *)v110.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v108.i8, *(int32x2_t *)v112.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v108.i8, *(int32x2_t *)v112.i8));
    v108.i64[0] = vzip2q_s32(v108, v112).u64[0];
    float32x4_t v113 = v85;
    v113.f32[2] = -v85.f32[3];
    *(float32x2_t *)v103.f32 = vadd_f32(*(float32x2_t *)v108.i8, *(float32x2_t *)v110.i8);
    int8x16_t v114 = v30;
    *(float *)&v114.i32[2] = -*(float *)&v30.i32[3];
    *(float *)&v8.i32[2] = -*(float *)&v8.i32[3];
    float32x4_t v115 = vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v8, v8, 0xCuLL), v8, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v114, (int32x4_t)v114), v114, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v8, (int32x4_t)v8), v8, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v114, v114, 0xCuLL), v114, 8uLL)), v113);
    v103.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v115, 2), vaddq_f32(v115, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v115.f32, 1))).u32[0];
    v208[5] = vdivq_f32(v103, (float32x4_t)vdupq_lane_s32(v104, 0));
  }
  float32x4_t v116 = vmulq_f32(v53, v85);
  float32x4_t v117 = vaddq_f32(v116, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v116.f32, 1));
  int32x2_t v118 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v116, 2), v117).u64[0];
  if (*(float *)v118.i32 != 0.0)
  {
    float32x4_t v119 = v85;
    v119.f32[0] = -v85.f32[3];
    int8x16_t v120 = v7;
    *(float *)v120.i32 = -*(float *)&v7.i32[3];
    int8x16_t v121 = v50;
    *(float *)v121.i32 = -*(float *)&v50.i32[3];
    int32x4_t v122 = (int32x4_t)vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v121, v121, 0xCuLL), v121, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v120, (int32x4_t)v120), v120, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v121, (int32x4_t)v121), v121, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v120, v120, 0xCuLL), v120, 8uLL)), v119);
    float32x4_t v123 = v85;
    v123.f32[1] = -v85.f32[3];
    int8x16_t v124 = v7;
    *(float *)&v124.i32[1] = -*(float *)&v7.i32[3];
    int8x16_t v125 = v50;
    *(float *)&v125.i32[1] = -*(float *)&v50.i32[3];
    int32x4_t v126 = (int32x4_t)vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v125, v125, 0xCuLL), v125, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v124, (int32x4_t)v124), v124, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v125, (int32x4_t)v125), v125, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v124, v124, 0xCuLL), v124, 8uLL)), v123);
    *(float32x2_t *)v124.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v122.i8, *(int32x2_t *)v126.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v122.i8, *(int32x2_t *)v126.i8));
    v122.i64[0] = vzip2q_s32(v122, v126).u64[0];
    float32x4_t v127 = v85;
    v127.f32[2] = -v85.f32[3];
    *(float32x2_t *)v117.f32 = vadd_f32(*(float32x2_t *)v122.i8, *(float32x2_t *)v124.i8);
    *(float *)&v7.i32[2] = -*(float *)&v7.i32[3];
    int8x16_t v128 = v50;
    *(float *)&v128.i32[2] = -*(float *)&v50.i32[3];
    float32x4_t v129 = vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v128, v128, 0xCuLL), v128, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v7, (int32x4_t)v7), v7, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v128, (int32x4_t)v128), v128, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v7, v7, 0xCuLL), v7, 8uLL)), v127);
    v117.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v129, 2), vaddq_f32(v129, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v129.f32, 1))).u32[0];
    v208[6] = vdivq_f32(v117, (float32x4_t)vdupq_lane_s32(v118, 0));
  }
  float32x4_t v130 = vmulq_f32(v70, v85);
  int32x2_t v131 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v130, 2), vaddq_f32(v130, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v130.f32, 1))).u64[0];
  if (*(float *)v131.i32 != 0.0)
  {
    float32x4_t v132 = v85;
    v132.f32[0] = -v85.f32[3];
    int8x16_t v133 = v50;
    *(float *)v133.i32 = -*(float *)&v50.i32[3];
    int8x16_t v134 = v30;
    *(float *)v134.i32 = -*(float *)&v30.i32[3];
    float32x4_t v135 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v134, v134, 0xCuLL), v134, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v133, (int32x4_t)v133), v133, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v134, (int32x4_t)v134), v134, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v133, v133, 0xCuLL), v133, 8uLL));
    float32x4_t v136 = v85;
    v136.f32[1] = -v85.f32[3];
    int8x16_t v137 = v50;
    *(float *)&v137.i32[1] = -*(float *)&v50.i32[3];
    int8x16_t v138 = v30;
    *(float *)&v138.i32[1] = -*(float *)&v30.i32[3];
    int32x4_t v139 = (int32x4_t)vmulq_f32(v135, v132);
    int32x4_t v140 = (int32x4_t)vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v138, v138, 0xCuLL), v138, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v137, (int32x4_t)v137), v137, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v138, (int32x4_t)v138), v138, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v137, v137, 0xCuLL), v137, 8uLL)), v136);
    *(float32x2_t *)v136.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v139.i8, *(int32x2_t *)v140.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v139.i8, *(int32x2_t *)v140.i8));
    float32x4_t v141 = (float32x4_t)vzip2q_s32(v139, v140);
    *(float32x2_t *)v141.f32 = vadd_f32(*(float32x2_t *)v141.f32, *(float32x2_t *)v136.f32);
    v85.f32[2] = -v85.f32[3];
    *(float *)&v50.i32[2] = -*(float *)&v50.i32[3];
    *(float *)&v30.i32[2] = -*(float *)&v30.i32[3];
    float32x4_t v142 = vmulq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8(v30, v30, 0xCuLL), v30, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v50, (int32x4_t)v50), v50, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), v30, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8(v50, v50, 0xCuLL), v50, 8uLL)), v85);
    v141.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v142, 2), vaddq_f32(v142, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v142.f32, 1))).u32[0];
    v208[7] = vdivq_f32(v141, (float32x4_t)vdupq_lane_s32(v131, 0));
  }
  uint64_t v143 = 0;
  v144.columns[0] = 0uLL;
  do
    v144.columns[0] = (simd_float4)vaddq_f32((float32x4_t)v144.columns[0], (float32x4_t)v208[v143++]);
  while (v143 != 8);
  uint64_t v145 = 0;
  v144.columns[1].i64[0] = 0x3E0000003E000000;
  v144.columns[1].i64[1] = 0x3E0000003E000000;
  v144.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v144.columns[0], (float32x4_t)v144.columns[1]);
  v144.columns[0].i32[0] = 0;
  do
  {
    v144.columns[1] = (simd_float4)vsubq_f32((float32x4_t)v208[v145], (float32x4_t)v144.columns[3]);
    v144.columns[1] = (simd_float4)vmulq_f32((float32x4_t)v144.columns[1], (float32x4_t)v144.columns[1]);
    v144.columns[1] = (simd_float4)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v144.columns[1], 2), vaddq_f32((float32x4_t)v144.columns[1], (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v144.columns[1].f32, 1)));
    v144.columns[0].f32[0] = fmaxf(v144.columns[0].f32[0], sqrtf(v144.columns[1].f32[0]));
    ++v145;
  }
  while (v145 != 8);
  float v146 = ceilf(v144.columns[0].f32[0] * 16.0);
  v144.columns[1].f32[0] = v146 * 0.0625;
  simd_float4 v205 = v144.columns[1];
  v144.columns[0] = v144.columns[3];
  v144.columns[0].f32[3] = v146 * 0.0625;
  *(simd_float4 *)(a1 + 224) = v144.columns[0];
  v144.columns[3].i32[3] = *(_DWORD *)(a1 + 60);
  *(simd_float4 *)(a1 + 48) = v144.columns[3];
  v144.columns[0] = *(simd_float4 *)a1;
  v144.columns[1] = *(simd_float4 *)(a1 + 16);
  v144.columns[2] = *(simd_float4 *)(a1 + 32);
  simd_float4x4 v214 = __invert_f4(v144);
  uint64_t v148 = 0;
  float32x4_t v149 = *(float32x4_t *)(a1 + 32);
  float32x4_t v150 = *(float32x4_t *)(a1 + 48);
  int32x4_t v151 = (int32x4_t)vmulq_f32(v149, v149);
  v151.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v151, 2), vadd_f32(*(float32x2_t *)v151.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v151.i8, 1))).u32[0];
  float32x2_t v152 = vrsqrte_f32((float32x2_t)v151.u32[0]);
  float32x2_t v153 = vmul_f32(v152, vrsqrts_f32((float32x2_t)v151.u32[0], vmul_f32(v152, v152)));
  float32x4_t v154 = vmulq_n_f32(v149, vmul_f32(v153, vrsqrts_f32((float32x2_t)v151.u32[0], vmul_f32(v153, v153))).f32[0]);
  __asm { FMOV            V4.4S, #1.0 }
  float32x4_t v160 = _Q4;
  float32x4_t v164 = vdivq_f32(_Q4, v154);
  _Q4.f32[0] = -(float)(v146 * 0.0625);
  float32x4_t v161 = _Q4;
  v161.f32[1] = _Q4.f32[0];
  simd_float4 v200 = v214.columns[1];
  simd_float4 v201 = v214.columns[0];
  *(simd_float4x4 *)(a1 + 64) = v214;
  v161.i32[2] = v205.i32[0];
  v160.i32[0] = v205.i32[0];
  simd_float4 v198 = v214.columns[3];
  simd_float4 v199 = v214.columns[2];
  float32x4_t v162 = v160;
  v162.f32[1] = _Q4.f32[0];
  v162.i32[2] = v205.i32[0];
  float32x4_t v209 = v161;
  float32x4_t v210 = v162;
  v160.i32[1] = v205.i32[0];
  v160.i32[2] = v205.i32[0];
  _Q4.i32[1] = v205.i32[0];
  __n128 v163 = (__n128)v205;
  _Q4.i32[2] = v205.i32[0];
  float32x4_t v211 = v160;
  float32x4_t v212 = _Q4;
  v164.i32[3] = 1259902592;
  float32x4_t v165 = vsubq_f32(a3, a4);
  float32x4_t v166 = vaddq_f32(a3, a4);
  float v167 = 0.0;
  do
  {
    float32x4_t v168 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)a1, COERCE_FLOAT(*(_OWORD *)((char *)&v209 + v148 * 4))), *(float32x4_t *)(a1 + 16), *(float32x2_t *)&v209.f32[v148], 1), v149, *(float32x4_t *)((char *)&v209 + v148 * 4), 2), v150, *(float32x4_t *)((char *)&v209 + v148 * 4), 3);
    v168.i32[3] = 1.0;
    float32x4_t v169 = vmulq_f32(v164, vsubq_f32(v165, v168));
    float32x4_t v170 = vmulq_f32(v164, vsubq_f32(v166, v168));
    v169.i32[3] = 0;
    v170.i32[3] = 0;
    float32x4_t v171 = vminnmq_f32(v169, v170);
    float32x4_t v172 = vmaxnmq_f32(v169, v170);
    float v173 = fmaxf(fmaxf(v171.f32[0], v171.f32[2]), v171.f32[1]);
    float v174 = fminf(fminf(v172.f32[0], v172.f32[2]), v172.f32[1]);
    if (v174 >= v173)
    {
      if (v173 > 0.0 && v173 < 10000000.0 || v174 > 0.0 && (float v173 = v174, v174 < 10000000.0)) {
        float v167 = fmaxf(v167, v173);
      }
    }
    v148 += 4;
  }
  while (v148 != 16);
  *(float *)v147.i32 = -(float)(v146 * 0.0625);
  v163.n128_u32[1] = v205.i32[0];
  v163.n128_f32[2] = v205.f32[0] + v167;
  __n128 v204 = (__n128)vdupq_lane_s32(v147, 0);
  __n128 v206 = v163;
  *(double *)v182.i64 = sub_1B63C2C1C(v204, v163);
  uint64_t v186 = 0;
  *(float32x4_t *)(a1 + 128) = v182;
  *(float32x4_t *)(a1 + 144) = v183;
  *(float32x4_t *)(a1 + 160) = v184;
  *(float32x4_t *)(a1 + 176) = v185;
  float32x4_t v187 = (float32x4_t)v204;
  float32x4_t v188 = (float32x4_t)v206;
  v187.i32[3] = 1.0;
  v188.i32[3] = 1.0;
  float32x4_t v189 = vaddq_f32(v187, v188);
  float32x4_t v190 = v188;
  float32x4_t v191 = v187;
  v187.i64[0] = 0x3F0000003F000000;
  v187.i64[1] = 0x3F0000003F000000;
  *(float32x4_t *)(a1 + 352) = vmulq_f32(v189, v187);
  *(float32x4_t *)(a1 + 368) = vmulq_f32(vsubq_f32(v190, v191), v187);
  v207[0] = v201;
  v207[1] = v200;
  v207[2] = v199;
  v207[3] = v198;
  float32x4_t v209 = 0u;
  float32x4_t v210 = 0u;
  float32x4_t v211 = 0u;
  float32x4_t v212 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v209 + v186 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v182, COERCE_FLOAT(v207[v186])), v183, *(float32x2_t *)&v207[v186], 1), v184, (float32x4_t)v207[v186], 2), v185, (float32x4_t)v207[v186], 3);
    ++v186;
  }
  while (v186 != 4);
  float32x2_t v192 = vadd_f32(*(float32x2_t *)v212.f32, (float32x2_t)*(_OWORD *)&vmlaq_f32(vmlaq_f32(vmulq_f32(v209, (float32x4_t)0), (float32x4_t)0, v210), (float32x4_t)0, v211));
  double v193 = sub_1B649609C(a2, v175, v176, v177, v178, v179, v180, v181);
  *(float32x2_t *)v194.f32 = vmul_n_f32(v192, 0.5 * *(float *)&v193);
  float32x2_t v195 = vmul_n_f32(vsub_f32((float32x2_t)*(_OWORD *)&vrndaq_f32(v194), *(float32x2_t *)v194.f32), 2.0 / *(float *)&v193);
  int8x16_t v196 = *(int8x16_t *)(a1 + 176);
  *(float32x2_t *)&long long v197 = vadd_f32(*(float32x2_t *)v196.i8, v195);
  *((void *)&v197 + 1) = vextq_s8(v196, v196, 8uLL).u64[0];
  *(_OWORD *)(a1 + 176) = v197;
}

double sub_1B63C3AC8(uint64_t a1)
{
  return *(double *)(a1 + 135536);
}

uint64_t sub_1B63C3AD8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 135544);
}

void sub_1B63C3AE8(float32x4_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v230 = *MEMORY[0x1E4F143B8];
  if (sub_1B6495454(a3, (uint64_t)a2, a3, a4, a5, a6, a7, a8)) {
    LODWORD(v19) = sub_1B64954A8(a3, v12, v13, v14, v15, v16, v17, v18);
  }
  else {
    LODWORD(v19) = 1;
  }
  int v20 = sub_1B6496680(a3, v12, v13, v14, v15, v16, v17, v18);
  if (sub_1B6498540(a3, v21, v22, v23, v24, v25, v26, v27))
  {
    if (v20 == 2)
    {
      int32x2_t v35 = a1 + 7291;
      uint64_t v36 = sub_1B63F4F54(a2, v28, v29, v30, v31, v32, v33, v34);
      uint64_t v44 = sub_1B64B2994(v36, v37, v38, v39, v40, v41, v42, v43);
      uint64_t v210 = 0;
      long long v208 = 0u;
      long long v209 = 0u;
      sub_1B65C4C3C(0, (uint64_t)&v208);
      *(void *)&long long v209 = 0x200000014;
      *(void *)&long long v208 = sub_1B6495D3C(a3, v45, v46, v47, v48, v49, v50, v51);
      DWORD2(v209) = 1;
      sub_1B65C633C(v44, (uint64_t)&v208);
      float32x4_t v205 = v53;
      float32x4_t v206 = v52;
      uint64_t v61 = sub_1B64A01D4((uint64_t)a2, v54, v55, v56, v57, v58, v59, v60);
      v231.columns[1] = *(simd_float4 *)(v61 + 16);
      simd_float4 v62 = *(simd_float4 *)(v61 + 32);
      float32x4_t v222 = *(float32x4_t *)v61;
      simd_float4 v223 = v231.columns[1];
      v231.columns[3] = (simd_float4)xmmword_1B6E4F370;
      simd_float4 v224 = v62;
      long long v225 = xmmword_1B6E4F370;
      v231.columns[0] = (simd_float4)v222;
      v231.columns[2] = v224;
      simd_float4x4 v232 = __invert_f4(v231);
      float32x4_t v203 = (float32x4_t)v232.columns[1];
      float32x4_t v204 = (float32x4_t)v232.columns[0];
      float32x4_t v201 = (float32x4_t)v232.columns[3];
      float32x4_t v202 = (float32x4_t)v232.columns[2];
      float v63 = a1[7293].f32[0];
      float v64 = fminf(a1[7293].f32[1], sub_1B64986EC(a3));
      int v72 = sub_1B64984F0(a3, v65, v66, v67, v68, v69, v70, v71);
      char v80 = v72;
      if (v72)
      {
        float32x4_t v81 = vmulq_f32(v205, v205);
        v81.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 2), vaddq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 1))).f32[0]);
        float32x4_t v82 = vsubq_f32(v206, a1[7292]);
        float32x4_t v83 = vmulq_f32(v82, v82);
        v83.f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 2), vaddq_f32(v83, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.f32, 1))).f32[0]);
        float v63 = fmaxf(v63, v83.f32[0] - v81.f32[0]);
        float v64 = fminf(v64, v81.f32[0] + v83.f32[0]);
      }
      float v84 = sub_1B649874C(a3, v73, v74, v75, v76, v77, v78, v79);
      sub_1B63C2B60(a4 + 2304, v19, v63, v64, v84);
      unsigned int v195 = v19;
      int v85 = 0;
      if (v19)
      {
        int32x4_t v86 = (int32x4_t)vmulq_f32(*v35, *v35);
        v86.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v86, 2), vadd_f32(*(float32x2_t *)v86.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v86.i8, 1))).u32[0];
        float32x2_t v87 = vrsqrte_f32((float32x2_t)v86.u32[0]);
        float32x2_t v88 = vmul_f32(v87, vrsqrts_f32((float32x2_t)v86.u32[0], vmul_f32(v87, v87)));
        float32x4_t v199 = vmulq_n_f32(*v35, vmul_f32(v88, vrsqrts_f32((float32x2_t)v86.u32[0], vmul_f32(v88, v88))).f32[0]);
        float32x4_t v200 = a1[7292];
        float32x4_t v198 = vnegq_f32(v199);
        int8x16_t v89 = (long long *)&a1[7283];
        float32x4_t v91 = v201;
        float32x4_t v90 = v202;
        float32x4_t v93 = v205;
        float32x4_t v92 = v206;
        float32x4_t v95 = v203;
        float32x4_t v94 = v204;
        float32x4_t v96 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v201, v202, v206, 2), v203, *(float32x2_t *)v206.f32, 1), v204, v206.f32[0]);
        v96.i32[3] = v206.i32[3];
        float32x4_t v97 = v205;
        v97.i32[1] = v205.i32[0];
        v97.i32[2] = v205.i32[0];
        float32x4_t v98 = vmlaq_f32(vmlaq_f32(vmulq_f32((float32x4_t)vuzp2q_s32(vdupq_lane_s32(*(int32x2_t *)v205.f32, 1), (int32x4_t)v205), vabsq_f32(v203)), v97, vabsq_f32(v204)), (float32x4_t)vzip2q_s32(vtrn1q_s32((int32x4_t)v93, (int32x4_t)v93), (int32x4_t)v205), vabsq_f32(v202));
        v98.i32[2] = fminf(v98.f32[2], 10000.0);
        float32x4_t v196 = vaddq_f32(v96, v98);
        float32x4_t v197 = vsubq_f32(v96, v98);
        uint64_t v19 = v19;
        int8x16_t v99 = (float *)(a4 + 2308);
        do
        {
          uint64_t v100 = a4 + 384 * v85;
          simd_float4 v101 = v223;
          *(float32x4_t *)uint64_t v100 = v222;
          *(simd_float4 *)(v100 + 16) = v101;
          long long v102 = v225;
          *(simd_float4 *)(v100 + 32) = v224;
          *(_OWORD *)(v100 + 48) = v102;
          *(float32x4_t *)(v100 + 64) = v94;
          *(float32x4_t *)(v100 + 80) = v95;
          *(float32x4_t *)(v100 + 96) = v90;
          *(float32x4_t *)(v100 + 112) = v91;
          long long v104 = v89[1];
          long long v226 = *v89;
          long long v103 = v226;
          long long v227 = v104;
          long long v105 = v89[3];
          float32x4_t v106 = vmulq_f32(vmlaq_n_f32(v200, v198, *(v99 - 1)), v198);
          float32x4_t v107 = v198;
          v107.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 2), vaddq_f32(v106, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v106.f32, 1))).f32[0];
          float32x4_t v108 = vmulq_f32(v199, vmlaq_n_f32(v200, v198, *v99));
          long long v228 = v89[2];
          long long v229 = v105;
          v106.f32[0] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v108, 2), vaddq_f32(v108, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v108.f32, 1))).f32[0];
          float32x4_t v109 = v199;
          v109.i32[3] = v106.i32[0];
          *(_OWORD *)(v100 + 288) = v228;
          *(_OWORD *)(v100 + 304) = v105;
          *(_OWORD *)(v100 + 256) = v103;
          *(_OWORD *)(v100 + 272) = v104;
          *(float32x4_t *)(v100 + 320) = v109;
          *(float32x4_t *)(v100 + 336) = v107;
          if (v80)
          {
            int8x16_t v110 = *(void **)(a4 + 384 * v85 + 240);
            long long v211 = v226;
            long long v212 = v227;
            long long v213 = v228;
            long long v214 = v229;
            float32x4_t v215 = v109;
            float32x4_t v216 = v107;
            sub_1B662E40C(v110, (uint64_t)&v211);
            if (!sub_1B662FE8C(v110, v206, v205)) {
              goto LABEL_16;
            }
            *(double *)v111.i64 = sub_1B6630014((uint64_t)v110, v204, v203, v202, v201);
            float32x4_t v113 = vsubq_f32(v111, v112);
            float32x4_t v114 = vaddq_f32(v111, v112);
            v113.i32[2] = v197.i32[2];
            v114.i32[2] = v196.i32[2];
            v115.i64[0] = 0x3F0000003F000000;
            v115.i64[1] = 0x3F0000003F000000;
            sub_1B662E360(v110, vmulq_f32(vaddq_f32(v114, v113), v115), vmulq_f32(vsubq_f32(v114, v113), v115));
            sub_1B662FFC8((uint64_t)v110, &v222);
            if (!sub_1B662FE8C(v110, v206, v205)) {
              goto LABEL_16;
            }
            *(double *)v116.i64 = sub_1B6630014((uint64_t)v110, v204, v203, v202, v201);
            float32x4_t v118 = vmulq_f32(vaddq_f32(v117, (float32x4_t)vdupq_n_s32(0x3C23D70Au)), (float32x4_t)vdupq_n_s32(0x3F800054u));
            v118.i32[3] = v117.i32[3];
            float32x4_t v119 = (_OWORD *)(a4 + 384 * v85);
            v119[22] = v116;
            v119[23] = v118;
            *(double *)&long long v120 = sub_1B63C2C1C((__n128)vsubq_f32(v116, v118), (__n128)vaddq_f32(v116, v118));
            v119[8] = v120;
            v119[9] = v121;
            v119[10] = v122;
            v119[11] = v123;
          }
          else
          {
            sub_1B63C2D24(v100, a3, v92, v93);
          }
          ++v85;
LABEL_16:
          float32x4_t v95 = v203;
          float32x4_t v94 = v204;
          float32x4_t v91 = v201;
          float32x4_t v90 = v202;
          ++v99;
          --v19;
          float32x4_t v93 = v205;
          float32x4_t v92 = v206;
        }
        while (v19);
      }
      if (v195 > v85)
      {
        *(double *)&long long v124 = sub_1B63C2C1C((__n128)vdupq_n_s32(0x47C34F80u), (__n128)vdupq_n_s32(0x47C35000u));
        do
        {
          int8x16_t v128 = (_OWORD *)(a4 + 384 * v85);
          v128[8] = v124;
          v128[9] = v125;
          v128[10] = v126;
          v128[11] = v127;
          ++v85;
        }
        while (v195 > v85);
      }
    }
    else
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Not Yet Implemented!!!!", v29, v30, v31, v32, v33, v34, (uint64_t)"0");
    }
  }
  else
  {
    long long v220 = 0u;
    long long v221 = 0u;
    long long v218 = 0u;
    long long v219 = 0u;
    float32x4_t v216 = 0u;
    long long v217 = 0u;
    long long v214 = 0u;
    float32x4_t v215 = 0u;
    long long v212 = 0u;
    long long v213 = 0u;
    long long v211 = 0u;
    sub_1B64957BC(a3, (uint64_t)&v211, v29, v30, v31, v32, v33, v34);
    double v143 = sub_1B649609C(a3, v129, v130, v131, v132, v133, v134, v135);
    if (v20 == 1)
    {
      float v144 = sub_1B6496784(a3, v136, v137, v138, v139, v140, v141, v142);
      double v145 = v144;
      float v153 = sub_1B64966CC(a3, v146, v147, v148, v149, v150, v151, v152);
      double v161 = __tanpi(0.25);
      uint64_t v162 = 0;
      if (v161 == 0.0) {
        double v163 = 1.0;
      }
      else {
        double v163 = 1.0 / v161;
      }
      float v164 = v163;
      double v165 = v145 + 1.0;
      if (v153 > v144) {
        double v165 = v153;
      }
      double v166 = v165 / (v145 - v165);
      *(float *)&unsigned int v167 = v166;
      float v168 = v164;
      LODWORD(v169) = 0;
      *((float *)&v169 + 1) = v164;
      *(float *)&unsigned int v170 = v166 * v145;
      *(void *)&long long v171 = 0;
      *((void *)&v171 + 1) = __PAIR64__(-1.0, v167);
      *(void *)&long long v172 = 0;
      *((void *)&v172 + 1) = v170;
      long long v226 = LODWORD(v168);
      long long v227 = v169;
      long long v228 = v171;
      long long v229 = v172;
      float32x4_t v222 = 0u;
      simd_float4 v223 = 0u;
      simd_float4 v224 = 0u;
      long long v225 = 0u;
      do
      {
        *(float32x4_t *)((char *)&v222 + v162) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(long long *)((char *)&v226 + v162))), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)((char *)&v226 + v162), 1), (float32x4_t)xmmword_1B6E4F340, *(float32x4_t *)((char *)&v226 + v162), 2), (float32x4_t)xmmword_1B6E4F360, *(float32x4_t *)((char *)&v226 + v162), 3);
        v162 += 16;
      }
      while (v162 != 64);
      simd_float4 v173 = v223;
      simd_float4 v174 = v224;
      int v207 = DWORD2(v225);
      long long v175 = v225;
      *(float32x4_t *)(a4 + 128) = v222;
      *(simd_float4 *)(a4 + 144) = v173;
      *(simd_float4 *)(a4 + 160) = v174;
      *(_OWORD *)(a4 + 176) = v175;
      float v176 = v174.f32[2];
      float v184 = sub_1B6495FE4(a3, v154, v155, v156, v157, v158, v159, v160);
      *(float *)&long long v185 = -v176;
      DWORD1(v185) = v207;
      *((float *)&v185 + 2) = v184 * 0.001;
      *(_OWORD *)(a4 + 192) = v185;
    }
    else
    {
      v186.i64[0] = 0;
      *(double *)&v186.i64[1] = v143;
      float32x4_t v222 = v186;
      float32x4_t v187 = sub_1B649CD50((unsigned __int8 *)&v211, (uint64_t)&v222, v137, v138, v139, v140, v141, v142);
      long long v188 = *((_OWORD *)v187 + 3);
      long long v190 = *(_OWORD *)v187;
      long long v189 = *((_OWORD *)v187 + 1);
      *(_OWORD *)(a4 + 160) = *((_OWORD *)v187 + 2);
      *(_OWORD *)(a4 + 176) = v188;
      *(_OWORD *)(a4 + 128) = v190;
      *(_OWORD *)(a4 + 144) = v189;
    }
    float32x4_t v191 = (long long *)sub_1B64A01D4((uint64_t)a2, v177, v178, v179, v180, v181, v182, v183);
    long long v192 = v191[3];
    long long v194 = *v191;
    long long v193 = v191[1];
    *(_OWORD *)(a4 + 32) = v191[2];
    *(_OWORD *)(a4 + 48) = v192;
    *(_OWORD *)a4 = v194;
    *(_OWORD *)(a4 + 16) = v193;
    *(simd_float4x4 *)(a4 + 64) = __invert_f4(*(simd_float4x4 *)a4);
  }
}

void sub_1B63C41A0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, simd_float4 *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, (uint64_t)a5, a6, a7, a8, (uint64_t)"lightNode");
  }
  sub_1B63C1AE8(a1);
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (Value)
  {
    uint64_t v24 = a1 + 8 * (Value >> 28);
    uint64_t v25 = (Value & 0xFFFFFFF) - 1;
    uint64_t v26 = *(void *)(*(void *)(v24 + 216) + 8 * v25);
    if (sub_1B649535C(v26, v17, v18, v19, v20, v21, v22, v23))
    {
      if (*(unsigned char *)(*(void *)(v24 + 408) + v25))
      {
        if (*(_DWORD *)(a1 + 116776) < 9u)
        {
          uint64_t v33 = a1 + 2336 * (*(unsigned __int8 *)(*(void *)(v24 + 408) + v25) - 1) + 116784;
          sub_1B63C3AE8((float32x4_t *)a1, a2, v26, v33, v29, v30, v31, v32);
          __n128 v100 = *(__n128 *)(a1 + 116704);
          __n128 v98 = *(__n128 *)(a1 + 116736);
          __n128 v99 = *(__n128 *)(a1 + 116720);
          __n128 v97 = *(__n128 *)(a1 + 116752);
          uint64_t v41 = sub_1B6495454(v26, v34, v35, v36, v37, v38, v39, v40);
          if (v41)
          {
            uint64_t v41 = sub_1B64954A8(v26, v42, v43, v44, v45, v46, v47, v48);
            int v49 = v41;
          }
          else
          {
            int v49 = 1;
          }
          *(double *)v107.columns[0].i64 = sub_1B63C2A48(*(__n128 *)(v33 + 64), *(__n128 *)(v33 + 80), *(__n128 *)(v33 + 96), *(__n128 *)(v33 + 112), *(__n128 *)(v33 + 128), *(__n128 *)(v33 + 144), *(__n128 *)(v33 + 160), *(__n128 *)(v33 + 176), v41, v42, v43, v44, v45, v46, v47, v48, v100, v99, v98,
                                             v97);
          simd_float4 v91 = v107.columns[1];
          simd_float4 v92 = v107.columns[0];
          simd_float4 v89 = v107.columns[3];
          simd_float4 v90 = v107.columns[2];
          simd_float4x4 v108 = __invert_f4(v107);
          simd_float4 v95 = v108.columns[1];
          simd_float4 v96 = v108.columns[0];
          simd_float4 v93 = v108.columns[3];
          simd_float4 v94 = v108.columns[2];
          if (v49)
          {
            uint64_t v58 = 0;
            __asm { FMOV            V0.4S, #1.0 }
            long long v88 = _Q0;
            do
            {
              if (a3)
              {
                float v64 = (long long *)(v33 + 384 * v58);
                uint64_t v65 = (_OWORD *)(a3 + (v58 << 6));
                long long v66 = *v64;
                long long v67 = v64[1];
                long long v68 = v64[3];
                v65[2] = v64[2];
                v65[3] = v68;
                _OWORD *v65 = v66;
                v65[1] = v67;
              }
              if (a4)
              {
                uint64_t v69 = (_OWORD *)(a4 + (v58 << 6));
                uint64_t v70 = (_OWORD *)(v33 + 384 * v58);
                long long v71 = v70[8];
                long long v72 = v70[9];
                long long v73 = v70[11];
                v69[2] = v70[10];
                v69[3] = v73;
                _OWORD *v69 = v71;
                v69[1] = v72;
              }
              if (v58)
              {
                uint64_t v74 = (__n128 *)(v33 + 384 * v58);
                *(double *)v75.i64 = sub_1B63C2A48(v74[4], v74[5], v74[6], v74[7], v74[8], v74[9], v74[10], v74[11], v50, v51, v52, v53, v54, v55, v56, v57, v100, v99, v98,
                                       v97);
                uint64_t v79 = 0;
                v101[0] = v96;
                v101[1] = v95;
                v101[2] = v94;
                v101[3] = v93;
                long long v102 = 0u;
                long long v103 = 0u;
                long long v104 = 0u;
                long long v105 = 0u;
                do
                {
                  *(long long *)((char *)&v102 + v79 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v75, COERCE_FLOAT(v101[v79])), v76, *(float32x2_t *)&v101[v79], 1), v77, (float32x4_t)v101[v79], 2), v78, (float32x4_t)v101[v79], 3);
                  ++v79;
                }
                while (v79 != 4);
                long long v80 = v102;
                long long v81 = v105;
                DWORD1(v80) = DWORD1(v103);
                DWORD2(v80) = DWORD2(v104);
                uint64_t v82 = v33 + 384 * v58;
                *(_OWORD *)(v82 + 192) = v80;
                *(_OWORD *)(v82 + 208) = v81;
                if (a5)
                {
                  float32x4_t v83 = (float32x4_t *)&a5[4 * v58];
                  *float32x4_t v83 = v75;
                  v83[1] = v76;
                  float32x4_t v83[2] = v77;
                  v83[3] = v78;
                }
              }
              else
              {
                uint64_t v50 = sub_1B6496680(v26, v51, v52, v53, v54, v55, v56, v57);
                if (v50 != 1)
                {
                  *(_OWORD *)(v33 + 192) = v88;
                  *(_OWORD *)(v33 + 208) = 0u;
                }
                if (a5)
                {
                  *a5 = v92;
                  a5[1] = v91;
                  a5[2] = v90;
                  a5[3] = v89;
                }
              }
              if (a6)
              {
                long long v84 = *(_OWORD *)(v33 + 384 * v58 + 192);
                uint64_t v85 = a6 + 16 * v58;
                HIDWORD(v84) = *(_DWORD *)(v85 + 12);
                *(_OWORD *)uint64_t v85 = v84;
              }
              if (a7)
              {
                long long v86 = *(_OWORD *)(v33 + 384 * v58 + 208);
                uint64_t v87 = a7 + 16 * v58;
                HIDWORD(v86) = *(_DWORD *)(v87 + 12);
                *(_OWORD *)uint64_t v87 = v86;
              }
              ++v58;
            }
            while (v58 != v49);
          }
        }
        else if ((byte_1E9DDA50A & 1) == 0)
        {
          byte_1E9DDA50A = 1;
          sub_1B63F2F54(16, @"Error: Too many shadow caster lights at once. Limit is %d", v27, v28, v29, v30, v31, v32, 8);
        }
      }
    }
    else
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Light does not casts shadow. Cannot compute shadow parameters.", v27, v28, v29, v30, v31, v32, (uint64_t)"0");
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: The shadow node is not registered", v18, v19, v20, v21, v22, v23, a9);
  }
}

uint64_t sub_1B63C4554(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 100);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(a2 + 16))(a2, v2, *(void *)(result + 192), *(void *)(result + 256), *(void *)(result + 496));
  }
  return result;
}

uint64_t sub_1B63C4580(uint64_t result, uint64_t a2)
{
  *(void *)(result + 48) = a2;
  return result;
}

uint64_t sub_1B63C4588(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

const void *sub_1B63C4590(uint64_t a1, const void *a2)
{
  double result = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (result) {
    return (const void *)*(unsigned __int8 *)((result & 0xFFFFFFF)
  }
                                            + *(void *)(a1 + 8 * (result >> 28) + 408)
                                            - 1);
  return result;
}

uint64_t sub_1B63C45D4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    if (a2 >= 9) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Max caster index overflow", a3, a4, a5, a6, a7, a8, (uint64_t)"casterIndex <= kMaxRuntimeShadows");
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. 0 caster index is reserved", a3, a4, a5, a6, a7, a8, (uint64_t)"casterIndex > 0");
  }
  return a1 + 2336 * a2 + 114448;
}

uint64_t sub_1B63C4650(uint64_t a1)
{
  return a1 + 135472;
}

uint64_t sub_1B63C465C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116776);
}

void sub_1B63C4670(uint64_t a1)
{
  CFRelease(*(CFTypeRef *)(a1 + 24));
  CFRelease(*(CFTypeRef *)(a1 + 32));
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 56));
  CFRelease(*(CFTypeRef *)(a1 + 512));
  CFRelease(*(CFTypeRef *)(a1 + 504));
  uint64_t v2 = *(const void **)(a1 + 116504);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 116504) = 0;
  }
  uint64_t v3 = a1 + 408;
  uint64_t v4 = -64;
  do
  {
    free(*(void **)(v3 + v4 - 192));
    free(*(void **)(v3 + v4 - 128));
    free(*(void **)(v3 + v4 - 64));
    free(*(void **)(v3 + v4));
    free(*(void **)(v3 + v4 + 64));
    v4 += 8;
  }
  while (v4);
  free(*(void **)(a1 + 472));
  free(*(void **)(a1 + 480));
  free(*(void **)(a1 + 488));
  free(*(void **)(a1 + 496));
  uint64_t v5 = 0;
  uint64_t v6 = a1 + 117024;
  do
  {
    for (uint64_t i = 0; i != 1536; i += 384)
    {
      int8x16_t v8 = *(const void **)(v6 + i);
      if (v8)
      {
        CFRelease(v8);
        *(void *)(v6 + i) = 0;
      }
    }
    ++v5;
    v6 += 2336;
  }
  while (v5 != 8);
}

CFStringRef sub_1B63C4778(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXLightingSystem %p>", a1);
}

CFStringRef sub_1B63C47B8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXLightingSystem %p>", a1);
}

BOOL sub_1B63C47F8(CFTypeRef cf1, const void *a2)
{
  BOOL result = 0;
  if (cf1)
  {
    if (a2) {
      return CFEqual(cf1, a2) != 0;
    }
  }
  return result;
}

float32x4_t *moveSystem(float32x4_t *result, float32x4_t *a2, unsigned int a3, int32x2_t a4)
{
  if (a3)
  {
    float32x4_t v4 = (float32x4_t)vdupq_lane_s32(a4, 0);
    uint64_t v5 = a3;
    __asm { FMOV            V1.4S, #10.0 }
    do
    {
      float32x4_t v11 = vmlaq_f32(*result, v4, *a2);
      int32x4_t v12 = vcgtq_f32(vabsq_f32(v11), _Q1);
      uint32x4_t v13 = (uint32x4_t)v12;
      v13.i32[3] = v12.i32[2];
      if ((vmaxvq_u32(v13) & 0x80000000) != 0)
      {
        v12.i32[3] = 0;
        int8x16_t v14 = vbslq_s8((int8x16_t)vcltzq_s32(v12), (int8x16_t)vnegq_f32(*a2), *(int8x16_t *)a2);
        v14.i32[3] = HIDWORD(*(unsigned long long *)a2);
        *a2 = (float32x4_t)v14;
      }
      else
      {
        v11.i32[3] = HIDWORD(*(unsigned long long *)result);
        const void *result = v11;
      }
      ++result;
      ++a2;
      --v5;
    }
    while (v5);
  }
  return result;
}

float32x4_t globalClamp(float32x4_t *a1, int8x16_t *a2, float32x4_t a3)
{
  v3.i64[0] = 0x8000000080000000;
  v3.i64[1] = 0x8000000080000000;
  *a2 = veorq_s8(vandq_s8((int8x16_t)vcgtq_f32(*a1, a3), v3), *a2);
  float32x4_t result = vmaxnmq_f32(vnegq_f32(a3), vminnmq_f32(*a1, a3));
  *a1 = result;
  return result;
}

float srdnoise3(_OWORD *a1, float a2, float a3, float a4, float a5)
{
  __float2 v10 = __sincosf_stret(a5);
  float v11 = (float)((float)(a2 + a3) + a4) * 0.33333;
  float v12 = floorf(v11 + a2);
  float v13 = floorf(v11 + a3);
  float v14 = floorf(v11 + a4);
  float v15 = (float)(v14 + (float)(v12 + v13)) * 0.16667;
  float v16 = v13 - v15;
  float v17 = v14 - v15;
  float v18 = a2 - (float)(v12 - v15);
  float v19 = a3 - v16;
  float v20 = a4 - v17;
  if (v18 >= v19)
  {
    int v22 = 0;
    if (v19 < v20)
    {
      int v25 = 0;
      BOOL v21 = v18 >= v20;
      BOOL v24 = v18 < v20;
      BOOL v23 = 1;
      goto LABEL_6;
    }
    BOOL v24 = 0;
    BOOL v26 = 0;
    BOOL v21 = 1;
    BOOL v23 = 1;
  }
  else
  {
    BOOL v21 = 0;
    if (v19 < v20)
    {
      int v22 = 0;
      BOOL v23 = 0;
      BOOL v24 = 1;
      int v25 = 1;
LABEL_6:
      BOOL v26 = 1;
      goto LABEL_10;
    }
    BOOL v24 = 0;
    BOOL v23 = v18 >= v20;
    BOOL v26 = v18 < v20;
    int v22 = 1;
  }
  int v25 = 1;
LABEL_10:
  float v27 = (float)(v18 - (float)v21) + 0.16667;
  float v28 = (float)(v19 - (float)v22) + 0.16667;
  float v29 = (float)(v20 - (float)v24) + 0.16667;
  int v30 = (int)v12;
  unsigned int v31 = (int)v13;
  uint64_t v32 = (int)v14;
  float v33 = (float)((float)(0.6 - (float)(v18 * v18)) - (float)(v19 * v19)) - (float)(v20 * v20);
  float v34 = 0.0;
  float v35 = 0.0;
  float v36 = 0.0;
  float v37 = 0.0;
  float v38 = 0.0;
  float v39 = 0.0;
  float v40 = 0.0;
  float v41 = 0.0;
  if (v33 >= 0.0)
  {
    uint64_t v42 = (float *)((char *)&unk_1B6E4F570
                  + 12
                  * (byte_1B6E4F6F0[byte_1B6E4F6F0[byte_1B6E4F6F0[v32] + (unint64_t)v31]
                                  + (unint64_t)(int)v12] & 0xF));
    uint64_t v43 = (float *)((char *)&unk_1B6E4F630
                  + 12
                  * (byte_1B6E4F6F0[byte_1B6E4F6F0[byte_1B6E4F6F0[v32] + (unint64_t)v31]
                                  + (unint64_t)(int)v12] & 0xF));
    float v35 = (float)(v10.__sinval * *v43) + (float)(v10.__cosval * *v42);
    float v36 = (float)(v10.__sinval * v43[1]) + (float)(v10.__cosval * v42[1]);
    float v37 = (float)(v10.__sinval * v43[2]) + (float)(v10.__cosval * v42[2]);
    float v39 = v33 * v33;
    float v40 = v39 * v39;
    float v41 = (float)(v39 * v39) * (float)((float)((float)(v19 * v36) + (float)(v35 * v18)) + (float)(v37 * v20));
    float v38 = (float)((float)(0.6 - (float)(v18 * v18)) - (float)(v19 * v19)) - (float)(v20 * v20);
  }
  float v94 = v38;
  float v95 = v35;
  float v96 = v36;
  float v97 = v37;
  float v102 = v41;
  float v44 = (float)(v18 - (float)v23) + 0.33333;
  float v45 = (float)(v19 - (float)v25) + 0.33333;
  float v46 = (float)(v20 - (float)v26) + 0.33333;
  float v47 = (float)((float)(0.6 - (float)(v27 * v27)) - (float)(v28 * v28)) - (float)(v29 * v29);
  float v48 = 0.0;
  float v49 = 0.0;
  float v50 = 0.0;
  float v51 = 0.0;
  float v52 = 0.0;
  float v53 = 0.0;
  if (v47 >= 0.0)
  {
    uint64_t v54 = 3
        * (byte_1B6E4F6F0[(v21 + v30)
                        + (unint64_t)byte_1B6E4F6F0[v22
                                                         + v31
                                                         + (unint64_t)byte_1B6E4F6F0[v24
                                                                                          + (unint64_t)v32]]] & 0xF);
    uint64_t v55 = (float *)((char *)&unk_1B6E4F570 + 4 * v54);
    uint64_t v56 = (float *)((char *)&unk_1B6E4F630 + 4 * v54);
    float v34 = (float)(v10.__sinval * *v56) + (float)(v10.__cosval * *v55);
    float v48 = (float)(v10.__sinval * v56[1]) + (float)(v10.__cosval * v55[1]);
    float v49 = (float)(v10.__sinval * v56[2]) + (float)(v10.__cosval * v55[2]);
    float v51 = v47 * v47;
    float v52 = v51 * v51;
    float v53 = (float)(v51 * v51) * (float)((float)((float)(v28 * v48) + (float)(v34 * v27)) + (float)(v49 * v29));
    float v50 = (float)((float)(0.6 - (float)(v27 * v27)) - (float)(v28 * v28)) - (float)(v29 * v29);
  }
  float v93 = v49;
  float v100 = (float)(v18 - (float)v21) + 0.16667;
  float v101 = v53;
  float v98 = v29;
  float v99 = v28;
  float v57 = (float)(v18 + -1.0) + 0.5;
  float v58 = (float)(v19 + -1.0) + 0.5;
  float v59 = (float)(v20 + -1.0) + 0.5;
  float v60 = (float)((float)(0.6 - (float)(v44 * v44)) - (float)(v45 * v45)) - (float)(v46 * v46);
  float v61 = 0.0;
  float v62 = 0.0;
  float v63 = 0.0;
  float v64 = 0.0;
  float v65 = 0.0;
  float v66 = 0.0;
  float v67 = 0.0;
  float v68 = 0.0;
  if (v60 >= 0.0)
  {
    uint64_t v69 = 3
        * (byte_1B6E4F6F0[(v23 + v30)
                        + (unint64_t)byte_1B6E4F6F0[v25
                                                         + v31
                                                         + (unint64_t)byte_1B6E4F6F0[v26
                                                                                          + (unint64_t)v32]]] & 0xF);
    uint64_t v70 = (float *)((char *)&unk_1B6E4F570 + 4 * v69);
    long long v71 = (float *)((char *)&unk_1B6E4F630 + 4 * v69);
    float v62 = (float)(v10.__sinval * *v71) + (float)(v10.__cosval * *v70);
    float v63 = (float)(v10.__sinval * v71[1]) + (float)(v10.__cosval * v70[1]);
    float v64 = (float)(v10.__sinval * v71[2]) + (float)(v10.__cosval * v70[2]);
    float v66 = v60 * v60;
    float v67 = v66 * v66;
    float v68 = (float)(v66 * v66) * (float)((float)((float)(v45 * v63) + (float)(v62 * v44)) + (float)(v64 * v46));
    float v65 = (float)((float)(0.6 - (float)(v44 * v44)) - (float)(v45 * v45)) - (float)(v46 * v46);
  }
  float v92 = v62;
  float v72 = (float)((float)(0.6 - (float)(v57 * v57)) - (float)(v58 * v58)) - (float)(v59 * v59);
  float v73 = 0.0;
  float v74 = 0.0;
  float v75 = 0.0;
  float v76 = 0.0;
  float v77 = 0.0;
  float v78 = 0.0;
  if (v72 >= 0.0)
  {
    uint64_t v79 = 3
        * (byte_1B6E4F6F0[(v30 + 1)
                        + (unint64_t)byte_1B6E4F6F0[v31
                                                         + 1
                                                         + (unint64_t)byte_1B6E4F6F0[v32 + 1]]] & 0xF);
    long long v80 = (float *)((char *)&unk_1B6E4F570 + 4 * v79);
    long long v81 = (float *)((char *)&unk_1B6E4F630 + 4 * v79);
    float v61 = (float)(v10.__sinval * *v81) + (float)(v10.__cosval * *v80);
    float v73 = (float)(v10.__sinval * v81[1]) + (float)(v10.__cosval * v80[1]);
    float v74 = (float)(v10.__sinval * v81[2]) + (float)(v10.__cosval * v80[2]);
    float v76 = v72 * v72;
    float v77 = v76 * v76;
    float v78 = (float)(v76 * v76) * (float)((float)((float)(v58 * v73) + (float)(v61 * v57)) + (float)(v74 * v59));
    float v75 = (float)((float)(0.6 - (float)(v57 * v57)) - (float)(v58 * v58)) - (float)(v59 * v59);
  }
  if (a1)
  {
    float v82 = (float)((float)((float)(v19 * v96) + (float)(v95 * v18)) + (float)(v97 * v20)) * (float)(v94 * v39);
    *(float *)&long long v9 = (float)((float)((float)(v99 * v48) + (float)(v34 * v100)) + (float)(v93 * v98)) * (float)(v50 * v51);
    float v83 = (float)(v18 * v82) + (float)(*(float *)&v9 * v100);
    float v84 = (float)(v19 * v82) + (float)(*(float *)&v9 * v99);
    float v85 = (float)(v20 * v82) + (float)(*(float *)&v9 * v98);
    *(float *)&long long v9 = (float)((float)((float)(v45 * v63) + (float)(v92 * v44)) + (float)(v64 * v46)) * (float)(v65 * v66);
    float v86 = v83 + (float)(*(float *)&v9 * v44);
    float v87 = v84 + (float)(*(float *)&v9 * v45);
    float v88 = v85 + (float)(*(float *)&v9 * v46);
    *(float *)&long long v9 = (float)((float)((float)(v58 * v73) + (float)(v61 * v57)) + (float)(v74 * v59)) * (float)(v75 * v76);
    float v89 = v87 + (float)(*(float *)&v9 * v58);
    float v90 = (float)(v88 + (float)(*(float *)&v9 * v59)) * 8.0;
    *(float *)&long long v9 = (float)((float)((float)((float)((float)(v34 * v52) + (float)(v40 * v95)) + (float)(v67 * v92))
                                  + (float)(v77 * v61))
                          - (float)((float)(v86 + (float)(*(float *)&v9 * v57)) * 8.0))
                  * 28.0;
    *((float *)&v9 + 1) = (float)((float)((float)((float)((float)(v48 * v52) + (float)(v40 * v96)) + (float)(v67 * v63))
                                        + (float)(v77 * v73))
                                - (float)(v89 * 8.0))
                        * 28.0;
    *((float *)&v9 + 2) = (float)((float)((float)((float)((float)(v93 * v52) + (float)(v40 * v97)) + (float)(v67 * v64))
                                        + (float)(v77 * v74))
                                - v90)
                        * 28.0;
    *a1 = v9;
  }
  return (float)((float)((float)(v102 + v101) + v68) + v78) * 28.0;
}

double noised(float32x4_t a1)
{
  float32x4_t v1 = a1;
  v1.i32[3] = 0;
  float32x4_t v2 = vrndmq_f32(v1);
  float32x4_t v3 = vsubq_f32(a1, v2);
  float32x4_t v4 = v2;
  float32x4_t v123 = v2;
  v3.i32[3] = 0;
  float32x4_t v5 = vminnmq_f32(v3, (float32x4_t)xmmword_1B6E4F480);
  __asm
  {
    FMOV            V1.4S, #6.0
    FMOV            V2.4S, #-15.0
  }
  float32x4_t v12 = vmlaq_f32(_Q2, _Q1, v5);
  __asm { FMOV            V1.4S, #10.0 }
  float32x4_t v118 = v5;
  float32x4_t v119 = vmulq_f32(vmulq_f32(v5, vmulq_f32(v5, v5)), vmlaq_f32(_Q1, v12, v5));
  __asm { FMOV            V0.4S, #30.0 }
  _Q1.i64[0] = 0xC0000000C0000000;
  _Q1.i64[1] = 0xC0000000C0000000;
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v117 = _Q2;
  float32x4_t v120 = vmulq_f32(vmulq_f32(v5, vmulq_f32(v5, _Q0)), vmlaq_f32(_Q2, vaddq_f32(v5, _Q1), v5));
  float32x4_t v16 = vaddq_f32(v4, (float32x4_t)0);
  simd_float4 v17 = (simd_float4)vmulq_f32(v16, (float32x4_t)xmmword_1B6E4F450);
  v17.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32((float32x4_t)v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).u32[0];
  float32x4_t v18 = vmulq_f32(v16, (float32x4_t)xmmword_1B6E4F460);
  float32x4_t v19 = vmulq_f32(v16, (float32x4_t)xmmword_1B6E4F470);
  v17.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v18, 2), vaddq_f32(v18, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v18.f32, 1))).u32[0];
  v17.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).u32[0];
  float32x4_t v122 = (float32x4_t)vdupq_n_s32(0x472AEE8Cu);
  float32x4_t v20 = vmulq_f32((float32x4_t)_simd_sin_f4(v17), v122);
  float32x4_t v21 = v20;
  v21.i32[3] = 0;
  float32x4_t v22 = vsubq_f32(v20, vrndmq_f32(v21));
  v22.i32[3] = 0;
  v23.i64[0] = 0x4000000040000000;
  v23.i64[1] = 0x4000000040000000;
  __asm { FMOV            V1.4S, #-1.0 }
  float32x4_t v121 = _Q1;
  float32x4_t v116 = vmlaq_f32(_Q1, v23, vminnmq_f32(v22, (float32x4_t)xmmword_1B6E4F480));
  float32x4_t v25 = vaddq_f32(v123, (float32x4_t)xmmword_1B6E4F300);
  simd_float4 v26 = (simd_float4)vmulq_f32(v25, (float32x4_t)xmmword_1B6E4F450);
  float32x4_t v27 = vmulq_f32(v25, (float32x4_t)xmmword_1B6E4F460);
  v26.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32((float32x4_t)v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).u32[0];
  float32x4_t v28 = vmulq_f32(v25, (float32x4_t)xmmword_1B6E4F470);
  v26.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).u32[0];
  v26.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).u32[0];
  float32x4_t v29 = vmulq_f32((float32x4_t)_simd_sin_f4(v26), v122);
  float32x4_t v30 = v29;
  v30.i32[3] = 0;
  float32x4_t v31 = vsubq_f32(v29, vrndmq_f32(v30));
  v31.i32[3] = 0;
  v32.i64[0] = 0x4000000040000000;
  v32.i64[1] = 0x4000000040000000;
  float32x4_t v115 = vmlaq_f32(v121, v32, vminnmq_f32(v31, (float32x4_t)xmmword_1B6E4F480));
  float32x4_t v33 = vaddq_f32(v123, (float32x4_t)xmmword_1B6E4F320);
  simd_float4 v34 = (simd_float4)vmulq_f32(v33, (float32x4_t)xmmword_1B6E4F450);
  float32x4_t v35 = vmulq_f32(v33, (float32x4_t)xmmword_1B6E4F460);
  v34.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 2), vaddq_f32((float32x4_t)v34, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v34.f32, 1))).u32[0];
  float32x4_t v36 = vmulq_f32(v33, (float32x4_t)xmmword_1B6E4F470);
  v34.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), vaddq_f32(v35, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1))).u32[0];
  v34.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), vaddq_f32(v36, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1))).u32[0];
  float32x4_t v37 = vmulq_f32((float32x4_t)_simd_sin_f4(v34), v122);
  float32x4_t v38 = v37;
  v38.i32[3] = 0;
  float32x4_t v39 = vsubq_f32(v37, vrndmq_f32(v38));
  v39.i32[3] = 0;
  v40.i64[0] = 0x4000000040000000;
  v40.i64[1] = 0x4000000040000000;
  float32x4_t v114 = vmlaq_f32(v121, v40, vminnmq_f32(v39, (float32x4_t)xmmword_1B6E4F480));
  float32x4_t v41 = vaddq_f32(v123, (float32x4_t)xmmword_1B6E4F490);
  simd_float4 v42 = (simd_float4)vmulq_f32(v41, (float32x4_t)xmmword_1B6E4F450);
  float32x4_t v43 = vmulq_f32(v41, (float32x4_t)xmmword_1B6E4F460);
  v42.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32((float32x4_t)v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1))).u32[0];
  float32x4_t v44 = vmulq_f32(v41, (float32x4_t)xmmword_1B6E4F470);
  v42.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v43, 2), vaddq_f32(v43, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 1))).u32[0];
  v42.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).u32[0];
  float32x4_t v45 = vmulq_f32((float32x4_t)_simd_sin_f4(v42), v122);
  float32x4_t v46 = v45;
  v46.i32[3] = 0;
  float32x4_t v47 = vsubq_f32(v45, vrndmq_f32(v46));
  v47.i32[3] = 0;
  v48.i64[0] = 0x4000000040000000;
  v48.i64[1] = 0x4000000040000000;
  float32x4_t v113 = vmlaq_f32(v121, v48, vminnmq_f32(v47, (float32x4_t)xmmword_1B6E4F480));
  float32x4_t v49 = vaddq_f32(v123, (float32x4_t)xmmword_1B6E4F2E0);
  simd_float4 v50 = (simd_float4)vmulq_f32(v49, (float32x4_t)xmmword_1B6E4F450);
  float32x4_t v51 = vmulq_f32(v49, (float32x4_t)xmmword_1B6E4F460);
  v50.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32((float32x4_t)v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).u32[0];
  float32x4_t v52 = vmulq_f32(v49, (float32x4_t)xmmword_1B6E4F470);
  v50.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).u32[0];
  v50.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v52, 2), vaddq_f32(v52, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v52.f32, 1))).u32[0];
  float32x4_t v53 = vmulq_f32((float32x4_t)_simd_sin_f4(v50), v122);
  float32x4_t v54 = v53;
  v54.i32[3] = 0;
  float32x4_t v55 = vsubq_f32(v53, vrndmq_f32(v54));
  v55.i32[3] = 0;
  v54.i64[0] = 0x4000000040000000;
  v54.i64[1] = 0x4000000040000000;
  float32x4_t v112 = vmlaq_f32(v121, v54, vminnmq_f32(v55, (float32x4_t)xmmword_1B6E4F480));
  float32x4_t v56 = vaddq_f32(v123, (float32x4_t)xmmword_1B6E4F4A0);
  simd_float4 v57 = (simd_float4)vmulq_f32(v56, (float32x4_t)xmmword_1B6E4F450);
  float32x4_t v58 = vmulq_f32(v56, (float32x4_t)xmmword_1B6E4F460);
  v57.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 2), vaddq_f32((float32x4_t)v57, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 1))).u32[0];
  float32x4_t v59 = vmulq_f32(v56, (float32x4_t)xmmword_1B6E4F470);
  v57.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 2), vaddq_f32(v58, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 1))).u32[0];
  v57.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v59, 2), vaddq_f32(v59, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v59.f32, 1))).u32[0];
  float32x4_t v60 = vmulq_f32((float32x4_t)_simd_sin_f4(v57), v122);
  float32x4_t v61 = v60;
  v61.i32[3] = 0;
  float32x4_t v62 = vsubq_f32(v60, vrndmq_f32(v61));
  v62.i32[3] = 0;
  v61.i64[0] = 0x4000000040000000;
  v61.i64[1] = 0x4000000040000000;
  float32x4_t v111 = vmlaq_f32(v121, v61, vminnmq_f32(v62, (float32x4_t)xmmword_1B6E4F480));
  float32x4_t v63 = vaddq_f32(v123, (float32x4_t)xmmword_1B6E4F4B0);
  simd_float4 v64 = (simd_float4)vmulq_f32(v63, (float32x4_t)xmmword_1B6E4F450);
  float32x4_t v65 = vmulq_f32(v63, (float32x4_t)xmmword_1B6E4F460);
  v64.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v64, 2), vaddq_f32((float32x4_t)v64, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v64.f32, 1))).u32[0];
  float32x4_t v66 = vmulq_f32(v63, (float32x4_t)xmmword_1B6E4F470);
  v64.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 2), vaddq_f32(v65, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v65.f32, 1))).u32[0];
  v64.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 2), vaddq_f32(v66, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v66.f32, 1))).u32[0];
  float32x4_t v67 = vmulq_f32((float32x4_t)_simd_sin_f4(v64), v122);
  float32x4_t v68 = v67;
  v68.i32[3] = 0;
  float32x4_t v69 = vsubq_f32(v67, vrndmq_f32(v68));
  v69.i32[3] = 0;
  v68.i64[0] = 0x4000000040000000;
  v68.i64[1] = 0x4000000040000000;
  float32x4_t v110 = vmlaq_f32(v121, v68, vminnmq_f32(v69, (float32x4_t)xmmword_1B6E4F480));
  float32x4_t v70 = vaddq_f32(v123, v117);
  simd_float4 v71 = (simd_float4)vmulq_f32(v70, (float32x4_t)xmmword_1B6E4F450);
  float32x4_t v72 = vmulq_f32(v70, (float32x4_t)xmmword_1B6E4F460);
  v71.i32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v71, 2), vaddq_f32((float32x4_t)v71, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v71.f32, 1))).u32[0];
  float32x4_t v73 = vmulq_f32(v70, (float32x4_t)xmmword_1B6E4F470);
  v71.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 2), vaddq_f32(v72, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v72.f32, 1))).u32[0];
  v71.i64[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v73, 2), vaddq_f32(v73, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v73.f32, 1))).u32[0];
  float32x4_t v74 = vmulq_f32((float32x4_t)_simd_sin_f4(v71), v122);
  float32x4_t v75 = v74;
  v75.i32[3] = 0;
  float32x4_t v76 = vsubq_f32(v74, vrndmq_f32(v75));
  v76.i32[3] = 0;
  float32x4_t v77 = vminnmq_f32(v76, (float32x4_t)xmmword_1B6E4F480);
  v78.i64[0] = 0x4000000040000000;
  v78.i64[1] = 0x4000000040000000;
  float32x4_t v79 = vmlaq_f32(v121, v78, v77);
  int8x16_t v80 = (int8x16_t)vmulq_f32(v118, v116);
  v77.f32[0] = vaddv_f32(*(float32x2_t *)v80.i8);
  float32x4_t v81 = vmulq_f32(vaddq_f32(v118, (float32x4_t)xmmword_1B6E4F4C0), v115);
  float v82 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 2), vaddq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 1))).f32[0];
  float32x4_t v83 = vmulq_f32(vaddq_f32(v118, (float32x4_t)xmmword_1B6E4F4D0), v114);
  int8x16_t v84 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 2), vaddq_f32(v83, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.f32, 1)));
  float32x4_t v85 = vmulq_f32(vaddq_f32(v118, (float32x4_t)xmmword_1B6E4F4E0), v113);
  v85.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v85, 2), vaddq_f32(v85, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v85.f32, 1))).f32[0];
  float32x4_t v86 = vmulq_f32(vaddq_f32(v118, (float32x4_t)xmmword_1B6E4F4F0), v112);
  float32x4_t v87 = vmulq_f32(vaddq_f32(v118, (float32x4_t)xmmword_1B6E4F500), v111);
  v87.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v87, 2), vaddq_f32(v87, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.f32, 1))).f32[0];
  float32x4_t v88 = vmulq_f32(vaddq_f32(v118, (float32x4_t)xmmword_1B6E4F510), v110);
  v88.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v88, 2), vaddq_f32(v88, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v88.f32, 1))).f32[0];
  float32x4_t v89 = vmulq_f32(vaddq_f32(v118, v121), v79);
  _Q26 = v119;
  float v91 = vmuls_lane_f32(_Q26.f32[0], *(float32x2_t *)_Q26.f32, 1);
  int8x16_t v92 = vextq_s8(v80, v80, 8uLL);
  v92.i32[1] = v86.i32[0];
  v86.i32[0] = v77.i32[0];
  *(float32x2_t *)v92.i8 = vadd_f32(*(float32x2_t *)v92.i8, *(float32x2_t *)v86.f32);
  v77.f32[0] = v82 - *(float *)v92.i32;
  _S21 = *(float *)v84.i32 - *(float *)v92.i32;
  _S22 = (float)(*(float *)&v92.i32[1] + v86.f32[2]) - *(float *)v92.i32;
  v86.f32[0] = *(float *)v92.i32 - v82;
  float v95 = *(float *)v92.i32 - *(float *)v84.i32;
  __asm
  {
    FMLA            S23, S21, V26.S[1]
    FMLA            S23, S22, V26.S[2]
  }
  *(float *)v92.i32 = (float)(v86.f32[0] - *(float *)v84.i32) + v85.f32[0];
  float v98 = vmuls_lane_f32(v119.f32[1], v119, 2);
  float32_t v99 = (float)(v95 - (float)(*(float *)&v92.i32[1] + v86.f32[2])) + v88.f32[0];
  float v100 = vmuls_lane_f32(_Q26.f32[0], _Q26, 2);
  v86.f32[0] = (float)(v86.f32[0] - (float)(*(float *)&v92.i32[1] + v86.f32[2])) + v87.f32[0];
  float v101 = vmuls_lane_f32(v91, v119, 2);
  v87.f32[0] = (float)((float)((float)((float)((float)(v77.f32[0] + *(float *)v84.i32) - v85.f32[0])
                                     + (float)(*(float *)&v92.i32[1] + v86.f32[2]))
                             - v87.f32[0])
                     - v88.f32[0])
             + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v89, 2), vaddq_f32(v89, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v89.f32, 1))).f32[0];
  *(float *)v84.i32 = (float)((float)((float)(_S23 + (float)(v91 * *(float *)v92.i32)) + (float)(v98 * v99))
                            + (float)(v100 * v86.f32[0]))
                    + (float)(v101 * v87.f32[0]);
  float32x4_t v102 = vsubq_f32(v115, v116);
  float32x4_t v103 = vsubq_f32(v116, v115);
  v77.f32[1] = _S21;
  float32x4_t v104 = vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmlaq_n_f32(v116, v102, v119.f32[0]), vsubq_f32(v114, v116), *(float32x2_t *)v119.f32, 1), vsubq_f32(v112, v116), v119, 2), vaddq_f32(vsubq_f32(v103, v114), v113), v91), vaddq_f32(vsubq_f32(vsubq_f32(v116, v114), v112), v110), v98), vaddq_f32(vsubq_f32(v103, v112), v111), v100), vaddq_f32(vsubq_f32(vsubq_f32(vaddq_f32(vsubq_f32(vaddq_f32(v102, v114), v113), v112), v111), v110), v79),
           v101);
  v77.f32[2] = _S22;
  float32x4_t v105 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)_Q26, (int8x16_t)_Q26, 0xCuLL), (int8x16_t)v119, 8uLL);
  float32x4_t v106 = (float32x4_t)v92;
  v106.f32[1] = v99;
  v106.i32[2] = v86.i32[0];
  float32x4_t v107 = vmlaq_f32(v77, v106, v105);
  float32x4_t v108 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q26, (int32x4_t)_Q26), (int8x16_t)v119, 0xCuLL);
  v86.i32[1] = v92.i32[0];
  v86.f32[2] = v99;
  *(void *)&double result = vextq_s8(vextq_s8(v84, v84, 4uLL), (int8x16_t)vmlaq_f32(v104, vmlaq_n_f32(vmlaq_f32(v107, v86, v108), vmulq_f32(v105, v108), v87.f32[0]), v120), 0xCuLL).u64[0];
  return result;
}

uint64_t sub_1B63C5620(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v4 = 0;
    float32x4_t v5 = *(float32x4_t **)result;
    uint64_t v6 = *(float32x4_t **)(result + 8);
    int8x16_t v7 = *(float32x4_t **)(result + 16);
    uint64_t v8 = a4;
    uint64_t v9 = *(void *)result + 16;
    v10.i64[0] = 0x400000004;
    v10.i64[1] = 0x400000004;
    do
    {
      int32x4_t v11 = *(int32x4_t *)(a2 + 16 * v4);
      float32x4_t v12 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 0);
      float32x4_t v13 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 1);
      float32x4_t v14 = (float32x4_t)vdupq_laneq_s32(v11, 2);
      float32x4_t v15 = vsubq_f32(v12, *v5);
      float32x4_t v16 = vsubq_f32(v13, *v6);
      float32x4_t v17 = vsubq_f32(v14, *v7);
      float32x4_t v18 = vmlaq_f32(vmlaq_f32(vmulq_f32(v16, v16), v15, v15), v17, v17);
      unint64_t v19 = *(unsigned int *)(result + 24);
      if (v19 < 5)
      {
        int64x2_t v24 = (int64x2_t)xmmword_1B6E4B1A0;
      }
      else
      {
        float32x4_t v20 = v7 + 1;
        float32x4_t v21 = v6 + 1;
        float32x4_t v22 = (float32x4_t *)v9;
        unint64_t v23 = 4;
        int64x2_t v24 = (int64x2_t)xmmword_1B6E4B1A0;
        int32x4_t v25 = (int32x4_t)xmmword_1B6E4B190;
        do
        {
          float32x4_t v26 = *v22++;
          float32x4_t v27 = v26;
          float32x4_t v28 = *v21++;
          float32x4_t v29 = v28;
          float32x4_t v30 = *v20++;
          float32x4_t v31 = vsubq_f32(v12, v27);
          float32x4_t v32 = vsubq_f32(v13, v29);
          float32x4_t v33 = vsubq_f32(v14, v30);
          float32x4_t v34 = vmlaq_f32(vmlaq_f32(vmulq_f32(v32, v32), v31, v31), v33, v33);
          int8x16_t v35 = (int8x16_t)vcgtq_f32(v18, v34);
          float32x4_t v18 = vminnmq_f32(v34, v18);
          int64x2_t v24 = (int64x2_t)vbslq_s8(v35, (int8x16_t)v25, (int8x16_t)v24);
          v23 += 4;
          int32x4_t v25 = vaddq_s32(v25, v10);
        }
        while (v23 < v19);
      }
      float32x4_t v36 = (float32x4_t)vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL);
      float32x4_t v37 = vminnmq_f32(v18, v36);
      int8x16_t v38 = vbslq_s8((int8x16_t)vcgtq_f32(v18, v36), (int8x16_t)vdupq_laneq_s64(v24, 1), (int8x16_t)v24);
      *(_DWORD *)(a3 + 4 * v4++) = *(_DWORD *)((unint64_t)&v38 & 0xFFFFFFFFFFFFFFFBLL | (4
                                                                                              * (*(void *)&vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1), v37))) & 1)));
    }
    while (v4 != v8);
  }
  return result;
}

uint64_t sub_1B63C5748(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  if (!a4) {
    return 0;
  }
  uint64_t v5 = 0;
  uint64_t v6 = *(float32x4_t **)a1;
  int8x16_t v7 = *(float32x4_t **)(a1 + 8);
  uint64_t v8 = *(float32x4_t **)(a1 + 16);
  uint64_t v9 = a5;
  uint64_t v10 = a4;
  uint64_t v11 = *(void *)a1 + 16;
  LOBYTE(v12) = 1;
  v13.i64[0] = 0x400000004;
  v13.i64[1] = 0x400000004;
  do
  {
    int32x4_t v14 = *(int32x4_t *)(a2 + 16 * v5);
    float32x4_t v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.i8, 0);
    float32x4_t v16 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v14.i8, 1);
    float32x4_t v17 = (float32x4_t)vdupq_laneq_s32(v14, 2);
    float32x4_t v18 = vsubq_f32(v15, *v6);
    float32x4_t v19 = vsubq_f32(v16, *v7);
    float32x4_t v20 = vsubq_f32(v17, *v8);
    float32x4_t v21 = vmlaq_f32(vmlaq_f32(vmulq_f32(v19, v19), v18, v18), v20, v20);
    unint64_t v22 = *(unsigned int *)(a1 + 24);
    if (v22 < 5)
    {
      int64x2_t v27 = (int64x2_t)xmmword_1B6E4B1A0;
    }
    else
    {
      unint64_t v23 = v8 + 1;
      int64x2_t v24 = v7 + 1;
      int32x4_t v25 = (float32x4_t *)v11;
      unint64_t v26 = 4;
      int64x2_t v27 = (int64x2_t)xmmword_1B6E4B1A0;
      int32x4_t v28 = (int32x4_t)xmmword_1B6E4B190;
      do
      {
        float32x4_t v29 = *v25++;
        float32x4_t v30 = v29;
        float32x4_t v31 = *v24++;
        float32x4_t v32 = v31;
        float32x4_t v33 = *v23++;
        float32x4_t v34 = vsubq_f32(v15, v30);
        float32x4_t v35 = vsubq_f32(v16, v32);
        float32x4_t v36 = vsubq_f32(v17, v33);
        float32x4_t v37 = vmlaq_f32(vmlaq_f32(vmulq_f32(v35, v35), v34, v34), v36, v36);
        int8x16_t v38 = (int8x16_t)vcgtq_f32(v21, v37);
        float32x4_t v21 = vminnmq_f32(v37, v21);
        int64x2_t v27 = (int64x2_t)vbslq_s8(v38, (int8x16_t)v28, (int8x16_t)v27);
        v26 += 4;
        int32x4_t v28 = vaddq_s32(v28, v13);
      }
      while (v26 < v22);
    }
    float32x4_t v39 = (float32x4_t)vextq_s8((int8x16_t)v21, (int8x16_t)v21, 8uLL);
    float32x4_t v40 = vminnmq_f32(v21, v39);
    int8x16_t v43 = vbslq_s8((int8x16_t)vcgtq_f32(v21, v39), (int8x16_t)vdupq_laneq_s64(v27, 1), (int8x16_t)v27);
    uint64_t v41 = *(int *)((unint64_t)&v43 & 0xFFFFFFFFFFFFFFFBLL | (4
                                                                  * (*(void *)&vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1), v40))) & 1)));
    *(_DWORD *)(a3 + 4 * v5) = v41;
    int v12 = v12 & (v41 == v9);
    ++v5;
  }
  while (v5 != v10);
  return v12 ^ 1u;
}

uint64_t sub_1B63C5890(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  kcluster_update = (uint64_t)sub_1B63C5620;
  return sub_1B63C5620(result, a2, a3, a4);
}

uint64_t sub_1B63C58A8(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  kcluster_update_compare = (uint64_t (*)())sub_1B63C5748;
  return sub_1B63C5748(a1, a2, a3, a4, a5);
}

float noise(float32x4_t a1)
{
  float32x4_t v1 = a1;
  v1.i32[3] = 0;
  float32x4_t v2 = vrndmq_f32(v1);
  float32x4_t v3 = vmulq_f32(v2, (float32x4_t)xmmword_1B6E4F520);
  simd_float4 v22 = (simd_float4)vaddq_f32((float32x4_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))), 0), (float32x4_t)xmmword_1B6E4F530);
  simd_float4 v4 = (simd_float4)vmulq_f32(vsubq_f32(a1, v2), (float32x4_t)vdupq_n_s32(0x40490FDBu));
  v4.i32[3] = 0;
  simd_float4 v5 = _simd_cos_f4(v4);
  v6.i64[0] = 0xBF000000BF000000;
  v6.i64[1] = 0xBF000000BF000000;
  v7.i64[0] = 0x3F0000003F000000;
  v7.i64[1] = 0x3F0000003F000000;
  float32x4_t v21 = vmlaq_f32(v7, v6, (float32x4_t)v5);
  simd_float4 v8 = _simd_cos_f4(v22);
  simd_float4 v20 = _simd_sin_f4((simd_float4)vmulq_f32((float32x4_t)v22, (float32x4_t)v8));
  __asm { FMOV            V0.4S, #1.0 }
  simd_float4 v23 = (simd_float4)vaddq_f32((float32x4_t)v22, _Q0);
  simd_float4 v14 = _simd_cos_f4(v23);
  simd_float4 v15 = _simd_sin_f4((simd_float4)vmulq_f32((float32x4_t)v23, (float32x4_t)v14));
  _V2.S[2] = v21.i32[2];
  int8x16_t v17 = (int8x16_t)vmlaq_n_f32((float32x4_t)v20, vsubq_f32((float32x4_t)v15, (float32x4_t)v20), v21.f32[0]);
  _D1 = (int32x2_t)vextq_s8(v17, v17, 8uLL).u64[0];
  *(int32x2_t *)v15.f32 = vzip1_s32(*(int32x2_t *)v17.i8, _D1);
  *(float32x2_t *)v15.f32 = vmla_lane_f32(*(float32x2_t *)v15.f32, vsub_f32((float32x2_t)vzip2_s32(*(int32x2_t *)v17.i8, _D1), *(float32x2_t *)v15.f32), *(float32x2_t *)v21.f32, 1);
  _D1.i32[0] = vsub_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v15.f32, 1), *(float32x2_t *)v15.f32).u32[0];
  __asm { FMLA            S0, S1, V2.S[2] }
  return result;
}

uint64_t box_contains(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  return vminvq_u32((uint32x4_t)vcgeq_f32(a2, vabdq_f32(a3, a1))) >> 31;
}

float32x4_t *voxel_draw_points(float32x4_t *result, uint64_t a2, int a3, float a4)
{
  if (a3)
  {
    uint64_t v5 = 0;
    float32x4_t v6 = result[1];
    float32x4_t v7 = result[2];
    int v8 = result->i32[2];
    float32x4_t v9 = vmulq_n_f32(v7, 2.0 / (float)v8);
    v9.i32[3] = 1.0;
    v10.i32[0] = 1;
    v10.i32[1] = v8;
    v10.i64[1] = (v8 * v8);
    float32x4_t v11 = vsubq_f32(v7, v6);
    __asm { FMOV            V6.4S, #1.0 }
    float32x4_t v17 = vdivq_f32(_Q6, v9);
    *(float *)v4.i32 = (float)(v8 - 1);
    float32x4_t v18 = (float32x4_t)vdupq_lane_s32(v4, 0);
    v18.i32[3] = 0;
    uint64_t v19 = result->i64[0];
    float32x4_t v20 = (float32x4_t)vdupq_n_s32(0x3F7FFFFFu);
    v21.i64[0] = 0xBF000000BF000000;
    v21.i64[1] = 0xBF000000BF000000;
    v22.i64[0] = 0x8000000080000000;
    v22.i64[1] = 0x8000000080000000;
    do
    {
      float32x4_t v23 = *(float32x4_t *)(a2 + 16 * v5);
      if ((vminvq_u32((uint32x4_t)vcgeq_f32(v7, vabdq_f32(v23, v6))) & 0x80000000) != 0)
      {
        uint64_t v24 = 0;
        float32x4_t v25 = vmulq_f32(v17, vaddq_f32(v11, v23));
        float32x4_t v26 = vaddq_f32(vminnmq_f32(vsubq_f32(v25, vrndmq_f32(v25)), v20), v21);
        float32x4_t v27 = (float32x4_t)vandq_s8(vorrq_s8(vandq_s8((int8x16_t)v26, v22), (int8x16_t)_Q6), vorrq_s8((int8x16_t)vcltzq_f32(v26), (int8x16_t)vcgtzq_f32(v26)));
        float32x4_t v28 = vabsq_f32(v26);
        do
        {
          float32x4_t v29 = (float32x4_t)xmmword_1B6E4F8F0[v24];
          int8x16_t v30 = (int8x16_t)vmulq_s32(v10, vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v25, v29, v27), (float32x4_t)0), v18)));
          *(int32x2_t *)v30.i8 = vadd_s32(*(int32x2_t *)v30.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
          float32x4_t v31 = vsubq_f32(v29, v28);
          float32x4_t v32 = vmulq_f32(v31, v31);
          v30.i32[0] = vadd_s32(*(int32x2_t *)v30.i8, vdup_lane_s32(*(int32x2_t *)v30.i8, 1)).u32[0];
          *(float *)(v19 + 4 * v30.i32[0]) = *(float *)(v19 + 4 * v30.i32[0])
                                             + (float)((float)((float)(0.1 * v17.f32[0])
                                                             * fmaxf(1.0- sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).f32[0]), 0.0))* a4);
          ++v24;
        }
        while (v24 != 8);
      }
      ++v5;
    }
    while (v5 != a3);
  }
  return result;
}

float32x4_t *voxel_draw_colored_points(float32x4_t *result, uint64_t a2, uint64_t a3, int a4, float a5)
{
  if (a4)
  {
    uint64_t v6 = 0;
    float32x4_t v7 = result[2];
    int v8 = result->i32[2];
    float32x4_t v9 = vmulq_n_f32(v7, 2.0 / (float)v8);
    v9.i32[3] = 1.0;
    float32x4_t v10 = result[1];
    v11.i32[0] = 1;
    v11.i32[1] = v8;
    v11.i64[1] = (v8 * v8);
    float32x4_t v12 = vsubq_f32(v7, v10);
    __asm { FMOV            V6.4S, #1.0 }
    float32x4_t v18 = vdivq_f32(_Q6, v9);
    *(float *)v5.i32 = (float)(v8 - 1);
    float32x4_t v19 = (float32x4_t)vdupq_lane_s32(v5, 0);
    v19.i32[3] = 0;
    uint64_t v20 = result->i64[0];
    float32x4_t v21 = vmulq_n_f32((float32x4_t)xmmword_1B6E4F540, 0.1 * v18.f32[0]);
    float32x4_t v22 = vmulq_n_f32((float32x4_t)xmmword_1B6E4F550, 0.1 * v18.f32[0]);
    float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x3F7FFFFFu);
    v24.i64[0] = 0xBF000000BF000000;
    v24.i64[1] = 0xBF000000BF000000;
    v25.i64[0] = 0x8000000080000000;
    v25.i64[1] = 0x8000000080000000;
    do
    {
      float32x4_t v26 = (float32x4_t)xmmword_1B6E4F370;
      if (a3) {
        float32x4_t v26 = vmaxnmq_f32(vmlaq_f32(v22, v21, *(float32x4_t *)(a3 + 16 * v6)), (float32x4_t)0);
      }
      float32x4_t v27 = *(float32x4_t *)(a2 + 16 * v6);
      if ((vminvq_u32((uint32x4_t)vcgeq_f32(v7, vabdq_f32(v27, v10))) & 0x80000000) != 0)
      {
        uint64_t v28 = 0;
        v26.i32[3] = vmuls_lane_f32(a5, v26, 3);
        float32x4_t v29 = vmulq_f32(v18, vaddq_f32(v12, v27));
        float32x4_t v30 = vaddq_f32(vminnmq_f32(vsubq_f32(v29, vrndmq_f32(v29)), v23), v24);
        float32x4_t v31 = (float32x4_t)vandq_s8(vorrq_s8(vandq_s8((int8x16_t)v30, v25), (int8x16_t)_Q6), vorrq_s8((int8x16_t)vcltzq_f32(v30), (int8x16_t)vcgtzq_f32(v30)));
        float32x4_t v32 = vabsq_f32(v30);
        float32x4_t v33 = (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v26, 0xCuLL);
        do
        {
          float32x4_t v34 = (float32x4_t)xmmword_1B6E4F8F0[v28];
          int8x16_t v35 = (int8x16_t)vmulq_s32(v11, vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v29, v34, v31), (float32x4_t)0), v19)));
          *(int32x2_t *)v35.i8 = vadd_s32(*(int32x2_t *)v35.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL));
          float32x4_t v36 = vsubq_f32(v34, v32);
          v35.i32[0] = vadd_s32(*(int32x2_t *)v35.i8, vdup_lane_s32(*(int32x2_t *)v35.i8, 1)).u32[0];
          float32x4_t v37 = vmulq_f32(v36, v36);
          *(float32x4_t *)(v20 + 16 * v35.i32[0]) = vmlaq_n_f32(*(float32x4_t *)(v20 + 16 * v35.i32[0]), v33, fmaxf(1.0- sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).f32[0]), 0.0));
          ++v28;
        }
        while (v28 != 8);
      }
      ++v6;
    }
    while (v6 != a4);
  }
  return result;
}

void voxel_draw_spheres(float32x4_t *a1, uint64_t a2, uint64_t a3, unsigned int a4, float a5)
{
  if (a4)
  {
    uint64_t v6 = 0;
    float32x4_t v7 = a1[1];
    float32x4_t v8 = a1[2];
    int v9 = a1->i32[2];
    float32x4_t v10 = vmulq_n_f32(v8, 2.0 / (float)v9);
    float v11 = 1.0;
    v10.i32[3] = 1.0;
    v12.i32[0] = 1;
    v12.i32[1] = v9;
    v12.i64[1] = (v9 * v9);
    float32x4_t v13 = vsubq_f32(v8, v7);
    __asm { FMOV            V1.4S, #1.0 }
    v7.f32[0] = (float)(v9 - 1);
    float32x4_t v19 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
    int8x16_t v64 = (int8x16_t)_Q1;
    float32x4_t v65 = v13;
    v19.i32[3] = 0;
    uint64_t v20 = a1->i64[0];
    uint64_t v21 = a4;
    float32x4_t v62 = (float32x4_t)vdupq_n_s32(0x3F7FFFFFu);
    float32x4_t v63 = vdivq_f32(_Q1, v10);
    float32x4_t v22 = 0uLL;
    float32x4_t v71 = v19;
    int32x4_t v72 = v12;
    do
    {
      float32x4_t v23 = vmulq_f32(v63, vaddq_f32(v65, *(float32x4_t *)(a2 + 16 * v6)));
      int v24 = (int)(float)(v63.f32[0] * *(float *)(a3 + 4 * v6));
      v25.i64[0] = 0xBF000000BF000000;
      v25.i64[1] = 0xBF000000BF000000;
      float32x4_t v26 = vaddq_f32(vminnmq_f32(vsubq_f32(v23, vrndmq_f32(v23)), v62), v25);
      v25.i64[0] = 0x8000000080000000;
      v25.i64[1] = 0x8000000080000000;
      float32x4_t v27 = (float32x4_t)vandq_s8(vorrq_s8(vandq_s8((int8x16_t)v26, (int8x16_t)v25), v64), vorrq_s8((int8x16_t)vcltzq_f32(v26), (int8x16_t)vcgtzq_f32(v26)));
      float32x4_t v28 = vabsq_f32(v26);
      if (v24 <= 0)
      {
        for (uint64_t i = 0; i != 8; ++i)
        {
          float32x4_t v58 = (float32x4_t)xmmword_1B6E4F8F0[i];
          int8x16_t v59 = (int8x16_t)vmulq_s32(v12, vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v23, v58, v27), v22), v19)));
          *(int32x2_t *)v59.i8 = vadd_s32(*(int32x2_t *)v59.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v59, v59, 8uLL));
          float32x4_t v60 = vsubq_f32(v58, v28);
          v59.i32[0] = vadd_s32(*(int32x2_t *)v59.i8, vdup_lane_s32(*(int32x2_t *)v59.i8, 1)).u32[0];
          float32x4_t v61 = vmulq_f32(v60, v60);
          *(float *)(v20 + 4 * v59.i32[0]) = *(float *)(v20 + 4 * v59.i32[0])
                                             + (float)(fmaxf(v11- sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v61, 2), vaddq_f32(v61, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v61.f32, 1))).f32[0]), 0.0)* a5);
        }
      }
      else
      {
        uint64_t v29 = 0;
        float32x4_t v69 = v27;
        float32x4_t v70 = v23;
        float32x4_t v68 = v28;
        do
        {
          float32x4_t v30 = (float32x4_t)xmmword_1B6E4F8F0[v29];
          float32x4_t v31 = vmlaq_f32(v23, v30, v27);
          float32x4_t v32 = vsubq_f32(v30, v28);
          float32x4_t v33 = vmulq_f32(v32, v32);
          float v34 = fmaxf(v11- sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v33, 2), vaddq_f32(v33, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v33.f32, 1))).f32[0]), 0.0)* a5;
          int v35 = -v24;
          float32x4_t v73 = v31;
          do
          {
            float v74 = (float)v35;
            long double v36 = cos((float)((float)v35 / (float)v24) * 3.14159265 * 0.5);
            float32x4_t v22 = 0uLL;
            float32x4_t v19 = v71;
            int32x4_t v12 = v72;
            int v37 = 0;
            long double v38 = v36 * (double)v24;
            int v39 = -(int)v38;
            int v40 = 2 - 2 * (int)v38;
            do
            {
              v41.f32[0] = (float)-v39;
              float32x4_t v42 = (float32x4_t)v41.u32[0];
              v42.f32[1] = (float)v37;
              v42.f32[2] = (float)v35;
              int8x16_t v43 = (int8x16_t)vmulq_s32(v72, vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vaddq_f32(v73, v42), (float32x4_t)0), v71)));
              v41.f32[1] = (float)-v37;
              v41.i64[1] = LODWORD(v74);
              float32x4_t v44 = (float32x4_t)vmulq_s32(v72, vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vaddq_f32(v73, v41), (float32x4_t)0), v71)));
              *(int32x2_t *)v43.i8 = vadd_s32(*(int32x2_t *)v43.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
              *(int32x2_t *)v44.f32 = vadd_s32(*(int32x2_t *)v44.f32, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v44, (int8x16_t)v44, 8uLL));
              *(int32x2_t *)v43.i8 = vadd_s32(vzip1_s32(*(int32x2_t *)v43.i8, *(int32x2_t *)v44.f32), vzip2_s32(*(int32x2_t *)v43.i8, *(int32x2_t *)v44.f32));
              v44.f32[0] = (float)v39;
              __int32 v45 = v43.i32[1];
              __int32 v46 = v43.i32[0];
              float32x4_t v47 = (float32x4_t)COERCE_UNSIGNED_INT((float)v39);
              v47.f32[1] = (float)-v37;
              v47.f32[2] = (float)v35;
              int8x16_t v48 = (int8x16_t)vmulq_s32(v72, vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vaddq_f32(v73, v47), (float32x4_t)0), v71)));
              *(int32x2_t *)v48.i8 = vadd_s32(*(int32x2_t *)v48.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL));
              *(float *)(v20 + 4 * v46) = v34 + *(float *)(v20 + 4 * v46);
              v44.f32[1] = (float)v37;
              v44.i64[1] = LODWORD(v74);
              int8x16_t v49 = (int8x16_t)vmulq_s32(v72, vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vaddq_f32(v73, v44), (float32x4_t)0), v71)));
              *(int32x2_t *)v49.i8 = vadd_s32(*(int32x2_t *)v49.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v49, v49, 8uLL));
              *(float *)(v20 + 4 * v45) = v34 + *(float *)(v20 + 4 * v45);
              int32x2_t v50 = vadd_s32(vzip1_s32(*(int32x2_t *)v48.i8, *(int32x2_t *)v49.i8), vzip2_s32(*(int32x2_t *)v48.i8, *(int32x2_t *)v49.i8));
              *(float *)(v20 + 4 * v50.i32[0]) = v34 + *(float *)(v20 + 4 * v50.i32[0]);
              int v51 = (2 * (v37 + 1)) | 1;
              if (v40 > v37) {
                int v51 = 0;
              }
              else {
                ++v37;
              }
              int v52 = v51 + v40;
              BOOL v54 = v40 > v39 || v52 > v37;
              *(float *)(v20 + 4 * v50.i32[1]) = v34 + *(float *)(v20 + 4 * v50.i32[1]);
              int v55 = (2 * (v39 + 1)) | 1;
              if (v54)
              {
                ++v39;
                int v56 = v55;
              }
              else
              {
                int v56 = 0;
              }
              int v40 = v56 + v52;
            }
            while (v39 < 1);
          }
          while (v35++ != v24);
          ++v29;
          float v11 = 1.0;
          float32x4_t v27 = v69;
          float32x4_t v23 = v70;
          float32x4_t v28 = v68;
        }
        while (v29 != 8);
      }
      ++v6;
    }
    while (v6 != v21);
  }
}

float32x4_t *voxel_draw_colored_spheres(float32x4_t *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, float a6, double a7, double a8, double a9, double a10, double a11)
{
  if (a5)
  {
    uint64_t v11 = 0;
    float32x4_t v12 = result[2];
    int v13 = result->i32[2];
    float32x4_t v14 = vmulq_n_f32(v12, 2.0 / (float)v13);
    v14.i32[3] = 1.0;
    v15.i32[0] = 1;
    v15.i32[1] = v13;
    v15.i64[1] = (v13 * v13);
    float32x4_t v16 = vsubq_f32(v12, result[1]);
    __asm { FMOV            V4.4S, #1.0 }
    *(float *)&a11 = (float)(v13 - 1);
    float32x4_t v22 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a11, 0);
    v22.i32[3] = 0;
    float32x4_t v23 = vdivq_f32(_Q4, v14);
    uint64_t v24 = result->i64[0];
    float32x4_t v25 = (float32x4_t)vdupq_n_s32(0x3F7FFFFFu);
    v26.i64[0] = 0xBF000000BF000000;
    v26.i64[1] = 0xBF000000BF000000;
    v27.i64[0] = 0x8000000080000000;
    v27.i64[1] = 0x8000000080000000;
    do
    {
      float32x4_t v28 = (float32x4_t)xmmword_1B6E4F370;
      if (a4) {
        float32x4_t v28 = vmaxnmq_f32(vmlaq_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F550, v23.f32[0] * *(float *)(a3 + 4 * v11)), vmulq_n_f32((float32x4_t)xmmword_1B6E4F540, v23.f32[0] * *(float *)(a3 + 4 * v11)), *(float32x4_t *)(a4 + 16 * v11)), (float32x4_t)0);
      }
      uint64_t v29 = 0;
      float32x4_t v30 = vmulq_f32(v23, vaddq_f32(v16, *(float32x4_t *)(a2 + 16 * v11)));
      v28.i32[3] = vmuls_lane_f32(a6, v28, 3);
      float32x4_t v31 = vaddq_f32(vminnmq_f32(vsubq_f32(v30, vrndmq_f32(v30)), v25), v26);
      float32x4_t v32 = (float32x4_t)vandq_s8(vorrq_s8(vandq_s8((int8x16_t)v31, v27), (int8x16_t)_Q4), vorrq_s8((int8x16_t)vcltzq_f32(v31), (int8x16_t)vcgtzq_f32(v31)));
      float32x4_t v33 = vabsq_f32(v31);
      float32x4_t v34 = (float32x4_t)vextq_s8((int8x16_t)v28, (int8x16_t)v28, 0xCuLL);
      do
      {
        float32x4_t v35 = (float32x4_t)xmmword_1B6E4F8F0[v29];
        int8x16_t v36 = (int8x16_t)vmulq_s32(v15, vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v30, v35, v32), (float32x4_t)0), v22)));
        *(int32x2_t *)v36.i8 = vadd_s32(*(int32x2_t *)v36.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL));
        float32x4_t v37 = vsubq_f32(v35, v33);
        float32x4_t v38 = vmulq_f32(v37, v37);
        v36.i32[0] = vadd_s32(*(int32x2_t *)v36.i8, vdup_lane_s32(*(int32x2_t *)v36.i8, 1)).u32[0];
        *(float32x4_t *)(v24 + 16 * v36.i32[0]) = vaddq_f32(*(float32x4_t *)(v24 + 16 * v36.i32[0]), vmulq_n_f32(v34, fmaxf(1.0- sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), vaddq_f32(v38, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1))).f32[0]), 0.0)));
        ++v29;
      }
      while (v29 != 8);
      ++v11;
    }
    while (v11 != a5);
  }
  return result;
}

uint64_t voxel_opacity_color_clamp(uint64_t result)
{
  uint64_t v1 = (*(_DWORD *)(result + 8) * *(_DWORD *)(result + 8) * *(_DWORD *)(result + 8));
  if (v1)
  {
    float32x4_t v2 = *(float32x4_t **)result;
    __asm { FMOV            V0.4S, #1.0 }
    do
    {
      *float32x4_t v2 = vminnmq_f32(*v2, _Q0);
      ++v2;
      --v1;
    }
    while (v1);
  }
  return result;
}

uint64_t voxel_opacity_clamp(uint64_t result)
{
  uint64_t v1 = (*(_DWORD *)(result + 8) * *(_DWORD *)(result + 8) * *(_DWORD *)(result + 8));
  if (v1)
  {
    float32x4_t v2 = *(float **)result;
    do
    {
      *float32x4_t v2 = fminf(*v2, 1.0);
      ++v2;
      --v1;
    }
    while (v1);
  }
  return result;
}

float32x4_t merge_aabb(float32x4_t *a1, float32x4_t *a2, float32x4_t a3)
{
  float32x4_t v3 = vminq_f32(vsubq_f32(*a1, *a2), a3);
  float32x4_t v4 = vmaxq_f32(vaddq_f32(*a1, *a2), a3);
  v5.i64[0] = 0x3F0000003F000000;
  v5.i64[1] = 0x3F0000003F000000;
  *a1 = vmulq_f32(vaddq_f32(v3, v4), v5);
  float32x4_t result = vmulq_f32(vsubq_f32(v4, v3), v5);
  *a2 = result;
  return result;
}

__n64 sub_1B63C62EC(double a1, double a2, double a3, float a4, int8x16_t a5, int8x16_t a6)
{
  *(float *)a6.i32 = (float)((float)((float)(*(float *)&a3 * -1.5) + (float)(a4 * 0.5)) + (float)(*(float *)&a2 * 1.5))
                   + (float)(*(float *)&a1 * -0.5);
  *(float *)&a2 = (float)((float)((float)(*(float *)&a3 + *(float *)&a3) + (float)(a4 * -0.5))
                        + (float)(*(float *)&a2 * -2.5))
                + *(float *)&a1;
  *(float *)&a1 = (float)(*(float *)&a1 * -0.5) + (float)(*(float *)&a3 * 0.5);
  *(float *)&a3 = *(float *)a5.i32 * *(float *)a5.i32;
  *(float *)&a2 = (float)(*(float *)&a2 + *(float *)&a2) * *(float *)a5.i32;
  float32x4_t v6 = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a1, 0), vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a2, 0), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0), *(float *)a6.i32 * 3.0));
  int32x4_t v7 = (int32x4_t)vmulq_f32(v6, v6);
  v7.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v7, 2), vadd_f32(*(float32x2_t *)v7.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 1))).u32[0];
  float32x2_t v8 = vrsqrte_f32((float32x2_t)v7.u32[0]);
  float32x2_t v9 = vmul_f32(v8, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v8, v8)));
  float32x4_t v10 = vmulq_n_f32(v6, vmul_f32(v9, vrsqrts_f32((float32x2_t)v7.u32[0], vmul_f32(v9, v9))).f32[0]);
  a5.i32[0] = v10.i32[2];
  a6.i32[0] = 1.0;
  v7.i64[0] = 0x8000000080000000;
  v7.i64[1] = 0x8000000080000000;
  float v11 = *(float *)vbslq_s8((int8x16_t)v7, a6, a5).i32;
  v6.f32[0] = v10.f32[1] / (float)(fabsf(v10.f32[2]) + 1.0);
  *(float *)v7.i32 = -(float)(v10.f32[0] * v6.f32[0]);
  result.n64_f32[0] = v10.f32[2] + (float)(v11 * vmuls_lane_f32(v6.f32[0], *(float32x2_t *)v10.f32, 1));
  result.n64_f32[1] = v11 * *(float *)v7.i32;
  return result;
}

double catmull_rom_spline_basis_quat(double a1, double a2, double a3, float a4, int8x16_t a5, int8x16_t a6)
{
  *(__n64 *)v6.i8 = sub_1B63C62EC(a1, a2, a3, a4, a5, a6);
  float v9 = *(float *)&v8.i32[2] + (float)(*(float *)v6.i32 + *(float *)&v7.i32[1]);
  if (v9 >= 0.0)
  {
    float v18 = sqrtf(v9 + 1.0);
    float32x2_t v19 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v18 + v18));
    float32x2_t v20 = vmul_f32(v19, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v18 + v18), v19));
    float32x2_t v30 = vmul_n_f32(vsub_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v7, vuzp1q_s32(v7, v8)), (float32x2_t)*(_OWORD *)&vtrn2q_s32(v8, vzip2q_s32(v8, v6))), vmul_f32(v20, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v18 + v18), v20)).f32[0]);
  }
  else if (*(float *)v6.i32 < *(float *)&v7.i32[1] || *(float *)v6.i32 < *(float *)&v8.i32[2])
  {
    float v11 = 1.0 - *(float *)v6.i32;
    if (*(float *)&v7.i32[1] >= *(float *)&v8.i32[2])
    {
      float v31 = sqrtf(*(float *)&v7.i32[1] + (float)(v11 - *(float *)&v8.i32[2]));
      *(float *)&unsigned int v32 = v31 + v31;
      float32x2_t v33 = vrecpe_f32((float32x2_t)v32);
      float32x2_t v34 = vmul_f32(v33, vrecps_f32((float32x2_t)v32, v33));
      v35.i32[0] = vmul_f32(v34, vrecps_f32((float32x2_t)v32, v34)).u32[0];
      v34.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)v6.i8, 1), *(float32x2_t *)v7.i8).u32[0];
      v34.i32[1] = v32;
      v35.i32[1] = 0.25;
      float32x2_t v30 = vmul_f32(v34, v35);
    }
    else
    {
      float32x2_t v12 = (float32x2_t)__PAIR64__(v6.u32[1], COERCE_UNSIGNED_INT(sqrtf(*(float *)&v8.i32[2] + (float)(v11 - *(float *)&v7.i32[1]))));
      float32x2_t v13 = vadd_f32((float32x2_t)*(_OWORD *)&vzip2q_s32(v6, v7), *(float32x2_t *)v8.i8);
      float32x2_t v14 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 0);
      v14.i32[0] = 2.0;
      v14.i32[0] = vmul_f32(v12, v14).u32[0];
      float32x2_t v15 = vrecpe_f32((float32x2_t)v14.u32[0]);
      float32x2_t v16 = vmul_f32(v15, vrecps_f32((float32x2_t)v14.u32[0], v15));
      float32x2_t v30 = vmul_n_f32(v13, vmul_f32(v16, vrecps_f32((float32x2_t)v14.u32[0], v16)).f32[0]);
      __asm { FMOV            V2.2S, #0.25 }
    }
  }
  else
  {
    float32x2_t v21 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v7.i8, 0);
    float32x2_t v22 = vadd_f32(*(float32x2_t *)v6.i8, v21);
    v21.i32[0] = 2.0;
    v21.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v6.u32[1], COERCE_UNSIGNED_INT(sqrtf(*(float *)v6.i32+ (float)((float)(1.0 - *(float *)&v7.i32[1]) - *(float *)&v8.i32[2])))), v21).u32[0];
    v21.i32[1] = v22.i32[1];
    float32x2_t v23 = vrecpe_f32((float32x2_t)v21.u32[0]);
    float32x2_t v24 = vmul_f32(v23, vrecps_f32((float32x2_t)v21.u32[0], v23));
    unsigned __int32 v25 = vmul_f32(v24, vrecps_f32((float32x2_t)v21.u32[0], v24)).u32[0];
    __asm { FMOV            V5.2S, #0.25 }
    _D5.i32[1] = v25;
    float32x2_t v30 = vmul_f32(v21, _D5);
  }
  return *(double *)&v30;
}

float catmull_rom_spline_arclength(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float a5, float a6)
{
  uint64_t v6 = 0;
  float v7 = (float)(a6 - a5) * 0.5;
  float v8 = (float)(a5 + a6) * 0.5;
  __asm { FMOV            V5.4S, #-1.5 }
  v14.i64[0] = 0x3F0000003F000000;
  v14.i64[1] = 0x3F0000003F000000;
  __asm { FMOV            V16.4S, #1.5 }
  float32x4_t v16 = vmlsq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(a3, _Q5), v14, a4), _Q16, a2), v14, a1);
  float32x4_t v17 = vmlsq_f32(vaddq_f32(a3, a3), v14, a4);
  __asm { FMOV            V3.4S, #-2.5 }
  float32x4_t v19 = vaddq_f32(a1, vmlaq_f32(v17, _Q3, a2));
  v20.i64[0] = 0xBF000000BF000000;
  v20.i64[1] = 0xBF000000BF000000;
  float32x4_t v21 = vmlaq_f32(vmulq_f32(a1, v20), v14, a3);
  __asm { FMOV            V1.4S, #3.0 }
  float32x4_t v23 = vmulq_f32(v16, _Q1);
  float32x4_t v24 = vaddq_f32(v19, v19);
  float v25 = 0.0;
  do
  {
    float32x4_t v26 = vaddq_f32(v21, vmlaq_n_f32(vmulq_n_f32(v24, v8 + (float)(v7 * *(float *)&dword_1B6E4F970[v6])), v23, (float)(v8 + (float)(v7 * *(float *)&dword_1B6E4F970[v6]))* (float)(v8 + (float)(v7 * *(float *)&dword_1B6E4F970[v6]))));
    float32x4_t v27 = vmulq_f32(v26, v26);
    float v25 = v25
        + (float)(*(float *)&dword_1B6E4F9A4[v6++]
                * sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]));
  }
  while (v6 != 13);
  return v7 * v25;
}

void computeTangents(unsigned int a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8, float32x4_t *a9, uint64_t a10, int a11)
{
  float v18 = a9;
  float32x4_t v19 = (float32x4_t *)malloc_type_calloc(16 * a2, 1uLL, 0x10E093CBuLL);
  if (a3 == 4)
  {
    uint64_t v24 = 0;
  }
  else
  {
    if (a3 != 2)
    {
      printf("ComputeTangents : Unsupported index size (%zu)", a3);
      return;
    }
    uint64_t v24 = a4;
    a4 = 0;
  }
  if (a1)
  {
    uint64_t v25 = 0;
    int v26 = 0;
    int v27 = 0;
    int v28 = 0;
    v20.i32[3] = 0;
    do
    {
      if (v24)
      {
        int v26 = *(unsigned __int16 *)(v24 + 2 * v25);
        int v27 = *(unsigned __int16 *)(v24 + 2 * (v25 + 1));
        int v28 = *(unsigned __int16 *)(v24 + 2 * (v25 + 2));
      }
      else if (a4)
      {
        int v26 = *(_DWORD *)(a4 + 4 * v25);
        int v27 = *(_DWORD *)(a4 + 4 * (v25 + 1));
        int v28 = *(_DWORD *)(a4 + 4 * (v25 + 2));
      }
      float32x2_t v29 = *(float32x2_t *)(a10 + (v26 * a11));
      float32x2_t v30 = vsub_f32(*(float32x2_t *)(a10 + (v27 * a11)), v29);
      int32x2_t v31 = (int32x2_t)vsub_f32(*(float32x2_t *)(a10 + (v28 * a11)), v29);
      float v32 = vmlas_n_f32((float)-v30.f32[1] * *(float *)v31.i32, *(float *)&v31.i32[1], v30.f32[0]);
      if (v32 == 0.0)
      {
        int32x2_t v31 = (int32x2_t)vadd_f32((float32x2_t)v31, (float32x2_t)0xB400000034000000);
        float32x2_t v30 = vadd_f32(v30, (float32x2_t)0xB4000000B4000000);
        float v32 = vmlas_n_f32((float)-v30.f32[1] * *(float *)v31.i32, *(float *)&v31.i32[1], v30.f32[0]);
      }
      uint64_t v33 = a5 + (v26 * a6);
      v21.i64[0] = *(void *)v33;
      v21.i32[2] = *(_DWORD *)(v33 + 8);
      uint64_t v34 = a5 + (v27 * a6);
      v22.i64[0] = *(void *)v34;
      v22.i32[2] = *(_DWORD *)(v34 + 8);
      uint64_t v35 = a5 + (v28 * a6);
      v23.i64[0] = *(void *)v35;
      v23.i32[2] = *(_DWORD *)(v35 + 8);
      float32x4_t v22 = vsubq_f32(v22, v21);
      float32x4_t v21 = vsubq_f32(v23, v21);
      float v36 = v32;
      float32x2_t v37 = vrecpe_f32((float32x2_t)LODWORD(v32));
      float32x2_t v38 = vmul_f32(v37, vrecps_f32((float32x2_t)LODWORD(v36), v37));
      v38.i32[0] = vmul_f32(v38, vrecps_f32((float32x2_t)LODWORD(v36), v38)).u32[0];
      float32x4_t v23 = vmulq_n_f32(vmlaq_lane_f32(vmulq_lane_f32(vnegq_f32(v21), v30, 1), v22, (float32x2_t)v31, 1), v38.f32[0]);
      v23.i32[3] = 0;
      a9[v26] = vaddq_f32(a9[v26], v23);
      a9[v27] = vaddq_f32(a9[v27], v23);
      a9[v28] = vaddq_f32(a9[v28], v23);
      float32x4_t v39 = vmulq_n_f32(vmlaq_n_f32(vmulq_f32(v22, vnegq_f32((float32x4_t)vdupq_lane_s32(v31, 0))), v21, v30.f32[0]), v38.f32[0]);
      v39.i32[3] = v20.i32[3];
      v19[v26] = vaddq_f32(v39, v19[v26]);
      v19[v27] = vaddq_f32(v39, v19[v27]);
      v19[v28] = vaddq_f32(v39, v19[v28]);
      v25 += 3;
      v20.i64[1] = v39.i64[1];
    }
    while (3 * a1 != v25);
  }
  if (a2)
  {
    unsigned int v40 = 0;
    uint64_t v41 = a2;
    float32x4_t v42 = v19;
    do
    {
      uint64_t v43 = a7 + v40;
      v20.i64[0] = *(void *)v43;
      float32x4_t v44 = v20;
      v44.i32[2] = *(_DWORD *)(v43 + 8);
      v20.i32[2] = v44.i32[2];
      float32x4_t v45 = vmulq_f32(*v18, v20);
      float32x4_t v46 = vmlsq_lane_f32(*v18, v44, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))), 0);
      int32x4_t v47 = (int32x4_t)vmulq_f32(v46, v46);
      v47.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v47, 2), vadd_f32(*(float32x2_t *)v47.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v47.i8, 1))).u32[0];
      float32x2_t v48 = vrsqrte_f32((float32x2_t)v47.u32[0]);
      float32x4_t v49 = *v42++;
      float32x4_t v20 = vmulq_n_f32(v46, vmul_f32(v48, vrsqrts_f32((float32x2_t)v47.u32[0], vmul_f32(v48, v48))).f32[0]);
      int32x4_t v50 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v20, (int32x4_t)v20), (int8x16_t)v20, 0xCuLL), vnegq_f32(v44)), v20, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v44, (int32x4_t)v44), (int8x16_t)v44, 0xCuLL));
      float32x4_t v51 = vmulq_f32(v49, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v50, v50), (int8x16_t)v50, 0xCuLL));
      if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).f32[0] < 0.0)float v52 = -1.0; {
      else
      }
        float v52 = 1.0;
      v20.f32[3] = v52;
      *v18++ = v20;
      v40 += a8;
      --v41;
    }
    while (v41);
  }

  free(v19);
}

uint64_t matrix_multiply_batch(uint64_t result, uint64_t a2, unint64_t a3, double a4, double a5, __n128 a6, __n128 a7)
{
  _OWORD v9[2] = a6;
  void v9[3] = a7;
  if (a3)
  {
    uint64_t v7 = 0;
    do
    {
      for (uint64_t i = 0; i != 4; ++i)
        *(float32x4_t *)(result + i * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(*(float32x4_t *)(a2 + (v7 << 6) + 16), *(float32x2_t *)&v9[i], 1), *(float32x4_t *)(a2 + (v7 << 6)), COERCE_FLOAT(v9[i])), *(float32x4_t *)(a2 + (v7 << 6) + 32), (float32x4_t)v9[i], 2), *(float32x4_t *)(a2 + (v7 << 6) + 48), (float32x4_t)v9[i], 3);
      ++v7;
      result += 64;
    }
    while (a3 > v7);
  }
  return result;
}

uint64_t matrix_multiply_constant_batch(uint64_t result, uint64_t a2, unint64_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7)
{
  if (a3)
  {
    uint64_t v7 = 0;
    do
    {
      for (uint64_t i = 0; i != 64; i += 16)
        *(float32x4_t *)(result + i) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(a5, *(float32x2_t *)(a2 + i), 1), a4, COERCE_FLOAT(*(_OWORD *)(a2 + i))), a6, *(float32x4_t *)(a2 + i), 2), a7, *(float32x4_t *)(a2 + i), 3);
      ++v7;
      a2 += 64;
      result += 64;
    }
    while (a3 > v7);
  }
  return result;
}

int32x4_t matrix_transpose_batch(uint64_t a1, int32x4_t *a2, unint64_t a3)
{
  if (a3)
  {
    float32x4_t v3 = a2 + 2;
    float32x4_t v4 = (float *)(a1 + 32);
    unsigned int v5 = 1;
    do
    {
      int32x4_t v6 = v3[-2];
      int32x4_t v7 = v3[-1];
      int32x4_t v8 = *v3;
      int32x4_t v9 = v3[1];
      v3 += 4;
      float32x2x2_t v10 = (float32x2x2_t)vzip1q_s32(v6, v8);
      v15.val[0] = (float32x2_t)vzip2q_s32(v6, v8).u64[0];
      int32x4_t v11 = vzip1q_s32(v7, v9);
      v15.val[1] = (float32x2_t)vzip2q_s32(v7, v9).u64[0];
      int32x4_t result = vzip2q_s32((int32x4_t)v10, v11);
      float32x2_t v13 = v4 - 8;
      vst2_f32(v13, v10);
      *((int32x4_t *)v4 - 1) = result;
      unint64_t v14 = v5;
      vst2_f32(v4, v15);
      ++v5;
      v4 += 12;
    }
    while (v14 < a3);
  }
  return result;
}

double sub_1B63C6AD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int32x4_t v7 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA518, memory_order_acquire) & 1) == 0)
  {
    uint64_t v19 = a2;
    uint64_t v20 = a3;
    int v18 = __cxa_guard_acquire(&qword_1E9DDA518);
    int32x4_t v7 = &unk_1E9DDA000;
    a2 = v19;
    a3 = v20;
    if (v18)
    {
      byte_1E9DDA510 = 1;
      __cxa_guard_release(&qword_1E9DDA518);
      int32x4_t v7 = (unsigned char *)&unk_1E9DDA000;
      a2 = v19;
      a3 = v20;
    }
  }
  if (v7[1296]) {
    uint64_t v8 = 0xA65946FB2DD0B312;
  }
  else {
    uint64_t v8 = 0;
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v8, 0);
  *(void *)a1 = &unk_1F0FB3CC8;
  long long v9 = *(_OWORD *)(a5 + 24);
  long long v10 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a5 + 40);
  *(_OWORD *)(a1 + 416) = v10;
  *(_OWORD *)(a1 + 384) = v9;
  long long v11 = *(_OWORD *)(a5 + 72);
  long long v12 = *(_OWORD *)(a5 + 88);
  long long v13 = *(_OWORD *)(a5 + 120);
  *(_OWORD *)(a1 + 464) = *(_OWORD *)(a5 + 104);
  *(_OWORD *)(a1 + 480) = v13;
  *(_OWORD *)(a1 + 432) = v11;
  *(_OWORD *)(a1 + 448) = v12;
  long long v14 = *(_OWORD *)(a5 + 136);
  long long v15 = *(_OWORD *)(a5 + 152);
  long long v16 = *(_OWORD *)(a5 + 184);
  *(_OWORD *)(a1 + 528) = *(_OWORD *)(a5 + 168);
  *(_OWORD *)(a1 + 544) = v16;
  *(_OWORD *)(a1 + 496) = v14;
  *(_OWORD *)(a1 + 512) = v15;
  double result = 0.0;
  *(_OWORD *)(a1 + 568) = 0u;
  return result;
}

void sub_1B63C6BE8(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = CFX::CrossFrameResourceManager::get(a2[4], v4);
  *(void *)(a1 + 560) = v5;
  if (!v5)
  {
    *(void *)(a1 + 560) = sub_1B63C6D20(a2[4], v4);
    long long v13 = (void *)sub_1B6445900(*(void *)(a1 + 368), v6, v7, v8, v9, v10, v11, v12);
    float32x4_t v17 = objc_msgSend_resourceManager(v13, v14, v15, v16);
    id v18 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_atIndex_(v18, v19, a1 + 552, 53, 20301);
    uint64_t v20 = CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 576));
    char v21 = *(unsigned char *)(v20 + 9);
    uint64_t v22 = *(void *)(v20 + 16);
    uint64_t v23 = *(void *)(a1 + 560);
    uint64_t v24 = (void *)sub_1B653EFAC((uint64_t)v17);
    *((void *)&v34 + 1) = objc_msgSend_frameworkLibrary(v24, v25, v26, v27, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0);
    *(void *)&long long v35 = v22;
    LOBYTE(v36) = v21;
    *((void *)&v37 + 1) = v18;
    *((void *)&v38 + 1) = @"vertex_draw_quad";
    *(void *)&long long v39 = @"bloom_threshold";
    uint64_t v30 = objc_msgSend_newRenderPipelineStateWithDesc_(v17, v28, (uint64_t)&v33, v29);
    int32x2_t v31 = *(void **)(v23 + 16);
    if (v31 != (void *)v30)
    {
      uint64_t v32 = v30;
      if (v31) {

      }
      *(void *)(v23 + 16) = v32;
    }
  }
}

uint64_t sub_1B63C6D20(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B63C6DA8(uint64_t a1, uint64_t a2)
{
  prof_beginFlame((uint64_t)"Bloom threshold", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/BloomPass.mm", 55);
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), v4, v5, v6, v7, v8, v9, v10);
  uint64_t v22 = objc_msgSend_renderEncoder(v11, v12, v13, v14);
  uint64_t v23 = *(void *)(a1 + 560);
  uint64_t v24 = *(void **)(v23 + 16);
  if (!v24)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v16, v17, v18, v19, v20, v21, (uint64_t)"_ptr != NULL");
    uint64_t v24 = *(void **)(v23 + 16);
  }
  uint64_t v25 = objc_msgSend_state(v24, v15, v16, v17);
  objc_msgSend_setRenderPipelineState_(*(void **)(v22 + 16), v26, v25, v27);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 568));
  sub_1B63C6ED0(v22, Texture, 0, v29);
  float v37 = sub_1B6529878(*(void *)(a1 + 544), v30, v31, v32, v33, v34, v35, v36);
  unint64_t v47 = __PAIR64__(COERCE_UNSIGNED_INT(sub_1B65299B8(*(void *)(a1 + 544), v38, v39, v40, v41, v42, v43, v44)), LODWORD(v37));
  float32x2_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  sub_1B649F334(*(void *)(v22 + 24), &v47, 8uLL, &v48);
  objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v22 + 16), v45, v49, v50, 0);
  sub_1B63C6F54(v22, v46);
  prof_endFlame();
}

void sub_1B63C6EB4(_Unwind_Exception *a1)
{
}

uint64_t sub_1B63C6ED0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = (uint64_t)a2;
  if (a2 && (objc_msgSend_conformsToProtocol_(a2, (const char *)a2, (uint64_t)&unk_1F108B030, a4) & 1) == 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. texture is not a MTLTexture", v6, a4, v7, v8, v9, v10, (uint64_t)"!texture || [texture conformsToProtocol:@protocol(MTLTexture)]");
  }
  sub_1B64D95D4(*(__IOSurface **)(a1 + 8), (const char *)&v13, 1, a4);
  return objc_msgSend_setFragmentTexture_atIndex_(*(void **)(a1 + 16), v11, v13, a3);
}

uint64_t sub_1B63C6F54(uint64_t a1, const char *a2)
{
  unsigned int v2 = *(_DWORD *)a1;
  float32x4_t v3 = *(void **)(a1 + 16);
  if (v2 < 2) {
    return objc_msgSend_drawPrimitives_vertexStart_vertexCount_(v3, a2, 3, 0, 3);
  }
  else {
    return objc_msgSend_drawPrimitives_vertexStart_vertexCount_instanceCount_(v3, a2, 3, 0, 3);
  }
}

uint64_t sub_1B63C6F80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA528, memory_order_acquire) & 1) == 0)
  {
    uint64_t v20 = a2;
    uint64_t v21 = a3;
    int v19 = __cxa_guard_acquire(&qword_1E9DDA528);
    uint64_t v7 = (void *)&unk_1E9DDA000;
    a2 = v20;
    a3 = v21;
    if (v19)
    {
      qword_1E9DDA520 = (uint64_t)sub_1B63C7FB4("BLOOM_DOWNSAMPLE_PASS", 0x15u);
      __cxa_guard_release(&qword_1E9DDA528);
      uint64_t v7 = (void *)&unk_1E9DDA000;
      a2 = v20;
      a3 = v21;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v7[164], 0);
  *(void *)a1 = &unk_1F0FB3F30;
  long long v8 = *(_OWORD *)(a5 + 24);
  long long v9 = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 400) = *(_OWORD *)(a5 + 40);
  *(_OWORD *)(a1 + 416) = v9;
  *(_OWORD *)(a1 + 384) = v8;
  long long v10 = *(_OWORD *)(a5 + 72);
  long long v11 = *(_OWORD *)(a5 + 88);
  long long v12 = *(_OWORD *)(a5 + 120);
  *(_OWORD *)(a1 + 464) = *(_OWORD *)(a5 + 104);
  *(_OWORD *)(a1 + 480) = v12;
  *(_OWORD *)(a1 + 432) = v10;
  *(_OWORD *)(a1 + 448) = v11;
  long long v13 = *(_OWORD *)(a5 + 136);
  long long v14 = *(_OWORD *)(a5 + 152);
  long long v15 = *(_OWORD *)(a5 + 184);
  *(_OWORD *)(a1 + 528) = *(_OWORD *)(a5 + 168);
  *(_OWORD *)(a1 + 544) = v15;
  *(_OWORD *)(a1 + 496) = v13;
  *(_OWORD *)(a1 + 512) = v14;
  *(_OWORD *)(a1 + 568) = 0u;
  int v16 = *(_DWORD *)(a1 + 552);
  *(unsigned char *)(CFX::RG::Pass::commonRenderParameters(v17) + 274) = v16;
  return a1;
}

void sub_1B63C709C(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B63C70B0(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 576));
  uint64_t v6 = *(unsigned __int8 *)(v5 + 9);
  uint64_t v7 = *(void *)(v5 + 16);
  unsigned int v15 = sub_1B652991C(*(void *)(a1 + 544), v8, v9, v10, v11, v12, v13, v14);
  char v52 = v15;
  unint64_t v16 = 0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ v15)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ v15)));
  unint64_t v17 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47))) ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47))) ^ v7)));
  unint64_t v18 = 0x9DDFEA08EB382D69 * (v17 ^ (v17 >> 47));
  uint64_t v19 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v18 ^ ((0x9DDFEA08EB382D69 * (v18 ^ v6)) >> 47) ^ (0x9DDFEA08EB382D69 * (v18 ^ v6)))) ^ ((0x9DDFEA08EB382D69 * (v18 ^ ((0x9DDFEA08EB382D69 * (v18 ^ v6)) >> 47) ^ (0x9DDFEA08EB382D69 * (v18 ^ v6)))) >> 47));
  uint64_t v20 = CFX::CrossFrameResourceManager::get(a2[4], v19);
  *(void *)(a1 + 560) = v20;
  if (!v20)
  {
    *(void *)(a1 + 560) = sub_1B63C7264(a2[4], v19);
    int v28 = (void *)sub_1B6445900(*(void *)(a1 + 368), v21, v22, v23, v24, v25, v26, v27);
    uint64_t v32 = objc_msgSend_resourceManager(v28, v29, v30, v31);
    id v33 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_atIndex_(v33, v34, (uint64_t)&v52, 53, 20300);
    uint64_t v35 = *(void *)(a1 + 560);
    uint64_t v36 = (void *)sub_1B653EFAC((uint64_t)v32);
    *((void *)&v46 + 1) = objc_msgSend_frameworkLibrary(v36, v37, v38, v39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0);
    *(void *)&long long v47 = v7;
    LOBYTE(v48) = v6;
    *((void *)&v49 + 1) = v33;
    *((void *)&v50 + 1) = @"vertex_draw_quad";
    *(void *)&long long v51 = @"bloom_down_sample";
    uint64_t v42 = objc_msgSend_newRenderPipelineStateWithDesc_(v32, v40, (uint64_t)&v45, v41);
    uint64_t v43 = *(void **)(v35 + 16);
    if (v43 != (void *)v42)
    {
      uint64_t v44 = v42;
      if (v43) {

      }
      *(void *)(v35 + 16) = v44;
    }
  }
}

uint64_t sub_1B63C7264(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B63C72EC(uint64_t a1, uint64_t a2)
{
  prof_beginFlame((uint64_t)"Bloom downsample", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/BloomPass.mm", 128);
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), v4, v5, v6, v7, v8, v9, v10);
  uint64_t v22 = objc_msgSend_renderEncoder(v11, v12, v13, v14);
  uint64_t v23 = *(void *)(a1 + 560);
  uint64_t v24 = *(void **)(v23 + 16);
  if (!v24)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v16, v17, v18, v19, v20, v21, (uint64_t)"_ptr != NULL");
    uint64_t v24 = *(void **)(v23 + 16);
  }
  uint64_t v25 = objc_msgSend_state(v24, v15, v16, v17);
  objc_msgSend_setRenderPipelineState_(*(void **)(v22 + 16), v26, v25, v27);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 568));
  sub_1B63C6ED0(v22, Texture, 0, v29);
  float v32 = (float)*(unsigned int *)(a1 + 552) + -1.0;
  id v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  sub_1B649F334(*(void *)(v22 + 24), &v32, 4uLL, &v33);
  objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v22 + 16), v30, v34, v35, 0);
  sub_1B63C6F54(v22, v31);
  prof_endFlame();
}

void sub_1B63C73EC(_Unwind_Exception *a1)
{
}

uint64_t sub_1B63C7408(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA538, memory_order_acquire) & 1) == 0)
  {
    uint64_t v11 = a2;
    uint64_t v12 = a3;
    int v10 = __cxa_guard_acquire(&qword_1E9DDA538);
    uint64_t v7 = (void *)&unk_1E9DDA000;
    a2 = v11;
    a3 = v12;
    if (v10)
    {
      qword_1E9DDA530 = (uint64_t)sub_1B63C7FB4("BLOOM_UPSAMPLE_PASS", 0x13u);
      __cxa_guard_release(&qword_1E9DDA538);
      uint64_t v7 = (void *)&unk_1E9DDA000;
      a2 = v11;
      a3 = v12;
    }
  }
  sub_1B645DCC0(a1, a2, a3, a5, v7[166], 0);
  *(void *)a1 = &unk_1F0FB3B08;
  memcpy((void *)(a1 + 384), a5 + 3, 0x150uLL);
  *(void *)(a1 + 728) = 0;
  *(void *)(a1 + 744) = 0;
  *(void *)(a1 + 736) = 0;
  int v8 = *(_DWORD *)(a1 + 712);
  *(unsigned char *)(CFX::RG::Pass::commonRenderParameters((CFX::RG::Pass *)a1) + 274) = v8;
  return a1;
}

void sub_1B63C74F4(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B63C7508(uint64_t a1, CFX::CrossFrameResourceManager **a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  uint64_t v5 = CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 744));
  uint64_t v6 = *(unsigned __int8 *)(v5 + 9);
  uint64_t v7 = *(void *)(v5 + 16);
  __n128 v22 = sub_1B652ADCC((__n128 *)*(void *)(a1 + 704), v8, v9, v10, v11, v12, v13, v14);
  __asm { FMOV            V1.4S, #1.0 }
  uint32x4_t v28 = (uint32x4_t)vmvnq_s8((int8x16_t)vceqq_f32((float32x4_t)v22, _Q1));
  v28.i32[3] = v28.i32[2];
  BOOL v29 = (vmaxvq_u32(v28) & 0x80000000) != 0
     || sub_1B652AE6C(*(void *)(a1 + 704), v15, v16, v17, v18, v19, v20, v21) != 1.0
     || sub_1B652AF10(*(void *)(a1 + 704), v15, v16, v17, v18, v19, v20, v21) != 1.0;
  BOOL v70 = v29;
  unsigned int v30 = sub_1B652991C(*(void *)(a1 + 704), v15, v16, v17, v18, v19, v20, v21);
  char v69 = v30;
  unint64_t v31 = 0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v4 ^ v30)) >> 47) ^ (0x9DDFEA08EB382D69 * (v4 ^ v30)));
  unint64_t v32 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47))) ^ v29)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47))) ^ v29)));
  unint64_t v33 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v32 ^ (v32 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v32 ^ (v32 >> 47))) ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v32 ^ (v32 >> 47))) ^ v7)));
  unint64_t v34 = 0x9DDFEA08EB382D69 * (v33 ^ (v33 >> 47));
  uint64_t v35 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ v6)) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ v6)))) ^ ((0x9DDFEA08EB382D69 * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ v6)) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ v6)))) >> 47));
  uint64_t v36 = CFX::CrossFrameResourceManager::get(a2[4], v35);
  *(void *)(a1 + 720) = v36;
  if (!v36)
  {
    *(void *)(a1 + 720) = sub_1B63C774C(a2[4], v35);
    uint64_t v44 = (void *)sub_1B6445900(*(void *)(a1 + 368), v37, v38, v39, v40, v41, v42, v43);
    long long v48 = objc_msgSend_resourceManager(v44, v45, v46, v47);
    id v49 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_atIndex_(v49, v50, (uint64_t)&v69, 53, 20300);
    objc_msgSend_setConstantValue_type_atIndex_(v49, v51, (uint64_t)&v70, 53, 20302);
    uint64_t v52 = *(void *)(a1 + 720);
    float32x4_t v53 = (void *)sub_1B653EFAC((uint64_t)v48);
    *((void *)&v63 + 1) = objc_msgSend_frameworkLibrary(v53, v54, v55, v56, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0,
                              0);
    *(void *)&long long v64 = v7;
    LOBYTE(v65) = v6;
    *((void *)&v66 + 1) = v49;
    *((void *)&v67 + 1) = @"vertex_draw_quad";
    *(void *)&long long v68 = @"bloom_up_sample_color_grading";
    uint64_t v59 = objc_msgSend_newRenderPipelineStateWithDesc_(v48, v57, (uint64_t)&v62, v58);
    float32x4_t v60 = *(void **)(v52 + 16);
    if (v60 != (void *)v59)
    {
      uint64_t v61 = v59;
      if (v60) {

      }
      *(void *)(v52 + 16) = v61;
    }
  }
}

uint64_t sub_1B63C774C(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

void sub_1B63C77D4(uint64_t a1, uint64_t a2)
{
  prof_beginFlame((uint64_t)"Bloom upsample", (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VFX/sources/vfx/CFX/RenderGraphV2/Passes/BloomPass.mm", 206);
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), v4, v5, v6, v7, v8, v9, v10);
  uint64_t v22 = objc_msgSend_renderEncoder(v11, v12, v13, v14);
  uint64_t v23 = *(void *)(a1 + 720);
  uint64_t v24 = *(void **)(v23 + 16);
  if (!v24)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v16, v17, v18, v19, v20, v21, (uint64_t)"_ptr != NULL");
    uint64_t v24 = *(void **)(v23 + 16);
  }
  uint64_t v25 = objc_msgSend_state(v24, v15, v16, v17);
  objc_msgSend_setRenderPipelineState_(*(void **)(v22 + 16), v26, v25, v27);
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 728));
  id v29 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 736));
  sub_1B63C6ED0(v22, v29, 0, v30);
  sub_1B63C6ED0(v22, Texture, 1, v31);
  v32.i32[0] = *(_DWORD *)(a1 + 712) + 1;
  v32.i32[1] = *(_DWORD *)(a1 + 712);
  float32x2_t v60 = vcvt_f32_u32(v32);
  long long v57 = 0uLL;
  v58.n128_u64[0] = 0;
  sub_1B649F334(*(void *)(v22 + 24), &v60, 8uLL, (void **)&v57);
  objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v22 + 16), v33, *((uint64_t *)&v57 + 1), v58.n128_i64[0], 0);
  __n128 v58 = 0u;
  long long v59 = 0u;
  long long v57 = 0u;
  LODWORD(v57) = 1065353216;
  __n128 v58 = sub_1B652ADCC((__n128 *)*(void *)(a1 + 704), v34, v35, v36, v37, v38, v39, v40);
  LODWORD(v59) = sub_1B652AE6C(*(void *)(a1 + 704), v41, v42, v43, v44, v45, v46, v47);
  DWORD1(v59) = sub_1B652AF10(*(void *)(a1 + 704), v48, v49, v50, v51, v52, v53, v54);
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  sub_1B649F334(*(void *)(v22 + 24), &v57, 0x30uLL, &v61);
  objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v22 + 16), v55, v62, v63, 1);
  sub_1B63C6F54(v22, v56);
  prof_endFlame();
}

void sub_1B63C795C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1B63C7980(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(const void **)(a3 + 8);
  if (!v11)
  {
    uint64_t v11 = sub_1B6446564(*(uint64_t **)a3, a2, a3, a4, a5, a6, a7, a8);
    if (!v11) {
      return 0;
    }
  }
  CFDictionaryRef v12 = sub_1B64A3B48((uint64_t)v11, a2, a3, a4, a5, a6, a7, a8);
  if (!v12) {
    return 0;
  }
  uint64_t v13 = (uint64_t)v12;
  float32x4_t v75 = (CFX::RG::Resource *)a4;
  uint64_t v14 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*(CFX::RG::Resource **)(a3 + 16));
  long long v15 = v14[1];
  v118[0] = *v14;
  v118[1] = v15;
  long long v16 = v14[5];
  long long v18 = v14[2];
  long long v17 = v14[3];
  v118[4] = v14[4];
  v118[5] = v16;
  v118[2] = v18;
  v118[3] = v17;
  long long v19 = v14[9];
  long long v21 = v14[6];
  long long v20 = v14[7];
  v118[8] = v14[8];
  v118[9] = v19;
  v118[6] = v21;
  v118[7] = v20;
  CFX::RG::TextureDescriptorReference::withSampleCount(v118, 1, (uint64_t)v117);
  unsigned int v22 = *(unsigned __int16 *)(a3 + 24);
  unsigned int v23 = *(unsigned __int16 *)(a3 + 26);
  int v24 = *(_DWORD *)(a3 + 28);
  int v115 = *(_DWORD *)(a3 + 34);
  __int16 v116 = *(_WORD *)(a3 + 38);
  long long v25 = *(_OWORD *)(a3 + 64);
  long long v111 = *(_OWORD *)(a3 + 48);
  long long v112 = v25;
  long long v113 = *(_OWORD *)(a3 + 80);
  uint64_t v114 = *(void *)(a3 + 96);
  unsigned int v26 = v23 >> 1;
  unsigned int v27 = v22 >> 1;
  if ((int)(v23 >> 1) <= (int)(v22 >> 1)) {
    int v28 = v22 >> 1;
  }
  else {
    int v28 = v23 >> 1;
  }
  if (v28 <= 1) {
    int v28 = 1;
  }
  int v29 = (int)(float)(floorf(log2f((float)v28)) + 1.0);
  v100[0] = v27;
  v100[1] = v26;
  int v101 = v24;
  char v102 = v29;
  char v103 = 1;
  int v104 = *(_DWORD *)(a3 + 34);
  __int16 v105 = *(_WORD *)(a3 + 38);
  long long v30 = *(_OWORD *)(a3 + 64);
  long long v107 = *(_OWORD *)(a3 + 48);
  long long v108 = v30;
  long long v109 = *(_OWORD *)(a3 + 80);
  uint64_t v31 = *(void *)(a3 + 96);
  uint64_t v106 = 92;
  uint64_t v110 = v31;
  uint32x2_t v32 = sub_1B63C7D8C(a1, (uint64_t)"BLOOM OUTPUT", (uint64_t)v100);
  long long v96 = v111;
  v89[0] = v27;
  v89[1] = v26;
  int v90 = v24;
  char v91 = v29;
  char v92 = 1;
  int v93 = v115;
  __int16 v94 = v116;
  long long v97 = v112;
  long long v98 = v113;
  uint64_t v95 = 92;
  uint64_t v99 = v114;
  unint64_t v33 = sub_1B63C7D8C(a1, (uint64_t)"BLOOM TMP", (uint64_t)v89);
  uint64_t v47 = sub_1B649ABF8(v13, v34, v35, v36, v37, v38, v39, v40);
  if (!v47) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v41, v42, v43, v44, v45, v46, (uint64_t)"bloom");
  }
  uint64_t v48 = *(uint64_t **)a3;
  v85[0] = "Bloom threshold";
  v85[1] = v48;
  __int16 v86 = 0;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)v87);
  v87[20] = v47;
  char v88 = 0;
  uint64_t v49 = (uint64_t *)sub_1B63C7DEC(a1, (uint64_t)a1, (uint64_t)v85);
  uint64_t v51 = (CFX::RG::Resource *)CFX::RG::copyIfNeeded((CFX::RG *)a1, *(CFX::RG::RenderGraphBuilder **)(a3 + 16), v75, (CFX::RG::Pass *)v117, 0, v50);
  v49[71] = (uint64_t)v51;
  CFX::RG::Pass::readFrom(v49, v51);
  v49[72] = (uint64_t)v33;
  CFX::RG::Pass::renderTo((uint64_t)v49, (uint64_t)v33, 0x100000000, 0);
  int v52 = v29 - 3;
  int v60 = sub_1B652AFB4(v47, v53, v54, v55, v56, v57, v58, v59);
  if (v52 >= v60) {
    int v61 = v60;
  }
  else {
    int v61 = v52;
  }
  if (v61 <= 2) {
    int v62 = 2;
  }
  else {
    int v62 = v61;
  }
  int v63 = 1;
  long long v64 = (CFX::RG::Resource *)a3;
  do
  {
    long long v65 = (CFX::RG::Pass *)v49;
    uint64_t v66 = *(void *)v64;
    float32x4_t v77 = "Bloom downsample";
    uint64_t v78 = v66;
    __int16 v79 = 0;
    CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)v80);
    uint64_t v81 = v47;
    int v82 = v63;
    uint64_t v49 = (uint64_t *)sub_1B63C7E44(a1, (uint64_t)a1, (uint64_t)&v77);
    v49[71] = (uint64_t)v33;
    CFX::RG::Pass::readFrom(v49, v33);
    v49[72] = (uint64_t)v33;
    CFX::RG::Pass::renderTo((uint64_t)v49, (uint64_t)v33, 0x100000000, 0);
    CFX::RG::Pass::dependsOn(v49, v65);
    ++v63;
  }
  while (v62 != v63);
  uint64_t v74 = v47;
  float32x4_t v76 = v64;
  int v67 = 0;
  int v68 = v62 - 1;
  char v69 = v49;
  do
  {
    BOOL v70 = (CFX::RG::Pass *)v69;
    uint64_t v71 = *(void *)v76;
    --v68;
    float32x4_t v77 = "Bloom upsample";
    uint64_t v78 = v71;
    __int16 v79 = 0;
    CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)v80);
    CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)&v81);
    uint64_t v83 = v74;
    int v84 = v68;
    char v69 = (uint64_t *)sub_1B63C7E9C(a1, (uint64_t)a1, (uint64_t *)&v77);
    v69[91] = (uint64_t)v33;
    CFX::RG::Pass::readFrom(v69, v33);
    if (v67) {
      int32x4_t v72 = v32;
    }
    else {
      int32x4_t v72 = v33;
    }
    v69[92] = (uint64_t)v72;
    CFX::RG::Pass::readFrom(v69, v72);
    v69[93] = (uint64_t)v32;
    CFX::RG::Pass::renderTo((uint64_t)v69, (uint64_t)v32, 0x100000000, 0);
    CFX::RG::Pass::dependsOn(v69, v70);
    if (v70 != (CFX::RG::Pass *)v49) {
      CFX::RG::Pass::dependsOn(v69, (CFX::RG::Pass *)v49);
    }
    ++v67;
  }
  while (v68 > 0);
  return v69;
}

CFX::RG::Resource *sub_1B63C7D8C(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = a2;
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  char v9 = 1;
  sub_1B63C82B8(v4, v5, &v10, a3, &v9);
  uint64_t v7 = v6;
  CFX::RG::RenderGraphBuilder::appendResource(a1, v6);
  return v7;
}

uint64_t sub_1B63C7DEC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v8[0] = *a1;
  v8[1] = v5;
  sub_1B63C887C(v8[0], v5, v8, a2, a3);
  v8[0] = v6;
  sub_1B63C88CC(a1 + 18, v8);
  return v8[0];
}

uint64_t sub_1B63C7E44(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63C8C70(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B63C7E9C(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63C8CC0(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B63C7EF8(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B63C7F30()
{
  return 1;
}

void sub_1B63C7F40(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63C7F7C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B63C7FB4(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0xC6A4A7935BD1E995 * a2;
    do
    {
      unint64_t v3 = 0xC6A4A7935BD1E995
         * ((0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * *(void *)&result[v2]) ^ ((0xC6A4A7935BD1E995 * *(void *)&result[v2]) >> 47))) ^ v3);
      v2 += 8;
    }
    while (v2 != 16);
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_11;
      case 2u:
        goto LABEL_10;
      case 3u:
        goto LABEL_9;
      case 4u:
        goto LABEL_8;
      case 5u:
        goto LABEL_7;
      case 6u:
        goto LABEL_6;
      case 7u:
        v3 ^= (unint64_t)result[22] << 48;
LABEL_6:
        v3 ^= (unint64_t)result[21] << 40;
LABEL_7:
        v3 ^= (unint64_t)result[20] << 32;
LABEL_8:
        v3 ^= (unint64_t)result[19] << 24;
LABEL_9:
        v3 ^= (unint64_t)result[18] << 16;
LABEL_10:
        v3 ^= (unint64_t)result[17] << 8;
LABEL_11:
        unint64_t v3 = 0xC6A4A7935BD1E995 * (v3 ^ result[16]);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v3 ^ (v3 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v3 ^ (v3 >> 47))) >> 47));
  }
  return result;
}

void *sub_1B63C8090(void *a1)
{
  *a1 = &unk_1F0FB3CA8;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B63C80DC(void *a1)
{
  *a1 = &unk_1F0FB3CA8;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B63C8148(void *a1)
{
  *a1 = &unk_1F0FB3F10;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B63C8194(void *a1)
{
  *a1 = &unk_1F0FB3F10;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B63C8200(void *a1)
{
  *a1 = &unk_1F0FB3AE8;
  uint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B63C824C(void *a1)
{
  *a1 = &unk_1F0FB3AE8;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

double sub_1B63C82B8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, char *a5)
{
  v12[0] = a1;
  v12[1] = a2;
  uint64_t v8 = sub_1B63C8330(v12, 0xE0u, 8u);
  uint64_t v9 = *a3;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v11, a4);
  *(void *)&double result = CFX::RG::Resource::Resource(v8, v9, (uint64_t)v11, *a5).n128_u64[0];
  return result;
}

uint64_t sub_1B63C8330(void *a1, unsigned int a2, unsigned int a3)
{
  uint64_t result = CScratchAllocatorAllocateAligned(*a1, a2, a3);
  uint64_t v8 = result;
  if (a1[1])
  {
    LODWORD(v7[128]) = backtrace(v7, 128);
    uint64_t v5 = a1[1];
    uint64_t v9 = &v8;
    uint64_t v6 = sub_1B63C83BC(v5, &v8, (uint64_t)&unk_1B6E4FDF8, &v9);
    memcpy(v6 + 3, v7, 0x408uLL);
    return v8;
  }
  return result;
}

void *sub_1B63C83BC(uint64_t a1, void *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
    }
    else
    {
      unint64_t v4 = v9 & (v10 - 1);
    }
    CFDictionaryRef v12 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v12)
    {
      for (uint64_t i = *v12; i; uint64_t i = (void *)*i)
      {
        unint64_t v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2) {
            return i;
          }
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x420uLL);
  *uint64_t i = 0;
  i[1] = v9;
  i[2] = **a4;
  bzero(i + 3, 0x408uLL);
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v10 || (float)(v16 * (float)v10) < v15)
  {
    BOOL v17 = 1;
    if (v10 >= 3) {
      BOOL v17 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v10);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    sub_1B63C8630(a1, v20);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v4 = v9 % v10;
      }
      else {
        unint64_t v4 = v9;
      }
    }
    else
    {
      unint64_t v4 = (v10 - 1) & v9;
    }
  }
  uint64_t v21 = *(void *)a1;
  unsigned int v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *uint64_t i = *v22;
LABEL_38:
    *unsigned int v22 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v23 = *(void *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v23 >= v10) {
        v23 %= v10;
      }
    }
    else
    {
      v23 &= v10 - 1;
    }
    unsigned int v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1B63C860C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1B63C8620()
{
}

void sub_1B63C8630(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      sub_1B63C8720(a1, prime);
    }
  }
}

void sub_1B63C8720(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_1B63C8620();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      uint8x8_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *uint8x8_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint8x8_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint8x8_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

double sub_1B63C887C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v7 = sub_1B63C8330(v10, 0x248u, 8u);
  return sub_1B63C6AD4(v7, *a3, a3[1], v8, a5);
}

uint64_t *sub_1B63C88CC(uint64_t *result, void *a2)
{
  unint64_t v3 = result;
  unsigned int v4 = *((_DWORD *)result + 4);
  unsigned int v5 = v4 + 1;
  if (v4 + 1 > *((_DWORD *)result + 5))
  {
    uint64_t result = sub_1B63C8928((uint64_t)result, 1, 0);
    unsigned int v4 = *((_DWORD *)v3 + 4);
    unsigned int v5 = v4 + 1;
  }
  *(void *)(v3[3] + 8 * v4) = *a2;
  *((_DWORD *)v3 + 4) = v5;
  return result;
}

uint64_t *sub_1B63C8928(uint64_t a1, int a2, int a3)
{
  unsigned int v4 = *(const void **)(a1 + 24);
  unsigned int v5 = (const void *)(a1 + 32);
  double v6 = 1.5;
  if (a3) {
    double v6 = 1.0;
  }
  unsigned int v7 = (v6 * (double)(*(_DWORD *)(a1 + 20) + a2));
  uint64_t v8 = (void *)sub_1B63C8330((void *)a1, 8 * v7, 8u);
  uint64_t result = (uint64_t *)memcpy(v8, v4, 8 * *(unsigned int *)(a1 + 16));
  *(void *)(a1 + 24) = v8;
  *(_DWORD *)(a1 + 20) = v7;
  if (v4 != v5)
  {
    unint64_t v10 = v4;
    uint64_t result = *(uint64_t **)(a1 + 8);
    if (result) {
      return sub_1B63C89D4(result, &v10);
    }
  }
  return result;
}

uint64_t *sub_1B63C89D4(void *a1, void *a2)
{
  uint64_t result = sub_1B63C8A0C(a1, a2);
  if (result)
  {
    sub_1B63C8AF8(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

void *sub_1B63C8A0C(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  uint64_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t sub_1B63C8AF8(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  sub_1B63C8B3C(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  __p = 0;
  if (v3) {
    operator delete(v3);
  }
  return v2;
}

void *sub_1B63C8B3C@<X0>(void *result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  uint8x8_t v6 = *(void **)(*result + 8 * v4);
  do
  {
    unint64_t v7 = v6;
    uint8x8_t v6 = (void *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*result + 8 * v4) = 0;
  }
  uint64_t v10 = *a2;
  if (*a2)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*result + 8 * v11) = v7;
      uint64_t v10 = *a2;
    }
  }
  *unint64_t v7 = v10;
  *a2 = 0;
  --result[3];
  *(void *)a3 = a2;
  *(void *)(a3 + 8) = result + 2;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

uint64_t sub_1B63C8C70(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v7 = sub_1B63C8330(v10, 0x248u, 8u);
  return sub_1B63C6F80(v7, *a3, a3[1], v8, a5);
}

uint64_t sub_1B63C8CC0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v7 = sub_1B63C8330(v10, 0x2F0u, 8u);
  return sub_1B63C7408(v7, *a3, a3[1], v8, a5);
}

uint64_t sub_1B63C8D10(uint64_t *a1)
{
  uint64_t result = *a1;
  if (!result)
  {
    uint64_t result = _CFRuntimeRegisterClass();
    *a1 = result;
  }
  return result;
}

uint64_t sub_1B63C8D44(CFTypeID a1, size_t a2)
{
  if (HIDWORD(a2)) {
    return 0;
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v2 = Instance;
  if (Instance)
  {
    bzero((void *)(Instance + 16), a2);
  }
  else
  {
    CFStringRef v6 = CFCopyTypeIDDescription(a1);
    CFRelease(v6);
  }
  return v2;
}

BOOL sub_1B63C8DC4(float *a1, float *a2)
{
  return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3];
}

BOOL sub_1B63C8E10(float *a1, float *a2)
{
  return vabds_f32(*a1, *a2) <= 0.001
      && vabds_f32(a1[1], a2[1]) <= 0.001
      && vabds_f32(a1[2], a2[2]) <= 0.001
      && vabds_f32(a1[3], a2[3]) <= 0.001;
}

BOOL sub_1B63C8E84(float *a1)
{
  return *a1 <= 0.001 && a1[1] <= 0.001 && a1[2] <= 0.001;
}

BOOL sub_1B63C8EC8(float *a1)
{
  return fabsf(*a1 + -1.0) <= 0.001 && fabsf(a1[1] + -1.0) <= 0.001 && fabsf(a1[2] + -1.0) <= 0.001;
}

float *sub_1B63C8F2C(float *result, float a2, float a3, float a4, float a5)
{
  void *result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

float sub_1B63C8F38(float *a1, float *a2, float *a3, float a4)
{
  *a3 = *a1 + (float)((float)(*a2 - *a1) * a4);
  a3[1] = a1[1] + (float)((float)(a2[1] - a1[1]) * a4);
  a3[2] = a1[2] + (float)((float)(a2[2] - a1[2]) * a4);
  float result = a1[3] + (float)((float)(a2[3] - a1[3]) * a4);
  a3[3] = result;
  return result;
}

float sub_1B63C8F8C(float *a1, float *a2, float *a3)
{
  *a3 = *a1 + *a2;
  a3[1] = a1[1] + a2[1];
  a3[2] = a1[2] + a2[2];
  float result = a1[3] + a2[3];
  a3[3] = result;
  return result;
}

float sub_1B63C8FD0(float *a1, float *a2, float *a3)
{
  *a3 = *a1 - *a2;
  a3[1] = a1[1] - a2[1];
  a3[2] = a1[2] - a2[2];
  float result = a1[3] - a2[3];
  a3[3] = result;
  return result;
}

float sub_1B63C9014(float *a1, float *a2)
{
  float v2 = a1[1] - a2[1];
  float v3 = a1[2] - a2[2];
  float v4 = a1[3] - a2[3];
  return sqrtf((float)((float)((float)(v2 * v2) + (float)((float)(*a1 - *a2) * (float)(*a1 - *a2))) + (float)(v3 * v3))+ (float)(v4 * v4));
}

unint64_t sub_1B63C904C(uint64_t a1, int a2)
{
  if (*((float *)&a1 + 1) <= 1.0) {
    float v2 = *((float *)&a1 + 1);
  }
  else {
    float v2 = 1.0;
  }
  float v3 = 0.0;
  if (*((float *)&a1 + 1) < 0.0) {
    float v2 = 0.0;
  }
  if (*(float *)&a2 <= 1.0) {
    float v4 = *(float *)&a2;
  }
  else {
    float v4 = 1.0;
  }
  if (*(float *)&a2 < 0.0) {
    float v4 = 0.0;
  }
  if (v2 == 0.0)
  {
    float v5 = v4;
    float v6 = v4;
  }
  else
  {
    float v8 = *(float *)&a1 * 360.0;
    if (*(float *)&a1 > 1.0) {
      float v8 = 360.0;
    }
    if (*(float *)&a1 >= 0.0) {
      float v9 = v8;
    }
    else {
      float v9 = 0.0;
    }
    if (v9 != 360.0) {
      float v3 = v9 / 60.0;
    }
    int v10 = (int)v3;
    float v11 = v3 - (float)(int)v3;
    float v12 = v4 * (float)(1.0 - v2);
    float v13 = v4 * (float)(1.0 - (float)(v2 * v11));
    float v14 = v4 * (float)(1.0 - (float)(v2 * (float)(1.0 - v11)));
    float v5 = v4;
    float v6 = v14;
    switch(v10)
    {
      case 0:
        return LODWORD(v5) | ((unint64_t)LODWORD(v6) << 32);
      case 1:
        float v5 = v13;
        float v6 = v4;
        break;
      case 2:
        float v5 = v12;
        float v6 = v4;
        break;
      case 3:
        float v5 = v12;
        float v6 = v13;
        break;
      case 4:
        float v5 = v14;
        float v6 = v12;
        break;
      default:
        float v5 = v4;
        float v6 = v12;
        break;
    }
  }
  return LODWORD(v5) | ((unint64_t)LODWORD(v6) << 32);
}

uint64_t sub_1B63C9198()
{
  if (sub_1B63CC4D8())
  {
    if (qword_1E9DDA5B8 != -1) {
      dispatch_once(&qword_1E9DDA5B8, &unk_1F0FB6F68);
    }
    unint64_t v0 = &qword_1E9DDA5B0;
  }
  else
  {
    if (qword_1EB9954D0 != -1) {
      dispatch_once(&qword_1EB9954D0, &unk_1F0FB6FA8);
    }
    unint64_t v0 = &qword_1EB9954C8;
  }
  return *v0;
}

uint64_t sub_1B63C921C()
{
  if (qword_1E9DDA578 != -1) {
    dispatch_once(&qword_1E9DDA578, &unk_1F0FB63A8);
  }
  return qword_1E9DDA570;
}

__n128 sub_1B63C9260(CGColorRef color, CGColorSpace *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!color) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"color");
  }
  if (CGColorGetColorSpace(color) == a2) {
    int v10 = CGColorRetain(color);
  }
  else {
    int v10 = (CGColor *)CGColorTransformConvertColor();
  }
  float v11 = v10;
  size_t NumberOfComponents = CGColorGetNumberOfComponents(v10);
  Components = (float64x2_t *)CGColorGetComponents(v11);
  if (NumberOfComponents >= 4)
  {
    *(float *)&__int32 v14 = Components[1].f64[1];
    v15.i64[0] = 0;
    v15.i32[2] = 0;
    v15.i32[3] = v14;
LABEL_12:
    *(float32x2_t *)&long long v17 = vcvt_f32_f64(*Components);
    *((void *)&v17 + 1) = vextq_s8(v15, v15, 8uLL).u64[0];
    float v18 = Components[1].f64[0];
LABEL_15:
    *((float *)&v17 + 2) = v18;
    goto LABEL_16;
  }
  if (NumberOfComponents == 2)
  {
    float v16 = Components->f64[1];
    *((float *)&v17 + 3) = v16;
    goto LABEL_14;
  }
  if (NumberOfComponents >= 3)
  {
    int8x16_t v15 = (int8x16_t)xmmword_1B6E4F370;
    goto LABEL_12;
  }
  long long v17 = xmmword_1B6E4F370;
  if (NumberOfComponents)
  {
LABEL_14:
    float v18 = Components->f64[0];
    *(float *)&long long v17 = v18;
    *((float *)&v17 + 1) = v18;
    goto LABEL_15;
  }
LABEL_16:
  long long v20 = v17;
  CGColorRelease(v11);
  return (__n128)v20;
}

uint64_t sub_1B63C9388()
{
  if (qword_1E9DDA548 != -1) {
    dispatch_once(&qword_1E9DDA548, &unk_1F0FB5508);
  }
  return qword_1E9DDA540;
}

uint64_t sub_1B63C93CC()
{
  if (qword_1EB9953B8 != -1) {
    dispatch_once(&qword_1EB9953B8, &unk_1F0FB6108);
  }
  return qword_1EB9953B0;
}

uint64_t sub_1B63C9410()
{
  if (qword_1E9DDA588 != -1) {
    dispatch_once(&qword_1E9DDA588, &unk_1F0FB64C8);
  }
  return qword_1E9DDA580;
}

double sub_1B63C9454(CGColorRef color, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_1E9DDA588 != -1) {
    dispatch_once(&qword_1E9DDA588, &unk_1F0FB64C8);
  }
  float v9 = (CGColorSpace *)qword_1E9DDA580;
  if (qword_1E9DDA5B8 != -1) {
    dispatch_once(&qword_1E9DDA5B8, &unk_1F0FB6F68);
  }
  uint64_t v10 = qword_1E9DDA5B0;

  *(void *)&double result = sub_1B63C9260(color, v9, v10, a4, a5, a6, a7, a8).n128_u64[0];
  return result;
}

uint64_t sub_1B63C94EC()
{
  if (qword_1E9DDA598 != -1) {
    dispatch_once(&qword_1E9DDA598, &unk_1F0FB65E8);
  }
  return qword_1E9DDA590;
}

double sub_1B63C9530(CGColorRef color, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_1E9DDA5A8 != -1) {
    dispatch_once(&qword_1E9DDA5A8, &unk_1F0FB6728);
  }
  float v9 = (CGColorSpace *)qword_1E9DDA5A0;
  if (qword_1E9DDA5E8 != -1) {
    dispatch_once(&qword_1E9DDA5E8, &unk_1F0FB7048);
  }
  uint64_t v10 = qword_1E9DDA5E0;

  *(void *)&double result = sub_1B63C9260(color, v9, v10, a4, a5, a6, a7, a8).n128_u64[0];
  return result;
}

unint64_t sub_1B63C95C8(CGColorRef color, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (color)
  {
    if (a2) {
      goto LABEL_16;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"color");
    if (a2)
    {
LABEL_16:
      float v12 = CGColorRetain(color);
      goto LABEL_20;
    }
  }
  if (sub_1B63CC4D8())
  {
    if (qword_1E9DDA588 != -1) {
      dispatch_once(&qword_1E9DDA588, &unk_1F0FB64C8);
    }
    uint64_t v10 = &qword_1E9DDA580;
  }
  else
  {
    if (qword_1EB9953B8 != -1) {
      dispatch_once(&qword_1EB9953B8, &unk_1F0FB6108);
    }
    uint64_t v10 = &qword_1EB9953B0;
  }
  float v11 = (CGColorSpace *)*v10;
  if (CGColorGetColorSpace(color) == v11) {
    goto LABEL_16;
  }
  if (sub_1B63CC4D8())
  {
    if (qword_1E9DDA5B8 != -1) {
      dispatch_once(&qword_1E9DDA5B8, &unk_1F0FB6F68);
    }
  }
  else if (qword_1EB9954D0 != -1)
  {
    dispatch_once(&qword_1EB9954D0, &unk_1F0FB6FA8);
  }
  float v12 = (CGColor *)CGColorTransformConvertColor();
LABEL_20:
  float v13 = v12;
  size_t NumberOfComponents = CGColorGetNumberOfComponents(v12);
  Components = CGColorGetComponents(v13);
  if (NumberOfComponents >= 4)
  {
LABEL_21:
    float v16 = *Components;
    float v25 = v16;
    unsigned __int32 v17 = vcvt_f32_f64(*(float64x2_t *)(Components + 1)).u32[0];
    goto LABEL_26;
  }
  if (NumberOfComponents == 2) {
    goto LABEL_25;
  }
  if (NumberOfComponents >= 3) {
    goto LABEL_21;
  }
  if (NumberOfComponents)
  {
LABEL_25:
    double v18 = *Components;
    *(float *)&double v18 = *Components;
    float v25 = *(float *)&v18;
    unsigned __int32 v17 = vdup_lane_s32(*(int32x2_t *)&v18, 0).u32[0];
  }
  else
  {
    unsigned __int32 v17 = 0;
    float v25 = 0.0;
  }
LABEL_26:
  CGColorRelease(v13);
  if (a2)
  {
    float v19 = v25;
    double v20 = v25;
    if (v25 <= 0.00001) {
      float v19 = 0.0;
    }
    BOOL v21 = v20 < 0.99999;
    LODWORD(v20) = 1.0;
    if (v21) {
      float v22 = v19;
    }
    else {
      float v22 = 1.0;
    }
    if (v22 <= 0.00001) {
      float v23 = 0.0;
    }
    else {
      float v23 = v22;
    }
    if (v22 < 0.99999) {
      *(float *)&double v20 = v23;
    }
    unsigned __int32 v17 = vdup_lane_s32(*(int32x2_t *)&v20, 0).u32[0];
  }
  else
  {
    float v22 = v25;
  }
  return LODWORD(v22) | ((unint64_t)v17 << 32);
}

CGColorRef sub_1B63C9830(float32x4_t a1)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  v2[0] = vcvtq_f64_f32(*(float32x2_t *)a1.f32);
  v2[1] = vcvt_hight_f64_f32(a1);
  if (qword_1E9DDA588 != -1) {
    dispatch_once(&qword_1E9DDA588, &unk_1F0FB64C8);
  }
  return CGColorCreate((CGColorSpaceRef)qword_1E9DDA580, (const CGFloat *)v2);
}

CGColorRef sub_1B63C98BC(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3.i64[0] = a1;
  v3.i64[1] = a2;
  sub_1B63C9958(&v3);
  *(float64x2_t *)components = vcvtq_f64_f32(*(float32x2_t *)v3.f32);
  float64x2_t v5 = vcvtq_f64_f32(*(float32x2_t *)&v3.u32[2]);
  if (qword_1E9DDA578 != -1) {
    dispatch_once(&qword_1E9DDA578, &unk_1F0FB63A8);
  }
  return CGColorCreate((CGColorSpaceRef)qword_1E9DDA570, components);
}

float64_t sub_1B63C9958(float32x4_t *a1)
{
  v3.f64[0] = 0.0;
  v3.f64[1] = a1->f32[3];
  if (sub_1B63CC4D8())
  {
    if (qword_1E9DDA5C8 != -1) {
      dispatch_once(&qword_1E9DDA5C8, &unk_1F0FB6FC8);
    }
    if (qword_1E9DDA588 != -1) {
      dispatch_once(&qword_1E9DDA588, &unk_1F0FB64C8);
    }
  }
  else
  {
    if (qword_1E9DDA5D8 != -1) {
      dispatch_once(&qword_1E9DDA5D8, &unk_1F0FB6FE8);
    }
    if (qword_1EB9953B8 != -1) {
      dispatch_once(&qword_1EB9953B8, &unk_1F0FB6108);
    }
  }
  CGColorTransformConvertColorComponents();
  float64_t result = v3.f64[0];
  *a1 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64((float64x2_t)0), v3);
  return result;
}

CGColorSpaceRef sub_1B63C9AC8()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
  qword_1E9DDA540 = (uint64_t)result;
  return result;
}

CGColorSpaceRef sub_1B63C9AF4()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
  qword_1EB9953B0 = (uint64_t)result;
  return result;
}

uint64_t sub_1B63C9B20()
{
  if (qword_1E9DDA558 != -1) {
    dispatch_once(&qword_1E9DDA558, &unk_1F0FB6208);
  }
  return qword_1E9DDA550;
}

CGColorSpaceRef sub_1B63C9B64()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
  qword_1E9DDA550 = (uint64_t)result;
  return result;
}

uint64_t sub_1B63C9B90()
{
  if (qword_1E9DDA568 != -1) {
    dispatch_once(&qword_1E9DDA568, &unk_1F0FB62C8);
  }
  return qword_1E9DDA560;
}

CGColorSpaceRef sub_1B63C9BD4()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC78]);
  qword_1E9DDA560 = (uint64_t)result;
  return result;
}

CGColorSpaceRef sub_1B63C9C00()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE8]);
  qword_1E9DDA570 = (uint64_t)result;
  return result;
}

CGColorSpaceRef sub_1B63C9C2C()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE0]);
  qword_1E9DDA580 = (uint64_t)result;
  return result;
}

CGColorSpaceRef sub_1B63C9C58()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC70]);
  qword_1E9DDA590 = (uint64_t)result;
  return result;
}

CGColorSpaceRef sub_1B63C9C84()
{
  CGColorSpaceRef result = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC58]);
  qword_1E9DDA5A0 = (uint64_t)result;
  return result;
}

void sub_1B63C9D34(CGColorSpaceRef a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X8>)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  uint64_t v40 = &v39;
  uint64_t v41 = 0xA000000000;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  uint64_t v35 = 0;
  uint64_t v36 = &v35;
  uint64_t v37 = 0x2000000000;
  int v38 = -1;
  uint64_t v31 = 0;
  uint32x2_t v32 = &v31;
  uint64_t v33 = 0x2000000000;
  int v34 = -1;
  CGColorConversionInfoRef v5 = CGColorConversionInfoCreateFromList(0, a1, kCGColorConversionTransformFromSpace, kCGRenderingIntentDefault, a2, 1, 0, 0);
  if (v5)
  {
    CGColorConversionInfoRef v12 = v5;
    if ((CGColorConversionInfoIterateFunctionsWithCallbacks() & 1) == 0)
    {
      sub_1B63F2F54(16, @"Error: Failed to compute color conversion parameters for %@  %@", v13, v14, v15, v16, v17, v18, (uint64_t)a1);
      float v19 = v40;
      *((_WORD *)v40 + 16) = 0;
      *((unsigned char *)v19 + 34) = 0;
    }
    CFRelease(v12);
  }
  else
  {
    sub_1B63F2F54(16, @"Error: No conversion info for %@  %@, texture will be copied", v6, v7, v8, v9, v10, v11, (uint64_t)a1);
  }
  if (!*((unsigned char *)v40 + 33))
  {
    if (*((unsigned char *)v40 + 34))
    {
      if (*((unsigned char *)v40 + 32) || *((_DWORD *)v32 + 6) != 4) {
        goto LABEL_7;
      }
    }
    else if (!*((unsigned char *)v40 + 32) || *((_DWORD *)v36 + 6) != 1)
    {
      goto LABEL_7;
    }
    sub_1B63F2F54(16, @"Error: Color matching for %@  %@ could be done more efficiently by switching to a _sRGB variant of the MTLPixelFormat", v20, v21, v22, v23, v24, v25, (uint64_t)a1);
  }
LABEL_7:
  unsigned int v26 = v40;
  long long v27 = *((_OWORD *)v40 + 7);
  a3[4] = *((_OWORD *)v40 + 6);
  a3[5] = v27;
  long long v28 = *((_OWORD *)v26 + 9);
  a3[6] = *((_OWORD *)v26 + 8);
  a3[7] = v28;
  long long v29 = *((_OWORD *)v26 + 3);
  *a3 = *((_OWORD *)v26 + 2);
  a3[1] = v29;
  long long v30 = *((_OWORD *)v26 + 5);
  a3[2] = *((_OWORD *)v26 + 4);
  a3[3] = v30;
  _Block_object_dispose(&v31, 8);
  _Block_object_dispose(&v35, 8);
  _Block_object_dispose(&v39, 8);
}

uint64_t sub_1B63C9FBC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(*(void *)(a2 + 52) + 8 * *a5);
  if (a4 >= 2)
  {
    uint64_t v12 = a4 - 1;
    uint64_t v13 = a5 + 1;
    do
    {
      uint64_t v14 = *v13++;
      if (*(void *)(*(void *)(a2 + 52) + 8 * v14) != v11) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Unsupported conversion info - different TRCs for input components", a3, a4, (uint64_t)a5, a6, a7, a8, (uint64_t)"trcOther == trc");
      }
      --v12;
    }
    while (v12);
  }
  int v15 = CGColorTRCGetGammaID();
  if (v15 == 7) {
    return 1;
  }
  int v17 = v15;
  CGColorTRCGetFunction();
  if (!a3)
  {
    *(_DWORD *)(*(void *)(a1[4] + 8) + 24) = v17;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 32) = 1;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 36) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 40) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 44) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 48) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 52) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 56) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 60) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 64) = 0;
    return 1;
  }
  if (*(void *)(a2 + 4) - 1 == a3)
  {
    *(_DWORD *)(*(void *)(a1[6] + 8) + 24) = v17;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 34) = 1;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 128) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 132) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 136) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 140) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 144) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 148) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 152) = 0;
    *(_DWORD *)(*(void *)(a1[5] + 8) + 156) = 0;
    return 1;
  }
  sub_1B63F2F54(16, @"Error: Unsupported conversion info - stage %d of %d will be ignored!", v18, v19, v20, v21, v22, v23, a3);
  return 0;
}

BOOL sub_1B63CA25C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 36);
  if (v8 == 1)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 33) = 1;
    memset(v14, 0, 24);
    CGColorMatrixGetMatrix();
    long long v10 = 0u;
    DWORD1(v10) = 0;
    DWORD2(v10) = 0;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 80) = v10;
    long long v11 = *(_OWORD *)((char *)v14 + 4);
    DWORD1(v11) = 0;
    DWORD2(v11) = 0;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 96) = v11;
    long long v12 = *(_OWORD *)((char *)v14 + 8);
    DWORD1(v12) = 0;
    DWORD2(v12) = 0;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 112) = v12;
  }
  else
  {
    sub_1B63F2F54(16, @"Error: Unsupported conversion info - %d color matrices", a3, a4, a5, a6, a7, a8, *(void *)(a2 + 36));
  }
  return v8 == 1;
}

uint64_t sub_1B63CA350(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1B63F2F54(16, @"Error: Unsupported conversion info - NxMLUTs not supported", a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t sub_1B63CA378()
{
  if (qword_1E9DDA588 != -1) {
    dispatch_once(&qword_1E9DDA588, &unk_1F0FB64C8);
  }
  uint64_t result = MEMORY[0x1BA9B62D0](qword_1E9DDA580, 0);
  qword_1E9DDA5B0 = result;
  return result;
}

uint64_t sub_1B63CA3CC()
{
  if (qword_1EB9953B8 != -1) {
    dispatch_once(&qword_1EB9953B8, &unk_1F0FB6108);
  }
  uint64_t result = MEMORY[0x1BA9B62D0](qword_1EB9953B0, 0);
  qword_1EB9954C8 = result;
  return result;
}

uint64_t sub_1B63CA420()
{
  if (qword_1E9DDA578 != -1) {
    dispatch_once(&qword_1E9DDA578, &unk_1F0FB63A8);
  }
  uint64_t result = MEMORY[0x1BA9B62D0](qword_1E9DDA570, 0);
  qword_1E9DDA5C0 = result;
  return result;
}

uint64_t sub_1B63CA474()
{
  if (qword_1E9DDA548 != -1) {
    dispatch_once(&qword_1E9DDA548, &unk_1F0FB5508);
  }
  uint64_t result = MEMORY[0x1BA9B62D0](qword_1E9DDA540, 0);
  qword_1E9DDA5D0 = result;
  return result;
}

uint64_t sub_1B63CA4C8()
{
  if (qword_1E9DDA5A8 != -1) {
    dispatch_once(&qword_1E9DDA5A8, &unk_1F0FB6728);
  }
  uint64_t result = MEMORY[0x1BA9B62D0](qword_1E9DDA5A0, 0);
  qword_1E9DDA5E0 = result;
  return result;
}

void *sub_1B63CA51C(size_t a1)
{
  return malloc_type_malloc(a1, 0xDCFB6CECuLL);
}

void *sub_1B63CA528(size_t a1)
{
  return malloc_type_malloc(a1, 0xE0978C61uLL);
}

uint64_t sub_1B63CA534(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 45) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. unknown type", a3, a4, a5, a6, a7, a8, (uint64_t)"type < kCFXBaseTypeCount");
  }
  return qword_1B6E4F9F8[a1];
}

uint64_t sub_1B63CA58C(const __CFString *a1)
{
  CFRange v2 = CFStringFind(a1, @"[", 4uLL);
  if (!v2.length) {
    return 1;
  }
  v6.length = CFStringGetLength(a1) - v2.location - 2;
  v6.location = v2.location + 1;
  CFStringRef v3 = CFStringCreateWithSubstring(0, a1, v6);
  uint64_t IntValue = CFStringGetIntValue(v3);
  CFRelease(v3);
  return IntValue;
}

CFComparisonResult sub_1B63CA610(const __CFString *a1)
{
  CFRange v2 = CFStringFind(a1, @"[", 4uLL);
  if (v2.length)
  {
    v7.length = v2.location;
    v7.location = 0;
    CFStringRef v3 = CFStringCreateWithSubstring(0, a1, v7);
    CFComparisonResult v4 = sub_1B63CA690(v3);
    CFRelease(v3);
    return v4;
  }
  else
  {
    return sub_1B63CA690(a1);
  }
}

CFComparisonResult sub_1B63CA690(const __CFString *a1)
{
  if (CFEqual(a1, @"int")) {
    return 2;
  }
  if (CFEqual(a1, @"BOOL")) {
    return 3;
  }
  if (CFEqual(a1, @"texture1d")
    || CFEqual(a1, @"texture2d")
    || CFEqual(a1, @"texture3d")
    || CFEqual(a1, @"texturecube"))
  {
    return 5;
  }
  if (CFEqual(a1, @"float")) {
    return 1;
  }
  if (CFEqual(a1, @"float2")) {
    return 7;
  }
  if (CFEqual(a1, @"float3")) {
    return 8;
  }
  if (CFEqual(a1, @"float4")) {
    return 9;
  }
  if (CFEqual(a1, @"int2")) {
    return 17;
  }
  if (CFEqual(a1, @"int3")) {
    return 18;
  }
  if (CFEqual(a1, @"int4")) {
    return 19;
  }
  if (CFEqual(a1, @"float4x4")) {
    return 10;
  }
  CFComparisonResult result = CFStringCompare(a1, @"none", 0);
  if (result)
  {
    CFComparisonResult result = CFStringCompare(a1, @"sampler", 0);
    if (result)
    {
      sub_1B63F2F54(0, @"Warning: CFXBaseTypeFromMetalString: unknown type name '%@'", v3, v4, v5, v6, v7, v8, (uint64_t)a1);
      return 0;
    }
  }
  return result;
}

__CFString *sub_1B63CA8A4(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 45)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. unknown type", a3, a4, a5, a6, a7, a8, (uint64_t)"type < kCFXBaseTypeCount");
  }
  else if (a1 <= 0x2C)
  {
    return off_1E6140D20[(unsigned __int16)a1];
  }
  return @"unknown type";
}

uint64_t sub_1B63CA908(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 0x2D)
  {
    return (__int16)word_1B6E4FB60[3 * (unsigned __int16)a1];
  }
  else
  {
    sub_1B63F2F54(16, @"Error: unknown type", a3, a4, a5, a6, a7, a8, vars0);
    return 0;
  }
}

uint64_t sub_1B63CA958(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 0x2D) {
    return HIBYTE(word_1B6E4FB60[3 * (unsigned __int16)a1 + 1]);
  }
  sub_1B63F2F54(16, @"Error: unknown type", a3, a4, a5, a6, a7, a8, vars0);
  return 1;
}

uint64_t sub_1B63CA9A4(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 0x2D) {
    return LOBYTE(word_1B6E4FB60[3 * (unsigned __int16)a1 + 1]);
  }
  sub_1B63F2F54(16, @"Error: unknown type", a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

unint64_t sub_1B63CA9F0(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 < 0x2D) {
    return (0x1FFC0CF05FC2uLL >> a1) & 1;
  }
  sub_1B63F2F54(16, @"Error: unknown type", a3, a4, a5, a6, a7, a8, v8);
  return 0;
}

uint64_t sub_1B63CAA3C(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LOWORD(v8) = a1;
  switch(a1)
  {
    case 1:
      if ((a2 - 1) < 4)
      {
        char v9 = 16 * (a2 - 1);
        unint64_t v10 = 0x9000800070001;
        goto LABEL_19;
      }
      long long v11 = "kCFXBaseTypeFloat";
      goto LABEL_48;
    case 2:
      if ((a2 - 1) < 4)
      {
        char v9 = 16 * (a2 - 1);
        unint64_t v10 = 0x13001200110002;
        goto LABEL_19;
      }
      long long v11 = "kCFXBaseTypeInteger";
      goto LABEL_48;
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 17:
    case 18:
    case 19:
      goto LABEL_8;
    case 4:
      if (a2 == 1)
      {
        LOWORD(v8) = 4;
        return (__int16)v8;
      }
      if (a2 == 4)
      {
        LOWORD(v8) = 25;
        return (__int16)v8;
      }
      long long v11 = "kCFXBaseTypeChar";
      goto LABEL_48;
    case 13:
      if ((a2 - 1) < 4)
      {
        char v9 = 16 * (a2 - 1);
        unint64_t v10 = 0x210020001F000DLL;
        goto LABEL_19;
      }
      long long v11 = "kCFXBaseTypeShort";
      goto LABEL_48;
    case 14:
      if ((a2 - 1) >= 4)
      {
        long long v11 = "kCFXBaseTypeHalf";
        goto LABEL_48;
      }
      char v9 = 16 * (a2 - 1);
      unint64_t v10 = 0x2C002B002A000ELL;
LABEL_19:
      unint64_t v8 = v10 >> v9;
      return (__int16)v8;
    case 15:
      if (a2 == 1)
      {
        LOWORD(v8) = 15;
        return (__int16)v8;
      }
      if (a2 == 4)
      {
        LOWORD(v8) = 24;
        return (__int16)v8;
      }
      long long v11 = "kCFXBaseTypeUnsignedChar";
      goto LABEL_48;
    case 16:
      if ((a2 - 1) < 4)
      {
        unint64_t v8 = 0x1E001D001C0010uLL >> (16 * (a2 - 1));
        return (__int16)v8;
      }
      long long v11 = "kCFXBaseTypeUnsignedShort";
      goto LABEL_48;
    case 20:
      if (a2 == 1)
      {
        LOWORD(v8) = 20;
        return (__int16)v8;
      }
      if (a2 == 4)
      {
        LOWORD(v8) = 26;
        return (__int16)v8;
      }
      long long v11 = "kCFXBaseTypeUnsignedCharNormalized";
      goto LABEL_48;
    case 21:
      if (a2 == 1)
      {
        LOWORD(v8) = 21;
        return (__int16)v8;
      }
      if (a2 == 4)
      {
        LOWORD(v8) = 27;
        return (__int16)v8;
      }
      long long v11 = "kCFXBaseTypeCharNormalized";
      goto LABEL_48;
    default:
      if (a1 == 34)
      {
        if ((a2 - 1) < 4)
        {
          LOWORD(v8) = a2 + 33;
          return (__int16)v8;
        }
        long long v11 = "kCFXBaseTypeUnsignedShortNormalized";
        goto LABEL_48;
      }
      if (a1 == 38)
      {
        if ((a2 - 1) < 4)
        {
          LOWORD(v8) = a2 + 37;
          return (__int16)v8;
        }
        long long v11 = "kCFXBaseTypeShortNormalized";
LABEL_48:
        sub_1B63F2F54(16, @"Unreachable code: Compound type %s%d is not supported", a3, a4, a5, a6, a7, a8, (uint64_t)v11);
        return (__int16)v8;
      }
LABEL_8:
      if (a2 != 1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Only one compound type per vector", a3, a4, a5, a6, a7, a8, (uint64_t)"componentCount == 1");
      }
      return (__int16)v8;
  }
}

BOOL sub_1B63CAD14(int a1, uint64_t *a2, uint64_t *a3, unsigned char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 >= 45) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. unknown type", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"type < kCFXBaseTypeCount");
  }
  if (!a2 || !a3 || !a4) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong parameters", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"bytesPerComponent && componentsCount && floatComponents");
  }
  long long v12 = (unsigned __int8 *)&word_1B6E4FB60[3 * a1];
  uint64_t v13 = v12[2];
  uint64_t v14 = v12[3];
  LOBYTE(v12) = v12[4];
  *a2 = v13;
  *a3 = v14;
  *a4 = v12 & 1;
  return sub_1B63CADD8(*a2, v14, v12 & 1, (uint64_t)a4, a5, a6, a7, a8) == a1;
}

uint64_t sub_1B63CADD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LOWORD(v9) = 6;
  switch(a1)
  {
    case 1:
      if (a3) {
        goto LABEL_10;
      }
      goto LABEL_20;
    case 2:
      char v10 = a2 - 1;
      if (a3)
      {
        if ((unint64_t)(a2 - 1) >= 4) {
          goto LABEL_10;
        }
        char v11 = 16 * v10;
        unint64_t v12 = 0x2C002B002A000ELL;
      }
      else
      {
        if ((unint64_t)(a2 - 1) >= 4) {
          goto LABEL_20;
        }
        char v11 = 16 * v10;
        unint64_t v12 = 0x210020001F000DLL;
      }
      goto LABEL_19;
    case 4:
      char v13 = a2 - 1;
      if (a3)
      {
        if ((unint64_t)(a2 - 1) < 4)
        {
          unint64_t v9 = 0x9000800070001uLL >> (16 * v13);
          return (__int16)v9;
        }
LABEL_10:
        if ((byte_1E9DDA5F0 & 1) == 0)
        {
          byte_1E9DDA5F0 = 1;
          sub_1B63F2F54(16, @"Warning: CFXBaseTypeFromDescription - signed/unsigned ambiguity", a3, a4, a5, a6, a7, a8, v15);
        }
        if (a2 != 1)
        {
          if (a2 == 4)
          {
            LOWORD(v9) = 26;
            return (__int16)v9;
          }
LABEL_25:
          sub_1B63F2F54(16, @"Error: CFXBaseTypeFromDescription - Type not supported", a3, a4, a5, a6, a7, a8, v15);
          LOWORD(v9) = 0;
          return (__int16)v9;
        }
        LOWORD(v9) = 20;
      }
      else if ((unint64_t)(a2 - 1) >= 4)
      {
LABEL_20:
        if ((byte_1E9DDA5F1 & 1) == 0)
        {
          byte_1E9DDA5F1 = 1;
          sub_1B63F2F54(16, @"Warning: CFXBaseTypeFromDescription - signed/unsigned ambiguity", a3, a4, a5, a6, a7, a8, v15);
        }
        if (a2 != 1)
        {
          if (a2 == 4)
          {
            LOWORD(v9) = 24;
            return (__int16)v9;
          }
          goto LABEL_25;
        }
        LOWORD(v9) = 15;
      }
      else
      {
        char v11 = 16 * v13;
        unint64_t v12 = 0x13001200110002;
LABEL_19:
        unint64_t v9 = v12 >> v11;
      }
      return (__int16)v9;
    case 8:
      return (__int16)v9;
    default:
      goto LABEL_25;
  }
}

void sub_1B63CAF80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a2)
  {
    if (a3) {
      goto LABEL_3;
    }
LABEL_7:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"_b");
    if (a4) {
      goto LABEL_4;
    }
LABEL_8:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"_dst");
    goto LABEL_4;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"_a");
  if (!a3) {
    goto LABEL_7;
  }
LABEL_3:
  if (!a4) {
    goto LABEL_8;
  }
LABEL_4:
  switch((int)a1)
  {
    case 1:
      *(float *)a4 = *(float *)a2 + *(float *)a3;
      return;
    case 2:
      *(_DWORD *)a4 = *(_DWORD *)a3 + *(_DWORD *)a2;
      return;
    case 3:
    case 4:
    case 5:
    case 11:
    case 15:
      sub_1B63F2F54(16, @"Error: CFXAddBaseType - type %d can't be added", a3, a4, a5, a6, a7, a8, a1);
      return;
    case 6:
      double v13 = *(double *)a2 + *(double *)a3;
      goto LABEL_16;
    case 7:
    case 17:
      double v13 = COERCE_DOUBLE(vadd_f32(*(float32x2_t *)a2, *(float32x2_t *)a3));
LABEL_16:
      *(double *)a4 = v13;
      return;
    case 8:
    case 9:
    case 18:
    case 19:
      *(float32x4_t *)a4 = vaddq_f32(*(float32x4_t *)a2, *(float32x4_t *)a3);
      return;
    case 10:
      float32x4_t v15 = vaddq_f32(*(float32x4_t *)(a2 + 16), *(float32x4_t *)(a3 + 16));
      float32x4_t v16 = vaddq_f32(*(float32x4_t *)(a2 + 32), *(float32x4_t *)(a3 + 32));
      float32x4_t v17 = vaddq_f32(*(float32x4_t *)(a2 + 48), *(float32x4_t *)(a3 + 48));
      *(float32x4_t *)a4 = vaddq_f32(*(float32x4_t *)a2, *(float32x4_t *)a3);
      *(float32x4_t *)(a4 + 16) = v15;
      *(float32x4_t *)(a4 + 32) = v16;
      *(float32x4_t *)(a4 + 48) = v17;
      return;
    case 12:
      sub_1B63C8F8C((float *)a2, (float *)a3, (float *)a4);
      return;
    case 13:
    case 16:
      *(_WORD *)a4 = *(_WORD *)a3 + *(_WORD *)a2;
      return;
    case 14:
      uint64_t v14 = @"Error: CFXAddBaseType - addition of half float not supported";
      goto LABEL_23;
    default:
      uint64_t v14 = @"Error: CFXAddBaseType - unknown type";
LABEL_23:
      sub_1B63F2F54(16, (uint64_t)v14, a3, a4, a5, a6, a7, a8, a9);
      return;
  }
}

void sub_1B63CB1C0(uint64_t a1, _OWORD *a2, float32x4_t *a3, _OWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a2)
  {
    if (a3) {
      goto LABEL_3;
    }
LABEL_12:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"_b");
    if (a4) {
      goto LABEL_4;
    }
    goto LABEL_13;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"_a");
  if (!a3) {
    goto LABEL_12;
  }
LABEL_3:
  if (a4) {
    goto LABEL_4;
  }
LABEL_13:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"_dst");
LABEL_4:
  if (a1 == 10)
  {
    uint64_t v13 = 0;
    float32x4_t v14 = *a3;
    float32x4_t v15 = a3[1];
    float32x4_t v16 = a3[2];
    float32x4_t v17 = a3[3];
    long long v18 = a2[1];
    long long v19 = a2[2];
    long long v20 = a2[3];
    v24[0] = *a2;
    v24[1] = v18;
    v24[2] = v19;
    v24[3] = v20;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    do
    {
      *(long long *)((char *)&v25 + v13 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, COERCE_FLOAT(v24[v13])), v15, *(float32x2_t *)&v24[v13], 1), v16, (float32x4_t)v24[v13], 2), v17, (float32x4_t)v24[v13], 3);
      ++v13;
    }
    while (v13 != 4);
    long long v21 = v26;
    long long v22 = v27;
    long long v23 = v28;
    *a4 = v25;
    a4[1] = v21;
    a4[2] = v22;
    a4[3] = v23;
  }
  else
  {
    sub_1B63CAF80(a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, a9);
  }
}

void sub_1B63CB308(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a2)
  {
    if (a3) {
      goto LABEL_3;
    }
LABEL_7:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"_b");
    if (a4) {
      goto LABEL_4;
    }
LABEL_8:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"_dst");
    goto LABEL_4;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"_a");
  if (!a3) {
    goto LABEL_7;
  }
LABEL_3:
  if (!a4) {
    goto LABEL_8;
  }
LABEL_4:
  switch((int)a1)
  {
    case 1:
      *(float *)a4 = *(float *)a2 - *(float *)a3;
      return;
    case 2:
      *(_DWORD *)a4 = *(_DWORD *)a2 - *(_DWORD *)a3;
      return;
    case 3:
    case 4:
    case 5:
    case 11:
    case 15:
      sub_1B63F2F54(16, @"Error: CFXSubBaseType - type %d can't be substracted", a3, a4, a5, a6, a7, a8, a1);
      return;
    case 6:
      double v13 = *(double *)a2 - *(double *)a3;
      goto LABEL_16;
    case 7:
    case 17:
      double v13 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)a2, *(float32x2_t *)a3));
LABEL_16:
      *(double *)a4 = v13;
      return;
    case 8:
    case 9:
    case 18:
    case 19:
      *(float32x4_t *)a4 = vsubq_f32(*(float32x4_t *)a2, *(float32x4_t *)a3);
      return;
    case 10:
      float32x4_t v15 = vsubq_f32(*(float32x4_t *)(a2 + 16), *(float32x4_t *)(a3 + 16));
      float32x4_t v16 = vsubq_f32(*(float32x4_t *)(a2 + 32), *(float32x4_t *)(a3 + 32));
      float32x4_t v17 = vsubq_f32(*(float32x4_t *)(a2 + 48), *(float32x4_t *)(a3 + 48));
      *(float32x4_t *)a4 = vsubq_f32(*(float32x4_t *)a2, *(float32x4_t *)a3);
      *(float32x4_t *)(a4 + 16) = v15;
      *(float32x4_t *)(a4 + 32) = v16;
      *(float32x4_t *)(a4 + 48) = v17;
      return;
    case 12:
      sub_1B63C8FD0((float *)a2, (float *)a3, (float *)a4);
      return;
    case 13:
    case 16:
      *(_WORD *)a4 = *(_WORD *)a2 - *(_WORD *)a3;
      return;
    case 14:
      float32x4_t v14 = @"Error: CFXSubBaseType - substraction of half float not supported";
      goto LABEL_23;
    default:
      float32x4_t v14 = @"Error: CFXSubBaseType - unknown type";
LABEL_23:
      sub_1B63F2F54(16, (uint64_t)v14, a3, a4, a5, a6, a7, a8, a9);
      return;
  }
}

uint64_t sub_1B63CB548(uint64_t a1)
{
  return MEMORY[0x1F4181798](MEMORY[0x1E4F28B68], sel_stringFromByteCount_countStyle_, a1, 3);
}

const char *sub_1B63CB55C(const char *result)
{
  if (result)
  {
    uint64_t v1 = (char *)result;
    CFComparisonResult result = CFStringGetCStringPtr((CFStringRef)result, 0x600u);
    if (!result)
    {
      return (const char *)objc_msgSend_UTF8String(v1, v2, v3, v4);
    }
  }
  return result;
}

CFCharacterSetRef sub_1B63CB5AC(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4, char a5)
{
  *(void *)a1 = a3;
  *(void *)(a1 + 8) = a4;
  if (theString)
  {
    *(void *)(a1 + 144) = theString;
    *(void *)(a1 + 168) = a3;
    *(void *)(a1 + 176) = a4;
    CharactersPtr = CFStringGetCharactersPtr(theString);
    *(void *)(a1 + 152) = CharactersPtr;
    if (CharactersPtr) {
      CStringPtr = 0;
    }
    else {
      CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
    }
    *(void *)(a1 + 160) = CStringPtr;
    *(void *)(a1 + 184) = 0;
    *(void *)(a1 + 192) = 0;
  }
  *(void *)(a1 + 200) = a3;
  *(void *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 216) = a5;
  *(void *)(a1 + 224) = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  CFCharacterSetRef result = CFCharacterSetGetPredefined(kCFCharacterSetAlphaNumeric);
  *(void *)(a1 + 232) = result;
  return result;
}

uint64_t sub_1B63CB63C(uint64_t a1)
{
  return sub_1B63CBCB8(a1, 0);
}

uint64_t sub_1B63CB644(uint64_t a1)
{
  return *(void *)(a1 + 200);
}

void sub_1B63CB650(UniChar *buffer, uint64_t *a2, uint64_t a3)
{
  for (uint64_t i = *a2; i < a3; *a2 = i)
  {
    if (i < 0 || (uint64_t v7 = *((void *)buffer + 20), v7 <= i))
    {
      UniChar v9 = 0;
    }
    else
    {
      uint64_t v8 = *((void *)buffer + 17);
      if (v8)
      {
        UniChar v9 = *(_WORD *)(v8 + 2 * (*((void *)buffer + 19) + i));
      }
      else
      {
        uint64_t v10 = *((void *)buffer + 18);
        if (v10)
        {
          UniChar v9 = *(char *)(v10 + *((void *)buffer + 19) + i);
        }
        else
        {
          if (*((void *)buffer + 22) <= i || (uint64_t v11 = *((void *)buffer + 21), v11 > i))
          {
            uint64_t v12 = i - 4;
            if ((unint64_t)i < 4) {
              uint64_t v12 = 0;
            }
            if (v12 + 64 < v7) {
              uint64_t v7 = v12 + 64;
            }
            *((void *)buffer + 21) = v12;
            *((void *)buffer + 22) = v7;
            v13.location = *((void *)buffer + 19) + v12;
            v13.length = v7 - v12;
            CFStringGetCharacters(*((CFStringRef *)buffer + 16), v13, buffer);
            uint64_t v11 = *((void *)buffer + 21);
          }
          UniChar v9 = buffer[i - v11];
        }
      }
    }
    if (v9 != 12288 && (unsigned __int16)(v9 - 0x2000) >= 0xCu && v9 >= 0x21u && (unsigned __int16)(v9 - 127) > 0x21u) {
      break;
    }
    uint64_t i = *a2 + 1;
  }
}

BOOL sub_1B63CB778(const __CFString *a1, const __CFString *a2)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex v5 = CFStringGetLength(a2);
  CFStringRef theString = a1;
  uint64_t v46 = 0;
  uint64_t v47 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  long long v44 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  long long v32 = 0uLL;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  *(_OWORD *)long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  long long v45 = CStringPtr;
  v31[0] = a2;
  long long v33 = (unint64_t)v5;
  uint64_t v34 = 0;
  CFStringRef v8 = (const __CFString *)CFStringGetCharactersPtr(a2);
  UniChar v9 = 0;
  v31[1] = v8;
  if (!v8) {
    UniChar v9 = CFStringGetCStringPtr(a2, 0x600u);
  }
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  *(_OWORD *)buffer = 0u;
  long long v36 = 0u;
  *((void *)&v33 + 1) = 0;
  uint64_t v34 = 0;
  *(void *)&long long v32 = v9;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  sub_1B63CB650(buffer, &v22, Length);
LABEL_6:
  sub_1B63CB650(v23, &v21, v5);
  uint64_t v10 = v21;
  while (1)
  {
    if (v10 == v5) {
      return 1;
    }
    uint64_t v11 = v22;
    if (v22 == Length) {
      goto LABEL_51;
    }
    if (v22 < 0 || (uint64_t v12 = v47, v47 <= v22))
    {
      UniChar v13 = 0;
    }
    else if (v44)
    {
      UniChar v13 = v44[v46 + v22];
    }
    else if (v45)
    {
      UniChar v13 = v45[v46 + v22];
    }
    else
    {
      if (v49 <= v22 || (uint64_t v16 = v48, v48 > v22))
      {
        uint64_t v17 = v22 - 4;
        if ((unint64_t)v22 < 4) {
          uint64_t v17 = 0;
        }
        if (v17 + 64 < v47) {
          uint64_t v12 = v17 + 64;
        }
        uint64_t v48 = v17;
        uint64_t v49 = v12;
        v50.location = v46 + v17;
        v50.length = v12 - v17;
        CFStringGetCharacters(theString, v50, buffer);
        uint64_t v16 = v48;
      }
      UniChar v13 = buffer[v11 - v16];
    }
    if (v10 < 0 || (uint64_t v14 = v33, (uint64_t)v33 <= v10))
    {
      UniChar v15 = 0;
    }
    else if (v31[1])
    {
      UniChar v15 = *((_WORD *)&v31[1]->isa + *((void *)&v32 + 1) + v10);
    }
    else if ((void)v32)
    {
      UniChar v15 = *(char *)(v32 + *((void *)&v32 + 1) + v10);
    }
    else
    {
      if (v34 <= v10 || (uint64_t v18 = *((void *)&v33 + 1), *((uint64_t *)&v33 + 1) > v10))
      {
        uint64_t v19 = v10 - 4;
        if ((unint64_t)v10 < 4) {
          uint64_t v19 = 0;
        }
        if (v19 + 64 < (uint64_t)v33) {
          uint64_t v14 = v19 + 64;
        }
        *((void *)&v33 + 1) = v19;
        uint64_t v34 = v14;
        v51.location = *((void *)&v32 + 1) + v19;
        v51.length = v14 - v19;
        CFStringGetCharacters(v31[0], v51, v23);
        uint64_t v18 = *((void *)&v33 + 1);
      }
      UniChar v15 = v23[v10 - v18];
    }
    if (v15 == 12288
      || (unsigned __int16)(v15 - 0x2000) < 0xCu
      || v15 < 0x21u
      || (unsigned __int16)(v15 - 127) <= 0x21u)
    {
      if (v13 == 12288
        || (unsigned __int16)(v13 - 0x2000) < 0xCu
        || v13 < 0x21u
        || (unsigned __int16)(v13 - 127) <= 0x21u)
      {
        sub_1B63CB650(buffer, &v22, Length);
        goto LABEL_6;
      }
LABEL_51:
      sub_1B63CB650(v23, &v21, v5);
      return v21 == v5;
    }
    if (v13 != v15) {
      return 0;
    }
    uint64_t v21 = ++v10;
    uint64_t v22 = v11 + 1;
  }
}

uint64_t sub_1B63CBAB4()
{
  uint64_t result = dword_1E9DC9F00;
  if (dword_1E9DC9F00 == -1)
  {
    dword_1E9DC9F00 = 0;
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.sse2", &v3, &v2, 0, 0) && v3) {
      dword_1E9DC9F00 |= 1u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.sse3", &v3, &v2, 0, 0) && v3) {
      dword_1E9DC9F00 |= 2u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.supplementalsse3", &v3, &v2, 0, 0) && v3) {
      dword_1E9DC9F00 |= 2u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.sse4_1", &v3, &v2, 0, 0) && v3) {
      dword_1E9DC9F00 |= 8u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.sse4_2", &v3, &v2, 0, 0) && v3) {
      dword_1E9DC9F00 |= 0x10u;
    }
    int v3 = 0;
    size_t v2 = 4;
    if (!sysctlbyname("hw.optional.avx1_0", &v3, &v2, 0, 0) && v3) {
      dword_1E9DC9F00 |= 0x20u;
    }
    int v3 = 0;
    size_t v2 = 4;
    int v1 = sysctlbyname("hw.optional.fma", &v3, &v2, 0, 0);
    uint64_t result = dword_1E9DC9F00;
    if (!v1)
    {
      if (v3)
      {
        uint64_t result = dword_1E9DC9F00 | 0x40u;
        dword_1E9DC9F00 |= 0x40u;
      }
    }
  }
  return result;
}

uint64_t sub_1B63CBCB0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 217);
}

uint64_t sub_1B63CBCB8(uint64_t a1, int a2)
{
  uint64_t result = 0;
  uint64_t v4 = *(void *)(a1 + 208) + *(void *)(a1 + 200);
  uint64_t v5 = *(void *)(a1 + 8) + *(void *)a1;
  *(unsigned char *)(a1 + 217) = 0;
  if (v4 >= v5) {
    return result;
  }
  uint64_t v7 = a1 + 16;
  while (1)
  {
    uint64_t v8 = v4 - *(void *)a1;
    if (v8 < 0 || (uint64_t v9 = *(void *)(a1 + 176), v9 <= v8))
    {
      UniChar v11 = 0;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 152);
      if (v10)
      {
        UniChar v11 = *(_WORD *)(v10 + 2 * (*(void *)(a1 + 168) + v8));
      }
      else
      {
        uint64_t v22 = *(void *)(a1 + 160);
        if (v22)
        {
          UniChar v11 = *(char *)(v22 + *(void *)(a1 + 168) + v8);
        }
        else
        {
          if (*(void *)(a1 + 192) <= v8 || (uint64_t v23 = *(void *)(a1 + 184), v23 > v8))
          {
            uint64_t v24 = v8 - 4;
            if ((unint64_t)v8 < 4) {
              uint64_t v24 = 0;
            }
            if (v24 + 64 < v9) {
              uint64_t v9 = v24 + 64;
            }
            *(void *)(a1 + 184) = v24;
            *(void *)(a1 + 192) = v9;
            v40.location = *(void *)(a1 + 168) + v24;
            v40.length = v9 - v24;
            CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v40, (UniChar *)(a1 + 16));
            uint64_t v23 = *(void *)(a1 + 184);
          }
          UniChar v11 = *(_WORD *)(v7 + 2 * (v8 - v23));
        }
      }
    }
    ++v4;
    if (CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), v11))
    {
      uint64_t v12 = v4;
      do
      {
        uint64_t v4 = v12;
        uint64_t v13 = v12 - *(void *)a1;
        if (v13 < 0 || (uint64_t v14 = *(void *)(a1 + 176), v14 <= v13))
        {
          UniChar v16 = 0;
        }
        else
        {
          uint64_t v15 = *(void *)(a1 + 152);
          if (v15)
          {
            UniChar v16 = *(_WORD *)(v15 + 2 * (*(void *)(a1 + 168) + v13));
          }
          else
          {
            uint64_t v17 = *(void *)(a1 + 160);
            if (v17)
            {
              UniChar v16 = *(char *)(v17 + *(void *)(a1 + 168) + v13);
            }
            else
            {
              if (*(void *)(a1 + 192) <= v13 || (uint64_t v18 = *(void *)(a1 + 184), v18 > v13))
              {
                uint64_t v19 = v13 - 4;
                if ((unint64_t)v13 < 4) {
                  uint64_t v19 = 0;
                }
                if (v19 + 64 < v14) {
                  uint64_t v14 = v19 + 64;
                }
                *(void *)(a1 + 184) = v19;
                *(void *)(a1 + 192) = v14;
                v39.location = *(void *)(a1 + 168) + v19;
                v39.length = v14 - v19;
                CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v39, (UniChar *)(a1 + 16));
                uint64_t v18 = *(void *)(a1 + 184);
              }
              UniChar v16 = *(_WORD *)(v7 + 2 * (v13 - v18));
            }
          }
        }
        uint64_t v12 = v4 + 1;
      }
      while (CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), v16));
      uint64_t v20 = *(void *)(a1 + 200) + *(void *)(a1 + 208);
      *(void *)(a1 + 200) = v20;
      *(void *)(a1 + 208) = v4 - v20;
      if (*(unsigned char *)(a1 + 216))
      {
        uint64_t result = 1;
        *(unsigned char *)(a1 + 217) = 1;
        return result;
      }
      goto LABEL_32;
    }
    if (v11 == 95 || CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 232), v11)) {
      break;
    }
    uint64_t v21 = *(void *)(a1 + 200) + *(void *)(a1 + 208);
    *(void *)(a1 + 200) = v21;
    *(void *)(a1 + 208) = v4 - v21;
    if (*(unsigned char *)(a1 + 216)) {
      return 1;
    }
LABEL_32:
    if (v4 >= v5) {
      return 0;
    }
  }
  char v25 = 0;
  uint64_t v26 = v4;
  do
  {
LABEL_45:
    uint64_t v27 = v26;
    while (1)
    {
      uint64_t v26 = v27;
      uint64_t v28 = v4++;
      uint64_t v29 = v28 - *(void *)a1;
      if (v29 < 0 || (uint64_t v30 = *(void *)(a1 + 176), v30 <= v29))
      {
        UniChar v32 = 0;
      }
      else
      {
        uint64_t v31 = *(void *)(a1 + 152);
        if (v31)
        {
          UniChar v32 = *(_WORD *)(v31 + 2 * (*(void *)(a1 + 168) + v29));
        }
        else
        {
          uint64_t v35 = *(void *)(a1 + 160);
          if (v35)
          {
            UniChar v32 = *(char *)(v35 + *(void *)(a1 + 168) + v29);
          }
          else
          {
            if (*(void *)(a1 + 192) <= v29 || (uint64_t v36 = *(void *)(a1 + 184), v36 > v29))
            {
              uint64_t v37 = v29 - 4;
              if ((unint64_t)v29 < 4) {
                uint64_t v37 = 0;
              }
              if (v37 + 64 < v30) {
                uint64_t v30 = v37 + 64;
              }
              *(void *)(a1 + 184) = v37;
              *(void *)(a1 + 192) = v30;
              v41.location = *(void *)(a1 + 168) + v37;
              v41.length = v30 - v37;
              CFStringGetCharacters(*(CFStringRef *)(a1 + 144), v41, (UniChar *)(a1 + 16));
              uint64_t v36 = *(void *)(a1 + 184);
            }
            UniChar v32 = *(_WORD *)(v7 + 2 * (v29 - v36));
          }
        }
        if (v32 == 95)
        {
          CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), 0x5Fu);
          goto LABEL_52;
        }
      }
      int IsCharacterMember = CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 232), v32);
      int v34 = CFCharacterSetIsCharacterMember(*(CFCharacterSetRef *)(a1 + 224), v32);
      if (!IsCharacterMember) {
        break;
      }
LABEL_52:
      uint64_t v27 = v4;
      if (v25) {
        goto LABEL_70;
      }
    }
    if (!a2) {
      break;
    }
    char v25 = 1;
    if (v32 == 42)
    {
      uint64_t v26 = v4;
      goto LABEL_45;
    }
  }
  while (v34);
LABEL_70:
  uint64_t v38 = *(void *)(a1 + 200) + *(void *)(a1 + 208);
  *(void *)(a1 + 200) = v38;
  *(void *)(a1 + 208) = v26 - v38;
  return 1;
}

CFURLRef sub_1B63CC040(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  PathComponent = objc_msgSend_lastPathComponent(a1, a2, a3, a4);
  if (objc_msgSend_isEqualToString_(a1, v6, (uint64_t)PathComponent, v7)) {
    CFStringRef v11 = 0;
  }
  else {
    CFStringRef v11 = (const __CFString *)objc_msgSend_stringByDeletingLastPathComponent(a1, v8, v9, v10);
  }
  CFStringRef v12 = (const __CFString *)objc_msgSend_pathExtension(a1, v8, v9, v10);
  CFStringRef v16 = (const __CFString *)objc_msgSend_stringByDeletingPathExtension(PathComponent, v13, v14, v15);
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.vfx");
  CFURLRef v18 = CFBundleCopyResourceURL(BundleWithIdentifier, v16, v12, 0);
  if (!v18)
  {
    MainBundle = CFBundleGetMainBundle();
    CFURLRef v18 = CFBundleCopyResourceURL(MainBundle, v16, v12, v11);
  }

  return v18;
}

CFURLRef sub_1B63CC0F4(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  CFURLRef v4 = sub_1B63CC040(a1, a2, a3, a4);
  CFURLRef v5 = v4;
  if (v4) {
    CFRetain(v4);
  }
  return v5;
}

uint64_t sub_1B63CC128(const __CFURL *a1)
{
  MainBundle = CFBundleGetMainBundle();
  uint64_t v3 = 0;
  if (!a1) {
    return v3;
  }
  CFURLRef v4 = MainBundle;
  if (!MainBundle) {
    return v3;
  }
  *(void *)packageCreator = 0;
  CFBundleGetPackageInfo(MainBundle, &packageCreator[1], packageCreator);
  uint64_t v3 = 0;
  if (packageCreator[1] != 1095782476) {
    return v3;
  }
  CFURLRef v5 = CFBundleCopyBundleURL(v4);
  if (!v5) {
    return 0;
  }
  CFURLRef v6 = v5;
  uint64_t v7 = (__CFString *)CFURLCopyPath(v5);
  uint64_t v8 = (__CFString *)CFURLCopyPath(a1);
  CFStringRef v12 = v8;
  if (v7 && v8)
  {
    CFStringRef v13 = (const __CFString *)objc_msgSend_stringByStandardizingPath(v8, v9, v10, v11);
    CFStringRef v17 = (const __CFString *)objc_msgSend_stringByStandardizingPath(v7, v14, v15, v16);
    CFRange v18 = CFStringFind(v13, v17, 1uLL);
    if (v18.location) {
      BOOL v19 = 1;
    }
    else {
      BOOL v19 = v18.length <= 0;
    }
    uint64_t v20 = !v19;
    goto LABEL_15;
  }
  uint64_t v20 = 0;
  uint64_t v3 = 0;
  if (v7)
  {
LABEL_15:
    CFRelease(v7);
    uint64_t v3 = v20;
  }
  if (v12) {
    CFRelease(v12);
  }
  CFRelease(v6);
  return v3;
}

uint64_t sub_1B63CC238(void *a1)
{
  size_t v2 = (void *)sub_1B6602C1C(a1);
  if (!v2
    || (uint64_t v6 = objc_msgSend_dataUsingEncoding_(v2, v3, 4, v5),
        uint64_t v17 = 0,
        (uint64_t result = objc_msgSend_propertyListWithData_options_format_error_(MEMORY[0x1E4F28F98], v7, v6, 0, &v17, 0)) == 0))
  {
    CFURLRef v9 = sub_1B63CC040(a1, v3, v4, v5);
    if (v9)
    {
      return objc_msgSend_dictionaryWithContentsOfURL_(MEMORY[0x1E4F1C9E8], v10, (uint64_t)v9, v12);
    }
    else
    {
      sub_1B63F2F54(16, @"Error: failed to load dictionary named %@", v11, v12, v13, v14, v15, v16, (uint64_t)a1);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1B63CC2D0(void *a1, char *a2, uint64_t a3, uint64_t a4)
{
  *(void *)a2 = objc_msgSend_length(a1, a2, a3, a4);

  return objc_msgSend_contents(a1, v5, v6, v7);
}

uint64_t sub_1B63CC310(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (objc_msgSend_storageMode(a1, a2, a3, a4) == 2)
  {
    if ((byte_1E9DDA5F2 & 1) == 0)
    {
      byte_1E9DDA5F2 = 1;
      sub_1B63F2F54(16, @"Warning: CFXDataFromMTLBuffer - can't read private MTL buffer", v6, v7, v8, v9, v10, v11, v20);
    }
    return 0;
  }
  else
  {
    uint64_t v13 = (void *)MEMORY[0x1E4F1C9B8];
    uint64_t v14 = objc_msgSend_contents(a1, v5, v6, v7);
    uint64_t v19 = objc_msgSend_length(a1, v15, v16, v17);
    return objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(v13, v18, v14, v19, 0);
  }
}

uint64_t sub_1B63CC3B8()
{
  if (qword_1E9DDA5F8 != -1) {
    dispatch_once(&qword_1E9DDA5F8, &unk_1F0FB5528);
  }
  return byte_1E9DDA5F3;
}

void sub_1B63CC440()
{
  id v6 = MTLCreateSystemDefaultDevice();
  byte_1E9DDA5F4 = v6 != 0;
  byte_1E9DDA5F3 |= objc_msgSend_supportsFeatureSet_(v6, v0, 1, v1);
  byte_1E9DDA5F3 |= objc_msgSend_supportsFeatureSet_(v6, v2, 3, v3);
  byte_1E9DDA5F3 |= objc_msgSend_supportsFeatureSet_(v6, v4, 4, v5);
}

uint64_t sub_1B63CC4D8()
{
  if (qword_1EB9956D0 != -1) {
    dispatch_once(&qword_1EB9956D0, &unk_1F0FB67C8);
  }
  return byte_1EB980FA8;
}

uint64_t sub_1B63CC51C()
{
  byte_1EB980FA8 = 0;
  byte_1EB980FA8 = sub_1B63F3214(6);
  if (byte_1EB980FA8)
  {
    byte_1EB980FA8 = 1;
  }
  else
  {
    char v2 = sub_1B63F3270(@"VFXEnableWideGamut", 0, v0, v1);
    uint64_t result = 0;
    byte_1EB980FA8 = v2;
    if ((v2 & 1) == 0) {
      goto LABEL_9;
    }
  }
  if (qword_1E9DDA5F8 != -1) {
    dispatch_once(&qword_1E9DDA5F8, &unk_1F0FB5528);
  }
  byte_1EB980FA8 = byte_1E9DDA5F4;
  if (byte_1E9DDA5F4) {
    uint64_t result = MGGetBoolAnswer();
  }
  else {
    uint64_t result = 0;
  }
LABEL_9:
  byte_1EB980FA8 = result;
  return result;
}

uint64_t sub_1B63CC5CC()
{
  if (qword_1EB9956C8 != -1) {
    dispatch_once(&qword_1EB9956C8, &unk_1F0FB6828);
  }
  return byte_1EB981021;
}

BOOL sub_1B63CC610()
{
  BOOL result = sub_1B63F3214(16);
  byte_1EB981021 = result;
  return result;
}

uint64_t sub_1B63CC634(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"length");
  }
  uint64_t v9 = sqrt((double)(a1 / 0xC));
  if (12 * (v9 * v9) != a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Spherical Harmonics Data seems malformed: order(%d) !=> length(%zu)", a3, a4, a5, a6, a7, a8, (uint64_t)"(order * order * sizePerCoeff) == length");
  }
  return v9;
}

uint64_t sub_1B63CC6D0()
{
  if (qword_1E9DDA608 != -1) {
    dispatch_once(&qword_1E9DDA608, &unk_1F0FB6868);
  }
  return byte_1E9DDA600;
}

uint64_t sub_1B63CC714(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_mainBundle(MEMORY[0x1E4F28B50], a2, a3, a4);
  uint64_t v8 = objc_msgSend_bundleIdentifier(v4, v5, v6, v7);
  uint64_t result = objc_msgSend_hasPrefix_(v8, v9, @"com.apple.vfxstudio", v10);
  byte_1E9DDA600 = result;
  return result;
}

CFTypeRef sub_1B63CC74C(CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)qword_1E9DDA610;
  if ((CFTypeRef)qword_1E9DDA610 != cf)
  {
    if (qword_1E9DDA610)
    {
      CFRelease((CFTypeRef)qword_1E9DDA610);
      qword_1E9DDA610 = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    qword_1E9DDA610 = (uint64_t)result;
  }
  return result;
}

uint64_t sub_1B63CC7A0()
{
  return qword_1E9DDA610;
}

CFTypeRef _VFXSetShaderCacheURL_0(CFTypeRef cf)
{
  CFTypeRef result = (CFTypeRef)qword_1E9DDA618;
  if ((CFTypeRef)qword_1E9DDA618 != cf)
  {
    if (qword_1E9DDA618)
    {
      CFRelease((CFTypeRef)qword_1E9DDA618);
      qword_1E9DDA618 = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    qword_1E9DDA618 = (uint64_t)result;
  }
  return result;
}

uint64_t sub_1B63CC800()
{
  return qword_1E9DDA618;
}

CFStringRef sub_1B63CC80C(const __CFString *theString)
{
  if (theString) {
    return (const __CFString *)CFStringCreateArrayBySeparatingStrings(0, theString, @".");
  }
  return theString;
}

CFArrayRef sub_1B63CC828(const __CFArray *theArray)
{
  if (theArray) {
    return (const __CFArray *)CFStringCreateByCombiningStrings(0, theArray, @".");
  }
  return theArray;
}

__CFArray *sub_1B63CC844(CFArrayRef theArray)
{
  if (!theArray) {
    return 0;
  }
  MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, theArray);
  v4.length = CFArrayGetCount(theArray);
  v4.location = 0;
  CFArraySortValues(MutableCopy, v4, (CFComparatorFunction)sub_1B63CC8BC, 0);
  return MutableCopy;
}

CFComparisonResult sub_1B63CC8BC(const __CFString *a1, const __CFString *a2)
{
  return CFStringCompare(a1, a2, 0);
}

uint64_t sub_1B63CC8C4(void *a1, const char *a2, uint64_t a3)
{
  return objc_msgSend_subarrayWithRange_(a1, a2, (uint64_t)a2, a3);
}

CFArrayRef sub_1B63CC8D0(const __CFDictionary *a1)
{
  if (a1 && (CFIndex Count = CFDictionaryGetCount(a1)) != 0)
  {
    CFIndex v3 = Count;
    CFRange v4 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    CFDictionaryGetKeysAndValues(a1, v4, 0);
    CFArrayRef v5 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, v3, MEMORY[0x1E4F1D510]);
    free(v4);
    return v5;
  }
  else
  {
    CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v8 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    return CFArrayCreate(v7, 0, 0, v8);
  }
}

void sub_1B63CC9A0(const __CFSet *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t context = a2;
      CFSetApplyFunction(a1, (CFSetApplierFunction)sub_1B63CC9E4, &context);
    }
  }
}

uint64_t sub_1B63CC9E4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)a2 + 16))();
}

void sub_1B63CC9FC(const __CFArray *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      v3[0] = 0;
      v3[1] = a2;
      v4.length = CFArrayGetCount(a1);
      v4.location = 0;
      CFArrayApplyFunction(a1, v4, (CFArrayApplierFunction)sub_1B63CCA5C, v3);
    }
  }
}

uint64_t sub_1B63CCA5C(uint64_t a1, void *a2)
{
  uint64_t v2 = a2[1];
  ++*a2;
  return (*(uint64_t (**)(void))(v2 + 16))();
}

void sub_1B63CCA7C(const __CFDictionary *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t context = a2;
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_1B63CCAC0, &context);
    }
  }
}

uint64_t sub_1B63CCAC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void))(*(void *)a3 + 16))();
}

void sub_1B63CCADC(const __CFDictionary *a1, uint64_t a2)
{
  if (a1)
  {
    if (a2)
    {
      CFArrayRef v4 = sub_1B63CC8D0(a1);
      CFArrayRef v5 = sub_1B63CC844(v4);
      CFRelease(v4);
      v6[0] = MEMORY[0x1E4F143A8];
      v6[1] = 3221225472;
      _OWORD v6[2] = sub_1B63CCB90;
      v6[3] = &unk_1E6140EB0;
      v6[4] = a2;
      v6[5] = a1;
      sub_1B63CC9FC(v5, (uint64_t)v6);
      CFRelease(v5);
    }
  }
}

uint64_t sub_1B63CCB90(uint64_t a1, int a2, void *key)
{
  CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), key);
  CFArrayRef v4 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v4();
}

void sub_1B63CCBEC(uint64_t a1)
{
  CFSetRef v1 = *(const __CFSet **)(a1 + 88);
  if (v1) {
    CFSetApplyFunction(v1, (CFSetApplierFunction)sub_1B63CCBE8, 0);
  }
}

id sub_1B63CCC14(void *a1)
{
  sub_1B6595A0C(@"kCFXNotificationGeometryWillDie", a1, 0, 1u);
  sub_1B647F1D4(a1);
  CFSetRef v9 = (const __CFSet *)a1[11];
  if (v9)
  {
    if (CFSetGetCount(v9)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. No node should be tracked anymore by the geometry %@", v3, v4, v5, v6, v7, v8, (uint64_t)"!geometry->_trackedNodes || !CFSetGetCount(geometry->_trackedNodes)");
    }
    uint64_t v10 = (const void *)a1[11];
    if (v10)
    {
      CFRelease(v10);
      a1[11] = 0;
    }
  }
  uint64_t v11 = (const void *)a1[10];
  if (v11)
  {
    CFRelease(v11);
    a1[10] = 0;
  }
  uint64_t v12 = (const void *)a1[9];
  if (v12)
  {
    CFRelease(v12);
    a1[9] = 0;
  }
  uint64_t v13 = (const void *)a1[8];
  if (v13)
  {
    CFRelease(v13);
    a1[8] = 0;
  }
  uint64_t v14 = (const void *)a1[12];
  if (v14)
  {
    CFRelease(v14);
    a1[12] = 0;
  }
  uint64_t v15 = (void *)a1[13];
  if (v15) {
    free(v15);
  }
  a1[13] = 0;

  return sub_1B658325C((uint64_t)a1, v2, v3, v4, v5, v6, v7, v8);
}

__CFString *sub_1B63CCD00(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  CFStringRef v3 = CFCopyTypeIDDescription(v2);
  CFMutableSetRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  uint64_t v12 = sub_1B63CCE0C((uint64_t)a1, v5, v6, v7, v8, v9, v10, v11);
  CFStringAppendFormat(Mutable, 0, @"<%@:%p \"%@\"\n", v3, a1, v12);
  uint64_t v20 = sub_1B63CCE68((uint64_t)a1, v13, v14, v15, v16, v17, v18, v19);
  CFStringAppendFormat(Mutable, 0, @"  mesh: %@\n", v20);
  if ((uint64_t)sub_1B63CCEC4((uint64_t)a1, v21, v22, v23, v24, v25, v26, v27) >= 1)
  {
    uint64_t v34 = 0;
    do
    {
      CFArrayRef v35 = sub_1B63CCF34((uint64_t)a1, v34, v28, v29, v30, v31, v32, v33);
      CFStringAppendFormat(Mutable, 0, @"  mat%d: %@\n", v34++, v35);
    }
    while (v34 < (uint64_t)sub_1B63CCEC4((uint64_t)a1, v36, v37, v38, v39, v40, v41, v42));
  }
  CFStringAppend(Mutable, @">");
  CFRelease(v3);
  return Mutable;
}

uint64_t sub_1B63CCE0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }

  return sub_1B6583470(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B63CCE68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  uint64_t v9 = *(void (**)(uint64_t))(a1 + 120);
  if (v9) {
    v9(a1);
  }
  return *(void *)(a1 + 64);
}

CFArrayRef sub_1B63CCEC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  CFArrayRef result = *(const __CFArray **)(a1 + 80);
  if (result)
  {
    return (const __CFArray *)CFArrayGetCount(result);
  }
  return result;
}

CFArrayRef sub_1B63CCF34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  CFArrayRef result = sub_1B63CCEC4(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    CFIndex v11 = a2 % (uint64_t)result;
    CFArrayRef v12 = *(const __CFArray **)(a1 + 80);
    return (const __CFArray *)CFArrayGetValueAtIndex(v12, v11);
  }
  return result;
}

uint64_t sub_1B63CCFB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 72);
  if (v9) {
    uint64_t v10 = sub_1B64AFA68(v9, a2, a3, a4, a5, a6, a7, a8) != 0;
  }
  else {
    uint64_t v10 = 0;
  }
  CFArrayRef v11 = sub_1B63CCEC4(a1, a2, a3, a4, a5, a6, a7, a8);
  if ((uint64_t)v11 >= 1 && (v10 & 1) == 0)
  {
    CFArrayRef v18 = v11;
    uint64_t v19 = 1;
    do
    {
      CFArrayRef v20 = sub_1B63CCF34(a1, v19 - 1, v12, v13, v14, v15, v16, v17);
      uint64_t v28 = sub_1B64AFA68((uint64_t)v20, v21, v22, v23, v24, v25, v26, v27);
      uint64_t v10 = v28 != 0;
      uint64_t v36 = sub_1B64AF43C((uint64_t)v20, v29, v30, v31, v32, v33, v34, v35);
      if (v36)
      {
        uint64_t v37 = sub_1B6475290(v36, 16, 0, v13, v14, v15, v16, v17);
        if (v37)
        {
          uint64_t v39 = v37;
          BOOL v41 = sub_1B6475F88(v37, v38, v12, v13, v14, v15, v16, v17)
             && sub_1B64763AC(v39, v40, v12, v13, v14, v15, v16, v17) != 0.0;
          if (v28) {
            uint64_t v10 = 1;
          }
          else {
            uint64_t v10 = v41;
          }
        }
      }
      if (v19 >= (uint64_t)v18) {
        break;
      }
      ++v19;
    }
    while ((v10 & 1) == 0);
  }
  return v10;
}

uint64_t sub_1B63CD09C(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

void sub_1B63CD0A4(uint64_t a1, _OWORD *a2)
{
  CFStringRef v3 = *(_OWORD **)(a1 + 104);
  if (a2)
  {
    if (!v3)
    {
      CFStringRef v3 = malloc_type_malloc(0x20uLL, 0x1000040E0EAB150uLL);
      *(void *)(a1 + 104) = v3;
    }
    long long v5 = a2[1];
    *CFStringRef v3 = *a2;
    v3[1] = v5;
  }
  else
  {
    if (!v3) {
      return;
    }
    free(v3);
    *(void *)(a1 + 104) = 0;
  }
  CFSetRef v6 = *(const __CFSet **)(a1 + 88);
  if (v6)
  {
    CFSetApplyFunction(v6, (CFSetApplierFunction)sub_1B63CCBE8, 0);
  }
}

__CFArray *sub_1B63CD140(uint64_t a1)
{
  CFMutableSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFStringRef v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  long long v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v38 = 1;
  int valuePtr = 5;
  uint64_t v37 = sub_1B63CCE0C(a1, v6, v7, v8, v9, v10, v11, v12);
  CFNumberRef v13 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v14 = CFNumberCreate(0, kCFNumberSInt32Type, &v38);
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberLongType, &v37);
  CFDictionarySetValue(v5, @"name", @"name");
  CFDictionarySetValue(v5, @"type", v13);
  CFDictionarySetValue(v5, @"address", v15);
  CFDictionarySetValue(v5, @"semantic", v14);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v14);
  CFRelease(v5);
  CFRelease(v15);
  CFRelease(v13);
  uint64_t v16 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v38 = 2;
  int valuePtr = 5;
  uint64_t v37 = a1 + 64;
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v18 = CFNumberCreate(0, kCFNumberSInt32Type, &v38);
  CFNumberRef v19 = CFNumberCreate(0, kCFNumberLongType, &v37);
  CFDictionarySetValue(v16, @"name", @"mesh");
  CFDictionarySetValue(v16, @"type", v17);
  CFDictionarySetValue(v16, @"address", v19);
  CFDictionarySetValue(v16, @"semantic", v18);
  CFArrayAppendValue(Mutable, v16);
  CFRelease(v18);
  CFRelease(v16);
  CFRelease(v19);
  CFRelease(v17);
  CFArrayRef v20 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v38 = 2;
  int valuePtr = 5;
  uint64_t v37 = a1 + 72;
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberSInt32Type, &v38);
  CFNumberRef v23 = CFNumberCreate(0, kCFNumberLongType, &v37);
  CFDictionarySetValue(v20, @"name", @"overrideMaterial");
  CFDictionarySetValue(v20, @"type", v21);
  CFDictionarySetValue(v20, @"address", v23);
  CFDictionarySetValue(v20, @"semantic", v22);
  CFArrayAppendValue(Mutable, v20);
  CFRelease(v22);
  CFRelease(v20);
  CFRelease(v23);
  CFRelease(v21);
  uint64_t v24 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v38 = 2;
  int valuePtr = 5;
  uint64_t v37 = a1 + 80;
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberSInt32Type, &v38);
  CFNumberRef v27 = CFNumberCreate(0, kCFNumberLongType, &v37);
  CFDictionarySetValue(v24, @"name", @"materials");
  CFDictionarySetValue(v24, @"type", v25);
  CFDictionarySetValue(v24, @"address", v27);
  CFDictionarySetValue(v24, @"semantic", v26);
  CFArrayAppendValue(Mutable, v24);
  CFRelease(v26);
  CFRelease(v24);
  CFRelease(v27);
  CFRelease(v25);
  uint64_t v28 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v38 = 2;
  int valuePtr = 5;
  uint64_t v37 = a1 + 96;
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberSInt32Type, &v38);
  CFNumberRef v31 = CFNumberCreate(0, kCFNumberLongType, &v37);
  CFDictionarySetValue(v28, @"name", @"levelsOfDetail");
  CFDictionarySetValue(v28, @"type", v29);
  CFDictionarySetValue(v28, @"address", v31);
  CFDictionarySetValue(v28, @"semantic", v30);
  CFArrayAppendValue(Mutable, v28);
  CFRelease(v30);
  CFRelease(v28);
  CFRelease(v31);
  CFRelease(v29);
  uint64_t v32 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v38 = 0;
  int valuePtr = 5;
  uint64_t v37 = a1 + 48;
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberSInt32Type, &v38);
  CFNumberRef v35 = CFNumberCreate(0, kCFNumberLongType, &v37);
  CFDictionarySetValue(v32, @"name", @"worldRef");
  CFDictionarySetValue(v32, @"type", v33);
  CFDictionarySetValue(v32, @"address", v35);
  CFDictionarySetValue(v32, @"semantic", v34);
  CFArrayAppendValue(Mutable, v32);
  CFRelease(v34);
  CFRelease(v32);
  CFRelease(v35);
  CFRelease(v33);
  return Mutable;
}

uint64_t sub_1B63CD714(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *((void *)cf + 8);
  if (v10) {
    (*(void (**)(uint64_t))(a2 + 16))(a2);
  }
  CFArrayRef v11 = (const __CFArray *)*((void *)cf + 10);
  if (v11)
  {
    CFIndex Count = CFArrayGetCount(*((CFArrayRef *)cf + 10));
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      for (CFIndex i = 0; i != v13; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v11, i);
        (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, ValueAtIndex);
      }
    }
  }
  CFArrayRef v16 = (const __CFArray *)*((void *)cf + 12);
  if (v16)
  {
    CFIndex v17 = CFArrayGetCount(v16);
    if (v17 >= 1)
    {
      CFIndex v18 = v17;
      for (CFIndex j = 0; j != v18; ++j)
      {
        CFArrayRef v20 = CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 12), j);
        (*(void (**)(uint64_t, const void *))(a2 + 16))(a2, v20);
      }
    }
  }
  uint64_t result = sub_1B63F4808(cf, v10, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    CFNumberRef v22 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 16);
    return v22(a2, result);
  }
  return result;
}

CFDictionaryRef sub_1B63CD838(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }

  return sub_1B6583734(a1, @"kBehaviorGraph", a3, a4, a5, a6, a7, a8);
}

void sub_1B63CD8A4(CFTypeRef *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  uint64_t v10 = sub_1B63F4F54(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  CFDictionaryRef v18 = sub_1B63CD838((uint64_t)a1, v11, v12, v13, v14, v15, v16, v17);
  if (v10 && v18) {
    sub_1B63F4AAC(v18, v10, v19, v20, v21, v22, v23, v24);
  }
  sub_1B65837D4(a1, @"kBehaviorGraph", a2, v10 != 0, v21, v22, v23, v24);
  if (a2 && v10)
  {
    sub_1B63F4CCC((uint64_t *)a2, v10, v25, v26, v27, v28, v29, v30);
  }
}

uint64_t sub_1B63CD970()
{
  if (qword_1EB9954B8 != -1) {
    dispatch_once(&qword_1EB9954B8, &unk_1F0FB5548);
  }
  return qword_1EB9954C0;
}

double sub_1B63CD9B4()
{
  if (!qword_1EB9954C0)
  {
    uint64_t v0 = (void *)sub_1B63C8D10(&qword_1EB9954C0);
    qword_1EB9954C0 = (uint64_t)v0;
    CFSetRef v1 = (const void *)sub_1B65833C8();
    sub_1B660E380(v0, v1);
    sub_1B660E3EC();
    *(_OWORD *)algn_1EB983FD0 = xmmword_1F0FB8898;
    *(_OWORD *)&algn_1EB983FD0[16] = xmmword_1F0FB88A8;
    qword_1EB983FC8 = (uint64_t)sub_1B63CD140;
    *(_OWORD *)&algn_1EB983FD0[32] = unk_1F0FB88B8;
    qword_1EB984000 = (uint64_t)off_1F0FB88C8;
    unk_1EB984008 = sub_1B63CF304;
    qword_1EB984010 = (uint64_t)sub_1B63CF3B0;
    double result = *(double *)&xmmword_1F0FB8888;
    unk_1EB984020 = xmmword_1F0FB8888;
  }
  return result;
}

double sub_1B63CDA84(uint64_t a1)
{
  *(void *)(a1 + 80) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 200) = 0;

  return sub_1B647F1B0(a1);
}

uint64_t sub_1B63CDB74(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"input");
  }

  return sub_1B63F46C0(cf, a2, a3, a4, a5, a6, a7, a8);
}

void sub_1B63CDBD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (uint64_t *)a2;
  if (*(void *)(a1 + 64) == a2)
  {
    if (a2 || !*(void *)(a1 + 120)) {
      return;
    }
    uint64_t v16 = sub_1B63F4F08(a1, 0, a3, a4, a5, a6, a7, a8);
    goto LABEL_8;
  }
  uint64_t v16 = sub_1B63F4F08(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v16)
  {
LABEL_8:
    int v18 = 0;
    goto LABEL_9;
  }
  uint64_t v17 = *(void **)(a1 + 64);
  if (!v17)
  {
    if (!v8) {
      goto LABEL_20;
    }
    LOBYTE(v18) = 1;
    goto LABEL_13;
  }
  sub_1B63F4AAC(v17, v16, v10, v11, v12, v13, v14, v15);
  int v18 = 1;
LABEL_9:
  uint64_t v19 = *(uint64_t **)(a1 + 64);
  if (v19 != v8)
  {
    if (v19)
    {
      CFRelease(v19);
      *(void *)(a1 + 64) = 0;
    }
    if (!v8)
    {
LABEL_14:
      *(void *)(a1 + 64) = v8;
      if ((v18 & 1) == 0) {
        goto LABEL_22;
      }
LABEL_20:
      if (v8) {
        sub_1B63F4CCC(v8, v16, v10, v11, v12, v13, v14, v15);
      }
      goto LABEL_22;
    }
LABEL_13:
    uint64_t v8 = (uint64_t *)CFRetain(v8);
    goto LABEL_14;
  }
  if (v18) {
    goto LABEL_20;
  }
LABEL_22:
  *(unsigned char *)(a1 + 200) = 0;
  CFSetRef v20 = *(const __CFSet **)(a1 + 88);
  if (v20)
  {
    CFSetApplyFunction(v20, (CFSetApplierFunction)sub_1B63CCBE8, 0);
  }
}

void sub_1B63CDCE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_17:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dst");
    if (a1) {
      goto LABEL_4;
    }
    goto LABEL_18;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"src");
  if (!a2) {
    goto LABEL_17;
  }
LABEL_3:
  if (a1) {
    goto LABEL_4;
  }
LABEL_18:
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
LABEL_4:
  sub_1B63CDBD0(a2, *(void *)(a1 + 64), a3, a4, a5, a6, a7, a8);
  CFArrayRef v16 = *(const __CFArray **)(a1 + 80);
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"geometry");
  }
  CFArrayRef v17 = *(const __CFArray **)(a2 + 80);
  if (v17 != v16)
  {
    if (v17)
    {
      CFRelease(v17);
      *(void *)(a2 + 80) = 0;
    }
    if (v16) {
      *(void *)(a2 + 80) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v16);
    }
  }
  sub_1B63CDEBC(a2, *(void *)(a1 + 96), v10, v11, v12, v13, v14, v15);
  CFStringRef v25 = (const __CFString *)sub_1B63CCE0C(a1, v18, v19, v20, v21, v22, v23, v24);
  if (v25) {
    sub_1B63CE124(a2, v25, v26, v27, v28, v29, v30, v31);
  }
  *(void *)(a2 + 120) = *(void *)(a1 + 120);
  if (*(void *)(a1 + 104))
  {
    uint64_t v32 = sub_1B63CA51C(0x20uLL);
    *(void *)(a2 + 104) = v32;
    CFNumberRef v33 = *(_OWORD **)(a1 + 104);
    long long v34 = v33[1];
    *uint64_t v32 = *v33;
    v32[1] = v34;
  }
  sub_1B6583A28(a1, (CFTypeRef *)a2, v26, v27, v28, v29, v30, v31);
  sub_1B647F230(a1, a2);
  long long v41 = *(_OWORD *)(a1 + 176);
  uint64_t v42 = *(void *)(a1 + 192);
  sub_1B63CE188((__n128 *)a2, (unsigned __int8 *)&v41, v35, v36, v37, v38, v39, v40);
}

uint64_t sub_1B63CDE70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  return *(void *)(a1 + 64);
}

void sub_1B63CDEBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v8 = (const __CFArray *)a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  uint64_t v10 = sub_1B63F4F08(a1, a2, a3, a4, a5, a6, a7, a8);
  CFArrayRef v11 = *(const __CFArray **)(a1 + 96);
  if (v11)
  {
    if (*(void *)(a1 + 88))
    {
      CFIndex Count = CFArrayGetCount(v11);
      if (Count >= 1)
      {
        CFIndex v13 = Count;
        for (CFIndex i = 0; i != v13; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
          uint64_t v23 = (void *)sub_1B647B264((uint64_t)ValueAtIndex, v16, v17, v18, v19, v20, v21, v22);
          if (v23) {
            CFSetApplyFunction(*(CFSetRef *)(a1 + 88), (CFSetApplierFunction)sub_1B63CE9F8, v23);
          }
        }
      }
    }
  }
  CFArrayRef v24 = *(const __CFArray **)(a1 + 96);
  if (v24 && v10)
  {
    CFIndex v25 = CFArrayGetCount(v24);
    if (v25 >= 1)
    {
      CFIndex v26 = v25;
      for (CFIndex j = 0; j != v26; ++j)
      {
        uint64_t v28 = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), j);
        sub_1B63F4AAC(v28, v10, v29, v30, v31, v32, v33, v34);
      }
    }
    CFArrayRef v24 = *(const __CFArray **)(a1 + 96);
  }
  if (v24 != v8)
  {
    if (v24)
    {
      CFRelease(v24);
      *(void *)(a1 + 96) = 0;
    }
    if (v8) {
      CFArrayRef v8 = (const __CFArray *)CFRetain(v8);
    }
    *(void *)(a1 + 96) = v8;
  }
  if (v8 && v10)
  {
    CFIndex v35 = CFArrayGetCount(v8);
    if (v35 >= 1)
    {
      CFIndex v36 = v35;
      for (CFIndex k = 0; k != v36; ++k)
      {
        uint64_t v38 = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), k);
        sub_1B63F4CCC(v38, v10, v39, v40, v41, v42, v43, v44);
      }
    }
    CFArrayRef v8 = *(const __CFArray **)(a1 + 96);
  }
  if (v8)
  {
    if (*(void *)(a1 + 88))
    {
      CFIndex v45 = CFArrayGetCount(v8);
      if (v45 >= 1)
      {
        CFIndex v46 = v45;
        for (CFIndex m = 0; m != v46; ++m)
        {
          uint64_t v48 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), m);
          uint64_t v56 = (void *)sub_1B647B264((uint64_t)v48, v49, v50, v51, v52, v53, v54, v55);
          if (v56) {
            CFSetApplyFunction(*(CFSetRef *)(a1 + 88), (CFSetApplierFunction)sub_1B63CEA08, v56);
          }
        }
      }
    }
  }
  CFSetRef v57 = *(const __CFSet **)(a1 + 88);
  if (v57)
  {
    CFSetApplyFunction(v57, (CFSetApplierFunction)sub_1B63CEA18, 0);
  }
}

uint64_t sub_1B63CE0D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  return *(void *)(a1 + 96);
}

CFStringRef sub_1B63CE124(uint64_t a1, CFStringRef theString, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }

  return sub_1B65834BC(a1, theString, a3, a4, a5, a6, a7, a8);
}

void sub_1B63CE188(__n128 *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  uint64_t v10 = a1[11].n128_u8[0];
  int v11 = a1[11].n128_u8[12];
  __n128 v12 = *(__n128 *)a2;
  a1[12].n128_u64[0] = *((void *)a2 + 2);
  a1[11] = v12;
  if (v11 != a2[12])
  {
    uint64_t v13 = sub_1B63F4F54(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    sub_1B64B1F18(v13, 6, a1, 0, v14, v15, v16, v17);
  }
  uint64_t v18 = *a2;
  uint64_t v19 = a1[8].n128_u8[0];

  sub_1B647F448(a1, v10, v18, v19, v19, a6, a7, a8);
}

CFTypeRef sub_1B63CE23C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B647F390(a1, a2, a3, a4, a5, a6, a7, a8))
  {
    return sub_1B653976C(a1);
  }
  else
  {
    return (CFTypeRef)sub_1B63CCE68(a1, v9, v10, v11, v12, v13, v14, v15);
  }
}

void sub_1B63CE298(uint64_t a1, void *value, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (value) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
    if (value) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"material");
LABEL_3:
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 80), value);
  uint64_t v17 = sub_1B63F4F08(a1, v10, v11, v12, v13, v14, v15, v16);
  sub_1B63F4CCC((uint64_t *)value, v17, v18, v19, v20, v21, v22, v23);

  sub_1B63CE340((void *)a1);
}

void sub_1B63CE340(void *cf)
{
  CFSetRef v2 = (const __CFSet *)cf[11];
  if (v2) {
    CFSetApplyFunction(v2, (CFSetApplierFunction)sub_1B63CCBE8, 0);
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 == sub_1B6559034())
  {
    sub_1B6558D10((uint64_t)cf, v4, v5, v6, v7, v8, v9, v10);
  }
}

uint64_t sub_1B63CE3B8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 120) = a2;
  return result;
}

void sub_1B63CE3C0(uint64_t a1, CFIndex a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  if (sub_1B63F4F08(a1, a2, a3, a4, a5, a6, a7, a8))
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), a2);
    uint64_t v18 = sub_1B63F4F08(a1, v11, v12, v13, v14, v15, v16, v17);
    sub_1B63F4AAC(ValueAtIndex, v18, v19, v20, v21, v22, v23, v24);
  }
  CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), a2);

  sub_1B63CE340((void *)a1);
}

void sub_1B63CE464(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  if (sub_1B63F4F08(a1, a2, a3, a4, a5, a6, a7, a8))
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >= 1)
    {
      CFIndex v10 = Count;
      for (CFIndex i = 0; i != v10; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), i);
        uint64_t v20 = sub_1B63F4F08(a1, v13, v14, v15, v16, v17, v18, v19);
        sub_1B63F4AAC(ValueAtIndex, v20, v21, v22, v23, v24, v25, v26);
      }
    }
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 80));

  sub_1B63CE340((void *)a1);
}

void sub_1B63CE524(uint64_t a1, void *value, CFIndex idx, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", idx, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  CFArrayInsertValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), idx, value);
  uint64_t v18 = sub_1B63F4F08(a1, v11, v12, v13, v14, v15, v16, v17);
  sub_1B63F4CCC((uint64_t *)value, v18, v19, v20, v21, v22, v23, v24);

  sub_1B63CE340((void *)a1);
}

void sub_1B63CE5B4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  newValues = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  if (sub_1B63F4F08(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8))
  {
    ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), a3);
    uint64_t v18 = sub_1B63F4F08(a1, v11, v12, v13, v14, v15, v16, v17);
    sub_1B63F4AAC(ValueAtIndex, v18, v19, v20, v21, v22, v23, v24);
  }
  v41.location = a3;
  v41.length = 1;
  CFArrayReplaceValues(*(CFMutableArrayRef *)(a1 + 80), v41, (const void **)&newValues, 1);
  uint64_t v25 = (uint64_t *)newValues;
  uint64_t v33 = sub_1B63F4F08(a1, v26, v27, v28, v29, v30, v31, v32);
  sub_1B63F4CCC(v25, v33, v34, v35, v36, v37, v38, v39);
  sub_1B63CE340((void *)a1);
}

CFIndex sub_1B63CE674(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
LABEL_3:
  CFSetRef Mutable = *(const __CFSet **)(a1 + 88);
  if (!Mutable)
  {
    CFSetRef Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
    *(void *)(a1 + 88) = Mutable;
  }
  if (CFSetContainsValue(Mutable, a2)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Node should not already been tracked by this geometry", v11, v12, v13, v14, v15, v16, (uint64_t)"!CFSetContainsValue(geometry->_trackedNodes, node)");
  }
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 88), a2);
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a1 + 112) & 0xFE | (CFSetGetCount(*(CFSetRef *)(a1 + 88)) > 4);
  CFIndex result = *(void *)(a1 + 96);
  if (result)
  {
    CFIndex result = CFArrayGetCount((CFArrayRef)result);
    if (result >= 1)
    {
      CFIndex v18 = result;
      for (CFIndex i = 0; i != v18; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
        CFIndex result = sub_1B647B264((uint64_t)ValueAtIndex, v21, v22, v23, v24, v25, v26, v27);
        if (result) {
          CFIndex result = sub_1B63CE674(result, a2);
        }
      }
    }
  }
  return result;
}

void sub_1B63CE7AC(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  if (!a2) {
LABEL_3:
  }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
LABEL_4:
  CFSetRef v10 = *(const __CFSet **)(a1 + 88);
  if (!v10 || !CFSetContainsValue(v10, a2)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Node should been tracked by this geometry", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry->_trackedNodes && CFSetContainsValue(geometry->_trackedNodes, node)");
  }
  CFArrayRef v11 = *(const __CFArray **)(a1 + 96);
  if (v11)
  {
    CFIndex Count = CFArrayGetCount(v11);
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      for (CFIndex i = 0; i != v13; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 96), i);
        uint64_t v23 = sub_1B647B264((uint64_t)ValueAtIndex, v16, v17, v18, v19, v20, v21, v22);
        if (v23) {
          sub_1B63CE7AC(v23, a2);
        }
      }
    }
  }
  uint64_t v24 = *(__CFSet **)(a1 + 88);
  if (v24
    || (sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry->_trackedNodes"), (uint64_t v24 = *(__CFSet **)(a1 + 88)) != 0))
  {
    CFSetRemoveValue(v24, a2);
  }
}

void sub_1B63CE8F0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v9 = sub_1B63CCEC4((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if ((uint64_t)v9 >= 1)
  {
    CFArrayRef v16 = v9;
    for (uint64_t i = 0; (const __CFArray *)i != v16; ++i)
    {
      CFArrayRef v18 = sub_1B63CCF34((uint64_t)a1, i, v10, v11, v12, v13, v14, v15);
      sub_1B64AFC88((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25);
    }
  }
  sub_1B63CE340(a1);

  sub_1B6595A0C(@"kCFXShadableDidChange", a1, 0, 1u);
}

void sub_1B63CE978(void *a1, void *cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (const void *)a1[9];
  if (v10 != cf)
  {
    if (v10)
    {
      CFRelease(v10);
      a1[9] = 0;
    }
    if (cf) {
      CFTypeRef v11 = CFRetain(cf);
    }
    else {
      CFTypeRef v11 = 0;
    }
    a1[9] = v11;
  }
  if (cf)
  {
    uint64_t v12 = sub_1B63F4F08((uint64_t)a1, (uint64_t)cf, a3, a4, a5, a6, a7, a8);
    sub_1B63F4CCC((uint64_t *)cf, v12, v13, v14, v15, v16, v17, v18);
  }

  sub_1B63CE8F0(a1, (uint64_t)cf, a3, a4, a5, a6, a7, a8);
}

void sub_1B63CE9F8(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

CFIndex sub_1B63CEA08(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B63CE674(a2, a1, a3, a4, a5, a6, a7, a8);
}

BOOL sub_1B63CEA1C(uint64_t a1)
{
  if (qword_1EB9954B8 != -1) {
    dispatch_once(&qword_1EB9954B8, &unk_1F0FB5548);
  }
  return qword_1EB9954C0 == a1
      || sub_1B651930C() == a1
      || sub_1B6559034() == a1
      || sub_1B662AA9C() == a1
      || sub_1B662ABD4() == a1;
}

void sub_1B63CEAAC(CFTypeRef cf, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = a6;
  uint64_t v10 = (_OWORD *)a5;
  CFTypeRef v11 = (_OWORD *)a4;
  uint64_t v114 = a2;
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  if (a6 != 2)
  {
    CFTypeID v13 = CFGetTypeID(cf);
    if (v13 == sub_1B6559034())
    {
      sub_1B6558A64((uint64_t)cf, v114, (uint64_t)a3, (uint64_t)v11, (uint64_t)v10, v9, a7, a8, a9);
      return;
    }
  }
  uint64_t v14 = sub_1B63CCE68((uint64_t)cf, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!v14) {
    return;
  }
  uint64_t v21 = v14;
  uint64_t v22 = sub_1B64ACF7C(v14, 1, v15, v16, v17, v18, v19, v20);
  if (!v22) {
    return;
  }
  uint64_t v30 = (uint64_t)v22;
  uint64_t v31 = sub_1B641D8A0((uint64_t)v22, v23, v24, v25, v26, v27, v28, v29);
  if (!v31) {
    return;
  }
  uint64_t v38 = v31;
  uint64_t v39 = sub_1B64AD1C4(v21, 1, v32, v33, v34, v35, v36, v37);
  uint64_t v47 = (uint64_t)v39;
  if (!v39 || sub_1B641D8A0((uint64_t)v39, v40, v41, v42, v43, v44, v45, v46) == v38)
  {
    if (v9 == 1)
    {
      if ((byte_1E9DDA621 & 1) == 0)
      {
        byte_1E9DDA621 = 1;
        sub_1B63F2F54(16, @"Error: Cannot use volume generation on a generic mesh. fallbacking on surface", v41, v42, v43, v44, v45, v46, v108);
      }
      LODWORD(v9) = 0;
    }
    CFArrayRef v48 = sub_1B64ABD08(v21, v40, v41, v42, v43, v44, v45, v46);
    if (v48) {
      BOOL v55 = 0;
    }
    else {
      BOOL v55 = v9 == 0;
    }
    if (v55) {
      int v56 = 2;
    }
    else {
      int v56 = v9;
    }
    if (v56)
    {
      if (v56 == 2 && v114 >= 1)
      {
        if (v10) {
          BOOL v57 = v47 == 0;
        }
        else {
          BOOL v57 = 1;
        }
        int v58 = !v57;
        do
        {
          uint64_t v59 = 214013 * *a3 + 2531011;
          *a3 = v59;
          uint64_t v60 = v59 % v38;
          *(double *)&long long v61 = sub_1B641E208(v30, v59 % v38, v49, v50, v51, v52, v53, v54);
          *CFTypeRef v11 = v61;
          if (v58)
          {
            *(double *)&long long v62 = sub_1B641E208(v47, v60, v49, v50, v51, v52, v53, v54);
            *uint64_t v10 = v62;
          }
          ++v10;
          ++v11;
          --v114;
        }
        while (v114);
      }
      return;
    }
    if (v114 < 1) {
      return;
    }
    uint64_t v63 = 0;
    long long v111 = v11;
    long long v112 = v10;
    CFArrayRef v109 = v48;
    uint64_t v110 = v21;
    while (1)
    {
      uint64_t v64 = 214013 * *a3 + 2531011;
      *a3 = v64;
      long long v65 = sub_1B64ABD78(v21, v64 % (uint64_t)v48, 1, v50, v51, v52, v53, v54);
      uint64_t v66 = sub_1B63D11E8((uint64_t)v65);
      uint64_t v67 = 214013 * *a3 + 2531011;
      *a3 = v67;
      uint64_t v75 = sub_1B63D0DCC((uint64_t)v65, v68, v69, v70, v71, v72, v73, v74);
      if (v75 >= 1)
      {
        uint64_t v79 = 0;
        uint64_t v80 = v67 % v66;
        do
        {
          uint64_t v81 = sub_1B63D14A0((uint64_t)v65, v80, v79, 0, v51, v52, v53, v54);
          *(double *)&long long v76 = sub_1B641E208(v30, v81, v82, v83, v84, v85, v86, v87);
          *((_OWORD *)&v118 + v79) = v76;
          if (v47)
          {
            *(double *)&long long v76 = sub_1B641E208(v47, v81, v88, v50, v51, v52, v53, v54);
            *((_OWORD *)&v115 + v79) = v76;
          }
          ++v79;
        }
        while (v75 != v79);
      }
      if (v75 == 1)
      {
        float32x4_t v89 = v112;
        v111[v63] = v118;
        CFArrayRef v48 = v109;
        uint64_t v21 = v110;
        if (v112)
        {
          float32x4_t v102 = v115;
LABEL_54:
          v89[v63] = v102;
        }
      }
      else
      {
        float32x4_t v89 = v112;
        CFArrayRef v48 = v109;
        uint64_t v21 = v110;
        if (v75 != 2)
        {
          if (v75 != 3) {
            goto LABEL_55;
          }
          unsigned int v90 = 214013 * *a3 + 2531011;
          float v91 = (float)HIWORD(v90) * 0.000015259;
          unsigned int v92 = 214013 * v90 + 2531011;
          float v93 = (float)HIWORD(v92) * 0.000015259;
          unsigned int v94 = 214013 * v92 + 2531011;
          *a3 = v94;
          float v95 = (float)HIWORD(v94) * 0.000015259;
          float v96 = 1.0 / (float)((float)(v91 + v93) + v95);
          *(float *)v77.i32 = v91 * v96;
          float v97 = v93 * v96;
          v111[v63] = vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v119, v93 * v96), v118, *(float *)v77.i32), v120, v95 * v96);
          if (!v112) {
            goto LABEL_55;
          }
          *(float *)v78.i32 = v95 * v96;
          float32x4_t v98 = vmlaq_f32(vmlaq_f32(vmulq_n_f32(v116, v97), v115, (float32x4_t)vdupq_lane_s32(v77, 0)), v117, (float32x4_t)vdupq_lane_s32(v78, 0));
          int32x4_t v99 = (int32x4_t)vmulq_f32(v98, v98);
          v99.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v99, 2), vadd_f32(*(float32x2_t *)v99.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v99.i8, 1))).u32[0];
          float32x2_t v100 = vrsqrte_f32((float32x2_t)v99.u32[0]);
          float32x2_t v101 = vmul_f32(v100, vrsqrts_f32((float32x2_t)v99.u32[0], vmul_f32(v100, v100)));
          float32x4_t v102 = vmulq_n_f32(v98, vmul_f32(v101, vrsqrts_f32((float32x2_t)v99.u32[0], vmul_f32(v101, v101))).f32[0]);
          goto LABEL_54;
        }
        unsigned int v103 = 214013 * *a3 + 2531011;
        *a3 = v103;
        *(float *)&long long v76 = (float)HIWORD(v103) * 0.000015259;
        v111[v63] = vmlaq_n_f32(v118, vsubq_f32(v119, v118), *(float *)&v76);
        if (v112)
        {
          float32x4_t v104 = vmlaq_f32(v115, vsubq_f32(v116, v115), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v76, 0));
          int32x4_t v105 = (int32x4_t)vmulq_f32(v104, v104);
          v105.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v105, 2), vadd_f32(*(float32x2_t *)v105.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v105.i8, 1))).u32[0];
          float32x2_t v106 = vrsqrte_f32((float32x2_t)v105.u32[0]);
          float32x2_t v107 = vmul_f32(v106, vrsqrts_f32((float32x2_t)v105.u32[0], vmul_f32(v106, v106)));
          float32x4_t v102 = vmulq_n_f32(v104, vmul_f32(v107, vrsqrts_f32((float32x2_t)v105.u32[0], vmul_f32(v107, v107))).f32[0]);
          goto LABEL_54;
        }
      }
LABEL_55:
      if (++v63 == v114) {
        return;
      }
    }
  }
  if ((byte_1E9DDA620 & 1) == 0)
  {
    byte_1E9DDA620 = 1;
    sub_1B63F2F54(16, @"Error: cannot generate points : mismatch between vertices and normals count", v41, v42, v43, v44, v45, v46, a9);
  }
}

uint64_t sub_1B63CEFD8(uint64_t a1)
{
  return *(unsigned char *)(a1 + 112) & 1;
}

BOOL sub_1B63CEFE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = *(unsigned char *)(a1 + 200);
  int v9 = v8 & 3;
  if ((v8 & 3) == 0)
  {
    int v9 = 1;
    CFArrayRef v11 = (const __CFArray *)sub_1B64AD3C4(*(void *)(a1 + 64), 1, a3, a4, a5, a6, a7, a8);
    CFIndex Count = CFArrayGetCount(v11);
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      CFIndex v14 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v11, v14);
        if (sub_1B63D0C08((uint64_t)ValueAtIndex, v16, v17, v18, v19, v20, v21, v22)) {
          break;
        }
        if (v13 == ++v14)
        {
          int v9 = 1;
          goto LABEL_8;
        }
      }
      int v9 = 2;
    }
LABEL_8:
    *(unsigned char *)(a1 + 200) = v9 | v8 & 0xFC;
  }
  return v9 == 1;
}

BOOL sub_1B63CF088(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  if (*(unsigned __int8 *)(a1 + 176) - 1 >= 3)
  {
    if (*(unsigned char *)(a1 + 176))
    {
      return sub_1B647F740(a1, a2, a3, a4, a5, a6, a7, a8);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return sub_1B63CEFE4(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

BOOL sub_1B63CF130(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  return !sub_1B647F3B0(a1, a2, a3, a4, a5, a6, a7, a8);
}

__n128 sub_1B63CF184@<Q0>(__n128 *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, __n128 *a8@<X8>)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a2, a3, a4, a5, a6, a7, (uint64_t)"geometry");
  }
  __n128 result = a1[11];
  *a8 = result;
  a8[1].n128_u64[0] = a1[12].n128_u64[0];
  return result;
}

uint64_t sub_1B63CF1E4(uint64_t a1, uint64_t a2, _OWORD *a3, _OWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(float32x4_t **)(a1 + 104);
  if (v10)
  {
    *a3 = vsubq_f32(*v10, v10[1]);
    *a4 = vaddq_f32(*(float32x4_t *)*(void *)(a1 + 104), *(float32x4_t *)(*(void *)(a1 + 104) + 16));
    return 1;
  }
  else
  {
    uint64_t result = sub_1B63CCE68(a1, a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
    if (result)
    {
      return sub_1B64AB620(result, a3, a4, v12, v13, v14, v15, v16);
    }
  }
  return result;
}

uint64_t sub_1B63CF25C(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B63CCE68(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (result)
  {
    return sub_1B64AB7A0(result, a3, v10, v11, v12, v13, v14, v15);
  }
  return result;
}

void sub_1B63CF2A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B63CCE68(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v9)
  {
    uint64_t v17 = (const void *)sub_1B64AB2A8(v9, v10, v11, v12, v13, v14, v15, v16);
    sub_1B63CDBD0(a1, (uint64_t)v17, v18, v19, v20, v21, v22, v23);
    if (v17)
    {
      CFRelease(v17);
    }
  }
}

uint64_t sub_1B63CF304(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1;
  uint64_t v10 = (const void *)sub_1B6583544(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (sub_1B63C47F8(v10, a2)) {
    return v9;
  }
  CFArrayRef v18 = sub_1B63CCEC4(v9, v11, v12, v13, v14, v15, v16, v17);
  if ((uint64_t)v18 >= 1)
  {
    CFArrayRef v26 = v18;
    uint64_t v27 = 0;
    do
    {
      CFArrayRef v28 = sub_1B63CCF34(v9, v27, v20, v21, v22, v23, v24, v25);
      uint64_t v29 = sub_1B63F4FC8(v28, (uint64_t)a2);
      if (v29) {
        return v29;
      }
    }
    while (v26 != (const __CFArray *)++v27);
  }
  uint64_t v30 = (const void *)sub_1B63CCE68(v9, v19, v20, v21, v22, v23, v24, v25);

  return sub_1B63F4FC8(v30, (uint64_t)a2);
}

uint64_t sub_1B63CF3B0(uint64_t a1)
{
  uint64_t v2 = -[VFXModel __createCFObject]_0();
  sub_1B63CDCE8(a1, v2, v3, v4, v5, v6, v7, v8);
  return v2;
}

double sub_1B63CF3E8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = sub_1B6DABD0C(a1, "Main");
  *(void *)uint64_t v3 = &unk_1F0FB2DD8;
  *(void *)(v3 + 24) = a2;
  *(void *)(v3 + 32) = 0;
  *(_WORD *)(v3 + 48) = 0;
  *(void *)(v3 + 72) = 0;
  *(void *)(v3 + 80) = 0;
  *(void *)(v3 + 64) = 0;
  double result = NAN;
  *(_OWORD *)(v3 + 88) = xmmword_1B6E4FC80;
  return result;
}

uint64_t sub_1B63CF44C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v5, *(_WORD *)(a1 + 8), 9273, 1656467160);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v6, *(_WORD *)(a1 + 8), 9273, -797957750);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v7, *(_WORD *)(a1 + 8), 9273, 1490954098);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v8, *(_WORD *)(a1 + 8), 9273, -1170177454);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v9, *(_WORD *)(a1 + 8), 9273, 839732700);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v10, *(_WORD *)(a1 + 8), 9273, -691122579);
  return sub_1B63D0050(a2, &v5, 6);
}

uint64_t sub_1B63CF550@<X0>(CFX::RG::ResourceIdentifier *a1@<X0>, uint64_t a2@<X8>)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  v4[0] = CFX::RG::ResourceIdentifier::finalColor(a1);
  return sub_1B63D0050(a2, v4, 1);
}

unint64_t sub_1B63CF5BC(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = *(unsigned __int16 *)(a1 + 8);
  uint64_t v11 = *a3;
  if (v11)
  {
    uint64_t v12 = (uint64_t *)*((void *)a3 + 1);
    uint64_t v13 = 8 * v11;
    do
    {
      uint64_t v14 = *v12++;
      uint64_t v48 = v14;
      uint64_t v15 = CFX::RG::ResourceIdentifier::id((CFX::RG::ResourceIdentifier *)&v48);
      unint64_t v10 = 0x9DDFEA08EB382D69
          * ((0x9DDFEA08EB382D69
            * (v10 ^ ((0x9DDFEA08EB382D69 * (v15 ^ v10)) >> 47) ^ (0x9DDFEA08EB382D69 * (v15 ^ v10)))) ^ ((0x9DDFEA08EB382D69 * (v10 ^ ((0x9DDFEA08EB382D69 * (v15 ^ v10)) >> 47) ^ (0x9DDFEA08EB382D69 * (v15 ^ v10)))) >> 47));
      v13 -= 8;
    }
    while (v13);
  }
  uint64_t v16 = sub_1B6446564(*(uint64_t **)(a1 + 24), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  CFDictionaryRef v24 = sub_1B64A3B48((uint64_t)v16, v17, v18, v19, v20, v21, v22, v23);
  unsigned int v32 = sub_1B649BAE8((uint64_t)v24, v25, v26, v27, v28, v29, v30, v31);
  uint64_t v33 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v34 = *(void *)(a1 + 80);
  char v41 = sub_1B63FACD8(*(void *)(a1 + 24), a2, v35, v36, v37, v38, v39, v40);
  uint64_t v42 = *(void *)(a1 + 32);
  if (v41) {
    *(void *)(a1 + 32) = ++v42;
  }
  unint64_t v43 = 0x9DDFEA08EB382D69
      * (v10 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v32)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v32)));
  unint64_t v44 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47))) ^ ((0x9DDFEA08EB382D69
                                                        * ((0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47))) ^ v33)) >> 47) ^ (0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * (v43 ^ (v43 >> 47))) ^ v33)));
  unint64_t v45 = 0x9DDFEA08EB382D69 * (v44 ^ (v44 >> 47));
  unint64_t v46 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v45 ^ ((0x9DDFEA08EB382D69 * (v45 ^ v34)) >> 47) ^ (0x9DDFEA08EB382D69 * (v45 ^ v34)))) ^ ((0x9DDFEA08EB382D69 * (v45 ^ ((0x9DDFEA08EB382D69 * (v45 ^ v34)) >> 47) ^ (0x9DDFEA08EB382D69 * (v45 ^ v34)))) >> 47));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v46 ^ ((0x9DDFEA08EB382D69 * (v42 ^ v46)) >> 47) ^ (0x9DDFEA08EB382D69 * (v42 ^ v46)))) ^ ((0x9DDFEA08EB382D69 * (v46 ^ ((0x9DDFEA08EB382D69 * (v42 ^ v46)) >> 47) ^ (0x9DDFEA08EB382D69 * (v42 ^ v46)))) >> 47));
}

uint64_t *sub_1B63CF704(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, _OWORD *a7, _OWORD *a8)
{
  uint64_t v172 = *MEMORY[0x1E4F143B8];
  sub_1B6447FBC((uint64_t)a3, 0);
  uint64_t v30 = (void *)sub_1B6445900((uint64_t)a3, v16, v17, v18, v19, v20, v21, v22);
  uint64_t v31 = *(uint64_t ***)(a4 + 32);
  if (!v31)
  {
    uint64_t v31 = (uint64_t **)sub_1B6446564(a3, v23, v24, v25, v26, v27, v28, v29);
    if (!v31) {
      return 0;
    }
  }
  float v153 = a7;
  CFDictionaryRef v32 = sub_1B64A3B48((uint64_t)v31, v23, v24, v25, v26, v27, v28, v29);
  if (!v32) {
    return 0;
  }
  uint64_t v33 = (uint64_t)v32;
  unsigned int v34 = sub_1B63CBCB0((uint64_t)a3);
  __int16 v152 = v34;
  if (a8)
  {
    long long v35 = a8[7];
    v166[6] = a8[6];
    v166[7] = v35;
    long long v36 = a8[9];
    v166[8] = a8[8];
    v166[9] = v36;
    long long v37 = a8[3];
    v166[2] = a8[2];
    v166[3] = v37;
    long long v38 = a8[5];
    v166[4] = a8[4];
    v166[5] = v38;
    long long v39 = a8[1];
    v166[0] = *a8;
    v166[1] = v39;
  }
  else
  {
    if (v34 <= 1) {
      MTLTextureType v41 = MTLTextureType2D;
    }
    else {
      MTLTextureType v41 = MTLTextureType2DArray;
    }
    CFX::RG::TextureDescriptorReference::finalColor((uint64_t)v163);
    unsigned __int8 v45 = objc_msgSend_sampleCount(v30, v42, v43, v44);
    CFX::RG::TextureDescriptorReference::withSampleCount(v163, v45, (uint64_t)v164);
    CFX::RG::TextureDescriptorReference::withTextureType((CFX::RG::TextureDescriptorReference *)v164, v41, (uint64_t)v165);
    CFX::RG::TextureDescriptorReference::withArraylength((CFX::RG::TextureDescriptorReference *)v165, v152, (uint64_t)&v167);
    float v46 = sub_1B6447C30((uint64_t)a3);
    CFX::RG::TextureDescriptorReference::withSizeFactor(&v167, v46, (float *)v166);
  }
  CFX::RG::TextureDescriptorReference::withPixelFormatIf(v166, MTLPixelFormatRGBA16Float, *a5, (uint64_t)v162);
  uint64_t v47 = sub_1B63CFDE4(a1, (uint64_t)"COLOR", v162);
  *(void *)a6 = v47;
  uint64_t v48 = (_WORD *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, v47);
  LOWORD(v49) = *v48;
  *(float *)&uint64_t v50 = (float)v49;
  LOWORD(v51) = v48[1];
  *((float *)&v50 + 1) = (float)v51;
  *((void *)a5 + 1) = v50;
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v166, MTLPixelFormatDepth32Float, (uint64_t)v161);
  *(void *)(a6 + 8) = sub_1B63CFDE4(a1, (uint64_t)"DEPTH", v161);
  sub_1B64479B4((uint64_t)a3, a5[5]);
  if (a5[5])
  {
    CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v166, MTLPixelFormatRGBA16Float, (uint64_t)v160);
    *(void *)(a6 + 24) = sub_1B63CFDE4(a1, (uint64_t)"VELOCITY", v160);
  }
  if (a5[2])
  {
    CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v166, MTLPixelFormatRGBA16Float, (uint64_t)v159);
    *(void *)(a6 + 16) = sub_1B63CFDE4(a1, (uint64_t)"NORMAL", v159);
    CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v166, MTLPixelFormatRGBA16Float, (uint64_t)v158);
    *(void *)(a6 + 40) = sub_1B63CFDE4(a1, (uint64_t)"REFLECTANCE ROUGHNESS", v158);
    CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v166, MTLPixelFormatRGBA16Float, (uint64_t)v157);
    *(void *)(a6 + 32) = sub_1B63CFDE4(a1, (uint64_t)"RADIANCE", v157);
  }
  if (*(unsigned char *)a4) {
    uint64_t v59 = 40;
  }
  else {
    uint64_t v59 = 32;
  }
  if (sub_1B6446B60((uint64_t)a3, v52, v53, v54, v55, v56, v57, v58)) {
    v59 |= 0x100uLL;
  }
  float32x4_t v60 = *(float32x4_t *)(a4 + 16);
  if ((vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v60))) & 0x80000000) != 0)
  {
    float32x2_t v63 = *(float32x2_t *)(a5 + 8);
    *(float32x2_t *)&long long v62 = vmul_f32(*(float32x2_t *)v60.f32, v63);
    *((float32x2_t *)&v62 + 1) = vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v60, (int8x16_t)v60, 8uLL), v63);
    char v61 = 1;
  }
  else
  {
    char v61 = 0;
    long long v62 = 0uLL;
  }
  *(void *)&long long v167 = a3;
  BYTE8(v167) = 1;
  uint64_t v170 = 0;
  float v168 = v31;
  unint64_t v169 = 0;
  *(_OWORD *)((char *)v171 + 8) = v62;
  BYTE8(v171[1]) = v61;
  *(_OWORD *)((char *)&v171[2] + 8) = *(_OWORD *)(a4 + 40);
  BYTE8(v171[3]) = sub_1B6446D64((uint64_t)a3);
  BYTE9(v171[3]) = sub_1B6447BF0((uint64_t)a3);
  *(void *)&v171[4] = v59;
  DWORD2(v171[4]) = 1;
  WORD6(v171[4]) = v152;
  uint64_t v64 = (CFX::RG::Pass *)sub_1B65269BC(a1, &v167, (uint64_t)"MainCulling");
  if (sub_1B649BAE8(v33, v65, v66, v67, v68, v69, v70, v71))
  {
    uint64_t v79 = sub_1B649B3A0(v33, v72, v73, v74, v75, v76, v77, v78);
    CFX::RG::TextureDescriptorReference::withSampleCount(v166, 1, (uint64_t)&v167);
    CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)&v167, MTLPixelFormatDepth32Float, (uint64_t)v156);
    uint64_t v80 = sub_1B63CFDE4(a1, (uint64_t)"DEPTH_PREPASS", v156);
    CFX::RG::TextureDescriptorReference::withSampleCount(v166, 1, (uint64_t)&v167);
    CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)&v167, MTLPixelFormatRGBA16Float, (uint64_t)v155);
    uint64_t v81 = sub_1B63CFDE4(a1, (uint64_t)"NORMAL_PREPASS", v155);
    *(void *)&long long v167 = "depthPrePass";
    *((void *)&v167 + 1) = a3;
    LOWORD(v168) = 0;
    LOBYTE(v169) = 0;
    uint64_t v170 = sub_1B65267F8((uint64_t)v64);
    *(void *)&v171[0] = 0;
    *((void *)&v171[0] + 1) = v80;
    *(void *)&v171[1] = v81;
    memset((char *)&v171[1] + 8, 0, 56);
    uint64_t v88 = sub_1B6474360(a1, (uint64_t)&v167, v82, v83, v84, v85, v86, v87);
    CFX::RG::Pass::dependsOn(v88, v64);
    LOBYTE(v167) = 0;
    DWORD1(v167) = sub_1B6529330(v79, v89, v90, v91, v92, v93, v94, v95);
    DWORD2(v167) = sub_1B6529878(v79, v96, v97, v98, v99, v100, v101, v102);
    HIDWORD(v167) = sub_1B65299B8(v79, v103, v104, v105, v106, v107, v108, v109);
    float v110 = sub_1B6447C30((uint64_t)a3);
    *(float *)&float v168 = v110 * (float)(1.0 / sub_1B6447C0C((uint64_t)a3));
    unint64_t v169 = a3;
    uint64_t v170 = 0;
    *(void *)&v171[0] = v80;
    *(_OWORD *)((char *)v171 + 8) = (unint64_t)v81;
    long long v111 = sub_1B63F0D14(a1, (CFX::RG::RenderGraphContext *)a2, (uint64_t)&v167);
    CFX::RG::Pass::dependsOn(v111, (CFX::RG::Pass *)v88);
  }
  else
  {
    long long v111 = 0;
  }
  *(void *)&long long v167 = "Main";
  *((void *)&v167 + 1) = a3;
  LOBYTE(v168) = sub_1B6446D64((uint64_t)a3);
  if (sub_1B6446D64((uint64_t)a3) == 1) {
    char v112 = sub_1B6447B7C((uint64_t)a3);
  }
  else {
    char v112 = 0;
  }
  BYTE1(v168) = v112;
  LOBYTE(v169) = 1;
  uint64_t v170 = sub_1B65267F8((uint64_t)v64);
  long long v113 = *(_OWORD *)(a6 + 16);
  v171[0] = *(_OWORD *)a6;
  v171[1] = v113;
  long long v114 = *(_OWORD *)(a6 + 48);
  v171[2] = *(_OWORD *)(a6 + 32);
  v171[3] = v114;
  v171[4] = *v153;
  uint64_t v40 = sub_1B6474360(a1, (uint64_t)&v167, v115, v116, v117, v118, v119, v120);
  CFX::RG::Pass::dependsOn(v40, v64);
  if (v111) {
    CFX::RG::Pass::dependsOn(v40, (CFX::RG::Pass *)v111);
  }
  uint64_t v126 = sub_1B655035C(a1, a2[2], (uint64_t)a3, v121, v122, v123, v124, v125);
  long long v127 = (uint64_t *)v126;
  if (v126)
  {
    CFX::RG::Pass::readFrom(v40, *(CFX::RG::Resource **)(v126 + 424));
    CFX::RG::Pass::dependsOn(v127, v64);
  }
  uint64_t v128 = a2[2];
  uint64_t v129 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*(CFX::RG::Resource **)a6);
  long long v130 = v129[1];
  v154[0] = *v129;
  v154[1] = v130;
  long long v131 = v129[2];
  long long v132 = v129[3];
  long long v133 = v129[5];
  int v154[4] = v129[4];
  v154[5] = v133;
  v154[2] = v131;
  v154[3] = v132;
  long long v134 = v129[6];
  long long v135 = v129[7];
  long long v136 = v129[9];
  v154[8] = v129[8];
  v154[9] = v136;
  v154[6] = v134;
  v154[7] = v135;
  sub_1B65560EC((uint64_t)a1, v128, (uint64_t)a3, (uint64_t)v154, v137, v138, v139, v140, (uint64_t *)&v167);
  if (DWORD2(v167))
  {
    uint64_t v146 = v168;
    uint64_t v147 = 8 * DWORD2(v167);
    do
    {
      uint64_t v148 = *v146;
      CFX::RG::Pass::readFrom(v40, (CFX::RG::Resource *)(*v146)[71]);
      uint64_t v149 = (CFX::RG::Resource *)v148[72];
      if (v149) {
        CFX::RG::Pass::readFrom(v40, v149);
      }
      CFX::RG::Pass::dependsOn(v148, v64);
      ++v146;
      v147 -= 8;
    }
    while (v147);
  }
  v165[0] = (uint64_t)a3;
  v165[1] = 0;
  uint64_t v150 = (CFX::RG::Pass *)sub_1B63FAE10(a1, (uint64_t)a2, v165, v141, v142, v143, v144, v145);
  if (v150)
  {
    CFX::RG::Pass::dependsOn(v40, v150);
    CFX::RG::Pass::dependsOn((uint64_t *)v150, v64);
  }
  return v40;
}

CFX::RG::Resource *sub_1B63CFDE4(uint64_t *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v10 = a2;
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  char v9 = 1;
  sub_1B63D01F0(v4, v5, &v10, a3, &v9);
  uint64_t v7 = v6;
  CFX::RG::RenderGraphBuilder::appendResource(a1, v6);
  return v7;
}

void sub_1B63CFE44(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  sub_1B6447FBC(*(void *)(a1 + 24), 0);
  uint64_t v13 = sub_1B6446564(*(uint64_t **)(a1 + 24), v6, v7, v8, v9, v10, v11, v12);
  if (v13 && sub_1B64A3B48((uint64_t)v13, v14, v15, v16, v17, v18, v19, v20))
  {
    if (*(unsigned char *)(a1 + 49)) {
      memset(v39, 0, sizeof(v39));
    }
    else {
      sub_1B64E3F20(v39, *(void *)(a1 + 24), 0);
    }
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v34 = 0uLL;
    uint64_t v21 = sub_1B63CF704(a3, a2, *(uint64_t **)(a1 + 24), a1 + 48, (unsigned __int8 *)v39, (uint64_t)&v35, &v34, 0);
    unint64_t v22 = v35;
    if ((void)v35)
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v33, *(_WORD *)(a1 + 8), 9273, 1656467160);
      CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v33, v22, (uint64_t)v21);
    }
    unint64_t v23 = *((void *)&v35 + 1);
    if (*((void *)&v35 + 1))
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v32, *(_WORD *)(a1 + 8), 9273, -797957750);
      CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v32, v23, (uint64_t)v21);
    }
    unint64_t v24 = v36;
    if ((void)v36)
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v31, *(_WORD *)(a1 + 8), 9273, 1490954098);
      CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v31, v24, (uint64_t)v21);
    }
    unint64_t v25 = *((void *)&v37 + 1);
    if (*((void *)&v37 + 1))
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v30, *(_WORD *)(a1 + 8), 9273, -691122579);
      CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v30, v25, (uint64_t)v21);
    }
    unint64_t v26 = v37;
    if ((void)v37)
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v29, *(_WORD *)(a1 + 8), 9273, 839732700);
      CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v29, v26, (uint64_t)v21);
    }
    unint64_t v27 = *((void *)&v36 + 1);
    if (*((void *)&v36 + 1))
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v28, *(_WORD *)(a1 + 8), 9273, -1170177454);
      CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v28, v27, (uint64_t)v21);
    }
  }
}

void sub_1B63D003C()
{
}

uint64_t sub_1B63D0050(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = a1 + 16;
  sub_1B63D00C4((unsigned int *)a1, a3, 1);
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      uint64_t v7 = *a2++;
      uint64_t v9 = v7;
      sub_1B63D0190(a1, &v9);
      v6 -= 8;
    }
    while (v6);
  }
  return a1;
}

void sub_1B63D00C4(unsigned int *a1, int a2, int a3)
{
  uint64_t v4 = (unsigned int *)*((void *)a1 + 1);
  uint64_t v5 = a1 + 4;
  double v6 = 1.5;
  if (a3) {
    double v6 = 1.0;
  }
  unsigned int v7 = (v6 * (double)(a1[1] + a2));
  uint64_t v8 = malloc_type_malloc(8 * v7, 0xD5346062uLL);
  memset(v8, 255, 8 * v7);
  memcpy(v8, v4, 8 * *a1);
  *((void *)a1 + 1) = v8;
  a1[1] = v7;
  if (v4 != v5)
  {
    free(v4);
  }
}

void sub_1B63D0190(uint64_t a1, void *a2)
{
  unsigned int v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 + 1) > *(_DWORD *)(a1 + 4))
  {
    sub_1B63D00C4((unsigned int *)a1, 1, 0);
    unsigned int v4 = *(_DWORD *)a1;
  }
  *(void *)(*(void *)(a1 + 8) + 8 * v4) = *a2;
  ++*(_DWORD *)a1;
}

double sub_1B63D01F0(uint64_t a1, uint64_t a2, uint64_t *a3, _OWORD *a4, char *a5)
{
  v17[0] = a1;
  v17[1] = a2;
  uint64_t v8 = sub_1B63C8330(v17, 0xE0u, 8u);
  uint64_t v9 = *a3;
  long long v10 = a4[7];
  v16[6] = a4[6];
  v16[7] = v10;
  long long v11 = a4[9];
  v16[8] = a4[8];
  v16[9] = v11;
  long long v12 = a4[3];
  _OWORD v16[2] = a4[2];
  v16[3] = v12;
  long long v13 = a4[5];
  v16[4] = a4[4];
  v16[5] = v13;
  long long v14 = a4[1];
  v16[0] = *a4;
  v16[1] = v14;
  *(void *)&double result = CFX::RG::Resource::Resource(v8, v9, (uint64_t)v16, *a5).n128_u64[0];
  return result;
}

uint64_t sub_1B63D0278()
{
  if (qword_1EB995550 != -1) {
    dispatch_once(&qword_1EB995550, &unk_1F0FB5568);
  }
  return qword_1EB995558;
}

void sub_1B63D02BC()
{
  if (!qword_1EB995558)
  {
    qword_1EB995558 = sub_1B63C8D10(&qword_1EB995558);
    qword_1EB9845B0 = (uint64_t)sub_1B63D36E4;
  }
}

uint64_t sub_1B63D0314()
{
  if (qword_1EB995550 != -1) {
    dispatch_once(&qword_1EB995550, &unk_1F0FB5568);
  }
  uint64_t v6 = sub_1B63C8D44(qword_1EB995558, 0xD0uLL);
  if (!v6) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v0, v1, v2, v3, v4, v5, (uint64_t)"meshElement");
  }
  *(unsigned char *)(v6 + 88) = 0;
  *(void *)(v6 + 96) = 0;
  *(_DWORD *)(v6 + 128) = 0x10000;
  *(void *)(v6 + 112) = 0;
  *(void *)(v6 + 120) = 0;
  *(_DWORD *)(v6 + 68) = 1;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(v6 + 144) = _D0;
  *(_DWORD *)(v6 + 152) = 1065353216;
  return v6;
}

uint64_t sub_1B63D03C4()
{
  if (qword_1E9DDA628 != -1) {
    dispatch_once(&qword_1E9DDA628, &unk_1F0FB6CC8);
  }
  return qword_1E9DDA630;
}

uint64_t sub_1B63D0408()
{
  uint64_t result = sub_1B63D0314();
  qword_1E9DDA630 = result;
  return result;
}

void sub_1B63D0428(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, CFTypeRef cf, uint64_t a7, uint64_t a8)
{
  char v8 = a7;
  char v10 = a5;
  char v11 = a4;
  int v12 = a3;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, (uint64_t)cf, a7, a8, (uint64_t)"meshElement");
  }
  *(unsigned char *)(a1 + 88) = a2;
  *(unsigned char *)(a1 + 130) = v11;
  *(unsigned char *)(a1 + 131) = v10;
  *(_DWORD *)(a1 + 104) = v12;
  sub_1B63D0E74(a1, cf, v8);
  free(*(void **)(a1 + 120));
  *(void *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 128) = 0;
}

void sub_1B63D04D0(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  *(unsigned char *)(a1 + 88) = a2;
}

CFTypeRef sub_1B63D0520(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8)
{
  char v8 = a7;
  char v10 = a5;
  char v11 = a4;
  int v12 = a3;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"meshElement");
  }
  *(unsigned char *)(a1 + 88) = a2;
  *(unsigned char *)(a1 + 130) = v11;
  *(unsigned char *)(a1 + 131) = v10;
  *(_DWORD *)(a1 + 104) = v12;
  sub_1B63D0E74(a1, 0, v8);
  free(*(void **)(a1 + 120));
  *(void *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 128) = 0;
  CFTypeRef result = CFRetain(a6);
  *(void *)(a1 + 136) = result;
  return result;
}

void sub_1B63D05D4(uint64_t a1, char a2, uint64_t a3, CFTypeRef cf, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B63D05E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"input");
  }
  uint64_t v9 = sub_1B63D0314();
  sub_1B63D064C(a1, v9, 0, v10, v11, v12, v13, v14);
  return v9;
}

void sub_1B63D064C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  if (!a1)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"src");
    if (a2) {
      goto LABEL_3;
    }
LABEL_16:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"dst");
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_16;
  }
LABEL_3:
  *(_WORD *)(a2 + 80) = *(_WORD *)(a1 + 80);
  *(unsigned char *)(a2 + 88) = *(unsigned char *)(a1 + 88);
  CFDataRef v11 = *(const __CFData **)(a1 + 96);
  if (v8 && v11)
  {
    CFDataRef Copy = CFDataCreateCopy(0, v11);
    CFDataRef v13 = *(CFDataRef *)(a2 + 96);
    if (v13 != Copy)
    {
      if (v13)
      {
        CFRelease(v13);
        *(void *)(a2 + 96) = 0;
      }
      if (Copy) {
        CFTypeRef v14 = CFRetain(Copy);
      }
      else {
        CFTypeRef v14 = 0;
      }
      *(void *)(a2 + 96) = v14;
    }
    CFRelease(Copy);
  }
  else
  {
    CFDataRef v15 = *(const __CFData **)(a2 + 96);
    if (v15 != v11)
    {
      if (v15)
      {
        CFRelease(v15);
        *(void *)(a2 + 96) = 0;
        CFDataRef v11 = *(const __CFData **)(a1 + 96);
      }
      if (v11) {
        CFTypeRef v16 = CFRetain(v11);
      }
      else {
        CFTypeRef v16 = 0;
      }
      *(void *)(a2 + 96) = v16;
    }
  }
  *(_DWORD *)(a2 + 104) = *(_DWORD *)(a1 + 104);
  free(*(void **)(a2 + 112));
  *(void *)(a2 + 112) = 0;
  if (*(void *)(a1 + 112))
  {
    size_t v17 = 4 * *(unsigned int *)(a1 + 104);
    uint64_t v18 = malloc_type_malloc(v17, 0x4BA2350uLL);
    *(void *)(a2 + 112) = v18;
    memcpy(v18, *(const void **)(a1 + 112), v17);
  }
  free(*(void **)(a2 + 120));
  *(void *)(a2 + 120) = 0;
  if (*(void *)(a1 + 120))
  {
    size_t v25 = 2 * *(unsigned __int16 *)(a1 + 128);
    unint64_t v26 = malloc_type_malloc(v25, 0xFF13E64BuLL);
    *(void *)(a2 + 120) = v26;
    memcpy(v26, *(const void **)(a1 + 120), v25);
  }
  *(_DWORD *)(a2 + 128) = *(_DWORD *)(a1 + 128);

  sub_1B6583A28(a1, (CFTypeRef *)a2, v19, v20, v21, v22, v23, v24);
}

uint64_t sub_1B63D0804(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"input");
  }
  uint64_t v9 = sub_1B63D0314();
  sub_1B63D064C(a1, v9, 1, v10, v11, v12, v13, v14);
  return v9;
}

CFTypeRef sub_1B63D0868(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 168);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 168) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 168) = result;
  }
  return result;
}

uint64_t sub_1B63D08E4(CFArrayRef theArray, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!theArray) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"elements");
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (!Count) {
    return 0;
  }
  uint64_t v16 = Count;
  if (Count < 1)
  {
LABEL_10:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"meshElement");
    LODWORD(v17) = 0;
    ValueAtIndex = 0;
    int v20 = 1;
  }
  else
  {
    CFIndex v17 = 0;
    while (1)
    {
      ValueAtIndex = (CFTypeRef *)CFArrayGetValueAtIndex(theArray, v17);
      if (!ValueAtIndex) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v10, v11, v12, v13, v14, v15, (uint64_t)"meshElement");
      }
      if (*((unsigned __int8 *)ValueAtIndex + 88) < 6u) {
        break;
      }
      if (v16 == ++v17) {
        goto LABEL_10;
      }
    }
    int v20 = 0;
  }
  int v21 = *((unsigned __int8 *)ValueAtIndex + 81);
  uint64_t v28 = sub_1B63D0CA8((uint64_t)ValueAtIndex, v18, v10, v11, v12, v13, v14, v15);
  int v29 = *((unsigned __int8 *)ValueAtIndex + 88);
  uint64_t v30 = *((unsigned __int8 *)ValueAtIndex + 80);
  if (v29 == 1) {
    sub_1B63F2F54(16, @"Error: CFXMeshElementCreateByMergingElements - strip not supported", v22, v23, v24, v25, v26, v27, v77);
  }
  for (CFIndex i = (v17 + 1); v16 > i; ++i)
  {
    long long v39 = (unsigned __int8 *)CFArrayGetValueAtIndex(theArray, i);
    if (!v39) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v33, v34, v35, v36, v37, v38, (uint64_t)"meshElement");
    }
    if (v39[88] <= 5u)
    {
      uint64_t v40 = sub_1B63D0CA8((uint64_t)v39, v32, v33, v34, v35, v36, v37, v38);
      if (v30 != v39[80])
      {
        sub_1B63F2F54(16, @"Error: CFXMeshElementCreateByMergingElements - merging elements with different byte per index", v41, v42, v43, v44, v45, v46, v77);
        return 0;
      }
      v28 += v40;
    }
  }
  uint64_t v53 = sub_1B63D0314();
  if (v20) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v47, v48, v49, v50, v51, v52, (uint64_t)"meshElement");
  }
  sub_1B63D0868(v53, ValueAtIndex[21], v47, v48, v49, v50, v51, v52);
  if (!v53) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v54, v55, v56, v57, v58, v59, (uint64_t)"meshElement");
  }
  *(unsigned char *)(v53 + 81) = v21 != 0;
  *(unsigned char *)(v53 + 88) = v29;
  CFSetRef Mutable = CFDataCreateMutable(0, v28 * v30);
  CFDataSetLength(Mutable, v28 * v30);
  cf = Mutable;
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (v16 >= 1)
  {
    uint64_t v69 = MutableBytePtr;
    for (CFIndex j = 0; j != v16; ++j)
    {
      uint64_t v71 = (CFDataRef *)CFArrayGetValueAtIndex(theArray, j);
      if (!v71) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v63, v64, v65, v66, v67, v68, (uint64_t)"meshElement");
      }
      if (*((unsigned __int8 *)v71 + 88) <= 5u)
      {
        CFIndex Length = CFDataGetLength(v71[12]);
        BytePtr = CFDataGetBytePtr(v71[12]);
        memcpy(v69, BytePtr, Length);
        v69 += Length;
      }
    }
  }
  unint64_t v74 = sub_1B63D0DCC(v53, v62, v63, v64, v65, v66, v67, v68);
  if (v74 <= 1) {
    uint64_t v75 = 1;
  }
  else {
    uint64_t v75 = v74;
  }
  *(_DWORD *)(v53 + 104) = v28 / v75;
  sub_1B63D0E74(v53, cf, v30);
  free(*(void **)(v53 + 120));
  *(void *)(v53 + 120) = 0;
  *(_WORD *)(v53 + 128) = 0;
  CFRelease(cf);
  return v53;
}

BOOL sub_1B63D0BFC(unsigned int a1)
{
  return a1 < 6;
}

uint64_t sub_1B63D0C08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  return *(char *)(a1 + 88);
}

BOOL sub_1B63D0C54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  return *(unsigned char *)(a1 + 81) != 0;
}

uint64_t sub_1B63D0CA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  int v9 = *(unsigned __int8 *)(a1 + 88);
  if (v9 == 4)
  {
    unint64_t v11 = *(unsigned __int8 *)(a1 + 80);
    uint64_t v10 = *(unsigned int *)(a1 + 104);
    uint64_t v18 = CFDataGetLength(*(CFDataRef *)(a1 + 96)) / v11 - v10;
    uint64_t v19 = *(unsigned __int8 *)(a1 + 130);
    uint64_t v20 = v18 / v19;
    if (v18 % v19) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. Internal consistency error: number of indices should be a multiple of number of channels", v12, v13, v14, v15, v16, v17, (uint64_t)"indexCount % channelCount == 0");
    }
    return v20;
  }
  else
  {
    uint64_t v22 = *(unsigned int *)(a1 + 104);
    return sub_1B63D1414((char)v9, v22, a3, a4, a5, a6, a7, a8);
  }
}

void sub_1B63D0D7C(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  *(unsigned char *)(a1 + 81) = a2;
}

uint64_t sub_1B63D0DCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(char *)(a1 + 88);
  if (v8 < 4) {
    return qword_1B6E4FC90[v8];
  }
  sub_1B63F2F54(0, @"Warning: %s does not support non-renderable topologies.", a3, a4, a5, a6, a7, a8, (uint64_t)"CFXMeshElementGetIndexCountPerPrimitive");
  return 0;
}

void sub_1B63D0E24(uint64_t a1, int a2, CFTypeRef cf, char a4)
{
  *(_DWORD *)(a1 + 104) = a2;
  sub_1B63D0E74(a1, cf, a4);
  free(*(void **)(a1 + 120));
  *(void *)(a1 + 120) = 0;
  *(_WORD *)(a1 + 128) = 0;
}

BOOL sub_1B63D0E64(char a1)
{
  return (a1 & 0xFA) == 0;
}

void sub_1B63D0E74(uint64_t a1, CFTypeRef cf, char a3)
{
  CFTypeRef v3 = cf;
  *(unsigned char *)(a1 + 80) = a3;
  CFTypeRef v5 = *(CFTypeRef *)(a1 + 96);
  if (v5 != cf)
  {
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a1 + 96) = 0;
    }
    if (v3) {
      CFTypeRef v3 = CFRetain(v3);
    }
    *(void *)(a1 + 96) = v3;
  }
  uint64_t v6 = *(void **)(a1 + 112);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 112) = 0;
    CFTypeRef v3 = *(CFTypeRef *)(a1 + 96);
  }
  if (v3)
  {
    CFIndex Length = CFDataGetLength((CFDataRef)v3);
    uint64_t v8 = *(unsigned int *)(a1 + 64);
    uint64_t v9 = *(unsigned __int8 *)(a1 + 80);
    if (Length < v8 + sub_1B63D0CA8(a1, v10, v11, v12, v13, v14, v15, v16) * v9)
    {
      sub_1B63F2F54(16, @"Error: CFXMeshElementSetPrimitives invalid index buffer size", v17, v18, v19, v20, v21, v22, v24);
      uint64_t v23 = *(const void **)(a1 + 96);
      if (v23)
      {
        CFRelease(v23);
        *(void *)(a1 + 96) = 0;
      }
    }
  }
}

uint64_t sub_1B63D0F30(uint64_t a1)
{
  return *(void *)(a1 + 136);
}

uint64_t sub_1B63D0F38(uint64_t a1, _DWORD *a2)
{
  if (a2) {
    *a2 = *(unsigned __int8 *)(a1 + 80);
  }
  return *(void *)(a1 + 96);
}

uint64_t sub_1B63D0F4C(uint64_t a1)
{
  if (*(_WORD *)(a1 + 128) == 1) {
    return **(void **)(a1 + 120);
  }
  else {
    return -1;
  }
}

void *sub_1B63D0F70(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(unsigned __int16 *)(a1 + 128);
  CFTypeRef result = *(void **)(a1 + 120);
  if (!v6)
  {
    CFTypeRef result = malloc_type_realloc(result, 0x10uLL, 0x1000040451B5BE8uLL);
    *(void *)(a1 + 120) = result;
  }
  void *result = a2;
  result[1] = a3;
  *(_WORD *)(a1 + 128) = 1;
  return result;
}

uint64_t sub_1B63D0FD4(uint64_t a1, _WORD *a2)
{
  if (a2) {
    *a2 = *(_WORD *)(a1 + 128);
  }
  return *(void *)(a1 + 120);
}

void sub_1B63D0FE8(uint64_t a1, uint64_t a2, __int16 a3)
{
  *(void *)(a1 + 120) = a2;
  *(_WORD *)(a1 + 128) = a3;
}

uint64_t sub_1B63D1028(uint64_t result, uint64_t a2)
{
  if (*(void *)(result + 120))
  {
    uint64_t v2 = result;
    if (*(_WORD *)(result + 128))
    {
      uint64_t v4 = 0;
      unint64_t v5 = 0;
      do
      {
        CFTypeRef result = (*(uint64_t (**)(uint64_t, void, void))(a2 + 16))(a2, *(void *)(*(void *)(v2 + 120) + v4), *(void *)(*(void *)(v2 + 120) + v4 + 8));
        ++v5;
        v4 += 16;
      }
      while (v5 < *(unsigned __int16 *)(v2 + 128));
    }
  }
  return result;
}

uint64_t sub_1B63D10A4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 120);
  if (!v1) {
    return *(unsigned int *)(a1 + 104);
  }
  uint64_t v2 = *(unsigned __int16 *)(a1 + 128);
  if (!*(_WORD *)(a1 + 128)) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = (uint64_t *)(v1 + 8);
  do
  {
    uint64_t v5 = *v4;
    v4 += 2;
    result += v5;
    --v2;
  }
  while (v2);
  return result;
}

uint64_t sub_1B63D10E0(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (*(void *)(result + 120))
  {
    unsigned int v4 = *(unsigned __int16 *)(result + 128);
    if (*(_WORD *)(result + 128))
    {
      unint64_t v5 = 0;
      do
      {
        int v6 = (unsigned int *)(*(void *)(v3 + 120) + 16 * v5);
        uint64_t v7 = *v6;
        uint64_t v8 = *((void *)v6 + 1);
        if (v7 < (int)v8 + (int)v7)
        {
          do
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v7);
            uint64_t v7 = (v7 + 1);
            LODWORD(v8) = v8 - 1;
          }
          while (v8);
          unsigned int v4 = *(unsigned __int16 *)(v3 + 128);
        }
        ++v5;
      }
      while (v5 < v4);
    }
  }
  else if (*(_DWORD *)(result + 104))
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, v9);
      uint64_t v9 = (v9 + 1);
    }
    while (v9 < *(_DWORD *)(v3 + 104));
  }
  return result;
}

uint64_t sub_1B63D11A8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 130);
}

uint64_t sub_1B63D11B0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 131);
}

float sub_1B63D11B8(uint64_t a1)
{
  return *(float *)(a1 + 144);
}

uint64_t sub_1B63D11C0(uint64_t result, float a2)
{
  *(float *)(result + 144) = a2;
  return result;
}

float sub_1B63D11C8(uint64_t a1)
{
  return *(float *)(a1 + 148);
}

uint64_t sub_1B63D11D0(uint64_t result, float a2)
{
  *(float *)(result + 148) = a2;
  return result;
}

float sub_1B63D11D8(uint64_t a1)
{
  return *(float *)(a1 + 152);
}

uint64_t sub_1B63D11E0(uint64_t result, float a2)
{
  *(float *)(result + 152) = a2;
  return result;
}

uint64_t sub_1B63D11E8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 104);
}

const UInt8 *sub_1B63D11F0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>)
{
  uint64_t v9 = a2;
  uint64_t v12 = *(unsigned __int8 *)(a1 + 130);
  if (a2 < 0 || v12 <= a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Mesh element has %d channels but channel %d was requested", a3, a4, a5, a6, a7, a8, (uint64_t)"channel >= 0 && channel < channelCount");
  }
  int v13 = *(unsigned __int8 *)(a1 + 131);
  if (!*(unsigned char *)(a1 + 131)) {
    v9 *= sub_1B63D0CA8(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  int v14 = *(unsigned __int8 *)(a1 + 88);
  uint64_t result = *(const UInt8 **)(a1 + 96);
  if (result)
  {
    uint64_t result = CFDataGetBytePtr((CFDataRef)result);
    *(void *)(a9 + 16) = 0;
    *(void *)(a9 + 24) = 0;
    *(void *)(a9 + 8) = 0;
    if (v14 == 4 && result) {
      uint64_t v16 = &result[*(_DWORD *)(a1 + 104) * *(unsigned __int8 *)(a1 + 80)];
    }
    else {
      uint64_t v16 = result;
    }
  }
  else
  {
    uint64_t v16 = 0;
    *(void *)(a9 + 8) = 0;
    *(void *)(a9 + 16) = 0;
    *(void *)(a9 + 24) = 0;
  }
  *(void *)a9 = v16;
  if (v13) {
    uint64_t v17 = v12;
  }
  else {
    uint64_t v17 = 1;
  }
  *(_DWORD *)(a9 + 8) = *(_DWORD *)(a1 + 104);
  *(void *)(a9 + 16) = *(void *)(a1 + 120);
  *(_WORD *)(a9 + 24) = *(_WORD *)(a1 + 128);
  *(unsigned char *)(a9 + 26) = *(unsigned char *)(a1 + 88);
  *(unsigned char *)(a9 + 27) = *(unsigned char *)(a1 + 80);
  if (v14 == 4) {
    uint64_t v18 = result;
  }
  else {
    uint64_t v18 = 0;
  }
  *(void *)(a9 + 32) = v18;
  *(void *)(a9 + 40) = v9;
  *(void *)(a9 + 48) = v17;
  return result;
}

uint64_t sub_1B63D1304(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 88) == 4)
  {
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
    int v18 = *(unsigned __int8 *)(a1 + 80);
    if (*(unsigned __int8 *)(a1 + 80) * (unint64_t)(a2 + 1) <= Length)
    {
      switch(v18)
      {
        case 4:
          return *(unsigned int *)&BytePtr[4 * a2];
        case 2:
          return *(unsigned __int16 *)&BytePtr[2 * a2];
        case 1:
          return BytePtr[a2];
      }
      sub_1B63F2F54(17, @"Assertion '%s' failed. %s - unsupported index size (%ld)", v12, v13, v14, v15, v16, v17, (uint64_t)"false");
    }
    else
    {
      sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v12, v13, v14, v15, v16, v17, a2);
    }
    return 0;
  }

  return sub_1B63D0DCC(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1B63D1414(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a1)
  {
    case 0:
      a2 *= 3;
      break;
    case 1:
    case 5:
      a2 += 2;
      break;
    case 2:
      a2 *= 2;
      break;
    case 3:
      return a2;
    default:
      sub_1B63F2F54(16, @"Error: CFXMeshElementGetIndexCount:primitive type not handled", a3, a4, a5, a6, a7, a8, v8);
      a2 = 0;
      break;
  }
  return a2;
}

uint64_t sub_1B63D14A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a4;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  if (*(unsigned char *)(a1 + 88) == 4)
  {
    uint64_t v12 = *(unsigned int *)(a1 + 104);
    uint64_t v13 = *(_DWORD **)(a1 + 112);
    if (v13) {
      goto LABEL_5;
    }
    unint64_t v29 = *(unsigned __int8 *)(a1 + 80);
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
    if (BytePtr)
    {
      uint64_t v31 = *(unsigned int *)(a1 + 104);
      uint64_t v13 = malloc_type_malloc(4 * v31, 0x100004052888210uLL);
      *(void *)(a1 + 112) = v13;
      if (!v31) {
        goto LABEL_5;
      }
      uint64_t v36 = v12;
      uint64_t v32 = 0;
      int v33 = 0;
      unint64_t v34 = v29;
      while (v34 <= Length)
      {
        switch(v29)
        {
          case 4:
            int v35 = *(_DWORD *)&BytePtr[4 * v32];
            break;
          case 2:
            int v35 = *(unsigned __int16 *)&BytePtr[2 * v32];
            break;
          case 1:
            int v35 = BytePtr[v32];
            break;
          default:
            sub_1B63F2F54(17, @"Assertion '%s' failed. %s - unsupported index size (%ld)", a3, a4, a5, a6, a7, a8, (uint64_t)"false");
            goto LABEL_34;
        }
LABEL_35:
        v33 += v35;
        uint64_t v13 = *(_DWORD **)(a1 + 112);
        v13[v32] = v33;
        v34 += v29;
        if (v31 == ++v32)
        {
          uint64_t v12 = v36;
          goto LABEL_5;
        }
      }
      sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", a3, a4, a5, a6, a7, a8, v32);
LABEL_34:
      int v35 = 0;
      goto LABEL_35;
    }
    uint64_t v13 = *(_DWORD **)(a1 + 112);
LABEL_5:
    unsigned int v14 = 0;
    if (a2 >= 1 && v13) {
      unsigned int v14 = v13[a2 - 1];
    }
  }
  else
  {
    uint64_t v12 = 0;
    unsigned int v14 = sub_1B63D0DCC(a1, a2, a3, a4, a5, a6, a7, a8) * a2;
  }
  if (*(unsigned char *)(a1 + 131))
  {
    uint64_t v15 = *(unsigned __int8 *)(a1 + 130);
  }
  else
  {
    v8 *= sub_1B63D0CA8(a1, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v15 = 1;
  }
  uint64_t v16 = v8 + v12 + v15 * (a3 + v14);
  CFDataRef v17 = *(const __CFData **)(a1 + 96);
  if (v17)
  {
    unsigned int v18 = *(unsigned __int8 *)(a1 + 80);
    unint64_t v19 = CFDataGetLength(*(CFDataRef *)(a1 + 96));
    uint64_t v20 = CFDataGetBytePtr(v17);
    if (v18 * (unint64_t)(v16 + 1) <= v19)
    {
      switch(v18)
      {
        case 4u:
          return *(unsigned int *)&v20[4 * v16];
        case 2u:
          return *(unsigned __int16 *)&v20[2 * v16];
        case 1u:
          return v20[v16];
      }
      sub_1B63F2F54(17, @"Assertion '%s' failed. %s - unsupported index size (%ld)", v21, v22, v23, v24, v25, v26, (uint64_t)"false");
    }
    else
    {
      sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v21, v22, v23, v24, v25, v26, v16);
    }
    return 0;
  }
  return v16;
}

uint64_t sub_1B63D1748(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  int v9 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  unsigned int v11 = sub_1B63D0CA8(a1, a2, a3, a4, a5, a6, a7, a8);
  unsigned int v12 = *(unsigned __int8 *)(a1 + 80);
  unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 96));
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 96));
  uint64_t v21 = BytePtr;
  if (*(unsigned char *)(a1 + 88) == 4)
  {
    unsigned int v22 = *(_DWORD *)(a1 + 104);
    uint64_t v21 = &BytePtr[v22 * (unint64_t)v12];
    Length -= v22 * (unint64_t)v12;
  }
  if (*(unsigned char *)(a1 + 131))
  {
    if (v11)
    {
      int v23 = 0;
      while (1)
      {
        int v24 = v9 + v23 * *(unsigned __int8 *)(a1 + 130);
        if (v12 * (unint64_t)(v24 + 1) > Length) {
          break;
        }
        switch(v12)
        {
          case 4u:
            int v25 = *(_DWORD *)&v21[4 * v24];
            break;
          case 2u:
            int v25 = *(unsigned __int16 *)&v21[2 * v24];
            break;
          case 1u:
            int v25 = v21[v24];
            break;
          default:
            sub_1B63F2F54(17, @"Assertion '%s' failed. %s - unsupported index size (%ld)", v15, v16, v17, v18, v19, v20, (uint64_t)"false");
            goto LABEL_10;
        }
LABEL_11:
        int v26 = v8 + v23 * *(unsigned __int8 *)(a1 + 130);
        if (v12 * (unint64_t)(v26 + 1) <= Length)
        {
          switch(v12)
          {
            case 4u:
              int v27 = *(_DWORD *)&v21[4 * v26];
              goto LABEL_14;
            case 2u:
              int v27 = *(unsigned __int16 *)&v21[2 * v26];
              goto LABEL_14;
            case 1u:
              int v27 = v21[v26];
              goto LABEL_14;
          }
          sub_1B63F2F54(17, @"Assertion '%s' failed. %s - unsupported index size (%ld)", v15, v16, v17, v18, v19, v20, (uint64_t)"false");
        }
        else
        {
          sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v15, v16, v17, v18, v19, v20, v8 + v23 * *(unsigned __int8 *)(a1 + 130));
        }
        int v27 = 0;
LABEL_14:
        if (v25 != v27) {
          return 0;
        }
        if (v11 == ++v23) {
          return 1;
        }
      }
      sub_1B63F2F54(16, @"Error: __readIndexInBuffer - index (%u) out of bounds (%lu)", v15, v16, v17, v18, v19, v20, v9 + v23 * *(unsigned __int8 *)(a1 + 130));
LABEL_10:
      int v25 = 0;
      goto LABEL_11;
    }
  }
  else if (memcmp(&v21[v12 * (unint64_t)(v11 * v9)], &v21[v12 * (unint64_t)(v11 * v8)], v11 * (unint64_t)v12))
  {
    return 0;
  }
  return 1;
}

uint64_t sub_1B63D1960(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  unsigned int v9 = *(unsigned __int8 *)(a1 + 130);
  if (v9 < 2) {
    return 1;
  }
  for (unsigned __int8 i = 1; i < v9; ++i)
  {
    uint64_t result = sub_1B63D1748(a1, 0, i, a4, a5, a6, a7, a8);
    if (!result) {
      break;
    }
  }
  return result;
}

uint64_t sub_1B63D19E8(uint64_t result)
{
  if (*(void *)(result + 72)) {
    return *(void *)(result + 72);
  }
  return result;
}

uint64_t sub_1B63D19F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  return *(unsigned int *)(a1 + 64);
}

uint64_t sub_1B63D1A44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  return *(unsigned int *)(a1 + 68);
}

uint64_t sub_1B63D1A90()
{
  uint64_t result = sub_1B63D0314();
  *(unsigned char *)(result + 82) = 1;
  return result;
}

BOOL sub_1B63D1AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  return *(unsigned char *)(a1 + 82) != 0;
}

void sub_1B63D1B04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  *(void *)(a1 + 160) = a2;
}

uint64_t sub_1B63D1B54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  return *(void *)(a1 + 160);
}

uint64_t sub_1B63D1BA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  return *(unsigned __int8 *)(a1 + 80);
}

void sub_1B63D1BEC(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  uint64_t v8[2] = sub_1B63D2750;
  v8[3] = &unk_1E6140F38;
  v8[4] = a2;
  sub_1B63D1C5C(a1, 1, (uint64_t)v8, a4, a5, a6, a7, a8);
}

void sub_1B63D1C5C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v131 = a3;
  uint64_t v136 = *MEMORY[0x1E4F143B8];
  int v8 = *((unsigned __int8 *)a1 + 26);
  int v9 = (char)v8;
  uint64_t v132 = *((unsigned int *)a1 + 2);
  uint64_t v10 = *((unsigned __int8 *)a1 + 27);
  uint64_t v11 = a1[4];
  char v133 = 0;
  unsigned int v12 = a2;
  switch(v8)
  {
    case 0:
    case 1:
    case 5:
      if (a2 == 1)
      {
        if (v132)
        {
          uint64_t v14 = 0;
          uint64_t v15 = 0;
          uint64_t v16 = *a1;
          uint64_t v18 = a1[5];
          uint64_t v17 = a1[6];
          while (1)
          {
            if (v9)
            {
              if (v15) {
                uint64_t v19 = 1;
              }
              else {
                uint64_t v19 = 2;
              }
              if (v15) {
                uint64_t v20 = 2;
              }
              else {
                uint64_t v20 = 1;
              }
              uint64_t v21 = v9 == 1 || v9 != 5;
              uint64_t v22 = 1;
              if (v9 == 1) {
                uint64_t v23 = v19;
              }
              else {
                uint64_t v23 = 2;
              }
              if (v9 == 1) {
                uint64_t v24 = v20;
              }
              else {
                uint64_t v24 = 1;
              }
              if (!v16)
              {
LABEL_27:
                int v27 = v22 * v15;
                LODWORD(v134[0]) = v15 * v21;
                DWORD1(v134[0]) = v24 + v27;
                int v26 = v27 + v23;
                goto LABEL_30;
              }
            }
            else
            {
              uint64_t v21 = 3;
              uint64_t v22 = 3;
              uint64_t v23 = 2;
              uint64_t v24 = 1;
              if (!v16) {
                goto LABEL_27;
              }
            }
            switch(v10)
            {
              case 4:
                LODWORD(v134[0]) = *(_DWORD *)(v16 + 4 * (v18 + v14 * v21));
                uint64_t v28 = v22 * v15;
                DWORD1(v134[0]) = *(_DWORD *)(v16 + 4 * (v18 + (v24 + v28) * v17));
                int v26 = *(_DWORD *)(v16 + 4 * (v18 + (v28 + v23) * v17));
                goto LABEL_30;
              case 2:
                LODWORD(v134[0]) = *(unsigned __int16 *)(v16 + 2 * (v18 + v14 * v21));
                uint64_t v29 = v22 * v15;
                DWORD1(v134[0]) = *(unsigned __int16 *)(v16 + 2 * (v18 + (v24 + v29) * v17));
                int v26 = *(unsigned __int16 *)(v16 + 2 * (v18 + (v29 + v23) * v17));
                goto LABEL_30;
              case 1:
                LODWORD(v134[0]) = *(unsigned __int8 *)(v16 + v18 + v14 * v21);
                uint64_t v25 = v22 * v15;
                DWORD1(v134[0]) = *(unsigned __int8 *)(v16 + v18 + (v24 + v25) * v17);
                int v26 = *(unsigned __int8 *)(v16 + v18 + (v25 + v23) * v17);
LABEL_30:
                DWORD2(v134[0]) = v26;
                goto LABEL_31;
            }
            *(void *)&v134[0] = 0;
            DWORD2(v134[0]) = 0;
            sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", a3, a4, a5, a6, a7, a8, v10);
LABEL_31:
            (*(void (**)(uint64_t, uint64_t, _OWORD *, uint64_t, char *))(v131 + 16))(v131, v15, v134, 3, &v133);
            if (!v133)
            {
              ++v15;
              v14 += v17;
              if (v132 != v15) {
                continue;
              }
            }
            return;
          }
        }
      }
      else
      {
        long long v130 = v129;
        v33.n128_f64[0] = MEMORY[0x1F4188790](a1, a2);
        int v35 = (char *)v129 - v34;
        if (v132)
        {
          uint64_t v36 = 0;
          do
          {
            if (v12)
            {
              uint64_t v37 = 0;
              uint64_t v38 = a1;
              do
              {
                long long v39 = *((_OWORD *)v38 + 1);
                v134[0] = *(_OWORD *)v38;
                v134[1] = v39;
                v134[2] = *((_OWORD *)v38 + 2);
                uint64_t v135 = v38[6];
                sub_1B63D28DC((uint64_t *)v134, v36, &v35[v37], &v35[4 * v12 + v37], &v35[8 * v12 + v37], v30, v31, v32);
                v37 += 4;
                v38 += 7;
              }
              while (4 * v12 != v37);
            }
            (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *, __n128))(v131 + 16))(v131, v36, v35, 3, &v133, v33);
            if (v133) {
              break;
            }
            ++v36;
          }
          while (v36 != v132);
        }
      }
      return;
    case 2:
      if (a2 == 1)
      {
        if (!v132) {
          return;
        }
        uint64_t v40 = 0;
        uint64_t v41 = *a1;
        unsigned int v42 = 1;
        uint64_t v44 = a1[5];
        uint64_t v43 = a1[6];
        while (1)
        {
          switch(v10)
          {
            case 1:
              LODWORD(v134[0]) = *(unsigned __int8 *)(v41 + v44 + v43 * (v42 - 1));
              int v45 = *(unsigned __int8 *)(v41 + v44 + v43 * v42);
              break;
            case 2:
              LODWORD(v134[0]) = *(unsigned __int16 *)(v41 + 2 * (v44 + v43 * (v42 - 1)));
              int v45 = *(unsigned __int16 *)(v41 + 2 * (v44 + v43 * v42));
              break;
            case 4:
              LODWORD(v134[0]) = *(_DWORD *)(v41 + 4 * (v44 + v43 * (v42 - 1)));
              int v45 = *(_DWORD *)(v41 + 4 * (v44 + v43 * v42));
              break;
            default:
              goto LABEL_54;
          }
          DWORD1(v134[0]) = v45;
LABEL_54:
          (*(void (**)(uint64_t, uint64_t, _OWORD *, uint64_t, char *))(v131 + 16))(v131, v40, v134, 2, &v133);
          if (!v133)
          {
            ++v40;
            v42 += 2;
            if (v132 != v40) {
              continue;
            }
          }
          return;
        }
      }
      v95.n128_f64[0] = MEMORY[0x1F4188790](a1, a2);
      uint64_t v97 = (char *)v129 - v96;
      if (v132)
      {
        uint64_t v98 = 0;
        uint64_t v99 = 4 * v12;
        uint64_t v100 = &v97[v99];
        do
        {
          if (v10 == 1)
          {
            if (v12)
            {
              uint64_t v106 = 0;
              uint64_t v107 = a1 + 6;
              do
              {
                uint64_t v108 = *(v107 - 6);
                uint64_t v109 = *(v107 - 1);
                uint64_t v110 = *v107;
                *(_DWORD *)&v97[v106] = *(unsigned __int8 *)(v108 + v109 + *v107 * (2 * v98));
                *(_DWORD *)&v100[v106] = *(unsigned __int8 *)(v108 + v109 + v110 * ((2 * v98) | 1u));
                v106 += 4;
                v107 += 7;
              }
              while (v99 != v106);
            }
          }
          else if (v10 == 2)
          {
            if (v12)
            {
              uint64_t v111 = 0;
              char v112 = a1 + 6;
              do
              {
                uint64_t v113 = *(v112 - 6);
                uint64_t v114 = *(v112 - 1);
                uint64_t v115 = *v112;
                *(_DWORD *)&v97[v111] = *(unsigned __int16 *)(v113 + 2 * (v114 + *v112 * (2 * v98)));
                *(_DWORD *)&v100[v111] = *(unsigned __int16 *)(v113 + 2 * (v114 + v115 * ((2 * v98) | 1u)));
                v111 += 4;
                v112 += 7;
              }
              while (v99 != v111);
            }
          }
          else if (v10 == 4 && v12)
          {
            uint64_t v101 = 0;
            uint64_t v102 = a1 + 6;
            do
            {
              uint64_t v103 = *(v102 - 6);
              uint64_t v104 = *(v102 - 1);
              uint64_t v105 = *v102;
              *(_DWORD *)&v97[v101] = *(_DWORD *)(v103 + 4 * (v104 + *v102 * (2 * v98)));
              *(_DWORD *)&v100[v101] = *(_DWORD *)(v103 + 4 * (v104 + v105 * ((2 * v98) | 1u)));
              v101 += 4;
              v102 += 7;
            }
            while (v99 != v101);
          }
          (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *, __n128))(v131 + 16))(v131, v98, v97, 2, &v133, v95);
          if (v133) {
            break;
          }
          ++v98;
        }
        while (v98 != v132);
      }
      return;
    case 3:
      if (a2 == 1)
      {
        uint64_t v46 = *a1;
        uint64_t v48 = a1[5];
        uint64_t v47 = a1[6];
        LODWORD(v134[0]) = 0;
        if (!v132) {
          return;
        }
        uint64_t v49 = 0;
        while (1)
        {
          switch(v10)
          {
            case 4:
              int v50 = *(_DWORD *)(v46 + 4 * v48);
              break;
            case 2:
              int v50 = *(unsigned __int16 *)(v46 + 2 * v48);
              break;
            case 1:
              int v50 = *(unsigned __int8 *)(v46 + v48);
              break;
            default:
              goto LABEL_67;
          }
          LODWORD(v134[0]) = v50;
LABEL_67:
          (*(void (**)(uint64_t, uint64_t, _OWORD *, uint64_t, char *))(v131 + 16))(v131, v49, v134, 1, &v133);
          if (!v133)
          {
            ++v49;
            v48 += v47;
            if (v132 != v49) {
              continue;
            }
          }
          return;
        }
      }
      v116.n128_f64[0] = MEMORY[0x1F4188790](a1, a2);
      uint64_t v118 = (char *)v129 - v117;
      if (v132)
      {
        for (uint64_t i = 0; i != v132; ++i)
        {
          switch(v10)
          {
            case 1:
              if (v12)
              {
                uint64_t v123 = v12;
                uint64_t v124 = v118;
                uint64_t v125 = a1 + 6;
                do
                {
                  *(_DWORD *)uint64_t v124 = *(unsigned __int8 *)(*(v125 - 6) + *(v125 - 1) + *v125 * i);
                  v124 += 4;
                  v125 += 7;
                  --v123;
                }
                while (v123);
              }
              break;
            case 2:
              uint64_t v126 = v12;
              long long v127 = v118;
              uint64_t v128 = a1 + 6;
              if (v12)
              {
                do
                {
                  *(_DWORD *)long long v127 = *(unsigned __int16 *)(*(v128 - 6) + 2 * (*(v128 - 1) + *v128 * i));
                  v127 += 4;
                  v128 += 7;
                  --v126;
                }
                while (v126);
              }
              break;
            case 4:
              uint64_t v120 = v12;
              uint64_t v121 = v118;
              uint64_t v122 = a1 + 6;
              if (v12)
              {
                do
                {
                  *(_DWORD *)uint64_t v121 = *(_DWORD *)(*(v122 - 6) + 4 * (*(v122 - 1) + *v122 * i));
                  v121 += 4;
                  v122 += 7;
                  --v120;
                }
                while (v120);
              }
              break;
          }
          (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *, __n128))(v131 + 16))(v131, i, v118, 1, &v133, v116);
          if (v133) {
            break;
          }
        }
      }
      return;
    case 4:
      if (!v132) {
        return;
      }
      uint64_t v51 = 0;
      unsigned int v52 = 0;
      v129[0] = v11;
      v129[1] = v131 + 16;
      while (2)
      {
        switch(v10)
        {
          case 4:
            uint64_t v53 = *(unsigned int *)(v11 + 4 * v51);
            break;
          case 2:
            uint64_t v53 = *(unsigned __int16 *)(v11 + 2 * v51);
            break;
          case 1:
            uint64_t v53 = *(unsigned __int8 *)(v11 + v51);
            break;
          default:
            LODWORD(v53) = 0;
            goto LABEL_86;
        }
        if (v53 <= 2)
        {
LABEL_86:
          sub_1B63F2F54(16, @"Error: unexpected vertex count", a3, a4, a5, a6, a7, a8, v129[0]);
          goto LABEL_114;
        }
        if (v12 == 1)
        {
          v59.n128_f64[0] = MEMORY[0x1F4188790](56, a2);
          if (v10 == 1)
          {
            unsigned int v75 = v52;
            uint64_t v76 = (_DWORD *)((char *)v129 - v58);
            do
            {
              *v76++ = *(unsigned __int8 *)(v54 + v55 + v57 * v75++);
              --v56;
            }
            while (v56);
          }
          else if (v10 == 2)
          {
            unsigned int v77 = v52;
            uint64_t v78 = (_DWORD *)((char *)v129 - v58);
            do
            {
              *v78++ = *(unsigned __int16 *)(v54 + 2 * (v55 + v57 * v77++));
              --v56;
            }
            while (v56);
          }
          else
          {
            unsigned int v60 = v52;
            char v61 = (_DWORD *)((char *)v129 - v58);
            do
            {
              *v61++ = *(_DWORD *)(v54 + 4 * (v55 + v57 * v60++));
              --v56;
            }
            while (v56);
          }
          (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *, __n128))(v131 + 16))(v131, v51, (char *)v129 - v58, v53, &v133, v59);
          uint64_t v11 = v129[0];
          if (v133) {
            return;
          }
LABEL_114:
          v52 += v53;
          if (++v51 == v132) {
            return;
          }
          continue;
        }
        break;
      }
      v63.n128_f64[0] = MEMORY[0x1F4188790](56, a2);
      uint64_t v65 = (char *)v129 - v64;
      long long v130 = v66;
      if (v10 == 1)
      {
        if (v12)
        {
          for (uint64_t j = 0; j != v12; ++j)
          {
            uint64_t v80 = (uint64_t *)((char *)a1 + j * v62);
            uint64_t v81 = *v80;
            uint64_t v82 = v80[5];
            uint64_t v83 = v80[6];
            uint64_t v84 = v53;
            unsigned int v85 = v52;
            int v86 = j;
            do
            {
              *(_DWORD *)&v65[4 * v86] = *(unsigned __int8 *)(v81 + v82 + v83 * v85);
              v86 += v12;
              ++v85;
              --v84;
            }
            while (v84);
          }
        }
      }
      else if (v10 == 2)
      {
        if (v12)
        {
          for (uint64_t k = 0; k != v12; ++k)
          {
            uint64_t v88 = (uint64_t *)((char *)a1 + k * v62);
            uint64_t v89 = *v88;
            uint64_t v90 = v88[5];
            uint64_t v91 = v88[6];
            uint64_t v92 = v53;
            unsigned int v93 = v52;
            int v94 = k;
            do
            {
              *(_DWORD *)&v65[4 * v94] = *(unsigned __int16 *)(v89 + 2 * (v90 + v91 * v93));
              v94 += v12;
              ++v93;
              --v92;
            }
            while (v92);
          }
        }
      }
      else if (v12)
      {
        for (uint64_t m = 0; m != v12; ++m)
        {
          uint64_t v68 = (uint64_t *)((char *)a1 + m * v62);
          uint64_t v69 = *v68;
          uint64_t v70 = v68[5];
          uint64_t v71 = v68[6];
          uint64_t v72 = v53;
          unsigned int v73 = v52;
          int v74 = m;
          do
          {
            *(_DWORD *)&v65[4 * v74] = *(_DWORD *)(v69 + 4 * (v70 + v71 * v73));
            v74 += v12;
            ++v73;
            --v72;
          }
          while (v72);
        }
      }
      (*(void (**)(uint64_t, uint64_t, char *, uint64_t, char *, __n128))(v131 + 16))(v131, v51, v65, v53, &v133, v63);
      if (!v133) {
        goto LABEL_114;
      }
      return;
    default:
      sub_1B63F2F54(16, @"Unreachable code: Unknown primitive type %d", a3, a4, a5, a6, a7, a8, (char)v8);
      return;
  }
}

uint64_t sub_1B63D2750(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1B63D2760(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  uint64_t v8[2] = sub_1B63D27D0;
  v8[3] = &unk_1E6140F60;
  v8[4] = a2;
  sub_1B63D1C5C(a1, 1, (uint64_t)v8, a4, a5, a6, a7, a8);
}

void sub_1B63D27D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a4 == 3)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
  }
  else if (a4 < 4)
  {
    sub_1B63F2F54(16, @"Unreachable code: unexpected vertex count", a3, a4, a5, a6, a7, a8, a9);
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = (a4 - 2);
    do
    {
      if (v12 == v11) {
        break;
      }
      uint64_t v13 = v11 + 1;
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
      uint64_t v11 = v13;
    }
    while (!a5);
  }
}

void sub_1B63D28DC(uint64_t *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *((unsigned __int8 *)a1 + 26);
  uint64_t v9 = 3;
  if (a2) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = 2;
  }
  if (a2) {
    uint64_t v11 = 2;
  }
  else {
    uint64_t v11 = 1;
  }
  BOOL v12 = v8 != 5;
  BOOL v13 = v8 == 1 || v8 != 5;
  if (v8 != 1)
  {
    uint64_t v10 = 2;
    uint64_t v11 = 1;
  }
  BOOL v14 = v8 == 0;
  if (*((unsigned char *)a1 + 26)) {
    uint64_t v15 = v13;
  }
  else {
    uint64_t v15 = 3;
  }
  if (*((unsigned char *)a1 + 26))
  {
    uint64_t v9 = 1;
    uint64_t v16 = v10;
  }
  else
  {
    uint64_t v16 = 2;
  }
  if (v14) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = v11;
  }
  uint64_t v18 = *a1;
  if (!*a1)
  {
    *a3 = v15 * a2;
    *a4 = v17 + v9 * a2;
    int v23 = v9 * a2 + v16;
    goto LABEL_29;
  }
  uint64_t v19 = *((unsigned __int8 *)a1 + 27);
  switch(v19)
  {
    case 4:
      uint64_t v24 = a1[5];
      uint64_t v25 = a1[6];
      *a3 = *(_DWORD *)(v18 + 4 * (v24 + v15 * a2 * v25));
      uint64_t v26 = v9 * a2;
      *a4 = *(_DWORD *)(v18 + 4 * (v24 + v25 * (v17 + v26)));
      int v23 = *(_DWORD *)(v18 + 4 * (v24 + v25 * (v26 + v16)));
      goto LABEL_29;
    case 2:
      uint64_t v27 = a1[5];
      uint64_t v28 = a1[6];
      *a3 = *(unsigned __int16 *)(v18 + 2 * (v27 + v15 * a2 * v28));
      uint64_t v29 = v9 * a2;
      *a4 = *(unsigned __int16 *)(v18 + 2 * (v27 + v28 * (v17 + v29)));
      int v23 = *(unsigned __int16 *)(v18 + 2 * (v27 + v28 * (v29 + v16)));
      goto LABEL_29;
    case 1:
      uint64_t v20 = a1[5];
      uint64_t v21 = a1[6];
      *a3 = *(unsigned __int8 *)(v18 + v20 + v15 * a2 * v21);
      uint64_t v22 = v9 * a2;
      *a4 = *(unsigned __int8 *)(v18 + v20 + v21 * (v17 + v22));
      int v23 = *(unsigned __int8 *)(v18 + v20 + v21 * (v22 + v16));
LABEL_29:
      *a5 = v23;
      return;
  }
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, 1, v12, a8, v19);
}

void sub_1B63D2A6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1;
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 16))
  {
    long long v32 = *(_OWORD *)(a1 + 16);
    v102[0] = *(_OWORD *)a1;
    v102[1] = v32;
    v102[2] = *(_OWORD *)(a1 + 32);
    uint64_t v103 = *(void *)(a1 + 48);
    v101[0] = MEMORY[0x1E4F143A8];
    v101[1] = 0x40000000;
    v101[2] = sub_1B63D2750;
    v101[3] = &unk_1E6140F38;
    _OWORD v101[4] = a2;
    sub_1B63D1C5C((uint64_t *)v102, 1, (uint64_t)v101, a4, a5, a6, a7, a8);
    return;
  }
  LOBYTE(v101[0]) = 0;
  switch(*(unsigned char *)(a1 + 26))
  {
    case 0:
    case 1:
    case 5:
      DWORD2(v102[0]) = 0;
      *(void *)&v102[0] = 0;
      unsigned int v10 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24)) {
        return;
      }
      unint64_t v11 = 0;
      do
      {
        BOOL v12 = (void *)(*(void *)(v9 + 16) + 16 * v11);
        uint64_t v13 = v12[1];
        if (*v12 >= v13 + *v12) {
          goto LABEL_37;
        }
        uint64_t v14 = *v12;
        do
        {
          int v15 = *(unsigned __int8 *)(v9 + 26);
          if (*(unsigned char *)(v9 + 26))
          {
            if (v14) {
              uint64_t v16 = 1;
            }
            else {
              uint64_t v16 = 2;
            }
            if (v14) {
              uint64_t v17 = 2;
            }
            else {
              uint64_t v17 = 1;
            }
            BOOL v18 = v15 == 1;
            uint64_t v19 = v15 == 1 || v15 != 5;
            uint64_t v20 = 1;
            if (v15 == 1) {
              uint64_t v21 = v16;
            }
            else {
              uint64_t v21 = 2;
            }
            if (v18) {
              uint64_t v22 = v17;
            }
            else {
              uint64_t v22 = 1;
            }
          }
          else
          {
            uint64_t v19 = 3;
            uint64_t v20 = 3;
            uint64_t v21 = 2;
            uint64_t v22 = 1;
          }
          uint64_t v23 = *(void *)v9;
          if (!*(void *)v9)
          {
            int v29 = v20 * v14;
            LODWORD(v102[0]) = v14 * v19;
            DWORD1(v102[0]) = v22 + v29;
            int v28 = v29 + v21;
            goto LABEL_32;
          }
          uint64_t v24 = *(unsigned __int8 *)(v9 + 27);
          uint64_t v25 = *(void *)(v9 + 40);
          uint64_t v26 = *(void *)(v9 + 48);
          switch(v24)
          {
            case 4:
              LODWORD(v102[0]) = *(_DWORD *)(v23 + 4 * (v25 + v26 * v14 * v19));
              uint64_t v30 = v20 * v14;
              DWORD1(v102[0]) = *(_DWORD *)(v23 + 4 * (v25 + (v22 + v30) * v26));
              int v28 = *(_DWORD *)(v23 + 4 * (v25 + (v30 + v21) * v26));
              goto LABEL_32;
            case 2:
              LODWORD(v102[0]) = *(unsigned __int16 *)(v23 + 2 * (v25 + v26 * v14 * v19));
              uint64_t v31 = v20 * v14;
              DWORD1(v102[0]) = *(unsigned __int16 *)(v23 + 2 * (v25 + (v22 + v31) * v26));
              int v28 = *(unsigned __int16 *)(v23 + 2 * (v25 + (v31 + v21) * v26));
              goto LABEL_32;
            case 1:
              LODWORD(v102[0]) = *(unsigned __int8 *)(v23 + v25 + v26 * v14 * v19);
              uint64_t v27 = v20 * v14;
              DWORD1(v102[0]) = *(unsigned __int8 *)(v23 + v25 + (v22 + v27) * v26);
              int v28 = *(unsigned __int8 *)(v23 + v25 + (v27 + v21) * v26);
LABEL_32:
              DWORD2(v102[0]) = v28;
              goto LABEL_33;
          }
          *(void *)&v102[0] = 0;
          DWORD2(v102[0]) = 0;
          sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", a3, a4, a5, a6, a7, a8, v24);
LABEL_33:
          (*(void (**)(uint64_t, uint64_t, _OWORD *, uint64_t, void *))(a2 + 16))(a2, v14, v102, 3, v101);
          if (LOBYTE(v101[0])) {
            return;
          }
          ++v14;
          LODWORD(v13) = v13 - 1;
        }
        while (v13);
        unsigned int v10 = *(unsigned __int16 *)(v9 + 24);
LABEL_37:
        ++v11;
      }
      while (v11 < v10);
      return;
    case 2:
      *(void *)&v102[0] = 0;
      unsigned int v33 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24)) {
        return;
      }
      uint64_t v34 = 0;
      while (1)
      {
        int v35 = (uint64_t *)(*(void *)(v9 + 16) + 16 * v34);
        uint64_t v36 = *v35;
        uint64_t v37 = v35[1] + *v35;
        if (v36 < v37) {
          break;
        }
LABEL_56:
        if (++v34 >= (unint64_t)v33) {
          return;
        }
      }
      uint64_t v38 = v36;
      unsigned int v39 = 2 * v36;
      unint64_t v40 = v37 - (unint64_t)v36;
      while (1)
      {
        int v41 = *(unsigned __int8 *)(v9 + 27);
        if (v41 == 1) {
          break;
        }
        if (v41 == 2)
        {
          uint64_t v49 = *(void *)v9;
          uint64_t v50 = *(void *)(v9 + 40);
          uint64_t v51 = *(void *)(v9 + 48);
          LODWORD(v102[0]) = *(unsigned __int16 *)(*(void *)v9 + 2 * (v50 + v51 * v39));
          int v45 = *(unsigned __int16 *)(v49 + 2 * (v50 + v51 * (v39 + 1)));
          goto LABEL_52;
        }
        if (v41 == 4)
        {
          uint64_t v42 = *(void *)v9;
          uint64_t v43 = *(void *)(v9 + 40);
          uint64_t v44 = *(void *)(v9 + 48);
          LODWORD(v102[0]) = *(_DWORD *)(*(void *)v9 + 4 * (v43 + v44 * v39));
          int v45 = *(_DWORD *)(v42 + 4 * (v43 + v44 * (v39 + 1)));
LABEL_52:
          DWORD1(v102[0]) = v45;
        }
        (*(void (**)(uint64_t, uint64_t, _OWORD *, uint64_t, void *))(a2 + 16))(a2, v38, v102, 2, v101);
        if (LOBYTE(v101[0])) {
          return;
        }
        ++v38;
        v39 += 2;
        if (!--v40)
        {
          unsigned int v33 = *(unsigned __int16 *)(v9 + 24);
          goto LABEL_56;
        }
      }
      uint64_t v46 = *(void *)v9;
      uint64_t v47 = *(void *)(v9 + 40);
      uint64_t v48 = *(void *)(v9 + 48);
      LODWORD(v102[0]) = *(unsigned __int8 *)(*(void *)v9 + v47 + v48 * v39);
      int v45 = *(unsigned __int8 *)(v46 + v47 + v48 * (v39 + 1));
      goto LABEL_52;
    case 3:
      LODWORD(v102[0]) = 0;
      unsigned int v52 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24)) {
        return;
      }
      uint64_t v53 = 0;
      while (1)
      {
        uint64_t v54 = (uint64_t *)(*(void *)(v9 + 16) + 16 * v53);
        uint64_t v55 = *v54;
        uint64_t v56 = v54[1] + *v54;
        if (v55 < v56) {
          break;
        }
LABEL_72:
        if (++v53 >= (unint64_t)v52) {
          return;
        }
      }
      uint64_t v57 = v55;
      uint64_t v58 = v56;
      while (1)
      {
        int v59 = *(unsigned __int8 *)(v9 + 27);
        if (v59 == 4) {
          break;
        }
        if (v59 == 2)
        {
          int v60 = *(unsigned __int16 *)(*(void *)v9 + 2 * (*(void *)(v9 + 40) + *(void *)(v9 + 48) * v57));
          goto LABEL_68;
        }
        if (v59 == 1)
        {
          int v60 = *(unsigned __int8 *)(*(void *)v9 + *(void *)(v9 + 40) + *(void *)(v9 + 48) * v57);
LABEL_68:
          LODWORD(v102[0]) = v60;
        }
        (*(void (**)(uint64_t, uint64_t, _OWORD *, uint64_t, void *))(a2 + 16))(a2, v57, v102, 1, v101);
        if (LOBYTE(v101[0])) {
          return;
        }
        if (v58 == ++v57)
        {
          unsigned int v52 = *(unsigned __int16 *)(v9 + 24);
          goto LABEL_72;
        }
      }
      int v60 = *(_DWORD *)(*(void *)v9 + 4 * (*(void *)(v9 + 40) + *(void *)(v9 + 48) * v57));
      goto LABEL_68;
    case 4:
      unsigned int v61 = *(unsigned __int16 *)(a1 + 24);
      if (!*(_WORD *)(a1 + 24)) {
        return;
      }
      uint64_t v62 = 0;
      uint64_t v100 = a2 + 16;
      while (2)
      {
        __n128 v63 = (uint64_t *)(*(void *)(v9 + 16) + 16 * v62);
        uint64_t v64 = *v63;
        if (*v63)
        {
          uint64_t v65 = 0;
          unsigned int v66 = 0;
          int v67 = *(unsigned __int8 *)(v9 + 27);
          do
          {
            switch(v67)
            {
              case 4:
                int v68 = *(_DWORD *)(*(void *)(v9 + 32) + 4 * v65);
                break;
              case 2:
                int v68 = *(unsigned __int16 *)(*(void *)(v9 + 32) + 2 * v65);
                break;
              case 1:
                int v68 = *(unsigned __int8 *)(*(void *)(v9 + 32) + v65);
                break;
              default:
                int v68 = 0;
                break;
            }
            v66 += v68;
            ++v65;
          }
          while (*v63 != v65);
        }
        else
        {
          unsigned int v66 = 0;
        }
        uint64_t v69 = v63[1] + v64;
        if (v64 >= v69) {
          goto LABEL_115;
        }
        uint64_t v70 = v64;
        uint64_t v71 = v69;
LABEL_90:
        int v72 = *(unsigned __int8 *)(v9 + 27);
        switch(v72)
        {
          case 4:
            uint64_t v73 = *(unsigned int *)(*(void *)(v9 + 32) + 4 * v70);
            break;
          case 2:
            uint64_t v73 = *(unsigned __int16 *)(*(void *)(v9 + 32) + 2 * v70);
            break;
          case 1:
            uint64_t v73 = *(unsigned __int8 *)(*(void *)(v9 + 32) + v70);
            break;
          default:
            LODWORD(v73) = 0;
            goto LABEL_104;
        }
        if (v73 > 2)
        {
          v76.n128_f64[0] = MEMORY[0x1F4188790](a1, a2);
          unsigned int v77 = (char *)&v101[-1] - v75;
          uint64_t v78 = *(unsigned __int8 *)(v9 + 27);
          switch(v78)
          {
            case 4:
              uint64_t v84 = *(void *)v9;
              unsigned int v85 = v66;
              int v86 = (_DWORD *)((char *)&v101[-1] - v75);
              uint64_t v87 = *(void *)(v9 + 40);
              uint64_t v88 = *(void *)(v9 + 48);
              do
              {
                *v86++ = *(_DWORD *)(v84 + 4 * (v87 + v88 * v85++));
                --v74;
              }
              while (v74);
              break;
            case 2:
              uint64_t v89 = *(void *)v9;
              unsigned int v90 = v66;
              uint64_t v91 = (_DWORD *)((char *)&v101[-1] - v75);
              uint64_t v92 = *(void *)(v9 + 40);
              uint64_t v93 = *(void *)(v9 + 48);
              do
              {
                *v91++ = *(unsigned __int16 *)(v89 + 2 * (v92 + v93 * v90++));
                --v74;
              }
              while (v74);
              break;
            case 1:
              uint64_t v79 = *(void *)v9;
              unsigned int v80 = v66;
              uint64_t v81 = (_DWORD *)((char *)&v101[-1] - v75);
              uint64_t v82 = *(void *)(v9 + 40);
              uint64_t v83 = *(void *)(v9 + 48);
              do
              {
                *v81++ = *(unsigned __int8 *)(v79 + v82 + v83 * v80++);
                --v74;
              }
              while (v74);
              break;
            default:
              bzero((char *)&v101[-1] - v75, 4 * v74);
              sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", v94, v95, v96, v97, v98, v99, v78);
              break;
          }
          a1 = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t, void *, __n128))(a2 + 16))(a2, v70, v77, v73, v101, v76);
          if (LOBYTE(v101[0])) {
            return;
          }
LABEL_113:
          v66 += v73;
          if (++v70 == v71)
          {
            unsigned int v61 = *(unsigned __int16 *)(v9 + 24);
LABEL_115:
            if (++v62 >= (unint64_t)v61) {
              return;
            }
            continue;
          }
          goto LABEL_90;
        }
        break;
      }
LABEL_104:
      sub_1B63F2F54(16, @"Error: unexpected vertex count", a3, a4, a5, a6, a7, a8, v100);
      goto LABEL_113;
    default:
      sub_1B63F2F54(16, @"Unreachable code: Unknown primitive type %d", a3, a4, a5, a6, a7, a8, *(unsigned __int8 *)(a1 + 26));
      return;
  }
}

void sub_1B63D31CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  uint64_t v9 = *(unsigned __int8 *)(a1 + 130);
  if (*(unsigned char *)(a1 + 130))
  {
    uint64_t v10 = 0;
    char v11 = *(unsigned char *)(a1 + 88);
    do
    {
      fprintf((FILE *)*MEMORY[0x1E4F143D8], "CHANNEL %ld/%ld\n", v10 + 1, v9);
      uint64_t v32 = 0;
      long long v30 = 0u;
      long long v31 = 0u;
      long long v29 = 0u;
      sub_1B63D11F0(a1, v10, v12, v13, v14, v15, v16, v17, (uint64_t)&v29);
      v27[0] = 0;
      v27[1] = v27;
      v27[2] = 0x2000000000;
      int v28 = 0;
      v25[0] = MEMORY[0x1E4F143A8];
      v25[1] = 0x40000000;
      v25[2] = sub_1B63D3374;
      void v25[3] = &unk_1E6140F88;
      char v26 = v11;
      v25[4] = v27;
      v23[0] = v29;
      v23[1] = v30;
      v23[2] = v31;
      uint64_t v24 = v32;
      v33[0] = MEMORY[0x1E4F143A8];
      v33[1] = 0x40000000;
      v33[2] = sub_1B63D2750;
      v33[3] = &unk_1E6140F38;
      v33[4] = v25;
      sub_1B63D1C5C((uint64_t *)v23, 1, (uint64_t)v33, v18, v19, v20, v21, v22);
      _Block_object_dispose(v27, 8);
      ++v10;
    }
    while (v9 != v10);
  }
}

uint64_t sub_1B63D3374(uint64_t result, uint64_t a2, int *a3, unsigned int a4)
{
  uint64_t v4 = result;
  switch(*(unsigned char *)(result + 40))
  {
    case 0:
    case 1:
    case 5:
      uint64_t result = fprintf((FILE *)*MEMORY[0x1E4F143D8], "%4u : %4u %4u %4u\n");
      break;
    case 2:
      uint64_t result = fprintf((FILE *)*MEMORY[0x1E4F143D8], "%4u : %4u %4u\n");
      break;
    case 3:
      uint64_t result = fprintf((FILE *)*MEMORY[0x1E4F143D8], "%4u : %4u\n");
      break;
    case 4:
      uint64_t v7 = (FILE **)MEMORY[0x1E4F143D8];
      fprintf((FILE *)*MEMORY[0x1E4F143D8], "%2u : [Polygon %4u]", *(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24), a4);
      if (a4)
      {
        uint64_t v8 = a4;
        do
        {
          int v9 = *a3++;
          fprintf(*v7, " %4u", v9);
          --v8;
        }
        while (v8);
      }
      uint64_t result = fputc(10, *v7);
      break;
    default:
      break;
  }
  ++*(_DWORD *)(*(void *)(*(void *)(v4 + 32) + 8) + 24);
  return result;
}

id sub_1B63D3504(uint64_t a1)
{
  uint64_t valuePtr = a1;
  uint64_t v2 = a1;
  if (!*(void *)(a1 + 72))
  {
    CFNumberRef v3 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
    LocalCenter = CFNotificationCenterGetLocalCenter();
    CFNotificationCenterPostNotification(LocalCenter, @"kCFXNotificationMeshElementWillDie", v3, 0, 1u);
    CFRelease(v3);
    uint64_t v2 = valuePtr;
  }
  unint64_t v5 = *(const void **)(v2 + 96);
  if (v5)
  {
    CFRelease(v5);
    uint64_t v2 = valuePtr;
    *(void *)(valuePtr + 96) = 0;
  }
  int v6 = *(const void **)(v2 + 168);
  if (v6)
  {
    CFRelease(v6);
    uint64_t v2 = valuePtr;
    *(void *)(valuePtr + 168) = 0;
  }
  uint64_t v7 = *(const void **)(v2 + 72);
  if (v7)
  {
    CFRelease(v7);
    uint64_t v2 = valuePtr;
    *(void *)(valuePtr + 72) = 0;
  }
  uint64_t v8 = *(const void **)(v2 + 136);
  if (v8)
  {
    CFRelease(v8);
    uint64_t v2 = valuePtr;
    *(void *)(valuePtr + 136) = 0;
  }
  free(*(void **)(v2 + 112));
  free(*(void **)(valuePtr + 120));
  free(*(void **)(valuePtr + 208));
  return sub_1B658325C(a1, v9, v10, v11, v12, v13, v14, v15);
}

__CFString *sub_1B63D35F8(uint64_t a1)
{
  CFSetRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  unint64_t v9 = *(char *)(a1 + 88);
  if (v9 > 5) {
    uint64_t v10 = @"invalid";
  }
  else {
    uint64_t v10 = off_1E6140FA8[v9];
  }
  uint64_t v11 = *(unsigned int *)(a1 + 104);
  uint64_t v12 = *(unsigned __int8 *)(a1 + 130);
  uint64_t v13 = *(unsigned __int8 *)(a1 + 80);
  uint64_t v14 = *(unsigned int *)(a1 + 64);
  float v15 = sub_1B65E2620(a1, 0x20uLL, v2, v3, v4, v5, v6, v7);
  uint64_t v16 = *(unsigned int *)(a1 + 68);
  CFDataRef Length = *(const __CFData **)(a1 + 96);
  if (Length) {
    CFDataRef Length = (const __CFData *)CFDataGetLength(Length);
  }
  CFStringAppendFormat(Mutable, 0, @"<CFXMeshElement %p type:%@ primCount:%d channels:%d indexBytes:%d offset:%d acmr:%f inst:%d dataSize:%d shared:%p>", a1, v10, v11, v12, v13, v14, v15, v16, Length, *(void *)(a1 + 72));
  return Mutable;
}

__CFArray *sub_1B63D36E4(uint64_t a1)
{
  CFSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v4 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
  uint64_t v5 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v41 = 1;
  int valuePtr = 5;
  uint64_t v40 = *(void *)(a1 + 96);
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v7 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v8 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v5, @"name", @"indexes");
  CFDictionarySetValue(v5, @"type", v6);
  CFDictionarySetValue(v5, @"address", v8);
  CFDictionarySetValue(v5, @"semantic", v7);
  CFArrayAppendValue(Mutable, v5);
  CFRelease(v7);
  CFRelease(v5);
  CFRelease(v8);
  CFRelease(v6);
  unint64_t v9 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 104;
  CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v11 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v9, @"name", @"subElementsCount");
  CFDictionarySetValue(v9, @"type", v10);
  CFDictionarySetValue(v9, @"address", v12);
  CFDictionarySetValue(v9, @"semantic", v11);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v11);
  CFRelease(v9);
  CFRelease(v12);
  CFRelease(v10);
  uint64_t v13 = v4;
  uint64_t v14 = CFDictionaryCreateMutable(0, 4, v3, v4);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 88;
  CFNumberRef v15 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v16 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v17 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v14, @"name", @"type");
  CFDictionarySetValue(v14, @"type", v15);
  CFDictionarySetValue(v14, @"address", v17);
  CFDictionarySetValue(v14, @"semantic", v16);
  CFArrayAppendValue(Mutable, v14);
  CFRelease(v16);
  CFRelease(v14);
  CFRelease(v17);
  CFRelease(v15);
  uint64_t v18 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
  uint64_t v19 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], v13);
  int v41 = 0;
  int valuePtr = 2;
  uint64_t v40 = a1 + 80;
  CFNumberRef v20 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v21 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v22 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v19, @"name", @"bytesPerIndex");
  CFDictionarySetValue(v19, @"type", v20);
  CFDictionarySetValue(v19, @"address", v22);
  CFDictionarySetValue(v19, @"semantic", v21);
  CFArrayAppendValue(Mutable, v19);
  CFRelease(v21);
  CFRelease(v19);
  CFRelease(v22);
  CFRelease(v20);
  uint64_t v23 = CFDictionaryCreateMutable(0, 4, v18, MEMORY[0x1E4F1D540]);
  int v41 = 0;
  int valuePtr = 3;
  uint64_t v40 = a1 + 81;
  CFNumberRef v24 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v25 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v26 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v23, @"name", @"doubleSided");
  CFDictionarySetValue(v23, @"type", v24);
  CFDictionarySetValue(v23, @"address", v26);
  CFDictionarySetValue(v23, @"semantic", v25);
  CFArrayAppendValue(Mutable, v23);
  CFRelease(v25);
  CFRelease(v23);
  CFRelease(v26);
  CFRelease(v24);
  uint64_t v27 = CFDictionaryCreateMutable(0, 4, v18, MEMORY[0x1E4F1D540]);
  int v41 = 1;
  int valuePtr = 5;
  uint64_t v40 = *(void *)(a1 + 168);
  CFNumberRef v28 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v29 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v30 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v27, @"name", @"primitiveNormals");
  CFDictionarySetValue(v27, @"type", v28);
  CFDictionarySetValue(v27, @"address", v30);
  CFDictionarySetValue(v27, @"semantic", v29);
  CFArrayAppendValue(Mutable, v27);
  CFRelease(v29);
  CFRelease(v27);
  CFRelease(v30);
  CFRelease(v28);
  long long v31 = CFDictionaryCreateMutable(0, 4, v18, MEMORY[0x1E4F1D540]);
  int v41 = 0;
  int valuePtr = 8;
  uint64_t v40 = a1 + 176;
  CFNumberRef v32 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v33 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v34 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v31, @"name", @"bbox[0]");
  CFDictionarySetValue(v31, @"type", v32);
  CFDictionarySetValue(v31, @"address", v34);
  CFDictionarySetValue(v31, @"semantic", v33);
  CFArrayAppendValue(Mutable, v31);
  CFRelease(v33);
  CFRelease(v31);
  CFRelease(v34);
  CFRelease(v32);
  int v35 = CFDictionaryCreateMutable(0, 4, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v41 = 0;
  int valuePtr = 8;
  uint64_t v40 = a1 + 192;
  CFNumberRef v36 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v37 = CFNumberCreate(0, kCFNumberSInt32Type, &v41);
  CFNumberRef v38 = CFNumberCreate(0, kCFNumberLongType, &v40);
  CFDictionarySetValue(v35, @"name", @"bbox[1]");
  CFDictionarySetValue(v35, @"type", v36);
  CFDictionarySetValue(v35, @"address", v38);
  CFDictionarySetValue(v35, @"semantic", v37);
  CFArrayAppendValue(Mutable, v35);
  CFRelease(v37);
  CFRelease(v35);
  CFRelease(v38);
  CFRelease(v36);
  return Mutable;
}

uint64_t sub_1B63D3E78@<X0>(uint64_t a1@<X0>, CFX::RG::RenderGraphProvider *a2@<X8>)
{
  uint64_t v5 = a1;
  CFX::RG::RenderGraphProvider::RenderGraphProvider(a2, "Forward");
  sub_1B63D3F20((uint64_t)a2, &v5);
  sub_1B63D3F8C((uint64_t)a2, &v5);
  sub_1B63D3FEC((uint64_t)a2, &v5);
  uint64_t v3 = sub_1B63D4054((uint64_t)a2, &v5);
  uint64_t result = sub_1B63D40B4((uint64_t)a2, &v5);
  *(_WORD *)(result + 24) = *((_WORD *)v3 + 4);
  *((unsigned char *)a2 + 41) = 1;
  return result;
}

void sub_1B63D3F04(_Unwind_Exception *a1)
{
  CFX::RG::RenderGraphProvider::~RenderGraphProvider(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B63D3F20(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = malloc_type_malloc(0x70uLL, 0xD5346062uLL);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  *uint64_t v4 = v5;
  v4[1] = v5;
  uint64_t v4[2] = v5;
  v4[3] = v5;
  v4[4] = v5;
  v4[5] = v5;
  v4[6] = v5;
  sub_1B63CF3E8((uint64_t)v4, *a2);
  uint64_t v8 = v6;
  sub_1B63D4868(a1 + 8, &v8);
  return v8;
}

void *sub_1B63D3F8C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = malloc_type_malloc(0x20uLL, 0xD5346062uLL);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  *uint64_t v4 = v5;
  v4[1] = v5;
  CFNumberRef v7 = sub_1B640DED4((uint64_t)v4, *a2);
  sub_1B63D4868(a1 + 8, &v7);
  return v7;
}

void *sub_1B63D3FEC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = malloc_type_malloc(0x28uLL, 0xD5346062uLL);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  *uint64_t v4 = v5;
  v4[1] = v5;
  *((void *)v4 + 4) = -1;
  CFNumberRef v7 = sub_1B63F5064((uint64_t)v4, *a2);
  sub_1B63D4868(a1 + 8, &v7);
  return v7;
}

void *sub_1B63D4054(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = malloc_type_malloc(0x20uLL, 0xD5346062uLL);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  *uint64_t v4 = v5;
  v4[1] = v5;
  CFNumberRef v7 = sub_1B6403CA4((uint64_t)v4, *a2);
  sub_1B63D4868(a1 + 8, &v7);
  return v7;
}

uint64_t sub_1B63D40B4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = malloc_type_malloc(0x28uLL, 0xD5346062uLL);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  *uint64_t v4 = v5;
  v4[1] = v5;
  *((void *)v4 + 4) = -1;
  uint64_t v7 = sub_1B64E0118((uint64_t)v4, *a2);
  sub_1B63D4868(a1 + 8, &v7);
  return v7;
}

uint64_t sub_1B63D411C@<X0>(uint64_t a1@<X0>, CFX::RG::RenderGraphProvider *a2@<X8>)
{
  uint64_t v5 = a1;
  CFX::RG::RenderGraphProvider::RenderGraphProvider(a2, "PathTracer");
  sub_1B63D41BC((uint64_t)a2, &v5);
  sub_1B63D421C((uint64_t)a2, &v5);
  sub_1B63D3F8C((uint64_t)a2, &v5);
  uint64_t v3 = sub_1B63D4054((uint64_t)a2, &v5);
  uint64_t result = sub_1B63D40B4((uint64_t)a2, &v5);
  *(_WORD *)(result + 24) = *((_WORD *)v3 + 4);
  return result;
}

void sub_1B63D41A0(_Unwind_Exception *a1)
{
  CFX::RG::RenderGraphProvider::~RenderGraphProvider(v1);
  _Unwind_Resume(a1);
}

void *sub_1B63D41BC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = malloc_type_malloc(0x20uLL, 0xD5346062uLL);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  *uint64_t v4 = v5;
  v4[1] = v5;
  uint64_t v7 = sub_1B65EF1D4((uint64_t)v4, *a2);
  sub_1B63D4868(a1 + 8, &v7);
  return v7;
}

void *sub_1B63D421C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = malloc_type_malloc(0x20uLL, 0xD5346062uLL);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  *uint64_t v4 = v5;
  v4[1] = v5;
  uint64_t v7 = sub_1B65F3C24((uint64_t)v4, *a2);
  sub_1B63D4868(a1 + 8, &v7);
  return v7;
}

uint64_t sub_1B63D427C@<X0>(uint64_t a1@<X0>, CFX::RG::RenderGraphProvider *a2@<X8>)
{
  uint64_t v5 = a1;
  CFX::RG::RenderGraphProvider::RenderGraphProvider(a2, "Hybrid");
  sub_1B63D41BC((uint64_t)a2, &v5);
  sub_1B63D431C((uint64_t)a2, &v5);
  sub_1B63D3F8C((uint64_t)a2, &v5);
  uint64_t v3 = sub_1B63D4054((uint64_t)a2, &v5);
  uint64_t result = sub_1B63D40B4((uint64_t)a2, &v5);
  *(_WORD *)(result + 24) = *((_WORD *)v3 + 4);
  return result;
}

void sub_1B63D4300(_Unwind_Exception *a1)
{
  CFX::RG::RenderGraphProvider::~RenderGraphProvider(v1);
  _Unwind_Resume(a1);
}

void *sub_1B63D431C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = malloc_type_malloc(0x7A0uLL, 0xD5346062uLL);
  memset(v4, 255, 0x7A0uLL);
  sub_1B63EE90C((uint64_t)v4, *a2);
  uint64_t v6 = v4;
  sub_1B63D4868(a1 + 8, &v6);
  return v6;
}

uint64_t sub_1B63D4390@<X0>(uint64_t a1@<X0>, CFX::RG::RenderGraphProvider *a2@<X8>)
{
  uint64_t v5 = a1;
  CFX::RG::RenderGraphProvider::RenderGraphProvider(a2, "Stereo");
  uint64_t v3 = sub_1B63D3F20((uint64_t)a2, &v5);
  *(unsigned char *)(v3 + 49) = 1;
  uint64_t result = sub_1B63D4410((uint64_t)a2, &v5);
  *(_WORD *)(result + 24) = *(_WORD *)(v3 + 8);
  return result;
}

void sub_1B63D43F8(_Unwind_Exception *a1)
{
  CFX::RG::RenderGraphProvider::~RenderGraphProvider(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B63D4410(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = malloc_type_malloc(0x28uLL, 0xD5346062uLL);
  *(void *)&long long v5 = -1;
  *((void *)&v5 + 1) = -1;
  *uint64_t v4 = v5;
  v4[1] = v5;
  *((void *)v4 + 4) = -1;
  uint64_t v7 = sub_1B64E0434((uint64_t)v4, *a2);
  sub_1B63D4868(a1 + 8, &v7);
  return v7;
}

uint64_t sub_1B63D4478@<X0>(uint64_t a1@<X0>, CFX::RG::RenderGraphProvider *a2@<X8>)
{
  uint64_t v5 = a1;
  CFX::RG::RenderGraphProvider::RenderGraphProvider(a2, "Holographic");
  uint64_t v3 = sub_1B63D3F20((uint64_t)a2, &v5);
  *(unsigned char *)(v3 + 49) = 1;
  uint64_t result = sub_1B63D40B4((uint64_t)a2, &v5);
  *(_WORD *)(result + 24) = *(_WORD *)(v3 + 8);
  return result;
}

void sub_1B63D44E0(_Unwind_Exception *a1)
{
  CFX::RG::RenderGraphProvider::~RenderGraphProvider(v1);
  _Unwind_Resume(a1);
}

_OWORD *sub_1B63D44F8()
{
  uint64_t v0 = malloc_type_malloc(0x38uLL, 0xD5346062uLL);
  *(void *)&long long v1 = -1;
  *((void *)&v1 + 1) = -1;
  *uint64_t v0 = v1;
  v0[1] = v1;
  v0[2] = v1;
  *((void *)v0 + 6) = -1;
  CFX::RG::RenderGraphProvider::RenderGraphProvider((CFX::RG::RenderGraphProvider *)v0, "Compute irradiance");
  sub_1B63D456C(v2);
  return v0;
}

uint64_t sub_1B63D456C(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x38uLL, 0xD5346062uLL);
  *(void *)&long long v3 = -1;
  *((void *)&v3 + 1) = -1;
  *uint64_t v2 = v3;
  v2[1] = v3;
  _OWORD v2[2] = v3;
  *((void *)v2 + 6) = -1;
  uint64_t v5 = sub_1B65F2F14();
  sub_1B63D4868(a1 + 8, &v5);
  return v5;
}

_OWORD *sub_1B63D45F0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v27 = a1;
  CFNumberRef v25 = a4;
  uint64_t v26 = a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA640, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDA640))
  {
    CFX::RG::ResourceIdentifier::ResourceIdentifier((CFX::RG::ResourceIdentifier *)&unk_1E9DDA638, "CustomAuthoring.Final.Color");
    __cxa_guard_release(&qword_1E9DDA640);
  }
  uint64_t v5 = malloc_type_malloc(0x38uLL, 0xD5346062uLL);
  *(void *)&long long v6 = -1;
  *((void *)&v6 + 1) = -1;
  *uint64_t v5 = v6;
  v5[1] = v6;
  _OWORD v5[2] = v6;
  *((void *)v5 + 6) = -1;
  CFX::RG::RenderGraphProvider::RenderGraphProvider((CFX::RG::RenderGraphProvider *)v5, "Custom");
  *(unsigned char *)(v7 + 41) = 1;
  uint64_t v8 = sub_1B63D47EC(v7);
  unint64_t v9 = (unsigned int *)sub_1B6595E60(v8);
  uint64_t v10 = *v9;
  if (v10)
  {
    CFNumberRef v11 = (unsigned __int16 *)*((void *)v9 + 1);
    uint64_t v12 = 8 * v10;
    while (1)
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v24, 6893, 6893, 1656467160);
      if (CFX::RG::ResourceIdentifier::match(v11, v24)) {
        break;
      }
      v11 += 4;
      v12 -= 8;
      if (!v12) {
        goto LABEL_6;
      }
    }
  }
  else
  {
LABEL_6:
    sub_1B63D3F20((uint64_t)v5, &v27);
    sub_1B63D3F8C((uint64_t)v5, &v27);
  }
  uint64_t v13 = malloc_type_malloc(0x20uLL, 0xD5346062uLL);
  *(void *)&long long v14 = -1;
  *((void *)&v14 + 1) = -1;
  *uint64_t v13 = v14;
  v13[1] = v14;
  sub_1B6403CA4((uint64_t)v13, v27);
  CFX::RG::RenderGraphProvider::addSubgraph((uint64_t)v5, (uint64_t)v13);
  *(_WORD *)(sub_1B63D40B4((uint64_t)v5, &v27) + 24) = *((_WORD *)v13 + 4);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v23 = 0;
  if ((CFX::RG::RenderGraphProvider::resolve((uint64_t)v5, a2, (uint64_t)__p) & 1) == 0)
  {
    CFNumberRef v17 = v25;
    if (v23 >= 0) {
      uint64_t v18 = objc_msgSend_stringWithUTF8String_(NSString, v15, (uint64_t)__p, v16);
    }
    else {
      uint64_t v18 = objc_msgSend_stringWithUTF8String_(NSString, v15, (uint64_t)__p[0], v16);
    }
    objc_msgSend_addGenericRenderGraphErrorWithMessage_(v17, v19, v18, v20);
  }
  if (SHIBYTE(v23) < 0) {
    operator delete(__p[0]);
  }
  return v5;
}

void sub_1B63D47BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

uint64_t sub_1B63D47EC(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x40uLL, 0xD5346062uLL);
  *(void *)&long long v3 = -1;
  *((void *)&v3 + 1) = -1;
  *uint64_t v2 = v3;
  v2[1] = v3;
  _OWORD v2[2] = v3;
  v2[3] = v3;
  uint64_t v5 = sub_1B6595C08();
  sub_1B63D4868(a1 + 8, &v5);
  return v5;
}

void sub_1B63D4868(uint64_t a1, void *a2)
{
  unsigned int v4 = *(_DWORD *)a1;
  unsigned int v5 = *(_DWORD *)a1 + 1;
  if (v5 > *(_DWORD *)(a1 + 4))
  {
    sub_1B63D00C4((unsigned int *)a1, 1, 0);
    unsigned int v4 = *(_DWORD *)a1;
    unsigned int v5 = *(_DWORD *)a1 + 1;
  }
  *(void *)(*(void *)(a1 + 8) + 8 * v4) = *a2;
  *(_DWORD *)a1 = v5;
}

uint64_t sub_1B63D48C4(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B63D48F4()
{
  if (qword_1E9DDA650 != -1) {
    dispatch_once_f(&qword_1E9DDA650, &qword_1E9DDA648, (dispatch_function_t)sub_1B63D48C4);
  }
  CFTypeID v0 = qword_1E9DDA648;

  return sub_1B63C8D44(v0, 0xD0uLL);
}

uint64_t sub_1B63D495C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  return *(void *)(a1 + 16);
}

uint64_t sub_1B63D49A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  return *(void *)(a1 + 24);
}

CFTypeRef sub_1B63D49F4(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  CFTypeRef result = *(CFTypeRef *)(a1 + 16);
  if (result != cf)
  {
    if (result)
    {
      CFRelease(result);
      *(void *)(a1 + 16) = 0;
    }
    if (cf) {
      CFTypeRef result = CFRetain(cf);
    }
    else {
      CFTypeRef result = 0;
    }
    *(void *)(a1 + 16) = result;
  }
  return result;
}

uint64_t sub_1B63D4A70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  return *(void *)(a1 + 32);
}

uint64_t sub_1B63D4ABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  return *(void *)(a1 + 40);
}

uint64_t sub_1B63D4B08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  return a1 + 64;
}

uint64_t sub_1B63D4B54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  return a1 + 96;
}

uint64_t sub_1B63D4BA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  return a1 + 80;
}

double sub_1B63D4BEC(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  float32x4_t v9 = a1[7];
  float32x4_t v10 = a1[8];
  float32x4_t v11 = a1[9];
  int32x4_t v12 = (int32x4_t)vmulq_f32(v9, v9);
  int32x4_t v13 = (int32x4_t)vmulq_f32(v10, v10);
  int32x4_t v14 = (int32x4_t)vmulq_f32(v11, v11);
  int32x4_t v15 = vzip1q_s32(v12, v14);
  int32x4_t v16 = vzip2q_s32(v12, v14);
  float32x4_t v17 = (float32x4_t)vtrn2q_s32(v12, v13);
  v17.i32[2] = v14.i32[1];
  float32x4_t v18 = vaddq_f32((float32x4_t)vzip1q_s32(v16, vdupq_laneq_s32(v13, 2)), vaddq_f32((float32x4_t)vzip1q_s32(v15, v13), v17));
  __asm { FMOV            V5.4S, #1.0 }
  int32x4_t v24 = vceqzq_f32(v18);
  v24.i32[3] = 0;
  float32x4_t v25 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v24), (int8x16_t)v18, (int8x16_t)vdivq_f32(_Q5, v18));
  *(void *)&double result = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32(vmulq_laneq_f32(v11, v25, 2), a1[5], 2), vmulq_lane_f32(v10, *(float32x2_t *)v25.f32, 1), *(float32x2_t *)a1[5].f32, 1), vmulq_n_f32(v9, v25.f32[0]), COERCE_FLOAT(*(_OWORD *)&a1[5])).u64[0];
  return result;
}

uint64_t sub_1B63D4CA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"result");
  }
  return a1 + 112;
}

double sub_1B63D4CEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"hit");
  }
  uint64_t v10 = *(void *)(a1 + 16);
  double v11 = 0.0;
  if (v10)
  {
    uint64_t v12 = sub_1B649F5F4(v10, a2, a3, a4, a5, a6, a7, a8);
    if (v12)
    {
      uint64_t v20 = sub_1B63CCE68(v12, v13, v14, v15, v16, v17, v18, v19);
      if (v20)
      {
        uint64_t v25 = v20;
        uint64_t v26 = sub_1B64AC5F8(v20, 3, a2, 0, v21, v22, v23, v24);
        if (v26)
        {
          uint64_t v33 = (uint64_t)v26;
          CFNumberRef v34 = sub_1B64ACF7C(v25, 0, v27, v28, v29, v30, v31, v32);
          if (v34)
          {
            uint64_t v40 = (uint64_t)v34;
            int v41 = sub_1B64ABD78(v25, *(void *)(a1 + 32), 0, v35, v36, v37, v38, v39);
            if (v41)
            {
              uint64_t v47 = (uint64_t)v41;
              uint64_t v48 = sub_1B64ACE9C(v25, 3, a2, v42, v43, v44, v45, v46);
              uint64_t v54 = sub_1B64ACE9C(v25, 0, 0, v49, v50, v51, v52, v53);
              uint64_t v59 = sub_1B63D14A0(v47, *(void *)(a1 + 40), *(unsigned int *)(a1 + 48), v48, v55, v56, v57, v58);
              uint64_t v64 = sub_1B63D14A0(v47, *(void *)(a1 + 40), *(unsigned int *)(a1 + 52), v48, v60, v61, v62, v63);
              uint64_t v75 = sub_1B63D14A0(v47, *(void *)(a1 + 40), *(unsigned int *)(a1 + 56), v48, v65, v66, v67, v68);
              uint64_t v122 = v64;
              uint64_t v123 = v59;
              uint64_t v76 = v75;
              if (v54 != v48)
              {
                uint64_t v59 = sub_1B63D14A0(v47, *(void *)(a1 + 40), *(unsigned int *)(a1 + 48), v54, v71, v72, v73, v74);
                uint64_t v64 = sub_1B63D14A0(v47, *(void *)(a1 + 40), *(unsigned int *)(a1 + 52), v54, v77, v78, v79, v80);
                uint64_t v76 = sub_1B63D14A0(v47, *(void *)(a1 + 40), *(unsigned int *)(a1 + 56), v54, v81, v82, v83, v84);
              }
              *(double *)&long long v85 = sub_1B641E208(v40, v59, v69, v70, v71, v72, v73, v74);
              v125[0] = v85;
              *(double *)&long long v92 = sub_1B641E208(v40, v64, v86, v87, v88, v89, v90, v91);
              v125[1] = v92;
              *(double *)&long long v99 = sub_1B641E208(v40, v76, v93, v94, v95, v96, v97, v98);
              v125[2] = v99;
              v124.i32[2] = 0;
              v124.i64[0] = 0;
              sub_1B6454A74(v125, (long long *)(a1 + 64), &v124);
              double v106 = sub_1B641E284(v33, v123, v100, v101, v102, v103, v104, v105);
              double v113 = sub_1B641E284(v33, v122, v107, v108, v109, v110, v111, v112);
              double v120 = sub_1B641E284(v33, v75, v114, v115, v116, v117, v118, v119);
              return COERCE_DOUBLE(vmla_laneq_f32(vmla_n_f32(vmul_lane_f32(*(float32x2_t *)&v113, *(float32x2_t *)v124.f32, 1), *(float32x2_t *)&v106, v124.f32[0]), *(float32x2_t *)&v120, v124, 2));
            }
          }
        }
      }
    }
  }
  return v11;
}

uint64_t sub_1B63D4F14(float32x4_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  float32x4_t v9 = (float32x2_t *)a5;
  __n128 v53 = a9;
  if (!a3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", 0, a4, a5, a6, a7, a8, (uint64_t)"pointOfView");
  }
  memset(v52, 0, sizeof(v52));
  uint64_t v20 = sub_1B63E0460(a3, (uint64_t)v52, a3, a4, a5, a6, a7, a8);
  if (v20)
  {
    if (a4 && (v52[0] & 2) != 0) {
      sub_1B63E0578((uint64_t)v52, a3, 0, a4, v16, v17, v18, v19, v46);
    }
    uint64_t v21 = sub_1B649CD50((unsigned __int8 *)v52, (uint64_t)&v53, v14, v15, v16, v17, v18, v19);
    float32x4_t v49 = *((float32x4_t *)v21 + 1);
    float32x4_t v50 = *(float32x4_t *)v21;
    float32x4_t v47 = *((float32x4_t *)v21 + 3);
    float32x4_t v48 = *((float32x4_t *)v21 + 2);
    memset(&v51, 0, sizeof(v51));
    sub_1B64A27C4(a3, (uint64_t)&v51, v22, v23, v24, v25, v26, v27);
    simd_float4x4 v59 = __invert_f4(v51);
    uint64_t v28 = 0;
    int8x16_t v29 = (int8x16_t)v53;
    simd_float4x4 v54 = v59;
    float32x4_t v55 = 0u;
    float32x4_t v56 = 0u;
    float32x4_t v57 = 0u;
    float32x4_t v58 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v55 + v28 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v50, COERCE_FLOAT(*(_OWORD *)&v54.columns[v28])), v49, *(float32x2_t *)v54.columns[v28].f32, 1), v48, (float32x4_t)v54.columns[v28], 2), v47, (float32x4_t)v54.columns[v28], 3);
      ++v28;
    }
    while (v28 != 4);
    if (a2 >= 1)
    {
      float32x4_t v30 = v55;
      float32x4_t v31 = v56;
      float64x2_t v32 = vcvtq_f64_f32(*(float32x2_t *)v29.i8);
      uint64_t v33 = a2;
      float32x2_t v34 = (float32x2_t)vextq_s8(v29, v29, 8uLL).u64[0];
      __asm
      {
        FMOV            V5.2S, #1.0
        FMOV            V6.2D, #0.5
      }
      float32x4_t v41 = v57;
      float32x4_t v42 = v58;
      do
      {
        float32x4_t v43 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v42, v41, *a1, 2), v31, *(float32x2_t *)a1->f32, 1), v30, COERCE_FLOAT(*a1));
        if (v43.f32[3] == 0.0) {
          break;
        }
        float v44 = 1.0 / v43.f32[3];
        if ((float)(1.0 / v43.f32[3]) == 0.0) {
          break;
        }
        v9[1].f32[0] = 1.0 - vmuls_lane_f32(v44, v43, 2);
        *float32x4_t v9 = vcvt_f32_f64(vaddq_f64(vmulq_f64(vcvtq_f64_f32(vmul_f32(v34, vadd_f32(vmul_n_f32(*(float32x2_t *)v43.f32, v44), _D5))), _Q6), v32));
        v9 += 2;
        ++a1;
        --v33;
      }
      while (v33);
    }
  }
  return v20;
}

uint64_t sub_1B63D5100(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  float32x4_t v9 = (float32x4_t *)a5;
  if (!a3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", 0, a4, a5, a6, a7, a8, (uint64_t)"pointOfView");
  }
  memset(v34, 0, sizeof(v34));
  uint64_t result = sub_1B63E0460(a3, (uint64_t)v34, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    if (a4 && (v34[0] & 2) != 0) {
      sub_1B63E0578((uint64_t)v34, a3, 0, a4, v15, v16, v17, v18, v32);
    }
    uint64_t result = sub_1B649D1E0((float *)v34, a1, a2, (uint64_t)v9, v15, v16, v17, v18, a9);
    if (result)
    {
      uint64_t v26 = (float32x4_t *)sub_1B64A01D4(a3, v19, v20, v21, v22, v23, v24, v25);
      if ((int)a2 >= 1)
      {
        float32x4_t v28 = v26[2];
        float32x4_t v27 = v26[3];
        uint64_t v29 = a2;
        float32x4_t v31 = *v26;
        float32x4_t v30 = v26[1];
        do
        {
          *float32x4_t v9 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v27, v28, *v9, 2), v30, *(float32x2_t *)v9->f32, 1), v31, COERCE_FLOAT(*v9));
          ++v9;
          --v29;
        }
        while (v29);
      }
      return 1;
    }
  }
  return result;
}

double sub_1B63D5214(uint64_t a1, uint64_t a2, _OWORD *a3, _OWORD *a4, __n128 a5, double a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    __asm { FMOV            V2.4S, #1.0 }
    *(double *)&_Q2 = a6;
    v20[0] = *(unint64_t *)&a6;
    v20[1] = _Q2;
    sub_1B63D5100((uint64_t)v20, 2, a1, a2, (uint64_t)&v18, a8, a9, a10, a5);
    if (a3)
    {
      a5.n128_u64[0] = v18;
      *a3 = v18;
    }
    if (a4)
    {
      a5.n128_u64[0] = v19;
      *a4 = v19;
    }
  }
  return a5.n128_f64[0];
}

_OWORD *sub_1B63D52BC(_OWORD *result, CFDictionaryRef theDict)
{
  result[25] = 0u;
  result[26] = 0u;
  result[23] = 0u;
  result[24] = 0u;
  result[21] = 0u;
  result[22] = 0u;
  result[19] = 0u;
  result[20] = 0u;
  result[17] = 0u;
  result[18] = 0u;
  result[15] = 0u;
  result[16] = 0u;
  result[13] = 0u;
  result[14] = 0u;
  result[11] = 0u;
  result[12] = 0u;
  result[9] = 0u;
  result[10] = 0u;
  result[7] = 0u;
  result[8] = 0u;
  result[5] = 0u;
  result[6] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[1] = 0u;
  result[2] = 0u;
  const UInt8 *result = 0u;
  *(void *)uint64_t result = -1;
  *((unsigned char *)result + 10) = 1;
  *((_WORD *)result + 4) = *((_WORD *)result + 4) & 0xE400 | 0xA3F;
  if (!theDict) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  Value = CFDictionaryGetValue(theDict, @"kHitTestAllLayers");
  unsigned int v5 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
  if (Value)
  {
    if (CFEqual((CFTypeRef)*MEMORY[0x1E4F1CFD0], Value)) {
      char v6 = 3;
    }
    else {
      char v6 = 1;
    }
    *(unsigned char *)(v3 + 10) = v6;
  }
  uint64_t v7 = (void *)CFDictionaryGetValue(theDict, @"kHitTestLayerMask");
  if (v7)
  {
    uint64_t v11 = objc_msgSend_integerValue(v7, v8, v9, v10);
    if (v11 >= 1) {
      *(unsigned char *)(v3 + 10) = v11;
    }
  }
  uint64_t v12 = CFDictionaryGetValue(theDict, @"kHitTestClipToZRange");
  if (v12) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFFFD | (2 * (CFEqual(*v5, v12) != 0));
  }
  uint64_t v13 = CFDictionaryGetValue(theDict, @"kHitTestIgnoreLockedNodes");
  if (v13) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xEFFF | ((CFEqual(*v5, v13) != 0) << 12);
  }
  uint64_t v14 = CFDictionaryGetValue(theDict, @"kHitTestBackFaceCulling");
  if (v14) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFFF7 | (8 * (CFEqual(*v5, v14) != 0));
  }
  uint64_t v15 = CFDictionaryGetValue(theDict, @"kHitTestSkipTransparentNode");
  if (v15) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFFEF | (16 * (CFEqual(*v5, v15) != 0));
  }
  CFNumberRef v16 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"kHitTestCategoryBitMask");
  if (v16)
  {
    uint64_t valuePtr = 0;
    CFNumberGetValue(v16, kCFNumberLongType, &valuePtr);
    *(void *)uint64_t v3 = valuePtr;
  }
  uint64_t v17 = CFDictionaryGetValue(theDict, @"kHitTestSkipHiddenNode");
  if (v17) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFFDF | (32 * (CFEqual(*v5, v17) != 0));
  }
  long long v18 = CFDictionaryGetValue(theDict, @"kHitTestSkipParticleEmitter");
  if (v18) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFFBF | ((CFEqual(*v5, v18) != 0) << 6);
  }
  long long v19 = CFDictionaryGetValue(theDict, @"kHitTestIgnoreChildNodes");
  if (v19) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFFFE | (CFEqual(*v5, v19) == 0);
  }
  uint64_t v20 = CFDictionaryGetValue(theDict, @"kHitTestFirstFoundOnly");
  if (v20) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFEFF | ((CFEqual(*v5, v20) != 0) << 8);
  }
  uint64_t v21 = CFDictionaryGetValue(theDict, @"kHitTestSortResults");
  if (v21) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFFFB | (4 * (CFEqual(*v5, v21) != 0));
  }
  uint64_t v22 = (void *)CFDictionaryGetValue(theDict, @"kHitTestSearchMode");
  if (v22)
  {
    uint64_t v26 = objc_msgSend_integerValue(v22, v23, v24, v25);
    switch(v26)
    {
      case 2:
        __int16 v27 = *(_WORD *)(v3 + 8) & 0xFCFF | 0x100;
        goto LABEL_37;
      case 1:
        __int16 v27 = *(_WORD *)(v3 + 8) & 0xFCFF;
        goto LABEL_37;
      case 0:
        __int16 v27 = *(_WORD *)(v3 + 8) & 0xFCFF | 0x200;
LABEL_37:
        *(_WORD *)(v3 + 8) = v27;
        break;
    }
  }
  float32x4_t v28 = CFDictionaryGetValue(theDict, @"kHitTestBoundingBoxOnly");
  if (v28) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFF7F | ((CFEqual(*v5, v28) != 0) << 7);
  }
  uint64_t v29 = CFDictionaryGetValue(theDict, @"kHitTestShowDebugInfo");
  if (v29) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xFBFF | ((CFEqual(*v5, v29) != 0) << 10);
  }
  float32x4_t v30 = CFDictionaryGetValue(theDict, @"kHitTestResultIgnoreLightArea");
  if (v30) {
    *(_WORD *)(v3 + 8) = *(_WORD *)(v3 + 8) & 0xF7FF | ((CFEqual(*v5, v30) & 1) << 11);
  }
  uint64_t result = CFDictionaryGetValue(theDict, @"auth");
  *(void *)(v3 + 416) = result;
  return result;
}

void sub_1B63D5728(uint64_t a1, unsigned int a2, int a3, int a4, int a5, float a6, float32x4_t a7, __n128 a8)
{
  uint64_t v14 = sub_1B63D48F4();
  sub_1B63D49F4(v14, *(CFTypeRef *)(a1 + 112), v15, v16, v17, v18, v19, v20);
  CFTypeRef v21 = *(CFTypeRef *)(v14 + 24);
  CFTypeRef v22 = *(CFTypeRef *)(a1 + 120);
  if (v21 != v22)
  {
    if (v21)
    {
      CFRelease(*(CFTypeRef *)(v14 + 24));
      *(void *)(v14 + 24) = 0;
      CFTypeRef v22 = *(CFTypeRef *)(a1 + 120);
    }
    if (v22) {
      CFTypeRef v22 = CFRetain(v22);
    }
    *(void *)(v14 + 24) = v22;
  }
  long long v23 = *(_OWORD *)(a1 + 128);
  long long v24 = *(_OWORD *)(a1 + 144);
  long long v25 = *(_OWORD *)(a1 + 176);
  *(_OWORD *)(v14 + 144) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(v14 + 160) = v25;
  *(_OWORD *)(v14 + 112) = v23;
  *(_OWORD *)(v14 + 128) = v24;
  *(__n128 *)(v14 + 80) = a8;
  *(void *)(v14 + 32) = *(void *)(a1 + 192);
  *(void *)(v14 + 40) = a2;
  *(_DWORD *)(v14 + 48) = a3;
  *(_DWORD *)(v14 + 52) = a4;
  *(_DWORD *)(v14 + 56) = a5;
  *(float32x4_t *)(v14 + 64) = a7;
  *(float32x4_t *)(v14 + 96) = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a1 + 176), *(float32x4_t *)(a1 + 160), a7, 2), *(float32x4_t *)(a1 + 144), *(float32x2_t *)a7.f32, 1), *(float32x4_t *)(a1 + 128), a7.f32[0]);
  if ((*(_WORD *)(a1 + 8) & 0x200) != 0)
  {
    float v26 = a6 / *(float *)(a1 + 108);
    *(float *)(a1 + 108) = a6;
    *(float *)(a1 + 60) = v26 * *(float *)(a1 + 60);
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 312), (const void *)v14);

  CFRelease((CFTypeRef)v14);
}

void sub_1B63D5848(uint64_t a1, unsigned int a2, int a3, int a4, int a5, float a6, float32x4_t a7, __n128 a8)
{
  uint64_t v14 = sub_1B63D48F4();
  sub_1B63D49F4(v14, *(CFTypeRef *)(a1 + 112), v15, v16, v17, v18, v19, v20);
  long long v21 = *(_OWORD *)(a1 + 128);
  long long v22 = *(_OWORD *)(a1 + 144);
  long long v23 = *(_OWORD *)(a1 + 176);
  *(_OWORD *)(v14 + 144) = *(_OWORD *)(a1 + 160);
  *(_OWORD *)(v14 + 160) = v23;
  *(_OWORD *)(v14 + 112) = v21;
  *(_OWORD *)(v14 + 128) = v22;
  *(__n128 *)(v14 + 80) = a8;
  *(void *)(v14 + 32) = *(void *)(a1 + 192);
  *(void *)(v14 + 40) = a2;
  *(_DWORD *)(v14 + 48) = a3;
  *(_DWORD *)(v14 + 52) = a4;
  *(_DWORD *)(v14 + 56) = a5;
  *(float32x4_t *)(v14 + 96) = a7;
  simd_float4x4 v27 = __invert_f4(*(simd_float4x4 *)(a1 + 128));
  *(float32x4_t *)(v14 + 64) = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v27.columns[3], (float32x4_t)v27.columns[2], a7, 2), (float32x4_t)v27.columns[1], *(float32x2_t *)a7.f32, 1), (float32x4_t)v27.columns[0], a7.f32[0]);
  if ((*(_WORD *)(a1 + 8) & 0x200) != 0) {
    *(float *)(a1 + 60) = a6;
  }
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 312), (const void *)v14);

  CFRelease((CFTypeRef)v14);
}

BOOL sub_1B63D5930(uint64_t a1, uint64_t a2, unsigned int a3, float32x4_t a4, float32x4_t a5, __n128 a6, uint64_t a7, char a8, uint64_t a9)
{
  if (a3)
  {
    float32x4_t v11 = a5;
    float32x4_t v12 = a4;
    uint64_t v15 = 0;
    float v16 = a6.n128_f32[3];
    __int16 v17 = *(_WORD *)(a9 + 8);
    BOOL v18 = 1;
    unsigned int v19 = 2;
    __asm { FMOV            V22.4S, #-1.0 }
    unint64_t v25 = a3;
    v26.i64[0] = 0xBF000000BF000000;
    v26.i64[1] = 0xBF000000BF000000;
    v27.i64[0] = 0x3F0000003F000000;
    v27.i64[1] = 0x3F0000003F000000;
    float32x4_t v70 = _Q22;
    while (1)
    {
      float32x4_t v28 = *(float32x4_t *)(a1 + 16 * (v19 - 2));
      float32x4_t v29 = *(float32x4_t *)(a1 + 16 * (v19 - 1));
      float32x4_t v30 = *(float32x4_t *)(a1 + 16 * v19);
      float32x4_t v31 = vsubq_f32(v29, v28);
      float32x4_t v32 = vsubq_f32(v30, v28);
      float32x4_t v33 = vnegq_f32(v31);
      float32x4_t v34 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32), (int8x16_t)v32, 0xCuLL), v33), v32, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), (int8x16_t)v31, 0xCuLL));
      float32x4_t v35 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), (int8x16_t)v34, 0xCuLL);
      float32x4_t v36 = vmulq_f32(v34, v34);
      v36.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v36, 2), v36)).u64[0];
      float32x4_t v37 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v36.f32, 0);
      v37.i32[3] = 0;
      float32x4_t v38 = vrsqrteq_f32(v37);
      float32x4_t v39 = vmulq_f32(v38, vrsqrtsq_f32(v37, vmulq_f32(v38, v38)));
      int32x4_t v40 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v36.f32[0] != 0.0)), 0x1FuLL));
      v40.i32[3] = 0;
      __n128 v42 = (__n128)vbslq_s8((int8x16_t)vcltzq_s32(v40), (int8x16_t)vmulq_f32(vmulq_f32(v39, vrsqrtsq_f32(v37, vmulq_f32(v39, v39))), v35), (int8x16_t)v35);
      float32x4_t v41 = vmulq_f32((float32x4_t)v42, v28);
      v42.n128_f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), vaddq_f32(v41, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1))).f32[0];
      int8x16_t v43 = (int8x16_t)vmulq_f32(v11, (float32x4_t)v42);
      float v44 = vaddv_f32(vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL)));
      if (v17 & 8) == 0 || (a8)
      {
        if (v44 == 0.0) {
          goto LABEL_17;
        }
      }
      else if (v44 >= 0.0)
      {
        goto LABEL_17;
      }
      int8x16_t v45 = (int8x16_t)vmulq_f32(v12, (float32x4_t)v42);
      float v46 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v45.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v45, v45, 8uLL))) / v44;
      if (v46 >= 0.0 && v46 <= v16)
      {
        float32x4_t v48 = vmlaq_n_f32(v12, v11, v46);
        float32x4_t v49 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v32, (int8x16_t)v32, 0xCuLL), (int8x16_t)v32, 8uLL), v33), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v31, (int8x16_t)v31, 0xCuLL), (int8x16_t)v31, 8uLL), v32);
        float32x4_t v50 = vmulq_f32(v49, v49);
        int32x2_t v51 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).u64[0];
        float32x4_t v52 = _Q22;
        if (fabsf(*(float *)v51.i32) >= 1.1755e-38)
        {
          float32x4_t v53 = vsubq_f32(v30, v48);
          float32x4_t v54 = vsubq_f32(v29, v48);
          float32x4_t v55 = vsubq_f32(v28, v48);
          float32x4_t v56 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v54, (int8x16_t)v54, 0xCuLL), (int8x16_t)v54, 8uLL);
          float32x4_t v57 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v53, (int8x16_t)v53, 0xCuLL), (int8x16_t)v53, 8uLL);
          float32x4_t v58 = vmlaq_f32(vmulq_f32(v57, vnegq_f32(v54)), v56, v53);
          float32x4_t v59 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v55, (int8x16_t)v55, 0xCuLL), (int8x16_t)v55, 8uLL);
          float32x4_t v60 = vmlaq_f32(vmulq_f32(v59, vnegq_f32(v53)), v57, v55);
          float32x4_t v61 = vmlaq_f32(vmulq_f32(v56, vnegq_f32(v55)), v59, v54);
          int32x4_t v62 = (int32x4_t)vmulq_f32(v49, v58);
          int32x4_t v63 = (int32x4_t)vmulq_f32(v49, v60);
          int32x4_t v64 = (int32x4_t)vmulq_f32(v49, v61);
          int32x4_t v65 = vzip2q_s32(v62, v64);
          float32x4_t v66 = (float32x4_t)vzip1q_s32(vzip1q_s32(v62, v64), v63);
          float32x4_t v67 = (float32x4_t)vtrn2q_s32(v62, v63);
          v67.i32[2] = v64.i32[1];
          float32x4_t v52 = vdivq_f32(vaddq_f32((float32x4_t)vzip1q_s32(v65, vdupq_laneq_s32(v63, 2)), vaddq_f32(v66, v67)), (float32x4_t)vdupq_lane_s32(v51, 0));
        }
        uint32x4_t v68 = (uint32x4_t)vcgeq_f32(v27, vabsq_f32(vaddq_f32(v52, v26)));
        v68.i32[3] = v68.i32[2];
        if ((vminvq_u32(v68) & 0x80000000) != 0)
        {
          sub_1B63D5728(a9, *(_DWORD *)(a2 + 4 * v15), 0, 1, 2, v46, v48, v42);
          v27.i64[0] = 0x3F0000003F000000;
          v27.i64[1] = 0x3F0000003F000000;
          v26.i64[0] = 0xBF000000BF000000;
          v26.i64[1] = 0xBF000000BF000000;
          _Q22 = v70;
          float32x4_t v12 = a4;
          float32x4_t v11 = a5;
          __int16 v17 = *(_WORD *)(a9 + 8);
          if ((v17 & 0x100) != 0) {
            return v18;
          }
        }
      }
LABEL_17:
      BOOL v18 = ++v15 < v25;
      v19 += 3;
      if (v25 == v15) {
        return v18;
      }
    }
  }
  return 0;
}

uint64_t sub_1B63D5C0C(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (_DWORD *)a5;
  uint64_t v9 = a4;
  uint64_t v108 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"meshElement");
  }
  uint64_t result = *(void *)(a1 + 208);
  if (result) {
    goto LABEL_4;
  }
  if ((*((unsigned char *)a2 + 26) & 0xFA) == 0)
  {
    unsigned int v14 = *((_DWORD *)a2 + 2) + 31;
    *(_DWORD *)(a1 + 216) = v14 >> 5;
    *(void *)(a1 + 208) = malloc_type_malloc(v14 & 0xFFFFFFE0, 0x1000040E0EAB150uLL);
    uint64_t v21 = v9 & 0xFF000000000000;
    uint64_t v96 = 0;
    uint64_t v97 = &v96;
    uint64_t v98 = 0x2020000000;
    int v99 = 0;
    uint64_t v104 = 0;
    uint64_t v105 = (float32x4_t *)&v104;
    uint64_t v106 = 0x3020000000;
    float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
    float32x4_t v107 = v22;
    uint64_t v100 = 0;
    uint64_t v101 = (float32x4_t *)&v100;
    uint64_t v102 = 0x3020000000;
    v23.i64[0] = 0x80000000800000;
    v23.i64[1] = 0x80000000800000;
    float32x4_t v103 = v23;
    uint64_t v92 = 0;
    uint64_t v93 = &v92;
    uint64_t v94 = 0x2020000000;
    int v95 = 0;
    uint64_t v79 = v8;
    if (*((unsigned char *)a2 + 26) == 4)
    {
      v85[0] = MEMORY[0x1E4F143A8];
      v85[1] = 3221225472;
      long long v24 = a2[1];
      long long v86 = *a2;
      long long v87 = v24;
      long long v26 = *a2;
      long long v25 = a2[1];
      long long v88 = a2[2];
      void v85[2] = sub_1B63D616C;
      v85[3] = &unk_1E6140FE0;
      BOOL v91 = v21 == 0x1000000000000;
      v85[8] = a3;
      v85[9] = v9;
      v85[4] = &v104;
      v85[5] = &v100;
      uint64_t v89 = *((void *)a2 + 6);
      uint64_t v90 = a1;
      v85[6] = &v96;
      v85[7] = &v92;
      v83[0] = v26;
      v83[1] = v25;
      float32x4_t v83[2] = a2[2];
      uint64_t v84 = *((void *)a2 + 6);
      sub_1B63D1BEC((uint64_t *)v83, (uint64_t)v85, v15, v16, v17, v18, v19, v20);
    }
    else if (*((_DWORD *)a2 + 2))
    {
      unint64_t v27 = 0;
      float32x4_t v28 = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
      float32x4_t v80 = v28;
      do
      {
        int v29 = *((unsigned __int8 *)a2 + 26);
        if (*((unsigned char *)a2 + 26))
        {
          if (v27) {
            uint64_t v30 = 1;
          }
          else {
            uint64_t v30 = 2;
          }
          if (v27) {
            uint64_t v31 = 2;
          }
          else {
            uint64_t v31 = 1;
          }
          uint64_t v32 = v29 != 5;
          BOOL v33 = v29 == 1;
          if (v29 == 1) {
            uint64_t v32 = 1;
          }
          uint64_t v34 = 1;
          if (v29 == 1) {
            uint64_t v35 = v30;
          }
          else {
            uint64_t v35 = 2;
          }
          if (v33) {
            uint64_t v36 = v31;
          }
          else {
            uint64_t v36 = 1;
          }
        }
        else
        {
          uint64_t v32 = 3;
          uint64_t v34 = 3;
          uint64_t v35 = 2;
          uint64_t v36 = 1;
        }
        uint64_t v37 = *(void *)a2;
        if (*(void *)a2)
        {
          int v38 = *((unsigned __int8 *)a2 + 27);
          uint64_t v39 = *((void *)a2 + 5);
          uint64_t v40 = *((void *)a2 + 6);
          switch(v38)
          {
            case 4:
              int v41 = *(_DWORD *)(v37 + 4 * (v39 + v40 * v27 * v32));
              unint64_t v45 = v34 * v27;
              int v43 = *(_DWORD *)(v37 + 4 * (v39 + (v36 + v45) * v40));
              LODWORD(v9) = *(_DWORD *)(v37 + 4 * (v39 + (v45 + v35) * v40));
              break;
            case 2:
              int v41 = *(unsigned __int16 *)(v37 + 2 * (v39 + v40 * v27 * v32));
              unint64_t v46 = v34 * v27;
              int v43 = *(unsigned __int16 *)(v37 + 2 * (v39 + (v36 + v46) * v40));
              LODWORD(v9) = *(unsigned __int16 *)(v37 + 2 * (v39 + (v46 + v35) * v40));
              break;
            case 1:
              int v41 = *(unsigned __int8 *)(v37 + v39 + v40 * v27 * v32);
              unint64_t v42 = v34 * v27;
              int v43 = *(unsigned __int8 *)(v37 + v39 + (v36 + v42) * v40);
              LODWORD(v9) = *(unsigned __int8 *)(v37 + v39 + (v42 + v35) * v40);
              break;
            default:
              sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", v15, v16, v17, v18, v19, v20, *((unsigned __int8 *)a2 + 27));
              LODWORD(v9) = 0;
              int v43 = 0;
              int v41 = 0;
              break;
          }
        }
        else
        {
          int v41 = v27 * v32;
          int v44 = v34 * v27;
          int v43 = v36 + v44;
          LODWORD(v9) = v44 + v35;
        }
        uint64_t v47 = a3 + v41 * BYTE5(v9);
        if (v21 == 0x1000000000000)
        {
          v22.i64[0] = *(void *)v47;
          v22.i64[1] = *(unsigned int *)(v47 + 8);
          uint64_t v48 = a3 + v43 * BYTE5(v9);
          v49.i64[0] = *(void *)v48;
          v49.i64[1] = *(unsigned int *)(v48 + 8);
          uint64_t v50 = a3 + v9 * BYTE5(v9);
          v51.i64[0] = *(void *)v50;
          v51.i64[1] = *(unsigned int *)(v50 + 8);
        }
        else
        {
          *(double *)v52.i64 = sub_1B65D6198(BYTE4(v9), (const float *)v47, v15, v16, v17, v18, v19, v20, v28, v23.f32[0], v22.f32[0]);
          float32x4_t v82 = v52;
          *(double *)v61.i64 = sub_1B65D6198(BYTE4(v9), (const float *)(a3 + v43 * BYTE5(v9)), v53, v54, v55, v56, v57, v58, v52, v59, v60);
          float32x4_t v81 = v61;
          *(double *)v51.i64 = sub_1B65D6198(BYTE4(v9), (const float *)(a3 + v9 * BYTE5(v9)), v62, v63, v64, v65, v66, v67, v61, v68, v69);
          float32x4_t v49 = v81;
          float32x4_t v22 = v82;
        }
        float32x4_t v70 = v105;
        v105[2] = vminnmq_f32(vminnmq_f32(vminnmq_f32(v105[2], v22), v49), v51);
        uint64_t v71 = v101;
        float32x4_t v23 = vmaxnmq_f32(vmaxnmq_f32(v101[2], v22), v49);
        float32x4_t v28 = vmaxnmq_f32(v23, v51);
        v101[2] = v28;
        unsigned int v72 = *((_DWORD *)v97 + 6) + 1;
        *((_DWORD *)v97 + 6) = v72;
        if (v72 > 0x1F || (unsigned int v73 = *((_DWORD *)a2 + 2), v27 >= v73 - 1))
        {
          uint64_t v74 = *(void *)(a1 + 208);
          uint64_t v75 = *((unsigned int *)v93 + 6);
          *((_DWORD *)v93 + 6) = v75 + 1;
          uint64_t v76 = (float32x4_t *)(v74 + 32 * v75);
          float32x4_t v77 = v70[2];
          float32x4_t v23 = v71[2];
          v77.i32[3] = 1.0;
          v23.i32[3] = 1.0;
          v78.i64[0] = 0x3F0000003F000000;
          v78.i64[1] = 0x3F0000003F000000;
          float32x4_t v22 = vmulq_f32(vaddq_f32(v77, v23), v78);
          *uint64_t v76 = v22;
          v76[1] = vmulq_f32(vsubq_f32(v23, v77), v78);
          v105[2] = v80;
          v28.i64[0] = 0x80000000800000;
          v28.i64[1] = 0x80000000800000;
          v101[2] = v28;
          *((_DWORD *)v97 + 6) = 0;
          unsigned int v73 = *((_DWORD *)a2 + 2);
        }
        ++v27;
      }
      while (v27 < v73);
    }
    if (*((_DWORD *)v93 + 6) != *(_DWORD *)(a1 + 216)) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. error in computing triangle bbox", v15, v16, v17, v18, v19, v20, (uint64_t)"groupIndex == meshElement->_primitiveGroupCount");
    }
    _Block_object_dispose(&v92, 8);
    _Block_object_dispose(&v100, 8);
    _Block_object_dispose(&v104, 8);
    _Block_object_dispose(&v96, 8);
    uint64_t result = *(void *)(a1 + 208);
    uint64_t v8 = v79;
LABEL_4:
    *uint64_t v8 = *(_DWORD *)(a1 + 216);
    return result;
  }
  return 0;
}

void sub_1B63D6128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose((const void *)(v43 - 208), 8);
  _Block_object_dispose((const void *)(v43 - 160), 8);
  _Block_object_dispose((const void *)(v43 - 240), 8);
  _Unwind_Resume(a1);
}

float32x4_t sub_1B63D616C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t result, float32x4_t a10, float a11)
{
  float32x4_t v11 = (int *)a3;
  if (*(unsigned char *)(a1 + 144))
  {
    if (a4)
    {
      uint64_t v14 = a4;
      result.i32[3] = 0;
      do
      {
        int v15 = *v11++;
        uint64_t v16 = *(void *)(a1 + 64) + v15 * *(unsigned __int8 *)(a1 + 77);
        v17.i64[0] = *(void *)v16;
        v17.i32[2] = *(_DWORD *)(v16 + 8);
        v17.i32[3] = result.i32[3];
        *(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 32) = vminnmq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8)+ 32), v17);
        *(float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 32) = vmaxnmq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8)+ 32), v17);
        uint64_t result = v17;
        --v14;
      }
      while (v14);
    }
  }
  else if (a4)
  {
    uint64_t v18 = a4;
    do
    {
      int v19 = *v11++;
      *(double *)v20.i64 = sub_1B65D6198(*(unsigned __int8 *)(a1 + 76), (const float *)(*(void *)(a1 + 64) + v19 * *(unsigned __int8 *)(a1 + 77)), a3, a4, a5, a6, a7, a8, result, a10.f32[0], a11);
      *(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 32) = vminnmq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8)+ 32), v20);
      uint64_t v21 = *(__n128 **)(*(void *)(a1 + 40) + 8);
      a10 = (float32x4_t)v21[2];
      uint64_t result = vmaxnmq_f32(a10, v20);
      _OWORD v21[2] = (__n128)result;
      --v18;
    }
    while (v18);
  }
  if (++*(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) > 0x1Fu || *(_DWORD *)(a1 + 88) - 1 <= a2)
  {
    uint64_t v22 = *(void *)(*(void *)(a1 + 136) + 208);
    uint64_t v23 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v24 = *(unsigned int *)(v23 + 24);
    *(_DWORD *)(v23 + 24) = v24 + 1;
    long long v25 = (float32x4_t *)(v22 + 32 * v24);
    float32x4_t v26 = *(float32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 32);
    float32x4_t v27 = *(float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 32);
    v26.i32[3] = 1.0;
    v27.i32[3] = 1.0;
    v28.i64[0] = 0x3F0000003F000000;
    v28.i64[1] = 0x3F0000003F000000;
    *long long v25 = vmulq_f32(vaddq_f32(v26, v27), v28);
    v25[1] = vmulq_f32(vsubq_f32(v27, v26), v28);
    *(int32x4_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 32) = vdupq_n_s32(0x7F7FFFFFu);
    result.i64[0] = 0x80000000800000;
    result.i64[1] = 0x80000000800000;
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 32) = result;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
  return result;
}

BOOL sub_1B63D631C(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, float32x4_t a10, int8x16_t a11)
{
  BOOL v129 = (*(_WORD *)(a3 + 8) & 8) != 0 && *(unsigned char *)(a3 + 272) == 0;
  unsigned int v11 = a2 - a1;
  if (a2 > a1)
  {
    int v124 = *(unsigned __int8 *)(a3 + 212);
    int v12 = *(unsigned __int8 *)(a3 + 242);
    uint64_t v132 = *(void *)(a3 + 216);
    uint64_t v133 = *(unsigned __int8 *)(a3 + 243);
    uint64_t v13 = *(void *)(a3 + 200);
    int v14 = *(unsigned __int8 *)(a3 + 213);
    uint64_t v15 = *(void *)(a3 + 264);
    uint64_t v121 = *(void *)(a3 + 256);
    uint64_t v122 = v15;
    int v16 = *(unsigned __int8 *)(a3 + 214);
    int v17 = *(unsigned __int8 *)(a3 + 273);
    uint64_t v18 = a1;
    unint64_t v128 = a2;
    uint64_t v19 = v15 * a1;
    __asm { FMOV            V0.4S, #-1.0 }
    float32x4_t v120 = _Q0;
    float32x4_t v125 = *(float32x4_t *)(a3 + 64);
    float32x4_t v25 = *(float32x4_t *)(a3 + 80);
    float32x4_t v131 = v25;
    BOOL v130 = 1;
    float v26 = *(float *)(a3 + 108);
    int v123 = v12;
    while (1)
    {
      if (v17)
      {
        if (v12)
        {
          uint64_t v27 = 1;
          if (v18) {
            uint64_t v28 = 1;
          }
          else {
            uint64_t v28 = 2;
          }
          if (v18) {
            uint64_t v29 = 2;
          }
          else {
            uint64_t v29 = 1;
          }
          uint64_t v30 = v12 == 1 || v12 != 5;
          if (v12 == 1) {
            uint64_t v31 = v28;
          }
          else {
            uint64_t v31 = 2;
          }
          if (v12 == 1) {
            uint64_t v32 = v29;
          }
          else {
            uint64_t v32 = 1;
          }
        }
        else
        {
          uint64_t v30 = 3;
          uint64_t v27 = 3;
          uint64_t v31 = 2;
          uint64_t v32 = 1;
        }
        if (!v132)
        {
          int v39 = v18 * v30;
          int v43 = v27 * v18;
          int v41 = v32 + v43;
          int v44 = v43 + v31;
          goto LABEL_55;
        }
        if (v133 == 4)
        {
          uint64_t v45 = v121;
          uint64_t v46 = v132;
          int v39 = *(_DWORD *)(v132 + 4 * (v121 + v19 * v30));
          uint64_t v47 = v27 * v18;
          int v41 = *(_DWORD *)(v132 + 4 * (v121 + (v32 + v47) * v15));
          uint64_t v48 = v47 + v31;
LABEL_52:
          int v44 = *(_DWORD *)(v46 + 4 * (v45 + v48 * v15));
          goto LABEL_55;
        }
        if (v133 != 2)
        {
          if (v133 == 1)
          {
            uint64_t v37 = v121;
            uint64_t v38 = v132;
            int v39 = *(unsigned __int8 *)(v132 + v121 + v19 * v30);
            uint64_t v40 = v27 * v18;
            int v41 = *(unsigned __int8 *)(v132 + v121 + (v32 + v40) * v15);
            uint64_t v42 = v40 + v31;
LABEL_48:
            int v44 = *(unsigned __int8 *)(v38 + v37 + v42 * v15);
            goto LABEL_55;
          }
LABEL_49:
          sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", a3, a4, a5, a6, a7, a8, v133);
          int v44 = 0;
          int v39 = 0;
          int v41 = 0;
          goto LABEL_55;
        }
        uint64_t v49 = v121;
        uint64_t v50 = v132;
        int v39 = *(unsigned __int16 *)(v132 + 2 * (v121 + v19 * v30));
        uint64_t v51 = v27 * v18;
        int v41 = *(unsigned __int16 *)(v132 + 2 * (v121 + (v32 + v51) * v15));
        uint64_t v52 = v51 + v31;
      }
      else
      {
        if (v12)
        {
          uint64_t v33 = 1;
          if (v18) {
            uint64_t v34 = 1;
          }
          else {
            uint64_t v34 = 2;
          }
          if (v18) {
            uint64_t v35 = 2;
          }
          else {
            uint64_t v35 = 1;
          }
          uint64_t v36 = v12 != 5;
          if (v12 == 1)
          {
            uint64_t v36 = 1;
          }
          else
          {
            uint64_t v34 = 2;
            uint64_t v35 = 1;
          }
        }
        else
        {
          uint64_t v36 = 3;
          uint64_t v33 = 3;
          uint64_t v34 = 2;
          uint64_t v35 = 1;
        }
        if (!v132)
        {
          int v41 = v18 * v36;
          int v54 = v33 * v18;
          int v39 = v35 + v54;
          int v44 = v54 + v34;
          goto LABEL_55;
        }
        if (v133 == 4)
        {
          uint64_t v45 = v121;
          uint64_t v46 = v132;
          int v41 = *(_DWORD *)(v132 + 4 * (v121 + v19 * v36));
          uint64_t v55 = v33 * v18;
          int v39 = *(_DWORD *)(v132 + 4 * (v121 + (v35 + v55) * v15));
          uint64_t v48 = v55 + v34;
          goto LABEL_52;
        }
        if (v133 != 2)
        {
          if (v133 == 1)
          {
            uint64_t v37 = v121;
            uint64_t v38 = v132;
            int v41 = *(unsigned __int8 *)(v132 + v121 + v19 * v36);
            uint64_t v53 = v33 * v18;
            int v39 = *(unsigned __int8 *)(v132 + v121 + (v35 + v53) * v15);
            uint64_t v42 = v53 + v34;
            goto LABEL_48;
          }
          goto LABEL_49;
        }
        uint64_t v49 = v121;
        uint64_t v50 = v132;
        int v41 = *(unsigned __int16 *)(v132 + 2 * (v121 + v19 * v36));
        uint64_t v56 = v33 * v18;
        int v39 = *(unsigned __int16 *)(v132 + 2 * (v121 + (v35 + v56) * v15));
        uint64_t v52 = v56 + v34;
      }
      int v44 = *(unsigned __int16 *)(v50 + 2 * (v49 + v52 * v15));
LABEL_55:
      uint64_t v57 = v13 + (v41 * v14);
      if (v16 == 1)
      {
        v58.i64[0] = *(void *)v57;
        v58.i64[1] = *(unsigned int *)(v57 + 8);
        uint64_t v59 = v13 + (v39 * v14);
        v60.i64[0] = *(void *)v59;
        v60.i64[1] = *(unsigned int *)(v59 + 8);
        uint64_t v61 = v13 + (v44 * v14);
        v25.i64[0] = *(void *)v61;
        v25.i64[1] = *(unsigned int *)(v61 + 8);
      }
      else
      {
        uint64_t v62 = v19;
        uint64_t v63 = v18;
        int v64 = v39;
        *(double *)v65.i64 = sub_1B65D6198(v124, (const float *)v57, a3, a4, a5, a6, a7, a8, v25, a10.f32[0], *(float *)a11.i32);
        float32x4_t v127 = v65;
        *(double *)v74.i64 = sub_1B65D6198(v124, (const float *)(v13 + (v64 * v14)), v66, v67, v68, v69, v70, v71, v65, v72, v73);
        float32x4_t v126 = v74;
        int v12 = v123;
        uint64_t v18 = v63;
        uint64_t v19 = v62;
        uint64_t v15 = v122;
        *(double *)v25.i64 = sub_1B65D6198(v124, (const float *)(v13 + (v44 * v14)), v75, v76, v77, v78, v79, v80, v74, v81, v82);
        float32x4_t v60 = v126;
        float32x4_t v58 = v127;
      }
      float32x4_t v83 = vsubq_f32(v60, v58);
      float32x4_t v84 = vsubq_f32(v25, v58);
      float32x4_t v85 = vnegq_f32(v83);
      float32x4_t v86 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v84, (int32x4_t)v84), (int8x16_t)v84, 0xCuLL), v85), v84, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v83, (int32x4_t)v83), (int8x16_t)v83, 0xCuLL));
      float32x4_t v87 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v86, (int32x4_t)v86), (int8x16_t)v86, 0xCuLL);
      float32x4_t v88 = vmulq_f32(v86, v86);
      v88.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v88.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v88, 2), v88)).u64[0];
      float32x4_t v89 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v88.f32, 0);
      v89.i32[3] = 0;
      float32x4_t v90 = vrsqrteq_f32(v89);
      float32x4_t v91 = vmulq_f32(v90, vrsqrtsq_f32(v89, vmulq_f32(v90, v90)));
      int32x4_t v92 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v88.f32[0] != 0.0)), 0x1FuLL));
      v92.i32[3] = 0;
      a11 = vbslq_s8((int8x16_t)vcltzq_s32(v92), (int8x16_t)vmulq_f32(vmulq_f32(v91, vrsqrtsq_f32(v89, vmulq_f32(v91, v91))), v87), (int8x16_t)v87);
      float32x4_t v93 = vmulq_f32(v58, (float32x4_t)a11);
      *(float *)&a11.i32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v93, 2), vaddq_f32(v93, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v93.f32, 1))).f32[0];
      a10 = vmulq_f32(v131, (float32x4_t)a11);
      a10.f32[0] = vaddv_f32(vadd_f32(*(float32x2_t *)a10.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a10, (int8x16_t)a10, 8uLL)));
      if (v129)
      {
        if (a10.f32[0] >= 0.0) {
          goto LABEL_71;
        }
      }
      else if (a10.f32[0] == 0.0)
      {
        goto LABEL_71;
      }
      int8x16_t v94 = (int8x16_t)vmulq_f32(v125, (float32x4_t)a11);
      float v95 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v94.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v94, v94, 8uLL)))
          / a10.f32[0];
      if (v95 >= 0.0 && v95 <= v26)
      {
        a10 = vmlaq_n_f32(v125, v131, v95);
        float32x4_t v97 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v84, (int8x16_t)v84, 0xCuLL), (int8x16_t)v84, 8uLL), v85), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v83, (int8x16_t)v83, 0xCuLL), (int8x16_t)v83, 8uLL), v84);
        float32x4_t v98 = vmulq_f32(v97, v97);
        int32x2_t v99 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v98, 2), vaddq_f32(v98, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v98.f32, 1))).u64[0];
        float32x4_t v100 = v120;
        if (fabsf(*(float *)v99.i32) >= 1.1755e-38)
        {
          float32x4_t v101 = vsubq_f32(v25, a10);
          float32x4_t v102 = vsubq_f32(v60, a10);
          float32x4_t v103 = vsubq_f32(v58, a10);
          float32x4_t v104 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v102, (int8x16_t)v102, 0xCuLL), (int8x16_t)v102, 8uLL);
          float32x4_t v105 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v101, (int8x16_t)v101, 0xCuLL), (int8x16_t)v101, 8uLL);
          float32x4_t v106 = vmlaq_f32(vmulq_f32(v105, vnegq_f32(v102)), v104, v101);
          float32x4_t v107 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v103, (int8x16_t)v103, 0xCuLL), (int8x16_t)v103, 8uLL);
          float32x4_t v108 = vmlaq_f32(vmulq_f32(v107, vnegq_f32(v101)), v105, v103);
          float32x4_t v109 = vmlaq_f32(vmulq_f32(v104, vnegq_f32(v103)), v107, v102);
          int32x4_t v110 = (int32x4_t)vmulq_f32(v97, v106);
          int32x4_t v111 = (int32x4_t)vmulq_f32(v97, v108);
          int32x4_t v112 = (int32x4_t)vmulq_f32(v97, v109);
          int32x4_t v113 = vdupq_laneq_s32(v111, 2);
          float32x4_t v114 = (float32x4_t)vzip1q_s32(vzip1q_s32(v110, v112), v111);
          float32x4_t v115 = (float32x4_t)vtrn2q_s32(v110, v111);
          v115.i32[2] = v112.i32[1];
          float32x4_t v100 = vdivq_f32(vaddq_f32((float32x4_t)vzip1q_s32(vzip2q_s32(v110, v112), v113), vaddq_f32(v114, v115)), (float32x4_t)vdupq_lane_s32(v99, 0));
        }
        v116.i64[0] = 0xBF000000BF000000;
        v116.i64[1] = 0xBF000000BF000000;
        v117.i64[0] = 0x3F0000003F000000;
        v117.i64[1] = 0x3F0000003F000000;
        float32x4_t v25 = (float32x4_t)vcgeq_f32(v117, vabsq_f32(vaddq_f32(v100, v116)));
        v25.i32[3] = v25.i32[2];
        v25.i32[0] = vminvq_u32((uint32x4_t)v25);
        if (v25.i32[0] < 0)
        {
          sub_1B63D5728(a3, v18, 0, 1, 2, v95, a10, (__n128)a11);
          if ((*(_WORD *)(a3 + 8) & 0x100) != 0) {
            return v130;
          }
        }
      }
LABEL_71:
      BOOL v130 = ++v18 < v128;
      v19 += v15;
      if (!--v11) {
        return v130;
      }
    }
  }
  return 0;
}

uint64_t sub_1B63D6940(unsigned int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a3 + 200);
  char v9 = *(unsigned char *)(a3 + 212);
  int v10 = *(unsigned __int8 *)(a3 + 213);
  v34[0] = a1;
  v34[1] = a2 - a1;
  BOOL v11 = *(unsigned char *)(a3 + 214) == 1;
  BOOL v12 = (*(unsigned char *)(a3 + 8) & 8) != 0 && *(unsigned char *)(a3 + 272) == 0;
  char v13 = *(unsigned char *)(a3 + 273);
  long long v14 = *(_OWORD *)(a3 + 80);
  long long v21 = *(_OWORD *)(a3 + 64);
  long long v22 = v14;
  long long v23 = *(_OWORD *)(a3 + 96);
  v32[0] = 0;
  v32[1] = v32;
  _OWORD v32[2] = 0x2020000000;
  char v33 = 0;
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3221225472;
  _OWORD v20[2] = sub_1B63D6A94;
  v20[3] = &unk_1E6141008;
  char v28 = v13;
  BOOL v29 = v11;
  int v27 = v10;
  char v30 = v9;
  BOOL v31 = v12;
  uint64_t v25 = v8;
  uint64_t v26 = a3;
  uint64_t v24 = v32;
  long long v16 = *(_OWORD *)(a3 + 216);
  int v17 = v34;
  __int16 v18 = 1;
  v19[0] = *(_OWORD *)(a3 + 242);
  *(_OWORD *)((char *)v19 + 14) = *(_OWORD *)(a3 + 256);
  sub_1B63D2A6C((uint64_t)&v16, (uint64_t)v20, a3, a4, a5, a6, a7, a8);
  _Block_object_dispose(v32, 8);
  return 0;
}

void sub_1B63D6A7C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1B63D6A94(float32x4_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x4_t a9, float32x4_t a10, int8x16_t a11)
{
  uint64_t v15 = 0;
  uint64_t v16 = (a4 - 2);
  uint64_t v17 = a3 + 4;
  __asm { FMOV            V20.4S, #-1.0 }
  v23.i64[0] = 0xBF000000BF000000;
  v23.i64[1] = 0xBF000000BF000000;
  v24.i64[0] = 0x3F0000003F000000;
  v24.i64[1] = 0x3F0000003F000000;
  float32x4_t v93 = _Q20;
  while (v16 != v15)
  {
    uint64_t v25 = (int *)(a1[6].i8[12] ? v17 : a3);
    uint64_t v26 = (int *)(a1[6].i8[12] ? a3 : v17);
    int v27 = *(_DWORD *)(a3 + 4 * (v15 + 2));
    int v28 = *v26;
    int v29 = *v25;
    if (a1[6].i8[13])
    {
      uint64_t v30 = a1[5].i64[1];
      __int32 v31 = a1[6].i32[2];
      uint64_t v32 = v30 + (v31 * v29);
      v33.i64[0] = *(void *)v32;
      v33.i64[1] = *(unsigned int *)(v32 + 8);
      uint64_t v34 = v30 + (v31 * v28);
      v35.i64[0] = *(void *)v34;
      v35.i64[1] = *(unsigned int *)(v34 + 8);
      uint64_t v36 = v30 + (v31 * v27);
      v37.i64[0] = *(void *)v36;
      v37.i64[1] = *(unsigned int *)(v36 + 8);
    }
    else
    {
      *(double *)v38.i64 = sub_1B65D6198(a1[6].u8[14], (const float *)(a1[5].i64[1] + (a1[6].i32[2] * v29)), a3, a4, (uint64_t)a5, a6, a7, a8, (float32x4_t)a9, a10.f32[0], *(float *)a11.i32);
      float32x4_t v95 = v38;
      *(double *)v47.i64 = sub_1B65D6198(a1[6].u8[14], (const float *)(a1[5].i64[1] + (a1[6].i32[2] * v28)), v39, v40, v41, v42, v43, v44, v38, v45, v46);
      float32x4_t v94 = v47;
      *(double *)v37.i64 = sub_1B65D6198(a1[6].u8[14], (const float *)(a1[5].i64[1] + (a1[6].i32[2] * v27)), v48, v49, v50, v51, v52, v53, v47, v54, v55);
      float32x4_t v35 = v94;
      float32x4_t v33 = v95;
      v24.i64[0] = 0x3F0000003F000000;
      v24.i64[1] = 0x3F0000003F000000;
      v23.i64[0] = 0xBF000000BF000000;
      v23.i64[1] = 0xBF000000BF000000;
      _Q20 = v93;
    }
    float32x4_t v56 = vsubq_f32(v35, v33);
    float32x4_t v57 = vsubq_f32(v37, v33);
    float32x4_t v58 = vnegq_f32(v56);
    float32x4_t v59 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v57, (int32x4_t)v57), (int8x16_t)v57, 0xCuLL), v58), v57, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v56, (int32x4_t)v56), (int8x16_t)v56, 0xCuLL));
    float32x4_t v60 = vmulq_f32(v59, v59);
    v60.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v60, 2), v60)).u64[0];
    float32x4_t v61 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.f32, 0);
    v61.i32[3] = 0;
    float32x4_t v62 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v59, (int32x4_t)v59), (int8x16_t)v59, 0xCuLL);
    float32x4_t v63 = vrsqrteq_f32(v61);
    float32x4_t v64 = vmulq_f32(v63, vrsqrtsq_f32(v61, vmulq_f32(v63, v63)));
    int32x4_t v65 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v60.f32[0] != 0.0)), 0x1FuLL));
    v65.i32[3] = 0;
    a11 = vbslq_s8((int8x16_t)vcltzq_s32(v65), (int8x16_t)vmulq_f32(v62, vmulq_f32(v64, vrsqrtsq_f32(v61, vmulq_f32(v64, v64)))), (int8x16_t)v62);
    float32x4_t v66 = vmulq_f32(v33, (float32x4_t)a11);
    *(float *)&a11.i32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 2), vaddq_f32(v66, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v66.f32, 1))).f32[0];
    float32x4_t v67 = a1[3];
    int8x16_t v68 = (int8x16_t)vmulq_f32((float32x4_t)a11, v67);
    float v69 = vaddv_f32(vadd_f32(*(float32x2_t *)v68.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL)));
    if (a1[6].i8[15])
    {
      if (v69 >= 0.0) {
        return;
      }
    }
    else if (v69 == 0.0)
    {
      return;
    }
    float32x4_t v70 = a1[2];
    int8x16_t v71 = (int8x16_t)vmulq_f32((float32x4_t)a11, v70);
    float v72 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v71.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v71, v71, 8uLL))) / v69;
    if (v72 < 0.0 || v72 > a1[4].f32[3]) {
      break;
    }
    a10 = vmlaq_n_f32(v70, v67, v72);
    float32x4_t v74 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v57, (int8x16_t)v57, 0xCuLL), (int8x16_t)v57, 8uLL), v58), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v56, (int8x16_t)v56, 0xCuLL), (int8x16_t)v56, 8uLL), v57);
    float32x4_t v75 = vmulq_f32(v74, v74);
    int32x2_t v76 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 2), vaddq_f32(v75, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v75.f32, 1))).u64[0];
    float32x4_t v77 = _Q20;
    if (fabsf(*(float *)v76.i32) >= 1.1755e-38)
    {
      float32x4_t v78 = vsubq_f32(v37, a10);
      float32x4_t v79 = vsubq_f32(v35, a10);
      float32x4_t v80 = vsubq_f32(v33, a10);
      float32x4_t v81 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v79, (int8x16_t)v79, 0xCuLL), (int8x16_t)v79, 8uLL);
      float32x4_t v82 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v78, (int8x16_t)v78, 0xCuLL), (int8x16_t)v78, 8uLL);
      float32x4_t v83 = vmlaq_f32(vmulq_f32(v82, vnegq_f32(v79)), v81, v78);
      float32x4_t v84 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v80, (int8x16_t)v80, 0xCuLL), (int8x16_t)v80, 8uLL);
      float32x4_t v85 = vmlaq_f32(vmulq_f32(v84, vnegq_f32(v78)), v82, v80);
      float32x4_t v86 = vmlaq_f32(vmulq_f32(v81, vnegq_f32(v80)), v84, v79);
      int32x4_t v87 = (int32x4_t)vmulq_f32(v74, v83);
      int32x4_t v88 = (int32x4_t)vmulq_f32(v74, v85);
      int32x4_t v89 = (int32x4_t)vmulq_f32(v74, v86);
      int32x4_t v90 = vdupq_laneq_s32(v88, 2);
      float32x4_t v91 = (float32x4_t)vzip1q_s32(vzip1q_s32(v87, v89), v88);
      float32x4_t v92 = (float32x4_t)vtrn2q_s32(v87, v88);
      v92.i32[2] = v89.i32[1];
      float32x4_t v77 = vdivq_f32(vaddq_f32((float32x4_t)vzip1q_s32(vzip2q_s32(v87, v89), v90), vaddq_f32(v91, v92)), (float32x4_t)vdupq_lane_s32(v76, 0));
    }
    a9 = vcgeq_f32(v24, vabsq_f32(vaddq_f32(v77, v23)));
    a9.i32[3] = a9.i32[2];
    a9.i32[0] = vminvq_u32((uint32x4_t)a9);
    v17 += 4;
    ++v15;
    if (a9.i32[0] < 0)
    {
      sub_1B63D5728(a1[6].i64[0], a2, 0, v15, v15 + 1, v72, a10, (__n128)a11);
      if ((*(_WORD *)(a1[6].i64[0] + 8) & 0x100) != 0)
      {
        *a5 = 1;
        *(unsigned char *)(*(void *)(a1[5].i64[0] + 8) + 24) = 1;
      }
      return;
    }
  }
}

BOOL sub_1B63D6E04(unsigned int a1, unsigned int a2, uint64_t a3, double a4, float32x4_t a5, int8x16_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  BOOL v126 = (*(_WORD *)(a3 + 8) & 8) != 0 && *(unsigned char *)(a3 + 272) == 0;
  unsigned int v11 = a2 - a1;
  if (a2 > a1)
  {
    int v117 = *(unsigned __int8 *)(a3 + 212);
    uint64_t v12 = *(void *)(a3 + 216);
    int v13 = *(unsigned __int8 *)(a3 + 242);
    uint64_t v129 = *(unsigned __int8 *)(a3 + 243);
    uint64_t v14 = *(void *)(a3 + 200);
    int v15 = *(unsigned __int8 *)(a3 + 213);
    uint64_t v16 = *(void *)(a3 + 264);
    uint64_t v128 = *(void *)(a3 + 256);
    int v125 = *(unsigned __int8 *)(a3 + 214);
    int v17 = *(unsigned __int8 *)(a3 + 273);
    uint64_t v18 = a1;
    unint64_t v19 = a2;
    uint64_t v20 = v16 * a1;
    __asm { FMOV            V0.4S, #-1.0 }
    float32x4_t v115 = _Q0;
    float32x4_t v118 = *(float32x4_t *)(a3 + 64);
    float32x4_t v26 = *(float32x4_t *)(a3 + 80);
    float32x4_t v127 = v26;
    BOOL v27 = 1;
    float v28 = *(float *)(a3 + 108);
    uint64_t v123 = v16;
    uint64_t v124 = a3;
    int v122 = v17;
    unint64_t v121 = a2;
    int v116 = v13;
    while (1)
    {
      if (v17)
      {
        if (v13)
        {
          if (v18) {
            uint64_t v29 = 1;
          }
          else {
            uint64_t v29 = 2;
          }
          if (v18) {
            uint64_t v30 = 2;
          }
          else {
            uint64_t v30 = 1;
          }
          uint64_t v31 = v13 == 1 || v13 != 5;
          uint64_t v32 = 1;
          if (v13 == 1) {
            uint64_t v33 = v29;
          }
          else {
            uint64_t v33 = 2;
          }
          if (v13 == 1) {
            uint64_t v34 = v30;
          }
          else {
            uint64_t v34 = 1;
          }
          if (!v12)
          {
LABEL_46:
            unsigned int v36 = v18 * v31;
            int v46 = v32 * v18;
            unsigned int v38 = v34 + v46;
            unsigned int v45 = v46 + v33;
            goto LABEL_56;
          }
        }
        else
        {
          uint64_t v31 = 3;
          uint64_t v32 = 3;
          uint64_t v33 = 2;
          uint64_t v34 = 1;
          if (!v12) {
            goto LABEL_46;
          }
        }
        if (v129 == 4)
        {
          uint64_t v47 = v128;
          unsigned int v36 = *(_DWORD *)(v12 + 4 * (v128 + v20 * v31));
          uint64_t v48 = v32 * v18;
          unsigned int v38 = *(_DWORD *)(v12 + 4 * (v128 + (v34 + v48) * v16));
          uint64_t v49 = v48 + v33;
LABEL_53:
          unsigned int v45 = *(_DWORD *)(v12 + 4 * (v47 + v49 * v16));
          goto LABEL_56;
        }
        if (v129 != 2)
        {
          if (v129 == 1)
          {
            uint64_t v35 = v128;
            unsigned int v36 = *(unsigned __int8 *)(v12 + v128 + v20 * v31);
            uint64_t v37 = v32 * v18;
            unsigned int v38 = *(unsigned __int8 *)(v12 + v128 + (v34 + v37) * v16);
            uint64_t v39 = v37 + v33;
LABEL_44:
            unsigned int v45 = *(unsigned __int8 *)(v12 + v35 + v39 * v16);
            goto LABEL_56;
          }
LABEL_47:
          sub_1B63F2F54(16, @"Unreachable code: Invalid bytes per index (%d)", a3, 2, a8, a9, a10, a11, v129);
          unint64_t v19 = v121;
          int v17 = v122;
          uint64_t v16 = v123;
          a3 = v124;
          unsigned int v45 = 0;
          unsigned int v36 = 0;
          unsigned int v38 = 0;
          goto LABEL_56;
        }
        uint64_t v50 = v128;
        unsigned int v36 = *(unsigned __int16 *)(v12 + 2 * (v128 + v20 * v31));
        uint64_t v51 = v32 * v18;
        unsigned int v38 = *(unsigned __int16 *)(v12 + 2 * (v128 + (v34 + v51) * v16));
        uint64_t v52 = v51 + v33;
      }
      else
      {
        if (v13)
        {
          if (v18) {
            uint64_t v40 = 1;
          }
          else {
            uint64_t v40 = 2;
          }
          if (v18) {
            uint64_t v41 = 2;
          }
          else {
            uint64_t v41 = 1;
          }
          uint64_t v42 = v13 != 5;
          if (v13 == 1) {
            uint64_t v42 = 1;
          }
          uint64_t v43 = 1;
          if (v13 != 1)
          {
            uint64_t v40 = 2;
            uint64_t v41 = 1;
          }
          if (!v12)
          {
LABEL_51:
            unsigned int v38 = v18 * v42;
            int v53 = v43 * v18;
            unsigned int v36 = v41 + v53;
            unsigned int v45 = v53 + v40;
            goto LABEL_56;
          }
        }
        else
        {
          uint64_t v42 = 3;
          uint64_t v43 = 3;
          uint64_t v40 = 2;
          uint64_t v41 = 1;
          if (!v12) {
            goto LABEL_51;
          }
        }
        if (v129 == 4)
        {
          uint64_t v47 = v128;
          unsigned int v38 = *(_DWORD *)(v12 + 4 * (v128 + v20 * v42));
          uint64_t v54 = v43 * v18;
          unsigned int v36 = *(_DWORD *)(v12 + 4 * (v128 + (v41 + v54) * v16));
          uint64_t v49 = v54 + v40;
          goto LABEL_53;
        }
        if (v129 != 2)
        {
          if (v129 == 1)
          {
            uint64_t v35 = v128;
            unsigned int v38 = *(unsigned __int8 *)(v12 + v128 + v20 * v42);
            uint64_t v44 = v43 * v18;
            unsigned int v36 = *(unsigned __int8 *)(v12 + v128 + (v41 + v44) * v16);
            uint64_t v39 = v44 + v40;
            goto LABEL_44;
          }
          goto LABEL_47;
        }
        uint64_t v50 = v128;
        unsigned int v38 = *(unsigned __int16 *)(v12 + 2 * (v128 + v20 * v42));
        uint64_t v55 = v43 * v18;
        unsigned int v36 = *(unsigned __int16 *)(v12 + 2 * (v128 + (v41 + v55) * v16));
        uint64_t v52 = v55 + v40;
      }
      unsigned int v45 = *(unsigned __int16 *)(v12 + 2 * (v50 + v52 * v16));
LABEL_56:
      if (((*(unsigned char *)(*(void *)(a3 + 304) + v36) & *(unsigned char *)(*(void *)(a3 + 304) + v38)) & *(unsigned char *)(*(void *)(a3 + 304) + v45)) == 0)
      {
        uint64_t v56 = v14 + v38 * v15;
        if (v125 == 1)
        {
          v57.i64[0] = *(void *)v56;
          v57.i64[1] = *(unsigned int *)(v56 + 8);
          uint64_t v58 = v14 + v36 * v15;
          v59.i64[0] = *(void *)v58;
          v59.i64[1] = *(unsigned int *)(v58 + 8);
          uint64_t v60 = v14 + v45 * v15;
          v26.i64[0] = *(void *)v60;
          v26.i64[1] = *(unsigned int *)(v60 + 8);
        }
        else
        {
          *(double *)v61.i64 = sub_1B65D6198(v117, (const float *)v56, a3, 2, a8, a9, a10, a11, v26, a5.f32[0], *(float *)a6.i32);
          float32x4_t v120 = v61;
          *(double *)v70.i64 = sub_1B65D6198(v117, (const float *)(v14 + v36 * v15), v62, v63, v64, v65, v66, v67, v61, v68, v69);
          float32x4_t v119 = v70;
          int v13 = v116;
          *(double *)v26.i64 = sub_1B65D6198(v117, (const float *)(v14 + v45 * v15), v71, v72, v73, v74, v75, v76, v70, v77, v78);
          float32x4_t v59 = v119;
          float32x4_t v57 = v120;
          unint64_t v19 = v121;
          int v17 = v122;
          uint64_t v16 = v123;
          a3 = v124;
        }
        float32x4_t v79 = vsubq_f32(v59, v57);
        float32x4_t v80 = vsubq_f32(v26, v57);
        float32x4_t v81 = vnegq_f32(v79);
        float32x4_t v82 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v80, (int32x4_t)v80), (int8x16_t)v80, 0xCuLL), v81), v80, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v79, (int32x4_t)v79), (int8x16_t)v79, 0xCuLL));
        float32x4_t v83 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v82, (int32x4_t)v82), (int8x16_t)v82, 0xCuLL);
        float32x4_t v84 = vmulq_f32(v82, v82);
        v84.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v84.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v84, 2), v84)).u64[0];
        float32x4_t v85 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v84.f32, 0);
        v85.i32[3] = 0;
        float32x4_t v86 = vrsqrteq_f32(v85);
        float32x4_t v87 = vmulq_f32(v86, vrsqrtsq_f32(v85, vmulq_f32(v86, v86)));
        int32x4_t v88 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v84.f32[0] != 0.0)), 0x1FuLL));
        v88.i32[3] = 0;
        a6 = vbslq_s8((int8x16_t)vcltzq_s32(v88), (int8x16_t)vmulq_f32(vmulq_f32(v87, vrsqrtsq_f32(v85, vmulq_f32(v87, v87))), v83), (int8x16_t)v83);
        float32x4_t v89 = vmulq_f32(v57, (float32x4_t)a6);
        *(float *)&a6.i32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v89, 2), vaddq_f32(v89, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v89.f32, 1))).f32[0];
        a5 = vmulq_f32(v127, (float32x4_t)a6);
        a5.f32[0] = vaddv_f32(vadd_f32(*(float32x2_t *)a5.f32, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL)));
        if (v126)
        {
          if (a5.f32[0] >= 0.0) {
            goto LABEL_57;
          }
        }
        else if (a5.f32[0] == 0.0)
        {
          goto LABEL_57;
        }
        int8x16_t v90 = (int8x16_t)vmulq_f32(v118, (float32x4_t)a6);
        float v91 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v90.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v90, v90, 8uLL)))
            / a5.f32[0];
        if (v91 >= 0.0 && v91 <= v28)
        {
          a5 = vmlaq_n_f32(v118, v127, v91);
          float32x4_t v93 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v80, (int8x16_t)v80, 0xCuLL), (int8x16_t)v80, 8uLL), v81), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v79, (int8x16_t)v79, 0xCuLL), (int8x16_t)v79, 8uLL), v80);
          float32x4_t v94 = vmulq_f32(v93, v93);
          int32x2_t v95 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 2), vaddq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v94.f32, 1))).u64[0];
          float32x4_t v96 = v115;
          if (fabsf(*(float *)v95.i32) >= 1.1755e-38)
          {
            float32x4_t v97 = vsubq_f32(v26, a5);
            float32x4_t v98 = vsubq_f32(v59, a5);
            float32x4_t v99 = vsubq_f32(v57, a5);
            float32x4_t v100 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v98, (int8x16_t)v98, 0xCuLL), (int8x16_t)v98, 8uLL);
            float32x4_t v101 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v97, (int8x16_t)v97, 0xCuLL), (int8x16_t)v97, 8uLL);
            float32x4_t v102 = vmlaq_f32(vmulq_f32(v101, vnegq_f32(v98)), v100, v97);
            float32x4_t v103 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v99, (int8x16_t)v99, 0xCuLL), (int8x16_t)v99, 8uLL);
            float32x4_t v104 = vmlaq_f32(vmulq_f32(v103, vnegq_f32(v97)), v101, v99);
            float32x4_t v105 = vmlaq_f32(vmulq_f32(v100, vnegq_f32(v99)), v103, v98);
            int32x4_t v106 = (int32x4_t)vmulq_f32(v93, v102);
            int32x4_t v107 = (int32x4_t)vmulq_f32(v93, v104);
            int32x4_t v108 = (int32x4_t)vmulq_f32(v93, v105);
            int32x4_t v109 = vdupq_laneq_s32(v107, 2);
            float32x4_t v110 = (float32x4_t)vzip1q_s32(vzip1q_s32(v106, v108), v107);
            float32x4_t v111 = (float32x4_t)vtrn2q_s32(v106, v107);
            v111.i32[2] = v108.i32[1];
            float32x4_t v96 = vdivq_f32(vaddq_f32((float32x4_t)vzip1q_s32(vzip2q_s32(v106, v108), v109), vaddq_f32(v110, v111)), (float32x4_t)vdupq_lane_s32(v95, 0));
          }
          v112.i64[0] = 0xBF000000BF000000;
          v112.i64[1] = 0xBF000000BF000000;
          v113.i64[0] = 0x3F0000003F000000;
          v113.i64[1] = 0x3F0000003F000000;
          float32x4_t v26 = (float32x4_t)vcgeq_f32(v113, vabsq_f32(vaddq_f32(v96, v112)));
          v26.i32[3] = v26.i32[2];
          v26.i32[0] = vminvq_u32((uint32x4_t)v26);
          if (v26.i32[0] < 0)
          {
            sub_1B63D5728(a3, v18, 0, 1, 2, v91, a5, (__n128)a6);
            unint64_t v19 = v121;
            int v17 = v122;
            uint64_t v16 = v123;
            a3 = v124;
            if ((*(_WORD *)(v124 + 8) & 0x100) != 0) {
              return v27;
            }
          }
        }
      }
LABEL_57:
      BOOL v27 = ++v18 < v19;
      v20 += v16;
      if (!--v11) {
        return v27;
      }
    }
  }
  return 0;
}

uint64_t sub_1B63D743C(unsigned int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a3 + 200);
  char v9 = *(unsigned char *)(a3 + 212);
  int v10 = *(unsigned __int8 *)(a3 + 213);
  v34[0] = a1;
  v34[1] = a2 - a1;
  BOOL v11 = *(unsigned char *)(a3 + 214) == 1;
  BOOL v12 = (*(unsigned char *)(a3 + 8) & 8) != 0 && *(unsigned char *)(a3 + 272) == 0;
  char v13 = *(unsigned char *)(a3 + 273);
  long long v14 = *(_OWORD *)(a3 + 80);
  long long v21 = *(_OWORD *)(a3 + 64);
  long long v22 = v14;
  long long v23 = *(_OWORD *)(a3 + 96);
  v32[0] = 0;
  v32[1] = v32;
  _OWORD v32[2] = 0x2020000000;
  char v33 = 0;
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 3221225472;
  _OWORD v20[2] = sub_1B63D7590;
  v20[3] = &unk_1E6141008;
  char v28 = v13;
  BOOL v29 = v11;
  uint64_t v25 = a3;
  uint64_t v26 = v8;
  int v27 = v10;
  char v30 = v9;
  BOOL v31 = v12;
  float32x4_t v24 = v32;
  long long v16 = *(_OWORD *)(a3 + 216);
  int v17 = v34;
  __int16 v18 = 1;
  v19[0] = *(_OWORD *)(a3 + 242);
  *(_OWORD *)((char *)v19 + 14) = *(_OWORD *)(a3 + 256);
  sub_1B63D2A6C((uint64_t)&v16, (uint64_t)v20, a3, a4, a5, a6, a7, a8);
  _Block_object_dispose(v32, 8);
  return 0;
}

void sub_1B63D7578(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1B63D7590(float32x4_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t a8, int32x4_t a9, float32x4_t a10, int8x16_t a11)
{
  uint64_t v15 = 0;
  uint64_t v16 = (a4 - 2);
  uint64_t v17 = a3 + 4;
  __asm { FMOV            V20.4S, #-1.0 }
  v23.i64[0] = 0xBF000000BF000000;
  v23.i64[1] = 0xBF000000BF000000;
  v24.i64[0] = 0x3F0000003F000000;
  v24.i64[1] = 0x3F0000003F000000;
  float32x4_t v93 = _Q20;
  while (v16 != v15)
  {
    uint64_t v25 = (unsigned int *)(a1[6].i8[12] ? v17 : a3);
    uint64_t v26 = (unsigned int *)(a1[6].i8[12] ? a3 : v17);
    uint64_t v27 = *(unsigned int *)(a3 + 4 * (v15 + 2));
    uint64_t v28 = *v26;
    uint64_t v29 = *v25;
    if (((*(unsigned char *)(*(void *)(a1[5].i64[1] + 304) + v28) & *(unsigned char *)(*(void *)(a1[5].i64[1] + 304)
                                                                                         + v29)) & *(unsigned char *)(*(void *)(a1[5].i64[1] + 304) + v27)) != 0)
      break;
    if (a1[6].i8[13])
    {
      uint64_t v30 = a1[6].i64[0];
      __int32 v31 = a1[6].i32[2];
      uint64_t v32 = v30 + (v31 * v29);
      v33.i64[0] = *(void *)v32;
      v33.i64[1] = *(unsigned int *)(v32 + 8);
      uint64_t v34 = v30 + (v31 * v28);
      v35.i64[0] = *(void *)v34;
      v35.i64[1] = *(unsigned int *)(v34 + 8);
      uint64_t v36 = v30 + (v31 * v27);
      v37.i64[0] = *(void *)v36;
      v37.i64[1] = *(unsigned int *)(v36 + 8);
    }
    else
    {
      *(double *)v38.i64 = sub_1B65D6198(a1[6].u8[14], (const float *)(a1[6].i64[0] + (a1[6].i32[2] * v29)), a3, a4, (uint64_t)a5, a6, a7, a8, (float32x4_t)a9, a10.f32[0], *(float *)a11.i32);
      float32x4_t v95 = v38;
      *(double *)v47.i64 = sub_1B65D6198(a1[6].u8[14], (const float *)(a1[6].i64[0] + (a1[6].i32[2] * v28)), v39, v40, v41, v42, v43, v44, v38, v45, v46);
      float32x4_t v94 = v47;
      *(double *)v37.i64 = sub_1B65D6198(a1[6].u8[14], (const float *)(a1[6].i64[0] + (a1[6].i32[2] * v27)), v48, v49, v50, v51, v52, v53, v47, v54, v55);
      float32x4_t v35 = v94;
      float32x4_t v33 = v95;
      v24.i64[0] = 0x3F0000003F000000;
      v24.i64[1] = 0x3F0000003F000000;
      v23.i64[0] = 0xBF000000BF000000;
      v23.i64[1] = 0xBF000000BF000000;
      _Q20 = v93;
    }
    float32x4_t v56 = vsubq_f32(v35, v33);
    float32x4_t v57 = vsubq_f32(v37, v33);
    float32x4_t v58 = vnegq_f32(v56);
    float32x4_t v59 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v57, (int32x4_t)v57), (int8x16_t)v57, 0xCuLL), v58), v57, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v56, (int32x4_t)v56), (int8x16_t)v56, 0xCuLL));
    float32x4_t v60 = vmulq_f32(v59, v59);
    v60.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v60, 2), v60)).u64[0];
    float32x4_t v61 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v60.f32, 0);
    v61.i32[3] = 0;
    float32x4_t v62 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v59, (int32x4_t)v59), (int8x16_t)v59, 0xCuLL);
    float32x4_t v63 = vrsqrteq_f32(v61);
    float32x4_t v64 = vmulq_f32(v63, vrsqrtsq_f32(v61, vmulq_f32(v63, v63)));
    int32x4_t v65 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v60.f32[0] != 0.0)), 0x1FuLL));
    v65.i32[3] = 0;
    a11 = vbslq_s8((int8x16_t)vcltzq_s32(v65), (int8x16_t)vmulq_f32(v62, vmulq_f32(v64, vrsqrtsq_f32(v61, vmulq_f32(v64, v64)))), (int8x16_t)v62);
    float32x4_t v66 = vmulq_f32(v33, (float32x4_t)a11);
    *(float *)&a11.i32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 2), vaddq_f32(v66, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v66.f32, 1))).f32[0];
    float32x4_t v67 = a1[3];
    int8x16_t v68 = (int8x16_t)vmulq_f32((float32x4_t)a11, v67);
    float v69 = vaddv_f32(vadd_f32(*(float32x2_t *)v68.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v68, v68, 8uLL)));
    if (a1[6].i8[15])
    {
      if (v69 >= 0.0) {
        return;
      }
    }
    else if (v69 == 0.0)
    {
      return;
    }
    float32x4_t v70 = a1[2];
    int8x16_t v71 = (int8x16_t)vmulq_f32((float32x4_t)a11, v70);
    float v72 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v71.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v71, v71, 8uLL))) / v69;
    if (v72 < 0.0 || v72 > a1[4].f32[3]) {
      break;
    }
    a10 = vmlaq_n_f32(v70, v67, v72);
    float32x4_t v74 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v57, (int8x16_t)v57, 0xCuLL), (int8x16_t)v57, 8uLL), v58), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v56, (int8x16_t)v56, 0xCuLL), (int8x16_t)v56, 8uLL), v57);
    float32x4_t v75 = vmulq_f32(v74, v74);
    int32x2_t v76 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v75, 2), vaddq_f32(v75, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v75.f32, 1))).u64[0];
    float32x4_t v77 = _Q20;
    if (fabsf(*(float *)v76.i32) >= 1.1755e-38)
    {
      float32x4_t v78 = vsubq_f32(v37, a10);
      float32x4_t v79 = vsubq_f32(v35, a10);
      float32x4_t v80 = vsubq_f32(v33, a10);
      float32x4_t v81 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v79, (int8x16_t)v79, 0xCuLL), (int8x16_t)v79, 8uLL);
      float32x4_t v82 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v78, (int8x16_t)v78, 0xCuLL), (int8x16_t)v78, 8uLL);
      float32x4_t v83 = vmlaq_f32(vmulq_f32(v82, vnegq_f32(v79)), v81, v78);
      float32x4_t v84 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v80, (int8x16_t)v80, 0xCuLL), (int8x16_t)v80, 8uLL);
      float32x4_t v85 = vmlaq_f32(vmulq_f32(v84, vnegq_f32(v78)), v82, v80);
      float32x4_t v86 = vmlaq_f32(vmulq_f32(v81, vnegq_f32(v80)), v84, v79);
      int32x4_t v87 = (int32x4_t)vmulq_f32(v74, v83);
      int32x4_t v88 = (int32x4_t)vmulq_f32(v74, v85);
      int32x4_t v89 = (int32x4_t)vmulq_f32(v74, v86);
      int32x4_t v90 = vdupq_laneq_s32(v88, 2);
      float32x4_t v91 = (float32x4_t)vzip1q_s32(vzip1q_s32(v87, v89), v88);
      float32x4_t v92 = (float32x4_t)vtrn2q_s32(v87, v88);
      v92.i32[2] = v89.i32[1];
      float32x4_t v77 = vdivq_f32(vaddq_f32((float32x4_t)vzip1q_s32(vzip2q_s32(v87, v89), v90), vaddq_f32(v91, v92)), (float32x4_t)vdupq_lane_s32(v76, 0));
    }
    a9 = vcgeq_f32(v24, vabsq_f32(vaddq_f32(v77, v23)));
    a9.i32[3] = a9.i32[2];
    a9.i32[0] = vminvq_u32((uint32x4_t)a9);
    v17 += 4;
    ++v15;
    if (a9.i32[0] < 0)
    {
      sub_1B63D5728(a1[5].i64[1], a2, 0, v15, v15 + 1, v72, a10, (__n128)a11);
      if ((*(_WORD *)(a1[5].i64[1] + 8) & 0x100) != 0)
      {
        *a5 = 1;
        *(unsigned char *)(*(void *)(a1[5].i64[0] + 8) + 24) = 1;
      }
      return;
    }
  }
}

BOOL sub_1B63D7920(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, int32x4_t a12, float32x4_t a13, float32x4_t a14)
{
  uint64_t v17 = *(void *)(a3 + 200);
  unsigned int v18 = *(unsigned __int8 *)(a3 + 213);
  uint64_t v19 = *(void *)(a3 + 216);
  if (*(void *)(a3 + 256) || *(void *)(a3 + 264) != 1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Update %s to support mesh element channels", a3, a4, a5, a6, a7, a8, (uint64_t)"ctx->_currentIndicesContent.indicesOffset == 0 && ctx->_currentIndicesContent.indicesStride == 1");
  }
  unsigned int v20 = a2 - a1;
  if (a2 <= a1)
  {
    return 0;
  }
  else
  {
    uint64_t v21 = a1;
    BOOL v22 = 1;
    __asm { FMOV            V20.4S, #-1.0 }
    v28.i64[0] = 0xBF000000BF000000;
    v28.i64[1] = 0xBF000000BF000000;
    v29.i64[0] = 0x3F0000003F000000;
    v29.i64[1] = 0x3F0000003F000000;
    unsigned int v30 = 3 * a1;
    float32x4_t v74 = _Q20;
    do
    {
      if (((*(unsigned char *)(*(void *)(a3 + 304) + *(unsigned __int16 *)(v19 + 2 * (v30 + 1))) & *(unsigned char *)(*(void *)(a3 + 304) + *(unsigned __int16 *)(v19 + 2 * v30))) & *(unsigned char *)(*(void *)(a3 + 304) + *(unsigned __int16 *)(v19 + 2 * (v30 + 2)))) == 0)
      {
        uint64_t v31 = v17 + *(unsigned __int16 *)(v19 + 2 * v30) * (unint64_t)v18;
        a12.i64[0] = *(void *)v31;
        a12.i32[2] = *(_DWORD *)(v31 + 8);
        uint64_t v32 = v17 + *(unsigned __int16 *)(v19 + 2 * (v30 + 1)) * (unint64_t)v18;
        a13.i64[0] = *(void *)v32;
        a13.i32[2] = *(_DWORD *)(v32 + 8);
        uint64_t v33 = v17 + *(unsigned __int16 *)(v19 + 2 * (v30 + 2)) * (unint64_t)v18;
        a14.i64[0] = *(void *)v33;
        a14.i32[2] = *(_DWORD *)(v33 + 8);
        float32x4_t v34 = vsubq_f32(a13, (float32x4_t)a12);
        float32x4_t v35 = vsubq_f32(a14, (float32x4_t)a12);
        float32x4_t v36 = vnegq_f32(v34);
        float32x4_t v37 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), (int8x16_t)v35, 0xCuLL), v36), v35, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v34, (int32x4_t)v34), (int8x16_t)v34, 0xCuLL));
        float32x4_t v38 = vmulq_f32(v37, v37);
        v38.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v38, 2), v38)).u64[0];
        float32x4_t v39 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v38.f32, 0);
        v39.i32[3] = 0;
        float32x4_t v40 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v37, (int32x4_t)v37), (int8x16_t)v37, 0xCuLL);
        float32x4_t v41 = vrsqrteq_f32(v39);
        float32x4_t v42 = vmulq_f32(v41, vrsqrtsq_f32(v39, vmulq_f32(v41, v41)));
        int32x4_t v43 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v38.f32[0] != 0.0)), 0x1FuLL));
        v43.i32[3] = 0;
        __n128 v45 = (__n128)vbslq_s8((int8x16_t)vcltzq_s32(v43), (int8x16_t)vmulq_f32(vmulq_f32(v42, vrsqrtsq_f32(v39, vmulq_f32(v42, v42))), v40), (int8x16_t)v40);
        float32x4_t v44 = vmulq_f32((float32x4_t)a12, (float32x4_t)v45);
        v45.n128_f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).f32[0];
        float32x4_t v46 = *(float32x4_t *)(a3 + 80);
        int8x16_t v47 = (int8x16_t)vmulq_f32(v46, (float32x4_t)v45);
        float v48 = vaddv_f32(vadd_f32(*(float32x2_t *)v47.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL)));
        if (v48 < 0.0)
        {
          float32x4_t v49 = *(float32x4_t *)(a3 + 64);
          int8x16_t v50 = (int8x16_t)vmulq_f32(v49, (float32x4_t)v45);
          float v51 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)))
              / v48;
          if (v51 >= 0.0 && v51 <= *(float *)(a3 + 108))
          {
            float32x4_t v53 = vmlaq_n_f32(v49, v46, v51);
            float32x4_t v54 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v35, (int8x16_t)v35, 0xCuLL), (int8x16_t)v35, 8uLL), v36), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v34, (int8x16_t)v34, 0xCuLL), (int8x16_t)v34, 8uLL), v35);
            float32x4_t v55 = vmulq_f32(v54, v54);
            int32x2_t v56 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v55, 2), vaddq_f32(v55, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v55.f32, 1))).u64[0];
            float32x4_t v57 = _Q20;
            if (fabsf(*(float *)v56.i32) >= 1.1755e-38)
            {
              float32x4_t v58 = vsubq_f32(a14, v53);
              float32x4_t v59 = vsubq_f32(a13, v53);
              float32x4_t v60 = vsubq_f32((float32x4_t)a12, v53);
              float32x4_t v61 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v59, (int8x16_t)v59, 0xCuLL), (int8x16_t)v59, 8uLL);
              float32x4_t v62 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v58, (int8x16_t)v58, 0xCuLL), (int8x16_t)v58, 8uLL);
              float32x4_t v63 = vmlaq_f32(vmulq_f32(v62, vnegq_f32(v59)), v61, v58);
              float32x4_t v64 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v60, (int8x16_t)v60, 0xCuLL), (int8x16_t)v60, 8uLL);
              float32x4_t v65 = vmlaq_f32(vmulq_f32(v64, vnegq_f32(v58)), v62, v60);
              float32x4_t v66 = vmlaq_f32(vmulq_f32(v61, vnegq_f32(v60)), v64, v59);
              int32x4_t v67 = (int32x4_t)vmulq_f32(v54, v63);
              a14 = vmulq_f32(v54, v65);
              int32x4_t v68 = (int32x4_t)vmulq_f32(v54, v66);
              int32x4_t v69 = vzip2q_s32(v67, v68);
              float32x4_t v70 = (float32x4_t)vzip1q_s32(vzip1q_s32(v67, v68), (int32x4_t)a14);
              float32x4_t v71 = (float32x4_t)vtrn2q_s32(v67, (int32x4_t)a14);
              v71.i32[2] = v68.i32[1];
              float32x4_t v72 = vaddq_f32((float32x4_t)vzip1q_s32(v69, vdupq_laneq_s32((int32x4_t)a14, 2)), vaddq_f32(v70, v71));
              a13 = (float32x4_t)vdupq_lane_s32(v56, 0);
              float32x4_t v57 = vdivq_f32(v72, a13);
            }
            a12 = vcgeq_f32(v29, vabsq_f32(vaddq_f32(v57, v28)));
            a12.i32[3] = a12.i32[2];
            if ((vminvq_u32((uint32x4_t)a12) & 0x80000000) != 0)
            {
              sub_1B63D5728(a3, v21, 0, 1, 2, v51, v53, v45);
              v29.i64[0] = 0x3F0000003F000000;
              v29.i64[1] = 0x3F0000003F000000;
              v28.i64[0] = 0xBF000000BF000000;
              v28.i64[1] = 0xBF000000BF000000;
              _Q20 = v74;
              if ((*(_WORD *)(a3 + 8) & 0x100) != 0) {
                break;
              }
            }
          }
        }
      }
      BOOL v22 = ++v21 < (unint64_t)a2;
      v30 += 3;
      --v20;
    }
    while (v20);
  }
  return v22;
}

BOOL sub_1B63D7C54(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, int32x4_t a12, float32x4_t a13, float32x4_t a14)
{
  uint64_t v17 = *(void *)(a3 + 200);
  unsigned int v18 = *(unsigned __int8 *)(a3 + 213);
  uint64_t v19 = *(void *)(a3 + 216);
  if (*(void *)(a3 + 256) || *(void *)(a3 + 264) != 1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Update %s to support mesh element channels", a3, a4, a5, a6, a7, a8, (uint64_t)"ctx->_currentIndicesContent.indicesOffset == 0 && ctx->_currentIndicesContent.indicesStride == 1");
  }
  unsigned int v20 = a2 - a1;
  if (a2 <= a1)
  {
    return 0;
  }
  else
  {
    uint64_t v21 = a1;
    BOOL v22 = 1;
    __asm { FMOV            V20.4S, #-1.0 }
    v28.i64[0] = 0xBF000000BF000000;
    v28.i64[1] = 0xBF000000BF000000;
    v29.i64[0] = 0x3F0000003F000000;
    v29.i64[1] = 0x3F0000003F000000;
    unsigned int v30 = 3 * a1;
    float32x4_t v77 = _Q20;
    do
    {
      if (v19)
      {
        unsigned __int16 v31 = *(_WORD *)(v19 + 2 * v30);
        unsigned __int16 v32 = *(_WORD *)(v19 + 2 * (v30 + 1));
        unsigned __int16 v33 = *(_WORD *)(v19 + 2 * (v30 + 2));
      }
      else
      {
        unsigned __int16 v32 = v30 + 1;
        unsigned __int16 v33 = v30 + 2;
        unsigned __int16 v31 = v30;
      }
      uint64_t v34 = v17 + v18 * (unint64_t)v31;
      a12.i64[0] = *(void *)v34;
      a12.i32[2] = *(_DWORD *)(v34 + 8);
      uint64_t v35 = v17 + v18 * (unint64_t)v32;
      a13.i64[0] = *(void *)v35;
      a13.i32[2] = *(_DWORD *)(v35 + 8);
      uint64_t v36 = v17 + v18 * (unint64_t)v33;
      a14.i64[0] = *(void *)v36;
      a14.i32[2] = *(_DWORD *)(v36 + 8);
      float32x4_t v37 = vsubq_f32(a13, (float32x4_t)a12);
      float32x4_t v38 = vsubq_f32(a14, (float32x4_t)a12);
      float32x4_t v39 = vnegq_f32(v37);
      float32x4_t v40 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v38, (int32x4_t)v38), (int8x16_t)v38, 0xCuLL), v39), v38, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v37, (int32x4_t)v37), (int8x16_t)v37, 0xCuLL));
      float32x4_t v41 = vmulq_f32(v40, v40);
      v41.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v41, 2), v41)).u64[0];
      float32x4_t v42 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v41.f32, 0);
      v42.i32[3] = 0;
      float32x4_t v43 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v40, (int32x4_t)v40), (int8x16_t)v40, 0xCuLL);
      float32x4_t v44 = vrsqrteq_f32(v42);
      float32x4_t v45 = vmulq_f32(v44, vrsqrtsq_f32(v42, vmulq_f32(v44, v44)));
      int32x4_t v46 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v41.f32[0] != 0.0)), 0x1FuLL));
      v46.i32[3] = 0;
      __n128 v48 = (__n128)vbslq_s8((int8x16_t)vcltzq_s32(v46), (int8x16_t)vmulq_f32(vmulq_f32(v45, vrsqrtsq_f32(v42, vmulq_f32(v45, v45))), v43), (int8x16_t)v43);
      float32x4_t v47 = vmulq_f32((float32x4_t)a12, (float32x4_t)v48);
      v48.n128_f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1))).f32[0];
      float32x4_t v49 = *(float32x4_t *)(a3 + 80);
      int8x16_t v50 = (int8x16_t)vmulq_f32(v49, (float32x4_t)v48);
      float v51 = vaddv_f32(vadd_f32(*(float32x2_t *)v50.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v50, v50, 8uLL)));
      if (v51 < 0.0)
      {
        float32x4_t v52 = *(float32x4_t *)(a3 + 64);
        int8x16_t v53 = (int8x16_t)vmulq_f32(v52, (float32x4_t)v48);
        float v54 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v53.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v53, v53, 8uLL)))
            / v51;
        if (v54 >= 0.0 && v54 <= *(float *)(a3 + 108))
        {
          float32x4_t v56 = vmlaq_n_f32(v52, v49, v54);
          float32x4_t v57 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v38, (int8x16_t)v38, 0xCuLL), (int8x16_t)v38, 8uLL), v39), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v37, (int8x16_t)v37, 0xCuLL), (int8x16_t)v37, 8uLL), v38);
          float32x4_t v58 = vmulq_f32(v57, v57);
          int32x2_t v59 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v58, 2), vaddq_f32(v58, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v58.f32, 1))).u64[0];
          float32x4_t v60 = _Q20;
          if (fabsf(*(float *)v59.i32) >= 1.1755e-38)
          {
            float32x4_t v61 = vsubq_f32(a14, v56);
            float32x4_t v62 = vsubq_f32(a13, v56);
            float32x4_t v63 = vsubq_f32((float32x4_t)a12, v56);
            float32x4_t v64 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v62, (int8x16_t)v62, 0xCuLL), (int8x16_t)v62, 8uLL);
            float32x4_t v65 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v61, (int8x16_t)v61, 0xCuLL), (int8x16_t)v61, 8uLL);
            float32x4_t v66 = vmlaq_f32(vmulq_f32(v65, vnegq_f32(v62)), v64, v61);
            float32x4_t v67 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v63, (int8x16_t)v63, 0xCuLL), (int8x16_t)v63, 8uLL);
            float32x4_t v68 = vmlaq_f32(vmulq_f32(v67, vnegq_f32(v61)), v65, v63);
            float32x4_t v69 = vmlaq_f32(vmulq_f32(v64, vnegq_f32(v63)), v67, v62);
            int32x4_t v70 = (int32x4_t)vmulq_f32(v57, v66);
            a14 = vmulq_f32(v57, v68);
            int32x4_t v71 = (int32x4_t)vmulq_f32(v57, v69);
            int32x4_t v72 = vzip2q_s32(v70, v71);
            float32x4_t v73 = (float32x4_t)vzip1q_s32(vzip1q_s32(v70, v71), (int32x4_t)a14);
            float32x4_t v74 = (float32x4_t)vtrn2q_s32(v70, (int32x4_t)a14);
            v74.i32[2] = v71.i32[1];
            float32x4_t v75 = vaddq_f32((float32x4_t)vzip1q_s32(v72, vdupq_laneq_s32((int32x4_t)a14, 2)), vaddq_f32(v73, v74));
            a13 = (float32x4_t)vdupq_lane_s32(v59, 0);
            float32x4_t v60 = vdivq_f32(v75, a13);
          }
          a12 = vcgeq_f32(v29, vabsq_f32(vaddq_f32(v60, v28)));
          a12.i32[3] = a12.i32[2];
          if ((vminvq_u32((uint32x4_t)a12) & 0x80000000) != 0)
          {
            sub_1B63D5728(a3, v21, 0, 1, 2, v54, v56, v48);
            v29.i64[0] = 0x3F0000003F000000;
            v29.i64[1] = 0x3F0000003F000000;
            v28.i64[0] = 0xBF000000BF000000;
            v28.i64[1] = 0xBF000000BF000000;
            _Q20 = v77;
            if ((*(_WORD *)(a3 + 8) & 0x100) != 0) {
              break;
            }
          }
        }
      }
      BOOL v22 = ++v21 < (unint64_t)a2;
      v30 += 3;
      --v20;
    }
    while (v20);
  }
  return v22;
}

BOOL sub_1B63D7F8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a3;
  uint64_t v154 = *MEMORY[0x1E4F143B8];
  CFArrayRef v12 = sub_1B63CCEC4(a2, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v20 = sub_1B63CCE68(a2, v13, v14, v15, v16, v17, v18, v19);
  uint64_t v27 = sub_1B64ACF7C(v20, 0, v21, v22, v23, v24, v25, v26);
  uint64_t v108 = sub_1B64ACE9C(v20, 0, 0, v28, v29, v30, v31, v32);
  uint64_t v106 = sub_1B641D478((uint64_t)v27, v33, v34, v35, v36, v37, v38, v39);
  uint64_t v107 = v40;
  if (!v106) {
    return 0;
  }
  uint64_t v54 = sub_1B6531B9C(a1, v40, v41, v42, v43, v44, v45, v46);
  if (!v54) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v48, v49, v50, v51, v52, v53, (uint64_t)"boneIndicesSrc");
  }
  uint64_t v55 = sub_1B641D478(v54, v47, v48, v49, v50, v51, v52, v53);
  unint64_t v104 = v56;
  uint64_t v105 = v55;
  if (HIWORD(v56) != 1039) {
    return 0;
  }
  long long v63 = *(_OWORD *)(a4 + 80);
  long long v145 = *(_OWORD *)(a4 + 64);
  long long v146 = v63;
  long long v147 = *(_OWORD *)(a4 + 96);
  CFArrayRef v64 = sub_1B64ABD08(v20, v56, v57, v58, v59, v60, v61, v62);
  if ((uint64_t)v64 >= 1)
  {
    CFArrayRef v71 = v64;
    CFIndex v72 = 0;
    *(int16x4_t *)v70.i8 = vdup_n_s16(v9);
    BOOL v73 = 1;
    int32x4_t v103 = vdupq_n_s32(0x7F7FFFFFu);
    unsigned __int32 v102 = vmovn_s16(v70).u32[0];
    do
    {
      *(void *)(a4 + 192) = v72;
      float32x4_t v74 = sub_1B64ABD78(v20, v72, 0, v65, v66, v67, v68, v69);
      uint64_t v144 = 0;
      long long v142 = 0u;
      long long v143 = 0u;
      long long v141 = 0u;
      sub_1B63D11F0((uint64_t)v74, v108, v75, v76, v77, v78, v79, v80, (uint64_t)&v141);
      if ((((uint64_t)v12 > 0) & (*(unsigned __int16 *)(a4 + 8) >> 3)) == 1)
      {
        CFArrayRef v82 = sub_1B63CCF34(a2, v72 % (uint64_t)v12, v81, v65, v66, v67, v68, v69);
        char v90 = sub_1B64AF3EC((uint64_t)v82, v83, v84, v85, v86, v87, v88, v89);
        int v98 = sub_1B64AF564((uint64_t)v82, v91, v92, v93, v94, v95, v96, v97);
      }
      else
      {
        char v90 = 0;
        int v98 = 0;
      }
      if ((BYTE10(v142) & 0xFA) == 0)
      {
        v139[0] = 0;
        v139[1] = v139;
        v139[2] = 0x2020000000;
        int v140 = 0;
        v150[0] = 0;
        v150[1] = v150;
        v150[2] = 0x3020000000;
        int32x4_t v151 = v103;
        v148[0] = 0;
        v148[1] = v148;
        v148[2] = 0x3020000000;
        *(void *)&long long v99 = 0x80000000800000;
        *((void *)&v99 + 1) = 0x80000000800000;
        long long v149 = v99;
        uint64_t v135 = 0;
        uint64_t v136 = &v135;
        uint64_t v137 = 0x2020000000;
        char v138 = 0;
        v111[0] = MEMORY[0x1E4F143A8];
        v111[1] = 3221225472;
        long long v126 = v142;
        long long v127 = v143;
        long long v125 = v141;
        long long v113 = v146;
        long long v114 = v147;
        long long v112 = v145;
        v111[2] = sub_1B63D8388;
        v111[3] = &unk_1E6141030;
        int v131 = v98;
        uint64_t v119 = v105;
        unint64_t v120 = v104;
        unsigned __int32 v132 = v102;
        BOOL v133 = (v107 & 0xFF000000000000) == 0x1000000000000;
        uint64_t v121 = v106;
        uint64_t v122 = v107;
        float32x4_t v115 = v150;
        int v116 = v148;
        uint64_t v123 = &v153;
        uint64_t v124 = &v152;
        uint64_t v128 = v144;
        char v134 = v90;
        CFIndex v129 = v72;
        uint64_t v130 = a4;
        int v117 = v139;
        float32x4_t v118 = &v135;
        v109[0] = v141;
        v109[1] = v142;
        v109[2] = v143;
        uint64_t v110 = v144;
        sub_1B63D2760((uint64_t *)v109, (uint64_t)v111, v81, v65, v66, v67, v68, v69);
        int v100 = *((unsigned __int8 *)v136 + 24);
        _Block_object_dispose(&v135, 8);
        _Block_object_dispose(v148, 8);
        _Block_object_dispose(v150, 8);
        _Block_object_dispose(v139, 8);
        if (v100) {
          break;
        }
      }
      BOOL v73 = ++v72 < (uint64_t)v71;
    }
    while (v71 != (const __CFArray *)v72);
  }
  else
  {
    return 0;
  }
  return v73;
}

void sub_1B63D8344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose(&STACK[0x260], 8);
  _Block_object_dispose(&STACK[0x290], 8);
  _Block_object_dispose(&a67, 8);
  _Unwind_Resume(a1);
}

void sub_1B63D8388(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8x8_t a9, uint8x8_t a10, uint8x8_t a11, uint8x8_t a12, unsigned char *a13)
{
  int v13 = a5;
  int v14 = a4;
  int v17 = *(_DWORD *)(a1 + 232);
  BOOL v18 = v17 == 1;
  if (v17 == 1) {
    int v19 = a7;
  }
  else {
    int v19 = a6;
  }
  if (v18) {
    int v20 = a6;
  }
  else {
    int v20 = a7;
  }
  uint64_t v21 = *(void *)(a1 + 112);
  int v22 = *(unsigned __int8 *)(a1 + 125);
  a9.i32[0] = *(_DWORD *)(v21 + (v19 * v22));
  float32x4_t v26 = (float32x4_t)vmovl_u8(a9);
  a10.i32[0] = *(_DWORD *)(v21 + (v20 * v22));
  a11.i32[0] = *(_DWORD *)(v21 + (v22 * a8));
  int16x4_t v23 = (int16x4_t)vmovl_u8(a11).u64[0];
  a12.i32[0] = *(_DWORD *)(a1 + 236);
  int16x4_t v24 = (int16x4_t)vmovl_u8(a12).u64[0];
  *(int8x8_t *)v26.f32 = vorr_s8((int8x8_t)vceq_s16(*(int16x4_t *)v26.f32, v24), (int8x8_t)vceq_s16((int16x4_t)*(_OWORD *)&vmovl_u8(a10), v24));
  int8x8_t v25 = (int8x8_t)vceq_s16(v23, v24);
  *(int8x8_t *)v26.f32 = vorr_s8(*(int8x8_t *)v26.f32, v25);
  *(int8x8_t *)v26.f32 = vuzp1_s8(*(int8x8_t *)v26.f32, *(int8x8_t *)v26.f32);
  v26.i8[0] = vmaxv_u8(*(uint8x8_t *)v26.f32);
  if (v26.i8[0] < 0)
  {
    int v27 = a8;
    if (*(unsigned char *)(a1 + 240))
    {
      uint64_t v28 = *(void *)(a1 + 128);
      int v29 = *(unsigned __int8 *)(a1 + 141);
      uint64_t v30 = v28 + (v19 * v29);
      v31.i64[0] = *(void *)v30;
      v31.i64[1] = *(unsigned int *)(v30 + 8);
      uint64_t v32 = v28 + (v20 * v29);
      v33.i64[0] = *(void *)v32;
      v33.i64[1] = *(unsigned int *)(v32 + 8);
      uint64_t v34 = v28 + (v29 * a8);
      v35.i64[0] = *(void *)v34;
      v35.i64[1] = *(unsigned int *)(v34 + 8);
    }
    else
    {
      *(double *)v36.i64 = sub_1B65D6198(*(unsigned __int8 *)(a1 + 140), (const float *)(*(void *)(a1 + 128) + v19 * *(unsigned __int8 *)(a1 + 141)), a3, a4, a5, a6, a7, a8, v26, *(float *)v25.i32, *(float *)v23.i32);
      float32x4_t v69 = v36;
      *(double *)v45.i64 = sub_1B65D6198(*(unsigned __int8 *)(a1 + 140), (const float *)(*(void *)(a1 + 128) + v20 * *(unsigned __int8 *)(a1 + 141)), v37, v38, v39, v40, v41, v42, v36, v43, v44);
      float32x4_t v68 = v45;
      *(double *)v35.i64 = sub_1B65D6198(*(unsigned __int8 *)(a1 + 140), (const float *)(*(void *)(a1 + 128) + *(unsigned __int8 *)(a1 + 141) * v27), v46, v47, v48, v49, v50, v51, v45, v52, v53);
      float32x4_t v33 = v68;
      float32x4_t v31 = v69;
    }
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 80) + 8) + 32) = vminnmq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 80) + 8)+ 32), v31);
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 80) + 8) + 32) = vminnmq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 80) + 8)+ 32), v33);
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 80) + 8) + 32) = vminnmq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 80) + 8)+ 32), v35);
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 88) + 8) + 32) = vmaxnmq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 88) + 8)+ 32), v31);
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 88) + 8) + 32) = vmaxnmq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 88) + 8)+ 32), v33);
    *(float32x4_t *)(*(void *)(*(void *)(a1 + 88) + 8) + 32) = vmaxnmq_f32(*(float32x4_t *)(*(void *)(*(void *)(a1 + 88) + 8)+ 32), v35);
    *(float32x4_t *)(*(void *)(a1 + 144)
                   + 16 * (3 * *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 24))) = v31;
    *(float32x4_t *)(*(void *)(a1 + 144)
                   + 16 * (3 * *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) + 1)) = v33;
    *(float32x4_t *)(*(void *)(a1 + 144)
                   + 16 * (3 * *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 24) + 2)) = v35;
    *(_DWORD *)(*(void *)(a1 + 152)
              + 4 * (*(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 24))++) = a2;
  }
  uint64_t v54 = *(void *)(*(void *)(a1 + 96) + 8);
  unsigned int v55 = *(_DWORD *)(v54 + 24);
  if (v55 > 0x1F || v14 - 3 == v13 && *(_DWORD *)(a1 + 168) - 1 == a2)
  {
    *(_DWORD *)(v54 + 24) = 0;
    unint64_t v56 = *(float32x4_t **)(*(void *)(a1 + 80) + 8);
    float32x4_t v57 = v56[2];
    float32x4_t v58 = *(float32x4_t *)(*(void *)(*(void *)(a1 + 88) + 8) + 32);
    v56[2] = (float32x4_t)vdupq_n_s32(0x7F7FFFFFu);
    *(void *)&long long v59 = 0x80000000800000;
    *((void *)&v59 + 1) = 0x80000000800000;
    *(_OWORD *)(*(void *)(*(void *)(a1 + 88) + 8) + 32) = v59;
    float32x4_t v60 = *(float32x4_t *)(a1 + 32);
    __n128 v61 = *(__n128 *)(a1 + 64);
    float32x4_t v62 = vmulq_f32(vsubq_f32(v57, v60), (float32x4_t)v61);
    float32x4_t v63 = vmulq_f32(vsubq_f32(v58, v60), (float32x4_t)v61);
    v62.i32[3] = 0;
    v63.i32[3] = 0;
    float32x4_t v64 = vminnmq_f32(v62, v63);
    float32x4_t v65 = vmaxnmq_f32(v62, v63);
    float v66 = fmaxf(fmaxf(v64.f32[0], v64.f32[2]), v64.f32[1]);
    if (fminf(fminf(v65.f32[0], v65.f32[2]), v65.f32[1]) >= v66
      && v66 < COERCE_FLOAT(HIDWORD(*(_OWORD *)(a1 + 64)))
      && sub_1B63D5930(*(void *)(a1 + 144), *(void *)(a1 + 152), v55, v60, *(float32x4_t *)(a1 + 48), v61, a4, *(unsigned char *)(a1 + 241), *(void *)(a1 + 224)))
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = 1;
      *a13 = 1;
    }
  }
}

uint64_t sub_1B63D86B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B6525AA8(a1, *(void *)(a2 + 112), a3, a4, a5, a6, a7, a8);
  uint64_t v11 = sub_1B63CD09C(a1);
  uint64_t v19 = sub_1B649F5F4(*(void *)(a2 + 112), v12, v13, v14, v15, v16, v17, v18);
  uint64_t v20 = v19;
  if ((*(_WORD *)(a2 + 8) & 0x80) != 0 || v19)
  {
    uint64_t v21 = sub_1B65312B8(v11);
    CFArrayRef v22 = (const __CFArray *)sub_1B6451F14(a1);
    if (v22)
    {
      CFArrayRef v23 = v22;
      CFIndex Count = CFArrayGetCount(v22);
      if (Count >= 1)
      {
        CFIndex v25 = Count;
        char v26 = 0;
        CFIndex v27 = 0;
        while (1)
        {
          uint64_t v28 = (float32x4_t *)(v10 + 32 * v27);
          if ((vminvq_u32((uint32x4_t)vcgezq_f32(v28[1])) & 0x80000000) != 0)
          {
            float32x4_t v116 = *v28;
            float32x4_t v118 = v28[1];
            ValueAtIndex = CFArrayGetValueAtIndex(v23, v27);
            *(void *)(a2 + 120) = ValueAtIndex;
            uint64_t v37 = sub_1B64A01D4((uint64_t)ValueAtIndex, v30, v31, v32, v33, v34, v35, v36);
            float32x4_t v38 = *(float32x4_t *)v37;
            float32x4_t v39 = *(float32x4_t *)(v37 + 16);
            float32x4_t v40 = *(float32x4_t *)(v37 + 32);
            float32x4_t v41 = *(float32x4_t *)(v37 + 48);
            float32x4_t v42 = vmulq_f32(v38, v38);
            float32x4_t v43 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v42, 2), vaddq_f32(v42, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v42.f32, 1)));
            v43.f32[0] = sqrtf(v43.f32[0]);
            float32x4_t v44 = vmulq_f32(v39, v39);
            v44.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32(v44, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1))).u64[0];
            v44.f32[0] = sqrtf(v44.f32[0]);
            float32x4_t v45 = vmulq_f32(v40, v40);
            v45.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))).u64[0];
            v45.f32[0] = sqrtf(v45.f32[0]);
            float32x4_t v46 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v43.f32, 0);
            v43.i32[1] = v44.i32[0];
            v43.i32[2] = v45.i32[0];
            int32x4_t v47 = (int32x4_t)vdivq_f32(*(float32x4_t *)v37, v46);
            int32x4_t v48 = (int32x4_t)vdivq_f32(v39, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 0));
            int32x4_t v49 = (int32x4_t)vdivq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 0));
            float32x4_t v50 = vmulq_f32(v118, v43);
            float32x4_t v51 = *(float32x4_t *)(a2 + 16);
            float32x4_t v52 = *(float32x4_t *)(a2 + 32);
            float32x4_t v53 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(v41, v40, v116, 2), v39, *(float32x2_t *)v116.f32, 1), *(float32x4_t *)v37, v116.f32[0]), v51);
            float32x4_t v54 = (float32x4_t)vzip1q_s32(vzip1q_s32(v47, v49), v48);
            float32x4_t v55 = (float32x4_t)vtrn2q_s32(v47, v48);
            v55.i32[2] = v49.i32[1];
            float32x4_t v56 = (float32x4_t)vzip1q_s32(vzip2q_s32(v47, v49), vdupq_laneq_s32(v48, 2));
            float32x4_t v57 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v55, *(float32x2_t *)v53.f32, 1), v54, v53.f32[0]), v56, v53, 2);
            float32x4_t v58 = vaddq_f32(v50, v57);
            float32x4_t v59 = vsubq_f32(v57, v50);
            v50.i32[3] = v118.i32[3];
            v122.columns[1] = (simd_float4)v47;
            v122.columns[2] = (simd_float4)v48;
            float32x4_t v60 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v55, *(float32x2_t *)v52.f32, 1), v54, v52.f32[0]), v56, v52, 2);
            float32x4_t v61 = vdivq_f32(v58, v60);
            float32x4_t v62 = vdivq_f32(v59, v60);
            v61.i32[3] = 0;
            v62.i32[3] = 0;
            v122.columns[3] = (simd_float4)v49;
            float32x4_t v123 = v50;
            int8x16_t v63 = (int8x16_t)vminnmq_f32(v61, v62);
            float32x4_t v64 = vmaxnmq_f32(v61, v62);
            float v65 = fmaxf(fmaxf(*(float *)v63.i32, *(float *)&v63.i32[2]), *(float *)&v63.i32[1]);
            float v66 = fminf(fminf(v64.f32[0], v64.f32[2]), v64.f32[1]);
            if (v66 >= v65 && v66 >= 0.0 && v65 < *(float *)(a2 + 60))
            {
              LODWORD(v68) = *(float *)v63.i32 < *(float *)&v63.i32[1];
              if (*(float *)v63.i32 < *(float *)&v63.i32[1]) {
                v63.i32[0] = v63.i32[1];
              }
              if (*(float *)v63.i32 < *(float *)&v63.i32[2]) {
                uint64_t v68 = 2;
              }
              else {
                uint64_t v68 = v68;
              }
              if (v65 < 0.0) {
                float v65 = v66;
              }
              simd_float4 v69 = v122.columns[v68 + 1];
              float32x4_t v121 = v60;
              v60.i32[0] = *(_DWORD *)((unint64_t)&v121 | (4 * v68));
              v63.i32[0] = 1.0;
              v70.i64[0] = 0x8000000080000000;
              v70.i64[1] = 0x8000000080000000;
              v63.i32[0] = vbslq_s8(v70, v63, (int8x16_t)v60).u32[0];
              if (v60.f32[0] == 0.0) {
                float v71 = 0.0;
              }
              else {
                float v71 = *(float *)v63.i32;
              }
              float v72 = v71;
              if ((*(_WORD *)(a2 + 8) & 0x80) != 0)
              {
                float32x4_t v113 = (float32x4_t)v69;
                float32x4_t v115 = v52;
                float v117 = v65;
                float32x4_t v119 = v51;
                uint64_t v89 = sub_1B63D48F4();
                sub_1B63D49F4(v89, *(CFTypeRef *)(a2 + 112), v90, v91, v92, v93, v94, v95);
                uint64_t v96 = *(const void **)(v89 + 24);
                if (v96 != ValueAtIndex)
                {
                  if (v96)
                  {
                    CFRelease(v96);
                    *(void *)(v89 + 24) = 0;
                  }
                  if (ValueAtIndex) {
                    CFTypeRef v97 = CFRetain(ValueAtIndex);
                  }
                  else {
                    CFTypeRef v97 = 0;
                  }
                  *(void *)(v89 + 24) = v97;
                }
                float32x4_t v114 = vmulq_n_f32(v113, -v72);
                float32x4_t v120 = vmlaq_n_f32(v119, v115, v117);
                long long v109 = *(_OWORD *)(a2 + 128);
                long long v110 = *(_OWORD *)(a2 + 144);
                long long v111 = *(_OWORD *)(a2 + 176);
                *(_OWORD *)(v89 + 144) = *(_OWORD *)(a2 + 160);
                *(_OWORD *)(v89 + 160) = v111;
                *(_OWORD *)(v89 + 112) = v109;
                *(_OWORD *)(v89 + 128) = v110;
                *(float32x4_t *)(v89 + 96) = v120;
                simd_float4x4 v126 = __invert_f4(*(simd_float4x4 *)(a2 + 128));
                v126.columns[3] = (simd_float4)vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v126.columns[3], (float32x4_t)v126.columns[2], v120, 2), (float32x4_t)v126.columns[1], *(float32x2_t *)v120.f32, 1);
                v126.columns[2] = (simd_float4)vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32((float32x4_t)v126.columns[2], v114, 2), (float32x4_t)v126.columns[1], *(float32x2_t *)v114.f32, 1), (float32x4_t)v126.columns[0], v114.f32[0]);
                v126.columns[1] = (simd_float4)vmulq_f32((float32x4_t)v126.columns[2], (float32x4_t)v126.columns[2]);
                v126.columns[1].i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v126.columns[1], 2), vadd_f32(*(float32x2_t *)v126.columns[1].f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v126.columns[1].f32, 1))).u32[0];
                v126.columns[3] = (simd_float4)vmlaq_n_f32((float32x4_t)v126.columns[3], (float32x4_t)v126.columns[0], v120.f32[0]);
                *(float32x2_t *)v126.columns[0].f32 = vrsqrte_f32((float32x2_t)v126.columns[1].u32[0]);
                *(float32x2_t *)v126.columns[0].f32 = vmul_f32(*(float32x2_t *)v126.columns[0].f32, vrsqrts_f32((float32x2_t)v126.columns[1].u32[0], vmul_f32(*(float32x2_t *)v126.columns[0].f32, *(float32x2_t *)v126.columns[0].f32)));
                *(simd_float4 *)(v89 + 64) = v126.columns[3];
                *(float32x4_t *)(v89 + 80) = vmulq_n_f32((float32x4_t)v126.columns[2], vmul_f32(*(float32x2_t *)v126.columns[0].f32, vrsqrts_f32((float32x2_t)v126.columns[1].u32[0], vmul_f32(*(float32x2_t *)v126.columns[0].f32, *(float32x2_t *)v126.columns[0].f32))).f32[0]);
                CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 312), (const void *)v89);
                CFRelease((CFTypeRef)v89);
                __int16 v108 = *(_WORD *)(a2 + 8);
                if ((v108 & 0x200) != 0) {
                  *(float *)(a2 + 60) = v117;
                }
LABEL_40:
                char v26 = 1;
                if ((v108 & 0x100) != 0) {
                  return v26 & 1;
                }
                goto LABEL_41;
              }
              uint64_t v73 = 0;
              float32x4_t v74 = (_OWORD *)(v21 + (v27 << 6));
              long long v75 = v74[1];
              long long v76 = v74[2];
              long long v77 = v74[3];
              v124[0] = *v74;
              v124[1] = v75;
              v124[2] = v76;
              v124[3] = v77;
              memset(&v122, 0, sizeof(v122));
              do
              {
                v122.columns[v73] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v38, COERCE_FLOAT(v124[v73])), v39, *(float32x2_t *)&v124[v73], 1), v40, (float32x4_t)v124[v73], 2), v41, (float32x4_t)v124[v73], 3);
                ++v73;
              }
              while (v73 != 4);
              simd_float4x4 v125 = __invert_f4(v122);
              float32x4_t v82 = *(float32x4_t *)(a2 + 16);
              float32x4_t v83 = *(float32x4_t *)(a2 + 32);
              float32x4_t v84 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v125.columns[3], (float32x4_t)v125.columns[2], v82, 2), (float32x4_t)v125.columns[1], *(float32x2_t *)v82.f32, 1), (float32x4_t)v125.columns[0], v82.f32[0]);
              if (COERCE_FLOAT(HIDWORD(*(_OWORD *)(a2 + 48))) >= 1.0e20)
              {
                float32x4_t v98 = vaddq_f32(v82, v83);
                float32x4_t v99 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v125.columns[3], (float32x4_t)v125.columns[2], v98, 2), (float32x4_t)v125.columns[1], *(float32x2_t *)v98.f32, 1), (float32x4_t)v125.columns[0], v98.f32[0]), v84);
                float32x4_t v87 = vmulq_f32(v99, v99);
                v87.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v87, 2), vadd_f32(*(float32x2_t *)v87.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v87.f32, 1))).u32[0];
                float32x2_t v100 = vrsqrte_f32((float32x2_t)v87.u32[0]);
                float32x2_t v101 = vmul_f32(v100, vrsqrts_f32((float32x2_t)v87.u32[0], vmul_f32(v100, v100)));
                float32x4_t v88 = vmulq_n_f32(v99, vmul_f32(v101, vrsqrts_f32((float32x2_t)v87.u32[0], vmul_f32(v101, v101))).f32[0]);
                v84.i32[3] = 1.0;
                v87.i32[0] = 2139095040;
              }
              else
              {
                float32x4_t v85 = vmlaq_laneq_f32(v82, v83, *(float32x4_t *)(a2 + 48), 3);
                float32x4_t v86 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v125.columns[3], (float32x4_t)v125.columns[2], v85, 2), (float32x4_t)v125.columns[1], *(float32x2_t *)v85.f32, 1), (float32x4_t)v125.columns[0], v85.f32[0]), v84);
                float32x4_t v87 = vmulq_f32(v86, v86);
                v84.i32[3] = 1.0;
                v87.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v87, 2), vaddq_f32(v87, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.f32, 1))).u64[0];
                v87.f32[0] = sqrtf(v87.f32[0]);
                float32x4_t v88 = vdivq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v87.f32, 0));
              }
              float32x4_t v102 = v88;
              v88.i32[3] = 0;
              __asm { FMOV            V3.4S, #1.0 }
              float32x4_t v107 = vdivq_f32(_Q3, v102);
              v107.i32[3] = v87.i32[0];
              *(float32x4_t *)(a2 + 64) = v84;
              *(float32x4_t *)(a2 + 80) = v88;
              *(float32x4_t *)(a2 + 96) = v107;
              if (sub_1B63D7F8C(v11, v20, v27, a2, v78, v79, v80, v81))
              {
                __int16 v108 = *(_WORD *)(a2 + 8);
                goto LABEL_40;
              }
            }
          }
LABEL_41:
          if (++v27 == v25) {
            return v26 & 1;
          }
        }
      }
    }
  }
  char v26 = 0;
  return v26 & 1;
}

uint64_t sub_1B63D8BD8(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1F4188790](a1, a2);
  uint64_t v3 = (uint64_t)v2;
  uint64_t v5 = v4;
  uint64_t v377 = *MEMORY[0x1E4F143B8];
  v2[14] = v4;
  void v2[15] = 0;
  v2[24] = 0;
  uint64_t v12 = (float32x4_t *)sub_1B64A01D4(v4, (uint64_t)v2, v6, v7, v8, v9, v10, v11);
  float32x4_t v13 = v12[2];
  float32x4_t v14 = v12[3];
  float32x4_t v358 = v12[1];
  float32x4_t v361 = *v12;
  *(float32x4_t *)(v3 + 128) = *v12;
  *(float32x4_t *)(v3 + 144) = v358;
  float32x4_t v354 = v14;
  float32x4_t v356 = v13;
  *(float32x4_t *)(v3 + 160) = v13;
  *(float32x4_t *)(v3 + 176) = v14;
  uint64_t v22 = sub_1B64A16A0(v5, v15, v16, v17, v18, v19, v20, v21);
  if (!v22) {
    goto LABEL_12;
  }
  uint64_t v30 = v22;
  sub_1B649F5F4(v5, v23, v24, v25, v26, v27, v28, v29);
  BOOL v31 = sub_1B6524E80(v30);
  if (sub_1B6525DCC(v31))
  {
    return sub_1B63D86B8(v30, v3, v32, v33, v34, v35, v36, v37);
  }
  if (v31)
  {
    *(void *)&v367[0] = 0;
    uint64_t v45 = sub_1B6525800(v30, v367);
    if (*(void *)&v367[0] != 3) {
      sub_1B63F2F54(17, @"Assertion '%s' failed. there should be exactly one transposed matrix in here", v39, v40, v41, v42, v43, v44, (uint64_t)"vectorCount == 3");
    }
    unint64_t v46 = 0;
    int32x4_t v47 = *(int32x4_t *)(v45 + 16);
    int32x4_t v48 = *(int32x4_t *)(v45 + 32);
    float32x2x2_t v49 = (float32x2x2_t)vzip1q_s32(*(int32x4_t *)v45, v48);
    float32x2x2_t v50 = (float32x2x2_t)vzip2q_s32(*(int32x4_t *)v45, v48);
    int32x4_t v51 = vzip1q_s32(v47, (int32x4_t)0);
    float32x4_t v52 = &v371;
    vst2_f32(v52->f32, v49);
    ++v52;
    int32x4_t v53 = vzip2q_s32(v47, (int32x4_t)xmmword_1B6E4F370);
    *(int32x4_t *)float32x4_t v52 = vzip2q_s32((int32x4_t)v49, v51);
    float32x4_t v54 = (float *)&v373;
    vst2_f32(v54, v50);
    int32x4_t v374 = vzip2q_s32((int32x4_t)v50, v53);
    memset(&v375, 0, sizeof(v375));
    do
    {
      v375.columns[v46 / 4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v361, COERCE_FLOAT(*(_OWORD *)((char *)&v371 + v46 * 4))), v358, *(float32x2_t *)&v371.f32[v46], 1), v356, *(float32x4_t *)((char *)&v371 + v46 * 4), 2), v354, *(float32x4_t *)((char *)&v371 + v46 * 4), 3);
      v46 += 4;
    }
    while (v46 != 16);
    simd_float4x4 v55 = v375;
  }
  else
  {
LABEL_12:
    v55.columns[1] = (simd_float4)v358;
    v55.columns[0] = (simd_float4)v361;
    v55.columns[3] = (simd_float4)v354;
    v55.columns[2] = (simd_float4)v356;
  }
  float v370 = 0.0;
  simd_float4x4 v379 = __invert_f4(v55);
  float32x4_t v63 = *(float32x4_t *)(v3 + 16);
  float32x4_t v64 = *(float32x4_t *)(v3 + 32);
  float32x4_t v65 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v379.columns[3], (float32x4_t)v379.columns[2], v63, 2), (float32x4_t)v379.columns[1], *(float32x2_t *)v63.f32, 1), (float32x4_t)v379.columns[0], v63.f32[0]);
  if (COERCE_FLOAT(HIDWORD(*(_OWORD *)(v3 + 48))) >= 1.0e20)
  {
    float32x4_t v70 = vaddq_f32(v63, v64);
    float32x4_t v71 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v379.columns[3], (float32x4_t)v379.columns[2], v70, 2), (float32x4_t)v379.columns[1], *(float32x2_t *)v70.f32, 1), (float32x4_t)v379.columns[0], v70.f32[0]), v65);
    float32x4_t v68 = vmulq_f32(v71, v71);
    v68.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v68, 2), vadd_f32(*(float32x2_t *)v68.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v68.f32, 1))).u32[0];
    float32x2_t v72 = vrsqrte_f32((float32x2_t)v68.u32[0]);
    float32x2_t v73 = vmul_f32(v72, vrsqrts_f32((float32x2_t)v68.u32[0], vmul_f32(v72, v72)));
    float32x4_t v69 = vmulq_n_f32(v71, vmul_f32(v73, vrsqrts_f32((float32x2_t)v68.u32[0], vmul_f32(v73, v73))).f32[0]);
    v65.i32[3] = 1.0;
    v68.i32[0] = 2139095040;
  }
  else
  {
    float32x4_t v66 = vmlaq_laneq_f32(v63, v64, *(float32x4_t *)(v3 + 48), 3);
    float32x4_t v67 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v379.columns[3], (float32x4_t)v379.columns[2], v66, 2), (float32x4_t)v379.columns[1], *(float32x2_t *)v66.f32, 1), (float32x4_t)v379.columns[0], v66.f32[0]), v65);
    v65.i32[3] = 1.0;
    float32x4_t v68 = vmulq_f32(v67, v67);
    v68.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1))).u64[0];
    v68.f32[0] = sqrtf(v68.f32[0]);
    float32x4_t v69 = vdivq_f32(v67, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 0));
  }
  float32x4_t v74 = v69;
  v69.i32[3] = 0;
  __asm { FMOV            V3.4S, #1.0 }
  float32x4_t v362 = _Q3;
  float32x4_t v78 = vdivq_f32(_Q3, v74);
  v78.i32[3] = v68.i32[0];
  *(float32x4_t *)(v3 + 64) = v65;
  *(float32x4_t *)(v3 + 80) = v69;
  *(float32x4_t *)(v3 + 96) = v78;
  if ((*(unsigned char *)(v3 + 9) & 8) == 0)
  {
    CFDictionaryRef v79 = sub_1B649F640(v5, v56, v57, v58, v59, v60, v61, v62);
    if (v79)
    {
      uint64_t v80 = (uint64_t)v79;
      if (sub_1B6496680((uint64_t)v79, v56, v57, v58, v59, v60, v61, v62) == 5)
      {
        if (sub_1B6496EF8(v80, v56, v57, v58, v59, v60, v61, v62))
        {
          v81.i32[0] = *(_DWORD *)(v3 + 88);
          v82.i32[0] = 1.0;
          v83.i64[0] = 0x8000000080000000;
          v83.i64[1] = 0x8000000080000000;
          v82.i32[0] = vbslq_s8(v83, v82, v81).u32[0];
          if (*(float *)v81.i32 == 0.0) {
            *(float *)v82.i32 = 0.0;
          }
          float v84 = *(float *)v82.i32;
          int v85 = sub_1B64970A0(v80, v56, v57, v58, v59, v60, v61, v62);
          float32x4_t v372 = 0u;
          long long v373 = 0u;
          float32x4_t v371 = 0u;
          sub_1B6497104(v80, v86, v87, v88, v89, v90, v91, (uint64_t)&v371);
          switch(v371.i8[0])
          {
            case 1:
              if (v84 > 0.0) {
                int v92 = 1;
              }
              else {
                int v92 = v85;
              }
              if (v92 == 1)
              {
                v375.columns[0] = 0u;
                v375.columns[1] = (simd_float4)xmmword_1B6E4F2E0;
                v375.columns[2] = (simd_float4)xmmword_1B6E4F300;
                v375.columns[3].i64[0] = v372.i64[0];
                float32x4_t v359 = *(float32x4_t *)(v3 + 80);
                float32x4_t v363 = *(float32x4_t *)(v3 + 64);
                int v93 = sub_1B63D9B04((uint64_t)&v375, &v370, v363, v359, *(__n128 *)(v3 + 96));
                v94.n128_u64[0] = 0;
                v94.n128_u32[3] = 0;
                float32x4_t v95 = v359;
                float32x4_t v96 = v363;
                if (v93)
                {
                  v94.n128_f32[2] = -v84;
                  float v97 = v370;
                  goto LABEL_71;
                }
              }
              break;
            case 2:
              if (v84 > 0.0) {
                int v98 = 1;
              }
              else {
                int v98 = v85;
              }
              if (v98 == 1)
              {
                float32x4_t v95 = *(float32x4_t *)(v3 + 80);
                int8x16_t v99 = (int8x16_t)vmulq_f32(v95, (float32x4_t)xmmword_1B6E4FCE0);
                float v100 = vaddv_f32(vadd_f32(*(float32x2_t *)v99.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v99, v99, 8uLL)));
                if (v100 != 0.0)
                {
                  float32x4_t v96 = *(float32x4_t *)(v3 + 64);
                  int8x16_t v101 = (int8x16_t)vmulq_f32(v96, (float32x4_t)xmmword_1B6E4FCE0);
                  float v97 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v101.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v101, v101, 8uLL)))
                      / v100;
                  if (v97 >= 0.0 && v97 <= *(float *)(v3 + 108))
                  {
                    float32x4_t v103 = vmlaq_n_f32(v96, v95, v97);
                    int32x4_t v104 = (int32x4_t)vmulq_f32(v103, (float32x4_t)xmmword_1B6E4F300);
                    int32x4_t v105 = (int32x4_t)vmulq_f32(v103, (float32x4_t)xmmword_1B6E4F320);
                    float32x2_t v106 = vdiv_f32((float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v104, 2), vadd_f32(*(float32x2_t *)v104.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v104.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v105, 2), vadd_f32(*(float32x2_t *)v105.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v105.i8, 1)))), *(float32x2_t *)v372.f32);
                    if (vaddv_f32(vmul_f32(v106, v106)) <= 1.0)
                    {
                      v94.n128_u64[0] = 0;
                      v94.n128_u32[3] = 0;
                      v94.n128_f32[2] = -v84;
                      float v370 = v97;
                      goto LABEL_71;
                    }
                  }
                }
              }
              break;
            case 3:
              float32x4_t v96 = *(float32x4_t *)(v3 + 64);
              float32x4_t v95 = *(float32x4_t *)(v3 + 80);
              float32x4_t v107 = vdivq_f32(v362, v372);
              float32x4_t v108 = vabsq_f32(v107);
              v108.i32[3] = 0;
              v109.i64[0] = 0x8000000080000000;
              v109.i64[1] = 0x8000000080000000;
              int8x16_t v110 = vorrq_s8((int8x16_t)(*(_OWORD *)&vmaxnmq_f32(v108, (float32x4_t)xmmword_1B6E4FCD0) & __PAIR128__(0x7FFFFFFF7FFFFFFFLL, 0x7FFFFFFF7FFFFFFFLL)), vandq_s8((int8x16_t)v107, v109));
              float32x4_t v111 = (float32x4_t)v110.u32[0];
              v112.i32[0] = 0;
              v112.i64[1] = 0;
              v112.i32[1] = v110.i32[1];
              v113.i64[0] = 0;
              v113.i64[1] = v110.u32[2];
              float32x4_t v114 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)0, v113, v96, 2), (float32x4_t)v112.u64[0], *(float32x2_t *)v96.f32, 1), (float32x4_t)v110.u32[0], v96.f32[0]);
              if (COERCE_FLOAT(HIDWORD(*(_OWORD *)(v3 + 96))) >= 1.0e20)
              {
                float32x4_t v143 = vaddq_f32(v96, v95);
                float32x4_t v144 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)0, v113, v143, 2), v112, *(float32x2_t *)v143.f32, 1), v111, v143.f32[0]), v114);
                float32x4_t v117 = vmulq_f32(v144, v144);
                v117.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v117, 2), vadd_f32(*(float32x2_t *)v117.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v117.f32, 1))).u32[0];
                *(float32x2_t *)v143.f32 = vrsqrte_f32((float32x2_t)v117.u32[0]);
                *(float32x2_t *)v143.f32 = vmul_f32(*(float32x2_t *)v143.f32, vrsqrts_f32((float32x2_t)v117.u32[0], vmul_f32(*(float32x2_t *)v143.f32, *(float32x2_t *)v143.f32)));
                float32x4_t v118 = vmulq_n_f32(v144, vmul_f32(*(float32x2_t *)v143.f32, vrsqrts_f32((float32x2_t)v117.u32[0], vmul_f32(*(float32x2_t *)v143.f32, *(float32x2_t *)v143.f32))).f32[0]);
                v114.i32[3] = 1.0;
                v117.i32[0] = 2139095040;
              }
              else
              {
                float32x4_t v115 = vmlaq_laneq_f32(v96, v95, *(float32x4_t *)(v3 + 96), 3);
                float32x4_t v116 = vsubq_f32(vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)0, v113, v115, 2), v112, *(float32x2_t *)v115.f32, 1), v111, v115.f32[0]), v114);
                v114.i32[3] = 1.0;
                float32x4_t v117 = vmulq_f32(v116, v116);
                v117.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v117, 2), vaddq_f32(v117, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v117.f32, 1))).u64[0];
                v117.f32[0] = sqrtf(v117.f32[0]);
                float32x4_t v118 = vdivq_f32(v116, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v117.f32, 0));
              }
              v118.i32[3] = 0;
              float32x4_t v145 = vmulq_f32(v114, v118);
              LODWORD(v146) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v145, 2), vaddq_f32(v145, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v145.f32, 1))).u32[0];
              float32x4_t v147 = vmulq_f32(v114, v114);
              float v148 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v147, 2), vaddq_f32(v147, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v147.f32, 1))).f32[0]+ -1.0;
              if (v148 <= 0.0 || v146 <= 0.0)
              {
                float v149 = -(float)(v148 - (float)(v146 * v146));
                if (v149 >= 0.0)
                {
                  float v150 = sqrtf(v149);
                  float v151 = (float)-v146 - v150;
                  float v152 = v146 + v150;
                  if (v151 >= 0.0) {
                    float v152 = v151;
                  }
                  if (v152 <= v117.f32[0])
                  {
                    float32x4_t v153 = vmlaq_f32(v114, (float32x4_t)0, v118);
                    float32x4_t v154 = vsubq_f32(vmulq_f32(v372, v153), v96);
                    float32x4_t v155 = vmulq_f32(v154, v154);
                    float v97 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v155, 2), vaddq_f32(v155, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v155.f32, 1))).f32[0]);
                    float v370 = v97;
                    float32x4_t v156 = vdivq_f32(v153, v372);
                    int32x4_t v157 = (int32x4_t)vmulq_f32(v156, v156);
                    v157.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v157, 2), vadd_f32(*(float32x2_t *)v157.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v157.i8, 1))).u32[0];
                    float32x2_t v158 = vrsqrte_f32((float32x2_t)v157.u32[0]);
                    float32x2_t v159 = vmul_f32(v158, vrsqrts_f32((float32x2_t)v157.u32[0], vmul_f32(v158, v158)));
                    __n128 v94 = (__n128)vmulq_n_f32(v156, vmul_f32(v159, vrsqrts_f32((float32x2_t)v157.u32[0], vmul_f32(v159, v159))).f32[0]);
                    goto LABEL_71;
                  }
                }
              }
              break;
            case 4:
              if (v84 > 0.0) {
                int v119 = 1;
              }
              else {
                int v119 = v85;
              }
              if (v119 == 1)
              {
                float32x4_t v95 = *(float32x4_t *)(v3 + 80);
                int8x16_t v120 = (int8x16_t)vmulq_f32(v95, (float32x4_t)xmmword_1B6E4FCF0);
                float v121 = vaddv_f32(vadd_f32(*(float32x2_t *)v120.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v120, v120, 8uLL)));
                if (v121 != 0.0)
                {
                  float32x4_t v96 = *(float32x4_t *)(v3 + 64);
                  int8x16_t v122 = (int8x16_t)vmulq_f32(v96, (float32x4_t)xmmword_1B6E4FCF0);
                  float v97 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v122.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v122, v122, 8uLL)))
                      / v121;
                  if (v97 >= 0.0 && v97 <= *(float *)(v3 + 108))
                  {
                    if ((_BYTE)v373)
                    {
                      uint64_t v124 = 0;
                      char v125 = 0;
                      v94.n128_u64[0] = 0;
                      v94.n128_u32[3] = 0;
                      v94.n128_f32[2] = -v84;
                      float32x4_t v126 = vmlaq_n_f32(v96, v95, v97);
                      int8x16_t v127 = (int8x16_t)vmulq_f32(v126, (float32x4_t)xmmword_1B6E4F310);
                      int8x16_t v128 = (int8x16_t)vmulq_f32(v126, (float32x4_t)xmmword_1B6E4F320);
                      float32x2_t v129 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(v127, v127, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(v128, v128, 8uLL)), vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v127.i8, *(int32x2_t *)v128.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v127.i8, *(int32x2_t *)v128.i8)));
                      v130.i32[1] = v129.i32[1];
                      v130.i32[0] = -859915232;
                      int32x2_t v131 = (int32x2_t)vsub_f32(v130, v129);
                      float v132 = -*(float *)&v131.i32[1];
                      float32x2_t v133 = (float32x2_t)vdup_lane_s32(v131, 0);
                      do
                      {
                        float32x2_t v134 = *(float32x2_t *)(*((void *)&v373 + 1) + 8 * v124);
                        if (v373 - 1 == v124) {
                          uint64_t v135 = 0;
                        }
                        else {
                          uint64_t v135 = v124 + 1;
                        }
                        float32x2_t v136 = *(float32x2_t *)(*((void *)&v373 + 1) + 8 * v135);
                        float32x2_t v137 = vsub_f32(v129, v134);
                        float32x2_t v138 = vsub_f32(v130, v134);
                        float32x2_t v139 = vsub_f32(v136, v134);
                        if (vmlas_n_f32((float)-v139.f32[1] * v137.f32[0], v137.f32[1], v139.f32[0]) < 0.0 == vmlas_n_f32((float)-v139.f32[1] * v138.f32[0], v138.f32[1], v139.f32[0]) >= 0.0)
                        {
                          int32x2_t v140 = (int32x2_t)vsub_f32(v136, v129);
                          int32x2_t v141 = (int32x2_t)vsub_f32(v134, v129);
                          int32x2_t v142 = vcgez_f32(vmla_f32(vmul_n_f32((float32x2_t)vzip1_s32(v141, v140), v132), (float32x2_t)vzip2_s32(v141, v140), v133));
                          v125 -= veor_s8((int8x8_t)v142, (int8x8_t)vdup_lane_s32(v142, 1)).u8[0];
                        }
                        ++v124;
                      }
                      while (v373 != v124);
                      float v370 = v97;
                      if (v125) {
LABEL_71:
                      }
                        sub_1B63D5728(v3, 0, 0, 0, 0, v97, vmlaq_n_f32(v96, v95, v97), v94);
                    }
                    else
                    {
                      float v370 = v97;
                    }
                  }
                }
              }
              break;
            default:
              break;
          }
        }
      }
    }
  }
  if ((*(unsigned char *)(v5 + 221) & 0x10) != 0)
  {
    float32x4_t v192 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32(*(float32x4_t *)(v3 + 160), *(float32x4_t *)(v3 + 288), 2), *(float32x4_t *)(v3 + 144), *(float32x2_t *)(v3 + 288), 1), *(float32x4_t *)(v3 + 128), COERCE_FLOAT(*(_OWORD *)(v3 + 288)));
    int32x4_t v193 = (int32x4_t)vmulq_f32(v192, v192);
    v193.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v193, 2), vadd_f32(*(float32x2_t *)v193.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v193.i8, 1))).u32[0];
    float32x2_t v194 = vrsqrte_f32((float32x2_t)v193.u32[0]);
    float32x2_t v195 = vmul_f32(v194, vrsqrts_f32((float32x2_t)v193.u32[0], vmul_f32(v194, v194)));
    float32x4_t v196 = vmulq_n_f32(v192, vmul_f32(v195, vrsqrts_f32((float32x2_t)v193.u32[0], vmul_f32(v195, v195))).f32[0]);
    float32x4_t v197 = vmulq_f32(*(float32x4_t *)(v3 + 176), v196);
    float32x4_t v198 = v196;
    v198.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v197, 2), vaddq_f32(v197, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v197.f32, 1))).f32[0];
    int8x16_t v199 = (int8x16_t)vmulq_f32(*(float32x4_t *)(v3 + 32), v198);
    float v200 = vaddv_f32(vadd_f32(*(float32x2_t *)v199.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v199, v199, 8uLL)));
    if (v200 == 0.0) {
      return 0;
    }
    int8x16_t v201 = (int8x16_t)vmulq_f32(v198, *(float32x4_t *)(v3 + 16));
    float v202 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v201.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v201, v201, 8uLL)))
         / v200;
    if (v202 < 0.0 || v202 > *(float *)(v3 + 60)) {
      return 0;
    }
    __n128 v364 = (__n128)v196;
    float v370 = v202;
  }
  else
  {
    float32x4_t v371 = 0u;
    float32x4_t v372 = 0u;
    if ((sub_1B649F7D4(v5, &v371) & 1) == 0) {
      return 0;
    }
    float32x4_t v160 = *(float32x4_t *)(v3 + 128);
    float32x4_t v161 = *(float32x4_t *)(v3 + 144);
    float32x4_t v162 = *(float32x4_t *)(v3 + 160);
    float32x4_t v163 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(v3 + 176), v162, v371, 2), v161, *(float32x2_t *)v371.f32, 1), v160, v371.f32[0]);
    float32x4_t v164 = vmulq_f32(v160, v160);
    float32x4_t v165 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v164, 2), vaddq_f32(v164, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v164.f32, 1)));
    v165.f32[0] = sqrtf(v165.f32[0]);
    float32x4_t v166 = vmulq_f32(v161, v161);
    v166.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v166, 2), vaddq_f32(v166, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v166.f32, 1))).u64[0];
    v166.f32[0] = sqrtf(v166.f32[0]);
    float32x4_t v167 = vmulq_f32(v162, v162);
    v167.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v167, 2), vaddq_f32(v167, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v167.f32, 1))).u64[0];
    v167.f32[0] = sqrtf(v167.f32[0]);
    float32x4_t v168 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v165.f32, 0);
    v165.i32[1] = v166.i32[0];
    v165.i32[2] = v167.i32[0];
    int32x4_t v169 = (int32x4_t)vdivq_f32(v160, v168);
    int32x4_t v170 = (int32x4_t)vdivq_f32(v161, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v166.f32, 0));
    int32x4_t v171 = (int32x4_t)vdivq_f32(v162, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v167.f32, 0));
    float32x4_t v172 = vmulq_f32(v372, v165);
    float32x4_t v173 = *(float32x4_t *)(v3 + 32);
    float32x4_t v174 = vsubq_f32(v163, *(float32x4_t *)(v3 + 16));
    float32x4_t v175 = (float32x4_t)vzip1q_s32(vzip1q_s32(v169, v171), v170);
    float32x4_t v176 = (float32x4_t)vtrn2q_s32(v169, v170);
    v176.i32[2] = v171.i32[1];
    float32x4_t v177 = (float32x4_t)vzip1q_s32(vzip2q_s32(v169, v171), vdupq_laneq_s32(v170, 2));
    float32x4_t v178 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v176, *(float32x2_t *)v174.f32, 1), v175, v174.f32[0]), v177, v174, 2);
    float32x4_t v179 = vaddq_f32(v172, v178);
    float32x4_t v180 = vsubq_f32(v178, v172);
    v172.i32[3] = v372.i32[3];
    v375.columns[1] = (simd_float4)v169;
    v375.columns[2] = (simd_float4)v170;
    float32x4_t v181 = vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v176, *(float32x2_t *)v173.f32, 1), v175, v173.f32[0]), v177, v173, 2);
    float32x4_t v182 = vdivq_f32(v179, v181);
    float32x4_t v183 = vdivq_f32(v180, v181);
    v182.i32[3] = 0;
    v183.i32[3] = 0;
    v375.columns[3] = (simd_float4)v171;
    float32x4_t v376 = v172;
    int8x16_t v184 = (int8x16_t)vminnmq_f32(v182, v183);
    float32x4_t v185 = vmaxnmq_f32(v182, v183);
    float v186 = fmaxf(fmaxf(*(float *)v184.i32, *(float *)&v184.i32[2]), *(float *)&v184.i32[1]);
    float v187 = fminf(fminf(v185.f32[0], v185.f32[2]), v185.f32[1]);
    if (v187 < v186) {
      return 0;
    }
    if (v187 < v370 || v186 >= *(float *)(v3 + 60)) {
      return 0;
    }
    LODWORD(v189) = *(float *)v184.i32 < *(float *)&v184.i32[1];
    if (*(float *)v184.i32 < *(float *)&v184.i32[1]) {
      v184.i32[0] = v184.i32[1];
    }
    if (*(float *)v184.i32 < *(float *)&v184.i32[2]) {
      uint64_t v189 = 2;
    }
    else {
      uint64_t v189 = v189;
    }
    if (v186 < v370) {
      float v186 = v187;
    }
    float v370 = v186;
    float32x4_t v190 = (float32x4_t)v375.columns[v189 + 1];
    float32x4_t v366 = v181;
    v181.i32[0] = *(_DWORD *)((unint64_t)&v366 | (4 * v189));
    v184.i32[0] = 1.0;
    v191.i64[0] = 0x8000000080000000;
    v191.i64[1] = 0x8000000080000000;
    v184.i32[0] = vbslq_s8(v191, v184, (int8x16_t)v181).u32[0];
    if (v181.f32[0] == 0.0) {
      *(float *)v184.i32 = 0.0;
    }
    __n128 v364 = (__n128)vmulq_n_f32(v190, -*(float *)v184.i32);
  }
  uint64_t v205 = sub_1B649F5F4(v5, v56, v57, v58, v59, v60, v61, v62);
  if (!v205) {
    goto LABEL_166;
  }
  uint64_t v213 = v205;
  uint64_t v214 = sub_1B63CCE68(v205, v206, v207, v208, v209, v210, v211, v212);
  if (!v214) {
    goto LABEL_166;
  }
  uint64_t v222 = v214;
  CFArrayRef v223 = sub_1B64ABD08(v214, v215, v216, v217, v218, v219, v220, v221);
  if ((uint64_t)v223 < 1) {
    goto LABEL_166;
  }
  CFArrayRef v229 = v223;
  uint64_t v230 = sub_1B64ABD78(v222, 0, 0, v224, v225, v226, v227, v228);
  char v238 = sub_1B63D0C08((uint64_t)v230, v231, v232, v233, v234, v235, v236, v237);
  BOOL v239 = sub_1B63D0E64(v238);
  BOOL v247 = 0;
  if (!v239)
  {
    CFIndex v248 = 1;
    do
    {
      CFIndex v249 = v248;
      if (v229 == (const __CFArray *)v248) {
        break;
      }
      v250 = sub_1B64ABD78(v222, v248, 0, v242, v243, v244, v245, v246);
      char v258 = sub_1B63D0C08((uint64_t)v250, v251, v252, v253, v254, v255, v256, v257);
      BOOL v259 = sub_1B63D0E64(v258);
      CFIndex v248 = v249 + 1;
    }
    while (!v259);
    BOOL v247 = v249 >= (uint64_t)v229;
  }
  if (v247 || (*(_WORD *)(v3 + 8) & 0x80) != 0 || (*(unsigned char *)(v5 + 221) & 0x10) != 0)
  {
LABEL_166:
    sub_1B63D5848(v3, 0, 0, 0, 0, v370, vmlaq_n_f32(*(float32x4_t *)(v3 + 16), *(float32x4_t *)(v3 + 32), v370), v364);
    return 1;
  }
  CFArrayRef v260 = sub_1B63CCEC4(v213, v240, v241, v242, v243, v244, v245, v246);
  v267 = sub_1B64ACF7C(v222, 0, v261, v262, v263, v264, v265, v266);
  if (!v267) {
    return 0;
  }
  uint64_t v273 = (uint64_t)v267;
  uint64_t v274 = sub_1B64ACE9C(v222, 0, 0, v268, v269, v270, v271, v272);
  uint64_t v365 = sub_1B641D478(v273, v275, v276, v277, v278, v279, v280, v281);
  if (!v365) {
    return 0;
  }
  uint64_t v290 = v282;
  uint64_t v357 = v282 & 0xFFFFF000;
  if ((v282 & 0xFFFFF000) == 0)
  {
    sub_1B63E1308(v365, v282, (uint64_t)&v375, v284, v285, v286, v287, v288, *(float32x4_t *)(v3 + 64), *(__n128 *)(v3 + 80), *(int8x16_t *)(v3 + 96), v289);
    *(void *)(v3 + 304) = &v375;
  }
  CFArrayRef v291 = sub_1B64ABD08(v222, v282, v283, v284, v285, v286, v287, v288);
  if ((uint64_t)v291 < 1) {
    return 0;
  }
  CFArrayRef v297 = v291;
  CFIndex v298 = 0;
  uint64_t v360 = v290;
  uint64_t v353 = v290 & 0xFF000000000000;
  BOOL v204 = 1;
  uint64_t v355 = v274;
  CFArrayRef v352 = v260;
  while (1)
  {
    *(void *)(v3 + 192) = v298;
    unint64_t v299 = sub_1B64ABD78(v222, v298, 0, v292, v293, v294, v295, v296);
    v374.i64[0] = 0;
    float32x4_t v372 = 0u;
    long long v373 = 0u;
    float32x4_t v371 = 0u;
    sub_1B63D11F0((uint64_t)v299, v274, v300, v301, v302, v303, v304, v305, (uint64_t)&v371);
    if (sub_1B63D0F30((uint64_t)v299) || !sub_1B63D0E64(v372.i8[10])) {
      goto LABEL_164;
    }
    int v307 = 0;
    if ((*(_WORD *)(v3 + 8) & 8) != 0)
    {
      int v308 = 0;
      if ((uint64_t)v260 >= 1)
      {
        CFArrayRef v309 = sub_1B63CCF34(v213, v298 % (uint64_t)v260, v306, v292, v293, v294, v295, v296);
        int v307 = sub_1B64AF3EC((uint64_t)v309, v310, v311, v312, v313, v314, v315, v316);
        uint64_t v317 = (uint64_t)v309;
        uint64_t v274 = v355;
        int v308 = sub_1B64AF564(v317, v318, v319, v320, v321, v322, v323, v324);
      }
    }
    else
    {
      int v308 = 0;
    }
    *(unsigned char *)(v3 + 272) = v307;
    *(unsigned char *)(v3 + 273) = v308 == 1;
    float32x4_t v325 = v372;
    *(float32x4_t *)(v3 + 216) = v371;
    *(float32x4_t *)(v3 + 232) = v325;
    *(_OWORD *)(v3 + 248) = v373;
    *(void *)(v3 + 264) = v374.i64[0];
    *(void *)(v3 + 200) = v365;
    *(void *)(v3 + 208) = v360;
    BOOL v329 = v353 == 0x1000000000000 && v372.u8[10] == 0 && v372.u8[11] == 2 && v308 == 0;
    if (!v357)
    {
      v349 = sub_1B63D6E04;
      if (v372.u8[10] == 4) {
        v349 = sub_1B63D743C;
      }
      if (v329 && !((*(_WORD *)(v3 + 8) & 8) != 0 ? v307 : 1)) {
        v349 = sub_1B63D7920;
      }
      ((void (*)(void, void, uint64_t))v349)(0, v371.u32[2], v3);
      goto LABEL_164;
    }
    if (v372.u8[10] == 4) {
      char v330 = (unsigned int (*)(void))sub_1B63D6940;
    }
    else {
      char v330 = (unsigned int (*)(void))sub_1B63D631C;
    }
    if (v329 && !((*(_WORD *)(v3 + 8) & 8) != 0 ? v307 : 1)) {
      char v330 = (unsigned int (*)(void))sub_1B63D7C54;
    }
    if (v371.i32[2] < 0x41u)
    {
      int v351 = ((uint64_t (*)(void))v330)(0);
      uint64_t v274 = v355;
      if (v351) {
        return v204;
      }
      goto LABEL_164;
    }
    unsigned int v369 = 0;
    v367[0] = (__int128)v371;
    v367[1] = (__int128)v372;
    v367[2] = v373;
    uint64_t v368 = v374.i64[0];
    uint64_t v332 = sub_1B63D5C0C((uint64_t)v299, v367, v365, v360, (uint64_t)&v369, v294, v295, v296);
    if (v369) {
      break;
    }
LABEL_153:
    CFArrayRef v260 = v352;
    uint64_t v274 = v355;
LABEL_164:
    BOOL v204 = ++v298 < (uint64_t)v297;
    if ((const __CFArray *)v298 == v297) {
      return v204;
    }
  }
  uint64_t v333 = v332;
  uint64_t v334 = 0;
  uint64_t v335 = 32 * v369;
  while (1)
  {
    float32x4_t v336 = *(float32x4_t *)(v333 + v334);
    float32x4_t v337 = *(float32x4_t *)(v333 + v334 + 16);
    float32x4_t v338 = *(float32x4_t *)(v3 + 64);
    float32x4_t v339 = *(float32x4_t *)(v3 + 96);
    float32x4_t v340 = vsubq_f32(v336, v337);
    float32x4_t v341 = vaddq_f32(v336, v337);
    float32x4_t v342 = vmulq_f32(vsubq_f32(v340, v338), v339);
    float32x4_t v343 = vmulq_f32(vsubq_f32(v341, v338), v339);
    v342.i32[3] = 0;
    v343.i32[3] = 0;
    float32x4_t v344 = vminnmq_f32(v342, v343);
    float32x4_t v345 = vmaxnmq_f32(v342, v343);
    float v346 = fmaxf(fmaxf(v344.f32[0], v344.f32[2]), v344.f32[1]);
    uint64_t v347 = v334 + 32;
    BOOL v348 = fminf(fminf(v345.f32[0], v345.f32[2]), v345.f32[1]) >= v346
        && v346 < COERCE_FLOAT(HIDWORD(*(_OWORD *)(v3 + 96)));
    if (v348 && v330()) {
      return v204;
    }
    uint64_t v334 = v347;
    if (v335 == v347) {
      goto LABEL_153;
    }
  }
}

uint64_t sub_1B63D9B04(uint64_t a1, float *a2, float32x4_t a3, float32x4_t a4, __n128 a5)
{
  float32x4_t v5 = *(float32x4_t *)(a1 + 16);
  float32x4_t v6 = vmulq_f32(v5, *(float32x4_t *)a1);
  float32_t v7 = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0];
  float32x4_t v8 = v5;
  v8.f32[3] = v7;
  int8x16_t v9 = (int8x16_t)vmulq_f32(a4, v8);
  float v10 = vaddv_f32(vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL)));
  if (v10 == 0.0) {
    return 0;
  }
  int8x16_t v11 = (int8x16_t)vmulq_f32(a3, v8);
  float v12 = (float)-vaddv_f32(vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v11, v11, 8uLL))) / v10;
  if (v12 < 0.0 || v12 > a5.n128_f32[3]) {
    return 0;
  }
  float32x4_t v14 = vmlaq_n_f32(a3, a4, v12);
  float32x4_t v15 = *(float32x4_t *)(a1 + 32);
  int32x4_t v16 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v15, (int32x4_t)v15), (int8x16_t)v15, 0xCuLL), vnegq_f32(v5)), v15, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v5, (int32x4_t)v5), (int8x16_t)v5, 0xCuLL));
  float32x4_t v17 = vsubq_f32(v14, *(float32x4_t *)a1);
  int32x4_t v18 = (int32x4_t)vmulq_f32(v15, v17);
  int32x4_t v19 = (int32x4_t)vmulq_f32(v17, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v16, v16), (int8x16_t)v16, 0xCuLL));
  float32x2_t v20 = (float32x2_t)vzip1_s32((int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v18, 2), vadd_f32(*(float32x2_t *)v18.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v18.i8, 1))), (int32x2_t)vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v19, 2), vadd_f32(*(float32x2_t *)v19.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v19.i8, 1))));
  float32x2_t v21 = *(float32x2_t *)(a1 + 48);
  uint32x2_t v22 = (uint32x2_t)vcgt_f32(vneg_f32(v21), v20);
  if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  uint32x2_t v23 = (uint32x2_t)vcgt_f32(v20, v21);
  if ((vpmax_u32(v23, v23).u32[0] & 0x80000000) != 0) {
    return 0;
  }
  if (a2) {
    *a2 = v12;
  }
  return 1;
}

uint64_t sub_1B63D9C04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v10 = *(uint64_t **)(a1 + 32);
  int v11 = *((unsigned __int16 *)v10 + 4);
  if ((v11 & 0x1000) != 0)
  {
    if (sub_1B64A4DE4(a2)) {
      return 1;
    }
    float v10 = *(uint64_t **)(a1 + 32);
    int v11 = *((unsigned __int16 *)v10 + 4);
  }
  if ((v11 & 0x20) == 0) {
    goto LABEL_7;
  }
  if (sub_1B649F390(a2, a2, a3, a4, a5, a6, a7, a8)) {
    return 1;
  }
  float v10 = *(uint64_t **)(a1 + 32);
  int v11 = *((unsigned __int16 *)v10 + 4);
LABEL_7:
  if ((~v11 & 0x30) == 0)
  {
    if (sub_1B64A0C9C(a2, a2, a3, a4, a5, a6, a7, a8) == 0.0) {
      return 1;
    }
    float v10 = *(uint64_t **)(a1 + 32);
  }
  uint64_t v13 = *v10;
  if ((sub_1B64A3808(a2, a2, a3, a4, a5, a6, a7, a8) & v13) != 0
    && (char v14 = sub_1B64A4DAC(a2), v15 = *(void *)(a1 + 32), ((*(unsigned __int8 *)(v15 + 10) >> v14) & 1) != 0)
    && (*(unsigned char *)(a2 + 220) & 8) != 0
    && sub_1B63D8BD8(a2, v15)
    && (*(_WORD *)(*(void *)(a1 + 32) + 8) & 0x100) != 0)
  {
    return 2;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_1B63D9CE8(__n128 *a1, float32x4_t *a2, CFDictionaryRef theDict, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)theDict, a4, a5, a6, a7, a8, (uint64_t)"world");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)theDict, a4, a5, a6, a7, a8, (uint64_t)"segment");
LABEL_3:
  memset(__src, 0, 432);
  sub_1B63D52BC(__src, theDict);
  sub_1B64B2438(a1, (__n128 *)&__src[18], v11, v12, v13, v14, v15, v16);
  *((void *)&__src[19] + 1) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  float32x4_t v24 = *a2;
  float32x4_t v25 = vsubq_f32(a2[1], *a2);
  if ((BYTE8(__src[0]) & 2) != 0)
  {
    v24.i32[3] = 1.0;
    float32x4_t v29 = vmulq_f32(v25, v25);
    v29.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).u64[0];
    v29.f32[0] = sqrtf(v29.f32[0]);
    float32x4_t v28 = vdivq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0));
  }
  else
  {
    float32x4_t v29 = vmulq_f32(v25, v25);
    v29.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32((int32x4_t)v29, 2), vadd_f32(*(float32x2_t *)v29.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v29.f32, 1))).u32[0];
    float32x2_t v26 = vrsqrte_f32((float32x2_t)v29.u32[0]);
    float32x2_t v27 = vmul_f32(v26, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(v26, v26)));
    float32x4_t v28 = vmulq_n_f32(v25, vmul_f32(v27, vrsqrts_f32((float32x2_t)v29.u32[0], vmul_f32(v27, v27))).f32[0]);
    v24.i32[3] = 1.0;
    v29.i32[0] = 2139095040;
  }
  float32x4_t v30 = v28;
  v28.i32[3] = 0;
  __asm { FMOV            V4.4S, #1.0 }
  float32x4_t v122 = _Q4;
  float32x4_t v36 = vdivq_f32(_Q4, v30);
  v36.i32[3] = v29.i32[0];
  __src[1] = v24;
  __src[2] = v28;
  __src[3] = v36;
  uint64_t v37 = sub_1B64B1FBC((uint64_t)a1, v17, v18, v19, v20, v21, v22, v23);
  if (theDict) {
    Value = CFDictionaryGetValue(theDict, @"kHitTestRootNode");
  }
  else {
    Value = 0;
  }
  if (!Value) {
    Value = (const void *)v37;
  }
  if ((BYTE8(__src[0]) & 1) != 0 && Value == (const void *)v37)
  {
    *(void *)&long long v134 = 0;
    long long v132 = 0u;
    long long v133 = 0u;
    v143[0] = MEMORY[0x1E4F143A8];
    v143[1] = 3221225472;
    v143[2] = sub_1B63DA414;
    _OWORD v143[3] = &unk_1E6141070;
    v143[4] = __src;
    sub_1B65C4C3C((uint64_t)v143, (uint64_t)&v132);
    *(void *)&long long v132 = *(void *)&__src[0];
    BYTE12(v133) = (WORD4(__src[0]) & 0x200) != 0;
    if ((BYTE8(__src[0]) & 0x20) != 0) {
      DWORD1(v133) |= 2u;
    }
    if ((BYTE8(__src[0]) & 0x40) != 0) {
      DWORD1(v133) |= 0x20u;
    }
    DWORD2(v133) = BYTE10(__src[0]);
    uint64_t v46 = sub_1B64B2994((uint64_t)a1, v39, v40, v41, v42, v43, v44, v45);
    sub_1B65C5818(v46, (uint64_t)&v132);
    if ((WORD4(__src[0]) & 0x1000) != 0)
    {
      CFIndex Count = CFArrayGetCount(*((CFArrayRef *)&__src[19] + 1));
      if (Count >= 1)
      {
        CFIndex v48 = Count;
        CFIndex v49 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*((CFArrayRef *)&__src[19] + 1), v49);
          if (!ValueAtIndex) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v50, v51, v52, v53, v54, v55, (uint64_t)"result");
          }
          uint64_t v57 = ValueAtIndex[2];
          if (v57 && sub_1B64A4DF0(v57))
          {
            CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)&__src[19] + 1), v49);
            --v48;
          }
          else
          {
            ++v49;
          }
        }
        while (v49 < v48);
      }
    }
  }
  else if (BYTE8(__src[0]))
  {
    *(void *)&long long v132 = MEMORY[0x1E4F143A8];
    *((void *)&v132 + 1) = 3221225472;
    *(void *)&long long v133 = sub_1B63D9C04;
    *((void *)&v133 + 1) = &unk_1E6141050;
    *(void *)&long long v134 = __src;
    sub_1B64A18A4((uint64_t)Value, (uint64_t)&v132);
  }
  else
  {
    sub_1B63D8BD8((uint64_t)Value, (uint64_t)__src);
  }
  uint64_t v58 = CFArrayGetCount(*((CFArrayRef *)&__src[19] + 1));
  __int16 v59 = WORD4(__src[0]);
  if ((BYTE8(__src[0]) & 4) != 0)
  {
    v60.length = v58;
    if (v58 >= 2)
    {
      v60.location = 0;
      CFArraySortValues(*((CFMutableArrayRef *)&__src[19] + 1), v60, (CFComparatorFunction)sub_1B63DA47C, a2);
      __int16 v59 = WORD4(__src[0]);
    }
  }
  if ((v59 & 0x400) != 0 && *(void *)&__src[26])
  {
    long long v142 = 0uLL;
    sub_1B63C8F2C((float *)&v142, 1.0, 0.0, 0.0, 1.0);
    long long v141 = 0uLL;
    sub_1B63C8F2C((float *)&v141, 0.0, 1.0, 0.0, 1.0);
    v140[1] = 0;
    v140[0] = 0;
    sub_1B63C8F2C((float *)v140, 0.0, 0.0, 1.0, 1.0);
    sub_1B642A7B4(*(uint64_t *)&__src[26], 5.0, v61, v62, v63, v64, v65, v66, v67);
    CFIndex v68 = CFArrayGetCount(*((CFArrayRef *)&__src[19] + 1));
    if (v68 >= 1)
    {
      CFIndex v69 = v68;
      for (CFIndex i = 0; i != v69; ++i)
      {
        float32x4_t v78 = (__n128 *)CFArrayGetValueAtIndex(*((CFArrayRef *)&__src[19] + 1), i);
        uint64_t v136 = 0;
        float32x2_t v137 = &v136;
        uint64_t v138 = 0x2020000000;
        int v139 = 1065353216;
        uint64_t v79 = v78[1].n128_i64[0];
        if (v79)
        {
          uint64_t v80 = sub_1B649F5F4(v79, v71, v72, v73, v74, v75, v76, v77);
          if (v80)
          {
            uint64_t v83 = sub_1B63CCE68(v80, v81, v82, v73, v74, v75, v76, v77);
            uint64_t v84 = v83;
            if (v83)
            {
              uint64_t v85 = sub_1B64ACE9C(v83, 0, 0, v73, v74, v75, v76, v77);
              int v92 = sub_1B64ACF7C(v84, 0, v86, v87, v88, v89, v90, v91);
              if (v92)
              {
                int v93 = sub_1B64ABD78(v84, v78[2].n128_i64[0], 0, v73, v74, v75, v76, v77);
                if (v93)
                {
                  uint64_t v135 = 0;
                  long long v133 = 0u;
                  long long v134 = 0u;
                  long long v132 = 0u;
                  sub_1B63D11F0((uint64_t)v93, v85, v94, v73, v74, v75, v76, v77, (uint64_t)&v132);
                  v131[0] = v78[2].n128_u64[1];
                  v131[1] = 1;
                  *(void *)&long long v133 = v131;
                  WORD4(v133) = 1;
                  v125[0] = MEMORY[0x1E4F143A8];
                  v125[1] = 3221225472;
                  v125[2] = sub_1B63DA55C;
                  _OWORD v125[3] = &unk_1E6141098;
                  float32x2_t v129 = v92;
                  int8x16_t v128 = &v136;
                  memcpy(v126, __src, sizeof(v126));
                  float32x2_t v130 = v78;
                  long long v127 = v142;
                  v123[0] = v132;
                  v123[1] = v133;
                  v123[2] = v134;
                  uint64_t v124 = v135;
                  sub_1B63D2A6C((uint64_t)v123, (uint64_t)v125, v95, v96, v97, v98, v99, v100);
                }
              }
            }
          }
        }
        __n128 v101 = v78[6];
        v101.n128_u32[3] = *((_DWORD *)v137 + 6);
        sub_1B642AC18(*(uint64_t *)&__src[26], 0, &v141, v73, v74, v75, v76, v77, v101);
        float32x4_t v102 = (float32x4_t)v78[7];
        float32x4_t v103 = (float32x4_t)v78[8];
        float32x4_t v104 = (float32x4_t)v78[9];
        int32x4_t v105 = (int32x4_t)vmulq_f32(v102, v102);
        int32x4_t v106 = (int32x4_t)vmulq_f32(v103, v103);
        int32x4_t v107 = (int32x4_t)vmulq_f32(v104, v104);
        int32x4_t v108 = vzip2q_s32(v105, v107);
        float32x4_t v109 = (float32x4_t)vzip1q_s32(vzip1q_s32(v105, v107), v106);
        float32x4_t v110 = (float32x4_t)vtrn2q_s32(v105, v106);
        v110.i32[2] = v107.i32[1];
        float32x4_t v111 = vaddq_f32((float32x4_t)vzip1q_s32(v108, vdupq_laneq_s32(v106, 2)), vaddq_f32(v109, v110));
        int32x4_t v112 = vceqzq_f32(v111);
        v112.i32[3] = 0;
        float32x4_t v113 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v112), (int8x16_t)v111, (int8x16_t)vdivq_f32(v122, v111));
        float32x4_t v114 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32(vmulq_laneq_f32(v104, v113, 2), (float32x4_t)v78[5], 2), vmulq_lane_f32(v103, *(float32x2_t *)v113.f32, 1), (float32x2_t)v78[5].n128_u64[0], 1), vmulq_n_f32(v102, v113.f32[0]), COERCE_FLOAT(*(_OWORD *)&v78[5]));
        int32x4_t v115 = (int32x4_t)vmulq_f32(v114, v114);
        v115.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v115, 2), vadd_f32(*(float32x2_t *)v115.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v115.i8, 1))).u32[0];
        *(float32x2_t *)v113.f32 = vrsqrte_f32((float32x2_t)v115.u32[0]);
        *(float32x2_t *)v113.f32 = vmul_f32(*(float32x2_t *)v113.f32, vrsqrts_f32((float32x2_t)v115.u32[0], vmul_f32(*(float32x2_t *)v113.f32, *(float32x2_t *)v113.f32)));
        sub_1B642AA68(*(uint64_t *)&__src[26], 0, (float *)v140, v116, v117, v118, v119, v120, (float32x4_t)v78[6], vaddq_f32((float32x4_t)v78[6], vmulq_n_f32(v114, vmul_f32(*(float32x2_t *)v113.f32, vrsqrts_f32((float32x2_t)v115.u32[0], vmul_f32(*(float32x2_t *)v113.f32, *(float32x2_t *)v113.f32))).f32[0])));
        _Block_object_dispose(&v136, 8);
      }
    }
    sub_1B642A824(*(uint64_t *)&__src[26]);
  }
  return *((void *)&__src[19] + 1);
}

void sub_1B63DA3DC(_Unwind_Exception *a1)
{
}

uint64_t sub_1B63DA414(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v5 = result;
    for (uint64_t i = 0; i < a3; ++i)
    {
      uint64_t result = sub_1B63D8BD8(*(void *)(a2 + 8 * i), *(void *)(v5 + 32));
      if (result && (*(_WORD *)(*(void *)(v5 + 32) + 8) & 0x100) != 0) {
        break;
      }
    }
  }
  return result;
}

uint64_t sub_1B63DA47C(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"result");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"result");
LABEL_3:
  float32x4_t v11 = vsubq_f32(a1[6], *a3);
  float32x4_t v12 = vmulq_f32(v11, v11);
  float32x4_t v13 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1)));
  float32x4_t v14 = vsubq_f32(a2[6], *a3);
  float32x4_t v15 = vmulq_f32(v14, v14);
  float32x4_t v16 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 2), vaddq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.f32, 1)));
  unsigned __int8 v17 = vmovn_s32(vcgtq_f32(v16, v13)).u8[0];
  unsigned __int8 v18 = vmovn_s32(vcgtq_f32(v13, v16)).u8[0];
  if (v17) {
    return -1;
  }
  else {
    return v18 & 1;
  }
}

void sub_1B63DA55C(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a4;
  MEMORY[0x1F4188790](a1, a2);
  float32x4_t v14 = (_OWORD *)&v31.f32[-4 * v7];
  if (v9)
  {
    float32x4_t v15 = 0uLL;
    uint64_t v16 = v7;
    unsigned __int8 v17 = &v31 - v7;
    do
    {
      float32x4_t v31 = v15;
      unsigned int v18 = *a3++;
      *(double *)v19.i64 = sub_1B641E208(*(void *)(a1 + 488), v18, v8, v9, v10, v11, v12, v13);
      float32x4_t v20 = v31;
      *v17++ = v19;
      float32x4_t v15 = vaddq_f32(v20, v19);
      --v16;
    }
    while (v16);
    v19.f32[0] = (float)a4;
    float32x4_t v21 = vdivq_f32(v15, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 0));
    float v22 = 3.4028e38;
    uint64_t v23 = v7;
    float32x4_t v24 = &v31 - v7;
    do
    {
      float32x4_t v25 = *v24++;
      float32x4_t v26 = vsubq_f32(v25, v21);
      float32x4_t v27 = vmulq_f32(v26, v26);
      float v22 = fminf(v22, sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v27, 2), vaddq_f32(v27, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.f32, 1))).f32[0]));
      --v23;
    }
    while (v23);
    *(float *)(*(void *)(*(void *)(a1 + 480) + 8) + 24) = v22 * 0.5;
    do
    {
      float32x4_t v28 = (float32x4_t)v14[v23];
      uint64_t v29 = v23 + 1;
      if (v7 - 1 == v23) {
        uint64_t v30 = 0;
      }
      else {
        uint64_t v30 = v23 + 1;
      }
      sub_1B642AB40(*(void *)(a1 + 448), (float32x4_t *)(*(void *)(a1 + 496) + 112), (float *)(a1 + 464), v9, v10, v11, v12, v13, v28, (float32x4_t)v14[v30]);
      uint64_t v23 = v29;
    }
    while (v7 != v29);
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 480) + 8) + 24) = 2130706431;
  }
}

uint64_t sub_1B63DA6D0(__n128 *a1, uint64_t a2, const __CFDictionary *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, __n128 a10)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
LABEL_11:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"pointOfView");
    return 0;
  }
  double v42 = a9;
  __n128 v44 = a10;
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"world");
  a9 = v42;
  a10 = v44;
  if (!a2) {
    goto LABEL_11;
  }
LABEL_3:
  __asm { FMOV            V3.4S, #1.0 }
  *(double *)&_Q3 = a9;
  long long v46 = *(unint64_t *)&a9;
  long long v47 = _Q3;
  int v18 = sub_1B63D5100((uint64_t)&v46, 2, a2, (uint64_t)a1, (uint64_t)&v57, a6, a7, a8, a10);
  v45[0] = v57;
  v45[1] = v58;
  if (!v18) {
    return 0;
  }
  float32x4_t v41 = v58;
  float32x4_t v43 = v57;
  if (a3)
  {
    Value = CFDictionaryGetValue(a3, @"kHitTestClipToZRange");
    if (Value)
    {
      if (!CFEqual((CFTypeRef)*MEMORY[0x1E4F1CFD0], Value))
      {
        long long v55 = 0u;
        long long v56 = 0u;
        long long v53 = 0u;
        long long v54 = 0u;
        long long v51 = 0u;
        long long v52 = 0u;
        long long v49 = 0u;
        long long v50 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v46 = 0u;
        if (sub_1B63E0460(a2, (uint64_t)&v46, v25, v19, v20, v21, v22, v23))
        {
          if (v46)
          {
            *(uint64_t *)((char *)v57.i64 + 4) = 0;
            v57.i32[0] = 0;
            sub_1B64A1EC8(a2, (__n128 *)&v57, v27, v28, v29, v30, v31, v32);
            float32x4_t v35 = vsubq_f32(v41, v43);
            int32x4_t v36 = (int32x4_t)vmulq_f32(v35, v35);
            v36.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v36, 2), vadd_f32(*(float32x2_t *)v36.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v36.i8, 1))).u32[0];
            float32x2_t v37 = vrsqrte_f32((float32x2_t)v36.u32[0]);
            float32x2_t v38 = vmul_f32(v37, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v37, v37)));
            float32x4_t v39 = vmulq_n_f32(v35, vmul_f32(v38, vrsqrts_f32((float32x2_t)v36.u32[0], vmul_f32(v38, v38))).f32[0]);
            float32x4_t v40 = vmulq_f32(vsubq_f32(v43, v57), v39);
            float32x4_t v33 = vmlsq_lane_f32(v43, v39, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))), 0);
          }
          else
          {
            float32x4_t v33 = *(float32x4_t *)(sub_1B64A01D4(a2, v26, v27, v28, v29, v30, v31, v32) + 48);
          }
          v45[0] = v33;
          return sub_1B63D9CE8(a1, v45, a3, v19, v20, v21, v22, v23);
        }
        return 0;
      }
    }
  }
  return sub_1B63D9CE8(a1, v45, a3, v19, v20, v21, v22, v23);
}

uint64_t sub_1B63DA8D0(const void *a1, float32x4_t a2, float32x4_t a3)
{
  uint64_t v4 = sub_1B63D48F4();
  uint64_t v12 = (long long *)sub_1B64A01D4((uint64_t)a1, v5, v6, v7, v8, v9, v10, v11);
  long long v13 = v12[3];
  long long v15 = *v12;
  long long v14 = v12[1];
  *(_OWORD *)(v4 + 144) = v12[2];
  *(_OWORD *)(v4 + 160) = v13;
  *(_OWORD *)(v4 + 112) = v15;
  *(_OWORD *)(v4 + 12_Block_object_dispose(&STACK[0x2B0], 8) = v14;
  simd_float4x4 v35 = __invert_f4(*(simd_float4x4 *)(v4 + 112));
  float32x4_t v31 = (float32x4_t)v35.columns[0];
  float32x4_t v32 = (float32x4_t)v35.columns[1];
  float32x4_t v30 = (float32x4_t)v35.columns[2];
  *(float32x4_t *)(v4 + 96) = a2;
  *(float32x4_t *)(v4 + 64) = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32((float32x4_t)v35.columns[3], (float32x4_t)v35.columns[2], a2, 2), (float32x4_t)v35.columns[1], *(float32x2_t *)a2.f32, 1), (float32x4_t)v35.columns[0], a2.f32[0]);
  sub_1B63D49F4(v4, a1, v16, v17, v18, v19, v20, v21);
  float32x4_t v22 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32(v30, a3, 2), v32, *(float32x2_t *)a3.f32, 1), v31, a3.f32[0]);
  float32x4_t v23 = vmulq_f32(a3, a3);
  float32x4_t v24 = vmulq_f32(v22, v22);
  v24.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v24, 2), vaddq_f32(v24, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 1))).u64[0];
  float32x4_t v25 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v24.f32, 0);
  v25.i32[3] = 0;
  float32x4_t v26 = vrsqrteq_f32(v25);
  float32x4_t v27 = vmulq_f32(v26, vrsqrtsq_f32(v25, vmulq_f32(v26, v26)));
  int32x4_t v28 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v24.f32[0] != 0.0)), 0x1FuLL));
  v28.i32[3] = 0;
  *(int8x16_t *)(v4 + 80) = vbslq_s8((int8x16_t)vcltzq_s32(v28), (int8x16_t)vmulq_f32(v22, vmulq_n_f32(vmulq_f32(v27, vrsqrtsq_f32(v25, vmulq_f32(v27, v27))), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v23, 2), vaddq_f32(v23, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v23.f32, 1))).f32[0]))), (int8x16_t)v22);
  return v4;
}

void sub_1B63DAA00(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 16) = 0;
  }
}

CFStringRef sub_1B63DAA34(uint64_t a1)
{
  CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10) {
    uint64_t v10 = sub_1B64A1954(v10, v2, v3, v4, v5, v6, v7, v8);
  }
  return CFStringCreateWithFormat(v9, 0, @"<CFXHitTestResult %@ %f,%f,%f>", v10, *(float *)(a1 + 96), *(float *)(a1 + 100), *(float *)(a1 + 104));
}

void sub_1B63DAAA4(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v10 = a2;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"material");
  }
  uint64_t v12 = sub_1B64AF43C(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);

  sub_1B6476640(v12, v10, a3, v13, v14, v15, v16, v17, a9);
}

float32_t sub_1B63DAB1C(float32x4_t *a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  if (a1)
  {
    if (a3) {
      goto LABEL_3;
    }
  }
  else
  {
    __n128 v17 = a9;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"sphere");
    a9 = v17;
    if (a3) {
      goto LABEL_3;
    }
  }
  __n128 v18 = a9;
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"transformedSphere");
  a9 = v18;
LABEL_3:
  float32x4_t v12 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a2[3], a2[2], *a1, 2), a2[1], *(float32x2_t *)a1->f32, 1), *a2, COERCE_FLOAT(*a1));
  v12.i32[3] = *(_DWORD *)(a3 + 12);
  *(float32x4_t *)a3 = v12;
  float32x2_t v13 = vabs_f32((float32x2_t)a9.n128_u64[0]);
  if (v13.f32[0] < v13.f32[1]) {
    v13.f32[0] = v13.f32[1];
  }
  float v14 = fabsf(a9.n128_f32[2]);
  if (v13.f32[0] >= v14) {
    float v15 = v13.f32[0];
  }
  else {
    float v15 = v14;
  }
  float32_t result = v15 * a1->f32[3];
  v12.f32[3] = result;
  *(float32x4_t *)a3 = v12;
  return result;
}

double sub_1B63DAC00(float *a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"modelMatrix");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"normalMatrix");
LABEL_3:
  float v10 = a1[9];
  float v11 = a1[10];
  float v13 = a1[5];
  float v12 = a1[6];
  float v14 = a1[8];
  float v15 = a1[4];
  float v16 = (float)(v13 * v11) - (float)(v12 * v10);
  float v17 = *a1;
  float v18 = a1[1];
  float v19 = a1[2];
  float v20 = (float)(v18 * v11) - (float)(v19 * v10);
  float v21 = (float)(v18 * v12) - (float)(v19 * v13);
  float v22 = (float)((float)(*a1 * v16) - (float)(v15 * v20)) + (float)(v14 * v21);
  if (v22 == 0.0)
  {
    long long v23 = xmmword_1B6E4F2E0;
    long long v24 = xmmword_1B6E4F320;
    long long v25 = xmmword_1B6E4F300;
  }
  else
  {
    float v26 = -v19;
    float v27 = 1.0 / v22;
    HIDWORD(v25) = 0;
    *(float *)&long long v25 = v16 * v27;
    *((float *)&v25 + 1) = -(float)((float)((float)(v14 * (float)-v12) + (float)(v15 * v11)) * v27);
    HIDWORD(v23) = 0;
    *((float *)&v25 + 2) = (float)((float)(v15 * v10) - (float)(v13 * v14)) * v27;
    float v28 = (float)((float)(v14 * v26) + (float)(v17 * v11)) * v27;
    float v29 = (float)(v17 * v10) - (float)(v18 * v14);
    HIDWORD(v24) = 0;
    *(float *)&long long v24 = -(float)(v20 * v27);
    *((float *)&v24 + 1) = v28;
    *((float *)&v24 + 2) = -(float)(v29 * v27);
    *(float *)&long long v23 = v21 * v27;
    *((float *)&v23 + 1) = -(float)((float)((float)(v15 * v26) + (float)(v17 * v12)) * v27);
    *((float *)&v23 + 2) = (float)((float)(v18 * (float)-v15) + (float)(v17 * v13)) * v27;
  }
  *a2 = v25;
  a2[1] = v24;
  double result = 0.0;
  a2[2] = v23;
  a2[3] = xmmword_1B6E4F370;
  return result;
}

void sub_1B63DAD7C(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2)
    {
      CFRelease(v2);
      *a1 = 0;
    }
    uint64_t v3 = a1[1];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

CFComparisonResult sub_1B63DADD4(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"couple1");
  if (!a2) {
LABEL_3:
  }
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"couple2");
LABEL_4:
  if (sub_1B64AEFF4(*a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8)) {
    CFStringRef v17 = (const __CFString *)sub_1B64AEFF4(*a1, v10, v11, v12, v13, v14, v15, v16);
  }
  else {
    CFStringRef v17 = &stru_1F0FCDBB0;
  }
  if (sub_1B64AEFF4(*a2, v10, v11, v12, v13, v14, v15, v16)) {
    CFStringRef v25 = (const __CFString *)sub_1B64AEFF4(*a2, v18, v19, v20, v21, v22, v23, v24);
  }
  else {
    CFStringRef v25 = &stru_1F0FCDBB0;
  }
  CFComparisonResult result = CFStringCompare(v17, v25, 0);
  if (result) {
    return result;
  }
  uint64_t v27 = a1[1];
  uint64_t v28 = a2[1];
  if (!v27)
  {
    uint64_t v29 = 0;
    if (v28) {
      goto LABEL_15;
    }
LABEL_17:
    uint64_t v30 = 0;
    goto LABEL_18;
  }
  uint64_t v29 = sub_1B63D11E8(v27);
  if (!v28) {
    goto LABEL_17;
  }
LABEL_15:
  uint64_t v30 = sub_1B63D11E8(v28);
LABEL_18:
  uint64_t v31 = -1;
  if (v29 >= v30) {
    uint64_t v31 = 1;
  }
  if (v29 == v30) {
    return 0;
  }
  else {
    return v31;
  }
}

void sub_1B63DAEE8(uint64_t a1)
{
  CFSetRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0);
  uint64_t v10 = sub_1B63CCE68(a1, v3, v4, v5, v6, v7, v8, v9);
  CFIndex v18 = (CFIndex)sub_1B63CCEC4(a1, v11, v12, v13, v14, v15, v16, v17);
  if (v18 >= 1)
  {
    CFIndex v26 = v18;
    if (sub_1B64ABD08(v10, v19, v20, v21, v22, v23, v24, v25) == (const __CFArray *)v18)
    {
      for (uint64_t i = 0; i != v26; ++i)
      {
        uint64_t v28 = sub_1B63CA51C(0x10uLL);
        *uint64_t v28 = 0;
        v28[1] = 0;
        simd_float4x4 v35 = sub_1B63CCF34(a1, i, v29, v30, v31, v32, v33, v34);
        if (v35) {
          simd_float4x4 v35 = CFRetain(v35);
        }
        *uint64_t v28 = v35;
        if ((uint64_t)sub_1B64ABD08(v10, v36, v37, v38, v39, v40, v41, v42) >= 1)
        {
          long long v48 = sub_1B64ABD78(v10, i, 0, v43, v44, v45, v46, v47);
          if (v48) {
            long long v48 = CFRetain(v48);
          }
          v28[1] = v48;
        }
        CFArrayAppendValue(Mutable, v28);
      }
      if (v26 >= 2)
      {
        v78.location = 0;
        v78.length = v26;
        CFArraySortValues(Mutable, v78, (CFComparatorFunction)sub_1B63DADD4, 0);
      }
      sub_1B63CE464(a1, v49, v50, v51, v52, v53, v54, v55);
      sub_1B64AD508(v10, v56, v57, v58, v59, v60, v61, v62);
      for (CFIndex j = 0; j != v26; ++j)
      {
        ValueAtIndex = (const void **)CFArrayGetValueAtIndex(Mutable, j);
        sub_1B64AD1E8(v10, ValueAtIndex[1], v65, v66, v67, v68, v69, v70);
        sub_1B63CE298(a1, (void *)*ValueAtIndex, v71, v72, v73, v74, v75, v76);
        sub_1B63DAD7C(ValueAtIndex);
      }
    }
  }

  CFRelease(Mutable);
}

uint64_t sub_1B63DB064(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a4;
  uint64_t v161 = *MEMORY[0x1E4F143B8];
  long long v159 = 0u;
  long long v160 = 0u;
  long long context = 0u;
  float v150 = 0;
  float v149 = 0;
  uint64_t v151 = 0;
  long long v148 = 0u;
  memset(v147, 0, sizeof(v147));
  long long v145 = 0u;
  long long v146 = 0u;
  long long v143 = 0u;
  long long v144 = 0u;
  *(double *)&long long v10 = sub_1B64A2650(a1, a2, a3, a4, a5, a6, a7, a8);
  v142[0] = v10;
  v142[1] = v11;
  _OWORD v142[2] = v12;
  v142[3] = v13;
  v141[0] = xmmword_1B6E4F300;
  v141[1] = xmmword_1B6E4F320;
  v141[2] = xmmword_1B6E4F2E0;
  v141[3] = xmmword_1B6E4F370;
  sub_1B64A2614(a1, (uint64_t)v141);
  long long v139 = 0u;
  long long v140 = 0u;
  long long v137 = 0u;
  long long v138 = 0u;
  BOOL v131 = sub_1B64A0A1C(a1, v14, v15, v16, v17, v18, v19, v20);
  if (v131)
  {
    uint64_t v28 = (long long *)sub_1B64A0B00(a1, v21, v22, v23, v24, v25, v26, v27);
    long long v29 = v28[3];
    long long v31 = *v28;
    long long v30 = v28[1];
    long long v139 = v28[2];
    long long v140 = v29;
    long long v137 = v31;
    long long v138 = v30;
    sub_1B64A0A70(a1, v141, v32, v33, v34, v35, v36, v37);
  }
  *(int64x2_t *)((char *)v147 + _Block_object_dispose(&STACK[0x2B0], 8) = vdupq_n_s64(3uLL);
  *(_OWORD *)((char *)&v147[1] + _Block_object_dispose(&STACK[0x2B0], 8) = xmmword_1B6E4FD10;
  *(void *)&long long v148 = 0;
  long long v143 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v146 = 0u;
  *((void *)&v147[2] + 1) = 4;
  *(void *)&v147[0] = 0;
  BYTE8(v14_Block_object_dispose(&STACK[0x2B0], 8) = v8;
  CFAllocatorRef v38 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, 0, MEMORY[0x1E4F1D540]);
  CFArrayRef v40 = CFArrayCreateMutable(v38, 0, 0);
  CFMutableArrayRef v41 = CFArrayCreateMutable(v38, 0, MEMORY[0x1E4F1D510]);
  CFAllocatorRef bytesDeallocator = v38;
  CFMutableDictionaryRef v42 = CFDictionaryCreateMutable(v38, 0, 0, 0);
  *(void *)&long long context = Mutable;
  *((void *)&context + 1) = v40;
  *(void *)&long long v159 = &v143;
  CFMutableArrayRef v128 = v41;
  *(void *)&long long v160 = v41;
  *((void *)&v160 + 1) = v42;
  float v149 = 0;
  float v150 = sub_1B63DB6B0;
  uint64_t v151 = 0;
  uint64_t v132 = a1;
  sub_1B63F3570(a1, &v149, 0, (uint64_t)&context, v43, v44, v45, v46);
  uint64_t v47 = -[VFXModel __createCFObject]_0();
  long long v48 = (const void *)-[VFXMesh __createCFObject]_0();
  sub_1B63CDBD0(v47, (uint64_t)v48, v49, v50, v51, v52, v53, v54);
  CFRelease(v48);
  uint64_t v129 = v47;
  CFDictionaryRef cf = Mutable;
  *(void *)&long long context = v47;
  *((void *)&context + 1) = &v143;
  CFMutableDictionaryRef v127 = v42;
  *(void *)&long long v159 = v42;
  CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)sub_1B63DBA40, &context);
  CFIndex Count = CFArrayGetCount(v40);
  if (Count >= 1)
  {
    CFIndex v62 = 0;
    do
    {
      while (1)
      {
        uint64_t v63 = *((void *)CFArrayGetValueAtIndex(v40, v62) + 1);
        v157[0] = MEMORY[0x1E4F143A8];
        v157[1] = 3221225472;
        v157[2] = sub_1B63E1C5C;
        v157[3] = &unk_1E6141128;
        v157[4] = &v143;
        sub_1B64AAFB4(v63, 1, (uint64_t)v157, v64, v65, v66, v67, v68);
        if (*((void *)&v147[1] + 1) == 4) {
          break;
        }
        if (++v62 >= Count) {
          goto LABEL_12;
        }
      }
      ++v62;
    }
    while (*((void *)&v147[0] + 1) != 4 && v62 < Count);
  }
LABEL_12:
  CFIndex v133 = Count;
  uint64_t v70 = 0;
  __asm { FMOV            V0.4S, #1.0 }
  float32x4_t v135 = _Q0;
  do
  {
    if (*((uint64_t *)&v143 + v70) >= 1)
    {
      uint64_t v76 = 0;
      uint64_t v77 = (uint64_t *)v147 + v70 + 1;
      do
      {
        uint64_t v78 = v148;
        uint64_t v79 = *v77;
        if (!*v77) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. __AllocateNewSource - componentsCount is zero", v55, v56, v57, v58, v59, v60, (uint64_t)"componentsCount!=0");
        }
        if (v78 <= (0x7FFFFFFF / v79) && v78 * v79 <= 0x1FFFFFFF)
        {
          uint64_t v81 = (const UInt8 *)malloc_type_calloc(4 * v78 * v79, 1uLL, 0x6EB2BC6BuLL);
          CFDataRef v82 = CFDataCreateWithBytesNoCopy(bytesDeallocator, v81, 4 * v78 * v79, bytesDeallocator);
          uint64_t v86 = (const void *)sub_1B641CF98(v82, (char)v70, v78, v79, 1, v83, v84, v85);
          CFRelease(v82);
          if (v86)
          {
            if (v70 == 2)
            {
              uint64_t v88 = sub_1B641D8A0((uint64_t)v86, v87, v55, v56, v57, v58, v59, v60);
              if (v88 >= 1)
              {
                uint64_t v91 = v88;
                for (uint64_t i = 0; i != v91; ++i)
                  sub_1B647B6A8((uint64_t)v86, i, v89, v90, v57, v58, v59, v60, v135);
              }
            }
            sub_1B64AC000((uint64_t)v48, v86, 0, 0, v57, v58, v59, v60);
            CFRelease(v86);
          }
        }
        ++v76;
      }
      while (v76 < *((void *)&v143 + v70));
    }
    ++v70;
  }
  while (v70 != 9);
  CFArrayRef v93 = v40;
  if (Count >= 1)
  {
    CFIndex v94 = 0;
    uint64_t v95 = 0;
    uint64_t v96 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v93, v94);
      uint64_t v105 = ValueAtIndex[1];
      uint64_t v106 = ValueAtIndex[3];
      long long v155 = 0u;
      long long v156 = 0u;
      long long v153 = 0u;
      long long v154 = 0u;
      CFIndex v136 = v94;
      if (v106)
      {
        sub_1B64A27C4(v106, (uint64_t)&v153, v99, v100, v101, v102, v103, v104);
      }
      else
      {
        long long v153 = xmmword_1B6E4F300;
        long long v154 = xmmword_1B6E4F320;
        long long v155 = xmmword_1B6E4F2E0;
        long long v156 = xmmword_1B6E4F370;
      }
      for (uint64_t j = 0; j != 9; ++j)
      {
        if (*((uint64_t *)&v143 + j) >= 1)
        {
          uint64_t v108 = 0;
          uint64_t v109 = v96;
          while (1)
          {
            float32x4_t v110 = sub_1B64AC5F8((uint64_t)v48, (char)j, v108, 0, v101, v102, v103, v104);
            int32x4_t v115 = sub_1B64AC5F8(v105, (char)j, v108, 1, v111, v112, v113, v114);
            if (!v115) {
              goto LABEL_46;
            }
            uint64_t v96 = (uint64_t)v115;
            if ((unint64_t)(j - 2) < 3) {
              break;
            }
            if (j == 1)
            {
              memset(v152, 0, sizeof(v152));
              sub_1B63DAC00((float *)&v153, v152, v99, v100, v101, v102, v103, v104);
              uint64_t v118 = v152;
              uint64_t v116 = (uint64_t)v110;
              uint64_t v117 = v96;
              goto LABEL_45;
            }
            if (j)
            {
              sub_1B63F2F54(0, @"Warning: __MergeMeshSources unknown source type\n", v99, v100, v101, v102, v103, v104, v126);
              goto LABEL_46;
            }
            sub_1B63DD618((uint64_t)v110, (uint64_t)v115, (uint64_t)&v153, v95, v101, v102, v103, v104, v126);
LABEL_47:
            ++v108;
            uint64_t v109 = v96;
            if (v108 >= *((void *)&v143 + j)) {
              goto LABEL_50;
            }
          }
          uint64_t v116 = (uint64_t)v110;
          uint64_t v117 = v96;
          uint64_t v118 = 0;
LABEL_45:
          sub_1B63DD618(v116, v117, (uint64_t)v118, v95, v101, v102, v103, v104, v126);
LABEL_46:
          uint64_t v96 = v109;
          goto LABEL_47;
        }
LABEL_50:
        ;
      }
      if (v96) {
        v95 += sub_1B641D8A0(v96, v98, v99, v100, v101, v102, v103, v104);
      }
      CFArrayRef v93 = v40;
      CFIndex v94 = v136 + 1;
    }
    while (v136 + 1 != v133);
  }
  sub_1B63DAEE8(v129);
  CFRelease(cf);
  sub_1B63DBAB8(v93);
  CFRelease(v128);
  CFRelease(v127);
  CFRelease(v93);
  sub_1B64A2614(v132, (uint64_t)v142);
  if (v131) {
    sub_1B64A0A70(v132, &v137, v119, v120, v121, v122, v123, v124);
  }
  return v129;
}

uint64_t sub_1B63DB6B0(const void *a1, const __CFDictionary **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v10 = *a2;
  long long v11 = a2[4];
  uint64_t v12 = sub_1B649F5F4((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v12)
  {
    uint64_t v13 = v12;
    if ((sub_1B64A3928((uint64_t)a1) & 1) == 0)
    {
      uint64_t v21 = a2[1];
      uint64_t v120 = sub_1B63CCE68(v13, v14, v15, v16, v17, v18, v19, v20);
      if (v120)
      {
        if (sub_1B64ACF7C(v120, 1, v22, v23, v24, v25, v26, v27))
        {
          if (!a1) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v29, v30, v31, v32, v33, v34, (uint64_t)"node");
          }
          uint64_t v35 = sub_1B649F5F4((uint64_t)a1, v28, v29, v30, v31, v32, v33, v34);
          if (v35)
          {
            uint64_t v43 = v35;
            uint64_t v44 = sub_1B63CCE68(v35, v36, v37, v38, v39, v40, v41, v42);
            if (v44)
            {
              uint64_t v52 = v44;
              CFArrayRef v53 = sub_1B64ABD08(v44, v45, v46, v47, v48, v49, v50, v51);
              if (v53)
              {
                uint64_t v54 = (uint64_t)v53;
                theArray = v21;
                CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                CFDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFIndex)v53, 0);
                if (v54 >= 1)
                {
                  for (CFIndex i = 0; i != v54; ++i)
                  {
                    uint64_t v57 = malloc_type_malloc(0x20uLL, 0x20040DC1BFBCFuLL);
                    v57[1] = v52;
                    void *v57 = sub_1B64ABD78(v52, i, 1, v58, v59, v60, v61, v62);
                    v57[2] = sub_1B63CCF34(v43, i, v63, v64, v65, v66, v67, v68);
                    v57[3] = a1;
                    CFArrayAppendValue(Mutable, v57);
                  }
                }
                if (Mutable)
                {
                  CFIndex Count = CFArrayGetCount(Mutable);
                  CFArrayAppendValue(v11, a1);
                  if (Count >= 1)
                  {
                    CFIndex v70 = 0;
                    CFDictionaryRef v71 = a2[2];
                    uint64_t v72 = a2[5];
                    uint64_t v73 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
                    do
                    {
                      ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(Mutable, v70);
                      if (!ValueAtIndex) {
                        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v75, v76, v77, v78, v79, v80, (uint64_t)"element");
                      }
                      sub_1B64A2F68(ValueAtIndex[3], v74, v75, v76, v77, v78, v79, v80);
                      uint64_t v91 = 0;
                      if (v89 >= 1.0)
                      {
                        uint64_t v90 = ValueAtIndex[2];
                        if (!v90 || sub_1B64AF9CC(v90, v82, v83, v84, v85, v86, v87, v88)) {
                          uint64_t v91 = 1;
                        }
                      }
                      uint64_t v92 = ValueAtIndex[2];
                      if (v92 && sub_1B64AF3EC(v92, v82, v83, v84, v85, v86, v87, v88)) {
                        v91 |= 2uLL;
                      }
                      int v93 = sub_1B63D0C08(*ValueAtIndex, v82, v83, v84, v85, v86, v87, v88);
                      if (v93 == 2)
                      {
                        uint64_t v95 = (const void *)(v91 | 0x10);
                      }
                      else
                      {
                        uint64_t v94 = v91 | 4;
                        if (v93) {
                          uint64_t v94 = v91;
                        }
                        if (v93 == 1) {
                          uint64_t v95 = (const void *)(v91 | 8);
                        }
                        else {
                          uint64_t v95 = (const void *)v94;
                        }
                      }
                      Value = (void *)CFDictionaryGetValue(v10, v95);
                      if (!Value)
                      {
                        Value = CFDictionaryCreateMutable(allocator, 0, 0, v73);
                        CFDictionarySetValue(v10, v95, Value);
                        CFRelease(Value);
                      }
                      CFDictionarySetValue(v72, ValueAtIndex, *((const void **)v71 + 18));
                      uint64_t v97 = (void *)CFDictionaryGetValue((CFDictionaryRef)Value, (const void *)ValueAtIndex[2]);
                      if (!v97)
                      {
                        uint64_t v97 = CFArrayCreateMutable(allocator, 0, 0);
                        CFDictionarySetValue((CFMutableDictionaryRef)Value, (const void *)ValueAtIndex[2], v97);
                        CFRelease(v97);
                      }
                      CFArrayAppendValue((CFMutableArrayRef)v97, ValueAtIndex);
                      ++v70;
                    }
                    while (Count != v70);
                    uint64_t v104 = sub_1B64ACF7C(v120, 1, v98, v99, v100, v101, v102, v103);
                    if (v104)
                    {
                      uint64_t v112 = 0;
                      *((void *)v71 + 18) += sub_1B641D8A0((uint64_t)v104, v105, v106, v107, v108, v109, v110, v111);
                      do
                      {
                        uint64_t v113 = sub_1B64AD020(v120, (char)v112);
                        if (v113 > *((void *)v71 + v112)) {
                          *((void *)v71 + v112) = v113;
                        }
                        ++v112;
                      }
                      while (v112 != 9);
                    }
                    uint64_t v114 = malloc_type_malloc(0x20uLL, 0x20040DC1BFBCFuLL);
                    int32x4_t v115 = CFArrayGetValueAtIndex(Mutable, 0);
                    long long v116 = v115[1];
                    *uint64_t v114 = *v115;
                    v114[1] = v116;
                    CFArrayAppendValue(theArray, v114);
                  }
                  CFRelease(Mutable);
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

void sub_1B63DBA40(char a1, CFDictionaryRef theDict, uint64_t *a3)
{
  uint64_t v3 = a3[1];
  uint64_t context = *a3;
  uint64_t v6 = 0;
  if (*(uint64_t *)(v3 + 144) < 0x10000) {
    int v4 = 2;
  }
  else {
    int v4 = 4;
  }
  HIDWORD(v6) = v4;
  LOBYTE(v6) = a1 & 1 | (*(unsigned char *)(v3 + 152) != 0);
  uint64_t v7 = a3[2];
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1B63E151C, &context);
}

void sub_1B63DBAB8(const __CFArray *a1)
{
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
      free(ValueAtIndex);
    }
  }

  CFArrayRemoveAllValues(a1);
}

const void *sub_1B63DBB24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v213 = sub_1B649F5F4(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v213) {
    return 0;
  }
  if (sub_1B64A16A0(a1, v10, v11, v12, v13, v14, v15, v16)) {
    return 0;
  }
  if (sub_1B64A14EC(a1, v17, v18, v19, v20, v21, v22, v23)) {
    return 0;
  }
  uint64_t v33 = sub_1B63CCE68(v213, v24, v25, v26, v27, v28, v29, v30);
  if (!v33) {
    return 0;
  }
  uint64_t v40 = v33;
  uint64_t v41 = sub_1B64ACF7C(v33, 1, v34, v35, v36, v37, v38, v39);
  uint64_t v49 = a2;
  uint64_t v50 = v41 ? sub_1B641D8A0((uint64_t)v41, v42, v43, v44, v45, v46, v47, v48) : 0;
  if (v50 <= v49) {
    return 0;
  }
  uint64_t v31 = (const void *)sub_1B64A0828();
  uint64_t v58 = sub_1B64A1954(a1, v51, v52, v53, v54, v55, v56, v57);
  if (v58)
  {
    CFStringRef v65 = CFStringCreateWithFormat(0, 0, @"%@-splitContainer", v58);
    sub_1B64A2F04((uint64_t)v31, v65, v66, v67, v68, v69, v70, v71);
    CFRelease(v65);
  }
  else
  {
    sub_1B64A2F04((uint64_t)v31, @"splitContainer", v59, v60, v61, v62, v63, v64);
  }
  uint64_t v208 = (float32x4_t *)a1;
  sub_1B64A107C(a1, v31, v72, v73, v74, v75, v76, v77);
  CFRelease(v31);
  size_t v78 = 8 * v50;
  uint64_t v79 = malloc_type_malloc(v78, 0x100004000313F17uLL);
  size_t v217 = v78;
  uint64_t v80 = malloc_type_malloc(v78, 0x100004000313F17uLL);
  CFArrayRef v218 = sub_1B63CCEC4(v213, v81, v82, v83, v84, v85, v86, v87);
  CFArrayRef v209 = sub_1B64ABD08(v40, v88, v89, v90, v91, v92, v93, v94);
  if ((uint64_t)v209 >= 1)
  {
    uint64_t v100 = v49;
    uint64_t v101 = 0;
    CFIndex v102 = 0;
    uint64_t v223 = 0;
    uint64_t v224 = 0;
    uint64_t v222 = 0;
    uint64_t v215 = (uint64_t)v31;
    uint64_t v216 = v40;
    do
    {
      uint64_t v103 = sub_1B64ABD78(v40, v102, 1, v95, v96, v97, v98, v99);
      uint64_t v221 = v101 + 1;
      sub_1B63DBF98((uint64_t)v31, v101, &v224, &v222, &v223);
      uint64_t v104 = v222;
      int v112 = sub_1B63D0C08((uint64_t)v103, v105, v106, v107, v108, v109, v110, v111);
      if (v112 == 3) {
        char v119 = 3;
      }
      else {
        char v119 = 2 * (v112 == 2);
      }
      sub_1B63D04D0(v104, v119, v113, v114, v115, v116, v117, v118);
      char v127 = sub_1B63D0C54((uint64_t)v103, v120, v121, v122, v123, v124, v125, v126);
      sub_1B63D0D7C(v104, v127, v128, v129, v130, v131, v132, v133);
      uint64_t v134 = sub_1B63D11E8((uint64_t)v103);
      uint64_t v142 = sub_1B63D0DCC((uint64_t)v103, v135, v136, v137, v138, v139, v140, v141);
      bzero(v80, v217);
      uint64_t v211 = v102 / (uint64_t)v218;
      CFIndex v212 = v102;
      uint64_t v210 = v134;
      uint64_t v219 = v104;
      if (v134 < 1)
      {
        uint64_t v220 = 0;
        uint64_t v146 = 0;
      }
      else
      {
        uint64_t v143 = 0;
        uint64_t v144 = 0;
        uint64_t v220 = 0;
        uint64_t v214 = v142 - 1;
        do
        {
          if (v142 < 1)
          {
            uint64_t v146 = v143;
          }
          else
          {
            uint64_t v145 = 0;
            uint64_t v146 = v143;
            do
            {
              uint64_t v147 = sub_1B63D14A0((uint64_t)v103, v144, v145, 0, v96, v97, v98, v99);
              if (!*((void *)v80 + v147))
              {
                v79[v146++] = v147;
                *((void *)v80 + v147) = v146;
                if (v146 == v100)
                {
                  if (v145 == v214) {
                    uint64_t v143 = v100;
                  }
                  v144 -= v145 != v214;
                  sub_1B63DC0A0(v220, v144 + 1, (uint64_t)v80, (uint64_t)v79, v143, (uint64_t)v103, v219, v224, v216);
                  CFArrayRef v154 = sub_1B63CCF34(v213, v212 - v211 * (void)v218, v148, v149, v150, v151, v152, v153);
                  sub_1B63CE524(v223, v154, 0, v155, v156, v157, v158, v159);
                  sub_1B63DBF98(v215, v221, &v224, &v222, &v223);
                  uint64_t v160 = v222;
                  int v168 = sub_1B63D0C08((uint64_t)v103, v161, v162, v163, v164, v165, v166, v167);
                  if (v168 == 3) {
                    char v175 = 3;
                  }
                  else {
                    char v175 = 2 * (v168 == 2);
                  }
                  sub_1B63D04D0(v160, v175, v169, v170, v171, v172, v173, v174);
                  char v183 = sub_1B63D0C54((uint64_t)v103, v176, v177, v178, v179, v180, v181, v182);
                  uint64_t v219 = v160;
                  sub_1B63D0D7C(v160, v183, v184, v185, v186, v187, v188, v189);
                  bzero(v80, v217);
                  uint64_t v146 = 0;
                  uint64_t v220 = v144 + 1;
                  ++v221;
                  uint64_t v145 = v142;
                }
              }
              ++v145;
            }
            while (v145 < v142);
          }
          ++v144;
          uint64_t v143 = v146;
        }
        while (v144 < v210);
      }
      uint64_t v40 = v216;
      if (v220 < v210)
      {
        sub_1B63DC0A0(v220, v210, (uint64_t)v80, (uint64_t)v79, v146, (uint64_t)v103, v219, v224, v216);
        CFArrayRef v196 = sub_1B63CCF34(v213, v212 - v211 * (void)v218, v190, v191, v192, v193, v194, v195);
        sub_1B63CE524(v223, v196, 0, v197, v198, v199, v200, v201);
      }
      CFIndex v102 = v212 + 1;
      uint64_t v31 = (const void *)v215;
      uint64_t v101 = v221;
    }
    while ((const __CFArray *)(v212 + 1) != v209);
  }
  free(v80);
  free(v79);
  sub_1B64A0D6C(v208, 0, v202, v203, v204, v205, v206, v207);
  return v31;
}

void sub_1B63DBF98(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v10 = (float32x4_t *)sub_1B64A0828();
  sub_1B64A107C(a1, v10, v11, v12, v13, v14, v15, v16);
  uint64_t v24 = sub_1B64A1954(a1, v17, v18, v19, v20, v21, v22, v23);
  if (v24)
  {
    CFStringRef v25 = CFStringCreateWithFormat(0, 0, @"%@-split%d", v24, a2);
    sub_1B64A2F04((uint64_t)v10, v25, v26, v27, v28, v29, v30, v31);
    CFRelease(v25);
  }
  uint64_t v32 = (void *)-[VFXModel __createCFObject]_0();
  uint64_t v33 = (const void *)-[VFXMesh __createCFObject]_0();
  sub_1B64A0D6C(v10, v32, v34, v35, v36, v37, v38, v39);
  sub_1B63CDBD0((uint64_t)v32, (uint64_t)v33, v40, v41, v42, v43, v44, v45);
  uint64_t v46 = (const void *)sub_1B63D0314();
  sub_1B64AD1E8((uint64_t)v33, v46, v47, v48, v49, v50, v51, v52);
  CFRelease(v46);
  CFRelease(v33);
  CFRelease(v32);
  CFRelease(v10);
  *a4 = v46;
  *a3 = v33;
  *a5 = v32;
}

void sub_1B63DC0A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v13 = a1;
  uint64_t v14 = a2 - a1;
  BOOL v15 = a5 > 255;
  if (a5 <= 255) {
    unsigned int v16 = 1;
  }
  else {
    unsigned int v16 = 2;
  }
  uint64_t v17 = sub_1B63D0DCC(a6, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = v17;
  uint64_t v105 = a5;
  BOOL v19 = a5 < 0x10000;
  if (a5 < 0x10000) {
    uint64_t v20 = v16;
  }
  else {
    uint64_t v20 = 4;
  }
  char v21 = 2;
  if (v19) {
    char v21 = v15;
  }
  CFIndex length = (v17 << v21) * v14;
  bytes = (UInt8 *)malloc_type_malloc(length, 0xFF99BA0DuLL);
  CFArrayRef theArray = (CFArrayRef)a2;
  uint64_t v95 = a2 - v13;
  uint64_t v28 = 0;
  if (a2 > v13)
  {
    do
    {
      if (v18 >= 1)
      {
        uint64_t v29 = 0;
        uint64_t v30 = &bytes[2 * v28];
        uint64_t v31 = &bytes[v28];
        uint64_t v106 = v28;
        uint64_t v32 = &bytes[4 * v28];
        do
        {
          uint64_t v33 = sub_1B63D14A0(a6, v13, v29, 0, v24, v25, v26, v27);
          uint64_t v34 = *(void *)(a3 + 8 * v33);
          if (!v34)
          {
            uint64_t v35 = v33;
            sub_1B63F2F54(17, @"Assertion '%s' failed. inconsistency in _finalizeSplit", v22, v23, v24, v25, v26, v27, (uint64_t)"oldIndexToNewIndex[sourceIndex]");
            uint64_t v34 = *(void *)(a3 + 8 * v35);
          }
          int v36 = v34 - 1;
          if (v20 == 2)
          {
            *(_WORD *)&v30[2 * v29] = v36;
          }
          else if (v20 == 1)
          {
            v31[v29] = v36;
          }
          else
          {
            *(_DWORD *)&v32[4 * v29] = v36;
          }
          ++v29;
        }
        while (v18 != v29);
        uint64_t v28 = v106 + v29;
      }
      ++v13;
    }
    while ((CFArrayRef)v13 != theArray);
  }
  if (v28 != v18 * v95) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. _finalizeSplit - inconsistent data length", v22, v23, v24, v25, v26, v27, (uint64_t)"w == count * indexCountPerPrimitive");
  }
  uint64_t v37 = bytes;
  bytesa = (UInt8 *)*MEMORY[0x1E4F1CF80];
  CFDataRef v38 = CFDataCreateWithBytesNoCopy(0, v37, length, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  sub_1B63D0E24(a7, v95, v38, v20);
  CFRelease(v38);
  CFArrayRef theArraya = sub_1B64ACF8C(a9, 1, v39, v40, v41, v42, v43, v44);
  CFIndex Count = CFArrayGetCount(theArraya);
  uint64_t v45 = v105;
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArraya, i);
      uint64_t v48 = sub_1B641E2F4((uint64_t)ValueAtIndex);
      uint64_t v49 = sub_1B641E2FC((uint64_t)ValueAtIndex);
      uint64_t v57 = (void *)sub_1B641E1A8((uint64_t)ValueAtIndex, v50, v51, v52, v53, v54, v55, v56);
      size_t v65 = sub_1B63CA534(v49, v58, v59, v60, v61, v62, v63, v64) * v48;
      CFIndex v66 = v65 * v45;
      uint64_t v73 = (const UInt8 *)malloc_type_malloc(v65 * v45, 0x80B3CCA4uLL);
      uint64_t v107 = v48;
      uint64_t v74 = 0;
      if (v45 >= 1)
      {
        uint64_t v75 = (uint64_t *)a4;
        do
        {
          uint64_t v76 = *v75++;
          uint64_t v77 = sub_1B6534808(v57, v76, v67, v68, v69, v70, v71, v72);
          memcpy((void *)&v73[v74], v77, v65);
          v74 += v65;
          --v45;
        }
        while (v45);
      }
      if (v74 != v66) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. _createSubSource - inconsistent data length", v67, v68, v69, v70, v71, v72, (uint64_t)"w == dataLength");
      }
      CFDataRef v78 = CFDataCreateWithBytesNoCopy(0, v73, v66, (CFAllocatorRef)bytesa);
      uint64_t v86 = sub_1B641D56C((uint64_t)ValueAtIndex, v79, v80, v81, v82, v83, v84, v85);
      uint64_t v45 = v105;
      uint64_t v90 = (const void *)sub_1B641CF98(v78, v86, v105, v107, v49, v87, v88, v89);
      CFRelease(v78);
      sub_1B64AC000(a8, v90, 0, 0, v91, v92, v93, v94);
      CFRelease(v90);
    }
  }

  CFRelease(theArraya);
}

void sub_1B63DC3E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
  }
  uint64_t v15 = a2;
  CFTypeRef cf = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], 0);
  v14[0] = 0;
  v14[1] = (uint64_t (*)(uint64_t, uint64_t))sub_1B63DC4B0;
  _OWORD v14[2] = 0;
  sub_1B63F3570(a1, v14, 1, (uint64_t)&v15, v10, v11, v12, v13);
  CFRelease(cf);
}

uint64_t sub_1B63DC4B0(float32x4_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (const void *)sub_1B649F5F4((uint64_t)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    uint64_t v11 = v10;
    CFDictionaryRef v12 = (const __CFDictionary *)a2[1];
    Value = CFDictionaryGetValue(v12, v10);
    if (Value)
    {
      uint64_t v11 = (const void *)sub_1B64A0F4C((uint64_t)Value, 1, v14, v15, v16, v17, v18, v19);
      sub_1B64A107C((uint64_t)a1, v11, v20, v21, v22, v23, v24, v25);
      sub_1B64A0D6C(a1, 0, v26, v27, v28, v29, v30, v31);
    }
    else
    {
      uint64_t v32 = *a2;
      CFRetain(v11);
      uint64_t v39 = sub_1B63DBB24((uint64_t)a1, v32, v33, v34, v35, v36, v37, v38);
      if (v39) {
        CFDictionarySetValue(v12, v11, v39);
      }
    }
    CFRelease(v11);
  }
  return 0;
}

uint64_t sub_1B63DC55C(const __CFArray *a1, const __CFArray *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", 0, a4, a5, a6, a7, a8, (uint64_t)"sourceChannels");
  }
  uint64_t v11 = -[VFXMesh __createCFObject]_0();
  CFIndex Count = CFArrayGetCount(a1);
  if (Count >= 1)
  {
    CFIndex v13 = Count;
    for (CFIndex i = 0; i != v13; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
      sub_1B64AC000(v11, ValueAtIndex, *(unsigned __int8 *)(a3 + i), 0, v16, v17, v18, v19);
    }
  }
  CFIndex v20 = CFArrayGetCount(a2);
  if (v20 >= 1)
  {
    CFIndex v21 = v20;
    for (CFIndex j = 0; j != v21; ++j)
    {
      uint64_t v23 = CFArrayGetValueAtIndex(a2, j);
      sub_1B64AD1E8(v11, v23, v24, v25, v26, v27, v28, v29);
    }
  }
  return v11;
}

uint64_t sub_1B63DC648(const __CFArray *a1)
{
  uint64_t v183 = *MEMORY[0x1E4F143B8];
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    return 0;
  }
  uint64_t v2 = Count;
  if (Count != 1)
  {
    uint64_t v177 = -[VFXMesh __createCFObject]_0();
    uint64_t v15 = (const void *)sub_1B647B3F8(0, 0, 0, 3, 1, v12, v13, v14);
    uint64_t v174 = (const void *)sub_1B647B3F8(0, 1, 0, 3, 1, v16, v17, v18);
    uint64_t v22 = (const void *)sub_1B647B3F8(0, 3, 0, 2, 1, v19, v20, v21);
    if (v2 >= 1)
    {
      CFIndex v23 = 0;
      uint64_t v24 = 0;
      uint64_t v172 = v2;
      uint64_t v173 = v15;
      CFAllocatorRef v171 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (1)
      {
        CFIndex v176 = v23;
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v23);
        uint64_t v30 = sub_1B64AC5F8((uint64_t)ValueAtIndex, 0, 0, 1, v26, v27, v28, v29);
        uint64_t v35 = sub_1B64AC5F8((uint64_t)ValueAtIndex, 1, 0, 1, v31, v32, v33, v34);
        uint64_t v179 = (uint64_t)ValueAtIndex;
        uint64_t v40 = sub_1B64AC5F8((uint64_t)ValueAtIndex, 3, 0, 1, v36, v37, v38, v39);
        uint64_t v55 = sub_1B641D8A0((uint64_t)v30, v41, v42, v43, v44, v45, v46, v47);
        if (v55 >= 1)
        {
          for (uint64_t i = 0; i != v55; ++i)
          {
            *(_DWORD *)&bytes[8] = 0;
            *(void *)bytes = 0;
            *(double *)&long long v57 = sub_1B641E208((uint64_t)v30, i, v49, v50, v51, v52, v53, v54);
            *(_OWORD *)bytes = v57;
            sub_1B647B844((uint64_t)v15, (uint64_t)bytes, 1, v58, v59, v60, v61, v62);
            DWORD2(v181) = 0;
            *(void *)&long long v181 = 0;
            *(double *)&long long v69 = sub_1B641E208((uint64_t)v35, i, v63, v64, v65, v66, v67, v68);
            long long v181 = v69;
            sub_1B647B844((uint64_t)v174, (uint64_t)&v181, 1, v70, v71, v72, v73, v74);
            double v180 = 0.0;
            double v180 = sub_1B641E284((uint64_t)v40, i, v75, v76, v77, v78, v79, v80);
            sub_1B647B9C8((uint64_t)v22, (uint64_t)&v180, 1, v81, v82, v83, v84, v85);
          }
        }
        uint64_t v86 = v179;
        uint64_t v178 = v55 + v24;
        if ((uint64_t)sub_1B64ABD08(v179, v48, v49, v50, v51, v52, v53, v54) >= 1) {
          break;
        }
LABEL_42:
        CFIndex v23 = v176 + 1;
        uint64_t v24 = v178;
        uint64_t v15 = v173;
        if (v176 + 1 == v172) {
          goto LABEL_43;
        }
      }
      CFIndex v92 = 0;
      while (1)
      {
        uint64_t v93 = sub_1B64ABD78(v86, v92, 1, v87, v88, v89, v90, v91);
        int v101 = sub_1B63D0C08((uint64_t)v93, v94, v95, v96, v97, v98, v99, v100);
        CFMutableDataRef Mutable = CFDataCreateMutable(v171, 0);
        uint64_t v103 = sub_1B63D11E8((uint64_t)v93);
        uint64_t v110 = v103;
        if (v178 >= 0x10000) {
          break;
        }
        if (v103 >= 1)
        {
          for (uint64_t j = 0; v110 != j; ++j)
          {
            if (v101 == 3)
            {
              *(_WORD *)bytes = 0;
              *(_WORD *)bytes = sub_1B63D14A0((uint64_t)v93, j, 0, 0, v106, v107, v108, v109) + v24;
              uint64_t v120 = Mutable;
              CFIndex v121 = 2;
            }
            else if (v101 == 2)
            {
              *(_WORD *)bytes = sub_1B63D14A0((uint64_t)v93, j, 0, 0, v106, v107, v108, v109) + v24;
              *(_WORD *)&bytes[2] = sub_1B63D14A0((uint64_t)v93, j, 1, 0, v122, v123, v124, v125) + v24;
              uint64_t v120 = Mutable;
              CFIndex v121 = 4;
            }
            else
            {
              if ((_BYTE)v101)
              {
                sub_1B63F2F54(17, @"Assertion '%s' failed. Unsupported element type in CFXMeshCreateByMergingMeshes", v104, v105, v106, v107, v108, v109, (uint64_t)"0");
                continue;
              }
              *(_WORD *)bytes = sub_1B63D14A0((uint64_t)v93, j, 0, 0, v106, v107, v108, v109) + v24;
              *(_WORD *)&bytes[2] = sub_1B63D14A0((uint64_t)v93, j, 1, 0, v112, v113, v114, v115) + v24;
              *(_WORD *)&bytes[4] = sub_1B63D14A0((uint64_t)v93, j, 2, 0, v116, v117, v118, v119) + v24;
              uint64_t v120 = Mutable;
              CFIndex v121 = 6;
            }
            CFDataAppendBytes(v120, bytes, v121);
          }
        }
        uint64_t v126 = 2;
LABEL_39:
        uint64_t v142 = (const void *)sub_1B63D0314();
        sub_1B63D05D4((uint64_t)v142, v101, v110, Mutable, v126, v143, v144, v145);
        sub_1B64AD1E8(v177, v142, v146, v147, v148, v149, v150, v151);
        if (v142) {
          CFRelease(v142);
        }
        CFRelease(Mutable);
        ++v92;
        uint64_t v86 = v179;
        if (v92 >= (uint64_t)sub_1B64ABD08(v179, v152, v153, v154, v155, v156, v157, v158)) {
          goto LABEL_42;
        }
      }
      if (v103 < 1)
      {
LABEL_38:
        uint64_t v126 = 4;
        goto LABEL_39;
      }
      uint64_t v127 = 0;
      while (1)
      {
        if (v101 == 3)
        {
          *(_DWORD *)bytes = 0;
          *(_DWORD *)bytes = sub_1B63D14A0((uint64_t)v93, v127, 0, 0, v106, v107, v108, v109) + v24;
          uint64_t v136 = Mutable;
          CFIndex v137 = 4;
        }
        else if (v101 == 2)
        {
          *(_DWORD *)bytes = sub_1B63D14A0((uint64_t)v93, v127, 0, 0, v106, v107, v108, v109) + v24;
          *(_DWORD *)&bytes[4] = sub_1B63D14A0((uint64_t)v93, v127, 1, 0, v138, v139, v140, v141) + v24;
          uint64_t v136 = Mutable;
          CFIndex v137 = 8;
        }
        else
        {
          if ((_BYTE)v101)
          {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Unsupported element type in CFXMeshCreateByMergingMeshes", v104, v105, v106, v107, v108, v109, (uint64_t)"0");
            goto LABEL_37;
          }
          *(_DWORD *)bytes = sub_1B63D14A0((uint64_t)v93, v127, 0, 0, v106, v107, v108, v109) + v24;
          *(_DWORD *)&bytes[4] = sub_1B63D14A0((uint64_t)v93, v127, 1, 0, v128, v129, v130, v131) + v24;
          *(_DWORD *)&bytes[8] = sub_1B63D14A0((uint64_t)v93, v127, 2, 0, v132, v133, v134, v135) + v24;
          uint64_t v136 = Mutable;
          CFIndex v137 = 12;
        }
        CFDataAppendBytes(v136, bytes, v137);
LABEL_37:
        if (v110 == ++v127) {
          goto LABEL_38;
        }
      }
    }
LABEL_43:
    sub_1B641CF94((uint64_t)v15);
    sub_1B641CF94((uint64_t)v174);
    sub_1B641CF94((uint64_t)v22);
    sub_1B64AC000(v177, v15, 0, 0, v159, v160, v161, v162);
    sub_1B64AC000(v177, v174, 0, 0, v163, v164, v165, v166);
    sub_1B64AC000(v177, v22, 0, 0, v167, v168, v169, v170);
    CFRelease(v15);
    CFRelease(v174);
    CFRelease(v22);
    return v177;
  }
  CFIndex v3 = CFArrayGetValueAtIndex(a1, 0);

  return sub_1B64AB2A8((uint64_t)v3, v4, v5, v6, v7, v8, v9, v10);
}

const void *sub_1B63DCC64(uint64_t a1, CFIndex a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v267 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = sub_1B63D11E8((uint64_t)a3);
  if (sub_1B63D0C08((uint64_t)a3, v15, v16, v17, v18, v19, v20, v21) == 2) {
    return 0;
  }
  int v256 = a7;
  uint64_t v253 = (uint64_t)a3;
  uint64_t v251 = (const void *)sub_1B647EC38(a3, 4 * v14, v22, v23, v24, v25, v26, v27);
  uint64_t v254 = sub_1B641D8A0(a4, v29, v30, v31, v32, v33, v34, v35);
  uint64_t v36 = sub_1B647E38C(a1, a2);
  uint64_t v44 = sub_1B647E620((uint64_t)v36, v37, v38, v39, v40, v41, v42, v43);
  uint64_t v51 = (float32x4_t *)malloc_type_malloc(16 * v44, 0x1000040451B5BE8uLL);
  uint64_t v252 = v14;
  v250 = v36;
  if (a6)
  {
    uint64_t v52 = (float32x2_t *)malloc_type_malloc(8 * v44, 0x100004000313F17uLL);
    BOOL v53 = a5 != 0;
LABEL_7:
    if (v44 >= 1)
    {
      for (uint64_t i = 0; i != v44; ++i)
      {
        uint64_t v55 = (uint64_t *)sub_1B647E66C((uint64_t)v36, i, v45, v46, v47, v48, v49, v50);
        uint64_t v56 = v55;
        if (v53)
        {
          *(double *)&long long v57 = sub_1B641E208(a5, *v55, v45, v46, v47, v48, v49, v50);
          *(_OWORD *)cfb = v57;
          *(double *)v64.i64 = sub_1B641E208(a5, v56[1], v58, v59, v60, v61, v62, v63);
          v65.i64[0] = 0x3F0000003F000000;
          v65.i64[1] = 0x3F0000003F000000;
          float32x4_t v66 = vmulq_f32(vaddq_f32(*(float32x4_t *)cfb, v64), v65);
          int32x4_t v67 = (int32x4_t)vmulq_f32(v66, v66);
          v67.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v67, 2), vadd_f32(*(float32x2_t *)v67.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v67.i8, 1))).u32[0];
          float32x2_t v68 = vrsqrte_f32((float32x2_t)v67.u32[0]);
          float32x2_t v69 = vmul_f32(v68, vrsqrts_f32((float32x2_t)v67.u32[0], vmul_f32(v68, v68)));
          v51[i] = vmulq_n_f32(v66, vmul_f32(v69, vrsqrts_f32((float32x2_t)v67.u32[0], vmul_f32(v69, v69))).f32[0]);
        }
        if (a6)
        {
          double v70 = sub_1B641E284(a6, *v56, v45, v46, v47, v48, v49, v50);
          v52[i] = vmul_f32(vadd_f32(*(float32x2_t *)&v70, COERCE_FLOAT32X2_T(sub_1B641E284(a6, v56[1], v71, v72, v73, v74, v75, v76))), (float32x2_t)0x3F0000003F000000);
        }
      }
    }
    if (v53) {
      sub_1B647B844(a5, (uint64_t)v51, v44, v46, v47, v48, v49, v50);
    }
    if (a6) {
      sub_1B647B9C8(a6, (uint64_t)v52, v44, v46, v47, v48, v49, v50);
    }
    if (v52) {
      free(v52);
    }
    goto LABEL_20;
  }
  BOOL v53 = a5 != 0;
  if (a5)
  {
    uint64_t v52 = 0;
    goto LABEL_7;
  }
LABEL_20:
  uint64_t v77 = v51;
  if (v44 >= 1)
  {
    for (uint64_t j = 0; j != v44; ++j)
    {
      uint64_t v79 = (uint64_t *)sub_1B647E66C((uint64_t)v250, j, v45, v46, v47, v48, v49, v50);
      *(double *)&long long v86 = sub_1B641E208(a4, *v79, v80, v81, v82, v83, v84, v85);
      *(_OWORD *)cfc = v86;
      *(double *)v93.i64 = sub_1B641E208(a4, v79[1], v87, v88, v89, v90, v91, v92);
      v94.i64[0] = 0x3F0000003F000000;
      v94.i64[1] = 0x3F0000003F000000;
      v51[j] = vmulq_f32(vaddq_f32(*(float32x4_t *)cfc, v93), v94);
    }
    if ((v53 & v256) == 1)
    {
      uint64_t v95 = 0;
      uint64_t v249 = a4;
      do
      {
        uint64_t v96 = (uint64_t *)sub_1B647E66C((uint64_t)v250, v95, v45, v46, v47, v48, v49, v50);
        uint64_t v97 = *v96;
        uint64_t v98 = v96[1];
        *(double *)v105.i64 = sub_1B641E208(a4, *v96, v99, v100, v101, v102, v103, v104);
        float32x4_t v257 = v105;
        v266[0] = v105;
        *(double *)&long long v112 = sub_1B641E208(a4, v98, v106, v107, v108, v109, v110, v111);
        *(_OWORD *)cfd = v112;
        v266[1] = v112;
        *(double *)&long long v119 = sub_1B641E208(a5, v97, v113, v114, v115, v116, v117, v118);
        v265[0] = v119;
        *(double *)&long long v126 = sub_1B641E208(a5, v98, v120, v121, v122, v123, v124, v125);
        v265[1] = v126;
        float32x4_t v255 = v77[v95];
        *(double *)v133.i64 = sub_1B641E208(a5, v95 + v254, v127, v128, v129, v130, v131, v132);
        uint64_t v134 = 0;
        float32x4_t v135 = vsubq_f32(v257, v255);
        float32x4_t v136 = vmulq_f32(v135, v135);
        float32x4_t v137 = vsubq_f32(*(float32x4_t *)cfd, v255);
        float32x4_t v138 = vmulq_f32(v137, v137);
        v264[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v136, 2), vaddq_f32(v136, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v136.f32, 1))).f32[0]);
        v264[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v138, 2), vaddq_f32(v138, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v138.f32, 1))).f32[0]);
        *(float32x4_t *)CFTypeRef cf = v133;
        float32x4_t v139 = vmulq_f32(v133, v133);
        float v140 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v139, 2), vaddq_f32(v139, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v139.f32, 1))).f32[0]);
        float32x4_t v141 = 0uLL;
        char v142 = 1;
        do
        {
          float32x4_t v258 = v141;
          char v143 = v142;
          float32x4_t v144 = vsubq_f32((float32x4_t)v266[v134], v255);
          int32x4_t v145 = (int32x4_t)vmulq_f32(v144, v144);
          v145.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v145, 2), vadd_f32(*(float32x2_t *)v145.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v145.i8, 1))).u32[0];
          float32x2_t v146 = vrsqrte_f32((float32x2_t)v145.u32[0]);
          float32x2_t v147 = vmul_f32(v146, vrsqrts_f32((float32x2_t)v145.u32[0], vmul_f32(v146, v146)));
          float32x4_t v148 = vmulq_n_f32(v144, vmul_f32(v147, vrsqrts_f32((float32x2_t)v145.u32[0], vmul_f32(v147, v147))).f32[0]);
          float32x4_t v149 = vmulq_f32(v148, v148);
          float v150 = v140
               * sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v149, 2), vaddq_f32(v149, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v149.f32, 1))).f32[0]);
          float v151 = 0.0;
          float v152 = 0.0;
          if (v150 > 0.0)
          {
            float32x4_t v153 = vmulq_f32(v148, *(float32x4_t *)cf);
            float v152 = acosf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v153, 2), vaddq_f32(v153, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v153.f32, 1))).f32[0]/ v150);
          }
          float32x4_t v154 = (float32x4_t)v265[v134];
          float32x4_t v155 = vmulq_f32(v154, v154);
          float v156 = v140
               * sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v155, 2), vaddq_f32(v155, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v155.f32, 1))).f32[0]);
          if (v156 > 0.0)
          {
            float32x4_t v157 = vmulq_f32(*(float32x4_t *)cf, v154);
            float v151 = acosf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v157, 2), vaddq_f32(v157, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v157.f32, 1))).f32[0]/ v156);
          }
          float v158 = v151 * 0.5;
          float v165 = cosf(v158);
          if (v165 == 0.0)
          {
            sub_1B63F2F54(16, @"Error: CFXMeshSubdivide inconsistency", v159, v160, v161, v162, v163, v164, v248);
            float v166 = 1.0;
          }
          else
          {
            float v166 = v165;
          }
          float v167 = *(float *)&v264[v134];
          float v168 = cosf(v152 - v158);
          char v142 = 0;
          float32x4_t v141 = vaddq_f32(v258, vmulq_n_f32(*(float32x4_t *)cf, (float)((float)(v168 * v167) / v166) * 0.5));
          uint64_t v134 = 1;
        }
        while ((v143 & 1) != 0);
        uint64_t v77 = v51;
        v51[v95++] = vaddq_f32(v255, v141);
        a4 = v249;
      }
      while (v95 != v44);
    }
  }
  sub_1B647B844(a4, (uint64_t)v77, v44, v46, v47, v48, v49, v50);
  free(v77);
  cfa = sub_1B647E718(v253, a4, (uint64_t)v250, v169, v170, v171, v172, v173);
  if (v252 >= 1)
  {
    for (uint64_t k = 0; k != v252; ++k)
    {
      uint64_t v182 = (uint64_t *)sub_1B647E9C8((uint64_t)cfa, k, v175, v176, v177, v178, v179, v180);
      uint64_t v184 = *v182;
      uint64_t v183 = v182[1];
      uint64_t v185 = v182[2];
      uint64_t v192 = (uint64_t *)sub_1B647E66C((uint64_t)v250, *v182, v186, v187, v188, v189, v190, v191);
      uint64_t v199 = (void *)sub_1B647E66C((uint64_t)v250, v183, v193, v194, v195, v196, v197, v198);
      uint64_t v206 = (uint64_t *)sub_1B647E66C((uint64_t)v250, v185, v200, v201, v202, v203, v204, v205);
      uint64_t v211 = sub_1B63D14A0(v253, k, 0, 0, v207, v208, v209, v210);
      uint64_t v216 = sub_1B63D14A0(v253, k, 2, 0, v212, v213, v214, v215);
      uint64_t v223 = *v192;
      if (*v192 == v211)
      {
        uint64_t v224 = v192[1];
        uint64_t v225 = v254;
        uint64_t v226 = v184 + v254;
        BOOL v227 = v224 == v216;
        if (v224 == v216) {
          uint64_t v228 = v184 + v254;
        }
        else {
          uint64_t v228 = -1;
        }
        if (v227) {
          uint64_t v226 = -1;
        }
        uint64_t v229 = -1;
      }
      else
      {
        uint64_t v230 = v192[1];
        uint64_t v225 = v254;
        BOOL v231 = v230 == v211;
        if (v230 == v211) {
          uint64_t v226 = v184 + v254;
        }
        else {
          uint64_t v226 = -1;
        }
        if (v231) {
          uint64_t v229 = -1;
        }
        else {
          uint64_t v229 = v184 + v254;
        }
        BOOL v232 = v223 == v216;
        if (v223 == v216) {
          uint64_t v228 = v226;
        }
        else {
          uint64_t v228 = -1;
        }
        if (v232) {
          uint64_t v226 = -1;
        }
      }
      if (*v199 == v211)
      {
        if (v199[1] == v216) {
          uint64_t v228 = v183 + v225;
        }
        else {
          uint64_t v226 = v183 + v225;
        }
      }
      else
      {
        uint64_t v233 = v199[1];
        uint64_t v234 = v183 + v225;
        BOOL v235 = v233 == v211;
        if (v233 == v211)
        {
          uint64_t v236 = v183 + v225;
        }
        else
        {
          uint64_t v229 = v183 + v225;
          uint64_t v236 = v226;
        }
        if (!v235) {
          uint64_t v234 = v228;
        }
        if (*v199 == v216) {
          uint64_t v228 = v234;
        }
        else {
          uint64_t v226 = v236;
        }
      }
      uint64_t v237 = *v206;
      if (*v206 == v211)
      {
        uint64_t v238 = v206[1];
        if (v238 == v216) {
          uint64_t v239 = v185 + v225;
        }
        else {
          uint64_t v239 = v228;
        }
        if (v238 == v216) {
          uint64_t v240 = v226;
        }
        else {
          uint64_t v240 = v185 + v225;
        }
      }
      else
      {
        uint64_t v241 = v206[1];
        uint64_t v242 = v185 + v225;
        BOOL v243 = v241 == v211;
        if (v241 == v211)
        {
          uint64_t v244 = v185 + v225;
        }
        else
        {
          uint64_t v229 = v185 + v225;
          uint64_t v244 = v226;
        }
        if (!v243) {
          uint64_t v242 = v228;
        }
        if (v237 == v216) {
          uint64_t v239 = v242;
        }
        else {
          uint64_t v239 = v228;
        }
        if (v237 == v216) {
          uint64_t v240 = v226;
        }
        else {
          uint64_t v240 = v244;
        }
      }
      if (v239 == -1 || v240 == -1 || v229 == -1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. inconsistency (2) in CFXMeshSubdivide", v217, v218, v219, v220, v221, v222, (uint64_t)"D!=-1 && E!=-1 && F !=-1");
      }
      sub_1B647EE6C((uint64_t)v251, k, v239, v240, v229, v220, v221, v222, v248);
    }
  }
  uint64_t v28 = (const void *)sub_1B647F078((uint64_t)v251, v174, v175, v176, v177, v178, v179, v180);
  CFRetain(v28);
  CFRelease(v251);
  CFRelease(v250);
  CFRelease(cfa);
  return v28;
}

uint64_t sub_1B63DD3C4(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(v78, 0, sizeof(v78));
  uint64_t v10 = sub_1B64AB2A8(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v17 = sub_1B64ACF7C(v10, 0, v11, v12, v13, v14, v15, v16);
  uint64_t v18 = (const void *)sub_1B641E128((uint64_t)v17);
  uint64_t v26 = (__CFData *)sub_1B6536C44((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25);
  uint64_t v34 = sub_1B641D8A0((uint64_t)v18, v27, v28, v29, v30, v31, v32, v33);
  sub_1B63DD4E4(v26, 0, v34, (uint64_t)a2, 0, v35, v36, v37);
  unsigned __int8 v43 = sub_1B64ACE9C(a1, 0, 0, v38, v39, v40, v41, v42);
  sub_1B64AC4C8(v10, v18, 0, v43, v44, v45, v46, v47);
  uint64_t v54 = sub_1B64AD1C4(v10, 0, v48, v49, v50, v51, v52, v53);
  if (v54)
  {
    uint64_t v55 = (uint64_t)v54;
    uint64_t v56 = (const void *)sub_1B641E128((uint64_t)v54);
    sub_1B63DAC00(a2, v78, v57, v58, v59, v60, v61, v62);
    sub_1B63DD618((uint64_t)v56, v55, (uint64_t)v78, 0, v63, v64, v65, v66, *(uint64_t *)&v78[0]);
    unsigned __int8 v72 = sub_1B64ACE9C(a1, 1, 0, v67, v68, v69, v70, v71);
    sub_1B64AC4C8(v10, v56, 0, v72, v73, v74, v75, v76);
    CFRelease(v56);
  }
  CFRelease(v18);
  return v10;
}

__CFData *sub_1B63DD4E4(__CFData *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 1)
  {
    int v8 = a5;
    uint64_t v10 = a3;
    uint64_t v12 = result;
    do
    {
      CFComparisonResult result = sub_1B6534884(v12, a2, a3, a4, a5, a6, a7, a8);
      v13.i32[0] = *(_DWORD *)result;
      float32x4_t v14 = v13;
      v14.i32[1] = *((_DWORD *)result + 1);
      float32x4_t v15 = v14;
      v15.i32[2] = *((_DWORD *)result + 2);
      float32x4_t v16 = *(float32x4_t *)a4;
      float32x4_t v17 = *(float32x4_t *)(a4 + 16);
      float32x4_t v18 = *(float32x4_t *)(a4 + 32);
      if (v8)
      {
        float32x4_t v19 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32(v18, v15, 2), v17, *(float32x2_t *)v14.f32, 1), v16, v13.f32[0]);
        float32x4_t v20 = vmulq_f32(v15, v15);
        float32x4_t v21 = vmulq_f32(v19, v19);
        v21.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).u64[0];
        float32x4_t v22 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 0);
        v22.i32[3] = 0;
        float32x4_t v23 = vrsqrteq_f32(v22);
        float32x4_t v24 = vmulq_f32(v23, vrsqrtsq_f32(v22, vmulq_f32(v23, v23)));
        int32x4_t v25 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v21.f32[0] != 0.0)), 0x1FuLL));
        v25.i32[3] = 0;
        float32x4_t v26 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v25), (int8x16_t)vmulq_f32(v19, vmulq_n_f32(vmulq_f32(v24, vrsqrtsq_f32(v22, vmulq_f32(v24, v24))), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0]))), (int8x16_t)v19);
      }
      else
      {
        float32x4_t v26 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(*(float32x4_t *)(a4 + 48), v18, v15, 2), v17, *(float32x2_t *)v14.f32, 1), v16, v13.f32[0]);
      }
      *(void *)CFComparisonResult result = v26.i64[0];
      *((_DWORD *)result + 2) = v26.i32[2];
      ++a2;
      --v10;
    }
    while (v10);
  }
  return result;
}

void sub_1B63DD618(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  float32x4_t v13 = (__CFData *)sub_1B6536C44(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v21 = sub_1B6536C44(a2, v14, v15, v16, v17, v18, v19, v20);
  uint64_t v22 = sub_1B6534800(v21);
  if (sub_1B6534A3C(v21, (uint64_t)v13, a4, v23, v24, v25, v26, v27))
  {
    uint64_t v34 = sub_1B6534884(v13, 0, v28, v29, v30, v31, v32, v33);
    uint64_t v35 = sub_1B6534800((uint64_t)v13);
    uint64_t v36 = sub_1B653465C(v21);
    sub_1B647B4C8(a1, (uint64_t)v34, v35, v36);
    if (a3)
    {
      BOOL v44 = sub_1B641D56C(a1, v37, v38, v39, v40, v41, v42, v43) == 1;
      sub_1B63DD4E4(v13, a4, v22, a3, v44, v45, v46, v47);
    }
  }
  else
  {
    sub_1B63F2F54(16, @"Error: CFXSourceAccessorCopyDataToAccessor failed", v28, v29, v30, v31, v32, v33, a9);
  }
}

uint64_t sub_1B63DD744(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  uint64_t v10 = sub_1B64ACF7C(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v17 = sub_1B64AD1C4(a1, a2, v11, v12, v13, v14, v15, v16);
  uint64_t v29 = sub_1B64AC5F8(a1, 3, 0, a2, v18, v19, v20, v21);
  if (v10)
  {
    if (v17) {
      goto LABEL_5;
    }
LABEL_45:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v23, v24, v25, v26, v27, v28, (uint64_t)"normalSource");
    if (v29) {
      goto LABEL_6;
    }
LABEL_46:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v23, v24, v25, v26, v27, v28, (uint64_t)"uvSource");
    goto LABEL_6;
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v23, v24, v25, v26, v27, v28, (uint64_t)"positionSource");
  if (!v17) {
    goto LABEL_45;
  }
LABEL_5:
  if (!v29) {
    goto LABEL_46;
  }
LABEL_6:
  uint64_t v30 = sub_1B641D478((uint64_t)v10, v22, v23, v24, v25, v26, v27, v28);
  if (!v30 || (uint64_t v38 = v31, !v31))
  {
    uint64_t v110 = @"Error: Cannot generate tangents without valid positions";
    goto LABEL_49;
  }
  uint64_t v39 = v30;
  *(void *)float v140 = a1;
  uint64_t v40 = sub_1B641D478((uint64_t)v29, v31, v32, v33, v34, v35, v36, v37);
  if (!v40 || (unsigned __int8 v42 = BYTE5(v41), v41 != v38))
  {
    uint64_t v110 = @"Error: Cannot generate valid tangents without valid texture coordinates";
    goto LABEL_49;
  }
  uint64_t v43 = v40;
  uint64_t v44 = sub_1B641D478((uint64_t)v17, v41, v32, v33, v34, v35, v36, v37);
  if (!v44 || (unsigned __int8 v47 = v46, v45 != v38))
  {
    uint64_t v110 = @"Error: Cannot generate valid tangents without valid normals";
    goto LABEL_49;
  }
  uint64_t v48 = v44;
  uint64_t v49 = (float32x4_t *)malloc_type_calloc(16 * v38, 1uLL, 0x8843F625uLL);
  uint64_t v50 = (float32x4_t *)malloc_type_calloc(16 * v38, 1uLL, 0x9A07271AuLL);
  CFArrayRef v141 = sub_1B64ABD08(a1, v51, v52, v53, v54, v55, v56, v57);
  uint64_t length = 16 * v38;
  uint64_t v133 = v38;
  unsigned int v135 = v38;
  uint64_t v136 = v48;
  unsigned __int8 v134 = v47;
  if ((uint64_t)v141 >= 1)
  {
    CFIndex v64 = 0;
    LOBYTE(v3_Block_object_dispose(&STACK[0x2B0], 8) = 0;
    uint64_t v65 = BYTE5(v38);
    uint64_t v66 = v42;
    uint64_t v67 = *(void *)v140;
    while (1)
    {
      uint64_t v68 = sub_1B64ABD78(v67, v64, 1, v58, v59, v60, v61, v62);
      if (sub_1B63D0C08((uint64_t)v68, v69, v70, v71, v72, v73, v74, v75)
        && sub_1B63D0C08((uint64_t)v68, v76, v77, v78, v79, v80, v81, v82) != 1)
      {
        goto LABEL_41;
      }
      unsigned int v142 = 0;
      CFDataRef v83 = (const __CFData *)sub_1B63D0F38((uint64_t)v68, &v142);
      if (v83)
      {
        CFDataRef v84 = v83;
        BytePtr = CFDataGetBytePtr(v83);
        if (BytePtr) {
          break;
        }
      }
LABEL_40:
      uint64_t v67 = *(void *)v140;
LABEL_41:
      if ((const __CFArray *)++v64 == v141) {
        goto LABEL_53;
      }
    }
    switch(v142)
    {
      case 1u:
        uint64_t v87 = 0;
        float32x4_t v137 = BytePtr;
        break;
      case 4u:
        float32x4_t v137 = 0;
        float32x4_t v138 = BytePtr;
        uint64_t v87 = 0;
LABEL_26:
        uint64_t v88 = sub_1B63D11E8((uint64_t)v68);
        CFIndex v139 = 3 * v88 * v142;
        if (v139 > CFDataGetLength(v84))
        {
          free(v49);
          free(v50);
          uint64_t v110 = @"Error: invalid geometry detected - skip CFXCreateTangentsWithGeometryOptimized";
LABEL_49:
          sub_1B63F2F54(16, (uint64_t)v110, v32, v33, v34, v35, v36, v37, v131);
          return 0;
        }
        if (v88 < 1)
        {
          LOBYTE(v3_Block_object_dispose(&STACK[0x2B0], 8) = 0;
        }
        else
        {
          uint64_t v92 = 0;
          uint64_t v93 = 0;
          uint64_t v94 = 0;
          uint64_t v95 = (unsigned __int16 *)(v87 + 4);
          uint64_t v96 = (unsigned __int8 *)(v137 + 2);
          __int32 v97 = 0;
          uint64_t v98 = (unsigned int *)(v138 + 4);
          do
          {
            if (v87)
            {
              uint64_t v94 = *(v95 - 2);
              uint64_t v93 = *(v95 - 1);
              uint64_t v92 = *v95;
            }
            else if (v138)
            {
              uint64_t v94 = *(v98 - 1);
              uint64_t v93 = *v98;
              uint64_t v92 = v98[1];
            }
            else if (v137)
            {
              uint64_t v94 = *(v96 - 2);
              uint64_t v93 = *(v96 - 1);
              uint64_t v92 = *v96;
            }
            float32x2_t v99 = *(float32x2_t *)(v43 + v94 * v66);
            float32x2_t v100 = vsub_f32(*(float32x2_t *)(v43 + v93 * v66), v99);
            int32x2_t v101 = (int32x2_t)vsub_f32(*(float32x2_t *)(v43 + v92 * v66), v99);
            float v102 = vmlas_n_f32((float)-v100.f32[1] * *(float *)v101.i32, *(float *)&v101.i32[1], v100.f32[0]);
            if (v102 == 0.0)
            {
              int32x2_t v101 = (int32x2_t)vadd_f32((float32x2_t)v101, (float32x2_t)0xB400000034000000);
              float32x2_t v100 = vadd_f32(v100, (float32x2_t)0xB4000000B4000000);
              float v102 = vmlas_n_f32((float)-v100.f32[1] * *(float *)v101.i32, *(float *)&v101.i32[1], v100.f32[0]);
            }
            uint64_t v103 = v39 + v94 * v65;
            v89.i64[0] = *(void *)v103;
            v89.i32[2] = *(_DWORD *)(v103 + 8);
            uint64_t v104 = v39 + v93 * v65;
            v90.i64[0] = *(void *)v104;
            v90.i32[2] = *(_DWORD *)(v104 + 8);
            uint64_t v105 = v39 + v92 * v65;
            v91.i64[0] = *(void *)v105;
            v91.i32[2] = *(_DWORD *)(v105 + 8);
            float32x4_t v90 = vsubq_f32(v90, v89);
            float32x4_t v89 = vsubq_f32(v91, v89);
            float v106 = v102;
            float32x2_t v107 = vrecpe_f32((float32x2_t)LODWORD(v102));
            float32x2_t v108 = vmul_f32(v107, vrecps_f32((float32x2_t)LODWORD(v106), v107));
            v108.i32[0] = vmul_f32(v108, vrecps_f32((float32x2_t)LODWORD(v106), v108)).u32[0];
            float32x4_t v91 = vmulq_n_f32(vmlaq_lane_f32(vmulq_lane_f32(vnegq_f32(v89), v100, 1), v90, (float32x2_t)v101, 1), v108.f32[0]);
            v91.i32[3] = v97;
            v49[v94] = vaddq_f32(v49[v94], v91);
            v49[v93] = vaddq_f32(v49[v93], v91);
            v49[v92] = vaddq_f32(v49[v92], v91);
            float32x4_t v109 = vmulq_n_f32(vmlaq_n_f32(vmulq_f32(v90, vnegq_f32((float32x4_t)vdupq_lane_s32(v101, 0))), v89, v100.f32[0]), v108.f32[0]);
            v109.i32[3] = 0;
            v50[v94] = vaddq_f32(v109, v50[v94]);
            v50[v93] = vaddq_f32(v109, v50[v93]);
            v50[v92] = vaddq_f32(v109, v50[v92]);
            v95 += 3;
            v96 += 3;
            v98 += 3;
            __int32 v97 = v91.i32[3];
            --v88;
          }
          while (v88);
          LOBYTE(v3_Block_object_dispose(&STACK[0x2B0], 8) = 1;
        }
        goto LABEL_40;
      case 2u:
        float32x4_t v137 = 0;
        uint64_t v87 = BytePtr;
        break;
      default:
        sub_1B63F2F54(16, @"Unreachable code: Unsupported index size (%zu)", v86, v58, v59, v60, v61, v62, v142);
        float32x4_t v137 = 0;
        uint64_t v87 = 0;
        break;
    }
    float32x4_t v138 = 0;
    goto LABEL_26;
  }
  LOBYTE(v3_Block_object_dispose(&STACK[0x2B0], 8) = 0;
LABEL_53:
  unint64_t v113 = 0;
  unsigned int v114 = 0;
  if (v135 <= 1) {
    unsigned int v115 = 1;
  }
  else {
    unsigned int v115 = v135;
  }
  uint64_t v116 = 16 * v115;
  do
  {
    uint64_t v117 = v136 + v114;
    v63.i64[0] = *(void *)v117;
    float32x4_t v118 = v63;
    v118.i32[2] = *(_DWORD *)(v117 + 8);
    v63.i32[2] = v118.i32[2];
    float32x4_t v119 = v49[v113 / 0x10];
    float32x4_t v120 = vmulq_f32(v119, v63);
    float32x4_t v121 = vmlsq_lane_f32(v119, v118, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v120, 2), vaddq_f32(v120, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v120.f32, 1))), 0);
    int32x4_t v122 = (int32x4_t)vmulq_f32(v121, v121);
    v122.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v122, 2), vadd_f32(*(float32x2_t *)v122.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v122.i8, 1))).u32[0];
    float32x2_t v123 = vrsqrte_f32((float32x2_t)v122.u32[0]);
    float32x4_t v63 = vmulq_n_f32(v121, vmul_f32(v123, vrsqrts_f32((float32x2_t)v122.u32[0], vmul_f32(v123, v123))).f32[0]);
    int8x16_t v124 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v63, (int32x4_t)v63), (int8x16_t)v63, 0xCuLL), vnegq_f32(v118)), v63, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v118, (int32x4_t)v118), (int8x16_t)v118, 0xCuLL));
    float32x4_t v125 = vmulq_f32(v50[v113 / 0x10], (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v124, (int32x4_t)v124), v124, 0xCuLL));
    if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v125, 2), vaddq_f32(v125, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v125.f32, 1))).f32[0] < 0.0)float v126 = -1.0; {
    else
    }
      float v126 = 1.0;
    v63.f32[3] = v126;
    v49[v113 / 0x10] = v63;
    v114 += v134;
    v113 += 16;
  }
  while (v116 != v113);
  free(v50);
  if ((v38 & 1) == 0)
  {
    free(v49);
    return 0;
  }
  CFDataRef v127 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v49, length, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  uint64_t v111 = sub_1B641CF98(v127, 4, v133, 4, 1, v128, v129, v130);
  CFRelease(v127);
  return v111;
}

uint64_t sub_1B63DDD4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1;
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  uint64_t v10 = sub_1B64ACF7C(v9, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v17 = sub_1B64AD1C4(v9, a2, v11, v12, v13, v14, v15, v16);
  uint64_t v29 = sub_1B64AC5F8(v9, 3, 0, a2, v18, v19, v20, v21);
  if (v10)
  {
    if (v17) {
      goto LABEL_5;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v23, v24, v25, v26, v27, v28, (uint64_t)"positionSource");
    if (v17) {
      goto LABEL_5;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v23, v24, v25, v26, v27, v28, (uint64_t)"normalSource");
LABEL_5:
  uint64_t v203 = (uint64_t)v17;
  if (!v29) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v23, v24, v25, v26, v27, v28, (uint64_t)"uvSource");
  }
  uint64_t v30 = sub_1B641D8A0((uint64_t)v10, v22, v23, v24, v25, v26, v27, v28);
  CFArrayRef v38 = sub_1B64ABD08(v9, v31, v32, v33, v34, v35, v36, v37);
  uint64_t v204 = v30;
  size_t v39 = 16 * v30;
  uint64_t v40 = (UInt8 *)malloc_type_calloc(16 * v30, 1uLL, 0x8E80353AuLL);
  CFIndex length = v39;
  uint64_t v41 = malloc_type_calloc(v39, 1uLL, 0xEA77C316uLL);
  uint64_t v212 = sub_1B641D478((uint64_t)v10, v42, v43, v44, v45, v46, v47, v48);
  __int16 v50 = WORD2(v49);
  uint64_t v211 = sub_1B641D478((uint64_t)v29, v49, v51, v52, v53, v54, v55, v56);
  if ((uint64_t)v38 < 1)
  {
    char v65 = 0;
  }
  else
  {
    CFIndex v64 = 0;
    char v65 = 0;
    uint64_t v209 = HIBYTE(v50);
    int v210 = v50;
    uint64_t v207 = BYTE5(v57);
    int v208 = BYTE4(v57);
    CFArrayRef v205 = v38;
    uint64_t v206 = v9;
    do
    {
      uint64_t v66 = sub_1B64ABD78(v9, v64, 1, v59, v60, v61, v62, v63);
      if (!sub_1B63D0C08((uint64_t)v66, v67, v68, v69, v70, v71, v72, v73)
        || sub_1B63D0C08((uint64_t)v66, v74, v75, v76, v77, v78, v79, v80) == 1)
      {
        uint64_t v213 = sub_1B63D11E8((uint64_t)v66);
        if (v213 < 1)
        {
          char v65 = 0;
        }
        else
        {
          for (uint64_t i = 0; i != v213; ++i)
          {
            uint64_t v82 = sub_1B63D14A0((uint64_t)v66, i, 0, 0, v60, v61, v62, v63);
            uint64_t v87 = sub_1B63D14A0((uint64_t)v66, i, 1, 0, v83, v84, v85, v86);
            uint64_t v92 = sub_1B63D14A0((uint64_t)v66, i, 2, 0, v88, v89, v90, v91);
            *(double *)v102.i64 = sub_1B65D6198(v210, (const float *)(v212 + v82 * v209), v93, v94, v95, v96, v97, v98, v99, v100, v101);
            float32x4_t v216 = v102;
            *(double *)v111.i64 = sub_1B65D6198(v210, (const float *)(v212 + v87 * v209), v103, v104, v105, v106, v107, v108, v102, v109, v110);
            float32x4_t v215 = v111;
            *(double *)v120.i64 = sub_1B65D6198(v210, (const float *)(v212 + v92 * v209), v112, v113, v114, v115, v116, v117, v111, v118, v119);
            float32x4_t v214 = v120;
            *(double *)v129.i64 = sub_1B65D6198(v208, (const float *)(v211 + v82 * v207), v121, v122, v123, v124, v125, v126, v120, v127, v128);
            float32x4_t v218 = v129;
            *(double *)v138.i64 = sub_1B65D6198(v208, (const float *)(v211 + v87 * v207), v130, v131, v132, v133, v134, v135, v129, v136, v137);
            float32x4_t v217 = v138;
            *(double *)v147.i64 = sub_1B65D6198(v208, (const float *)(v211 + v92 * v207), v139, v140, v141, v142, v143, v144, v138, v145, v146);
            float32x2_t v148 = (float32x2_t)vsubq_f32(v217, v218).u64[0];
            unint64_t v149 = vsubq_f32(v147, v218).u64[0];
            float v150 = v148.f32[1];
            float v151 = *((float *)&v149 + 1);
            float v152 = -*(float *)&v149;
            float v153 = vmlas_n_f32(vmuls_lane_f32(-*(float *)&v149, v148, 1), *((float *)&v149 + 1), v148.f32[0]);
            if (v153 == 0.0)
            {
              float v150 = v148.f32[1] + 0.00000011921;
              float v151 = *((float *)&v149 + 1) + -0.00000011921;
              v148.f32[0] = v148.f32[0] + -0.00000011921;
              float v152 = -(float)(*(float *)&v149 + -0.00000011921);
              float v153 = (float)(v148.f32[0] * (float)(*((float *)&v149 + 1) + -0.00000011921))
                   - (float)((float)(*(float *)&v149 + -0.00000011921) * (float)(v148.f32[1] + 0.00000011921));
            }
            float32x4_t v154 = vsubq_f32(v215, v216);
            float32x4_t v155 = vsubq_f32(v214, v216);
            float v156 = 1.0 / v153;
            float v157 = -v150;
            float v158 = (float)((float)(v151 * v154.f32[2]) - (float)(v150 * v155.f32[2])) * v156;
            uint64_t v159 = 4 * v82;
            uint64_t v160 = (16 * v82) | 8;
            *(float *)&v40[v160] = v158 + *(float *)&v40[v160];
            uint64_t v161 = (16 * v87) | 8;
            uint64_t v162 = 4 * v87;
            *(float *)&v40[v161] = v158 + *(float *)&v40[v161];
            float32x2_t v163 = vmul_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)v155.f32, v157), *(float32x2_t *)v154.f32, v151), v156);
            *(float32x2_t *)&v40[v159 * 4] = vadd_f32(*(float32x2_t *)&v40[16 * v82], v163);
            uint64_t v164 = 4 * v92;
            *(float32x2_t *)&v40[v162 * 4] = vadd_f32(v163, *(float32x2_t *)&v40[16 * v87]);
            *(float32x2_t *)&v40[v164 * 4] = vadd_f32(v163, *(float32x2_t *)&v40[16 * v92]);
            uint64_t v165 = (16 * v92) | 8;
            *(float *)&v40[v165] = v158 + *(float *)&v40[v165];
            v163.f32[0] = (float)((float)(v154.f32[2] * v152) + (float)(v148.f32[0] * v155.f32[2])) * v156;
            *(float *)((char *)v41 + v160) = v163.f32[0] + *(float *)((char *)v41 + v160);
            *(float *)((char *)v41 + v161) = v163.f32[0] + *(float *)((char *)v41 + v161);
            float32x2_t v166 = vmul_n_f32(vmla_n_f32(vmul_n_f32(*(float32x2_t *)v154.f32, v152), *(float32x2_t *)v155.f32, v148.f32[0]), v156);
            *(float32x2_t *)&v41[v159] = vadd_f32(v166, *(float32x2_t *)&v41[4 * v82]);
            *(float32x2_t *)&v41[v162] = vadd_f32(v166, *(float32x2_t *)&v41[4 * v87]);
            *(float32x2_t *)&v41[v164] = vadd_f32(v166, *(float32x2_t *)&v41[4 * v92]);
            *(float *)((char *)v41 + v165) = v163.f32[0] + *(float *)((char *)v41 + v165);
          }
          char v65 = 1;
          CFArrayRef v38 = v205;
          uint64_t v9 = v206;
        }
      }
      ++v64;
    }
    while ((const __CFArray *)v64 != v38);
  }
  uint64_t v167 = sub_1B641D478(v203, v57, v58, v59, v60, v61, v62, v63);
  if (v204 >= 1)
  {
    uint64_t v179 = (const float *)v167;
    int v180 = 0;
    int v181 = v168;
    uint64_t v182 = v169;
    uint64_t v183 = v204;
    do
    {
      *(double *)v184.i64 = sub_1B65D6198(v181, v179, v170, v171, v172, v173, v174, v175, v176, v177.f32[0], *(float *)v178.i32);
      uint64_t v185 = 4 * v180;
      uint64_t v186 = (__int32 *)&v40[4 * v180 + 8];
      v187.i64[0] = *(void *)&v40[v185];
      float32x4_t v188 = v187;
      v187.i32[2] = *v186;
      v188.i32[2] = *v186;
      float32x4_t v189 = vmulq_f32(v184, v187);
      float32x4_t v190 = vmlsq_lane_f32(v188, v184, (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v189, 2), vaddq_f32(v189, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v189.f32, 1))), 0);
      int32x4_t v191 = (int32x4_t)vmulq_f32(v190, v190);
      v191.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v191, 2), vadd_f32(*(float32x2_t *)v191.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v191.i8, 1))).u32[0];
      float32x2_t v192 = vrsqrte_f32((float32x2_t)v191.u32[0]);
      float32x2_t v193 = vmul_f32(v192, vrsqrts_f32((float32x2_t)v191.u32[0], vmul_f32(v192, v192)));
      float32x4_t v194 = vmulq_n_f32(v190, vmul_f32(v193, vrsqrts_f32((float32x2_t)v191.u32[0], vmul_f32(v193, v193))).f32[0]);
      *(void *)&v40[v185] = v194.i64[0];
      *uint64_t v186 = v194.i32[2];
      v194.i64[0] = *(void *)&v41[(unint64_t)v185 / 4];
      v194.i32[2] = v41[v180 + 2];
      int8x16_t v178 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v188, (int32x4_t)v188), (int8x16_t)v188, 0xCuLL), vnegq_f32(v184)), v188, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v184, (int32x4_t)v184), (int8x16_t)v184, 0xCuLL));
      float32x4_t v195 = vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v178, (int32x4_t)v178), v178, 0xCuLL), v194);
      float32x4_t v177 = vaddq_f32(v195, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v195.f32, 1));
      float32x4_t v176 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v195, 2), v177);
      if (v176.f32[0] < 0.0) {
        v176.f32[0] = -1.0;
      }
      else {
        v176.f32[0] = 1.0;
      }
      *(_DWORD *)&v40[4 * v180 + 12] = v176.i32[0];
      v180 += 4;
      uint64_t v179 = (const float *)((char *)v179 + v182);
      --v183;
    }
    while (v183);
  }
  free(v41);
  if (v65)
  {
    CFDataRef v196 = CFDataCreateWithBytesNoCopy(0, v40, length, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    uint64_t v200 = sub_1B641CF98(v196, 4, v204, 4, 1, v197, v198, v199);
    CFRelease(v196);
    return v200;
  }
  else
  {
    free(v40);
    return 0;
  }
}

uint64_t sub_1B63DE310(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  uint64_t v18 = sub_1B64ACF7C(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v18) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v12, v13, v14, v15, v16, v17, (uint64_t)"positionSource");
  }
  if (!sub_1B64ABD08(a1, v11, v12, v13, v14, v15, v16, v17)) {
    return 0;
  }
  uint64_t v26 = sub_1B641D8A0((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25);
  uint64_t v30 = sub_1B647B3F8(0, 1, v26, 3, 1, v27, v28, v29);
  sub_1B63DE3FC(a1, (uint64_t)v18, v30, a2, a3, v31, v32, v33);
  sub_1B641CF94(v30);
  return v30;
}

void sub_1B63DE3FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = sub_1B641D478(a2, a2, a3, a4, a5, a6, a7, a8);
  if ((v14 & 0xFF00000000) == 0x800000000
    && (uint64_t v21 = v13,
        uint64_t v22 = v14,
        uint64_t v23 = sub_1B641D478(a3, v14, v15, v16, v17, v18, v19, v20),
        uint64_t v93 = v24,
        (v24 & 0xFF00000000) == 0x800000000))
  {
    if (v22)
    {
      uint64_t v28 = (char *)v23;
      if (a5) {
        uint64_t v29 = sub_1B65E2DE0(a2, v24, v25, v26, v27, v18, v19, v20);
      }
      else {
        uint64_t v29 = 0;
      }
      CFArrayRef v30 = sub_1B64ABD08(a1, v24, v25, v26, v27, v18, v19, v20);
      unsigned int v38 = sub_1B641D8A0(a3, v31, v32, v33, v34, v35, v36, v37);
      unsigned int v45 = v38;
      if (BYTE5(v93) == 12)
      {
        LODWORD(__pattern4) = 0;
        memset_pattern4(v28, &__pattern4, 12 * v38);
      }
      else if (v38)
      {
        int v46 = 0;
        uint64_t v47 = v38;
        do
        {
          uint64_t v48 = &v28[v46];
          *(void *)uint64_t v48 = 0;
          *((_DWORD *)v48 + 2) = 0;
          v46 += BYTE5(v93);
          --v47;
        }
        while (v47);
      }
      if ((uint64_t)v30 >= 1)
      {
        for (CFIndex i = 0; v30 != (const __CFArray *)i; ++i)
        {
          uint64_t v56 = sub_1B64ABD78(a1, i, a4, v39, v40, v41, v42, v43);
          if (a4) {
            uint64_t v57 = 0;
          }
          else {
            uint64_t v57 = sub_1B64ACE9C(a1, 0, 0, v51, v52, v53, v54, v55);
          }
          uint64_t v101 = 0;
          long long v99 = 0u;
          long long v100 = 0u;
          long long __pattern4 = 0u;
          sub_1B63D11F0((uint64_t)v56, v57, v50, v51, v52, v53, v54, v55, (uint64_t)&__pattern4);
          if ((BYTE10(v99) & 0xFA) != 0)
          {
            CFIndex v64 = @"Warning: CFXUnifyNormalsFromGeometry can only process triangles and polygons";
          }
          else
          {
            if ((void)__pattern4)
            {
              v96[0] = MEMORY[0x1E4F143A8];
              v96[1] = 3221225472;
              v96[2] = sub_1B63E1FC0;
              v96[3] = &unk_1E6141148;
              v96[4] = v21;
              v96[5] = v22;
              int v97 = v22 - 1;
              v96[6] = v29;
              v96[7] = v28;
              v96[8] = v93;
              v94[0] = __pattern4;
              v94[1] = v99;
              v94[2] = v100;
              uint64_t v95 = v101;
              sub_1B63D1BEC((uint64_t *)v94, (uint64_t)v96, v58, v59, v60, v61, v62, v63);
              continue;
            }
            CFIndex v64 = @"Warning: CFXUnifyNormalsFromGeometry empty indices";
          }
          sub_1B63F2F54(0, (uint64_t)v64, v58, v59, v60, v61, v62, v63, v92);
        }
      }
      if (v29 && v45)
      {
        int v65 = 0;
        for (uint64_t j = 0; j != v45; ++j)
        {
          uint64_t v67 = v29[j];
          if (j != v67)
          {
            uint64_t v68 = &v28[v67 * BYTE5(v93)];
            int v69 = *((_DWORD *)v68 + 2);
            uint64_t v70 = *(void *)v68;
            uint64_t v71 = &v28[v65];
            *(void *)uint64_t v71 = v70;
            *((_DWORD *)v71 + 2) = v69;
          }
          v65 += BYTE5(v93);
        }
      }
      LODWORD(v72) = 0;
      if (BYTE5(v93) == 12 && v45 >= 4)
      {
        uint64_t v73 = 0;
        unint64_t v72 = 0;
        do
        {
          uint64_t v74 = (float *)&v28[v73 & 0xFFFFFFF0];
          *(float32x4x3_t *)v44.f32 = vld3q_f32(v74);
          float32x4_t v77 = vaddq_f32(vmulq_f32(v76, v76), vaddq_f32(vmulq_f32(v44, v44), vmulq_f32(v75, v75)));
          float32x4_t v78 = vrsqrteq_f32(v77);
          float32x4_t v79 = vmulq_f32(v78, vrsqrtsq_f32(v77, vmulq_f32(v78, v78)));
          float32x4_t v80 = vmulq_f32(v79, vrsqrtsq_f32(v77, vmulq_f32(v79, v79)));
          v103.val[0] = vmulq_f32(v44, v80);
          v103.val[1] = vmulq_f32(v75, v80);
          v103.val[2] = vmulq_f32(v76, v80);
          vst3q_f32(v74, v103);
          v72 += 4;
          v73 += 48;
        }
        while (v72 < (v45 & 0xFFFFFFFC));
      }
      if (v72 < v45)
      {
        int v81 = v72 * BYTE5(v93);
        unint64_t v82 = v45 - (unint64_t)v72;
        do
        {
          uint64_t v83 = &v28[v81];
          v44.i64[0] = *(void *)v83;
          float32x4_t v84 = v44;
          v84.i32[2] = *((_DWORD *)v83 + 2);
          float32x4_t v85 = vmulq_f32(v84, v84);
          v85.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v85, 2), vaddq_f32(v85, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v85.f32, 1))).u64[0];
          float32x4_t v86 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v85.f32, 0);
          v86.i32[3] = 0;
          float32x4_t v87 = vrsqrteq_f32(v86);
          float32x4_t v88 = vmulq_f32(v87, vrsqrtsq_f32(v86, vmulq_f32(v87, v87)));
          unsigned int v89 = v85.f32[0] != 0.0;
          float32x4_t v90 = vmulq_f32(v88, vrsqrtsq_f32(v86, vmulq_f32(v88, v88)));
          int32x4_t v91 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v89)), 0x1FuLL));
          v44.i32[2] = v84.i32[2];
          v91.i32[3] = 0;
          float32x4_t v44 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v91), (int8x16_t)vmulq_f32(v84, v90), (int8x16_t)v44);
          *(void *)uint64_t v83 = v44.i64[0];
          *((_DWORD *)v83 + 2) = v44.i32[2];
          v81 += BYTE5(v93);
          --v82;
        }
        while (v82);
      }
      free(v29);
    }
  }
  else
  {
    sub_1B63E1CC4(a1, a2, a3, a4, a5, v18, v19, v20);
  }
}

uint64_t sub_1B63DE824(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"mesh");
  }
  uint64_t v18 = sub_1B64ACF7C(a1, a3, a3, a4, a5, a6, a7, a8);
  if (!v18) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v12, v13, v14, v15, v16, v17, (uint64_t)"positionSource");
  }
  if (!sub_1B64ABD08(a2, v11, v12, v13, v14, v15, v16, v17)) {
    return 0;
  }
  uint64_t v26 = sub_1B641D8A0((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25);
  uint64_t v30 = sub_1B647B3F8(0, 1, v26, 3, 1, v27, v28, v29);
  sub_1B63DE3FC(a2, (uint64_t)v18, v30, a3, 0, v31, v32, v33);
  sub_1B641CF94(v30);
  return v30;
}

void sub_1B63DE908(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a3;
  if (sub_1B64ABD08(a2, a2, a3, a4, a5, a6, a7, a8))
  {
    uint64_t v18 = sub_1B64ACF7C(a1, 1, v12, v13, v14, v15, v16, v17);
    if (v18)
    {
      uint64_t v26 = (uint64_t)v18;
      uint64_t v27 = sub_1B641D8A0((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25);
      if (v27)
      {
        uint64_t v34 = v27;
        uint64_t v35 = sub_1B64ACF7C(a2, 1, v28, v29, v30, v31, v32, v33);
        if (v35)
        {
          if (v34 == sub_1B641D8A0((uint64_t)v35, v36, v37, v38, v39, v40, v41, v42))
          {
            uint64_t v52 = sub_1B64AD1C4(a1, 1, v43, v44, v45, v46, v47, v48);
            if (!v52 && v9)
            {
              uint64_t v52 = (const void *)sub_1B647B3F8(0, 1, v34, 3, 1, v49, v50, v51);
              sub_1B64AC4D0(a1, v52, 0, v53, v54, v55, v56, v57);
              CFRelease(v52);
            }
            if (v52)
            {
              if (sub_1B641CF90(v52))
              {
                sub_1B63DE3FC(a2, v26, (uint64_t)v52, 1, a4, v58, v59, v60);
              }
              else
              {
                uint64_t v61 = (const void *)sub_1B641E168((uint64_t)v52);
                sub_1B64AC4D0(a1, v61, 0, v62, v63, v64, v65, v66);
                CFRelease(v61);
                sub_1B63DE3FC(a2, v26, (uint64_t)v61, 1, a4, v67, v68, v69);
                sub_1B641CF94((uint64_t)v61);
              }
            }
          }
          else
          {
            sub_1B63F2F54(16, @"Error: target mesh has a different number of vertices (%d != %d)", v43, v44, v45, v46, v47, v48, v34);
          }
        }
      }
    }
  }
}

void sub_1B63DEAB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  uint64_t v10 = (__n128 *)sub_1B64B1FBC(a1, a2, a3, a4, a5, a6, a7, a8);
  *(float *)&double v11 = a9;

  sub_1B63DEAF4(v10, 1, v11);
}

void sub_1B63DEAF4(__n128 *a1, int a2, double a3)
{
  if (a1)
  {
    uint64_t v48 = *(void *)&a3;
    *(double *)v5.i64 = sub_1B64A230C(a1);
    sub_1B64A2314(a1, vmulq_n_f32(v5, *(float *)&v48));
    if (sub_1B64A0A1C((uint64_t)a1, v6, v7, v8, v9, v10, v11, v12))
    {
      *(double *)v20.i64 = sub_1B64A26AC((uint64_t)a1, v13, v14, v15, v16, v17, v18, v19);
      v21.i64[0] = 0x3400000034000000;
      v21.i64[1] = 0x3400000034000000;
      uint32x4_t v22 = (uint32x4_t)vcgeq_f32(v21, vabsq_f32(v20));
      v22.i32[3] = v22.i32[2];
      if ((vminvq_u32(v22) & 0x80000000) == 0) {
        sub_1B64A2708((uint64_t)a1, v13, v14, v15, v16, v17, v18, v19, (__n128)vmulq_n_f32(v20, *(float *)&v48));
      }
    }
    uint64_t v23 = sub_1B649F5F4((uint64_t)a1, v13, v14, v15, v16, v17, v18, v19);
    if (v23)
    {
      uint64_t v31 = sub_1B63CCE68(v23, v24, v25, v26, v27, v28, v29, v30);
      if (v31) {
        sub_1B63DECE8(v31, (float32x4_t)vdupq_lane_s32((int32x2_t)v48, 0), v24, v25, v26, v27, v28, v29, v30);
      }
    }
    uint64_t v32 = (float32x4_t *)sub_1B649F640((uint64_t)a1, v24, v25, v26, v27, v28, v29, v30);
    if (v32) {
      sub_1B63DEC24(v32, v33, v34, v35, v36, v37, v38, v39, *(float *)&v48, v48);
    }
    CFDictionaryRef v40 = sub_1B64A3B48((uint64_t)a1, v33, v34, v35, v36, v37, v38, v39);
    if (v40) {
      sub_1B63DEC80((uint64_t)v40, v41, v42, v43, v44, v45, v46, v47, *(float *)&v48);
    }
    if (a2)
    {
      v49[0] = MEMORY[0x1E4F143A8];
      v49[1] = 3221225472;
      v49[2] = sub_1B63DECD8;
      v49[3] = &unk_1E61410B8;
      int v50 = v48;
      sub_1B649FD10((uint64_t)a1, (uint64_t)v49);
    }
  }
}

void sub_1B63DEC24(float32x4_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9, uint64_t a10)
{
  float v12 = sub_1B6496784((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1B64967D0(a1, v13, v14, v15, v16, v17, v18, v19, v12 * a9, v35);
  float v34 = sub_1B64966CC((uint64_t)a1, v20, v21, v22, v23, v24, v25, v26) * a9;

  sub_1B6496718(a1, v27, v28, v29, v30, v31, v32, v33, v34, a10);
}

float32x2_t sub_1B63DEC80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  float v10 = sub_1B649C30C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1B649C358(a1, v10 * a9, v11, v12, v13, v14, v15, v16, v17);
  uint64_t v25 = sub_1B649D3DC(a1, v18, v19, v20, v21, v22, v23, v24);
  float32x2_t result = vmul_n_f32(*(float32x2_t *)(v25 + 4), a9);
  *(float32x2_t *)(v25 + 4) = result;
  return result;
}

uint64_t sub_1B63DECD8(uint64_t a1, uint64_t a2)
{
  return sub_1B63DEAF4(a2, 1, *(float *)(a1 + 32));
}

void sub_1B63DECE8(uint64_t a1, float32x4_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  float v10 = sub_1B64ACF7C(a1, 0, a4, a5, a6, a7, a8, a9);
  if (v10)
  {
    uint64_t v17 = (uint64_t)v10;
    unsigned __int8 v18 = sub_1B64ACE9C(a1, 0, 0, v12, v13, v14, v15, v16);
    uint64_t v19 = (const void *)sub_1B641E168(v17);
    uint64_t v27 = sub_1B641D8A0((uint64_t)v19, v20, v21, v22, v23, v24, v25, v26);
    if (v27 >= 1)
    {
      uint64_t v34 = v27;
      for (uint64_t i = 0; i != v34; ++i)
      {
        *(double *)v36.i64 = sub_1B641E208((uint64_t)v19, i, v28, v29, v30, v31, v32, v33);
        sub_1B647B618((uint64_t)v19, i, v37, v38, v39, v40, v41, v42, (__n128)vmulq_f32(a2, v36));
      }
    }
    sub_1B641CF94((uint64_t)v19);
    sub_1B64AC4C8(a1, v19, 0, v18, v43, v44, v45, v46);
    CFRelease(v19);
  }
  BOOL v47 = a2.f32[1] != a2.f32[2];
  if (a2.f32[0] != a2.f32[2]) {
    BOOL v47 = 0;
  }
  BOOL v48 = a2.f32[0] == a2.f32[1] && v47;
  uint64_t v49 = sub_1B64AD1C4(a1, 0, v11, v12, v13, v14, v15, v16);
  if (!v48)
  {
    uint64_t v55 = (uint64_t)v49;
    if (v49)
    {
      unsigned __int8 v56 = sub_1B64ACE9C(a1, 1, 0, v50, v51, v52, v53, v54);
      uint64_t v57 = (const void *)sub_1B641E168(v55);
      uint64_t v65 = sub_1B641D8A0((uint64_t)v57, v58, v59, v60, v61, v62, v63, v64);
      if (v65 >= 1)
      {
        uint64_t v72 = v65;
        uint64_t v73 = 0;
        __asm { FMOV            V0.4S, #1.0 }
        float32x4_t v91 = vdivq_f32(_Q0, a2);
        do
        {
          *(double *)v79.i64 = sub_1B641E208((uint64_t)v57, v73, v66, v67, v68, v69, v70, v71);
          sub_1B647B618((uint64_t)v57, v73++, v80, v81, v82, v83, v84, v85, (__n128)vmulq_f32(v91, v79));
        }
        while (v72 != v73);
      }
      sub_1B641CF94((uint64_t)v57);
      sub_1B64AC4C8(a1, v57, 0, v56, v86, v87, v88, v89);
      CFRelease(v57);
    }
  }
}

BOOL sub_1B63DEEAC(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v10 = sub_1B63CCEC4(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((uint64_t)v10 < 1)
  {
    return 0;
  }
  else
  {
    CFArrayRef v17 = v10;
    uint64_t v18 = 0;
    BOOL v19 = 1;
    while (1)
    {
      CFArrayRef v20 = sub_1B63CCF34(a1, v18, v11, v12, v13, v14, v15, v16);
      uint64_t v28 = sub_1B64AF43C((uint64_t)v20, v21, v22, v23, v24, v25, v26, v27);
      if (v28)
      {
        uint64_t v29 = sub_1B6475290(v28, 6, 0, v12, v13, v14, v15, v16);
        if (v29)
        {
          if (sub_1B6475F88(v29, v30, v11, v12, v13, v14, v15, v16)) {
            break;
          }
        }
      }
      BOOL v19 = ++v18 < (uint64_t)v17;
      if (v17 == (const __CFArray *)v18) {
        return v19;
      }
    }
    if (a2) {
      *a2 = v18;
    }
  }
  return v19;
}

uint64_t sub_1B63DEF50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (sub_1B64AC5F8(a1, 4, 0, a2, a5, a6, a7, a8)) {
    return 1;
  }
  CFArrayRef v17 = sub_1B64ACF7C(a1, a2, v10, v11, v12, v13, v14, v15);
  if (v17)
  {
    uint64_t v24 = (uint64_t)v17;
    unsigned __int8 v25 = sub_1B64ACE9C(a1, 0, 0, v19, v20, v21, v22, v23);
    uint64_t v37 = sub_1B64AD1C4(a1, a2, v26, v27, v28, v29, v30, v31);
    if (!v37)
    {
      uint64_t result = sub_1B63DE310(a1, a2, 0, v32, v33, v34, v35, v36);
      if (!result) {
        return result;
      }
      uint64_t v37 = (const void *)result;
      if (a2 == 1)
      {
        sub_1B64AC4D0(a1, (const void *)result, 0, v38, v39, v40, v41, v42);
      }
      else if (!a2)
      {
        sub_1B64AC4C8(a1, (const void *)result, 0, v25, v39, v40, v41, v42);
      }
      CFRelease(v37);
    }
    uint64_t v44 = sub_1B64AC5F8(a1, 3, 0, a2, v33, v34, v35, v36);
    if (v44)
    {
      uint64_t v52 = (uint64_t)v44;
      sub_1B641D478(v24, v45, v46, v47, v48, v49, v50, v51);
      unint64_t v54 = v53;
      sub_1B641D478((uint64_t)v37, v53, v55, v56, v57, v58, v59, v60);
      unint64_t v62 = v61;
      sub_1B641D478(v52, v61, v63, v64, v65, v66, v67, v68);
      if ((v54 & 0xFF000000000000) == 0x1000000000000
        && HIBYTE(v54) >= 3
        && (v62 & 0xFF000000000000) == 0x1000000000000
        && HIBYTE(v62) >= 3
        && (v69 & 0xFF000000000000) == 0x1000000000000
        && v69 >> 57)
      {
        uint64_t v76 = sub_1B63DD744(a1, a2, v70, v71, v72, v73, v74, v75);
      }
      else
      {
        uint64_t v76 = sub_1B63DDD4C(a1, a2, v70, v71, v72, v73, v74, v75);
      }
      uint64_t v92 = (const void *)v76;
      if (v76)
      {
LABEL_28:
        if (a2 == 1)
        {
          sub_1B64AC4D0(a1, v92, 0, v19, v20, v21, v22, v23);
        }
        else if (!a2)
        {
          sub_1B64AC4C8(a1, v92, 0, v25, v20, v21, v22, v23);
        }
        CFRelease(v92);
        return 1;
      }
    }
    else
    {
      sub_1B63F2F54(16, @"Error: Cannot generate tangents without texture coordinates", v46, v47, v48, v49, v50, v51, v93);
      uint64_t v84 = sub_1B641D8A0(v24, v77, v78, v79, v80, v81, v82, v83);
      uint64_t v85 = 16 * v84;
      uint64_t v86 = (UInt8 *)malloc_type_calloc(16 * v84, 1uLL, 0x737CBC28uLL);
      uint64_t v87 = v86;
      if (v84 >= 1) {
        memset_pattern16(v86, &xmmword_1B6E4F370, v85);
      }
      CFDataRef v88 = CFDataCreateWithBytesNoCopy(0, v87, v85, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      uint64_t v92 = (const void *)sub_1B641CF98(v88, 4, v84, 4, 1, v89, v90, v91);
      CFRelease(v88);
      if (v92) {
        goto LABEL_28;
      }
    }
    uint64_t v43 = @"Error: error in CFXMeshCreateTangentsIfNeeded";
  }
  else
  {
    uint64_t v43 = @"Error: Cannot generate tangents without positions";
  }
  sub_1B63F2F54(16, (uint64_t)v43, v18, v19, v20, v21, v22, v23, v93);
  return 0;
}

uint64_t sub_1B63DF1D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  uint64_t v24 = 0;
  uint64_t result = sub_1B63DEEAC(a1, &v24, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t result = sub_1B63CCE68(a1, v11, v12, v13, v14, v15, v16, v17);
    if (result) {
      return sub_1B63DEF50(result, a2, v18, v19, v20, v21, v22, v23);
    }
  }
  return result;
}

BOOL sub_1B63DF24C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = sub_1B64AC5F8(a1, 0, 0, 0, a5, a6, a7, a8);
  if (!v8) {
    return 0;
  }
  uint64_t v16 = sub_1B641E1A8((uint64_t)v8, v9, v10, v11, v12, v13, v14, v15);
  if (!v16) {
    return 0;
  }

  return sub_1B65349F4(v16, v17, v18, v19, v20, v21, v22, v23);
}

uint64_t sub_1B63DF298(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B64AB2A8(a1, a2, a3, a4, a5, a6, a7, a8);
  unsigned __int8 v10 = 0;
  do
  {
    int v11 = sub_1B64AD020(a1, (char)v10);
    if (v11 >= 1)
    {
      uint64_t v16 = 0;
      uint64_t v17 = v11;
      do
      {
        uint64_t v18 = sub_1B64AC5F8(a1, (char)v10, v16, 0, v12, v13, v14, v15);
        if (v18)
        {
          uint64_t v19 = (const void *)sub_1B641E128((uint64_t)v18);
          sub_1B64AC4C8(v9, v19, v16, 255, v20, v21, v22, v23);
          CFRelease(v19);
        }
        ++v16;
      }
      while (v17 != v16);
    }
    unsigned int v24 = v10++;
  }
  while (v24 < 8);
  return v9;
}

uint64_t sub_1B63DF358(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v43 = 0;
  uint64_t v44 = &v43;
  uint64_t v45 = 0x2020000000;
  uint64_t v46 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = &v39;
  uint64_t v41 = 0x2020000000;
  uint64_t v42 = 0;
  v38[0] = MEMORY[0x1E4F143A8];
  v38[1] = 3221225472;
  long long v38[2] = sub_1B63DF5A0;
  v38[3] = &unk_1E61410E0;
  v38[4] = &v43;
  v38[5] = &v39;
  sub_1B64AAFB4(a1, 0, (uint64_t)v38, a4, a5, a6, a7, a8);
  uint64_t v9 = v44[3];
  if (v9)
  {
    unsigned __int8 v10 = (const UInt8 *)sub_1B63CA51C(v40[3] * v9);
    CFDataRef v11 = CFDataCreateWithBytesNoCopy(0, v10, v44[3] * v40[3], (CFAllocatorRef)*MEMORY[0x1E4F1CF90]);
    uint64_t v34 = 0;
    uint64_t v35 = &v34;
    uint64_t v36 = 0x2020000000;
    uint64_t v37 = 0;
    uint64_t v12 = -[VFXMesh __createCFObject]_0();
    uint64_t v19 = (const void *)sub_1B64AD3C4(a1, 0, v13, v14, v15, v16, v17, v18);
    sub_1B64AD458(v12, v19, v20, v21, v22, v23, v24, v25);
    v33[0] = 0;
    v33[1] = v33;
    v33[2] = 0x2020000000;
    v33[3] = 0;
    v32[0] = MEMORY[0x1E4F143A8];
    v32[1] = 3221225472;
    _OWORD v32[2] = sub_1B63DF63C;
    void v32[3] = &unk_1E6141108;
    v32[4] = &v34;
    v32[5] = &v39;
    v32[6] = &v43;
    v32[7] = v33;
    v32[8] = v11;
    v32[9] = v12;
    sub_1B64AAFB4(a1, 0, (uint64_t)v32, v26, v27, v28, v29, v30);
    CFRelease((CFTypeRef)v35[3]);
    CFRelease(v11);
    _Block_object_dispose(v33, 8);
    _Block_object_dispose(&v34, 8);
  }
  else
  {
    uint64_t v12 = 0;
  }
  _Block_object_dispose(&v39, 8);
  _Block_object_dispose(&v43, 8);
  return v12;
}

void sub_1B63DF54C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1B63DF5A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B641E1A8(a2, a2, a3, a4, a5, a6, a7, a8);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += sub_1B65349C0(v10, v11, v12, v13, v14, v15, v16, v17);
  uint64_t v18 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v26 = sub_1B641D8A0(a2, v19, v20, v21, v22, v23, v24, v25);
  uint64_t v33 = *(void *)(*(void *)(a1 + 40) + 8);
  if (v18)
  {
    if (v26 != *(void *)(v33 + 24))
    {
      sub_1B63F2F54(0, @"Warning: Cannot create an interleaved copy, count mismatch", v27, v28, v29, v30, v31, v32, v34);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
  }
  else
  {
    *(void *)(v33 + 24) = v26;
  }
}

uint64_t sub_1B63DF63C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v10 = a3;
  uint64_t v12 = sub_1B641E1A8(a2, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v13 = v12;
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    int v14 = sub_1B6534654(v12);
    uint64_t v15 = sub_1B653465C(v13);
    uint64_t v16 = (const void *)sub_1B6534714(v14, v15, *(void *)(*(void *)(a1[5] + 8) + 24), *(void *)(*(void *)(a1[6] + 8) + 24), *(void *)(*(void *)(a1[7] + 8) + 24));
    uint64_t v17 = (const void *)sub_1B641D0F8(v16, v10);
    CFRelease(v16);
    sub_1B6534974((uint64_t)v16, *(void *)(*(void *)(a1[4] + 8) + 24));
    sub_1B64AC4C8(a1[9], v17, a4, a5, v18, v19, v20, v21);
    CFRelease(v17);
  }
  else
  {
    uint64_t v27 = (const void *)a1[8];
    uint64_t v28 = sub_1B6534654(v12);
    uint64_t v29 = sub_1B653465C(v13);
    *(void *)(*(void *)(a1[4] + 8) + 24) = sub_1B641D00C(v10, v27, v28, v29, *(void *)(*(void *)(a1[5] + 8) + 24), *(void *)(*(void *)(a1[6] + 8) + 24), *(void *)(*(void *)(a1[7] + 8) + 24), v30);
    uint64_t v16 = (const void *)sub_1B641E1A8(*(void *)(*(void *)(a1[4] + 8) + 24), v31, v32, v33, v34, v35, v36, v37);
    sub_1B64AC4C8(a1[9], *(const void **)(*(void *)(a1[4] + 8) + 24), a4, a5, v38, v39, v40, v41);
  }
  sub_1B6534A3C(v13, (uint64_t)v16, 0, v22, v23, v24, v25, v26);
  uint64_t result = sub_1B65349C0(v13, v42, v43, v44, v45, v46, v47, v48);
  *(void *)(*(void *)(a1[7] + 8) + 24) += result;
  return result;
}

void sub_1B63DF7DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"geometry");
  }
  uint64_t v9 = sub_1B63CCE68(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = sub_1B64AD020(v9, 1);
  if (v10 >= 1)
  {
    uint64_t v15 = v10;
    for (uint64_t i = 0; i != v15; ++i)
    {
      uint64_t v17 = sub_1B64AC5F8(v9, 1, i, 0, v11, v12, v13, v14);
      unsigned __int8 v23 = sub_1B64ACE9C(v9, 1, i, v18, v19, v20, v21, v22);
      uint64_t v31 = sub_1B641E1A8((uint64_t)v17, v24, v25, v26, v27, v28, v29, v30);
      if (sub_1B6534654(v31) != 4)
      {
        uint64_t v34 = (const void *)sub_1B641E310((uint64_t)v17, 4, v32, v33, v11, v12, v13, v14);
        if (v34)
        {
          uint64_t v35 = v34;
          sub_1B64AC4C8(v9, v34, i, v23, v11, v12, v13, v14);
          CFRelease(v35);
        }
      }
    }
  }
  uint64_t v36 = sub_1B64AD020(v9, 2);
  if (v36 >= 1)
  {
    uint64_t v41 = v36;
    for (uint64_t j = 0; j != v41; ++j)
    {
      uint64_t v43 = sub_1B64AC5F8(v9, 2, j, 0, v37, v38, v39, v40);
      unsigned __int8 v49 = sub_1B64ACE9C(v9, 2, j, v44, v45, v46, v47, v48);
      uint64_t v57 = sub_1B641E1A8((uint64_t)v43, v50, v51, v52, v53, v54, v55, v56);
      if (sub_1B6534654(v57) != 15)
      {
        uint64_t v60 = (const void *)sub_1B641E310((uint64_t)v43, 15, v58, v59, v37, v38, v39, v40);
        if (v60)
        {
          uint64_t v61 = v60;
          sub_1B64AC4C8(v9, v60, j, v49, v37, v38, v39, v40);
          CFRelease(v61);
        }
      }
    }
  }
}

uint64_t sub_1B63DF96C(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  *(uint64_t *)((char *)v185.i64 + 4) = 0;
  v185.i32[0] = 0;
  float32x4_t v182 = 0u;
  float32x4_t v183 = 0u;
  uint64_t v10 = sub_1B64B1FBC((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if ((sub_1B649FB70(v10, &v182, 0, v11, v12, v13, v14, v15) & 1) == 0)
  {
    uint64_t v30 = sub_1B64A0828();
    sub_1B649A528();
    CFDictionaryRef v77 = v76;
    sub_1B64A3BD8(v30, v76, v78, v79, v80, v81, v82, v83);
    sub_1B65834BC(v30, @"default camera", v84, v85, v86, v87, v88, v89);
    CFRelease(v77);
    return v30;
  }
  float32x4_t v23 = vsubq_f32(v182, v183);
  float32x4_t v24 = vaddq_f32(v182, v183);
  float32x4_t v25 = vmulq_f32(vsubq_f32(v24, v23), (float32x4_t)vdupq_n_s32(0x3DCCCCCDu));
  int8x16_t v26 = (int8x16_t)vsubq_f32(v23, v25);
  int8x16_t v27 = (int8x16_t)vaddq_f32(v24, v25);
  if (v8) {
    unsigned int v28 = -1;
  }
  else {
    unsigned int v28 = 0;
  }
  int8x16_t v29 = (int8x16_t)vdupq_n_s32(v28);
  float32x4_t v179 = (float32x4_t)vbslq_s8(v29, v27, (int8x16_t)v24);
  float32x4_t v178 = (float32x4_t)vbslq_s8(v29, v26, (int8x16_t)v23);
  *(double *)v188.columns[0].i64 = sub_1B649FE9C(v10, v16, v17, v18, v19, v20, v21, v22);
  simd_float4x4 v189 = __invert_f4(v188);
  float32x4_t v173 = (float32x4_t)v189.columns[1];
  float32x4_t v174 = (float32x4_t)v189.columns[0];
  float32x4_t v171 = (float32x4_t)v189.columns[3];
  float32x4_t v172 = (float32x4_t)v189.columns[2];
  uint64_t v30 = sub_1B64A0828();
  sub_1B649A528();
  CFDictionaryRef v32 = v31;
  sub_1B64A3BD8(v30, v31, v33, v34, v35, v36, v37, v38);
  sub_1B65834BC(v30, @"default camera", v39, v40, v41, v42, v43, v44);
  CFRelease(v32);
  uint64_t v52 = sub_1B649D3DC((uint64_t)v32, v45, v46, v47, v48, v49, v50, v51);
  sub_1B649C1B8((float *)v32, 45.0, v53, v54, v55, v56, v57, v58, v59);
  float32x4_t v176 = vaddq_f32(v178, v179);
  sub_1B64B2438(a1, (__n128 *)&v185, v60, v61, v62, v63, v64, v65);
  float32x4_t v66 = v185;
  v67.i64[0] = 0x3400000034000000;
  v67.i64[1] = 0x3400000034000000;
  uint32x4_t v68 = (uint32x4_t)vcgeq_f32(v67, vabsq_f32(v185));
  v68.i32[3] = v68.i32[2];
  unsigned int v69 = vminvq_u32(v68);
  long long v70 = (__int128)v185;
  if ((v69 & 0x80000000) != 0)
  {
    long long v70 = xmmword_1B6E4F320;
    float32x4_t v185 = (float32x4_t)xmmword_1B6E4F320;
    float32x4_t v66 = (float32x4_t)xmmword_1B6E4F320;
  }
  v71.i64[0] = 0x3F0000003F000000;
  v71.i64[1] = 0x3F0000003F000000;
  float32x4_t v72 = vmulq_f32(v176, v71);
  float32x4_t v73 = vmulq_f32(vsubq_f32(v179, v178), v71);
  float32x4_t v74 = vmulq_f32(v73, (float32x4_t)vdupq_n_s32(0x401A827Au));
  if (*((float *)&v70 + 1) == 0.0 && *(float *)&v70 == 0.0)
  {
    if (*((float *)&v70 + 2) == 0.0)
    {
      float32x4_t v75 = v72;
      goto LABEL_18;
    }
    if (v74.f32[0] < v74.f32[2]) {
      v74.f32[0] = v74.f32[2];
    }
    v75.i32[0] = v72.i32[0];
    v75.f32[1] = v72.f32[1] - (float)(v73.f32[1] + v74.f32[0]);
    v75.i32[2] = v72.i32[2];
  }
  else
  {
    if (v74.f32[0] < v74.f32[1]) {
      v74.f32[0] = v74.f32[1];
    }
    v75.i64[0] = v72.i64[0];
    v75.f32[2] = v72.f32[2] + (float)(v73.f32[2] + v74.f32[0]);
  }
  v75.i32[3] = v72.i32[3];
LABEL_18:
  float32x4_t v177 = v72;
  float32x4_t v90 = vsubq_f32(v72, v75);
  int32x4_t v91 = (int32x4_t)vmulq_f32(v90, v90);
  v91.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v91, 2), vadd_f32(*(float32x2_t *)v91.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v91.i8, 1))).u32[0];
  float32x2_t v92 = vrsqrte_f32((float32x2_t)v91.u32[0]);
  float32x2_t v93 = vmul_f32(v92, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v92, v92)));
  v91.i32[0] = vmul_f32(v93, vrsqrts_f32((float32x2_t)v91.u32[0], vmul_f32(v93, v93))).u32[0];
  int32x4_t v94 = (int32x4_t)vmulq_f32(v66, v66);
  v94.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v94, 2), vadd_f32(*(float32x2_t *)v94.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v94.i8, 1))).u32[0];
  float32x4_t v95 = vmulq_n_f32(v90, *(float *)v91.i32);
  *(float32x2_t *)v91.i8 = vrsqrte_f32((float32x2_t)v94.u32[0]);
  *(float32x2_t *)v91.i8 = vmul_f32(*(float32x2_t *)v91.i8, vrsqrts_f32((float32x2_t)v94.u32[0], vmul_f32(*(float32x2_t *)v91.i8, *(float32x2_t *)v91.i8)));
  float32x4_t v96 = vmulq_n_f32(v66, vmul_f32(*(float32x2_t *)v91.i8, vrsqrts_f32((float32x2_t)v94.u32[0], vmul_f32(*(float32x2_t *)v91.i8, *(float32x2_t *)v91.i8))).f32[0]);
  float32x4_t v97 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v95, (int32x4_t)v95), (int8x16_t)v95, 0xCuLL);
  float32x4_t v98 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v96, (int32x4_t)v96), (int8x16_t)v96, 0xCuLL), vnegq_f32(v95)), v96, v97);
  float32x4_t v99 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v98, (int32x4_t)v98), (int8x16_t)v98, 0xCuLL);
  int32x4_t v100 = (int32x4_t)vmulq_f32(v98, v98);
  v100.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v100.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v100, 2), *(float32x2_t *)v100.i8)).u32[0];
  float32x2_t v101 = vrsqrte_f32((float32x2_t)v100.u32[0]);
  float32x2_t v102 = vmul_f32(v101, vrsqrts_f32((float32x2_t)v100.u32[0], vmul_f32(v101, v101)));
  float32x4_t v103 = vmulq_n_f32(v99, vmul_f32(v102, vrsqrts_f32((float32x2_t)v100.u32[0], vmul_f32(v102, v102))).f32[0]);
  int8x16_t v104 = (int8x16_t)vmlaq_f32(vmulq_f32(v97, vnegq_f32(v103)), v95, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v103, (int32x4_t)v103), (int8x16_t)v103, 0xCuLL));
  float32x4_t v105 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v104, (int32x4_t)v104), v104, 0xCuLL);
  float32x4_t v106 = vmulq_f32(v75, v103);
  float32x4_t v107 = vmulq_f32(v75, v95);
  v95.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v107, 2), vaddq_f32(v107, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v107.f32, 1))).f32[0];
  int32x4_t v108 = (int32x4_t)vnegq_f32(v95);
  int32x4_t v109 = vzip1q_s32((int32x4_t)v103, v108);
  v103.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 2), vaddq_f32(v106, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v106.f32, 1))).f32[0];
  float32x4_t v175 = v75;
  float32x4_t v110 = vmulq_f32(v75, v105);
  int32x4_t v111 = vzip1q_s32((int32x4_t)v105, (int32x4_t)0);
  v105.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v110, 2), vaddq_f32(v110, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v110.f32, 1))).f32[0];
  v190.columns[3] = (simd_float4)vzip2q_s32((int32x4_t)v103, v108);
  int32x4_t v112 = vzip2q_s32((int32x4_t)v105, (int32x4_t)xmmword_1B6E4F370);
  v190.columns[0] = (simd_float4)vzip1q_s32(v109, v111);
  v190.columns[1] = (simd_float4)vzip2q_s32(v109, v111);
  v190.columns[2] = (simd_float4)vzip1q_s32((int32x4_t)v190.columns[3], v112);
  simd_float4x4 v184 = v190;
  v190.columns[3] = (simd_float4)vzip2q_s32((int32x4_t)v190.columns[3], v112);
  simd_float4x4 v191 = __invert_f4(v190);
  if (v8)
  {
    simd_float4x4 v169 = v191;
    long long v113 = xmmword_1B6E4FD20;
    if (v185.f32[1] == 0.0 && v185.f32[2] != 0.0) {
      long long v113 = xmmword_1B6E4FD30;
    }
    long long v170 = v113;
    __float2 v114 = __sincosf_stret(*(float *)&v113);
    v115.i32[0] = 0;
    v115.i32[1] = LODWORD(v114.__cosval);
    v115.i64[1] = LODWORD(v114.__sinval);
    v116.i32[0] = 0;
    v116.f32[1] = -v114.__sinval;
    v116.i64[1] = LODWORD(v114.__cosval);
    simd_float4 v167 = v116;
    simd_float4 v168 = v115;
    __float2 v117 = __sincosf_stret(*((float *)&v170 + 1));
    v118.i32[3] = 0;
    v118.i64[0] = LODWORD(v117.__cosval);
    v118.f32[2] = -v117.__sinval;
    v119.i64[0] = LODWORD(v117.__sinval);
    v119.i64[1] = LODWORD(v117.__cosval);
    float32x4_t v165 = v119;
    float32x4_t v166 = v118;
    __float2 v120 = __sincosf_stret(*((float *)&v170 + 2));
    uint64_t v121 = 0;
    v122.i32[1] = 0;
    v122.i64[1] = 0;
    v186.columns[0] = (simd_float4)xmmword_1B6E4F300;
    v186.columns[1] = v168;
    v186.columns[2] = v167;
    memset(&v187, 0, 48);
    do
    {
      v187.columns[v121] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v166, COERCE_FLOAT(*(_OWORD *)&v186.columns[v121])), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v186.columns[v121].f32, 1), v165, (float32x4_t)v186.columns[v121], 2);
      ++v121;
    }
    while (v121 != 3);
    uint64_t v123 = 0;
    float32x4_t cosval_low = (float32x4_t)LODWORD(v120.__cosval);
    cosval_low.i32[1] = LODWORD(v120.__sinval);
    cosval_low.i32[2] = 0;
    v122.f32[0] = -v120.__sinval;
    float32x4_t v125 = v122;
    v125.i32[1] = LODWORD(v120.__cosval);
    v125.i32[2] = 0;
    v186.columns[0] = v187.columns[0];
    v186.columns[1] = v187.columns[1];
    v186.columns[2] = v187.columns[2];
    memset(&v187, 0, 48);
    do
    {
      v187.columns[v123] = (simd_float4)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(cosval_low, COERCE_FLOAT(*(_OWORD *)&v186.columns[v123])), v125, *(float32x2_t *)v186.columns[v123].f32, 1), (float32x4_t)xmmword_1B6E4F2E0, (float32x4_t)v186.columns[v123], 2);
      ++v123;
    }
    while (v123 != 3);
    uint64_t v126 = 0;
    float32x4_t v127 = (float32x4_t)v187.columns[0];
    float32x4_t v128 = (float32x4_t)v187.columns[1];
    float32x4_t v129 = (float32x4_t)v187.columns[2];
    v127.i32[3] = 0;
    v128.i32[3] = 0;
    v129.i32[3] = 0;
    float32x4_t v130 = vnegq_f32(v177);
    v130.i32[3] = 1.0;
    v186.columns[0] = (simd_float4)xmmword_1B6E4F300;
    v186.columns[1] = (simd_float4)xmmword_1B6E4F320;
    v186.columns[2] = (simd_float4)xmmword_1B6E4F2E0;
    v186.columns[3] = (simd_float4)v130;
    memset(&v187, 0, sizeof(v187));
    do
    {
      v187.columns[v126] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v127, COERCE_FLOAT(*(_OWORD *)&v186.columns[v126])), v128, *(float32x2_t *)v186.columns[v126].f32, 1), v129, (float32x4_t)v186.columns[v126], 2), (float32x4_t)xmmword_1B6E4F370, (float32x4_t)v186.columns[v126], 3);
      ++v126;
    }
    while (v126 != 4);
    uint64_t v131 = 0;
    float32x4_t v132 = v177;
    v132.i32[3] = 1.0;
    simd_float4x4 v186 = v187;
    memset(&v187, 0, sizeof(v187));
    do
    {
      v187.columns[v131] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B6E4F300, COERCE_FLOAT(*(_OWORD *)&v186.columns[v131])), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v186.columns[v131].f32, 1), (float32x4_t)xmmword_1B6E4F2E0, (float32x4_t)v186.columns[v131], 2), v132, (float32x4_t)v186.columns[v131], 3);
      ++v131;
    }
    while (v131 != 4);
    uint64_t v133 = 0;
    float32x4_t v134 = (float32x4_t)v187.columns[0];
    float32x4_t v135 = (float32x4_t)v187.columns[1];
    float32x4_t v136 = (float32x4_t)v187.columns[2];
    float32x4_t v137 = (float32x4_t)v187.columns[3];
    simd_float4x4 v186 = v169;
    memset(&v187, 0, sizeof(v187));
    do
    {
      v187.columns[v133] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v134, COERCE_FLOAT(*(_OWORD *)&v186.columns[v133])), v135, *(float32x2_t *)v186.columns[v133].f32, 1), v136, (float32x4_t)v186.columns[v133], 2), v137, (float32x4_t)v186.columns[v133], 3);
      ++v133;
    }
    while (v133 != 4);
    simd_float4x4 v191 = v187;
    v184.columns[0] = v187.columns[0];
  }
  uint64_t v138 = 0;
  simd_float4x4 v186 = v191;
  memset(&v187, 0, sizeof(v187));
  do
  {
    v187.columns[v138] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v174, COERCE_FLOAT(*(_OWORD *)&v186.columns[v138])), v173, *(float32x2_t *)v186.columns[v138].f32, 1), v172, (float32x4_t)v186.columns[v138], 2), v171, (float32x4_t)v186.columns[v138], 3);
    ++v138;
  }
  while (v138 != 4);
  simd_float4x4 v184 = v187;
  sub_1B64A2614(v30, (uint64_t)&v184);
  BOOL v146 = v185.f32[0] == 0.0 && v185.f32[1] == 0.0;
  char v147 = 1;
  if (!v146) {
    char v147 = 2;
  }
  float32x4_t v180 = v178;
  int v148 = *(_DWORD *)((unint64_t)&v180 & 0xFFFFFFFFFFFFFFF3 | (4 * (v147 & 3)));
  float32x4_t v181 = v177;
  *(_DWORD *)((unint64_t)&v181 & 0xFFFFFFFFFFFFFFF3 | (4 * (v147 & 3))) = v148;
  float32x4_t v149 = v181;
  v149.i32[3] = v177.i32[3];
  float32x4_t v150 = vsubq_f32(v175, v149);
  float32x4_t v151 = vmulq_f32(v150, v150);
  float v152 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v151, 2), vaddq_f32(v151, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v151.f32, 1))).f32[0]);
  float32x4_t v153 = vsubq_f32(v175, v179);
  float32x4_t v154 = vmulq_f32(v153, v153);
  float v155 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v154, 2), vaddq_f32(v154, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v154.f32, 1))).f32[0]);
  if (v152 != 0.0 && v155 != 0.0 && (float)(v155 / v152) < 250.0)
  {
    float v156 = sqrt((float)(v155 / v152) / 250.0);
    float v152 = v152 * v156;
    float v155 = v155 / v156;
  }
  sub_1B649C9C0(v52, v155, v139, v140, v141, v142, v143, v144, v145);
  sub_1B649CAA8(v52, v152, v157, v158, v159, v160, v161, v162, v163);
  return v30;
}

uint64_t sub_1B63E0138(uint64_t a1, float32x4_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __n128 a9)
{
  __n128 v63 = a9;
  memset(v62, 0, sizeof(v62));
  uint64_t v17 = sub_1B63E0460(a1, (uint64_t)v62, a3, a4, a5, a6, a7, a8);
  if (v17)
  {
    memset(&v61, 0, sizeof(v61));
    sub_1B64A27C4(a1, (uint64_t)&v61, v11, v12, v13, v14, v15, v16);
    simd_float4x4 v61 = __invert_f4(v61);
    float32x4_t v24 = sub_1B649CD50((unsigned __int8 *)v62, (uint64_t)&v63, v18, v19, v20, v21, v22, v23);
    uint64_t v29 = 0;
    float32x4_t v30 = *(float32x4_t *)v24;
    float32x4_t v31 = *((float32x4_t *)v24 + 1);
    float32x4_t v32 = *((float32x4_t *)v24 + 2);
    float32x4_t v33 = *((float32x4_t *)v24 + 3);
    simd_float4x4 v64 = v61;
    int32x4_t v65 = 0u;
    int32x4_t v66 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    do
    {
      float32x4_t v34 = (float32x4_t)v64.columns[v29];
      *(float32x4_t *)((char *)&v65 + v29 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v30, v34.f32[0]), v31, *(float32x2_t *)v34.f32, 1), v32, v34, 2), v33, v34, 3);
      ++v29;
    }
    while (v29 != 4);
    v25.f32[0] = *(float *)&v65.i32[3] - *(float *)v65.i32;
    v25.f32[1] = *(float *)&v66.i32[3] - *(float *)v66.i32;
    v25.f32[2] = *((float *)&v67 + 3) - *(float *)&v67;
    int32x4_t v35 = (int32x4_t)vmulq_f32(v25, v25);
    v25.f32[3] = *((float *)&v68 + 3) - *(float *)&v68;
    v26.f32[0] = *(float *)&v65.i32[3] + *(float *)v65.i32;
    v26.f32[1] = *(float *)&v66.i32[3] + *(float *)v66.i32;
    v26.f32[2] = *((float *)&v67 + 3) + *(float *)&v67;
    int32x4_t v36 = (int32x4_t)vmulq_f32(v26, v26);
    v26.f32[3] = *((float *)&v68 + 3) + *(float *)&v68;
    v27.f32[0] = *(float *)&v65.i32[3] + *(float *)&v65.i32[1];
    v27.f32[1] = *(float *)&v66.i32[3] + *(float *)&v66.i32[1];
    v27.f32[2] = *((float *)&v67 + 3) + *((float *)&v67 + 1);
    float32x4_t v37 = v27;
    v37.f32[3] = *((float *)&v68 + 3) + *((float *)&v68 + 1);
    int32x4_t v38 = (int32x4_t)vmulq_f32(v27, v27);
    v28.f32[0] = *(float *)&v65.i32[3] - *(float *)&v65.i32[1];
    v28.f32[1] = *(float *)&v66.i32[3] - *(float *)&v66.i32[1];
    v28.f32[2] = *((float *)&v67 + 3) - *((float *)&v67 + 1);
    float32x4_t v39 = v28;
    v39.f32[3] = *((float *)&v68 + 3) - *((float *)&v68 + 1);
    int32x4_t v40 = (int32x4_t)vmulq_f32(v28, v28);
    v34.f32[0] = *(float *)&v65.i32[3] - *(float *)&v65.i32[2];
    v34.f32[1] = *(float *)&v66.i32[3] - *(float *)&v66.i32[2];
    v34.f32[2] = *((float *)&v67 + 3) - *((float *)&v67 + 2);
    int32x4_t v41 = (int32x4_t)vmulq_f32(v34, v34);
    v34.f32[3] = *((float *)&v68 + 3) - *((float *)&v68 + 2);
    float32x4_t v42 = (float32x4_t)vzip2q_s32(v65, v66);
    v42.i32[2] = DWORD2(v67);
    int32x4_t v43 = (int32x4_t)vmulq_f32(v42, v42);
    v42.i32[3] = DWORD2(v68);
    unsigned __int32 v44 = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v35, 2), vadd_f32(*(float32x2_t *)v35.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v35.i8, 1))).u32[0];
    float32x2_t v45 = vrsqrte_f32((float32x2_t)v44);
    float32x2_t v46 = vmul_f32(v45, vrsqrts_f32((float32x2_t)v44, vmul_f32(v45, v45)));
    float32x4_t v47 = vmulq_n_f32(v25, vmul_f32(v46, vrsqrts_f32((float32x2_t)v44, vmul_f32(v46, v46))).f32[0]);
    v46.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v36, 2), vadd_f32(*(float32x2_t *)v36.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v36.i8, 1))).u32[0];
    float32x2_t v48 = vrsqrte_f32((float32x2_t)v46.u32[0]);
    float32x2_t v49 = vmul_f32(v48, vrsqrts_f32((float32x2_t)v46.u32[0], vmul_f32(v48, v48)));
    float32x4_t v50 = vmulq_n_f32(v26, vmul_f32(v49, vrsqrts_f32((float32x2_t)v46.u32[0], vmul_f32(v49, v49))).f32[0]);
    v49.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v38, 2), vadd_f32(*(float32x2_t *)v38.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v38.i8, 1))).u32[0];
    float32x2_t v51 = vrsqrte_f32((float32x2_t)v49.u32[0]);
    float32x2_t v52 = vmul_f32(v51, vrsqrts_f32((float32x2_t)v49.u32[0], vmul_f32(v51, v51)));
    float32x4_t v53 = vmulq_n_f32(v37, vmul_f32(v52, vrsqrts_f32((float32x2_t)v49.u32[0], vmul_f32(v52, v52))).f32[0]);
    v52.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v40, 2), vadd_f32(*(float32x2_t *)v40.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v40.i8, 1))).u32[0];
    float32x2_t v54 = vrsqrte_f32((float32x2_t)v52.u32[0]);
    float32x2_t v55 = vmul_f32(v54, vrsqrts_f32((float32x2_t)v52.u32[0], vmul_f32(v54, v54)));
    float32x4_t v56 = vmulq_n_f32(v39, vmul_f32(v55, vrsqrts_f32((float32x2_t)v52.u32[0], vmul_f32(v55, v55))).f32[0]);
    v43.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v43, 2), vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v43.i8, 1))).u32[0];
    float32x2_t v57 = vrsqrte_f32((float32x2_t)v43.u32[0]);
    float32x2_t v58 = vmul_f32(v57, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v57, v57)));
    float32x4_t v59 = vmulq_n_f32(v42, vmul_f32(v58, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(v58, v58))).f32[0]);
    v43.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v41, 2), vadd_f32(*(float32x2_t *)v41.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v41.i8, 1))).u32[0];
    *(float32x2_t *)v41.i8 = vrsqrte_f32((float32x2_t)v43.u32[0]);
    *(float32x2_t *)v41.i8 = vmul_f32(*(float32x2_t *)v41.i8, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(*(float32x2_t *)v41.i8, *(float32x2_t *)v41.i8)));
    *a2 = v47;
    a2[1] = v50;
    a2[2] = v53;
    a2[3] = v56;
    a2[4] = v59;
    a2[5] = vmulq_n_f32(v34, vmul_f32(*(float32x2_t *)v41.i8, vrsqrts_f32((float32x2_t)v43.u32[0], vmul_f32(*(float32x2_t *)v41.i8, *(float32x2_t *)v41.i8))).f32[0]);
  }
  return v17;
}

uint64_t sub_1B63E0460(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"pointOfView");
  }
  CFDictionaryRef v10 = sub_1B64A3B48(a1, a2, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    uint64_t v18 = (_OWORD *)sub_1B649D3DC((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17);
    long long v20 = v18[1];
    long long v19 = v18[2];
    *(_OWORD *)a2 = *v18;
    *(_OWORD *)(a2 + 16) = v20;
    *(_OWORD *)(a2 + 32) = v19;
    long long v21 = v18[6];
    long long v23 = v18[3];
    long long v22 = v18[4];
    *(_OWORD *)(a2 + 80) = v18[5];
    *(_OWORD *)(a2 + 96) = v21;
    *(_OWORD *)(a2 + 4_Block_object_dispose(&STACK[0x2B0], 8) = v23;
    *(_OWORD *)(a2 + 64) = v22;
    long long v24 = v18[9];
    long long v25 = v18[10];
    long long v27 = v18[7];
    long long v26 = v18[8];
    *(_OWORD *)(a2 + 144) = v24;
    *(_OWORD *)(a2 + 160) = v25;
    *(_OWORD *)(a2 + 112) = v27;
    *(_OWORD *)(a2 + 12_Block_object_dispose(&STACK[0x2B0], 8) = v26;
    if ((*(unsigned char *)a2 & 4) != 0)
    {
      float v28 = *(float *)(a2 + 152);
      double v29 = v28;
      float v30 = *(float *)(a2 + 168);
      *(float *)&long long v24 = v30 / v28;
      double v31 = v30 / (v29 + 1.0);
      double v32 = (v30 + -1.0) / v29;
      if (*(float *)(a2 + 156) == 0.0) {
        double v31 = v32;
      }
      *(float *)&double v31 = v31;
      int32x2_t v33 = vcgt_f32(*(float32x2_t *)&v24, *(float32x2_t *)&v31);
      DWORD1(v24) = LODWORD(v31);
      *(int8x8_t *)(a2 + 4) = vbsl_s8((int8x8_t)vdup_lane_s32(v33, 0), (int8x8_t)vrev64_s32(*(int32x2_t *)&v24), *(int8x8_t *)&v24);
    }
    return 1;
  }
  else
  {
    uint64_t result = (uint64_t)sub_1B649F640(a1, v11, v12, v13, v14, v15, v16, v17);
    if (result)
    {
      return sub_1B64957BC(result, a2, v35, v36, v37, v38, v39, v40);
    }
  }
  return result;
}

void sub_1B63E0578(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (a2 && a4)
  {
    uint64_t v11 = sub_1B64B1FBC(a4, a2, a3, a4, a5, a6, a7, a8);
    if (v11)
    {
      long long v62 = 0u;
      float32x4_t v63 = 0u;
      char v61 = 0;
      if (sub_1B649FB70(v11, &v62, (uint64_t)&v61, a4, a5, a6, a7, a8))
      {
        uint64_t v19 = sub_1B64A01D4(a2, v12, v13, v14, v15, v16, v17, v18);
        if (v19)
        {
          uint64_t v26 = 0;
          float32x4_t v27 = *(float32x4_t *)(v19 + 48);
          float32x4_t v28 = vmlaq_f32(vmlaq_f32(vnegq_f32(*(float32x4_t *)(v19 + 32)), (float32x4_t)0, *(float32x4_t *)(v19 + 16)), (float32x4_t)0, *(float32x4_t *)v19);
          float32x4_t v29 = vmulq_f32(v28, v28);
          v29.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v29, 2), vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 1))).u64[0];
          unsigned int v30 = v29.f32[0] != 0.0;
          float32x4_t v31 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v29.f32, 0);
          v31.i32[3] = 0;
          float32x4_t v32 = vrsqrteq_f32(v31);
          float32x4_t v33 = vmulq_f32(v32, vrsqrtsq_f32(v31, vmulq_f32(v32, v32)));
          float32x4_t v34 = vmulq_f32(v33, v33);
          int32x4_t v35 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v30)), 0x1FuLL));
          v35.i32[3] = 0;
          float32x4_t v36 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v35), (int8x16_t)vmulq_f32(v28, vmulq_f32(v33, vrsqrtsq_f32(v31, v34))), (int8x16_t)v28);
          v34.f32[0] = *(float *)&v62 - v63.f32[0];
          float32x4_t v37 = v34;
          v37.f32[1] = *((float *)&v62 + 1) - v63.f32[1];
          float32x4_t v38 = v37;
          v38.f32[2] = *((float *)&v62 + 2) - v63.f32[2];
          v37.f32[2] = *((float *)&v62 + 2) + v63.f32[2];
          v34.f32[1] = *((float *)&v62 + 1) + v63.f32[1];
          float32x4_t v39 = v34;
          v39.f32[2] = *((float *)&v62 + 2) - v63.f32[2];
          v64[0] = v38;
          v64[1] = v37;
          v34.f32[2] = *((float *)&v62 + 2) + v63.f32[2];
          v64[2] = v39;
          v64[3] = v34;
          v28.f32[0] = *(float *)&v62 + v63.f32[0];
          float32x4_t v40 = v28;
          v40.f32[1] = *((float *)&v62 + 1) - v63.f32[1];
          float32x4_t v41 = v40;
          v41.f32[2] = *((float *)&v62 + 2) - v63.f32[2];
          v40.f32[2] = *((float *)&v62 + 2) + v63.f32[2];
          v64[4] = v41;
          v64[5] = v40;
          v28.f32[1] = *((float *)&v62 + 1) + v63.f32[1];
          float32x4_t v42 = v28;
          v42.f32[2] = *((float *)&v62 + 2) - v63.f32[2];
          v28.f32[2] = *((float *)&v62 + 2) + v63.f32[2];
          v64[6] = v42;
          v64[7] = v28;
          float v43 = 3.4028e38;
          float v44 = -3.4028e38;
          do
          {
            float32x4_t v45 = vmulq_f32(vsubq_f32((float32x4_t)v64[v26], v27), v36);
            float v46 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v45, 2), vaddq_f32(v45, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v45.f32, 1))).f32[0];
            if (v46 < v43) {
              float v43 = v46;
            }
            float v47 = fabsf(v46);
            if (v47 >= v44) {
              float v44 = v47;
            }
            ++v26;
          }
          while (v26 != 8);
          int8x16_t v48 = (int8x16_t)vmulq_f32(v63, v63);
          *(float *)v48.i32 = sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v48.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v48, v48, 8uLL))));
          float v49 = *(float *)v48.i32 + *(float *)v48.i32;
          float v50 = fminf(v44, 1000000.0);
          float v51 = v43 + v43 * -0.05;
          float v52 = v50 + v50 * 0.05;
          if (v49 <= v52) {
            float v49 = v52;
          }
          double v53 = fmax(v49 * 0.0001, 0.001);
          if (v53 > 1.0) {
            double v53 = 1.0;
          }
          float v54 = v53;
          if (v54 >= v51) {
            float v51 = v54;
          }
          if (v51 <= v52) {
            float v55 = v52;
          }
          else {
            float v55 = v51;
          }
          if (v61) {
            float v56 = v55 + v55;
          }
          else {
            float v56 = v55;
          }
          double v57 = v56 * 0.001;
          if (v57 <= v51) {
            float v58 = v57;
          }
          else {
            float v58 = v51;
          }
          if (v58 > v56) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. We badly computed zFar (%f) and zNear (%f) in this world", v20, v21, v22, v23, v24, v25, (uint64_t)"shortestPosition <= farthestPosition");
          }
          *(float *)(a1 + 4) = v58;
          *(float *)(a1 + _Block_object_dispose(&STACK[0x2B0], 8) = v56;
        }
        else
        {
          sub_1B63F2F54(16, @"Unreachable code: CFXAdjustZRangeOfProjectionInfos - no world matrix", v20, v21, v22, v23, v24, v25, v60);
        }
      }
      else
      {
        *(void *)(a1 + 4) = 0x447A00003DCCCCCDLL;
      }
      return;
    }
    float32x4_t v59 = @"Unreachable code: CFXAdjustZRangeOfProjectionInfos - no root node";
  }
  else
  {
    float32x4_t v59 = @"Unreachable code: CFXAdjustZRangeOfProjectionInfos - no world or no point of view";
  }

  sub_1B63F2F54(16, (uint64_t)v59, a3, a4, a5, a6, a7, a8, a9);
}

float32x4_t sub_1B63E08F4(uint64_t a1, float32x4_t *a2, __n128 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float32x4_t v17 = 0u;
  float32x4_t v18 = 0u;
  float32x4_t v15 = 0u;
  float32x4_t v16 = 0u;
  sub_1B64A27C4(a1, (uint64_t)&v15, (uint64_t)a3, a4, a5, a6, a7, a8);
  float32x4_t v10 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32(v17, *a2, 2), v16, *(float32x2_t *)a2->f32, 1), v15, COERCE_FLOAT(*a2));
  int32x4_t v11 = (int32x4_t)vmulq_f32(v10, v10);
  unsigned __int32 v12 = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v11, 2), vadd_f32(*(float32x2_t *)v11.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v11.i8, 1))).u32[0];
  *(float32x2_t *)v11.i8 = vrsqrte_f32((float32x2_t)v12);
  *(float32x2_t *)v11.i8 = vmul_f32(*(float32x2_t *)v11.i8, vrsqrts_f32((float32x2_t)v12, vmul_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)v11.i8)));
  float32x4_t result = vmulq_n_f32(v10, vmul_f32(*(float32x2_t *)v11.i8, vrsqrts_f32((float32x2_t)v12, vmul_f32(*(float32x2_t *)v11.i8, *(float32x2_t *)v11.i8))).f32[0]);
  float32x4_t v13 = vmulq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(v18, (float32x4_t)0, v17), (float32x4_t)0, v16), (float32x4_t)0, v15), result);
  result.f32[3] = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0];
  *a3 = (__n128)result;
  return result;
}

__n128 sub_1B63E09B8(__n128 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v31.n128_u32[2] = 0;
  v31.n128_u64[0] = 0;
  sub_1B64B2438(a1, &v31, a3, a4, a5, a6, a7, a8);
  float32x4_t v30 = 0uLL;
  sub_1B63E08F4(a2, (float32x4_t *)&v31, (__n128 *)&v30, v10, v11, v12, v13, v14);
  _Q0 = v30;
  float32x4_t v16 = vnegq_f32(v30);
  _S2 = vmuls_lane_f32(-2.0, v16, 2);
  _D5 = vmul_f32(*(float32x2_t *)v16.f32, (float32x2_t)0xC0000000C0000000);
  __asm { FMLS            S6, S5, V0.S[0] }
  _S7 = _D5.i32[1];
  HIDWORD(v25) = 0;
  *(void *)&long long v25 = __PAIR64__(COERCE_UNSIGNED_INT(vmuls_lane_f32(v16.f32[0], _D5, 1)), _S6);
  *((float *)&v25 + 2) = _S2 * v16.f32[0];
  __asm { FMLS            S16, S7, V0.S[1] }
  *(void *)&_Q6 = __PAIR64__(_S16, COERCE_UNSIGNED_INT(vmuls_lane_f32(_D5.f32[0], *(float32x2_t *)v16.f32, 1)));
  *((void *)&_Q6 + 1) = COERCE_UNSIGNED_INT(vmuls_lane_f32(_S2, *(float32x2_t *)v16.f32, 1));
  *(_OWORD *)a3 = v25;
  *(_OWORD *)(a3 + 16) = _Q6;
  *(float32x2_t *)&long long v28 = vmul_laneq_f32(_D5, v16, 2);
  __asm { FMLS            S6, S2, V0.S[2] }
  *((void *)&v28 + 1) = _Q6;
  result.n128_u64[0] = (unint64_t)vmul_laneq_f32(_D5, v16, 3);
  result.n128_u64[1] = __PAIR64__(1.0, COERCE_UNSIGNED_INT(vmuls_lane_f32(_S2, v16, 3)));
  *(_OWORD *)(a3 + 32) = v28;
  *(__n128 *)(a3 + 4_Block_object_dispose(&STACK[0x2B0], 8) = result;
  return result;
}

uint64_t sub_1B63E0A94(__n128 *a1, double a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
  sub_1B6447C0C((uint64_t)a1);
  __n128 v65 = sub_1B64479C4(a1);
  memset(v66, 0, sizeof(v66));
  uint64_t v14 = sub_1B6446564((uint64_t *)a1, v7, v8, v9, v10, v11, v12, v13);
  if (v14
    && (uint64_t v21 = (uint64_t)v14, sub_1B63E0460((uint64_t)v14, (uint64_t)v66, v15, v16, v17, v18, v19, v20)))
  {
    if (sub_1B649CD00(v66, v22, v23, v24, v25, v26, v27, v28))
    {
      sub_1B649CCB4((uint64_t)v66, v29, v30, v31, v32, v33, v34, v35);
    }
    else
    {
      float v44 = v65.n128_f32[2] / fmax(v65.n128_f32[3], 0.000001);
      sub_1B649C80C((unsigned __int8 *)v66, v44, v29, v30, v31, v32, v33, v34, v35);
      simd_float4x4 v69 = *(simd_float4x4 *)sub_1B64A01D4(v21, v45, v46, v47, v48, v49, v50, v51);
      simd_float4x4 v70 = __invert_f4(v69);
      uint64_t v59 = 0;
      v67[0] = a3;
      v67[1] = a4;
      v67[2] = a5;
      v67[3] = a6;
      memset(v68, 0, sizeof(v68));
      do
      {
        v68[v59] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v70.columns[0], COERCE_FLOAT(v67[v59])), (float32x4_t)v70.columns[1], *(float32x2_t *)&v67[v59], 1), (float32x4_t)v70.columns[2], (float32x4_t)v67[v59], 2), (float32x4_t)v70.columns[3], (float32x4_t)v67[v59], 3);
        ++v59;
      }
      while (v59 != 4);
      float v60 = sub_1B649CB64((uint64_t)v66, v52, v53, v54, v55, v56, v57, v58);
      sin(v60 / 180.0 * 3.14159265 * 0.5);
    }
    return sub_1B64A01D4(v21, v36, v37, v38, v39, v40, v41, v42);
  }
  else
  {
    sub_1B6447988((uint64_t)a1, 1);
    return sub_1B6447988((uint64_t)a1, 0);
  }
}

float sub_1B63E0D70(uint64_t a1, int a2, float result, float a4)
{
  if (a2 >= 1)
  {
    for (uint64_t i = 0; i != a2; *(void *)(a1 + 8 * i++) = v14)
    {
      if (i)
      {
        float v5 = 0.5;
        float v6 = 0.0;
        unsigned int v7 = i;
        do
        {
          if (v7) {
            float v8 = v5;
          }
          else {
            float v8 = -0.0;
          }
          float v6 = v6 + v8;
          float v5 = v5 * 0.5;
          BOOL v9 = v7 > 1;
          v7 >>= 1;
        }
        while (v9);
        float v10 = 0.0;
        int v11 = i;
        float v12 = 0.33333;
        do
        {
          if (v11 != 3 * (v11 / 3)) {
            float v10 = v10 + (float)((float)(v11 % 3) * v12);
          }
          float v12 = v12 * 0.33333;
          unsigned int v13 = v11 + 2;
          v11 /= 3;
        }
        while (v13 > 4);
      }
      else
      {
        float v6 = 0.0;
        float v10 = 0.0;
      }
      *(float *)&uint64_t v14 = (float)((float)(v6 * 2.0) + -1.0) * result;
      *((float *)&v14 + 1) = (float)((float)(v10 * 2.0) + -1.0) * a4;
    }
  }
  return result;
}

float32x4_t *sub_1B63E0E48(float32x4_t *result, int a2, float a3, float a4, float a5)
{
  if (a2 >= 1)
  {
    for (uint64_t i = 0; i != a2; result[i++] = v16)
    {
      if (i)
      {
        float v6 = 0.5;
        float v7 = 0.0;
        unsigned int v8 = i;
        do
        {
          if (v8) {
            float v9 = v6;
          }
          else {
            float v9 = -0.0;
          }
          float v7 = v7 + v9;
          float v6 = v6 * 0.5;
          BOOL v10 = v8 > 1;
          v8 >>= 1;
        }
        while (v10);
        float v11 = 0.0;
        int v12 = i;
        float v13 = 0.33333;
        do
        {
          if (v12 != 3 * (v12 / 3)) {
            float v11 = v11 + (float)((float)(v12 % 3) * v13);
          }
          float v13 = v13 * 0.33333;
          unsigned int v14 = v12 + 2;
          v12 /= 3;
        }
        while (v14 >= 5);
        float32_t v15 = (float)((float)(v7 * 2.0) + -1.0) * a3;
        float32x4_t v16 = result[i];
        v16.f32[0] = v15;
        v16.f32[1] = (float)((float)(v11 * 2.0) + -1.0) * a4;
      }
      else
      {
        v16.i64[0] = 0;
        v16.i64[1] = result->i64[1];
        const UInt8 *result = v16;
      }
      v16.i64[1] = COERCE_UNSIGNED_INT(sqrtf(vmlas_n_f32(COERCE_FLOAT(vmulq_f32(v16, v16).i32[1]), v16.f32[0], v16.f32[0])) * a5);
    }
  }
  return result;
}

uint64_t sub_1B63E0F4C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  MEMORY[0x1F4188790](a1, a2);
  float v13 = &v60 - 2 * v6;
  if (v6 < 1) {
    return 0;
  }
  unsigned int v14 = 0;
  uint64_t v15 = 0;
  float32x4_t v16 = v13 + 1;
  do
  {
    *(v16 - 1) = sub_1B641D478(*(void *)(a1 + 8 * v15), v6, v7, v8, v9, v10, v11, v12);
    *float32x4_t v16 = v6;
    if (v14)
    {
      if (v14 != v6)
      {
        sub_1B63F2F54(16, @"Error: Given sources must be of the same length for interval list creation", v7, v8, v9, v10, v11, v12, v60);
        return 0;
      }
    }
    else
    {
      unsigned int v14 = v6;
    }
    ++v15;
    v16 += 2;
  }
  while (a2 != v15);
  if (!v14) {
    return 0;
  }
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  int v22 = 0;
  simd_float4x4 v64 = v13;
  uint64_t v23 = (unsigned __int8 *)v13 + 13;
  char v24 = 1;
  do
  {
    if (a2 < 1)
    {
      uint64_t v25 = 0;
    }
    else
    {
      uint64_t v25 = 0;
      uint64_t v26 = v23;
      while (1)
      {
        v27.i64[0] = COERCE_UNSIGNED_INT64(sub_1B65D6198(*(v26 - 1), (const float *)(*(void *)(v26 - 13) + v22 * *v26), v7, v8, v9, v10, v11, v12, v17, v18.f32[0], v19)) & 0x7FFFFFFF7FFFFFFFLL;
        v27.i64[1] &= 0x7FFFFFFF7FFFFFFFuLL;
        v18.i64[0] = 0x3400000034000000;
        v18.i64[1] = 0x3400000034000000;
        float32x4_t v17 = (float32x4_t)vcgeq_f32(v27, v18);
        v17.i32[0] = vmaxvq_u32((uint32x4_t)v17);
        if (v17.i32[0] < 0) {
          break;
        }
        ++v25;
        v26 += 16;
        if (a2 == v25) {
          goto LABEL_17;
        }
      }
    }
    if (v25 == a2)
    {
LABEL_17:
      v24 |= v20++ > a3;
    }
    else
    {
      uint64_t v20 = 0;
      v21 += v24 & 1;
      char v24 = 0;
    }
    ++v22;
  }
  while (v22 != v14);
  if (!v21) {
    return 0;
  }
  if (v14 >= 0xFFFF) {
    int v28 = 4;
  }
  else {
    int v28 = 2;
  }
  char v29 = 1;
  if (v14 >= 0xFFFF) {
    char v29 = 2;
  }
  size_t v30 = 2 * (v21 << v29);
  float32x4_t v63 = (UInt8 *)malloc_type_malloc(v30, 0x3EA1A8D3uLL);
  CFIndex v61 = v30;
  int v62 = v28;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  simd_float4x4 v64 = (uint64_t *)((char *)v64 + 13);
  char v43 = 1;
  do
  {
    if (a2 < 1)
    {
      uint64_t v44 = 0;
    }
    else
    {
      uint64_t v44 = 0;
      uint64_t v45 = v64;
      while (1)
      {
        v46.i64[0] = COERCE_UNSIGNED_INT64(sub_1B65D6198(*((unsigned __int8 *)v45 - 1), (const float *)(*(uint64_t *)((char *)v45 - 13) + v40 * *(unsigned __int8 *)v45), v31, v32, v33, v34, v35, v36, v37, v38.f32[0], v39)) & 0x7FFFFFFF7FFFFFFFLL;
        v46.i64[1] &= 0x7FFFFFFF7FFFFFFFuLL;
        v38.i64[0] = 0x3400000034000000;
        v38.i64[1] = 0x3400000034000000;
        float32x4_t v37 = (float32x4_t)vcgeq_f32(v46, v38);
        v37.i32[0] = vmaxvq_u32((uint32x4_t)v37);
        if (v37.i32[0] < 0) {
          break;
        }
        ++v44;
        v45 += 2;
        if (a2 == v44) {
          goto LABEL_34;
        }
      }
    }
    if (v44 == a2)
    {
LABEL_34:
      if (!(v43 & 1 | (v41 <= a3)))
      {
        if (v14 > 0xFFFE) {
          *(_DWORD *)&v63[8 * v42 + 4] = v40 - v41;
        }
        else {
          *(_WORD *)&v63[4 * v42 + 2] = v40 - v41;
        }
        ++v42;
        char v43 = 1;
      }
      ++v41;
    }
    else if (v43)
    {
      uint64_t v41 = 0;
      char v43 = 0;
      if (v14 > 0xFFFE) {
        *(_DWORD *)&v63[8 * v42] = v40;
      }
      else {
        *(_WORD *)&v63[4 * v42] = v40;
      }
    }
    else
    {
      uint64_t v41 = 0;
      char v43 = 0;
    }
    ++v40;
  }
  while (v40 != v14);
  if (v43)
  {
    char v49 = v62;
    CFIndex v50 = v61;
  }
  else
  {
    uint64_t v51 = (2 * v42) | 1;
    if (v14 > 0xFFFE) {
      *(_DWORD *)&v63[4 * v51] = v14 - v41;
    }
    else {
      *(_WORD *)&v63[2 * v51] = v14 - v41;
    }
    char v49 = v62;
    CFIndex v50 = v61;
    LODWORD(v42) = v42 + 1;
  }
  uint64_t v52 = v63;
  CFDataRef v53 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v63, v50);
  free(v52);
  uint64_t v47 = sub_1B63D0314();
  sub_1B63D04D0(v47, 2, v54, v55, v56, v57, v58, v59);
  sub_1B63D0E24(v47, v42, v53, v49);
  CFRelease(v53);
  return v47;
}

void sub_1B63E1308(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t a9, __n128 a10, int8x16_t a11, int8x16_t a12)
{
  unsigned int v14 = (unsigned char *)a3;
  a11.i32[0] = a10.n128_i32[2];
  a12.i32[0] = 1.0;
  v16.i64[0] = 0x8000000080000000;
  v16.i64[1] = 0x8000000080000000;
  v16.i32[0] = vbslq_s8(v16, a12, a11).i32[0];
  float v17 = a10.n128_f32[1] / (float)(fabsf(a10.n128_f32[2]) + 1.0);
  float v18 = vmuls_lane_f32(v17, (float32x2_t)a10.n128_u64[0], 1);
  v12.f32[0] = -(float)(a10.n128_f32[0] * v17);
  v13.f32[0] = a10.n128_f32[2] + (float)(*(float *)v16.i32 * v18);
  v24.f32[0] = *(float *)v16.i32 * v12.f32[0];
  v13.f32[1] = *(float *)v16.i32 * v12.f32[0];
  v25.f32[0] = -a10.n128_f32[0];
  v13.f32[2] = -a10.n128_f32[0];
  float32_t v19 = 1.0 - v18;
  float32x4_t v20 = vmulq_f32(a9, v13);
  v23.f32[1] = -v13.f32[0];
  v23.f32[2] = v12.f32[0];
  v12.f32[1] = 1.0 - v18;
  v12.i32[2] = vmuls_lane_f32(-*(float *)v16.i32, (float32x2_t)a10.n128_u64[0], 1);
  float v21 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v20, 2), vaddq_f32(v20, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v20.f32, 1))).f32[0];
  v26.f32[0] = -v21;
  float32x4_t v22 = vmulq_f32(a9, v12);
  v22.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v22, 2), vaddq_f32(v22, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v22.f32, 1))).f32[0];
  v23.f32[3] = -(float)(v17 * (float)-a10.n128_f32[0]);
  v24.f32[1] = -(float)(*(float *)v16.i32 * v12.f32[0]);
  v24.f32[2] = v19;
  v24.f32[3] = -v19;
  v25.i32[1] = a10.n128_u32[0];
  v25.i32[2] = v12.i32[2];
  v25.f32[3] = -(float)(a10.n128_f32[1] * (float)-*(float *)v16.i32);
  v26.f32[1] = v21;
  v26.f32[2] = -v22.f32[0];
  v26.i32[3] = v22.i32[0];
  uint64_t v27 = a2;
  if ((a2 & 0xFF000000000000) == 0x1000000000000)
  {
    if (a2)
    {
      uint64_t v28 = 0;
      float32x4_t v29 = vnegq_f32(v26);
      do
      {
        int8x16_t v30 = (int8x16_t)vcgtq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v24, *(float *)(a1 + v28 + 4)), v23, *(float *)(a1 + v28)), v25, *(float *)(a1 + v28 + 8)), v29);
        int8x8_t v31 = vand_s8((int8x8_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL), (int8x8_t)0x800000004);
        *v14++ = v30.i8[4] & 2 | (v30.i32[0] < 0) | v31.i8[0] | v31.i8[4];
        v28 += BYTE5(a2);
        --v27;
      }
      while (v27);
    }
  }
  else if (a2)
  {
    unsigned int v32 = 0;
    int v33 = BYTE4(a2);
    int v34 = BYTE5(a2);
    float32x4_t v35 = vnegq_f32(v26);
    float32x4_t v37 = v35;
    float32x4_t v39 = v24;
    float32x4_t v40 = v23;
    float32x4_t v38 = v25;
    do
    {
      *(double *)v36.i64 = sub_1B65D6198(v33, (const float *)(a1 + v32), a3, a4, a5, a6, a7, a8, v35, a10.n128_f32[0], v26.f32[0]);
      float32x4_t v35 = (float32x4_t)vcgtq_f32(vmlaq_laneq_f32(vmlaq_n_f32(vmulq_lane_f32(v39, *(float32x2_t *)v36.f32, 1), v40, v36.f32[0]), v38, v36, 2), v37);
      a10.n128_u64[0] = (unint64_t)vand_s8((int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)v35, (int8x16_t)v35, 8uLL), (int8x8_t)0x800000004);
      *v14++ = v35.i8[4] & 2 | (v35.i32[0] < 0) | a10.n128_u8[0] | a10.n128_u8[4];
      v32 += v34;
      --v27;
    }
    while (v27);
  }
}

void sub_1B63E151C(void *a1, CFArrayRef theArray, uint64_t a3)
{
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count)
  {
    uint64_t v7 = Count;
    uint64_t v8 = *(void *)CFArrayGetValueAtIndex(theArray, 0);
    BOOL v16 = sub_1B63D0C54(v8, v9, v10, v11, v12, v13, v14, v15);
    int v24 = sub_1B63D0C08(v8, v17, v18, v19, v20, v21, v22, v23);
    if (v24 == 2) {
      uint64_t v25 = 2;
    }
    else {
      uint64_t v25 = 3;
    }
    uint64_t bytes = v25;
    if (*(unsigned char *)(a3 + 8))
    {
      char v125 = v16;
      int v128 = v24;
      if (v7 < 1)
      {
        uint64_t v28 = 0;
        uint64_t v26 = 0;
      }
      else
      {
        uint64_t v26 = 0;
        CFIndex v27 = 0;
        uint64_t v28 = 0;
        do
        {
          ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(theArray, v27);
          if ((void *)ValueAtIndex[2] != a1) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. different material!!!!", v29, v30, v31, v32, v33, v34, (uint64_t)"material == elt->material");
          }
          uint64_t v36 = *ValueAtIndex;
          uint64_t v37 = sub_1B63D11E8(*ValueAtIndex);
          if (v27 < v7 - 1 && v128 == 1)
          {
            if (sub_1B63D11E8(v36)) {
              v28 += 3;
            }
            else {
              v28 += 2;
            }
          }
          v26 += v37;
          ++v27;
        }
        while (v7 != v27);
      }
      uint64_t v75 = v28 + 2 * v7 + v26;
      if (v128 == 1)
      {
        uint64_t v76 = v75 - 2;
      }
      else
      {
        uint64_t v75 = v26 * bytes;
        uint64_t v76 = v26;
      }
      CFIndex length = v75 * *(unsigned int *)(a3 + 12);
      uint64_t v124 = v76;
      bytesa = (UInt8 *)sub_1B63CA51C(length);
      if (v7 >= 1)
      {
        CFIndex v77 = 0;
        uint64_t v78 = (uint64_t)bytesa;
        do
        {
          uint64_t v79 = (uint64_t *)CFArrayGetValueAtIndex(theArray, v77);
          uint64_t v80 = *v79;
          int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), v79);
          uint64_t v82 = (char *)sub_1B63E1978(v78, v80, Value, *(_DWORD *)(a3 + 12));
          uint64_t v78 = (uint64_t)v82;
          if (v128 == 1 && v77 < v7 - 1)
          {
            memcpy(v82, &v82[-*(unsigned int *)(a3 + 12)], *(unsigned int *)(a3 + 12));
            uint64_t v83 = (_WORD *)(v78 + *(unsigned int *)(a3 + 12));
            if (sub_1B63D11E8(v80))
            {
              memcpy(v83, (char *)v83 - *(unsigned int *)(a3 + 12), *(unsigned int *)(a3 + 12));
              uint64_t v83 = (_WORD *)((char *)v83 + *(unsigned int *)(a3 + 12));
            }
            uint64_t v84 = (uint64_t *)CFArrayGetValueAtIndex(theArray, ++v77);
            uint64_t v85 = *v84;
            unsigned int v90 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), v84);
            int v91 = *(_DWORD *)(a3 + 12);
            if (v91 == 2)
            {
              *uint64_t v83 = sub_1B63D14A0(v85, 0, 0, 0, v86, v87, v88, v89) + v90;
            }
            else if (v91 == 4)
            {
              *(_DWORD *)uint64_t v83 = sub_1B63D14A0(v85, 0, 0, 0, v86, v87, v88, v89) + v90;
            }
            else
            {
              *(unsigned char *)uint64_t v83 = sub_1B63D14A0(v85, 0, 0, 0, v86, v87, v88, v89) + v90;
            }
            uint64_t v78 = (uint64_t)v83 + *(unsigned int *)(a3 + 12);
          }
          else
          {
            ++v77;
          }
        }
        while (v77 != v7);
      }
      CFDataRef v92 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytesa, length, (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
      float32x2_t v93 = (const void *)sub_1B63D0314();
      sub_1B63D0D7C((uint64_t)v93, v125, v94, v95, v96, v97, v98, v99);
      sub_1B63D05D4((uint64_t)v93, v128, v124, v92, *(unsigned int *)(a3 + 12), v100, v101, v102);
      CFRelease(v92);
      uint64_t v110 = sub_1B63CCE68(*(void *)a3, v103, v104, v105, v106, v107, v108, v109);
      sub_1B64AD1E8(v110, v93, v111, v112, v113, v114, v115, v116);
      CFRelease(v93);
      if (a1) {
        sub_1B63CE298(*(void *)a3, a1, v117, v118, v119, v120, v121, v122);
      }
    }
    else if (v7 >= 1)
    {
      CFIndex v38 = 0;
      CFAllocatorRef v39 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      do
      {
        float32x4_t v40 = (uint64_t *)CFArrayGetValueAtIndex(theArray, v38);
        uint64_t v41 = *v40;
        uint64_t v42 = sub_1B63D11E8(*v40) * bytes * *(unsigned int *)(a3 + 12);
        char v43 = (const UInt8 *)sub_1B63CA51C(v42);
        int v44 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 16), v40);
        sub_1B63E1978((uint64_t)v43, v41, v44, *(_DWORD *)(a3 + 12));
        uint64_t v52 = (const void *)sub_1B63D05E8(v41, v45, v46, v47, v48, v49, v50, v51);
        CFDataRef v53 = CFDataCreateWithBytesNoCopy(v39, v43, v42, v39);
        int v54 = sub_1B63D11E8((uint64_t)v52);
        sub_1B63D0E24((uint64_t)v52, v54, v53, *(_DWORD *)(a3 + 12));
        CFRelease(v53);
        uint64_t v62 = sub_1B63CCE68(*(void *)a3, v55, v56, v57, v58, v59, v60, v61);
        sub_1B64AD1E8(v62, v52, v63, v64, v65, v66, v67, v68);
        CFRelease(v52);
        if (a1) {
          sub_1B63CE298(*(void *)a3, a1, v69, v70, v71, v72, v73, v74);
        }
        ++v38;
      }
      while (v7 != v38);
    }
    sub_1B63DBAB8(theArray);
  }
}

uint64_t sub_1B63E1978(uint64_t a1, uint64_t a2, int a3, int a4)
{
  int v44 = 0;
  uint64_t v8 = sub_1B63D11E8(a2);
  if (sub_1B63D0C08(a2, v9, v10, v11, v12, v13, v14, v15) == 2) {
    uint64_t v16 = 2;
  }
  else {
    uint64_t v16 = 3;
  }
  sub_1B63D0F38(a2, &v44);
  if (sub_1B63D0C08(a2, v17, v18, v19, v20, v21, v22, v23) == 1)
  {
    if (a4 == 2)
    {
      if (v8 < -1)
      {
        uint64_t v34 = 0;
      }
      else
      {
        unint64_t v33 = 0;
        uint64_t v34 = v8 + 2;
        do
        {
          *(_WORD *)(a1 + 2 * v33) = sub_1B63D14A0(a2, 3 * (v33 / 3), v33 % 3, 0, v24, v25, v26, v27) + a3;
          ++v33;
        }
        while (v34 != v33);
      }
      return a1 + 2 * v34;
    }
    else if (a4 == 1)
    {
      if (v8 < -1)
      {
        uint64_t v29 = 0;
      }
      else
      {
        unint64_t v28 = 0;
        uint64_t v29 = v8 + 2;
        do
        {
          *(unsigned char *)(a1 + v2_Block_object_dispose(&STACK[0x2B0], 8) = sub_1B63D14A0(a2, 3 * (v28 / 3), v28 % 3, 0, v24, v25, v26, v27) + a3;
          ++v28;
        }
        while (v29 != v28);
      }
      return a1 + v29;
    }
    else
    {
      if (v8 < -1)
      {
        uint64_t v36 = 0;
      }
      else
      {
        unint64_t v35 = 0;
        uint64_t v36 = v8 + 2;
        do
        {
          *(_DWORD *)(a1 + 4 * v35) = sub_1B63D14A0(a2, 3 * (v35 / 3), v35 % 3, 0, v24, v25, v26, v27) + a3;
          ++v35;
        }
        while (v36 != v35);
      }
      return a1 + 4 * v36;
    }
  }
  else if (a4 == 1)
  {
    if (v8 < 1)
    {
      uint64_t v37 = 0;
    }
    else
    {
      uint64_t v37 = 0;
      for (uint64_t i = 0; i != v8; ++i)
      {
        for (uint64_t j = 0; j != v16; ++j)
          *(unsigned char *)(a1 + v37 + j) = sub_1B63D14A0(a2, i, j, 0, v24, v25, v26, v27) + a3;
        v37 += j;
      }
    }
    return a1 + v37;
  }
  else if (a4 == 2)
  {
    if (v8 < 1)
    {
      uint64_t v30 = 0;
    }
    else
    {
      uint64_t v30 = 0;
      for (uint64_t k = 0; k != v8; ++k)
      {
        for (uint64_t m = 0; m != v16; ++m)
          *(_WORD *)(a1 + 2 * v30 + 2 * m) = sub_1B63D14A0(a2, k, m, 0, v24, v25, v26, v27) + a3;
        v30 += m;
      }
    }
    return a1 + 2 * v30;
  }
  else
  {
    if (v8 < 1)
    {
      uint64_t v40 = 0;
    }
    else
    {
      uint64_t v40 = 0;
      for (uint64_t n = 0; n != v8; ++n)
      {
        for (iuint64_t i = 0; ii != v16; ++ii)
          *(_DWORD *)(a1 + 4 * v40 + 4 * ii) = sub_1B63D14A0(a2, n, ii, 0, v24, v25, v26, v27) + a3;
        v40 += ii;
      }
    }
    return a1 + 4 * v40;
  }
}

uint64_t sub_1B63E1C5C(uint64_t result, uint64_t a2, unsigned __int8 a3)
{
  if ((a3 & 0xFD) == 0)
  {
    uint64_t v3 = result;
    unsigned int v4 = a3;
    uint64_t v5 = *(void *)(*(void *)(result + 32) + 8 * a3 + 72);
    __n128 result = sub_1B641E2F4(a2);
    if (v5 <= result) {
      uint64_t v6 = result;
    }
    else {
      uint64_t v6 = v5;
    }
    *(void *)(*(void *)(v3 + 32) + 8 * v4 + 72) = v6;
  }
  return result;
}

void sub_1B63E1CC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  CFArrayRef v13 = sub_1B64ABD08(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v21 = sub_1B641D8A0(a3, v14, v15, v16, v17, v18, v19, v20);
  uint64_t v29 = sub_1B641D478(a2, v22, v23, v24, v25, v26, v27, v28);
  uint64_t v99 = v30;
  uint64_t v100 = v29;
  uint64_t v44 = sub_1B641D478(a3, v30, v31, v32, v33, v34, v35, v36);
  uint64_t v101 = v37;
  if (v8) {
    uint64_t v48 = sub_1B65E2DE0(a2, v37, v38, v39, v40, v41, v42, v43);
  }
  else {
    uint64_t v48 = 0;
  }
  int v49 = BYTE4(v101);
  int v50 = BYTE5(v101);
  uint64_t v98 = v21;
  if (v21)
  {
    unsigned int v51 = 0;
    uint64_t v52 = v98;
    do
    {
      sub_1B65D6678(BYTE4(v101), v44 + v51, v38, v39, v40, v41, v42, v43, (float32x4_t)0);
      v51 += BYTE5(v101);
      --v52;
    }
    while (v52);
  }
  if ((uint64_t)v13 >= 1)
  {
    for (CFIndex i = 0; (const __CFArray *)i != v13; ++i)
    {
      uint64_t v60 = sub_1B64ABD78(a1, i, a4, v39, v40, v41, v42, v43);
      if (a4) {
        uint64_t v61 = 0;
      }
      else {
        uint64_t v61 = sub_1B64ACE9C(a1, 0, 0, v55, v56, v57, v58, v59);
      }
      uint64_t v109 = 0;
      long long v107 = 0u;
      long long v108 = 0u;
      long long v106 = 0u;
      sub_1B63D11F0((uint64_t)v60, v61, v54, v55, v56, v57, v58, v59, (uint64_t)&v106);
      if ((BYTE10(v107) & 0xFA) != 0)
      {
        sub_1B63F2F54(0, @"Warning: CFXUnifyNormalsFromGeometry can only process triangles and polygons", v62, v63, v64, v65, v66, v67, v98);
      }
      else
      {
        v105[0] = MEMORY[0x1E4F143A8];
        v105[1] = 3221225472;
        v105[2] = sub_1B63E213C;
        v105[3] = &unk_1E6141168;
        v105[4] = v100;
        v105[5] = v99;
        v105[6] = v48;
        v105[7] = v44;
        v105[8] = v101;
        v103[0] = v106;
        v103[1] = v107;
        v103[2] = v108;
        uint64_t v104 = v109;
        sub_1B63D1BEC((uint64_t *)v103, (uint64_t)v105, v62, v63, v64, v65, v66, v67);
      }
    }
  }
  if (v48 && v98)
  {
    unsigned int v68 = 0;
    uint64_t v69 = 0;
    do
    {
      uint64_t v70 = v48[v69];
      if (v69 != v70)
      {
        *(double *)v71.i64 = sub_1B65D6198(BYTE4(v101), (const float *)(v44 + v70 * BYTE5(v101)), v38, v39, v40, v41, v42, v43, v45, v46, v47);
        sub_1B65D6678(BYTE4(v101), v44 + v68, v72, v73, v74, v75, v76, v77, v71);
      }
      ++v69;
      v68 += BYTE5(v101);
    }
    while (v98 != v69);
  }
  if (v98)
  {
    unsigned int v78 = 0;
    uint64_t v79 = v98;
    __asm { FMOV            V0.4S, #1.0 }
    int8x16_t v102 = (int8x16_t)_Q0;
    do
    {
      *(double *)v85.i64 = sub_1B65D6198(v49, (const float *)(v44 + v78), v38, v39, v40, v41, v42, v43, _Q0, v46, v47);
      float32x4_t v86 = vmulq_f32(v85, v85);
      v86.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v86, 2), vaddq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v86.f32, 1))).u64[0];
      float32x4_t v87 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v86.f32, 0);
      v87.i32[3] = 0;
      float32x4_t v88 = vrsqrteq_f32(v87);
      float32x4_t v89 = vmulq_f32(v88, vrsqrtsq_f32(v87, vmulq_f32(v88, v88)));
      int32x4_t v90 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v86.f32[0] != 0.0)), 0x1FuLL));
      v90.i32[3] = 0;
      float32x4_t v91 = vmulq_f32(v85, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v90), (int8x16_t)vmulq_f32(v89, vrsqrtsq_f32(v87, vmulq_f32(v89, v89))), v102));
      v91.i32[3] = v85.i32[3];
      sub_1B65D6678(v49, v44 + v78, v92, v93, v94, v95, v96, v97, v91);
      v78 += v50;
      --v79;
    }
    while (v79);
  }
  free(v48);
}

void sub_1B63E1FC0(uint64_t a1, float32x4_t a2, float32x4_t a3, double a4, float32x4_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  unsigned int v12 = a8;
  CFArrayRef v13 = (unsigned int *)a7;
  if (a8 > 2
    || (sub_1B63F2F54(17, @"Assertion '%s' failed. unexpected vertex count", a7, a8, a9, a10, a11, a12, (uint64_t)"faceVertexCount >= 3"), v12))
  {
    unsigned int v15 = *(_DWORD *)(a1 + 72);
    uint64_t v16 = *(void *)(a1 + 32);
    unsigned int v17 = v13[1];
    if (v15 < v17) {
      unsigned int v17 = *(_DWORD *)(a1 + 72);
    }
    int v18 = *(unsigned __int8 *)(a1 + 45);
    uint64_t v19 = v16 + v17 * v18;
    a2.i64[0] = *(void *)v19;
    a2.i32[2] = *(_DWORD *)(v19 + 8);
    if (v15 >= *v13) {
      unsigned int v20 = *v13;
    }
    else {
      unsigned int v20 = *(_DWORD *)(a1 + 72);
    }
    uint64_t v21 = v16 + v20 * v18;
    a3.i64[0] = *(void *)v21;
    a3.i32[2] = *(_DWORD *)(v21 + 8);
    float32x4_t v22 = vsubq_f32(a2, a3);
    int8x16_t v23 = (int8x16_t)vuzp1q_s32((int32x4_t)v22, (int32x4_t)v22);
    unsigned int v24 = v13[2];
    if (v15 < v24) {
      unsigned int v24 = *(_DWORD *)(a1 + 72);
    }
    uint64_t v25 = v16 + v24 * v18;
    a5.i64[0] = *(void *)v25;
    a5.i32[2] = *(_DWORD *)(v25 + 8);
    float32x4_t v26 = vsubq_f32(a5, a3);
    int8x16_t v27 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v26, (int32x4_t)v26), (int8x16_t)v26, 0xCuLL), vnegq_f32(v22)), v26, (float32x4_t)vextq_s8(v23, (int8x16_t)v22, 0xCuLL));
    float32x4_t v28 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27), v27, 0xCuLL);
    float32x4_t v29 = v28;
    v29.i32[3] = 0;
    int8x16_t v30 = (int8x16_t)vmulq_f32(v29, v29);
    *(float32x2_t *)v30.i8 = vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v30, v30, 8uLL));
    float32x4_t v31 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v30.i8, 1)), 0);
    int8x16_t v32 = (int8x16_t)vceqzq_f32(v31);
    float32x4_t v33 = vrsqrteq_f32(v31);
    float32x4_t v34 = vmulq_f32(v33, vrsqrtsq_f32(v31, vmulq_f32(v33, v33)));
    int8x16_t v35 = (int8x16_t)vmulq_f32(v34, vrsqrtsq_f32(v31, vmulq_f32(v34, v34)));
    __asm { FMOV            V3.4S, #1.0 }
    float32x4_t v41 = (float32x4_t)vbslq_s8(v32, _Q3, v35);
    float32x4_t v42 = vmulq_f32(v28, v41);
    uint64_t v43 = *(void *)(a1 + 48);
    uint64_t v44 = *(void *)(a1 + 56);
    int v45 = *(unsigned __int8 *)(a1 + 69);
    uint64_t v46 = v12;
    do
    {
      unsigned int v48 = *v13++;
      unsigned int v47 = v48;
      if (v15 < v48) {
        unsigned int v47 = v15;
      }
      if (v43) {
        unsigned int v47 = *(_DWORD *)(v43 + 4 * v47);
      }
      uint64_t v49 = v44 + v47 * v45;
      v41.i64[0] = *(void *)v49;
      v41.i32[2] = *(_DWORD *)(v49 + 8);
      float32x4_t v41 = vaddq_f32(v42, v41);
      *(void *)uint64_t v49 = v41.i64[0];
      *(_DWORD *)(v49 + _Block_object_dispose(&STACK[0x2B0], 8) = v41.i32[2];
      --v46;
    }
    while (v46);
  }
}

void sub_1B63E213C(uint64_t a1, float32x4_t a2, float a3, float a4, uint64_t a5, unsigned int *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unsigned int v11 = a7;
  unsigned int v12 = a6;
  *(double *)v14.i64 = sub_1B65D6198(*(unsigned __int8 *)(a1 + 44), (const float *)(*(void *)(a1 + 32) + *a6 * *(unsigned __int8 *)(a1 + 45)), (uint64_t)a6, a7, a8, a9, a10, a11, a2, a3, a4);
  float32x4_t v67 = v14;
  *(double *)v23.i64 = sub_1B65D6198(*(unsigned __int8 *)(a1 + 44), (const float *)(*(void *)(a1 + 32) + v12[1] * *(unsigned __int8 *)(a1 + 45)), v15, v16, v17, v18, v19, v20, v14, v21, v22);
  float32x4_t v66 = v23;
  *(double *)v38.i64 = sub_1B65D6198(*(unsigned __int8 *)(a1 + 44), (const float *)(*(void *)(a1 + 32) + v12[2] * *(unsigned __int8 *)(a1 + 45)), v24, v25, v26, v27, v28, v29, v23, v30, v31);
  if (v11)
  {
    float32x4_t v39 = vsubq_f32(v66, v67);
    float32x4_t v40 = vsubq_f32(v38, v67);
    int8x16_t v41 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v40, (int32x4_t)v40), (int8x16_t)v40, 0xCuLL), vnegq_f32(v39)), v40, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v39, (int32x4_t)v39), (int8x16_t)v39, 0xCuLL));
    float32x4_t v42 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v41, (int32x4_t)v41), v41, 0xCuLL);
    v42.i32[3] = 0;
    int8x16_t v43 = (int8x16_t)vmulq_f32(v42, v42);
    *(float32x2_t *)v43.i8 = vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v43, v43, 8uLL));
    float32x4_t v44 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v43.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v43.i8, 1)), 0);
    float32x4_t v45 = vrsqrteq_f32(v44);
    float32x4_t v46 = vmulq_f32(v45, vrsqrtsq_f32(v44, vmulq_f32(v45, v45)));
    int8x16_t v47 = (int8x16_t)vmulq_f32(v46, vrsqrtsq_f32(v44, vmulq_f32(v46, v46)));
    __asm { FMOV            V3.4S, #1.0 }
    float32x4_t v53 = (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v44), _Q3, v47);
    float32x4_t v54 = vmulq_f32(v42, v53);
    float32x4_t v68 = v54;
    uint64_t v55 = v11;
    do
    {
      uint64_t v56 = *(void *)(a1 + 48);
      uint64_t v57 = v12;
      if (v56) {
        uint64_t v57 = (_DWORD *)(v56 + 4 * *v12);
      }
      uint64_t v58 = (const float *)(*(void *)(a1 + 56) + *v57 * *(unsigned __int8 *)(a1 + 69));
      *(double *)v59.i64 = sub_1B65D6198(*(unsigned __int8 *)(a1 + 68), v58, v32, v33, v34, v35, v36, v37, v54, v53.f32[0], *(float *)v47.i32);
      sub_1B65D6678(*(unsigned __int8 *)(a1 + 68), (uint64_t)v58, v60, v61, v62, v63, v64, v65, vaddq_f32(v68, v59));
      ++v12;
      --v55;
    }
    while (v55);
  }
}

uint64_t sub_1B63E22B4(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  switch(a3)
  {
    case 2:
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result + 56))(result, a2, a4 + 8);
    case 1:
      return (*(uint64_t (**)(void))(*(void *)result + 48))();
    case 0:
      return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t sub_1B63E233C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  int v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA660, memory_order_acquire) & 1) == 0)
  {
    uint64_t v27 = a2;
    uint64_t v28 = a3;
    int v26 = __cxa_guard_acquire(&qword_1E9DDA660);
    int v8 = &unk_1E9DDA000;
    a2 = v27;
    a3 = v28;
    if (v26)
    {
      byte_1E9DDA658 = 1;
      __cxa_guard_release(&qword_1E9DDA660);
      int v8 = (unsigned char *)&unk_1E9DDA000;
      a2 = v27;
      a3 = v28;
    }
  }
  if (v8[1624]) {
    uint64_t v9 = 0x3E7754EAF0AF1D07;
  }
  else {
    uint64_t v9 = 0;
  }
  CFX::RG::Pass::Pass(a1, a2, a3, *(void *)a5, 2, v9, 0);
  *(void *)a1 = &unk_1F0FB5138;
  *(_OWORD *)(a1 + 360) = *(_OWORD *)a5;
  *(void *)a1 = &unk_1F0FB3D18;
  long long v10 = *(_OWORD *)(a5 + 16);
  long long v11 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = v11;
  *(_OWORD *)(a1 + 376) = v10;
  long long v12 = *(_OWORD *)(a5 + 64);
  long long v13 = *(_OWORD *)(a5 + 80);
  long long v14 = *(_OWORD *)(a5 + 112);
  *(_OWORD *)(a1 + 456) = *(_OWORD *)(a5 + 96);
  *(_OWORD *)(a1 + 472) = v14;
  *(_OWORD *)(a1 + 424) = v12;
  *(_OWORD *)(a1 + 440) = v13;
  long long v15 = *(_OWORD *)(a5 + 128);
  long long v16 = *(_OWORD *)(a5 + 144);
  long long v17 = *(_OWORD *)(a5 + 176);
  *(_OWORD *)(a1 + 520) = *(_OWORD *)(a5 + 160);
  *(_OWORD *)(a1 + 536) = v17;
  *(_OWORD *)(a1 + 48_Block_object_dispose(&STACK[0x2B0], 8) = v15;
  *(_OWORD *)(a1 + 504) = v16;
  *(_OWORD *)(a1 + 552) = 0u;
  if (*(unsigned char *)(a1 + 376))
  {
    int v18 = *(_DWORD *)(a1 + 544);
    if (!*(unsigned char *)(a1 + 401)) {
      *(unsigned char *)(a1 + 401) = 1;
    }
    *(unsigned char *)(a1 + 400) = v18;
    long long v19 = *(_OWORD *)(a1 + 496);
    v29[6] = *(_OWORD *)(a1 + 480);
    v29[7] = v19;
    long long v20 = *(_OWORD *)(a1 + 528);
    v29[8] = *(_OWORD *)(a1 + 512);
    v29[9] = v20;
    long long v21 = *(_OWORD *)(a1 + 432);
    v29[2] = *(_OWORD *)(a1 + 416);
    v29[3] = v21;
    long long v22 = *(_OWORD *)(a1 + 464);
    v29[4] = *(_OWORD *)(a1 + 448);
    v29[5] = v22;
    long long v23 = *(_OWORD *)(a1 + 400);
    v29[0] = *(_OWORD *)(a1 + 384);
    v29[1] = v23;
    uint64_t v24 = sub_1B63CFDE4(a4, (uint64_t)"MIPMAP_OUTPUT", v29);
    *(void *)(a1 + 560) = v24;
    CFX::RG::Pass::writeTo((uint64_t *)a1, v24);
  }
  return a1;
}

void sub_1B63E24E8(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B63E2500(uint64_t a1, uint64_t a2, void **a3)
{
  uint64_t v5 = *a3;
  id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 560));
  if (*(unsigned char *)(a1 + 376))
  {
    id v9 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 552));
    uint64_t v13 = objc_msgSend_arrayLength(v9, v10, v11, v12);
    if ((unint64_t)(objc_msgSend_textureType(v9, v14, v15, v16) - 5) >= 2) {
      uint64_t v20 = v13;
    }
    else {
      uint64_t v20 = 6 * v13;
    }
    uint64_t v21 = objc_msgSend_width(v9, v17, v18, v19);
    uint64_t v25 = objc_msgSend_height(v9, v22, v23, v24);
    uint64_t v29 = objc_msgSend_depth(v9, v26, v27, v28);
    if (v20)
    {
      uint64_t v30 = v29;
      for (uint64_t i = 0; i != v20; ++i)
      {
        memset(v35, 0, sizeof(v35));
        v34[0] = v21;
        v34[1] = v25;
        void v34[2] = v30;
        memset(v33, 0, sizeof(v33));
        objc_msgSend_copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_(v5, v6, (uint64_t)v9, i, 0, v35, v34, Texture, i, 0, v33);
      }
    }
  }
  return objc_msgSend_generateMipmapsForTexture_(v5, v6, (uint64_t)Texture, v7);
}

uint64_t *sub_1B63E2620(uint64_t a1, CFX::RG::Resource *a2)
{
  *(void *)(a1 + 552) = a2;
  __n128 result = CFX::RG::Pass::readFrom((uint64_t *)a1, a2);
  if (!*(unsigned char *)(a1 + 376))
  {
    *(void *)(a1 + 560) = a2;
    return CFX::RG::Pass::writeTo((uint64_t *)a1, a2);
  }
  return result;
}

void sub_1B63E2680(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63E26BC(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63E2868(uint64_t a1)
{
}

void sub_1B63E2A5C(uint64_t a1)
{
}

void sub_1B63E2CF0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_prepareWithTarget_implicitDuration_(*(void **)(a1 + 32), a2, *(void *)(a1 + 40), a4);
  if ((sub_1B65005BC(*(void **)(a1 + 32), *(char **)(a1 + 40), *(void **)(a1 + 48), v5, v6, v7, v8, v9) & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 40) + 20));
    objc_msgSend_removeObjectForKey_(*(void **)(*(void *)(a1 + 40) + 24), v10, *(void *)(a1 + 48), v11);
    uint64_t v12 = (os_unfair_lock_s *)(*(void *)(a1 + 40) + 20);
    os_unfair_lock_unlock(v12);
  }
}

void sub_1B63E2F04(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B63E2FCC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B63E30A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B63E318C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B63E36CC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v24 = objc_alloc_init(CFXBinding);
  uint64_t v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);
  objc_msgSend_setSourceObject_(v24, v10, v9, v11);
  objc_msgSend_setKeyPathDst_(v24, v12, *(void *)(a1 + 48), v13);
  objc_msgSend_setKeyPathSrc_(v24, v14, *(void *)(a1 + 56), v15);
  objc_msgSend_setOptions_(v24, v16, *(void *)(a1 + 64), v17);
  sub_1B65844C0(v5, v24, v18, v19, v20, v21, v22, v23);
}

void sub_1B63E3828(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);
  CFStringRef v12 = *(const __CFString **)(a1 + 40);

  sub_1B6584728(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63E3904(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = (CFTypeRef *)objc_msgSend___CFObject(*(void **)(a1 + 32), a2, a3, a4);

  sub_1B658469C(v4, v5, v6, v7, v8, v9, v10, v11);
}

id sub_1B63E3AB8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  id result = (id)objc_msgSend_setWithArray_(MEMORY[0x1E4F1CAD0], a2, (uint64_t)&unk_1F103BF18, a4);
  qword_1E9DDA668 = (uint64_t)result;
  return result;
}

void sub_1B63E3E08(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(void *)(a1 + 40);

  sub_1B6529420(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63E3F88(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652937C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E40FC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(void *)(a1 + 40);

  sub_1B65294BC(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63E452C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529644(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E489C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529644(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E4A1C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B65298C4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E4B9C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529A04(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E4D1C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  char v12 = *(unsigned char *)(a1 + 40);

  sub_1B6529968(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63E4E88(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(void *)(a1 + 40);

  sub_1B65294BC(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63E52B4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529644(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E5434(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B65298C4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E55B4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529A04(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E5734(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529CF4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E58B4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  char v12 = *(unsigned char *)(a1 + 40);

  sub_1B652A028(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63E5A34(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529D98(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E5BB4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529E3C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E5D34(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529EE0(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E5EB4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529F84(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E64D4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  char v12 = *(unsigned char *)(a1 + 40);

  sub_1B652A2C4(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63E6654(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652A364(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E67D4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652A40C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E6954(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652A4B4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E6AD4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652A55C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E6C54(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652A604(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E6DD4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652A6AC(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E73D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529644(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E7558(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B65298C4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E76D8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529A04(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E7858(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  char v12 = *(unsigned char *)(a1 + 40);

  sub_1B6529968(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63E79E0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_cfxObject(*(void **)(a1 + 48), a2, a3, a4);
  __n128 v13 = *(__n128 *)(a1 + 32);

  sub_1B652AE18(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E7B60(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652AEB8(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E7CE0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652AF5C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E7E54(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(void *)(a1 + 40);

  sub_1B652B000(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63E85DC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529644(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E875C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B65298C4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E88DC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529A04(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E8A5C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529CF4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E8EE0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652B92C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E9060(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529644(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E948C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652937C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E960C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B65298C4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E978C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529A04(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E990C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529CF4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E9A94(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_cfxObject(*(void **)(a1 + 48), a2, a3, a4);
  __n128 v13 = *(__n128 *)(a1 + 32);

  sub_1B652AE18(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E9C14(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652AEB8(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E9D9C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_cfxObject(*(void **)(a1 + 48), a2, a3, a4);
  __n128 v13 = *(__n128 *)(a1 + 32);

  sub_1B652B360(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63E9F1C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652B400(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EA0A4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_cfxObject(*(void **)(a1 + 48), a2, a3, a4);
  __n128 v13 = *(__n128 *)(a1 + 32);

  sub_1B652B4A4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EA224(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652B544(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EA3AC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v9 = objc_msgSend___CFObject(*(void **)(a1 + 40), v6, v7, v8);

  sub_1B652B5E8(v5, v9, v10, v11, v12, v13, v14, v15);
}

void sub_1B63EAD80(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652BB24(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EAEF4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (unsigned char *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  int v12 = *(unsigned __int8 *)(a1 + 40);

  sub_1B652BBFC(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63EB2C0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v12 = *(int *)(a1 + 40);

  sub_1B652C038(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63EB440(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652C088(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EB5C8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  double v13 = *(double *)(a1 + 40);

  sub_1B652C170(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EB748(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529EE0(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EB8C8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529F84(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EBA50(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  double v13 = *(double *)(a1 + 40);

  sub_1B652C214(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EBBD0(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652AEB8(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EBD50(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652AF5C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EBED8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  double v13 = *(double *)(a1 + 40);

  sub_1B652C2B8(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EC060(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_cfxObject(*(void **)(a1 + 48), a2, a3, a4);
  __n128 v13 = *(__n128 *)(a1 + 32);

  sub_1B652B360(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EC1E8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_cfxObject(*(void **)(a1 + 48), a2, a3, a4);
  __n128 v13 = *(__n128 *)(a1 + 32);

  sub_1B652C35C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EC370(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (__n128 *)objc_msgSend_cfxObject(*(void **)(a1 + 48), a2, a3, a4);
  __n128 v13 = *(__n128 *)(a1 + 32);

  sub_1B652B4A4(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EC4F8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  double v13 = *(double *)(a1 + 40);

  sub_1B652C3FC(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EC678(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652C454(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EC7F8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  char v12 = *(unsigned char *)(a1 + 40);

  sub_1B652C4F8(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63EC978(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652C548(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63ED77C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529644(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63ED904(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  double v13 = *(double *)(a1 + 40);

  sub_1B652C790(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EDA84(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B6529D98(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EDC04(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  char v12 = *(unsigned char *)(a1 + 40);

  sub_1B652C834(v5, v12, v6, v7, v8, v9, v10, v11);
}

void sub_1B63EE218(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652BB24(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EE398(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652C9C0(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

void sub_1B63EE518(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = (float *)objc_msgSend_cfxObject(*(void **)(a1 + 32), a2, a3, a4);
  float v13 = *(float *)(a1 + 40);

  sub_1B652CA4C(v5, v13, v6, v7, v8, v9, v10, v11, v12);
}

uint64_t sub_1B63EE7F0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1B6DABD0C(a1, "HybridRenderer");
  *(void *)uint64_t v4 = &unk_1F0FB52B8;
  *(void *)(v4 + 24) = a2;
  *(unsigned char *)(v4 + 32) = 1;
  *(_DWORD *)(v4 + 36) = 1065353216;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)(v4 + 56));
  *(void *)(a1 + 256) = 0x3F66666600000018;
  *(_OWORD *)(a1 + 272) = xmmword_1B6E4FDA0;
  *(_OWORD *)(a1 + 28_Block_object_dispose(&STACK[0x2B0], 8) = xmmword_1B6E4FDB0;
  *(_OWORD *)(a1 + 304) = xmmword_1B6E4FDC0;
  *(unsigned char *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 356) = 1090519040;
  *(_WORD *)(a1 + 360) = 1;
  *(unsigned char *)(a1 + 376) = 1;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)(a1 + 392));
  *(unsigned char *)(a1 + 552) = 1;
  *(_DWORD *)(a1 + 556) = 0;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)(a1 + 712));
  *(unsigned char *)(a1 + 872) = 1;
  *(_DWORD *)(a1 + 876) = 0;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)(a1 + 1048));
  *(unsigned char *)(a1 + 120_Block_object_dispose(&STACK[0x2B0], 8) = 1;
  *(_DWORD *)(a1 + 1212) = 0;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)(a1 + 1368));
  *(unsigned char *)(a1 + 152_Block_object_dispose(&STACK[0x2B0], 8) = 1;
  *(_DWORD *)(a1 + 1532) = 0;
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference((CFX::RG::TextureDescriptorReference *)(a1 + 1688));
  *(unsigned char *)(a1 + 184_Block_object_dispose(&STACK[0x2B0], 8) = 1;
  *(_DWORD *)(a1 + 1936) = 0;
  *(_DWORD *)(a1 + 1852) = 1;
  *(_DWORD *)(a1 + 556) = 1;
  *(_DWORD *)(a1 + 876) = 0;
  *(_DWORD *)(a1 + 1212) = 0;
  *(_DWORD *)(a1 + 1532) = 1;
  *(unsigned char *)(a1 + 120_Block_object_dispose(&STACK[0x2B0], 8) = 0;
  *(unsigned char *)(a1 + 152_Block_object_dispose(&STACK[0x2B0], 8) = 0;
  return a1;
}

uint64_t sub_1B63EE910@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v4, *(_WORD *)(a1 + 8), 9273, 1656467160);
  return sub_1B63D0050(a2, v4, 1);
}

uint64_t sub_1B63EE98C@<X0>(uint64_t a1@<X8>)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v3, 53296, 9273, 1893898584);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v4, 53296, 9273, 1490954098);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v5, 53296, 9273, -287492009);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v6, 53296, 9273, 1251382574);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v7, 53296, 9273, -1170177454);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v8, 53296, 9273, -797957750);
  return sub_1B63D0050(a1, &v3, 6);
}

unint64_t sub_1B63EEA84(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unint64_t v3 = *(unsigned __int16 *)(a1 + 8);
  uint64_t v4 = *a3;
  if (v4)
  {
    uint64_t v5 = (uint64_t *)*((void *)a3 + 1);
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = *v5++;
      uint64_t v10 = v7;
      uint64_t v8 = CFX::RG::ResourceIdentifier::id((CFX::RG::ResourceIdentifier *)&v10);
      unint64_t v3 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v3 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v3)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v3)))) >> 47));
      v6 -= 8;
    }
    while (v6);
  }
  return v3;
}

void sub_1B63EEB0C(uint64_t a1, CFX::CrossFrameResourceManager **a2, uint64_t *a3)
{
  uint64_t v215 = *MEMORY[0x1E4F143B8];
  sub_1B6447FBC(*(void *)(a1 + 24), *(unsigned char *)(a1 + 32));
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v212, 9273, 9273, 1656467160);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v213, v212);
  uint64_t v6 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"HybridRenderer input color", (CFX::RG::ResourceReference *)v213);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v210, 9273, 9273, 1251382574);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v211, v210);
  uint64_t v133 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"HybridRenderer input emission", (CFX::RG::ResourceReference *)v211);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v208, 9273, 9273, 1490954098);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v209, v208);
  uint64_t v7 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"HybridRenderer input normals", (CFX::RG::ResourceReference *)v209);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v206, 9273, 9273, 1893898584);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v207, v206);
  uint64_t v8 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"HybridRenderer input albedo", (CFX::RG::ResourceReference *)v207);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v204, 9273, 9273, -287492009);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v205, v204);
  float32x4_t v137 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"HybridRenderer input roughmetalTarget", (CFX::RG::ResourceReference *)v205);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v202, 9273, 9273, -1170177454);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v203, v202);
  char v147 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"HybridRenderer input velocityTarget", (CFX::RG::ResourceReference *)v203);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v200, 9273, 9273, -797957750);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v201, v200);
  uint64_t v9 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"HybridRenderer input depthTarget", (CFX::RG::ResourceReference *)v201);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v198, 9273, 9273, -495228831);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v199, v198);
  float32x4_t v135 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"HybridRenderer input clearCoat", (CFX::RG::ResourceReference *)v199);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v196, 9273, 9273, -965507924);
  CFX::RG::ResourceReference::ResourceReference((uint64_t)v197, v196);
  float32x4_t v134 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"HybridRenderer input subsurface", (CFX::RG::ResourceReference *)v197);
  uint64_t v152 = *(void *)(a1 + 24);
  long long v153 = (unint64_t)v6;
  BOOL v146 = (CFX::RG::Pass *)sub_1B6456B74((CFX::RG::RenderGraphContext *)a2, &v152);
  uint64_t v152 = *(void *)(a1 + 24);
  long long v153 = (unint64_t)v9;
  uint64_t v10 = sub_1B6456B74((CFX::RG::RenderGraphContext *)a2, &v152);
  memcpy(__dst, (const void *)(a1 + 48), sizeof(__dst));
  *(void *)&__dst[0] = *(void *)(a1 + 24);
  uint64_t v11 = (__n128 *)CFX::RG::Resource::textureDesc(v6);
  __n128 v12 = *v11;
  *(__n128 *)((char *)&__dst[1] + _Block_object_dispose(&STACK[0x2B0], 8) = v11[1];
  *(__n128 *)((char *)__dst + _Block_object_dispose(&STACK[0x2B0], 8) = v12;
  __n128 v13 = v11[2];
  __n128 v14 = v11[3];
  __n128 v15 = v11[4];
  *(__n128 *)((char *)&__dst[5] + _Block_object_dispose(&STACK[0x2B0], 8) = v11[5];
  *(__n128 *)((char *)&__dst[4] + _Block_object_dispose(&STACK[0x2B0], 8) = v15;
  *(__n128 *)((char *)&__dst[3] + _Block_object_dispose(&STACK[0x2B0], 8) = v14;
  *(__n128 *)((char *)&__dst[2] + _Block_object_dispose(&STACK[0x2B0], 8) = v13;
  __n128 v16 = v11[6];
  __n128 v17 = v11[7];
  __n128 v18 = v11[8];
  *(__n128 *)((char *)&__dst[9] + _Block_object_dispose(&STACK[0x2B0], 8) = v11[9];
  *(__n128 *)((char *)&__dst[8] + _Block_object_dispose(&STACK[0x2B0], 8) = v18;
  *(__n128 *)((char *)&__dst[7] + _Block_object_dispose(&STACK[0x2B0], 8) = v17;
  *(__n128 *)((char *)&__dst[6] + _Block_object_dispose(&STACK[0x2B0], 8) = v16;
  *((void *)&__dst[10] + 1) = v6;
  *(void *)&__dst[11] = v9;
  *((void *)&__dst[11] + 1) = v7;
  *(void *)&__dst[12] = v8;
  uint64_t v143 = (CFX::RG::Pass *)sub_1B64587A8(a3, a2[4], (uint64_t)__dst, v19, v20, v21, v22, v23, v16);
  uint64_t v24 = sub_1B63EF890(a1, a3, 6, v143, *(uint64_t *)&__dst[20]);
  uint64_t v139 = *((void *)&__dst[12] + 1);
  long long v141 = __dst[17];
  long long v142 = __dst[14];
  long long v140 = __dst[18];
  float32x4_t v136 = v7;
  uint64_t v144 = v8;
  uint64_t v145 = (uint64_t *)v10;
  uint64_t v138 = v9;
  if (*(unsigned char *)(a1 + 1848))
  {
    *(void *)(a1 + 1680) = *(void *)(a1 + 24);
    uint64_t v25 = v7;
    int v26 = (uint64_t *)a2;
    uint64_t v27 = (long long *)CFX::RG::Resource::textureDesc(v6);
    long long v28 = *v27;
    *(_OWORD *)(a1 + 1704) = v27[1];
    *(_OWORD *)(a1 + 168_Block_object_dispose(&STACK[0x2B0], 8) = v28;
    long long v29 = v27[2];
    long long v30 = v27[3];
    long long v31 = v27[4];
    *(_OWORD *)(a1 + 176_Block_object_dispose(&STACK[0x2B0], 8) = v27[5];
    *(_OWORD *)(a1 + 1752) = v31;
    *(_OWORD *)(a1 + 1736) = v30;
    *(_OWORD *)(a1 + 1720) = v29;
    long long v32 = v27[6];
    long long v33 = v27[7];
    long long v34 = v27[8];
    *(_OWORD *)(a1 + 1832) = v27[9];
    *(_OWORD *)(a1 + 1816) = v34;
    *(_OWORD *)(a1 + 1800) = v33;
    *(_OWORD *)(a1 + 1784) = v32;
    *(void *)(a1 + 1856) = v9;
    *(void *)(a1 + 1872) = v25;
    *(void *)(a1 + 1864) = v8;
    uint64_t v35 = v137;
    *(void *)(a1 + 1880) = v137;
    *(void *)(a1 + 188_Block_object_dispose(&STACK[0x2B0], 8) = sub_1B6456B68(v10);
    *(void *)(a1 + 1896) = v147;
    uint64_t v36 = sub_1B64E286C((CFX::RG::RenderGraphContext *)a2, (uint64_t *)(a1 + 1680));
    float32x4_t v132 = (CFX::RG::Pass *)v36;
    if (!v24) {
      uint64_t v24 = sub_1B63EF890(a1, a3, 1, (CFX::RG::Pass *)v36, *(void *)(a1 + 1904));
    }
    uint64_t v37 = v136;
  }
  else
  {
    uint64_t v35 = v137;
    float32x4_t v132 = 0;
    *(void *)(a1 + 1904) = 0;
    uint64_t v37 = v7;
    int v26 = (uint64_t *)a2;
  }
  float32x4_t v38 = v35;
  if (*(unsigned char *)(a1 + 552))
  {
    *(void *)(a1 + 384) = *(void *)(a1 + 24);
    float32x4_t v39 = (_OWORD *)CFX::RG::Resource::textureDesc(v6);
    long long v40 = v39[1];
    *(_OWORD *)(a1 + 392) = *v39;
    *(_OWORD *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = v40;
    long long v41 = v39[4];
    long long v42 = v39[5];
    long long v43 = v39[3];
    *(_OWORD *)(a1 + 424) = v39[2];
    *(_OWORD *)(a1 + 472) = v42;
    *(_OWORD *)(a1 + 456) = v41;
    *(_OWORD *)(a1 + 440) = v43;
    long long v44 = v39[8];
    long long v45 = v39[9];
    long long v46 = v39[7];
    *(_OWORD *)(a1 + 48_Block_object_dispose(&STACK[0x2B0], 8) = v39[6];
    *(_OWORD *)(a1 + 536) = v45;
    *(_OWORD *)(a1 + 520) = v44;
    *(_OWORD *)(a1 + 504) = v46;
    *(void *)(a1 + 64_Block_object_dispose(&STACK[0x2B0], 8) = sub_1B6456B68((uint64_t)v146);
    *(void *)(a1 + 656) = sub_1B6456B68((uint64_t)v145);
    *(void *)(a1 + 632) = v138;
    *(void *)(a1 + 624) = v37;
    *(void *)(a1 + 640) = v147;
    *(void *)(a1 + 560) = v139;
    *(void *)(a1 + 56_Block_object_dispose(&STACK[0x2B0], 8) = 4;
    *(_OWORD *)(a1 + 576) = v142;
    *(_OWORD *)(a1 + 592) = v141;
    *(_OWORD *)(a1 + 60_Block_object_dispose(&STACK[0x2B0], 8) = v140;
    int8x16_t v47 = (uint64_t *)sub_1B64818DC((CFX::RG::RenderGraphContext *)v26, (uint64_t *)(a1 + 384));
    CFX::RG::Pass::dependsOn(v47, v143);
    if (!v24) {
      uint64_t v24 = sub_1B63EF890(a1, a3, 2, (CFX::RG::Pass *)v47, *(void *)(a1 + 664));
    }
  }
  else
  {
    int8x16_t v47 = 0;
    *(void *)(a1 + 664) = 0;
  }
  uint64_t v131 = (CFX::RG::Pass *)v47;
  if (*(unsigned char *)(a1 + 1528))
  {
    *(void *)(a1 + 1360) = *(void *)(a1 + 24);
    unsigned int v48 = (_OWORD *)CFX::RG::Resource::textureDesc(v6);
    long long v49 = v48[1];
    *(_OWORD *)(a1 + 136_Block_object_dispose(&STACK[0x2B0], 8) = *v48;
    *(_OWORD *)(a1 + 1384) = v49;
    long long v50 = v48[4];
    long long v51 = v48[5];
    long long v52 = v48[3];
    *(_OWORD *)(a1 + 1400) = v48[2];
    *(_OWORD *)(a1 + 144_Block_object_dispose(&STACK[0x2B0], 8) = v51;
    *(_OWORD *)(a1 + 1432) = v50;
    *(_OWORD *)(a1 + 1416) = v52;
    long long v53 = v48[8];
    long long v54 = v48[9];
    long long v55 = v48[7];
    *(_OWORD *)(a1 + 1464) = v48[6];
    *(_OWORD *)(a1 + 1512) = v54;
    *(_OWORD *)(a1 + 1496) = v53;
    *(_OWORD *)(a1 + 1480) = v55;
    *(void *)(a1 + 1640) = sub_1B6456B68((uint64_t)v146);
    *(void *)(a1 + 164_Block_object_dispose(&STACK[0x2B0], 8) = sub_1B6456B68((uint64_t)v145);
    *(void *)(a1 + 1624) = v138;
    *(void *)(a1 + 160_Block_object_dispose(&STACK[0x2B0], 8) = v37;
    *(void *)(a1 + 1616) = v8;
    *(void *)(a1 + 1632) = v147;
    *(void *)(a1 + 1600) = v134;
    *(void *)(a1 + 1536) = v139;
    *(void *)(a1 + 1544) = 4;
    *(_OWORD *)(a1 + 1552) = v142;
    *(_OWORD *)(a1 + 156_Block_object_dispose(&STACK[0x2B0], 8) = v141;
    *(_OWORD *)(a1 + 1584) = v140;
    uint64_t v56 = (uint64_t *)sub_1B6472950((CFX::RG::RenderGraphContext *)v26, (uint64_t *)(a1 + 1360));
    CFX::RG::Pass::dependsOn(v56, v143);
    if (!v24) {
      uint64_t v24 = sub_1B63EF890(a1, a3, 3, (CFX::RG::Pass *)v56, *(void *)(a1 + 1656));
    }
  }
  else
  {
    *(void *)(a1 + 1656) = 0;
  }
  if (*(unsigned char *)(a1 + 872))
  {
    *(void *)(a1 + 704) = *(void *)(a1 + 24);
    uint64_t v57 = v6;
    uint64_t v58 = (_OWORD *)CFX::RG::Resource::textureDesc(v6);
    long long v59 = v58[1];
    *(_OWORD *)(a1 + 712) = *v58;
    *(_OWORD *)(a1 + 72_Block_object_dispose(&STACK[0x2B0], 8) = v59;
    long long v60 = v58[4];
    long long v61 = v58[5];
    long long v62 = v58[3];
    *(_OWORD *)(a1 + 744) = v58[2];
    *(_OWORD *)(a1 + 792) = v61;
    *(_OWORD *)(a1 + 776) = v60;
    *(_OWORD *)(a1 + 760) = v62;
    long long v63 = v58[8];
    long long v64 = v58[9];
    long long v65 = v58[7];
    *(_OWORD *)(a1 + 80_Block_object_dispose(&STACK[0x2B0], 8) = v58[6];
    *(_OWORD *)(a1 + 856) = v64;
    *(_OWORD *)(a1 + 840) = v63;
    *(_OWORD *)(a1 + 824) = v65;
    *(void *)(a1 + 984) = sub_1B6456B68((uint64_t)v146);
    *(void *)(a1 + 992) = sub_1B6456B68((uint64_t)v145);
    *(void *)(a1 + 944) = v144;
    float32x4_t v66 = v138;
    *(void *)(a1 + 960) = v138;
    *(void *)(a1 + 952) = v37;
    *(void *)(a1 + 96_Block_object_dispose(&STACK[0x2B0], 8) = v147;
    *(void *)(a1 + 976) = v38;
    *(void *)(a1 + 880) = v139;
    *(void *)(a1 + 88_Block_object_dispose(&STACK[0x2B0], 8) = 4;
    *(_OWORD *)(a1 + 896) = v142;
    *(_OWORD *)(a1 + 912) = v141;
    *(_OWORD *)(a1 + 92_Block_object_dispose(&STACK[0x2B0], 8) = v140;
    float32x4_t v67 = (uint64_t *)sub_1B65FD290((CFX::RG::RenderGraphContext *)v26, (uint64_t *)(a1 + 704));
    CFX::RG::Pass::dependsOn(v67, v143);
    if (!v24) {
      uint64_t v24 = sub_1B63EF890(a1, a3, 4, (CFX::RG::Pass *)v67, *(void *)(a1 + 1000));
    }
  }
  else
  {
    uint64_t v57 = v6;
    float32x4_t v67 = 0;
    *(void *)(a1 + 1000) = 0;
    float32x4_t v66 = v138;
  }
  if (*(unsigned char *)(a1 + 1208))
  {
    *(void *)(a1 + 1040) = *(void *)(a1 + 24);
    float32x4_t v68 = (_OWORD *)CFX::RG::Resource::textureDesc(v57);
    long long v69 = v68[1];
    *(_OWORD *)(a1 + 104_Block_object_dispose(&STACK[0x2B0], 8) = *v68;
    *(_OWORD *)(a1 + 1064) = v69;
    long long v70 = v68[4];
    long long v71 = v68[5];
    long long v72 = v68[3];
    *(_OWORD *)(a1 + 1080) = v68[2];
    *(_OWORD *)(a1 + 112_Block_object_dispose(&STACK[0x2B0], 8) = v71;
    *(_OWORD *)(a1 + 1112) = v70;
    *(_OWORD *)(a1 + 1096) = v72;
    long long v73 = v68[8];
    long long v74 = v68[9];
    long long v75 = v68[7];
    *(_OWORD *)(a1 + 1144) = v68[6];
    *(_OWORD *)(a1 + 1192) = v74;
    *(_OWORD *)(a1 + 1176) = v73;
    *(_OWORD *)(a1 + 1160) = v75;
    *(void *)(a1 + 1312) = sub_1B6456B68((uint64_t)v146);
    *(void *)(a1 + 1320) = sub_1B6456B68((uint64_t)v145);
    *(void *)(a1 + 1280) = v144;
    *(void *)(a1 + 1296) = v66;
    *(void *)(a1 + 128_Block_object_dispose(&STACK[0x2B0], 8) = v135;
    *(void *)(a1 + 1304) = v147;
    *(void *)(a1 + 1216) = v139;
    *(void *)(a1 + 1224) = 4;
    *(_OWORD *)(a1 + 1232) = v142;
    *(_OWORD *)(a1 + 124_Block_object_dispose(&STACK[0x2B0], 8) = v141;
    *(_OWORD *)(a1 + 1264) = v140;
    uint64_t v76 = (uint64_t *)sub_1B65301B4((CFX::RG::RenderGraphContext *)v26, (uint64_t *)(a1 + 1040));
    CFX::RG::Pass::dependsOn(v76, v143);
    if (!v24) {
      uint64_t v24 = sub_1B63EF890(a1, a3, 5, (CFX::RG::Pass *)v76, *(void *)(a1 + 1328));
    }
  }
  else
  {
    uint64_t v76 = 0;
    *(void *)(a1 + 132_Block_object_dispose(&STACK[0x2B0], 8) = 0;
  }
  uint64_t v77 = (CFX::CrossFrameResourceManager *)v26[4];
  uint64_t v152 = *(void *)(a1 + 24);
  unsigned int v78 = (long long *)CFX::RG::Resource::textureDesc(v57);
  long long v79 = *v78;
  long long v154 = v78[1];
  long long v153 = v79;
  long long v80 = v78[2];
  long long v81 = v78[3];
  long long v82 = v78[4];
  long long v158 = v78[5];
  long long v157 = v82;
  long long v156 = v81;
  long long v155 = v80;
  long long v83 = v78[6];
  long long v84 = v78[7];
  long long v85 = v78[8];
  long long v162 = v78[9];
  long long v161 = v85;
  long long v160 = v84;
  long long v159 = v83;
  *(void *)&long long v163 = v144;
  *((void *)&v163 + 1) = v133;
  uint64_t v86 = *(void *)(a1 + 664);
  *(void *)&long long v164 = *(void *)(a1 + 1904);
  *((void *)&v164 + 1) = v86;
  uint64_t v87 = *(void *)(a1 + 1328);
  *(void *)&long long v165 = *(void *)(a1 + 1000);
  *((void *)&v165 + 1) = v87;
  *(void *)&long long v166 = v137;
  *((void *)&v166 + 1) = v136;
  *(void *)&long long v167 = v135;
  *((void *)&v167 + 1) = v134;
  *(void *)&long long v168 = *(void *)(a1 + 1656);
  *((void *)&v168 + 1) = v66;
  float32x4_t v88 = (uint64_t *)sub_1B656178C(a3, v77, &v152);
  CFX::RG::Pass::dependsOn(v88, v132);
  CFX::RG::Pass::dependsOn(v88, v131);
  CFX::RG::Pass::dependsOn(v88, (CFX::RG::Pass *)v67);
  CFX::RG::Pass::dependsOn(v88, (CFX::RG::Pass *)v76);
  float32x4_t v89 = (CFX::RG::Resource *)sub_1B656177C((uint64_t)v88);
  if (!v24) {
    uint64_t v24 = sub_1B63EF890(a1, a3, 8, (CFX::RG::Pass *)v88, (uint64_t)v89);
  }
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t v152 = *(void *)(a1 + 24);
    int32x4_t v90 = (long long *)CFX::RG::Resource::textureDesc(v89);
    long long v91 = v90[1];
    long long v153 = *v90;
    long long v154 = v91;
    long long v92 = v90[4];
    long long v93 = v90[5];
    long long v94 = v90[3];
    long long v155 = v90[2];
    long long v158 = v93;
    long long v157 = v92;
    long long v156 = v94;
    long long v95 = v90[8];
    long long v96 = v90[9];
    long long v97 = v90[7];
    long long v159 = v90[6];
    long long v162 = v96;
    long long v161 = v95;
    long long v160 = v97;
    uint64_t v98 = (long long *)CFX::RG::Resource::textureDesc(v66);
    long long v99 = v98[9];
    long long v101 = v98[6];
    long long v100 = v98[7];
    long long v171 = v98[8];
    long long v172 = v99;
    long long v169 = v101;
    long long v170 = v100;
    long long v102 = v98[1];
    long long v163 = *v98;
    long long v164 = v102;
    long long v103 = v98[4];
    long long v104 = v98[5];
    long long v105 = v98[3];
    long long v165 = v98[2];
    long long v168 = v104;
    long long v167 = v103;
    long long v166 = v105;
    uint64_t v106 = (uint64_t)v147;
    long long v107 = (long long *)CFX::RG::Resource::textureDesc(v147);
    long long v108 = v107[1];
    long long v173 = *v107;
    long long v174 = v108;
    long long v109 = v107[5];
    long long v111 = v107[2];
    long long v110 = v107[3];
    long long v177 = v107[4];
    long long v178 = v109;
    long long v175 = v111;
    long long v176 = v110;
    long long v112 = v107[9];
    long long v114 = v107[6];
    long long v113 = v107[7];
    long long v181 = v107[8];
    long long v182 = v112;
    long long v179 = v114;
    long long v180 = v113;
    uint64_t v115 = (long long *)CFX::RG::Resource::textureDesc(v89);
    long long v116 = v115[1];
    long long v183 = *v115;
    long long v184 = v116;
    long long v117 = v115[2];
    long long v118 = v115[3];
    long long v119 = v115[5];
    long long v187 = v115[4];
    long long v188 = v119;
    long long v185 = v117;
    long long v186 = v118;
    long long v120 = v115[6];
    long long v121 = v115[7];
    long long v122 = v115[9];
    long long v191 = v115[8];
    long long v192 = v122;
    long long v189 = v120;
    long long v190 = v121;
    float32x2_t v193 = v89;
    float32x4_t v194 = v66;
    float32x4_t v195 = v147;
    CopyPass = (uint64_t *)sub_1B645F704(a3, v26[4], &v152);
    CFX::RG::Pass::dependsOn(CopyPass, (CFX::RG::Pass *)v88);
    uint64_t v124 = sub_1B645F6FC((uint64_t)CopyPass);
  }
  else
  {
    CFX::RG::TextureDescriptorReference::finalColor((uint64_t)v150);
    CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v150, MTLPixelFormatRGBA16Float, (uint64_t)&v152);
    CFX::RG::TextureDescriptorReference::withSampleCount(&v152, 1, (uint64_t)v151);
    uint64_t v124 = (uint64_t)sub_1B63CFDE4(a3, (uint64_t)"Output copy", v151);
    uint64_t v152 = (uint64_t)v89;
    LODWORD(v153) = 0;
    *((void *)&v153 + 1) = v124;
    *(void *)&long long v154 = 0x100000000;
    CopyPass = (uint64_t *)CFX::RG::makeCopyPass(a3, (uint64_t)"copy", &v152);
    CFX::RG::Pass::dependsOn(CopyPass, (CFX::RG::Pass *)v88);
    uint64_t v106 = (uint64_t)v147;
  }
  if (!v24)
  {
    uint64_t v24 = sub_1B63EF890(a1, a3, 9, (CFX::RG::Pass *)CopyPass, v106);
    if (!v24)
    {
      uint64_t v125 = sub_1B6456B68((uint64_t)v146);
      uint64_t v24 = sub_1B63EF890(a1, a3, 7, v146, v125);
    }
  }
  CFX::RG::Pass::dependsOn(v145, (CFX::RG::Pass *)CopyPass);
  sub_1B6456B60(v145, v66);
  CFX::RG::Pass::dependsOn((uint64_t *)v146, (CFX::RG::Pass *)CopyPass);
  uint64_t v126 = (CFX::RG::Resource *)sub_1B6561784((uint64_t)v88);
  sub_1B6456B60((uint64_t *)v146, v126);
  CFX::RG::TextureDescriptorReference::finalColor((uint64_t)v149);
  float32x4_t v127 = sub_1B63CFDE4(a3, (uint64_t)"Resource copy", v149);
  uint64_t v152 = v124;
  LODWORD(v153) = 0;
  *((void *)&v153 + 1) = v127;
  *(void *)&long long v154 = 0x100000000;
  int v128 = (uint64_t *)CFX::RG::makeCopyPass(a3, (uint64_t)"copy", &v152);
  CFX::RG::Pass::dependsOn(v128, v146);
  CFX::RG::Pass::dependsOn(v128, (CFX::RG::Pass *)v145);
  __int16 v129 = *(_WORD *)(a1 + 8);
  if (v24) {
    unint64_t v130 = (unint64_t)v24;
  }
  else {
    unint64_t v130 = (unint64_t)v127;
  }
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v148, v129, 27036, 1656467160);
  CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v148, v130, (uint64_t)v128);
}

CFX::RG::Resource *sub_1B63EF7BC(uint64_t a1, uint64_t a2, CFX::RG::ResourceReference *this)
{
  uint64_t v16 = a2;
  uint64_t v15 = CFX::RG::ResourceReference::reference(this);
  unint64_t v5 = CFX::RG::ResourceIdentifier::hash((CFX::RG::ResourceIdentifier *)&v15);
  unsigned int v6 = (*(_DWORD *)(a1 + 284) - 1) & v5;
  unsigned int v7 = *(unsigned __int16 *)(*(void *)(a1 + 272) + 2 * v6);
  if (v7 < 2) {
    goto LABEL_5;
  }
  while ((v7 & 2) == 0 || v5 != *(void *)(*(void *)(a1 + 256) + 8 * v6))
  {
    ++v6;
    BOOL v8 = v7 > 3;
    v7 >>= 1;
    if (!v8) {
      goto LABEL_5;
    }
  }
  uint64_t v14 = *(void *)(a1 + 264);
  if (v14) {
    return *(CFX::RG::Resource **)(v14 + 24 * v6 + 8);
  }
LABEL_5:
  uint64_t v9 = *(void *)a1;
  uint64_t v10 = *(void *)(a1 + 8);
  LOBYTE(v15) = 1;
  sub_1B63EF98C(v9, v10, &v16, this, (char *)&v15);
  __n128 v12 = v11;
  CFX::RG::RenderGraphBuilder::appendResource((uint64_t *)a1, v11);
  return v12;
}

CFX::RG::Resource *sub_1B63EF890(uint64_t a1, uint64_t *a2, int a3, CFX::RG::Pass *a4, uint64_t a5)
{
  if (*(_DWORD *)(a1 + 1936) != a3) {
    return 0;
  }
  CFX::RG::TextureDescriptorReference::finalColor((uint64_t)v12);
  CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)v12, MTLPixelFormatRGBA16Float, (uint64_t)v13);
  CFX::RG::TextureDescriptorReference::withSizeFactor(v13, *(float *)(a1 + 36), (float *)&v14);
  CFX::RG::TextureDescriptorReference::withSampleCount(&v14, 1, (uint64_t)v17);
  uint64_t v9 = sub_1B63CFDE4(a2, (uint64_t)"DebugCopy", v17);
  *(void *)&long long v14 = a5;
  DWORD2(v14) = 0;
  uint64_t v15 = v9;
  uint64_t v16 = 0x100000000;
  CopyPass = (uint64_t *)CFX::RG::makeCopyPass(a2, (uint64_t)"copy", &v14);
  CFX::RG::Pass::dependsOn(CopyPass, a4);
  return v9;
}

void sub_1B63EF978()
{
}

double sub_1B63EF98C(uint64_t a1, uint64_t a2, uint64_t *a3, _OWORD *a4, char *a5)
{
  v17[0] = a1;
  v17[1] = a2;
  uint64_t v8 = sub_1B63C8330(v17, 0xE0u, 8u);
  uint64_t v9 = *a3;
  long long v10 = a4[7];
  v16[6] = a4[6];
  v16[7] = v10;
  long long v11 = a4[9];
  v16[8] = a4[8];
  v16[9] = v11;
  long long v12 = a4[3];
  _OWORD v16[2] = a4[2];
  v16[3] = v12;
  long long v13 = a4[5];
  v16[4] = a4[4];
  v16[5] = v13;
  long long v14 = a4[1];
  v16[0] = *a4;
  v16[1] = v14;
  *(void *)&double result = CFX::RG::Resource::Resource(v8, v9, (uint64_t)v16, *a5).n128_u64[0];
  return result;
}

uint64_t sub_1B63EFA14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA690, memory_order_acquire) & 1) == 0)
  {
    uint64_t v17 = a2;
    uint64_t v18 = a3;
    int v16 = __cxa_guard_acquire(&qword_1E9DDA690);
    uint64_t v8 = (void *)&unk_1E9DDA000;
    a2 = v17;
    a3 = v18;
    if (v16)
    {
      qword_1E9DDA688 = (uint64_t)sub_1B63F09B8("SSAO_TRACE_PASS", 0xFu);
      __cxa_guard_release(&qword_1E9DDA690);
      uint64_t v8 = (void *)&unk_1E9DDA000;
      a2 = v17;
      a3 = v18;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v8[209], 0);
  *(void *)a1 = &unk_1F0FB35E8;
  long long v9 = *(_OWORD *)(a5 + 24);
  long long v10 = *(_OWORD *)(a5 + 40);
  long long v11 = *(_OWORD *)(a5 + 72);
  *(_OWORD *)(a1 + 416) = *(_OWORD *)(a5 + 56);
  *(_OWORD *)(a1 + 432) = v11;
  *(_OWORD *)(a1 + 384) = v9;
  *(_OWORD *)(a1 + 400) = v10;
  *(void *)(a1 + 456) = 0;
  long long v12 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*(CFX::RG::Resource **)(a5 + 64));
  CFX::RG::TextureDescriptorReference::withSampleCount(v12, 1, (uint64_t)v20);
  CFX::RG::TextureDescriptorReference::withSizeFactor(v20, *(float *)(a1 + 400), (float *)&v21);
  *((void *)&v22 + 1) = 25;
  LOBYTE(v23) = 1;
  v19[6] = v27;
  long long v19[7] = v28;
  v19[8] = v29;
  v19[9] = v30;
  v19[4] = v25;
  v19[5] = v26;
  _OWORD v19[2] = v23;
  v19[3] = v24;
  v19[0] = v21;
  v19[1] = v22;
  long long v13 = sub_1B63CFDE4(a4, (uint64_t)"SSAO-COMPUTE", v19);
  *(void *)(a1 + 456) = v13;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v13, 0x100000002, 0);
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a5 + 64));
  long long v14 = *(CFX::RG::Resource **)(a5 + 72);
  if (v14) {
    CFX::RG::Pass::readFrom((uint64_t *)a1, v14);
  }
  return a1;
}

void sub_1B63EFBA4(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B63EFBBC(uint64_t a1, uint64_t a2)
{
  char v57 = 0;
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * v4) >> 47) ^ (0x9DDFEA08EB382D69 * v4));
  unint64_t v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v5 >> 47));
  double v7 = 0.0;
  if (*(unsigned char *)(a1 + 384)) {
    double v7 = 1.0;
  }
  uint64_t v8 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69
       * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ *(void *)&v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ *(void *)&v7)))) ^ ((0x9DDFEA08EB382D69 * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ *(void *)&v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ *(void *)&v7)))) >> 47));
  uint64_t v9 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v8);
  *(void *)(a1 + 44_Block_object_dispose(&STACK[0x2B0], 8) = v9;
  if (!v9)
  {
    *(void *)(a1 + 44_Block_object_dispose(&STACK[0x2B0], 8) = sub_1B63EFD88(*(CFX::CrossFrameResourceManager **)(a2 + 32), v8);
    uint64_t v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
    long long v21 = objc_msgSend_resourceManager(v17, v18, v19, v20);
    id v22 = objc_alloc_init(MEMORY[0x1E4F35228]);
    objc_msgSend_setConstantValue_type_withName_(v22, v23, (uint64_t)&v57, 53, @"HasNormalTex");
    objc_msgSend_setConstantValue_type_withName_(v22, v24, a1 + 384, 53, @"ScreenSpaceRadius");
    long long v25 = (void *)sub_1B653EFAC((uint64_t)v21);
    uint64_t v29 = objc_msgSend_frameworkLibrary(v25, v26, v27, v28);
    uint64_t v30 = *(void *)(a1 + 448);
    memset(v36, 0, sizeof(v36));
    uint64_t v37 = 0;
    uint64_t v38 = v29;
    uint64_t v39 = 25;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    uint64_t v44 = 0;
    char v45 = 1;
    memset(v50, 0, sizeof(v50));
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    id v51 = v22;
    uint64_t v52 = 0;
    long long v53 = @"vfx_draw_fullscreen_triangle_vertex";
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    long long v54 = @"vfx_ssao_compute";
    uint64_t v33 = objc_msgSend_newRenderPipelineStateWithDesc_(v21, v31, (uint64_t)v36, v32);
    long long v34 = *(void **)(v30 + 16);
    if (v34 != (void *)v33)
    {
      uint64_t v35 = v33;
      if (v34) {

      }
      *(void *)(v30 + 16) = v35;
    }

    *(_DWORD *)(*(void *)(a1 + 448) + 24) = 0;
  }
}

uint64_t sub_1B63EFD88(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B63EFE14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v119 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = (void *)sub_1B6445900(*(void *)(a1 + 368), a2, a3, a4, a5, a6, a7, a8);
  uint64_t v21 = objc_msgSend_renderEncoder(v10, v11, v12, v13);
  uint64_t v22 = *(void *)(a1 + 416);
  if (v22
    || (result = (uint64_t)sub_1B6446564(*(uint64_t **)(a1 + 368), v14, v15, v16, v17, v18, v19, v20), (uint64_t v22 = result) != 0))
  {
    uint64_t result = (uint64_t)sub_1B64A3B48(v22, v14, v15, v16, v17, v18, v19, v20);
    if (result)
    {
      uint64_t v31 = sub_1B649B3A0(result, v24, v25, v26, v27, v28, v29, v30);
      sub_1B63E0460(v22, (uint64_t)v109, v32, v33, v34, v35, v36, v37);
      __n128 v108 = sub_1B64471F4(*(void *)(a1 + 368), 0, v38, v39, v40, v41, v42, v43);
      uint64_t v51 = *(void *)(a1 + 448);
      uint64_t v52 = *(void **)(v51 + 16);
      if (!v52)
      {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v45, v46, v47, v48, v49, v50, (uint64_t)"_ptr != NULL");
        uint64_t v52 = *(void **)(v51 + 16);
      }
      uint64_t v53 = objc_msgSend_state(v52, v44, v45, v46);
      objc_msgSend_setRenderPipelineState_(*(void **)(v21 + 16), v54, v53, v55);
      id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 424));
      sub_1B63C6ED0(v21, Texture, 0, v57);
      uint64_t v58 = *(const CFX::RG::Resource **)(a1 + 432);
      if (v58)
      {
        id v59 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), v58);
        sub_1B63C6ED0(v21, v59, 1, v60);
      }
      long long v61 = sub_1B63BE410(v10, *(CFX::CrossFrameResourceManager **)(a2 + 32));
      sub_1B63C6ED0(v21, v61, 2, v62);
      if (sub_1B6446A8C(*(void *)(a1 + 368), v63, v64, v65, v66, v67, v68, v69) || !v31)
      {
        uint64_t v116 = *(void *)(a1 + 388);
        float v91 = *(float *)(a1 + 396);
      }
      else
      {
        LODWORD(v116) = sub_1B6529330(v31, v70, v71, v72, v73, v74, v75, v76);
        HIDWORD(v116) = sub_1B6529878(v31, v77, v78, v79, v80, v81, v82, v83);
        float v91 = sub_1B65299B8(v31, v84, v85, v86, v87, v88, v89, v90);
      }
      float v117 = v91;
      simd_float4x4 v120 = *(simd_float4x4 *)sub_1B649CD50(v109, (uint64_t)&v108, v71, v72, v73, v74, v75, v76);
      simd_float4x4 v113 = __invert_f4(v120);
      int v118 = *(_DWORD *)(*(void *)(a1 + 448) + 24);
      uint64_t v95 = objc_msgSend_width(Texture, v92, v93, v94);
      uint64_t v99 = objc_msgSend_height(Texture, v96, v97, v98);
      v100.i64[0] = v95;
      v100.i64[1] = v99;
      __asm { FMOV            V1.2S, #1.0 }
      float32x2_t v114 = vcvt_f32_f64(vcvtq_f64_u64(vshrq_n_u64(v100, 1uLL)));
      float32x2_t v115 = vdiv_f32(_D1, v114);
      long long v110 = 0;
      uint64_t v111 = 0;
      uint64_t v112 = 0;
      sub_1B649F334(*(void *)(v21 + 24), &v113, 0x70uLL, &v110);
      objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v21 + 16), v106, v111, v112, 8);
      uint64_t result = sub_1B63F0064(v21, v107);
      ++*(_DWORD *)(*(void *)(a1 + 448) + 24);
    }
  }
  return result;
}

uint64_t sub_1B63F0064(uint64_t a1, const char *a2)
{
  unsigned int v2 = *(_DWORD *)a1;
  unint64_t v3 = *(void **)(a1 + 16);
  if (v2 < 2) {
    return objc_msgSend_drawPrimitives_vertexStart_vertexCount_(v3, a2, 4, 0, 4);
  }
  else {
    return objc_msgSend_drawPrimitives_vertexStart_vertexCount_instanceCount_(v3, a2, 4, 0, 4);
  }
}

uint64_t sub_1B63F0090(uint64_t a1, uint64_t a2, uint64_t a3, CFX::RG::RenderGraphContext *a4, long long *a5)
{
  uint64_t v8 = *((void *)a5 + 3);
  *(void *)&long long v35 = "SSAOSpatialPass";
  *((void *)&v35 + 1) = v8;
  uint64_t v9 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA6A0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v30 = a2;
    uint64_t v31 = a3;
    int v29 = __cxa_guard_acquire(&qword_1E9DDA6A0);
    uint64_t v9 = (void *)&unk_1E9DDA000;
    a2 = v30;
    a3 = v31;
    if (v29)
    {
      qword_1E9DDA698 = (uint64_t)sub_1B63F09B8("SSAO_SPATIAL", 0xCu);
      __cxa_guard_release(&qword_1E9DDA6A0);
      uint64_t v9 = (void *)&unk_1E9DDA000;
      a2 = v30;
      a3 = v31;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)&v35, v9[211], 0);
  *(void *)a1 = &unk_1F0FB38F8;
  long long v10 = *a5;
  long long v11 = a5[1];
  long long v12 = a5[3];
  *(_OWORD *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = a5[2];
  *(_OWORD *)(a1 + 424) = v12;
  *(_OWORD *)(a1 + 376) = v10;
  *(_OWORD *)(a1 + 392) = v11;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  uint64_t v20 = (void *)sub_1B6445900(*(void *)(a1 + 368), v13, v14, v15, v16, v17, v18, v19);
  *(void *)(a1 + 472) = v20;
  *(void *)(a1 + 480) = objc_msgSend_resourceManager(v20, v21, v22, v23);
  CFX::RG::Pass::readFrom((uint64_t *)a1, *((CFX::RG::Resource **)a5 + 5));
  uint64_t v24 = (CFX::RG::Resource *)*((void *)a5 + 6);
  if (v24) {
    CFX::RG::Pass::readFrom((uint64_t *)a1, v24);
  }
  uint64_t v25 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*((CFX::RG::Resource **)a5 + 5));
  CFX::RG::TextureDescriptorReference::withSampleCount(v25, 1, (uint64_t)v34);
  CFX::RG::TextureDescriptorReference::withSizeFactor(v34, *(float *)(a1 + 392), (float *)&v35);
  *((void *)&v36 + 1) = 25;
  LOBYTE(v37) = 1;
  uint64_t v26 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder(a4);
  void v33[6] = v41;
  v33[7] = v42;
  v33[8] = v43;
  v33[9] = v44;
  v33[2] = v37;
  void v33[3] = v38;
  void v33[4] = v39;
  v33[5] = v40;
  v33[0] = v35;
  v33[1] = v36;
  *(void *)(a1 + 456) = sub_1B63CFDE4(v26, (uint64_t)"SSAO_SPATIAL_OUTPUT_TMP", v33);
  uint64_t v27 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder(a4);
  v32[6] = v41;
  v32[7] = v42;
  v32[8] = v43;
  v32[9] = v44;
  _OWORD v32[2] = v37;
  void v32[3] = v38;
  v32[4] = v39;
  v32[5] = v40;
  v32[0] = v35;
  v32[1] = v36;
  *(void *)(a1 + 464) = sub_1B63CFDE4(v27, (uint64_t)"SSAO_SPATIAL_OUTPUT", v32);
  CFX::RG::Pass::readFrom((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 456));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 456));
  CFX::RG::Pass::writeTo((uint64_t *)a1, *(CFX::RG::Resource **)(a1 + 464));
  return a1;
}

void sub_1B63F02A0(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B63F02BC(CFX::RG::Pass *a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash(a1);
  uint64_t result = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
  *((void *)a1 + 55) = result;
  if (!result) {
    operator new();
  }
  return result;
}

void sub_1B63F03C4(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  long long v10 = *a3;
  long long v11 = *(const void **)(a1 + 408);
  if (v11 || (long long v11 = sub_1B6446564(*(uint64_t **)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8)) != 0)
  {
    if (sub_1B64A3B48((uint64_t)v11, a2, (uint64_t)a3, a4, a5, a6, a7, a8))
    {
      sub_1B63E0460((uint64_t)v11, (uint64_t)v100, v12, v13, v14, v15, v16, v17);
      __n128 v99 = sub_1B64471F4(*(void *)(a1 + 368), 0, v18, v19, v20, v21, v22, v23);
      uint64_t v24 = *(void *)(a1 + 440);
      if (*(void *)(v24 + 16))
      {
        if (*(void *)(v24 + 24))
        {
          id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 448));
          id v26 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 416));
          id v27 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 424));
          id v28 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 456));
          id v29 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 464));
          objc_msgSend_setTexture_atIndex_(v10, v30, (uint64_t)v26, 1);
          objc_msgSend_setTexture_atIndex_(v10, v31, (uint64_t)v27, 2);
          uint64_t v104 = *(void *)(a1 + 380);
          int v106 = *(_DWORD *)(a1 + 388);
          simd_float4x4 v108 = *(simd_float4x4 *)sub_1B649CD50(v100, (uint64_t)&v99, v32, v33, v34, v35, v36, v37);
          simd_float4x4 v101 = __invert_f4(v108);
          float v98 = (float)(unint64_t)objc_msgSend_width(Texture, v38, v39, v40);
          uint64_t v44 = objc_msgSend_height(Texture, v41, v42, v43);
          v45.f32[0] = v98;
          v45.f32[1] = (float)(unint64_t)v44;
          __asm { FMOV            V0.2S, #1.0 }
          float32x2_t v102 = v45;
          float32x2_t v103 = vdiv_f32(_D0, v45);
          int v105 = *(_DWORD *)(a1 + 392);
          objc_msgSend_setBytes_length_atIndex_(v10, v51, (uint64_t)&v101, 112, 8);
          objc_msgSend_setTexture_atIndex_(v10, v52, (uint64_t)Texture, 0);
          objc_msgSend_setTexture_atIndex_(v10, v53, (uint64_t)v28, 3);
          uint64_t v60 = *(void *)(a1 + 440);
          uint64_t v61 = *(void *)(v60 + 16);
          if (!v61)
          {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v54, v55, v56, v57, v58, v59, (uint64_t)"_ptr != NULL");
            uint64_t v61 = *(void *)(v60 + 16);
          }
          uint64_t v62 = sub_1B653EFB8(v61);
          objc_msgSend_setComputePipelineState_(v10, v63, v62, v64);
          uint64_t v71 = *(void *)(a1 + 440);
          uint64_t v72 = *(void *)(v71 + 16);
          if (!v72)
          {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v65, v66, v67, v68, v69, v70, (uint64_t)"_ptr != NULL");
            uint64_t v72 = *(void *)(v71 + 16);
          }
          uint64_t v73 = sub_1B653EFB8(v72);
          objc_msgSend_dispatch_onTexture2D_(v10, v74, v73, (uint64_t)v28);
          objc_msgSend_setTexture_atIndex_(v10, v75, (uint64_t)v28, 0);
          objc_msgSend_setTexture_atIndex_(v10, v76, (uint64_t)v29, 3);
          uint64_t v83 = *(void *)(a1 + 440);
          uint64_t v84 = *(void *)(v83 + 24);
          if (!v84)
          {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v77, v78, v79, v80, v81, v82, (uint64_t)"_ptr != NULL");
            uint64_t v84 = *(void *)(v83 + 24);
          }
          uint64_t v85 = sub_1B653EFB8(v84);
          objc_msgSend_setComputePipelineState_(v10, v86, v85, v87);
          uint64_t v94 = *(void *)(a1 + 440);
          uint64_t v95 = *(void *)(v94 + 24);
          if (!v95)
          {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v88, v89, v90, v91, v92, v93, (uint64_t)"_ptr != NULL");
            uint64_t v95 = *(void *)(v94 + 24);
          }
          uint64_t v96 = sub_1B653EFB8(v95);
          objc_msgSend_dispatch_onTexture2D_(v10, v97, v96, (uint64_t)v29);
        }
      }
    }
  }
}

uint64_t sub_1B63F06B4(uint64_t a1, uint64_t a2, uint64_t a3, CFX::RG::RenderGraphContext *a4, long long *a5)
{
  uint64_t v8 = *((void *)a5 + 3);
  *(void *)&long long v34 = "SSAOUpscalePass";
  *((void *)&v34 + 1) = v8;
  uint64_t v9 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA6B0, memory_order_acquire) & 1) == 0)
  {
    uint64_t v30 = a2;
    uint64_t v31 = a3;
    int v29 = __cxa_guard_acquire(&qword_1E9DDA6B0);
    uint64_t v9 = (void *)&unk_1E9DDA000;
    a2 = v30;
    a3 = v31;
    if (v29)
    {
      qword_1E9DDA6A8 = (uint64_t)sub_1B63F09B8("SSAO_UPSCALE", 0xCu);
      __cxa_guard_release(&qword_1E9DDA6B0);
      uint64_t v9 = (void *)&unk_1E9DDA000;
      a2 = v30;
      a3 = v31;
    }
  }
  sub_1B653860C(a1, a2, a3, (uint64_t *)&v34, v9[213], 0);
  *(void *)a1 = &unk_1F0FB3968;
  long long v10 = *a5;
  long long v11 = a5[1];
  long long v12 = a5[3];
  *(_OWORD *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = a5[2];
  *(_OWORD *)(a1 + 424) = v12;
  *(_OWORD *)(a1 + 376) = v10;
  *(_OWORD *)(a1 + 392) = v11;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(void *)(a1 + 472) = 0;
  uint64_t v20 = (void *)sub_1B6445900(*(void *)(a1 + 368), v13, v14, v15, v16, v17, v18, v19);
  *(void *)(a1 + 464) = v20;
  *(void *)(a1 + 472) = objc_msgSend_resourceManager(v20, v21, v22, v23);
  CFX::RG::Pass::readFrom((uint64_t *)a1, *((CFX::RG::Resource **)a5 + 5));
  uint64_t v24 = (CFX::RG::Resource *)*((void *)a5 + 6);
  if (v24) {
    CFX::RG::Pass::readFrom((uint64_t *)a1, v24);
  }
  uint64_t v25 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*((CFX::RG::Resource **)a5 + 5));
  CFX::RG::TextureDescriptorReference::withSampleCount(v25, 1, (uint64_t)v33);
  CFX::RG::TextureDescriptorReference::withSizeFactor(v33, *(float *)(a1 + 392), (float *)&v34);
  *((void *)&v35 + 1) = 115;
  LOBYTE(v36) = 1;
  id v26 = (uint64_t *)CFX::RG::RenderGraphContext::currentBuilder(a4);
  v32[6] = v40;
  v32[7] = v41;
  v32[8] = v42;
  v32[9] = v43;
  _OWORD v32[2] = v36;
  void v32[3] = v37;
  v32[4] = v38;
  v32[5] = v39;
  v32[0] = v34;
  v32[1] = v35;
  id v27 = sub_1B63CFDE4(v26, (uint64_t)"SSAO_UPSCALE_OUTPUT", v32);
  *(void *)(a1 + 456) = v27;
  CFX::RG::Pass::writeTo((uint64_t *)a1, v27);
  return a1;
}

void sub_1B63F0868(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B63F0884(CFX::RG::Pass *a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash(a1);
  uint64_t v5 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v4);
  *((void *)a1 + 55) = v5;
  if (!v5) {
    operator new();
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA680, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDA680))
  {
    qword_1E9DDA678 = (uint64_t)sub_1B63F09B8("VFX-SSAO", 8u);
    __cxa_guard_release(&qword_1E9DDA680);
  }
  unint64_t v6 = *(CFX::GPUResourceManager **)(a2 + 24);
  double v7 = (const CFX::RG::Resource *)*((void *)a1 + 57);
  unsigned int v8 = qword_1E9DDA678;

  return CFX::GPUResourceManager::registerNamedFrameResource(v6, v7, v8);
}

unsigned __int8 *sub_1B63F09B8(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      unint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      uint64_t result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

void sub_1B63F0AA4(uint64_t a1, uint64_t a2, void **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v113 = *MEMORY[0x1E4F143B8];
  long long v10 = *a3;
  long long v11 = *(const void **)(a1 + 408);
  if (v11 || (long long v11 = sub_1B6446564(*(uint64_t **)(a1 + 368), a2, (uint64_t)a3, a4, a5, a6, a7, a8)) != 0)
  {
    CFDictionaryRef v12 = sub_1B64A3B48((uint64_t)v11, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (v12)
    {
      uint64_t v20 = sub_1B649B3A0((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19);
      sub_1B63E0460((uint64_t)v11, (uint64_t)v107, v21, v22, v23, v24, v25, v26);
      __n128 v106 = sub_1B64471F4(*(void *)(a1 + 368), 0, v27, v28, v29, v30, v31, v32);
      if (*(void *)(*(void *)(a1 + 440) + 16))
      {
        id Texture = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 448));
        id v34 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 416));
        id v35 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 424));
        id v36 = CFX::GPUResourceManager::getTexture(*(CFX::GPUResourceManager **)(a2 + 24), *(const CFX::RG::Resource **)(a1 + 456));
        objc_msgSend_setTexture_atIndex_(v10, v37, (uint64_t)v34, 1);
        objc_msgSend_setTexture_atIndex_(v10, v38, (uint64_t)v35, 2);
        objc_msgSend_setTexture_atIndex_(v10, v39, (uint64_t)Texture, 0);
        objc_msgSend_setTexture_atIndex_(v10, v40, (uint64_t)v36, 3);
        if (sub_1B6446A8C(*(void *)(a1 + 368), v41, v42, v43, v44, v45, v46, v47) || !v20)
        {
          uint64_t v111 = *(void *)(a1 + 380);
          float v69 = *(float *)(a1 + 388);
        }
        else
        {
          LODWORD(v111) = sub_1B6529330(v20, v48, v49, v50, v51, v52, v53, v54);
          HIDWORD(v111) = sub_1B6529878(v20, v55, v56, v57, v58, v59, v60, v61);
          float v69 = sub_1B65299B8(v20, v62, v63, v64, v65, v66, v67, v68);
        }
        float v112 = v69;
        simd_float4x4 v114 = *(simd_float4x4 *)sub_1B649CD50(v107, (uint64_t)&v106, v49, v50, v51, v52, v53, v54);
        simd_float4x4 v108 = __invert_f4(v114);
        float v105 = (float)(unint64_t)objc_msgSend_width(Texture, v70, v71, v72);
        uint64_t v76 = objc_msgSend_height(Texture, v73, v74, v75);
        v77.f32[0] = v105;
        v77.f32[1] = (float)(unint64_t)v76;
        __asm { FMOV            V0.2S, #1.0 }
        float32x2_t v109 = v77;
        float32x2_t v110 = vdiv_f32(_D0, v77);
        objc_msgSend_setBytes_length_atIndex_(v10, v83, (uint64_t)&v108, 112, 8);
        uint64_t v90 = *(void *)(a1 + 440);
        uint64_t v91 = *(void *)(v90 + 16);
        if (!v91)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v84, v85, v86, v87, v88, v89, (uint64_t)"_ptr != NULL");
          uint64_t v91 = *(void *)(v90 + 16);
        }
        uint64_t v92 = sub_1B653EFB8(v91);
        objc_msgSend_setComputePipelineState_(v10, v93, v92, v94);
        uint64_t v101 = *(void *)(a1 + 440);
        uint64_t v102 = *(void *)(v101 + 16);
        if (!v102)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v95, v96, v97, v98, v99, v100, (uint64_t)"_ptr != NULL");
          uint64_t v102 = *(void *)(v101 + 16);
        }
        uint64_t v103 = sub_1B653EFB8(v102);
        objc_msgSend_dispatch_onTexture2D_(v10, v104, v103, (uint64_t)v36);
      }
    }
  }
}

uint64_t *sub_1B63F0D14(uint64_t *a1, CFX::RG::RenderGraphContext *a2, uint64_t a3)
{
  long long v6 = *(_OWORD *)(a3 + 16);
  long long v17 = *(_OWORD *)a3;
  long long v18 = v6;
  long long v7 = *(_OWORD *)(a3 + 48);
  long long v19 = *(_OWORD *)(a3 + 32);
  long long v20 = v7;
  uint64_t v8 = *(void *)(a3 + 24);
  v15[0] = "SSAOTracePass";
  v15[1] = v8;
  __int16 v16 = 0;
  uint64_t v9 = (CFX::RG::Pass *)sub_1B63F0DF4(a1, a1, (uint64_t)v15);
  long long v10 = (uint64_t *)sub_1B63F0E4C(a1, a2, (long long *)a3);
  CFX::RG::Pass::dependsOn(v10, v9);
  long long v11 = (CFX::RG::Resource *)*((void *)v9 + 57);
  CFX::RG::Pass::readFrom(v10, v11);
  v10[56] = (uint64_t)v11;
  CFDictionaryRef v12 = (uint64_t *)sub_1B63F0EA4(a1, a2, (long long *)a3);
  CFX::RG::Pass::dependsOn(v12, (CFX::RG::Pass *)v10);
  uint64_t v13 = (CFX::RG::Resource *)v10[58];
  CFX::RG::Pass::readFrom(v12, v13);
  v12[56] = (uint64_t)v13;
  *(void *)(a3 + 56) = v12[57];
  return v12;
}

uint64_t sub_1B63F0DF4(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63F11F4(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B63F0E4C(uint64_t *a1, CFX::RG::RenderGraphContext *a2, long long *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63F1254(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B63F0EA4(uint64_t *a1, CFX::RG::RenderGraphContext *a2, long long *a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63F12B4(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

void sub_1B63F0F00(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63F0F3C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63F0F7C(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B63F0FB4(void *a1)
{
  *a1 = &unk_1F0FB35C8;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B63F1000(void *a1)
{
  *a1 = &unk_1F0FB35C8;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B63F106C(void *a1)
{
  *a1 = &unk_1F0FB38D8;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  return a1;
}

void sub_1B63F10C4(void *a1)
{
  *a1 = &unk_1F0FB38D8;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B63F113C(void *a1)
{
  *a1 = &unk_1F0FB3948;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B63F1188(void *a1)
{
  *a1 = &unk_1F0FB3948;
  uint64_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B63F11F4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1D0u, 8u);
  return sub_1B63EFA14(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B63F1254(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::RG::RenderGraphContext *a4, long long *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1E8u, 8u);
  return sub_1B63F0090(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B63F12B4(uint64_t a1, uint64_t a2, uint64_t *a3, CFX::RG::RenderGraphContext *a4, long long *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1E0u, 8u);
  return sub_1B63F06B4(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B63F1314(uint64_t result)
{
  *(_WORD *)(result + 80) &= ~0x400u;
  return result;
}

void sub_1B63F1324(uint64_t a1)
{
  sub_1B6595A0C(@"kCFXNotificationRendererElementWillDie", (const void *)a1, 0, 1u);
  if ((*(_WORD *)(a1 + 80) & 7) == 4)
  {
    unint64_t v2 = *(const void **)(a1 + 48);
    if (v2)
    {
      _Block_release(v2);
    }
  }
  else
  {
    uint64_t v3 = *(const void **)(a1 + 32);
    if (v3)
    {
      CFRelease(v3);
      *(void *)(a1 + 32) = 0;
    }
    unint64_t v4 = *(const void **)(a1 + 16);
    if (v4)
    {
      CFRelease(v4);
      *(void *)(a1 + 16) = 0;
    }
    uint64_t v5 = *(const void **)(a1 + 24);
    if (v5)
    {
      CFRelease(v5);
      *(void *)(a1 + 24) = 0;
    }
    long long v6 = *(const void **)(a1 + 48);
    if (v6)
    {
      CFTypeID v7 = CFGetTypeID(v6);
      if (v7 == sub_1B63D0278())
      {
        uint64_t v8 = *(const void **)(a1 + 48);
        if (v8)
        {
          CFRelease(v8);
          *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2B0], 8) = 0;
        }
      }
    }
    uint64_t v9 = *(const void **)(a1 + 40);
    if (v9)
    {
      CFRelease(v9);
      *(void *)(a1 + 40) = 0;
    }
  }
}

BOOL sub_1B63F1400(uint64_t a1)
{
  return (*(_WORD *)(a1 + 80) & 7) == 4;
}

void sub_1B63F1414(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a2;
  if ((a2 & 4) != 0)
  {
    uint64_t v10 = *(void *)(a1 + 8);
    if ((*(_WORD *)(a1 + 80) & 7) == 5)
    {
      unsigned int v11 = 0x80000000;
    }
    else if (v10)
    {
      unsigned int v11 = sub_1B64A34FC(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
    }
    else
    {
      unsigned int v11 = 0;
    }
    *(_DWORD *)(a1 + 72) = v11;
    if (v10)
    {
      if (sub_1B64A3638(v10, a2, a3, a4, a5, a6, a7, a8)) {
        __int16 v12 = 16;
      }
      else {
        __int16 v12 = 0;
      }
    }
    else
    {
      __int16 v12 = 0;
    }
    *(_WORD *)(a1 + 80) = *(_WORD *)(a1 + 80) & 0xFFEF | v12;
  }
  if ((v8 & 8) == 0) {
    goto LABEL_41;
  }
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"rendererElement");
  }
  int v13 = *(_WORD *)(a1 + 80) & 7;
  if (v13 != 4)
  {
    uint64_t v15 = *(void *)(a1 + 32);
    BOOL v16 = v15 == 0;
    if (v15)
    {
      CFArrayRef v17 = sub_1B65849C8(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
      char v18 = sub_1B63F17DC(v17);
      int v13 = *(_WORD *)(a1 + 80) & 7;
    }
    else
    {
      char v18 = 0;
    }
    if (v13 != 2 && v13 != 4)
    {
      uint64_t v19 = *(void *)(a1 + 16);
      if (v19)
      {
        CFArrayRef v20 = sub_1B65849C8(*(void *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
        v18 |= sub_1B63F17DC(v20);
        uint64_t v28 = sub_1B63CCE68(v19, v21, v22, v23, v24, v25, v26, v27);
        if (v28)
        {
          if (sub_1B64AD1A4(v28))
          {
            __int16 v29 = *(_WORD *)(a1 + 80);
            if ((v29 & 8) == 0) {
              goto LABEL_41;
            }
            goto LABEL_36;
          }
        }
      }
    }
    if ((v18 & 1) == 0)
    {
      uint64_t v14 = *(void *)(a1 + 8);
      if (v14) {
        goto LABEL_31;
      }
      if (v15)
      {
LABEL_33:
        int v31 = sub_1B64AF9CC(v15, a2, a3, a4, a5, a6, a7, a8);
        goto LABEL_34;
      }
    }
LABEL_38:
    __int16 v29 = *(_WORD *)(a1 + 80);
    if ((v29 & 8) == 0) {
      goto LABEL_39;
    }
    goto LABEL_41;
  }
  uint64_t v14 = *(void *)(a1 + 8);
  if (!v14) {
    goto LABEL_38;
  }
  uint64_t v15 = 0;
  BOOL v16 = 1;
LABEL_31:
  sub_1B64A2F68(v14, a2, a3, a4, a5, a6, a7, a8);
  int v31 = v30 >= 1.0;
  if (!v16 && v30 >= 1.0) {
    goto LABEL_33;
  }
LABEL_34:
  __int16 v29 = *(_WORD *)(a1 + 80);
  if (((v31 ^ ((v29 & 8) == 0)) & 1) == 0)
  {
    if (!v31)
    {
LABEL_36:
      __int16 v32 = 0;
LABEL_40:
      *(_WORD *)(a1 + 80) = v29 & 0xFFF7 | v32;
      sub_1B6595A0C(@"kCFXNotificationRendererElementWillDie", (const void *)a1, 0, 1u);
      goto LABEL_41;
    }
LABEL_39:
    __int16 v32 = 8;
    goto LABEL_40;
  }
LABEL_41:
  if ((v8 & 0x10) != 0)
  {
    __int16 v33 = *(_WORD *)(a1 + 80);
    if ((v33 & 7) != 4)
    {
      uint64_t v34 = *(void *)(a1 + 32);
      if (!v34)
      {
        __int16 v45 = v33 & 0xFFBF;
LABEL_53:
        *(_WORD *)(a1 + 80) = v45;
        return;
      }
      uint64_t v35 = sub_1B64AF488(v34, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v43 = v35;
      if (v35 && (sub_1B64757A4(v35, v36, v37, v38, v39, v40, v41, v42) & 0xFFFFFFFD) != 0) {
        __int16 v44 = 64;
      }
      else {
        __int16 v44 = 0;
      }
      if (!v43) {
        __int16 v44 = 0;
      }
      *(_WORD *)(a1 + 80) = *(_WORD *)(a1 + 80) & 0xFFBF | v44;
      if (!sub_1B64AF840(*(void *)(a1 + 32), v36, v37, v38, v39, v40, v41, v42))
      {
        __int16 v45 = *(_WORD *)(a1 + 80) & 0xFFEF;
        goto LABEL_53;
      }
    }
  }
}

uint64_t sub_1B63F1678(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_1B63F1680(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return *(void *)(a1 + 32);
  }
  uint64_t v10 = sub_1B65F6D48(a2, a2, a3, a4, a5, a6, a7, a8);
  __int16 v18 = *(_WORD *)(a1 + 80);
  if ((v18 & 0x400) != 0) {
    return *(void *)(a1 + 32);
  }
  uint64_t v19 = v10;
  if (!v10 || (v18 & 8) == 0 && sub_1B65F7028(a2, v11, v12, v13, v14, v15, v16, v17)) {
    return *(void *)(a1 + 32);
  }
  return v19;
}

uint64_t sub_1B63F16E0(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 80) >> 3) & 1;
}

uint64_t sub_1B63F16EC(uint64_t a1)
{
  int v1 = *(_WORD *)(a1 + 80) & 7;
  if (v1 == 2 || v1 == 4) {
    return 0;
  }
  else {
    return *(void *)(a1 + 16);
  }
}

uint64_t sub_1B63F1710(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 80) & 7) == 4) {
    return 0;
  }
  else {
    return *(void *)(a1 + 32);
  }
}

uint64_t sub_1B63F1730(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 80) & 7) == 4) {
    return 0;
  }
  else {
    return *(void *)(a1 + 24);
  }
}

const void *sub_1B63F1750(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 80) & 7) == 4) {
    return 0;
  }
  uint64_t result = *(const void **)(a1 + 48);
  if (!result) {
    return result;
  }
  CFTypeID v3 = CFGetTypeID(result);
  if (v3 != sub_1B63D0278()) {
    return 0;
  }
  else {
    return *(const void **)(a1 + 48);
  }
}

uint64_t sub_1B63F17A8(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 80) & 7) == 4) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    return 0;
  }
  else {
    return sub_1B641E308(v1);
  }
}

uint64_t sub_1B63F17CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    return sub_1B649F390(result, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t sub_1B63F17DC(const __CFArray *a1)
{
  if (a1 && (CFIndex Count = CFArrayGetCount(a1), Count >= 1))
  {
    CFIndex v3 = Count;
    CFIndex v4 = 0;
    int v5 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1, v4);
      v5 |= sub_1B6604094((uint64_t)ValueAtIndex, v7, v8, v9, v10, v11, v12, v13);
      ++v4;
    }
    while (v3 != v4);
  }
  else
  {
    LOWORD(v5) = 0;
  }
  return (__int16)v5;
}

uint64_t sub_1B63F184C(uint64_t a1, float *a2, float32x4_t *a3)
{
  nullsub_1(a1);
  uint64_t v7 = v6;
  uint64_t v8 = (float32x4_t *)sub_1B6456E74(a1);
  float v9 = a2[1];
  float v10 = a2[2];
  float v11 = (float)((float)(v8->f32[1] * v9) + (float)(v8->f32[0] * *a2)) + (float)(v8->f32[2] * v10);
  if (v11 == 0.0) {
    return 0;
  }
  float v12 = (float)-(float)(a2[3]
                      + (float)((float)((float)(v9 * v7->f32[1]) + (float)(*a2 * v7->f32[0])) + (float)(v10 * v7->f32[2])))
      / v11;
  if (v12 < 0.0) {
    return 0;
  }
  if (a3) {
    *a3 = vmlaq_n_f32(*v7, *v8, v12);
  }
  return 1;
}

BOOL sub_1B63F18FC(uint64_t a1, float *a2, float32x4_t *a3)
{
  nullsub_1(a1);
  uint64_t v7 = v6;
  uint64_t v8 = (float32x4_t *)sub_1B6456E74(a1);
  float v9 = a2[1];
  float v10 = a2[2];
  float v11 = (float)((float)(v8->f32[1] * v9) + (float)(v8->f32[0] * *a2)) + (float)(v8->f32[2] * v10);
  if (a3 && v11 != 0.0) {
    *a3 = vmlaq_n_f32(*v7, *v8, (float)-(float)(a2[3]+ (float)((float)((float)(v9 * v7->f32[1]) + (float)(*a2 * v7->f32[0]))+ (float)(v10 * v7->f32[2])))/ v11);
  }
  return v11 != 0.0;
}

BOOL sub_1B63F19A0(float32x4_t *a1, float *a2, float32x4_t *a3)
{
  v14.i32[2] = 0;
  v14.i64[0] = 0;
  memset(v13, 0, sizeof(v13));
  sub_1B6456E24(v13, a1);
  int v6 = sub_1B63F184C((uint64_t)v13, a2, &v14);
  BOOL result = 0;
  if (v6)
  {
    nullsub_1(a1);
    float v9 = v8;
    float v10 = (float32x4_t *)sub_1B6456E74((uint64_t)a1);
    float32x4_t v11 = vmulq_f32(vsubq_f32(v14, *v9), vsubq_f32(v14, *v10));
    float v12 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0];
    BOOL result = v12 <= 0.0;
    if (a3)
    {
      if (v12 <= 0.0)
      {
        *a3 = v14;
        return 1;
      }
    }
  }
  return result;
}

uint64_t sub_1B63F1E14(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend__setCFXProgram(*(void **)(a1 + 32), a2, a3, a4);
  uint64_t v7 = *(void *)(a1 + 32);

  return MEMORY[0x1F4181798](v7, sel__startObservingProgram, v5, v6);
}

void sub_1B63F2120(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float32x4_t v11 = objc_alloc_init(VFXShaderArgument);
  objc_msgSend_setName_(v11, v6, a2, v7);
  objc_msgSend_setType_(v11, v8, a3, v9);
  objc_msgSend_setValue_forKey_(*(void **)(*(void *)(a1 + 32) + 48), v10, (uint64_t)v11, a2);
}

void sub_1B63F21A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t sub_1B63F21B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = sub_1B64B20C4(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);

  return sub_1B651194C(v8, v9, v10, v11);
}

void sub_1B63F2548(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_owner(*(void **)(a1 + 32), a2, a3, a4);
  objc_opt_class();
  if (objc_opt_isKindOfClass() & 1) != 0 || (objc_opt_class(), (objc_opt_isKindOfClass()))
  {
    uint64_t v13 = (CFTypeRef *)objc_msgSend___CFObject(v5, v6, v7, v8);
    CFDictionaryRef v20 = *(const __CFDictionary **)(a1 + 40);
    sub_1B6584AD0(v13, v20, v14, v15, v16, v17, v18, v19);
  }
  else
  {
    sub_1B63F2F54(16, @"Error: ShaderModifiers - unkwnown supporting class '%@'", v7, v8, v9, v10, v11, v12, (uint64_t)v5);
  }
}

uint64_t sub_1B63F269C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_userInfo(*(void **)(a1 + 32), a2, a3, a4);
  if (v5) {
    objc_msgSend_valueForKey_(v5, v6, @"parameter", v8);
  }
  else {
    objc_msgSend__setCFXProgram(*(void **)(a1 + 40), v6, v7, v8);
  }
  uint64_t v12 = objc_msgSend_defaultCenter(MEMORY[0x1E4F28EB8], v9, v10, v11);
  uint64_t v16 = objc_msgSend_owner(*(void **)(a1 + 40), v13, v14, v15);
  uint64_t v21 = objc_msgSend_worldRef(v16, v17, v18, v19);

  return objc_msgSend_postNotificationName_object_(v12, v20, @"kCFXWorldDidUpdateNotification", v21);
}

void sub_1B63F2984(uint64_t a1, void *a2, void *a3)
{
}

void sub_1B63F2D00(uint64_t a1, void *a2, __CFString *a3, uint64_t a4)
{
  if (objc_msgSend_isEqualToString_(a2, (const char *)a2, @"VFXShaderModifierEntryPointVertex", a4))
  {
    int v9 = 0;
  }
  else if (objc_msgSend_isEqualToString_(a2, v7, @"VFXShaderModifierEntryPointSurface", v8))
  {
    int v9 = 1;
  }
  else if (objc_msgSend_isEqualToString_(a2, v7, @"VFXShaderModifierEntryPointFragment", v8))
  {
    int v9 = 2;
  }
  else
  {
    if ((objc_msgSend_isEqualToString_(a2, v7, @"VFXShaderModifierEntryPointLighting", v8) & 1) == 0)
    {
      sub_1B63F2F54(16, @"Error: ShaderModifiers - unkwnown entrypoint '%@'", v10, v8, v11, v12, v13, v14, (uint64_t)a2);
      return;
    }
    int v9 = 3;
  }
  uint64_t v15 = objc_msgSend_rangeOfString_(a3, v7, @";", v8);
  if (v16 != (const char *)1)
  {
    uint64_t v19 = (void *)VFXGetResourceBundle(v15, v16, v17, v18);
    PathComponent = objc_msgSend_lastPathComponent(a3, v20, v21, v22);
    uint64_t v27 = objc_msgSend_stringByDeletingPathExtension(PathComponent, v24, v25, v26);
    uint64_t v31 = objc_msgSend_pathExtension(a3, v28, v29, v30);
    uint64_t v35 = objc_msgSend_stringByDeletingLastPathComponent(a3, v32, v33, v34);
    uint64_t v37 = objc_msgSend_pathForResource_ofType_inDirectory_(v19, v36, v27, v31, v35);
    if (v37)
    {
      uint64_t v38 = objc_msgSend_stringWithContentsOfFile_encoding_error_(NSString, v16, v37, 4, 0);
      if (v38) {
        a3 = (__CFString *)v38;
      }
    }
  }
  uint64_t v39 = objc_msgSend_length(a3, v16, v17, v18);
  uint64_t v41 = objc_msgSend_stringByReplacingOccurrencesOfString_withString_options_range_(a3, v40, @"(//.*|/\\*(.|\n)*?\\*/)", (uint64_t)&stru_1F0FCDBB0, 1024, 0, v39);
  uint64_t v45 = objc_msgSend_whitespaceAndNewlineCharacterSet(MEMORY[0x1E4F28B88], v42, v43, v44);
  uint64_t v48 = objc_msgSend_stringByTrimmingCharactersInSet_(v41, v46, v45, v47);
  if (objc_msgSend_length(v48, v49, v50, v51))
  {
    uint64_t v52 = (const void *)sub_1B6603A04(a3, v9, 0, 1, 0);
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v52);
    CFRelease(v52);
  }
}

uint64_t sub_1B63F2EE0()
{
  if (qword_1EB995FB8[0] != -1) {
    dispatch_once(qword_1EB995FB8, &unk_1F0FB6A88);
  }
  return qword_1EB995FB0;
}

os_log_t sub_1B63F2F24()
{
  os_log_t result = os_log_create("com.apple.vfx", "PointsOfInterest");
  qword_1EB995FB0 = (uint64_t)result;
  return result;
}

void sub_1B63F2F54(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v11 = [NSString alloc];
  uint64_t v13 = objc_msgSend_initWithFormat_arguments_(v11, v12, a2, (uint64_t)&a9);
  objc_msgSend_UTF8String(v13, v14, v15, v16);
  sub_1B6B34168(a1);
}

uint64_t sub_1B63F2FB8(int a1)
{
  if (qword_1EB9955C0 != -1) {
    dispatch_once(&qword_1EB9955C0, &unk_1F0FB55A8);
  }
  return qword_1EB9955C8[a1];
}

uint64_t sub_1B63F300C()
{
  CFTypeID v0 = (void *)CFPreferencesCopyAppValue(@"internalSettings", @"com.apple.vfx");
  CFIndex v3 = objc_msgSend_objectForKeyedSubscript_(v0, v1, @"showsStatistics", v2);
  qword_1EB9955C8[0] = objc_msgSend_BOOLValue(v3, v4, v5, v6);
  int v9 = objc_msgSend_objectForKeyedSubscript_(v0, v7, @"cameraControlEnabled", v8);
  qword_1EB9955D0 = objc_msgSend_BOOLValue(v9, v10, v11, v12);
  uint64_t v15 = objc_msgSend_valueForKey_(v0, v13, @"batchMaxCount", v14);
  qword_1EB9955D8 = (int)objc_msgSend_intValue(v15, v16, v17, v18);
  unk_1EB9955E0 = 0;
  uint64_t v21 = objc_msgSend_objectForKeyedSubscript_(v0, v19, @"disableLinearSpaceRendering", v20);
  qword_1EB9955E8 = objc_msgSend_BOOLValue(v21, v22, v23, v24);
  uint64_t v27 = objc_msgSend_objectForKeyedSubscript_(v0, v25, @"disableWideGamut", v26);
  qword_1EB9955F0 = objc_msgSend_BOOLValue(v27, v28, v29, v30);
  uint64_t v33 = objc_msgSend_objectForKeyedSubscript_(v0, v31, @"enableWideGamut", v32);
  qword_1EB9955F8 = objc_msgSend_BOOLValue(v33, v34, v35, v36);
  uint64_t v39 = objc_msgSend_objectForKeyedSubscript_(v0, v37, @"enablePostMorphUnifyNormals", v38);
  qword_1EB995600 = objc_msgSend_BOOLValue(v39, v40, v41, v42);
  uint64_t v45 = objc_msgSend_objectForKeyedSubscript_(v0, v43, @"enableStandardShadersWithFunctionConstants", v44);
  qword_1EB995610 = objc_msgSend_BOOLValue(v45, v46, v47, v48);
  uint64_t v51 = objc_msgSend_objectForKeyedSubscript_(v0, v49, @"forceNMOSBehavior", v50);
  qword_1EB995618 = objc_msgSend_BOOLValue(v51, v52, v53, v54);
  uint64_t v57 = objc_msgSend_objectForKeyedSubscript_(v0, v55, @"com.apple.vfx.forceOS2019Behavior", v56);
  qword_1EB995620 = objc_msgSend_BOOLValue(v57, v58, v59, v60);
  uint64_t v63 = objc_msgSend_objectForKeyedSubscript_(v0, v61, @"com.apple.vfx.forceOS2018Behavior", v62);
  qword_1EB995628 = objc_msgSend_BOOLValue(v63, v64, v65, v66);
  float v69 = objc_msgSend_objectForKeyedSubscript_(v0, v67, @"com.apple.vfx.forceOS2017Behavior", v68);
  qword_1EB995630 = objc_msgSend_BOOLValue(v69, v70, v71, v72);
  uint64_t v75 = objc_msgSend_objectForKeyedSubscript_(v0, v73, @"com.apple.vfx.forceOS2016Behavior", v74);
  qword_1EB995638 = objc_msgSend_BOOLValue(v75, v76, v77, v78);
  unk_1EB995640 = 0;
  if (objc_msgSend_objectForKeyedSubscript_(v0, v79, @"com.apple.vfx.useOneCommandQueuePerDevice", v80))
  {
    uint64_t v83 = objc_msgSend_objectForKeyedSubscript_(v0, v81, @"com.apple.vfx.useOneCommandQueuePerDevice", v82);
    uint64_t v87 = objc_msgSend_BOOLValue(v83, v84, v85, v86);
  }
  else
  {
    uint64_t v87 = 1;
  }
  qword_1EB995648 = v87;

  uint64_t v91 = objc_msgSend_standardUserDefaults(MEMORY[0x1E4F1CB18], v88, v89, v90);
  uint64_t result = objc_msgSend_BOOLForKey_(v91, v92, @"com.apple.vfx.isolateCacheMissShader", v93);
  qword_1EB995608 = result;
  return result;
}

BOOL sub_1B63F3214(int a1)
{
  if (qword_1EB9955C0 != -1) {
    dispatch_once(&qword_1EB9955C0, &unk_1F0FB55A8);
  }
  return qword_1EB9955C8[a1] != 0;
}

uint64_t sub_1B63F3270(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = objc_msgSend_mainBundle(MEMORY[0x1E4F28B50], a2, a3, a4);
  uint64_t v10 = objc_msgSend_infoDictionary(v6, v7, v8, v9);
  uint64_t v13 = objc_msgSend_objectForKeyedSubscript_(v10, v11, a1, v12);
  if (!v13) {
    return (uint64_t)a2;
  }
  uint64_t v14 = (void *)v13;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    return (uint64_t)a2;
  }

  return objc_msgSend_BOOLValue(v14, v15, v16, v17);
}

uint64_t sub_1B63F32F4(uint64_t a1, uint64_t (**a2)(uint64_t, uint64_t), uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (!*a2 || (uint64_t v6 = (*a2)(a1, a3)) == 0)
  {
    uint64_t v7 = a2[1];
    if (!v7)
    {
      uint64_t v6 = 0;
LABEL_10:
      v10[0] = MEMORY[0x1E4F143A8];
      v10[1] = 0x40000000;
      void v10[2] = sub_1B63F33F8;
      v10[3] = &unk_1E6141378;
      v10[4] = a2;
      v10[5] = a3;
      if (sub_1B64A1830(a1, (uint64_t)v10)) {
        uint64_t v6 = 3;
      }
      goto LABEL_12;
    }
    uint64_t v6 = v7(a1, a3);
  }
  if ((unint64_t)(v6 - 4) <= 0xFFFFFFFFFFFFFFFDLL) {
    goto LABEL_10;
  }
LABEL_12:
  uint64_t v8 = (void (*)(uint64_t, uint64_t))a2[2];
  if (v8) {
    v8(a1, a3);
  }
  return v6;
}

uint64_t sub_1B63F33F8(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = sub_1B63F32F4(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
  if (result == 3) {
    *a3 = 1;
  }
  return result;
}

uint64_t sub_1B63F3438(uint64_t a1, uint64_t (**a2)(uint64_t, uint64_t), uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (!*a2)
  {
    uint64_t v6 = 0;
    goto LABEL_6;
  }
  uint64_t v6 = (*a2)(a1, a3);
  if ((unint64_t)(v6 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
  {
LABEL_6:
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    void v10[2] = sub_1B63F3530;
    v10[3] = &unk_1E6141398;
    v10[4] = a2;
    v10[5] = a3;
    sub_1B64A1830(a1, (uint64_t)v10);
  }
  uint64_t v7 = (void (*)(uint64_t, uint64_t))a2[2];
  if (v7) {
    v7(a1, a3);
  }
  if (!v6)
  {
    uint64_t v8 = a2[1];
    if (v8) {
      return v8(a1, a3);
    }
    return 0;
  }
  return v6;
}

uint64_t sub_1B63F3530(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = sub_1B63F3438(a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
  if (result == 3) {
    *a3 = 1;
  }
  return result;
}

uint64_t sub_1B63F3570(uint64_t a1, uint64_t (**a2)(uint64_t, uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. CFXNodeIterateTree : null node", a3, a4, a5, a6, a7, a8, (uint64_t)"node");
    if (a2) {
      goto LABEL_3;
    }
  }
  sub_1B63F2F54(17, @"Assertion '%s' failed. CFXNodeIterateTree : no callbacks", a3, a4, a5, a6, a7, a8, (uint64_t)"callbacks");
LABEL_3:
  if (a3)
  {
    return sub_1B63F3438(a1, a2, a4);
  }
  else
  {
    return sub_1B63F32F4(a1, a2, a4);
  }
}

float32_t sub_1B63F3638(__n128 *a1, float32x4_t a2, float32x4_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a1)
  {
    float32x4_t v13 = a2;
    float32x4_t v14 = a3;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a5, a6, a7, a8, a9, a10, (uint64_t)"out");
    a2 = v13;
    a3 = v14;
  }
  float32x4_t v11 = vmulq_f32(a2, a3);
  float32_t result = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0];
  a3.f32[3] = result;
  *a1 = (__n128)a3;
  return result;
}

BOOL sub_1B63F36A8(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4)
{
  float32x4_t v4 = vsubq_f32(*a4, *a2);
  float32x4_t v5 = vsubq_f32(*a3, *a2);
  float32x4_t v6 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v5, (int32x4_t)v5), (int8x16_t)v5, 0xCuLL), vnegq_f32(v4)), v5, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v4, (int32x4_t)v4), (int8x16_t)v4, 0xCuLL));
  float32x4_t v7 = vmulq_f32(v6, v6);
  int32x2_t v8 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), v7)).u64[0];
  *(float *)v8.i32 = sqrtf(*(float *)v8.i32);
  if (*(float *)v8.i32 == 0.0)
  {
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x2B0], 8) = 0;
    float v11 = 0.0;
    *(void *)a1 = 0;
  }
  else
  {
    float32x4_t v9 = vdivq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v6, (int32x4_t)v6), (int8x16_t)v6, 0xCuLL), (float32x4_t)vdupq_lane_s32(v8, 0));
    *(void *)a1 = v9.i64[0];
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x2B0], 8) = v9.i32[2];
    float32x4_t v10 = vmulq_f32(v9, *a4);
    float v11 = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v10, 2), vaddq_f32(v10, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v10.f32, 1))).f32[0];
  }
  *(float *)(a1 + 12) = v11;
  return *(float *)v8.i32 != 0.0;
}

BOOL sub_1B63F3754(uint64_t a1, uint64_t a2)
{
  float32x4_t v4 = (float32x4_t *)sub_1B6454A6C(a2, 0);
  float32x4_t v5 = (float32x4_t *)sub_1B6454A6C(a2, 1u);
  float32x4_t v6 = (float32x4_t *)sub_1B6454A6C(a2, 2u);

  return sub_1B63F36A8(a1, v4, v5, v6);
}

uint64_t sub_1B63F37CC(int a1, float a2)
{
  values[3] = *(void **)MEMORY[0x1E4F143B8];
  values[0] = (void *)sub_1B63F3A4C(0, a2);
  values[1] = (void *)sub_1B63F3A4C(1, a2);
  values[2] = (void *)sub_1B63F3A4C(3, a2);
  float32x4_t v4 = (const void *)sub_1B63D0314();
  CFTypeRef cf = v4;
  if (a1)
  {
    if (a1 == 2)
    {
      long long v33 = xmmword_1B6E50048;
      long long v34 = unk_1B6E50058;
      long long v35 = xmmword_1B6E50068;
      long long v29 = xmmword_1B6E50008;
      long long v30 = unk_1B6E50018;
      long long v31 = xmmword_1B6E50028;
      long long v32 = unk_1B6E50038;
      long long v25 = xmmword_1B6E4FFC8;
      long long v26 = unk_1B6E4FFD8;
      long long v27 = xmmword_1B6E4FFE8;
      long long v28 = *(_OWORD *)asc_1B6E4FFF8;
      *(_OWORD *)uint64_t bytes = xmmword_1B6E4FF88;
      long long v22 = unk_1B6E4FF98;
      long long v23 = xmmword_1B6E4FFA8;
      long long v24 = unk_1B6E4FFB8;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 240);
      uint64_t v7 = (uint64_t)v4;
      int v8 = 60;
    }
    else
    {
      if (a1 != 3)
      {
        CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        goto LABEL_9;
      }
      *(_OWORD *)uint64_t bytes = xmmword_1B6E50078;
      *(void *)&long long v22 = 0x10000F000E000DLL;
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 24);
      uint64_t v7 = (uint64_t)v4;
      int v8 = 12;
    }
  }
  else
  {
    long long v25 = xmmword_1B6E4FF50;
    long long v26 = unk_1B6E4FF60;
    long long v27 = xmmword_1B6E4FF70;
    *(void *)&long long v28 = 0x14000F000E0013;
    *(_OWORD *)uint64_t bytes = xmmword_1B6E4FF10;
    long long v22 = unk_1B6E4FF20;
    long long v23 = xmmword_1B6E4FF30;
    long long v24 = unk_1B6E4FF40;
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 120);
    uint64_t v7 = (uint64_t)v4;
    int v8 = 20;
  }
  sub_1B63D0E24(v7, v8, v6, 2);
  CFRelease(v6);
LABEL_9:
  bytes[2] = 0;
  *(_WORD *)uint64_t bytes = 0;
  float32x4_t v9 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
  CFArrayRef v10 = CFArrayCreate(v5, (const void **)values, 3, MEMORY[0x1E4F1D510]);
  CFArrayRef v11 = CFArrayCreate(v5, &cf, 1, v9);
  uint64_t v17 = sub_1B63DC55C(v10, v11, (uint64_t)bytes, v12, v13, v14, v15, v16);
  for (uint64_t i = 0; i != 3; ++i)
    CFRelease(values[i]);
  CFRelease(cf);
  CFRelease(v10);
  CFRelease(v11);
  return v17;
}

uint64_t sub_1B63F3A4C(int a1, float a2)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  *(double *)&unint64_t v2 = (float)(a2 + a2) * 2.23606798;
  float v3 = *(double *)&v2 / 5.0;
  float v4 = *(double *)&v2 / 10.0;
  LODWORD(v2) = 0;
  *((float *)&v2 + 1) = -v4;
  v5.i32[0] = 0;
  float32x4_t v6 = (float32x4_t)v2;
  v6.f32[2] = v3;
  float32x4_t v7 = vaddq_f32(vmlaq_lane_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B6E4FE30, v6, 2), (float32x4_t)xmmword_1B6E4F320, (float32x2_t)v2, 1), (float32x4_t)xmmword_1B6E4FE40);
  float32x4_t v8 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B6E4FE30, v7, 2), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v7.f32, 1), (float32x4_t)xmmword_1B6E4FE50, v7.f32[0]);
  float32x4_t v9 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B6E4FE30, v8, 2), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v8.f32, 1), (float32x4_t)xmmword_1B6E4FE50, v8.f32[0]);
  float32x4_t v10 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B6E4FE30, v9, 2), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v9.f32, 1), (float32x4_t)xmmword_1B6E4FE50, v9.f32[0]);
  v5.f32[1] = v4;
  float32x4_t v11 = (float32x4_t)(unint64_t)v5;
  v11.f32[2] = -v3;
  float32x4_t v12 = vaddq_f32(vmlaq_lane_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B6E4FE30, v11, 2), (float32x4_t)xmmword_1B6E4F320, v5, 1), (float32x4_t)xmmword_1B6E4FE40);
  float32x4_t v13 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B6E4FE30, v12, 2), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v12.f32, 1), (float32x4_t)xmmword_1B6E4FE50, v12.f32[0]);
  float32x4_t v14 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B6E4FE30, v13, 2), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v13.f32, 1), (float32x4_t)xmmword_1B6E4FE50, v13.f32[0]);
  float32x4_t v15 = vmlaq_n_f32(vmlaq_lane_f32(vmulq_laneq_f32((float32x4_t)xmmword_1B6E4FE30, v14, 2), (float32x4_t)xmmword_1B6E4F320, *(float32x2_t *)v14.f32, 1), (float32x4_t)xmmword_1B6E4FE50, v14.f32[0]);
  switch(a1)
  {
    case 0:
      LODWORD(v51) = 0;
      *((float *)&v51 + 1) = -a2;
      *((void *)&v51 + 1) = 0;
      *(float *)&long long v52 = -a2;
      *(void *)((char *)&v52 + 4) = 0;
      *((float *)&v52 + 3) = -a2;
      *(void *)uint64_t v53 = 0;
      *(float *)&v53[8] = -a2;
      *(void *)&v53[12] = 0;
      *(float *)&v53[20] = -a2;
      *(void *)&v53[24] = 0;
      *(float *)&v53[32] = -v4;
      *(float *)&v53[36] = v3;
      v7.i32[3] = v8.i32[0];
      *(float32x4_t *)&v53[40] = v7;
      *(int8x16_t *)&v53[56] = vextq_s8(vextq_s8((int8x16_t)v8, (int8x16_t)v8, 0xCuLL), (int8x16_t)v9, 8uLL);
      *(int8x16_t *)&v53[72] = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v9, (int32x4_t)v9), (int8x16_t)v10, 0xCuLL);
      *(_DWORD *)&v53[88] = 0;
      *(float *)&v53[92] = -v4;
      *(float *)&v53[96] = v3;
      v14.i32[3] = v15.i32[0];
      *(float32x4_t *)&v53[100] = v14;
      *(void *)&v53[116] = vextq_s8((int8x16_t)v15, (int8x16_t)v15, 4uLL).u64[0];
      *(_DWORD *)&v53[124] = 0;
      v12.i32[3] = v13.i32[0];
      *(float *)&v53[128] = v4;
      *(float *)&v53[132] = -v3;
      *(float32x4_t *)&v53[136] = v12;
      *(void *)&v53[152] = vextq_s8((int8x16_t)v13, (int8x16_t)v13, 4uLL).u64[0];
      LODWORD(v54) = 0;
      *((float *)&v54 + 1) = a2;
      *((void *)&v54 + 1) = 0;
      *(void *)((char *)&v55 + 4) = 0;
      *(float *)&long long v55 = a2;
      *((float *)&v55 + 3) = a2;
      *(void *)uint64_t v56 = 0;
      *(void *)&v56[12] = 0;
      *(float *)&v56[8] = a2;
      *(float *)&v56[20] = a2;
      int v57 = 0;
      CFDataRef v16 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v51, 252);
      CFDataRef v20 = v16;
      uint64_t v21 = 0;
      goto LABEL_7;
    case 1:
      int32x4_t v23 = (int32x4_t)vmulq_f32(v10, v10);
      v23.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v23, 2), vadd_f32(*(float32x2_t *)v23.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v23.i8, 1))).u32[0];
      float32x2_t v24 = vrsqrte_f32((float32x2_t)v23.u32[0]);
      float32x2_t v25 = vmul_f32(v24, vrsqrts_f32((float32x2_t)v23.u32[0], vmul_f32(v24, v24)));
      float32x4_t v26 = vmulq_n_f32(v10, vmul_f32(v25, vrsqrts_f32((float32x2_t)v23.u32[0], vmul_f32(v25, v25))).f32[0]);
      int32x4_t v27 = (int32x4_t)vmulq_f32(v6, v6);
      v27.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v27, 2), vadd_f32(*(float32x2_t *)v27.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v27.i8, 1))).u32[0];
      float32x2_t v28 = vrsqrte_f32((float32x2_t)v27.u32[0]);
      float32x2_t v29 = vmul_f32(v28, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v28, v28)));
      v27.i32[0] = vmul_f32(v29, vrsqrts_f32((float32x2_t)v27.u32[0], vmul_f32(v29, v29))).u32[0];
      int32x4_t v30 = (int32x4_t)vmulq_f32(v7, v7);
      v30.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v30, 2), vadd_f32(*(float32x2_t *)v30.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v30.i8, 1))).u32[0];
      int8x16_t v31 = (int8x16_t)vmulq_n_f32(v6, *(float *)v27.i32);
      *(float32x2_t *)v27.i8 = vrsqrte_f32((float32x2_t)v30.u32[0]);
      *(float32x2_t *)v27.i8 = vmul_f32(*(float32x2_t *)v27.i8, vrsqrts_f32((float32x2_t)v30.u32[0], vmul_f32(*(float32x2_t *)v27.i8, *(float32x2_t *)v27.i8)));
      int8x16_t v32 = (int8x16_t)vmulq_n_f32(v7, vmul_f32(*(float32x2_t *)v27.i8, vrsqrts_f32((float32x2_t)v30.u32[0], vmul_f32(*(float32x2_t *)v27.i8, *(float32x2_t *)v27.i8))).f32[0]);
      int32x4_t v33 = (int32x4_t)vmulq_f32(v8, v8);
      v33.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v33, 2), vadd_f32(*(float32x2_t *)v33.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v33.i8, 1))).u32[0];
      *(float32x2_t *)v30.i8 = vrsqrte_f32((float32x2_t)v33.u32[0]);
      *(float32x2_t *)v30.i8 = vmul_f32(*(float32x2_t *)v30.i8, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(*(float32x2_t *)v30.i8, *(float32x2_t *)v30.i8)));
      v33.i32[0] = vmul_f32(*(float32x2_t *)v30.i8, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(*(float32x2_t *)v30.i8, *(float32x2_t *)v30.i8))).u32[0];
      int32x4_t v34 = (int32x4_t)vmulq_f32(v9, v9);
      int8x16_t v35 = (int8x16_t)vmulq_n_f32(v8, *(float *)v33.i32);
      v33.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v34, 2), vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v34.i8, 1))).u32[0];
      *(float32x2_t *)v34.i8 = vrsqrte_f32((float32x2_t)v33.u32[0]);
      *(float32x2_t *)v34.i8 = vmul_f32(*(float32x2_t *)v34.i8, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(*(float32x2_t *)v34.i8, *(float32x2_t *)v34.i8)));
      int8x16_t v36 = (int8x16_t)vmulq_n_f32(v9, vmul_f32(*(float32x2_t *)v34.i8, vrsqrts_f32((float32x2_t)v33.u32[0], vmul_f32(*(float32x2_t *)v34.i8, *(float32x2_t *)v34.i8))).f32[0]);
      int32x4_t v37 = (int32x4_t)vmulq_f32(v12, v12);
      v37.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v37, 2), vadd_f32(*(float32x2_t *)v37.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v37.i8, 1))).u32[0];
      *(float32x2_t *)v34.i8 = vrsqrte_f32((float32x2_t)v37.u32[0]);
      *(float32x2_t *)v34.i8 = vmul_f32(*(float32x2_t *)v34.i8, vrsqrts_f32((float32x2_t)v37.u32[0], vmul_f32(*(float32x2_t *)v34.i8, *(float32x2_t *)v34.i8)));
      int8x16_t v38 = (int8x16_t)vmulq_n_f32(v12, vmul_f32(*(float32x2_t *)v34.i8, vrsqrts_f32((float32x2_t)v37.u32[0], vmul_f32(*(float32x2_t *)v34.i8, *(float32x2_t *)v34.i8))).f32[0]);
      int32x4_t v39 = (int32x4_t)vmulq_f32(v13, v13);
      v39.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v39, 2), vadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v39.i8, 1))).u32[0];
      *(float32x2_t *)v34.i8 = vrsqrte_f32((float32x2_t)v39.u32[0]);
      *(float32x2_t *)v34.i8 = vmul_f32(*(float32x2_t *)v34.i8, vrsqrts_f32((float32x2_t)v39.u32[0], vmul_f32(*(float32x2_t *)v34.i8, *(float32x2_t *)v34.i8)));
      int8x16_t v40 = (int8x16_t)vmulq_n_f32(v13, vmul_f32(*(float32x2_t *)v34.i8, vrsqrts_f32((float32x2_t)v39.u32[0], vmul_f32(*(float32x2_t *)v34.i8, *(float32x2_t *)v34.i8))).f32[0]);
      int32x4_t v41 = (int32x4_t)vmulq_f32(v14, v14);
      v41.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v41, 2), vadd_f32(*(float32x2_t *)v41.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v41.i8, 1))).u32[0];
      *(float32x2_t *)v34.i8 = vrsqrte_f32((float32x2_t)v41.u32[0]);
      *(float32x2_t *)v34.i8 = vmul_f32(*(float32x2_t *)v34.i8, vrsqrts_f32((float32x2_t)v41.u32[0], vmul_f32(*(float32x2_t *)v34.i8, *(float32x2_t *)v34.i8)));
      v41.i32[0] = vmul_f32(*(float32x2_t *)v34.i8, vrsqrts_f32((float32x2_t)v41.u32[0], vmul_f32(*(float32x2_t *)v34.i8, *(float32x2_t *)v34.i8))).u32[0];
      int32x4_t v42 = (int32x4_t)vmulq_f32(v15, v15);
      v42.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v42, 2), vadd_f32(*(float32x2_t *)v42.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v42.i8, 1))).u32[0];
      int8x16_t v43 = (int8x16_t)vmulq_n_f32(v14, *(float *)v41.i32);
      *(float32x2_t *)v41.i8 = vrsqrte_f32((float32x2_t)v42.u32[0]);
      *(float32x2_t *)v41.i8 = vmul_f32(*(float32x2_t *)v41.i8, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(*(float32x2_t *)v41.i8, *(float32x2_t *)v41.i8)));
      int8x16_t v44 = (int8x16_t)vmulq_n_f32(v15, vmul_f32(*(float32x2_t *)v41.i8, vrsqrts_f32((float32x2_t)v42.u32[0], vmul_f32(*(float32x2_t *)v41.i8, *(float32x2_t *)v41.i8))).f32[0]);
      int32x4_t v45 = (int32x4_t)vmulq_f32(v11, v11);
      v45.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v45, 2), vadd_f32(*(float32x2_t *)v45.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v45.i8, 1))).u32[0];
      *(float32x2_t *)v42.i8 = vrsqrte_f32((float32x2_t)v45.u32[0]);
      *(float32x2_t *)v42.i8 = vmul_f32(*(float32x2_t *)v42.i8, vrsqrts_f32((float32x2_t)v45.u32[0], vmul_f32(*(float32x2_t *)v42.i8, *(float32x2_t *)v42.i8)));
      long long v51 = xmmword_1B6E4F330;
      long long v52 = xmmword_1B6E4FF00;
      *(_OWORD *)uint64_t v53 = xmmword_1B6E4F340;
      *(void *)&v53[16] = 0xBF80000000000000;
      v26.i32[3] = v31.i32[0];
      int8x16_t v46 = vextq_s8(v31, v31, 0xCuLL);
      v31.i32[3] = v32.i32[0];
      *(_DWORD *)&v53[24] = 0;
      *(int8x16_t *)&v53[28] = v31;
      *(int8x16_t *)&v53[44] = vextq_s8(vextq_s8(v32, v32, 0xCuLL), v35, 8uLL);
      *(int8x16_t *)&v53[60] = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v35, (int32x4_t)v35), v36, 0xCuLL);
      float32x4_t v47 = vmulq_n_f32(v11, vmul_f32(*(float32x2_t *)v42.i8, vrsqrts_f32((float32x2_t)v45.u32[0], vmul_f32(*(float32x2_t *)v42.i8, *(float32x2_t *)v42.i8))).f32[0]);
      *(float32x4_t *)&v53[76] = v26;
      *(int8x16_t *)&v53[92] = vextq_s8(v46, v43, 8uLL);
      *(int8x16_t *)&v53[108] = vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v43, (int32x4_t)v43), v44, 0xCuLL);
      v47.i32[3] = v38.i32[0];
      *(float32x4_t *)&v53[124] = v47;
      *(int8x16_t *)&v53[140] = vextq_s8(vextq_s8(v38, v38, 0xCuLL), v40, 8uLL);
      *(_DWORD *)&v53[156] = v40.i32[2];
      long long v54 = xmmword_1B6E4F320;
      long long v55 = xmmword_1B6E4F390;
      *(_OWORD *)uint64_t v56 = xmmword_1B6E4F2E0;
      *(void *)&v56[16] = 0x3F80000000000000;
      int v57 = 0;
      CFDataRef v16 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v51, 252);
      CFDataRef v20 = v16;
      uint64_t v21 = 1;
LABEL_7:
      uint64_t v22 = 3;
      goto LABEL_8;
    case 3:
      long long v51 = xmmword_1B6E4FE60;
      long long v52 = xmmword_1B6E4FE70;
      *(_OWORD *)uint64_t v53 = xmmword_1B6E4FE80;
      *(_OWORD *)&v53[16] = xmmword_1B6E4FE90;
      *(_OWORD *)&v53[32] = xmmword_1B6E4FEA0;
      *(_OWORD *)&v53[48] = xmmword_1B6E4FEB0;
      *(_OWORD *)&v53[64] = xmmword_1B6E4FEC0;
      *(_OWORD *)&v53[80] = xmmword_1B6E4FED0;
      *(_OWORD *)&v53[96] = xmmword_1B6E4FEE0;
      *(_OWORD *)&v53[112] = xmmword_1B6E4FEF0;
      *(void *)&v53[128] = 1061997773;
      CFDataRef v16 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v51, 168);
      CFDataRef v20 = v16;
      uint64_t v21 = 3;
      uint64_t v22 = 2;
LABEL_8:
      uint64_t v48 = (const void *)sub_1B641CF98(v16, v21, 21, v22, 1, v17, v18, v19);
      CFRelease(v20);
      uint64_t v49 = sub_1B641E168((uint64_t)v48);
      if (v48) {
        CFRelease(v48);
      }
      return v49;
  }

  return sub_1B641E168(0);
}

uint64_t sub_1B63F408C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1B641D8A0(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result >= 1)
  {
    uint64_t v18 = result;
    for (uint64_t i = 0; i != v18; ++i)
    {
      v39.i32[2] = 0;
      v39.i64[0] = 0;
      *(double *)v20.i64 = sub_1B641E208(a1, i, v12, v13, v14, v15, v16, v17);
      int32x4_t v21 = (int32x4_t)vmulq_f32(v20, v20);
      v21.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v21, 2), vadd_f32(*(float32x2_t *)v21.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v21.i8, 1))).u32[0];
      float32x2_t v22 = vrsqrte_f32((float32x2_t)v21.u32[0]);
      float32x2_t v23 = vmul_f32(v22, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v22, v22)));
      float32x4_t v39 = vmulq_n_f32(v20, vmul_f32(v23, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v23, v23))).f32[0]);
      sub_1B647B844(a2, (uint64_t)&v39, 1, v24, v25, v26, v27, v28);
      float v36 = v39.f32[1];
      float v29 = asinf(v39.f32[0]) / 3.14159265 + 0.5;
      float v37 = v29;
      *(float *)&unsigned int v30 = 1.0 - (asinf(v36) / 3.14159265 + 0.5);
      unint64_t v38 = __PAIR64__(v30, LODWORD(v37));
      uint64_t result = sub_1B647B9C8(a3, (uint64_t)&v38, 1, v31, v32, v33, v34, v35);
    }
  }
  return result;
}

uint64_t sub_1B63F41C8(int a1, uint64_t a2, float a3)
{
  float32x2_t v5 = (const void *)sub_1B63F37CC(0, a3);
  uint64_t v6 = 6;
  if (a2 > 6) {
    uint64_t v6 = a2;
  }
  int v11 = vcvtpd_s64_f64(log((double)(v6 - 5)) / 1.09861229);
  if (v11 < 1)
  {
    uint64_t v27 = v5;
  }
  else
  {
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    int v13 = v11 + 1;
    uint64_t v14 = (const CFArrayCallBacks *)MEMORY[0x1E4F1D510];
    do
    {
      uint64_t v15 = sub_1B64AC5F8((uint64_t)v5, 0, 0, 0, v7, v8, v9, v10);
      float32x4_t v20 = sub_1B64AC5F8((uint64_t)v5, 1, 0, 0, v16, v17, v18, v19);
      values = 0;
      uint64_t v26 = sub_1B64ABD78((uint64_t)v5, 0, 0, v21, v22, v23, v24, v25);
      values = (void *)sub_1B63DCC64((uint64_t)v5, 0, v26, (uint64_t)v15, (uint64_t)v20, 0, 1);
      uint64_t v27 = (const void *)-[VFXMesh __createCFObject]_0();
      sub_1B64AC000((uint64_t)v27, v15, 0, 0, v28, v29, v30, v31);
      sub_1B64AC000((uint64_t)v27, v20, 0, 0, v32, v33, v34, v35);
      CFArrayRef v36 = CFArrayCreate(v12, (const void **)&values, 1, v14);
      sub_1B64AD458((uint64_t)v27, v36, v37, v38, v39, v40, v41, v42);
      if (values)
      {
        CFRelease(values);
        values = 0;
      }
      CFRelease(v36);
      if (v5) {
        CFRelease(v5);
      }
      --v13;
      float32x2_t v5 = v27;
    }
    while (v13 > 1);
  }
  int8x16_t v43 = (const void *)sub_1B647B3F8(0, 1, 0, 3, 1, v8, v9, v10);
  float32x4_t v47 = (const void *)sub_1B647B3F8(0, 3, 0, 2, 1, v44, v45, v46);
  long long v52 = sub_1B64AC5F8((uint64_t)v27, 0, 0, 0, v48, v49, v50, v51);
  sub_1B63F408C((uint64_t)v52, (uint64_t)v43, (uint64_t)v47, v53, v54, v55, v56, v57);
  uint64_t v62 = sub_1B64AC5F8((uint64_t)v27, 1, 0, 0, v58, v59, v60, v61);
  sub_1B64AC8AC((uint64_t)v27, v62, v63, v64, v65, v66, v67, v68);
  sub_1B64AC000((uint64_t)v27, v43, 0, 0, v69, v70, v71, v72);
  sub_1B64AC000((uint64_t)v27, v47, 0, 0, v73, v74, v75, v76);
  if (v43) {
    CFRelease(v43);
  }
  if (v47) {
    CFRelease(v47);
  }
  sub_1B64AD578((uint64_t)v27, a1, v77, v78, v79, v80, v81, v82);
  uint64_t v90 = sub_1B64AB4D0((uint64_t)v27, v83, v84, v85, v86, v87, v88, v89);
  if (v27) {
    CFRelease(v27);
  }
  return v90;
}

void *sub_1B63F4434(CFTypeRef cf, const void *a2, void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696
    && (uint64_t v15 = (uint64_t (*)(CFTypeRef, const void *, void *, size_t, uint64_t, uint64_t))ClassWithTypeID[13]) != 0)
  {
    return (void *)v15(cf, a2, a3, a4, a5, a6);
  }
  else
  {
    return memcpy(a3, a2, a4);
  }
}

void *sub_1B63F4524(CFTypeRef cf, void *a2, const void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696
    && (uint64_t v15 = (uint64_t (*)(CFTypeRef, void *, const void *, size_t, uint64_t, uint64_t))ClassWithTypeID[12]) != 0)
  {
    return (void *)v15(cf, a2, a3, a4, a5, a6);
  }
  else
  {
    return memcpy(a2, a3, a4);
  }
}

void *(*sub_1B63F4614(const void *a1))(int a1, const void *a2, void *__dst, size_t __n)
{
  CFGetTypeID(a1);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return sub_1B63F465C;
  }
  uint64_t result = (void *(*)(int, const void *, void *, size_t))ClassWithTypeID[13];
  if (!result) {
    return sub_1B63F465C;
  }
  return result;
}

void *sub_1B63F465C(int a1, const void *a2, void *__dst, size_t __n)
{
  return memcpy(__dst, a2, __n);
}

void *(*sub_1B63F4668(const void *a1))(int a1, void *__dst, void *__src, size_t __n)
{
  CFGetTypeID(a1);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return sub_1B63F46B0;
  }
  uint64_t result = (void *(*)(int, void *, void *, size_t))ClassWithTypeID[12];
  if (!result) {
    return sub_1B63F46B0;
  }
  return result;
}

void *sub_1B63F46B0(int a1, void *__dst, void *__src, size_t __n)
{
  return memcpy(__dst, __src, __n);
}

uint64_t sub_1B63F46C0(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID == 749405696 && (uint64_t v16 = (uint64_t (*)(CFTypeRef))ClassWithTypeID[23]) != 0)
  {
    return v16(cf);
  }
  else
  {
    sub_1B63F2F54(16, @"Error: object %@ doesn't conform to the copying protocol", v10, v11, v12, v13, v14, v15, (uint64_t)cf);
    return 0;
  }
}

void *sub_1B63F476C(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  CFGetTypeID(cf);
  uint64_t result = (void *)_CFRuntimeGetClassWithTypeID();
  if (*result == 749405696)
  {
    uint64_t v11 = (uint64_t (*)(CFTypeRef, uint64_t))result[24];
    if (v11)
    {
      return (void *)v11(cf, a2);
    }
  }
  return result;
}

uint64_t sub_1B63F4808(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return 0;
  }
  uint64_t v10 = (uint64_t (*)(CFTypeRef))ClassWithTypeID[25];
  if (!v10) {
    return 0;
  }

  return v10(cf);
}

void *sub_1B63F48A0(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  CFGetTypeID(cf);
  uint64_t result = (void *)_CFRuntimeGetClassWithTypeID();
  if (*result == 749405696)
  {
    uint64_t v11 = (uint64_t (*)(CFTypeRef, uint64_t))result[26];
    if (v11)
    {
      return (void *)v11(cf, a2);
    }
  }
  return result;
}

uint64_t sub_1B63F493C(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return 0;
  }
  uint64_t v13 = (uint64_t (*)(CFTypeRef, uint64_t, uint64_t, uint64_t))ClassWithTypeID[15];
  if (!v13) {
    return 0;
  }

  return v13(cf, a2, a3, a4);
}

uint64_t sub_1B63F49F8(CFTypeRef cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  CFGetTypeID(cf);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return 0;
  }
  uint64_t v12 = (uint64_t (*)(CFTypeRef, uint64_t, uint64_t))ClassWithTypeID[16];
  if (!v12) {
    return 0;
  }

  return v12(cf, a2, a3);
}

void sub_1B63F4AAC(void *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  if (a2)
  {
    if (qword_1E9DDA6C8 != -1) {
      dispatch_once(&qword_1E9DDA6C8, &unk_1F0FB55C8);
    }
    uint64_t v10 = qword_1E9DDA6C0;
    CFGetTypeID(cf);
    ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
    uint64_t v18 = *ClassWithTypeID;
    if (*ClassWithTypeID == 749405696) {
      uint64_t v19 = ClassWithTypeID;
    }
    else {
      uint64_t v19 = 0;
    }
    if (*((void *)cf + 6) == a2)
    {
      uint64_t v20 = *((void *)cf + 7);
      if (v20)
      {
        uint64_t v21 = v20 - 1;
        *((void *)cf + 7) = v21;
        if (!v21)
        {
          if (v18 == 749405696)
          {
            uint64_t v22 = (void (*)(void *, uint64_t))v19[19];
            if (v22) {
              v22(cf, a2);
            }
          }
          uint64_t v23 = *(void (**)(void *, uint64_t))(v10 + 16);
          if (v23) {
            v23(cf, a2);
          }
          if (v18 == 749405696)
          {
            uint64_t v24 = (void (*)(void *, void *))v19[17];
            if (v24)
            {
              v25[0] = MEMORY[0x1E4F143A8];
              v25[1] = 3221225472;
              v25[2] = sub_1B63F4C60;
              void v25[3] = &unk_1E61413B8;
              v25[4] = a2;
              v24(cf, v25);
            }
          }
          sub_1B63F4C70(cf, a2, v12, v13, v14, v15, v16, v17);
          *((void *)cf + 6) = 0;
        }
      }
      else if ((byte_1E9DDA6B8 & 1) == 0)
      {
        byte_1E9DDA6B8 = 1;
        sub_1B63F2F54(16, @"Error: invalid ref count for entity %@", v12, v13, v14, v15, v16, v17, (uint64_t)cf);
      }
    }
  }
}

uint64_t sub_1B63F4C60(int a1, CFTypeRef cf)
{
  return sub_1B63F4AAC(cf);
}

void sub_1B63F4C70(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = sub_1B64B2008(a2, a2, a3, a4, a5, a6, a7, a8);
  if (v9)
  {
    uint64_t v16 = v9;
    sub_1B64239A4(v9, a1, v10, v11, v12, v13, v14, v15);
    sub_1B6424AFC(v16, (uint64_t)a1);
  }
}

void sub_1B63F4CCC(uint64_t *cf, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!cf) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  if (a2)
  {
    if (qword_1E9DDA6C8 != -1) {
      dispatch_once(&qword_1E9DDA6C8, &unk_1F0FB55C8);
    }
    uint64_t v10 = (void *)qword_1E9DDA6C0;
    CFGetTypeID(cf);
    ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
    uint64_t v18 = *ClassWithTypeID;
    if (*ClassWithTypeID == 749405696) {
      uint64_t v19 = ClassWithTypeID;
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v20 = cf[6];
    if (!v20 || v20 == a2)
    {
      ++cf[7];
      if (v20) {
        return;
      }
    }
    else
    {
      if (v18 == 749405696)
      {
        uint64_t v21 = (void (*)(uint64_t *, uint64_t))v19[19];
        if (v21) {
          v21(cf, cf[6]);
        }
      }
      uint64_t v22 = (void (*)(uint64_t *, uint64_t))v10[2];
      if (v22) {
        v22(cf, v20);
      }
      sub_1B63F4C70(cf, v20, v12, v13, v14, v15, v16, v17);
      cf[7] = 1;
    }
    cf[6] = a2;
    uint64_t v23 = (void (*)(uint64_t *, uint64_t))v10[1];
    if (v23) {
      v23(cf, a2);
    }
    if (v18 == 749405696)
    {
      uint64_t v24 = (void (*)(uint64_t *, uint64_t))v19[18];
      if (v24) {
        v24(cf, a2);
      }
      uint64_t v25 = (void (*)(uint64_t *, void *))v19[17];
      if (v25)
      {
        v30[0] = MEMORY[0x1E4F143A8];
        v30[1] = 3221225472;
        _OWORD v30[2] = sub_1B63F4EF8;
        v30[3] = &unk_1E61413B8;
        unsigned char v30[4] = a2;
        v25(cf, v30);
      }
    }
    if (v20)
    {
      uint64_t v26 = (void (*)(uint64_t *, uint64_t))v10[4];
      if (v26) {
        v26(cf, v20);
      }
      if (v18 == 749405696)
      {
        uint64_t v27 = (void (*)(uint64_t *, uint64_t))v19[21];
        if (v27) {
          v27(cf, v20);
        }
      }
    }
    uint64_t v28 = (void (*)(uint64_t *, uint64_t))v10[3];
    if (v28) {
      v28(cf, a2);
    }
    if (v18 == 749405696)
    {
      uint64_t v29 = (void (*)(uint64_t *, uint64_t))v19[20];
      if (v29) {
        v29(cf, a2);
      }
    }
  }
}

uint64_t sub_1B63F4EF8(int a1, CFTypeRef cf)
{
  return sub_1B63F4CCC(cf);
}

uint64_t sub_1B63F4F08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  return *(void *)(a1 + 48);
}

uint64_t sub_1B63F4F54(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"object");
  }
  if ((sub_1B6583B18(a1) & 1) == 0) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Must call GetWorld with an entity", v9, v10, v11, v12, v13, v14, (uint64_t)"CFTypeIsCFXEntity(object)");
  }
  return a1[6];
}

uint64_t sub_1B63F4FC8(const void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  CFGetTypeID(a1);
  ClassWithTypeID = (void *)_CFRuntimeGetClassWithTypeID();
  if (*ClassWithTypeID != 749405696) {
    return 0;
  }
  float32x2_t v5 = (uint64_t (*)(const void *, uint64_t))ClassWithTypeID[22];
  if (!v5) {
    return 0;
  }

  return v5(a1, a2);
}

uint64_t sub_1B63F503C()
{
  sub_1B65833C8();
  uint64_t result = _CFRuntimeGetClassWithTypeID();
  qword_1E9DDA6C0 = result + 136;
  return result;
}

void *sub_1B63F5064(uint64_t a1, uint64_t a2)
{
  uint64_t result = (void *)sub_1B6DABD0C(a1, "Jittering");
  void *result = &unk_1F0FB5390;
  result[3] = a2;
  result[4] = 0;
  return result;
}

uint64_t sub_1B63F50B0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v4, *(_WORD *)(a1 + 8), 9273, 1656467160);
  return sub_1B63D0050(a2, v4, 1);
}

uint64_t sub_1B63F512C@<X0>(uint64_t a1@<X8>)
{
  v3[1] = *MEMORY[0x1E4F143B8];
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v3, 6893, 9273, 1656467160);
  return sub_1B63D0050(a1, v3, 1);
}

unint64_t sub_1B63F51A8(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unint64_t v4 = *(unsigned __int16 *)(a1 + 8);
  uint64_t v5 = *a3;
  if (v5)
  {
    uint64_t v6 = (uint64_t *)*((void *)a3 + 1);
    uint64_t v7 = 8 * v5;
    do
    {
      uint64_t v8 = *v6++;
      uint64_t v13 = v8;
      uint64_t v9 = CFX::RG::ResourceIdentifier::id((CFX::RG::ResourceIdentifier *)&v13);
      unint64_t v4 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v4 ^ ((0x9DDFEA08EB382D69 * (v9 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v9 ^ v4)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v9 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v9 ^ v4)))) >> 47));
      v7 -= 8;
    }
    while (v7);
  }
  char v10 = sub_1B6447D40(*(void *)(a1 + 24));
  uint64_t v11 = *(void *)(a1 + 32);
  if (v10) {
    *(void *)(a1 + 32) = ++v11;
  }
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v4 ^ ((0x9DDFEA08EB382D69 * (v11 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v11 ^ v4)))) ^ ((0x9DDFEA08EB382D69 * (v4 ^ ((0x9DDFEA08EB382D69 * (v11 ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69 * (v11 ^ v4)))) >> 47));
}

void sub_1B63F526C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (sub_1B6447D40(*(void *)(a1 + 24)))
  {
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v35, 9273, 9273, 1656467160);
    CFX::RG::ResourceReference::ResourceReference((uint64_t)v36, v35);
    uint64_t v6 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"Jittering input color", (CFX::RG::ResourceReference *)v36);
    uint64_t v7 = (_OWORD *)CFX::RG::Resource::constTextureDesc(v6);
    long long v8 = v7[1];
    v34[0] = *v7;
    v34[1] = v8;
    long long v9 = v7[5];
    long long v11 = v7[2];
    long long v10 = v7[3];
    v34[4] = v7[4];
    v34[5] = v9;
    void v34[2] = v11;
    void v34[3] = v10;
    long long v12 = v7[9];
    long long v14 = v7[6];
    long long v13 = v7[7];
    v34[8] = v7[8];
    v34[9] = v12;
    v34[6] = v14;
    v34[7] = v13;
    uint64_t v15 = sub_1B63CFDE4(a3, (uint64_t)"Jittering output color", v34);
    uint64_t v16 = (_OWORD *)CFX::RG::Resource::constTextureDesc(v6);
    CFX::RG::TextureDescriptorReference::withSampleCount(v16, 1, (uint64_t)v30);
    uint64_t v18 = CFX::RG::copyIfNeeded((CFX::RG *)a3, v6, 0, (CFX::RG::Pass *)v30, (const CFX::RG::TextureDescriptorReference *)"Jittering color input resolve", v17);
    uint64_t v19 = *(CFX::CrossFrameResourceManager **)(a2 + 32);
    uint64_t v20 = *(void *)(a1 + 24);
    v30[0] = "Jittering";
    v30[1] = v20;
    __int16 v31 = 0;
    uint64_t v32 = v18;
    uint64_t v33 = v15;
    uint64_t v21 = sub_1B644E60C(a3, v19, (uint64_t)v30);
    if (sub_1B6447D6C(*(void *)(a1 + 24)))
    {
      uint64_t v22 = *(unsigned char **)(v21 + 24);
      char v23 = *v22;
      if (*v22)
      {
        uint64_t v24 = v22 + 1;
        __int16 v25 = -25147;
        do
        {
          __int16 v25 = 403 * (v25 ^ v23);
          int v26 = *v24++;
          char v23 = v26;
        }
        while (v26);
      }
      else
      {
        __int16 v25 = -25147;
      }
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v29, *(_WORD *)(a1 + 8), v25, 1656467160);
      CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v29, (unint64_t)v15, v21);
    }
  }
  else
  {
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v28, 9273, 9273, 1656467160);
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v27, *(_WORD *)(a1 + 8), 64484, 1656467160);
    CFX::RG::RenderGraphBuilder::aliasResourceReference((uint64_t)a3, v28, v27);
  }
}

void sub_1B63F5454()
{
}

uint64_t sub_1B63F574C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_setTessellationPartitionMode_(a2, (const char *)a2, *(unsigned char *)(a1 + 40) & 3, a4);
  objc_msgSend_setTessellationFactorStepFunction_(a2, v6, ((unint64_t)*(unsigned __int8 *)(a1 + 40) >> 2) & 3, v7);
  objc_msgSend_setTessellationControlPointIndexType_(a2, v8, ((unint64_t)*(unsigned __int8 *)(a1 + 40) >> 4) & 3, v9);
  objc_msgSend_setTessellationFactorScaleEnabled_(a2, v10, (*(unsigned __int8 *)(a1 + 40) >> 6) & 1, v11);
  objc_msgSend_setTessellationFactorFormat_(a2, v12, 0, v13);
  objc_msgSend_setTessellationOutputWindingOrder_(a2, v14, 1, v15);
  uint64_t v19 = objc_msgSend_maxTessellationFactor(*(void **)(a1 + 32), v16, v17, v18);

  return MEMORY[0x1F4181798](a2, sel_setMaxTessellationFactor_, v19, v20);
}

uint64_t sub_1B63F687C(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B63F68AC()
{
  if (qword_1EB996E90[0] != -1) {
    dispatch_once_f(qword_1EB996E90, &qword_1EB995F38, (dispatch_function_t)sub_1B63F687C);
  }
  uint64_t v0 = sub_1B63C8D44(qword_1EB995F38, 0x30uLL);
  sub_1B63F72E4(v0 + 16, 32);
  *(void *)(v0 + 4_Block_object_dispose(&STACK[0x2B0], 8) = sub_1B661D7EC(0x7FFFFFFFLL);
  return v0;
}

void sub_1B63F6930(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 56) < a2)
  {
    int v4 = *(_DWORD *)(a1 + 44);
    if (v4 != -15)
    {
      unint64_t v5 = 0;
      do
      {
        if (*(_WORD *)(*(void *)(a1 + 32) + 2 * v5))
        {
          uint64_t v6 = *(void *)(a1 + 24);
          sub_1B66215D8(*(_DWORD **)(v6 + 8 * v5), a2);
          uint64_t v14 = sub_1B6621548(*(void *)(v6 + 8 * v5), v7, v8, v9, v10, v11, v12, v13);
          bzero((void *)(v14 + 8 * *(unsigned int *)(a1 + 56)), 8 * (a2 - *(_DWORD *)(a1 + 56)));
          int v4 = *(_DWORD *)(a1 + 44);
        }
        ++v5;
      }
      while (v5 < (v4 + 15));
    }
    *(_DWORD *)(a1 + 56) = a2;
  }
}

void sub_1B63F69D4(uint64_t a1)
{
  uint64_t v2 = a1 + 16;
  sub_1B63F6A1C(a1 + 16, (uint64_t)&unk_1F0FB55E8);
  sub_1B63F6ABC(v2);
  sub_1B661DB58(*(void *)(a1 + 48), v3, v4, v5, v6, v7, v8, v9);
  *(_DWORD *)(a1 + 56) = 0;
}

uint64_t sub_1B63F6A1C(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 28);
  if (v2 != -15)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      if (*(_WORD *)(*(void *)(v4 + 16) + 2 * v6))
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(a2 + 16))(a2, *(void *)(*(void *)v4 + 8 * v6), *(void *)(v4 + 8) + v5);
        int v2 = *(_DWORD *)(v4 + 28);
      }
      ++v6;
      v5 += 8;
    }
    while (v6 < (v2 + 15));
  }
  return result;
}

void sub_1B63F6AA4(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_1B63F6AB4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
}

void sub_1B63F6ABC(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
}

void sub_1B63F6B20(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = HIDWORD(a2);
  if (HIDWORD(a2))
  {
    int v4 = 0;
    __int16 v5 = WORD1(a2);
    int v6 = (unsigned __int16)a2;
    do
    {
      unsigned int v7 = sub_1B661AF18(v6, (unsigned __int16)(v4 + v5));
      if (*(_DWORD *)(a1 + 44) != -15)
      {
        unint64_t v15 = 0;
        uint64_t v16 = v7;
        do
        {
          if (*(_WORD *)(*(void *)(a1 + 32) + 2 * v15))
          {
            uint64_t v17 = *(void *)(a1 + 24);
            if (sub_1B6621414(*(void *)(v17 + 8 * v15), (uint64_t)v8, v9, v10, v11, v12, v13, v14) > v16)
            {
              uint64_t v18 = (void **)sub_1B66214AC(*(void *)(v17 + 8 * v15), v16, v9, v10, v11, v12, v13, v14);
              uint64_t v8 = *v18;
              if (*v18)
              {
                uint64_t v19 = (uint64_t *)v18;
                sub_1B661DA28(*(void *)(a1 + 48), v8, v9, v10, v11, v12, v13, v14);
                sub_1B659EC24(*v19);
                *uint64_t v19 = 0;
              }
            }
          }
          ++v15;
        }
        while (v15 < (*(_DWORD *)(a1 + 44) + 15));
      }
      ++v4;
    }
    while (v4 != v2);
  }
}

uint64_t sub_1B63F6BFC(uint64_t a1, char *a2, uint64_t a3, uint64_t a4)
{
  if (sub_1B63F1400((uint64_t)a2)) {
    return 0;
  }
  if (!a3
    || !sub_1B65F8D04(a3, v8, v9, v10, v11, v12, v13, v14)
    || (uint64_t result = (uint64_t)sub_1B65F8D58(0, a3, a2, v10, v11, v12, v13, v14)) == 0)
  {
    uint64_t result = sub_1B63F1680((uint64_t)a2, a3, v9, v10, v11, v12, v13, v14);
    if (result)
    {
      if (!sub_1B64AFA68(result, v16, v17, v18, v19, v20, v21, v22))
      {
        unsigned int v30 = (*(_DWORD *)(a1 + 44) - 1) & a4;
        unsigned int v31 = *(unsigned __int16 *)(*(void *)(a1 + 32) + 2 * v30);
        if (v31 >= 2)
        {
          uint64_t v32 = *(unsigned int *)a2;
          while ((v31 & 2) == 0 || *(void *)(*(void *)(a1 + 16) + 8 * v30) != a4)
          {
            ++v30;
            BOOL v33 = v31 >= 4;
            v31 >>= 1;
            if (!v33) {
              return 0;
            }
          }
          uint64_t v34 = *(void *)(a1 + 24);
          if (v34)
          {
            uint64_t v35 = v30;
            uint64_t v36 = *(void *)(v34 + 8 * v30);
            if (!v36)
            {
              sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v24, v25, v26, v27, v28, v29, (uint64_t)"_ptr != NULL");
              uint64_t v36 = *(void *)(v34 + 8 * v35);
            }
            if (sub_1B6621414(v36, v23, v24, v25, v26, v27, v28, v29) > v32) {
              return *(void *)sub_1B66214AC(*(void *)(v34 + 8 * v35), v32, v37, v38, v39, v40, v41, v42);
            }
          }
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_1B63F6D20(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2) {
    return sub_1B661D8A0(*(void *)(a1 + 48), a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    return 0;
  }
}

void sub_1B63F6D34(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 44) != -15)
  {
    unint64_t v9 = 0;
    uint64_t v10 = *a2;
    do
    {
      if (*(_WORD *)(*(void *)(a1 + 32) + 2 * v9))
      {
        uint64_t v11 = *(void *)(a1 + 24);
        if (sub_1B6621414(*(void *)(v11 + 8 * v9), (uint64_t)a2, a3, a4, a5, a6, a7, a8) > v10)
        {
          uint64_t v12 = (unsigned int **)sub_1B66214AC(*(void *)(v11 + 8 * v9), v10, a3, a4, a5, a6, a7, a8);
          a2 = *v12;
          if (*v12)
          {
            uint64_t v13 = v12;
            sub_1B661DA28(*(void *)(a1 + 48), a2, a3, a4, a5, a6, a7, a8);
            *uint64_t v13 = 0;
          }
        }
      }
      ++v9;
    }
    while (v9 < (*(_DWORD *)(a1 + 44) + 15));
  }
}

void sub_1B63F6DC8(uint64_t a1, unsigned int *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *a2;
  uint64_t v12 = (void *)(a1 + 16);
  unsigned int v13 = (*(_DWORD *)(a1 + 44) - 1) & a4;
  unsigned int v14 = *(unsigned __int16 *)(*(void *)(a1 + 32) + 2 * v13);
  if (v14 < 2) {
    goto LABEL_5;
  }
  while ((v14 & 2) == 0 || *(void *)(*v12 + 8 * v13) != a4)
  {
    ++v13;
    BOOL v15 = v14 >= 4;
    v14 >>= 1;
    if (!v15) {
      goto LABEL_5;
    }
  }
  uint64_t v33 = *(void *)(a1 + 24);
  if (!v33 || (uint64_t v16 = *(_DWORD **)(v33 + 8 * v13)) == 0)
  {
LABEL_5:
    uint64_t v16 = (_DWORD *)sub_1B6621374(8, *(_DWORD *)(a1 + 56));
    CFTypeRef cf = v16;
    sub_1B63F6F48((uint64_t)v12, a4, &cf);
    if (cf) {
      CFRelease(cf);
    }
    sub_1B66215D8(v16, *(_DWORD *)(a1 + 56));
    uint64_t v24 = (void *)sub_1B6621548((uint64_t)v16, v17, v18, v19, v20, v21, v22, v23);
    bzero(v24, 8 * *(unsigned int *)(a1 + 56));
  }
  if (v11 >= *(_DWORD *)(a1 + 56))
  {
    sub_1B63F2F54(16, @"Error: CFXProgramHashCodeStoreRegisterProgramForRendererElement - index out of capacity (%d > %d)", (uint64_t)a3, a4, a5, a6, a7, a8, v11);
  }
  else
  {
    uint64_t v25 = (uint64_t *)sub_1B66214AC((uint64_t)v16, v11, (uint64_t)a3, a4, a5, a6, a7, a8);
    if ((const void *)*v25 != a3)
    {
      sub_1B659EC24(*v25);
      if (a3) {
        uint64_t v32 = (void *)CFRetain(a3);
      }
      else {
        uint64_t v32 = 0;
      }
      *uint64_t v25 = (uint64_t)v32;
      if (sub_1B661D908(*(void *)(a1 + 48), v32, v26, v27, v28, v29, v30, v31) >= 0xFFFFFFFFLL) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. CFXProgramHashCodeStoreRegisterProgramForRendererElement - programIndex out of uint32_t. will crash soon", v34, v35, v36, v37, v38, v39, (uint64_t)"programIndex < 0xffffffff");
      }
    }
  }
}

uint64_t sub_1B63F6F48(uint64_t a1, uint64_t a2, void *a3)
{
  while (1)
  {
    int v6 = *(_DWORD *)(a1 + 28);
    uint64_t v7 = (v6 - 1) & a2;
    uint64_t v8 = *(void *)(a1 + 16);
    unsigned int v9 = *(unsigned __int16 *)(v8 + 2 * v7);
    if (v9 >= 2) {
      break;
    }
LABEL_6:
    unsigned int v12 = v7 + 496;
    unsigned int v13 = v6 + 15;
    if (v13 < (int)v7 + 496) {
      unsigned int v12 = v13;
    }
    if (v7 >= v12)
    {
      unsigned int v15 = v7;
    }
    else
    {
      unsigned int v14 = (__int16 *)(v8 + 2 * v7);
      unsigned int v15 = v7;
      while (1)
      {
        __int16 v16 = *v14++;
        if ((v16 & 1) == 0) {
          break;
        }
        if (v12 == ++v15) {
          goto LABEL_33;
        }
      }
    }
    if (v15 != v12)
    {
      __int16 v17 = *(_WORD *)(v8 + 2 * v15) | 1;
      *(_WORD *)(v8 + 2 * v15) = v17;
      if (v15 <= (int)v7 + 14)
      {
        uint64_t v33 = v15;
        uint64_t v28 = *(void *)a1;
        uint64_t v29 = *(void *)(a1 + 8);
        LOBYTE(v22) = v15;
      }
      else
      {
        while (2)
        {
          if (v15 >= 0xF) {
            unsigned int v18 = v15 - 14;
          }
          else {
            unsigned int v18 = 0;
          }
          unsigned int v19 = v18 - 1;
          if (v18 <= v15) {
            unsigned int v20 = v15;
          }
          else {
            unsigned int v20 = v18;
          }
          char v21 = 1;
          while (1)
          {
            uint64_t v22 = v19 + 1;
            if (v18 <= v22) {
              break;
            }
LABEL_27:
            ++v21;
            unsigned int v19 = v22;
            if (v22 == v20) {
              goto LABEL_32;
            }
          }
          int v23 = 1 << (v19 - v18 + 2);
          char v24 = v21;
          unsigned int v25 = v18;
          while (1)
          {
            uint64_t v26 = v25;
            int v27 = *(unsigned __int16 *)(v8 + 2 * v25);
            if ((v23 & v27) != 0) {
              break;
            }
            unsigned int v25 = v26 + 1;
            int v23 = (unsigned __int16)v23 >> 1;
            --v24;
            if ((int)v26 + 1 > v22) {
              goto LABEL_27;
            }
          }
          if (v22 >= v15)
          {
LABEL_32:
            *(_WORD *)(v8 + 2 * v15) ^= 1u;
            goto LABEL_33;
          }
          uint64_t v28 = *(void *)a1;
          uint64_t v29 = *(void *)(a1 + 8);
          *(void *)(*(void *)a1 + 8 * v15) = *(void *)(*(void *)a1 + 8 * v22);
          *(void *)(v29 + 8 * v15) = *(void *)(v29 + 8 * v22);
          *(void *)(v29 + 8 * v22) = 0;
          *(_WORD *)(v8 + 2 * v26) = (v27 | (1 << (v15 - v26 + 1))) ^ (1 << v24);
          unsigned int v15 = v22;
          if (v22 > (int)v7 + 14) {
            continue;
          }
          break;
        }
        __int16 v17 = *(_WORD *)(v8 + 2 * v22) | 1;
        uint64_t v33 = v22;
      }
      *(void *)(v29 + 8 * v33) = *a3;
      *a3 = 0;
      *(void *)(v28 + 8 * v33) = a2;
      *(_WORD *)(v8 + 2 * v33) = v17;
      uint64_t result = 1;
      *(_WORD *)(v8 + 2 * v7) |= 1 << (v22 - v7 + 1);
      ++*(_DWORD *)(a1 + 24);
      return result;
    }
LABEL_33:
    sub_1B63F73C0(a1);
  }
  unsigned int v10 = (v6 - 1) & a2;
  while ((v9 & 2) == 0 || *(void *)(*(void *)a1 + 8 * v10) != a2)
  {
    ++v10;
    BOOL v11 = v9 > 3;
    v9 >>= 1;
    if (!v11) {
      goto LABEL_6;
    }
  }
  uint64_t v30 = *(void *)(a1 + 8);
  uint64_t v31 = *a3;
  *a3 = 0;
  uint64_t result = *(void *)(v30 + 8 * v10);
  *(void *)(v30 + 8 * v10) = v31;
  if (result)
  {
    CFRelease((CFTypeRef)result);
    return 0;
  }
  return result;
}

void sub_1B63F717C(uint64_t a1)
{
  sub_1B63F69D4(a1);
  sub_1B63F7238(a1 + 16);
  unint64_t v2 = *(const void **)(a1 + 48);
  if (v2)
  {
    CFRelease(v2);
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x2B0], 8) = 0;
  }
}

CFStringRef sub_1B63F71B8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXProgramHashCodeStore %p>", a1);
}

CFStringRef sub_1B63F71F8(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXProgramHashCodeStore %p>", a1);
}

uint64_t sub_1B63F7238(uint64_t a1)
{
  CFAllocatorRef v2 = *(CFTypeRef **)(a1 + 8);
  if (v2)
  {
    sub_1B63F728C(v2, *(__int16 **)(a1 + 16), *(_DWORD *)(a1 + 28) + 15);
    free(*(void **)(a1 + 8));
  }
  free(*(void **)a1);
  free(*(void **)(a1 + 16));
  return a1;
}

void sub_1B63F728C(CFTypeRef *a1, __int16 *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v5 = a3;
    do
    {
      __int16 v6 = *a2++;
      if (v6)
      {
        if (*a1) {
          CFRelease(*a1);
        }
      }
      ++a1;
      --v5;
    }
    while (v5);
  }
}

void sub_1B63F72E4(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x2B0], 8) = a2;
  unsigned int v3 = a2 + 15;
  size_t v4 = 2 * (a2 + 15);
  uint64_t v5 = malloc_type_malloc((2 * (a2 + 15)), 0xD5346062uLL);
  memset(v5, 255, v4 & 0xFFFFFFFE);
  *(void *)(a1 + 16) = v5;
  size_t v6 = 8 * v3;
  uint64_t v7 = malloc_type_malloc(8 * v3, 0xD5346062uLL);
  memset(v7, 255, v6 & 0xFFFFFFF8);
  *(void *)a1 = v7;
  uint64_t v8 = malloc_type_malloc(v6 & 0xFFFFFFF8, 0xD5346062uLL);
  memset(v8, 255, v6 & 0xFFFFFFF8);
  *(void *)(a1 + _Block_object_dispose(&STACK[0x2B0], 8) = v8;
  memset(*(void **)a1, 255, v6);
  unsigned int v9 = *(void **)(a1 + 16);

  bzero(v9, v4);
}

void sub_1B63F73C0(uint64_t a1)
{
  CFAllocatorRef v2 = *(void **)a1;
  unsigned int v3 = *(CFTypeRef **)(a1 + 8);
  size_t v4 = *(__int16 **)(a1 + 16);
  int v5 = *(_DWORD *)(a1 + 28);
  sub_1B63F72E4(a1, 2 * v5);
  uint64_t v6 = (v5 + 15);
  if (v5 != -15)
  {
    uint64_t v7 = v3;
    uint64_t v8 = v2;
    unsigned int v9 = v4;
    do
    {
      __int16 v10 = *v9++;
      if (v10)
      {
        sub_1B63F6F48(a1, *v8, v7);
        if (*v7) {
          CFRelease(*v7);
        }
      }
      ++v8;
      ++v7;
      --v6;
    }
    while (v6);
  }
  free(v3);
  free(v2);

  free(v4);
}

void sub_1B63F76DC(uint64_t a1)
{
}

void sub_1B63F7FF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B63F8004(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int16 v6 = objc_msgSend_count(a2, (const char *)a2, a3, a4);
  __int16 v7 = v6;
  if (v6)
  {
    uint64_t v8 = malloc_type_malloc(16 * v6, 0x1000040451B5BE8uLL);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    _OWORD v11[2] = sub_1B63F8908;
    v11[3] = &unk_1E6141440;
    _OWORD v11[4] = v8;
    objc_msgSend_enumerateObjectsUsingBlock_(a2, v9, (uint64_t)v11, v10);
  }
  else
  {
    uint64_t v8 = 0;
  }
  sub_1B63D0FE8(a1, (uint64_t)v8, v7);
}

uint64_t sub_1B63F8190(uint64_t a1)
{
  return sub_1B63D11C0(*(void *)(*(void *)(a1 + 32) + 8), *(float *)(a1 + 40));
}

uint64_t sub_1B63F825C(uint64_t a1)
{
  return sub_1B63D11D0(*(void *)(*(void *)(a1 + 32) + 8), *(float *)(a1 + 40));
}

uint64_t sub_1B63F8328(uint64_t a1)
{
  return sub_1B63D11E0(*(void *)(*(void *)(a1 + 32) + 8), *(float *)(a1 + 40));
}

uint64_t sub_1B63F8908(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_rangeValue(a2, (const char *)a2, a3, a4);
  uint64_t v8 = (uint64_t *)(*(void *)(a1 + 32) + 16 * a3);
  if (result == 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v9 = -1;
  }
  else {
    uint64_t v9 = result;
  }
  *uint64_t v8 = v9;
  v8[1] = v7;
  return result;
}

__n128 sub_1B63F894C(__n128 *a1, float32x4_t *a2)
{
  float32x4_t v3 = vmulq_f32(*a2, *a2);
  v3.i64[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).u64[0];
  float32x4_t v4 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 0);
  v4.i32[3] = 0;
  float32x4_t v5 = vrsqrteq_f32(v4);
  float32x4_t v6 = vmulq_f32(v5, vrsqrtsq_f32(v4, vmulq_f32(v5, v5)));
  int8x16_t v7 = (int8x16_t)vmulq_f32(v6, vrsqrtsq_f32(v4, vmulq_f32(v6, v6)));
  int32x4_t v8 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v3.f32[0] != 0.0)), 0x1FuLL));
  v8.i32[3] = 0;
  __asm { FMOV            V3.4S, #1.0 }
  float32x4_t v16 = vmulq_f32(*a2, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v8), v7, _Q3));
  __float2 v14 = __sincosf_stret(vmuls_lane_f32(0.5, *a2, 3));
  __n128 result = (__n128)vmulq_n_f32(v16, v14.__sinval);
  result.n128_u32[3] = LODWORD(v14.__cosval);
  *a1 = result;
  return result;
}

float32_t sub_1B63F89FC(float32x4_t *a1, float32x4_t *a2)
{
  float32x4_t v3 = vmulq_f32(*a1, *a1);
  LODWORD(v4) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).u32[0];
  float32x2_t v5 = vrsqrte_f32((float32x2_t)LODWORD(v4));
  float32x2_t v6 = vmul_f32(v5, vrsqrts_f32((float32x2_t)LODWORD(v4), vmul_f32(v5, v5)));
  float32x4_t v10 = vmulq_n_f32(*a1, vmul_f32(v6, vrsqrts_f32((float32x2_t)LODWORD(v4), vmul_f32(v6, v6))).f32[0]);
  float v7 = atan2f(sqrtf(v4), COERCE_FLOAT(HIDWORD(*(unsigned long long *)a1)));
  float32_t result = v7 + v7;
  float32x4_t v9 = v10;
  v9.f32[3] = result;
  *a2 = v9;
  return result;
}

float32x4_t sub_1B63F8A80(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3)
{
  float32x4_t result = vaddq_f32(*a1, *a2);
  *a3 = result;
  return result;
}

float32x4_t sub_1B63F8A94(float32x4_t *a1)
{
  int8x16_t v1 = (int8x16_t)vmulq_f32(*a1, *a1);
  *(float32x2_t *)v1.i8 = vadd_f32(*(float32x2_t *)v1.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v1, v1, 8uLL));
  float32x4_t v2 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v1.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v1.i8, 1)), 0);
  float32x4_t v3 = vrsqrteq_f32(v2);
  float32x4_t v4 = vmulq_f32(v3, vrsqrtsq_f32(v2, vmulq_f32(v3, v3)));
  __asm { FMOV            V3.4S, #1.0 }
  float32x4_t result = vmulq_f32(*a1, (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v2), _Q3, (int8x16_t)vmulq_f32(v4, vrsqrtsq_f32(v2, vmulq_f32(v4, v4)))));
  *a1 = result;
  return result;
}

int32x4_t sub_1B63F8AE4(float32x4_t *a1, int32x4_t *a2, float32x4_t *a3)
{
  int32x4_t result = *(int32x4_t *)a1;
  _S2 = HIDWORD(*(unsigned long long *)a2);
  int32x4_t v5 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(*a2, *a2), *(int8x16_t *)a2, 0xCuLL), vnegq_f32(*a1)), *(float32x4_t *)a2, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(result, result), *(int8x16_t *)a1, 0xCuLL));
  float32x4_t v6 = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(*a1, *(float32x4_t *)a2, 3), *(float32x4_t *)a2, *a1, 3), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v5, v5), (int8x16_t)v5, 0xCuLL));
  __asm { FMLA            S1, S2, V0.S[3] }
  v6.i32[3] = _S1;
  *a3 = v6;
  return result;
}

float32x4_t sub_1B63F8B48(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3, float a4)
{
  float32x4_t v6 = *a1;
  float32x4_t v7 = *a2;
  int8x16_t v8 = (int8x16_t)vmulq_f32(*a1, *a2);
  float32x4_t v61 = *a2;
  float32x4_t v63 = *a1;
  float v9 = 1.0;
  float v10 = 1.0 - a4;
  if (vaddv_f32(vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL))) >= 0.0)
  {
    float32x4_t v31 = vsubq_f32(v6, v7);
    int8x16_t v32 = (int8x16_t)vmulq_f32(v31, v31);
    float32x4_t v33 = vaddq_f32(v6, v7);
    int8x16_t v34 = (int8x16_t)vmulq_f32(v33, v33);
    float v35 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v32.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v32, v32, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v34.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL)))));
    float v36 = v35 + v35;
    _ZF = (float)(v35 + v35) == 0.0;
    float v37 = 1.0;
    if (!_ZF) {
      float v37 = sinf(v36) / v36;
    }
    float v38 = v37;
    float32x2_t v39 = vrecpe_f32((float32x2_t)LODWORD(v37));
    int32x2_t v40 = (int32x2_t)vmul_f32(v39, vrecps_f32((float32x2_t)LODWORD(v38), v39));
    LODWORD(v41) = vmul_f32((float32x2_t)v40, vrecps_f32((float32x2_t)LODWORD(v38), (float32x2_t)v40)).u32[0];
    if ((float)(v10 * v36) != 0.0)
    {
      float v59 = v41;
      *(float *)v40.i32 = sinf(v10 * v36);
      float v41 = v59;
      float v9 = *(float *)v40.i32 / (float)(v10 * v36);
    }
    *(float *)v40.i32 = v10 * (float)(v41 * v9);
    float32x4_t v42 = (float32x4_t)vdupq_lane_s32(v40, 0);
    float v43 = v36 * a4;
    float v44 = 1.0;
    if (v43 != 0.0)
    {
      float32x4_t v56 = v42;
      float v60 = v41;
      float v45 = sinf(v43);
      float32x4_t v42 = v56;
      float v41 = v60;
      float v44 = v45 / v43;
    }
    float32x4_t v30 = vmlaq_f32(vmulq_n_f32(v61, (float)(v41 * v44) * a4), v63, v42);
  }
  else
  {
    float32x4_t v11 = vaddq_f32(v6, v7);
    int8x16_t v12 = (int8x16_t)vmulq_f32(v11, v11);
    float32x4_t v13 = vsubq_f32(v6, v7);
    int8x16_t v14 = (int8x16_t)vmulq_f32(v13, v13);
    float v15 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v12.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v14.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL)))));
    float v16 = v15 + v15;
    _ZF = (float)(v15 + v15) == 0.0;
    float v18 = 1.0;
    if (!_ZF) {
      float v18 = sinf(v16) / v16;
    }
    float v19 = v18;
    float32x2_t v20 = vrecpe_f32((float32x2_t)LODWORD(v18));
    float32x2_t v21 = vmul_f32(v20, vrecps_f32((float32x2_t)LODWORD(v19), v20));
    LODWORD(v22) = vmul_f32(v21, vrecps_f32((float32x2_t)LODWORD(v19), v21)).u32[0];
    if ((float)(v10 * v16) != 0.0)
    {
      float v57 = v22;
      float v23 = sinf(v10 * v16);
      float v22 = v57;
      float v9 = v23 / (float)(v10 * v16);
    }
    v24.i32[1] = v61.i32[1];
    float32x4_t v25 = vnegq_f32(v61);
    *(float *)v24.i32 = v10 * (float)(v22 * v9);
    float32x4_t v26 = (float32x4_t)vdupq_lane_s32(v24, 0);
    float v27 = v16 * a4;
    float v28 = 1.0;
    if (v27 != 0.0)
    {
      float v58 = v22;
      float32x4_t v62 = v25;
      float32x4_t v55 = v26;
      float v29 = sinf(v27);
      float32x4_t v26 = v55;
      float v22 = v58;
      float32x4_t v25 = v62;
      float v28 = v29 / v27;
    }
    float32x4_t v30 = vmlaq_f32(vmulq_n_f32(v25, (float)(v22 * v28) * a4), v63, v26);
  }
  int8x16_t v46 = (int8x16_t)vmulq_f32(v30, v30);
  *(float32x2_t *)v46.i8 = vadd_f32(*(float32x2_t *)v46.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v46, v46, 8uLL));
  float32x4_t v47 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v46.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v46.i8, 1)), 0);
  float32x4_t v48 = vrsqrteq_f32(v47);
  float32x4_t v49 = vmulq_f32(v48, vrsqrtsq_f32(v47, vmulq_f32(v48, v48)));
  __asm { FMOV            V3.4S, #1.0 }
  float32x4_t result = vmulq_f32(v30, (float32x4_t)vbslq_s8((int8x16_t)vceqzq_f32(v47), _Q3, (int8x16_t)vmulq_f32(v49, vrsqrtsq_f32(v47, vmulq_f32(v49, v49)))));
  *a3 = result;
  return result;
}

float sub_1B63F8DB8(_OWORD *a1, float32x4_t a2, float32_t a3, float32_t a4)
{
  a2.f32[1] = a3;
  a2.f32[2] = a4;
  v5.i64[0] = 0x3F0000003F000000;
  v5.i64[1] = 0x3F0000003F000000;
  simd_float4 v6 = (simd_float4)vmulq_f32(a2, v5);
  v6.i32[3] = 0;
  simd_float4 x = v6;
  simd_float4 v22 = _simd_cos_f4(v6);
  _Q0 = _simd_sin_f4(x);
  _Q7 = v22;
  float v9 = vmuls_lane_f32(v22.f32[1], (float32x4_t)v22, 2);
  float v10 = vmuls_lane_f32(_Q0.f32[1], (float32x4_t)_Q0, 2);
  *(float *)&long long v11 = vmlas_n_f32(-(float)(v22.f32[0] * v10), v9, _Q0.f32[0]);
  _S4 = vmuls_lane_f32(v22.f32[0], *(float32x2_t *)_Q0.f32, 1);
  __asm { FMLA            S5, S4, V7.S[2] }
  _S4 = vmuls_lane_f32(_Q7.f32[0], *(float32x2_t *)_Q7.f32, 1);
  __asm { FMLA            S6, S4, V0.S[2] }
  DWORD1(v11) = _S5;
  float result = vmlas_n_f32(v10 * _Q0.f32[0], v9, v22.f32[0]);
  *((void *)&v11 + 1) = __PAIR64__(LODWORD(result), _S6);
  *a1 = v11;
  return result;
}

double sub_1B63F8E60(float32x4_t a1, float32x4_t _Q1)
{
  _Q3 = (int8x16_t)vmulq_f32(a1, a1);
  *(float32x2_t *)_Q3.i8 = vadd_f32(*(float32x2_t *)_Q3.i8, (float32x2_t)*(_OWORD *)&vextq_s8(_Q3, _Q3, 8uLL));
  _Q2 = vdivq_f32(vmulq_f32(a1, (float32x4_t)xmmword_1B6E4F550), (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)_Q3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q3.i8, 1)), 0));
  _Q3.i32[0] = _Q2.i32[3];
  int32x4_t v4 = (int32x4_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q2, (int32x4_t)_Q2), (int8x16_t)_Q2, 0xCuLL), vnegq_f32(_Q1)), _Q2, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)_Q1, (int32x4_t)_Q1), (int8x16_t)_Q1, 0xCuLL));
  *(void *)&double result = vaddq_f32(vmlaq_laneq_f32(vmulq_laneq_f32(_Q1, _Q2, 3), _Q2, _Q1, 3), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v4, v4), (int8x16_t)v4, 0xCuLL)).u64[0];
  __asm { FMLA            S2, S3, V1.S[3] }
  return result;
}

void sub_1B63F8EE0(float32x4_t *a1, _OWORD *a2)
{
  _Q2 = *a1;
  int8x16_t v4 = (int8x16_t)vmulq_f32(_Q2, _Q2);
  float v5 = vaddv_f32(vadd_f32(*(float32x2_t *)v4.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v4, v4, 8uLL)));
  long long v6 = 0uLL;
  if (v5 != 0.0)
  {
    LODWORD(v7) = HIDWORD(*(unsigned long long *)a1);
    LODWORD(_S9) = HIDWORD(a1->i64[0]);
    LODWORD(v9) = a1->i64[1];
    __asm { FMLA            S1, S9, V2.S[3] }
    float v15 = _S1 / v5;
    double v16 = (float)(_S1 / v5);
    if (v16 <= 0.4999)
    {
      if (v16 >= -0.4999)
      {
        float v20 = *(float *)&v4.i32[1];
        uint64_t v21 = v4.i64[1];
        float32x4_t v24 = *a1;
        float v25 = *(float *)v4.i32;
        *(float *)&uint64_t v22 = atan2f((float)((float)(_Q2.f32[0] * _Q2.f32[3]) + (float)(_Q2.f32[1] * _Q2.f32[2]))+ (float)((float)(_Q2.f32[0] * _Q2.f32[3]) + (float)(_Q2.f32[1] * _Q2.f32[2])), *(float *)&v4.i32[3]+ (float)(*(float *)&v4.i32[2] + (float)((float)-*(float *)v4.i32 - *(float *)&v4.i32[1])));
        *(void *)&long long v27 = v22;
        float v26 = asinf(v15 + v15);
        float v23 = atan2f((float)((float)(v9 * v7) + (float)(v24.f32[0] * _S9))+ (float)((float)(v9 * v7) + (float)(v24.f32[0] * _S9)), *((float *)&v21 + 1) + (float)((float)(v25 - v20) - *(float *)&v21));
        long long v6 = v27;
        *((float *)&v6 + 1) = v26;
        *((float *)&v6 + 2) = v23;
        goto LABEL_8;
      }
      float v19 = atan2f(COERCE_FLOAT(*a1), _Q2.f32[3]);
      *(float *)&long long v6 = v19 + v19;
      float v18 = &dword_1B6E500B0;
    }
    else
    {
      float v17 = atan2f(COERCE_FLOAT(*a1), _Q2.f32[3]);
      *(float *)&long long v6 = v17 + v17;
      float v18 = &dword_1B6E500B4;
    }
    DWORD1(v6) = *v18;
    DWORD2(v6) = 0;
  }
LABEL_8:
  *a2 = v6;
}

uint64_t sub_1B63F903C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  *(void *)&long long v34 = a2;
  *((void *)&v34 + 1) = a3;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA6D8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v21 = a3;
    uint64_t v19 = a2;
    int v20 = __cxa_guard_acquire(&qword_1E9DDA6D8);
    a2 = v19;
    a3 = v21;
    if (v20)
    {
      qword_1E9DDA6D0 = (uint64_t)sub_1B63FC21C("REFLECTION_PROBE_RENDER_PASS", 0x1Cu);
      __cxa_guard_release(&qword_1E9DDA6D8);
      a2 = v19;
      a3 = v21;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, qword_1E9DDA6D0, 0);
  *(void *)a1 = &unk_1F0FB46F0;
  uint64_t v8 = *(void *)(a5 + 40);
  *(_OWORD *)(a1 + 392) = *(_OWORD *)(a5 + 24);
  *(_WORD *)(a1 + 376) = 0;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = v8;
  *(unsigned char *)(CFX::RG::Pass::commonRenderParameters(v9) + 277) = 6;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  RGTextureDescriptorMakeCube(*(_DWORD *)(a1 + 392), *(void *)(a1 + 400), (uint64_t)&v29);
  *((void *)&v31 + 1) = 5;
  BYTE8(v29) = 5;
  v28[0] = v29;
  v28[1] = v30;
  uint64_t v28[3] = v32;
  v28[4] = v33;
  v28[2] = v31;
  float v10 = sub_1B63C7D8C(a4, (uint64_t)"REFLECTION_PROBE_COLOR_TARGET", (uint64_t)v28);
  *(void *)(a1 + 416) = v10;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v10, 0x100000002, 0);
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v23 = 0u;
  RGTextureDescriptorMakeCube(*(_DWORD *)(a1 + 392), 252, (uint64_t)&v23);
  *((void *)&v31 + 1) = 4;
  void v22[2] = v25;
  v22[3] = v26;
  v22[4] = v27;
  v22[0] = v23;
  v22[1] = v24;
  long long v11 = sub_1B63C7D8C(a4, (uint64_t)"REFLECTION_PROBE_DEPTH_TARGET", (uint64_t)v22);
  *(void *)(a1 + 424) = v11;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v11, 0x200000002, -1);
  *(void *)&long long v35 = *(void *)(a1 + 368);
  unint64_t v12 = *(void *)(a1 + 408);
  uint64_t v37 = 0;
  long long v36 = v12;
  *(void *)&long long v13 = 0;
  *((float *)&v13 + 2) = (float)*(unsigned int *)(a1 + 392);
  *((float *)&v13 + 3) = *((float *)&v13 + 2);
  long long v39 = v13;
  char v40 = 1;
  long long v41 = xmmword_1B6E4FC80;
  char v42 = *(unsigned char *)(a1 + 376);
  char v43 = 2;
  uint64_t v44 = 4;
  int v45 = 1;
  __int16 v46 = 1;
  uint64_t v14 = sub_1B63F9384(v34, *((uint64_t *)&v34 + 1), (uint64_t *)&v34, (uint64_t *)&v35, &v36);
  *(void *)&long long v36 = 0;
  WORD4(v36) = 32;
  BYTE10(v36) = *(unsigned char *)(a1 + 377);
  uint64_t v37 = 3;
  __int16 v38 = 0;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA6D8, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E9DDA6D8))
  {
    qword_1E9DDA6D0 = (uint64_t)sub_1B63FC21C("REFLECTION_PROBE_RENDER_PASS", 0x1Cu);
    __cxa_guard_release(&qword_1E9DDA6D8);
  }
  *(void *)&long long v39 = qword_1E9DDA6D0;
  uint64_t v15 = *(void *)(a1 + 368);
  long long v35 = v34;
  uint64_t v16 = sub_1B63C8330(&v35, 0x40u, 8u);
  sub_1B6460520(v16, v15, (uint64_t)&v36, v14);
  *(void *)(a1 + 384) = v17;
  return a1;
}

void sub_1B63F9360(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B63F9384(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, long long *a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0xB0u, 0x10u);
  return sub_1B65A84D4(v8, *a3, a3[1], *a4, a5);
}

void sub_1B63F93E4(uint64_t a1, uint64_t a2)
{
  float32x4_t v3 = (__n128 *)sub_1B643D7FC(*(void *)(a1 + 384));
  sub_1B65A8594(v3, v4, v5, v6);
  sub_1B65A88F8((uint64_t)v3, v7, v8, v9, v10, v11, v12, v13);
  sub_1B65A8D10((uint64_t)v3);
  sub_1B65A8D3C((uint64_t)v3, v14, v15, v16, v17, v18, v19, v20);
  uint64_t v22 = *(const char **)a2;
  uint64_t v23 = *(void *)(a2 + 8);

  sub_1B65A8F34((uint64_t *)v3, v22, v23, v21);
}

void sub_1B63F9444(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
}

void sub_1B63F944C(uint64_t a1, const char *a2, uint64_t a3)
{
}

uint64_t sub_1B63F945C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA6E8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v27 = a3;
    uint64_t v25 = a2;
    int v26 = __cxa_guard_acquire(&qword_1E9DDA6E8);
    uint64_t v8 = (void *)&unk_1E9DDA000;
    a2 = v25;
    a3 = v27;
    if (v26)
    {
      qword_1E9DDA6E0 = (uint64_t)sub_1B63FC21C("REFLECTION_PROBE_RADIANCE_PASS", 0x1Eu);
      __cxa_guard_release(&qword_1E9DDA6E8);
      uint64_t v8 = (void *)&unk_1E9DDA000;
      a2 = v25;
      a3 = v27;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v8[220], 0);
  *(void *)a1 = &unk_1F0FB49D0;
  long long v9 = *(_OWORD *)(a5 + 24);
  uint64_t v10 = *(void *)(a5 + 40);
  *(void *)(a1 + 400) = v10;
  *(_OWORD *)(a1 + 384) = v9;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  if ((_BYTE)v10)
  {
    RGTextureDescriptorMake2D(2 * *(_DWORD *)(a1 + 384), *(_DWORD *)(a1 + 384), *(void *)(a1 + 392), (uint64_t)&v34);
    uint64_t v11 = v34;
    v40[0] = v35[0];
    *(_OWORD *)((char *)v40 + 15) = *(_OWORD *)((char *)v35 + 15);
    long long v38 = v36;
    long long v39 = v37;
  }
  else
  {
    RGTextureDescriptorMakeCube(*(_DWORD *)(a1 + 384), *(void *)(a1 + 392), (uint64_t)&v34);
    uint64_t v11 = v34;
    v40[0] = v35[0];
    *(_OWORD *)((char *)v40 + 15) = *(_OWORD *)((char *)v35 + 15);
    long long v38 = v36;
    long long v39 = v37;
    uint64_t v19 = (void *)sub_1B6445900(*(void *)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
    if ((objc_msgSend_features(v19, v20, v21, v22) & 0x20) != 0) {
      *(_WORD *)(a1 + 376) = 257;
    }
    *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 26_Block_object_dispose(&STACK[0x2B0], 8) = 6;
  }
  uint64_t v28 = v11;
  char v29 = 5;
  *(_OWORD *)long long v30 = v40[0];
  *(_OWORD *)&v30[15] = *(_OWORD *)((char *)v40 + 15);
  uint64_t v31 = 5;
  long long v32 = v38;
  long long v33 = v39;
  uint64_t v23 = sub_1B63C7D8C(a4, (uint64_t)"REFLECTION_PROBE_RADIANCE_TARGET", (uint64_t)&v28);
  *(void *)(a1 + 424) = v23;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v23, 0x100000000, 0);
  *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 275) = 5;
  return a1;
}

void sub_1B63F96B4(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B63F96D8(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v5 = 0x9DDFEA08EB382D69
     * (v4 ^ ((0x9DDFEA08EB382D69 * (*(void *)(a1 + 392) ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                            * (*(void *)(a1 + 392) ^ v4)));
  unint64_t v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v5 >> 47));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (v6 ^ *(unsigned __int8 *)(a1 + 400));
  uint64_t v8 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
  uint64_t v9 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v8);
  *(void *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = v9;
  if (!v9)
  {
    *(void *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = sub_1B63F98DC(*(CFX::CrossFrameResourceManager **)(a2 + 32), v8);
    uint64_t v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v10, v11, v12, v13, v14, v15, v16);
    long long v24 = objc_msgSend_resourceManager(v17, v18, v19, v20);
    if (*(void *)(a1 + 392) == 125) {
      uint64_t v25 = "float";
    }
    else {
      uint64_t v25 = "half";
    }
    int v26 = *(unsigned __int8 *)(a1 + 400);
    uint64_t v27 = @"vfx_draw_fullscreen_cube";
    if (!*(unsigned char *)(a1 + 400))
    {
      __int16 v28 = objc_msgSend_features(v17, v21, v22, v23);
      char v32 = objc_msgSend_features(v17, v29, v30, v31);
      long long v33 = @"vfx_draw_fullscreen_cube_no_base";
      if ((v28 & 0x400) != 0) {
        long long v33 = @"vfx_draw_fullscreen_cube";
      }
      if ((v32 & 0x20) != 0) {
        uint64_t v27 = @"vfx_draw_fullscreen_cube_layered";
      }
      else {
        uint64_t v27 = v33;
      }
      int v26 = *(unsigned __int8 *)(a1 + 400);
    }
    uint64_t v34 = objc_msgSend_stringWithFormat_(NSString, v21, @"vfx_radiance_%s_%s_frag", v23, off_1E6141488[v26], v25);
    long long v35 = (void *)sub_1B653EFAC((uint64_t)v24);
    uint64_t v39 = objc_msgSend_frameworkLibrary(v35, v36, v37, v38);
    uint64_t v40 = *(void *)(a1 + 392);
    uint64_t v41 = *(void *)(a1 + 408);
    memset(v47, 0, sizeof(v47));
    uint64_t v48 = 0;
    uint64_t v49 = v39;
    uint64_t v50 = v40;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    uint64_t v60 = 0;
    char v61 = 3;
    uint64_t v62 = 0;
    memset(v63, 0, sizeof(v63));
    uint64_t v64 = v27;
    uint64_t v65 = v34;
    uint64_t v66 = 0;
    uint64_t v67 = 0;
    uint64_t v44 = objc_msgSend_newRenderPipelineStateWithDesc_(v24, v42, (uint64_t)v47, v43);
    int v45 = *(void **)(v41 + 16);
    if (v45 != (void *)v44)
    {
      uint64_t v46 = v44;
      if (v45) {

      }
      *(void *)(v41 + 16) = v46;
    }
  }
}

uint64_t sub_1B63F98DC(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B63F9968(uint64_t a1, CFX::GPUResourceManager **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v22 = objc_msgSend_renderEncoder(v11, v12, v13, v14);
  uint64_t v23 = *(void *)(a1 + 408);
  long long v24 = *(void **)(v23 + 16);
  if (!v24)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v16, v17, v18, v19, v20, v21, (uint64_t)"_ptr != NULL");
    long long v24 = *(void **)(v23 + 16);
  }
  uint64_t v25 = objc_msgSend_state(v24, v15, v16, v17);
  objc_msgSend_setRenderPipelineState_(*(void **)(v22 + 16), v26, v25, v27);
  id Texture = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 416));
  id v29 = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 424));
  uint64_t v33 = objc_msgSend_mipmapLevelCount(Texture, v30, v31, v32);
  double v35 = MEMORY[0x1F4188790](v33, v34);
  uint64_t v37 = (char *)&v85 - v36;
  sub_1B63F9CC0(v35, v39, v38, (const char *)&v85 - v36, v38, Texture, *(_DWORD *)(a1 + 404) == 1);
  LOBYTE(v40) = *(unsigned char *)(a3 + 16);
  float v87 = (float)v40 / (float)(unint64_t)(objc_msgSend_mipmapLevelCount(v29, v41, v42, v43) - 1);
  float64x2_t v88 = 0uLL;
  v89.f64[0] = 0.0;
  sub_1B649F334(*(void *)(v22 + 24), &v87, 4uLL, (void **)&v88);
  objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v22 + 16), v44, *(uint64_t *)&v88.f64[1], *(uint64_t *)&v89.f64[0], 0);
  int v86 = *(_DWORD *)&v37[4 * *(unsigned __int8 *)(a3 + 16)];
  float64x2_t v88 = 0uLL;
  v89.f64[0] = 0.0;
  sub_1B649F334(*(void *)(v22 + 24), &v86, 4uLL, (void **)&v88);
  objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v22 + 16), v45, *(uint64_t *)&v88.f64[1], *(uint64_t *)&v89.f64[0], 1);
  sub_1B63C6ED0(v22, Texture, 0, v46);
  uint64_t v47 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 424));
  if (*(unsigned char *)(a1 + 400) || *(unsigned char *)(a1 + 376) != 1)
  {
    uint64_t v66 = objc_msgSend_width(v29, v48, v49, v50);
    uint64_t v70 = objc_msgSend_height(v29, v67, v68, v69);
    v71.i64[0] = v66;
    v71.i64[1] = v70;
    float32x4_t v85 = vcvt_hight_f32_f64(0, vcvtq_f64_u64(v71));
    *(float *)v72.i32 = ldexpf(1.0, *(unsigned __int8 *)(a3 + 16));
    float32x4_t v73 = vdivq_f32(v85, (float32x4_t)vdupq_lane_s32(v72, 0));
    uint64_t v74 = *(void **)(v22 + 16);
    float64x2_t v88 = vcvtq_f64_f32(*(float32x2_t *)v73.f32);
    float64x2_t v89 = vcvt_hight_f64_f32(v73);
    long long v90 = xmmword_1B6E500C0;
    objc_msgSend_setViewport_(v74, v75, (uint64_t)&v88, v76);
    *(_DWORD *)uint64_t v22 = 1;
  }
  else
  {
    unsigned int v51 = v47[1];
    float v52 = (float)*v47;
    float v54 = ldexpf(1.0, *(unsigned __int8 *)(a3 + 16));
    uint64_t v55 = 0;
    double v56 = (float)(v52 / v54);
    double v57 = (float)((float)v51 / v54);
    do
    {
      long long v58 = (char *)&v88 + v55;
      *(void *)long long v58 = 0;
      *((void *)v58 + 1) = 0;
      *((double *)v58 + 2) = v56;
      *((double *)v58 + 3) = v57;
      v55 += 48;
      *((void *)v58 + 4) = 0;
      *((void *)v58 + 5) = 0;
    }
    while (v55 != 288);
    objc_msgSend_setViewports_count_(*(void **)(v22 + 16), v53, (uint64_t)&v88, 6);
  }
  uint64_t v77 = (void *)sub_1B6445900(*(void *)(a1 + 368), v59, v60, v61, v62, v63, v64, v65);
  if ((objc_msgSend_features(v77, v78, v79, v80) & 0x400) != 0)
  {
    if (*(unsigned char *)(a1 + 376) == 1 || !*(unsigned char *)(a3 + 17)) {
      return sub_1B63C6F54(v22, v81);
    }
    else {
      return sub_1B63F9E14((unsigned int *)v22, (const char *)3, 0, 3, 1, *(unsigned __int8 *)(a3 + 17));
    }
  }
  else
  {
    float64x2_t v88 = 0uLL;
    v89.f64[0] = 0.0;
    sub_1B649F334(*(void *)(v22 + 24), (const void *)(a3 + 17), 1uLL, (void **)&v88);
    objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v22 + 16), v82, *(uint64_t *)&v88.f64[1], *(uint64_t *)&v89.f64[0], 0);
    return objc_msgSend_drawPrimitives_vertexStart_vertexCount_(*(void **)(v22 + 16), v83, 3, 0, 3);
  }
}

void sub_1B63F9CC0(double a1, double a2, uint64_t a3, const char *a4, uint64_t a5, void *a6, int a7)
{
  unsigned int v7 = a5;
  LODWORD(a1) = 28.0;
  if (a7)
  {
    uint64_t v9 = objc_msgSend_width(a6, a4, a5, (uint64_t)a6, a1);
    HIDWORD(a2) = 1174405120;
    *(float *)&a1 = fminf(fmaxf((float)(unint64_t)(4 * v9), 32.0), 8192.0) + -4.0;
  }
  if (v7)
  {
    uint64_t v10 = 0;
    *(float *)&a2 = (float)(v7 - 1);
    uint64x2_t v25 = (uint64x2_t)vdupq_n_s64((unint64_t)v7 - 1);
    uint64x2_t v11 = (uint64x2_t)xmmword_1B6E4F270;
    int64x2_t v24 = vdupq_n_s64(2uLL);
    uint64_t v12 = (v7 + 1) & 0x1FFFFFFFELL;
    float32x2_t v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a1, 0);
    float32x2_t v14 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a2, 0);
    __asm { FMOV            V10.2S, #4.0 }
    do
    {
      int32x2_t v28 = vmovn_s64((int64x2_t)vcgeq_u64(v25, v11));
      int64x2_t v29 = (int64x2_t)v11;
      v20.i32[0] = v10;
      v20.i32[1] = v10 + 1;
      float32x2_t v21 = vdiv_f32(vcvt_f32_u32(v20), v14);
      float v26 = v21.f32[0];
      float v27 = powf(v21.f32[1], 0.25);
      v22.f32[0] = powf(v26, 0.25);
      v22.f32[1] = v27;
      float32x2_t v23 = vmla_f32(_D10, v13, v22);
      if (v28.i8[0]) {
        *(_DWORD *)&a4[4 * v10] = v23.f32[0];
      }
      if (v28.i8[4]) {
        *(_DWORD *)&a4[4 * v10 + 4] = v23.f32[1];
      }
      v10 += 2;
      uint64x2_t v11 = (uint64x2_t)vaddq_s64(v29, v24);
    }
    while (v12 != v10);
  }
}

uint64_t sub_1B63F9E14(unsigned int *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *a1;
  uint64_t v7 = v6 * a6;
  uint64_t v8 = (void *)*((void *)a1 + 2);
  if ((unint64_t)(v6 * a5) <= 1 && v7 == 0) {
    return objc_msgSend_drawPrimitives_vertexStart_vertexCount_(v8, a2, (uint64_t)a2, a3, a4);
  }
  if (v7) {
    return objc_msgSend_drawPrimitives_vertexStart_vertexCount_instanceCount_baseInstance_(v8, a2, (uint64_t)a2, a3, a4);
  }
  return objc_msgSend_drawPrimitives_vertexStart_vertexCount_instanceCount_(v8, a2, (uint64_t)a2, a3, a4);
}

uint64_t sub_1B63F9E54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v8 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA6F8, memory_order_acquire) & 1) == 0)
  {
    uint64_t v14 = a2;
    uint64_t v15 = a3;
    int v13 = __cxa_guard_acquire(&qword_1E9DDA6F8);
    uint64_t v8 = (void *)&unk_1E9DDA000;
    a2 = v14;
    a3 = v15;
    if (v13)
    {
      qword_1E9DDA6F0 = (uint64_t)sub_1B63FC21C("REFLECTION_PROBE_BOX_BLUR_PASS", 0x1Eu);
      __cxa_guard_release(&qword_1E9DDA6F8);
      uint64_t v8 = (void *)&unk_1E9DDA000;
      a2 = v14;
      a3 = v15;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v8[222], 0);
  *(void *)a1 = &unk_1F0FB47D0;
  long long v9 = *(_OWORD *)(a5 + 24);
  *(void *)(a1 + 400) = *(void *)(a5 + 40);
  *(_OWORD *)(a1 + 384) = v9;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v17 = 0u;
  RGTextureDescriptorMake2D(2 * *(_DWORD *)(a1 + 384), *(_DWORD *)(a1 + 384), *(void *)(a1 + 392), (uint64_t)&v17);
  *((void *)&v19 + 1) = 5;
  BYTE8(v17) = 5;
  v16[0] = v17;
  v16[1] = v18;
  v16[3] = v20;
  v16[4] = v21;
  _OWORD v16[2] = v19;
  uint64_t v10 = sub_1B63C7D8C(a4, (uint64_t)"REFLECTION_PROBE_BOX_BLUR_TARGET", (uint64_t)v16);
  *(void *)(a1 + 424) = v10;
  CFX::RG::Pass::renderTo(a1, (uint64_t)v10, 0x100000000, 0);
  char v11 = BYTE8(v17);
  *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 275) = v11;
  return a1;
}

void sub_1B63F9FD8(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B63F9FEC(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ *(unsigned __int16 *)(a1 + 400));
  unint64_t v6 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  uint64_t v7 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69
       * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ *(void *)(a1 + 392))) >> 47) ^ (0x9DDFEA08EB382D69
                                                                              * (v6 ^ *(void *)(a1 + 392))))) ^ ((0x9DDFEA08EB382D69 * (v6 ^ ((0x9DDFEA08EB382D69 * (v6 ^ *(void *)(a1 + 392))) >> 47) ^ (0x9DDFEA08EB382D69 * (v6 ^ *(void *)(a1 + 392))))) >> 47));
  uint64_t v8 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v7);
  *(void *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = v8;
  if (!v8)
  {
    *(void *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = sub_1B63FA218(*(CFX::CrossFrameResourceManager **)(a2 + 32), v7);
    uint64_t v16 = (void *)sub_1B6445900(*(void *)(a1 + 368), v9, v10, v11, v12, v13, v14, v15);
    long long v20 = objc_msgSend_resourceManager(v16, v17, v18, v19);
    long long v21 = (void *)sub_1B653EFAC((uint64_t)v20);
    uint64_t v25 = objc_msgSend_frameworkLibrary(v21, v22, v23, v24);
    uint64_t v26 = *(void *)(a1 + 392);
    float v27 = (void *)sub_1B653EFAC((uint64_t)v20);
    uint64_t v31 = objc_msgSend_frameworkLibrary(v27, v28, v29, v30);
    uint64_t v32 = *(void *)(a1 + 392);
    uint64_t v35 = objc_msgSend_stringWithFormat_(NSString, v33, @"box_blur_frag_%d", v34, *(unsigned __int16 *)(a1 + 400));
    uint64_t v36 = *(void *)(a1 + 408);
    memset(v67, 0, sizeof(v67));
    uint64_t v68 = 0;
    uint64_t v69 = v25;
    long long v80 = 0u;
    long long v81 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v79 = 0u;
    uint64_t v70 = v26;
    uint64_t v82 = @"vfx_draw_fullscreen_triangle_vertex";
    uint64_t v85 = 0;
    uint64_t v83 = @"copy_frag";
    uint64_t v84 = 0;
    uint64_t v39 = objc_msgSend_newRenderPipelineStateWithDesc_(v20, v37, (uint64_t)v67, v38);
    uint64_t v42 = *(void **)(v36 + 16);
    if (v42 != (void *)v39)
    {
      uint64_t v43 = v39;
      if (v42) {

      }
      *(void *)(v36 + 16) = v43;
    }
    uint64_t v44 = *(void *)(a1 + 408);
    memset(v48, 0, sizeof(v48));
    uint64_t v49 = 0;
    uint64_t v50 = v31;
    uint64_t v51 = v32;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    uint64_t v63 = @"vfx_draw_fullscreen_triangle_vertex";
    uint64_t v64 = v35;
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    uint64_t v45 = objc_msgSend_newRenderPipelineStateWithDesc_(v20, v40, (uint64_t)v48, v41);
    uint64_t v46 = *(void **)(v44 + 24);
    if (v46 != (void *)v45)
    {
      uint64_t v47 = v45;
      if (v46) {

      }
      *(void *)(v44 + 24) = v47;
    }
  }
}

uint64_t sub_1B63FA218(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B63FA2A0(uint64_t a1, CFX::GPUResourceManager **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v15 = objc_msgSend_renderEncoder(v11, v12, v13, v14);
  id Texture = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 416));
  id v20 = Texture;
  if (*(unsigned char *)(a3 + 16))
  {
    uint64_t v21 = objc_msgSend_pixelFormat(Texture, v17, v18, v19);
    uint64_t v25 = objc_msgSend_textureType(v20, v22, v23, v24);
    id v20 = (id)objc_msgSend_newTextureViewWithPixelFormat_textureType_levels_slices_(v20, v26, v21, v25, *(unsigned __int8 *)(a3 + 16), 1, 0, 1);
  }
  float v27 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 424));
  v28.i32[0] = *v27;
  v28.i32[1] = v27[1];
  v29.i64[0] = 0;
  *(float32x2_t *)&v29.u32[2] = vcvt_f32_u32(v28);
  float32x4_t v54 = v29;
  *(float *)v30.i32 = ldexpf(1.0, *(unsigned __int8 *)(a3 + 16));
  float32x4_t v31 = vdivq_f32(v54, (float32x4_t)vdupq_lane_s32(v30, 0));
  uint64_t v32 = *(void **)(v15 + 16);
  v55[0] = vcvtq_f64_f32(*(float32x2_t *)v31.f32);
  v55[1] = vcvt_hight_f64_f32(v31);
  v55[2] = xmmword_1B6E500C0;
  objc_msgSend_setViewport_(v32, v33, (uint64_t)v55, v34);
  *(_DWORD *)uint64_t v15 = 1;
  sub_1B63C6ED0(v15, v20, 0, v35);
  int v43 = *(unsigned __int8 *)(a3 + 16);
  uint64_t v44 = *(void *)(a1 + 408);
  if (!v43)
  {
    long long v53 = *(void **)(v44 + 16);
    uint64_t v46 = (void **)(v44 + 16);
    uint64_t v45 = v53;
    if (v53) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  uint64_t v47 = *(void **)(v44 + 24);
  uint64_t v46 = (void **)(v44 + 24);
  uint64_t v45 = v47;
  if (!v47)
  {
LABEL_5:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v37, v38, v39, v40, v41, v42, (uint64_t)"_ptr != NULL");
    uint64_t v45 = *v46;
  }
LABEL_6:
  uint64_t v48 = objc_msgSend_state(v45, v36, v37, v38);
  objc_msgSend_setRenderPipelineState_(*(void **)(v15 + 16), v49, v48, v50);
  return sub_1B63C6F54(v15, v51);
}

uint64_t sub_1B63FA41C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA708, memory_order_acquire) & 1) == 0)
  {
    uint64_t v28 = a2;
    uint64_t v29 = a3;
    int v27 = __cxa_guard_acquire(&qword_1E9DDA708);
    uint64_t v7 = (void *)&unk_1E9DDA000;
    a2 = v28;
    a3 = v29;
    if (v27)
    {
      qword_1E9DDA700 = (uint64_t)sub_1B63FC21C("REFLECTION_PROBE_CONVERT_CUBE_PASS", 0x22u);
      __cxa_guard_release(&qword_1E9DDA708);
      uint64_t v7 = (void *)&unk_1E9DDA000;
      a2 = v28;
      a3 = v29;
    }
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v7[224], 0);
  uint64_t v15 = (uint64_t (**)(uint64_t))&unk_1F0FB4D60;
  *(void *)a1 = &unk_1F0FB4D60;
  uint64_t v16 = *(void *)(a5 + 40);
  *(_OWORD *)(a1 + 384) = *(_OWORD *)(a5 + 24);
  *(void *)(a1 + 400) = v16;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 424) = 0;
  if (!*(unsigned char *)(a1 + 385))
  {
    long long v17 = (void *)sub_1B6445900(*(void *)(a1 + 368), v8, v9, v10, v11, v12, v13, v14);
    if ((objc_msgSend_features(v17, v18, v19, v20) & 0x20) != 0) {
      *(_WORD *)(a1 + 376) = 257;
    }
    *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 26_Block_object_dispose(&STACK[0x2B0], 8) = 6;
    uint64_t v15 = *(uint64_t (***)(uint64_t))a1;
  }
  int v21 = *(_DWORD *)(a1 + 404);
  *(unsigned char *)(v15[4](a1) + 275) = v21;
  int v22 = *(unsigned __int8 *)(a1 + 385);
  int v23 = *(_DWORD *)(a1 + 400);
  uint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  char v25 = 6 * v23;
  if (v22) {
    char v25 = v23;
  }
  *(unsigned char *)(v24 + 276) = v25;
  return a1;
}

void sub_1B63FA5BC(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

void sub_1B63FA5DC(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = CFX::RG::Pass::hash((CFX::RG::Pass *)a1);
  unint64_t v5 = 0x9DDFEA08EB382D69
     * (v4 ^ ((0x9DDFEA08EB382D69 * (*(void *)(a1 + 392) ^ v4)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                            * (*(void *)(a1 + 392) ^ v4)));
  unint64_t v6 = 0x9DDFEA08EB382D69 * (v5 ^ (v5 >> 47));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (v6 ^ *(unsigned __int8 *)(a1 + 384));
  unint64_t v8 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ *(unsigned __int8 *)(a1 + 385));
  uint64_t v10 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  uint64_t v11 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), v10);
  *(void *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = v11;
  if (!v11)
  {
    *(void *)(a1 + 40_Block_object_dispose(&STACK[0x2B0], 8) = sub_1B63FA7DC(*(CFX::CrossFrameResourceManager **)(a2 + 32), v10);
    uint64_t v19 = (void *)sub_1B6445900(*(void *)(a1 + 368), v12, v13, v14, v15, v16, v17, v18);
    int v23 = objc_msgSend_resourceManager(v19, v20, v21, v22);
    if ((objc_msgSend_features(v19, v24, v25, v26) & 0x400) != 0) {
      int32x2_t v30 = @"vfx_draw_fullscreen_cube";
    }
    else {
      int32x2_t v30 = @"vfx_draw_fullscreen_cube_no_base";
    }
    if ((objc_msgSend_features(v19, v27, v28, v29) & 0x20) != 0) {
      int32x2_t v30 = @"vfx_draw_fullscreen_cube_layered";
    }
    uint64_t v33 = objc_msgSend_stringWithFormat_(NSString, v31, @"vfx_convert_%s_from_%s_frag", v32, off_1E6141488[*(unsigned __int8 *)(a1 + 385)], off_1E6141488[*(unsigned __int8 *)(a1 + 384)]);
    uint64_t v34 = (void *)sub_1B653EFAC((uint64_t)v23);
    uint64_t v38 = objc_msgSend_frameworkLibrary(v34, v35, v36, v37);
    uint64_t v39 = *(void *)(a1 + 392);
    uint64_t v40 = *(void *)(a1 + 408);
    memset(v46, 0, sizeof(v46));
    uint64_t v47 = 0;
    uint64_t v48 = v38;
    uint64_t v49 = v39;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    long long v57 = 0u;
    long long v58 = 0u;
    uint64_t v59 = 0;
    char v60 = 3;
    memset(v62, 0, sizeof(v62));
    uint64_t v61 = 0;
    uint64_t v63 = v30;
    uint64_t v65 = 0;
    uint64_t v66 = 0;
    uint64_t v64 = v33;
    uint64_t v43 = objc_msgSend_newRenderPipelineStateWithDesc_(v23, v41, (uint64_t)v46, v42);
    uint64_t v44 = *(void **)(v40 + 16);
    if (v44 != (void *)v43)
    {
      uint64_t v45 = v43;
      if (v44) {

      }
      *(void *)(v40 + 16) = v45;
    }
  }
}

uint64_t sub_1B63FA7DC(CFX::CrossFrameResourceManager *a1, uint64_t a2)
{
  uint64_t v2 = CFX::CrossFrameResourceManager::get(a1, a2);
  if (!v2) {
    operator new();
  }
  return v2;
}

uint64_t sub_1B63FA864(uint64_t a1, CFX::GPUResourceManager **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = (void *)sub_1B6445900(*(void *)(a1 + 368), (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v22 = objc_msgSend_renderEncoder(v11, v12, v13, v14);
  uint64_t v23 = *(void *)(a1 + 408);
  uint64_t v24 = *(void **)(v23 + 16);
  if (!v24)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", v16, v17, v18, v19, v20, v21, (uint64_t)"_ptr != NULL");
    uint64_t v24 = *(void **)(v23 + 16);
  }
  uint64_t v25 = objc_msgSend_state(v24, v15, v16, v17);
  objc_msgSend_setRenderPipelineState_(*(void **)(v22 + 16), v26, v25, v27);
  id Texture = CFX::GPUResourceManager::getTexture(a2[3], *(const CFX::RG::Resource **)(a1 + 416));
  id v32 = Texture;
  if (*(unsigned char *)(a3 + 16))
  {
    if (*(unsigned char *)(a1 + 384)) {
      uint64_t v33 = 1;
    }
    else {
      uint64_t v33 = 6;
    }
    uint64_t v34 = objc_msgSend_pixelFormat(Texture, v29, v30, v31);
    uint64_t v38 = objc_msgSend_textureType(v32, v35, v36, v37);
    id v32 = (id)objc_msgSend_newTextureViewWithPixelFormat_textureType_levels_slices_(v32, v39, v34, v38, *(unsigned __int8 *)(a3 + 16), 1, 0, v33);
  }
  sub_1B63C6ED0(v22, v32, 0, v31);
  uint64_t v40 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor((CFX::RG::RenderGraphContext *)a2, *(const CFX::RG::Resource **)(a1 + 424));
  unsigned int v41 = *v40;
  unsigned int v42 = v40[1];
  if (*(unsigned char *)(a1 + 385) || *(unsigned char *)(a1 + 376) != 1)
  {
    v53.i64[0] = 0;
    v53.f32[2] = (float)v41;
    v53.f32[3] = (float)v42;
    float32x4_t v63 = v53;
    *(float *)v54.i32 = ldexpf(1.0, *(unsigned __int8 *)(a3 + 16));
    float32x4_t v55 = vdivq_f32(v63, (float32x4_t)vdupq_lane_s32(v54, 0));
    long long v56 = *(void **)(v22 + 16);
    float64x2_t v64 = vcvtq_f64_f32(*(float32x2_t *)v55.f32);
    float64x2_t v65 = vcvt_hight_f64_f32(v55);
    long long v66 = xmmword_1B6E500C0;
    objc_msgSend_setViewport_(v56, v57, (uint64_t)&v64, v58);
    *(_DWORD *)uint64_t v22 = 1;
  }
  else
  {
    float v43 = (float)v41;
    float v45 = ldexpf(1.0, *(unsigned __int8 *)(a3 + 16));
    uint64_t v46 = 0;
    double v47 = (float)(v43 / v45);
    double v48 = (float)((float)v42 / v45);
    do
    {
      uint64_t v49 = (char *)&v64 + v46;
      *(void *)uint64_t v49 = 0;
      *((void *)v49 + 1) = 0;
      *((double *)v49 + 2) = v47;
      *((double *)v49 + 3) = v48;
      v46 += 48;
      *((void *)v49 + 4) = 0;
      *((void *)v49 + 5) = 0;
    }
    while (v46 != 288);
    objc_msgSend_setViewports_count_(*(void **)(v22 + 16), v44, (uint64_t)&v64, 6);
  }
  if ((objc_msgSend_features(v11, v50, v51, v52) & 0x400) != 0)
  {
    if (*(unsigned char *)(a1 + 376) == 1 || !*(unsigned char *)(a3 + 17)) {
      return sub_1B63C6F54(v22, v59);
    }
    else {
      return sub_1B63F9E14((unsigned int *)v22, (const char *)3, 0, 3, 1, *(unsigned __int8 *)(a3 + 17));
    }
  }
  else
  {
    float64x2_t v64 = 0uLL;
    v65.f64[0] = 0.0;
    sub_1B649F334(*(void *)(v22 + 24), (const void *)(a3 + 17), 1uLL, (void **)&v64);
    objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v22 + 16), v60, *(uint64_t *)&v64.f64[1], *(uint64_t *)&v65.f64[0], 0);
    return objc_msgSend_drawPrimitives_vertexStart_vertexCount_(*(void **)(v22 + 16), v61, 3, 0, 3);
  }
}

uint64_t sub_1B63FAB14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7 = &unk_1E9DDA000;
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E9DDA718, memory_order_acquire) & 1) == 0)
  {
    uint64_t v18 = a2;
    uint64_t v20 = a3;
    int v17 = __cxa_guard_acquire(&qword_1E9DDA718);
    unint64_t v7 = &unk_1E9DDA000;
    a2 = v18;
    a3 = v20;
    if (v17)
    {
      byte_1E9DDA710 = 1;
      __cxa_guard_release(&qword_1E9DDA718);
      unint64_t v7 = (unsigned char *)&unk_1E9DDA000;
      a2 = v18;
      a3 = v20;
    }
  }
  if (v7[1808]) {
    uint64_t v8 = 0x5303C3899FA12B45;
  }
  else {
    uint64_t v8 = 0;
  }
  sub_1B645DCC0(a1, a2, a3, (uint64_t *)a5, v8, 0);
  *(void *)a1 = &unk_1F0FB37C8;
  long long v9 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)(a1 + 384) = *(_OWORD *)(a5 + 32);
  *(_OWORD *)(a1 + 400) = v9;
  *(void *)(a1 + 416) = 0;
  float32x4_t v19 = *(float32x4_t *)(a1 + 384);
  uint64_t v11 = (float64x2_t *)CFX::RG::Pass::commonRenderParameters(v10);
  *uint64_t v11 = vcvtq_f64_f32(*(float32x2_t *)v19.f32);
  v11[1] = vcvt_hight_f64_f32(v19);
  int v12 = *(_DWORD *)(a1 + 400);
  *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 276) = v12;
  int v13 = *(_DWORD *)(a1 + 404);
  *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 277) = v13;
  int v14 = *(_DWORD *)(a1 + 408);
  *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 274) = v14;
  int v15 = *(_DWORD *)(a1 + 412);
  *(unsigned char *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) + 275) = v15;
  return a1;
}

void sub_1B63FACC4(_Unwind_Exception *a1)
{
  CFX::RG::Pass::~Pass(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1B63FACD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = sub_1B644558C(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v18 = sub_1B64B28B0(v10, v11, v12, v13, v14, v15, v16, v17);
  int v26 = sub_1B63C1F7C(v18, v19, v20, v21, v22, v23, v24, v25);
  unint64_t v27 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v18) ^ ((0x9DDFEA08EB382D69 * v18) >> 47));
  uint64_t v28 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), 0x9DDFEA08EB382D69 * (v27 ^ (v27 >> 47)));
  uint64_t v36 = v28;
  if (v28 && *(unsigned char *)(v28 + 137))
  {
    *(unsigned char *)(v28 + 137) = 0;
    return 1;
  }
  if (v26
    || (uint64_t v38 = sub_1B64B2810(v10, 0)) != 0
    && ((uint64_t v39 = v38, sub_1B6475F88(v38, (uint64_t)v29, v30, v31, v32, v33, v34, v35))
     || sub_1B6477598(v39, (uint64_t)v29, v30, v31, v32, v33, v34, v35))
    || (uint64_t result = sub_1B64463F8(a1, (uint64_t)v29, v30, v31, v32, v33, v34, v35), result))
  {
    if (v36)
    {
      if (*(unsigned char *)(v36 + 136)) {
        return 1;
      }
      unsigned int v42 = *(void **)(v36 + 48);
      if (v42) {
        BOOL v41 = objc_msgSend_arrayLength(v42, v29, v30, v31) != v26 + 1;
      }
      else {
        BOOL v41 = 1;
      }
      int v43 = sub_1B64B37D0(v10, (uint64_t)v29, v30, v31, v32, v33, v34, v35);
      unsigned int v40 = *(_DWORD *)(v36 + 16);
      if (v40) {
        unsigned int v40 = **(_DWORD **)(v36 + 24) != v43;
      }
    }
    else
    {
      sub_1B64B37D0(v10, (uint64_t)v29, v30, v31, v32, v33, v34, v35);
      unsigned int v40 = 0;
      BOOL v41 = 1;
    }
    return v41 | v40;
  }
  return result;
}

uint64_t sub_1B63FAE10(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = (void *)sub_1B6445900(*a3, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v19 = sub_1B644558C(*a3, v12, v13, v14, v15, v16, v17, v18);
  uint64_t v27 = sub_1B64B28B0(v19, v20, v21, v22, v23, v24, v25, v26);
  int v118 = objc_msgSend_resourceManager(v11, v28, v29, v30);
  int v41 = sub_1B63C1F7C(v27, v31, v32, v33, v34, v35, v36, v37);
  if (!v41)
  {
    uint64_t v60 = sub_1B64B2810(v19, 0);
    if (!v60
      || (uint64_t v65 = v60, !sub_1B6475F88(v60, (uint64_t)v38, v39, v40, v61, v62, v63, v64))
      && !sub_1B6477598(v65, (uint64_t)v38, v39, v40, v66, v67, v68, v69))
    {
      if (!sub_1B64463F8(*a3, (uint64_t)v38, v39, v40, v61, v62, v63, v64)) {
        return 0;
      }
    }
  }
  unsigned int v42 = v41 + 1;
  objc_msgSend_device(v11, v38, v39, v40);
  int v43 = sub_1B64D96DC();
  objc_msgSend_device(v11, v44, v45, v46);
  int v47 = sub_1B64D971C();
  uint64_t v51 = 115;
  if ((v47 & v43) != 0) {
    uint64_t v51 = 93;
  }
  uint64_t v117 = v51;
  if ((objc_msgSend_features(v11, v48, v49, v50) & 0x100) != 0) {
    int v52 = 256;
  }
  else {
    int v52 = 128;
  }
  int v116 = v52;
  unint64_t v53 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v27) ^ ((0x9DDFEA08EB382D69 * v27) >> 47));
  uint64_t v114 = v27;
  uint64_t v54 = CFX::CrossFrameResourceManager::get(*(CFX::CrossFrameResourceManager **)(a2 + 32), 0x9DDFEA08EB382D69 * (v53 ^ (v53 >> 47)));
  uint64_t v58 = v54;
  if (!v54 || (uint64_t v59 = *(void **)(v54 + 48)) == 0 || objc_msgSend_arrayLength(v59, v55, v56, v57) != v42) {
    operator new();
  }
  uint64_t v71 = *(void *)(v58 + 48);
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v138, v58 + 56);
  v137[0] = MEMORY[0x1E4F143A8];
  v137[1] = 3221225472;
  v137[2] = sub_1B63FB770;
  v137[3] = &unk_1E61414A8;
  v137[4] = v71;
  CFX::RG::ExternalResourceDesc::ExternalResourceDesc(v139, v138, v137, 0);
  float32x2_t v115 = sub_1B63FB710(a1, (uint64_t)"REFLECTION PROBE ARRAY", (long long *)v139);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v139);
  uint64_t v79 = sub_1B64B2810(v19, 0);
  if (v79) {
    objc_msgSend_renderResourceForMaterialProperty_withEngineContext_didFallbackToDefaultTexture_isDynamic_(v118, v72, v79, *a3, 0, 0);
  }
  uint64_t v133 = 0;
  float32x4_t v134 = &v133;
  uint64_t v135 = 0x2020000000;
  uint64_t v136 = 0;
  uint64_t v129 = 0;
  unint64_t v130 = &v129;
  uint64_t v131 = 0x2020000000;
  char v132 = 0;
  int v87 = sub_1B64B37D0(v19, (uint64_t)v72, v73, v74, v75, v76, v77, v78);
  if (**(_DWORD **)(v58 + 24) != v87)
  {
    *((unsigned char *)v130 + 24) = 1;
    if (!v79) {
      goto LABEL_23;
    }
    if (sub_1B6475F88(v79, v80, v81, v82, v83, v84, v85, v86))
    {
      isDynamic = (CFX::RG::Resource *)objc_msgSend_renderResourceForMaterialProperty_withEngineContext_didFallbackToDefaultTexture_isDynamic_(v118, v88, v79, *a3, 0, 0);
      goto LABEL_27;
    }
    if (!sub_1B6477598(v79, (uint64_t)v88, v89, v90, v91, v92, v93, v94))
    {
LABEL_23:
      BOOL v99 = !sub_1B64463F8(*a3, v80, v81, v82, v83, v84, v85, v86);
      if (v42 > 1) {
        LOBYTE(v99) = 1;
      }
      if (!v99)
      {
        uint64_t v100 = objc_msgSend_resourceManager(v11, v96, v97, v98);
        isDynamic = (CFX::RG::Resource *)(id)objc_msgSend_defaultLightingEnvironmentRadianceTexture(v100, v101, v102, v103);
LABEL_27:
        uint64_t v104 = isDynamic;
        if (isDynamic)
        {
          memset(v128, 0, sizeof(v128));
          RGTextureDescriptorFromMTLTexture(isDynamic, (uint64_t)v128);
          CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v124, v128);
          v123[0] = MEMORY[0x1E4F143A8];
          v123[1] = 3221225472;
          v123[2] = sub_1B63FB780;
          _OWORD v123[3] = &unk_1E61414A8;
          v123[4] = v104;
          CFX::RG::ExternalResourceDesc::ExternalResourceDesc(&v125, v124, v123, 0);
          CFX::RG::ExternalResourceDesc::ExternalResourceDesc((uint64_t)v122, &v125);
          uint64_t v104 = sub_1B63FB710(a1, (uint64_t)"ENVIRONMENT TEXTURE", (long long *)v122);
          CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v122);
          CFX::RG::ExternalResourceDesc::~ExternalResourceDesc((id *)&v125);
        }
        goto LABEL_30;
      }
    }
    uint64_t v104 = 0;
LABEL_30:
    float v105 = sub_1B63FB788(a1, a3, 0, v104, v116, v117, v115);
    _OWORD v134[3] = (uint64_t)v105;
    **(_DWORD **)(v58 + 24) = v87;
    **(void **)(v58 + 40) = 0;
  }
  *(void *)&long long v125 = 0;
  *((void *)&v125 + 1) = &v125;
  uint64_t v126 = 0x2020000000;
  char v127 = 0;
  v119[0] = MEMORY[0x1E4F143A8];
  v119[1] = 3221225472;
  v119[2] = sub_1B63FB9C8;
  v119[3] = &unk_1E61414F8;
  char v121 = 0;
  v119[8] = v58;
  v119[9] = a1;
  v119[10] = a3;
  v119[11] = v115;
  int v120 = v116;
  v119[12] = v58;
  v119[13] = v117;
  v119[5] = &v133;
  v119[6] = &v129;
  v119[4] = v118;
  v119[7] = &v125;
  sub_1B63C4554(v114, (uint64_t)v119);
  *(unsigned char *)(v58 + 136) = *(unsigned char *)(*((void *)&v125 + 1) + 24);
  *(unsigned char *)(v58 + 137) = *((unsigned char *)v130 + 24);
  uint64_t v112 = *(void *)(v58 + 48);
  if (!v112)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", 0, v107, v108, v109, v110, v111, (uint64_t)"_ptr != NULL");
    uint64_t v112 = *(void *)(v58 + 48);
  }
  objc_msgSend__setReflectionProbeArrayTexture_(v11, v106, v112, v107);
  uint64_t v70 = v134[3];
  _Block_object_dispose(&v125, 8);
  _Block_object_dispose(&v129, 8);
  _Block_object_dispose(&v133, 8);
  return v70;
}

void sub_1B63FB5B8(_Unwind_Exception *a1)
{
}

void sub_1B63FB640(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != a2)
  {
    if (v2 <= a2)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 4);
      int v6 = a2 - v5;
      if (a2 > v5)
      {
        sub_1B63FCC18((unsigned int *)a1, v6, 0);
        unsigned int v2 = *(_DWORD *)a1;
      }
      bzero((void *)(*(void *)(a1 + 8) + 4 * v2), 4 * (a2 - v2));
    }
    *(_DWORD *)a1 = a2;
  }
}

void sub_1B63FB6A8(uint64_t a1, unsigned int a2)
{
  unsigned int v2 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != a2)
  {
    if (v2 <= a2)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 4);
      int v6 = a2 - v5;
      if (a2 > v5)
      {
        sub_1B63D00C4((unsigned int *)a1, v6, 0);
        unsigned int v2 = *(_DWORD *)a1;
      }
      bzero((void *)(*(void *)(a1 + 8) + 8 * v2), 8 * (a2 - v2));
    }
    *(_DWORD *)a1 = a2;
  }
}

CFX::RG::Resource *sub_1B63FB710(uint64_t *a1, uint64_t a2, long long *a3)
{
  uint64_t v9 = a2;
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unsigned __int8 v8 = 1;
  int v6 = (CFX::RG::Resource *)sub_1B63FCCE4(v4, v5, &v9, a3, &v8);
  CFX::RG::RenderGraphBuilder::appendResource(a1, v6);
  return v6;
}

uint64_t sub_1B63FB770(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_1B63FB778(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_1B63FB780(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t *sub_1B63FB788(uint64_t *a1, uint64_t *a2, int a3, CFX::RG::Resource *this, int a5, uint64_t a6, CFX::RG::Resource *a7)
{
  if (this
    && (uint64_t v13 = this, v14 = CFX::RG::Resource::constTextureDesc(this), VFXMTLTextureTypeIsCube(*(void *)(v14 + 40))))
  {
    uint64_t v15 = CFX::RG::Resource::constTextureDesc(v13);
    if (*(unsigned char *)(v15 + 17)
      && *(unsigned char *)(v15 + 16) == 5
      && ((uint64_t v16 = CFX::RG::Resource::constTextureDesc(v13), !*(unsigned char *)(v16 + 2)) || *(_WORD *)v16 != 16))
    {
      *(void *)&long long v34 = v13;
      DWORD2(v34) = 0;
      uint64_t v35 = a7;
      *(_DWORD *)uint64_t v36 = a3;
      *(_DWORD *)&v36[4] = 1;
      return (uint64_t *)CFX::RG::makeCopyPass(a1, (uint64_t)"Copy probe pass", &v34);
    }
    else
    {
      uint64_t v17 = CFX::RG::Resource::constTextureDesc(v13);
      if (*(unsigned char *)(v17 + 17) && *(unsigned __int8 *)(v17 + 16) > 4u)
      {
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v23 = *a2;
        *(void *)&long long v34 = "Generate probe mipmap pass";
        *((void *)&v34 + 1) = v23;
        LOBYTE(v35) = 1;
        uint64_t v24 = (long long *)CFX::RG::Resource::constTextureDesc(v13);
        long long v25 = *v24;
        *(_OWORD *)&v36[16] = v24[1];
        *(_OWORD *)uint64_t v36 = v25;
        long long v26 = v24[2];
        long long v27 = v24[3];
        long long v28 = v24[4];
        long long v40 = v24[5];
        long long v39 = v28;
        long long v38 = v27;
        long long v37 = v26;
        long long v29 = v24[6];
        long long v30 = v24[7];
        long long v31 = v24[8];
        long long v44 = v24[9];
        long long v43 = v31;
        long long v42 = v30;
        long long v41 = v29;
        int v45 = 5;
        uint64_t v18 = (CFX::RG::Pass *)sub_1B63FC458(a1, (uint64_t)a1, (uint64_t)&v34);
        sub_1B63E2620((uint64_t)v18, v13);
        uint64_t v13 = (CFX::RG::Resource *)*((void *)v18 + 70);
      }
      return sub_1B63FC4B0(a1, a2, a3, a5, a6, 1, v13, v18, (uint64_t)a7);
    }
  }
  else
  {
    uint64_t v19 = CFX::RG::Resource::constTextureDesc(a7);
    if (VFXMTLTextureTypeIsCube(*(void *)(v19 + 40))) {
      int v20 = 6;
    }
    else {
      int v20 = 1;
    }
    uint64_t v21 = *a2;
    *(void *)&long long v34 = "Clear texture pass";
    *((void *)&v34 + 1) = v21;
    LOWORD(v35) = 0;
    *(_OWORD *)&v36[8] = xmmword_1B6E4F370;
    *(_DWORD *)&v36[24] = v20 * a3;
    *(_DWORD *)&v36[28] = v20;
    LODWORD(v37) = 0;
    DWORD1(v37) = *(unsigned __int8 *)(CFX::RG::Resource::constTextureDesc(a7) + 16);
    uint64_t v22 = sub_1B63FC400(a1, (uint64_t)a1, (uint64_t)&v34);
    *(void *)(v22 + 416) = a7;
    CFX::RG::Pass::renderTo(v22, (uint64_t)a7, 0x100000002, 0);
  }
  return (uint64_t *)v22;
}

uint64_t sub_1B63FB9C8(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    unsigned __int8 v8 = (uint64_t *)a4;
    uint64_t v9 = (uint64_t *)a3;
    uint64_t v10 = result;
    uint64_t v11 = a2;
    while (1)
    {
      uint64_t v12 = (const void *)*v8;
      if (sub_1B64975FC(*v8, a2, a3, a4, a5, a6, a7, a8) != 1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Wrong probe type", v14, v15, v16, v17, v18, v19, (uint64_t)"CFXLightGetProbeType(light) == kCFXLightProbeTypeRadiance");
      }
      unsigned int v27 = sub_1B6497C2C((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19);
      if (v27 == -1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Bad index", v21, v22, v23, v24, v25, v26, (uint64_t)"probeIndex != (uint32_t)kProbeSliceIndexInvalid");
      }
      int v28 = sub_1B6497C8C((uint64_t)v12, v20, v21, v22, v23, v24, v25, v26);
      uint64_t result = sub_1B64977A4((uint64_t)v12, v29, v30, v31, v32, v33, v34, v35);
      if (result == 1) {
        break;
      }
      int v37 = result;
      if (!*(unsigned char *)(v10 + 116)) {
        goto LABEL_17;
      }
      v73[0] = MEMORY[0x1E4F143A8];
      v73[1] = 3221225472;
      v73[2] = sub_1B63FBDBC;
      v73[3] = &unk_1E61414D0;
      uint64_t v75 = *(void *)(v10 + 64);
      uint64_t v76 = v12;
      long long v38 = *(_OWORD *)(v10 + 72);
      int v79 = v28;
      unsigned int v80 = v27;
      long long v39 = *(_OWORD *)(v10 + 88);
      long long v77 = v38;
      long long v78 = v39;
      long long v74 = *(_OWORD *)(v10 + 40);
      uint64_t result = sub_1B63FBDBC((uint64_t)v73, a2, a3, a4, a5, a6, a7, a8);
      if ((result & 1) == 0)
      {
LABEL_17:
        if (v37 == 2)
        {
          uint64_t v45 = *(void *)(v10 + 96);
          int v46 = *(_DWORD *)(*(void *)(v45 + 24) + 4 * v27);
          int v47 = *(const void **)(*(void *)(v45 + 40) + 8 * v27);
          if (v46 != v28 || v47 != v12)
          {
            printf("probe[%d] not up to date stamp [%d -> %d] sources [%p -> %p]\n", v27, v46, v28, v47, v12);
            uint64_t v55 = sub_1B6494F20((uint64_t)v12, 0, v49, v50, v51, v52, v53, v54);
            uint64_t v63 = (CFX::RG::Resource *)v55;
            if (v55)
            {
              if (sub_1B6475F88(v55, v56, v57, v58, v59, v60, v61, v62))
              {
                isDynamic = objc_msgSend_renderResourceForMaterialProperty_withEngineContext_didFallbackToDefaultTexture_isDynamic_(*(void **)(v10 + 32), v64, (uint64_t)v63, **(void **)(v10 + 80), 0, 0);
                memset(v72, 0, 80);
                RGTextureDescriptorFromMTLTexture(isDynamic, (uint64_t)v72);
                CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v70, v72);
                v69[0] = MEMORY[0x1E4F143A8];
                v69[1] = 3221225472;
                v69[2] = sub_1B63FC0E0;
                v69[3] = &unk_1E61414A8;
                v69[4] = isDynamic;
                CFX::RG::ExternalResourceDesc::ExternalResourceDesc(v71, v70, v69, 0);
                uint64_t v66 = *(uint64_t **)(v10 + 72);
                CFX::RG::ExternalResourceDesc::ExternalResourceDesc((uint64_t)v68, (long long *)v71);
                uint64_t v63 = sub_1B63FB710(v66, (uint64_t)"ENVIRONMENT TEXTURE", (long long *)v68);
                CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v68);
                CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v71);
              }
              else
              {
                uint64_t v63 = 0;
              }
            }
            uint64_t result = (uint64_t)sub_1B63FB788(*(uint64_t **)(v10 + 72), *(uint64_t **)(v10 + 80), v27, v63, *(_DWORD *)(v10 + 112), *(void *)(v10 + 104), *(CFX::RG::Resource **)(v10 + 88));
            *(void *)(*(void *)(*(void *)(v10 + 40) + 8) + 24) = result;
            *(unsigned char *)(*(void *)(*(void *)(v10 + 48) + 8) + 24) = 1;
            uint64_t v67 = *(void *)(v10 + 96);
            *(_DWORD *)(*(void *)(v67 + 24) + 4 * v27) = v28;
            *(void *)(*(void *)(v67 + 40) + 8 * v27) = v12;
          }
          goto LABEL_28;
        }
        if (!v37)
        {
          uint64_t v40 = *(void *)(v10 + 96);
          int v41 = *(_DWORD *)(*(void *)(v40 + 24) + 4 * v27);
          long long v42 = *(const void **)(*(void *)(v40 + 40) + 8 * v27);
          if (v41 != v28 || v42 != v12)
          {
            printf("probe[%d] not up to date stamp [%d -> %d] sources [%p -> %p]\n", v27, v41, v28, v42, v12);
            uint64_t v44 = *(void *)(v10 + 96);
            *(_DWORD *)(*(void *)(v44 + 24) + 4 * v27) = v28;
            *(void *)(*(void *)(v44 + 40) + 8 * v27) = v12;
            uint64_t result = (uint64_t)sub_1B63FBFA8(*(uint64_t **)(v10 + 72), *(uint64_t **)(v10 + 80), v27, *v9, *(_DWORD *)(v10 + 112), *(void *)(v10 + 104), *(void *)(v10 + 88));
            *(void *)(*(void *)(*(void *)(v10 + 40) + 8) + 24) = result;
            uint64_t v36 = *(void *)(v10 + 48);
            goto LABEL_9;
          }
        }
      }
LABEL_28:
      ++v8;
      ++v9;
      if (!--v11) {
        return result;
      }
    }
    uint64_t result = (uint64_t)sub_1B63FBFA8(*(uint64_t **)(v10 + 72), *(uint64_t **)(v10 + 80), v27, *v9, *(_DWORD *)(v10 + 112), *(void *)(v10 + 104), *(void *)(v10 + 88));
    *(void *)(*(void *)(*(void *)(v10 + 40) + 8) + 24) = result;
    uint64_t v36 = *(void *)(v10 + 56);
LABEL_9:
    *(unsigned char *)(*(void *)(v36 + 8) + 24) = 1;
    goto LABEL_28;
  }
  return result;
}

void sub_1B63FBD98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(&a16);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(&a65);
  _Unwind_Resume(a1);
}

uint64_t sub_1B63FBDBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(void *)(v9 + 40);
  uint64_t v11 = *(unsigned int *)(v9 + 32);
  if (v11)
  {
    uint64_t v12 = 8 * v11;
    uint64_t v13 = *(void **)(v9 + 40);
    while (*v13 != *(void *)(a1 + 56))
    {
      ++v13;
      v12 -= 8;
      if (!v12)
      {
        uint64_t v13 = (void *)(v10 + 8 * v11);
        break;
      }
    }
  }
  else
  {
    uint64_t v13 = *(void **)(v9 + 40);
  }
  uint64_t v14 = (uint64_t)v13 - v10;
  unint64_t v15 = (unint64_t)v14 >> 3;
  BOOL v16 = v11 == v14 >> 3 || v15 == -1;
  if (v16 || *(_DWORD *)(*(void *)(v9 + 24) + 4 * v15) == *(_DWORD *)(a1 + 96)) {
    return 0;
  }
  uint64_t v18 = *(void *)(v9 + 48);
  if (!v18)
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Dereferencing null pointer", a3, a4, a5, a6, a7, a8, (uint64_t)"_ptr != NULL");
    uint64_t v18 = *(void *)(v9 + 48);
    uint64_t v9 = *(void *)(a1 + 48);
  }
  uint64_t v19 = *(uint64_t **)(a1 + 64);
  CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v27, v9 + 56);
  v26[0] = MEMORY[0x1E4F143A8];
  v26[1] = 3221225472;
  v26[2] = sub_1B63FBFA0;
  void v26[3] = &unk_1E61414A8;
  v26[4] = v18;
  CFX::RG::ExternalResourceDesc::ExternalResourceDesc(v28, v27, v26, 0);
  uint64_t v20 = sub_1B63FB710(v19, (uint64_t)"OLD REFLECTION PROBE ARRAY", (long long *)v28);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v28);
  uint64_t v21 = *(uint64_t **)(a1 + 64);
  uint64_t v22 = *(void *)(a1 + 80);
  int v23 = *(_DWORD *)(a1 + 100);
  *(void *)&long long v29 = v20;
  DWORD2(v29) = v15;
  uint64_t v30 = v22;
  uint64_t v17 = 1;
  int v31 = v23;
  int v32 = 1;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFX::RG::makeCopyPass(v21, (uint64_t)"Copy probe pass", &v29);
  uint64_t v24 = *(void *)(a1 + 88);
  *(_DWORD *)(*(void *)(v24 + 24) + 4 * *(unsigned int *)(a1 + 100)) = *(_DWORD *)(a1 + 96);
  *(void *)(*(void *)(v24 + 40) + 8 * *(unsigned int *)(a1 + 100)) = *(void *)(a1 + 56);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  return v17;
}

void sub_1B63FBF8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,id a35)
{
}

uint64_t sub_1B63FBFA0(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t *sub_1B63FBFA8(uint64_t *a1, uint64_t *a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = *a2;
  v39[0] = "Reflection probe render pass";
  v39[1] = v13;
  __int16 v40 = 0;
  int v41 = a5;
  uint64_t v42 = a6;
  uint64_t v43 = a4;
  uint64_t v14 = (CFX::RG::Resource **)sub_1B63FC920(a1, a1, (uint64_t)v39);
  uint64_t v15 = *a2;
  v26[0] = "Generate probe mipmap pass";
  v26[1] = v15;
  char v27 = 0;
  BOOL v16 = (long long *)CFX::RG::Resource::constTextureDesc(v14[52]);
  long long v17 = *v16;
  long long v29 = v16[1];
  long long v28 = v17;
  long long v18 = v16[2];
  long long v19 = v16[3];
  long long v20 = v16[4];
  long long v33 = v16[5];
  long long v32 = v20;
  long long v31 = v19;
  long long v30 = v18;
  long long v21 = v16[6];
  long long v22 = v16[7];
  long long v23 = v16[8];
  long long v37 = v16[9];
  long long v36 = v23;
  long long v35 = v22;
  long long v34 = v21;
  int v38 = 0;
  uint64_t v24 = sub_1B63FC458(a1, (uint64_t)a1, (uint64_t)v26);
  sub_1B63E2620(v24, v14[52]);
  CFX::RG::Pass::dependsOn((uint64_t *)v24, (CFX::RG::Pass *)v14);
  return sub_1B63FC4B0(a1, a2, a3, a5, a6, 0, *(CFX::RG::Resource **)(v24 + 560), (CFX::RG::Pass *)v24, a7);
}

uint64_t sub_1B63FC0E0(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_1B63FC0EC(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63FC128(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63FC168(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63FC1A4(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63FC1E0(CFX::RG::Pass *a1)
{
  CFX::RG::Pass::~Pass(a1);

  JUMPOUT(0x1BA9B6D80);
}

unsigned __int8 *sub_1B63FC21C(unsigned __int8 *result, unsigned int a2)
{
  if (result)
  {
    unint64_t v2 = 0xC6A4A7935BD1E995 * a2;
    if (a2 >= 8)
    {
      uint64_t v3 = a2 >> 3;
      uint64_t v4 = &result[8 * v3];
      uint64_t v5 = 8 * v3;
      do
      {
        uint64_t v6 = *(void *)result;
        result += 8;
        unint64_t v2 = 0xC6A4A7935BD1E995
           * ((0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * v6) ^ ((0xC6A4A7935BD1E995 * v6) >> 47))) ^ v2);
        v5 -= 8;
      }
      while (v5);
      uint64_t result = v4;
    }
    switch(a2 & 7)
    {
      case 1u:
        goto LABEL_13;
      case 2u:
        goto LABEL_12;
      case 3u:
        goto LABEL_11;
      case 4u:
        goto LABEL_10;
      case 5u:
        goto LABEL_9;
      case 6u:
        goto LABEL_8;
      case 7u:
        v2 ^= (unint64_t)result[6] << 48;
LABEL_8:
        v2 ^= (unint64_t)result[5] << 40;
LABEL_9:
        v2 ^= (unint64_t)result[4] << 32;
LABEL_10:
        v2 ^= (unint64_t)result[3] << 24;
LABEL_11:
        v2 ^= (unint64_t)result[2] << 16;
LABEL_12:
        v2 ^= (unint64_t)result[1] << 8;
LABEL_13:
        unint64_t v2 = 0xC6A4A7935BD1E995 * (v2 ^ *result);
        break;
      default:
        return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995
                                                                                * (v2 ^ (v2 >> 47))) >> 47));
    }
    return (unsigned __int8 *)((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) ^ ((0xC6A4A7935BD1E995 * (v2 ^ (v2 >> 47))) >> 47));
  }
  return result;
}

uint64_t sub_1B63FC308(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB3E30;
  unint64_t v2 = *(void **)(a1 + 48);
  if (v2) {

  }
  if (*(_DWORD *)(a1 + 36)) {
    free(*(void **)(a1 + 40));
  }
  if (*(_DWORD *)(a1 + 20)) {
    free(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1B63FC374(uint64_t a1)
{
  *(void *)a1 = &unk_1F0FB3E30;
  unint64_t v2 = *(void **)(a1 + 48);
  if (v2) {

  }
  if (*(_DWORD *)(a1 + 36)) {
    free(*(void **)(a1 + 40));
  }
  if (*(_DWORD *)(a1 + 20)) {
    free(*(void **)(a1 + 24));
  }

  JUMPOUT(0x1BA9B6D80);
}

uint64_t sub_1B63FC400(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63FC658(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B63FC458(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63FC6A8(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t *sub_1B63FC4B0(uint64_t *a1, uint64_t *a2, int a3, int a4, uint64_t a5, int a6, CFX::RG::Resource *a7, CFX::RG::Pass *a8, uint64_t a9)
{
  uint64_t v17 = *a2;
  v38[0] = "Reflection probe radiance pass";
  v38[1] = v17;
  __int16 v39 = 0;
  int v40 = a4;
  uint64_t v41 = a5;
  BOOL v42 = a6 != 1;
  int v43 = a6;
  long long v18 = (uint64_t *)sub_1B63FC708(a1, a1, (uint64_t)v38);
  v18[52] = (uint64_t)a7;
  CFX::RG::Pass::readFrom(v18, a7);
  if (a8) {
    CFX::RG::Pass::dependsOn(v18, a8);
  }
  if (a6 == 1)
  {
    *(void *)&long long v32 = v18[53];
    DWORD2(v32) = 0;
    uint64_t v33 = a9;
    int v34 = a3;
    int v35 = 1;
    CopyPass = (uint64_t *)CFX::RG::makeCopyPass(a1, (uint64_t)"Copy radiance pass", &v32);
    CFX::RG::Pass::dependsOn(CopyPass, (CFX::RG::Pass *)v18);
  }
  else
  {
    uint64_t v19 = *a2;
    *(void *)&long long v32 = "Reflection probe box blur pass";
    *((void *)&v32 + 1) = v19;
    LOWORD(v33) = 0;
    int v34 = a4;
    uint64_t v36 = a5;
    __int16 v37 = 5;
    long long v20 = (uint64_t *)sub_1B63FC760(a1, a1, (uint64_t)&v32);
    long long v21 = (CFX::RG::Resource *)v18[53];
    v20[52] = (uint64_t)v21;
    CFX::RG::Pass::readFrom(v20, v21);
    uint64_t v22 = *a2;
    v26[0] = "Reflection probe convert cube pass";
    v26[1] = v22;
    __int16 v27 = 0;
    __int16 v28 = 1;
    uint64_t v29 = a5;
    int v30 = a3;
    int v31 = 5;
    CopyPass = (uint64_t *)sub_1B63FC7B8(a1, (uint64_t)a1, (uint64_t)v26);
    uint64_t v24 = (CFX::RG::Resource *)v20[53];
    CopyPass[52] = (uint64_t)v24;
    CFX::RG::Pass::readFrom(CopyPass, v24);
    CopyPass[53] = a9;
    CFX::RG::Pass::renderTo((uint64_t)CopyPass, a9, 0x100000000, 0);
  }
  return CopyPass;
}

uint64_t sub_1B63FC658(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v7 = sub_1B63C8330(v10, 0x1B0u, 0x10u);
  return sub_1B63FAB14(v7, *a3, a3[1], v8, a5);
}

uint64_t sub_1B63FC6A8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x238u, 8u);
  return sub_1B63E24FC(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B63FC708(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63FC810(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B63FC760(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63FC870(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B63FC7B8(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63FC8D0(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B63FC810(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1B0u, 8u);
  return sub_1B63F945C(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B63FC870(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1B0u, 8u);
  return sub_1B63F9E54(v8, *a3, a3[1], a4, a5);
}

uint64_t sub_1B63FC8D0(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v7 = sub_1B63C8330(v10, 0x1B0u, 8u);
  return sub_1B63FA41C(v7, *a3, a3[1], v8, a5);
}

uint64_t sub_1B63FC920(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = a1[1];
  v7[0] = *a1;
  v7[1] = v5;
  v7[0] = sub_1B63FC978(v7[0], v5, v7, a2, a3);
  sub_1B63C88CC(a1 + 18, v7);
  return v7[0];
}

uint64_t sub_1B63FC978(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  v10[0] = a1;
  v10[1] = a2;
  uint64_t v8 = sub_1B63C8330(v10, 0x1B0u, 8u);
  return sub_1B63F903C(v8, *a3, a3[1], a4, a5);
}

void *sub_1B63FC9D8(void *a1)
{
  *a1 = &unk_1F0FB49B0;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B63FCA24(void *a1)
{
  *a1 = &unk_1F0FB49B0;
  int8x16_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B63FCA90(void *a1)
{
  *a1 = &unk_1F0FB47B0;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  return a1;
}

void sub_1B63FCAE8(void *a1)
{
  *a1 = &unk_1F0FB47B0;
  unint64_t v2 = (void *)a1[3];
  if (v2) {

  }
  uint64_t v3 = (void *)a1[2];
  if (v3) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void *sub_1B63FCB60(void *a1)
{
  *a1 = &unk_1F0FB4D40;
  unint64_t v2 = (void *)a1[2];
  if (v2) {

  }
  return a1;
}

void sub_1B63FCBAC(void *a1)
{
  *a1 = &unk_1F0FB4D40;
  int8x16_t v1 = (void *)a1[2];
  if (v1) {

  }
  JUMPOUT(0x1BA9B6D80);
}

void sub_1B63FCC18(unsigned int *a1, int a2, int a3)
{
  uint64_t v4 = (unsigned int *)*((void *)a1 + 1);
  uint64_t v5 = a1 + 4;
  double v6 = 1.5;
  if (a3) {
    double v6 = 1.0;
  }
  unsigned int v7 = (v6 * (double)(a1[1] + a2));
  uint64_t v8 = malloc_type_malloc(4 * v7, 0xD5346062uLL);
  memset(v8, 255, 4 * v7);
  memcpy(v8, v4, 4 * *a1);
  *((void *)a1 + 1) = v8;
  a1[1] = v7;
  if (v4 != v5)
  {
    free(v4);
  }
}

uint64_t sub_1B63FCCE4(uint64_t a1, uint64_t a2, uint64_t *a3, long long *a4, unsigned __int8 *a5)
{
  v12[0] = a1;
  v12[1] = a2;
  uint64_t v8 = sub_1B63C8330(v12, 0xE0u, 8u);
  uint64_t v9 = *a3;
  CFX::RG::ExternalResourceDesc::ExternalResourceDesc((uint64_t)v11, a4);
  CFX::RG::Resource::Resource(v8, v9, v11, *a5);
  CFX::RG::ExternalResourceDesc::~ExternalResourceDesc(v11);
  return v8;
}

void sub_1B63FCD70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
}

double sub_1B63FCD84(uint64_t a1, __n128 *a2, void *a3, void *a4, __n128 *a5, int a6, double result)
{
  v33[1] = *MEMORY[0x1E4F143B8];
  if (a6)
  {
    *(double *)v15.i64 = MEMORY[0x1F4188790](a1, a2);
    uint64_t v17 = (char *)v33 - v16;
    if (v18 >= 1)
    {
      float32x4_t v19 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3);
      v20.i64[0] = 0x8000000080000000;
      v20.i64[1] = 0x8000000080000000;
      uint64_t v21 = v14;
      uint64_t v22 = (float32x4_t *)a2;
      long long v23 = v17;
      do
      {
        float32x4_t v24 = *v22++;
        int8x16_t v25 = (int8x16_t)v24;
        float32x4_t v26 = vmulq_f32(v15, v24);
        int8x16_t v27 = (int8x16_t)vaddq_f32(v19, vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))));
        *(float *)v25.i32 = fmaxf(fabsf(*(float *)v27.i32) - v24.f32[3], 0.0);
        *v23++ = vbslq_s8(v20, v25, v27).u32[0];
        --v21;
      }
      while (v21);
    }
    MEMORY[0x1F4188790](v12, v13);
    int v30 = (__int16 *)((char *)v33 - v29);
    uint64_t v31 = 0;
    uint64_t v32 = 2 * a6;
    do
    {
      v30[v31] = v31;
      ++v31;
      v32 -= 2;
    }
    while (v32);
    v33[0] = v28;
    sub_1B6401F20((uint64_t)v33 - v29, (__int16 *)((char *)v33 + 2 * a6 - v29), v33, 126 - 2 * __clz(a6), 1);
    sub_1B63FCF44(a3, v30, a6);
    sub_1B63FCF44(a4, v30, a6);
    sub_1B63FD02C(a2, v30, a6);
    *(void *)&uint64_t result = sub_1B63FD02C(a5, v30, a6).n128_u64[0];
  }
  return result;
}

void *sub_1B63FCF44(void *a1, __int16 *a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  v16[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (unsigned __int16)a3;
  MEMORY[0x1F4188790](a1, a2);
  uint64_t v10 = (char *)v16 - v9;
  if (v8 >= 0x200) {
    unint64_t v8 = 512;
  }
  BOOL v11 = v8 >= 8 * v7;
  size_t v12 = v8 - 8 * v7;
  if (v11) {
    size_t v13 = v12;
  }
  else {
    size_t v13 = 0;
  }
  bzero(&v10[8 * v7], v13);
  uint64_t result = memcpy(v10, v5, 8 * a3);
  if (a3 >= 1)
  {
    do
    {
      uint64_t v15 = *v4++;
      *v5++ = *(void *)&v10[8 * v15];
      --v6;
    }
    while (v6);
  }
  return result;
}

__n128 sub_1B63FD02C(__n128 *a1, __int16 *a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  v10[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (unsigned __int16)a3;
  MEMORY[0x1F4188790](a1, a2);
  int v7 = &v10[-2 * v6];
  memcpy(v7, v5, 16 * a3);
  if (a3 >= 1)
  {
    do
    {
      uint64_t v9 = *v4++;
      __n128 result = *(__n128 *)&v7[2 * v9];
      *v5++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

double sub_1B63FD0E4(uint64_t a1, float32x4_t *a2, void *a3, void *a4, int a5, double result)
{
  v44[1] = *MEMORY[0x1E4F143B8];
  if (a5)
  {
    *(double *)v13.i64 = MEMORY[0x1F4188790](a1, a2);
    uint64_t v16 = (float *)((char *)v44 - v15);
    if (v17 >= 1)
    {
      float32x4_t v18 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v13, (int32x4_t)v13), (int8x16_t)v13, 0xCuLL);
      float32x4_t v19 = vnegq_f32(v13);
      int8x16_t v20 = a2 + 2;
      uint64_t v21 = v12;
      uint64_t v22 = v16;
      do
      {
        float32x4_t v23 = v20[-2];
        float32x4_t v24 = v20[-1];
        float v25 = v20->f32[0];
        v14.i32[0] = v20->i32[1];
        v20 += 3;
        float32x4_t v26 = vmulq_f32(v13, v23);
        float32x4_t v27 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v24, (int32x4_t)v24), (int8x16_t)v24, 0xCuLL);
        int8x16_t v28 = (int8x16_t)vmlaq_f32(vmulq_f32(v27, v19), v24, v18);
        float32x4_t v29 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v28, (int32x4_t)v28), v28, 0xCuLL);
        float32x4_t v30 = vmlaq_f32(vmulq_f32(v27, vnegq_f32(v29)), v24, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v29, (int32x4_t)v29), (int8x16_t)v29, 0xCuLL));
        float32x4_t v31 = vmulq_f32(v30, v30);
        v26.f32[0] = v13.f32[3]
                   + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v26, 2), vaddq_f32(v26, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v26.f32, 1))).f32[0];
        v31.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v31, 2), v31)).u64[0];
        float32x4_t v32 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v31.f32, 0);
        v32.i32[3] = 0;
        float32x4_t v33 = vrsqrteq_f32(v32);
        float32x4_t v34 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v30, (int32x4_t)v30), (int8x16_t)v30, 0xCuLL);
        float32x4_t v35 = vmulq_f32(v33, vrsqrtsq_f32(v32, vmulq_f32(v33, v33)));
        int32x4_t v36 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v31.f32[0] != 0.0)), 0x1FuLL));
        v36.i32[3] = 0;
        float32x4_t v37 = vmulq_f32(v13, vmlsq_lane_f32(vmlaq_n_f32(v23, v24, v25), (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v36), (int8x16_t)vmulq_f32(v34, vmulq_f32(v35, vrsqrtsq_f32(v32, vmulq_f32(v35, v35)))), (int8x16_t)v34), v14, 0));
        v37.f32[0] = v13.f32[3]
                   + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).f32[0];
        v24.f32[0] = v26.f32[0] * v37.f32[0];
        float v38 = fminf(v26.f32[0], v37.f32[0]);
        if (v24.f32[0] < 0.0) {
          float v38 = 0.0;
        }
        *v22++ = v38;
        --v21;
      }
      while (v21);
    }
    MEMORY[0x1F4188790](v10, v11);
    uint64_t v41 = (__int16 *)((char *)v44 - v40);
    uint64_t v42 = 0;
    uint64_t v43 = 2 * a5;
    do
    {
      v41[v42] = v42;
      ++v42;
      v43 -= 2;
    }
    while (v43);
    v44[0] = v39;
    sub_1B6401F20((uint64_t)v44 - v40, (__int16 *)((char *)v44 + 2 * a5 - v40), v44, 126 - 2 * __clz(a5), 1);
    sub_1B63FCF44(a3, v41, a5);
    sub_1B63FCF44(a4, v41, a5);
    *(void *)&__n128 result = sub_1B63FD344(a2, v41, a5).n128_u64[0];
  }
  return result;
}

__n128 sub_1B63FD344(_OWORD *a1, __int16 *a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  v14[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (unsigned __int16)a3;
  MEMORY[0x1F4188790](a1, a2);
  unint64_t v8 = &v14[-2 * v7];
  memcpy(v8, v5, 48 * v9);
  if (a3 >= 1)
  {
    do
    {
      int v11 = *v4++;
      uint64_t v12 = &v8[6 * v11];
      long long v13 = *((_OWORD *)v12 + 1);
      *uint64_t v5 = *(_OWORD *)v12;
      v5[1] = v13;
      __n128 result = *((__n128 *)v12 + 2);
      _OWORD v5[2] = result;
      v5 += 3;
      --v6;
    }
    while (v6);
  }
  return result;
}

double sub_1B63FD41C(_OWORD *a1, void *a2, void *a3, int a4)
{
  v25[1] = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    MEMORY[0x1F4188790](a1, a2);
    uint64_t v12 = (float *)((char *)v25 - v11);
    if (v13 >= 1)
    {
      float32x2_t v14 = (float *)a1 + 18;
      uint64_t v15 = v10;
      uint64_t v16 = v12;
      do
      {
        float v17 = *(v14 - 2) * *(v14 - 1);
        float v18 = *v14;
        v14 += 20;
        *v16++ = (float)(v18 * v17) * 8.0;
        --v15;
      }
      while (v15);
    }
    MEMORY[0x1F4188790](v8, v9);
    uint64_t v21 = (__int16 *)((char *)v25 - v20);
    uint64_t v22 = 0;
    uint64_t v23 = 2 * a4;
    do
    {
      v21[v22] = v22;
      ++v22;
      v23 -= 2;
    }
    while (v23);
    v25[0] = v19;
    sub_1B6402D14((uint64_t)v25 - v20, (__int16 *)((char *)v25 + 2 * a4 - v20), v25, 126 - 2 * __clz(a4), 1);
    sub_1B63FCF44(a2, v21, a4);
    sub_1B63FCF44(a3, v21, a4);
    *(void *)&double result = sub_1B63FD598(a1, v21, a4).n128_u64[0];
  }
  return result;
}

__n128 sub_1B63FD598(_OWORD *a1, __int16 *a2, int a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a1;
  v14[1] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (unsigned __int16)a3;
  MEMORY[0x1F4188790](a1, a2);
  uint64_t v8 = &v14[-2 * v7];
  memcpy(v8, v5, 80 * v9);
  if (a3 >= 1)
  {
    do
    {
      int v11 = *v4++;
      uint64_t v12 = &v8[10 * v11];
      long long v13 = *((_OWORD *)v12 + 3);
      _OWORD v5[2] = *((_OWORD *)v12 + 2);
      v5[3] = v13;
      v5[4] = *((_OWORD *)v12 + 4);
      __n128 result = *((__n128 *)v12 + 1);
      *uint64_t v5 = *(_OWORD *)v12;
      v5[1] = result;
      v5 += 5;
      --v6;
    }
    while (v6);
  }
  return result;
}

void sub_1B63FD674(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1F4188790](a1, a2);
  uint64_t v3 = (simd_float4 *)v2;
  unsigned int v437 = v4;
  uint64_t v6 = (long long *)v5;
  uint64_t v540 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (uint64_t *)v7[1];
  uint64_t v485 = *v7;
  CFDictionaryRef v9 = (const __CFDictionary *)v7[2];
  uint64_t v434 = v7[3];
  uint64_t v10 = (__n128 *)v7[4];
  int v11 = (float32x4_t *)v7[5];
  uint64_t v12 = (_OWORD *)v7[6];
  uint64_t v450 = sub_1B644558C((uint64_t)v8, v5, v4, (uint64_t)v7, v2, v13, v14, v15);
  memset(v539, 0, 512);
  memset(v538, 0, 512);
  uint64_t v529 = 0;
  v530 = &v529;
  uint64_t v531 = 0x2020000000;
  int v532 = 0;
  v528[0] = MEMORY[0x1E4F143A8];
  v528[1] = 3221225472;
  v528[2] = sub_1B63FEBD4;
  v528[3] = &unk_1E6141520;
  v528[4] = &v529;
  v528[5] = v538;
  v528[6] = v539;
  uint64_t v435 = (uint64_t)v8;
  sub_1B63BFF20(v9, v8, (uint64_t)v528, v16, v17, v18, v19, v20);
  uint64_t v21 = *((unsigned int *)v530 + 6);
  v516[0] = MEMORY[0x1E4F143A8];
  v516[1] = 3221225472;
  v516[2] = sub_1B63FEC28;
  v516[3] = &unk_1E6141548;
  long long v22 = v6[3];
  long long v519 = v6[2];
  long long v520 = v22;
  long long v23 = v6[5];
  long long v521 = v6[4];
  long long v522 = v23;
  long long v24 = v6[1];
  long long v517 = *v6;
  long long v518 = v24;
  v523 = &v529;
  v445 = v10;
  v524 = v10;
  int v527 = v21;
  v525 = v538;
  v526 = v539;
  uint64_t v443 = (uint64_t)v9;
  sub_1B63C2724((uint64_t)v9, (uint64_t)v516);
  LODWORD(v25) = v21;
  HIDWORD(v25) = *((_DWORD *)v530 + 6) - v21;
  v3[5].i64[1] = v25;
  sub_1B6446254(v435, 0, v26, v27, v28, v29, v30, v31);
  long long v32 = v6[3];
  v515[2] = v6[2];
  v515[3] = v32;
  long long v33 = v6[5];
  v515[4] = v6[4];
  v515[5] = v33;
  long long v34 = v6[1];
  v515[0] = *v6;
  v515[1] = v34;
  sub_1B63FCD84((uint64_t)v515, v10, (void *)v539 + v21, (void *)v538 + v21, (__n128 *)&v537[16 * v21 + 1024], v3[5].i16[6], *(double *)v515);
  uint64_t v35 = *((unsigned int *)v530 + 6);
  v503[0] = MEMORY[0x1E4F143A8];
  v503[1] = 3221225472;
  v503[2] = sub_1B63FED0C;
  v503[3] = &unk_1E6141570;
  long long v36 = v6[3];
  long long v506 = v6[2];
  long long v507 = v36;
  long long v37 = v6[5];
  long long v508 = v6[4];
  long long v509 = v37;
  long long v38 = v6[1];
  long long v504 = *v6;
  long long v505 = v38;
  v510 = &v529;
  v511 = v11;
  int v514 = v35;
  v512 = v538;
  v513 = v539;
  sub_1B63C2874((uint64_t)v9, (uint64_t)v503);
  unsigned int v39 = *((_DWORD *)v530 + 6) - v35;
  v3[6].i64[0] = __PAIR64__(v39, v35);
  long long v40 = v6[3];
  v502[2] = v6[2];
  v502[3] = v40;
  long long v41 = v6[5];
  v502[4] = v6[4];
  v502[5] = v41;
  long long v42 = v6[1];
  v502[0] = *v6;
  v502[1] = v42;
  sub_1B63FD0E4((uint64_t)v502, v11, (void *)v539 + v35, (void *)v538 + v35, (__int16)v39, *(double *)v502);
  uint64_t v43 = *((unsigned int *)v530 + 6);
  v490[0] = MEMORY[0x1E4F143A8];
  v490[1] = 3221225472;
  v490[2] = sub_1B63FEF54;
  v490[3] = &unk_1E6141598;
  long long v44 = v6[3];
  long long v493 = v6[2];
  long long v494 = v44;
  long long v45 = v6[5];
  long long v495 = v6[4];
  long long v496 = v45;
  long long v46 = v6[1];
  long long v491 = *v6;
  long long v492 = v46;
  v498 = v12;
  v497 = &v529;
  int v501 = v43;
  v499 = v538;
  v500 = v539;
  sub_1B63C4554((uint64_t)v9, (uint64_t)v490);
  unsigned int v47 = *((_DWORD *)v530 + 6) - v43;
  v3[6].i64[1] = __PAIR64__(v47, v43);
  sub_1B63FD41C(v12, (void *)v539 + v43, (void *)v538 + v43, (__int16)v47);
  v439 = (void *)sub_1B6445900(v435, v48, v49, v50, v51, v52, v53, v54);
  v440 = objc_msgSend_resourceManager(v439, v55, v56, v57);
  if (v437)
  {
    uint64_t v58 = (_OWORD *)(v485 + 8208);
    uint64_t v59 = v536;
    uint64_t v60 = v537;
    uint64_t v61 = (float *)v535;
    uint64_t v62 = v437;
    do
    {
      long long v63 = v58[1];
      *(_OWORD *)uint64_t v60 = *v58;
      *((_OWORD *)v60 + 1) = v63;
      long long v64 = v58[3];
      *((_OWORD *)v60 + 2) = v58[2];
      *((_OWORD *)v60 + 3) = v64;
      simd_float4x4 v541 = *(simd_float4x4 *)v60;
      float32x4_t v479 = *(float32x4_t *)v60;
      float32x4_t v483 = (float32x4_t)v541.columns[1];
      float32x4_t v486 = (float32x4_t)v541.columns[2];
      simd_float4x4 v542 = __invert_f4(*(simd_float4x4 *)v60);
      float32x4_t v65 = vmulq_f32(v479, v479);
      float32x4_t v66 = vmulq_f32(v483, v483);
      float32x4_t v67 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v65, 2), vaddq_f32(v65, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v65.f32, 1)));
      float32x4_t v68 = vmulq_f32(v486, v486);
      v67.f32[0] = sqrtf(v67.f32[0]);
      v67.i32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v66, 2), vaddq_f32(v66, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v66.f32, 1))).f32[0]);
      v67.i32[2] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1))).f32[0]);
      float32x4_t v69 = vabsq_f32(v67);
      *v61++ = fmaxf(fmaxf(v69.f32[0], v69.f32[2]), v69.f32[1]);
      *(simd_float4x4 *)(v59 - 32) = v542;
      v59 += 64;
      v60 += 64;
      v58 += 4;
      --v62;
    }
    while (v62);
  }
  unsigned int v70 = *((_DWORD *)v530 + 6);
  if (v70 <= 1) {
    unsigned int v70 = 1;
  }
  v3[8].i32[2] = v70;
  sub_1B649F150(v434, 368 * v437 * (unint64_t)v70, v488);
  v3[7] = v488[0].columns[0];
  v3[8].i64[0] = v488[0].columns[1].i64[0];
  uint64_t v71 = (const CFX::RG::Resource *)sub_1B63C4588((uint64_t)v9);
  unsigned int v78 = v437;
  if (v71) {
    v3[9].i64[0] = (uint64_t)sub_1B6447A14(v435, v71, v72, v73, v74, v75, v76, v77);
  }
  int v79 = v530;
  if (!*((_DWORD *)v530 + 6)) {
    goto LABEL_110;
  }
  unsigned int v80 = 0;
  unint64_t v478 = 0;
  uint64_t v449 = v3[7].i64[0] + 128;
  __asm { FMOV            V0.4S, #1.0 }
  int v444 = DWORD2(_Q0);
  v477 = v3;
  uint64_t v436 = v21;
  uint64_t v487 = v3[7].i64[0];
  do
  {
    if (!v78) {
      goto LABEL_109;
    }
    uint64_t v85 = 0;
    uint64_t v86 = (char *)v3 + 8 * v478;
    int v476 = v478 * v437;
    v441 = (void **)(v86 + 216);
    v442 = (uint64_t *)(v86 + 152);
    unsigned int v438 = v80;
    unsigned int v484 = v80;
    do
    {
      int v87 = (float32x4_t *)*((void *)v538 + v478);
      uint64_t v88 = *((void *)v539 + v478);
      unsigned int v89 = v476 + v85;
      uint64_t v480 = v487 + 368 * (v476 + v85);
      uint64_t v90 = v477[6].i64[1];
      if (v478 < v90 || v478 >= (v90 + HIDWORD(v477[6].i64[1])))
      {
        if (v87)
        {
          int v92 = sub_1B6496680((uint64_t)v87, (uint64_t)v71, v72, v73, v74, v75, v76, v77);
          sub_1B64972C4(v87, v93, v94, v95, v96, v97, v98, v99, v100, v101);
          *(void *)&long long v103 = v102;
          DWORD2(v103) = v104;
          HIDWORD(v103) = *(_DWORD *)(v480 + 12);
          *(_OWORD *)uint64_t v480 = v103;
          *(float *)(v480 + 12) = sub_1B6495588((uint64_t)v87, v104, v105, v106, v107, v108, v109, v110);
          v457 = (const void *)v88;
          uint64_t v118 = sub_1B64A01D4(v88, v111, v112, v113, v114, v115, v116, v117);
          uint64_t v119 = 0;
          simd_float4 v120 = *(simd_float4 *)(v118 + 16);
          simd_float4 v121 = *(simd_float4 *)(v118 + 32);
          simd_float4 v122 = *(simd_float4 *)(v118 + 48);
          uint64_t v123 = (float32x4_t *)&v537[64 * v85];
          float32x4_t v124 = *v123;
          float32x4_t v125 = v123[1];
          float32x4_t v126 = v123[2];
          float32x4_t v127 = v123[3];
          uint64_t v128 = v449 + 368 * v484;
          v534.columns[0] = *(simd_float4 *)v118;
          v534.columns[1] = v120;
          v534.columns[2] = v121;
          v534.columns[3] = v122;
          do
          {
            v488[0].columns[v119] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v124, COERCE_FLOAT(*(_OWORD *)&v534.columns[v119])), v125, *(float32x2_t *)v534.columns[v119].f32, 1), v126, (float32x4_t)v534.columns[v119], 2), v127, (float32x4_t)v534.columns[v119], 3);
            ++v119;
          }
          while (v119 != 4);
          simd_float4x4 v462 = v488[0];
          uint64_t v129 = v487 + 368 * v89;
          int32x4_t v130 = (int32x4_t)vmulq_f32((float32x4_t)v488[0].columns[2], (float32x4_t)v488[0].columns[2]);
          v130.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v130, 2), vadd_f32(*(float32x2_t *)v130.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v130.i8, 1))).u32[0];
          float32x2_t v131 = vrsqrte_f32((float32x2_t)v130.u32[0]);
          float32x2_t v132 = vmul_f32(v131, vrsqrts_f32((float32x2_t)v130.u32[0], vmul_f32(v131, v131)));
          float32x4_t v133 = vmulq_n_f32((float32x4_t)v488[0].columns[2], vmul_f32(v132, vrsqrts_f32((float32x2_t)v130.u32[0], vmul_f32(v132, v132))).f32[0]);
          *(simd_float4 *)(v129 + 16) = v488[0].columns[3];
          *(float32x4_t *)(v129 + 32) = v133;
          v134.f32[0] = sub_1B649597C((uint64_t)v87, 1, *(float *)&v535[v85]);
          uint64_t v135 = (simd_float4 *)(v487 + 368 * v89);
          v135[4] = v134;
          uint64_t v136 = v135 + 4;
          *(unsigned char *)(v487 + 368 * v89 + 352) = sub_1B6495D3C((uint64_t)v87, v137, v138, v139, v140, v141, v142, v143);
          if (v92 == 5)
          {
            switch(v87[20].i8[0])
            {
              case 0:
                v136->i32[0] = v87[21].i32[0];
                break;
              case 1:
              case 2:
                if (v87[19].i8[0]) {
                  float v243 = 1.0;
                }
                else {
                  float v243 = 0.0;
                }
                v136->f32[2] = v243;
                v136->i64[0] = v87[21].i64[0];
                break;
              case 3:
                *uint64_t v136 = (simd_float4)v87[21];
                break;
              case 4:
                if (v87[19].i8[0]) {
                  float v244 = 1.0;
                }
                else {
                  float v244 = 0.0;
                }
                v136->f32[1] = v244;
                v136->i32[0] = v87[22].u8[0];
                break;
              default:
                break;
            }
            *(simd_float4x4 *)(v487 + 368 * v89 + 192) = v462;
          }
          else if (v92 == 3)
          {
            sub_1B64959FC((uint64_t)v87);
            v136[1].i64[0] = v151;
          }
          *(unsigned char *)(v487 + 368 * v89 + 52) = v92;
          char v245 = sub_1B64953A8((uint64_t)v87, v144, v145, v146, v147, v148, v149, v150);
          uint64_t v246 = v487 + 368 * v89;
          *(unsigned char *)(v246 + 53) = v245;
          v455 = (unsigned __int8 *)(v246 + 53);
          if (v478 <= 7)
          {
            if (sub_1B649535C((uint64_t)v87, (uint64_t)v71, v72, v73, v74, v75, v76, v77)) {
              int v452 = sub_1B649530C((uint64_t)v87);
            }
            else {
              int v452 = 0;
            }
            int v446 = sub_1B64952FC((uint64_t)v87, v247, v248, v249, v250, v251, v252, v253);
            BOOL v447 = sub_1B6497178((uint64_t)v87);
            if (v452)
            {
              uint64_t v254 = sub_1B63C4590(v443, v457);
              if (v254)
              {
                uint64_t v459 = sub_1B63C45D4(v443, v254, v255, v256, v257, v258, v259, v260);
                uint64_t v268 = (const void *)sub_1B6498928((uint64_t)v87, v261, v262, v263, v264, v265, v266, v267);
                unsigned int v276 = sub_1B6498974((uint64_t)v87, v269, v270, v271, v272, v273, v274, v275);
                uint64_t v277 = memcpy((void *)(v487 + 368 * v89 + 256), v268, 16 * v276);
                __n128 v285 = *(__n128 *)(v459 + 64);
                __n128 v286 = *(__n128 *)(v459 + 80);
                __n128 v287 = *(__n128 *)(v459 + 96);
                __n128 v288 = *(__n128 *)(v459 + 112);
                if (v92 == 1)
                {
                  uint64_t v289 = 0;
                  uint64_t v290 = (simd_float4 *)&v535[16 * v85 + 16];
                  simd_float4 v291 = v290[1];
                  simd_float4 v292 = v290[2];
                  simd_float4 v293 = v290[3];
                  v534.columns[0] = *v290;
                  v534.columns[1] = v291;
                  v534.columns[2] = v292;
                  v534.columns[3] = v293;
                  do
                  {
                    v488[0].columns[v289] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v285, COERCE_FLOAT(*(_OWORD *)&v534.columns[v289])), (float32x4_t)v286, *(float32x2_t *)v534.columns[v289].f32, 1), (float32x4_t)v287, (float32x4_t)v534.columns[v289], 2), (float32x4_t)v288, (float32x4_t)v534.columns[v289], 3);
                    ++v289;
                  }
                  while (v289 != 4);
                  simd_float4 v294 = v488[0].columns[1];
                  simd_float4 v295 = v488[0].columns[2];
                  simd_float4 v296 = v488[0].columns[3];
                  CFArrayRef v297 = (simd_float4 *)(v487 + 368 * v89);
                  v297[12] = v488[0].columns[0];
                  v297[13] = v294;
                  v297[14] = v295;
                  v297[15] = v296;
                  *(double *)v298.i64 = sub_1B63C2A34();
                  uint64_t v302 = 0;
                  simd_float4 v303 = *(simd_float4 *)(v459 + 144);
                  simd_float4 v304 = *(simd_float4 *)(v459 + 160);
                  simd_float4 v305 = *(simd_float4 *)(v459 + 176);
                  v534.columns[0] = *(simd_float4 *)(v459 + 128);
                  v534.columns[1] = v303;
                  v534.columns[2] = v304;
                  v534.columns[3] = v305;
                  do
                  {
                    v488[0].columns[v302] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v298, COERCE_FLOAT(*(_OWORD *)&v534.columns[v302])), v299, *(float32x2_t *)v534.columns[v302].f32, 1), v300, (float32x4_t)v534.columns[v302], 2), v301, (float32x4_t)v534.columns[v302], 3);
                    ++v302;
                  }
                  while (v302 != 4);
                  simd_float4 v306 = v488[0].columns[1];
                  simd_float4 v307 = v488[0].columns[2];
                  simd_float4 v308 = v488[0].columns[3];
                  v136[1] = v488[0].columns[0];
                  v136[2] = v306;
                  v136[3] = v307;
                  v136[4] = v308;
                  v136[5].i32[0] = *(_DWORD *)(v459 + 200);
                }
                else
                {
                  *(double *)&long long v309 = sub_1B63C2A48(v285, v286, v287, v288, *(__n128 *)(v459 + 128), *(__n128 *)(v459 + 144), *(__n128 *)(v459 + 160), *(__n128 *)(v459 + 176), (uint64_t)v277, v278, v279, v280, v281, v282, v283, v284, *(__n128 *)&v535[16 * v85 + 16], *(__n128 *)&v535[16 * v85 + 20], *(__n128 *)&v535[16 * v85 + 24],
                                       *(__n128 *)&v536[64 * v85 + 16]);
                  uint64_t v310 = (_OWORD *)(v487 + 368 * v89);
                  v310[12] = v309;
                  v310[13] = v311;
                  v310[14] = v312;
                  v310[15] = v313;
                  if (v92 == 2)
                  {
                    unsigned int v314 = sub_1B64954A8((uint64_t)v87, (uint64_t)v254, v255, v256, v257, v258, v259, v260);
                    if (v314)
                    {
                      uint64_t v315 = v314;
                      uint64_t v316 = (long long *)(v459 + 208);
                      do
                      {
                        long long v317 = *(v316 - 1);
                        HIDWORD(v317) = *(_DWORD *)(v128 - 52);
                        *(_OWORD *)(v128 - 64) = v317;
                        long long v318 = *v316;
                        HIDWORD(v31_Block_object_dispose(&STACK[0x4F8], 8) = *(_DWORD *)(v128 + 12);
                        *(_OWORD *)uint64_t v128 = v318;
                        v128 += 16;
                        v316 += 24;
                        --v315;
                      }
                      while (v315);
                    }
                  }
                }
              }
              if (*v455 >= 2u)
              {
                double v460 = sub_1B649609C((uint64_t)v87, (uint64_t)v254, v255, v256, v257, v258, v259, v260);
                float v326 = sub_1B6495408((uint64_t)v87, v319, v320, v321, v322, v323, v324, v325);
                float v327 = *((float *)&v460 + 1);
                if (*(float *)&v460 >= *((float *)&v460 + 1)) {
                  float v327 = *(float *)&v460;
                }
                *(float *)(v487 + 368 * v89 + 4_Block_object_dispose(&STACK[0x4F8], 8) = v326 / fmaxf(v327, 1.0);
              }
              float v328 = sub_1B649885C((uint64_t)v87, (uint64_t)v254, v255, v256, v257, v258, v259, v260);
              if (v328 != 0.0) {
                *(float *)(v480 + 12) = v328;
              }
            }
            if (v447)
            {
              *(float *)v329.i32 = (float)(180.0
                                         / sub_1B6495748((uint64_t)v87, (uint64_t)v71, v72, v73, v74, v75, v76, v77))
                                 * 0.5;
              *(int32x2_t *)v136[1].f32 = vdup_lane_s32(v329, 0);
              simd_float4x4 v544 = __invert_f4(v462);
              v544.columns[3] = (simd_float4)vmulq_f32((float32x4_t)v544.columns[0], (float32x4_t)v544.columns[0]);
              int32x4_t v337 = (int32x4_t)vmulq_f32((float32x4_t)v544.columns[1], (float32x4_t)v544.columns[1]);
              int32x4_t v338 = (int32x4_t)vmulq_f32((float32x4_t)v544.columns[2], (float32x4_t)v544.columns[2]);
              int32x4_t v339 = vzip2q_s32((int32x4_t)v544.columns[3], v338);
              float32x4_t v340 = (float32x4_t)vzip1q_s32(vzip1q_s32((int32x4_t)v544.columns[3], v338), v337);
              v544.columns[3] = (simd_float4)vtrn2q_s32((int32x4_t)v544.columns[3], v337);
              v544.columns[3].i32[2] = v338.i32[1];
              float32x4_t v341 = vaddq_f32((float32x4_t)vzip1q_s32(v339, vdupq_laneq_s32(v337, 2)), vaddq_f32(v340, (float32x4_t)v544.columns[3]));
              v544.columns[3].i64[0] = 0x80000000800000;
              v544.columns[3].i64[1] = 0x80000000800000;
              int32x4_t v342 = vcgeq_f32((float32x4_t)v544.columns[3], v341);
              v341.i32[3] = 0;
              float32x4_t v343 = vrsqrteq_f32(v341);
              float32x4_t v344 = vmulq_f32(v343, vrsqrtsq_f32(v341, vmulq_f32(v343, v343)));
              int32x4_t v345 = v342;
              v345.i32[3] = 0;
              float32x4_t v346 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v345), (int8x16_t)v341, (int8x16_t)vmulq_f32(v344, vrsqrtsq_f32(v341, vmulq_f32(v344, v344))));
              float32x4_t v347 = vmulq_n_f32((float32x4_t)v544.columns[0], v346.f32[0]);
              float32x4_t v348 = vmulq_lane_f32((float32x4_t)v544.columns[1], *(float32x2_t *)v346.f32, 1);
              float32x4_t v349 = vmulq_laneq_f32((float32x4_t)v544.columns[2], v346, 2);
              int8x16_t v350 = (int8x16_t)vuzp1q_s32((int32x4_t)v349, (int32x4_t)v349);
              int8x16_t v351 = (int8x16_t)vuzp1q_s32((int32x4_t)v348, (int32x4_t)v348);
              int32x4_t v352 = (int32x4_t)v347;
              if (v342.i32[0])
              {
                int8x16_t v353 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v350, (int8x16_t)v349, 0xCuLL), vnegq_f32(v348)), v349, (float32x4_t)vextq_s8(v351, (int8x16_t)v348, 0xCuLL));
                int32x4_t v352 = (int32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v353, (int32x4_t)v353), v353, 0xCuLL);
              }
              int8x16_t v354 = (int8x16_t)vuzp1q_s32((int32x4_t)v347, (int32x4_t)v347);
              float32x4_t v355 = v348;
              if (v342.i32[1])
              {
                int8x16_t v356 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v354, (int8x16_t)v347, 0xCuLL), vnegq_f32(v349)), v347, (float32x4_t)vextq_s8(v350, (int8x16_t)v349, 0xCuLL));
                float32x4_t v355 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v356, (int32x4_t)v356), v356, 0xCuLL);
              }
              if (v342.i32[2])
              {
                int8x16_t v357 = (int8x16_t)vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(v351, (int8x16_t)v348, 0xCuLL), vnegq_f32(v347)), v348, (float32x4_t)vextq_s8(v354, (int8x16_t)v347, 0xCuLL));
                float32x4_t v349 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v357, (int32x4_t)v357), v357, 0xCuLL);
              }
              float v358 = (float)(*(float *)v352.i32 + v355.f32[1]) + v349.f32[2];
              if (v358 > 0.0)
              {
                float v359 = sqrtf(v358 + 1.0);
                float32x4_t v360 = (float32x4_t)vzip2q_s32((int32x4_t)v355, vuzp1q_s32((int32x4_t)v355, (int32x4_t)v349));
                v360.i32[2] = v352.i32[1];
                float32x4_t v361 = (float32x4_t)vtrn2q_s32((int32x4_t)v349, vzip2q_s32((int32x4_t)v349, v352));
                v361.i32[2] = v355.i32[0];
                float32x4_t v363 = vsubq_f32(v360, v361);
                v360.f32[3] = v359;
                v361.f32[3] = v359;
                float32x4_t v362 = vmulq_f32(v360, v361);
                v363.i32[3] = v362.i32[3];
                goto LABEL_84;
              }
              if (*(float *)v352.i32 >= v355.f32[1] && *(float *)v352.i32 >= v349.f32[2])
              {
                float v403 = sqrtf((float)((float)(*(float *)v352.i32 + 1.0) - v355.f32[1]) - v349.f32[2]);
                float32x2_t v404 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v355.f32, 0);
                float32x2_t v405 = vadd_f32(*(float32x2_t *)v352.i8, v404);
                v404.f32[0] = v403;
                v364.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v352.u32[1], LODWORD(v403)), v404).u32[0];
                v364.i32[1] = v405.i32[1];
                float32x2_t v406 = (float32x2_t)vzip2q_s32(v352, (int32x4_t)v355).u64[0];
                LODWORD(v407) = vadd_f32(v406, *(float32x2_t *)v349.f32).u32[0];
                int32x2_t v408 = (int32x2_t)vsub_f32(v406, *(float32x2_t *)v349.f32);
                HIDWORD(v407) = v408.i32[1];
                v364.i64[1] = v407;
                *(float *)v408.i32 = 0.5 / v403;
                goto LABEL_100;
              }
              if (v355.f32[1] <= v349.f32[2])
              {
                float v359 = sqrtf((float)((float)(v349.f32[2] + 1.0) - *(float *)v352.i32) - v355.f32[1]);
                float32x2_t v411 = (float32x2_t)vzip2q_s32(v352, (int32x4_t)v355).u64[0];
                float32x2_t v412 = (float32x2_t)__PAIR64__(v352.u32[1], LODWORD(v359));
                float32x2_t v413 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v355.f32, 0);
                *(float32x2_t *)v362.f32 = vsub_f32(*(float32x2_t *)v352.i8, v413);
                v413.f32[0] = v359;
                v413.i32[0] = vmul_f32(v412, v413).u32[0];
                v413.i32[1] = v362.i32[1];
                *(float32x2_t *)v363.f32 = vadd_f32(v411, *(float32x2_t *)v349.f32);
                *(float32x2_t *)&v363.u32[2] = v413;
LABEL_84:
                v362.f32[0] = 0.5 / v359;
                float32x4_t v364 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v362.f32, 0);
              }
              else
              {
                float v400 = sqrtf((float)((float)(v355.f32[1] + 1.0) - *(float *)v352.i32) - v349.f32[2]);
                int8x16_t v401 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v352.i8, 1), v355);
                *(int32x2_t *)v355.f32 = vdup_laneq_s32((int32x4_t)v355, 2);
                float32x2_t v402 = vadd_f32(*(float32x2_t *)v355.f32, *(float32x2_t *)v349.f32);
                v355.f32[0] = v400;
                v355.i32[0] = vmul_f32(*(float32x2_t *)v355.f32, (float32x2_t)__PAIR64__(v349.u32[1], LODWORD(v400))).u32[0];
                v355.i32[1] = v402.i32[1];
                int32x2_t v408 = (int32x2_t)vsubq_f32(v349, (float32x4_t)vdupq_laneq_s32(v352, 2)).u64[0];
                float32x4_t v364 = (float32x4_t)vextq_s8(vextq_s8(v401, v401, 4uLL), (int8x16_t)v355, 0xCuLL);
                v364.i32[3] = v408.i32[0];
                *(float *)v408.i32 = 0.5 / v400;
LABEL_100:
                float32x4_t v363 = (float32x4_t)vdupq_lane_s32(v408, 0);
              }
              v136[2] = (simd_float4)vmulq_f32(v363, v364);
              uint64_t v409 = sub_1B64956D4((uint64_t)v87, v330, v331, v332, v333, v334, v335, v336);
              uint64_t *v442 = objc_msgSend_iesTextureForProfile_renderContext_(v440, v410, v409, (uint64_t)v439);
              *v441 = 0;
              goto LABEL_102;
            }
            if (v446 && (v452 & 1) == 0)
            {
              uint64_t v489 = 0;
              uint64_t *v442 = sub_1B6447AAC(v435, v87[17].i64[0], &v489, v73, v74, v75, v76, v77);
              *v441 = sub_1B653E820((uint64_t)v440, v489);
              sub_1B64957BC((uint64_t)v87, (uint64_t)v488, v365, v366, v367, v368, v369, v370);
              uint64_t v377 = sub_1B649CD50((unsigned __int8 *)v488, 0, v371, v372, v373, v374, v375, v376);
              float32x4_t v456 = *(float32x4_t *)v377;
              float32x4_t v461 = *((float32x4_t *)v377 + 1);
              float32x4_t v453 = *((float32x4_t *)v377 + 2);
              float32x4_t v448 = *((float32x4_t *)v377 + 3);
              simd_float4x4 v545 = __invert_f4(v462);
              uint64_t v378 = 0;
              simd_float4x4 v533 = v545;
              do
              {
                v534.columns[v378] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v456, COERCE_FLOAT(*(_OWORD *)&v533.columns[v378])), v461, *(float32x2_t *)v533.columns[v378].f32, 1), v453, (float32x4_t)v533.columns[v378], 2), v448, (float32x4_t)v533.columns[v378], 3);
                ++v378;
              }
              while (v378 != 4);
              simd_float4 v468 = v534.columns[1];
              simd_float4 v470 = v534.columns[0];
              simd_float4 v464 = v534.columns[3];
              simd_float4 v466 = v534.columns[2];
              if (sub_1B6477268(v87[17].i64[0]))
              {
                v386 = (float32x4_t *)sub_1B647721C(v87[17].i64[0], v379, v380, v381, v382, v383, v384, v385);
                uint64_t v387 = 0;
                float32x4_t v388 = *v386;
                float32x4_t v389 = v386[1];
                float32x4_t v390 = v386[2];
                float32x4_t v391 = v386[3];
                v533.columns[0] = v470;
                v533.columns[1] = v468;
                v533.columns[2] = v466;
                v533.columns[3] = v464;
                v392 = (float32x4_t *)&unk_1B6E4F000;
                v393 = (float32x4_t *)&unk_1B6E4F000;
                v394 = (float32x4_t *)&unk_1B6E4F000;
                do
                {
                  v534.columns[v387] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v388, COERCE_FLOAT(*(_OWORD *)&v533.columns[v387])), v389, *(float32x2_t *)v533.columns[v387].f32, 1), v390, (float32x4_t)v533.columns[v387], 2), v391, (float32x4_t)v533.columns[v387], 3);
                  ++v387;
                }
                while (v387 != 4);
                simd_float4 v395 = v534.columns[0];
                simd_float4 v396 = v534.columns[1];
                simd_float4 v397 = v534.columns[2];
                simd_float4 v398 = v534.columns[3];
              }
              else
              {
                v392 = (float32x4_t *)&unk_1B6E4F000;
                v393 = (float32x4_t *)&unk_1B6E4F000;
                v394 = (float32x4_t *)&unk_1B6E4F000;
                simd_float4 v396 = v468;
                simd_float4 v395 = v470;
                simd_float4 v398 = v464;
                simd_float4 v397 = v466;
              }
              uint64_t v414 = 0;
              v533.columns[0] = v395;
              v533.columns[1] = v396;
              v533.columns[2] = v397;
              v533.columns[3] = v398;
              do
              {
                v534.columns[v414] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v392[44], COERCE_FLOAT(*(_OWORD *)&v533.columns[v414])), v393[45], *(float32x2_t *)v533.columns[v414].f32, 1), v394[46], (float32x4_t)v533.columns[v414], 2), (float32x4_t)xmmword_1B6E4F2F0, (float32x4_t)v533.columns[v414], 3);
                ++v414;
              }
              while (v414 != 4);
              simd_float4 v415 = v534.columns[1];
              simd_float4 v416 = v534.columns[2];
              simd_float4 v417 = v534.columns[3];
              v418 = (simd_float4 *)(v487 + 368 * v89);
              v418[12] = v534.columns[0];
              v418[13] = v415;
              v418[14] = v416;
              v418[15] = v417;
              *(float *)(v480 + 12) = sub_1B64763AC(v87[17].i64[0], v379, v380, v381, v382, v383, v384, v385);
            }
          }
        }
        else
        {
          *(_OWORD *)uint64_t v480 = *(_OWORD *)&v537[16 * v478 + 1024];
          float32x4_t v168 = (float32x4_t)v445[(v478 - v21)];
          uint64_t v167 = v487 + 368 * v89;
          *(float32x4_t *)(v167 + 16) = vaddq_f32(*(float32x4_t *)&v537[64 * v85 + 48], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)&v537[64 * v85], v168.f32[0]), *(float32x4_t *)&v537[64 * v85 + 16], *(float32x2_t *)v168.f32, 1), *(float32x4_t *)&v537[64 * v85 + 32], v168, 2));
          v168.i32[0] = v168.i32[3];
          if (v168.f32[3] <= 0.01) {
            v168.f32[0] = INFINITY;
          }
          DWORD2(v169) = v444;
          *(float *)&long long v169 = -1.0 / v168.f32[3];
          *((float *)&v169 + 1) = (float)((float)(-1.0 / v168.f32[3]) * -0.0) + 1.0;
          *((float *)&v169 + 3) = 1.0 / (float)(v168.f32[0] * v168.f32[0]);
          *(_OWORD *)(v167 + 64) = v169;
        }
      }
      else
      {
        *(unsigned char *)(v487 + 368 * v89 + 52) = 4;
        if (v87)
        {
          if (sub_1B6496680((uint64_t)v87, (uint64_t)v71, v72, v73, v74, v75, v76, v77) != 4) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Wrong light type", v152, v153, v154, v155, v156, v157, (uint64_t)"CFXLightGetType(light) == kCFXLightTypeProbe");
          }
          uint64_t v158 = sub_1B6494F20((uint64_t)v87, 0, v152, v153, v154, v155, v156, v157);
          if (v158) {
            float v166 = sub_1B64763AC(v158, v159, v160, v161, v162, v163, v164, v165);
          }
          else {
            float v166 = 1.0;
          }
          *(float *)uint64_t v480 = v166 * sub_1B6495EC0((uint64_t)v87, v159, v160, v161, v162, v163, v164, v165);
          unsigned __int32 v177 = sub_1B6497C2C((uint64_t)v87, v170, v171, v172, v173, v174, v175, v176);
          long long v185 = (__n128 *)(v487 + 368 * v89);
          v185[8].n128_u32[0] = v177;
          if ((v177 & 0x80000000) != 0) {
            sub_1B63F2F54(17, @"Assertion '%s' failed. Slice index should have been attributed already", v179, v180, v181, v182, v183, v184, (uint64_t)"outData->parameters.probe.index >= 0");
          }
          v185[4] = sub_1B6497B74((__n128 *)v87, v178, v179, v180, v181, v182, v183, v184);
          long long v186 = v185 + 4;
          __n128 v194 = sub_1B6497AB4((__n128 *)v87, v187, v188, v189, v190, v191, v192, v193);
          v195.i64[0] = 0x3F0000003F000000;
          v195.i64[1] = 0x3F0000003F000000;
          float32x4_t v481 = vmulq_f32((float32x4_t)v194, v195);
          float32x4_t v196 = v481;
          v196.f32[3] = fmaxf(fmaxf(v481.f32[0], v481.f32[2]), v481.f32[1]) * 0.1;
          v186[1] = (__n128)v196;
          v186[4].n128_u32[1] = sub_1B6497860((uint64_t)v87, v197, v198, v199, v200, v201, v202, v203);
          float32x4_t v211 = vmulq_f32(v481, (float32x4_t)sub_1B6497928((__n128 *)v87, v204, v205, v206, v207, v208, v209, v210));
          v186[2].n128_u32[2] = v211.u32[2];
          v186[2].n128_u64[0] = v211.i64[0];
          float32x4_t v219 = vmulq_f32(v481, (float32x4_t)sub_1B64979E4((__n128 *)v87, v212, v213, v214, v215, v216, v217, v218));
          v186[3].n128_u32[2] = v219.u32[2];
          v186[3].n128_u64[0] = v219.i64[0];
          BOOL v227 = (simd_float4 *)sub_1B64A01D4(v88, v220, v221, v222, v223, v224, v225, v226);
          simd_float4 v469 = v227[1];
          simd_float4 v472 = *v227;
          simd_float4 v465 = v227[3];
          simd_float4 v467 = v227[2];
          *(simd_float4 *)(v487 + 368 * v89 + 16) = v465;
          uint64_t v228 = (float32x4_t *)&v537[64 * v85];
          float32x4_t v482 = *v228;
          float32x4_t v474 = v228[2];
          float32x4_t v475 = v228[1];
          float32x4_t v473 = v228[3];
          *(double *)v236.i64 = sub_1B64B33CC(v450, v229, v230, v231, v232, v233, v234, v235);
          float32x4_t v451 = v238;
          float32x4_t v454 = v237;
          float32x4_t v458 = v239;
          float32x4_t v463 = v236;
          uint64_t v240 = 0;
          v534.columns[0] = v472;
          v534.columns[1] = v469;
          v534.columns[2] = v467;
          v534.columns[3] = v465;
          do
          {
            v488[0].columns[v240] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v482, COERCE_FLOAT(*(_OWORD *)&v534.columns[v240])), v475, *(float32x2_t *)v534.columns[v240].f32, 1), v474, (float32x4_t)v534.columns[v240], 2), v473, (float32x4_t)v534.columns[v240], 3);
            ++v240;
          }
          while (v240 != 4);
          simd_float4x4 v543 = __invert_f4(v488[0]);
          uint64_t v241 = 0;
          simd_float4x4 v534 = v543;
          do
          {
            v488[0].columns[v241] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v463, COERCE_FLOAT(*(_OWORD *)&v534.columns[v241])), v458, *(float32x2_t *)v534.columns[v241].f32, 1), v454, (float32x4_t)v534.columns[v241], 2), v451, (float32x4_t)v534.columns[v241], 3);
            ++v241;
          }
          while (v241 != 4);
          simd_float4x4 v471 = v488[0];
        }
        uint64_t v242 = (_OWORD *)(v487 + 368 * v89);
        v242[12] = v471.columns[0];
        v242[13] = v471.columns[1];
        v242[14] = v471.columns[2];
        v242[15] = v471.columns[3];
      }
LABEL_102:
      ++v85;
      ++v484;
    }
    while (v85 != v437);
    int v79 = v530;
    uint64_t v3 = v477;
    uint64_t v21 = v436;
    unsigned int v78 = v437;
    unsigned int v80 = v438;
LABEL_109:
    v80 += v78;
    ++v478;
  }
  while (v478 < *((unsigned int *)v79 + 6));
  if (!v21) {
    goto LABEL_123;
  }
LABEL_110:
  uint64_t v419 = 0;
  v420 = (uint64_t *)v538;
  uint64_t v421 = v21;
  do
  {
    uint64_t v422 = *v420;
    if (sub_1B6496680(*v420, (uint64_t)v71, v72, v73, v74, v75, v76, v77) == 5
      && *(unsigned char *)(v422 + 320) == 4)
    {
      v419 += 8 * *(unsigned __int8 *)(v422 + 352);
    }
    ++v420;
    --v421;
  }
  while (v421);
  if (v419)
  {
    memset(v488, 0, 24);
    sub_1B649F150(v434, v419, v488);
    v430 = &v3[18].i64[1];
    v431 = (uint64_t *)v538;
    do
    {
      uint64_t v432 = *v431;
      if (sub_1B6496680(*v431, v423, v424, v425, v426, v427, v428, v429) == 5
        && *(unsigned char *)(v432 + 320) == 4)
      {
        memcpy((void *)(v488[0].columns[0].i64[0] + *v430), *(const void **)(v432 + 360), 8 * *(unsigned __int8 *)(v432 + 352));
      }
      ++v431;
      ++v430;
      --v21;
    }
    while (v21);
    uint64_t v433 = v488[0].columns[1].i64[0];
    v3[17].i64[1] = v488[0].columns[0].i64[1];
    v3[18].i64[0] = v433;
  }
  else
  {
LABEL_123:
    v3[17].i64[1] = 0;
  }
  _Block_object_dispose(&v529, 8);
}

void sub_1B63FEB04(_Unwind_Exception *a1)
{
}

void *sub_1B63FEBD4(void *result, unsigned int a2, uint64_t *a3, uint64_t *a4)
{
  if (a2)
  {
    uint64_t v4 = a2;
    do
    {
      uint64_t v5 = *(unsigned int *)(*(void *)(result[4] + 8) + 24);
      if (v5 > 0xFF) {
        break;
      }
      uint64_t v6 = *a4++;
      *(void *)(result[5] + 8 * v5) = v6;
      uint64_t v7 = *a3++;
      uint64_t v8 = result[6];
      uint64_t v9 = *(void *)(result[4] + 8);
      uint64_t v10 = *(unsigned int *)(v9 + 24);
      *(_DWORD *)(v9 + 24) = v10 + 1;
      *(void *)(v8 + 8 * v10) = v7;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t sub_1B63FEC28(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      uint64_t v6 = 0;
      float32x4_t v7 = *(float32x4_t *)(a5 + 16 * i);
      long long v8 = *(_OWORD *)(result + 80);
      _OWORD v18[2] = *(_OWORD *)(result + 64);
      void v18[3] = v8;
      long long v9 = *(_OWORD *)(result + 112);
      void v18[4] = *(_OWORD *)(result + 96);
      v18[5] = v9;
      long long v10 = *(_OWORD *)(result + 48);
      v18[0] = *(_OWORD *)(result + 32);
      v18[1] = v10;
      while (1)
      {
        float32x4_t v11 = (float32x4_t)v18[v6];
        float32x4_t v12 = vmulq_f32(v7, v11);
        if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 3), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1)))).f32[0] < (float)-v7.f32[3])break; {
        if (++v6 == 6)
        }
        {
          unsigned int v13 = *(_DWORD *)(*(void *)(*(void *)(result + 128) + 8) + 24);
          if (v13 > 0xFF) {
            return result;
          }
          *(float32x4_t *)(*(void *)(result + 136) + 16 * (v13 - *(_DWORD *)(result + 160))) = v7;
          *(void *)(*(void *)(result + 144)
                    + 8 * *(unsigned int *)(*(void *)(*(void *)(result + 128) + 8) + 24)) = *(void *)(a4 + 8 * i);
          uint64_t v14 = *(void *)(a3 + 8 * i);
          uint64_t v15 = *(void *)(result + 152);
          uint64_t v16 = *(void *)(*(void *)(result + 128) + 8);
          uint64_t v17 = *(unsigned int *)(v16 + 24);
          *(_DWORD *)(v16 + 24) = v17 + 1;
          *(void *)(v15 + 8 * v17) = v14;
          break;
        }
      }
    }
  }
  return result;
}

void sub_1B63FED0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v12 = 0;
    unsigned int v13 = (_OWORD *)(a1 + 32);
    uint64_t v14 = a2;
    do
    {
      if ((sub_1B649535C(*(void *)(a4 + 8 * v12), a2, a3, a4, a5, a6, a7, a8) & 1) == 0
        && (sub_1B64952FC(*(void *)(a4 + 8 * v12), a2, a3, a4, a5, a6, a7, a8) & 1) == 0
        && sub_1B6495B40(*(void *)(a4 + 8 * v12), a2, a3, a4, a5, a6, a7, a8) > 0.0)
      {
        uint64_t v15 = 0;
        uint64_t v16 = a5 + 48 * v12;
        float32x4_t v17 = *(float32x4_t *)v16;
        float32x4_t v18 = *(float32x4_t *)(v16 + 16);
        int32x2_t v19 = *(int32x2_t *)(v16 + 32);
        uint64_t v20 = *(void *)(v16 + 40);
        long long v21 = v13[3];
        v48[2] = v13[2];
        v48[3] = v21;
        long long v22 = v13[5];
        v48[4] = v13[4];
        v48[5] = v22;
        long long v23 = v13[1];
        v48[0] = *v13;
        v48[1] = v23;
        float32x4_t v24 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v18, (int32x4_t)v18), (int8x16_t)v18, 0xCuLL);
        float32x4_t v25 = vmlaq_n_f32(v17, v18, *(float *)v19.i32);
        float32x4_t v26 = (float32x4_t)vdupq_lane_s32(v19, 1);
        while (1)
        {
          float32x4_t v27 = (float32x4_t)v48[v15];
          float32x4_t v28 = vmulq_f32(v17, v27);
          float v29 = v27.f32[3];
          float v30 = v27.f32[3]
              + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v28, 2), vaddq_f32(v28, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v28.f32, 1))).f32[0];
          int8x16_t v31 = (int8x16_t)vmlaq_f32(vmulq_f32(v24, vnegq_f32(v27)), v18, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v27, (int32x4_t)v27), (int8x16_t)v27, 0xCuLL));
          float32x4_t v32 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v31, (int32x4_t)v31), v31, 0xCuLL);
          float32x4_t v33 = vmlaq_f32(vmulq_f32(v24, vnegq_f32(v32)), v18, (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v32, (int32x4_t)v32), (int8x16_t)v32, 0xCuLL));
          float32x4_t v34 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v33, (int32x4_t)v33), (int8x16_t)v33, 0xCuLL);
          float32x4_t v35 = vmulq_f32(v33, v33);
          v35.i64[0] = vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 1), vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v35, 2), v35)).u64[0];
          float32x4_t v36 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v35.f32, 0);
          v36.i32[3] = 0;
          float32x4_t v37 = vrsqrteq_f32(v36);
          float32x4_t v38 = vmulq_f32(v37, vrsqrtsq_f32(v36, vmulq_f32(v37, v37)));
          int32x4_t v39 = vcltzq_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)vdup_n_s16(v35.f32[0] != 0.0)), 0x1FuLL));
          v39.i32[3] = 0;
          float32x4_t v40 = vmulq_f32(v27, vmlsq_f32(v25, v26, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v39), (int8x16_t)vmulq_f32(vmulq_f32(v38, vrsqrtsq_f32(v36, vmulq_f32(v38, v38))), v34), (int8x16_t)v34)));
          float v41 = v29
              + vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v40, 2), vaddq_f32(v40, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v40.f32, 1))).f32[0];
          if ((float)(v30 * v41) >= 0.0 && fminf(v30, v41) < 0.0) {
            break;
          }
          if (++v15 == 6)
          {
            unsigned int v42 = *(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 8) + 24);
            if (v42 > 0xFF) {
              return;
            }
            uint64_t v43 = *(void *)(a1 + 136) + 48 * (v42 - *(_DWORD *)(a1 + 160));
            *(float32x4_t *)uint64_t v43 = v17;
            *(float32x4_t *)(v43 + 16) = v18;
            *(int32x2_t *)(v43 + 32) = v19;
            *(void *)(v43 + 40) = v20;
            *(void *)(*(void *)(a1 + 144) + 8 * *(unsigned int *)(*(void *)(*(void *)(a1 + 128) + 8) + 24)) = *(void *)(a4 + 8 * v12);
            uint64_t v44 = *(void *)(a3 + 8 * v12);
            uint64_t v45 = *(void *)(a1 + 152);
            uint64_t v46 = *(void *)(*(void *)(a1 + 128) + 8);
            uint64_t v47 = *(unsigned int *)(v46 + 24);
            *(_DWORD *)(v46 + 24) = v47 + 1;
            *(void *)(v45 + 8 * v47) = v44;
            break;
          }
        }
      }
      ++v12;
    }
    while (v12 != v14);
  }
}

void sub_1B63FEF54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v11 = 0;
    uint64_t v12 = (_OWORD *)(a1 + 32);
    uint64_t v13 = a2;
    do
    {
      if (sub_1B64975FC(*(void *)(a4 + 8 * v11), a2, a3, a4, a5, a6, a7, a8) != 1) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Wrong probe type", v15, v16, v17, v18, v19, v20, (uint64_t)"CFXLightGetProbeType(lights[i]) == kCFXLightProbeTypeRadiance");
      }
      if (sub_1B6495E08(*(void *)(a4 + 8 * v11), v14, v15, v16, v17, v18, v19, v20) > 0.0)
      {
        uint64_t v21 = sub_1B6494F20(*(void *)(a4 + 8 * v11), 0, a3, a4, a5, a6, a7, a8);
        if (!v21 || sub_1B64763AC(v21, a2, a3, a4, a5, a6, a7, a8) > 0.0)
        {
          uint64_t v23 = 0;
          float32x4_t v24 = (float32x4_t *)(a5 + 80 * v11);
          float32x4_t v25 = *v24;
          float32x4_t v26 = v24[1];
          float32x4_t v27 = v24[2];
          float32x4_t v28 = v24[3];
          float32x4_t v29 = v24[4];
          *(float *)v22.i32 = fmaxf(fmaxf(v29.f32[0], COERCE_FLOAT(v24[4].i64[1])), COERCE_FLOAT(HIDWORD(v24[4].i64[0])))* 0.1;
          float32x4_t v30 = vaddq_f32(v29, (float32x4_t)vdupq_lane_s32(v22, 0));
          v30.i32[3] = v29.i32[3];
          long long v31 = v12[3];
          v51[2] = v12[2];
          v51[3] = v31;
          long long v32 = v12[5];
          v51[4] = v12[4];
          uint64_t v51[5] = v32;
          long long v33 = v12[1];
          v51[0] = *v12;
          v51[1] = v33;
          while (1)
          {
            float32x4_t v34 = (float32x4_t)v51[v23];
            int32x4_t v35 = (int32x4_t)vmulq_f32(v26, v34);
            int32x4_t v36 = (int32x4_t)vmulq_f32(v27, v34);
            int32x4_t v37 = (int32x4_t)vmulq_f32(v28, v34);
            int32x4_t v38 = (int32x4_t)vmulq_f32(v25, v34);
            int32x4_t v39 = vzip1q_s32(v35, v37);
            int32x4_t v40 = vzip2q_s32(v35, v37);
            int32x4_t v41 = vzip1q_s32(v36, v38);
            int32x4_t v42 = vzip2q_s32(v36, v38);
            float32x4_t v43 = vaddq_f32((float32x4_t)vzip2q_s32(v40, v42), vaddq_f32((float32x4_t)vzip1q_s32(v40, v42), vaddq_f32((float32x4_t)vzip1q_s32(v39, v41), (float32x4_t)vzip2q_s32(v39, v41))));
            float32x4_t v44 = vabsq_f32(vmulq_f32(v30, v43));
            if (v43.f32[3] <= (float)-vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v44, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v44.f32, 1), v44)).f32[0])break; {
            if (++v23 == 6)
            }
            {
              uint64_t v45 = (float32x4_t *)(*(void *)(a1 + 136)
                                  + 80
                                  * (*(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 8) + 24)
                                                 - *(_DWORD *)(a1 + 160)));
              float32x4_t *v45 = v25;
              v45[1] = v26;
              float32x4_t v45[2] = v27;
              v45[3] = v28;
              v45[4] = v30;
              *(void *)(*(void *)(a1 + 144)
                        + 8 * *(unsigned int *)(*(void *)(*(void *)(a1 + 128) + 8) + 24)) = *(void *)(a4 + 8 * v11);
              uint64_t v46 = *(void *)(a3 + 8 * v11);
              uint64_t v47 = *(void *)(a1 + 152);
              uint64_t v48 = *(void *)(*(void *)(a1 + 128) + 8);
              uint64_t v49 = *(unsigned int *)(v48 + 24);
              *(_DWORD *)(v48 + 24) = v49 + 1;
              *(void *)(v47 + 8 * v49) = v46;
              if (*(_DWORD *)(*(void *)(*(void *)(a1 + 128) + 8) + 24) > 0xFFu) {
                return;
              }
              break;
            }
          }
        }
      }
      ++v11;
    }
    while (v11 != v13);
  }
}

float32x4_t sub_1B63FF16C(float32x4_t *a1, unsigned int a2, unsigned int a3, unsigned __int32 a4, float32x4_t *a5, uint32x4_t a6)
{
  a6.i64[0] = __PAIR64__(a3, a2);
  a6.i32[2] = a4;
  float32x4_t v6 = a1[1];
  float32x4_t v7 = vmulq_f32(v6, vcvtq_f32_u32(a6));
  float32x4_t result = vaddq_f32(v6, v7);
  float32x4_t v9 = vmlaq_laneq_f32(a1[35], vsubq_f32(a1[39], a1[35]), v7, 2);
  float32x4_t v10 = vmlaq_laneq_f32(a1[36], vsubq_f32(a1[40], a1[36]), v7, 2);
  float32x4_t v11 = vsubq_f32(vmlaq_laneq_f32(a1[33], vsubq_f32(a1[37], a1[33]), v7, 2), v9);
  float32x4_t v12 = vmlaq_lane_f32(v9, v11, *(float32x2_t *)v7.f32, 1);
  float32x4_t v13 = vsubq_f32(vmlaq_laneq_f32(a1[34], vsubq_f32(a1[38], a1[34]), v7, 2), v10);
  float32x4_t v14 = vmlaq_lane_f32(v9, v11, *(float32x2_t *)result.f32, 1);
  float32x4_t v15 = vsubq_f32(vmlaq_lane_f32(v10, v13, *(float32x2_t *)v7.f32, 1), v12);
  *a5 = vmlaq_n_f32(v12, v15, v7.f32[0]);
  a5[1] = vmlaq_n_f32(v12, v15, result.f32[0]);
  float32x4_t v16 = vsubq_f32(vmlaq_lane_f32(v10, v13, *(float32x2_t *)result.f32, 1), v14);
  a5[2] = vmlaq_n_f32(v14, v16, v7.f32[0]);
  a5[3] = vmlaq_n_f32(v14, v16, result.f32[0]);
  float32x4_t v17 = vmlaq_laneq_f32(a1[35], vsubq_f32(a1[39], a1[35]), result, 2);
  float32x4_t v18 = vmlaq_laneq_f32(a1[36], vsubq_f32(a1[40], a1[36]), result, 2);
  float32x4_t v19 = vsubq_f32(vmlaq_laneq_f32(a1[33], vsubq_f32(a1[37], a1[33]), result, 2), v17);
  float32x4_t v20 = vmlaq_lane_f32(v17, v19, *(float32x2_t *)v7.f32, 1);
  float32x4_t v21 = vsubq_f32(vmlaq_laneq_f32(a1[34], vsubq_f32(a1[38], a1[34]), result, 2), v18);
  float32x4_t v22 = vmlaq_lane_f32(v17, v19, *(float32x2_t *)result.f32, 1);
  float32x4_t v23 = vsubq_f32(vmlaq_lane_f32(v18, v21, *(float32x2_t *)v7.f32, 1), v20);
  a5[4] = vmlaq_n_f32(v20, v23, v7.f32[0]);
  a5[5] = vmlaq_n_f32(v20, v23, result.f32[0]);
  float32x4_t v24 = vsubq_f32(vmlaq_lane_f32(v18, v21, *(float32x2_t *)result.f32, 1), v22);
  a5[6] = vmlaq_n_f32(v22, v24, v7.f32[0]);
  a5[7] = vmlaq_n_f32(v22, v24, result.f32[0]);
  return result;
}

uint64_t sub_1B63FF27C(uint64_t a1, void *__src, size_t __n)
{
  int v3 = __n;
  size_t v6 = __n;
  unsigned int v7 = *(_DWORD *)(a1 + 512);
  unsigned int v8 = v7 + __n;
  size_t v9 = *(unsigned int *)(a1 + 516);
  unsigned int v10 = v7;
  if (v8 >= v9)
  {
    if (v9) {
      int v11 = *(_DWORD *)(a1 + 516);
    }
    else {
      int v11 = 4096;
    }
    do
    {
      unsigned int v12 = v11;
      v11 *= 2;
    }
    while (v12 < v8);
    *(void *)(a1 + 504) = CStackAllocatorReallocate(*(uint64_t **)(a1 + 2784), *(void *)(a1 + 504), v9, v12, 16);
    *(void *)(a1 + 656) = CStackAllocatorReallocate(*(uint64_t **)(a1 + 2784), *(void *)(a1 + 656), 4 * *(unsigned int *)(a1 + 516), 4 * v12, 16);
    *(_DWORD *)(a1 + 516) = v12;
    unsigned int v10 = *(_DWORD *)(a1 + 512);
  }
  memcpy((void *)(*(void *)(a1 + 504) + v10), __src, v6);
  uint64_t v19 = *(unsigned int *)(a1 + 512);
  if (v19 < v8)
  {
    int v20 = v7 + v3 - v19;
    do
    {
      uint64_t v21 = *(void *)(a1 + 504);
      uint64_t v22 = *(unsigned __int8 *)(v21 + v19);
      uint64_t v23 = a1 + 4 * v22;
      int v24 = *(_DWORD *)(v23 + 664);
      if (v24)
      {
        if (*(unsigned __int8 *)(v21 + (v24 - 1)) != v22) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. first light was not of the same index", v13, v14, v15, v16, v17, v18, (uint64_t)"ctx.packedIndices.data[fl - 1] == li");
        }
        uint64_t v25 = a1 + 4 * v22;
        int v26 = *(_DWORD *)(v25 + 1688);
        if (!v26) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. end index should be set already", v13, v14, v15, v16, v17, v18, (uint64_t)"pl != 0");
        }
        uint64_t v27 = (v26 - 1);
        if (*(unsigned __int8 *)(*(void *)(a1 + 504) + v27) != v22) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. previous light was not of the same index", v13, v14, v15, v16, v17, v18, (uint64_t)"ctx.packedIndices.data[pl - 1] == li");
        }
        uint64_t v28 = *(void *)(a1 + 656);
        *(_DWORD *)(v28 + 4 * v27) = v19 + 1;
        *(_DWORD *)(v28 + 4 * v19) = 0;
        *(_DWORD *)(v25 + 168_Block_object_dispose(&STACK[0x5A0], 8) = v19 + 1;
        if (*(_DWORD *)(v28 + 4 * v19) > v8) {
          sub_1B63F2F54(17, @"Assertion '%s' failed. nextIndex out of range", v13, v14, v15, v16, v17, v18, (uint64_t)"ctx.nextIndex[i] <= newIndicesCount");
        }
      }
      else
      {
        *(_DWORD *)(v23 + 664) = v19 + 1;
        *(_DWORD *)(a1 + 4 * v22 + 168_Block_object_dispose(&STACK[0x5A0], 8) = v19 + 1;
        *(_DWORD *)(*(void *)(a1 + 656) + 4 * v19) = 0;
      }
      ++v19;
      --v20;
    }
    while (v20);
    LODWORD(v19) = *(_DWORD *)(a1 + 512);
  }
  *(_DWORD *)(a1 + 512) = v8;
  return (unsigned __int16)v19;
}

uint64_t sub_1B63FF484(uint64_t a1, unsigned __int8 *__src, size_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = *(_DWORD *)(a1 + 4 * *__src + 664);
  if (v11)
  {
    unsigned int v12 = *(_DWORD *)(a1 + 512);
    uint64_t v13 = __n - 1;
    while (1)
    {
      uint64_t v14 = v11 - 1;
      if (__n < 2)
      {
        int v18 = 1;
      }
      else
      {
        uint64_t v15 = 0;
        unsigned int v16 = v12 - v11;
        if (v12 < v11) {
          unsigned int v16 = 0;
        }
        uint64_t v17 = v16 + 1 - 1;
        while (v17 != v15 && *(unsigned __int8 *)(*(void *)(a1 + 504) + v11 + v15) == __src[v15 + 1])
        {
          if (v13 == ++v15) {
            return (unsigned __int16)v14;
          }
        }
        int v18 = v15 + 1;
      }
      if (v18 == __n) {
        return (unsigned __int16)v14;
      }
      unsigned int v11 = *(_DWORD *)(*(void *)(a1 + 656) + 4 * v14);
      if (v11 > v12)
      {
        sub_1B63F2F54(17, @"Assertion '%s' failed. nextIndex out of range", __n, a4, a5, a6, a7, a8, (uint64_t)"ctx.nextIndex[i] <= indicesCount");
        unsigned int v11 = *(_DWORD *)(*(void *)(a1 + 656) + 4 * v14);
      }
      if (!v11) {
        goto LABEL_17;
      }
    }
  }
  else
  {
LABEL_17:
    return sub_1B63FF27C(a1, __src, __n);
  }
}

uint64_t sub_1B63FF5D8(uint64_t *a1, char **a2, void *__src, size_t __n)
{
  unsigned int v4 = __n;
  int v8 = *((_DWORD *)a2 + 2);
  size_t v7 = *((unsigned int *)a2 + 3);
  unsigned int v9 = v8 + __n;
  if (v8 + (int)__n >= v7)
  {
    if (v7) {
      int v11 = *((_DWORD *)a2 + 3);
    }
    else {
      int v11 = 4096;
    }
    do
    {
      unsigned int v12 = v11;
      v11 *= 2;
    }
    while (v12 < v9);
    unsigned int v10 = (char *)CStackAllocatorReallocate(a1, (unint64_t)*a2, v7, v12, 16);
    *a2 = v10;
    *((_DWORD *)a2 + 3) = v12;
    int v8 = *((_DWORD *)a2 + 2);
  }
  else
  {
    unsigned int v10 = *a2;
  }
  memcpy(&v10[v8], __src, v4);
  uint64_t result = *((unsigned __int16 *)a2 + 4);
  *((_DWORD *)a2 + 2) = v9;
  return result;
}

_DWORD *sub_1B63FF678(uint64_t *a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a3;
  bzero(v19, 0x400uLL);
  unsigned int v7 = 0;
  if (v6)
  {
    uint64_t v8 = v6;
    unsigned int v9 = a2;
    do
    {
      unsigned int v11 = *v9++;
      uint64_t v10 = v11;
      if (v11) {
        ++v7;
      }
      ++v19[v10];
      --v8;
    }
    while (v8);
  }
  bzero(v18, 0x400uLL);
  uint64_t v12 = 0;
  int v13 = 0;
  do
  {
    v13 += v19[v12];
    v18[++v12] = v13;
  }
  while (v12 != 255);
  uint64_t result = CStackAllocatorAllocate(a1, 4 * v7);
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      uint64_t v16 = a2[i];
      if (v16)
      {
        int v17 = v18[v16];
        v18[v16] = v17 + 1;
        result[(v6 + ~v17)] = i;
      }
    }
  }
  *a3 = v7;
  return result;
}

uint64_t sub_1B63FF7AC(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = *(_DWORD *)a1 * *(_DWORD *)(a1 + 4);
  int v7 = *(_DWORD *)(a1 + 8);
  uint64_t v8 = (v6 * v7);
  int v28 = v6 * v7;
  unsigned int v9 = (unsigned int *)CStackAllocatorAllocate(*(uint64_t **)(a1 + 2784), 4 * v8);
  uint64_t v10 = v9;
  if (v8)
  {
    unint64_t v11 = 0;
    do
    {
      if (a3 == 8) {
        int v12 = HIBYTE(*(unsigned __int16 *)(a2 + 2 * v11 + 2))
      }
            + *(_WORD *)(a2 + 2 * v11 + 2)
            + *(unsigned __int8 *)(a2 + 2 * v11 + 4);
      else {
        int v12 = HIBYTE(*(unsigned __int16 *)(a2 + v11 + 2)) + *(_WORD *)(a2 + v11 + 2);
      }
      v9[v11 / 4] = v12;
      v11 += 4;
    }
    while (4 * v8 != v11);
  }
  uint64_t result = (uint64_t)sub_1B63FF678(*(uint64_t **)(a1 + 2784), v9, (unsigned int *)&v28);
  uint64_t v20 = v28;
  if (v28)
  {
    uint64_t v21 = (unsigned int *)result;
    do
    {
      unsigned int v23 = *v21++;
      uint64_t v22 = v23;
      size_t v24 = v10[v23];
      if (!v24) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Should be non empty", v14, v15, v16, v17, v18, v19, (uint64_t)"count > 0");
      }
      uint64_t v25 = *(void *)(a1 + 488);
      if (a3 == 8)
      {
        uint64_t v26 = 8 * v22;
        uint64_t v27 = (unsigned __int8 *)(v25 + (unsigned __int16)*(void *)(a2 + 8 * v22));
      }
      else
      {
        uint64_t v26 = 4 * v22;
        uint64_t v27 = (unsigned __int8 *)(v25 + *(unsigned __int16 *)(a2 + 4 * v22));
      }
      uint64_t result = sub_1B63FF484(a1, v27, v24, v15, v16, v17, v18, v19);
      *(_WORD *)(a2 + v26) = result;
      --v20;
    }
    while (v20);
  }
  return result;
}

float32x4_t *sub_1B63FF8FC(float32x4_t *result, unsigned int a2)
{
  uint64_t v2 = &result->i32[a2 & 3];
  __int32 v3 = *v2;
  if (*v2)
  {
    unsigned int v4 = result;
    int v5 = 0;
    int v6 = (const float *)(v2 + 4);
    float32x4_t v7 = vld1q_dup_f32(v6);
    float32x4_t v52 = v7;
    float32x4_t v53 = result[((2 * a2) | 1) + 2];
    float32x4_t v8 = 0uLL;
    float32x4_t v51 = vsubq_f32(vnegq_f32(result[2 * a2 + 2]), v53);
    float32x4_t v9 = vmlaq_f32(v53, (float32x4_t)0, v51);
    int32x4_t v10 = (int32x4_t)vmulq_f32(v9, v9);
    v10.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v10, 2), vadd_f32(*(float32x2_t *)v10.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v10.i8, 1))).u32[0];
    *(float32x2_t *)v7.f32 = vrsqrte_f32((float32x2_t)v10.u32[0]);
    *(float32x2_t *)v7.f32 = vmul_f32(*(float32x2_t *)v7.f32, vrsqrts_f32((float32x2_t)v10.u32[0], vmul_f32(*(float32x2_t *)v7.f32, *(float32x2_t *)v7.f32)));
    int32x4_t v11 = (int32x4_t)vmulq_n_f32(v9, vmul_f32(*(float32x2_t *)v7.f32, vrsqrts_f32((float32x2_t)v10.u32[0], vmul_f32(*(float32x2_t *)v7.f32, *(float32x2_t *)v7.f32))).f32[0]);
    int v12 = (uint64_t *)&result[171] + a2;
    uint64_t v13 = result[9].i64[0] + 32;
    do
    {
      uint64_t v14 = *v12;
      __int32 v15 = v4[173].i32[2];
      float32x4_t v56 = (float32x4_t)v11;
      float32x4_t v57 = vaddq_f32(v52, v8);
      float32x4_t v16 = vmlaq_f32(v53, v51, v57);
      int32x4_t v17 = (int32x4_t)vmulq_f32(v16, v16);
      v17.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v17, 2), vadd_f32(*(float32x2_t *)v17.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v17.i8, 1))).u32[0];
      float32x2_t v18 = vrsqrte_f32((float32x2_t)v17.u32[0]);
      float32x2_t v19 = vmul_f32(v18, vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(v18, v18)));
      float32x4_t v55 = vmulq_n_f32(v16, vmul_f32(v19, vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(v19, v19))).f32[0]);
      v59[0] = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 0);
      v59[1] = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.i8, 1);
      v59[2] = (float32x4_t)vdupq_laneq_s32(v11, 2);
      v59[3] = (float32x4_t)vdupq_laneq_s32(v11, 3);
      float32x4_t v54 = vnegq_f32(v55);
      uint64_t v20 = (char *)(v14 + 4 * (v15 * v5));
      v58[0] = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 0);
      v58[1] = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v54.f32, 1);
      v58[2] = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 2);
      v58[3] = (float32x4_t)vdupq_laneq_s32((int32x4_t)v54, 3);
      bzero(v20, (4 * v15));
      sub_1B640D880((float32x4_t *)v4[9].i64[1], v4[10].i32[0], v59, v58, v4[10].i64[1]);
      memcpy(&v20[4 * v4[169].i64[1]], (const void *)v4[10].i64[1], v4[11].u32[0]);
      sub_1B640D52C((float32x4_t *)v4[11].i64[1], v4[12].i32[0], v59, v58, v4[12].i64[1]);
      uint64_t result = (float32x4_t *)memcpy(&v20[4 * v4[170].i64[0]], (const void *)v4[12].i64[1], v4[13].u32[0]);
      uint64_t v21 = v4[170].u32[3];
      if ((int)v21 >= 1)
      {
        uint64_t v22 = 0;
        unsigned int v23 = (float32x4_t *)v13;
        do
        {
          float32x4_t v24 = v23[-2];
          float32x4_t v25 = v23[-1];
          float32x4_t v26 = v23[1];
          float32x4_t v27 = v23[2];
          int32x4_t v28 = (int32x4_t)vmulq_f32(v56, v25);
          int32x4_t v29 = (int32x4_t)vmulq_f32(v56, *v23);
          int32x4_t v30 = (int32x4_t)vmulq_f32(v56, v26);
          int32x4_t v31 = (int32x4_t)vmulq_f32(v56, v24);
          int32x4_t v32 = vzip1q_s32(v28, v30);
          int32x4_t v33 = vzip2q_s32(v28, v30);
          int32x4_t v34 = vzip1q_s32(v29, v31);
          int32x4_t v35 = vzip2q_s32(v29, v31);
          float32x4_t v36 = vaddq_f32((float32x4_t)vzip2q_s32(v33, v35), vaddq_f32((float32x4_t)vzip1q_s32(v33, v35), vaddq_f32((float32x4_t)vzip1q_s32(v32, v34), (float32x4_t)vzip2q_s32(v32, v34))));
          float32x4_t v37 = vabsq_f32(vmulq_f32(v27, v36));
          BOOL v49 = v36.f32[3] > (float)-vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1), v37)).f32[0];
          int32x4_t v38 = (int32x4_t)vmulq_f32(v25, v54);
          int32x4_t v39 = (int32x4_t)vmulq_f32(*v23, v54);
          int32x4_t v40 = (int32x4_t)vmulq_f32(v26, v54);
          int32x4_t v41 = (int32x4_t)vmulq_f32(v24, v54);
          int32x4_t v42 = vzip1q_s32(v38, v40);
          int32x4_t v43 = vzip2q_s32(v38, v40);
          int32x4_t v44 = vzip1q_s32(v39, v41);
          int32x4_t v45 = vzip2q_s32(v39, v41);
          float32x4_t v46 = vaddq_f32((float32x4_t)vzip2q_s32(v43, v45), vaddq_f32((float32x4_t)vzip1q_s32(v43, v45), vaddq_f32((float32x4_t)vzip1q_s32(v42, v44), (float32x4_t)vzip2q_s32(v42, v44))));
          float32x4_t v47 = vabsq_f32(vmulq_f32(v27, v46));
          float v48 = -vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1), v47)).f32[0];
          BOOL v49 = v49 && v46.f32[3] > v48;
          if (v49)
          {
            uint64_t v50 = &v20[4 * v4[170].i64[1]];
            v50[v22 >> 3] |= 1 << (v22 & 7);
          }
          ++v22;
          v23 += 5;
        }
        while (v21 != v22);
      }
      ++v5;
      int32x4_t v11 = (int32x4_t)v55;
      float32x4_t v8 = v57;
    }
    while (v5 != v3);
  }
  return result;
}

double sub_1B63FFC10(uint64_t a1)
{
  *(_OWORD *)a1 = xmmword_1B6E500F0;
  *(void *)(a1 + 16) = 0x4000000040;
  *(void *)&double result = 0x40000000400;
  *(_OWORD *)(a1 + 32) = xmmword_1B6E50100;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 4_Block_object_dispose(&STACK[0x5A0], 8) = 0;
  return result;
}

id *sub_1B63FFC3C(id *a1)
{
  for (uint64_t i = 0; i != 7; ++i)
  {
    __int32 v3 = &a1[i];
    id v4 = a1[i + 9];
    if (v4)
    {
      CFRelease(v4);
      v3[9] = 0;
    }
    id v5 = v3[16];
    if (v5)
    {
      CFRelease(v5);
      v3[16] = 0;
    }
  }
  return a1;
}

uint64_t sub_1B63FFCB8(uint64_t a1, uint64_t a2)
{
  double v2 = MEMORY[0x1F4188790](a1, a2);
  uint64_t v4 = v3;
  int v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  float v12 = v11;
  double v219 = v2;
  uint64_t v14 = (uint32x4_t *)v13;
  float32x4_t v16 = v15;
  uint64_t v291 = *MEMORY[0x1E4F143B8];
  *((_OWORD *)v15 + 21) = 0u;
  *((_OWORD *)v15 + 22) = 0u;
  *((_OWORD *)v15 + 19) = 0u;
  *((_OWORD *)v15 + 20) = 0u;
  *((_OWORD *)v15 + 17) = 0u;
  *((_OWORD *)v15 + 1_Block_object_dispose(&STACK[0x5A0], 8) = 0u;
  *((_OWORD *)v15 + 15) = 0u;
  *((_OWORD *)v15 + 16) = 0u;
  *((_OWORD *)v15 + 13) = 0u;
  *((_OWORD *)v15 + 14) = 0u;
  *((_OWORD *)v15 + 11) = 0u;
  *((_OWORD *)v15 + 12) = 0u;
  *((_OWORD *)v15 + 9) = 0u;
  *((_OWORD *)v15 + 10) = 0u;
  *((_OWORD *)v15 + 7) = 0u;
  *((_OWORD *)v15 + _Block_object_dispose(&STACK[0x5A0], 8) = 0u;
  *((_OWORD *)v15 + 5) = 0u;
  *((_OWORD *)v15 + 6) = 0u;
  *((_OWORD *)v15 + 3) = 0u;
  *((_OWORD *)v15 + 4) = 0u;
  *((_OWORD *)v15 + 1) = 0u;
  *((_OWORD *)v15 + 2) = 0u;
  *(_OWORD *)__int32 v15 = 0u;
  uint64_t v17 = *(void *)(v9 + 12648);
  long long v18 = *(_OWORD *)(v9 + 5696);
  long long v239 = *(_OWORD *)(v9 + 5680);
  long long v240 = v18;
  long long v19 = *(_OWORD *)(v9 + 5728);
  long long v241 = *(_OWORD *)(v9 + 5712);
  long long v242 = v19;
  long long v20 = *(_OWORD *)(v9 + 5664);
  long long v237 = *(_OWORD *)(v9 + 5648);
  long long v238 = v20;
  uint64_t v230 = v9;
  uint64_t v231 = v17;
  uint64_t v232 = v7;
  uint64_t v233 = v3;
  uint64_t v234 = v290;
  uint64_t v235 = v289;
  float32x4_t v236 = v288;
  long long v21 = *(_OWORD *)(v9 + 5664);
  v229[0] = *(_OWORD *)(v9 + 5648);
  v229[1] = v21;
  long long v22 = *(_OWORD *)(v9 + 5680);
  long long v23 = *(_OWORD *)(v9 + 5696);
  long long v24 = *(_OWORD *)(v9 + 5728);
  v229[4] = *(_OWORD *)(v9 + 5712);
  v229[5] = v24;
  v229[2] = v22;
  v229[3] = v23;
  sub_1B63FD674(v13, (uint64_t)v229);
  uint64_t result = sub_1B63C1F6C(v8);
  if (result)
  {
    unsigned __int32 v177 = (unsigned int *)sub_1B64468E8(v17, v26, v27, v28, v29, v30, v31, v32);
    CStackAllocatorPushFrame(v177);
    float32x4_t v34 = vcvtq_f32_u32(*v14);
    uint64_t v35 = v14[1].i64[0];
    if (v35)
    {
      float v36 = (float)v35 * v12;
      v16[20] = v36;
      v38.i32[1] = HIDWORD(v219);
      v37.f32[0] = (float)LODWORD(v219) / v36;
      v37.i32[1] = v34.i32[1];
      v37.i64[1] = v34.i64[1];
      v38.i32[0] = (float)(v36 * ceilf(v37.f32[0]));
      float32x4_t v34 = v37;
    }
    else
    {
      uint32x2_t v38 = *(uint32x2_t *)&v219;
    }
    if (HIDWORD(v35))
    {
      float v39 = (float)HIDWORD(v35) * v12;
      v40.i32[0] = v34.i32[0];
      v40.f32[1] = (float)v38.u32[1] / v39;
      v16[21] = v39;
      v40.i64[1] = v34.i64[1];
      v38.i32[1] = (float)(v39 * ceilf(v40.f32[1]));
      float32x4_t v34 = v40;
    }
    uint64_t v176 = v6;
    *(uint32x2_t *)v33.f32 = vcvt_u32_f32(vrndp_f32(*(float32x2_t *)v34.f32));
    float32x4_t v41 = v33;
    v41.i32[2] = v34.f32[2];
    float32x4_t v220 = v41;
    __asm { FMOV            V1.4S, #1.0 }
    float32x4_t v216 = vdivq_f32(_Q1, v34);
    _Q1.f32[0] = *(double *)(v10 + 12656);
    double v47 = *(double *)(v10 + 12664);
    *(float *)&double v47 = v47;
    *(float32x2_t *)&long long v48 = vdiv_f32(vcvt_f32_u32(*(uint32x2_t *)v33.f32), vcvt_f32_u32(v38));
    *(float *)&double v47 = _Q1.f32[0] - *(float *)&v47;
    _Q1.f32[0] = vmuls_lane_f32(_Q1.f32[0], v34, 2);
    v34.i32[0] = vextq_s8((int8x16_t)v34, (int8x16_t)v34, 8uLL).u32[0];
    v34.i32[1] = _Q1.i32[0];
    *((float32x2_t *)&v48 + 1) = vdiv_f32(*(float32x2_t *)v34.f32, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v47, 0));
    *((float32x4_t *)v16 + 3) = v216;
    *((_OWORD *)v16 + 4) = v48;
    unsigned int v180 = v34.f32[2];
    __int32 v184 = v33.i32[1];
    float32x4_t v214 = v33;
    __int32 v49 = v33.i32[0];
    int v187 = *((_DWORD *)v16 + 27);
    if (v187) {
      int v50 = 8;
    }
    else {
      int v50 = 4;
    }
    int v175 = v50;
    if (v187) {
      char v51 = 3;
    }
    else {
      char v51 = 2;
    }
    size_t v52 = (v33.i32[1] * v34.f32[2] * v33.i32[0]) << v51;
    sub_1B649F150(v4, v52, &v252);
    *(float32x4_t *)float32x4_t v16 = v252;
    *((void *)v16 + 2) = v253.i64[0];
    uint64_t v186 = *(void *)v16;
    bzero(*(void **)v16, v52);
    bzero(&v262, 0xA60uLL);
    float32x4_t v53 = v220;
    float32x4_t v252 = v220;
    float32x4_t v253 = v216;
    long long v256 = v239;
    long long v257 = v240;
    long long v258 = v241;
    long long v259 = v242;
    long long v254 = v237;
    long long v255 = v238;
    uint64_t v260 = (int32x4_t *)v290;
    uint64_t v261 = v289;
    uint64_t v262 = v288;
    *(void *)__n128 v287 = v177;
    uint64_t v54 = *((void *)v16 + 11);
    uint64_t v217 = v54;
    unsigned int v55 = HIDWORD(v54);
    unsigned int v264 = (HIDWORD(v54) + 3) >> 2;
    if ((HIDWORD(v54) + 3) >= 4)
    {
      Aligned = CStackAllocatorAllocateAligned((uint64_t *)v177, (unint64_t)((HIDWORD(v54) + 3) >> 2) << 6, 16, 2);
      sub_1B640D7B8((uint64_t)Aligned, v260, v55);
      unsigned int v266 = (v264 + 1) >> 1;
      float32x4_t v56 = CStackAllocatorAllocateAligned((uint64_t *)v177, v266, 16, 2);
      float32x4_t v53 = v220;
      uint64_t v265 = v56;
    }
    uint64_t v178 = v16;
    uint64_t v57 = *((void *)v16 + 12);
    uint64_t v213 = v57;
    unsigned int v58 = HIDWORD(v57);
    unsigned int v268 = (HIDWORD(v57) + 3) >> 2;
    if ((HIDWORD(v57) + 3) >= 4)
    {
      uint64_t v267 = CStackAllocatorAllocateAligned((uint64_t *)v177, (unint64_t)((HIDWORD(v57) + 3) >> 2) << 7, 16, 2);
      sub_1B640D3FC((uint64_t)v267, v289, v58);
      unsigned int v270 = (v268 + 1) >> 1;
      uint64_t v59 = CStackAllocatorAllocateAligned((uint64_t *)v177, v270, 16, 2);
      float32x4_t v53 = v220;
      uint64_t v269 = v59;
    }
    uint64_t v60 = 0;
    HIDWORD(v61) = HIDWORD(v213);
    LODWORD(v61) = (v55 + 31) >> 5;
    HIDWORD(v62) = HIDWORD(v217);
    LODWORD(v62) = 0;
    uint64_t v279 = v62;
    uint64_t v280 = v61;
    uint64_t v63 = *((void *)v16 + 13);
    char v212 = v63;
    LODWORD(v63) = ((v58 + 31) >> 5) + ((v55 + 31) >> 5);
    uint64_t v281 = v63;
    unsigned int v286 = v63 + ((HIDWORD(v63) + 31) >> 5);
    size_t v64 = 4 * v286;
    do
    {
      float32x4_t v222 = v53;
      v282[v60] = CStackAllocatorAllocateZero((uint64_t *)v177, (*(_DWORD *)((unint64_t)&v222 & 0xFFFFFFFFFFFFFFF3 | (4 * (v60 & 3))) * v64));
      uint64_t v284 = CStackAllocatorAllocate((uint64_t *)v177, v64);
      __n128 v285 = (int *)CStackAllocatorAllocate((uint64_t *)v177, v64);
      sub_1B63FF8FC(&v252, v60);
      float32x4_t v53 = v220;
      ++v60;
    }
    while (v60 != 3);
    sub_1B6400AF4((uint64_t)&v237, v278);
    if (v180)
    {
      unsigned __int32 v185 = 0;
      v65.i64[1] = v214.i64[1];
      *(int32x2_t *)v65.f32 = vceqz_s32(*(int32x2_t *)v214.f32);
      uint64_t v211 = *((void *)v16 + 14);
      char v215 = v217;
      __int8 v179 = v65.i8[4];
      __int8 v183 = v65.i8[0];
      int v201 = v49;
      do
      {
        if (v286)
        {
          if (*(_DWORD *)(v283 + 4 * v286 * v185)) {
            goto LABEL_27;
          }
          uint64_t v66 = 1;
          do
          {
            unint64_t v67 = v66;
            if (v286 == v66) {
              break;
            }
          }
          while (!*(_DWORD *)(v283 + 4 * v286 * v185 + 4 * v66++));
          if (v67 < v286)
          {
LABEL_27:
            float32x4_t v65 = sub_1B63FF16C(&v252, 0, 0, v185, &v244, (uint32x4_t)v65);
            if ((v179 & 1) == 0)
            {
              unsigned int v200 = 0;
              float32x4_t v196 = v244;
              float32x4_t v197 = v245;
              float32x4_t v194 = v249;
              float32x4_t v195 = vsubq_f32(v245, v244);
              float32x4_t v191 = v246;
              float32x4_t v192 = vsubq_f32(v249, v248);
              float32x4_t v188 = v251;
              float32x4_t v193 = v248;
              float32x4_t v189 = v250;
              float32x4_t v190 = v247;
              float32x4_t v65 = vsubq_f32(v250, v248);
              float32x4_t v181 = v65;
              float32x4_t v182 = vsubq_f32(v246, v244);
              do
              {
                uint64_t v75 = v286;
                if (v286)
                {
                  int v76 = 0;
                  uint64_t v77 = v285;
                  unsigned int v78 = (int *)(v283 + 4 * v185 * v286);
                  int v79 = (int *)(v282[1] + 4 * v286 * v200);
                  do
                  {
                    int v81 = *v79++;
                    int v80 = v81;
                    int v82 = *v78++;
                    int v83 = v82 & v80;
                    *v77++ = v83;
                    v76 |= v83;
                    --v75;
                  }
                  while (v75);
                  if (v76 && (v183 & 1) == 0)
                  {
                    unsigned int v84 = 0;
                    float32x4_t v65 = vmulq_n_f32(v181, (float)v200);
                    float32x4_t v198 = v65;
                    float32x4_t v199 = vmulq_n_f32(v182, (float)v200);
                    int v85 = (v200 + v185 * v184) * v49;
                    do
                    {
                      uint64_t v86 = v286;
                      if (v286)
                      {
                        int v87 = 0;
                        uint64_t v88 = v284;
                        unsigned int v89 = v285;
                        uint64_t v90 = (int *)(v282[0] + 4 * v286 * v84);
                        uint64_t v91 = v284;
                        do
                        {
                          int v93 = *v89++;
                          int v92 = v93;
                          int v94 = *v90++;
                          int v95 = v94 & v92;
                          *v91++ = v95;
                          v87 |= v95;
                          --v86;
                        }
                        while (v86);
                        if (v87)
                        {
                          unsigned int v202 = v85;
                          unsigned int v203 = v84;
                          float32x4_t v96 = vmlaq_n_f32(v199, v195, (float)v84);
                          float32x4_t v97 = vmlaq_n_f32(v198, v192, (float)v84);
                          float32x4_t v98 = vaddq_f32(v196, v96);
                          v243[0] = v98;
                          v243[1] = vaddq_f32(v197, v96);
                          v243[2] = vaddq_f32(v191, v96);
                          v243[3] = vaddq_f32(v96, v190);
                          v243[4] = vaddq_f32(v193, v97);
                          v243[5] = vaddq_f32(v194, v97);
                          v243[6] = vaddq_f32(v189, v97);
                          v243[7] = vaddq_f32(v97, v188);
                          v98.i32[3] = 0;
                          uint64_t v99 = 1;
                          float32x4_t v100 = v98;
                          do
                          {
                            float32x4_t v101 = (float32x4_t)v243[v99];
                            v101.i32[3] = 0;
                            float32x4_t v98 = vminnmq_f32(v98, v101);
                            float32x4_t v100 = vmaxnmq_f32(v100, v101);
                            ++v99;
                          }
                          while (v99 != 8);
                          v102.i64[0] = 0x3F0000003F000000;
                          v102.i64[1] = 0x3F0000003F000000;
                          float32x4_t v106 = vmulq_f32(vaddq_f32(v100, v98), v102);
                          float32x4_t v103 = vmulq_f32(vsubq_f32(v100, v98), v102);
                          float32x4_t v104 = vmulq_f32(v103, v103);
                          float v105 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v104, 2), vaddq_f32(v104, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v104.f32, 1))).f32[0]);
                          float v221 = v105;
                          v106.f32[3] = v105;
                          unsigned int v275 = 0;
                          unsigned int v107 = HIDWORD(v281);
                          float32x4_t v218 = v106;
                          if ((HIDWORD(v281) + 31) >= 0x20)
                          {
                            uint64_t v112 = 0;
                            uint64_t v204 = (HIDWORD(v281) + 31) >> 5;
                            uint64_t v205 = &v88[v281];
                            float v113 = v105 * v105;
                            float32x4_t v208 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v106, 3);
                            while (1)
                            {
                              unsigned int v114 = v205[v112];
                              if (v114) {
                                break;
                              }
LABEL_53:
                              if (++v112 == v204) {
                                goto LABEL_42;
                              }
                            }
                            int v115 = 32 * v112;
                            while (1)
                            {
                              unsigned int v116 = __clz(__rbit32(v114));
                              int v117 = v116 | v115;
                              if ((v116 | v115) >= v107)
                              {
                                sub_1B63F2F54(17, @"Assertion '%s' failed. range overflow", v69, v70, v71, v72, v73, v74, (uint64_t)"i < lightRange.y");
                                float32x4_t v106 = v218;
                              }
                              uint64_t v118 = (float32x4_t *)&v288[5 * v117];
                              float32x4_t v119 = v118[4];
                              float32x4_t v120 = vsubq_f32(v106, *v118);
                              int32x4_t v121 = (int32x4_t)vmulq_f32(v118[1], v120);
                              int32x4_t v122 = (int32x4_t)vmulq_f32(v120, v118[2]);
                              int32x4_t v123 = (int32x4_t)vmulq_f32(v120, v118[3]);
                              int32x4_t v124 = vzip1q_s32(v121, v123);
                              int32x4_t v125 = vzip2q_s32(v121, v123);
                              float32x4_t v126 = (float32x4_t)vtrn2q_s32(v121, v122);
                              v126.i32[2] = v123.i32[1];
                              float32x4_t v127 = vabsq_f32(vaddq_f32((float32x4_t)vzip1q_s32(v125, vdupq_laneq_s32(v122, 2)), vaddq_f32((float32x4_t)vzip1q_s32(v124, v122), v126)));
                              float32x4_t v128 = vsubq_f32(v127, v119);
                              v128.i32[3] = 0;
                              float32x4_t v129 = vmaxnmq_f32(v128, (float32x4_t)0);
                              float32x4_t v130 = vmulq_f32(v129, v129);
                              int32x2_t v131 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v130, 2), vaddq_f32(v130, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v130.f32, 1))).u64[0];
                              if (*(float *)v131.i32 <= v113)
                              {
                                uint64_t v132 = v275++;
                                v271[v132] = v117 + v212;
                                if (*(float *)(v211 + 368 * (v117 + v212)) >= 1.0)
                                {
                                  *(float *)v131.i32 = fmaxf(fmaxf(v119.f32[0], v119.f32[2]), v119.f32[1]) * 0.090909;
                                  uint32x4_t v133 = (uint32x4_t)vcgeq_f32(vsubq_f32(vsubq_f32(v119, (float32x4_t)vdupq_lane_s32(v131, 0)), v127), v208);
                                  v133.i32[3] = v133.i32[2];
                                  if ((vminvq_u32(v133) & 0x80000000) != 0) {
                                    break;
                                  }
                                }
                              }
                              v114 &= ~(1 << v116);
                              if (!v114) {
                                goto LABEL_53;
                              }
                            }
                          }
LABEL_42:
                          uint64_t v108 = &v271[v275];
                          unsigned int v273 = 0;
                          uint64_t v109 = v284;
                          unsigned int v110 = HIDWORD(v279);
                          if ((HIDWORD(v279) + 31) >= 0x20)
                          {
                            uint64_t v134 = 0;
                            uint64_t v206 = (HIDWORD(v279) + 31) >> 5;
                            uint64_t v209 = (char *)&v284[v279];
                            do
                            {
                              unsigned int v135 = *(_DWORD *)&v209[4 * v134];
                              if (v135)
                              {
                                int v136 = 32 * v134;
                                do
                                {
                                  unsigned int v137 = __clz(__rbit32(v135));
                                  int v138 = v137 | v136;
                                  if ((v137 | v136) >= v110)
                                  {
                                    sub_1B63F2F54(17, @"Assertion '%s' failed. range overflow", v69, v70, v71, v72, v73, v74, (uint64_t)"i < lightRange.y");
                                    float32x4_t v106 = v218;
                                  }
                                  float v139 = v221 + COERCE_FLOAT(HIDWORD(v290[v138]));
                                  float32x4_t v140 = vsubq_f32((float32x4_t)v290[v138], v106);
                                  float32x4_t v141 = vmulq_f32(v140, v140);
                                  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v141, 2), vaddq_f32(v141, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v141.f32, 1))).f32[0] <= (float)(v139 * v139))
                                  {
                                    uint64_t v142 = v273++;
                                    v108[v142] = v138 + v215;
                                  }
                                  v135 &= ~(1 << v137);
                                }
                                while (v135);
                              }
                              ++v134;
                            }
                            while (v134 != v206);
                            unsigned int v111 = v273;
                            uint64_t v109 = v284;
                            __int32 v49 = v201;
                          }
                          else
                          {
                            unsigned int v111 = 0;
                            __int32 v49 = v201;
                          }
                          unsigned int v274 = 0;
                          unsigned int v143 = HIDWORD(v280);
                          if ((HIDWORD(v280) + 31) >= 0x20)
                          {
                            uint64_t v145 = 0;
                            uint64_t v146 = &v108[v111];
                            uint64_t v207 = &v109[v280];
                            uint64_t v210 = (HIDWORD(v280) + 31) >> 5;
                            do
                            {
                              unsigned int v147 = v207[v145];
                              if (v147)
                              {
                                int v148 = 32 * v145;
                                do
                                {
                                  unsigned int v149 = __clz(__rbit32(v147));
                                  int v150 = v149 | v148;
                                  if ((v149 | v148) >= v143)
                                  {
                                    sub_1B63F2F54(17, @"Assertion '%s' failed. range overflow", v69, v70, v71, v72, v73, v74, (uint64_t)"i < lightRange.y");
                                    float32x4_t v106 = v218;
                                  }
                                  uint64_t v151 = (float32x4_t *)&v289[3 * v150];
                                  float v152 = v151[2].f32[0];
                                  float32x4_t v153 = vsubq_f32(v106, *v151);
                                  float32x4_t v154 = vmulq_f32(v153, v153);
                                  if (vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v154, 2), vaddq_f32(v154, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v154.f32, 1))).f32[0] <= (float)((float)(v221 + v152) * (float)(v221 + v152)))
                                  {
                                    float v155 = v151[2].f32[2];
                                    float32x4_t v156 = vmulq_f32(v153, v151[1]);
                                    LODWORD(_S3) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v156, 2), vaddq_f32(v156, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v156.f32, 1))).u32[0];
                                    __asm { FMLS            S1, S3, V3.S[0] }
                                    float v159 = sqrtf(_S1);
                                    float v160 = v151[2].f32[3] * v155;
                                    float v161 = vmlas_n_f32(-(float)(v155 * v159), v160, _S3);
                                    if (v161 >= 0.0
                                      || (float v162 = (float)(v155 * _S3) + (float)(v160 * v159),
                                          float v163 = fminf(fmaxf(v162, 0.0), v152),
                                          (float)((float)(v161 * v161)
                                                + (float)((float)(v162 - v163) * (float)(v162 - v163))) <= (float)(v221 * v221)))
                                    {
                                      uint64_t v164 = v274++;
                                      v146[v164] = v150 + v213;
                                    }
                                  }
                                  v147 &= ~(1 << v149);
                                }
                                while (v147);
                              }
                              ++v145;
                            }
                            while (v145 != v210);
                            unsigned int v144 = v274;
                            unsigned int v111 = v273;
                            __int32 v49 = v201;
                          }
                          else
                          {
                            unsigned int v144 = 0;
                          }
                          unsigned int v84 = v203;
                          int v85 = v202;
                          unsigned int v165 = v144 + v111;
                          size_t v70 = v275 + v165;
                          unsigned int v272 = v275 + v165;
                          if (v275 + v165)
                          {
                            __int16 v166 = sub_1B63FF5D8(*(uint64_t **)v287, v276, v271, v70);
                            v65.i32[3] = 0;
                            v65.i16[0] = v166;
                            v65.i16[1] = v273 | (unsigned __int16)((_WORD)v274 << 8);
                            *(uint64_t *)((char *)v65.i64 + 4) = v275;
                          }
                          else
                          {
                            float32x4_t v65 = 0uLL;
                          }
                          if (v187)
                          {
                            *(void *)(v186 + 8 * v202) = v65.i64[0];
                          }
                          else
                          {
                            float32x4_t v65 = (float32x4_t)vmovl_u16(*(uint16x4_t *)v65.f32);
                            uint64_t v167 = (_WORD *)(v186 + 4 * v202);
                            v167[1] = v65.i16[2];
                            *uint64_t v167 = v65.i16[0];
                          }
                        }
                      }
                      ++v84;
                      ++v85;
                    }
                    while (v84 != v49);
                  }
                }
                ++v200;
              }
              while (v200 != v184);
            }
          }
        }
        ++v185;
      }
      while (v185 != v180);
    }
    sub_1B63FF7AC((uint64_t)&v252, v186, v175);
    uint64_t v168 = v277;
    if (v277 <= 1) {
      uint64_t v169 = 1;
    }
    else {
      uint64_t v169 = v277;
    }
    unint64_t v170 = (v169 - 1) | ((unint64_t)(v169 - 1) >> 1) | (((v169 - 1) | ((unint64_t)(v169 - 1) >> 1)) >> 2);
    unint64_t v171 = v170 | (v170 >> 4) | ((v170 | (v170 >> 4)) >> 8);
    float32x4_t v248 = 0u;
    float32x4_t v247 = 0u;
    float32x4_t v246 = 0u;
    float32x4_t v245 = 0u;
    float32x4_t v244 = 0u;
    RGTextureDescriptorMake1D((WORD1(v171) | v171) + 1, 13, (uint64_t)&v244);
    v246.i64[0] = 0;
    v246.i64[1] = 1;
    v228[0] = v244;
    v228[1] = v245;
    v228[3] = v247;
    v228[4] = v248;
    v228[2] = v246;
    uint64_t v172 = (void *)sub_1B650EC18((uint64_t)v176, (unsigned __int16 *)v228, 0, 1);
    *((void *)v178 + 4) = v172;
    if (v168)
    {
      memset(v226, 0, 24);
      v226[3] = v168;
      int64x2_t v227 = vdupq_n_s64(1uLL);
      objc_msgSend_replaceRegion_mipmapLevel_withBytes_bytesPerRow_(v172, v173, (uint64_t)v226, 0, v276[2], v277);
    }
    float32x4_t v248 = 0u;
    if (v187) {
      uint64_t v174 = 113;
    }
    else {
      uint64_t v174 = 63;
    }
    float32x4_t v247 = 0uLL;
    float32x4_t v246 = 0uLL;
    float32x4_t v245 = 0uLL;
    float32x4_t v244 = 0uLL;
    RGTextureDescriptorMake3D(v49, v184, v180, v174, (uint64_t)&v244);
    v246.i64[1] = 1;
    v225[0] = v244;
    v225[1] = v245;
    v225[3] = v247;
    v225[4] = v248;
    v225[2] = v246;
    long long v223 = *(_OWORD *)v178;
    uint64_t v224 = *((void *)v178 + 2);
    *((void *)v178 + 3) = sub_1B650F004(v176, (unsigned __int16 *)v225, &v223, 1);
    return CStackAllocatorPopFrame((uint64_t)v177);
  }
  return result;
}

float32x4_t sub_1B6400AF4(uint64_t a1, float32x4_t *a2)
{
  float32x4_t v2 = *(float32x4_t *)(a1 + 80);
  int32x4_t v4 = *(int32x4_t *)(a1 + 16);
  int32x4_t v3 = *(int32x4_t *)(a1 + 32);
  float32x4_t v5 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v3, (int8x16_t)v3, 0xCuLL), (int8x16_t)v3, 8uLL);
  float32x4_t v6 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v3, v3), (int8x16_t)v3, 0xCuLL);
  float32x4_t v7 = vmulq_f32(v2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v4, (int8x16_t)v4, 0xCuLL), (int8x16_t)v4, 8uLL), vnegq_f32(v6)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v4, v4), (int8x16_t)v4, 0xCuLL), v5));
  int32x2_t v8 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).u64[0];
  if (*(float *)v8.i32 != 0.0)
  {
    float32x4_t v9 = *(float32x4_t *)(a1 + 80);
    v9.f32[0] = -v2.f32[3];
    int32x4_t v10 = *(int32x4_t *)(a1 + 32);
    *(float *)v10.i32 = -*(float *)&v3.i32[3];
    int32x4_t v11 = *(int32x4_t *)(a1 + 16);
    *(float *)v11.i32 = -*(float *)&v4.i32[3];
    float32x4_t v12 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v11, (int8x16_t)v11, 0xCuLL), (int8x16_t)v11, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v10, v10), (int8x16_t)v10, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v11, v11), (int8x16_t)v11, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v10, (int8x16_t)v10, 0xCuLL), (int8x16_t)v10, 8uLL));
    float32x4_t v13 = *(float32x4_t *)(a1 + 80);
    v13.f32[1] = -v2.f32[3];
    int32x4_t v14 = *(int32x4_t *)(a1 + 32);
    *(float *)&v14.i32[1] = -*(float *)&v3.i32[3];
    int32x4_t v15 = *(int32x4_t *)(a1 + 16);
    *(float *)&v15.i32[1] = -*(float *)&v4.i32[3];
    int32x4_t v16 = (int32x4_t)vmulq_f32(v9, v12);
    int32x4_t v17 = (int32x4_t)vmulq_f32(v13, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v15, (int8x16_t)v15, 0xCuLL), (int8x16_t)v15, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v14, v14), (int8x16_t)v14, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v15, v15), (int8x16_t)v15, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v14, (int8x16_t)v14, 0xCuLL), (int8x16_t)v14, 8uLL)));
    *(float32x2_t *)v13.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v16.i8, *(int32x2_t *)v17.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v16.i8, *(int32x2_t *)v17.i8));
    float32x4_t v18 = (float32x4_t)vzip2q_s32(v16, v17);
    *(float32x2_t *)v18.f32 = vadd_f32(*(float32x2_t *)v18.f32, *(float32x2_t *)v13.f32);
    v2.f32[2] = -v2.f32[3];
    *(float *)&v3.i32[2] = -*(float *)&v3.i32[3];
    *(float *)&v4.i32[2] = -*(float *)&v4.i32[3];
    float32x4_t v19 = vmulq_f32(v2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v4, (int8x16_t)v4, 0xCuLL), (int8x16_t)v4, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v3, v3), (int8x16_t)v3, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v4, v4), (int8x16_t)v4, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v3, (int8x16_t)v3, 0xCuLL), (int8x16_t)v3, 8uLL)));
    v18.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).u32[0];
    *a2 = vdivq_f32(v18, (float32x4_t)vdupq_lane_s32(v8, 0));
    float32x4_t v2 = *(float32x4_t *)(a1 + 80);
    int32x4_t v3 = *(int32x4_t *)(a1 + 32);
    float32x4_t v6 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v3, v3), (int8x16_t)v3, 0xCuLL);
    float32x4_t v5 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v3, (int8x16_t)v3, 0xCuLL), (int8x16_t)v3, 8uLL);
  }
  int32x4_t v20 = *(int32x4_t *)a1;
  float32x4_t v21 = vmulq_f32(v2, vmlaq_f32(vmulq_f32(v5, vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v20, v20), *(int8x16_t *)a1, 0xCuLL))), v6, (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v20, (int8x16_t)v20, 0xCuLL), *(int8x16_t *)a1, 8uLL)));
  int32x2_t v22 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v21, 2), vaddq_f32(v21, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v21.f32, 1))).u64[0];
  if (*(float *)v22.i32 != 0.0)
  {
    float32x4_t v23 = v2;
    v23.f32[0] = -v2.f32[3];
    int32x4_t v24 = *(int32x4_t *)a1;
    *(float *)v24.i32 = -*(float *)&v20.i32[3];
    int32x4_t v25 = v3;
    *(float *)v25.i32 = -*(float *)&v3.i32[3];
    int32x4_t v26 = (int32x4_t)vmulq_f32(v23, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v25, (int8x16_t)v25, 0xCuLL), (int8x16_t)v25, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v24, v24), (int8x16_t)v24, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v25, v25), (int8x16_t)v25, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v24, (int8x16_t)v24, 0xCuLL), (int8x16_t)v24, 8uLL)));
    float32x4_t v27 = v2;
    v27.f32[1] = -v2.f32[3];
    int32x4_t v28 = *(int32x4_t *)a1;
    *(float *)&v28.i32[1] = -*(float *)&v20.i32[3];
    int32x4_t v29 = v3;
    *(float *)&v29.i32[1] = -*(float *)&v3.i32[3];
    int32x4_t v30 = (int32x4_t)vmulq_f32(v27, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v29, (int8x16_t)v29, 0xCuLL), (int8x16_t)v29, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v28, v28), (int8x16_t)v28, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v29, v29), (int8x16_t)v29, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v28, (int8x16_t)v28, 0xCuLL), (int8x16_t)v28, 8uLL)));
    *(float32x2_t *)v28.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v26.i8, *(int32x2_t *)v30.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v26.i8, *(int32x2_t *)v30.i8));
    float32x4_t v31 = (float32x4_t)vzip2q_s32(v26, v30);
    *(float32x2_t *)v31.f32 = vadd_f32(*(float32x2_t *)v31.f32, *(float32x2_t *)v28.i8);
    v2.f32[2] = -v2.f32[3];
    *(float *)&v20.i32[2] = -*(float *)&v20.i32[3];
    *(float *)&v3.i32[2] = -*(float *)&v3.i32[3];
    float32x4_t v32 = vmulq_f32(v2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v3, (int8x16_t)v3, 0xCuLL), (int8x16_t)v3, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v20, v20), (int8x16_t)v20, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v3, v3), (int8x16_t)v3, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v20, (int8x16_t)v20, 0xCuLL), (int8x16_t)v20, 8uLL)));
    v31.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v32, 2), vaddq_f32(v32, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v32.f32, 1))).u32[0];
    a2[1] = vdivq_f32(v31, (float32x4_t)vdupq_lane_s32(v22, 0));
    float32x4_t v2 = *(float32x4_t *)(a1 + 80);
  }
  int32x4_t v33 = *(int32x4_t *)(a1 + 16);
  int32x4_t v34 = *(int32x4_t *)(a1 + 48);
  float32x4_t v35 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v34, v34), (int8x16_t)v34, 0xCuLL);
  float32x4_t v36 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v34, (int8x16_t)v34, 0xCuLL), (int8x16_t)v34, 8uLL);
  float32x4_t v37 = vmulq_f32(v2, vmlaq_f32(vmulq_f32(v36, vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v33, v33), (int8x16_t)v33, 0xCuLL))), v35, (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v33, (int8x16_t)v33, 0xCuLL), (int8x16_t)v33, 8uLL)));
  int32x2_t v38 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 2), vaddq_f32(v37, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v37.f32, 1))).u64[0];
  if (*(float *)v38.i32 != 0.0)
  {
    float32x4_t v39 = v2;
    v39.f32[0] = -v2.f32[3];
    int32x4_t v40 = *(int32x4_t *)(a1 + 16);
    *(float *)v40.i32 = -*(float *)&v33.i32[3];
    int32x4_t v41 = *(int32x4_t *)(a1 + 48);
    *(float *)v41.i32 = -*(float *)&v34.i32[3];
    float32x4_t v42 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v41, (int8x16_t)v41, 0xCuLL), (int8x16_t)v41, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v40, v40), (int8x16_t)v40, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v41, v41), (int8x16_t)v41, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v40, (int8x16_t)v40, 0xCuLL), (int8x16_t)v40, 8uLL));
    float32x4_t v43 = v2;
    v43.f32[1] = -v2.f32[3];
    int32x4_t v44 = *(int32x4_t *)(a1 + 16);
    *(float *)&v44.i32[1] = -*(float *)&v33.i32[3];
    int32x4_t v45 = *(int32x4_t *)(a1 + 48);
    *(float *)&v45.i32[1] = -*(float *)&v34.i32[3];
    int32x4_t v46 = (int32x4_t)vmulq_f32(v39, v42);
    int32x4_t v47 = (int32x4_t)vmulq_f32(v43, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v45, (int8x16_t)v45, 0xCuLL), (int8x16_t)v45, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v44, v44), (int8x16_t)v44, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v45, v45), (int8x16_t)v45, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v44, (int8x16_t)v44, 0xCuLL), (int8x16_t)v44, 8uLL)));
    *(float32x2_t *)v43.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v46.i8, *(int32x2_t *)v47.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v46.i8, *(int32x2_t *)v47.i8));
    float32x4_t v48 = (float32x4_t)vzip2q_s32(v46, v47);
    *(float32x2_t *)v48.f32 = vadd_f32(*(float32x2_t *)v48.f32, *(float32x2_t *)v43.f32);
    v2.f32[2] = -v2.f32[3];
    *(float *)&v33.i32[2] = -*(float *)&v33.i32[3];
    *(float *)&v34.i32[2] = -*(float *)&v34.i32[3];
    float32x4_t v49 = vmulq_f32(v2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v34, (int8x16_t)v34, 0xCuLL), (int8x16_t)v34, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v33, v33), (int8x16_t)v33, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v34, v34), (int8x16_t)v34, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v33, (int8x16_t)v33, 0xCuLL), (int8x16_t)v33, 8uLL)));
    v48.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).u32[0];
    a2[2] = vdivq_f32(v48, (float32x4_t)vdupq_lane_s32(v38, 0));
    float32x4_t v2 = *(float32x4_t *)(a1 + 80);
    int32x4_t v34 = *(int32x4_t *)(a1 + 48);
    float32x4_t v36 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v34, (int8x16_t)v34, 0xCuLL), (int8x16_t)v34, 8uLL);
    float32x4_t v35 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v34, v34), (int8x16_t)v34, 0xCuLL);
  }
  int32x4_t v50 = *(int32x4_t *)a1;
  float32x4_t v51 = vmulq_f32(v2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v50, (int8x16_t)v50, 0xCuLL), *(int8x16_t *)a1, 8uLL), vnegq_f32(v35)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v50, v50), *(int8x16_t *)a1, 0xCuLL), v36));
  int32x2_t v52 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v51, 2), vaddq_f32(v51, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v51.f32, 1))).u64[0];
  if (*(float *)v52.i32 != 0.0)
  {
    float32x4_t v53 = v2;
    v53.f32[0] = -v2.f32[3];
    int32x4_t v54 = v34;
    *(float *)v54.i32 = -*(float *)&v34.i32[3];
    int32x4_t v55 = *(int32x4_t *)a1;
    *(float *)v55.i32 = -*(float *)&v50.i32[3];
    float32x4_t v56 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v55, (int8x16_t)v55, 0xCuLL), (int8x16_t)v55, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v54, v54), (int8x16_t)v54, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v55, v55), (int8x16_t)v55, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v54, (int8x16_t)v54, 0xCuLL), (int8x16_t)v54, 8uLL));
    float32x4_t v57 = v2;
    v57.f32[1] = -v2.f32[3];
    int32x4_t v58 = v34;
    *(float *)&v58.i32[1] = -*(float *)&v34.i32[3];
    int32x4_t v59 = *(int32x4_t *)a1;
    *(float *)&v59.i32[1] = -*(float *)&v50.i32[3];
    int32x4_t v60 = (int32x4_t)vmulq_f32(v53, v56);
    int32x4_t v61 = (int32x4_t)vmulq_f32(v57, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v59, (int8x16_t)v59, 0xCuLL), (int8x16_t)v59, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v58, v58), (int8x16_t)v58, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v59, v59), (int8x16_t)v59, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v58, (int8x16_t)v58, 0xCuLL), (int8x16_t)v58, 8uLL)));
    *(float32x2_t *)v57.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v60.i8, *(int32x2_t *)v61.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v60.i8, *(int32x2_t *)v61.i8));
    float32x4_t v62 = (float32x4_t)vzip2q_s32(v60, v61);
    *(float32x2_t *)v62.f32 = vadd_f32(*(float32x2_t *)v62.f32, *(float32x2_t *)v57.f32);
    v2.f32[2] = -v2.f32[3];
    *(float *)&v34.i32[2] = -*(float *)&v34.i32[3];
    *(float *)&v50.i32[2] = -*(float *)&v50.i32[3];
    float32x4_t v63 = vmulq_f32(v2, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v50, (int8x16_t)v50, 0xCuLL), (int8x16_t)v50, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v34, v34), (int8x16_t)v34, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v50, v50), (int8x16_t)v50, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v34, (int8x16_t)v34, 0xCuLL), (int8x16_t)v34, 8uLL)));
    v62.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v63, 2), vaddq_f32(v63, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v63.f32, 1))).u32[0];
    a2[3] = vdivq_f32(v62, (float32x4_t)vdupq_lane_s32(v52, 0));
  }
  float32x4_t result = *(float32x4_t *)(a1 + 64);
  int32x4_t v66 = *(int32x4_t *)(a1 + 16);
  int32x4_t v65 = *(int32x4_t *)(a1 + 32);
  float32x4_t v67 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v65, (int8x16_t)v65, 0xCuLL), (int8x16_t)v65, 8uLL);
  float32x4_t v68 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v65, v65), (int8x16_t)v65, 0xCuLL);
  float32x4_t v69 = vmulq_f32(result, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v66, (int8x16_t)v66, 0xCuLL), (int8x16_t)v66, 8uLL), vnegq_f32(v68)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v66, v66), (int8x16_t)v66, 0xCuLL), v67));
  int32x2_t v70 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v69, 2), vaddq_f32(v69, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v69.f32, 1))).u64[0];
  if (*(float *)v70.i32 != 0.0)
  {
    float32x4_t v71 = *(float32x4_t *)(a1 + 64);
    v71.f32[0] = -result.f32[3];
    int32x4_t v72 = *(int32x4_t *)(a1 + 32);
    *(float *)v72.i32 = -*(float *)&v65.i32[3];
    int32x4_t v73 = *(int32x4_t *)(a1 + 16);
    *(float *)v73.i32 = -*(float *)&v66.i32[3];
    float32x4_t v74 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v73, (int8x16_t)v73, 0xCuLL), (int8x16_t)v73, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v72, v72), (int8x16_t)v72, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v73, v73), (int8x16_t)v73, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v72, (int8x16_t)v72, 0xCuLL), (int8x16_t)v72, 8uLL));
    float32x4_t v75 = *(float32x4_t *)(a1 + 64);
    v75.f32[1] = -result.f32[3];
    int32x4_t v76 = *(int32x4_t *)(a1 + 32);
    *(float *)&v76.i32[1] = -*(float *)&v65.i32[3];
    int32x4_t v77 = *(int32x4_t *)(a1 + 16);
    *(float *)&v77.i32[1] = -*(float *)&v66.i32[3];
    int32x4_t v78 = (int32x4_t)vmulq_f32(v71, v74);
    int32x4_t v79 = (int32x4_t)vmulq_f32(v75, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v77, (int8x16_t)v77, 0xCuLL), (int8x16_t)v77, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v76, v76), (int8x16_t)v76, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v77, v77), (int8x16_t)v77, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v76, (int8x16_t)v76, 0xCuLL), (int8x16_t)v76, 8uLL)));
    *(float32x2_t *)v75.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v78.i8, *(int32x2_t *)v79.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v78.i8, *(int32x2_t *)v79.i8));
    float32x4_t v80 = (float32x4_t)vzip2q_s32(v78, v79);
    *(float32x2_t *)v80.f32 = vadd_f32(*(float32x2_t *)v80.f32, *(float32x2_t *)v75.f32);
    result.f32[2] = -result.f32[3];
    *(float *)&v65.i32[2] = -*(float *)&v65.i32[3];
    *(float *)&v66.i32[2] = -*(float *)&v66.i32[3];
    float32x4_t v81 = vmulq_f32(result, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v66, (int8x16_t)v66, 0xCuLL), (int8x16_t)v66, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v65, v65), (int8x16_t)v65, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v66, v66), (int8x16_t)v66, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v65, (int8x16_t)v65, 0xCuLL), (int8x16_t)v65, 8uLL)));
    v80.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v81, 2), vaddq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 1))).u32[0];
    a2[4] = vdivq_f32(v80, (float32x4_t)vdupq_lane_s32(v70, 0));
    float32x4_t result = *(float32x4_t *)(a1 + 64);
    int32x4_t v65 = *(int32x4_t *)(a1 + 32);
    float32x4_t v68 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v65, v65), (int8x16_t)v65, 0xCuLL);
    float32x4_t v67 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v65, (int8x16_t)v65, 0xCuLL), (int8x16_t)v65, 8uLL);
  }
  int32x4_t v82 = *(int32x4_t *)a1;
  float32x4_t v83 = vmulq_f32(result, vmlaq_f32(vmulq_f32(v67, vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v82, v82), *(int8x16_t *)a1, 0xCuLL))), v68, (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v82, (int8x16_t)v82, 0xCuLL), *(int8x16_t *)a1, 8uLL)));
  int32x2_t v84 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v83, 2), vaddq_f32(v83, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v83.f32, 1))).u64[0];
  if (*(float *)v84.i32 != 0.0)
  {
    float32x4_t v85 = result;
    v85.f32[0] = -result.f32[3];
    int32x4_t v86 = *(int32x4_t *)a1;
    *(float *)v86.i32 = -*(float *)&v82.i32[3];
    int32x4_t v87 = v65;
    *(float *)v87.i32 = -*(float *)&v65.i32[3];
    int32x4_t v88 = (int32x4_t)vmulq_f32(v85, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v87, (int8x16_t)v87, 0xCuLL), (int8x16_t)v87, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v86, v86), (int8x16_t)v86, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v87, v87), (int8x16_t)v87, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v86, (int8x16_t)v86, 0xCuLL), (int8x16_t)v86, 8uLL)));
    float32x4_t v89 = result;
    v89.f32[1] = -result.f32[3];
    int32x4_t v90 = *(int32x4_t *)a1;
    *(float *)&v90.i32[1] = -*(float *)&v82.i32[3];
    int32x4_t v91 = v65;
    *(float *)&v91.i32[1] = -*(float *)&v65.i32[3];
    int32x4_t v92 = (int32x4_t)vmulq_f32(v89, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v91, (int8x16_t)v91, 0xCuLL), (int8x16_t)v91, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v90, v90), (int8x16_t)v90, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v91, v91), (int8x16_t)v91, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v90, (int8x16_t)v90, 0xCuLL), (int8x16_t)v90, 8uLL)));
    *(float32x2_t *)v90.i8 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v88.i8, *(int32x2_t *)v92.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v88.i8, *(int32x2_t *)v92.i8));
    float32x4_t v93 = (float32x4_t)vzip2q_s32(v88, v92);
    *(float32x2_t *)v93.f32 = vadd_f32(*(float32x2_t *)v93.f32, *(float32x2_t *)v90.i8);
    result.f32[2] = -result.f32[3];
    *(float *)&v82.i32[2] = -*(float *)&v82.i32[3];
    *(float *)&v65.i32[2] = -*(float *)&v65.i32[3];
    float32x4_t v94 = vmulq_f32(result, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v65, (int8x16_t)v65, 0xCuLL), (int8x16_t)v65, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v82, v82), (int8x16_t)v82, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v65, v65), (int8x16_t)v65, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v82, (int8x16_t)v82, 0xCuLL), (int8x16_t)v82, 8uLL)));
    v93.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 2), vaddq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v94.f32, 1))).u32[0];
    a2[5] = vdivq_f32(v93, (float32x4_t)vdupq_lane_s32(v84, 0));
    float32x4_t result = *(float32x4_t *)(a1 + 64);
  }
  int32x4_t v95 = *(int32x4_t *)(a1 + 16);
  int32x4_t v96 = *(int32x4_t *)(a1 + 48);
  float32x4_t v97 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v96, v96), (int8x16_t)v96, 0xCuLL);
  float32x4_t v98 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v96, (int8x16_t)v96, 0xCuLL), (int8x16_t)v96, 8uLL);
  float32x4_t v99 = vmulq_f32(result, vmlaq_f32(vmulq_f32(v98, vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v95, v95), (int8x16_t)v95, 0xCuLL))), v97, (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v95, (int8x16_t)v95, 0xCuLL), (int8x16_t)v95, 8uLL)));
  int32x2_t v100 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v99, 2), vaddq_f32(v99, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v99.f32, 1))).u64[0];
  if (*(float *)v100.i32 != 0.0)
  {
    float32x4_t v101 = result;
    v101.f32[0] = -result.f32[3];
    int32x4_t v102 = *(int32x4_t *)(a1 + 16);
    *(float *)v102.i32 = -*(float *)&v95.i32[3];
    int32x4_t v103 = *(int32x4_t *)(a1 + 48);
    *(float *)v103.i32 = -*(float *)&v96.i32[3];
    float32x4_t v104 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v103, (int8x16_t)v103, 0xCuLL), (int8x16_t)v103, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v102, v102), (int8x16_t)v102, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v103, v103), (int8x16_t)v103, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v102, (int8x16_t)v102, 0xCuLL), (int8x16_t)v102, 8uLL));
    float32x4_t v105 = result;
    v105.f32[1] = -result.f32[3];
    int32x4_t v106 = *(int32x4_t *)(a1 + 16);
    *(float *)&v106.i32[1] = -*(float *)&v95.i32[3];
    int32x4_t v107 = *(int32x4_t *)(a1 + 48);
    *(float *)&v107.i32[1] = -*(float *)&v96.i32[3];
    int32x4_t v108 = (int32x4_t)vmulq_f32(v101, v104);
    int32x4_t v109 = (int32x4_t)vmulq_f32(v105, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v107, (int8x16_t)v107, 0xCuLL), (int8x16_t)v107, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v106, v106), (int8x16_t)v106, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v107, v107), (int8x16_t)v107, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v106, (int8x16_t)v106, 0xCuLL), (int8x16_t)v106, 8uLL)));
    *(float32x2_t *)v105.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v108.i8, *(int32x2_t *)v109.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v108.i8, *(int32x2_t *)v109.i8));
    float32x4_t v110 = (float32x4_t)vzip2q_s32(v108, v109);
    *(float32x2_t *)v110.f32 = vadd_f32(*(float32x2_t *)v110.f32, *(float32x2_t *)v105.f32);
    result.f32[2] = -result.f32[3];
    *(float *)&v95.i32[2] = -*(float *)&v95.i32[3];
    *(float *)&v96.i32[2] = -*(float *)&v96.i32[3];
    float32x4_t v111 = vmulq_f32(result, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v96, (int8x16_t)v96, 0xCuLL), (int8x16_t)v96, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v95, v95), (int8x16_t)v95, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v96, v96), (int8x16_t)v96, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v95, (int8x16_t)v95, 0xCuLL), (int8x16_t)v95, 8uLL)));
    v110.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v111, 2), vaddq_f32(v111, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v111.f32, 1))).u32[0];
    a2[6] = vdivq_f32(v110, (float32x4_t)vdupq_lane_s32(v100, 0));
    int32x4_t v96 = *(int32x4_t *)(a1 + 48);
    float32x4_t result = *(float32x4_t *)(a1 + 64);
    float32x4_t v98 = (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v96, (int8x16_t)v96, 0xCuLL), (int8x16_t)v96, 8uLL);
    float32x4_t v97 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v96, v96), (int8x16_t)v96, 0xCuLL);
  }
  int32x4_t v112 = *(int32x4_t *)a1;
  float32x4_t v113 = vmulq_f32(result, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v112, (int8x16_t)v112, 0xCuLL), *(int8x16_t *)a1, 8uLL), vnegq_f32(v97)), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v112, v112), *(int8x16_t *)a1, 0xCuLL), v98));
  int32x2_t v114 = (int32x2_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v113, 2), vaddq_f32(v113, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v113.f32, 1))).u64[0];
  if (*(float *)v114.i32 != 0.0)
  {
    float32x4_t v115 = result;
    v115.f32[0] = -result.f32[3];
    int32x4_t v116 = v96;
    *(float *)v116.i32 = -*(float *)&v96.i32[3];
    int32x4_t v117 = *(int32x4_t *)a1;
    *(float *)v117.i32 = -*(float *)&v112.i32[3];
    float32x4_t v118 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v117, (int8x16_t)v117, 0xCuLL), (int8x16_t)v117, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v116, v116), (int8x16_t)v116, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v117, v117), (int8x16_t)v117, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v116, (int8x16_t)v116, 0xCuLL), (int8x16_t)v116, 8uLL));
    float32x4_t v119 = result;
    v119.f32[1] = -result.f32[3];
    int32x4_t v120 = v96;
    *(float *)&v120.i32[1] = -*(float *)&v96.i32[3];
    int32x4_t v121 = *(int32x4_t *)a1;
    *(float *)&v121.i32[1] = -*(float *)&v112.i32[3];
    int32x4_t v122 = (int32x4_t)vmulq_f32(v115, v118);
    int32x4_t v123 = (int32x4_t)vmulq_f32(v119, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v121, (int8x16_t)v121, 0xCuLL), (int8x16_t)v121, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v120, v120), (int8x16_t)v120, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v121, v121), (int8x16_t)v121, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v120, (int8x16_t)v120, 0xCuLL), (int8x16_t)v120, 8uLL)));
    *(float32x2_t *)v119.f32 = vadd_f32((float32x2_t)vzip1_s32(*(int32x2_t *)v122.i8, *(int32x2_t *)v123.i8), (float32x2_t)vzip2_s32(*(int32x2_t *)v122.i8, *(int32x2_t *)v123.i8));
    float32x4_t v124 = (float32x4_t)vzip2q_s32(v122, v123);
    *(float32x2_t *)v124.f32 = vadd_f32(*(float32x2_t *)v124.f32, *(float32x2_t *)v119.f32);
    result.f32[2] = -result.f32[3];
    *(float *)&v96.i32[2] = -*(float *)&v96.i32[3];
    *(float *)&v112.i32[2] = -*(float *)&v112.i32[3];
    float32x4_t v125 = vmulq_f32(result, vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8(vextq_s8((int8x16_t)v112, (int8x16_t)v112, 0xCuLL), (int8x16_t)v112, 8uLL), vnegq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v96, v96), (int8x16_t)v96, 0xCuLL))), (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v112, v112), (int8x16_t)v112, 0xCuLL), (float32x4_t)vextq_s8(vextq_s8((int8x16_t)v96, (int8x16_t)v96, 0xCuLL), (int8x16_t)v96, 8uLL)));
    v124.i32[2] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v125, 2), vaddq_f32(v125, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v125.f32, 1))).u32[0];
    float32x4_t result = vdivq_f32(v124, (float32x4_t)vdupq_lane_s32(v114, 0));
    a2[7] = result;
  }
  return result;
}

void sub_1B640164C(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1F4188790](a1, a2);
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v205 = v8;
  uint64_t v10 = v9;
  uint64_t v230 = *MEMORY[0x1E4F143B8];
  char v212 = (uint64_t *)sub_1B6446254(v6, 0, v6, v4, v2, v11, v12, v13);
  if (!v212 || !*(void *)(v3 + 24)) {
    return;
  }
  uint64_t v200 = v5;
  int v201 = (uint64_t *)v7;
  uint64_t v207 = (void *)sub_1B6445900(v7, v14, v15, v16, v17, v18, v19, v20);
  uint64_t v206 = objc_msgSend_resourceManager(v207, v21, v22, v23);
  unsigned int v27 = objc_msgSend_width(*(void **)(v3 + 24), v24, v25, v26);
  unsigned int v31 = objc_msgSend_height(*(void **)(v3 + 24), v28, v29, v30);
  unsigned int v35 = objc_msgSend_depth(*(void **)(v3 + 24), v32, v33, v34);
  uint64_t v43 = 0;
  float32x4_t v199 = *(float32x4_t *)(v3 + 48);
  unsigned int v202 = v35;
  int32x4_t v44 = (uint64_t *)(v3 + 88);
  unsigned int v211 = v31;
  do
  {
    int32x4_t v45 = v44;
    if (v43 != 1)
    {
      if (v43 != 3) {
        goto LABEL_23;
      }
      int32x4_t v45 = (uint64_t *)(v3 + 96);
    }
    uint64_t v46 = *v45;
    int v209 = (__int16)WORD2(*v45);
    if (v209 >= 1)
    {
      uint64_t v47 = v10 + 8 * v43;
      if (*(void *)(v47 + 128)) {
        goto LABEL_14;
      }
      if (v43 == 3)
      {
        __int16 v203 = *v45;
        uint64_t v48 = sub_1B65233C8(0, 12, 1, 0.0, 1.0, 1.0);
      }
      else
      {
        if (v43 != 1) {
          goto LABEL_14;
        }
        __int16 v203 = *v45;
        uint64_t v48 = sub_1B6522AAC(0, 12, 1, 1.0, 1.0);
      }
      *(void *)(v47 + 12_Block_object_dispose(&STACK[0x5A0], 8) = v48;
      LOWORD(v46) = v203;
LABEL_14:
      if (!*(void *)(v47 + 72))
      {
        if (v43 == 1)
        {
          __int16 v204 = v46;
          float32x4_t v49 = @"debug_omni_vert";
          goto LABEL_19;
        }
        if (v43 == 3)
        {
          __int16 v204 = v46;
          float32x4_t v49 = @"debug_spot_vert";
LABEL_19:
          *(void *)(v47 + 72) = sub_1B6450670(v49, @"debug_light_frag");
          LOWORD(v46) = v204;
        }
      }
      __int16 v50 = v46;
      float32x4_t v51 = sub_1B653C844((uint64_t)v206, *(void *)(v47 + 128), 1);
      uint64_t v52 = *(void *)(v47 + 72);
      uint64_t v53 = sub_1B64E35DC();
      long long v217 = 0u;
      long long v218 = 0u;
      uint64_t v216 = v52;
      double v219 = v51;
      uint64_t v220 = v53;
      uint64_t v221 = 0;
      int v222 = 16777231;
      long long v223 = 0u;
      long long v224 = 0u;
      int v225 = 0;
      uint64_t v57 = objc_msgSend_currentRenderPassDescriptor(v207, v54, v55, v56);
      int32x4_t v59 = objc_msgSend_renderResourceForProgramDesc_renderPassDescriptor_(v206, v58, (uint64_t)&v216, v57);
      uint64_t v63 = objc_msgSend_state(v59, v60, v61, v62);
      objc_msgSend_setRenderPipelineState_(*(void **)(v205 + 16), v64, v63, v65);
      objc_msgSend__setWorldBufferAtVertexIndex_fragmentIndex_(v207, v66, 0, -1);
      objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v205 + 16), v67, *(void *)(v3 + 120), *(void *)(v3 + 128) + 368 * v50, 1);
      CFArrayRef v74 = (const __CFArray *)sub_1B64AD3C4(*(void *)(v47 + 128), 1, v68, v69, v70, v71, v72, v73);
      unsigned int v31 = v211;
      int32x4_t v44 = (uint64_t *)(v3 + 88);
      if (v74)
      {
        ValueAtIndesimd_float4 x = CFArrayGetValueAtIndex(v74, 0);
        if (ValueAtIndex)
        {
          int32x4_t v76 = sub_1B653C040((uint64_t)v206, (uint64_t)ValueAtIndex);
          objc_msgSend__setMeshBuffers_(v207, v77, (uint64_t)v51, v78);
          unsigned int v31 = v211;
          objc_msgSend__drawMeshElement_instanceCount_(v207, v79, (uint64_t)v76, (unsigned __int16)v209);
        }
      }
    }
LABEL_23:
    ++v43;
  }
  while (v43 != 7);
  float32x4_t v80 = (const void *)sub_1B6446740((uint64_t)v201, v36, v37, v38, v39, v40, v41, v42);
  if (!v80 || v80 == sub_1B6446564(v201, (uint64_t)v81, v82, v83, v84, v85, v86, v87))
  {
    int32x4_t v112 = *(void **)(v10 + 48);
    if (!v112
      || (uint64_t v113 = objc_msgSend_currentRenderPassDescriptor(v207, v81, v82, v83),
          (objc_msgSend_matchesRenderPassDescriptor_(v112, v114, v113, v115) & 1) == 0))
    {
      float32x4_t v119 = (void *)sub_1B653EFAC((uint64_t)v206);
      uint64_t v123 = objc_msgSend_frameworkLibrary(v119, v120, v121, v122);
      memset(&__src[7], 0, 216);
      memset(__src, 0, 104);
      __src[6].i64[1] = v123;
      __src[12].i64[1] = sub_1B64E35DC();
      __src[18].i64[1] = @"vfx_draw_fullscreen_quad_vertex";
      __src[19].i64[0] = @"debug_cluster_frag";
      float32x4_t v127 = objc_msgSend_currentRenderPassDescriptor(v207, v124, v125, v126);
      sub_1B659B6B0((uint64_t)&__src[7], v127, v128, v129);

      memcpy(__dst, __src, sizeof(__dst));
      *(void *)(v10 + 4_Block_object_dispose(&STACK[0x5A0], 8) = objc_msgSend_newRenderPipelineStateWithDesc_(v206, v130, (uint64_t)__dst, v131);
    }
    uint64_t v132 = *(void **)(v10 + 56);
    if (!v132
      || (uint64_t v133 = objc_msgSend_currentRenderPassDescriptor(v207, v116, v117, v118),
          (objc_msgSend_matchesRenderPassDescriptor_(v132, v134, v133, v135) & 1) == 0))
    {
      int v136 = (void *)sub_1B653EFAC((uint64_t)v206);
      uint64_t v140 = objc_msgSend_frameworkLibrary(v136, v137, v138, v139);
      memset(&__src[7], 0, 216);
      memset(__src, 0, 104);
      __src[6].i64[1] = v140;
      __src[12].i64[1] = sub_1B64E35DC();
      __src[18].i64[1] = @"vfx_draw_fullscreen_quad_VR_pos_vertex";
      __src[19].i64[0] = @"debug_light_indices_8_buffer_frag";
      unsigned int v144 = objc_msgSend_currentRenderPassDescriptor(v207, v141, v142, v143);
      sub_1B659B6B0((uint64_t)&__src[7], v144, v145, v146);

      memcpy(v214, __src, sizeof(v214));
      *(void *)(v10 + 56) = objc_msgSend_newRenderPipelineStateWithDesc_(v206, v147, (uint64_t)v214, v148);
    }
    uint64_t v149 = sub_1B653EE3C((uint64_t)v206);
    objc_msgSend_setDepthStencilState_(*(void **)(v205 + 16), v150, v149, v151);
    float v155 = *(void **)(v10 + 64);
    if (!v155
      || (uint64_t v156 = objc_msgSend_currentRenderPassDescriptor(v207, v152, v153, v154),
          (objc_msgSend_matchesRenderPassDescriptor_(v155, v157, v156, v158) & 1) == 0))
    {
      float v162 = (void *)sub_1B653EFAC((uint64_t)v206);
      uint64_t v166 = objc_msgSend_frameworkLibrary(v162, v163, v164, v165);
      memset(&__src[7], 0, 216);
      memset(__src, 0, 104);
      __src[6].i64[1] = v166;
      __src[12].i64[1] = sub_1B64E35DC();
      __src[18].i64[1] = @"vfx_draw_fullscreen_quad_VR_pos_vertex";
      __src[19].i64[0] = @"debug_cluster_slices_frag";
      unint64_t v170 = objc_msgSend_currentRenderPassDescriptor(v207, v167, v168, v169);
      sub_1B659B6B0((uint64_t)&__src[7], v170, v171, v172);

      memcpy(v213, __src, sizeof(v213));
      *(void *)(v10 + 64) = objc_msgSend_newRenderPipelineStateWithDesc_(v206, v173, (uint64_t)v213, v174);
    }
    if (objc_msgSend_state(*(void **)(v10 + 48), v159, v160, v161, *(_OWORD *)&v199, v200))
    {
      uint64_t v178 = objc_msgSend_state(*(void **)(v10 + 48), v175, v176, v177);
      objc_msgSend_setRenderPipelineState_(*(void **)(v205 + 16), v179, v178, v180);
      sub_1B63C6ED0(v205, *(void **)(v3 + 24), 0, v181);
      objc_msgSend__setWorldBufferAtVertexIndex_fragmentIndex_(v207, v182, -1, 0);
      memset(__src, 0, 24);
      sub_1B649F334(*(void *)(v205 + 24), (const void *)(v3 + 80), 8uLL, (void **)__src);
      objc_msgSend_setFragmentBuffer_offset_atIndex_(*(void **)(v205 + 16), v183, __src[0].i64[1], __src[1].i64[0], 1);
      objc_msgSend_drawPrimitives_vertexStart_vertexCount_(*(void **)(v205 + 16), v184, 4, 0, 4);
    }
    if (objc_msgSend_state(*(void **)(v10 + 64), v175, v176, v177))
    {
      uint64_t v188 = objc_msgSend_state(*(void **)(v10 + 64), v185, v186, v187);
      objc_msgSend_setRenderPipelineState_(*(void **)(v205 + 16), v189, v188, v190);
      uint64_t v194 = objc_msgSend_depth(*(void **)(v3 + 24), v191, v192, v193);
      LODWORD(v195) = 0.5;
      *((float *)&v195 + 1) = 0.5 / (float)(unint64_t)v194;
      DWORD2(v195) = 0;
      *((float *)&v195 + 3) = 1.0 - *((float *)&v195 + 1);
      v229[0] = v195;
      memset(__src, 0, 24);
      sub_1B649F334(*(void *)(v205 + 24), v229, 0x10uLL, (void **)__src);
      objc_msgSend_setVertexBuffer_offset_atIndex_(*(void **)(v205 + 16), v196, __src[0].i64[1], __src[1].i64[0], 0);
      sub_1B63C6ED0(v205, *(void **)(v3 + 24), 0, v197);
      objc_msgSend_drawPrimitives_vertexStart_vertexCount_(*(void **)(v205 + 16), v198, 4, 0, 4);
    }
  }
  else
  {
    _OWORD v229[6] = xmmword_1B6E50180;
    v229[7] = *(_OWORD *)"fff?333?";
    v229[8] = xmmword_1B6E501A0;
    v229[2] = xmmword_1B6E50140;
    v229[3] = unk_1B6E50150;
    v229[4] = xmmword_1B6E50160;
    v229[5] = unk_1B6E50170;
    v229[0] = *(_OWORD *)"333?333?333?";
    v229[1] = unk_1B6E50130;
    sub_1B6400AF4(v200, v228);
    float32x4_t v88 = v199;
    __src[1] = v199;
    unsigned int v89 = v202;
    if (v202)
    {
      int v210 = 0;
      unsigned __int32 v90 = 0;
      int v91 = *(_DWORD *)(v3 + 108);
      uint64_t v92 = *(void *)v3;
      int v208 = v31 * v27;
      do
      {
        unsigned int v93 = v89;
        unsigned int v94 = *(_DWORD *)(v10 + 40);
        if ((v94 == v90 || v94 >= v93) && v31 != 0)
        {
          unsigned int v97 = 0;
          int v98 = v210;
          do
          {
            unsigned int v99 = *(_DWORD *)(v10 + 36);
            if ((v99 == v97 || v99 >= v31) && v27 != 0)
            {
              unsigned int v102 = 0;
              do
              {
                unsigned int v103 = *(_DWORD *)(v10 + 32);
                if (v103 >= v27 || v102 == v103)
                {
                  uint64_t v105 = v98 + v102;
                  float32x4_t v88 = sub_1B63FF16C(__src, v102, v97, v90, v226, (uint32x4_t)v88);
                  if (v91)
                  {
                    v88.i64[0] = *(void *)(v92 + 8 * v105);
                  }
                  else
                  {
                    float32x4_t v110 = (__int16 *)(v92 + 4 * v105);
                    v88.i16[3] = 0;
                    v88.i64[1] = 0;
                    v88.i16[0] = *v110;
                    *(__int32 *)((char *)v88.i32 + 2) = (unsigned __int16)v110[1];
                  }
                  unsigned int v111 = v88.u8[3];
                  if (v88.u8[2] > ((unsigned __int16)(v88.i16[1] & 0xFF00) >> 8)) {
                    unsigned int v111 = v88.u8[2];
                  }
                  if (v111 >= 8) {
                    unsigned int v111 = 8;
                  }
                  if (v111) {
                    sub_1B642C6B4(v212, (uint64_t)v226, 0, (float *)&v229[v111], v106, v107, v108, v109);
                  }
                }
                ++v102;
              }
              while (v27 != v102);
            }
            ++v97;
            v98 += v27;
            unsigned int v31 = v211;
          }
          while (v97 != v211);
        }
        ++v90;
        v210 += v208;
        unsigned int v89 = v202;
      }
      while (v90 != v202);
    }
  }
}

uint64_t sub_1B6401F20(uint64_t result, __int16 *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v10 = (__int16 *)result;
LABEL_2:
  uint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v22 = *(a2 - 1);
          uint64_t v23 = *v11;
          if (*(float *)(*a3 + 4 * v22) > *(float *)(*a3 + 4 * v23))
          {
            *uint64_t v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          float32x4_t result = sub_1B64023FC(v11, v11 + 1, a2 - 1, a3);
          break;
        case 4uLL:
          float32x4_t result = sub_1B6402838(v11, v11 + 1, v11 + 2, a2 - 1, a3);
          break;
        case 5uLL:
          float32x4_t result = sub_1B64028FC(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 47) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)sub_1B64029EC(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x101)
    {
      sub_1B64023FC(v11, &v11[v15 >> 1], a2 - 1, a3);
      sub_1B64023FC(v11 + 1, v17 - 1, a2 - 2, a3);
      sub_1B64023FC(v11 + 2, &v11[v16 + 1], a2 - 3, a3);
      sub_1B64023FC(v17 - 1, v17, &v11[v16 + 1], a3);
      __int16 v18 = *v11;
      *uint64_t v11 = *v17;
      *uint64_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      sub_1B64023FC(&v11[v15 >> 1], v11, a2 - 1, a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(float *)(*a3 + 4 * *(v11 - 1)) <= *(float *)(*a3 + 4 * *v11))
    {
      float32x4_t result = (uint64_t)sub_1B64024B8(v11, a2, a3);
      uint64_t v11 = (__int16 *)result;
      goto LABEL_19;
    }
LABEL_14:
    uint64_t v19 = sub_1B6402594(v11, a2, a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = sub_1B6402674(v11, v19, a3);
    uint64_t v11 = v19 + 1;
    float32x4_t result = sub_1B6402674(v19 + 1, a2, a3);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      float32x4_t result = sub_1B6401F20(v10, v19, a3, -v13, a5 & 1);
      uint64_t v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)sub_1B64022F8(v11, a2, a3);
  }
  else
  {
    return (uint64_t)sub_1B640238C(v11, a2, a3);
  }
}

__int16 *sub_1B64022F8(__int16 *result, __int16 *a2, uint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = 0;
      uint64_t v5 = *a3;
      char v6 = result;
      do
      {
        uint64_t v7 = v6[1];
        uint64_t v8 = *v6;
        char v6 = v3;
        float v9 = *(float *)(v5 + 4 * v7);
        if (v9 > *(float *)(v5 + 4 * v8))
        {
          __int16 v10 = v7;
          __int16 v11 = v8;
          uint64_t v12 = v4;
          while (1)
          {
            *(__int16 *)((char *)result + v12 + 2) = v11;
            if (!v12) {
              break;
            }
            __int16 v11 = *(__int16 *)((char *)result + v12 - 2);
            v12 -= 2;
            if (v9 <= *(float *)(v5 + 4 * v11))
            {
              uint64_t v13 = (__int16 *)((char *)result + v12 + 2);
              goto LABEL_10;
            }
          }
          uint64_t v13 = result;
LABEL_10:
          *uint64_t v13 = v10;
        }
        uint64_t v3 = v6 + 1;
        v4 += 2;
      }
      while (v6 + 1 != a2);
    }
  }
  return result;
}

__int16 *sub_1B640238C(__int16 *result, __int16 *a2, uint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = *a3;
      do
      {
        uint64_t v5 = result[1];
        uint64_t v6 = *result;
        float32x4_t result = v3;
        float v7 = *(float *)(v4 + 4 * v5);
        if (v7 > *(float *)(v4 + 4 * v6))
        {
          __int16 v8 = v5;
          __int16 v9 = v6;
          __int16 v10 = result;
          do
          {
            *__int16 v10 = v9;
            __int16 v9 = *(v10 - 2);
            --v10;
          }
          while (v7 > *(float *)(v4 + 4 * v9));
          *__int16 v10 = v8;
        }
        uint64_t v3 = result + 1;
      }
      while (result + 1 != a2);
    }
  }
  return result;
}

uint64_t sub_1B64023FC(__int16 *a1, __int16 *a2, __int16 *a3, uint64_t *a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *a4;
  float v6 = *(float *)(*a4 + 4 * *a2);
  float v7 = *(float *)(*a4 + 4 * v4);
  __int16 v8 = *a2;
  __int16 v9 = *a3;
  float v10 = *(float *)(*a4 + 4 * *a3);
  if (v6 > v7)
  {
    if (v10 > v6)
    {
      *a1 = v9;
      *a3 = v4;
      return 1;
    }
    *a1 = v8;
    *a2 = v4;
    uint64_t v13 = *a3;
    if (*(float *)(v5 + 4 * v13) <= v7) {
      return 1;
    }
    *a2 = v13;
    *a3 = v4;
    return 2;
  }
  if (v10 > v6)
  {
    *a2 = v9;
    *a3 = v8;
    uint64_t v11 = *a2;
    uint64_t v12 = *a1;
    if (*(float *)(v5 + 4 * v11) <= *(float *)(v5 + 4 * v12)) {
      return 1;
    }
    *a1 = v11;
    *a2 = v12;
    return 2;
  }
  return 0;
}

__int16 *sub_1B64024B8(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *a3;
  float v5 = *(float *)(*a3 + 4 * v3);
  if (v5 <= *(float *)(*a3 + 4 * *(a2 - 1)))
  {
    __int16 v8 = a1 + 1;
    do
    {
      float v6 = v8;
      if (v8 >= a2) {
        break;
      }
      ++v8;
    }
    while (v5 <= *(float *)(v4 + 4 * *v6));
  }
  else
  {
    float v6 = a1;
    do
    {
      uint64_t v7 = v6[1];
      ++v6;
    }
    while (v5 <= *(float *)(v4 + 4 * v7));
  }
  if (v6 < a2)
  {
    do
      uint64_t v9 = *--a2;
    while (v5 > *(float *)(v4 + 4 * v9));
  }
  if (v6 < a2)
  {
    __int16 v10 = *v6;
    __int16 v11 = *a2;
    do
    {
      *float v6 = v11;
      *a2 = v10;
      do
      {
        uint64_t v12 = v6[1];
        ++v6;
        __int16 v10 = v12;
      }
      while (v5 <= *(float *)(v4 + 4 * v12));
      do
      {
        uint64_t v13 = *--a2;
        __int16 v11 = v13;
      }
      while (v5 > *(float *)(v4 + 4 * v13));
    }
    while (v6 < a2);
  }
  if (v6 - 1 != a1) {
    *a1 = *(v6 - 1);
  }
  *(v6 - 1) = v3;
  return v6;
}

__int16 *sub_1B6402594(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v3 = 0;
  __int16 v4 = *a1;
  uint64_t v5 = *a3;
  float v6 = *(float *)(*a3 + 4 * *a1);
  do
    uint64_t v7 = a1[++v3];
  while (*(float *)(v5 + 4 * v7) > v6);
  __int16 v8 = &a1[v3];
  uint64_t v9 = &a1[v3 - 1];
  if (v3 == 1)
  {
    do
    {
      if (v8 >= a2) {
        break;
      }
      uint64_t v11 = *--a2;
    }
    while (*(float *)(v5 + 4 * v11) <= v6);
  }
  else
  {
    do
      uint64_t v10 = *--a2;
    while (*(float *)(v5 + 4 * v10) <= v6);
  }
  if (v8 < a2)
  {
    __int16 v12 = v7;
    __int16 v13 = *a2;
    uint64_t v14 = v8;
    unint64_t v15 = a2;
    do
    {
      *uint64_t v14 = v13;
      *unint64_t v15 = v12;
      do
      {
        uint64_t v16 = v14[1];
        ++v14;
        __int16 v12 = v16;
      }
      while (*(float *)(v5 + 4 * v16) > v6);
      do
      {
        uint64_t v17 = *--v15;
        __int16 v13 = v17;
      }
      while (*(float *)(v5 + 4 * v17) <= v6);
    }
    while (v14 < v15);
    uint64_t v9 = v14 - 1;
  }
  if (v9 != a1) {
    *a1 = *v9;
  }
  *uint64_t v9 = v4;
  return v9;
}

BOOL sub_1B6402674(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(float *)(*a3 + 4 * v8) > *(float *)(*a3 + 4 * v9))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      sub_1B64023FC(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_1B6402838(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      sub_1B64028FC(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      sub_1B64023FC(a1, a1 + 1, a1 + 2, a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = *a3;
      uint64_t v14 = 6;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v11;
    float v16 = *(float *)(v13 + 4 * v15);
    if (v16 > *(float *)(v13 + 4 * *v10))
    {
      __int16 v17 = *v10;
      uint64_t v18 = v14;
      while (1)
      {
        *(__int16 *)((char *)a1 + v1_Block_object_dispose(&STACK[0x5A0], 8) = v17;
        uint64_t v19 = v18 - 2;
        if (v18 == 2) {
          break;
        }
        uint64_t v20 = *(__int16 *)((char *)a1 + v18 - 4);
        __int16 v17 = v20;
        float v21 = *(float *)(v13 + 4 * v20);
        uint64_t v18 = v19;
        if (v16 <= v21)
        {
          uint64_t v22 = (__int16 *)((char *)a1 + v19);
          goto LABEL_12;
        }
      }
      uint64_t v22 = a1;
LABEL_12:
      *uint64_t v22 = v15;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v14 += 2;
    if (++v11 == a2) {
      return 1;
    }
  }
}

uint64_t sub_1B6402838(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, uint64_t *a5)
{
  uint64_t result = sub_1B64023FC(a1, a2, a3, a5);
  uint64_t v11 = *a4;
  uint64_t v12 = *a3;
  uint64_t v13 = *a5;
  if (*(float *)(*a5 + 4 * v11) > *(float *)(*a5 + 4 * v12))
  {
    *a3 = v11;
    *a4 = v12;
    uint64_t v14 = *a3;
    uint64_t v15 = *a2;
    if (*(float *)(v13 + 4 * v14) > *(float *)(v13 + 4 * v15))
    {
      *a2 = v14;
      *a3 = v15;
      uint64_t v16 = *a2;
      uint64_t v17 = *a1;
      if (*(float *)(v13 + 4 * v16) > *(float *)(v13 + 4 * v17))
      {
        *a1 = v16;
        *a2 = v17;
      }
    }
  }
  return result;
}

uint64_t sub_1B64028FC(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int16 *a5, uint64_t *a6)
{
  uint64_t result = sub_1B6402838(a1, a2, a3, a4, a6);
  uint64_t v13 = *a5;
  uint64_t v14 = *a4;
  uint64_t v15 = *a6;
  if (*(float *)(*a6 + 4 * v13) > *(float *)(*a6 + 4 * v14))
  {
    *a4 = v13;
    *a5 = v14;
    uint64_t v16 = *a4;
    uint64_t v17 = *a3;
    if (*(float *)(v15 + 4 * v16) > *(float *)(v15 + 4 * v17))
    {
      *a3 = v16;
      *a4 = v17;
      uint64_t v18 = *a3;
      uint64_t v19 = *a2;
      if (*(float *)(v15 + 4 * v18) > *(float *)(v15 + 4 * v19))
      {
        *a2 = v18;
        *a3 = v19;
        uint64_t v20 = *a2;
        uint64_t v21 = *a1;
        if (*(float *)(v15 + 4 * v20) > *(float *)(v15 + 4 * v21))
        {
          *a1 = v20;
          *a2 = v21;
        }
      }
    }
  }
  return result;
}

__int16 *sub_1B64029EC(__int16 *a1, __int16 *a2, __int16 *a3, uint64_t *a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 3)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[v10];
      do
      {
        sub_1B6402B4C((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        uint64_t v15 = *v14;
        uint64_t v16 = *a1;
        if (*(float *)(*a4 + 4 * v15) > *(float *)(*a4 + 4 * v16))
        {
          *uint64_t v14 = v16;
          *a1 = v15;
          sub_1B6402B4C((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = a3;
    }
    if (v8 >= 3)
    {
      uint64_t v17 = (unint64_t)v8 >> 1;
      uint64_t v18 = a2 - 1;
      do
      {
        __int16 v19 = *a1;
        uint64_t v20 = sub_1B6402C34(a1, a4, v17);
        if (v18 == v20)
        {
          *uint64_t v20 = v19;
        }
        else
        {
          *uint64_t v20 = *v18;
          *uint64_t v18 = v19;
          sub_1B6402CA8((uint64_t)a1, (uint64_t)(v20 + 1), a4, v20 + 1 - a1);
        }
        --v18;
      }
      while (v17-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_1B6402B4C(uint64_t result, uint64_t *a2, uint64_t a3, __int16 *a4)
{
  if (a3 >= 2)
  {
    __int16 v4 = (char *)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 1)
    {
      uint64_t v6 = (uint64_t)(v4 + 1);
      uint64_t v7 = (__int16 *)(result + 2 * (void)(v4 + 1));
      uint64_t v8 = (uint64_t)(v4 + 2);
      uint64_t v9 = *a2;
      if (v8 < a3 && *(float *)(v9 + 4 * *v7) > *(float *)(v9 + 4 * v7[1]))
      {
        ++v7;
        uint64_t v6 = v8;
      }
      uint64_t v10 = *a4;
      float v11 = *(float *)(v9 + 4 * v10);
      if (*(float *)(v9 + 4 * *v7) <= v11)
      {
        __int16 v12 = *v7;
        do
        {
          uint64_t v13 = v7;
          *a4 = v12;
          if (v5 < v6) {
            break;
          }
          uint64_t v14 = 2 * v6;
          uint64_t v6 = (2 * v6) | 1;
          uint64_t v7 = (__int16 *)(result + 2 * v6);
          uint64_t v15 = v14 + 2;
          if (v15 < a3 && *(float *)(v9 + 4 * *v7) > *(float *)(v9 + 4 * v7[1]))
          {
            ++v7;
            uint64_t v6 = v15;
          }
          __int16 v12 = *v7;
          a4 = v13;
        }
        while (*(float *)(v9 + 4 * *v7) <= v11);
        *uint64_t v13 = v10;
      }
    }
  }
  return result;
}

__int16 *sub_1B6402C34(__int16 *result, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  uint64_t v6 = *a2;
  do
  {
    uint64_t v7 = result;
    uint64_t v8 = 2 * v3 + 2;
    uint64_t result = (__int16 *)((char *)result + v8);
    uint64_t v3 = (2 * v3) | 1;
    if (v8 < a3 && *(float *)(v6 + 4 * *result) > *(float *)(v6 + 4 * result[1]))
    {
      ++result;
      uint64_t v3 = v8;
    }
    *uint64_t v7 = *result;
  }
  while (v3 <= v5);
  return result;
}

uint64_t sub_1B6402CA8(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v5 = (__int16 *)(result + 2 * v4);
    uint64_t v6 = *v5;
    uint64_t v9 = *(__int16 *)(a2 - 2);
    uint64_t v7 = (_WORD *)(a2 - 2);
    __int16 v8 = v9;
    uint64_t v10 = *a3;
    float v11 = *(float *)(*a3 + 4 * v9);
    if (*(float *)(*a3 + 4 * v6) > v11)
    {
      do
      {
        __int16 v12 = v5;
        *uint64_t v7 = v6;
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
        uint64_t v5 = (__int16 *)(result + 2 * v4);
        LOWORD(v6) = *v5;
        uint64_t v7 = v12;
      }
      while (*(float *)(v10 + 4 * *v5) > v11);
      *__int16 v12 = v8;
    }
  }
  return result;
}

uint64_t sub_1B6402D14(uint64_t result, __int16 *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v10 = (__int16 *)result;
LABEL_2:
  float v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v22 = *(a2 - 1);
          uint64_t v23 = *v11;
          if (*(float *)(*a3 + 4 * v22) < *(float *)(*a3 + 4 * v23))
          {
            *float v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          uint64_t result = sub_1B64031F0(v11, v11 + 1, a2 - 1, a3);
          break;
        case 4uLL:
          uint64_t result = sub_1B640362C(v11, v11 + 1, v11 + 2, a2 - 1, a3);
          break;
        case 5uLL:
          uint64_t result = sub_1B64036F0(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 47) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)sub_1B64037E0(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x101)
    {
      sub_1B64031F0(v11, &v11[v15 >> 1], a2 - 1, a3);
      sub_1B64031F0(v11 + 1, v17 - 1, a2 - 2, a3);
      sub_1B64031F0(v11 + 2, &v11[v16 + 1], a2 - 3, a3);
      sub_1B64031F0(v17 - 1, v17, &v11[v16 + 1], a3);
      __int16 v18 = *v11;
      *float v11 = *v17;
      *uint64_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      sub_1B64031F0(&v11[v15 >> 1], v11, a2 - 1, a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(float *)(*a3 + 4 * *(v11 - 1)) >= *(float *)(*a3 + 4 * *v11))
    {
      uint64_t result = (uint64_t)sub_1B64032AC(v11, a2, a3);
      float v11 = (__int16 *)result;
      goto LABEL_19;
    }
LABEL_14:
    __int16 v19 = sub_1B6403388(v11, a2, a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = sub_1B6403468(v11, v19, a3);
    float v11 = v19 + 1;
    uint64_t result = sub_1B6403468(v19 + 1, a2, a3);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = sub_1B6402D14(v10, v19, a3, -v13, a5 & 1);
      float v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)sub_1B64030EC(v11, a2, a3);
  }
  else
  {
    return (uint64_t)sub_1B6403180(v11, a2, a3);
  }
}

__int16 *sub_1B64030EC(__int16 *result, __int16 *a2, uint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = 0;
      uint64_t v5 = *a3;
      char v6 = result;
      do
      {
        uint64_t v7 = v6[1];
        uint64_t v8 = *v6;
        char v6 = v3;
        float v9 = *(float *)(v5 + 4 * v7);
        if (v9 < *(float *)(v5 + 4 * v8))
        {
          __int16 v10 = v7;
          __int16 v11 = v8;
          uint64_t v12 = v4;
          while (1)
          {
            *(__int16 *)((char *)result + v12 + 2) = v11;
            if (!v12) {
              break;
            }
            __int16 v11 = *(__int16 *)((char *)result + v12 - 2);
            v12 -= 2;
            if (v9 >= *(float *)(v5 + 4 * v11))
            {
              uint64_t v13 = (__int16 *)((char *)result + v12 + 2);
              goto LABEL_10;
            }
          }
          uint64_t v13 = result;
LABEL_10:
          *uint64_t v13 = v10;
        }
        uint64_t v3 = v6 + 1;
        v4 += 2;
      }
      while (v6 + 1 != a2);
    }
  }
  return result;
}

__int16 *sub_1B6403180(__int16 *result, __int16 *a2, uint64_t *a3)
{
  if (result != a2)
  {
    uint64_t v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = *a3;
      do
      {
        uint64_t v5 = result[1];
        uint64_t v6 = *result;
        uint64_t result = v3;
        float v7 = *(float *)(v4 + 4 * v5);
        if (v7 < *(float *)(v4 + 4 * v6))
        {
          __int16 v8 = v5;
          __int16 v9 = v6;
          __int16 v10 = result;
          do
          {
            *__int16 v10 = v9;
            __int16 v9 = *(v10 - 2);
            --v10;
          }
          while (v7 < *(float *)(v4 + 4 * v9));
          *__int16 v10 = v8;
        }
        uint64_t v3 = result + 1;
      }
      while (result + 1 != a2);
    }
  }
  return result;
}

uint64_t sub_1B64031F0(__int16 *a1, __int16 *a2, __int16 *a3, uint64_t *a4)
{
  uint64_t v4 = *a1;
  uint64_t v5 = *a4;
  float v6 = *(float *)(*a4 + 4 * *a2);
  float v7 = *(float *)(*a4 + 4 * v4);
  __int16 v8 = *a2;
  __int16 v9 = *a3;
  float v10 = *(float *)(*a4 + 4 * *a3);
  if (v6 < v7)
  {
    if (v10 < v6)
    {
      *a1 = v9;
      *a3 = v4;
      return 1;
    }
    *a1 = v8;
    *a2 = v4;
    uint64_t v13 = *a3;
    if (*(float *)(v5 + 4 * v13) >= v7) {
      return 1;
    }
    *a2 = v13;
    *a3 = v4;
    return 2;
  }
  if (v10 < v6)
  {
    *a2 = v9;
    *a3 = v8;
    uint64_t v11 = *a2;
    uint64_t v12 = *a1;
    if (*(float *)(v5 + 4 * v11) >= *(float *)(v5 + 4 * v12)) {
      return 1;
    }
    *a1 = v11;
    *a2 = v12;
    return 2;
  }
  return 0;
}

__int16 *sub_1B64032AC(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *a3;
  float v5 = *(float *)(*a3 + 4 * v3);
  if (v5 >= *(float *)(*a3 + 4 * *(a2 - 1)))
  {
    __int16 v8 = a1 + 1;
    do
    {
      float v6 = v8;
      if (v8 >= a2) {
        break;
      }
      ++v8;
    }
    while (v5 >= *(float *)(v4 + 4 * *v6));
  }
  else
  {
    float v6 = a1;
    do
    {
      uint64_t v7 = v6[1];
      ++v6;
    }
    while (v5 >= *(float *)(v4 + 4 * v7));
  }
  if (v6 < a2)
  {
    do
      uint64_t v9 = *--a2;
    while (v5 < *(float *)(v4 + 4 * v9));
  }
  if (v6 < a2)
  {
    __int16 v10 = *v6;
    __int16 v11 = *a2;
    do
    {
      *float v6 = v11;
      *a2 = v10;
      do
      {
        uint64_t v12 = v6[1];
        ++v6;
        __int16 v10 = v12;
      }
      while (v5 >= *(float *)(v4 + 4 * v12));
      do
      {
        uint64_t v13 = *--a2;
        __int16 v11 = v13;
      }
      while (v5 < *(float *)(v4 + 4 * v13));
    }
    while (v6 < a2);
  }
  if (v6 - 1 != a1) {
    *a1 = *(v6 - 1);
  }
  *(v6 - 1) = v3;
  return v6;
}

__int16 *sub_1B6403388(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v3 = 0;
  __int16 v4 = *a1;
  uint64_t v5 = *a3;
  float v6 = *(float *)(*a3 + 4 * *a1);
  do
    uint64_t v7 = a1[++v3];
  while (*(float *)(v5 + 4 * v7) < v6);
  __int16 v8 = &a1[v3];
  uint64_t v9 = &a1[v3 - 1];
  if (v3 == 1)
  {
    do
    {
      if (v8 >= a2) {
        break;
      }
      uint64_t v11 = *--a2;
    }
    while (*(float *)(v5 + 4 * v11) >= v6);
  }
  else
  {
    do
      uint64_t v10 = *--a2;
    while (*(float *)(v5 + 4 * v10) >= v6);
  }
  if (v8 < a2)
  {
    __int16 v12 = v7;
    __int16 v13 = *a2;
    uint64_t v14 = v8;
    unint64_t v15 = a2;
    do
    {
      *uint64_t v14 = v13;
      *unint64_t v15 = v12;
      do
      {
        uint64_t v16 = v14[1];
        ++v14;
        __int16 v12 = v16;
      }
      while (*(float *)(v5 + 4 * v16) < v6);
      do
      {
        uint64_t v17 = *--v15;
        __int16 v13 = v17;
      }
      while (*(float *)(v5 + 4 * v17) >= v6);
    }
    while (v14 < v15);
    uint64_t v9 = v14 - 1;
  }
  if (v9 != a1) {
    *a1 = *v9;
  }
  *uint64_t v9 = v4;
  return v9;
}

BOOL sub_1B6403468(__int16 *a1, __int16 *a2, uint64_t *a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(float *)(*a3 + 4 * v8) < *(float *)(*a3 + 4 * v9))
      {
        *a1 = v8;
        *(a2 - 1) = v9;
      }
      return result;
    case 3:
      sub_1B64031F0(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      sub_1B640362C(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      sub_1B64036F0(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      sub_1B64031F0(a1, a1 + 1, a1 + 2, a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = *a3;
      uint64_t v14 = 6;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v11;
    float v16 = *(float *)(v13 + 4 * v15);
    if (v16 < *(float *)(v13 + 4 * *v10))
    {
      __int16 v17 = *v10;
      uint64_t v18 = v14;
      while (1)
      {
        *(__int16 *)((char *)a1 + v1_Block_object_dispose(&STACK[0x5A0], 8) = v17;
        uint64_t v19 = v18 - 2;
        if (v18 == 2) {
          break;
        }
        uint64_t v20 = *(__int16 *)((char *)a1 + v18 - 4);
        __int16 v17 = v20;
        float v21 = *(float *)(v13 + 4 * v20);
        uint64_t v18 = v19;
        if (v16 >= v21)
        {
          uint64_t v22 = (__int16 *)((char *)a1 + v19);
          goto LABEL_12;
        }
      }
      uint64_t v22 = a1;
LABEL_12:
      *uint64_t v22 = v15;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v14 += 2;
    if (++v11 == a2) {
      return 1;
    }
  }
}

uint64_t sub_1B640362C(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, uint64_t *a5)
{
  uint64_t result = sub_1B64031F0(a1, a2, a3, a5);
  uint64_t v11 = *a4;
  uint64_t v12 = *a3;
  uint64_t v13 = *a5;
  if (*(float *)(*a5 + 4 * v11) < *(float *)(*a5 + 4 * v12))
  {
    *a3 = v11;
    *a4 = v12;
    uint64_t v14 = *a3;
    uint64_t v15 = *a2;
    if (*(float *)(v13 + 4 * v14) < *(float *)(v13 + 4 * v15))
    {
      *a2 = v14;
      *a3 = v15;
      uint64_t v16 = *a2;
      uint64_t v17 = *a1;
      if (*(float *)(v13 + 4 * v16) < *(float *)(v13 + 4 * v17))
      {
        *a1 = v16;
        *a2 = v17;
      }
    }
  }
  return result;
}

uint64_t sub_1B64036F0(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4, __int16 *a5, uint64_t *a6)
{
  uint64_t result = sub_1B640362C(a1, a2, a3, a4, a6);
  uint64_t v13 = *a5;
  uint64_t v14 = *a4;
  uint64_t v15 = *a6;
  if (*(float *)(*a6 + 4 * v13) < *(float *)(*a6 + 4 * v14))
  {
    *a4 = v13;
    *a5 = v14;
    uint64_t v16 = *a4;
    uint64_t v17 = *a3;
    if (*(float *)(v15 + 4 * v16) < *(float *)(v15 + 4 * v17))
    {
      *a3 = v16;
      *a4 = v17;
      uint64_t v18 = *a3;
      uint64_t v19 = *a2;
      if (*(float *)(v15 + 4 * v18) < *(float *)(v15 + 4 * v19))
      {
        *a2 = v18;
        *a3 = v19;
        uint64_t v20 = *a2;
        uint64_t v21 = *a1;
        if (*(float *)(v15 + 4 * v20) < *(float *)(v15 + 4 * v21))
        {
          *a1 = v20;
          *a2 = v21;
        }
      }
    }
  }
  return result;
}

__int16 *sub_1B64037E0(__int16 *a1, __int16 *a2, __int16 *a3, uint64_t *a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 3)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[v10];
      do
      {
        sub_1B6403940((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        uint64_t v15 = *v14;
        uint64_t v16 = *a1;
        if (*(float *)(*a4 + 4 * v15) < *(float *)(*a4 + 4 * v16))
        {
          *uint64_t v14 = v16;
          *a1 = v15;
          sub_1B6403940((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = a3;
    }
    if (v8 >= 3)
    {
      uint64_t v17 = (unint64_t)v8 >> 1;
      uint64_t v18 = a2 - 1;
      do
      {
        __int16 v19 = *a1;
        uint64_t v20 = sub_1B6403A28(a1, a4, v17);
        if (v18 == v20)
        {
          *uint64_t v20 = v19;
        }
        else
        {
          *uint64_t v20 = *v18;
          *uint64_t v18 = v19;
          sub_1B6403A9C((uint64_t)a1, (uint64_t)(v20 + 1), a4, v20 + 1 - a1);
        }
        --v18;
      }
      while (v17-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t sub_1B6403940(uint64_t result, uint64_t *a2, uint64_t a3, __int16 *a4)
{
  if (a3 >= 2)
  {
    __int16 v4 = (char *)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 1)
    {
      uint64_t v6 = (uint64_t)(v4 + 1);
      uint64_t v7 = (__int16 *)(result + 2 * (void)(v4 + 1));
      uint64_t v8 = (uint64_t)(v4 + 2);
      uint64_t v9 = *a2;
      if (v8 < a3 && *(float *)(v9 + 4 * *v7) < *(float *)(v9 + 4 * v7[1]))
      {
        ++v7;
        uint64_t v6 = v8;
      }
      uint64_t v10 = *a4;
      float v11 = *(float *)(v9 + 4 * v10);
      if (*(float *)(v9 + 4 * *v7) >= v11)
      {
        __int16 v12 = *v7;
        do
        {
          uint64_t v13 = v7;
          *a4 = v12;
          if (v5 < v6) {
            break;
          }
          uint64_t v14 = 2 * v6;
          uint64_t v6 = (2 * v6) | 1;
          uint64_t v7 = (__int16 *)(result + 2 * v6);
          uint64_t v15 = v14 + 2;
          if (v15 < a3 && *(float *)(v9 + 4 * *v7) < *(float *)(v9 + 4 * v7[1]))
          {
            ++v7;
            uint64_t v6 = v15;
          }
          __int16 v12 = *v7;
          a4 = v13;
        }
        while (*(float *)(v9 + 4 * *v7) >= v11);
        *uint64_t v13 = v10;
      }
    }
  }
  return result;
}

__int16 *sub_1B6403A28(__int16 *result, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  uint64_t v6 = *a2;
  do
  {
    uint64_t v7 = result;
    uint64_t v8 = 2 * v3 + 2;
    uint64_t result = (__int16 *)((char *)result + v8);
    uint64_t v3 = (2 * v3) | 1;
    if (v8 < a3 && *(float *)(v6 + 4 * *result) < *(float *)(v6 + 4 * result[1]))
    {
      ++result;
      uint64_t v3 = v8;
    }
    *uint64_t v7 = *result;
  }
  while (v3 <= v5);
  return result;
}

uint64_t sub_1B6403A9C(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v5 = (__int16 *)(result + 2 * v4);
    uint64_t v6 = *v5;
    uint64_t v9 = *(__int16 *)(a2 - 2);
    uint64_t v7 = (_WORD *)(a2 - 2);
    __int16 v8 = v9;
    uint64_t v10 = *a3;
    float v11 = *(float *)(*a3 + 4 * v9);
    if (*(float *)(*a3 + 4 * v6) < v11)
    {
      do
      {
        __int16 v12 = v5;
        *uint64_t v7 = v6;
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
        uint64_t v5 = (__int16 *)(result + 2 * v4);
        LOWORD(v6) = *v5;
        uint64_t v7 = v12;
      }
      while (*(float *)(v10 + 4 * *v5) < v11);
      *__int16 v12 = v8;
    }
  }
  return result;
}

void sub_1B6403B08(_OWORD *a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  if (!a1)
  {
    float v12 = a9;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"out");
    a9 = v12;
    if (a2) {
      goto LABEL_3;
    }
LABEL_5:
    float v13 = a9;
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"center");
    a9 = v13;
    goto LABEL_3;
  }
  if (!a2) {
    goto LABEL_5;
  }
LABEL_3:
  long long v11 = *a2;
  *((float *)&v11 + 3) = a9;
  *a1 = v11;
}

float32x4_t *sub_1B6403B98(float32x4_t *result, float32x4_t *a2, float32x4_t *a3)
{
  float32x4_t v3 = *a2;
  LODWORD(v4) = HIDWORD(*(unsigned long long *)a2);
  if (v4 < 0.0)
  {
    float32x4_t v5 = *a3;
LABEL_5:
    _DWORD *result = v5;
    return result;
  }
  float32x4_t v6 = *a3;
  LODWORD(v7) = HIDWORD(*(unsigned long long *)a3);
  if (v7 < 0.0)
  {
    float32x4_t v5 = *a2;
    goto LABEL_5;
  }
  float32x4_t v8 = vsubq_f32(v3, v6);
  float32x4_t v9 = vmulq_f32(v8, v8);
  float v10 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
  if ((float)(v4 + v10) >= v7)
  {
    if ((float)(v7 + v10) > v4)
    {
      float32x4_t v3 = vmlaq_n_f32(v3, v8, (float)(v4 - (float)((float)((float)(v4 + v7) + v10) * 0.5)) / v10);
      v3.f32[3] = (float)((float)(v4 + v7) + v10) * 0.5;
    }
    float32x4_t v6 = v3;
  }
  _DWORD *result = v6;
  return result;
}

float sub_1B6403C2C(float32x4_t *a1, float32x4_t *a2, float32x4_t *a3)
{
  float32x4_t v3 = a2[1];
  float32x4_t v4 = a2[2];
  float32x4_t v5 = vmulq_f32(*a2, *a2);
  float32x4_t v6 = vmulq_f32(v3, v3);
  float32x4_t v7 = vmulq_f32(v4, v4);
  float32x4_t v8 = vmlaq_n_f32(vmlaq_lane_f32(vmlaq_laneq_f32(a2[3], v4, *a1, 2), v3, *(float32x2_t *)a1->f32, 1), *a2, COERCE_FLOAT(*a1));
  float result = vmuls_lane_f32(fmaxf(fmaxf(sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).f32[0]), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 2), vaddq_f32(v7, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 1))).f32[0])), sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0])), *a1, 3);
  v8.f32[3] = result;
  *a3 = v8;
  return result;
}

void *sub_1B6403CA4(uint64_t a1, uint64_t a2)
{
  float result = (void *)sub_1B6DABD0C(a1, "Authoring");
  void *result = &unk_1F0FB5348;
  result[3] = a2;
  return result;
}

uint64_t sub_1B6403CF0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v4, *(_WORD *)(a1 + 8), 9273, 1656467160);
  return sub_1B63D0050(a2, v4, 1);
}

uint64_t sub_1B6403D6C@<X0>(uint64_t a1@<X8>)
{
  uint64_t v4[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (CFX::RG::ResourceIdentifier *)CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v4, 6893, 9273, 1656467160);
  v4[1] = CFX::RG::ResourceIdentifier::finalColor(v2);
  return sub_1B63D0050(a1, v4, 2);
}

unint64_t sub_1B6403DF0(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = *(unsigned __int16 *)(a1 + 8);
  uint64_t v10 = *a3;
  if (v10)
  {
    long long v11 = (uint64_t *)*((void *)a3 + 1);
    uint64_t v12 = 8 * v10;
    do
    {
      uint64_t v13 = *v11++;
      uint64_t v60 = v13;
      uint64_t v14 = CFX::RG::ResourceIdentifier::id((CFX::RG::ResourceIdentifier *)&v60);
      unint64_t v9 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v9 ^ ((0x9DDFEA08EB382D69 * (v14 ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v14 ^ v9)))) ^ ((0x9DDFEA08EB382D69 * (v9 ^ ((0x9DDFEA08EB382D69 * (v14 ^ v9)) >> 47) ^ (0x9DDFEA08EB382D69 * (v14 ^ v9)))) >> 47));
      v12 -= 8;
    }
    while (v12);
  }
  uint64_t v15 = (void *)sub_1B6445900(*(void *)(a1 + 24), a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v23 = (void *)sub_1B644689C(*(void *)(a1 + 24), v16, v17, v18, v19, v20, v21, v22);
  int v24 = sub_1B6447D40(*(void *)(a1 + 24));
  int v25 = sub_1B6447D6C(*(void *)(a1 + 24));
  int v29 = objc_msgSend_showsAuthoringEnvironment(v15, v26, v27, v28);
  int v33 = objc_msgSend_showsStatistics(v23, v30, v31, v32);
  int v37 = objc_msgSend_showsDebugUI(v23, v34, v35, v36);
  int32x4_t v44 = (void *)sub_1B6446254(*(void *)(a1 + 24), 0, v38, v39, v40, v41, v42, v43);
  BOOL v45 = sub_1B642F984(v44);
  BOOL v46 = sub_1B6600AA8(*(void *)(a1 + 24), v44);
  unsigned int v47 = sub_1B6446228(*(void *)(a1 + 24));
  uint64_t v48 = 2;
  if (!v24) {
    uint64_t v48 = 0;
  }
  uint64_t v49 = 4;
  if (!v25) {
    uint64_t v49 = 0;
  }
  uint64_t v50 = v49 | v48;
  uint64_t v51 = 8;
  if (!v29) {
    uint64_t v51 = 0;
  }
  uint64_t v52 = v50 | v51;
  uint64_t v53 = 16;
  if (!v33) {
    uint64_t v53 = 0;
  }
  uint64_t v54 = 32;
  if (!v37) {
    uint64_t v54 = 0;
  }
  uint64_t v55 = v52 | v53 | v54;
  uint64_t v56 = 64;
  if (!v45) {
    uint64_t v56 = 0;
  }
  uint64_t v57 = 128;
  if (!v46) {
    uint64_t v57 = 0;
  }
  unint64_t v58 = 0x9DDFEA08EB382D69 * ((v55 | v56 | v57 | (v47 >> 11) & 0x100) ^ v9);
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v9 ^ (v58 >> 47) ^ v58)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v58 >> 47) ^ v58)) >> 47));
}

void sub_1B6403FA8(uint64_t a1, CFX::RG::RenderGraphContext *a2, uint64_t *a3)
{
  if (!sub_1B6447D40(*(void *)(a1 + 24)) || sub_1B6447D6C(*(void *)(a1 + 24)))
  {
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v108, 9273, 9273, 1656467160);
    CFX::RG::ResourceReference::ResourceReference((uint64_t)v109, v108);
    float32x4_t v6 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"Authoring input color", (CFX::RG::ResourceReference *)v109);
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v107, 9273, 9273, -797957750);
    uint64_t PublishedResource = CFX::RG::RenderGraphBuilder::findPublishedResource((uint64_t)a3, v107);
    BOOL v9 = (PublishedResource | v8) == 0;
    if (PublishedResource | v8)
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v104, 9273, 9273, -797957750);
      CFX::RG::ResourceReference::ResourceReference((uint64_t)v105, v104);
      long long v11 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"Authoring input depth", (CFX::RG::ResourceReference *)v105);
    }
    else
    {
      uint64_t v10 = (_OWORD *)CFX::RG::Resource::constTextureDesc(v6);
      CFX::RG::TextureDescriptorReference::withSampleCount(v10, 1, (uint64_t)&v89);
      CFX::RG::TextureDescriptorReference::withPixelFormat((CFX::RG::TextureDescriptorReference *)&v89, MTLPixelFormatDepth32Float, (uint64_t)v106);
      long long v11 = sub_1B63CFDE4(a3, (uint64_t)"Authoring input depth", v106);
    }
    uint64_t v12 = v11;
    uint64_t v13 = (_OWORD *)CFX::RG::Resource::constTextureDesc(v6);
    CFX::RG::TextureDescriptorReference::withSampleCount(v13, 1, (uint64_t)&v89);
    uint64_t v15 = CFX::RG::copyIfNeeded_r((CFX::RG *)a3, v6, 0, (CFX::RG::Pass *)&v89, (const CFX::RG::TextureDescriptorReference *)"Authoring color input resolve", v14);
    uint64_t v17 = (CFX::RG::Resource *)v16;
    int v24 = (void *)sub_1B6445900(*(void *)(a1 + 24), v16, v18, v19, v20, v21, v22, v23);
    if (objc_msgSend_showsAuthoringEnvironment(v24, v25, v26, v27))
    {
      if (v9)
      {
        uint64_t v35 = 0;
      }
      else
      {
        uint64_t v38 = (_OWORD *)CFX::RG::Resource::constTextureDesc(v12);
        CFX::RG::TextureDescriptorReference::withSampleCount(v38, 1, (uint64_t)&v89);
        uint64_t v12 = CFX::RG::copyIfNeeded_r((CFX::RG *)a3, v12, 0, (CFX::RG::Pass *)&v89, (const CFX::RG::TextureDescriptorReference *)"Authoring depth input resolve", v39);
      }
      v102[0] = v15;
      v102[1] = v17;
      v102[2] = v12;
      _OWORD v102[3] = v35;
      BOOL v103 = v9;
      uint64_t v40 = *(void *)(a1 + 24);
      unsigned int v89 = "Authoring";
      uint64_t v90 = v40;
      __int16 v91 = 0;
      int v37 = sub_1B6602020(a2, a3, (uint64_t)&v89, (uint64_t)v102, v31, v32, v33, v34);
      uint64_t v15 = (CFX::RG::RenderGraphBuilder *)v37[52];
      unsigned int v47 = (void *)sub_1B6446254(*(void *)(a1 + 24), 0, v41, v42, v43, v44, v45, v46);
      if ((sub_1B6446228(*(void *)(a1 + 24)) & 0x80000) != 0 && sub_1B642F984(v47))
      {
        uint64_t v48 = *(void *)(a1 + 24);
        unsigned int v89 = "Manipulator";
        uint64_t v90 = v48;
        __int16 v91 = 0;
        uint64_t v49 = (long long *)CFX::RG::Resource::constTextureDesc(v12);
        long long v50 = v49[1];
        long long v92 = *v49;
        long long v93 = v50;
        long long v51 = v49[4];
        long long v52 = v49[5];
        long long v53 = v49[3];
        long long v94 = v49[2];
        long long v97 = v52;
        long long v96 = v51;
        long long v95 = v53;
        long long v54 = v49[8];
        long long v55 = v49[9];
        long long v56 = v49[7];
        long long v98 = v49[6];
        long long v101 = v55;
        long long v100 = v54;
        long long v99 = v56;
        uint64_t v36 = (uint64_t *)sub_1B65CB0F8(a3, (uint64_t)&v89, (uint64_t)v15);
        CFX::RG::Pass::dependsOn(v36, (CFX::RG::Pass *)v37);
        uint64_t v12 = (CFX::RG::Resource *)v36[50];
      }
      else
      {
        uint64_t v36 = v37;
      }
      uint64_t v17 = (CFX::RG::Resource *)v36;
    }
    else
    {
      uint64_t v36 = 0;
      int v37 = 0;
    }
    uint64_t v57 = (void *)sub_1B644689C(*(void *)(a1 + 24), v28, v29, v30, v31, v32, v33, v34);
    if (!v57) {
      goto LABEL_25;
    }
    uint64_t v61 = v57;
    int v62 = objc_msgSend_showsStatistics(v57, v58, v59, v60);
    int v66 = objc_msgSend_showsDebugUI(v61, v63, v64, v65);
    if (!sub_1B6447D6C(*(void *)(a1 + 24)) || !(v62 | v66)) {
      goto LABEL_25;
    }
    CFX::RG::TextureDescriptorReference::finalColor((uint64_t)&v89);
    uint64_t v68 = CFX::RG::copyIfNeeded_r((CFX::RG *)a3, v15, v17, (CFX::RG::Pass *)&v89, (const CFX::RG::TextureDescriptorReference *)"Overlay color input copy", v67);
    uint64_t v70 = (uint64_t *)v69;
    uint64_t v71 = *(void *)(a1 + 24);
    unsigned int v89 = "Overlay";
    uint64_t v90 = v71;
    __int16 v91 = 0;
    LOBYTE(v92) = objc_msgSend_showsStatistics(v61, v69, v72, v73);
    BYTE1(v92) = objc_msgSend_showsDebugUI(v61, v74, v75, v76);
    uint64_t v77 = v36 == v70 ? (uint64_t)v12 : 0;
    uint64_t v78 = (uint64_t *)sub_1B65D5794(a3, (uint64_t)&v89, (uint64_t)v68, v77);
    if (v78)
    {
      int32x4_t v79 = v78;
      if (v70) {
        float32x4_t v80 = (CFX::RG::Pass *)v70;
      }
      else {
        float32x4_t v80 = (CFX::RG::Pass *)v37;
      }
      CFX::RG::Pass::dependsOn(v78, v80);
      uint64_t v17 = (CFX::RG::Resource *)v79;
      uint64_t v15 = v68;
    }
    else
    {
LABEL_25:
      if (!v17)
      {
        CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v87, 9273, 9273, 1656467160);
        CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v86, *(_WORD *)(a1 + 8), 64484, 1656467160);
        CFX::RG::RenderGraphBuilder::aliasResourceReference((uint64_t)a3, v87, v86);
        return;
      }
    }
    float32x4_t v81 = (unsigned char *)*((void *)v17 + 3);
    char v82 = *v81;
    if (*v81)
    {
      uint64_t v83 = v81 + 1;
      __int16 v84 = -25147;
      do
      {
        __int16 v84 = 403 * (v84 ^ v82);
        int v85 = *v83++;
        char v82 = v85;
      }
      while (v85);
    }
    else
    {
      __int16 v84 = -25147;
    }
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v88, *(_WORD *)(a1 + 8), v84, 1656467160);
    CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v88, (unint64_t)v15, (uint64_t)v17);
  }
}

void sub_1B64043F4()
{
}

uint64_t sub_1B6404408(uint64_t *a1)
{
  uint64_t result = sub_1B63C8D10(a1);
  *a1 = result;
  return result;
}

uint64_t sub_1B6404438(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  if (qword_1E9DDA728 != -1) {
    dispatch_once_f(&qword_1E9DDA728, &qword_1E9DDA720, (dispatch_function_t)sub_1B6404408);
  }
  uint64_t v4 = sub_1B63C8D44(qword_1E9DDA720, 0x28uLL);
  *(void *)(v4 + 40) = a1;
  *(void *)(v4 + 4_Block_object_dispose(&STACK[0x5A0], 8) = a2;
  *(void *)float32x4_t v7 = 0x1000000006;
  size_t v6 = 4;
  if (sysctl(v7, 2u, (void *)(v4 + 32), &v6, 0, 0) < 0) {
    *(_DWORD *)(v4 + 32) = 64;
  }
  return v4;
}

void sub_1B640452C(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    free(v2);
    *(void *)a1 = 0;
    *(_DWORD *)(a1 + _Block_object_dispose(&STACK[0x5A0], 8) = 0;
  }
  float32x4_t v5 = *(void **)(a1 + 16);
  uint64_t v4 = (void *)(a1 + 16);
  float32x4_t v3 = v5;
  if (v5)
  {
    free(v3);
    *uint64_t v4 = 0;
    v4[1] = 0;
  }
}

void sub_1B6404570(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24))
  {
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      sub_1B640452C(*(void *)(a1 + 16) + v2);
      ++v3;
      v2 += 40;
    }
    while (v3 < *(unsigned int *)(a1 + 24));
  }
  free(*(void **)(a1 + 16));
  *(_DWORD *)(a1 + 36) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
}

_DWORD *sub_1B64045D8(_DWORD *result, uint64_t a2)
{
  uint64_t v2 = (result[6] - 1);
  result[6] = v2;
  if (v2 != a2) {
    return memmove((void *)(*((void *)result + 2) + 8 * a2), (const void *)(*((void *)result + 2) + 8 * a2 + 8), 8 * (v2 - a2));
  }
  return result;
}

void sub_1B6404608(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v8 = WORD1(a2);
  unint64_t v29 = a2;
  if (!HIDWORD(a2)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. cannot remove null span", a3, a4, a5, a6, a7, a8, (uint64_t)"span.count > 0");
  }
  unint64_t v28 = *(unsigned int *)(a1 + 24);
  if (!v28)
  {
    BOOL v15 = 0;
    uint64_t v12 = 0;
LABEL_21:
    unsigned int v24 = *(_DWORD *)(a1 + 28);
    if (v24 < *(_DWORD *)(a1 + 24) + 1)
    {
      int v25 = *(void **)(a1 + 16);
      if (v25)
      {
        unsigned int v26 = 2 * v24;
        *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x5A0], 8) = v26;
        if (!v26)
        {
          sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"page->freeCapacity");
          int v25 = *(void **)(a1 + 16);
          unsigned int v26 = *(_DWORD *)(a1 + 28);
        }
        uint64_t v27 = malloc_type_realloc(v25, 8 * v26, 0x100004000313F17uLL);
      }
      else
      {
        *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x5A0], 8) = 8;
        uint64_t v27 = malloc_type_malloc(0x40uLL, 0x100004000313F17uLL);
      }
      *(void *)(a1 + 16) = v27;
    }
    if (HIDWORD(v29) > *(_DWORD *)(a1 + 32)) {
      *(_DWORD *)(a1 + 32) = HIDWORD(v29);
    }
    if (v15) {
      memmove((void *)(*(void *)(a1 + 16) + 8 * v12 + 8), (const void *)(*(void *)(a1 + 16) + 8 * v12), 8 * (v28 - v12));
    }
    *(void *)(*(void *)(a1 + 16) + 8 * v12) = v29;
    ++*(_DWORD *)(a1 + 24);
    return;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  unsigned int v13 = v8;
  uint64_t v14 = (uint64_t *)&v29;
  BOOL v15 = 1;
  while (1)
  {
    uint64_t v16 = (unsigned int *)(*(void *)(a1 + 16) + v10);
    unsigned int v17 = *((unsigned __int16 *)v16 + 1);
    unsigned int v18 = v16[1];
    int v19 = *((unsigned __int16 *)v14 + 1);
    int v20 = *((_DWORD *)v14 + 1);
    uint64_t v21 = v16;
    if (v18 + v17 == v19 || (uint64_t v21 = (unsigned int *)v14, v20 + v19 == v17))
    {
      uint64_t v22 = *v21;
      if (v11 == 1)
      {
        sub_1B64045D8((_DWORD *)a1, v12);
        uint64_t v16 = (unsigned int *)v14;
      }
      uint64_t v23 = v20 + v18;
      *(void *)uint64_t v16 = v22 | (v23 << 32);
      if (v23 + WORD1(v22) > *(_DWORD *)(a1 + 8))
      {
        sub_1B63F2F54(17, @"Assertion '%s' failed. page overflow", a3, a4, a5, a6, a7, a8, (uint64_t)"(freeSpan->start.index + freeSpan->count) <= page->capacity");
        LODWORD(v23) = v16[1];
      }
      if (v23 > *(_DWORD *)(a1 + 32)) {
        *(_DWORD *)(a1 + 32) = v23;
      }
      if (++v11 == 2) {
        return;
      }
      unsigned int v17 = *((unsigned __int16 *)v16 + 1);
      unsigned int v13 = WORD1(v29);
      uint64_t v14 = (uint64_t *)v16;
    }
    if (v17 > v13) {
      break;
    }
    BOOL v15 = ++v12 < v28;
    v10 += 8;
    if (v28 == v12)
    {
      uint64_t v12 = v28;
      break;
    }
  }
  if (!v11) {
    goto LABEL_21;
  }
}

unint64_t sub_1B6404864(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  if (*(_DWORD *)(a1 + 32) < a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong page selected for span size %d", a3, a4, a5, a6, a7, a8, (uint64_t)"spanSize <= page->freeMaxSpan");
  }
  uint64_t v10 = *(unsigned int *)(a1 + 24);
  if (v10)
  {
    uint64_t v11 = 0;
    uint64_t v12 = *(void *)(a1 + 16);
    uint64_t v13 = 4;
    while (1)
    {
      unsigned int v14 = *(_DWORD *)(v12 + v13);
      if (v14 >= v8) {
        break;
      }
      ++v11;
      v13 += 8;
      if (v10 == v11) {
        goto LABEL_7;
      }
    }
    unsigned int v16 = *(unsigned __int16 *)(v12 + v13 - 4);
    unsigned int v15 = *(unsigned __int16 *)(v12 + v13 - 2);
    if (v15 + v8 > *(_DWORD *)(a1 + 8))
    {
      sub_1B63F2F54(17, @"Assertion '%s' failed. page overflow", a3, a4, a5, a6, a7, a8, (uint64_t)"span.start.index + span.count <= page->capacity");
      uint64_t v12 = *(void *)(a1 + 16);
    }
    int v18 = *(_DWORD *)(v12 + v13) - v8;
    if (v18)
    {
      int v19 = (_DWORD *)(v12 + v13);
      *((_WORD *)v19 - 1) += v8;
      *int v19 = v18;
    }
    else
    {
      sub_1B64045D8((_DWORD *)a1, v11);
    }
    if (*(_DWORD *)(a1 + 32) == v14)
    {
      uint64_t v20 = *(unsigned int *)(a1 + 24);
      if (v20)
      {
        unsigned int v21 = 0;
        uint64_t v22 = (unsigned int *)(*(void *)(a1 + 16) + 4);
        do
        {
          unsigned int v24 = *v22;
          v22 += 2;
          unsigned int v23 = v24;
          if (v24 > v21) {
            unsigned int v21 = v23;
          }
          --v20;
        }
        while (v20);
        *(_DWORD *)(a1 + 32) = v21;
      }
      else
      {
        *(_DWORD *)(a1 + 32) = 0;
      }
    }
  }
  else
  {
LABEL_7:
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"0");
    uint64_t v8 = 0;
    unsigned int v15 = 0xFFFF;
    unsigned int v16 = 0xFFFF;
  }
  return (v8 << 32) | ((unint64_t)v15 << 16) | v16;
}

void sub_1B64049F8(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  *(void *)(a2 + 32) = 0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v7 = a4;
  size_t v8 = *(void *)(a1 + 40) * a4;
  BOOL v9 = malloc_type_malloc(v8, 0xCFF4C382uLL);
  *(void *)a2 = v9;
  bzero(v9, v8);
  *(_DWORD *)(a2 + _Block_object_dispose(&STACK[0x5A0], 8) = a4;
  *(_DWORD *)(a2 + 12) = a3;

  sub_1B6404608(a2, (unsigned __int16)a3 | (unint64_t)(v7 << 32), v10, v11, v12, v13, v14, v15);
}

uint64_t sub_1B6404A84(uint64_t a1, unsigned int a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4)
  {
    *(_DWORD *)(a1 + 24) = v4 + 1;
    float32x4_t v5 = malloc_type_realloc(*(void **)(a1 + 16), 40 * (v4 + 1), 0x10A00408EF24B1CuLL);
    *(void *)(a1 + 16) = v5;
  }
  else
  {
    float32x4_t v5 = malloc_type_malloc(0x28uLL, 0x10A00408EF24B1CuLL);
    *(void *)(a1 + 16) = v5;
    *(_DWORD *)(a1 + 24) = 1;
  }
  ++*(_DWORD *)(a1 + 28);
  uint64_t v6 = (uint64_t)v5 + 40 * v4;
  sub_1B64049F8(a1, v6, v4, a2);
  return v6;
}

unint64_t sub_1B6404B38(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(unsigned int *)(a1 + 24);
  if (v11)
  {
    uint64_t v12 = *(void *)(a1 + 16);
    uint64_t v13 = v11;
    while (!*(void *)v12 || *(_DWORD *)(v12 + 32) < a2)
    {
      v12 += 40;
      if (!--v13)
      {
        uint64_t v14 = 0;
        uint64_t v12 = 0;
        uint64_t v15 = 40 * v11;
        do
        {
          uint64_t v16 = *(void *)(a1 + 16);
          unsigned int v17 = (void *)(v16 + v14);
          a4 = *(unsigned int *)(v16 + v14 + 32);
          if (a4 >= a2)
          {
            if (!*v17) {
              sub_1B64049F8(a1, (uint64_t)v17, *(_DWORD *)(v16 + v14 + 12), a4);
            }
            uint64_t v12 = (uint64_t)v17;
          }
          v14 += 40;
        }
        while (v15 != v14);
        if (v12) {
          break;
        }
        goto LABEL_13;
      }
    }
  }
  else
  {
LABEL_13:
    if (*(void *)(a1 + 48) >= (uint64_t)a2) {
      unsigned int v18 = *(void *)(a1 + 48);
    }
    else {
      unsigned int v18 = a2;
    }
    if (v18 > 0x10000)
    {
      sub_1B63F2F54(16, @"Error: RendererElementStore does not support span of more than %d", (uint64_t)a3, a4, a5, a6, a7, a8, 0x10000);
      return 0xFFFFFFFFLL;
    }
    uint64_t v12 = sub_1B6404A84(a1, v18);
  }
  if (a3) {
    *a3 = v12;
  }
  *(_DWORD *)(a1 + 36) += a2;

  return sub_1B6404864(v12, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
}

void sub_1B6404C74(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 16);
  unsigned int v11 = (unsigned __int16)a2;
  uint64_t v12 = v10 + 40 * (unsigned __int16)a2;
  if (*(_DWORD *)(v12 + 12) != (unsigned __int16)a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. pages are broken...", a3, a4, a5, a6, a7, a8, (uint64_t)"page->pageIndex == span.start.page");
  }
  sub_1B6404608(v12, a2, a3, a4, a5, a6, a7, a8);
  if (*(_DWORD *)(v10 + 40 * v11 + 32) == *(_DWORD *)(v10 + 40 * v11 + 8) && *(_DWORD *)(a1 + 28) >= 2u)
  {
    sub_1B640452C(v12);
    --*(_DWORD *)(a1 + 28);
  }
}

unint64_t sub_1B6404D2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_1B6404B38(a1, a2, 0, a4, a5, a6, a7, a8);
}

uint64_t sub_1B6404D38(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_1B6404D40(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 24) * *(_DWORD *)(a1 + 48));
}

uint64_t sub_1B6404D50(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"allocator");
  }
  if ((unsigned __int16)a2 >= *(_DWORD *)(a1 + 24)) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. handle is broken...", a3, a4, a5, a6, a7, a8, (uint64_t)"handle.page < allocator->_pageCount");
  }
  uint64_t v11 = *(void *)(a1 + 16);
  if (*(_DWORD *)(v11 + 40 * (unsigned __int16)a2 + 12) != (unsigned __int16)a2
    || *(_DWORD *)(v11 + 40 * (unsigned __int16)a2 + 8) <= HIWORD(a2))
  {
    sub_1B63F2F54(17, @"Assertion '%s' failed. re is broken...", a3, a4, a5, a6, a7, a8, (uint64_t)"(page->pageIndex == handle.page) && (handle.index < page->capacity)");
  }
  return *(void *)(v11 + 40 * (unsigned __int16)a2) + *(void *)(a1 + 40) * (a3 + HIWORD(a2));
}

uint64_t sub_1B6404E44(uint64_t result, uint64_t a2)
{
  uint64_t v14 = *(unsigned int *)(result + 24);
  if (v14)
  {
    uint64_t v3 = result;
    for (uint64_t i = 0; i != v14; ++i)
    {
      uint64_t v5 = *(void *)(v3 + 16);
      uint64_t v6 = v5 + 40 * i;
      if (*(_DWORD *)(v6 + 24))
      {
        uint64_t v7 = v5 + 40 * i;
        unsigned int v8 = *(unsigned __int16 *)(*(void *)(v7 + 16) + 2);
        unsigned int v9 = *(_DWORD *)(v7 + 8);
        if (v9) {
          goto LABEL_7;
        }
      }
      else
      {
        unsigned int v9 = *(_DWORD *)(v5 + 40 * i + 8);
        unsigned int v8 = v9;
        if (v9)
        {
LABEL_7:
          unsigned int v10 = 0;
          unsigned int v11 = 0;
          uint64_t v12 = (unsigned int *)(v5 + 40 * i + 8);
          uint64_t v13 = (void *)(v5 + 40 * i + 16);
          do
          {
            if (v11 == v8)
            {
              unsigned int v11 = v8 + *(_DWORD *)(*v13 + 8 * v10++ + 4) - 1;
              if (v10 >= *(_DWORD *)(v6 + 24)) {
                unsigned int v8 = v9;
              }
              else {
                unsigned int v8 = *(unsigned __int16 *)(*v13 + 8 * v10 + 2);
              }
            }
            else
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, *(void *)v6 + *(void *)(v3 + 40) * v11);
            }
            ++v11;
            unsigned int v9 = *v12;
          }
          while (v11 < *v12);
        }
      }
    }
  }
  return result;
}

CFStringRef sub_1B6404F90(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXSpanAllocator %p>", a1);
}

CFStringRef sub_1B6404FD0(const void *a1)
{
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CFXSpanAllocator %p>", a1);
}

void sub_1B640588C(uint64_t a1, const char *a2, uint64_t a3, void *a4, int a5)
{
  int v8 = (int)a2;
  if ((objc_msgSend_hasPrefix_(a4, a2, @"texture", (uint64_t)a4) & 1) != 0
    || (objc_msgSend_hasPrefix_(a4, v10, @"depth", v11) & 1) != 0)
  {
    uint64_t v12 = 176;
    if (v8) {
      uint64_t v12 = 184;
    }
    uint64_t v13 = *(void **)(a1 + v12);
    if (objc_msgSend_hasSuffix_(a4, v10, @">", v11)) {
      objc_msgSend_appendFormat_(v13, v14, @", %@ %@\n", v15, a4, a3);
    }
    else {
      objc_msgSend_appendFormat_(v13, v14, @", %@<float> %@\n", v15, a4, a3);
    }
    int v18 = 1;
  }
  else
  {
    hasPrefisimd_float4 x = objc_msgSend_hasPrefix_(a4, v10, @"sampler", v11);
    uint64_t v25 = 176;
    if (v8) {
      uint64_t v25 = 184;
    }
    unsigned int v26 = *(void **)(a1 + v25);
    if (hasPrefix)
    {
      objc_msgSend_appendFormat_(v26, v23, @", %@ %@\n", v24, a4, a3);
      int v18 = 2;
    }
    else
    {
      if (objc_msgSend_hasSuffix_(a4, v23, @"*", v24)) {
        objc_msgSend_appendFormat_(v26, v28, @", device %@ %@\n", v29, a4, a3);
      }
      else {
        objc_msgSend_appendFormat_(v26, v28, @", constant %@& %@\n", v29, a4, a3);
      }
      int v18 = 0;
    }
  }
  if (a5 == 3)
  {
    objc_msgSend_appendFormat_(*(void **)(a1 + 168), v16, @"_lightingContribution.%@=%@;\n", v17, a3, a3);
    if (v18 != 1)
    {
      unsigned int v21 = *(void **)(a1 + 160);
LABEL_17:
      objc_msgSend_appendFormat_(v21, v19, @"%@ %@;\n", v20, a4, a3);
      return;
    }
    hasSuffisimd_float4 x = objc_msgSend_hasSuffix_(a4, v19, @">", v20);
    unsigned int v21 = *(void **)(a1 + 160);
    if (hasSuffix) {
      goto LABEL_17;
    }
    objc_msgSend_appendFormat_(v21, v19, @"%@<float> %@;\n", v20, a4, a3);
  }
}

uint64_t sub_1B6405A5C(uint64_t result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 1)
  {
    uint64_t v8 = a3;
    unsigned int v9 = (uint64_t *)a2;
    unsigned int v10 = (void *)result;
    do
    {
      uint64_t v11 = *v9;
      if (!*v9) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"modifier");
      }
      uint64_t result = sub_1B6603CBC(v11, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
      if (result) {
        uint64_t result = objc_msgSend_addEntriesFromDictionary_(v10, a2, result, a4);
      }
      ++v9;
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t sub_1B6405AF4(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 1)
  {
    uint64_t v24 = v11;
    uint64_t v25 = v10;
    uint64_t v26 = v8;
    uint64_t v27 = v9;
    uint64_t v12 = a3;
    uint64_t v13 = (uint64_t *)a2;
    uint64_t v14 = result;
    do
    {
      uint64_t v15 = *v13;
      if (!*v13) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", a3, a4, a5, a6, a7, a8, (uint64_t)"modifier");
      }
      uint64_t result = sub_1B6603C70(v15, a2, a3, a4, a5, a6, a7, a8);
      if (result)
      {
        uint64_t v16 = (void *)result;
        int v17 = sub_1B660412C(*v13, a2, a3, a4, a5, a6, a7, a8);
        BOOL v20 = v17 && (v17 != 3 || *(unsigned char *)(v14 + 203));
        v21[0] = MEMORY[0x1E4F143A8];
        v21[1] = 3221225472;
        _OWORD v21[2] = sub_1B6405C20;
        v21[3] = &unk_1E61415B8;
        v21[4] = v14;
        BOOL v23 = v20;
        int v22 = v17;
        uint64_t result = objc_msgSend_enumerateKeysAndObjectsUsingBlock_(v16, v18, (uint64_t)v21, v19);
      }
      ++v13;
      --v12;
    }
    while (v12);
  }
  return result;
}

void sub_1B6405C20(uint64_t a1, uint64_t a2, void *a3)
{
}

uint64_t sub_1B6405C3C(void **a1, int a2, uint64_t a3)
{
  unint64_t v6 = sub_1B659D830(a3);
  uint64_t result = sub_1B659D984(a3);
  if ((v6 & 0x20) != 0 && a2)
  {
    uint64_t v8 = result;
    uint64_t v9 = 0x2000010000;
    if ((v6 & 0x80) == 0) {
      uint64_t v9 = 0x2000000000;
    }
    a1[26] = (void *)sub_1B65A1190(result & 0xFFFFFEFF | (((v6 >> 6) & 1) << 8) | v9, (const char *)((v6 >> 8) & 0x7FFFF), a1[1]);
    a1[27] = (void *)sub_1B65A0FF8(v8);
    uint64_t v10 = NSString;
    uint64_t v11 = sub_1B65A0F24();
    uint64_t v12 = sub_1B6602C1C(@"CFX-OpenSubdiv-Utils.h");
    uint64_t v13 = sub_1B6602C1C(@"CFX-OpenSubdiv-Utils.metal");
    a1[28] = objc_msgSend_stringWithFormat_(v10, v14, @"%@%@%@", v15, v11, v12, v13);
    a1[26] = objc_msgSend_stringByReplacingOccurrencesOfString_withString_(a1[26], v16, @"#line", @"// #line");
    a1[27] = objc_msgSend_stringByReplacingOccurrencesOfString_withString_(a1[27], v17, @"#line", @"// #line");
    uint64_t result = objc_msgSend_stringByReplacingOccurrencesOfString_withString_(a1[28], v18, @"#line", @"// #line");
    a1[28] = (void *)result;
  }
  else
  {
    a1[26] = &stru_1F0FCDBB0;
    a1[27] = &stru_1F0FCDBB0;
    a1[28] = &stru_1F0FCDBB0;
  }
  return result;
}

uint64_t sub_1B6408490(uint64_t a1, unsigned int a2, int a3, int a4)
{
  uint64_t v8 = sub_1B644CCC8(a3, 0);
  uint64_t v9 = sub_1B644CCC8(a3, 1);
  uint64_t result = sub_1B644CCC8(a3, 5);
  uint64_t v13 = result;
  *(unsigned char *)(a1 + 24) = 0;
  if (a4)
  {
    uint64_t result = sub_1B659D870(*(void *)a1, a2);
    if (result)
    {
      uint64_t v14 = *(void **)(a1 + 8);
      if (a3 == 6) {
        objc_msgSend_setObject_forKeyedSubscript_(v14, v11, (uint64_t)&unk_1F103BB10, v9);
      }
      else {
        objc_msgSend_setObject_forKeyedSubscript_(v14, v11, (uint64_t)&stru_1F0FCDBB0, v9);
      }
      if (sub_1B659D860(*(void *)a1, a2))
      {
        if (sub_1B659D880(*(void *)a1, a2) == 4) {
          int v15 = 7;
        }
        else {
          int v15 = 6;
        }
        uint64_t v16 = sub_1B644CCC8(a3, v15);
        objc_msgSend_setObject_forKeyedSubscript_(*(void **)(a1 + 8), v17, (uint64_t)&stru_1F0FCDBB0, v16);
        *(unsigned char *)(a1 + 24) = 1;
        objc_msgSend_setObject_forKeyedSubscript_(*(void **)(a1 + 8), v18, (uint64_t)&stru_1F0FCDBB0, v13);
        uint64_t result = sub_1B659D854(*(void *)a1, a2);
        unsigned int v19 = result;
        if ((result & 0x1000) != 0)
        {
          uint64_t v20 = sub_1B644CCC8(a3, 3);
          uint64_t result = objc_msgSend_setObject_forKeyedSubscript_(*(void **)(a1 + 8), v21, (uint64_t)&stru_1F0FCDBB0, v20);
        }
        uint64_t v22 = (v19 >> 13) & 0xF;
        if (v22 && v22 != 15)
        {
          uint64_t v23 = sub_1B644CCC8(a3, 4);
          uint64_t v26 = objc_msgSend_stringWithFormat_(NSString, v24, @"%d", v25, v22);
          uint64_t result = objc_msgSend_setObject_forKeyedSubscript_(*(void **)(a1 + 8), v27, v26, v23);
        }
      }
      else
      {
        uint64_t v28 = sub_1B644CCC8(a3, 2);
        uint64_t result = objc_msgSend_setObject_forKeyedSubscript_(*(void **)(a1 + 8), v29, (uint64_t)&stru_1F0FCDBB0, v28);
      }
    }
  }
  uint64_t v30 = *(void **)(a1 + 16);
  if (v30)
  {
    uint64_t v31 = sub_1B644CCC8(a3, 1);
    objc_msgSend_addObject_(v30, v32, v31, v33);
    uint64_t v34 = *(void **)(a1 + 16);
    uint64_t v35 = sub_1B644CCC8(a3, 2);
    objc_msgSend_addObject_(v34, v36, v35, v37);
    uint64_t v38 = *(void **)(a1 + 16);
    uint64_t v39 = sub_1B644CCC8(a3, 3);
    objc_msgSend_addObject_(v38, v40, v39, v41);
    uint64_t v42 = *(void **)(a1 + 16);
    uint64_t v43 = sub_1B644CCC8(a3, 4);
    objc_msgSend_addObject_(v42, v44, v43, v45);
    uint64_t v46 = *(void **)(a1 + 16);
    uint64_t v47 = sub_1B644CCC8(a3, 5);
    objc_msgSend_addObject_(v46, v48, v47, v49);
    long long v50 = *(void **)(a1 + 16);
    uint64_t v51 = sub_1B644CCC8(a3, 6);
    objc_msgSend_addObject_(v50, v52, v51, v53);
    long long v54 = *(void **)(a1 + 16);
    uint64_t v55 = sub_1B644CCC8(a3, 7);
    uint64_t result = objc_msgSend_addObject_(v54, v56, v55, v57);
  }
  if (a3 != 3)
  {
    uint64_t result = objc_msgSend_objectForKeyedSubscript_(*(void **)(a1 + 8), v11, v13, v12);
    if (result)
    {
      uint64_t result = sub_1B659D854(*(void *)a1, a2);
      uint64_t v64 = (result >> 17) & 0xF;
      if (v64 != 15)
      {
        if (a3 == 16)
        {
          __int16 v65 = sub_1B659D990(*(void *)a1, v64, v58, v59, v60, v61, v62, v63);
          unsigned __int8 v68 = v65;
          unsigned int v69 = HIBYTE(v65);
          uint64_t v70 = *(void **)(a1 + 112);
          if (v69 <= 0xFE) {
            return objc_msgSend_appendFormat_(v70, v66, @"float2 _%@Texcoord = (vfx_commonprofile.textureTransforms[%d] * float4(_geometry.texcoords[%d], 0., 1.)).xy;\n",
          }
                     v67,
                     v8,
                     (*(_DWORD *)(a1 + 128) - 1),
                     v68);
          else {
            return objc_msgSend_appendFormat_(v70, v66, @"float2 _%@Texcoord = _geometry.texcoords[%d].xy;\n",
          }
                     v67,
                     v8,
                     v68);
        }
        else
        {
          return objc_msgSend_appendFormat_(*(void **)(a1 + 120), (const char *)v64, @"    _surface.%@Texcoord = in.texcoord%d;\n",
                   v59,
                   v8,
                   v64);
        }
      }
    }
  }
  return result;
}

void sub_1B6408BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

unint64_t sub_1B6408C2C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  unint64_t result = objc_msgSend_rangeValue(a2, (const char *)a2, a3, a4);
  uint64_t v9 = v7;
  if (result >= *(void *)(*(void *)(a1 + 32) + 56))
  {
    if (result >= *(void *)(a1 + 56)) {
      return result;
    }
    int v15 = objc_msgSend_objectAtIndexedSubscript_(*(void **)(a1 + 40), v7, a3, v8);
    unint64_t result = objc_msgSend_length(v15, v16, v17, v18);
    uint64_t v14 = (void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  }
  else
  {
    uint64_t v10 = objc_msgSend_objectAtIndexedSubscript_(*(void **)(a1 + 40), v7, a3, v8);
    unint64_t result = objc_msgSend_length(v10, v11, v12, v13);
    uint64_t v14 = (void *)(*(void *)(*(void *)(a1 + 48) + 8) + 32);
  }
  *v14 += result - (void)v9;
  return result;
}

uint64_t sub_1B64092A4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_appendFormat_(*(void **)(*(void *)(a1 + 32) + 192), a2, @"%@ %@;\n",
           a4,
           a3,
           a2);
}

void *sub_1B64092D8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a2;
  uint64_t v10 = *a3;
  if (sub_1B660412C(*a3, a2, (uint64_t)a3, a4, a5, a6, a7, a8) != a2) {
    sub_1B63F2F54(17, @"Assertion '%s' failed. wrong entry point", v12, v13, v14, v15, v16, v17, (uint64_t)"CFXShaderModifierGetEntryPoint(shaderModifier) == entryPoint");
  }
  uint64_t v18 = sub_1B6603BD8(v10, v11, v12, v13, v14, v15, v16, v17);
  if (v18) {
    objc_msgSend_appendString_(*(void **)(a1 + 32), v19, v18, v21);
  }
  uint64_t v26 = sub_1B6603D08(v10, (uint64_t)v19, v20, v21, v22, v23, v24, v25);
  if (v26) {
    *(void *)(a1 + 8 * v8 + 4_Block_object_dispose(&STACK[0x5A0], 8) = v26;
  }
  else {
    sub_1B63F2F54(16, @"Error: Invalid shader modifier : no code provided", v28, v29, v30, v31, v32, v33, v45);
  }
  CFDictionaryRef v34 = (const __CFDictionary *)sub_1B6603D54(v10, v27, v28, v29, v30, v31, v32, v33);
  if (v34) {
    CFDictionaryApplyFunction(v34, (CFDictionaryApplierFunction)sub_1B64094D8, *(void **)(a1 + 8));
  }
  unint64_t result = (void *)sub_1B6603C24(v10, v35, v36, v37, v38, v39, v40, v41);
  if (result)
  {
    v46[0] = MEMORY[0x1E4F143A8];
    v46[1] = 3221225472;
    v46[2] = sub_1B64094E8;
    v46[3] = &unk_1E6141660;
    v46[4] = a1;
    return objc_msgSend_enumerateKeysAndObjectsUsingBlock_(result, v43, (uint64_t)v46, v44);
  }
  return result;
}

uint64_t sub_1B64093FC(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  return objc_msgSend_addObject_(*(void **)(*(void *)(a1 + 32) + 16), a2, (uint64_t)a2, a4);
}

uint64_t sub_1B640940C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_1B6409460(a2, (const char *)a2, a3, a4);
  if (result)
  {
    uint64_t v8 = result;
    uint64_t v9 = *(void **)(*(void *)(a1 + 32) + 16);
    return objc_msgSend_addObject_(v9, v6, v8, v7);
  }
  return result;
}

uint64_t sub_1B6409460(void *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  if (!objc_msgSend_hasPrefix_(a1, a2, @"vfx_node.", a4)) {
    return 0;
  }
  uint64_t v8 = objc_msgSend_length(@"vfx_node.", v5, v6, v7);
  uint64_t v11 = objc_msgSend_substringFromIndex_(a1, v9, v8, v10);
  uint64_t v16 = objc_msgSend_uppercaseString(v11, v12, v13, v14);

  return objc_msgSend_stringByAppendingString_(@"USE_", v15, v16, v17);
}

uint64_t sub_1B64094D8(uint64_t a1, const char *a2, void *a3)
{
  return objc_msgSend_setObject_forKeyedSubscript_(a3, a2, (uint64_t)a2, a1);
}

uint64_t sub_1B64094E8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = sub_1B6409460(a2, (const char *)a2, a3, a4);
  if (result)
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void **)(*(void *)(a1 + 32) + 8);
    return objc_msgSend_setObject_forKeyedSubscript_(v8, v6, (uint64_t)&stru_1F0FCDBB0, v7);
  }
  return result;
}

void sub_1B640A110(_Unwind_Exception *a1)
{
  sub_1B640A148(v1 - 224);
  _Unwind_Resume(a1);
}

uint64_t sub_1B640A148(uint64_t a1)
{
  CFAllocatorRef v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    operator delete(v3);
  }
  unsigned int v4 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + _Block_object_dispose(&STACK[0x5A0], 8) = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1B640A19C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = objc_msgSend_nodeRef(a2, (const char *)a2, a3, a4);
  uint64_t result = sub_1B63F4F54(v5, v6, v7, v8, v9, v10, v11, v12);
  if (result == *(void *)(a1 + 40))
  {
    uint64_t v15 = *(void *)(a1 + 32);
    return MEMORY[0x1F4181798](v15, sel_addedNode_, v5, v14);
  }
  return result;
}

void sub_1B640A348(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1B640A430(void *a1, char *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend_setIsAuthoring_(a1, a2, 1, a4);
  uint64_t v6 = sub_1B6583674((id *)a2);
  objc_msgSend_setAuthoringTargetNode_(a1, v7, (uint64_t)v6, v8);

  return sub_1B64A4DB8((uint64_t)a2, 1);
}

void sub_1B640A618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_1B640A148((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B640AEA8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B640AF08(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B640B92C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_1B640B9B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (void *)sub_1B6497530(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  unint64_t v13 = objc_msgSend_length(v9, v10, v11, v12);
  uint64_t v21 = sub_1B63CC634(v13, v14, v15, v16, v17, v18, v19, v20);
  uint64_t v25 = objc_msgSend_bytes(v9, v22, v23, v24);
  if (v21 == 3)
  {
    uint64_t v33 = v25;
    uint64_t v34 = objc_msgSend_length(v9, v26, v27, v28);
    MEMORY[0x1F4181798](a2, sel_writeBytes_length_, v33, v34);
  }
  else
  {
    sub_1B63F2F54(16, @"Error: SH order unsupported : %d", v27, v28, v29, v30, v31, v32, v21);
  }
}

void sub_1B640C4A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

uint64_t sub_1B640C4B4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = objc_msgSend_isAuthoring(a2, (const char *)a2, a3, a4);
  if (result)
  {
    int v14 = sub_1B649F390(*(void *)(a1 + 40), v7, v8, v9, v10, v11, v12, v13);
    uint64_t v18 = 296;
    if (v14) {
      uint64_t v18 = 280;
    }
    uint64_t v19 = 264;
    if (!*(unsigned char *)(a1 + 48)) {
      uint64_t v19 = v18;
    }
    uint64_t v20 = *(void *)(*(void *)(a1 + 32) + v19);
    uint64_t v21 = objc_msgSend_model(a2, v15, v16, v17);
    Material = objc_msgSend_firstMaterial(v21, v22, v23, v24);
    uint64_t v29 = objc_msgSend_diffuse(Material, v26, v27, v28);
    return objc_msgSend_setColor_(v29, v30, v20, v31);
  }
  return result;
}

void sub_1B640CF98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  objc_sync_exit(v15);
  _Unwind_Resume(a1);
}

uint64_t sub_1B640CFD8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](a3, sel_updateLightNode_withSourceNode_, a2, a1);
}

uint64_t sub_1B640CFE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](a3, sel_updateCameraNode_withSourceNode_, a2, a1);
}

uint64_t sub_1B640CFF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](a3, sel_updateEffectNode_withSourceNode_, a2, a1);
}

uint64_t sub_1B640D008(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4181798](a3, sel_updateFieldNode_withSourceNode_, a2, a1);
}

uint64_t sub_1B640D018(uint64_t a1, char *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v7 = objc_msgSend_pointOfView(*(void **)(a1 + 32), a2, a3, (uint64_t)a4);
  uint64_t result = objc_msgSend_node(a2, v8, v9, v10);
  if (v7 == result)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

uint64_t sub_1B640D310(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = objc_msgSend_worldWithWorldRef_(VFXWorld, a2, a1, a4);
  uint64_t v5 = [VFXAuthoringEnvironment2 alloc];

  return objc_msgSend_initWithWorld_(v5, v6, v4, v7);
}

uint64_t sub_1B640D360(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](a1, sel_addedNode_, a2, a4);
}

uint64_t sub_1B640D368(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](a1, sel_removedNode_, a2, a4);
}

uint64_t sub_1B640D370(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F4181798](a1, sel_updateWithRenderer_, a2, a4);
}

uint64_t sub_1B640D3FC(uint64_t result, int32x4_t *a2, unsigned int a3)
{
  if (a3 + 3 >= 4)
  {
    unint64_t v3 = 0;
    uint64_t v4 = a2 + 6;
    uint64_t v5 = result + 64;
    int32x4_t v6 = vdupq_n_s32(0x7F800000u);
    do
    {
      int32x4_t v7 = 0uLL;
      int32x2_t v8 = 0;
      __int32 v9 = 0;
      int32x4_t v10 = v6;
      int32x4_t v11 = 0uLL;
      if (v3 < a3)
      {
        int32x4_t v10 = v4[-6];
        int32x4_t v11 = v4[-5];
        v8.i32[0] = v4[-4].i32[0];
        __int32 v9 = v4[-4].i32[1];
      }
      uint64_t v12 = 0;
      int32x4_t v13 = v6;
      int32x2_t v14 = 0;
      if (v3 + 1 < a3)
      {
        int32x4_t v13 = v4[-3];
        int32x4_t v7 = v4[-2];
        int32x2_t v14 = *(int32x2_t *)v4[-1].i8;
      }
      int32x4_t v15 = 0uLL;
      int32x4_t v16 = 0uLL;
      int32x4_t v17 = v6;
      if (v3 + 2 < a3)
      {
        int32x4_t v17 = *v4;
        int32x4_t v16 = v4[1];
        uint64_t v12 = v4[2].i64[0];
      }
      uint64_t v18 = 0;
      int32x4_t v19 = v6;
      if (v3 + 3 < a3)
      {
        int32x4_t v19 = v4[3];
        int32x4_t v15 = v4[4];
        uint64_t v18 = v4[5].i64[0];
      }
      float32x2x2_t v20 = (float32x2x2_t)vzip1q_s32(v10, v17);
      v31.val[0] = (float32x2_t)vzip2q_s32(v10, v17).u64[0];
      int32x4_t v21 = vzip1q_s32(v13, v19);
      v31.val[1] = (float32x2_t)vzip2q_s32(v13, v19).u64[0];
      *(void *)&long long v22 = __PAIR64__(v14.u32[1], v9);
      *((void *)&v22 + 1) = __PAIR64__(HIDWORD(v18), HIDWORD(v12));
      float32x2x2_t v23 = (float32x2x2_t)vzip1q_s32(v11, v16);
      *(int32x2_t *)&long long v24 = vzip1_s32(v8, v14);
      *((void *)&v24 + 1) = __PAIR64__(v18, v12);
      uint64_t v25 = (float *)(v5 - 64);
      vst2_f32(v25, v20);
      uint64_t v26 = (float *)(v5 - 32);
      vst2_f32(v26, v31);
      v30.val[0] = (float32x2_t)vzip2q_s32(v11, v16).u64[0];
      int32x4_t v27 = vzip1q_s32(v7, v15);
      v30.val[1] = (float32x2_t)vzip2q_s32(v7, v15).u64[0];
      uint64_t v28 = (float *)(v5 - 16);
      vst2_f32(v28, v23);
      *(int32x4_t *)(v5 - 4_Block_object_dispose(&STACK[0x5A0], 8) = vzip2q_s32((int32x4_t)v20, v21);
      *(int32x4_t *)uint64_t v5 = vzip2q_s32((int32x4_t)v23, v27);
      uint64_t v29 = (float *)(v5 + 16);
      vst2_f32(v29, v30);
      *(_OWORD *)(v5 + 32) = v24;
      *(_OWORD *)(v5 + 4_Block_object_dispose(&STACK[0x5A0], 8) = v22;
      v3 += 4;
      v4 += 12;
      v5 += 128;
    }
    while (((a3 + 3) & 0xFFFFFFFC) != v3);
  }
  return result;
}

float32x4_t *sub_1B640D52C(float32x4_t *result, int a2, float32x4_t *a3, float32x4_t *a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v5 = 0;
    float32x4_t v6 = *a3;
    float32x4_t v7 = a3[1];
    float32x4_t v8 = a3[2];
    float32x4_t v9 = a3[3];
    float32x4_t v10 = *a4;
    float32x4_t v11 = a4[1];
    float32x4_t v12 = a4[2];
    float32x4_t v13 = a4[3];
    float32x4_t v14 = vnegq_f32(v8);
    float32x4_t v15 = vnegq_f32(*a3);
    float32x4_t v16 = vnegq_f32(v7);
    float32x4_t v17 = vnegq_f32(v12);
    float32x4_t v18 = vnegq_f32(*a4);
    float32x4_t v19 = vnegq_f32(v11);
    float32x2x2_t v20 = result + 4;
    do
    {
      float32x4_t v21 = v20[-4];
      float32x4_t v22 = v20[-3];
      float32x4_t v23 = v20[-2];
      float32x4_t v24 = v20[2];
      float32x4_t v25 = vnegq_f32(v24);
      float32x4_t v26 = vaddq_f32(v9, vmlaq_f32(vmlaq_f32(vmulq_f32(v7, v22), v21, v6), v23, v8));
      float32x4_t v27 = vaddq_f32(v13, vmlaq_f32(vmlaq_f32(vmulq_f32(v11, v22), v21, v10), v23, v12));
      if ((vminvq_u32((uint32x4_t)vornq_s8(vmvnq_s8((int8x16_t)vcgeq_f32(v26, v25)), (int8x16_t)vcgeq_f32(v27, v25))) & 0x80000000) != 0)
      {
        if ((v5 & 1) == 0) {
          *(unsigned char *)(a5 + (v5 >> 1)) = 0;
        }
      }
      else
      {
        float32x4_t v28 = v20[3];
        float32x4_t v29 = v20[1];
        float32x4_t v30 = v20[-1];
        float32x4_t v31 = vmlaq_f32(vmulq_f32(*v20, v14), v29, v7);
        float32x4_t v32 = vmlaq_f32(vmulq_f32(v29, v15), v30, v8);
        float32x4_t v33 = vmlaq_f32(vmulq_f32(v30, v16), *v20, v6);
        float32x4_t v34 = vmlaq_f32(vmulq_f32(*v20, vnegq_f32(v33)), v29, v32);
        float32x4_t v35 = vmlaq_f32(vmulq_f32(v29, vnegq_f32(v31)), v30, v33);
        float32x4_t v36 = vmlaq_f32(vmulq_f32(v30, vnegq_f32(v32)), *v20, v31);
        float32x4_t v37 = vmlaq_f32(vmlaq_f32(vmulq_f32(v35, v35), v34, v34), v36, v36);
        float32x4_t v38 = vrsqrteq_f32(v37);
        float32x4_t v39 = vmulq_f32(v38, vrsqrtsq_f32(v37, vmulq_f32(v38, v38)));
        float32x4_t v40 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v39, vrsqrtsq_f32(v37, vmulq_f32(v39, v39))), (int8x16_t)vceqzq_f32(v37));
        float32x4_t v41 = vmlaq_f32(v21, v24, v30);
        float32x4_t v42 = vmlaq_f32(v22, v24, *v20);
        float32x4_t v43 = vmlaq_f32(v23, v24, v29);
        float32x4_t v44 = vaddq_f32(v9, vmlaq_f32(vmlaq_f32(vmulq_f32(v7, vmlaq_f32(v42, v28, vmulq_f32(v40, vnegq_f32(v35)))), vmlaq_f32(v41, v28, vmulq_f32(v40, vnegq_f32(v34))), v6), vmlaq_f32(v43, v28, vmulq_f32(v40, vnegq_f32(v36))), v8));
        float32x4_t v45 = vmlaq_f32(vmulq_f32(*v20, v17), v29, v11);
        float32x4_t v46 = vmlaq_f32(vmulq_f32(v29, v18), v30, v12);
        float32x4_t v47 = vmlaq_f32(vmulq_f32(v30, v19), *v20, v10);
        float32x4_t v48 = vmlaq_f32(vmulq_f32(*v20, vnegq_f32(v47)), v29, v46);
        float32x4_t v49 = vmlaq_f32(vmulq_f32(v29, vnegq_f32(v45)), v30, v47);
        float32x4_t v50 = vmlaq_f32(vmulq_f32(v30, vnegq_f32(v46)), *v20, v45);
        float32x4_t v51 = vmlaq_f32(vmlaq_f32(vmulq_f32(v49, v49), v48, v48), v50, v50);
        float32x4_t v52 = vrsqrteq_f32(v51);
        float32x4_t v53 = vmulq_f32(v52, vrsqrtsq_f32(v51, vmulq_f32(v52, v52)));
        float32x4_t v54 = (float32x4_t)vbicq_s8((int8x16_t)vmulq_f32(v53, vrsqrtsq_f32(v51, vmulq_f32(v53, v53))), (int8x16_t)vceqzq_f32(v51));
        float32x4_t v55 = vaddq_f32(v13, vmlaq_f32(vmlaq_f32(vmulq_f32(v11, vmlaq_f32(v42, v28, vmulq_f32(v54, vnegq_f32(v49)))), vmlaq_f32(v41, v28, vmulq_f32(v54, vnegq_f32(v48))), v10), vmlaq_f32(v43, v28, vmulq_f32(v54, vnegq_f32(v50))), v12));
        int8x16_t v56 = vandq_s8(vandq_s8(vorrq_s8((int8x16_t)vcltzq_f32(vmulq_f32(v26, v44)), (int8x16_t)vcgezq_f32(vminnmq_f32(v26, v44))), vorrq_s8((int8x16_t)vcltzq_f32(vmulq_f32(v27, v55)), (int8x16_t)vcgezq_f32(vminnmq_f32(v27, v55)))), (int8x16_t)xmmword_1B6E50330);
        *(int8x8_t *)v56.i8 = vorr_s8(*(int8x8_t *)v56.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v56, v56, 8uLL));
        unsigned __int8 v57 = vadd_s32(*(int32x2_t *)v56.i8, vdup_lane_s32(*(int32x2_t *)v56.i8, 1)).u8[0];
        uint64_t v58 = v5 >> 1;
        if (v5) {
          unsigned __int8 v57 = *(unsigned char *)(a5 + v58) | (16 * v57);
        }
        *(unsigned char *)(a5 + v5_Block_object_dispose(&STACK[0x5A0], 8) = v57;
      }
      ++v5;
      v20 += 8;
    }
    while (a2 != v5);
  }
  return result;
}

uint64_t sub_1B640D7B8(uint64_t result, int32x4_t *a2, unsigned int a3)
{
  if (a3 + 3 >= 4)
  {
    unint64_t v3 = 0;
    uint64_t v4 = (float *)(result + 32);
    uint64_t v5 = a2 + 2;
    do
    {
      int32x4_t v6 = (int32x4_t)xmmword_1B6E50340;
      if (v3 < a3) {
        int32x4_t v6 = v5[-2];
      }
      int32x4_t v7 = (int32x4_t)xmmword_1B6E50340;
      if (v3 + 1 < a3) {
        int32x4_t v7 = v5[-1];
      }
      int32x4_t v8 = (int32x4_t)xmmword_1B6E50340;
      if (v3 + 2 < a3) {
        int32x4_t v8 = *v5;
      }
      int32x4_t v9 = (int32x4_t)xmmword_1B6E50340;
      if (v3 + 3 < a3) {
        int32x4_t v9 = v5[1];
      }
      float32x2x2_t v10 = (float32x2x2_t)vzip1q_s32(v6, v8);
      v16.val[0] = (float32x2_t)vzip2q_s32(v6, v8).u64[0];
      int32x4_t v11 = vzip1q_s32(v7, v9);
      *(void *)&long long v12 = vuzp2q_s32(vuzp2q_s32(v6, v7), v6).u64[0];
      *((void *)&v12 + 1) = __PAIR64__(v9.u32[3], v8.u32[3]);
      v16.val[1] = (float32x2_t)vzip2q_s32(v7, v9).u64[0];
      float32x4_t v13 = v4 - 8;
      vst2_f32(v13, v10);
      *((int32x4_t *)v4 - 1) = vzip2q_s32((int32x4_t)v10, v11);
      float32x4_t v14 = v4 + 16;
      vst2_f32(v4, v16);
      float32x4_t v15 = v4 + 4;
      *float32x4_t v15 = v12;
      v3 += 4;
      v5 += 4;
      uint64_t v4 = v14;
    }
    while (((a3 + 3) & 0xFFFFFFFC) != v3);
  }
  return result;
}

float32x4_t *sub_1B640D880(float32x4_t *result, int a2, float32x4_t *a3, float32x4_t *a4, uint64_t a5)
{
  if (a2)
  {
    uint64_t v5 = 0;
    float32x4_t v6 = *a3;
    float32x4_t v7 = a3[1];
    float32x4_t v8 = a3[2];
    float32x4_t v9 = a3[3];
    float32x4_t v10 = *a4;
    float32x4_t v11 = a4[1];
    float32x4_t v12 = a4[2];
    float32x4_t v13 = a4[3];
    float32x4_t v14 = result + 2;
    do
    {
      float32x4_t v15 = vnegq_f32(v14[1]);
      int8x16_t v16 = vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(vaddq_f32(v9, vmlaq_f32(vmlaq_f32(vmulq_f32(v7, v14[-1]), v14[-2], v6), *v14, v8)), v15), (int8x16_t)vcgeq_f32(vaddq_f32(v13, vmlaq_f32(vmlaq_f32(vmulq_f32(v11, v14[-1]), v14[-2], v10), *v14, v12)), v15)), (int8x16_t)xmmword_1B6E50330);
      *(int8x8_t *)v16.i8 = vorr_s8(*(int8x8_t *)v16.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL));
      unsigned __int8 v17 = vadd_s32(*(int32x2_t *)v16.i8, vdup_lane_s32(*(int32x2_t *)v16.i8, 1)).u8[0];
      uint64_t v18 = v5 >> 1;
      if (v5) {
        unsigned __int8 v17 = *(unsigned char *)(a5 + v18) | (16 * v17);
      }
      *(unsigned char *)(a5 + v1_Block_object_dispose(&STACK[0x5A0], 8) = v17;
      ++v5;
      v14 += 4;
    }
    while (a2 != v5);
  }
  return result;
}

uint64_t *sub_1B640D920(CFX::RG *a1, CFX::RG::RenderGraphContext *a2, CFX::RG::Resource *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v14 = sub_1B64A3B48(*(void *)(a4 + 16), (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!v14) {
    return 0;
  }
  uint64_t v15 = (uint64_t)v14;
  float32x4_t v110 = (const CFX::RG::Resource **)a6;
  int8x16_t v16 = *(CFX::RG::RenderGraphBuilder **)a5;
  unsigned __int8 v17 = *(CFX::RG::Resource **)(a5 + 48);
  uint64_t v18 = (_OWORD *)CFX::RG::Resource::constTextureDesc(*(CFX::RG::Resource **)a5);
  CFX::RG::TextureDescriptorReference::withSampleCount(v18, 1, (uint64_t)&v112);
  float32x2x2_t v20 = CFX::RG::copyIfNeeded_r(a1, v16, v17, (CFX::RG::Pass *)&v112, (const CFX::RG::TextureDescriptorReference *)"PostProcess color input resolve", v19);
  float32x4_t v22 = v21;
  float32x4_t v23 = *(CFX::RG::Resource **)(a5 + 8);
  float32x4_t v24 = *(CFX::RG::Resource **)(a5 + 48);
  float32x4_t v25 = (_OWORD *)CFX::RG::Resource::constTextureDesc(v23);
  CFX::RG::TextureDescriptorReference::withSampleCount(v25, 1, (uint64_t)&v112);
  float32x4_t v26 = v24;
  float32x4_t v27 = v20;
  uint64_t v107 = CFX::RG::copyIfNeeded(a1, v23, v26, (CFX::RG::Pass *)&v112, (const CFX::RG::TextureDescriptorReference *)"PostProcess depth input resolve", v28);
  unsigned int v111 = a2;
  float32x4_t v29 = (unsigned __int16 *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(a2, v20);
  unsigned int v37 = *v29;
  unsigned int v38 = v29[1];
  long long v39 = *(_OWORD *)(v29 + 10);
  long long v40 = *(_OWORD *)(v29 + 26);
  long long v131 = *(_OWORD *)(v29 + 18);
  v132[0] = v40;
  *(_OWORD *)((char *)v132 + 12) = *((_OWORD *)v29 + 4);
  long long v129 = *(_OWORD *)(v29 + 2);
  long long v130 = v39;
  *(float *)&long long v39 = (float)v37;
  __int16 v109 = v38;
  *((float *)&v39 + 1) = (float)v38;
  *(void *)(a4 + _Block_object_dispose(&STACK[0x5A0], 8) = v39;
  if (*(unsigned char *)(a4 + 2))
  {
    float32x4_t v41 = *(const CFX::RG::Resource **)(a4 + 16);
    int32x4_t v112 = a3;
    uint64_t v113 = v41;
    long long v42 = *(_OWORD *)(a5 + 16);
    *(_OWORD *)int32x2_t v114 = *(_OWORD *)a5;
    *(_OWORD *)&v114[16] = v42;
    *(void *)&v114[32] = *(void *)(a5 + 32);
    *(_DWORD *)&v114[40] = 2;
    *(void *)((char *)&v115 + 4) = 0;
    float32x4_t v22 = sub_1B644B2A0((uint64_t *)a1, (uint64_t *)&v112, 0);
    float32x4_t v27 = *(const CFX::RG::Resource **)((char *)&v115 + 4);
  }
  if (*(unsigned char *)(a4 + 5))
  {
    uint64_t v44 = sub_1B649A798(v15, v30, v31, v32, v33, v34, v35, v36);
    int32x4_t v112 = a3;
    uint64_t v113 = v27;
    *(void *)int32x2_t v114 = *(void *)(a5 + 40);
    *(void *)&v114[8] = v44;
    float32x4_t v22 = sub_1B642042C((uint64_t *)a1, (uint64_t *)&v112);
    float32x4_t v27 = (const CFX::RG::Resource *)v22[52];
  }
  if (*(unsigned char *)(a4 + 6))
  {
    float32x4_t v45 = (long long *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(v111, v27);
    long long v124 = *v45;
    long long v46 = v45[4];
    long long v48 = v45[1];
    long long v47 = v45[2];
    long long v127 = v45[3];
    long long v128 = v46;
    long long v125 = v48;
    long long v126 = v47;
    float32x4_t v49 = *(const CFX::RG::Resource **)(a4 + 16);
    float32x4_t v50 = a3;
    int32x4_t v112 = a3;
    uint64_t v113 = v49;
    CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v114, &v124);
    uint64_t v117 = v27;
    uint64_t v118 = 0;
    float32x4_t v22 = sub_1B643D540(a1, v111, &v112, (CFX::RG::Resource *)v22);
    float32x4_t v27 = (const CFX::RG::Resource *)v22[70];
  }
  else
  {
    float32x4_t v50 = a3;
  }
  long long v121 = *(_OWORD *)a4;
  uint64_t v122 = *(void *)(a4 + 16);
  sub_1B64E40C4(&v123, v50, &v121);
  if (sub_1B64E40C8(&v123))
  {
    __int16 v106 = v37;
    v120[0] = (uint64_t)v50;
    v120[1] = (uint64_t)v27;
    float32x4_t v43 = (uint64_t *)sub_1B64E4EC0((uint64_t *)a1, v120, (long long *)a4, &v123);
    if (*(unsigned char *)(a4 + 3))
    {
      int32x4_t v112 = v50;
      uint64_t v113 = v20;
      uint64_t v58 = *(void *)(a4 + 16);
      *(void *)int32x2_t v114 = v107;
      *(void *)&v114[8] = v58;
      *(_OWORD *)&v114[16] = (unint64_t)sub_1B649A680(v15, v51, v52, v53, v54, v55, v56, v57);
      uint64_t v63 = sub_1B6551824((uint64_t *)a1, (uint64_t)&v112, (CFX::RG::Resource *)v22, 0, v59, v60, v61, v62);
      uint64_t v64 = (CFX::RG::Resource *)v63[72];
      sub_1B64E4EA8(v43, v64);
    }
    else
    {
      uint64_t v64 = 0;
      uint64_t v63 = 0;
    }
    if (*(unsigned char *)(a4 + 4))
    {
      uint64_t v73 = sub_1B649AE28(v15, v51, v52, v53, v54, v55, v56, v57);
      CFArrayRef v74 = a3;
      if (!v73) {
        sub_1B63F2F54(17, @"Assertion '%s' failed. Null argument", v67, v68, v69, v70, v71, v72, (uint64_t)"lensBlur");
      }
      float v75 = sub_1B6529330(v73, v66, v67, v68, v69, v70, v71, v72);
      unsigned int v83 = sub_1B652BBB0(v73, v76, v77, v78, v79, v80, v81, v82);
      __int16 v84 = (long long *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(v111, v27);
      long long v124 = *v84;
      long long v85 = v84[4];
      long long v87 = v84[1];
      long long v86 = v84[2];
      long long v127 = v84[3];
      long long v128 = v85;
      long long v125 = v87;
      long long v126 = v86;
      if (v64) {
        unint64_t v88 = v64;
      }
      else {
        unint64_t v88 = v27;
      }
      int32x4_t v112 = a3;
      uint64_t v113 = v88;
      *(float *)int32x2_t v114 = v75;
      *(void *)&v114[8] = v83;
      CFX::RG::TextureDescriptorReference::TextureDescriptorReference(&v114[16], &v124);
      uint64_t v119 = 0;
      if (v63) {
        unsigned int v89 = (CFX::RG::Resource *)v63;
      }
      else {
        unsigned int v89 = (CFX::RG::Resource *)v22;
      }
      uint64_t v63 = sub_1B66192A4(a1, v111, (uint64_t *)&v112, v89);
      uint64_t v64 = (CFX::RG::Resource *)v63[62];
      uint64_t v108 = v63;
    }
    else
    {
      uint64_t v108 = 0;
      CFArrayRef v74 = a3;
    }
    if (*(unsigned char *)(a4 + 1))
    {
      *(_OWORD *)&v114[28] = v130;
      long long v115 = v131;
      v116[0] = v132[0];
      *(_OWORD *)((char *)v116 + 12) = *(_OWORD *)((char *)v132 + 12);
      uint64_t v90 = *(const CFX::RG::Resource **)(a4 + 16);
      int32x4_t v112 = v74;
      uint64_t v113 = v90;
      if (v64) {
        __int16 v91 = v64;
      }
      else {
        __int16 v91 = v27;
      }
      *(void *)int32x2_t v114 = v91;
      *(_WORD *)&v114[8] = v106;
      *(_WORD *)&v114[10] = v109;
      if (v63) {
        uint64_t v92 = (uint64_t)v63;
      }
      else {
        uint64_t v92 = (uint64_t)v22;
      }
      *(_OWORD *)&v114[12] = v129;
      long long v93 = (CFX::RG::Resource **)sub_1B63C7980((uint64_t *)a1, (uint64_t)v111, (uint64_t)&v112, v92, v54, v55, v56, v57);
    }
    else
    {
      long long v93 = 0;
    }
    int v94 = *(unsigned __int8 *)(a4 + 7);
    if (*(unsigned char *)(a4 + 7))
    {
      long long v95 = (long long *)CFX::RG::RenderGraphContext::resolvedTextureDescriptor(v111, v27);
      long long v124 = *v95;
      long long v96 = v95[4];
      long long v98 = v95[1];
      long long v97 = v95[2];
      long long v127 = v95[3];
      long long v128 = v96;
      long long v125 = v98;
      long long v126 = v97;
      long long v99 = *(const CFX::RG::Resource **)(a4 + 16);
      int32x4_t v112 = v74;
      uint64_t v113 = v99;
      CFX::RG::TextureDescriptorReference::TextureDescriptorReference(v114, &v124);
      if (v64) {
        long long v100 = v64;
      }
      else {
        long long v100 = v27;
      }
      uint64_t v117 = v93;
      uint64_t v118 = v100;
      uint64_t v119 = 0;
      if (v63) {
        long long v101 = (CFX::RG::Resource *)v63;
      }
      else {
        long long v101 = (CFX::RG::Resource *)v22;
      }
      float32x4_t v22 = sub_1B64491D8(a1, v111, &v112, v101);
      float32x4_t v27 = (const CFX::RG::Resource *)v22[60];
      CFX::RG::Pass::dependsOn(v43, (CFX::RG::Pass *)v22);
      if (*(unsigned char *)(a4 + 1)) {
        CFX::RG::Pass::dependsOn(v22, (CFX::RG::Pass *)v93);
      }
      int v94 = *(unsigned __int8 *)(a4 + 7);
      __int16 v65 = v110;
    }
    else
    {
      __int16 v65 = v110;
    }
    if (*(unsigned char *)(a4 + 1) && !v94)
    {
      sub_1B64E4EB0(v43, v93[93]);
      CFX::RG::Pass::dependsOn(v43, (CFX::RG::Pass *)v93);
      int v94 = *(unsigned __int8 *)(a4 + 7);
    }
    if (v108 && *(unsigned char *)(a4 + 4) && !v94) {
      sub_1B64E4EB8(v43, (CFX::RG::Resource *)v108[62]);
    }
    unsigned int v102 = (_OWORD *)CFX::RG::Resource::textureDesc(v27);
    CFX::RG::TextureDescriptorReference::withSampleCount(v102, 1, (uint64_t)&v112);
    uint64_t v104 = (CFX::RG::Resource *)CFX::RG::copyIfNeeded(a1, v27, (CFX::RG::Resource *)v22, (CFX::RG::Pass *)&v112, 0, v103);
    sub_1B64E4EA0(v43, v104);
    float32x4_t v27 = (const CFX::RG::Resource *)v43[59];
  }
  else
  {
    float32x4_t v43 = v22;
    __int16 v65 = v110;
  }
  char *v65 = v27;
  return v43;
}

void *sub_1B640DED4(uint64_t a1, uint64_t a2)
{
  uint64_t result = (void *)sub_1B6DABD0C(a1, "PostProcess");
  void *result = &unk_1F0FB2E20;
  result[3] = a2;
  return result;
}

uint64_t sub_1B640DF20@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v4[1] = *MEMORY[0x1E4F143B8];
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)v4, *(_WORD *)(a1 + 8), 9273, 1656467160);
  return sub_1B63D0050(a2, v4, 1);
}

void sub_1B640DF9C(uint64_t a1@<X0>, void *a2@<X8>)
{
  sub_1B64E3F20(v4, *(void *)(a1 + 24), 0);
  *a2 = 0;
  a2[1] = a2 + 2;
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v3, 9273, 9273, 1656467160);
  sub_1B63D0190((uint64_t)a2, &v3);
  CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v3, 9273, 9273, -797957750);
  sub_1B63D0190((uint64_t)a2, &v3);
  if (v4[5])
  {
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v3, 9273, 9273, -1170177454);
    sub_1B63D0190((uint64_t)a2, &v3);
  }
  if (v4[2])
  {
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v3, 9273, 9273, 1490954098);
    sub_1B63D0190((uint64_t)a2, &v3);
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v3, 9273, 9273, -691122579);
    sub_1B63D0190((uint64_t)a2, &v3);
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v3, 9273, 9273, 839732700);
    sub_1B63D0190((uint64_t)a2, &v3);
  }
}

void sub_1B640E0C4(_Unwind_Exception *exception_object)
{
  if (*(_DWORD *)(v1 + 4)) {
    free(*(void **)(v1 + 8));
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1B640E0F4(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  unint64_t v3 = *(unsigned __int16 *)(a1 + 8);
  uint64_t v4 = *a3;
  if (v4)
  {
    uint64_t v5 = (uint64_t *)*((void *)a3 + 1);
    uint64_t v6 = 8 * v4;
    do
    {
      uint64_t v7 = *v5++;
      uint64_t v10 = v7;
      uint64_t v8 = CFX::RG::ResourceIdentifier::id((CFX::RG::ResourceIdentifier *)&v10);
      unint64_t v3 = 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69
           * (v3 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v3)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v3)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v3)))) >> 47));
      v6 -= 8;
    }
    while (v6);
  }
  return v3;
}

void sub_1B640E17C(uint64_t a1, CFX::RG::RenderGraphContext *a2, CFX::RG *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float32x4_t v11 = sub_1B6446564(*(uint64_t **)(a1 + 24), (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (v11 && sub_1B64A3B48((uint64_t)v11, v12, v13, v14, v15, v16, v17, v18))
  {
    uint64_t v46 = 0;
    long long v44 = 0u;
    long long v45 = 0u;
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v41, 9273, 9273, 1656467160);
    CFX::RG::ResourceReference::ResourceReference((uint64_t)v42, v41);
    v43[0] = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"Post process input color", (CFX::RG::ResourceReference *)v42);
    CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v39, 9273, 9273, -797957750);
    CFX::RG::ResourceReference::ResourceReference((uint64_t)v40, v39);
    v43[1] = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"Post process input depth", (CFX::RG::ResourceReference *)v40);
    sub_1B64E3F20(v38, *(void *)(a1 + 24), 0);
    if (v38[2])
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v36, 9273, 9273, 1490954098);
      CFX::RG::ResourceReference::ResourceReference((uint64_t)v37, v36);
      *(void *)&long long v44 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"Post process input normal", (CFX::RG::ResourceReference *)v37);
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v34, 9273, 9273, 839732700);
      CFX::RG::ResourceReference::ResourceReference((uint64_t)v35, v34);
      *((void *)&v44 + 1) = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"Post process input radiance", (CFX::RG::ResourceReference *)v35);
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v32, 9273, 9273, -691122579);
      CFX::RG::ResourceReference::ResourceReference((uint64_t)v33, v32);
      *(void *)&long long v45 = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"Post process input reflectance roughness", (CFX::RG::ResourceReference *)v33);
    }
    if (v38[5])
    {
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v30, 9273, 9273, -1170177454);
      CFX::RG::ResourceReference::ResourceReference((uint64_t)v31, v30);
      *((void *)&v45 + 1) = sub_1B63EF7BC((uint64_t)a3, (uint64_t)"Post process input velocity", (CFX::RG::ResourceReference *)v31);
    }
    unint64_t v29 = 0;
    float32x4_t v21 = sub_1B640D920(a3, a2, *(CFX::RG::Resource **)(a1 + 24), (uint64_t)v38, (uint64_t)v43, (uint64_t)&v29, v19, v20);
    if (v21)
    {
      uint64_t v22 = (uint64_t)v21;
      float32x4_t v23 = (unsigned char *)v21[3];
      char v24 = *v23;
      if (*v23)
      {
        float32x4_t v25 = v23 + 1;
        __int16 v26 = -25147;
        do
        {
          __int16 v26 = 403 * (v26 ^ v24);
          int v27 = *v25++;
          char v24 = v27;
        }
        while (v27);
      }
      else
      {
        __int16 v26 = -25147;
      }
      CFX::RG::ResourceIdentifier::ResourceIdentifier((uint64_t)&v28, *(_WORD *)(a1 + 8), v26, 1656467160);
      CFX::RG::RenderGraphBuilder::publishResourceReference((uint64_t)a3, v28, v29, v22);
    }
  }
}

void sub_1B640E3F0()
{
}

double sub_1B640E404(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int8x16_t v6 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v6.i8 = vadd_s32(*(int32x2_t *)v6.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  int32x2_t v7 = vadd_s32(*(int32x2_t *)v6.i8, vdup_lane_s32(*(int32x2_t *)v6.i8, 1));
  unsigned int v8 = *(unsigned __int16 *)(*(void *)(a1 + 64) + v7.i32[0]);
  int v9 = (v8 >> 10) & 0x1F;
  if (v9 == 31) {
    int v10 = 2139095040;
  }
  else {
    int v10 = (v8 >> 10) & 0x1F;
  }
  if (v9) {
    _ZF = v9 == 31;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    int v12 = v10;
  }
  else {
    int v12 = (v9 << 23) + 939524096;
  }
  v7.i32[0] = v12 | (v8 << 16) & 0x80000000 | (v8 >> 7) & 7 | (8 * (v8 & 0x3FF)) & 0x1FFF | ((v8 & 0x3FF) << 13);
  *(void *)&double result = vdupq_lane_s32(v7, 0).u64[0];
  return result;
}

double sub_1B640E4B0(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  unsigned int v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  *(void *)&double result = vld1q_dup_f32(v8).u64[0];
  return result;
}

double sub_1B640E514(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  v7.i64[0] = *(void *)(*(void *)(a1 + 64)
                        + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  v8.i64[0] = 0x8000000080000000;
  v8.i64[1] = 0x8000000080000000;
  int32x4_t v9 = (int32x4_t)vandq_s8((int8x16_t)vmovl_s16(*(int16x4_t *)v7.i8), v8);
  int8x16_t v10 = (int8x16_t)vshll_n_u16(*(uint16x4_t *)v7.i8, 0xDuLL);
  int32x4_t v11 = (int32x4_t)vorrq_s8(vandq_s8(v10, (int8x16_t)vdupq_n_s32(0xF800000u)), vorrq_s8((int8x16_t)v9, vandq_s8(v10, (int8x16_t)vdupq_n_s32(0x7FE000u))));
  v9.i64[0] = 0x3800000038000000;
  v9.i64[1] = 0x3800000038000000;
  *(void *)&double result = vaddq_s32(v11, v9).u64[0];
  return result;
}

double sub_1B640E5AC(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0)
  {
    *(void *)&long long v8 = 0;
  }
  else
  {
    int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
    *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
    long long v8 = *(_OWORD *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  }
  return *(double *)&v8;
}

double sub_1B640E60C(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1));
  v7.i8[0] = *(unsigned char *)(*(void *)(a1 + 64) + v7.i32[0]);
  *(float *)v7.i32 = (float)v7.u32[0] * 0.0039216;
  *(void *)&double result = vdupq_lane_s32(*(int32x2_t *)v7.i8, 0).u64[0];
  return result;
}

double sub_1B640E680(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  int32x2_t v8 = vdup_lane_s32(*(int32x2_t *)v7.i8, 1);
  v7.i32[0] = vadd_s32(*(int32x2_t *)v7.i8, v8).u32[0];
  v7.i8[0] = *(unsigned char *)(*(void *)(a1 + 64) + v7.i32[0]);
  *(float *)v8.i32 = (float)v7.u32[0] * 0.0039216;
  int32x4_t v9 = vcgeq_f32((float32x4_t)vdupq_lane_s32(v8, 0), (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v9.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v9), (int8x16_t)vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)vdupq_n_s32(0x3D11FA77u), *(float *)v8.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)vdupq_n_s32(0x3F622C5Fu), *(float *)v8.i32), *(float *)v8.i32 * *(float *)v8.i32), vmlaq_n_f32(vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)vdupq_n_s32(0x3F6BC556u), *(float *)v8.i32), vmlaq_n_f32((float32x4_t)vdupq_n_s32(0xBF12862E),
                                          (float32x4_t)vdupq_n_s32(0x3E1C096Eu),
                                          *(float *)v8.i32),
                                        *(float *)v8.i32 * *(float *)v8.i32),
                                      (float)(*(float *)v8.i32 * *(float *)v8.i32)
                                    * (float)(*(float *)v8.i32 * *(float *)v8.i32)),
                         (int8x16_t)vmulq_n_f32((float32x4_t)vdupq_n_s32(0x3D9E8391u), *(float *)v8.i32)).u64[0];
  return result;
}

double sub_1B640E7A8(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  int32x2_t v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10)), (float32x4_t)vdupq_n_s32(0x3B808081u)).u64[0];
  return result;
}

double sub_1B640E834(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  int32x2_t v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  float32x4_t v11 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10));
  float32x4_t v12 = vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v13 = vmulq_f32(v12, v12);
  float32x4_t v14 = vmulq_f32(v13, v13);
  float32x4_t v15 = vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v11), v13, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v11));
  float32x4_t v16 = vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v11), v13, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v11));
  int32x4_t v17 = vcgeq_f32(v12, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v17.i32[3] = 0;
  *(void *)&double result = vbslq_s8((int8x16_t)vcltzq_s32(v17), (int8x16_t)vmlaq_f32(v16, v14, v15), (int8x16_t)vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x399F22B4u))).u64[0];
  return result;
}

double sub_1B640E964(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  int32x2_t v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  int8x16_t v11 = (int8x16_t)vrev64q_s32((int32x4_t)vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10)), (float32x4_t)vdupq_n_s32(0x3B808081u)));
  *(void *)&double result = vextq_s8(v11, v11, 0xCuLL).u64[0];
  return result;
}

double sub_1B640E9F8(uint64_t a1, float32x4_t a2)
{
  a2.i32[3] = 0;
  __asm { FMOV            V1.4S, #1.0 }
  if ((vmaxvq_u32((uint32x4_t)vorrq_s8((int8x16_t)vcgeq_f32(a2, _Q1), (int8x16_t)vcltzq_f32(a2))) & 0x80000000) != 0) {
    return 0.0;
  }
  int8x16_t v7 = (int8x16_t)vmulq_s32(*(int32x4_t *)(a1 + 32), vminq_s32(vcvtq_s32_f32(vmulq_f32(*(float32x4_t *)a1, a2)), *(int32x4_t *)(a1 + 16)));
  *(int32x2_t *)v7.i8 = vadd_s32(*(int32x2_t *)v7.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v7, v7, 8uLL));
  int32x2_t v8 = (const float *)(*(void *)(a1 + 64) + vadd_s32(*(int32x2_t *)v7.i8, vdup_lane_s32(*(int32x2_t *)v7.i8, 1)).i32[0]);
  uint32x4_t v9 = (uint32x4_t)vld1q_dup_f32(v8);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  float32x4_t v11 = vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v9, (uint32x4_t)xmmword_1B6E50360), v10));
  float32x4_t v12 = vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x3B808081u));
  float32x4_t v13 = vmulq_f32(v12, v12);
  int8x16_t v14 = (int8x16_t)vmlaq_f32(vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3A5DBC4Du), (float32x4_t)xmmword_1B6E503A0, v11), v13, vmlaq_f32((float32x4_t)vdupq_n_s32(0x3EF653C9u), (float32x4_t)xmmword_1B6E50390, v11)), vmulq_f32(v13, v13), vmlaq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF66EEDE), (float32x4_t)xmmword_1B6E50380, v11), v13, vmlaq_f32((float32x4_t)vdupq_n_s32(0xBF12862E), (float32x4_t)xmmword_1B6E50370, v11)));
  int32x4_t v15 = vcgeq_f32(v12, (float32x4_t)vdupq_n_s32(0x3D25AEE6u));
  v15.i32[3] = 0;
  int32x4_t v16 = (int32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v15), v14, (int8x16_t)vmulq_f32(v11, (float32x4_t)vdupq_n_s32(0x399F22B4u)));
  v16.i32[3] = v12.i32[3];
  int8x16_t v17 = (int8x16_t)vrev64q_s32(v16);
  *(void *)&double result = vextq_s8(v17, v17, 0xCuLL).u64[0];
  return result;
}