void sub_10000715C(uint64_t a1)
{
  void *v1;
  void v2[4];
  id v3;

  v1 = *(void **)(*(void *)(a1 + 32) + 24);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_1000213DC;
  v2[3] = &unk_10073A260;
  v3 = *(id *)(a1 + 40);
  [v1 dismissedDiscoveryItems:v2];
}

void sub_10000725C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = v3;
    if (!v3)
    {
      __break(1u);
      return;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
    [*(id *)(a1 + 24) removeObject:v4];
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 12));
    id v3 = v4;
  }
}

void sub_1000072CC(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    id v3 = (os_unfair_lock_s *)(a1 + 8);
    id v4 = a2;
    os_unfair_lock_lock(v3);
    [*(id *)(a1 + 40) addObject:v4];

    os_unfair_lock_unlock(v3);
  }
}

void sub_100007500(uint64_t a1)
{
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v13;
    do
    {
      v6 = 0;
      do
      {
        if (*(void *)v13 != v5) {
          objc_enumerationMutation(v2);
        }
        v7 = *(void **)(a1 + 40);
        v8 = objc_msgSend(*(id *)(*((void *)&v12 + 1) + 8 * (void)v6), "identifier", (void)v12);
        v9 = [v7 objectForKey:v8];

        if (v9) {
          [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) addObject:v9];
        }

        v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v4);
  }

  uint64_t v10 = *(void *)(a1 + 48);
  id v11 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) copy];
  (*(void (**)(uint64_t, id))(v10 + 16))(v10, v11);
}

void sub_1000077EC(uint64_t a1)
{
  v1 = *(void **)(*(void *)(a1 + 32) + 24);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_1003993E8;
  v2[3] = &unk_1007378B8;
  id v3 = *(id *)(a1 + 40);
  [v1 processDiscoveryItemsAndMessagesWithCompletion:v2];
}

void sub_100007AA4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  id v2 = [*(id *)(*(void *)(a1 + 32) + 8) dismissedDiscoveryItems];
  (*(void (**)(uint64_t, id, void))(v1 + 16))(v1, v2, 0);
}

unsigned __int8 *sub_100007B70(unsigned __int8 *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!atomic_load(result + 32)) {
      +[NSException raise:NSInternalInconsistencyException format:@"PDApplicationMessageManager: cannot fetch registrations before connection attempt."];
    }
    id v3 = (os_unfair_lock_s *)(v1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)v1 + 4);
    id v4 = [*((id *)v1 + 5) copy];
    os_unfair_lock_unlock(v3);
    return (unsigned __int8 *)v4;
  }
  return result;
}

void sub_100007BE8(uint64_t a1)
{
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 24);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_1000213C8;
  v2[3] = &unk_100736918;
  id v3 = *(id *)(a1 + 40);
  [v1 discoveryArticleLayoutsWithCompletion:v2];
}

void sub_100007CE8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_1004669DC;
  v2[3] = &unk_10073D508;
  void v2[4] = v1;
  id v3 = *(id *)(a1 + 40);
  objc_msgSend(v1, "_queue_processDiscoveryItemsAndMessagesShouldForceBadgeCountUpdate:completion:", 0, v2);
}

id sub_100007EB8(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 32));
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 24);
  *(void *)(v2 + 24) = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 32));
  id v4 = *(void **)(a1 + 32);
  return [v4 _executeNextRequestIfPossible];
}

id *sub_100007FA0(os_unfair_lock_s *a1)
{
  WeakRetained = (id *)a1;
  if (a1)
  {
    uint64_t v2 = a1 + 3;
    os_unfair_lock_lock(a1 + 3);
    WeakRetained = (id *)objc_loadWeakRetained(WeakRetained + 2);
    os_unfair_lock_unlock(v2);
  }
  return WeakRetained;
}

PDAccountService *sub_100008034(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDAccountService alloc] initWithConnection:v3 server:v4];

  return v5;
}

uint64_t PDNFSecureXPCEventIsSecureElementEvent(uint64_t result, uint64_t *a2)
{
  if (result)
  {
    id v3 = (const char *)result;
    if (!strcmp((const char *)result, "com.apple.stockholm.tsm.script.executed"))
    {
      if (!a2) {
        return 1;
      }
      result = 0;
      goto LABEL_18;
    }
    if (strcmp(v3, "com.apple.stockholm.se.update.by.tsm"))
    {
      if (strcmp(v3, "com.apple.stockholm.express.applets.updated"))
      {
        if (strcmp(v3, "com.apple.stockholm.express.config.failure"))
        {
          if (strcmp(v3, "com.apple.stockhom.radio.stateChanged")) {
            return 0;
          }
          if (!a2) {
            return 1;
          }
          result = 4;
          goto LABEL_18;
        }
        if (a2)
        {
          result = 3;
          goto LABEL_18;
        }
        return 1;
      }
      if (!a2) {
        return 1;
      }
      result = 2;
LABEL_18:
      *a2 = result;
      return 1;
    }
    result = 1;
    if (a2) {
      goto LABEL_18;
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_10000817C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_10000C004;
    v5[3] = &unk_10072FDC8;
    v5[4] = a1;
    id v6 = v3;
    sub_100012974(a1, v5);
  }
}

void sub_100008218(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_type_t type = xpc_get_type(v3);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10000EE30(*(void *)(a1 + 32), v3);
    goto LABEL_8;
  }
  if (type != (xpc_type_t)&_xpc_type_error)
  {
    uint64_t v5 = PKLogFacilityTypeGetObject();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
LABEL_6:

      xpc_connection_cancel(*(xpc_connection_t *)(a1 + 40));
      goto LABEL_8;
    }
    uint64_t v6 = *(void *)(a1 + 40);
    int v12 = 134217984;
    uint64_t v13 = v6;
    v7 = "PDNFSecureXPCEventStreamManager: unexpected type for event from peer %p - canceling connection.";
LABEL_5:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v12, 0xCu);
    goto LABEL_6;
  }
  if (v3 == &_xpc_error_termination_imminent) {
    goto LABEL_8;
  }
  if (v3 == &_xpc_error_connection_interrupted)
  {
    uint64_t v5 = PKLogFacilityTypeGetObject();
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_6;
    }
    uint64_t v10 = *(void *)(a1 + 40);
    int v12 = 134217984;
    uint64_t v13 = v10;
    v7 = "PDNFSecureXPCEventStreamManager: peer %p interrupted.";
    goto LABEL_5;
  }
  uint64_t v5 = PKLogFacilityTypeGetObject();
  BOOL v8 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3 != &_xpc_error_connection_invalid)
  {
    if (!v8) {
      goto LABEL_6;
    }
    uint64_t v9 = *(void *)(a1 + 40);
    int v12 = 134217984;
    uint64_t v13 = v9;
    v7 = "PDNFSecureXPCEventStreamManager: unexpected error dictionary for peer %p - canceling connection.";
    goto LABEL_5;
  }
  if (v8)
  {
    uint64_t v11 = *(void *)(a1 + 40);
    int v12 = 134217984;
    uint64_t v13 = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: peer %p invalidated.", (uint8_t *)&v12, 0xCu);
  }

  [*(id *)(*(void *)(a1 + 32) + 24) removeObjectIdenticalTo:*(void *)(a1 + 40)];
  xpc_connection_set_event_handler(*(xpc_connection_t *)(a1 + 40), &stru_100747148);
LABEL_8:
}

uint64_t sub_10000842C(uint64_t a1)
{
  if ((PKUseMockSURFServer() & 1) == 0 && !PKStoreDemoModeEnabled())
  {
    if ([*(id *)(*(void *)(a1 + 32) + 56) needsRegistration])
    {
      uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
      goto LABEL_4;
    }
    if (*(unsigned char *)(a1 + 48))
    {
      id v4 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Preventing fetching the peer payment account from the server if it was necessary.", buf, 2u);
      }

      return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    if ([*(id *)(*(void *)(a1 + 32) + 64) isAccountStateDirty])
    {
      uint64_t v5 = [*(id *)(*(void *)(a1 + 32) + 64) associatedAccountInformation];
      unsigned int v6 = [v5 isAssociatedAccountStateDirty];

      if (v6)
      {
        v7 = *(void **)(a1 + 32);
        +[NSSet setWithObjects:@"CashReasonAccountDirty", @"CashReasonAssociatedAccountDirty", 0];
        BOOL v8 = LABEL_16:;
        [v7 updateAccountAndAssociatedAccountsWithDiagnosticReasons:v8 completion:0];
LABEL_23:

        return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
      }
    }
    unsigned int v9 = [*(id *)(*(void *)(a1 + 32) + 64) isAccountStateDirty];
    uint64_t v10 = *(id **)(a1 + 32);
    if (v9)
    {
      CFStringRef v11 = @"CashReasonAccountDirty";
LABEL_19:
      BOOL v8 = +[NSSet setWithObject:v11];
      [v10 updateAccountWithDiagnosticReasons:v8 completion:0];
      goto LABEL_23;
    }
    int v12 = [v10[8] associatedAccountInformation];
    unsigned int v13 = [v12 isAssociatedAccountStateDirty];

    long long v14 = *(id **)(a1 + 32);
    if (v13)
    {
      CFStringRef v15 = @"CashReasonAssociatedAccountDirty";
    }
    else
    {
      unsigned int v16 = [v14[8] isAccountOutOfDate];
      uint64_t v10 = *(id **)(a1 + 32);
      if (v16)
      {
        CFStringRef v11 = @"CashReasonAccountProactiveFetch";
        goto LABEL_19;
      }
      if ([v10[8] areAssociatedAccountsOutOfDate]
        && [*(id *)(*(void *)(a1 + 32) + 64) isAccountOutOfDate])
      {
        v7 = *(void **)(a1 + 32);
        +[NSSet setWithObjects:@"CashReasonAssociatedAccountProactiveFetch", @"CashReasonAccountProactiveFetch", 0];
        goto LABEL_16;
      }
      if (![*(id *)(*(void *)(a1 + 32) + 64) areAssociatedAccountsOutOfDate]) {
        return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
      }
      long long v14 = *(id **)(a1 + 32);
      CFStringRef v15 = @"CashReasonAssociatedAccountProactiveFetch";
    }
    BOOL v8 = +[NSSet setWithObject:v15];
    [v14 updateAssociatedAccountsWithDiagnosticReasons:v8 completion:0];
    goto LABEL_23;
  }
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
LABEL_4:
  return v2();
}

void sub_1000086C4(void *a1, void *a2)
{
  uint64_t v3 = a1[20];
  id v6 = a2;
  id v4 = a1;
  [v6 setDiscoveryManager:v3];
  uint64_t v5 = v4[21];

  [v6 setRuleManager:v5];
}

void sub_100008734(void *a1, void *a2)
{
  uint64_t v3 = a1[16];
  id v6 = a2;
  id v4 = a1;
  [v6 setAccountManager:v3];
  uint64_t v5 = v4[62];

  [v6 setStatementMetadataProcessor:v5];
}

PDDiscoveryService *sub_1000087A4(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDDiscoveryService alloc] initWithConnection:v3 server:v4];

  return v5;
}

uint64_t PDNFSecureXPCEventIsFieldDetectEvent(uint64_t result, uint64_t *a2)
{
  if (!result)
  {
    __break(1u);
    return result;
  }
  id v3 = (const char *)result;
  if (!strcmp((const char *)result, "com.apple.stockholm.wallet.presentment.field-detect"))
  {
    if (!a2) {
      return 1;
    }
    result = 0;
LABEL_8:
    *a2 = result;
    return 1;
  }
  if (strcmp(v3, "com.apple.stockholm.field.off")) {
    return 0;
  }
  result = 1;
  if (a2) {
    goto LABEL_8;
  }
  return result;
}

PDPeerPaymentService *sub_100008DCC(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDPeerPaymentService alloc] initWithConnection:v3 server:v4];

  return v5;
}

void sub_100008E40(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138412290;
    id v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Family members received: %@", (uint8_t *)&v6, 0xCu);
  }

  uint64_t v5 = *(void *)(a1 + 32);
  if (v5) {
    (*(void (**)(uint64_t, id))(v5 + 16))(v5, v3);
  }
}

PDPassLibrary *sub_1000091D0(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDPassLibrary alloc] initWithConnection:v3 server:v4];

  [(PDPassLibrary *)v5 setDelegate:v4];
  return v5;
}

void sub_1000093A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  kdebug_trace();
  uint64_t v5 = *(void **)(a1 + 32);
  id v7 = v3;
  int v6 = +[NSArray arrayWithObjects:&v7 count:1];
  [v5 _deliverEvents:v6 eventsWerePreviouslyDeferred:0];
}

void sub_100009744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100009868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100009974(void *a1, uint64_t a2, void *a3, void *a4)
{
  int v6 = a4;
  id v13 = a3;
  uint64_t v7 = PDOSTransactionCreate("PDPaymentService");
  uint64_t v8 = *(void *)(a1[5] + 8);
  unsigned int v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v7;

  id v10 = sub_10002196C(*(id *)(a1[4] + 312));
  uint64_t v11 = *(void *)(a1[6] + 8);
  int v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  v6[2](v6, v13, 0);
}

void sub_100009D50(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v4 = *(id *)(*(void *)(a1 + 32) + 8);
  id v5 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v11;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v4);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v10 + 1) + 8 * (void)v8) + 16))(*(void *)(*((void *)&v10 + 1) + 8 * (void)v8));
        uint64_t v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v6);
  }

  uint64_t v9 = *(void *)(a1 + 40);
  if (v9) {
    (*(void (**)(uint64_t))(v9 + 16))(v9);
  }
}

void PDNFSecureXPCEventHandleFieldDetectEvent(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (!v5 || (uint64_t v7 = v6) == 0) {
    __break(1u);
  }
  if (a1 == 1)
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    id v17 = [v6 countByEnumeratingWithState:&v21 objects:v30 count:16];
    if (v17)
    {
      id v18 = v17;
      uint64_t v19 = *(void *)v22;
      do
      {
        for (i = 0; i != v18; i = (char *)i + 1)
        {
          if (*(void *)v22 != v19) {
            objc_enumerationMutation(v7);
          }
          [*(id *)(*((void *)&v21 + 1) + 8 * i) receivedSecureFieldExitEvent];
        }
        id v18 = [v7 countByEnumeratingWithState:&v21 objects:v30 count:16];
      }
      while (v18);
    }
  }
  else if (!a1)
  {
    uint64_t v8 = xpc_dictionary_get_value(v5, "field");
    if (v8)
    {
      uint64_t v9 = [(id)PKGetClassNFFieldNotification() fieldNotificationFromXPCObject:v8];
      if (v9)
      {
        uint64_t v10 = +[PKFieldProperties fieldPropertiesForFieldNotification:v9];
        if (v10)
        {
          long long v11 = v10;
          long long v28 = 0u;
          long long v29 = 0u;
          long long v26 = 0u;
          long long v27 = 0u;
          id v12 = v7;
          id v13 = [v12 countByEnumeratingWithState:&v26 objects:v31 count:16];
          if (v13)
          {
            id v14 = v13;
            uint64_t v15 = *(void *)v27;
            do
            {
              for (j = 0; j != v14; j = (char *)j + 1)
              {
                if (*(void *)v27 != v15) {
                  objc_enumerationMutation(v12);
                }
                [*(id *)(*((void *)&v26 + 1) + 8 * (void)j) receivedSecureFieldEntranceEventWithProperties:v11];
              }
              id v14 = [v12 countByEnumeratingWithState:&v26 objects:v31 count:16];
            }
            while (v14);
          }

LABEL_27:
          goto LABEL_28;
        }
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    long long v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: ignoring field presentation request with no properties.", buf, 2u);
    }
    goto LABEL_27;
  }
LABEL_28:
}

void sub_10000A0D8(uint64_t a1)
{
  if (!*(void *)(a1 + 48))
  {
    if ([*(id *)(a1 + 32) isEqualToString:PDDarwinNotificationMobileKeyBagFirstUnlock])
    {
      uint64_t v2 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Keybag unlocked notification received", buf, 2u);
      }

      char v3 = 0;
      atomic_compare_exchange_strong((atomic_uchar *volatile)(*(void *)(a1 + 40) + 9), (unsigned __int8 *)&v3, 1u);
      if (!v3) {
        sub_100035694(*(void *)(a1 + 40), 2);
      }
    }
    else if ([*(id *)(a1 + 32) isEqualToString:off_100803F88()])
    {
      id v4 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "iCloud restore complete notification received", buf, 2u);
      }

      char v5 = 0;
      atomic_compare_exchange_strong((atomic_uchar *volatile)(*(void *)(a1 + 40) + 10), (unsigned __int8 *)&v5, 1u);
      if (!v5)
      {
        PDRestorePassdPreferences();
        sub_100035694(*(void *)(a1 + 40), 0);
        if (PKPassbookIsCurrentlyDeletedByUser()) {
          sub_100046B50(*(id **)(a1 + 40));
        }
      }
    }
    else if ([*(id *)(a1 + 32) isEqualToString:off_100803F90()])
    {
      dispatch_time_t v6 = dispatch_time(0, 10000000000);
      uint64_t v7 = PDDefaultQueue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100046BF0;
      block[3] = &unk_10072E1E8;
      block[4] = *(void *)(a1 + 40);
      dispatch_after(v6, v7, block);
    }
    else if ([*(id *)(a1 + 32) isEqualToString:PKDarwinNotificationEventLostModeStateChanged])
    {
      uint64_t v8 = +[FMDFMIPManager sharedInstance];
      unsigned __int8 v9 = [v8 lostModeIsActive];

      if (v9)
      {
        uint64_t v10 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Lost Mode Is Active", buf, 2u);
        }

        PKSetNeedsLostModeExitAuth();
        PKAnalyticsSendEvent();
      }
      else
      {
        PKAnalyticsSendEvent();
        long long v11 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Processing Lost Mode Exit", buf, 2u);
        }

        id v12 = [*(id *)(*(void *)(a1 + 40) + 48) allPaymentApplications];
        if ([v12 count])
        {
          id v13 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Starting FMDFMIP lost mode exit.", buf, 2u);
          }

          long long v11 = +[FMDFMIPManager sharedInstance];
          v18[0] = _NSConcreteStackBlock;
          v18[1] = 3221225472;
          v18[2] = sub_100046CE8;
          v18[3] = &unk_10072F6E8;
          v18[4] = *(void *)(a1 + 40);
          [v11 initiateLostModeExitAuthWithCompletion:v18];
        }
        else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "No Cards. Skipping Lost Mode Exit", buf, 2u);
        }
      }
    }
    else if ([*(id *)(a1 + 32) isEqualToString:PKDarwinNotificationEventDeveloperImageMounted])
    {
      id v17 = [*(id *)(*(void *)(a1 + 40) + 96) sharedWebServiceContext];
      [v17 setConfigurationDate:0];
      [*(id *)(*(void *)(a1 + 40) + 96) updateSharedWebServiceContext:v17];
      [*(id *)(*(void *)(a1 + 40) + 96) updateWebServiceConfigurationWithCompletion:0];
    }
    else if ([*(id *)(a1 + 32) isEqualToString:PDDarwinNotificationEventPasswordChanged])
    {
      sub_1000388F4(*(void *)(a1 + 40), 1, 0);
      [*(id *)(*(void *)(a1 + 40) + 272) notePasscodeChanged];
      if (PKPasscodeEnabled())
      {
        uint64_t v14 = *(void *)(a1 + 40);
        sub_100046DF0(v14, 0);
      }
    }
    else if ([*(id *)(a1 + 32) isEqualToString:PDDarwinNotificationEventBluetoothPowerChanged])
    {
      uint64_t v15 = *(void **)(*(void *)(a1 + 40) + 192);
      _[v15 updateSubcredentialsForBluetoothPowerChange];
    }
    else if ([*(id *)(a1 + 32) isEqualToString:PDDarwinNotificationEventAppProtectionChanged])
    {
      unsigned int v16 = *(void **)(*(void *)(a1 + 40) + 616);
      [v16 updateHideCardsWhileLockedEnforcement];
    }
  }
}

void sub_10000A668(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412290;
      id v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Error loading family members: %@", (uint8_t *)&v10, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    if (*(unsigned char *)(*(void *)(a1 + 32) + 16)) {
      [v5 pendingMembers];
    }
    else {
    uint64_t v8 = [v5 members];
    }
    unsigned __int8 v9 = [*(id *)(a1 + 32) _pkFamilyMemberArrayFromFAFamilyMemberArray:v8];
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_10000A7B4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  unsigned int v3 = [WeakRetained processIdentifier];
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    int v5 = *(unsigned __int8 *)(a1 + 64);
    *(_DWORD *)buf = 67109632;
    int v19 = v5;
    __int16 v20 = 2048;
    id v21 = WeakRetained;
    __int16 v22 = 1024;
    unsigned int v23 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "PDXPCServiceListener %u (%p:%d): connection invalidated", buf, 0x18u);
  }

  [*(id *)(a1 + 32) clearConnectionReference];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 24));
  [*(id *)(*(void *)(a1 + 56) + 32) removeObject:*(void *)(a1 + 32)];
  if (*(unsigned char *)(a1 + 64) == 2)
  {
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v6 = *(id *)(*(void *)(a1 + 56) + 32);
    id v7 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v14;
      while (2)
      {
        int v10 = 0;
        do
        {
          if (*(void *)v14 != v9) {
            objc_enumerationMutation(v6);
          }
          id v11 = objc_msgSend(*(id *)(*((void *)&v13 + 1) + 8 * (void)v10), "connection", (void)v13);
          unsigned int v12 = [v11 processIdentifier];

          if (v12 == v3)
          {

            goto LABEL_14;
          }
          int v10 = (char *)v10 + 1;
        }
        while (v8 != v10);
        id v8 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
        if (v8) {
          continue;
        }
        break;
      }
    }

    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 56) + 24));
    objc_msgSend(*(id *)(*(void *)(a1 + 40) + 280), "removeListenerEndpointsForProcessIdentifier:", objc_msgSend(WeakRetained, "processIdentifier"));
  }
  else
  {
LABEL_14:
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 56) + 24));
  }
}

void sub_10000A9C8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  PKTimeProfileBegin();
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_100469F6C;
  v12[3] = &unk_100737B60;
  uint64_t v9 = *(void **)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  id v14 = v7;
  uint64_t v15 = v8;
  v12[4] = v9;
  id v13 = v6;
  id v10 = v6;
  id v11 = v7;
  objc_msgSend(v9, "_queue_activeDialogRequestSourcedDiscoveryItems:", v12);
}

void sub_10000ABD8(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableArray);
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  id v3 = *(id *)(*(void *)(a1 + 32) + 64);
  id v4 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v16;
    do
    {
      id v7 = 0;
      do
      {
        if (*(void *)v16 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = [*(id *)(*((void *)&v15 + 1) + 8 * (void)v7) copy];
        [v2 addObject:v8];

        id v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v5);
  }

  uint64_t v9 = *(NSObject **)(*(void *)(a1 + 32) + 24);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1000213EC;
  v12[3] = &unk_10072E598;
  id v10 = *(id *)(a1 + 40);
  id v13 = v2;
  id v14 = v10;
  id v11 = v2;
  dispatch_async(v9, v12);
}

void sub_10000AD78(void *a1, void *a2)
{
  uint64_t v3 = a1[14];
  id v6 = a2;
  id v4 = a1;
  [v6 setPeerPaymentAccountManager:v3];
  [v6 setPeerPaymentWebServiceCoordinator:v4[13]];
  [v6 setDatabaseManager:v4[6]];
  [v6 setUserNotificationManager:v4[7]];
  uint64_t v5 = v4[40];

  [v6 setIdsSharingManager:v5];
}

void sub_10000BA70(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 32);
  *(void *)(v2 + 32) = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
  uint64_t v4 = *(void *)(a1 + 32);
  if (*(void *)(v4 + 40))
  {
    [*(id *)(v4 + 40) invalidate];
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = 0;

    uint64_t v4 = *(void *)(a1 + 32);
  }
  id v7 = sub_100007FA0((os_unfair_lock_s *)v4);
  id v8 = v7;
  if (v7) {
    unsigned __int8 v9 = [v7 fieldDetectorManagerShouldSuppressFieldEvents:*(void *)(a1 + 32)];
  }
  else {
    unsigned __int8 v9 = 0;
  }
  uint64_t v10 = PKAnalyticsSubjectFieldDetect;
  uint64_t v27 = PKAnalyticsReportEventKey;
  uint64_t v28 = PKAnalyticsReportEventTypeFieldExited;
  id v11 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
  +[PKAnalyticsReporter subject:v10 sendEvent:v11];

  +[PKAnalyticsReporter endSubjectReporting:v10];
  unsigned int v12 = PKLogFacilityTypeGetObject();
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (!v3)
  {
    if (v9)
    {
      if (!v13) {
        goto LABEL_25;
      }
      *(_WORD *)buf = 0;
      __int16 v20 = "PDFieldDetectorManager: did exit field (suppressed).";
    }
    else
    {
      if (!v13) {
        goto LABEL_25;
      }
      *(_WORD *)buf = 0;
      __int16 v20 = "PDFieldDetectorManager: did exit field (unbalanced).";
    }
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v20, buf, 2u);
    goto LABEL_25;
  }
  if (v13)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PDFieldDetectorManager: did exit field.", buf, 2u);
  }

  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
  id v14 = [*(id *)(*(void *)(a1 + 32) + 24) allObjects];
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  unsigned int v12 = v14;
  id v15 = [v12 countByEnumeratingWithState:&v21 objects:v26 count:16];
  if (v15)
  {
    id v16 = v15;
    uint64_t v17 = *(void *)v22;
    do
    {
      for (i = 0; i != v16; i = (char *)i + 1)
      {
        if (*(void *)v22 != v17) {
          objc_enumerationMutation(v12);
        }
        int v19 = *(void **)(*((void *)&v21 + 1) + 8 * i);
        if (objc_opt_respondsToSelector()) {
          objc_msgSend(v19, "fieldDetectorManagerDidExitField:", *(void *)(a1 + 32), (void)v21);
        }
      }
      id v16 = [v12 countByEnumeratingWithState:&v21 objects:v26 count:16];
    }
    while (v16);
  }

LABEL_25:
}

void sub_10000BE2C(id a1, PKAsyncOperationState *a2, NSNull *a3, id a4)
{
  uint64_t v5 = a3;
  id v6 = a4;
  id v7 = PDHeavyQueue();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100021388;
  v10[3] = &unk_10072E598;
  id v11 = v5;
  id v12 = v6;
  id v8 = v5;
  id v9 = v6;
  dispatch_async(v7, v10);
}

void sub_10000C004(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(unsigned __int8 *)(v3 + 24);
  if (*(unsigned char *)(v3 + 24)
    || (*(unsigned char *)(*(void *)(a1 + 32) + 24) = sub_10000C100(v3, @"BEGIN IMMEDIATE TRANSACTION;")) != 0)
  {
    int v5 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
    if (!v4)
    {
      if (v5) {
        sub_10000C100(*(void *)(a1 + 32), @"COMMIT;");
      }
      else {
        sub_10000C100(*(void *)(a1 + 32), @"ROLLBACK;");
      }
      *(unsigned char *)(*(void *)(a1 + 32) + 24) = 0;
    }
  }
}

BOOL sub_10000C100(BOOL a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (a1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2020000000;
    char v12 = 0;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_100019C6C;
    v6[3] = &unk_100739568;
    v6[4] = a1;
    id v7 = v3;
    id v8 = &v9;
    sub_100012974(a1, v6);
    a1 = *((unsigned char *)v10 + 24) != 0;

    _Block_object_dispose(&v9, 8);
  }

  return a1;
}

void sub_10000C1DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000C590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000D08C(uint64_t a1)
{
  uint64_t v2 = (void *)PDOSTransactionCreate("PDPassLibrary");
  id v11 = 0;
  id v12 = 0;
  id v10 = 0;
  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 88), "getCatalog:passes:dbStates:ofPassTypes:limitResults:", &v11, &v12, &v10, objc_msgSend(*(id *)(a1 + 40), "allowedPassType"), objc_msgSend(*(id *)(a1 + 40), "limitResults"));
  [*(id *)(a1 + 32) _sanitizePasses:v12];
  int v4 = [*(id *)(*(void *)(a1 + 32) + 192) passDynamicStatesFromStates:v10];
  int v5 = 0;
  if ([*(id *)(a1 + 40) includeAnnotations])
  {
    int v5 = [*(id *)(*(void *)(a1 + 32) + 88) updatedPassAnnotationsForPasses:v12];
  }
  id v6 = [*(id *)(*(void *)(a1 + 32) + 88) accounts];
  id v7 = objc_alloc((Class)PKGroupsControllerSnapshot);
  if (v4) {
    id v8 = v4;
  }
  else {
    id v8 = &__NSDictionary0__struct;
  }
  id v9 = [v7 initWithPasses:v12 states:v8 annotations:v5 accounts:v6 catalog:v11];
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

uint64_t PDNFSecureXPCEventIsAccessKeyEvent(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  if (result)
  {
    id v5 = [objc_alloc((Class)NSString) initWithUTF8String:result];
    if ([v5 isEqualToString:@"com.apple.secureelementservice.dck.event.vehicle.did.disconnect"])
    {
      uint64_t v6 = 0;
      uint64_t v7 = 1;
    }
    else
    {
      if ([v5 isEqualToString:@"com.apple.secureelementservice.dck.event.vehicle.did.lock"])
      {
        uint64_t v6 = 0;
        uint64_t v8 = 1;
        uint64_t v7 = 2;
        if (!a2) {
          goto LABEL_35;
        }
        goto LABEL_32;
      }
      if ([v5 isEqualToString:@"com.apple.secureelementservice.dck.event.vehicle.did.unlock"])
      {
        uint64_t v6 = 0;
        uint64_t v8 = 1;
        uint64_t v7 = 3;
        if (!a2) {
          goto LABEL_35;
        }
        goto LABEL_32;
      }
      if ([v5 isEqualToString:@"com.apple.secureelementservice.dck.event.vehicle.did.ranging.start"])
      {
        uint64_t v6 = 0;
        uint64_t v8 = 1;
        uint64_t v7 = 5;
        if (!a2) {
          goto LABEL_35;
        }
        goto LABEL_32;
      }
      if ([v5 isEqualToString:@"com.apple.secureelementservice.dck.event.did.ranging.resume"])
      {
        uint64_t v6 = 0;
        uint64_t v8 = 1;
        uint64_t v7 = 6;
        if (!a2) {
          goto LABEL_35;
        }
        goto LABEL_32;
      }
      if ([v5 isEqualToString:@"com.apple.secureelementservice.dck.event.did.ranging.suspend"])
      {
        uint64_t v6 = 0;
        uint64_t v8 = 1;
        uint64_t v7 = 8;
        if (!a2) {
          goto LABEL_35;
        }
        goto LABEL_32;
      }
      if ([v5 isEqualToString:@"com.apple.secureelementservice.dck.event.vehicle.did.status.update"])
      {
        uint64_t v6 = 0;
        uint64_t v8 = 1;
        uint64_t v7 = 9;
        if (!a2) {
          goto LABEL_35;
        }
        goto LABEL_32;
      }
      if ([v5 isEqualToString:@"deprecated"])
      {
        uint64_t v6 = 0;
        uint64_t v8 = 1;
        uint64_t v7 = 10;
        if (!a2) {
          goto LABEL_35;
        }
        goto LABEL_32;
      }
      if ([v5 isEqualToString:@"com.apple.secureelementservice.dck.event.vehicle.did.rke.action.start"])
      {
        uint64_t v6 = 0;
        uint64_t v8 = 1;
        uint64_t v7 = 11;
        if (!a2) {
          goto LABEL_35;
        }
        goto LABEL_32;
      }
      if ([v5 isEqualToString:@"com.apple.secureelementservice.dck.event.vehicle.did.rke.action.complete"])
      {
        uint64_t v6 = 0;
        uint64_t v8 = 1;
        uint64_t v7 = 12;
        if (!a2)
        {
LABEL_35:

          return v8;
        }
LABEL_32:
        if (a3)
        {
          if (v8)
          {
            *a3 = v6;
            *a2 = v7;
          }
        }
        goto LABEL_35;
      }
      if ([v5 isEqualToString:@"com.apple.secureelementservice.acwg.event.did.connect"])
      {
        uint64_t v7 = 0;
      }
      else
      {
        if (([v5 isEqualToString:@"com.apple.secureelementservice.acwg.event.did.disconnect"] & 1) == 0)
        {
          if ([v5 isEqualToString:@"com.apple.secureelementservice.acwg.event.did.lock"])
          {
            uint64_t v6 = 1;
            uint64_t v7 = 2;
          }
          else if ([v5 isEqualToString:@"com.apple.secureelementservice.acwg.event.did.unlock"])
          {
            uint64_t v6 = 1;
            uint64_t v7 = 3;
          }
          else if ([v5 isEqualToString:@"com.apple.secureelementservice.acwg.event.did.jam"])
          {
            uint64_t v6 = 1;
            uint64_t v7 = 4;
          }
          else if ([v5 isEqualToString:@"com.apple.secureelementservice.acwg.event.did.ranging.start"])
          {
            uint64_t v6 = 1;
            uint64_t v7 = 5;
          }
          else
          {
            if (([v5 isEqualToString:@"com.apple.secureelementservice.acwg.event.did.ranging.end"] & 1) == 0)
            {
              id v9 = [v5 isEqualToString:@"com.apple.secureelementservice.acwg.event.did.status.update"];
              uint64_t v8 = (uint64_t)v9;
              if (v9) {
                uint64_t v7 = 9;
              }
              else {
                uint64_t v7 = 0;
              }
              uint64_t v6 = v9;
              if (!a2) {
                goto LABEL_35;
              }
              goto LABEL_32;
            }
            uint64_t v6 = 1;
            uint64_t v7 = 7;
          }
          goto LABEL_4;
        }
        uint64_t v7 = 1;
      }
      uint64_t v6 = 1;
    }
LABEL_4:
    uint64_t v8 = 1;
    if (!a2) {
      goto LABEL_35;
    }
    goto LABEL_32;
  }
  __break(1u);
  return result;
}

void sub_10000D758(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000D7A4(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000D7F0(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000D83C(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000D888(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000D8D4(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10000D920(void *a1)
{
  if (*(unsigned char *)(a1[4] + 16))
  {
    uint64_t v2 = *(void (**)(void))(a1[5] + 16);
    v2();
  }
  else
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for discovery service", v6, 2u);
    }

    uint64_t v4 = a1[6];
    if (v4)
    {
      id v5 = +[NSError errorWithDomain:PKDiscoveryErrorDomain code:1 userInfo:0];
      (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v5);
    }
  }
}

void sub_10000DA18(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) peerPaymentAllAccess])
  {
    id v3 = [*(id *)(a1 + 32) peerPaymentWebServiceCoordinator];
    [v3 accountWithPreventingServerFetch:0 completion:*(void *)(a1 + 40)];
  }
  else
  {
    uint64_t v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      id v5 = "-[PDPeerPaymentService accountWithCompletion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

uint64_t sub_10000DD18(uint64_t a1)
{
  [*(id *)(a1 + 32) _validateDefaultPaymentPassOrdering];
  uint64_t v36 = a1;
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  v63[0] = @"pass_group.group_order";
  v63[1] = @"ingested_date";
  id v3 = +[NSArray arrayWithObjects:v63 count:2];
  v62[0] = @"ASC";
  v62[1] = @"DESC";
  uint64_t v4 = +[NSArray arrayWithObjects:v62 count:2];
  v31 = +[SQLiteEntity queryWithDatabase:v2 predicate:0 orderingProperties:v3 orderingDirections:v4];

  v61[0] = @"group_pid";
  v61[1] = @"unique_id";
  v61[2] = @"pass_group.group_order";
  v61[3] = @"pass_flavor";
  v61[4] = @"grouping_id";
  v61[5] = @"template";
  v61[6] = @"pass_type.identifier";
  v30 = +[NSArray arrayWithObjects:v61 count:7];
  id v5 = objc_alloc_init((Class)NSMutableArray);
  v56[0] = 0;
  v56[1] = v56;
  v56[2] = 0x3032000000;
  v56[3] = sub_100020D7C;
  v56[4] = sub_1000211B0;
  id v57 = 0;
  v51[0] = _NSConcreteStackBlock;
  v51[1] = 3221225472;
  v51[2] = sub_10001721C;
  v51[3] = &unk_10074FCD0;
  v55 = v56;
  id v6 = objc_alloc_init((Class)NSMutableDictionary);
  id v52 = v6;
  id v53 = *(id *)(v36 + 40);
  id v7 = v5;
  id v54 = v7;
  [v31 enumeratePersistentIDsAndProperties:v30 usingBlock:v51];
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  id obj = v7;
  id v8 = [obj countByEnumeratingWithState:&v47 objects:v60 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v48;
    uint64_t v32 = *(void *)v48;
    id v33 = v6;
    do
    {
      id v10 = 0;
      id v34 = v8;
      do
      {
        if (*(void *)v48 != v9) {
          objc_enumerationMutation(obj);
        }
        uint64_t v11 = *(void *)(*((void *)&v47 + 1) + 8 * (void)v10);
        id v12 = objc_msgSend(v6, "objectForKeyedSubscript:", v11, v30);
        BOOL v13 = [v12 uniqueIDs];
        if ((unint64_t)[v13 count] >= 2)
        {
          uint64_t v14 = *(void *)(*(void *)(v36 + 32) + 8);
          id v15 = +[SQLiteComparisonPredicate predicateWithProperty:@"pid" equalToValue:v11];
          id v16 = +[SQLiteEntity anyInDatabase:v14 predicate:v15];

          if (v16)
          {
            v38 = [v16 sortedPassUniqueIdentifiers];
            if (v38)
            {
              id v17 = [objc_alloc((Class)NSMutableSet) initWithArray:v13];
              id v18 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", objc_msgSend(v13, "count"));
              v35 = v16;
              long long v45 = 0u;
              long long v46 = 0u;
              long long v43 = 0u;
              long long v44 = 0u;
              id v19 = v38;
              id v20 = [v19 countByEnumeratingWithState:&v43 objects:v59 count:16];
              if (v20)
              {
                uint64_t v21 = *(void *)v44;
                do
                {
                  for (i = 0; i != v20; i = (char *)i + 1)
                  {
                    if (*(void *)v44 != v21) {
                      objc_enumerationMutation(v19);
                    }
                    uint64_t v23 = *(void *)(*((void *)&v43 + 1) + 8 * i);
                    if ([v17 containsObject:v23])
                    {
                      [v18 addObject:v23];
                      [v17 removeObject:v23];
                    }
                  }
                  id v20 = [v19 countByEnumeratingWithState:&v43 objects:v59 count:16];
                }
                while (v20);
              }

              long long v41 = 0u;
              long long v42 = 0u;
              long long v39 = 0u;
              long long v40 = 0u;
              id v24 = v13;
              id v25 = [v24 countByEnumeratingWithState:&v39 objects:v58 count:16];
              if (v25)
              {
                uint64_t v26 = *(void *)v40;
                do
                {
                  for (j = 0; j != v25; j = (char *)j + 1)
                  {
                    if (*(void *)v40 != v26) {
                      objc_enumerationMutation(v24);
                    }
                    uint64_t v28 = *(void *)(*((void *)&v39 + 1) + 8 * (void)j);
                    if ([v17 containsObject:v28])
                    {
                      [v18 addObject:v28];
                      [v17 removeObject:v28];
                    }
                  }
                  id v25 = [v24 countByEnumeratingWithState:&v39 objects:v58 count:16];
                }
                while (v25);
              }

              id v6 = v33;
              id v8 = v34;
              uint64_t v9 = v32;
              id v16 = v35;
              [v12 setUniqueIDs:v18];
            }
          }
        }
        id v10 = (char *)v10 + 1;
      }
      while (v10 != v8);
      id v8 = [obj countByEnumeratingWithState:&v47 objects:v60 count:16];
    }
    while (v8);
  }

  _Block_object_dispose(v56, 8);
  return 1;
}

void sub_10000E2DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
}

void sub_10000E548(void *a1, void *a2)
{
  uint64_t v3 = a1[9];
  id v6 = a2;
  uint64_t v4 = a1;
  [v6 setSecureElement:v3];
  [v6 setExpressPassManager:v4[42]];
  [v6 setCardFileManager:v4[4]];
  [v6 setDatabaseManager:v4[6]];
  [v6 setUserNotificationManager:v4[7]];
  [v6 setWebServicesCoordinator:v4[36]];
  [v6 setPaymentWebServicesCoordinator:v4[12]];
  [v6 setRelevantPassProvider:v4[41]];
  [v6 setUsageNotificationServer:v4[38]];
  [v6 setIdsManager:v4[39]];
  [v6 setSpotlightIndexer:v4[44]];
  [v6 setAccountManager:v4[16]];
  [v6 setDefaultPassManager:v4[45]];
  [v6 setExpressUpgradeController:v4[49]];
  [v6 setSubcredentialManager:v4[24]];
  [v6 setCarKeyRequirementsChecker:v4[26]];
  [v6 setIssuerBindingManager:v4[70]];
  [v6 setPassLiveRenderManager:v4[72]];
  [v6 setDynamicStateManager:v4[71]];
  [v6 setPushProvisioningManager:v4[28]];
  [v6 setIsoManager:v4[27]];
  [v6 setAuxiliaryCapabilityManager:v4[31]];
  [v6 setDeviceRegistrationServiceCoordinator:v4[34]];
  uint64_t v5 = v4[73];

  [v6 setProvisioningRequirementsChecker:v5];
}

void sub_10000E9E8(uint64_t a1)
{
  if (PKForceEnableAllDiscoveryCardsInWallet())
  {
    id v2 = objc_alloc_init((Class)NSMutableArray);
    uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 8) discoveryItems];
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    id v4 = [v3 countByEnumeratingWithState:&v47 objects:v52 count:16];
    if (v4)
    {
      uint64_t v5 = *(void *)v48;
      do
      {
        for (i = 0; i != v4; i = (char *)i + 1)
        {
          if (*(void *)v48 != v5) {
            objc_enumerationMutation(v3);
          }
          id v7 = *(void **)(*((void *)&v47 + 1) + 8 * i);
          if ([v7 status] != (id)4) {
            [v2 addObject:v7];
          }
        }
        id v4 = [v3 countByEnumeratingWithState:&v47 objects:v52 count:16];
      }
      while (v4);
    }
    id v8 = [v2 copy];
  }
  else
  {
    uint64_t v9 = *(void **)(*(void *)(a1 + 32) + 8);
    id v10 = +[NSDate date];
    uint64_t v11 = [v9 activeDiscoveryItemsForRelevantDate:v10];

    id v8 = [*(id *)(a1 + 32) _filterItemsForViewCount:v11];
  }
  dispatch_group_t v12 = dispatch_group_create();
  BOOL v13 = *(void **)(*(void *)(a1 + 32) + 304);
  if (v13) {
    uint64_t v14 = (char *)[v13 count];
  }
  else {
    uint64_t v14 = 0;
  }
  id v15 = [v8 count];
  uint64_t v41 = 0;
  long long v42 = &v41;
  uint64_t v43 = 0x3032000000;
  long long v44 = sub_100020E08;
  long long v45 = sub_1000211F8;
  id v46 = [objc_alloc((Class)NSMutableArray) initWithCapacity:&v14[(void)v15]];
  id v16 = *(void **)(*(void *)(a1 + 32) + 304);
  if (v16)
  {
    long long v39 = 0u;
    long long v40 = 0u;
    long long v38 = 0u;
    long long v37 = 0u;
    id v17 = v16;
    id v18 = [v17 countByEnumeratingWithState:&v37 objects:v51 count:16];
    if (v18)
    {
      uint64_t v19 = *(void *)v38;
      do
      {
        for (j = 0; j != v18; j = (char *)j + 1)
        {
          if (*(void *)v38 != v19) {
            objc_enumerationMutation(v17);
          }
          [(id)v42[5] addObject:*(void *)(*((void *)&v37 + 1) + 8 * (void)j)];
        }
        id v18 = [v17 countByEnumeratingWithState:&v37 objects:v51 count:16];
      }
      while (v18);
    }
  }
  id v21 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:v15];
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 3221225472;
  v33[2] = sub_10045F6FC;
  v33[3] = &unk_10073ACF8;
  long long v22 = v12;
  uint64_t v23 = *(void *)(a1 + 32);
  id v34 = v22;
  uint64_t v35 = v23;
  id v24 = v21;
  id v36 = v24;
  [v8 enumerateObjectsUsingBlock:v33];
  id v25 = *(NSObject **)(*(void *)(a1 + 32) + 272);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100007500;
  block[3] = &unk_10073F2A0;
  id v29 = v8;
  id v30 = v24;
  uint64_t v32 = &v41;
  id v31 = *(id *)(a1 + 40);
  id v26 = v24;
  id v27 = v8;
  dispatch_group_notify(v22, v25, block);

  _Block_object_dispose(&v41, 8);
}

void sub_10000EE04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_10000EE30(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = (const char *)PKGetConstantStringNF_SECURE_XPC_EVENT_KEY_EVENT_NAME();
    uint64_t v5 = xpc_dictionary_get_value(v3, v4);
    string_ptr = xpc_string_get_string_ptr(v5);

    if (string_ptr)
    {
      uint64_t v19 = 1;
      uint64_t v20 = 0;
      uint64_t v17 = 0;
      uint64_t v18 = 1;
      uint64_t v15 = 0;
      unint64_t v16 = 10;
      if (PDNFSecureXPCEventIsContactlessPresentationEvent(string_ptr, &v20))
      {
        id v7 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          long long v22 = string_ptr;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: received contactless presentation event %s.", buf, 0xCu);
        }

        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
        id v8 = objc_msgSend(*(id *)(a1 + 40), "allObjects", v15, v16, v17, v18, v19);
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
        PDNFSecureXPCEventHandleContactlessPresentationEvent(v20, v3, v8);
      }
      else if (PDNFSecureXPCEventIsExpressTransactionEvent((uint64_t)string_ptr, &v19))
      {
        id v10 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          long long v22 = string_ptr;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: received express transaction event %s.", buf, 0xCu);
        }

        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
        id v8 = objc_msgSend(*(id *)(a1 + 48), "allObjects", v15, v16, v17, v18);
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
        PDNFSecureXPCEventHandleExpressTransactionEvent(v19, v3, v8);
      }
      else if (PDNFSecureXPCEventIsFieldDetectEvent((uint64_t)string_ptr, &v18))
      {
        uint64_t v11 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          long long v22 = string_ptr;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: received field detect event %s.", buf, 0xCu);
        }

        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
        id v8 = objc_msgSend(*(id *)(a1 + 56), "allObjects", v15, v16, v17);
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
        PDNFSecureXPCEventHandleFieldDetectEvent(v18, v3, v8);
      }
      else if (PDNFSecureXPCEventIsSecureElementEvent((uint64_t)string_ptr, &v17))
      {
        dispatch_group_t v12 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          long long v22 = string_ptr;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: received secure element event %s.", buf, 0xCu);
        }

        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
        id v8 = objc_msgSend(*(id *)(a1 + 64), "allObjects", v15, v16);
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
        PDNFSecureXPCEventHandleSecureElementEvent(v17, v3, v8);
      }
      else
      {
        int IsAccessKeyEvent = PDNFSecureXPCEventIsAccessKeyEvent((uint64_t)string_ptr, (uint64_t *)&v16, &v15);
        id v8 = PKLogFacilityTypeGetObject();
        BOOL v14 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
        if (IsAccessKeyEvent)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136315138;
            long long v22 = string_ptr;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: received car key event %s.", buf, 0xCu);
          }

          os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
          id v8 = [*(id *)(a1 + 72) allObjects];
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
          PDNFSecureXPCEventHandleAccessKeyEvent(v16, v15, v3, v8);
        }
        else if (v14)
        {
          *(_DWORD *)buf = 136315138;
          long long v22 = string_ptr;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: ignoring event %s.", buf, 0xCu);
        }
      }
    }
    else
    {
      uint64_t v9 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: ignoring malformed event - missing event name.", buf, 2u);
      }
    }
  }
}

uint64_t PDNFSecureXPCEventIsExpressTransactionEvent(uint64_t result, uint64_t *a2)
{
  if (result)
  {
    id v3 = (const char *)result;
    if (!strcmp((const char *)result, "com.apple.stockholm.express.enter"))
    {
      if (!a2) {
        return 1;
      }
      result = 0;
      goto LABEL_39;
    }
    if (strcmp(v3, "com.apple.stockholm.express.exit"))
    {
      if (!strcmp(v3, "com.apple.stockholm.express.transaction.start"))
      {
        if (!a2) {
          return 1;
        }
        result = 2;
      }
      else if (!strcmp(v3, "com.apple.stockholm.express.transaction.timeout"))
      {
        if (!a2) {
          return 1;
        }
        result = 3;
      }
      else if (!strcmp(v3, "com.apple.stockholm.express.transaction.end"))
      {
        if (!a2) {
          return 1;
        }
        result = 4;
      }
      else if (!strcmp(v3, "com.apple.stockholm.express.transaction.end.incompatible"))
      {
        if (!a2) {
          return 1;
        }
        result = 5;
      }
      else if (!strcmp(v3, "com.apple.stockholm.express.transaction.end.failed"))
      {
        if (!a2) {
          return 1;
        }
        result = 6;
      }
      else if (!strcmp(v3, "com.apple.stockholm.express.transaction.end.keypairingmode"))
      {
        if (!a2) {
          return 1;
        }
        result = 7;
      }
      else if (!strcmp(v3, "com.apple.stockholm.express.transaction.notfound"))
      {
        if (!a2) {
          return 1;
        }
        result = 8;
      }
      else
      {
        if (strcmp(v3, "com.apple.stockholm.express.field.ecp2.tci"))
        {
          if (strcmp(v3, (const char *)[@"com.apple.stockholm.present" UTF8String]))
          {
            if (strcmp(v3, (const char *)[@"com.apple.stockholm.biometrics.enable" UTF8String])) {
              return 0;
            }
            if (!a2) {
              return 1;
            }
            result = 11;
            goto LABEL_39;
          }
          if (a2)
          {
            result = 10;
            goto LABEL_39;
          }
          return 1;
        }
        if (!a2) {
          return 1;
        }
        result = 9;
      }
LABEL_39:
      *a2 = result;
      return 1;
    }
    result = 1;
    if (a2) {
      goto LABEL_39;
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

void sub_10000F674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_10000F8FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t sub_10000FA64(uint64_t a1)
{
  uint64_t v2 = objc_msgSend(*(id *)(a1 + 32), "_dc_cardDirectoryCoordinatorForUniqueID:", *(void *)(a1 + 40));
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;
  return _objc_release_x1(v2, v4);
}

void sub_100010190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100010218(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void **)(a1 + 32);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100010450;
  v9[3] = &unk_1007322F8;
  id v10 = v3;
  id v5 = v3;
  uint64_t v6 = [v4 objectsPassingTest:v9];
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;
}

id sub_100010450(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [a2 uniqueID];
  id v4 = [v2 containsObject:v3];

  return v4;
}

void sub_100010498(void *a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = a1[8];
    uint64_t v4 = a1[4];
    id v5 = a2;
    PKScreenScale();
    double v7 = v6;
    PKScreenSize();
    id v10 = +[PKImageSet createXPCContainerForImageSetWithType:displayProfile:screenScale:screenSize:suffix:fileURL:cacheURL:](PKImageSet, "createXPCContainerForImageSetWithType:displayProfile:screenScale:screenSize:suffix:fileURL:cacheURL:", v3, v4, a1[5], v5, a1[6], v7, v8, v9);

    uint64_t v11 = *(void *)(a1[7] + 8);
    dispatch_group_t v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;
  }
}

void *sub_1000107BC(void *result, void *a2)
{
  if (a2)
  {
    uint64_t v2 = result;
    id v3 = a2;
    id v4 = objc_alloc((Class)PKFileDataAccessor);
    uint64_t v5 = *(void *)(v2[6] + 8);
    id obj = *(id *)(v5 + 40);
    id v6 = [v4 initWithFileURL:v3 error:&obj coordinator:v2[4]];

    objc_storeStrong((id *)(v5 + 40), obj);
    uint64_t v7 = *(void *)(v2[5] + 8);
    double v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;

    return [*(id *)(*(void *)(v2[5] + 8) + 40) setExplicitDataTypeIdentifier:PKPassDataTypeIdentifier];
  }
  return result;
}

void sub_100010870(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void **)(a1 + 40);
  id v6 = a2;
  id v7 = [v5 _passDynamicStateFromState:a3];
  [*(id *)(a1 + 32) setObject:v7 forKeyedSubscript:v6];
}

void sub_100010E4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100010FD8(uint64_t a1)
{
  uint64_t v2 = objc_msgSend(*(id *)(a1 + 32), "_dc_cardDirectoryCoordinatorForUniqueID:", *(void *)(a1 + 40));
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;
  return _objc_release_x1(v2, v4);
}

uint64_t sub_100011028(uint64_t a1)
{
  uint64_t v2 = objc_msgSend(*(id *)(a1 + 32), "_dc_cardDirectoryCoordinatorForUniqueID:", *(void *)(a1 + 40));
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;
  return _objc_release_x1(v2, v4);
}

uint64_t sub_10001135C(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = result;
    int v3 = atomic_load((unsigned __int8 *)(result + 8));
    if (v3 == 1)
    {
      return 1;
    }
    else
    {
      uint64_t v5 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
        sub_100514B30(a2, v5);
      }

      id v6 = PDDefaultQueue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100038EAC;
      block[3] = &unk_10072E1E8;
      void block[4] = v2;
      dispatch_sync(v6, block);

      return atomic_load((unsigned __int8 *)(v2 + 8));
    }
  }
  return result;
}

void sub_100011448(uint64_t a1, void *a2, unsigned int a3)
{
  id v5 = a2;
  if (a1)
  {
    if (a3 <= 0xA
      && (id v6 = (void (*)(uint64_t, id))qword_100808938[5 * a3 + 1]) != 0
      && (v6(a1, v5), (uint64_t v7 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      double v8 = (void *)v7;
      double v9 = &qword_100808938[5 * a3];
      id v10 = (os_unfair_lock_s *)(v9 + 3);
      os_unfair_lock_lock((os_unfair_lock_t)v9 + 6);
      BOOL v13 = (void *)v9[4];
      dispatch_group_t v12 = (void **)(v9 + 4);
      uint64_t v11 = v13;
      if (!v13)
      {
        id v14 = objc_alloc_init((Class)NSMutableSet);
        uint64_t v15 = *v12;
        *dispatch_group_t v12 = v14;

        uint64_t v11 = *v12;
      }
      [v11 addObject:v8];
      objc_initWeak(&location, v5);
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472;
      v24[2] = sub_10000A7B4;
      v24[3] = &unk_10072F0A0;
      objc_copyWeak(v27, &location);
      char v28 = a3;
      id v16 = v8;
      v27[1] = &qword_100808938[5 * a3];
      id v25 = v16;
      uint64_t v26 = a1;
      [v5 setInvalidationHandler:v24];
      uint64_t v18 = _NSConcreteStackBlock;
      uint64_t v19 = 3221225472;
      uint64_t v20 = sub_100038EB8;
      id v21 = &unk_10072F0C8;
      objc_copyWeak(&v22, &location);
      char v23 = a3;
      [v5 setInterruptionHandler:&v18];
      uint64_t v17 = (void (*)(uint64_t, id))qword_100808938[5 * a3 + 2];
      if (v17) {
        v17(a1, v16);
      }
      objc_msgSend(v5, "activate", v18, v19, v20, v21);
      os_unfair_lock_unlock(v10);
      [v16 activated];
      objc_destroyWeak(&v22);

      objc_destroyWeak(v27);
      objc_destroyWeak(&location);
    }
    else
    {
      [v5 invalidate];
    }
  }
}

void sub_100011670(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 104));
  _Unwind_Resume(a1);
}

void sub_1000116A0(void *a1, void *a2)
{
  uint64_t v3 = a1[9];
  id v6 = a2;
  uint64_t v4 = a1;
  [v6 setSecureElement:v3];
  [v6 setExpressPassManager:v4[42]];
  [v6 setDatabaseManager:v4[6]];
  [v6 setPeerPaymentWebServicesCoordinator:v4[13]];
  [v6 setPaymentTransactionProcessor:v4[10]];
  [v6 setPaymentWebServiceCoordinator:v4[12]];
  [v6 setNotificationServiceCoordinator:v4[11]];
  [v6 setCloudStoreNotificationCoordinator:v4[33]];
  [v6 setUserNotificationManager:v4[7]];
  [v6 setTransitStateManager:v4[43]];
  [v6 setDefaultPassManager:v4[45]];
  [v6 setPushNotificationManager:v4[8]];
  [v6 setDevicePasscodeManager:v4[46]];
  [v6 setApplyManager:v4[15]];
  [v6 setAccountManager:v4[16]];
  [v6 setFamilyMemberManager:v4[54]];
  [v6 setTapToRadarDelegate:v4];
  [v6 setPaymentOffersManager:v4[23]];
  [v6 setSubcredentialManager:v4[24]];
  [v6 setNFCPairingManager:v4[25]];
  [v6 setCardFileManager:v4[4]];
  [v6 setPassTileManager:v4[56]];
  [v6 setMapsBrandAndMerchantUpdater:v4[51]];
  [v6 setPushProvisioningManager:v4[28]];
  [v6 setSharingManager:v4[59]];
  [v6 setPendingProvisioningManager:v4[60]];
  [v6 setIssuerBindingManager:v4[70]];
  [v6 setBarcodeCredentialManager:v4[29]];
  [v6 setTransactionAuthenticationManager:v4[30]];
  [v6 setAuxiliaryCapabilityManager:v4[31]];
  [v6 setIso18013Manager:v4[27]];
  [v6 setTransactionReceiptFileManager:v4[53]];
  [v6 setIdsSharingManager:v4[40]];
  [v6 setApplicationMessageManager:v4[65]];
  [v6 setPaymentUserCommunicationManager:v4[66]];
  [v6 setFinanceKitMessageProvider:v4[67]];
  [v6 setAuxiliaryPassInformationManager:v4[61]];
  uint64_t v5 = v4[64];

  [v6 setPassKitEventPublisher:v5];
}

PDPaymentService *sub_1000118C0(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDPaymentService alloc] initWithConnection:v3 server:v4];

  return v5;
}

uint64_t sub_100011FD0(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

uint64_t sub_100011FDC(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

uint64_t sub_100011FE8(uint64_t result)
{
  if (result) {
    return *(void *)(result + 648);
  }
  return result;
}

void sub_10001204C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = v3;
    if (!v3)
    {
      __break(1u);
      return;
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 12));
    [*(id *)(a1 + 24) addObject:v4];
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 12));
    id v3 = v4;
  }
}

void sub_1000124BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000128B8(uint64_t a1, void *a2, char a3, void *a4)
{
  id v7 = a4;
  double v8 = v7;
  if (a1)
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100012A0C;
    v10[3] = &unk_100730238;
    void v10[4] = a1;
    v10[5] = a2;
    char v12 = a3;
    id v11 = v7;
    id v9 = a2;
    sub_100012974(a1, v10);
  }
}

void sub_100012974(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    os_unfair_recursive_lock_lock_with_options();
    v3[2]();
    os_unfair_recursive_lock_unlock();
  }
}

void sub_1000129E4(void *a1)
{
}

void sub_1000129F8(_Unwind_Exception *a1)
{
}

void sub_100012A0C(uint64_t a1)
{
  id v3 = sub_100012AD0(*(sqlite3_stmt **)(a1 + 32), *(void **)(a1 + 40), *(unsigned __int8 *)(a1 + 56));
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  sqlite3_clear_bindings(v3);
  sqlite3_reset(v3);
  if (!*(unsigned char *)(a1 + 56)) {
    sqlite3_finalize(v3);
  }
}

void sub_100012AA4(_Unwind_Exception *a1)
{
}

sqlite3_stmt *sub_100012AD0(sqlite3_stmt *a1, void *a2, int a3)
{
  id v3 = a1;
  if (a1)
  {
    id v5 = [a2 copy];
    ppStmt = 0;
    if (!a3
      || (CFDictionaryRef v6 = (const __CFDictionary *)*((void *)v3 + 4)) == 0
      || (ppStmt = (sqlite3_stmt *)CFDictionaryGetValue(v6, v5)) == 0)
    {
      id v7 = (const char *)[v5 UTF8String];
      size_t v8 = strlen(v7);
      int v9 = v8 + 1;
      uint64_t v10 = v8 == -1;
      uint64_t v11 = v10 << 63 >> 63;
      int v12 = 5;
      if (v11 != v10 || v11 < 0 || v8 - 0x7FFFFFFF < 0xFFFFFFFF80000001) {
        goto LABEL_10;
      }
      do
        int v13 = sqlite3_prepare_v2(*((sqlite3 **)v3 + 2), v7, v9, &ppStmt, 0);
      while ((v13 - 5) < 2);
      int v12 = v13;
      if (v13)
      {
LABEL_10:
        id v14 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v15 = sqlite3_errmsg(*((sqlite3 **)v3 + 2));
          *(_DWORD *)buf = 138412802;
          id v20 = v5;
          __int16 v21 = 1024;
          int v22 = v12;
          __int16 v23 = 2080;
          id v24 = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SQLiteDatabase: Could not prepare statement: %@: [%d, %s]", buf, 0x1Cu);
        }
      }
      else if (a3)
      {
        Mutable = (__CFDictionary *)*((void *)v3 + 4);
        if (!Mutable)
        {
          Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, (const CFDictionaryValueCallBacks *)&unk_100806DB8);
          *((void *)v3 + 4) = Mutable;
        }
        CFDictionarySetValue(Mutable, v5, ppStmt);
      }
    }
    id v3 = ppStmt;
  }
  return v3;
}

void sub_100012DC8(uint64_t a1, void *a2, void *a3)
{
  if (a1) {
    sub_1000128B8(a1, a2, 0, a3);
  }
}

id sub_100012E88(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    id v5 = [v3 count];
    id v6 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:v5];
    if (v5 == (id)1
      && ([v4 objectAtIndexedSubscript:0],
          id v7 = objc_claimAutoreleasedReturnValue(),
          unsigned int v8 = [v7 isEqualToString:@"ROWID"],
          v7,
          v8))
    {
      int v9 = +[NSNumber numberWithLongLong:*(void *)(a1 + 16)];
      [v6 setObject:v9 forKeyedSubscript:@"ROWID"];
    }
    else
    {
      id v43 = v5;
      id v46 = v6;
      uint64_t v44 = a1;
      uint64_t v10 = objc_opt_class();
      long long v48 = [v10 databaseTable];
      id v11 = [objc_alloc((Class)NSMutableString) initWithString:@"SELECT "];
      id v12 = objc_alloc_init((Class)NSMutableDictionary);
      id v13 = objc_alloc_init((Class)NSMutableSet);
      id v49 = objc_alloc_init((Class)NSMutableSet);
      long long v64 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v47 = v4;
      id v14 = v4;
      id v15 = [v14 countByEnumeratingWithState:&v64 objects:v70 count:16];
      if (v15)
      {
        id v16 = v15;
        uint64_t v17 = *(void *)v65;
        do
        {
          for (i = 0; i != v16; i = (char *)i + 1)
          {
            if (*(void *)v65 != v17) {
              objc_enumerationMutation(v14);
            }
            uint64_t v19 = *(void *)(*((void *)&v64 + 1) + 8 * i);
            id v20 = [v12 objectForKey:v19];

            if (!v20)
            {
              __int16 v21 = [v10 disambiguatedSQLForProperty:v19];
              [v12 setObject:v21 forKeyedSubscript:v19];
              [v13 addObject:v21];
              [v10 addJoinClausesForProperty:v19 toJoins:v49];
            }
          }
          id v16 = [v14 countByEnumeratingWithState:&v64 objects:v70 count:16];
        }
        while (v16);
      }

      long long v42 = v13;
      id v22 = objc_msgSend(v13, "pk_mutableArrayCopy");
      id v23 = objc_msgSend(v49, "pk_mutableArrayCopy");
      [v22 sortUsingComparator:&stru_100732670];
      uint64_t v41 = v23;
      [v23 sortUsingComparator:&stru_100732690];
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      id v24 = v22;
      id v25 = [v24 countByEnumeratingWithState:&v60 objects:v69 count:16];
      if (v25)
      {
        id v26 = v25;
        uint64_t v27 = *(void *)v61;
        char v28 = 1;
        do
        {
          for (j = 0; j != v26; j = (char *)j + 1)
          {
            if (*(void *)v61 != v27) {
              objc_enumerationMutation(v24);
            }
            uint64_t v30 = *(void *)(*((void *)&v60 + 1) + 8 * (void)j);
            if ((v28 & 1) == 0) {
              [v11 appendString:@", "];
            }
            [v11 appendString:v30];
            char v28 = 0;
          }
          id v26 = [v24 countByEnumeratingWithState:&v60 objects:v69 count:16];
          char v28 = 0;
        }
        while (v26);
      }

      [v11 appendString:@" FROM "];
      [v11 appendString:v48];
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      id v31 = v41;
      id v32 = [v31 countByEnumeratingWithState:&v56 objects:v68 count:16];
      if (v32)
      {
        id v33 = v32;
        uint64_t v34 = *(void *)v57;
        do
        {
          for (k = 0; k != v33; k = (char *)k + 1)
          {
            if (*(void *)v57 != v34) {
              objc_enumerationMutation(v31);
            }
            uint64_t v36 = *(void *)(*((void *)&v56 + 1) + 8 * (void)k);
            [v11 appendString:@" "];
            [v11 appendString:v36];
          }
          id v33 = [v31 countByEnumeratingWithState:&v56 objects:v68 count:16];
        }
        while (v33);
      }

      [v11 appendString:@" WHERE "];
      [v11 appendString:v48];
      [v11 appendString:@".ROWID = ?;"];

      uint64_t v37 = *(void *)(v44 + 8);
      v50[0] = _NSConcreteStackBlock;
      v50[1] = 3221225472;
      v50[2] = sub_100014D30;
      v50[3] = &unk_1007326B8;
      id v55 = v43;
      v50[4] = v44;
      id v51 = v24;
      id v52 = v14;
      id v53 = v12;
      id v6 = v46;
      id v54 = v6;
      id v38 = v12;
      id v39 = v24;
      sub_1000128B8(v37, v11, 1, v50);

      id v4 = v47;
    }
  }
  else
  {
    id v6 = 0;
  }

  return v6;
}

void sub_100013C84(uint64_t a1, sqlite3_stmt *a2)
{
  int v16 = 1;
  [*(id *)(a1 + 32) bindToSelectStatement:a2 bindingIndex:&v16];
  id v4 = (char *)[*(id *)(a1 + 40) count];
  id v5 = v4;
  if (v4) {
    id v6 = (void **)malloc_type_calloc((size_t)v4, 8uLL, 0x80040B8603338uLL);
  }
  else {
    id v6 = 0;
  }
  uint64_t v7 = 0;
  do
  {
    if (!sub_1000140E0((uint64_t)SQLiteDatabase, a2)) {
      break;
    }
    if (v5)
    {
      for (i = 0; i != v5; ++i)
      {
        id v9 = SQLiteCopyFoundationValueForStatementColumn(a2, (int)i + 1);
        uint64_t v10 = v6[(void)i];
        v6[(void)i] = v9;
      }
    }
    char v15 = 0;
    uint64_t v11 = *(void *)(a1 + 48);
    sqlite3_int64 v12 = sqlite3_column_int64(a2, 0);
    (*(void (**)(uint64_t, sqlite3_int64, void, void **, uint64_t, char *))(v11 + 16))(v11, v12, *(void *)(a1 + 40), v6, v7++, &v15);
  }
  while (!v15);
  if (v6)
  {
    if (v5)
    {
      id v13 = v6;
      do
      {
        id v14 = *v13;
        *v13++ = 0;

        --v5;
      }
      while (v5);
    }
    free(v6);
  }
}

id SQLiteCopyFoundationValueForStatementColumn(sqlite3_stmt *a1, int a2)
{
  switch(sqlite3_column_type(a1, a2))
  {
    case 1:
      id v4 = objc_alloc((Class)NSNumber);
      sqlite3_int64 v5 = sqlite3_column_int64(a1, a2);
      id result = [v4 initWithLongLong:v5];
      break;
    case 2:
      id v7 = objc_alloc((Class)NSNumber);
      double v8 = sqlite3_column_double(a1, a2);
      id result = [v7 initWithDouble:v8];
      break;
    case 3:
      id v9 = objc_alloc((Class)NSString);
      uint64_t v10 = sqlite3_column_text(a1, a2);
      id result = [v9 initWithUTF8String:v10];
      break;
    case 5:
      id result = 0;
      break;
    default:
      uint64_t v11 = sqlite3_column_blob(a1, a2);
      int v12 = sqlite3_column_bytes(a1, a2);
      id v13 = objc_alloc((Class)NSData);
      id result = [v13 initWithBytes:v11 length:v12];
      break;
  }
  return result;
}

uint64_t sub_1000140E0(uint64_t a1, sqlite3_stmt *a2)
{
  self;
  unsigned __int8 v4 = 0;
  sub_10001412C((uint64_t)SQLiteDatabase, a2, &v4, 0);
  return v4;
}

void sub_10001412C(uint64_t a1, sqlite3_stmt *a2, unsigned char *a3, unsigned char *a4)
{
  self;
  if (a2)
  {
    while (1)
    {
      int v7 = sqlite3_step(a2);
      if (v7 == 9) {
        break;
      }
      if (v7 == 101)
      {
        if (a4) {
          *a4 = 1;
        }
        return;
      }
      if (v7 == 100)
      {
        if (a3) {
          *a3 = 1;
        }
        return;
      }
      int v8 = v7;
      if (v7 - 7 <= 0xFFFFFFFD)
      {
        id v9 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = sqlite3_sql(a2);
          uint64_t v11 = sqlite3_db_handle(a2);
          int v12 = 136315650;
          id v13 = v10;
          __int16 v14 = 1024;
          int v15 = v8;
          __int16 v16 = 2080;
          uint64_t v17 = sqlite3_errmsg(v11);
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SQLiteDatabase: Step failed: %s: [%d, %s]", (uint8_t *)&v12, 0x1Cu);
        }

        return;
      }
    }
  }
}

void sub_100014D30(uint64_t a1, sqlite3_stmt *a2)
{
  sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1 + 32) + 16));
  if (sub_1000140E0((uint64_t)SQLiteDatabase, a2))
  {
    id v4 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:*(void *)(a1 + 72)];
    sqlite3_int64 v5 = (char *)[*(id *)(a1 + 40) count];
    if (v5)
    {
      id v6 = v5;
      for (i = 0; i != v6; ++i)
      {
        int v8 = [*(id *)(a1 + 40) objectAtIndexedSubscript:i];
        id v9 = SQLiteCopyFoundationValueForStatementColumn(a2, (int)i);
        if (v9) {
          [v4 setObject:v9 forKeyedSubscript:v8];
        }
      }
    }
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id v10 = *(id *)(a1 + 48);
    id v11 = [v10 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v19;
      do
      {
        for (j = 0; j != v12; j = (char *)j + 1)
        {
          if (*(void *)v19 != v13) {
            objc_enumerationMutation(v10);
          }
          uint64_t v15 = *(void *)(*((void *)&v18 + 1) + 8 * (void)j);
          __int16 v16 = objc_msgSend(*(id *)(a1 + 56), "objectForKeyedSubscript:", v15, (void)v18);
          uint64_t v17 = [v4 objectForKeyedSubscript:v16];
          [*(id *)(a1 + 64) setObject:v17 forKeyedSubscript:v15];
        }
        id v12 = [v10 countByEnumeratingWithState:&v18 objects:v22 count:16];
      }
      while (v12);
    }
  }
}

void sub_100015658(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v4 = a2;
  -[PKPassDisplayProfile setHasBackgroundImage:](v4, "setHasBackgroundImage:", [a3 BOOLValue]);
}

void sub_1000156B0(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v4 = a2;
  -[PKPassDisplayProfile setTallCode:](v4, "setTallCode:", [a3 BOOLValue]);
}

void sub_100015708(id a1, PKPassDisplayProfile *a2, id a3)
{
}

void sub_100015710(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_ColorForSQLValue();
  [(PKPassDisplayProfile *)v3 setStripColor:v4];
}

void sub_100015770(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_ColorForSQLValue();
  [(PKPassDisplayProfile *)v3 setLabelColor:v4];
}

void sub_1000157D0(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_ColorForSQLValue();
  [(PKPassDisplayProfile *)v3 setForegroundColor:v4];
}

void sub_100015830(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_ColorForSQLValue();
  [(PKPassDisplayProfile *)v3 setSecondaryBackgroundColor:v4];
}

void sub_100015890(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_ColorForSQLValue();
  [(PKPassDisplayProfile *)v3 setBackgroundColor:v4];
}

void sub_1000158F0(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_ColorForSQLValue();
  [(PKPassDisplayProfile *)v3 setFooterBackgroundColor:v4];
}

void sub_100015950(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v4 = a2;
  -[PKPassDisplayProfile setSuppressesHeaderDarkening:](v4, "setSuppressesHeaderDarkening:", [a3 BOOLValue]);
}

void sub_1000159A8(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v4 = a2;
  -[PKPassDisplayProfile setSupportsAutomaticLabelVibrancy:](v4, "setSupportsAutomaticLabelVibrancy:", [a3 BOOLValue]);
}

void sub_100015A00(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v4 = a2;
  -[PKPassDisplayProfile setSupportsAutomaticForegroundVibrancy:](v4, "setSupportsAutomaticForegroundVibrancy:", [a3 BOOLValue]);
}

void sub_100015A58(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v4 = a2;
  -[PKPassDisplayProfile setHasStripImage:](v4, "setHasStripImage:", [a3 BOOLValue]);
}

void sub_100015AB0(id a1, PKPassDisplayProfile *a2, id a3)
{
  id v4 = a2;
  -[PKPassDisplayProfile setPassStyle:](v4, "setPassStyle:", [a3 integerValue]);
}

void sub_100015B08(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPass *)v3 setExpirationDate:v4];
}

void sub_100015B68(id a1, PKPass *a2, id a3)
{
}

void sub_100015B70(id a1, PKPass *a2, id a3)
{
}

void sub_100015B78(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setContactVenueWebsite:v4];
}

void sub_100015BD8(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setContactVenueEmail:v4];
}

void sub_100015C38(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setContactVenuePhoneNumber:v4];
}

void sub_100015C98(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setPartnerAddOnURL:v4];
}

void sub_100015CF8(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setPurchaseParkingURL:v4];
}

void sub_100015D58(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setAccessibilityURL:v4];
}

void sub_100015DB8(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setMerchandiseURL:v4];
}

void sub_100015E18(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setDirectionsInformationURL:v4];
}

void sub_100015E78(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setParkingInformationURL:v4];
}

void sub_100015ED8(id a1, PKPass *a2, id a3)
{
}

void sub_100015EE0(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setTransitInformationURL:v4];
}

void sub_100015F40(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setOrderFoodURL:v4];
}

void sub_100015FA0(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setBagPolicyURL:v4];
}

void sub_100016000(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setSellURL:v4];
}

void sub_100016060(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setTransferURL:v4];
}

void sub_1000160C0(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  sqlite3_int64 v5 = (void *)_DateForSQLValue();

  [v6 setOriginalProvisioningDate:v5];
}

void sub_100016134(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setShippingAddressSeed:v4];
}

void sub_100016194(id a1, PKPass *a2, id a3)
{
}

void sub_10001619C(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setIsCloudKitSecurelyArchived:](v4, "setIsCloudKitSecurelyArchived:", [a3 BOOLValue]);
}

void sub_1000161F4(id a1, PKPass *a2, id a3)
{
}

void sub_1000161FC(id a1, PKPass *a2, id a3)
{
}

void sub_100016204(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setIsCloudKitArchived:](v4, "setIsCloudKitArchived:", [a3 BOOLValue]);
}

void sub_10001625C(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setPartnerAccountIdentifier:v4];
}

void sub_1000162BC(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setIdentityAccountKeyIdentifier:v4];
}

void sub_10001631C(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setIssuerAdministrativeAreaCode:v4];
}

void sub_10001637C(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setIssuerCountryCode:v4];
}

void sub_1000163DC(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 BOOLValue];

  [v6 setCobranded:v5];
}

void sub_10001644C(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 unsignedIntegerValue];

  [v6 setContactlessActivationGroupingType:v5];
}

void sub_1000164BC(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setAssociatedAccountServiceAccountIdentifier:v4];
}

void sub_10001651C(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 BOOLValue];

  [v6 setHasAssociatedPeerPaymentAccount:v5];
}

void sub_10001658C(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 BOOLValue];

  [v6 setRequiresTransferSerialNumberBasedProvisioning:v5];
}

void sub_1000165FC(id a1, PKPass *a2, id a3)
{
}

void sub_100016604(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 BOOLValue];

  [v6 setSupportsSerialNumberBasedProvisioning:v5];
}

void sub_100016674(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 BOOLValue];

  [v6 setShellPass:v5];
}

void sub_1000166E4(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 BOOLValue];

  [v6 setSupportsDefaultCardSelection:v5];
}

void sub_100016754(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 BOOLValue];

  [v6 setSupportsFPANNotifications:v5];
}

void sub_1000167C4(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 BOOLValue];

  [v6 setSupportsDPANNotifications:v5];
}

void sub_100016834(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setSanitizedPrimaryAccountName:v4];
}

void sub_100016894(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setSanitizedPrimaryAccountNumber:v4];
}

void sub_1000168F4(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setPrimaryAccountNumberSuffix:v4];
}

void sub_100016954(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setPrimaryAccountIdentifier:v4];
}

void sub_1000169B4(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKPass *)a2 paymentPass];
  id v5 = [v4 integerValue];

  [v6 setCardType:v5];
}

void sub_100016A24(id a1, PKPass *a2, id a3)
{
}

void sub_100016A2C(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setPassType:](v4, "setPassType:", [a3 integerValue]);
}

void sub_100016A84(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setMuteReadyForUseNotification:](v4, "setMuteReadyForUseNotification:", [a3 BOOLValue]);
}

void sub_100016ADC(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setLiveRenderingRequiresEnablement:](v4, "setLiveRenderingRequiresEnablement:", [a3 BOOLValue]);
}

void sub_100016B34(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setSupportsCategoryVisualization:](v4, "setSupportsCategoryVisualization:", [a3 BOOLValue]);
}

void sub_100016B8C(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  [(PKPass *)v3 setHomeKeyLiveRenderType:PKPassHomeKeyLiveRenderTypeFromString()];
}

void sub_100016BE4(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  [(PKPass *)v3 setLiveRenderType:PKPassLiveRenderTypeFromString()];
}

void sub_100016C3C(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setHasStoredValue:](v4, "setHasStoredValue:", [a3 BOOLValue]);
}

void sub_100016C94(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setRevoked:](v4, "setRevoked:", [a3 BOOLValue]);
}

void sub_100016CEC(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPass *)v3 setModifiedDate:v4];
}

void sub_100016D4C(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPass *)v3 setSigningDate:v4];
}

void sub_100016DAC(id a1, PKPass *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPass *)a2 paymentPass];
  [v5 setTransactionSourceIdentifier:v4];
}

void sub_100016E0C(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPass *)v3 setIngestedDate:v4];
}

void sub_100016E6C(id a1, PKPass *a2, id a3)
{
}

void sub_100016E74(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setSharingURL:v4];
}

void sub_100016ED4(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setSharingMethod:](v4, "setSharingMethod:", [a3 integerValue]);
}

void sub_100016F2C(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setShareCount:](v4, "setShareCount:", [a3 integerValue]);
}

void sub_100016F84(id a1, PKPass *a2, id a3)
{
}

void sub_100016F8C(id a1, PKPass *a2, id a3)
{
}

void sub_100016F94(id a1, PKPass *a2, id a3)
{
  if (a3)
  {
    id v4 = a2;
    id v5 = +[NSJSONSerialization JSONObjectWithData:a3 options:0 error:0];
    -[PKPass setUserInfo:](v4, "setUserInfo:");
  }
  else
  {
    id v5 = a2;
    [(PKPass *)v5 setUserInfo:0];
  }
}

void sub_10001702C(id a1, PKPass *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKPass *)v3 setWebServiceURL:v4];
}

void sub_10001708C(id a1, PKPass *a2, id a3)
{
  id v4 = a2;
  -[PKPass setVoided:](v4, "setVoided:", [a3 BOOLValue]);
}

void sub_1000170E4(id a1, PKPass *a2, id a3)
{
}

void sub_1000170EC(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  id v6 = [objc_alloc(*(Class *)(a1 + 48)) initWithPersistentID:a2 inDatabase:*(void *)(a1 + 32)];
  uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
  int v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  *a4 = 1;
}

void sub_10001714C(id a1, PKPassAnnotations *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPassAnnotations *)v3 setArchivedTimestamp:v4];
}

void sub_1000171AC(id a1, PKPassAnnotations *a2, id a3)
{
  id v4 = a2;
  -[PKPassAnnotations setSortingState:](v4, "setSortingState:", [a3 integerValue]);
}

uint64_t sub_100017204(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10001721C(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  id v21 = *a4;
  id v6 = a4[1];
  id v7 = [a4[3] unsignedIntegerValue];
  id v8 = a4[4];
  [a4[5] unsignedIntegerValue];
  id v9 = a4[6];
  id v10 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  if (!v10
    || ([v10 groupID],
        id v11 = objc_claimAutoreleasedReturnValue(),
        unsigned __int8 v12 = [v11 isEqualToNumber:v21],
        v11,
        (v12 & 1) == 0))
  {
    uint64_t v13 = [*(id *)(a1 + 32) objectForKeyedSubscript:v21];
    uint64_t v14 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = v13;

    if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
    {
      id v16 = objc_alloc_init((Class)PKCatalogGroup);
      uint64_t v17 = *(void *)(*(void *)(a1 + 56) + 8);
      long long v18 = *(void **)(v17 + 40);
      *(void *)(v17 + 40) = v16;

      [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) setIsUbiquitous:PKPassSupportsSyncing()];
      [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) setGroupID:v21];
      [*(id *)(a1 + 32) setObject:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) forKeyedSubscript:v21];
      long long v19 = [*(id *)(a1 + 40) groups];
      [v19 addObject:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)];
    }
  }
  if (v7 == (id)1 && v8) {
    [*(id *)(a1 + 48) addObject:v21];
  }
  long long v20 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) uniqueIDs];
  [v20 addObject:v6];
}

void sub_1000173FC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v7 = objc_alloc_init((Class)PKLocation);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v7 withProperties:v6 values:a4];

  [*(id *)(a1 + 40) addObject:v7];
}

id *sub_100017488(id *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (*a4) {
    return (id *)objc_msgSend(result[4], "addObject:");
  }
  return result;
}

void sub_10001749C(id a1, PKLocation *a2, id a3)
{
}

void sub_1000174A4(id a1, PKLocation *a2, id a3)
{
}

void sub_1000174AC(id a1, PKLocation *a2, id a3)
{
  if (a3)
  {
    id v4 = a2;
    [a3 doubleValue];
    -[PKLocation setAltitude:](v4, "setAltitude:");
  }
}

void sub_100017508(id a1, PKLocation *a2, id a3)
{
  id v4 = a2;
  [a3 doubleValue];
  -[PKLocation setMaxDistance:](v4, "setMaxDistance:");
}

void sub_10001755C(id a1, PKLocation *a2, id a3)
{
  id v4 = a2;
  [a3 doubleValue];
  -[PKLocation setLongitude:](v4, "setLongitude:");
}

void sub_1000175B0(id a1, PKLocation *a2, id a3)
{
  id v4 = a2;
  [a3 doubleValue];
  -[PKLocation setLatitude:](v4, "setLatitude:");
}

void sub_1000177DC(uint64_t a1)
{
  id v8 = (id)_DateForSQLValue();
  uint64_t v2 = (void *)_DateForSQLValue();
  id v3 = (void *)_DateForSQLValue();
  id v4 = objc_alloc((Class)PKPassRelevantDate);
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    id v6 = [v4 initWithRelevantDate:v8];
  }
  else {
    id v6 = [v4 initWithEffectiveStartDate:v2 effectiveEndDate:v3];
  }
  id v7 = v6;
  [*(id *)(a1 + 32) safelyAddObject:v6];
}

void sub_100017894(uint64_t a1, uint64_t a2)
{
  id v4 = [Pass alloc];
  BOOL v5 = [*(id *)(a1 + 32) database];
  id v6 = [(SQLiteEntity *)v4 initWithPersistentID:a2 inDatabase:v5];

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100017938(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 expirationDate];
  if (v4)
  {
    BOOL v5 = 0;
    BOOL v6 = 1;
  }
  else
  {
    id v7 = +[PassRelevancyDates relevancyDatesForPassPID:inDatabase:](PassRelevancyDates, "relevancyDatesForPassPID:inDatabase:", [v3 persistentID], *(void *)(a1 + 32));
    BOOL v5 = +[PKPassRelevantDate findDateFromDates:v7 option:3];
    BOOL v6 = v5 != 0;
  }
  id v8 = [v3 signingDate];
  unint64_t v9 = (unint64_t)[v3 passStyle];
  id v10 = (char *)[v3 sortingState];
  [v4 timeIntervalSinceNow];
  if (v11 < 0.0
    || ([v3 voided] & 1) != 0
    || ([v5 timeIntervalSinceNow], v12 <= -86400.0)
    || !v6 && v9 <= 9 && ((1 << v9) & 0x214) != 0 && ([v8 timeIntervalSinceNow], v13 < -31536000.0)
    || *(void *)(a1 + 40) != 1 && (unint64_t)(v10 - 1) <= 1)
  {
    uint64_t v14 = *(void **)(a1 + 32);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_1003090C4;
    v17[3] = &unk_10073DBA0;
    id v18 = v14;
    id v15 = v3;
    uint64_t v16 = *(void *)(a1 + 40);
    id v19 = v15;
    uint64_t v20 = v16;
    sub_10000817C((uint64_t)v18, v17);
  }
}

void sub_100017B24(uint64_t a1, sqlite3_stmt *a2)
{
  int v5 = 1;
  [*(id *)(a1 + 32) bindToSelectStatement:a2 bindingIndex:&v5];
  if (sub_1000140E0((uint64_t)SQLiteDatabase, a2))
  {
    id v4 = SQLiteCopyFoundationNumberValueForStatementColumn(a2, 0);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v4 BOOLValue];
  }
}

id SQLiteCopyFoundationNumberValueForStatementColumn(sqlite3_stmt *a1, int a2)
{
  int v4 = sqlite3_column_type(a1, a2);
  if (v4 == 2)
  {
    id v8 = objc_alloc((Class)NSNumber);
    double v9 = sqlite3_column_double(a1, a2);
    return [v8 initWithDouble:v9];
  }
  else if (v4 == 1)
  {
    id v5 = objc_alloc((Class)NSNumber);
    sqlite3_int64 v6 = sqlite3_column_int64(a1, a2);
    return [v5 initWithLongLong:v6];
  }
  else
  {
    return 0;
  }
}

void sub_1000180DC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v22 = a3;
  id v7 = objc_alloc_init((Class)PKPaymentApplication);
  [*(id *)(a1 + 56) applyPropertySetters:*(void *)(a1 + 32) toObject:v7 withProperties:v22 values:a4];
  id v8 = +[PaymentExpressMode expressModesInDatabase:*(void *)(a1 + 40) forPaymentApplicationPID:a2];
  double v9 = [v8 allObjects];
  [v7 setSupportedExpressModes:v9];

  id v10 = +[PaymentAutomaticSelectionCriterion criteriaInDatabase:*(void *)(a1 + 40) forPaymentApplicationPID:a2];
  double v11 = [v10 allObjects];
  [v7 setAutomaticSelectionCriteria:v11];

  double v12 = +[PaymentTransitNetworkIdentifier transitNetworkIdentifiersInDatabase:*(void *)(a1 + 40) forPaymentApplicationPID:a2];
  [v7 setSupportedTransitNetworkIdentifiers:v12];

  double v13 = +[AppletSubcredential appletSubcredentialsInDatabase:*(void *)(a1 + 40) forPaymentApplicationPID:a2];
  [v7 setSubcredentials:v13];
  uint64_t v14 = +[FelicaTransitAppletState anyInDatabase:*(void *)(a1 + 40) withPaymentApplicationPID:a2];
  id v15 = [v14 transitAppletState];

  if (v15
    || (+[TransitAppletState anyInDatabase:withPaymentApplicationPID:](TransitAppletState, "anyInDatabase:withPaymentApplicationPID:", *(void *)(a1 + 40), a2), v16 = objc_claimAutoreleasedReturnValue(), [v16 transitAppletState], id v15 = objc_claimAutoreleasedReturnValue(), v16, v15))
  {
    id v17 = [v22 indexOfObject:@"pass_pid"];
    if (v17 == (id)0x7FFFFFFFFFFFFFFFLL)
    {
      id v18 = 0;
    }
    else
    {
      id v18 = +[SecureElementPassField secureElementPassFieldsInDatabase:forPassPID:](SecureElementPassField, "secureElementPassFieldsInDatabase:forPassPID:", *(void *)(a1 + 40), [*(id *)(a4 + 8 * (void)v17) longLongValue]);
    }
    id v19 = [v15 transitPassPropertiesWithPaymentApplication:v7 fieldCollection:v18];
    [v7 setTransitProperties:v19];
  }
  uint64_t v20 = +[PaymentApplicationMerchantSupport supportedCountryCodesForPaymentApplicationPID:a2 inDatabase:*(void *)(a1 + 40)];
  [v7 setSupportedInAppMerchantCountryCodes:v20];

  id v21 = +[PaymentApplicationMerchantSupport unsupportedCountryCodesForPaymentApplicationPID:a2 inDatabase:*(void *)(a1 + 40)];
  [v7 setUnsupportedInAppMerchantCountryCodes:v21];

  [*(id *)(a1 + 48) addObject:v7];
}

void sub_1000186B0(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setSupportsContactlessPayment:](v4, "setSupportsContactlessPayment:", [a3 BOOLValue]);
}

void sub_100018708(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018710(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setState:](v4, "setState:", [a3 integerValue]);
}

void sub_100018768(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018770(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018778(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018780(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setShareable:](v4, "setShareable:", [a3 BOOLValue]);
}

void sub_1000187D8(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setSupportsServiceMode:](v4, "setSupportsServiceMode:", [a3 BOOLValue]);
}

void sub_100018830(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018838(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setRequiresConsentForDataRelease:](v4, "setRequiresConsentForDataRelease:", [a3 BOOLValue]);
}

void sub_100018890(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setFundingSourcePaymentType:](v4, "setFundingSourcePaymentType:", [a3 integerValue]);
}

void sub_1000188E8(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setSupportsInstantFundsIn:](v4, "setSupportsInstantFundsIn:", [a3 BOOLValue]);
}

void sub_100018940(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setInAppPriority:](v4, "setInAppPriority:", [a3 integerValue]);
}

void sub_100018998(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setContactlessPriority:](v4, "setContactlessPriority:", [a3 integerValue]);
}

void sub_1000189F0(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setAuxiliaryPaymentType:](v4, "setAuxiliaryPaymentType:", [a3 integerValue]);
}

void sub_100018A48(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setPaymentType:](v4, "setPaymentType:", [a3 integerValue]);
}

void sub_100018AA0(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018AA8(id a1, PKPaymentApplication *a2, id a3)
{
  int v4 = a2;
  -[PKPaymentApplication setAuxiliary:](v4, "setAuxiliary:", [a3 BOOLValue]);
}

void sub_100018B00(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018B08(id a1, PKPaymentApplication *a2, id a3)
{
  id v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKPaymentApplication *)v3 setInAppPINRequiredAmount:v4];
}

void sub_100018B6C(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentApplication setPaymentNetworkIdentifier:](v4, "setPaymentNetworkIdentifier:", [a3 integerValue]);
}

void sub_100018BC4(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentApplication setRequiresDeferredAuthorization:](v4, "setRequiresDeferredAuthorization:", [a3 BOOLValue]);
}

void sub_100018C1C(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018C24(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018C2C(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentApplication setSupportsOptionalAuthentication:](v4, "setSupportsOptionalAuthentication:", [a3 BOOLValue]);
}

void sub_100018C84(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentApplication setSupportsBarcodePayment:](v4, "setSupportsBarcodePayment:", [a3 BOOLValue]);
}

void sub_100018CDC(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentApplication setVirtualCardVPANOrigin:](v4, "setVirtualCardVPANOrigin:", [a3 integerValue]);
}

void sub_100018D34(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018D3C(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018D44(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  id v5 = [a3 stringValue];
  [(PKPaymentApplication *)v4 setVirtualCardSuffix:v5];
}

void sub_100018DA8(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  id v5 = [a3 stringValue];
  [(PKPaymentApplication *)v4 setVirtualCardIdentifier:v5];
}

void sub_100018E0C(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018E14(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018E1C(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018E24(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentApplication setHadMerchantTokens:](v4, "setHadMerchantTokens:", [a3 BOOLValue]);
}

void sub_100018E7C(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentApplication setHasMerchantTokens:](v4, "setHasMerchantTokens:", [a3 BOOLValue]);
}

void sub_100018ED4(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentApplication setSupportsMerchantTokens:](v4, "setSupportsMerchantTokens:", [a3 BOOLValue]);
}

void sub_100018F2C(id a1, PKPaymentApplication *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentApplication setSupportsInAppPayment:](v4, "setSupportsInAppPayment:", [a3 BOOLValue]);
}

void sub_100018F84(id a1, PKPaymentApplication *a2, id a3)
{
}

void sub_100018F8C(uint64_t a1, sqlite3_stmt *a2)
{
  int v13 = 1;
  [*(id *)(a1 + 32) bindToSelectStatement:a2 bindingIndex:&v13];
  id v4 = (char *)[*(id *)(a1 + 40) count];
  id v5 = v4;
  if (v4) {
    sqlite3_int64 v6 = (void **)malloc_type_calloc((size_t)v4, 8uLL, 0x80040B8603338uLL);
  }
  else {
    sqlite3_int64 v6 = 0;
  }
  uint64_t v7 = 0;
  while (sub_1000140E0((uint64_t)SQLiteDatabase, a2))
  {
    if (v5)
    {
      for (i = 0; i != v5; ++i)
      {
        id v9 = SQLiteCopyFoundationValueForStatementColumn(a2, (int)i);
        id v10 = v6[(void)i];
        v6[(void)i] = v9;
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    ++v7;
  }
  if (v6)
  {
    if (v5)
    {
      double v11 = v6;
      do
      {
        double v12 = *v11;
        *v11++ = 0;

        --v5;
      }
      while (v5);
    }
    free(v6);
  }
}

void sub_100019C6C(uint64_t a1)
{
  errmsg = 0;
  int v2 = sqlite3_exec(*(sqlite3 **)(*(void *)(a1 + 32) + 16), (const char *)[*(id *)(a1 + 40) UTF8String], 0, 0, &errmsg);
  if (v2)
  {
    int v3 = v2;
    id v4 = errmsg;
    if (!errmsg) {
      id v4 = (void *)sqlite3_errmsg(*(sqlite3 **)(*(void *)(a1 + 32) + 16));
    }
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 138412802;
      uint64_t v9 = v6;
      __int16 v10 = 1024;
      int v11 = v3;
      __int16 v12 = 2080;
      int v13 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SQLiteDatabase: Could not execute SQL: %@: [%d, %s]", buf, 0x1Cu);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
  if (errmsg) {
    sqlite3_free(errmsg);
  }
}

id sub_10001A6F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[SQLiteEntity applyPropertySetters:*(void *)(a1 + 32) toObject:*(void *)(a1 + 40) withProperties:a2 values:a3];
}

void sub_10001A98C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v15 = a3;
  id v8 = +[NSNumber numberWithLongLong:a2];
  if (([*(id *)(a1 + 32) containsObject:v8] & 1) == 0)
  {
    [*(id *)(a1 + 32) addObject:v8];
    uint64_t v9 = *(void **)(a1 + 64);
    uint64_t v10 = *(void *)(a1 + 40);
    int v11 = [(SQLiteEntity *)[Pass alloc] initWithPersistentID:a2 inDatabase:v10];
    __int16 v12 = [v9 _realPassInDatabase:v10 withProperties:v15 values:a4 fromPass:v11];

    if (v12 && (!*(unsigned char *)(a1 + 72) || ![v12 passType]))
    {
      [*(id *)(a1 + 48) addObject:v12];
      if (*(void *)(a1 + 56))
      {
        int v13 = [v12 uniqueID];
        if (v13)
        {
          uint64_t v14 = [*(id *)(a1 + 64) _dynamicStateInDatabase:*(void *)(a1 + 40) forPassPID:a2];
          [*(id *)(a1 + 56) setObject:v14 forKeyedSubscript:v13];
        }
      }
    }
  }
}

void sub_10001DFC8(void *a1, void *a2)
{
  if (a1)
  {
    id v3 = a2;
    objc_msgSend(v3, "setSettingsWithoutUpdatingDataAccessor:", sub_10001E02C(a1, v3));
  }
}

id sub_10001E02C(id result, void *a2)
{
  if (result)
  {
    uint64_t v2 = (uint64_t)result;
    id v3 = a2;
    id v4 = objc_opt_class();
    id v5 = sub_10001E12C(v2, v4);
    uint64_t v6 = [v3 uniqueID];

    id v7 = sub_10001E0A8(v2, v6, v5);
    return v7;
  }
  return result;
}

id sub_10001E0A8(uint64_t a1, void *a2, id a3)
{
  id v5 = a2;
  if (a1)
  {
    uint64_t v6 = (os_unfair_lock_s *)(a1 + 8);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 8));
    if (v5)
    {
      id v7 = [*(id *)(a1 + 16) objectForKeyedSubscript:v5];
      if (v7)
      {
        id v8 = v7;
        a3 = [v7 unsignedIntegerValue];
      }
    }
    os_unfair_lock_unlock(v6);
  }
  else
  {
    a3 = 0;
  }

  return a3;
}

id sub_10001E12C(uint64_t a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  if (![a2 isSubclassOfClass:objc_opt_class()])
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = (objc_class *)objc_opt_class();
      uint64_t v6 = NSStringFromClass(v5);
      int v7 = 138543362;
      id v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDObjectSettingsManager (PKObjectAdditions): Error: Unknown default settings for object of class %{public}@.", (uint8_t *)&v7, 0xCu);
    }
    return 0;
  }
  return [a2 defaultSettings];
}

void sub_10001E390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10001E51C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_10001EAE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10001ECA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10001EF24(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

id sub_10001FCD4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    int v4 = atomic_load((unsigned __int8 *)(a1 + 32));
    if (v4 != 2) {
      +[NSException raise:NSInternalInconsistencyException format:@"PDApplicationMessageManager: sinks not ready."];
    }
    if (v3 && [v3 count])
    {
      id v5 = objc_alloc_init((Class)NSMutableArray);
      long long v15 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      id v6 = v3;
      id v7 = [v6 countByEnumeratingWithState:&v15 objects:v19 count:16];
      if (v7)
      {
        id v8 = v7;
        uint64_t v9 = *(void *)v16;
        do
        {
          for (i = 0; i != v8; i = (char *)i + 1)
          {
            if (*(void *)v16 != v9) {
              objc_enumerationMutation(v6);
            }
            int v11 = (void ***)sub_10001FE90(*(void **)(*((void *)&v15 + 1) + 8 * i));
            __int16 v12 = sub_10001FF34(v11);
            objc_msgSend(v5, "addObjectsFromArray:", v12, (void)v15);
          }
          id v8 = [v6 countByEnumeratingWithState:&v15 objects:v19 count:16];
        }
        while (v8);
      }

      if ([v5 count]) {
        id v13 = [v5 copy];
      }
      else {
        id v13 = &__NSArray0__struct;
      }
    }
    else
    {
      id v13 = &__NSArray0__struct;
    }
  }
  else
  {
    id v13 = 0;
  }

  return v13;
}

void *sub_10001FE90(void *result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t v2 = result[1];
  if (!v2)
  {
    NSExceptionName v4 = NSInternalInconsistencyException;
LABEL_6:
    +[NSException raise:v4, @"PDApplicationMessageSink (%ld): cannot fetch sink before connection.", v2 format];
    goto LABEL_7;
  }
  int v3 = atomic_load((unsigned __int8 *)(v2 + 8));
  if (v3 != 2)
  {
    uint64_t v2 = result[1];
    NSExceptionName v4 = NSInternalInconsistencyException;
    if (v2) {
      uint64_t v2 = *(void *)(v2 + 32);
    }
    goto LABEL_6;
  }
LABEL_7:
  id v5 = (void *)v1[1];
  return v5;
}

id *sub_10001FF34(void ***a1)
{
  uint64_t v1 = (id *)a1;
  if (a1)
  {
    uint64_t v2 = sub_1000200C8(a1[3]);
    int v3 = v2;
    if (v2 && [v2 count])
    {
      id v4 = objc_alloc_init((Class)NSMutableArray);
      long long v14 = 0u;
      long long v15 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      id v5 = v3;
      id v6 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v15;
        do
        {
          for (i = 0; i != v7; i = (char *)i + 1)
          {
            if (*(void *)v15 != v8) {
              objc_enumerationMutation(v5);
            }
            uint64_t v10 = *(void *)(*((void *)&v14 + 1) + 8 * i);
            id v11 = objc_msgSend(v1[5], "applicationMessageSink:createContentForMessageWithRegistration:", v1, v10, (void)v14);
            if (v11)
            {
              id v12 = +[PKApplicationMessage createWithRegistration:v10 content:v11];
              [v4 addObject:v12];
            }
          }
          id v7 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
        }
        while (v7);
      }

      uint64_t v1 = (id *)[v4 copy];
    }
    else
    {
      uint64_t v1 = (id *)&__NSArray0__struct;
    }
  }
  return v1;
}

void **sub_1000200C8(void **a1)
{
  if (a1)
  {
    sub_100020118((uint64_t)ApplicationMessageRegistration, a1[1]);
    a1 = (void **)objc_claimAutoreleasedReturnValue();
    uint64_t v1 = vars8;
  }
  return a1;
}

id sub_100020118(uint64_t a1, void *a2)
{
  id v2 = a2;
  int v3 = self;
  uint64_t v27 = 0;
  char v28 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  id v4 = 0;
  if (sub_100020358((uint64_t)v3, 0, &v28, (uint64_t)&v25))
  {
    id v5 = sub_1000202D4();
    id v6 = [v3 queryWithDatabase:v2 predicate:v5];

    uint64_t v19 = 0;
    uint64_t v20 = &v19;
    uint64_t v21 = 0x3032000000;
    id v22 = sub_100020CFC;
    id v23 = sub_100021170;
    id v24 = 0;
    uint64_t v9 = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472;
    long long v16 = v25;
    id v11 = sub_1003A5188;
    id v12 = &unk_10074D948;
    long long v15 = v3;
    long long v17 = v26;
    id v7 = v28;
    uint64_t v18 = v27;
    id v13 = v2;
    long long v14 = &v19;
    [v6 enumeratePersistentIDsAndProperties:v7 usingBlock:&v9];
    id v4 = objc_msgSend((id)v20[5], "copy", v9, v10, v11, v12);

    _Block_object_dispose(&v19, 8);
  }

  return v4;
}

void sub_1000202BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1000202D4()
{
  self;
  v0 = PKApplicationMessageSourceToString();
  if (v0) {
    +[SQLiteComparisonPredicate predicateWithProperty:@"source" equalToValue:v0];
  }
  else {
  uint64_t v1 = +[SQLiteBooleanPredicate falsePredicate];
  }

  return v1;
}

uint64_t sub_100020358(uint64_t a1, void *a2, void **a3, uint64_t a4)
{
  id v6 = a2;
  self;
  if (a3) {
    BOOL v7 = a4 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  uint64_t v8 = !v7;
  if (!v7)
  {
    id v9 = objc_alloc_init((Class)NSMutableArray);
    *(void *)a4 = [v9 count];
    [v9 addObject:@"created_date"];
    *(void *)(a4 + 8) = [v9 count];
    [v9 addObject:@"priority"];
    *(unsigned char *)(a4 + 16) = [v9 count] != 0;
    [v9 addObject:@"badge"];
    *(void *)(a4 + 24) = [v9 count];
    [v9 addObject:@"source"];
    *(void *)(a4 + 32) = [v9 count];
    [v9 addObject:@"identifier"];
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    id v10 = v6;
    id v11 = [v10 countByEnumeratingWithState:&v19 objects:v23 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v20;
      do
      {
        for (i = 0; i != v12; i = (char *)i + 1)
        {
          if (*(void *)v20 != v13) {
            objc_enumerationMutation(v10);
          }
          uint64_t v15 = *(void *)(*((void *)&v19 + 1) + 8 * i);
          if (objc_msgSend(v9, "indexOfObject:", v15, (void)v19) == (id)0x7FFFFFFFFFFFFFFFLL) {
            [v9 addObject:v15];
          }
        }
        id v12 = [v10 countByEnumeratingWithState:&v19 objects:v23 count:16];
      }
      while (v12);
    }

    id v16 = [v9 copy];
    long long v17 = *a3;
    *a3 = v16;
  }
  return v8;
}

id sub_100020648(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) _predicateForType:a2];
}

int64_t sub_10002066C(id a1, NSString *a2, NSString *a3)
{
  return [(NSString *)a2 compare:a3];
}

uint64_t sub_100020674(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = result;
    id v3 = +[PKContent createWithFileURL:a2 dataTypeIdentifier:PKPassDataTypeIdentifier];
    uint64_t v4 = *(void *)(*(void *)(v2 + 32) + 8);
    uint64_t v5 = *(void *)(v4 + 40);
    *(void *)(v4 + 40) = v3;
    return _objc_release_x1(v3, v5);
  }
  return result;
}

uint64_t sub_10002072C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002073C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002074C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002075C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002076C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002077C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002078C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002079C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000207AC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000207BC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000207CC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000207DC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000207EC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000207FC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002080C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002081C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002082C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002083C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002084C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002085C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002086C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002087C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002088C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002089C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000208AC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000208BC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000208CC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000208DC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000208EC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000208FC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002090C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002091C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002092C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002093C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002094C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002095C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002096C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002097C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002098C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_10002099C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000209AC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000209BC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000209CC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000209DC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000209EC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_1000209FC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A0C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A1C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A2C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A3C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A4C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A5C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A6C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A7C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A8C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020A9C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020AAC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020ABC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020ACC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020ADC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020AEC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020AFC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B0C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B1C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B2C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B3C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B4C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B5C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B6C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B7C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B8C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020B9C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020BAC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020BBC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020BCC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020BDC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020BEC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020BFC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C0C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C1C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C2C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C3C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C4C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C5C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C6C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C7C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C8C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020C9C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020CAC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020CBC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020CCC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020CDC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020CEC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020CFC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D0C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D1C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D2C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D3C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D4C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D5C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D6C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D7C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D8C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020D9C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020DAC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020DBC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020DCC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100020DDC(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_100020DE8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020DF8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020E08(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020E18(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020E28(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020E38(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020E48(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020E58(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020E68(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

uint64_t sub_100020E78(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100020E88(uint64_t a1)
{
}

void sub_100020E90(uint64_t a1)
{
}

void sub_100020E98(uint64_t a1)
{
}

void sub_100020EA0(uint64_t a1)
{
}

void sub_100020EA8(uint64_t a1)
{
}

void sub_100020EB0(uint64_t a1)
{
}

void sub_100020EB8(uint64_t a1)
{
}

void sub_100020EC0(uint64_t a1)
{
}

void sub_100020EC8(uint64_t a1)
{
}

void sub_100020ED0(uint64_t a1)
{
}

void sub_100020ED8(uint64_t a1)
{
}

void sub_100020EE0(uint64_t a1)
{
}

void sub_100020EE8(uint64_t a1)
{
}

void sub_100020EF0(uint64_t a1)
{
}

void sub_100020EF8(uint64_t a1)
{
}

void sub_100020F00(uint64_t a1)
{
}

void sub_100020F08(uint64_t a1)
{
}

void sub_100020F10(uint64_t a1)
{
}

void sub_100020F18(uint64_t a1)
{
}

void sub_100020F20(uint64_t a1)
{
}

void sub_100020F28(uint64_t a1)
{
}

void sub_100020F30(uint64_t a1)
{
}

void sub_100020F38(uint64_t a1)
{
}

void sub_100020F40(uint64_t a1)
{
}

void sub_100020F48(uint64_t a1)
{
}

void sub_100020F50(uint64_t a1)
{
}

void sub_100020F58(uint64_t a1)
{
}

void sub_100020F60(uint64_t a1)
{
}

void sub_100020F68(uint64_t a1)
{
}

void sub_100020F70(uint64_t a1)
{
}

void sub_100020F78(uint64_t a1)
{
}

void sub_100020F80(uint64_t a1)
{
}

void sub_100020F88(uint64_t a1)
{
}

void sub_100020F90(uint64_t a1)
{
}

void sub_100020F98(uint64_t a1)
{
}

void sub_100020FA0(uint64_t a1)
{
}

void sub_100020FA8(uint64_t a1)
{
}

void sub_100020FB0(uint64_t a1)
{
}

void sub_100020FB8(uint64_t a1)
{
}

void sub_100020FC0(uint64_t a1)
{
}

void sub_100020FC8(uint64_t a1)
{
}

void sub_100020FD0(uint64_t a1)
{
}

void sub_100020FD8(uint64_t a1)
{
}

void sub_100020FE0(uint64_t a1)
{
}

void sub_100020FE8(uint64_t a1)
{
}

void sub_100020FF0(uint64_t a1)
{
}

void sub_100020FF8(uint64_t a1)
{
}

void sub_100021000(uint64_t a1)
{
}

void sub_100021008(uint64_t a1)
{
}

void sub_100021010(uint64_t a1)
{
}

void sub_100021018(uint64_t a1)
{
}

void sub_100021020(uint64_t a1)
{
}

void sub_100021028(uint64_t a1)
{
}

void sub_100021030(uint64_t a1)
{
}

void sub_100021038(uint64_t a1)
{
}

void sub_100021040(uint64_t a1)
{
}

void sub_100021048(uint64_t a1)
{
}

void sub_100021050(uint64_t a1)
{
}

void sub_100021058(uint64_t a1)
{
}

void sub_100021060(uint64_t a1)
{
}

void sub_100021068(uint64_t a1)
{
}

void sub_100021070(uint64_t a1)
{
}

void sub_100021078(uint64_t a1)
{
}

void sub_100021080(uint64_t a1)
{
}

void sub_100021088(uint64_t a1)
{
}

void sub_100021090(uint64_t a1)
{
}

void sub_100021098(uint64_t a1)
{
}

void sub_1000210A0(uint64_t a1)
{
}

void sub_1000210A8(uint64_t a1)
{
}

void sub_1000210B0(uint64_t a1)
{
}

void sub_1000210B8(uint64_t a1)
{
}

void sub_1000210C0(uint64_t a1)
{
}

void sub_1000210C8(uint64_t a1)
{
}

void sub_1000210D0(uint64_t a1)
{
}

void sub_1000210D8(uint64_t a1)
{
}

void sub_1000210E0(uint64_t a1)
{
}

void sub_1000210E8(uint64_t a1)
{
}

void sub_1000210F0(uint64_t a1)
{
}

void sub_1000210F8(uint64_t a1)
{
}

void sub_100021100(uint64_t a1)
{
}

void sub_100021108(uint64_t a1)
{
}

void sub_100021110(uint64_t a1)
{
}

void sub_100021118(uint64_t a1)
{
}

void sub_100021120(uint64_t a1)
{
}

void sub_100021128(uint64_t a1)
{
}

void sub_100021130(uint64_t a1)
{
}

void sub_100021138(uint64_t a1)
{
}

void sub_100021140(uint64_t a1)
{
}

void sub_100021148(uint64_t a1)
{
}

void sub_100021150(uint64_t a1)
{
}

void sub_100021158(uint64_t a1)
{
}

void sub_100021160(uint64_t a1)
{
}

void sub_100021168(uint64_t a1)
{
}

void sub_100021170(uint64_t a1)
{
}

void sub_100021178(uint64_t a1)
{
}

void sub_100021180(uint64_t a1)
{
}

void sub_100021188(uint64_t a1)
{
}

void sub_100021190(uint64_t a1)
{
}

void sub_100021198(uint64_t a1)
{
}

void sub_1000211A0(uint64_t a1)
{
}

void sub_1000211A8(uint64_t a1)
{
}

void sub_1000211B0(uint64_t a1)
{
}

void sub_1000211B8(uint64_t a1)
{
}

void sub_1000211C0(uint64_t a1)
{
}

void sub_1000211C8(uint64_t a1)
{
}

void sub_1000211D0(uint64_t a1)
{
}

void sub_1000211D8(uint64_t a1)
{
}

void sub_1000211E0(uint64_t a1)
{
}

void sub_1000211E8(uint64_t a1)
{
}

void sub_1000211F0(uint64_t a1)
{
}

void sub_1000211F8(uint64_t a1)
{
}

void sub_100021200(uint64_t a1)
{
}

void sub_100021208(uint64_t a1)
{
}

void sub_100021210(uint64_t a1)
{
}

void sub_100021218(uint64_t a1)
{
}

void sub_100021220(uint64_t a1)
{
}

void sub_100021228(uint64_t a1)
{
}

void sub_100021230(uint64_t a1)
{
}

uint64_t sub_100021238(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 24) beginReporingDiscoveryAnalytics];
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  return v2();
}

uint64_t sub_10002128C(uint64_t a1, void *a2)
{
  uint64_t v3 = objc_msgSend(a2, "pk_objectsPassingTest:", &stru_100749B18);
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = v3;
    uint64_t v4 = (*(uint64_t (**)(void))(v4 + 16))();
    uint64_t v3 = v6;
  }
  return _objc_release_x1(v4, v3);
}

void sub_1000212FC(void *a1)
{
  uint64_t v2 = a1[4];
  if ([*(id *)(*(void *)(a1[5] + 8) + 40) count]) {
    uint64_t v3 = *(void *)(*(void *)(a1[5] + 8) + 40);
  }
  else {
    uint64_t v3 = 0;
  }
  (*(void (**)(uint64_t, uint64_t))(v2 + 16))(v2, v3);
  uint64_t v4 = *(void *)(a1[5] + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;

  uint64_t v6 = *(void *)(a1[6] + 8);
  BOOL v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0;
}

uint64_t sub_100021388(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

id sub_1000213A0(uint64_t a1)
{
  return _[*(id *)(a1 + 40) receivedXPCEvent:*(void *)(a1 + 48) forEventStream:*(void *)(*(void *)(a1 + 56) + 8)];
}

id sub_1000213B4(uint64_t a1)
{
  return _[*(id *)(*(void *)(a1 + 32) + 24) manifestAllowsMiniCardsWithCompletion:*(void *)(a1 + 40)];
}

uint64_t sub_1000213C8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000213DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000213EC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

const char *PDNFSecureXPCEventIsContactlessPresentationEvent(const char *result, void *a2)
{
  if (result)
  {
    int v3 = strcmp(result, "com.apple.stockholm.wallet.pre-arm");
    if (a2)
    {
      if (!v3) {
        *a2 = 0;
      }
    }
    return (const char *)(v3 == 0);
  }
  else
  {
    __break(1u);
  }
  return result;
}

id PDHeavyQueue()
{
  if (qword_100808DA0 != -1) {
    dispatch_once(&qword_100808DA0, &stru_100743D30);
  }
  v0 = (void *)qword_100808D98;
  return v0;
}

id sub_10002149C()
{
  if (qword_100808CE0 != -1) {
    dispatch_once(&qword_100808CE0, &stru_10073C5B0);
  }
  v0 = (void *)qword_100808CE8;
  return v0;
}

id PDDefaultQueue()
{
  if (qword_100808D80 != -1) {
    dispatch_once(&qword_100808D80, &stru_100743CF0);
  }
  v0 = (void *)qword_100808D78;
  return v0;
}

uint64_t sub_100021544()
{
  return qword_100808B28;
}

uint64_t sub_100021550()
{
  return qword_100808B20;
}

uint64_t sub_1000215A0(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

id sub_10002196C(id result)
{
  if (result)
  {
    uint64_t v1 = (unsigned __int8 *)result;
    int v2 = atomic_load((unsigned __int8 *)result + 32);
    if (v2 != 2) {
      dispatch_sync(*((dispatch_queue_t *)result + 8), &stru_10074D7F8);
    }
    int v3 = sub_100007B70(v1);
    id v4 = sub_10001FCD4((uint64_t)v1, v3);

    return v4;
  }
  return result;
}

void sub_1000223E8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_1000226F4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  id v15 = objc_alloc_init((Class)PKCreditInstallmentPlanPayment);
  [*(id *)(a1 + 56) applyPropertySetters:*(void *)(a1 + 32) toObject:v15 withProperties:v7 values:a4];

  uint64_t v8 = +[NSNumber numberWithLongLong:a2];
  id v9 = [*(id *)(a1 + 40) database];
  id v10 = +[CreditInstallmentPlanLineItem lineItemsForInstallmentPlanPaymentPID:v8 inDatabase:v9];

  [v15 setLineItems:v10];
  id v11 = [v15 statementIdentifier];
  if (v11)
  {
    id v12 = [*(id *)(a1 + 40) database];
    uint64_t v13 = +[CreditAccountStatement creditAccountStatementWithIdentifier:v11 inDatabase:v12];
    long long v14 = [v13 creditAccountStatement];

    [v15 setStatement:v14];
  }
  if (v15) {
    [*(id *)(a1 + 48) addObject:v15];
  }
}

void sub_100022BC8(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
}

void sub_100022BD0(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
}

void sub_100022BD8(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
}

void sub_100022BE0(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
  int v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKCreditInstallmentPlanPayment *)v3 setAmountDue:v4];
}

void sub_100022C44(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
  int v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKCreditInstallmentPlanPayment *)v3 setAmountPaid:v4];
}

void sub_100022CA8(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
  int v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKCreditInstallmentPlanPayment *)v3 setDueDate:v4];
}

void sub_100022D08(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
  int v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKCreditInstallmentPlanPayment *)v3 setStatementDate:v4];
}

void sub_100022D68(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
  int v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKCreditInstallmentPlanPayment *)v3 setOriginalAmountDue:v4];
}

void sub_100022DCC(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
  id v4 = a2;
  -[PKCreditInstallmentPlanPayment setPaymentNumber:](v4, "setPaymentNumber:", [a3 unsignedIntegerValue]);
}

void sub_100022E24(id a1, PKCreditInstallmentPlanPayment *a2, id a3)
{
  id v4 = a2;
  -[PKCreditInstallmentPlanPayment setPaymentCount:](v4, "setPaymentCount:", [a3 unsignedIntegerValue]);
}

void sub_100024110(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v8 = [a2 firstObject];
  uint64_t v6 = [v5 firstObject];

  if (v6 | v8)
  {
    id v7 = objc_alloc_init((Class)PKMerchant);
    [v7 setMapsMerchant:v8];
    [v7 setMapsBrand:v6];
  }
  else
  {
    id v7 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100024318(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100024334(uint64_t a1, void *a2)
{
  int v3 = (id *)(a1 + 40);
  id v4 = a2;
  id WeakRetained = objc_loadWeakRetained(v3);
  uint64_t v6 = [v4 mapItems];

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100024400;
  v7[3] = &unk_10072DF88;
  id v8 = *(id *)(a1 + 32);
  [WeakRetained _brandAndMerchantInformationForMapItems:v6 completion:v7];
}

void sub_100024400(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v8 = [a2 firstObject];
  uint64_t v6 = [v5 firstObject];

  if (v6 | v8)
  {
    id v7 = objc_alloc_init((Class)PKMerchant);
    [v7 setMapsMerchant:v8];
    [v7 setMapsBrand:v6];
  }
  else
  {
    id v7 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10002498C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 134218242;
    id v9 = [v5 count];
    __int16 v10 = 2112;
    id v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Completed maps data update with %ld items and error %@", (uint8_t *)&v8, 0x16u);
  }

  [*(id *)(a1 + 32) _brandAndMerchantInformationForMapItems:v5 completion:*(void *)(a1 + 40)];
}

id sub_1000255A4(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 32));
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(void **)(v2 + 8);
  *(void *)(v2 + 8) = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 32));
  id v4 = *(void **)(a1 + 32);
  return [v4 _executeNextRequestIfPossible];
}

Class sub_100025F48()
{
  if (qword_100808900 != -1) {
    dispatch_once(&qword_100808900, &stru_10072E040);
  }
  Class result = objc_getClass("MKMapService");
  qword_1008088F0 = (uint64_t)result;
  off_100803DD0 = (uint64_t (*)())sub_100025FAC;
  return result;
}

id sub_100025FAC()
{
  return (id)qword_1008088F0;
}

void sub_100025FB8(id a1)
{
  qword_1008088F8 = (uint64_t)dlopen("/System/Library/Frameworks/MapKit.framework/MapKit", 2);
}

Class sub_100025FE4()
{
  if (qword_100808900 != -1) {
    dispatch_once(&qword_100808900, &stru_10072E040);
  }
  Class result = objc_getClass("MKLocalSearchRequest");
  qword_100808908 = (uint64_t)result;
  off_100803DD8 = (uint64_t (*)())sub_100026048;
  return result;
}

id sub_100026048()
{
  return (id)qword_100808908;
}

Class sub_100026054()
{
  if (qword_100808900 != -1) {
    dispatch_once(&qword_100808900, &stru_10072E040);
  }
  Class result = objc_getClass("MKLocalSearch");
  qword_100808910 = (uint64_t)result;
  off_100803DE0 = (uint64_t (*)())sub_1000260B8;
  return result;
}

id sub_1000260B8()
{
  return (id)qword_100808910;
}

Class sub_1000260C4()
{
  if (qword_100808900 != -1) {
    dispatch_once(&qword_100808900, &stru_10072E040);
  }
  Class result = objc_getClass("MKWalletMerchantStylingInfo");
  qword_100808918 = (uint64_t)result;
  off_100803DE8 = (uint64_t (*)())sub_100026128;
  return result;
}

id sub_100026128()
{
  return (id)qword_100808918;
}

Class sub_100026134()
{
  if (qword_100808900 != -1) {
    dispatch_once(&qword_100808900, &stru_10072E040);
  }
  Class result = objc_getClass("MKMapItemIdentifier");
  qword_100808920 = (uint64_t)result;
  off_100803E50 = (uint64_t (*)())sub_100026198;
  return result;
}

id sub_100026198()
{
  return (id)qword_100808920;
}

void sub_1000263C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000263D8(uint64_t a1)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100026494;
  v9[3] = &unk_10072E068;
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = *(id *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 64);
  id v10 = v3;
  uint64_t v13 = v4;
  id v5 = *(id *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  id v11 = v5;
  uint64_t v12 = v6;
  [v2 enumerateKeysAndObjectsUsingBlock:v9];
  uint64_t v7 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);

  return v7;
}

void sub_100026494(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v9 = a2;
  uint64_t v7 = +[TileState insertState:a3 inDatabase:*(void *)(a1 + 32)];
  if (v7)
  {
    id v8 = [objc_alloc(*(Class *)(a1 + 56)) initWithState:v7 identifier:v9 forDescriptor:*(void *)(a1 + 40) inDatabase:*(void *)(a1 + 32)];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v8 != 0;
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
    *a4 = 1;
  }
}

void sub_100026BBC(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [a2 copyWithoutCompletion];
  [v2 addObject:v3];
}

BOOL sub_100026C68(id a1, PKPassShare *a2, unint64_t a3, BOOL *a4)
{
  [(PKPassShare *)a2 status];
  return PKShareStatusIsPendingVerification();
}

void sub_100026D5C(uint64_t a1)
{
  [*(id *)(a1 + 32) setStatus:5];
  [*(id *)(*(void *)(a1 + 40) + 8) addPassShare:*(void *)(a1 + 32) forPassUniqueIdentifier:0];
  uint64_t v2 = [*(id *)(a1 + 32) identifier];
  BOOL v3 = *(void *)(a1 + 56) == 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_100026E88;
  v11[3] = &unk_10072E148;
  id v12 = v2;
  uint64_t v4 = *(void **)(a1 + 40);
  id v5 = *(id *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  id v13 = v5;
  uint64_t v15 = v6;
  BOOL v16 = v3;
  int8x16_t v10 = *(int8x16_t *)(a1 + 32);
  id v7 = (id)v10.i64[0];
  int8x16_t v14 = vextq_s8(v10, v10, 8uLL);
  id v8 = v2;
  [v4 _enumerateOperations:v11];
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 16));
  [WeakRetained provisioningOperationsDidUpdate];
}

void sub_100026E88(uint64_t a1, void *a2, unsigned char *a3)
{
  id v5 = a2;
  uint64_t v6 = [v5 shareIdentifier];
  id v7 = *(void **)(a1 + 32);
  id v8 = v6;
  id v9 = v7;
  if (v8 == v9)
  {
  }
  else
  {
    int8x16_t v10 = v9;
    if (!v8 || !v9)
    {

      goto LABEL_20;
    }
    unsigned int v11 = [v8 isEqualToString:v9];

    if (!v11) {
      goto LABEL_20;
    }
  }
  id v12 = [v5 transportIdentifier];
  id v13 = *(void **)(a1 + 40);
  id v14 = v12;
  id v15 = v13;
  if (v14 != v15)
  {
    BOOL v16 = v15;
    if (v14 && v15)
    {
      unsigned __int8 v17 = [v14 isEqualToString:v15];

      if ((v17 & 1) == 0) {
        goto LABEL_21;
      }
      goto LABEL_14;
    }

LABEL_20:
    goto LABEL_21;
  }

LABEL_14:
  uint64_t v18 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = *(void *)(a1 + 32);
    long long v20 = PKSharingLoggableMailboxAddress();
    *(_DWORD *)buf = 138412546;
    uint64_t v30 = v19;
    __int16 v31 = 2112;
    id v32 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "StatefulProvisioningManager: Notifying operation of activation code failure for share: '%@' transportIdentifier: '%@'", buf, 0x16u);
  }
  long long v21 = *(NSObject **)(*(void *)(a1 + 48) + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100027118;
  block[3] = &unk_10072E120;
  uint64_t v27 = *(void *)(a1 + 64);
  char v28 = *(unsigned char *)(a1 + 72);
  id v22 = v5;
  id v26 = v22;
  dispatch_async(v21, block);
  if (*(unsigned char *)(a1 + 72))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16));
    id v24 = [v22 copyWithoutCompletion];
    [WeakRetained finishedStatefulProvisioningAttemptWithSuccess:0 operation:v24 share:*(void *)(a1 + 56)];
  }
  *a3 = 1;

LABEL_21:
}

void sub_100027118(uint64_t a1)
{
  if (*(void *)(a1 + 40) == 1)
  {
    uint64_t v2 = 3;
  }
  else if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = 5;
  }
  else
  {
    uint64_t v2 = 2;
  }
  id v4 = +[NSError pkSharingError:v2];
  BOOL v3 = [*(id *)(a1 + 32) completion];
  ((void (**)(void, void, id))v3)[2](v3, 0, v4);
}

void sub_100027258(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) devicePrimaryPaymentApplication];
  BOOL v3 = [v2 subcredentials];
  id v4 = [v3 anyObject];

  id v5 = [v4 identifier];
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000;
  char v20 = 0;
  uint64_t v6 = *(void **)(a1 + 40);
  id v9 = _NSConcreteStackBlock;
  uint64_t v10 = 3221225472;
  unsigned int v11 = sub_1000273B4;
  id v12 = &unk_10072E1C0;
  id v13 = v6;
  id v7 = v5;
  id v14 = v7;
  id v15 = *(id *)(a1 + 32);
  BOOL v16 = &v17;
  [v6 _enumerateOperations:&v9];
  if (*((unsigned char *)v18 + 24))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 16));
    objc_msgSend(WeakRetained, "provisioningOperationsDidUpdate", v9, v10, v11, v12, v13, v14);
  }
  _Block_object_dispose(&v17, 8);
}

void sub_10002739C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000273B4(uint64_t a1, void *a2, unsigned char *a3)
{
  id v5 = a2;
  uint64_t v6 = *(void **)(*(void *)(a1 + 32) + 8);
  id v7 = [v5 transportIdentifier];
  id v8 = [v6 passShareForTransportIdentifier:v7];

  id v9 = [v8 subcredentialIdentifier];
  uint64_t v10 = *(void **)(a1 + 40);
  id v11 = v9;
  id v12 = v10;
  if (v11 == v12)
  {

    goto LABEL_10;
  }
  id v13 = v12;
  if (v11) {
    BOOL v14 = v12 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (v14)
  {

LABEL_14:
    goto LABEL_15;
  }
  unsigned int v15 = [v11 isEqualToString:v12];

  if (!v15) {
    goto LABEL_14;
  }
LABEL_10:
  unsigned int v16 = [*(id *)(a1 + 32) _isPassProvisioningComplete:*(void *)(a1 + 48)];

  if (v16)
  {
    uint64_t v17 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = [v8 identifier];
      uint64_t v19 = [v5 transportIdentifier];
      char v20 = PKSharingLoggableMailboxAddress();
      *(_DWORD *)buf = 138412546;
      id v32 = v18;
      __int16 v33 = 2112;
      uint64_t v34 = v20;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "StatefulProvisioningManager: Notifying operation of activation code success for share: '%@' transportIdentifier: '%@'", buf, 0x16u);
    }
    long long v21 = *(NSObject **)(*(void *)(a1 + 32) + 32);
    long long v25 = _NSConcreteStackBlock;
    uint64_t v26 = 3221225472;
    uint64_t v27 = sub_10002764C;
    char v28 = &unk_10072E198;
    id v22 = v5;
    id v29 = v22;
    id v30 = *(id *)(a1 + 48);
    dispatch_async(v21, &v25);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
    *a3 = 1;
    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16));
    id v24 = objc_msgSend(v22, "copyWithoutCompletion", v25, v26, v27, v28);
    [WeakRetained finishedStatefulProvisioningAttemptWithSuccess:1 operation:v24 share:v8];
  }
LABEL_15:
}

void sub_10002764C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) completion];
  (*((void (**)(id, void, void))v2 + 2))(v2, *(void *)(a1 + 40), 0);
}

void sub_1000278D8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) identifier];
  BOOL v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    id v12 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "StatefulProvisioningManager: Terminated stateful provisioning for share: '%@'", buf, 0xCu);
  }

  id v4 = *(void **)(a1 + 40);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100027A28;
  v8[3] = &unk_10072E210;
  id v9 = v2;
  int8x16_t v7 = *(int8x16_t *)(a1 + 32);
  id v5 = (id)v7.i64[0];
  int8x16_t v10 = vextq_s8(v7, v7, 8uLL);
  id v6 = v2;
  [v4 _enumerateOperations:v8];
}

void sub_100027A28(void *a1, void *a2, unsigned char *a3)
{
  id v5 = a2;
  id v6 = [v5 shareIdentifier];
  int8x16_t v7 = (void *)a1[4];
  id v8 = v6;
  id v9 = v7;
  if (v8 == v9)
  {
  }
  else
  {
    int8x16_t v10 = v9;
    if (!v8 || !v9)
    {

      goto LABEL_9;
    }
    unsigned int v11 = [v8 isEqualToString:v9];

    if (!v11) {
      goto LABEL_9;
    }
  }
  id v12 = *(NSObject **)(a1[5] + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100027B74;
  block[3] = &unk_10072E1E8;
  id v13 = v5;
  id v16 = v13;
  dispatch_async(v12, block);
  id WeakRetained = objc_loadWeakRetained((id *)(a1[5] + 16));
  [WeakRetained finishedStatefulProvisioningAttemptWithSuccess:0 operation:v13 share:a1[6]];

  *a3 = 1;
LABEL_9:
}

void sub_100027B74(uint64_t a1)
{
  id v3 = +[NSError pkSharingError:5];
  id v2 = [*(id *)(a1 + 32) completion];
  ((void (**)(void, void, id))v2)[2](v2, 0, v3);
}

void sub_100027CB8(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = [objc_alloc((Class)PKPassShareActivationOption) initWithDefaultIdentifierForType:1];
    [v2 setValue:*(void *)(a1 + 32)];
    id v3 = *(void **)(a1 + 40);
    id v4 = objc_alloc((Class)PKPassShareActivationOptions);
    id v12 = v2;
    id v5 = +[NSArray arrayWithObjects:&v12 count:1];
    id v6 = [v4 initWithOptions:v5];
    [v3 setActivationOptions:v6];
  }
  else
  {
    [*(id *)(a1 + 40) setActivationOptions:0];
  }
  int8x16_t v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = [*(id *)(a1 + 40) identifier];
    int v10 = 138412290;
    unsigned int v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "StatefulProvisioningManager: Marking share '%@' as pending activation while waiting for verification.", (uint8_t *)&v10, 0xCu);
  }
  [*(id *)(a1 + 40) setStatus:4];
  [*(id *)(*(void *)(a1 + 48) + 8) addPassShare:*(void *)(a1 + 40) forPassUniqueIdentifier:0];
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 48) + 16));
  [WeakRetained provisioningOperationsDidUpdate];
}

void sub_100027EE4(uint64_t a1)
{
  id v6 = _NSConcreteStackBlock;
  uint64_t v7 = 3221225472;
  id v8 = sub_100027F8C;
  id v9 = &unk_10072E260;
  id v2 = *(void **)(a1 + 32);
  id v3 = *(id *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 32);
  id v10 = v3;
  uint64_t v11 = v4;
  [v2 _enumerateOperations:&v6];
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 16));
  objc_msgSend(WeakRetained, "provisioningOperationsDidUpdate", v6, v7, v8, v9);
}

void sub_100027F8C(uint64_t a1, void *a2, unsigned char *a3)
{
  id v5 = a2;
  id v6 = [v5 transportIdentifier];
  uint64_t v7 = *(void **)(a1 + 32);
  id v8 = v6;
  id v9 = v7;
  if (v8 == v9)
  {
  }
  else
  {
    id v10 = v9;
    if (!v8 || !v9)
    {

LABEL_11:
      *a3 = 0;
      goto LABEL_12;
    }
    unsigned int v11 = [v8 isEqualToString:v9];

    if (!v11) {
      goto LABEL_11;
    }
  }
  id v12 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    id v13 = PKSharingLoggableMailboxAddress();
    *(_DWORD *)buf = 138412290;
    id v24 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "StatefulProvisioningManager: Terminated stateful provisioning for transportIdentifier: '%@'", buf, 0xCu);
  }
  BOOL v14 = *(NSObject **)(*(void *)(a1 + 40) + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000281B8;
  block[3] = &unk_10072E1E8;
  id v15 = v5;
  id v22 = v15;
  dispatch_async(v14, block);
  id v16 = *(void **)(*(void *)(a1 + 40) + 8);
  uint64_t v17 = [v15 shareIdentifier];
  uint64_t v18 = [v16 passShareForIdentifier:v17];

  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 16));
  id v20 = [v15 copyWithoutCompletion];
  [WeakRetained finishedStatefulProvisioningAttemptWithSuccess:0 operation:v20 share:v18];

  *a3 = 1;
LABEL_12:
}

void sub_1000281B8(uint64_t a1)
{
  id v3 = +[NSError pkSharingError:5];
  id v2 = [*(id *)(a1 + 32) completion];
  ((void (**)(void, void, id))v2)[2](v2, 0, v3);
}

void sub_1000282CC(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v16 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "StatefulProvisioningManager: Adding new operation %@", buf, 0xCu);
  }

  uint64_t v5 = *(void *)(a1 + 40);
  uint64_t v4 = (id *)(a1 + 40);
  [*(id *)(v5 + 40) addObject:*(v4 - 1)];
  objc_initWeak((id *)buf, *v4);
  dispatch_time_t v6 = dispatch_time(0, 30000000000);
  uint64_t v7 = *((void *)*v4 + 3);
  id v9 = _NSConcreteStackBlock;
  uint64_t v10 = 3221225472;
  unsigned int v11 = sub_10002848C;
  id v12 = &unk_10072E288;
  objc_copyWeak(&v14, (id *)buf);
  id v13 = *(v4 - 1);
  dispatch_after(v6, v7, &v9);
  id WeakRetained = objc_loadWeakRetained((id *)*v4 + 2);
  objc_msgSend(WeakRetained, "provisioningOperationsDidUpdate", v9, v10, v11, v12);

  objc_destroyWeak(&v14);
  objc_destroyWeak((id *)buf);
}

void sub_100028468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10002848C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  [WeakRetained _operationDidTimeout:*(void *)(a1 + 32)];
}

BOOL sub_100028858(id a1, PDSharingStatefulProvisioningOperation *a2, unint64_t a3, BOOL *a4)
{
  return [(PDSharingStatefulProvisioningOperation *)a2 isForegroundOperation];
}

id sub_100028860(id a1, PDSharingStatefulProvisioningOperation *a2)
{
  return [(PDSharingStatefulProvisioningOperation *)a2 shareIdentifier];
}

void sub_100028D64(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_100028F50(id a1, PKTransactionReleasedData *a2, id a3)
{
  uint64_t v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKTransactionReleasedData *)v3 setPrivacyPolicyURL:v4];
}

void sub_100028FB0(id a1, PKTransactionReleasedData *a2, id a3)
{
}

void sub_100028FB8(id a1, PKTransactionReleasedData *a2, id a3)
{
}

id sub_100029030(id a1, uint64_t a2, void *a3, char a4)
{
  id v7 = a3;
  if (a1)
  {
    v12.receiver = a1;
    v12.super_class = (Class)PDDeviceRegistrationTask;
    id v8 = objc_msgSendSuper2(&v12, "init");
    a1 = v8;
    if (v8)
    {
      v8[3] = a2;
      id v9 = [v7 copy];
      uint64_t v10 = (void *)*((void *)a1 + 4);
      *((void *)a1 + 4) = v9;

      *((unsigned char *)a1 + 16) = a4;
    }
  }

  return a1;
}

void *sub_1000290BC(void *a1, void *a2, void *a3, char a4)
{
  id v7 = a3;
  if (a1)
  {
    id v8 = sub_100029030(a1, 2, a2, a4);
    if (v8)
    {
      id v9 = [v7 copy];
      uint64_t v10 = (void *)v8[7];
      v8[7] = v9;
    }
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void *sub_100029138(void *a1, void *a2, void *a3, char a4)
{
  id v7 = a3;
  if (a1)
  {
    id v8 = sub_100029030(a1, 1, a2, a4);
    if (v8)
    {
      id v9 = [v7 copy];
      uint64_t v10 = (void *)v8[6];
      v8[6] = v9;
    }
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void *sub_1000291B4(void *a1, void *a2, void *a3, char a4, char a5)
{
  id v9 = a3;
  if (a1)
  {
    uint64_t v10 = sub_100029030(a1, 0, a2, a4);
    if (v10)
    {
      id v11 = [v9 copy];
      objc_super v12 = (void *)v10[5];
      v10[5] = v11;

      *((unsigned char *)v10 + 17) = a5;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }

  return v10;
}

void sub_100029240(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = *(void **)(a1 + 8);
    id v8 = v3;
    if (!v4)
    {
      id v5 = objc_alloc_init((Class)NSMutableArray);
      dispatch_time_t v6 = *(void **)(a1 + 8);
      *(void *)(a1 + 8) = v5;

      id v4 = *(void **)(a1 + 8);
    }
    id v7 = objc_retainBlock(v8);
    [v4 addObject:v7];

    id v3 = v8;
  }
}

void *sub_1000292C8(void *result)
{
  if (result)
  {
    uint64_t v1 = (void *)result[1];
    result[1] = 0;
    id v2 = v1;

    id v3 = [v2 copy];
    return v3;
  }
  return result;
}

void sub_100029638(id *a1)
{
  if (!a1) {
    return;
  }
  id v2 = [a1[3] sharedWebService];
  id v3 = [v2 context];
  id v4 = [v3 configurationDate];
  if (v4 && sub_10002A728((uint64_t)a1, 0))
  {
    int v5 = PKAutomaticRegistrationSupported();

    if (v5)
    {
      dispatch_time_t v6 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "RegistrationService: Payment web service context changed. Performing device registration", buf, 2u);
      }

      [a1 performDeviceRegistrationForReason:@"payment context changed" brokerURL:0 action:1 forceApplePayRegister:0 forcePeerPaymentRegister:0 completion:0];
      return;
    }
  }
  else
  {
  }
  id v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v8 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "RegistrationService: Payment web service context changed. Skipping device registration", v8, 2u);
  }
}

void sub_100029884(uint64_t a1)
{
  id v2 = sub_1000290BC([PDDeviceRegistrationTask alloc], *(void **)(a1 + 32), *(void **)(a1 + 40), *(unsigned char *)(a1 + 64));
  id v3 = v2;
  id v4 = *(void **)(a1 + 56);
  id v5 = v2;
  if (v4)
  {
    sub_100029240((uint64_t)v2, v4);
    id v3 = v5;
  }
  sub_100029900(*(void *)(a1 + 48), v3);
}

void sub_100029900(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = [*(id *)(a1 + 16) count];
    [*(id *)(a1 + 16) addObject:v3];
    if (v4)
    {
      id v5 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)dispatch_time_t v6 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Registration attempt already underway", v6, 2u);
      }
    }
    else
    {
      sub_100029E10((dispatch_queue_t *)a1, v3);
    }
  }
}

void sub_100029AA8(uint64_t a1)
{
  id v2 = sub_100029138([PDDeviceRegistrationTask alloc], *(void **)(a1 + 32), *(void **)(a1 + 40), *(unsigned char *)(a1 + 64));
  id v3 = v2;
  id v4 = *(void **)(a1 + 56);
  id v5 = v2;
  if (v4)
  {
    sub_100029240((uint64_t)v2, v4);
    id v3 = v5;
  }
  sub_100029900(*(void *)(a1 + 48), v3);
}

void sub_100029C34(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (v2 != 1)
  {
    if (v2)
    {
LABEL_16:
      dispatch_time_t v6 = sub_1000291B4([PDDeviceRegistrationTask alloc], *(void **)(a1 + 48), *(void **)(a1 + 40), *(unsigned char *)(a1 + 72), *(unsigned char *)(a1 + 73));
      id v7 = v6;
      id v8 = *(void **)(a1 + 56);
      if (v8) {
        sub_100029240((uint64_t)v6, v8);
      }
      sub_100029900(*(void *)(a1 + 32), v7);

      uint64_t v3 = 0;
      goto LABEL_19;
    }
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled((os_log_t)v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)v3, OS_LOG_TYPE_DEFAULT, "Registration requested with queueing action", buf, 2u);
    }
LABEL_15:

    goto LABEL_16;
  }
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Registration requested with coalescing action", v11, 2u);
  }

  uint64_t v5 = [*(id *)(*(void *)(a1 + 32) + 16) lastObject];
  if (!v5) {
    goto LABEL_16;
  }
  uint64_t v3 = v5;
  if (*(void *)(v5 + 24)
    || ![*(id *)(v5 + 40) isEqual:*(void *)(a1 + 40)]
    || (*(unsigned char *)(v3 + 16) != 0) == (*(unsigned char *)(a1 + 72) == 0)
    || (*(unsigned char *)(v3 + 17) != 0) != (*(unsigned char *)(a1 + 73) != 0))
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Registration creating new task as mismatch with current task was detected", v10, 2u);
    }

    goto LABEL_15;
  }
  id v9 = *(void **)(a1 + 56);
  if (v9) {
    sub_100029240(v3, v9);
  }
LABEL_19:
}

void sub_100029E10(dispatch_queue_t *a1, void *a2)
{
  uint64_t v3 = a2;
  if (a1)
  {
    dispatch_assert_queue_V2(a1[1]);
    id v4 = objc_alloc((Class)NSString);
    if (v3) {
      uint64_t v5 = v3[4];
    }
    else {
      uint64_t v5 = 0;
    }
    id v6 = [v4 initWithFormat:@"PDDeviceRegistrationService.registering.%@", v5];
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_100029F04;
    v8[3] = &unk_10072E440;
    id v9 = (id)PDOSTransactionCreate((const char *)[v6 UTF8String]);
    uint64_t v10 = a1;
    id v7 = v9;
    sub_100029FE4(a1, v3, v8);
  }
}

void sub_100029F04(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
}

void sub_100029F0C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (a1)
  {
    id v9 = *(NSObject **)(a1 + 8);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_10002B070;
    v10[3] = &unk_10072E170;
    void v10[4] = a1;
    uint64_t v13 = a2;
    id v11 = v7;
    id v12 = v8;
    dispatch_async(v9, v10);
  }
}

void sub_100029FE4(dispatch_queue_t *a1, void *a2, void *a3)
{
  uint64_t v5 = a2;
  id v6 = a3;
  if (a1)
  {
    dispatch_assert_queue_V2(a1[1]);
    id v7 = [(dispatch_queue_t *)a1 paymentWebServiceCoordinator];
    id v8 = [v7 sharedWebService];

    id v9 = [(dispatch_queue_t *)a1 peerPaymentWebServiceCoordinator];
    uint64_t v10 = [v9 sharedPeerPaymentWebService];

    if (v5) {
      id v11 = (__CFString *)v5[4];
    }
    else {
      id v11 = 0;
    }
    if (!v11) {
      id v11 = @"default";
    }
    id v12 = v11;
    uint64_t v13 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      long long v25 = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Attempting registration for reason: %{public}@", buf, 0xCu);
    }

    [v8 addDiagnosticReason:v12];
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_10002A200;
    v17[3] = &unk_10072E548;
    id v18 = v8;
    uint64_t v19 = v12;
    id v23 = v6;
    id v20 = v5;
    long long v21 = a1;
    id v22 = v10;
    id v14 = v10;
    id v15 = v12;
    id v16 = v8;
    sub_10002ADA8((uint64_t)a1, v20, v16, v17);
  }
}

void sub_10002A200(uint64_t a1, char a2)
{
  if (a2)
  {
    id v24 = _NSConcreteStackBlock;
    uint64_t v25 = 3221225472;
    uint64_t v26 = sub_10002A498;
    uint64_t v27 = &unk_10072E520;
    id v28 = *(id *)(a1 + 32);
    id v29 = *(id *)(a1 + 40);
    id v3 = *(id *)(a1 + 48);
    uint64_t v4 = *(void *)(a1 + 56);
    uint64_t v5 = *(void **)(a1 + 64);
    id v30 = v3;
    uint64_t v31 = v4;
    id v32 = v5;
    id v33 = *(id *)(a1 + 72);
    id v6 = objc_retainBlock(&v24);
    id v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "RegistrationService: Attempting to register for Apple Pay.", buf, 2u);
    }

    id v8 = objc_msgSend(*(id *)(a1 + 56), "paymentWebServiceCoordinator", v24, v25, v26, v27);
    id v9 = v8;
    if (v8)
    {
      uint64_t v10 = *(void **)(a1 + 48);
      if (!v10)
      {
        uint64_t v12 = 0;
        goto LABEL_10;
      }
      uint64_t v11 = v10[3];
      switch(v11)
      {
        case 2:
          uint64_t v21 = v10[7];
          uint64_t v22 = *(void *)(a1 + 48);
          if (v22) {
            BOOL v23 = *(unsigned __int8 *)(v22 + 16) != 0;
          }
          else {
            BOOL v23 = 0;
          }
          [v8 performRegistrationForMemberOfRegions:v21 force:v23 completion:v6];
          goto LABEL_25;
        case 1:
          uint64_t v18 = v10[6];
          uint64_t v19 = *(void *)(a1 + 48);
          if (v19) {
            BOOL v20 = *(unsigned __int8 *)(v19 + 16) != 0;
          }
          else {
            BOOL v20 = 0;
          }
          [v8 performRegistrationForRegion:v18 force:v20 completion:v6];
          goto LABEL_25;
        case 0:
          uint64_t v12 = v10[5];
LABEL_10:
          uint64_t v13 = *(void *)(a1 + 48);
          if (v13) {
            BOOL v14 = *(unsigned __int8 *)(v13 + 16) != 0;
          }
          else {
            BOOL v14 = 0;
          }
          [v8 performRegistrationForBrokerURL:v12 force:v14 completion:v6];
LABEL_25:

          return;
      }
    }
    uint64_t v17 = *(void *)(a1 + 72);
    if (v17) {
      (*(void (**)(uint64_t, uint64_t, void, void))(v17 + 16))(v17, 2, 0, 0);
    }
    goto LABEL_25;
  }
  [*(id *)(a1 + 32) removeDiagnosticReason:*(void *)(a1 + 40)];
  id v15 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "RegistrationService: Cannot automatically register because the pre-conditions failed.", buf, 2u);
  }

  uint64_t v16 = *(void *)(a1 + 72);
  if (v16) {
    (*(void (**)(uint64_t, uint64_t, void, void))(v16 + 16))(v16, 2, 0, 0);
  }
}

void sub_10002A498(uint64_t a1, int a2)
{
  [*(id *)(a1 + 32) removeDiagnosticReason:*(void *)(a1 + 40)];
  uint64_t v4 = PKLogFacilityTypeGetObject();
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "RegistrationService: Successfully registered for Apple Pay.", buf, 2u);
    }

    id v6 = *(unsigned char **)(a1 + 48);
    if (v6) {
      BOOL v7 = v6[17] != 0;
    }
    else {
      BOOL v7 = 0;
    }
    if (sub_10002A728(*(void *)(a1 + 56), v6))
    {
      id v8 = *(void **)(a1 + 32);
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472;
      v18[2] = sub_10002A8D8;
      v18[3] = &unk_10072E490;
      id v19 = v8;
      id v20 = *(id *)(a1 + 64);
      id v9 = *(id *)(a1 + 40);
      uint64_t v10 = *(void *)(a1 + 56);
      id v21 = v9;
      uint64_t v22 = v10;
      BOOL v24 = v7;
      id v23 = *(id *)(a1 + 72);
      [v19 _canRegisterForPeerPaymentWithCompletion:v18];

      id v11 = v19;
    }
    else
    {
      uint64_t v13 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Peer payment registration not attempted", buf, 2u);
      }

      uint64_t v14 = *(void *)(a1 + 72);
      if (!v14) {
        goto LABEL_17;
      }
      id v11 = [*(id *)(a1 + 32) context];
      (*(void (**)(uint64_t, uint64_t, id, void))(v14 + 16))(v14, 16, v11, 0);
    }

LABEL_17:
    id v15 = *(void **)(a1 + 32);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    v16[2] = sub_10002AC9C;
    v16[3] = &unk_10072E4F8;
    id v17 = v15;
    [v17 _shouldPerformApplePayTrustRegistrationWithCompletion:v16];

    return;
  }
  if (v5)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "RegistrationService: Failed to register for Apple Pay.", buf, 2u);
  }

  uint64_t v12 = *(void *)(a1 + 72);
  if (v12) {
    (*(void (**)(uint64_t, uint64_t, void, void))(v12 + 16))(v12, 4, 0, 0);
  }
}

uint64_t sub_10002A728(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1)
  {
LABEL_26:
    uint64_t v12 = 0;
    goto LABEL_27;
  }
  if (v3) {
    BOOL v5 = *((unsigned char *)v3 + 17) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  id v6 = [*(id *)(a1 + 32) sharedPeerPaymentWebService];
  unsigned int v7 = v5 | [v6 needsRegistration];

  if (PKIsMac()) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = PKIsTV() ^ 1;
  }
  id v9 = [*(id *)(a1 + 24) sharedWebService];
  unsigned int v10 = [v9 _needsRegistrationShouldCheckSecureElementOwnership:v8];

  int v11 = v5 | PKUserHasDisabledPeerPayment() ^ 1;
  if ((v7 & v8) != 1 || v10 || (v11 & 1) == 0)
  {
    uint64_t v13 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v14 = @"N";
      if (v7) {
        CFStringRef v15 = @"Y";
      }
      else {
        CFStringRef v15 = @"N";
      }
      if (v8) {
        CFStringRef v16 = @"Y";
      }
      else {
        CFStringRef v16 = @"N";
      }
      int v19 = 138413058;
      CFStringRef v20 = v15;
      if (v10) {
        CFStringRef v17 = @"N";
      }
      else {
        CFStringRef v17 = @"Y";
      }
      __int16 v21 = 2112;
      CFStringRef v22 = v16;
      __int16 v23 = 2112;
      CFStringRef v24 = v17;
      if (v11) {
        CFStringRef v14 = @"Y";
      }
      __int16 v25 = 2112;
      CFStringRef v26 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "RegistrationService: Peer payment registration should not be attempted. peerPaymentNotRegistered: %@ supportedHardware: %@ brokerRegistered: %@ userEnabled: %@", (uint8_t *)&v19, 0x2Au);
    }

    goto LABEL_26;
  }
  uint64_t v12 = 1;
LABEL_27:

  return v12;
}

void sub_10002A8D8(uint64_t a1, int a2)
{
  uint64_t v4 = [*(id *)(a1 + 32) context];
  BOOL v5 = [v4 peerPaymentServiceURL];
  id v6 = PKPeerPaymentServiceOverrideURL();
  if (v6)
  {
    unsigned int v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      CFStringRef v20 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Using overridden peer payment service url '%@'", buf, 0xCu);
    }

    id v8 = v6;
    BOOL v5 = v8;
  }
  if (a2 && v5)
  {
    [*(id *)(a1 + 40) addDiagnosticReason:*(void *)(a1 + 48)];
    id v9 = *(void **)(a1 + 56);
    uint64_t v10 = *(unsigned __int8 *)(a1 + 72);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_10002AB10;
    v14[3] = &unk_10072E468;
    int v11 = *(void **)(a1 + 32);
    id v15 = *(id *)(a1 + 40);
    id v16 = *(id *)(a1 + 48);
    id v18 = *(id *)(a1 + 64);
    id v17 = v4;
    sub_10002AB80(v9, v5, v11, v10, v14);
  }
  else
  {
    uint64_t v12 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Peer payment registration not available for current device registration data.", buf, 2u);
    }

    uint64_t v13 = *(void *)(a1 + 64);
    if (v13) {
      (*(void (**)(uint64_t, uint64_t, void *, void))(v13 + 16))(v13, 16, v4, 0);
    }
  }
}

void sub_10002AB10(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = a3;
  [*(id *)(a1 + 32) removeDiagnosticReason:*(void *)(a1 + 40)];
  uint64_t v5 = *(void *)(a1 + 56);
  if (v5) {
    (*(void (**)(uint64_t, uint64_t, void, id))(v5 + 16))(v5, a2 | 0x10, *(void *)(a1 + 48), v6);
  }
}

void sub_10002AB80(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a5;
  if (a1)
  {
    id v10 = a2;
    int v11 = [a3 context];
    uint64_t v12 = [v11 pushToken];

    if (a4) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = PKIsWatch();
    }
    CFStringRef v14 = [a1 peerPaymentWebServiceCoordinator];
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_10002B2F8;
    v15[3] = &unk_10072E570;
    id v16 = v9;
    [v14 performDeviceRegistrationWithRegistrationURL:v10 pushToken:v12 forceReregister:a4 abridgedRegistration:v13 completion:v15];
  }
}

id *sub_10002AC9C(id *result, int a2)
{
  if (a2) {
    return (id *)_[result[4] performApplePayTrustRegistrationWithCompletion:&stru_10072E4D0];
  }
  return result;
}

void sub_10002ACB4(id a1, PKApplePayTrustKey *a2, NSError *a3)
{
  uint64_t v4 = a2;
  uint64_t v5 = a3;
  id v6 = PKLogFacilityTypeGetObject();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v7)
    {
      int v9 = 138412290;
      id v10 = v4;
      id v8 = "Apple Pay Trust registration succeeded with key: %@.";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v9, 0xCu);
    }
  }
  else if (v7)
  {
    int v9 = 138543362;
    id v10 = v5;
    id v8 = "Apple Pay Trust registration failed with error: %{public}@";
    goto LABEL_6;
  }
}

void sub_10002ADA8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    id v10 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472;
    v29[2] = sub_10002B4C8;
    v29[3] = &unk_10072E5C0;
    v29[4] = a1;
    [v10 addOperation:v29];
    v27[0] = 0;
    v27[1] = v27;
    id v27[2] = 0x3032000000;
    v27[3] = sub_10002072C;
    v27[4] = sub_100020E88;
    id v28 = 0;
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_10002B5A8;
    v24[3] = &unk_10072E610;
    CFStringRef v26 = v27;
    id v11 = v8;
    id v25 = v11;
    [v10 addOperation:v24];
    v22[0] = 0;
    v22[1] = v22;
    v22[2] = 0x2020000000;
    char v23 = 0;
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_10002B87C;
    v17[3] = &unk_10072E638;
    id v18 = v7;
    id v19 = v11;
    CFStringRef v20 = v27;
    __int16 v21 = v22;
    [v10 addOperation:v17];
    uint64_t v12 = +[NSNull null];
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_10002BD14;
    v14[3] = &unk_10072E660;
    id v15 = v9;
    id v16 = v22;
    id v13 = [v10 evaluateWithInput:v12 completion:v14];

    _Block_object_dispose(v22, 8);
    _Block_object_dispose(v27, 8);
  }
}

void sub_10002B044(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Unwind_Resume(a1);
}

void sub_10002B070(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 16) firstObject];
  if (v2)
  {
    id v3 = v2;
    [*(id *)(*(void *)(a1 + 32) + 16) removeObjectAtIndex:0];
    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    uint64_t v4 = sub_1000292C8(v3);
    id v5 = [v4 countByEnumeratingWithState:&v14 objects:v20 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v15;
      do
      {
        id v8 = 0;
        do
        {
          if (*(void *)v15 != v7) {
            objc_enumerationMutation(v4);
          }
          (*(void (**)(void))(*(void *)(*((void *)&v14 + 1) + 8 * (void)v8) + 16))(*(void *)(*((void *)&v14 + 1) + 8 * (void)v8));
          id v8 = (char *)v8 + 1;
        }
        while (v6 != v8);
        id v6 = [v4 countByEnumeratingWithState:&v14 objects:v20 count:16];
      }
      while (v6);
    }

    id v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = v3[4].isa;
      *(_DWORD *)buf = 138543362;
      id v19 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Completed processing registration attempt with reason :%{public}@", buf, 0xCu);
    }
    id v11 = objc_msgSend(*(id *)(*(void *)(a1 + 32) + 16), "count", (void)v14);
    BOOL v12 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (v11)
    {
      if (v12)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Processing next registration attempt", buf, 2u);
      }

      uint64_t v13 = [*(id *)(*(void *)(a1 + 32) + 16) firstObject];

      sub_100029E10(*(void *)(a1 + 32), v13);
      id v3 = v13;
    }
    else
    {
      if (v12)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Completed processing all registration attempts", buf, 2u);
      }
    }
  }
  else
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Error: no registration task found for completion", buf, 2u);
    }
  }
}

void sub_10002B2F8(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = PKLogFacilityTypeGetObject();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v7)
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Successfully registered with the peer payment service.", (uint8_t *)&v15, 2u);
    }

    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
      id v9 = *(void (**)(void))(v8 + 16);
LABEL_16:
      v9();
    }
  }
  else
  {
    if (v7)
    {
      int v15 = 138412290;
      id v16 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Failed to register with the peer payment service: %@.", (uint8_t *)&v15, 0xCu);
    }

    id v10 = [v5 domain];
    unsigned int v11 = [v10 isEqualToString:PKPeerPaymentWebServiceErrorDomain];

    if (v11)
    {
      id v12 = [v5 code];
      id v13 = v12;
      if (v12 == (id)40319 || v12 == (id)40308)
      {
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          int v15 = 134217984;
          id v16 = v13;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Including PKDeviceRegistrationResultPeerPaymentDoNotRetry in result due to terminal server response %li", (uint8_t *)&v15, 0xCu);
        }
      }
    }
    uint64_t v14 = *(void *)(a1 + 32);
    if (v14)
    {
      id v9 = *(void (**)(void))(v14 + 16);
      goto LABEL_16;
    }
  }
}

void sub_10002B4C8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(*(void *)(a1 + 32) + 24);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_10002B590;
  v11[3] = &unk_10072E598;
  id v12 = v6;
  id v13 = v7;
  id v9 = v6;
  id v10 = v7;
  [v8 updateWebServiceConfigurationWithCompletion:v11];
}

uint64_t sub_10002B590(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_10002B5A8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = [*(id *)(a1 + 32) _appleAccountInformation];
  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
  id v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;

  unsigned int v11 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  if (!v11
    || ([v11 aidaAccountAvailable] & 1) != 0
    || ([*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) aidaAccountRequiresAuthentication] & 1) == 0)
  {
LABEL_11:
    v7[2](v7, v6, 0);
    goto LABEL_12;
  }
  unsigned __int8 v12 = +[PDSetupAssistantCompleteMonitor hasCompletedSetupAssistant];
  id v13 = PKLogFacilityTypeGetObject();
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  if ((v12 & 1) == 0)
  {
    if (v14)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "RegistrationService: account requires token renewal, but setup assistant not complete", buf, 2u);
    }

    goto LABEL_11;
  }
  if (v14)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "RegistrationService: renewing apple account auth", buf, 2u);
  }

  int v15 = +[PKAppleAccountManager sharedInstance];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_10002B780;
  v16[3] = &unk_10072E5E8;
  uint64_t v19 = *(void *)(a1 + 40);
  id v18 = v7;
  id v17 = v6;
  [v15 renewAppleAccountWithCompletionHandler:v16];

LABEL_12:
}

void sub_10002B780(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = PKLogFacilityTypeGetObject();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v7)
    {
      *(_WORD *)unsigned __int8 v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "RegistrationService: Failed to renewed applet account auth", v12, 2u);
    }

    uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v9 = *(void **)(v8 + 40);
    *(void *)(v8 + 40) = 0;
  }
  else
  {
    if (v7)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "RegistrationService: Successfully renewed applet account auth", buf, 2u);
    }

    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    id v11 = v5;
    uint64_t v9 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v11;
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10002B87C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  uint64_t v9 = a4;
  uint64_t v10 = *(void *)(a1 + 32);
  if (!v10) {
    goto LABEL_4;
  }
  uint64_t v11 = *(void *)(v10 + 24);
  if ((unint64_t)(v11 - 1) >= 2)
  {
    if (v11) {
      goto LABEL_46;
    }
LABEL_4:
    if (![*(id *)(a1 + 40) registrationSetupSupportedInRegion]) {
      goto LABEL_46;
    }
  }
  int v12 = PKPasscodeEnabled();
  int IsAvailable = PKSecureElementIsAvailable();
  BOOL v14 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  id v34 = v7;
  if (v14) {
    unsigned int v15 = [v14 aidaAccountAvailable];
  }
  else {
    unsigned int v15 = 0;
  }
  int v16 = PKIsSRD();
  id v17 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) aaAlternateDSID];
  int v33 = PKIsBeneficiaryAccountWithAltDsid();

  id v18 = [*(id *)(a1 + 40) targetDevice];
  id v19 = [v18 secureElementOwnershipStateForCurrentUser];

  CFStringRef v20 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v21 = @"YES";
    if (!IsAvailable) {
      CFStringRef v21 = @"NO";
    }
    *(_DWORD *)buf = 138543362;
    CFStringRef v36 = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "RegistrationService: Secure Element Available: %{public}@", buf, 0xCu);
  }

  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v22 = @"YES";
    if (!v12) {
      CFStringRef v22 = @"NO";
    }
    *(_DWORD *)buf = 138543362;
    CFStringRef v36 = v22;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "RegistrationService: Passcode is enabled: %{public}@", buf, 0xCu);
  }

  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v23 = @"NO";
    if (v15) {
      CFStringRef v23 = @"YES";
    }
    *(_DWORD *)buf = 138543362;
    CFStringRef v36 = v23;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "RegistrationService: AppleIDAuth account for primary AppleAccount: %{public}@", buf, 0xCu);
  }
  unint64_t v24 = (unint64_t)v19 - 1;

  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v25 = @"NO";
    if (v24 < 3) {
      CFStringRef v25 = @"YES";
    }
    if ((unint64_t)v19 > 7) {
      CFStringRef v26 = @"unknown";
    }
    else {
      CFStringRef v26 = *(&off_10072E680 + (void)v19);
    }
    *(_DWORD *)buf = 138543618;
    CFStringRef v36 = v25;
    __int16 v37 = 2112;
    CFStringRef v38 = v26;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "RegistrationService: Secure element ownership state valid: %{public}@ - %@", buf, 0x16u);
  }

  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v27 = @"NO";
    if (v16) {
      CFStringRef v27 = @"YES";
    }
    *(_DWORD *)buf = 138543362;
    CFStringRef v36 = v27;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "RegistrationService: Is SRD: %{public}@", buf, 0xCu);
  }

  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v28 = @"NO";
    if (v33) {
      CFStringRef v28 = @"YES";
    }
    *(_DWORD *)buf = 138543362;
    CFStringRef v36 = v28;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "RegistrationService: Is Beneficiary Account: %{public}@", buf, 0xCu);
  }

  char v29 = 0;
  if (v12) {
    char v30 = v16;
  }
  else {
    char v30 = 1;
  }
  if (v30)
  {
    id v7 = v34;
  }
  else
  {
    id v7 = v34;
    if (IsAvailable)
    {
      if (((v15 ^ 1) & 1) == 0)
      {
        char v29 = v33 ^ 1;
        if (v24 >= 3) {
          char v29 = 0;
        }
      }
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v29;
LABEL_46:
  uint64_t v31 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
      CFStringRef v32 = @"YES";
    }
    else {
      CFStringRef v32 = @"NO";
    }
    *(_DWORD *)buf = 138543362;
    CFStringRef v36 = v32;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "RegistrationService: Can automatically register %{public}@", buf, 0xCu);
  }

  v9[2](v9, v8, 0);
}

uint64_t sub_10002BD14(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
}

int main(int argc, const char **argv, const char **envp)
{
  id v5 = +[NSNotificationCenter defaultCenter];
  id v6 = [v5 addObserverForName:NSCurrentLocaleDidChangeNotification object:0 queue:0 usingBlock:&stru_10072E6E0];

  id v7 = PDDefaultQueue();
  dispatch_sync(v7, &stru_10072E700);

  id v8 = +[NSRunLoop currentRunLoop];
  [v8 run];

  return 0;
}

void sub_10002C4F4(id a1, NSNotification *a2)
{
  uint64_t v2 = a2;
  PDSetPaymentSetupFeaturesAreDirty();
  PDSetSpotlightIndexNeedsIndexing();
  exit(0);
}

void sub_10002C744(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v3 = [*(id *)(a1 + 32) userNotificationManager];
  [v3 updateWalletBadgeCount];

  if ([*(id *)(a1 + 32) _canShowPayLaterNotificationsForAccount:v4 financingPlan:*(void *)(a1 + 40)])
  {
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeNewFinancingPlanNotification:oldFinancingPlan:account:", *(void *)(a1 + 40), *(void *)(a1 + 40), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeCanceledFinancingPlanNotification:oldFinancingPlan:account:", *(void *)(a1 + 40), *(void *)(a1 + 48), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeNewPaymentNotification:oldFinancingPlan:account:", *(void *)(a1 + 40), *(void *)(a1 + 48), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeDeclinedPaymentNotification:oldFinancingPlan:account:", *(void *)(a1 + 40), *(void *)(a1 + 48), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeFinancingPlanPaymentReminderNotifications:account:", *(void *)(a1 + 40), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeFinancingPlanPastDueNotifications:oldFinancingPlan:account:", *(void *)(a1 + 40), *(void *)(a1 + 48), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeFinancingPlanScheduleSummaryReasonNotifications:oldFinancingPlan:account:", *(void *)(a1 + 40), *(void *)(a1 + 48), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeRefundPaymentNotification:oldFinancingPlan:account:", *(void *)(a1 + 40), *(void *)(a1 + 48), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeFinancingPlanDisputeNotifications:oldFinancingPlan:account:", *(void *)(a1 + 40), *(void *)(a1 + 48), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeAdjustmentPaymentNotification:oldFinancingPlan:account:", *(void *)(a1 + 40), *(void *)(a1 + 48), v4);
  }
}

void sub_10002C8F0(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v3 = [*(id *)(a1 + 32) userNotificationManager];
  [v3 updateWalletBadgeCount];

  if ([*(id *)(a1 + 32) _canShowPayLaterNotificationsForAccount:v4 financingPlan:*(void *)(a1 + 40)])
  {
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeNewFinancingPlanNotification:oldFinancingPlan:account:", *(void *)(a1 + 40), 0, v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeFinancingPlanPaymentReminderNotifications:account:", *(void *)(a1 + 40), v4);
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeFinancingPlanPastDueNotifications:oldFinancingPlan:account:", *(void *)(a1 + 40), 0, v4);
  }
}

void sub_10002CA3C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) userNotificationManager];
  [v2 updateWalletBadgeCount];

  for (uint64_t i = 0; i != 3; ++i)
  {
    id v4 = [*(id *)(a1 + 32) userNotificationManager];
    id v5 = +[PDAccountFinancingPlanUserNotification notificationIdentifierForFinancingPlan:*(void *)(a1 + 40) updateType:i];
    [v4 removeUserNotificationWithIdentifier:v5];
  }
  id v6 = [*(id *)(a1 + 32) userNotificationManager];
  id v7 = +[PDAccountFinancingPlanPaidOffNotification notificationIdentifierForFinancingPlan:*(void *)(a1 + 40)];
  [v6 removeUserNotificationWithIdentifier:v7];

  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  id v8 = [*(id *)(a1 + 40) scheduleSummary];
  uint64_t v9 = [v8 payments];

  id v10 = [v9 countByEnumeratingWithState:&v48 objects:v54 count:16];
  if (v10)
  {
    id v11 = v10;
    uint64_t v12 = *(void *)v49;
    do
    {
      id v13 = 0;
      do
      {
        if (*(void *)v49 != v12) {
          objc_enumerationMutation(v9);
        }
        uint64_t v14 = *(void *)(*((void *)&v48 + 1) + 8 * (void)v13);
        unsigned int v15 = [*(id *)(a1 + 32) userNotificationManager];
        int v16 = +[PDAccountFinancingPlanPaymentNotification notificationIdentifierForPayment:v14];
        [v15 removeUserNotificationWithIdentifier:v16];

        id v13 = (char *)v13 + 1;
      }
      while (v11 != v13);
      id v11 = [v9 countByEnumeratingWithState:&v48 objects:v54 count:16];
    }
    while (v11);
  }

  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  id v17 = [*(id *)(a1 + 40) disputes];
  id v18 = [v17 countByEnumeratingWithState:&v44 objects:v53 count:16];
  if (v18)
  {
    id v19 = v18;
    uint64_t v20 = *(void *)v45;
    do
    {
      CFStringRef v21 = 0;
      do
      {
        if (*(void *)v45 != v20) {
          objc_enumerationMutation(v17);
        }
        uint64_t v22 = *(void *)(*((void *)&v44 + 1) + 8 * (void)v21);
        CFStringRef v23 = [*(id *)(a1 + 32) userNotificationManager];
        unint64_t v24 = +[PDAccountFinancingPlanDisputeUpdateNotification notificationIdentifierForFinancingPlan:*(void *)(a1 + 40) dispute:v22 type:0];
        [v23 removeUserNotificationWithIdentifier:v24];

        CFStringRef v25 = [*(id *)(a1 + 32) userNotificationManager];
        CFStringRef v26 = +[PDAccountFinancingPlanDisputeUpdateNotification notificationIdentifierForFinancingPlan:*(void *)(a1 + 40) dispute:v22 type:1];
        [v25 removeUserNotificationWithIdentifier:v26];

        CFStringRef v21 = (char *)v21 + 1;
      }
      while (v19 != v21);
      id v19 = [v17 countByEnumeratingWithState:&v44 objects:v53 count:16];
    }
    while (v19);
  }

  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  CFStringRef v27 = objc_msgSend(*(id *)(a1 + 40), "scheduleSummary", 0);
  CFStringRef v28 = [v27 installments];

  id v29 = [v28 countByEnumeratingWithState:&v40 objects:v52 count:16];
  if (v29)
  {
    id v30 = v29;
    uint64_t v31 = *(void *)v41;
    do
    {
      CFStringRef v32 = 0;
      do
      {
        if (*(void *)v41 != v31) {
          objc_enumerationMutation(v28);
        }
        uint64_t v33 = 0;
        uint64_t v34 = *(void *)(*((void *)&v40 + 1) + 8 * (void)v32);
        do
        {
          uint64_t v35 = [*(id *)(a1 + 32) userNotificationManager];
          CFStringRef v36 = +[PDAccountFinancingPlanPaymentReminderNotification notificationIdentifierForInstallment:v34 reminderOffset:v33];
          [v35 removeUserNotificationWithIdentifier:v36];

          ++v33;
        }
        while (v33 != 3);
        CFStringRef v32 = (char *)v32 + 1;
      }
      while (v32 != v30);
      id v30 = [v28 countByEnumeratingWithState:&v40 objects:v52 count:16];
    }
    while (v30);
  }

  for (uint64_t j = 0; j != 17; ++j)
  {
    CFStringRef v38 = [*(id *)(a1 + 32) userNotificationManager];
    id v39 = +[PDAccountFinancingPlanPastDueNotification notificationIdentifierForFinancingPlan:*(void *)(a1 + 40) daysPastDueEnum:j];
    [v38 removeUserNotificationWithIdentifier:v39];
  }
}

id sub_10002CF5C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) userNotificationManager];
  [v2 updateWalletBadgeCount];

  id result = [*(id *)(a1 + 32) _canShowPayLaterNotificationsForAccount:*(void *)(a1 + 40) overrideBlockNotifications:1];
  if (result)
  {
    objc_msgSend(*(id *)(a1 + 32), "_queue_computeAccountStateChangeNotification:oldAccount:", *(void *)(a1 + 40), *(void *)(a1 + 48));
    id v4 = *(void **)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    return _objc_msgSend(v4, "_queue_removeSummaryTimesForAccountChangedIfNecessary:oldAccount:", v5, v6);
  }
  return result;
}

BOOL sub_10002DECC(id a1, PKPayLaterInstallment *a2, unint64_t a3, BOOL *a4)
{
  return [(PKPayLaterInstallment *)a2 status] == (id)1;
}

int64_t sub_10002DEF0(id a1, PKPayLaterInstallment *a2, PKPayLaterInstallment *a3)
{
  id v4 = a3;
  uint64_t v5 = [(PKPayLaterInstallment *)a2 dueDate];
  uint64_t v6 = [(PKPayLaterInstallment *)v4 dueDate];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

void sub_10002E214(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) userNotificationManager];
  id v3 = [v2 scheduledNotificationActivitiesForPassUniqueIdentifier:*(void *)(a1 + 40) ofType:54];

  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v4 = v3;
  id v5 = [v4 countByEnumeratingWithState:&v23 objects:v29 count:16];
  if (v5)
  {
    id v7 = v5;
    uint64_t v8 = *(void *)v24;
    *(void *)&long long v6 = 138412290;
    long long v22 = v6;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v24 != v8) {
          objc_enumerationMutation(v4);
        }
        id v10 = *(void **)(*((void *)&v23 + 1) + 8 * i);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v11 = v10;
          uint64_t v12 = [*(id *)(a1 + 48) planIdentifier];
          id v13 = [v11 planIdentifier];
          id v14 = v12;
          id v15 = v13;
          if (v14 != v15)
          {
            int v16 = v15;
            if (v14 && v15)
            {
              unsigned __int8 v17 = [v14 isEqualToString:v15];

              if ((v17 & 1) == 0) {
                goto LABEL_18;
              }
LABEL_13:
              id v18 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = v22;
                id v28 = v11;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Removing future scheduled financing plan past due notification: %@", buf, 0xCu);
              }

              id v14 = [*(id *)(a1 + 32) userNotificationManager];
              [v14 removeUserNotification:v11];
            }
            else
            {
            }
LABEL_18:

            continue;
          }

          goto LABEL_13;
        }
      }
      id v7 = [v4 countByEnumeratingWithState:&v23 objects:v29 count:16];
    }
    while (v7);
  }

  for (uint64_t j = 0; j != 17; ++j)
  {
    uint64_t v20 = objc_msgSend(*(id *)(a1 + 32), "userNotificationManager", v22, (void)v23);
    CFStringRef v21 = +[PDAccountFinancingPlanPastDueNotification notificationIdentifierForFinancingPlan:*(void *)(a1 + 48) daysPastDueEnum:j];
    [v20 removeUserNotificationWithIdentifier:v21];
  }
}

id sub_10002F264(uint64_t a1, void *a2)
{
  uint64_t v2 = [a2 disputes];
  id v3 = objc_msgSend(v2, "pk_arrayByApplyingBlock:", &stru_10072E810);
  id v4 = +[NSSet setWithArray:v3];

  return v4;
}

id sub_10002F2E4(id a1, PKPayLaterFinancingPlanDispute *a2)
{
  return [(PKPayLaterFinancingPlanDispute *)a2 identifier];
}

id sub_10002F2EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v4 = *(void **)(a1 + 32);
    id v5 = [v3 disputeIdentifier];
    id v6 = [v4 containsObject:v5];
  }
  else
  {
    id v6 = 0;
  }

  return v6;
}

id sub_10002F370(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [a2 identifier];
  id v4 = [v2 containsObject:v3];

  return v4;
}

int64_t sub_10002F3B8(id a1, PKPayLaterFinancingPlanDispute *a2, PKPayLaterFinancingPlanDispute *a3)
{
  id v4 = a3;
  id v5 = [(PKPayLaterFinancingPlanDispute *)a2 lastUpdated];
  id v6 = [(PKPayLaterFinancingPlanDispute *)v4 lastUpdated];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

int64_t sub_10002F428(id a1, PKPayLaterFinancingPlanDispute *a2, PKPayLaterFinancingPlanDispute *a3)
{
  id v4 = a3;
  id v5 = [(PKPayLaterFinancingPlanDispute *)a2 lastUpdated];
  id v6 = [(PKPayLaterFinancingPlanDispute *)v4 lastUpdated];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

id sub_10002FABC(uint64_t a1, void *a2)
{
  id v3 = [a2 scheduleSummary];
  id v4 = [v3 paymentsOfType:*(void *)(a1 + 32)];
  id v5 = objc_msgSend(v4, "pk_arrayByApplyingBlock:", &stru_10072E900);
  id v6 = +[NSSet setWithArray:v5];

  return v6;
}

id sub_10002FB54(id a1, PKPayLaterPayment *a2)
{
  return [(PKPayLaterPayment *)a2 paymentIdentifier];
}

id sub_10002FB5C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [a2 paymentIdentifier];
  id v4 = [v2 containsObject:v3];

  return v4;
}

int64_t sub_10002FBA4(id a1, PKPayLaterPayment *a2, PKPayLaterPayment *a3)
{
  id v4 = a3;
  id v5 = [(PKPayLaterPayment *)a2 postedDate];
  id v6 = [(PKPayLaterPayment *)v4 postedDate];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

void sub_10002FCEC(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) accountManager];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10002FDA0;
  v4[3] = &unk_10072E9B0;
  uint64_t v3 = *(void *)(a1 + 40);
  v4[4] = *(void *)(a1 + 32);
  id v5 = *(id *)(a1 + 48);
  [v2 accountWithIdentifier:v3 completion:v4];
}

void sub_10002FDA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) workQueue];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10002FE64;
  v7[3] = &unk_10072E598;
  id v5 = *(id *)(a1 + 40);
  id v8 = v3;
  id v9 = v5;
  id v6 = v3;
  dispatch_async(v4, v7);
}

uint64_t sub_10002FE64(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_10002FFA4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) workQueue];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_10003009C;
  v10[3] = &unk_10072EA00;
  id v11 = v3;
  id v12 = *(id *)(a1 + 40);
  id v5 = *(id *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 32);
  id v13 = v5;
  uint64_t v14 = v6;
  id v7 = *(id *)(a1 + 56);
  uint64_t v8 = *(void *)(a1 + 64);
  id v15 = v7;
  uint64_t v16 = v8;
  id v9 = v3;
  dispatch_async(v4, v10);
}

void sub_10003009C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2 && [v2 isActive])
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 40);
      int v10 = 138412290;
      uint64_t v11 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&v10, 0xCu);
    }

    id v5 = *(void **)(a1 + 48);
    uint64_t v6 = 2;
  }
  else
  {
    id v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 64);
      int v10 = 138412290;
      uint64_t v11 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&v10, 0xCu);
    }

    id v5 = *(void **)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 72);
  }
  [v5 setSuppressionBehavior:v6];
  [*(id *)(a1 + 48) setReissueBannerOnUpdate:0];
  id v9 = [*(id *)(a1 + 56) userNotificationManager];
  [v9 insertUserNotification:*(void *)(a1 + 48)];
}

BOOL sub_1000302D4(id a1, PKPayLaterFinancingPlanDispute *a2)
{
  return [(PKPayLaterFinancingPlanDispute *)a2 isTerminal] ^ 1;
}

BOOL sub_1000302F4(id a1, PKPayLaterFinancingPlanDispute *a2)
{
  return [(PKPayLaterFinancingPlanDispute *)a2 isTerminal] ^ 1;
}

void sub_100030814(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [v5 setOrder:a3];
  id v6 = +[PaymentTransactionAward insertPaymentTransactionAward:v5 forPaymentTransactionPID:*(void *)(a1 + 48) inDatabase:*(void *)(a1 + 32)];

  [*(id *)(a1 + 40) safelyAddObject:v6];
}

void sub_100030B9C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v12 = objc_alloc_init((Class)PKPaymentTransactionAward);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v12 withProperties:v6 values:a4];
  id v7 = *(void **)(a1 + 48);
  uint64_t v8 = *(void *)(a4 + 8 * (void)[v6 indexOfObject:@"amount"]);
  uint64_t v9 = *(void *)(a4 + 8 * (void)[v6 indexOfObject:@"currency"]);
  id v10 = [v6 indexOfObject:@"exponent"];

  uint64_t v11 = objc_msgSend(v7, "_postProcessedAmountForDecimalAmount:currency:exponent:", v8, v9, objc_msgSend(*(id *)(a4 + 8 * (void)v10), "integerValue"));
  [v12 setAmount:v11];

  [*(id *)(a1 + 40) safelyAddObject:v12];
}

void sub_100030F90(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v11 = objc_alloc_init((Class)PKPaymentTransactionAward);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v11 withProperties:v6 values:a4];
  id v7 = objc_msgSend(*(id *)(a1 + 48), "_postProcessedAmountForDecimalAmount:currency:exponent:", *(void *)(a4 + 8 * (void)objc_msgSend(v6, "indexOfObject:", @"amount")), *(void *)(a4 + 8 * (void)objc_msgSend(v6, "indexOfObject:", @"currency")), objc_msgSend(*(id *)(a4 + 8 * (void)objc_msgSend(v6, "indexOfObject:", @"exponent")), "integerValue"));
  [v11 setAmount:v7];

  id v8 = [v6 count];
  id v9 = *(id *)(a4 + 8 * (void)v8 - 8);
  id v10 = [*(id *)(a1 + 40) objectForKey:v9];
  if (!v10)
  {
    id v10 = objc_alloc_init((Class)NSMutableArray);
    [*(id *)(a1 + 40) setObject:v10 forKey:v9];
  }
  [v10 addObject:v11];
}

void sub_1000317B4(id a1, PKPaymentTransactionAward *a2, id a3)
{
}

void sub_1000317BC(id a1, PKPaymentTransactionAward *a2, id a3)
{
}

void sub_1000317C4(id a1, PKPaymentTransactionAward *a2, id a3)
{
  uint64_t v4 = a2;
  -[PKPaymentTransactionAward setOrder:](v4, "setOrder:", [a3 integerValue]);
}

void sub_10003181C(id a1, PKPaymentTransactionAward *a2, id a3)
{
}

void sub_100031824(id a1, PKPaymentTransactionAward *a2, id a3)
{
}

void sub_10003182C(id a1, PKPaymentTransactionAward *a2, id a3)
{
}

void sub_100031834(id a1, PKPaymentTransactionAward *a2, id a3)
{
}

void sub_10003183C(id a1, PKPaymentTransactionAward *a2, id a3)
{
  uint64_t v4 = a2;
  -[PKPaymentTransactionAward setHasDeepLink:](v4, "setHasDeepLink:", [a3 BOOLValue]);
}

void sub_100031894(id a1, PKPaymentTransactionAward *a2, id a3)
{
  uint64_t v4 = a2;
  -[PKPaymentTransactionAward setClaimExpired:](v4, "setClaimExpired:", [a3 BOOLValue]);
}

void sub_1000318EC(id a1, PKPaymentTransactionAward *a2, id a3)
{
  uint64_t v4 = a2;
  -[PKPaymentTransactionAward setRedeemExpired:](v4, "setRedeemExpired:", [a3 BOOLValue]);
}

void sub_100031944(id a1, PKPaymentTransactionAward *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPaymentTransactionAward *)v3 setClaimExpiryDate:v4];
}

void sub_1000319A4(id a1, PKPaymentTransactionAward *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPaymentTransactionAward *)v3 setRedeemExpiryDate:v4];
}

void sub_100032004(uint64_t a1, uint64_t a2)
{
  id v4 = [AccountHold alloc];
  id v5 = [*(id *)(a1 + 32) database];
  id v8 = [(SQLiteEntity *)v4 initWithPersistentID:a2 inDatabase:v5];

  id v6 = *(void **)(a1 + 40);
  id v7 = [(AccountHold *)v8 hold];
  [v6 addObject:v7];
}

void sub_100032364(id a1, PKAccountHold *a2, id a3)
{
}

void sub_10003236C(id a1, PKAccountHold *a2, id a3)
{
  id v4 = a2;
  -[PKAccountHold setType:](v4, "setType:", [a3 integerValue]);
}

void sub_1000323C4(id a1, PKAccountHold *a2, id a3)
{
  id v4 = a2;
  -[PKAccountHold setState:](v4, "setState:", [a3 integerValue]);
}

void sub_100032564(void *a1, uint64_t a2, uint64_t a3)
{
  +[SQLiteEntity applyPropertySetters:a1[4] toObject:a1[5] withProperties:a2 values:a3];
  id v10 = *(id *)(a3 + 8 * a1[6]);
  id v5 = PKCurrencyStorageNumberToCurrencyDecimal();
  if (v5)
  {
    id v6 = +[NSDecimalNumber notANumber];
    unsigned __int8 v7 = [v5 isEqualToNumber:v6];

    if ((v7 & 1) == 0)
    {
      if (v10)
      {
        id v8 = (void *)a1[5];
        id v9 = PKCurrencyAmountMake();
        [v8 setCurrencyAmount:v9];
      }
    }
  }
}

id _ActionURLsForSQLValue(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc((Class)NSSet);
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  id v5 = objc_msgSend(v2, "initWithObjects:", v3, v4, objc_opt_class(), 0);
  id v6 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v5 fromData:v1 error:0];

  return v6;
}

id _SQLValueForActionInfo(void *a1)
{
  id v1 = a1;
  if (!v1
    || (+[NSKeyedArchiver archivedDataWithRootObject:v1 requiringSecureCoding:1 error:0], (id v2 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    id v2 = +[NSNull null];
  }

  return v2;
}

id _SQLValueForActionIconURLs(void *a1)
{
  id v1 = a1;
  if (!v1
    || (+[NSKeyedArchiver archivedDataWithRootObject:v1 requiringSecureCoding:1 error:0], (id v2 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    id v2 = +[NSNull null];
  }

  return v2;
}

id _ActionIconURLsForSQLValue(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc((Class)NSSet);
  uint64_t v3 = objc_opt_class();
  id v4 = objc_msgSend(v2, "initWithObjects:", v3, objc_opt_class(), 0);
  id v5 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v4 fromData:v1 error:0];

  return v5;
}

void sub_100033128(uint64_t a1, uint64_t a2)
{
  id v5 = [(SQLiteEntity *)[DiscoveryEngagementMessage alloc] initWithPersistentID:a2 inDatabase:*(void *)(a1 + 32)];
  uint64_t v3 = *(void **)(a1 + 40);
  id v4 = [(DiscoveryEngagementMessage *)v5 engagementMessage];
  [v3 addObject:v4];
}

void sub_100033458(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v19 = a3;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id obj = a2;
  id v4 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v4)
  {
    id v5 = v4;
    id v6 = 0;
    uint64_t v21 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = *(void *)v24;
    do
    {
      id v9 = 0;
      uint64_t v20 = v6;
      uint64_t v10 = v19 + 8 * (void)v6;
      do
      {
        if (*(void *)v24 != v8) {
          objc_enumerationMutation(obj);
        }
        id v11 = *(void **)(*((void *)&v23 + 1) + 8 * (void)v9);
        id v12 = *(void **)(v10 + 8 * (void)v9);
        id v13 = +[NSNull null];
        if (v12 == v13) {
          uint64_t v14 = 0;
        }
        else {
          uint64_t v14 = *(void **)(v10 + 8 * (void)v9);
        }
        id v15 = v14;

        if ([v11 isEqualToString:@"n"])
        {
          uint64_t v16 = (void *)v7;
          uint64_t v7 = _DateForSQLValue();
        }
        else if ([v11 isEqualToString:@"o"])
        {
          uint64_t v16 = (void *)v21;
          uint64_t v21 = _DateForSQLValue();
        }
        else
        {
          uint64_t v17 = [*(id *)(a1 + 32) objectForKey:v11];
          uint64_t v16 = (void *)v17;
          if (v17) {
            (*(void (**)(uint64_t, void, id))(v17 + 16))(v17, *(void *)(a1 + 40), v15);
          }
        }

        id v9 = (char *)v9 + 1;
      }
      while (v5 != v9);
      id v5 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
      id v6 = (char *)v9 + (void)v20;
    }
    while (v5);
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v7 = 0;
  }
  if (v7 | v21)
  {
    id v18 = [objc_alloc((Class)PKDiscoveryRelevantDateRange) initWithStartDate:v7 endDate:v21];
    [*(id *)(a1 + 40) setRelevantDateRange:v18];
  }
}

void sub_100033EE0(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
}

void sub_100033EE8(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a2;
  -[PKDiscoveryEngagementMessage setVersion:](v4, "setVersion:", [a3 integerValue]);
}

void sub_100033F40(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
}

void sub_100033F48(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  uint64_t v3 = a2;
  id v4 = (id)_OSVersionRequirementRangeForSQLValue();
  [(PKDiscoveryEngagementMessage *)v3 setOsVersionRange:v4];
}

void sub_100033FA8(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a2;
  -[PKDiscoveryEngagementMessage setPassQualifier:](v4, "setPassQualifier:", [a3 integerValue]);
}

void sub_100034000(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
}

void sub_100034008(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
}

void sub_100034010(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKDiscoveryEngagementMessage *)a2 action];
  [v5 setTitleKey:v4];
}

void sub_100034070(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKDiscoveryEngagementMessage *)a2 action];
  id v5 = [v4 integerValue];

  [v6 setType:v5];
}

void sub_1000340E0(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a2;
  _ActionIconURLsForSQLValue(a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  [(PKDiscoveryEngagementMessage *)v4 setIconURLs:v5];
}

void sub_100034144(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a3;
  id v6 = [(PKDiscoveryEngagementMessage *)a2 action];
  id v5 = _ActionURLsForSQLValue(v4);

  [v6 setActionInfo:v5];
}

void sub_1000341BC(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a2;
  -[PKDiscoveryEngagementMessage setStatus:](v4, "setStatus:", [a3 integerValue]);
}

void sub_100034214(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a2;
  -[PKDiscoveryEngagementMessage setViewCount:](v4, "setViewCount:", [a3 integerValue]);
}

void sub_10003426C(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a2;
  -[PKDiscoveryEngagementMessage setReportIdentifierToAggd:](v4, "setReportIdentifierToAggd:", [a3 BOOLValue]);
}

void sub_1000342C4(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a2;
  -[PKDiscoveryEngagementMessage setMaxViewCount:](v4, "setMaxViewCount:", [a3 integerValue]);
}

void sub_10003431C(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a2;
  -[PKDiscoveryEngagementMessage setType:](v4, "setType:", [a3 integerValue]);
}

void sub_100034374(id a1, PKDiscoveryEngagementMessage *a2, id a3)
{
  uint64_t v3 = a2;
  id v4 = (id)_HardwareVersionRangeForSQLValue();
  [(PKDiscoveryEngagementMessage *)v3 setHardwareVersionRange:v4];
}

void sub_1000348A4(id a1, DiscoveryEngagementMessage *a2, id a3)
{
  id v4 = a2;
  -[DiscoveryEngagementMessage setMessageOrder:](v4, "setMessageOrder:", [a3 integerValue]);
}

id sub_1000348FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[SQLiteEntity applyPropertySetters:*(void *)(a1 + 32) toObject:*(void *)(a1 + 40) withProperties:a2 values:a3];
}

void PDServerRun()
{
  v0 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "passd launch: starting...", buf, 2u);
  }

  uint64_t v1 = &dword_100000018;
  do
  {
    *(_DWORD *)((char *)qword_100808938 + v1) = 0;
    v1 += 40;
  }
  while (v1 != 464);
  PDXPCEventStreamRegisterForLaunchEvents();
  PDNFSecureXPCEventListenerCreate();
  id v2 = PKPassLibraryMachServiceName;
  if (qword_100808938[0]) {
    goto LABEL_25;
  }
  uint64_t v3 = v2;
  id v4 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v2];
  id v5 = (void *)qword_100808938[0];
  qword_100808938[0] = (uint64_t)v4;

  qword_100808940 = (uint64_t)sub_1000091D0;
  qword_100808948 = (uint64_t)sub_10000E548;

  id v6 = PKPaymentServiceMachServiceName;
  if (qword_100808960) {
    goto LABEL_25;
  }
  uint64_t v7 = v6;
  id v8 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v6];
  id v9 = (void *)qword_100808960;
  qword_100808960 = (uint64_t)v8;

  qword_100808968 = (uint64_t)sub_1000118C0;
  qword_100808970 = (uint64_t)sub_1000116A0;

  id v10 = PKInAppPaymentServiceMachServiceName;
  if (qword_100808988) {
    goto LABEL_25;
  }
  id v11 = v10;
  id v12 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v10];
  id v13 = (void *)qword_100808988;
  qword_100808988 = (uint64_t)v12;

  qword_100808990 = (uint64_t)sub_100034F7C;
  qword_100808998 = (uint64_t)sub_100034FFC;

  id v14 = PKContinuityPaymentServiceMachName;
  if (qword_1008089B0) {
    goto LABEL_25;
  }
  id v15 = v14;
  id v16 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v14];
  uint64_t v17 = (void *)qword_1008089B0;
  qword_1008089B0 = (uint64_t)v16;

  qword_1008089B8 = (uint64_t)sub_100035084;
  qword_1008089C0 = (uint64_t)sub_1000350F8;

  id v18 = PKTrustedDeviceEnrollmentInfoProviderServiceName;
  if (qword_1008089D8) {
    goto LABEL_25;
  }
  uint64_t v19 = v18;
  id v20 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v18];
  uint64_t v21 = (void *)qword_1008089D8;
  qword_1008089D8 = (uint64_t)v20;

  qword_1008089E0 = (uint64_t)sub_100035104;
  qword_1008089E8 = (uint64_t)sub_100035178;

  id v22 = PKPeerPaymentServiceMachServiceName;
  if (qword_100808A00) {
    goto LABEL_25;
  }
  long long v23 = v22;
  id v24 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v22];
  long long v25 = (void *)qword_100808A00;
  qword_100808A00 = (uint64_t)v24;

  qword_100808A08 = (uint64_t)sub_100008DCC;
  qword_100808A10 = (uint64_t)sub_10000AD78;

  id v26 = PKCloudStoreServiceMachServiceName;
  if (qword_100808A28) {
    goto LABEL_25;
  }
  CFStringRef v27 = v26;
  id v28 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v26];
  id v29 = (void *)qword_100808A28;
  qword_100808A28 = (uint64_t)v28;

  qword_100808A30 = (uint64_t)sub_100035184;
  qword_100808A38 = (uint64_t)sub_1000351F8;

  id v30 = PKDeviceRegistrationServiceMachServiceName;
  if (qword_100808A50) {
    goto LABEL_25;
  }
  uint64_t v31 = v30;
  id v32 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v30];
  uint64_t v33 = (void *)qword_100808A50;
  qword_100808A50 = (uint64_t)v32;

  qword_100808A58 = (uint64_t)sub_100035268;
  qword_100808A60 = (uint64_t)sub_1000352DC;

  id v34 = PKAccountServiceMachServiceName;
  if (qword_100808A78) {
    goto LABEL_25;
  }
  uint64_t v35 = v34;
  id v36 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v34];
  __int16 v37 = (void *)qword_100808A78;
  qword_100808A78 = (uint64_t)v36;

  qword_100808A80 = (uint64_t)sub_100008034;
  qword_100808A88 = (uint64_t)sub_100008734;

  id v38 = PKDiscoveryServiceMachServiceName;
  if (qword_100808AA0) {
    goto LABEL_25;
  }
  id v39 = v38;
  id v40 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v38];
  long long v41 = (void *)qword_100808AA0;
  qword_100808AA0 = (uint64_t)v40;

  qword_100808AA8 = (uint64_t)sub_1000087A4;
  qword_100808AB0 = (uint64_t)sub_1000086C4;

  id v42 = PKSearchServiceMachServiceName;
  if (qword_100808AC8)
  {
LABEL_25:
    __break(1u);
  }
  else
  {
    long long v43 = v42;
    id v44 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:v42];
    long long v45 = (void *)qword_100808AC8;
    qword_100808AC8 = (uint64_t)v44;

    qword_100808AD0 = (uint64_t)sub_1000352E8;
    qword_100808AD8 = (uint64_t)sub_10003535C;

    sub_1000AC3A4();
    long long v46 = sub_1000353E4([PDServer alloc]);
    long long v47 = (void *)qword_100808928;
    qword_100808928 = (uint64_t)v46;

    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v54 = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "passd launch: created PDServer.", v54, 2u);
    }

    for (uint64_t i = 0; i != 55; i += 5)
    {
      long long v49 = (void *)qword_100808938[i];
      if (v49)
      {
        uint64_t v50 = qword_100808928;
        id v51 = v49;
        [v51 setDelegate:v50];
        [v51 activate];
      }
    }
    sub_1000AC440((uint64_t)PDXPCListener_ApplicationAuthorization, (void *)qword_100808928);
    PDNFSecureXPCRegisterSecureElementEventObserver((void *)qword_100808928);
    PDXPCEventStreamBeginEventDelivery();
    PDNFSecureXPCEventListenerActivate();
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(DarwinNotifyCenter, (const void *)qword_100808928, (CFNotificationCallback)sub_1000354FC, FMDLostModeExitAuthCompleteNotification, 0, CFNotificationSuspensionBehaviorCoalesce);
    CFNotificationCenterPostNotification(DarwinNotifyCenter, PKServiceListenerResumedNotification, 0, 0, 0);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v53 = 0;
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "passd launch: finished.", v53, 2u);
    }
  }
}

PDInAppPaymentService *sub_100034F7C(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = [[PDInAppPaymentService alloc] initWithConnection:v3 server:v4];

  [(PDInAppPaymentService *)v5 setDelegate:v4];
  return v5;
}

void sub_100034FFC(void *a1, void *a2)
{
  uint64_t v3 = a1[12];
  id v6 = a2;
  id v4 = a1;
  [v6 setPaymentWebServiceCoordinator:v3];
  [v6 setIdsManager:v4[39]];
  [v6 setDatabaseManager:v4[6]];
  uint64_t v5 = v4[9];

  [v6 setSecureElement:v5];
}

PDContinuityPaymentService *sub_100035084(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDContinuityPaymentService alloc] initWithConnection:v3 server:v4];

  return v5;
}

id sub_1000350F8(uint64_t a1, void *a2)
{
  return [a2 setIdsManager:*(void *)(a1 + 312)];
}

PDTrustedDeviceEnrollmentInfoProvider *sub_100035104(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDTrustedDeviceEnrollmentInfoProvider alloc] initWithConnection:v3 server:v4];

  return v5;
}

id sub_100035178(uint64_t a1, void *a2)
{
  return [a2 setPaymentWebServiceCoordinator:*(void *)(a1 + 96)];
}

PDCloudStoreService *sub_100035184(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDCloudStoreService alloc] initWithConnection:v3 server:v4];

  return v5;
}

void sub_1000351F8(void *a1, void *a2)
{
  uint64_t v3 = a1[33];
  id v6 = a2;
  id v4 = a1;
  [v6 setCloudStoreNotificationCoordinator:v3];
  uint64_t v5 = v4[32];

  [v6 setTransactionSourceController:v5];
}

PDDeviceRegistrationService *sub_100035268(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDDeviceRegistrationService alloc] initWithConnection:v3 server:v4];

  return v5;
}

id sub_1000352DC(uint64_t a1, void *a2)
{
  return [a2 setDeviceRegistrationServiceCoordinator:*(void *)(a1 + 272)];
}

PDSearchService *sub_1000352E8(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  uint64_t v5 = [[PDSearchService alloc] initWithConnection:v3 server:v4];

  return v5;
}

void sub_10003535C(void *a1, void *a2)
{
  uint64_t v3 = a1[6];
  id v6 = a2;
  id v4 = a1;
  [v6 setDatabaseManager:v3];
  [v6 setAccountManager:v4[16]];
  [v6 setFamilyCircleManager:v4[54]];
  uint64_t v5 = v4[44];

  [v6 setIndexer:v5];
}

void *sub_1000353E4(void *a1)
{
  if (!a1) {
    return 0;
  }
  v13.receiver = a1;
  v13.super_class = (Class)PDServer;
  uint64_t v1 = objc_msgSendSuper2(&v13, "init");
  id v2 = v1;
  if (v1)
  {
    *((_DWORD *)v1 + 4) = 0;
    *((_DWORD *)v1 + 158) = 0;
    id v3 = objc_alloc_init((Class)NSMutableSet);
    id v4 = (void *)v2[63];
    v2[63] = v3;

    id v5 = sub_100035520([PDServerUnprotectedManagers alloc]);
    id v6 = (void *)v2[81];
    v2[81] = v5;

    sub_100035694((uint64_t)v2, 7);
    uint64_t v7 = (void *)v2[81];
    if (v7) {
      uint64_t v7 = (void *)v7[1];
    }
    id v8 = v7;
    sub_1001A5760((uint64_t)v8, v2);
    sub_1001A5428((uint64_t)v8);
    id v9 = (void *)v2[81];
    if (v9) {
      id v9 = (void *)v9[3];
    }
    id v10 = v9;
    [v10 registerConsumer:v2];
    [v10 start];

    id v11 = +[LSApplicationWorkspace defaultWorkspace];
    [v11 addObserver:v2];
  }
  return v2;
}

uint64_t sub_1000354FC()
{
  return PKSetNeedsLostModeExitAuth();
}

id sub_100035520(void *a1)
{
  if (!a1) {
    return 0;
  }
  v13.receiver = a1;
  v13.super_class = (Class)PDServerUnprotectedManagers;
  id v1 = objc_msgSendSuper2(&v13, "init");
  if (v1)
  {
    id v2 = sub_1001A5360([PDFieldDetectorManager alloc]);
    id v3 = (void *)*((void *)v1 + 1);
    *((void *)v1 + 1) = v2;

    id v4 = objc_alloc_init(PDAssertionManager);
    id v5 = (void *)*((void *)v1 + 2);
    *((void *)v1 + 2) = v4;

    id v6 = objc_alloc_init(PDNotificationStreamManager);
    uint64_t v7 = (void *)*((void *)v1 + 3);
    *((void *)v1 + 3) = v6;

    id v8 = sub_1002052A8((id *)[PDRemoteInterfacePresenter alloc], *((void **)v1 + 1), *((void **)v1 + 3), *((void **)v1 + 2));
    id v9 = (void *)*((void *)v1 + 4);
    *((void *)v1 + 4) = v8;

    uint64_t v10 = +[PKMobileAssetManager sharedInstance];
    id v11 = (void *)*((void *)v1 + 5);
    *((void *)v1 + 5) = v10;
  }
  return v1;
}

uint64_t sub_100035604(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

void sub_100035694(uint64_t a1, char a2)
{
  if (a1)
  {
    int v3 = atomic_load((unsigned __int8 *)(a1 + 8));
    if (v3 == 1)
    {
      id v4 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "passd initialization: Previously initialized ignoring request", buf, 2u);
      }
    }
    else
    {
      if (a2)
      {
        int v6 = PDProtectedDataAvailable();
        char v7 = 0;
        atomic_compare_exchange_strong((atomic_uchar *volatile)(a1 + 9), (unsigned __int8 *)&v7, v6);
        if (!v7)
        {
          BOOL v8 = v6;
          id v9 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            BOOL v235 = v8;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Updated file protection state : %d", buf, 8u);
          }
        }
      }
      if ((a2 & 2) != 0)
      {
        int v10 = atomic_load((unsigned __int8 *)(a1 + 9));
        if (v10 == 1)
        {
          unsigned int v11 = [(objc_class *)off_100803F78() hasStashedValuesOnDisk] ^ 1;
        }
        else
        {
          id v12 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Skipping icloud restore check as keybag is still locked", buf, 2u);
          }

          unsigned int v11 = 0;
        }
        char v13 = 0;
        atomic_compare_exchange_strong((atomic_uchar *volatile)(a1 + 10), (unsigned __int8 *)&v13, v11);
        if (!v13)
        {
          id v14 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            BOOL v235 = v11;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Updated icloud restore state : %d", buf, 8u);
          }
        }
      }
      int v15 = atomic_load((unsigned __int8 *)(a1 + 9));
      int v16 = atomic_load((unsigned __int8 *)(a1 + 10));
      uint64_t v17 = PKLogFacilityTypeGetObject();
      BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      if (v15 == 1 && v16 == 1)
      {
        if (v18)
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "passd initialization: criteria satisfied", buf, 2u);
        }

        uint64_t v19 = *(void **)(a1 + 648);
        if (v19) {
          uint64_t v19 = (void *)v19[1];
        }
        id v20 = v19;
        uint64_t v21 = *(void **)(a1 + 648);
        if (v21) {
          uint64_t v21 = (void *)v21[2];
        }
        id v22 = v21;
        long long v23 = *(void **)(a1 + 648);
        if (v23) {
          long long v23 = (void *)v23[3];
        }
        id v24 = v23;
        long long v25 = *(void **)(a1 + 648);
        if (v25) {
          long long v25 = (void *)v25[4];
        }
        id v26 = v25;
        _set_user_dir_suffix();
        CFStringRef v27 = PKHomeDirectoryPath();
        id v28 = [v27 stringByAppendingPathComponent:PDDatabaseName];
        v229 = +[NSURL fileURLWithPath:v28];

        v227 = v27;
        id v29 = [v27 stringByAppendingPathComponent:@"UserNotifications.archive"];
        uint64_t v30 = +[NSURL fileURLWithPath:v29];

        _VerifyOrCreateDirectoryStructure();
        _VerifyOrUpdateDirectoryFileProtection(0);
        int v31 = sub_100037330(a1);
        if (v31)
        {
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "passd: first unlocked initialization for boot.", buf, 2u);
          }
        }
        id v32 = objc_alloc_init((Class)PKUsageNotificationServer);
        uint64_t v33 = *(void **)(a1 + 304);
        *(void *)(a1 + 304) = v32;

        id v34 = objc_alloc_init(PDPushNotificationManager);
        uint64_t v35 = *(void **)(a1 + 64);
        *(void *)(a1 + 64) = v34;

        id v232 = [objc_alloc((Class)PKIDSService) initWithServiceName:@"com.apple.private.alloy.applepay.sharing"];
        id v36 = [objc_alloc((Class)PKSharingIDSManager) initWithIDSService:v232];
        __int16 v37 = *(void **)(a1 + 320);
        *(void *)(a1 + 320) = v36;

        [*(id *)(a1 + 320) addDelegate:a1];
        [*(id *)(a1 + 320) setDataSource:a1];
        id v38 = [[PDCardFileManager alloc] initWithDelegate:a1 cloudStoreCoordinatorDelegate:0];
        id v39 = *(void **)(a1 + 32);
        *(void *)(a1 + 32) = v38;

        *(_DWORD *)buf = 0;
        id v40 = [[PDDatabaseManager alloc] initWithURL:v229 delegate:a1 report:buf];
        long long v41 = *(void **)(a1 + 48);
        *(void *)(a1 + 48) = v40;

        int v224 = buf[0];
        if (buf[0])
        {
          if (buf[2])
          {
            if (buf[1]) {
              BOOL v42 = buf[3] == 0;
            }
            else {
              BOOL v42 = 1;
            }
          }
          else
          {
            BOOL v42 = 0;
          }
          *(unsigned char *)(a1 + 12) = v42;
        }
        else
        {
          *(unsigned char *)(a1 + 12) = 0;
          +[PDUbiquityManager removeLastEventIdentifier];
          BOOL v42 = 0;
        }
        uint64_t v43 = +[PKSecureElement sharedSecureElement];
        id v44 = *(void **)(a1 + 72);
        *(void *)(a1 + 72) = v43;

        [*(id *)(a1 + 32) setSecureElement:*(void *)(a1 + 72)];
        long long v45 = [[PDCloudStoreNotificationCoordinator alloc] initWithPushNotificationManager:*(void *)(a1 + 64) sharingIDSManger:*(void *)(a1 + 320) databaseManager:*(void *)(a1 + 48)];
        long long v46 = *(void **)(a1 + 264);
        *(void *)(a1 + 264) = v45;

        [*(id *)(a1 + 32) setCloudStoreCoordinatorDelegate:*(void *)(a1 + 264)];
        long long v47 = sub_1003A005C((uint64_t)PDApplicationMessageManager, *(void **)(a1 + 48), (void *)a1);
        long long v48 = *(void **)(a1 + 520);
        *(void *)(a1 + 520) = v47;

        id v49 = objc_alloc_init((Class)FDWalletMessagingProvider);
        uint64_t v50 = *(void **)(a1 + 536);
        *(void *)(a1 + 536) = v49;

        id v51 = [[PDBankConnectPushNotificationHandler alloc] initWithPushNotificationManager:*(void *)(a1 + 64)];
        id v52 = *(void **)(a1 + 544);
        *(void *)(a1 + 544) = v51;

        id v53 = objc_alloc_init(off_100803F80());
        id v54 = *(void **)(a1 + 552);
        *(void *)(a1 + 552) = v53;

        id v55 = objc_alloc_init((Class)PKPaymentHostEndpointRegistry);
        long long v56 = *(void **)(a1 + 280);
        *(void *)(a1 + 280) = v55;

        long long v57 = [[PDMapsBrandAndMerchantUpdater alloc] initWithDataSource:*(void *)(a1 + 48)];
        long long v58 = *(void **)(a1 + 408);
        *(void *)(a1 + 408) = v57;

        long long v59 = [[PDPayLaterMerchantProcessor alloc] initWithMapsBrandAndMerchantUpdater:*(void *)(a1 + 408) databaseManager:*(void *)(a1 + 48)];
        long long v60 = *(void **)(a1 + 416);
        *(void *)(a1 + 416) = v59;

        id v61 = objc_alloc_init((Class)PKIDSManager);
        long long v62 = *(void **)(a1 + 312);
        *(void *)(a1 + 312) = v61;

        sub_100210D90((uint64_t)v26, *(void **)(a1 + 48));
        char v225 = v31;
        long long v63 = sub_10018AE84([PDExpressPassManager alloc], *(void **)(a1 + 48), v22, *(void **)(a1 + 72), v26, v24, v31, v42);
        long long v64 = *(void **)(a1 + 336);
        *(void *)(a1 + 336) = v63;

        sub_100193A54(*(void *)(a1 + 336), (void *)a1);
        sub_100210E04((uint64_t)v26, *(void **)(a1 + 336));
        [*(id *)(a1 + 312) addDelegate:a1];
        [*(id *)(a1 + 312) setDataSource:a1];
        long long v65 = objc_alloc_init(PDFamilyCircleManager);
        long long v66 = *(void **)(a1 + 432);
        *(void *)(a1 + 432) = v65;

        long long v67 = [PDTransactionReceiptFileManager alloc];
        v68 = PKReceiptsDirectoryURL();
        v69 = [(PDTransactionReceiptFileManager *)v67 initWithDirectoryURL:v68 delegate:a1];
        v70 = *(void **)(a1 + 424);
        *(void *)(a1 + 424) = v69;

        v71 = [[PDPaymentWebServiceCoordinator alloc] initWithPushNotificationManager:*(void *)(a1 + 64) databaseManager:*(void *)(a1 + 48) passStore:*(void *)(a1 + 32) assertionManager:v22 cloudStoreCoordinator:*(void *)(a1 + 264) idsManager:*(void *)(a1 + 312) tapToRadarDelegate:a1 receiptFileManager:*(void *)(a1 + 424) expressPassManager:*(void *)(a1 + 336) familyCircleManager:*(void *)(a1 + 432)];
        v72 = *(void **)(a1 + 96);
        *(void *)(a1 + 96) = v71;

        [*(id *)(a1 + 96) setAssertionManager:v22];
        v73 = [PDPaymentTransactionProcessor alloc];
        v74 = PDDefaultQueue();
        v75 = [(PDPaymentTransactionProcessor *)v73 initWithQueue:v74 mapsBrandAndMerchantUpdater:*(void *)(a1 + 408) paymentWebServiceCoordinator:*(void *)(a1 + 96)];
        v76 = *(void **)(a1 + 80);
        *(void *)(a1 + 80) = v75;

        [*(id *)(a1 + 80) setUsageNotificationServer:*(void *)(a1 + 304)];
        [*(id *)(a1 + 80) registerObserver:a1];
        [*(id *)(a1 + 80) setDataSource:a1];
        v77 = [PDUserNotificationManager alloc];
        uint64_t v78 = *(void *)(a1 + 48);
        [*(id *)(a1 + 96) sharedWebService];
        v79 = v231 = v24;
        v226 = (void *)v30;
        v80 = [(PDUserNotificationManager *)v77 initWithArchiveFileURL:v30 databaseManager:v78 assertionManager:v22 paymentWebService:v79 paymentWebServiceCoordinator:*(void *)(a1 + 96) applicationMessageManager:*(void *)(a1 + 520) delegate:a1];
        v81 = *(void **)(a1 + 56);
        *(void *)(a1 + 56) = v80;

        [*(id *)(a1 + 96) setUserNotificationManager:*(void *)(a1 + 56)];
        v82 = [[PDPaymentUserCommunicationManager alloc] initWithNotificationManager:*(void *)(a1 + 56) paymentWebServiceCoordinator:*(void *)(a1 + 96) applicationMessageManager:*(void *)(a1 + 520)];
        v83 = *(void **)(a1 + 528);
        *(void *)(a1 + 528) = v82;

        v84 = [[PDTransitStateManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) expressPassManager:*(void *)(a1 + 336) secureElement:*(void *)(a1 + 72) transactionProcessor:*(void *)(a1 + 80) paymentWebServiceCoordinator:*(void *)(a1 + 96) delegate:a1];
        v85 = *(void **)(a1 + 344);
        *(void *)(a1 + 344) = v84;

        v86 = [[PDISO18013Manager alloc] initWithSecureElement:*(void *)(a1 + 72) userNotificationManager:*(void *)(a1 + 56)];
        v87 = *(void **)(a1 + 216);
        *(void *)(a1 + 216) = v86;

        v88 = [PDPeerPaymentWebServiceCoordinator alloc];
        uint64_t v89 = *(void *)(a1 + 64);
        v90 = [*(id *)(a1 + 96) sharedWebService];
        v91 = [(PDPeerPaymentWebServiceCoordinator *)v88 initWithPushNotificationManager:v89 paymentWebService:v90 assertionManager:v22 userNotificationManager:*(void *)(a1 + 56) sharingIDSManager:*(void *)(a1 + 320) familyCircleManager:*(void *)(a1 + 432) dataSource:*(void *)(a1 + 48) passStore:*(void *)(a1 + 32) tapToRadarDelegate:a1];
        v92 = *(void **)(a1 + 104);
        *(void *)(a1 + 104) = v91;

        [*(id *)(a1 + 104) registerObserver:a1];
        [*(id *)(a1 + 96) setPeerPaymentWebServiceCoordinator:*(void *)(a1 + 104)];
        [*(id *)(a1 + 96) setIsoManager:*(void *)(a1 + 216)];
        v93 = [[PDPeerPaymentAccountManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) cloudStoreNotificationCoordinator:*(void *)(a1 + 264) transactionProcessor:*(void *)(a1 + 80)];
        v94 = *(void **)(a1 + 112);
        *(void *)(a1 + 112) = v93;

        LOBYTE(v217) = v42;
        v95 = [[PDAccountManager alloc] initWithPushNotificationManager:*(void *)(a1 + 64) paymentWebServiceCoordinator:*(void *)(a1 + 96) databaseManager:*(void *)(a1 + 48) userNotificationManager:*(void *)(a1 + 56) payLaterMerchantProcessor:*(void *)(a1 + 416) cloudStoreNotificationCoordinator:*(void *)(a1 + 264) deviceEnvironmentStore:*(void *)(a1 + 176) databaseRecreated:v217];
        v96 = *(void **)(a1 + 128);
        *(void *)(a1 + 128) = v95;

        [*(id *)(a1 + 128) registerObserver:a1];
        [*(id *)(a1 + 96) setAccountManager:*(void *)(a1 + 128)];
        [*(id *)(a1 + 432) addObserver:*(void *)(a1 + 128)];
        v97 = [[PDPaymentOffersManager alloc] initWithPushNotificationManager:*(void *)(a1 + 64) paymentWebServiceCoordinator:*(void *)(a1 + 96) databaseManager:*(void *)(a1 + 48)];
        v98 = *(void **)(a1 + 184);
        *(void *)(a1 + 184) = v97;

        v99 = [[PDAccountNotificationController alloc] initWithAccountManager:*(void *)(a1 + 128) notificationStreamManager:v231 userNotificationManager:*(void *)(a1 + 56) databaseManager:*(void *)(a1 + 48) paymentWebServiceCoordinator:*(void *)(a1 + 96) peerPaymentWebServiceCoordinator:*(void *)(a1 + 104) familyMemberManager:*(void *)(a1 + 432)];
        v100 = *(void **)(a1 + 136);
        *(void *)(a1 + 136) = v99;

        [*(id *)(a1 + 128) setAccountNotificationController:*(void *)(a1 + 136)];
        v101 = [[PDAccountAdStatusChangesObserver alloc] initWithAccountManager:*(void *)(a1 + 128)];
        v102 = *(void **)(a1 + 144);
        *(void *)(a1 + 144) = v101;

        v103 = [[PDApplyManager alloc] initWithPushNotificationManager:*(void *)(a1 + 64) paymentWebServiceCoordinator:*(void *)(a1 + 96) databaseManager:*(void *)(a1 + 48) accountManager:*(void *)(a1 + 128) databaseRecreated:v42];
        v104 = *(void **)(a1 + 120);
        *(void *)(a1 + 120) = v103;

        [*(id *)(a1 + 96) setApplyManager:*(void *)(a1 + 120)];
        v105 = [[PDApplyNotificationController alloc] initWithApplyManager:*(void *)(a1 + 120) databaseManager:*(void *)(a1 + 48) familyMemberManager:*(void *)(a1 + 432) userNotificationManager:*(void *)(a1 + 56) paymentWebServiceCoordinator:*(void *)(a1 + 96)];
        v106 = *(void **)(a1 + 152);
        *(void *)(a1 + 152) = v105;

        [*(id *)(a1 + 120) setNotificationController:*(void *)(a1 + 152)];
        v107 = [[PDSpotlightIndexer alloc] initWithDatabaseManager:*(void *)(a1 + 48) transactionReceiptFileManager:*(void *)(a1 + 424) paymentWebServiceCoordinator:*(void *)(a1 + 96) peerPaymentWebServiceCoordinator:*(void *)(a1 + 104) databaseRecreated:v42];
        v108 = *(void **)(a1 + 352);
        *(void *)(a1 + 352) = v107;

        v222 = [[PDApplePayCloudStoreContainer alloc] initWithDataSource:*(void *)(a1 + 48) delegate:a1 transactionProcessor:*(void *)(a1 + 80) accountManager:*(void *)(a1 + 128) paymentWebServiceCoordinator:*(void *)(a1 + 96) peerPaymentWebServiceCoordinator:*(void *)(a1 + 104) familyCircleManager:*(void *)(a1 + 432) spotlightIndexer:*(void *)(a1 + 352) notificationStreamManager:v231];
        objc_msgSend(*(id *)(a1 + 264), "setApplePayContainer:");
        v221 = [[PDPassCloudStoreContainer alloc] initWithDataSource:*(void *)(a1 + 48)];
        objc_msgSend(*(id *)(a1 + 264), "setPassContainer:");
        if ([*(id *)(a1 + 48) shouldSyncTransactionsToCloudStore]) {
          [*(id *)(a1 + 264) scheduleTransactionDeviceDataSyncBackgroundActivityOriginatedOnDevice:1];
        }
        BOOL v223 = v42;
        [*(id *)(a1 + 264) schedulePassSyncBackgroundActivity];
        [*(id *)(a1 + 264) schedulePassChangesBackgroundActivity];
        v109 = [[PDCarKeyRequirementsChecker alloc] initWithWebServiceCoordinator:*(void *)(a1 + 96) databaseManager:*(void *)(a1 + 48)];
        v110 = *(void **)(a1 + 208);
        *(void *)(a1 + 208) = v109;

        id v111 = objc_alloc_init((Class)PKDAManager);
        v112 = [[PDAppletSubcredentialManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) cardFileManager:*(void *)(a1 + 32) paymentWebServiceCoordinator:*(void *)(a1 + 96) daManager:v111 carKeyRequirementsChecker:*(void *)(a1 + 208) secureElement:*(void *)(a1 + 72) assertionManager:v22 notificationManager:*(void *)(a1 + 56)];
        v113 = *(void **)(a1 + 192);
        *(void *)(a1 + 192) = v112;

        [*(id *)(a1 + 192) registerObserver:a1];
        [*(id *)(a1 + 96) setCredentialManager:*(void *)(a1 + 192)];
        v220 = v111;
        v114 = [[PDNFCInitiatedPairingManager alloc] initWithFieldDetectorManager:v20 daManager:v111 carKeyRequirementsChecker:*(void *)(a1 + 208) remoteInterfacePresenter:v26 assertionManager:v22];
        v115 = *(void **)(a1 + 200);
        *(void *)(a1 + 200) = v114;

        sub_100197C5C(*(void *)(a1 + 336), *(void **)(a1 + 200));
        v116 = [[PDAccountStatementMetadataProcessor alloc] initWithDatabaseManager:*(void *)(a1 + 48) accountManager:*(void *)(a1 + 128) cloudStoreNotificationCoordinator:*(void *)(a1 + 264)];
        v117 = *(void **)(a1 + 496);
        *(void *)(a1 + 496) = v116;

        v118 = [[PDDeviceRegistrationServiceCoordinator alloc] initWithPaymentWebServiceCoordinator:*(void *)(a1 + 96) peerPaymentWebServiceCoordinator:*(void *)(a1 + 104)];
        v119 = *(void **)(a1 + 272);
        *(void *)(a1 + 272) = v118;

        v120 = [[PDPushProvisioningManager alloc] initWithDataBaseManager:*(void *)(a1 + 48) cardFileManager:*(void *)(a1 + 32) userNotificationManager:*(void *)(a1 + 56) paymentWebServiceCoordinator:*(void *)(a1 + 96) familyCircleManager:*(void *)(a1 + 432) secureElement:*(void *)(a1 + 72) assertionManager:v22 deviceRegistrationServiceCoordinator:*(void *)(a1 + 272) notificationStreamManager:v231 pendingProvisioningManager:0];
        v121 = *(void **)(a1 + 224);
        *(void *)(a1 + 224) = v120;

        [*(id *)(a1 + 224) setCloudStoreCoordinator:*(void *)(a1 + 264)];
        [*(id *)(a1 + 96) setPushProvisioningManager:*(void *)(a1 + 224)];
        [*(id *)(a1 + 96) setDeviceRegistrationServiceCoordinator:*(void *)(a1 + 272)];
        [*(id *)(a1 + 48) setCloudStoreCoordinator:*(void *)(a1 + 264)];
        [*(id *)(a1 + 264) registerObserver:*(void *)(a1 + 104)];
        [*(id *)(a1 + 264) registerObserver:*(void *)(a1 + 128)];
        [*(id *)(a1 + 104) setCloudStoreNotificationCoordinator:*(void *)(a1 + 264)];
        [*(id *)(a1 + 104) setDeviceRegistrationCoordinator:*(void *)(a1 + 272)];
        v122 = [[PDNotificationServiceCoordinator alloc] initWithPushNotificationManager:*(void *)(a1 + 64) databaseManager:*(void *)(a1 + 48) userNotificationManager:*(void *)(a1 + 56) paymentTransactionProcessor:*(void *)(a1 + 80) paymentWebServiceCoordinator:*(void *)(a1 + 96)];
        v123 = *(void **)(a1 + 88);
        *(void *)(a1 + 88) = v122;

        v124 = [[PDWebServicesCoordinator alloc] initWithPushNotificationManager:*(void *)(a1 + 64) databaseManager:*(void *)(a1 + 48) cardFileManager:*(void *)(a1 + 32)];
        v125 = *(void **)(a1 + 288);
        *(void *)(a1 + 288) = v124;

        v126 = [[PDIssuerBindingManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) cardFileManager:*(void *)(a1 + 32) notificationMananger:*(void *)(a1 + 56) notificationStreamManager:v231 webServiceCoordinator:*(void *)(a1 + 288) paymentWebServiceCoordinator:*(void *)(a1 + 96) secureElement:*(void *)(a1 + 72)];
        v127 = *(void **)(a1 + 560);
        *(void *)(a1 + 560) = v126;

        [*(id *)(a1 + 560) registerObserver:a1];
        v128 = [[PDPassDynamicStateManager alloc] initWithDatabaseManager:*(void *)(a1 + 48)];
        v129 = *(void **)(a1 + 568);
        *(void *)(a1 + 568) = v128;

        [*(id *)(a1 + 568) setObserver:a1];
        v130 = [[PDPassLiveRenderManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) dynamicStateManager:*(void *)(a1 + 568)];
        v131 = *(void **)(a1 + 576);
        *(void *)(a1 + 576) = v130;

        v132 = [[PDRelevantPassProvider alloc] initWithDatabaseManager:*(void *)(a1 + 48) cardFileManager:*(void *)(a1 + 32) dynamicStateManager:*(void *)(a1 + 568) notificationManager:v231 delegate:a1];
        v133 = *(void **)(a1 + 328);
        *(void *)(a1 + 328) = v132;

        [*(id *)(a1 + 328) setRemoteInterfacePresenter:v26];
        v134 = [[PDMapsMerchantProcessingService alloc] initWithDatabaseManager:*(void *)(a1 + 48) transactionProcessor:*(void *)(a1 + 80) webServiceCoordinator:*(void *)(a1 + 96)];
        v135 = *(void **)(a1 + 400);
        *(void *)(a1 + 400) = v134;

        v228 = v20;
        v136 = [[PDDefaultPassManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) fieldDetectorManager:v20 remoteInterfacePresenter:v26 assertionManager:v22 delegate:a1];
        v137 = *(void **)(a1 + 360);
        *(void *)(a1 + 360) = v136;

        [*(id *)(a1 + 96) setDefaultPassManager:*(void *)(a1 + 360)];
        v138 = [PDDevicePasscodeManager alloc];
        v139 = [*(id *)(a1 + 96) sharedWebService];
        v140 = [(PDDevicePasscodeManager *)v138 initWithPaymentWebService:v139 databaseManager:*(void *)(a1 + 48) assertionManager:v22];
        v141 = *(void **)(a1 + 368);
        *(void *)(a1 + 368) = v140;

        [*(id *)(a1 + 96) setDevicePasscodeManager:*(void *)(a1 + 368)];
        v219 = [*(id *)(a1 + 96) sharedWebService];
        v142 = [[PDPassUpgradeController alloc] initWithWebService:v219 cardFileManager:*(void *)(a1 + 32)];
        v143 = *(void **)(a1 + 384);
        *(void *)(a1 + 384) = v142;

        v144 = [[PDExpressTransitUpgradeController alloc] initWithPaymentWebServiceCoordinator:*(void *)(a1 + 96) databaseManager:*(void *)(a1 + 48) expressPassManager:*(void *)(a1 + 336) notificationManager:*(void *)(a1 + 56) assertionManager:v22 passUpgradeController:*(void *)(a1 + 384)];
        v145 = *(void **)(a1 + 392);
        *(void *)(a1 + 392) = v144;

        v146 = [[PDTransitNotificationService alloc] initWithPaymentWebServiceCoordinator:*(void *)(a1 + 96) notificationManager:v231 userNotificationManager:*(void *)(a1 + 56) databaseManager:*(void *)(a1 + 48) expressPassManager:*(void *)(a1 + 336) upgradeController:*(void *)(a1 + 392)];
        v147 = *(void **)(a1 + 376);
        *(void *)(a1 + 376) = v146;

        v148 = [[PDDeviceEnvironmentStore alloc] initWithDatabaseManager:*(void *)(a1 + 48)];
        v149 = *(void **)(a1 + 176);
        *(void *)(a1 + 176) = v148;

        if ((PKIsPad() & 1) == 0)
        {
          v150 = [[PDRuleManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) accountManager:*(void *)(a1 + 128) applyManager:*(void *)(a1 + 120) peerPaymentWebServiceCoordinator:*(void *)(a1 + 104) paymentWebServiceCoordinator:*(void *)(a1 + 96) transitNotificationService:*(void *)(a1 + 376) familyCircleManager:*(void *)(a1 + 432) expressPassManager:*(void *)(a1 + 336)];
          v151 = *(void **)(a1 + 168);
          *(void *)(a1 + 168) = v150;

          v152 = [[PDDiscoveryManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) paymentWebServiceCoordinator:*(void *)(a1 + 96) ruleManager:*(void *)(a1 + 168) accountManager:*(void *)(a1 + 128) applyManager:*(void *)(a1 + 120) peerPaymentWebServiceCoordinator:*(void *)(a1 + 104) transitNotificationService:*(void *)(a1 + 376) userNotificationManager:*(void *)(a1 + 56) transactionProcessor:*(void *)(a1 + 80) pushNotificationManager:*(void *)(a1 + 64) notificationStreamManager:v231 deviceEnvironmentStore:*(void *)(a1 + 176) delegate:a1];
          v153 = *(void **)(a1 + 160);
          *(void *)(a1 + 160) = v152;

          [*(id *)(a1 + 168) setDiscoveryManager:*(void *)(a1 + 160)];
          [*(id *)(a1 + 96) setDiscoveryManager:*(void *)(a1 + 160)];
        }
        v154 = objc_alloc_init(PDBarcodeCertificateManager);
        v155 = [[PDAuxiliaryCapabilityManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) paymentWebServiceCoordinator:*(void *)(a1 + 96) secureElement:*(void *)(a1 + 72) pushNotificationManager:*(void *)(a1 + 64) iSO18013Manager:*(void *)(a1 + 216) barcodeCertManager:v154 subcredentialManager:*(void *)(a1 + 192)];
        v156 = *(void **)(a1 + 248);
        *(void *)(a1 + 248) = v155;

        [*(id *)(a1 + 96) setAuxiliaryCapabilityManager:*(void *)(a1 + 248)];
        v218 = v154;
        v157 = [[PDBarcodeCredentialManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) paymentWebServiceCoordinator:*(void *)(a1 + 96) pushNotificationManager:*(void *)(a1 + 64) barcodeCertManager:v154 auxiliaryCapabilityManager:*(void *)(a1 + 248)];
        v158 = *(void **)(a1 + 232);
        *(void *)(a1 + 232) = v157;

        [*(id *)(a1 + 248) addDelegate:*(void *)(a1 + 232)];
        v159 = [[PDTransactionAuthenticationManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) auxiliaryCapabilityManager:*(void *)(a1 + 232) notificationServiceCoordinator:*(void *)(a1 + 88) userNotificationManager:*(void *)(a1 + 56) transactionProcessor:*(void *)(a1 + 80) assertionManager:v22 pushNotificationManager:*(void *)(a1 + 64)];
        v160 = *(void **)(a1 + 240);
        *(void *)(a1 + 240) = v159;

        v161 = [[PDTransactionNotificationController alloc] initWithUserNotificationManager:*(void *)(a1 + 56) databaseManager:*(void *)(a1 + 48) accountManager:*(void *)(a1 + 128) peerPaymentWebServiceCoordinator:*(void *)(a1 + 104) familyCircleManager:*(void *)(a1 + 432)];
        v162 = *(void **)(a1 + 440);
        *(void *)(a1 + 440) = v161;

        v163 = sub_1003D5B70((id *)[PDPassTileManager alloc], *(void **)(a1 + 32), *(void **)(a1 + 48), (void *)a1);
        v164 = *(void **)(a1 + 448);
        *(void *)(a1 + 448) = v163;

        v165 = sub_100370BE4((id *)[PDVehicleFunctionsManager alloc], *(void **)(a1 + 48), *(void **)(a1 + 448));
        v166 = *(void **)(a1 + 456);
        *(void *)(a1 + 456) = v165;

        v167 = sub_1003D906C((id *)[PDBalanceManager alloc], *(void **)(a1 + 48), *(void **)(a1 + 448));
        v168 = *(void **)(a1 + 464);
        *(void *)(a1 + 464) = v167;

        [*(id *)(a1 + 88) setPassTileManager:*(void *)(a1 + 448)];
        v230 = v26;
        v169 = [[PDSharingManager alloc] initWithWebServiceCoordinator:*(void *)(a1 + 96) databaseManager:*(void *)(a1 + 48) notificationManager:*(void *)(a1 + 56) pushNotificationManager:*(void *)(a1 + 64) cardFileManager:*(void *)(a1 + 32) subcredentialManager:*(void *)(a1 + 192) applicationMessageManager:*(void *)(a1 + 520) remoteInterfacePresenter:v26 idsSharingService:v232 cloudStoreDelegate:*(void *)(a1 + 264) delegate:a1];
        v170 = *(void **)(a1 + 472);
        *(void *)(a1 + 472) = v169;

        v171 = [[PDAuxiliaryPassInformationManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) withMerchantUpdater:*(void *)(a1 + 408) userNotificationManager:*(void *)(a1 + 56)];
        v172 = *(void **)(a1 + 488);
        *(void *)(a1 + 488) = v171;

        v173 = [[PDCloudStoreTransactionSourceController alloc] initWithDatabaseManager:*(void *)(a1 + 48) accountManager:*(void *)(a1 + 128) peerPaymentWebServiceCoordinator:*(void *)(a1 + 104) cloudStoreNotificationCoordinator:*(void *)(a1 + 264)];
        v174 = *(void **)(a1 + 256);
        *(void *)(a1 + 256) = v173;

        [*(id *)(a1 + 96) setSharingManager:*(void *)(a1 + 472)];
        v175 = [[PDPassSignalManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) paymentWebServiceCoordinator:*(void *)(a1 + 96)];
        v176 = *(void **)(a1 + 624);
        *(void *)(a1 + 624) = v175;

        v177 = [PDPendingProvisioningManager alloc];
        uint64_t v178 = *(void *)(a1 + 48);
        uint64_t v179 = *(void *)(a1 + 520);
        uint64_t v180 = *(void *)(a1 + 208);
        uint64_t v182 = *(void *)(a1 + 96);
        uint64_t v181 = *(void *)(a1 + 104);
        uint64_t v183 = *(void *)(a1 + 264);
        v184 = [*(id *)(a1 + 472) channelManager];
        v185 = [(PDPendingProvisioningManager *)v177 initWithDatabaseManager:v178 applicationMessageManager:v179 webServiceCoordinator:v182 carKeyRequirementsChecker:v180 peerPaymentWebServiceCoordinator:v181 notificationStreamManager:v231 cloudStoreCoordinator:v183 sharingChannelManager:v184 notificationManager:*(void *)(a1 + 56)];
        v186 = *(void **)(a1 + 480);
        *(void *)(a1 + 480) = v185;

        [*(id *)(a1 + 480) setDelegate:a1];
        [*(id *)(a1 + 96) setPendingProvisioningManager:*(void *)(a1 + 480)];
        [*(id *)(a1 + 224) setPendingProvisioningManager:*(void *)(a1 + 480)];
        v187 = [PDProvisioningRequirementsChecker alloc];
        v188 = [*(id *)(a1 + 96) sharedWebService];
        v189 = [(PDProvisioningRequirementsChecker *)v187 initWithWebService:v188 cloudStoreCoordinator:*(void *)(a1 + 264)];
        v190 = *(void **)(a1 + 584);
        *(void *)(a1 + 584) = v189;

        [*(id *)(a1 + 96) setProvisioningRequirementsChecker:*(void *)(a1 + 584)];
        v191 = [[PDPassVerificationManager alloc] initWithDatabaseManager:*(void *)(a1 + 48) userNotificationManager:*(void *)(a1 + 56) webServiceCoordinator:*(void *)(a1 + 96) secureElement:*(void *)(a1 + 72)];
        v192 = *(void **)(a1 + 600);
        *(void *)(a1 + 600) = v191;

        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
        id v193 = objc_alloc((Class)NSMutableSet);
        v194 = [*(id *)(a1 + 32) passUniqueIDs];
        id v195 = [v193 initWithArray:v194];
        v196 = *(void **)(a1 + 24);
        *(void *)(a1 + 24) = v195;

        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 16));
        if (v223 || ([*(id *)(a1 + 48) verifyIntegrity] & 1) == 0)
        {
          v199 = PDDefaultQueue();
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_100037424;
          block[3] = &unk_10072E1E8;
          void block[4] = a1;
          dispatch_async(v199, block);

          char v198 = 0;
        }
        else
        {
          char v198 = 1;
        }
        [*(id *)(a1 + 328) startObservingEvents];
        [*(id *)(a1 + 360) setDelegate:a1];
        [*(id *)(a1 + 32) startObservingUbiquityEvents];
        [*(id *)(a1 + 64) connect];
        [v232 start];
        [*(id *)(a1 + 288) connect];
        sub_1003A0878(*(void *)(a1 + 520), 1, *(void **)(a1 + 536));
        sub_1003A0254(*(void *)(a1 + 520));
        [*(id *)(a1 + 88) connect];
        [*(id *)(a1 + 56) connect];
        sub_10020D720((uint64_t)v230);
        [*(id *)(a1 + 600) connect];
        if ((v198 & 1) == 0)
        {
          [*(id *)(a1 + 288) nukeTasks];
          [*(id *)(a1 + 88) nukeTasks];
          [*(id *)(a1 + 232) nukeTasks];
        }
        if (buf[0] && buf[1] == 2) {
          sub_10003742C(a1);
        }
        v200 = [PDPassSyncCloudStoreContainer alloc];
        v201 = +[PDCloudStoreContainerConfiguration passSyncConfigWithDataSource:*(void *)(a1 + 48)];
        v202 = [(PDPassSyncCloudStoreContainer *)v200 initWithConfiguration:v201];

        v203 = [PDPassSyncCloudStoreContainer alloc];
        v204 = +[PDCloudStoreContainerConfiguration passSyncSecureConfigWithDataSource:*(void *)(a1 + 48)];
        v205 = [(PDPassSyncCloudStoreContainer *)v203 initWithConfiguration:v204];

        v206 = [[PDCardCloudManager alloc] initWithContainer:v202];
        v207 = [[PDCardCloudManager alloc] initWithContainer:v205];
        v208 = [[PDCardCloudManagerChangeRegistry alloc] initWithDatabaseManager:*(void *)(a1 + 48)];
        v209 = [[PDCloudSyncCoordinator alloc] initWithChangeRegistry:v208 databaseManager:*(void *)(a1 + 48) cardFileManager:*(void *)(a1 + 32) cloudStoreManager:v206 secureCloudStoreManager:v207];
        v210 = *(void **)(a1 + 40);
        *(void *)(a1 + 40) = v209;

        [*(id *)(a1 + 264) setPassSyncContainer:v202];
        [*(id *)(a1 + 264) setPassSyncSecureContainer:v205];
        if (!v224) {
          [*(id *)(a1 + 32) startUbiquity];
        }
        if ((PDHasRegisteredCarKeySiriVocabulary() & 1) == 0) {
          PDRegisterCarKeySiriVocabulary(*(void **)(a1 + 48), 0);
        }
        sub_10018BC44(*(void *)(a1 + 336));
        sub_1000374EC(a1);
        sub_100037554(a1);
        [*(id *)(a1 + 104) updateSharedCache];
        if (PKWalletFinanceKitTransactionsV2Enabled())
        {
          v211 = [[PDFinanceSyncManager alloc] initWithDatabaseManager:*(void *)(a1 + 48)];
          v212 = *(void **)(a1 + 592);
          *(void *)(a1 + 592) = v211;

          [*(id *)(a1 + 592) setNeedsSync];
        }
        if (PKBankCredentialCenterEnabled())
        {
          v213 = [[PDBankCredentialMigrator alloc] initWithAccountManager:*(void *)(a1 + 128)];
          v214 = *(void **)(a1 + 608);
          *(void *)(a1 + 608) = v213;

          [*(id *)(a1 + 608) migrateIfNecessary];
        }
        v215 = objc_alloc_init(PDAppProtectionManager);
        v216 = *(void **)(a1 + 616);
        *(void *)(a1 + 616) = v215;

        atomic_store(1u, (unsigned __int8 *)(a1 + 8));
        sub_1000376F4((id *)a1, v225);
      }
      else
      {
        if (v18)
        {
          *(_DWORD *)buf = 67109632;
          BOOL v235 = v16 == 1;
          __int16 v236 = 1024;
          BOOL v237 = v15 == 1;
          __int16 v238 = 1024;
          int v239 = 1;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "passd initialization: waiting for: iCloud restore complete: %d & File protection enabled: %d & Hardware check: %d", buf, 0x14u);
        }

        atomic_store(0, (unsigned __int8 *)(a1 + 8));
      }
    }
  }
}

void _VerifyOrCreateDirectoryStructure()
{
  id v1 = +[NSFileManager defaultManager];
  v0 = PKHomeDirectoryPath();
  [v1 createDirectoryAtPath:v0 withIntermediateDirectories:1 attributes:0 error:0];
}

void _VerifyOrUpdateDirectoryFileProtection(int a1)
{
  if (PDProtectedDataAvailable())
  {
    id v2 = +[NSFileManager defaultManager];
    int v3 = PKHomeDirectoryPath();
    if (![v2 fileExistsAtPath:v3])
    {
LABEL_33:

      goto LABEL_37;
    }
    id v4 = +[NSURL fileURLWithPath:v3];
    id v5 = [v4 URLByResolvingSymlinksInPath];

    if (a1)
    {
      id v6 = 0;
    }
    else
    {
      NSURLResourceKey v48 = NSURLFileProtectionKey;
      id v26 = +[NSArray arrayWithObjects:&v48 count:1];
      id v42 = 0;
      CFStringRef v27 = [v5 resourceValuesForKeys:v26 error:&v42];
      id v6 = v42;

      if (!v27)
      {
        BOOL v8 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          sub_100514A84((uint64_t)v6, v8);
        }
        goto LABEL_31;
      }
      id v28 = [v27 objectForKeyedSubscript:NSURLFileProtectionKey];
      if (v28)
      {
        id v29 = v28;
        unsigned int v30 = [v28 isEqualToString:NSURLFileProtectionNone];

        if (!v30) {
          goto LABEL_32;
        }
      }
      else
      {
      }
    }
    id v32 = v3;
    char v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      sub_100514A50();
    }
    oslog = v7;

    NSURLResourceKey v46 = NSURLFileProtectionKey;
    NSURLFileProtectionType v47 = NSURLFileProtectionCompleteUntilFirstUserAuthentication;
    BOOL v8 = +[NSDictionary dictionaryWithObjects:&v47 forKeys:&v46 count:1];
    id v9 = [v8 allKeys];
    uint64_t v33 = v2;
    int v31 = v5;
    int v10 = [v2 enumeratorAtURL:v5 includingPropertiesForKeys:v9 options:0 errorHandler:0];
    long long v38 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    id v11 = [v10 countByEnumeratingWithState:&v38 objects:v45 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v39;
      do
      {
        for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v39 != v13) {
            objc_enumerationMutation(v10);
          }
          int v15 = *(void **)(*((void *)&v38 + 1) + 8 * i);

          id v37 = 0;
          int v16 = [v15 resourceValuesForKeys:v9 error:&v37];
          id v17 = v37;
          int v18 = PKEqualObjects();

          id v6 = 0;
          if (v18) {
            BOOL v19 = v17 == 0;
          }
          else {
            BOOL v19 = 0;
          }
          if (!v19)
          {

            id v36 = 0;
            unsigned int v20 = [v15 setResourceValues:v8 error:&v36];
            id v21 = v36;
            id v6 = 0;
            if (!v20 || v21 != 0)
            {
              id v23 = v21;
              if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                id v44 = v15;
                _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "PDServer: failed to update data protection for %@.", buf, 0xCu);
              }

              id v6 = v23;
            }
          }
        }
        id v12 = [v10 countByEnumeratingWithState:&v38 objects:v45 count:16];
      }
      while (v12);
    }

    id v35 = 0;
    id v5 = v31;
    unsigned int v24 = [v31 setResourceValues:v8 error:&v35];
    id v25 = v35;
    id v6 = v25;
    if (!v24 || v25)
    {
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        id v44 = v31;
        _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "PDServer: failed to update data protection for %@.", buf, 0xCu);
      }
    }
    int v3 = v32;
    id v2 = v33;
LABEL_31:

LABEL_32:
    goto LABEL_33;
  }
  if (!a1) {
    return;
  }
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
    sub_100514AFC();
  }
LABEL_37:
}

uint64_t sub_100037330(uint64_t result)
{
  if (result)
  {
    id v1 = sem_open("passd-work.boot", 2560, 256, 0);
    if (v1 == (sem_t *)-1)
    {
      if (*__error() != 17)
      {
        id v2 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          int v3 = __error();
          id v4 = strerror(*v3);
          *(_DWORD *)buf = 136446210;
          id v6 = v4;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "passd: error: unable to create first launch semaphore - %{public}s.", buf, 0xCu);
        }
      }
      return 0;
    }
    else
    {
      sem_close(v1);
      return 1;
    }
  }
  return result;
}

id sub_100037424(uint64_t a1)
{
  return [*(id *)(a1 + 32) handleDatabaseIntegrityProblem];
}

void sub_10003742C(uint64_t a1)
{
  if (a1 && os_variant_has_internal_ui())
  {
    id v2 = [(PDGenericUserNotification *)[PDWalletUserNotification alloc] initWithTitle:@"Database Removed [Internal]" message:@"Do not file radar, known issue. The Wallet database was removed because its version was not recognized. Some of your settings and data may have been reset."];
    [*(id *)(a1 + 56) insertUserNotification:v2];
    int v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Presented internal-only database removed (version was not recognized) banner.", v4, 2u);
    }
  }
}

uint64_t sub_1000374EC(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!*(void *)(result + 512))
    {
      id v2 = [[PDXPCEventPublisher alloc] initWithStreamName:@"com.apple.passd.matching"];
      uint64_t v3 = *(void *)(v1 + 512);
      *(void *)(v1 + 512) = v2;
      return _objc_release_x1(v2, v3);
    }
  }
  return result;
}

void sub_100037554(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = 0;
    char v3 = 0;
    while (2)
    {
      id v4 = &qword_100808938[5 * v2++];
      id v5 = (id *)(v4 + 4);
      while (1)
      {
        os_unfair_lock_lock((os_unfair_lock_t)v5 - 2);
        if (*(v5 - 2))
        {
          if (*v5 && [*v5 count]) {
            break;
          }
        }
        os_unfair_lock_unlock((os_unfair_lock_t)v5 - 2);
        ++v2;
        v5 += 5;
        if (v2 == 12)
        {
          if ((v3 & 1) == 0) {
            return;
          }
          goto LABEL_19;
        }
      }
      long long v13 = 0u;
      long long v14 = 0u;
      long long v11 = 0u;
      long long v12 = 0u;
      id v6 = *v5;
      id v7 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
      if (v7)
      {
        id v8 = v7;
        uint64_t v9 = *(void *)v12;
        do
        {
          for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v12 != v9) {
              objc_enumerationMutation(v6);
            }
            ((void (*)(uint64_t, void))*(v5 - 2))(a1, *(void *)(*((void *)&v11 + 1) + 8 * i));
          }
          id v8 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
        }
        while (v8);
      }

      os_unfair_lock_unlock((os_unfair_lock_t)v5 - 2);
      char v3 = 1;
      if (v2 != 11) {
        continue;
      }
      break;
    }
LABEL_19:
    PKAnalyticsSendEvent();
  }
}

id *sub_1000376F4(id *result, char a2)
{
  if (result)
  {
    uint64_t v2 = result;
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_100037900;
    v5[3] = &unk_10072F078;
    char v6 = a2;
    v5[4] = result;
    sub_100037830(v5);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_100037E60;
    v4[3] = &unk_10072E1E8;
    v4[4] = v2;
    sub_100037830(v4);
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_10003844C;
    v3[3] = &unk_10072E4F8;
    v3[4] = v2;
    sub_1000388F4((uint64_t)v2, 0, v3);
    [v2[59] start];
    [v2[22] start];
    return sub_100038D54(v2);
  }
  return result;
}

void sub_100037830(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)PDOSTransactionCreate("PDServer.utility");
  char v3 = PDUtilityQueue();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10004C6A0;
  v6[3] = &unk_10072FDC8;
  id v7 = v2;
  id v8 = v1;
  id v4 = v1;
  id v5 = v2;
  dispatch_async(v3, v6);
}

uint64_t sub_100037900(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40)) {
    sub_1000379AC(*(void *)(a1 + 32));
  }
  if (PKSecureElementIsAvailable() || PKIsHandoffClient())
  {
    uint64_t v2 = *(void *)(a1 + 32);
    char v3 = *(void **)(v2 + 96);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_100037B74;
    v5[3] = &unk_10072E1E8;
    v5[4] = v2;
    [v3 updateWebServiceConfigurationWithCompletion:v5];
  }
  sub_100037DA8(*(void *)(a1 + 32));
  return PDEnableAutomaticInternalLogging();
}

void sub_1000379AC(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Performing post-boot work", buf, 2u);
    }

    char v3 = (void *)PDOSTransactionCreate("PDServer.first_boot");
    if (+[PKSecureElement isInFailForward])
    {
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Secure element in fail-forward", buf, 2u);
      }

      if (off_100803F98())
      {
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Buddy is currently runningfail forward notification will be picked up afterwards", buf, 2u);
        }
      }
      else
      {
        sub_100046BF8(a1);
      }
    }
    if (PKNearFieldLowPowerSupportIsAvailable())
    {
      [*(id *)(a1 + 344) updateAllExpressTransitAppletStates];
      uint64_t v4 = *(void *)(a1 + 336);
      id v5 = _NSConcreteStackBlock;
      uint64_t v6 = 3221225472;
      id v7 = sub_10004B738;
      id v8 = &unk_10072FC70;
      id v9 = v3;
      uint64_t v10 = a1;
      sub_10018E790(v4, &v5);
    }
    objc_msgSend(*(id *)(a1 + 368), "performUpgradedPasscodeEnforcementUpdateAfterBoot", v5, v6, v7, v8);
    +[PKWalletVisibility updateWalletVisibility];
    sub_100370CF0(*(void *)(a1 + 456));
  }
}

void sub_100037B74(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 96) startTasksIfNecessary];
  [*(id *)(*(void *)(a1 + 32) + 400) start];
  [*(id *)(*(void *)(a1 + 32) + 376) start];
  sub_100037BD4(*(void *)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100037CC4(v2);
}

void sub_100037BD4(uint64_t a1)
{
  if (a1)
  {
    id v11 = [*(id *)(a1 + 96) sharedWebService];
    uint64_t v2 = [v11 context];
    char v3 = [v2 configuration];

    uint64_t v4 = [v11 targetDevice];
    id v5 = [v4 deviceRegion];
    [v3 dynamicAssetPrefetchTimeIntervalForRegion:v5];
    double v7 = v6;

    id v8 = *(void **)(a1 + 648);
    if (v8) {
      id v8 = (void *)v8[5];
    }
    id v9 = v8;
    uint64_t v10 = PDUtilityQueue();
    [v9 schedulePrefetchDynamicAssetsWithInterval:v10 queue:v7];
  }
}

void sub_100037CC4(uint64_t a1)
{
  if (a1)
  {
    id v10 = [*(id *)(a1 + 96) sharedWebService];
    uint64_t v2 = [v10 context];
    char v3 = [v2 configuration];

    uint64_t v4 = [v10 targetDevice];
    id v5 = [v4 deviceRegion];
    [v3 paymentSetupFeaturesCacheUpdateIntervalForRegion:v5];
    double v7 = v6;

    id v8 = [*(id *)(a1 + 96) paymentSetupFeaturesCoordinator];
    id v9 = v8;
    if (v7 <= 0.0) {
      [v8 unscheduleStaticPaymentSetupFeaturesCacheUpdate];
    }
    else {
      [v8 scheduleStaticPaymentSetupFeaturesCacheUpdateWithInterval:v7];
    }
  }
}

void sub_100037DA8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = PDLastLogDateDefault;
    if (sub_10004B550(a1, PDLastLogDateDefault) > 86400.0)
    {
      sub_10004B614(a1);
      id v4 = +[NSUserDefaults standardUserDefaults];
      char v3 = +[NSDate date];
      [v4 setObject:v3 forKey:v2];
    }
  }
}

void sub_100037E60(uint64_t a1)
{
  if ((PKStoreDemoModeEnabled() & 1) != 0 || PKUIOnlyDemoModeEnabled())
  {
    sub_100037FCC(*(id **)(a1 + 32));
    if (PKGenerateStoreDemoTransactionsDaily())
    {
      uint64_t v2 = PKLastGeneratedStoreDemoTransactionsDate();
      char v3 = v2;
      if (!v2
        || ([v2 timeIntervalSinceNow],
            double v5 = v4,
            +[NSDate date],
            double v6 = objc_claimAutoreleasedReturnValue(),
            id v7 = [v6 compare:v3],
            v6,
            v7 == (id)-1)
        || fabs(v5 / 3600.0) >= 18.0)
      {
        id v8 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 138412290;
          id v11 = v3;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Regenerating demo transactions. Last generation date: %@", (uint8_t *)&v10, 0xCu);
        }

        [*(id *)(*(void *)(a1 + 32) + 48) generateDemoTransactionsForAllPaymentPasses];
        id v9 = +[NSDate date];
        PKSetLastGeneratedStoreDemoTransactionsDate();
      }
    }
  }
}

void sub_100037FCC(id *a1)
{
  if (!a1 || (PKStoreDemoModeEnabled() & 1) == 0 && !PKUIOnlyDemoModeEnabled()) {
    return;
  }
  uint64_t v2 = [a1 catalogOfRecord];
  [v2 groups];
  v40 = long long v39 = a1;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  char v3 = [a1[6] passesOfType:1];
  id v4 = [v3 countByEnumeratingWithState:&v51 objects:v56 count:16];
  if (!v4)
  {
    double v6 = 0;
    id v7 = 0;
    goto LABEL_20;
  }
  id v5 = v4;
  double v6 = 0;
  id v7 = 0;
  uint64_t v8 = *(void *)v52;
  do
  {
    for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v52 != v8) {
        objc_enumerationMutation(v3);
      }
      int v10 = [*(id *)(*((void *)&v51 + 1) + 8 * i) paymentPass];
      if ([v10 hasAssociatedPeerPaymentAccount])
      {
        uint64_t v11 = [v10 uniqueID];
        long long v12 = v7;
        id v7 = (void *)v11;
LABEL_13:

        goto LABEL_14;
      }
      long long v13 = [v10 associatedAccountServiceAccountIdentifier];

      if (v13)
      {
        uint64_t v14 = [v10 uniqueID];
        long long v12 = v6;
        double v6 = (void *)v14;
        goto LABEL_13;
      }
LABEL_14:

      if (v7 && v6) {
        goto LABEL_20;
      }
    }
    id v5 = [v3 countByEnumeratingWithState:&v51 objects:v56 count:16];
  }
  while (v5);
LABEL_20:
  id v42 = v6;
  uint64_t v43 = v7;

  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v41 = v2;
  int v15 = [v2 groups];
  id v16 = [v15 countByEnumeratingWithState:&v47 objects:v55 count:16];
  if (v16)
  {
    id v17 = v16;
    int v18 = 0;
    BOOL v19 = 0;
    uint64_t v20 = *(void *)v48;
    while (1)
    {
      for (uint64_t j = 0; j != v17; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v48 != v20) {
          objc_enumerationMutation(v15);
        }
        id v22 = *(void **)(*((void *)&v47 + 1) + 8 * (void)j);
        if ([v22 isUbiquitous]) {
          continue;
        }
        id v23 = [v22 uniqueIDs];
        unsigned __int8 v24 = [v23 containsObject:v43];

        if (v24)
        {
          id v25 = v19;
          id v26 = v18;
          CFStringRef v27 = v22;
LABEL_29:
          id v30 = v22;

          int v18 = v26;
          goto LABEL_30;
        }
        CFStringRef v27 = v19;
        id v28 = [v22 uniqueIDs];
        unsigned int v29 = [v28 containsObject:v42];

        id v25 = v18;
        id v26 = v22;
        if (v29) {
          goto LABEL_29;
        }
LABEL_30:
        BOOL v19 = v27;
        if (v27 && v18) {
          goto LABEL_36;
        }
      }
      id v17 = [v15 countByEnumeratingWithState:&v47 objects:v55 count:16];
      if (!v17) {
        goto LABEL_36;
      }
    }
  }
  int v18 = 0;
  BOOL v19 = 0;
LABEL_36:

  v45[0] = _NSConcreteStackBlock;
  v45[1] = 3221225472;
  v45[2] = sub_10004BDF8;
  v45[3] = &unk_10072FD60;
  id v31 = v40;
  id v46 = v31;
  id v32 = objc_retainBlock(v45);
  uint64_t v33 = (char *)[v31 count];
  id v34 = v33 - 1;
  if (v43 && v42)
  {
    id v35 = v33;
    id v36 = v42;
    ((void (*)(void *, char *, void *))v32[2])(v32, v34, v18);
    ((void (*)(void *, char *, void *))v32[2])(v32, v35 - 2, v19);
    id v37 = v39;
  }
  else
  {
    id v37 = v39;
    if (v42)
    {
      id v36 = v42;
      ((void (*)(void *, char *, void *))v32[2])(v32, v34, v18);
    }
    else if (v43)
    {
      id v36 = v43;
      ((void (*)(void *, char *, void *))v32[2])(v32, v34, v19);
    }
    else
    {
      id v36 = 0;
    }
  }
  long long v38 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Updating store demo pass order.", buf, 2u);
  }

  [v37[45] updateDefaultPaymentPassIdentifier:v36];
  [v37[4] writeCatalogOfRecord:v41 source:4];
}

void sub_10003844C(uint64_t a1)
{
  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_1000384BC;
  v1[3] = &unk_10072E1E8;
  v1[4] = *(void *)(a1 + 32);
  sub_100037830(v1);
}

id sub_1000384BC(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 56) updateDeviceAssessmentEducationVisibility];
  [*(id *)(*(void *)(a1 + 32) + 56) updateWalletBadgeCount];
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 648);
  if (v2) {
    char v3 = *(void **)(v2 + 24);
  }
  else {
    char v3 = 0;
  }
  [v3 recalculateNotificationNames];
  [*(id *)(*(void *)(a1 + 32) + 360) updateContactlessPassesAvailability];
  [*(id *)(*(void *)(a1 + 32) + 360) updateDefaultPaymentPassIfNeeded];
  [*(id *)(*(void *)(a1 + 32) + 560) scheduleVerifyAllIssuerBoundPassesActivity];
  sub_1000385D8(*(void *)(a1 + 32));
  if ([*(id *)(*(void *)(a1 + 32) + 48) passExistsWithPassType:1])
  {
    [*(id *)(*(void *)(a1 + 32) + 96) connect];
    [*(id *)(*(void *)(a1 + 32) + 96) scheduleConsistencyCheckIfNecessary];
  }
  id v4 = +[PEPServiceConfiguration sharedInstance];
  [v4 registerNetworkDefaultsForAppID:@"com.apple.passd"];

  id v5 = +[NSNotificationCenter defaultCenter];
  [v5 addObserver:*(void *)(a1 + 32) selector:"_updateQuickActions" name:PDPreferencesChangedNotification object:0];

  double v6 = *(void **)(a1 + 32);
  return [v6 _updateQuickActions];
}

void sub_1000385D8(uint64_t a1)
{
  if (a1)
  {
    int v1 = PKAccessPassVisibilityEnabled();
    int v2 = PDMigratedAvailableWhileLocked();
    char v3 = +[MCProfileConnection sharedConnection];
    uint64_t v4 = MCFeatureCardsWhileLockedAllowed;
    unsigned int v5 = [v3 effectiveBoolValueForSetting:MCFeatureCardsWhileLockedAllowed];

    double v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v7 = @"N";
      if (v1) {
        CFStringRef v8 = @"Y";
      }
      else {
        CFStringRef v8 = @"N";
      }
      if (v2) {
        CFStringRef v9 = @"Y";
      }
      else {
        CFStringRef v9 = @"N";
      }
      int v22 = 138412802;
      CFStringRef v23 = v8;
      __int16 v24 = 2112;
      CFStringRef v25 = v9;
      if (v5 == 1) {
        CFStringRef v7 = @"Y";
      }
      __int16 v26 = 2112;
      CFStringRef v27 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Migrating AvailableWhileLocked: featureEnabled: %@ hasMigrated: %@ current: %@", (uint8_t *)&v22, 0x20u);
    }

    int v10 = v2 ^ 1;
    if (((v1 ^ 1) & 1) != 0 || v10)
    {
      if ((v1 ^ 1 | v2))
      {
        if ((v1 | v10))
        {
          int IsAvailable = PKUserIntentIsAvailable();
          int v12 = PDSanitizedAvailableWhileLocked();
          if (IsAvailable)
          {
            if ((v12 & 1) == 0)
            {
              long long v13 = +[MCProfileConnection sharedConnection];
              [v13 setBoolValue:1 forSetting:v4];

              PDSetSanitizedAvailableWhileLocked();
            }
            if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_36;
            }
            LOWORD(v22) = 0;
            uint64_t v14 = "Migrating AvailableWhileLocked: (Old) sanitizing";
          }
          else
          {
            if (v12) {
              PDSetSanitizedAvailableWhileLocked();
            }
            if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_36;
            }
            LOWORD(v22) = 0;
            uint64_t v14 = "Migrating AvailableWhileLocked: (Old) resetting sanitization";
          }
          uint64_t v20 = v6;
          uint32_t v21 = 2;
          goto LABEL_35;
        }
        uint64_t locked = PDAvailableWhileLockedPreviousSetting();
        int v18 = +[MCProfileConnection sharedConnection];
        [v18 setBoolValue:locked forSetting:v4];

        PDSetMigratedAvailableWhileLocked();
        PDSetSanitizedAvailableWhileLocked();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v19 = @"N";
          if (locked) {
            CFStringRef v19 = @"Y";
          }
          int v22 = 138412290;
          CFStringRef v23 = v19;
          uint64_t v14 = "Migrating AvailableWhileLocked: (New -> Old) previous: %@";
LABEL_29:
          uint64_t v20 = v6;
          uint32_t v21 = 12;
LABEL_35:
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v22, v21);
        }
      }
      else
      {
        PDSetAvailableWhileLockedPreviousSetting();
        int v15 = +[MCProfileConnection sharedConnection];
        [v15 setBoolValue:0 forSetting:v4];

        PDSetMigratedAvailableWhileLocked();
        PDSetSanitizedAvailableWhileLocked();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v16 = @"N";
          if (v5 == 1) {
            CFStringRef v16 = @"Y";
          }
          int v22 = 138412290;
          CFStringRef v23 = v16;
          uint64_t v14 = "Migrating AvailableWhileLocked: (Old -> New) current: %@";
          goto LABEL_29;
        }
      }
LABEL_36:
    }
  }
}

void sub_1000388F4(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    if (!PKSecureElementIsAvailable()) {
      goto LABEL_12;
    }
    if (PDProtectedDataAvailable())
    {
      if ((PKUIOnlyDemoModeEnabled() & 1) != 0
        || (PKStoreDemoModeEnabled() & 1) != 0
        || PKHandsOnDemoModeEnabled())
      {
        [*(id *)(a1 + 48) passExistsWithPassType:1];
LABEL_8:
        double v6 = PKLogFacilityTypeGetObject();
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
LABEL_11:

LABEL_12:
          if (!v5) {
            goto LABEL_18;
          }
          goto LABEL_17;
        }
        *(_WORD *)buf = 0;
        CFStringRef v7 = "Skipping Secure Element Access Policy validation - in demo mode.";
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 2u);
        goto LABEL_11;
      }
      char v9 = PKPPTTestingEnabled();
      unsigned int v10 = [*(id *)(a1 + 48) passExistsWithPassType:1];
      if (v9) {
        goto LABEL_8;
      }
      unsigned int v11 = v10;
      int v12 = [*(id *)(a1 + 96) sharedWebService];
      long long v13 = [v12 context];
      unsigned int v14 = [v13 isRegistered] | v11;

      double v6 = PKLogFacilityTypeGetObject();
      BOOL v15 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
      if (v14 != 1)
      {
        if (!v15) {
          goto LABEL_11;
        }
        *(_WORD *)buf = 0;
        CFStringRef v7 = "Skipping Secure Element Access Policy validation.";
        goto LABEL_10;
      }
      if (v15)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Validating Secure Element access policies...", buf, 2u);
      }

      v42[0] = _NSConcreteStackBlock;
      v42[1] = 3221225472;
      v42[2] = sub_10004A9D0;
      v42[3] = &unk_10072FB30;
      v42[4] = a1;
      id v16 = v5;
      id v43 = v16;
      id v17 = objc_retainBlock(v42);
      int v18 = PKPasscodeEnabled();
      int v19 = PKAutomaticLoginEnabled();
      if (!v18)
      {
        uint64_t v20 = (void (*)(void *, uint64_t, void))v17[2];
        uint32_t v21 = v17;
        uint64_t v22 = 1;
        goto LABEL_29;
      }
      if (v19)
      {
        uint64_t v20 = (void (*)(void *, uint64_t, void))v17[2];
        uint32_t v21 = v17;
        uint64_t v22 = 3;
LABEL_29:
        v20(v21, v22, 0);
LABEL_43:

        goto LABEL_18;
      }
      CFStringRef v23 = *(void **)(a1 + 72);
      if (v23) {
        unint64_t v24 = (unint64_t)[v23 ownershipStateForCurrentUser];
      }
      else {
        unint64_t v24 = 3;
      }
      if (v11)
      {
        if (v24 <= 7)
        {
          if (((1 << v24) & 0xB2) != 0)
          {
            ((void (*)(void *, uint64_t, unint64_t))v17[2])(v17, 2, v24);
            goto LABEL_43;
          }
          if (((1 << v24) & 0xD) == 0)
          {
            id v35 = _NSConcreteStackBlock;
            uint64_t v36 = 3221225472;
            id v37 = sub_10004AD0C;
            long long v38 = &unk_10072FB80;
            long long v39 = v17;
            uint64_t v41 = 6;
            id v40 = v16;
            PKRootVolumeIsBootVolume();

            __int16 v26 = v39;
            goto LABEL_42;
          }
          goto LABEL_41;
        }
      }
      else if (v24 <= 3 && v24 != 1)
      {
LABEL_41:
        CFStringRef v27 = *(void **)(a1 + 72);
        v30[0] = _NSConcreteStackBlock;
        v30[1] = 3221225472;
        v30[2] = sub_10004AE94;
        v30[3] = &unk_10072FBD0;
        id v31 = v16;
        id v32 = v17;
        uint64_t v33 = a2;
        unint64_t v34 = v24;
        [v27 pairingStateWithCompletion:v30];

        __int16 v26 = v31;
        goto LABEL_42;
      }
      CFStringRef v25 = PDDefaultQueue();
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472;
      v28[2] = sub_10004B0FC;
      v28[3] = &unk_10072F788;
      id v29 = v16;
      dispatch_async(v25, v28);

      __int16 v26 = v29;
LABEL_42:

      goto LABEL_43;
    }
    CFStringRef v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cannot validate Secure Element access policies - data unavailable. Deferring...", buf, 2u);
    }

    if (v5) {
LABEL_17:
    }
      (*((void (**)(id, uint64_t))v5 + 2))(v5, 1);
  }
LABEL_18:
}

id *sub_100038D54(id *result)
{
  if (result)
  {
    id v1 = [result[6] countPassesPreventingWalletDeletion];
    if (v1) {
      uint64_t v2 = 2;
    }
    else {
      uint64_t v2 = 1;
    }
    return (id *)+[IXAppInstallCoordinator setRemovability:forAppWithBundleID:completion:](IXAppInstallCoordinator, "setRemovability:forAppWithBundleID:completion:", _NSConcreteStackBlock, 3221225472, sub_10004101C, &unk_10072F460, v2, v1);
  }
  return result;
}

void sub_100038EAC(uint64_t a1)
{
}

void sub_100038EB8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  char v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    int v4 = *(unsigned __int8 *)(a1 + 40);
    v5[0] = 67109632;
    v5[1] = v4;
    __int16 v6 = 2048;
    id v7 = WeakRetained;
    __int16 v8 = 1024;
    unsigned int v9 = [WeakRetained processIdentifier];
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "PDXPCServiceListener %u (%p:%d): connection interrupted", (uint8_t *)v5, 0x18u);
  }

  +[NSException raise:NSInternalInconsistencyException format:@"Unexpected interruption on connection"];
}

void sub_100039CA0(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (a1)
  {
    if (!v3) {
      __break(1u);
    }
    id v5 = PDDefaultQueue();
    PDWakePassbookInBackground();

    __int16 v6 = sub_10004960C(a1);
    if ([v6 count])
    {
      id v7 = [*(id *)(a1 + 48) effectiveCatalog];
      __int16 v8 = *(void **)(a1 + 568);
      unsigned int v9 = [v4 uniqueID];
      unsigned int v10 = [v8 passDynamicStateForUniqueIdentifier:v9];

      int v19 = _NSConcreteStackBlock;
      uint64_t v20 = 3221225472;
      uint32_t v21 = sub_10004969C;
      uint64_t v22 = &unk_10072F960;
      id v23 = v4;
      id v24 = v10;
      id v25 = v7;
      id v11 = v7;
      id v12 = v10;
      long long v13 = objc_retainBlock(&v19);
      sub_100049380(a1, v13, v6);
    }
    unsigned int v14 = +[NSDistributedNotificationCenter defaultCenter];
    uint64_t v15 = PKPassLibraryDidUpdatePassNotification;
    uint64_t v26 = PKPassLibraryUniqueIDUserInfoKey;
    id v16 = [v4 uniqueID];
    CFStringRef v27 = v16;
    id v17 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
    [v14 postNotificationName:v15 object:0 userInfo:v17];

    xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v18, "Name", (const char *)[PKPassLibraryDidChangeNotification UTF8String]);
    [*(id *)(a1 + 512) sendEvent:v18];
  }
}

id sub_100039EFC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    id v4 = (id)TCCAccessCopyInformationForBundleId();
    id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      uint64_t v6 = *(void *)v13;
      while (2)
      {
        for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v13 != v6) {
            objc_enumerationMutation(v4);
          }
          __int16 v8 = *(void **)(*((void *)&v12 + 1) + 8 * i);
          unsigned int v9 = objc_msgSend(v8, "objectForKeyedSubscript:", kTCCInfoService, (void)v12);
          if ([v9 isEqualToString:v3])
          {
            id v5 = [v8 objectForKeyedSubscript:kTCCInfoGranted];

            goto LABEL_12;
          }
        }
        id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }
LABEL_12:

    id v10 = [v5 BOOLValue];
  }
  else
  {
    id v10 = 0;
  }

  return v10;
}

void sub_10003A080(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (a1)
  {
    if (!v7) {
      __break(1u);
    }
    unsigned int v9 = PDDefaultQueue();
    PDWakePassbookInBackground();

    id v10 = sub_10004960C(a1);
    if ([v10 count])
    {
      id v11 = [*(id *)(a1 + 48) effectiveCatalog];
      uint32_t v21 = _NSConcreteStackBlock;
      uint64_t v22 = 3221225472;
      id v23 = sub_10004968C;
      id v24 = &unk_10072F960;
      id v25 = v7;
      id v26 = v8;
      id v27 = v11;
      id v12 = v11;
      long long v13 = objc_retainBlock(&v21);
      sub_100049380(a1, v13, v10);
    }
    long long v14 = *(void **)(a1 + 104);
    long long v15 = objc_msgSend(v7, "uniqueID", v21, v22, v23, v24);
    [v14 handlePassLibraryChangedWithPassUniqueIdentifier:v15];

    id v16 = +[NSDistributedNotificationCenter defaultCenter];
    v28[0] = PKPassLibraryUniqueIDUserInfoKey;
    id v17 = [v7 uniqueID];
    v29[0] = v17;
    v28[1] = PKPassLibraryPassSourceUserInfoKey;
    xpc_object_t v18 = +[NSNumber numberWithInteger:a4];
    v29[1] = v18;
    int v19 = +[NSDictionary dictionaryWithObjects:v29 forKeys:v28 count:2];

    [v16 postNotificationName:PKPassLibraryDidAddPassNotification object:0 userInfo:v19];
    xpc_object_t v20 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v20, "Name", (const char *)[PKPassLibraryDidChangeNotification UTF8String]);
    [*(id *)(a1 + 512) sendEvent:v20];
  }
}

void sub_10003A30C(id a1, NSError *a2)
{
  id v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "PDServer: Finished pass signal donation with error: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_10003A3B4(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    sub_1000385D8(*(void *)(a1 + 40));
    id v2 = [*(id *)(a1 + 32) associatedAccountFeatureIdentifier];
    uint64_t v4 = *(void *)(a1 + 56);
    uint64_t v3 = *(void *)(a1 + 64);
    if (v2 == (id)2 && v4 != v3)
    {
      uint64_t v6 = v3 == 1 ? @"Pass Personalized" : @"Pass Lost";
      BOOL v7 = v4 == 7 || v3 == 7;
      if (v7 || v3 == 1) {
        +[PKHomeScreenWidgetController reloadWidget:PKHomeScreenWidgetKindAppleCard budgeted:0 reason:v6];
      }
    }
    if ([*(id *)(*(void *)(a1 + 40) + 480) isTrackingProvisioningOfPass:*(void *)(a1 + 32)])
    {
      unsigned int v9 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Skipping state change notification because active provisioning in progress", buf, 2u);
      }
    }
    else
    {
      sub_10003A5A4(*(void *)(a1 + 40), *(void **)(a1 + 32), *(void *)(a1 + 56), *(void *)(a1 + 64));
    }
    [*(id *)(*(void *)(a1 + 40) + 480) passAddedOrUpdated:*(void *)(a1 + 32)];
    sub_10003A660(*(void *)(a1 + 40), *(void **)(a1 + 32));
    sub_100038D54(*(id **)(a1 + 40));
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 72);
    BOOL v11 = v10 == 5 || v10 == 3;
    if (v11
      && *(void *)(a1 + 80) == 2
      && [*(id *)(a1 + 48) hasValidNFCPayload]
      && [*(id *)(a1 + 48) isValid])
    {
      id v12 = [*(id *)(a1 + 48) uniqueID];
      long long v13 = [*(id *)(*(void *)(a1 + 40) + 48) objectSettingsManager];
      BOOL v14 = sub_10045B584((uint64_t)v13, v12);

      if (!v14)
      {
        long long v15 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)id v16 = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "A new NFC pass was added with no pass settings. Adding default settings.", v16, 2u);
        }

        [*(id *)(*(void *)(a1 + 40) + 48) updateSettings:19 forPassWithUniqueIdentifier:v12];
      }
    }
  }
}

void sub_10003A5A4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = v7;
  if (a1)
  {
    unsigned int v9 = *(void **)(a1 + 96);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_1000448B8;
    v10[3] = &unk_10072F5C8;
    void v10[4] = a1;
    id v11 = v7;
    uint64_t v12 = a3;
    uint64_t v13 = a4;
    [v9 performHandlerOnSharedWebServiceQueue:v10];
  }
}

void sub_10003A660(uint64_t a1, void *a2)
{
  id v30 = a2;
  if (a1)
  {
    uint64_t v3 = [v30 transitCommutePlans];
    if ([v3 count])
    {
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      id v4 = v3;
      id v5 = [v4 countByEnumeratingWithState:&v31 objects:v39 count:16];
      if (!v5) {
        goto LABEL_30;
      }
      id v6 = v5;
      id v26 = v3;
      uint64_t v7 = *(void *)v32;
      uint64_t v27 = a1;
      id v28 = v4;
      while (1)
      {
        id v8 = 0;
        id v29 = v6;
        do
        {
          if (*(void *)v32 != v7) {
            objc_enumerationMutation(v4);
          }
          unsigned int v9 = *(void **)(*((void *)&v31 + 1) + 8 * (void)v8);
          if (((unint64_t)[v9 properties] & 3) == 1)
          {
            id v10 = v4;
            id v11 = [v30 uniqueID];
            uint64_t v12 = a1;
            uint64_t v13 = *(void **)(a1 + 48);
            BOOL v14 = [v9 identifier];
            long long v15 = [v13 commutePlanReminderForCommutePlanIdentifier:v14 withPassUniqueIdentifier:v11];

            id v16 = [v9 expiryDate];
            [v15 timeInterval];
            if (!v16 || v17 == 0.0)
            {
              uint64_t v22 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412546;
                uint64_t v36 = v15;
                __int16 v37 = 2112;
                long long v38 = v16;
                _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Remove PDUserNotificationTypePassCommutePlanRenewalReminder for reminder: %@, expirationDate: %@", buf, 0x16u);
              }

              a1 = v12;
              [*(id *)(v12 + 56) removeUserNotificationsForPassUniqueIdentifier:v11 ofType:8];
              id v6 = v29;
              id v4 = v10;
            }
            else
            {
              xpc_object_t v18 = [v16 dateByAddingTimeInterval:-v17];
              int v19 = +[NSDate date];
              id v20 = [v19 compare:v18];

              if (v20 == (id)-1)
              {
                uint32_t v21 = [[PDPassCommutePlanRenewalReminderUserNotification alloc] initWithPaymentPass:v30 commutePlan:v9];
                if (!v21) {
                  goto LABEL_21;
                }
                id v23 = PKLogFacilityTypeGetObject();
                id v6 = v29;
                if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138412546;
                  uint64_t v36 = v15;
                  __int16 v37 = 2112;
                  long long v38 = v16;
                  _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Insert PDUserNotificationTypePassCommutePlanRenewalReminder for reminder: %@, expirationDate: %@", buf, 0x16u);
                }

                [(PDUserNotification *)v21 setDate:v18];
                a1 = v27;
                [*(id *)(v27 + 56) insertUserNotification:v21];
                id v4 = v28;
              }
              else
              {
                PKLogFacilityTypeGetObject();
                uint32_t v21 = (PDPassCommutePlanRenewalReminderUserNotification *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(&v21->super.super.super, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138412546;
                  uint64_t v36 = v15;
                  __int16 v37 = 2112;
                  long long v38 = v16;
                  _os_log_impl((void *)&_mh_execute_header, &v21->super.super.super, OS_LOG_TYPE_DEFAULT, "PDUserNotificationTypePassCommutePlanRenewalReminder not added for reminder: %@, expirationDate: %@", buf, 0x16u);
                }
LABEL_21:
                a1 = v27;
                id v4 = v28;
                id v6 = v29;
              }
            }
          }
          id v8 = (char *)v8 + 1;
        }
        while (v6 != v8);
        id v6 = [v4 countByEnumeratingWithState:&v31 objects:v39 count:16];
        if (!v6)
        {
          uint64_t v3 = v26;
          goto LABEL_30;
        }
      }
    }
    id v24 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Remove PDUserNotificationTypePassCommutePlanRenewalReminder because there is no commute plan", buf, 2u);
    }

    id v25 = *(void **)(a1 + 56);
    id v4 = [v30 uniqueID];
    [v25 removeUserNotificationsForPassUniqueIdentifier:v4 ofType:8];
LABEL_30:
  }
}

void sub_10003B05C(id a1, NSError *a2)
{
  uint64_t v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "PDServer: Finished pass signal donation with error: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_10003B104(id a1)
{
}

void sub_10003B128(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (a1)
  {
    if (!v3) {
      __break(1u);
    }
    id v5 = PDDefaultQueue();
    PDWakePassbookInBackground();

    id v6 = sub_10004960C(a1);
    if ([v6 count])
    {
      uint64_t v7 = [*(id *)(a1 + 48) effectiveCatalog];
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472;
      v17[2] = sub_1000496B8;
      v17[3] = &unk_10072F988;
      id v18 = v4;
      id v19 = v7;
      id v8 = v7;
      unsigned int v9 = objc_retainBlock(v17);
      sub_100049380(a1, v9, v6);
    }
    id v10 = *(void **)(a1 + 104);
    id v11 = [v4 uniqueID];
    [v10 handlePassLibraryChangedWithPassUniqueIdentifier:v11];

    uint64_t v12 = +[NSDistributedNotificationCenter defaultCenter];
    uint64_t v13 = PKPassLibraryDidRemovePassNotification;
    uint64_t v20 = PKPassLibraryUniqueIDUserInfoKey;
    BOOL v14 = [v4 uniqueID];
    uint32_t v21 = v14;
    long long v15 = +[NSDictionary dictionaryWithObjects:&v21 forKeys:&v20 count:1];
    [v12 postNotificationName:v13 object:0 userInfo:v15];

    xpc_object_t v16 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v16, "Name", (const char *)[PKPassLibraryDidChangeNotification UTF8String]);
    [*(id *)(a1 + 512) sendEvent:v16];
  }
}

void sub_10003B364(id a1, BOOL a2)
{
  if (!a2)
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Failed to update upgrade passcode policy for pass deletation", v3, 2u);
    }
  }
}

void sub_10003B4D4(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (a1 && *(id *)(a1 + 296) != v4)
  {
    id v9 = v4;
    objc_storeStrong((id *)(a1 + 296), a2);
    id v5 = [*(id *)(a1 + 48) effectiveCatalog];
    id v6 = *(void **)(a1 + 48);
    uint64_t v7 = sub_10003C63C((id *)a1);
    [v6 applyCatalogOfRecord:v7];

    id v8 = [*(id *)(a1 + 48) effectiveCatalog];
    if (([v5 isEquivalentToCatalog:v8] & 1) == 0)
    {
      sub_1000496D4(a1, v8);
      -[PDExpressPassManager secureElementExpressConfigurationNeedsUpdate]_0(*(void *)(a1 + 336));
    }

    id v4 = v9;
  }
}

BOOL sub_10003BACC(uint64_t a1)
{
  if (a1)
  {
    long long v51 = (void *)PDOSTransactionCreate("PDServer");
    uint64_t v86 = 0;
    v87 = &v86;
    uint64_t v88 = 0x2020000000;
    char v89 = 1;
    v85[0] = _NSConcreteStackBlock;
    v85[1] = 3221225472;
    v85[2] = sub_10004A718;
    v85[3] = &unk_10072FAC8;
    v85[5] = &v86;
    uint64_t v56 = a1;
    v85[4] = a1;
    long long v57 = objc_retainBlock(v85);
    id v83 = 0;
    id v84 = 0;
    [*(id *)(a1 + 48) computeExtraneousUniqueIDs:&v84 missingUniqueIDs:&v83];
    long long v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    long long v80 = 0u;
    id v2 = v84;
    id v3 = [v2 countByEnumeratingWithState:&v79 objects:v97 count:16];
    if (v3)
    {
      uint64_t v4 = *(void *)v80;
      while (2)
      {
        for (uint64_t i = 0; i != v3; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v80 != v4) {
            objc_enumerationMutation(v2);
          }
          uint64_t v6 = *(void *)(*((void *)&v79 + 1) + 8 * i);
          ((void (*)(void))v57[2])();
          int v8 = *((unsigned __int8 *)v87 + 24);
          if (*((unsigned char *)v87 + 24))
          {
            id v9 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              *(void *)&uint8_t buf[4] = v6;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Database contained extraneous (or duplicate) Unique Identifier: %@", buf, 0xCu);
            }

            [*(id *)(v56 + 48) prepareToDeletePassWithUniqueIdentifier:v6];
            [*(id *)(v56 + 48) deletePassWithUniqueIdentifier:v6];
          }
          if (!v8)
          {

            BOOL v30 = 0;
            goto LABEL_97;
          }
        }
        id v3 = [v2 countByEnumeratingWithState:&v79 objects:v97 count:16];
        if (v3) {
          continue;
        }
        break;
      }
      BOOL v90 = 0;
    }

    long long v77 = 0u;
    long long v78 = 0u;
    long long v75 = 0u;
    long long v76 = 0u;
    id obj = v83;
    id v10 = [obj countByEnumeratingWithState:&v75 objects:v95 count:16];
    if (v10)
    {
      uint64_t v53 = *(void *)v76;
      while (2)
      {
        id v11 = 0;
        id v54 = v10;
        do
        {
          if (*(void *)v76 != v53) {
            objc_enumerationMutation(obj);
          }
          uint64_t v12 = *(void *)(*((void *)&v75 + 1) + 8 * (void)v11);
          ((void (*)(void))v57[2])();
          if (*((unsigned char *)v87 + 24))
          {
            uint64_t v13 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              *(void *)&uint8_t buf[4] = v12;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Database was missing uniqueID: %@", buf, 0xCu);
            }

            BOOL v14 = [*(id *)(v56 + 32) objectWithUniqueID:v12];
            if ([v14 passType] == (id)1) {
              long long v15 = v14;
            }
            else {
              long long v15 = 0;
            }
            id v16 = v15;
            double v17 = [*(id *)(v56 + 32) passDaemonDataForUniqueID:v12];
            if ([*(id *)(v56 + 48) insertPass:v14 withDaemonData:v17 source:0])
            {
              if (v16)
              {
                id v18 = [*(id *)(v56 + 72) secureElementIdentifiers];
                [v16 updateDevicePaymentApplicationsWithSecureElementIdentifiers:v18];

                long long v73 = 0u;
                long long v74 = 0u;
                long long v71 = 0u;
                long long v72 = 0u;
                id v19 = [v16 devicePaymentApplications];
                id v20 = [v19 countByEnumeratingWithState:&v71 objects:v94 count:16];
                if (v20)
                {
                  id v21 = 0;
                  uint64_t v22 = *(void *)v72;
                  do
                  {
                    for (uint64_t j = 0; j != v20; uint64_t j = (char *)j + 1)
                    {
                      if (*(void *)v72 != v22) {
                        objc_enumerationMutation(v19);
                      }
                      id v24 = [*(id *)(*((void *)&v71 + 1) + 8 * (void)j) subcredentials];
                      id v25 = v24;
                      if (v24)
                      {
                        if (v21) {
                          [v21 unionSet:v24];
                        }
                        else {
                          id v21 = [v24 mutableCopy];
                        }
                      }
                    }
                    id v20 = [v19 countByEnumeratingWithState:&v71 objects:v94 count:16];
                  }
                  while (v20);

                  if (v21) {
                    [*(id *)(v56 + 192) restoreSubcredentialsInDatabase:v21 withCompletion:0];
                  }
                }
                else
                {

                  id v21 = 0;
                }
              }
              int v26 = 0;
            }
            else
            {
              int v26 = 7;
            }
          }
          else
          {
            BOOL v90 = 0;
            int v26 = 1;
          }
          if (v26 != 7 && v26)
          {

            BOOL v30 = v90;
            goto LABEL_97;
          }
          id v11 = (char *)v11 + 1;
        }
        while (v11 != v54);
        id v10 = [obj countByEnumeratingWithState:&v75 objects:v95 count:16];
        if (v10) {
          continue;
        }
        break;
      }
    }

    *(void *)buf = 0;
    id v70 = 0;
    [*(id *)(v56 + 48) computeTransactionReceiptExtraneousUniqueIDs:buf missingUniqueIDs:buf removedUniqueIDs:&v70];
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    id v27 = v70;
    id v28 = [v27 countByEnumeratingWithState:&v66 objects:v93 count:16];
    if (v28)
    {
      uint64_t v29 = *(void *)v67;
      BOOL v30 = v90;
      while (2)
      {
        for (k = 0; k != v28; k = (char *)k + 1)
        {
          if (*(void *)v67 != v29) {
            objc_enumerationMutation(v27);
          }
          uint64_t v32 = *(void *)(*((void *)&v66 + 1) + 8 * (void)k);
          ((void (*)(void))v57[2])();
          int v34 = *((unsigned __int8 *)v87 + 24);
          if (*((unsigned char *)v87 + 24)) {
            [*(id *)(v56 + 424) deleteTransactionReceiptWithUniqueID:v32];
          }
          else {
            BOOL v30 = 0;
          }
          if (!v34)
          {

            goto LABEL_96;
          }
        }
        id v28 = [v27 countByEnumeratingWithState:&v66 objects:v93 count:16];
        if (v28) {
          continue;
        }
        break;
      }
      BOOL v90 = v30;
    }

    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    id v35 = *(id *)buf;
    id v36 = [v35 countByEnumeratingWithState:&v62 objects:v92 count:16];
    if (v36)
    {
      uint64_t v37 = *(void *)v63;
      BOOL v30 = v90;
      while (2)
      {
        for (m = 0; m != v36; m = (char *)m + 1)
        {
          if (*(void *)v63 != v37) {
            objc_enumerationMutation(v35);
          }
          uint64_t v39 = *(void *)(*((void *)&v62 + 1) + 8 * (void)m);
          ((void (*)(void))v57[2])();
          int v41 = *((unsigned __int8 *)v87 + 24);
          if (*((unsigned char *)v87 + 24)) {
            [*(id *)(v56 + 48) deleteTransactionReceiptWithUniqueID:v39];
          }
          else {
            BOOL v30 = 0;
          }
          if (!v41)
          {

            goto LABEL_96;
          }
        }
        id v36 = [v35 countByEnumeratingWithState:&v62 objects:v92 count:16];
        if (v36) {
          continue;
        }
        break;
      }
      BOOL v90 = v30;
    }

    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    id v42 = [0 countByEnumeratingWithState:&v58 objects:v91 count:16];
    if (v42)
    {
      uint64_t v43 = *(void *)v59;
      BOOL v30 = v90;
LABEL_77:
      uint64_t v44 = 0;
      while (1)
      {
        if (*(void *)v59 != v43) {
          objc_enumerationMutation(0);
        }
        uint64_t v45 = *(void *)(*((void *)&v58 + 1) + 8 * v44);
        ((void (*)(void))v57[2])();
        int v47 = *((unsigned __int8 *)v87 + 24);
        if (*((unsigned char *)v87 + 24))
        {
          long long v48 = [*(id *)(v56 + 424) transactionReceiptWithUniqueID:v45];
          if (v48) {
            id v49 = [*(id *)(v56 + 48) insertOrUpdateTransactionReceipt:v48];
          }
        }
        else
        {
          BOOL v30 = 0;
        }
        if (!v47) {
          break;
        }
        if (v42 == (id)++v44)
        {
          id v42 = [0 countByEnumeratingWithState:&v58 objects:v91 count:16];
          if (v42) {
            goto LABEL_77;
          }
          goto LABEL_88;
        }
      }
    }
    else
    {
LABEL_88:
      ((void (*)(void))v57[2])();
      if (*((unsigned char *)v87 + 24))
      {
        sub_10004424C(v56);
        [*(id *)(v56 + 32) scheduleImmediateRevocationCheck];
        if (*(unsigned char *)(v56 + 12))
        {
          *(unsigned char *)(v56 + 12) = 0;
          sub_10018BF44(*(void *)(v56 + 336));
          [*(id *)(v56 + 128) databaseRestored];
          [*(id *)(v56 + 120) databaseRestored];
          [*(id *)(v56 + 352) databaseRestored];
        }
      }
      BOOL v30 = *((unsigned char *)v87 + 24) != 0;
    }
LABEL_96:

LABEL_97:
    _Block_object_dispose(&v86, 8);
  }
  else
  {
    return 0;
  }
  return v30;
}

void sub_10003C3A4(_Unwind_Exception *a1)
{
}

uint64_t sub_10003C4DC(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 48) passWithUniqueIdentifier:*(void *)(a1 + 40)];
  id v3 = v2;
  if (v2)
  {
    id v5 = v2;
    sub_100039CA0(*(void *)(a1 + 32), v2);
    id v3 = v5;
  }
  return _objc_release_x1(v2, v3);
}

id *sub_10003C63C(id *a1)
{
  if (a1)
  {
    id v2 = a1;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10004A76C;
    block[3] = &unk_10072E1E8;
    void block[4] = a1;
    if (qword_100808930 != -1) {
      dispatch_once(&qword_100808930, block);
    }
    a1 = (id *)v2[37];
    uint64_t v1 = block[8];
  }
  return a1;
}

void sub_10003C6EC(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    uint64_t v7 = (void *)PDOSTransactionCreate("PDServer.installmentUpdates");
    objc_initWeak(&location, a1);
    int v8 = PDHeavyQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000498B0;
    block[3] = &unk_10072F9D0;
    id v11 = v7;
    id v9 = v7;
    objc_copyWeak(&v14, &location);
    id v12 = v5;
    id v13 = v6;
    dispatch_async(v8, block);

    objc_destroyWeak(&v14);
    objc_destroyWeak(&location);
  }
}

void sub_10003C818(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 56));
  _Unwind_Resume(a1);
}

BOOL sub_10003CC10(uint64_t a1, void *a2)
{
  id v3 = [a2 secureElementIdentifier];
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  BOOL v6 = !v5 && [v4 indexOfObject:v3] != (id)0x7FFFFFFFFFFFFFFFLL;

  return v6;
}

void sub_10003CC74(uint64_t a1, void *a2)
{
  if (a2) {
    sub_10003C6EC(*(void **)(a1 + 32), a2, 0);
  }
}

void sub_10003CC88(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    int v7 = PKBankConnectEnabled();
    if (v6)
    {
      if (v5 && v7)
      {
        if ([v5 hasBackingData])
        {
          int v8 = [v5 serviceIdentifier];
          BOOL v9 = [v8 length] == 0;
        }
        else
        {
          BOOL v9 = 1;
        }
        id v10 = [v5 paymentHash];

        if (!v9 || v10)
        {
          id v11 = [*(id *)(a1 + 48) primaryAccountIdentifierForTransactionSourceIdentifier:v6];
          if (v11)
          {
            id v13 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              id v14 = [v5 updateReasons];
              CFStringRef v15 = @"NO";
              if (v14 == (id)64) {
                CFStringRef v15 = @"YES";
              }
              int v18 = 138412546;
              CFStringRef v19 = v15;
              __int16 v20 = 2112;
              CFStringRef v21 = (const __CFString *)v11;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Handling PKPaymentTransaction with Bank Connect: fcns (%@), pai (%@)", (uint8_t *)&v18, 0x16u);
            }

            id v16 = *(void **)(a1 + 552);
            double v17 = [v5 fkPaymentTransaction];
            [v16 insertOrUpdateTransaction:v17 forPrimaryAccountIdentifier:v11];
          }
        }
        else
        {
          id v11 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            id v12 = [v5 identifier];
            int v18 = 138412802;
            CFStringRef v19 = v12;
            __int16 v20 = 2112;
            CFStringRef v21 = @"NO";
            __int16 v22 = 2112;
            CFStringRef v23 = @"NO";
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "PKPaymentTransaction with id (%@) will not be imported to Finance: hasNotificationServiceData (%@), hasPaymentHash (%@)", (uint8_t *)&v18, 0x20u);
          }
        }
      }
    }
  }
}

id sub_10003DF68(uint64_t a1)
{
  if (a1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_100808978);
    if (qword_100808980 && [(id)qword_100808980 count]) {
      id v1 = [(id)qword_100808980 copy];
    }
    else {
      id v1 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_100808978);
  }
  else
  {
    id v1 = 0;
  }
  return v1;
}

id sub_10003DFE8(uint64_t a1, void *a2)
{
  return _[a2 sendTransactionSourceIdentifier:*(void *)(a1 + 32) didReceiveTransaction:*(void *)(a1 + 40)];
}

id sub_10003DFF4(uint64_t a1)
{
  if (a1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_100808AE0);
    if (qword_100808AE8 && [(id)qword_100808AE8 count]) {
      id v1 = [(id)qword_100808AE8 copy];
    }
    else {
      id v1 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_100808AE0);
  }
  else
  {
    id v1 = 0;
  }
  return v1;
}

id sub_10003E074(void *a1, void *a2)
{
  return [a2 transactionSourceIdentifier:a1[4] didReceiveTransaction:a1[5] oldTransaction:a1[6]];
}

void sub_10003E084(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  [*(id *)(*(void *)(a1 + 32) + 504) removeObject:*(void *)(a1 + 40)];
  if (a2)
  {
    [*(id *)(a1 + 48) setDeviceScoreIdentifiersSubmitted:1];
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Updating local database after device submitted the device score identifiers.", (uint8_t *)&v9, 2u);
    }

    id v7 = [*(id *)(*(void *)(a1 + 32) + 48) insertOrUpdatePaymentTransaction:*(void *)(a1 + 48) withTransactionSourceIdentifier:*(void *)(a1 + 56) insertionMode:0 performTruncation:0 insertedTransaction:0];
  }
  else
  {
    int v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      id v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Device score identifier submission failed with error: %@", (uint8_t *)&v9, 0xCu);
    }
  }
}

void sub_10003E1D0(id a1, NSArray *a2, NSError *a3)
{
  uint64_t v4 = a2;
  id v5 = a3;
  id v6 = PKLogFacilityTypeGetObject();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      int v11 = 138412290;
      id v12 = v5;
      int v8 = "Error updating account promotions in response to transaction update: %@";
      int v9 = v6;
      uint32_t v10 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v11, v10);
    }
  }
  else if (v7)
  {
    LOWORD(v11) = 0;
    int v8 = "Did update account promotions in response to transaction update";
    int v9 = v6;
    uint32_t v10 = 2;
    goto LABEL_6;
  }
}

void sub_10003E2C8(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    if ([v3 type] == (id)1)
    {
      id v5 = [v4 items];
      id v6 = [v5 anyObject];

      if (v6)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          BOOL v7 = [v6 transactionIdentifiers];
          if ([v7 count])
          {

LABEL_10:
            long long v41 = 0u;
            long long v42 = 0u;
            long long v39 = 0u;
            long long v40 = 0u;
            id v13 = [v6 transactionIdentifiers];
            id v14 = [v13 countByEnumeratingWithState:&v39 objects:v46 count:16];
            if (v14)
            {
              id v15 = v14;
              uint64_t v16 = *(void *)v40;
              while (2)
              {
                for (uint64_t i = 0; i != v15; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v40 != v16) {
                    objc_enumerationMutation(v13);
                  }
                  int v18 = *(NSObject **)(*((void *)&v39 + 1) + 8 * i);
                  CFStringRef v19 = [*(id *)(a1[4] + 48) ambiguousTransactionWithServiceIdentifier:v18];

                  if (!v19)
                  {
                    __int16 v20 = PKLogFacilityTypeGetObject();
                    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 138412290;
                      uint64_t v45 = v18;
                      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "No card transaction for identifier: %@", buf, 0xCu);
                    }

                    char v34 = 1;
                    goto LABEL_28;
                  }
                }
                id v15 = [v13 countByEnumeratingWithState:&v39 objects:v46 count:16];
                if (v15) {
                  continue;
                }
                break;
              }
            }
            char v34 = 0;
LABEL_28:

            long long v37 = 0u;
            long long v38 = 0u;
            long long v35 = 0u;
            long long v36 = 0u;
            CFStringRef v21 = [v6 rewardsAddedIdentifiers];
            id v22 = [v21 countByEnumeratingWithState:&v35 objects:v43 count:16];
            if (v22)
            {
              id v23 = v22;
              uint64_t v24 = *(void *)v36;
              while (2)
              {
                for (uint64_t j = 0; j != v23; uint64_t j = (char *)j + 1)
                {
                  if (*(void *)v36 != v24) {
                    objc_enumerationMutation(v21);
                  }
                  int v26 = *(NSObject **)(*((void *)&v35 + 1) + 8 * (void)j);
                  id v27 = [*(id *)(a1[4] + 48) accountEventWithIdentifier:v26];

                  if (!v27)
                  {
                    long long v31 = PKLogFacilityTypeGetObject();
                    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 138412290;
                      uint64_t v45 = v26;
                      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "No rewards added event for identifier: %@", buf, 0xCu);
                    }

                    goto LABEL_43;
                  }
                }
                id v23 = [v21 countByEnumeratingWithState:&v35 objects:v43 count:16];
                if (v23) {
                  continue;
                }
                break;
              }
            }

            if (v34)
            {
LABEL_43:
              uint64_t v32 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
              {
                long long v33 = a1[5];
                *(_DWORD *)buf = 138412290;
                uint64_t v45 = v33;
                _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Not suppressing transaction from UI: %@, waiting for more events", buf, 0xCu);
              }
            }
            else
            {
              id v28 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v29 = a1[5];
                *(_DWORD *)buf = 138412290;
                uint64_t v45 = v29;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Suppressing transaction from UI: %@", buf, 0xCu);
              }

              id v30 = [*(id *)(a1[4] + 48) updateSuppressBehavior:1 forPaymentTransaction:a1[6] sourceIdentifier:a1[7]];
            }
            goto LABEL_23;
          }
          int v11 = [v6 rewardsAddedIdentifiers];
          id v12 = [v11 count];

          if (v12) {
            goto LABEL_10;
          }
        }
      }
      int v8 = PKLogFacilityTypeGetObject();
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 138412290;
      uint64_t v45 = v4;
      int v9 = "Transaction not suppressed with event: %@";
      uint32_t v10 = v8;
    }
    else
    {
      id v6 = PKLogFacilityTypeGetObject();
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
LABEL_23:

        goto LABEL_24;
      }
      [v4 type];
      int v8 = PKAccountEventTypeToString();
      *(_DWORD *)buf = 138412290;
      uint64_t v45 = v8;
      int v9 = "Redemption event is of incorrect type: %@";
      uint32_t v10 = v6;
    }
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, buf, 0xCu);
LABEL_22:

    goto LABEL_23;
  }
LABEL_24:
}

id *sub_10003E788(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    if ([a1[6] transactionSourceTypeForTransactionSourceIdentifier:v5] == (id)2)
    {
      BOOL v7 = [v6 accountIdentifier];
      uint64_t v8 = [v6 altDSID];
      int v9 = (void *)v8;
      if (v7 && v8)
      {
        uint32_t v10 = [a1[6] accountIdentifierWithPreviousAccountIdentifier:v7];
        if (v10)
        {
          int v11 = [a1[6] transactionSourceIdentifierForAccountUserAltDSID:v9 accountIdentifier:v10];
          id v12 = a1[6];
          id v13 = [v6 serviceIdentifier];
          a1 = (id *)[v12 hasTransactionWithServiceIdentifier:v13 transactionSourceIdentifier:v11];
        }
        else
        {
          a1 = 0;
        }
      }
      else
      {
        id v14 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          v16[0] = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Error: an account identifier or altDSID is not defined on an account user transaction", (uint8_t *)v16, 2u);
        }

        a1 = 0;
      }
    }
    else
    {
      a1 = 0;
    }
  }

  return a1;
}

void sub_10003E8F4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1 && [*(id *)(a1 + 48) transactionSourceTypeForTransactionSourceIdentifier:v5] == (id)2)
  {
    BOOL v7 = [v6 accountIdentifier];
    uint64_t v8 = [v6 altDSID];
    int v9 = (void *)v8;
    if (v7 && v8)
    {
      uint32_t v10 = [*(id *)(a1 + 48) previousAccountIdentifierForAccountIdentifier:v7];
      if ([v10 count])
      {
        CFStringRef v19 = v7;
        id v20 = v6;
        id v21 = v5;
        int v11 = [v6 serviceIdentifier];
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        uint32_t v10 = v10;
        id v12 = [v10 countByEnumeratingWithState:&v22 objects:v32 count:16];
        if (v12)
        {
          id v13 = v12;
          uint64_t v14 = *(void *)v23;
          do
          {
            for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v23 != v14) {
                objc_enumerationMutation(v10);
              }
              uint64_t v16 = *(void *)(*((void *)&v22 + 1) + 8 * i);
              double v17 = [*(id *)(a1 + 48) transactionSourceIdentifierForAccountUserAltDSID:v9 accountIdentifier:v16];
              if (v17
                && [*(id *)(a1 + 48) suppressionBehaviorForTransactionSourceIdentifier:v17 serviceIdentifier:v11] != (id)1)
              {
                int v18 = PKLogFacilityTypeGetObject();
                if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138412802;
                  uint64_t v27 = v16;
                  __int16 v28 = 2112;
                  uint64_t v29 = v9;
                  __int16 v30 = 2112;
                  long long v31 = v11;
                  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Suppressing replayed transaction for account identifier %@ user altDSID %@ and serviceIdentifier %@", buf, 0x20u);
                }

                [*(id *)(a1 + 48) updateSuppressBehavior:1 forTransactionSourceIdentifier:v17 serviceIdentifier:v11];
              }
            }
            id v13 = [v10 countByEnumeratingWithState:&v22 objects:v32 count:16];
          }
          while (v13);
        }

        id v6 = v20;
        id v5 = v21;
        BOOL v7 = v19;
      }
    }
    else
    {
      uint32_t v10 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Error: an account identifier or altDSID is not defined on an account user transaction", buf, 2u);
      }
    }
  }
}

id sub_10003EC50(uint64_t a1, void *a2)
{
  return _[a2 sendPaymentPassWithUniqueIdentifier:*(void *)(a1 + 32) didUpdateCategoryVisualizationWithStyle:*(void *)(a1 + 40)];
}

id sub_10003ED08(uint64_t a1, void *a2)
{
  return _[a2 sendDidRecieveCredentialInvitation:*(void *)(a1 + 32)];
}

id sub_10003EEAC(void *a1, void *a2)
{
  return [a2 sendCredential:a1[4] forPaymentApplication:a1[5] didUpdateRangingSuspensionReasons:a1[6]];
}

void sub_10003EF9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = PDDefaultQueue();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10003F050;
  v6[3] = &unk_10072E198;
  void v6[4] = *(void *)(a1 + 32);
  id v7 = v3;
  id v5 = v3;
  dispatch_async(v4, v6);
}

id sub_10003F050(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 136) updateDailyCashNotificationsWithAccount:*(void *)(a1 + 40)];
}

void sub_10003F05C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    int v7 = PKBankConnectEnabled();
    if (v6)
    {
      if (v5 && v7)
      {
        uint64_t v8 = [*(id *)(a1 + 48) primaryAccountIdentifierForTransactionSourceIdentifier:v6];
        if (v8)
        {
          int v9 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 138412290;
            id v11 = v5;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Deleting payment transaction with %@ from Finance store", (uint8_t *)&v10, 0xCu);
          }

          [*(id *)(a1 + 552) deleteTransactionWithIdentifier:v5 forPrimaryAccountIdentifier:v8];
        }
      }
    }
  }
}

void sub_10003F2FC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v7 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v12;
    do
    {
      int v10 = 0;
      do
      {
        if (*(void *)v12 != v9) {
          objc_enumerationMutation(v6);
        }
        [*(id *)(a1 + 32) transactionSourceIdentifier:v5 willRemoveTransaction:*(void *)(*((void *)&v11 + 1) + 8 * (void)v10)];
        int v10 = (char *)v10 + 1;
      }
      while (v8 != v10);
      id v8 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v8);
  }
}

id sub_10003F500(uint64_t a1, void *a2)
{
  return _[a2 sendTransactionSourceIdentifier:*(void *)(a1 + 32) didRemoveTransactionWithIdentifier:*(void *)(a1 + 40)];
}

void sub_10003F50C(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    [a1[44] transactionSourceIdentifier:v5 didRemoveTransactionWithIdentifier:v6];
    [a1[74] setNeedsSync];
    uint64_t v7 = [a1[6] passUniqueIdentifierForTransactionSourceIdentifier:v5];
    id v8 = (void *)v7;
    if (v6 && v7)
    {
      uint64_t v9 = +[NSDistributedNotificationCenter defaultCenter];
      v11[0] = PKDistributedNotificationTransactionIdentifierKey;
      v11[1] = PKDistributedNotificationTransactionPassUniqueIDKey;
      v12[0] = v6;
      v12[1] = v8;
      v11[2] = PKDistributedNotificationTransactionSourceTransactionIdentifierKey;
      v12[2] = v5;
      int v10 = +[NSDictionary dictionaryWithObjects:v12 forKeys:v11 count:3];
      [v9 postNotificationName:PKDistributedNotificationPaymentTransactionRemoved object:0 userInfo:v10];
    }
  }
}

id sub_10003F75C(uint64_t a1, void *a2)
{
  return _[a2 sendDidRemoveTransactionsWithSourceIdentifierMapping:*(void *)(a1 + 32)];
}

void sub_10003F768(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v7 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v12;
    do
    {
      int v10 = 0;
      do
      {
        if (*(void *)v12 != v9) {
          objc_enumerationMutation(v6);
        }
        sub_10003F50C(*(id **)(a1 + 32), v5, *(void **)(*((void *)&v11 + 1) + 8 * (void)v10));
        int v10 = (char *)v10 + 1;
      }
      while (v8 != v10);
      id v8 = [v6 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v8);
  }
}

id sub_10003F94C(uint64_t a1, void *a2)
{
  return _[a2 sendPaymentPassWithUniqueIdentifier:*(void *)(a1 + 32) didReceiveMessage:*(void *)(a1 + 40)];
}

void sub_10003FBA4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = a2;
  id v5 = +[NSSet setWithArray:v3];
  [v4 sendPaymentPassWithUniqueIdentifier:v2 didReceiveBalanceUpdate:v5];
}

void sub_10003FC20(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  int v10 = v9;
  if (a1)
  {
    long long v11 = *(void **)(a1 + 56);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_10003FFF4;
    void v12[3] = &unk_10072F3F0;
    id v13 = v9;
    uint64_t v14 = a1;
    id v15 = v7;
    id v16 = v8;
    [v11 userNotificationsForPassUniqueIdentifier:v15 ofType:7 completion:v12];
  }
}

id sub_10003FE2C(uint64_t a1, void *a2)
{
  return _[a2 sendPaymentPassWithUniqueIdentifier:*(void *)(a1 + 32) didReceivePlanUpdate:*(void *)(a1 + 40)];
}

id sub_10003FFE4(void *a1, void *a2)
{
  return _[a2 sendPaymentPassWithUniqueIdentifier:a1[4] didUpdateBalanceReminder:a1[5] forBalanceWithIdentifier:a1[6]];
}

void sub_10003FFF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) identifiers];
  id v5 = [v4 anyObject];

  id v6 = [*(id *)(*(void *)(a1 + 40) + 48) balanceReminderThresholdForBalanceIdentifier:v5 withPassUniqueIdentifier:*(void *)(a1 + 48)];
  if (!v6) {
    goto LABEL_15;
  }
  id v7 = [*(id *)(*(void *)(a1 + 40) + 48) passWithUniqueIdentifier:*(void *)(a1 + 48)];
  id v8 = [v7 paymentPass];

  if (![v8 isAutoTopUpBalance:*(void *)(a1 + 32)])
  {
LABEL_14:

LABEL_15:
    if ([v6 isEnabled])
    {
      id v8 = [v6 threshold];
    }
    else
    {
      id v8 = 0;
    }
    id obj = [*(id *)(a1 + 32) currencyCode];
    double v17 = [*(id *)(a1 + 32) value];
    int v47 = [*(id *)(a1 + 56) value];
    if (!v8 || !v17 || !v47)
    {
      PKLogFacilityTypeGetObject();
      int v26 = (PDPassLowBalanceReminderUserNotification *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(&v26->super.super.super, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v27 = *(PDPassLowBalanceReminderUserNotification **)(a1 + 48);
        *(_DWORD *)buf = 138413058;
        long long v69 = v27;
        __int16 v70 = 2112;
        long long v71 = v8;
        __int16 v72 = 2112;
        long long v73 = v17;
        __int16 v74 = 2112;
        long long v75 = v47;
        _os_log_impl((void *)&_mh_execute_header, &v26->super.super.super, OS_LOG_TYPE_DEFAULT, "Ignoring lowBalance evaluation for pass %@. (threshold %@, newBalance: %@, oldBalance: %@)", buf, 0x2Au);
      }
      goto LABEL_70;
    }
    uint64_t v45 = v5;
    id v46 = v3;
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    id v18 = v3;
    id v19 = [v18 countByEnumeratingWithState:&v58 objects:v78 count:16];
    uint64_t v44 = v6;
    if (v19)
    {
      id v20 = v19;
      char v21 = 0;
      uint64_t v22 = *(void *)v59;
      do
      {
        for (uint64_t i = 0; i != v20; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v59 != v22) {
            objc_enumerationMutation(v18);
          }
          long long v24 = *(PDPassLowBalanceReminderUserNotification **)(*((void *)&v58 + 1) + 8 * i);
          if (![(PDUserNotification *)v24 isActive])
          {
            long long v25 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              long long v69 = v24;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Removing an existing lowBalance reminder notification because it is inactive: %@", buf, 0xCu);
            }

            [*(id *)(*(void *)(a1 + 40) + 56) removeUserNotification:v24];
            v21 |= [v17 compare:v8] == (id)-1;
          }
        }
        id v20 = [v18 countByEnumeratingWithState:&v58 objects:v78 count:16];
      }
      while (v20);

      id v6 = v44;
      if (v21) {
        goto LABEL_50;
      }
    }
    else
    {
    }
    if ([v17 compare:v8] == (id)-1 && [v47 compare:v8] != (id)-1)
    {
LABEL_50:
      id v5 = v45;
      int v26 = -[PDPassLowBalanceReminderUserNotification initWithCurrentBalance:balanceCurrency:exponent:reminderAmount:reminderCurrency:passUniqueIdentifier:balanceIdentifier:]([PDPassLowBalanceReminderUserNotification alloc], "initWithCurrentBalance:balanceCurrency:exponent:reminderAmount:reminderCurrency:passUniqueIdentifier:balanceIdentifier:", v17, obj, [*(id *)(a1 + 32) exponent], v8, obj, *(void *)(a1 + 48), v45);
      [*(id *)(*(void *)(a1 + 40) + 56) insertUserNotification:v26];
      long long v35 = PKLogFacilityTypeGetObject();
      id v3 = v46;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        long long v36 = *(NSObject **)(a1 + 48);
        *(_DWORD *)buf = 138413314;
        long long v69 = v26;
        __int16 v70 = 2112;
        long long v71 = v36;
        __int16 v72 = 2112;
        long long v73 = v8;
        __int16 v74 = 2112;
        long long v75 = v17;
        __int16 v76 = 2112;
        long long v77 = v47;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Inserting new lowBalance notification %@ for pass %@ because new balance dropped below threshold. (threshold %@, newBalance: %@, oldBalance: %@)", buf, 0x34u);
      }

      goto LABEL_70;
    }
    id v5 = v45;
    id v3 = v46;
    if ([v17 compare:v8] == (id)-1)
    {
      if (!v18) {
        goto LABEL_71;
      }
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      int v26 = (PDPassLowBalanceReminderUserNotification *)v18;
      id v37 = [(PDPassLowBalanceReminderUserNotification *)v26 countByEnumeratingWithState:&v50 objects:v66 count:16];
      if (!v37)
      {
        id v5 = v45;
        id v3 = v46;
        goto LABEL_70;
      }
      id v38 = v37;
      uint64_t v39 = *(void *)v51;
      do
      {
        for (uint64_t j = 0; j != v38; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v51 != v39) {
            objc_enumerationMutation(v26);
          }
          long long v41 = *(PDPassLowBalanceReminderUserNotification **)(*((void *)&v50 + 1) + 8 * (void)j);
          -[PDPassLowBalanceReminderUserNotification updateBalanceAmount:currency:exponent:](v41, "updateBalanceAmount:currency:exponent:", v17, obj, [*(id *)(a1 + 32) exponent]);
          [(PDPassLowBalanceReminderUserNotification *)v41 updateReminderAmount:v8 currency:obj];
          [(PDUserNotification *)v41 setReissueBannerOnUpdate:0];
          [*(id *)(*(void *)(a1 + 40) + 56) insertUserNotification:v41];
          long long v42 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v43 = *(NSObject **)(a1 + 48);
            *(_DWORD *)buf = 138413314;
            long long v69 = v41;
            __int16 v70 = 2112;
            long long v71 = v43;
            __int16 v72 = 2112;
            long long v73 = v8;
            __int16 v74 = 2112;
            long long v75 = v17;
            __int16 v76 = 2112;
            long long v77 = v47;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Updating existing lowBalance notification %@ for pass %@ (threshold %@, newBalance: %@, oldBalance: %@)", buf, 0x34u);
          }
        }
        id v38 = [(PDPassLowBalanceReminderUserNotification *)v26 countByEnumeratingWithState:&v50 objects:v66 count:16];
      }
      while (v38);
      id v5 = v45;
      id v3 = v46;
    }
    else
    {
      if (!v18) {
        goto LABEL_71;
      }
      __int16 v28 = v8;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      id v29 = v18;
      id v30 = [v29 countByEnumeratingWithState:&v54 objects:v67 count:16];
      if (v30)
      {
        id v31 = v30;
        uint64_t v32 = *(void *)v55;
        do
        {
          for (k = 0; k != v31; k = (char *)k + 1)
          {
            if (*(void *)v55 != v32) {
              objc_enumerationMutation(v29);
            }
            [*(id *)(*(void *)(a1 + 40) + 56) removeUserNotification:*(void *)(*((void *)&v54 + 1) + 8 * (void)k)];
          }
          id v31 = [v29 countByEnumeratingWithState:&v54 objects:v67 count:16];
        }
        while (v31);
      }

      PKLogFacilityTypeGetObject();
      int v26 = (PDPassLowBalanceReminderUserNotification *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(&v26->super.super.super, OS_LOG_TYPE_DEFAULT))
      {
        id v6 = v44;
        id v8 = v28;
        goto LABEL_70;
      }
      char v34 = *(PDPassLowBalanceReminderUserNotification **)(a1 + 48);
      *(_DWORD *)buf = 138412802;
      long long v69 = v34;
      __int16 v70 = 2112;
      id v8 = v28;
      long long v71 = v28;
      __int16 v72 = 2112;
      long long v73 = v17;
      _os_log_impl((void *)&_mh_execute_header, &v26->super.super.super, OS_LOG_TYPE_DEFAULT, "Dropping current lowBalance notifications for pass %@ because new balance became above threshold. (threshold %@, newBalance: %@)", buf, 0x20u);
    }
    id v6 = v44;
LABEL_70:

LABEL_71:
LABEL_72:

    goto LABEL_73;
  }
  if (![v8 isAutoTopEnabled])
  {
    [v6 setEnabled:1];
    [*(id *)(*(void *)(a1 + 40) + 48) setBalanceReminder:v6 forBalanceIdentifier:v5 withPassUniqueIdentifier:*(void *)(a1 + 48)];
    goto LABEL_14;
  }
  [v6 setEnabled:0];
  [*(id *)(*(void *)(a1 + 40) + 48) setBalanceReminder:v6 forBalanceIdentifier:v5 withPassUniqueIdentifier:*(void *)(a1 + 48)];
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  id obj = v3;
  id v9 = [obj countByEnumeratingWithState:&v62 objects:v79 count:16];
  if (v9)
  {
    id v10 = v9;
    id v49 = v8;
    long long v11 = v6;
    uint64_t v12 = *(void *)v63;
    while (2)
    {
      for (m = 0; m != v10; m = (char *)m + 1)
      {
        if (*(void *)v63 != v12) {
          objc_enumerationMutation(obj);
        }
        uint64_t v14 = *(PDPassLowBalanceReminderUserNotification **)(*((void *)&v62 + 1) + 8 * (void)m);
        id v15 = [(PDPassLowBalanceReminderUserNotification *)v14 balanceIdentifier];
        int v16 = PKEqualObjects();

        if (v16)
        {
          [*(id *)(*(void *)(a1 + 40) + 56) removeUserNotification:v14];
          double v17 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            long long v69 = v14;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Removing an existing lowBalance reminder notification because auto top up is enabled: %@", buf, 0xCu);
          }
          id v6 = v11;
          id v8 = v49;
          goto LABEL_72;
        }
      }
      id v10 = [obj countByEnumeratingWithState:&v62 objects:v79 count:16];
      if (v10) {
        continue;
      }
      break;
    }
    id v6 = v11;
    id v8 = v49;
  }
LABEL_73:
}

id sub_100040A28(uint64_t a1, void *a2)
{
  return _[a2 sendPaymentPassWithUniqueIdentifier:*(void *)(a1 + 32) didEnableTransactionService:*(unsigned __int8 *)(a1 + 40)];
}

id sub_100040AF4(uint64_t a1, void *a2)
{
  return _[a2 sendPaymentPassWithUniqueIdentifier:*(void *)(a1 + 32) didEnableMessageService:*(unsigned __int8 *)(a1 + 40)];
}

id sub_100040C90(uint64_t a1, void *a2)
{
  return _[a2 sendPassWithUniqueIdentifier:*(void *)(a1 + 32) didReceiveValueAddedServiceTransaction:*(void *)(a1 + 40)];
}

id sub_100040E48(uint64_t a1, void *a2)
{
  return _[a2 sendPaymentPassWithUniqueIdentifier:*(void *)(a1 + 32) didUpdateWithTransitProperties:*(void *)(a1 + 40)];
}

void sub_100040E54(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    id v5 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v14;
      do
      {
        for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = *(void **)(*((void *)&v13 + 1) + 8 * i);
          id v10 = [v9 paymentTransaction];
          id v11 = [v10 transitType];
          id v12 = *(id *)(a1 + 40);

          if (v11 == v12)
          {
            [v9 invalidateTransitBalance];
            [*(id *)(*(void *)(a1 + 32) + 56) insertUserNotification:v9];
          }
          else
          {
            [*(id *)(*(void *)(a1 + 32) + 56) removeUserNotification:v9];
          }
        }
        id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
      }
      while (v6);
    }
  }
}

void sub_10004101C(uint64_t a1, void *a2)
{
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = a2;
    id v6 = IXStringForAppRemovability();
    uint64_t v7 = *(void *)(a1 + 40);

    int v8 = 138412802;
    id v9 = v6;
    __int16 v10 = 2048;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    id v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Marked Wallet removability as %@ (count: %lu) with error: %@", (uint8_t *)&v8, 0x20u);
  }
}

BOOL sub_1000415B4(uint64_t a1, uint64_t a2, void *a3, int a4, uint64_t a5)
{
  id v9 = a3;
  if (!a1)
  {
    BOOL v25 = 0;
    goto LABEL_35;
  }
  unsigned int v10 = PKIsPad();
  if (a2) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 1;
  }
  __int16 v12 = PKLogFacilityTypeGetObject();
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (v11 == 1)
  {
    if (!v13) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 138543362;
    id v38 = v9;
    long long v14 = "PDServer: obliterating apple pay for %{public}@.";
  }
  else
  {
    if (!v13) {
      goto LABEL_11;
    }
    *(_DWORD *)buf = 138543362;
    id v38 = v9;
    long long v14 = "PDServer: cleaning apple pay for %{public}@.";
  }
  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v14, buf, 0xCu);
LABEL_11:

  int v15 = atomic_load((unsigned __int8 *)(a1 + 8));
  if (v15 != 1)
  {
    long long v24 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "PDServer: passd is not active - ignoring apple pay reset request.", buf, 2u);
    }
    BOOL v25 = 0;
    goto LABEL_34;
  }
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  double v17 = objc_msgSend(*(id *)(a1 + 48), "passUniqueIDsOfType:", 1, 0);
  id v18 = [v17 countByEnumeratingWithState:&v32 objects:v36 count:16];
  if (v18)
  {
    id v19 = v18;
    uint64_t v20 = *(void *)v33;
    do
    {
      for (uint64_t i = 0; i != v19; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v33 != v20) {
          objc_enumerationMutation(v17);
        }
        [*(id *)(a1 + 32) deleteCardWithUniqueID:*(void *)(*((void *)&v32 + 1) + 8 * i) forReason:a5 withDiagnosticReason:v9];
      }
      id v19 = [v17 countByEnumeratingWithState:&v32 objects:v36 count:16];
    }
    while (v19);
  }

  if (a4)
  {
    uint64_t v22 = [(id)PKGetClassNFRemoteAdminManager() sharedRemoteAdminManager];
    long long v23 = v22;
    if (v11) {
      [v22 deleteAllAppletsAndCleanupWithTSM];
    }
    else {
    int v26 = [v22 deleteAllWalletAppletsAndCleanupWithTSM];
    }

    BOOL v25 = v26 == 0;
  }
  else
  {
    [*(id *)(a1 + 72) markAllAppletsForDeletionWithExternalAuthorization:0 obliterate:v11 completion:0];
    BOOL v25 = 1;
  }
  [*(id *)(a1 + 120) noteAccountDeletionWithCompletion:0];
  [*(id *)(a1 + 128) noteAccountDeletionWithCompletion:0];
  [*(id *)(a1 + 352) deleteAllFinHealthDataWithCompletion:0];
  [*(id *)(a1 + 104) deleteSharedWebServiceWithDiagnosticReason:v9];
  [*(id *)(a1 + 184) noteAccountDeleted];
  uint64_t v27 = *(void **)(a1 + 96);
  if (v11)
  {
    [v27 deleteSharedWebServiceWithDiagnosticReason:v9];
    __int16 v28 = *(void **)(a1 + 384);
    id v29 = [*(id *)(a1 + 96) sharedWebService];
    [v28 setPaymentWebService:v29];

    [*(id *)(a1 + 368) updateUpgradedPasscodePolicyEnforcementWithCompletion:&stru_10072F9A8];
    long long v24 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      id v30 = "PDServer: finished oblierating apple pay.";
LABEL_33:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v30, buf, 2u);
    }
  }
  else
  {
    [v27 performPrimaryRegionRegistrationForce:0 completion:0];
    [*(id *)(a1 + 368) updateUpgradedPasscodePolicyEnforcementWithCompletion:&stru_10072F9A8];
    long long v24 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      id v30 = "PDServer: finished cleaning apple pay.";
      goto LABEL_33;
    }
  }
LABEL_34:

LABEL_35:
  return v25;
}

void sub_100041A78(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    if (!v5) {
      __break(1u);
    }
    uint64_t v7 = PDDefaultQueue();
    PDWakePassbookInBackground();

    int v8 = sub_10004960C(a1);
    if ([v8 count])
    {
      id v9 = [*(id *)(a1 + 48) effectiveCatalog];
      double v17 = _NSConcreteStackBlock;
      uint64_t v18 = 3221225472;
      id v19 = sub_1000496C4;
      uint64_t v20 = &unk_10072F960;
      id v21 = v5;
      id v22 = v6;
      id v23 = v9;
      id v10 = v9;
      uint64_t v11 = objc_retainBlock(&v17);
      sub_100049380(a1, v11, v8);
    }
    __int16 v12 = +[NSDistributedNotificationCenter defaultCenter];
    uint64_t v13 = PKPassLibraryDidRecoverPassNotification;
    uint64_t v24 = PKPassLibraryUniqueIDUserInfoKey;
    long long v14 = [v5 uniqueID];
    BOOL v25 = v14;
    int v15 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
    [v12 postNotificationName:v13 object:0 userInfo:v15];

    xpc_object_t v16 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v16, "Name", (const char *)[PKPassLibraryDidChangeNotification UTF8String]);
    [*(id *)(a1 + 512) sendEvent:v16];
  }
}

void sub_100042004(uint64_t a1)
{
}

void sub_100042014(id *a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  if (a1)
  {
    id v6 = [v7 type];
    if (v6 == (id)1)
    {
      if (v5) {
        v5[2](v5);
      }
    }
    else if (!v6)
    {
      sub_100042298(a1, v5);
    }
  }
}

void sub_1000420A4(uint64_t a1)
{
}

void sub_1000420B4(id *a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  if (a1)
  {
    id v6 = [v7 type];
    if (v6 == (id)1)
    {
      sub_100042448(a1, v7, v5);
    }
    else if (!v6)
    {
      sub_10004237C(a1, v7, v5);
    }
  }
}

void sub_100042144(uint64_t a1)
{
}

void sub_100042154(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = [v5 type];
    if (v7 == (id)1)
    {
      objc_initWeak(&location, a1);
      int v8 = (void *)a1[16];
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_100042878;
      v9[3] = &unk_10072F488;
      objc_copyWeak(&v11, &location);
      id v10 = v6;
      [v8 defaultAccountForFeature:4 completion:v9];

      objc_destroyWeak(&v11);
      objc_destroyWeak(&location);
    }
    else if (!v7)
    {
      if ([v5 event] == (id)2) {
        sub_10004258C((uint64_t)a1, v6);
      }
      else {
        sub_100042698((id *)a1, v6);
      }
    }
  }
}

void sub_10004227C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_100042298(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    PKDisableAutomaticRegistration();
    PKDisableCloudKitEnvironmentChangeHandling();
    [a1[34] performDeviceRegistrationForReason:@"account added" brokerURL:0 action:0 forceApplePayRegister:0 forcePeerPaymentRegister:0 completion:&stru_10072F4C8];
    [a1[5] deleteCloudSyncRelatedInformation];
    [a1[4] restartUbiquity];
    +[PKWalletVisibility updateWalletVisibility];
    [a1[12] noteAccountChanged];
    [a1[33] noteAccountAdded];
    [a1[70] noteAccountAdded];
    id v3 = objc_alloc_init((Class)FDAccountNotificationHandler);
    [v3 primaryAppleAccountWasAdded];
    if (v4) {
      v4[2]();
    }
  }
}

void sub_10004237C(id *a1, void *a2, void *a3)
{
  id v6 = a2;
  id v5 = a3;
  if (a1)
  {
    PKDisableCloudKitEnvironmentChangeHandling();
    if ([v6 enablementOfUbiquityDataclassChanged]) {
      [a1[4] restartUbiquity];
    }
    if ([v6 enablementOfWalletDataclassChanged])
    {
      [a1[33] noteCloudSyncPassesSwitchChanged];
      +[PKWalletVisibility updateWalletVisibility];
    }
    if ([v6 accountManagedStateChanged]) {
      +[PKWalletVisibility updateWalletVisibility];
    }
    [a1[12] noteAccountChanged];
    if (v5) {
      v5[2](v5);
    }
  }
}

void sub_100042448(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = +[ACAccountStore ams_sharedAccountStore];
    objc_initWeak(&location, a1);
    int v8 = (void *)a1[16];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100042FC8;
    v10[3] = &unk_10072F580;
    objc_copyWeak(&v14, &location);
    id v11 = v5;
    id v9 = v7;
    id v12 = v9;
    id v13 = v6;
    [v8 defaultAccountForFeature:4 completion:v10];

    objc_destroyWeak(&v14);
    objc_destroyWeak(&location);
  }
}

void sub_100042570(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

void sub_10004258C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    int v4 = PKiCloudSignoutShouldDeleteLocalData();
    if (PKHandsOnDemoModeEnabled()) {
      int v5 = 1;
    }
    else {
      int v5 = PKStoreDemoModeEnabled();
    }
    if (_os_feature_enabled_impl()
      && (PKIsPhone(), PKSetiCloudSignoutShouldDeleteLocalData(), ((v4 ^ 1 | v5) & 1) == 0))
    {
      id v6 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "iCloud signout handler - removing all passes", v7, 2u);
      }

      [*(id *)(a1 + 32) deleteAllWithDiagnosticReason:@"Account Deleted"];
      if (v3) {
        goto LABEL_8;
      }
    }
    else
    {
      [*(id *)(a1 + 560) noteAccountRemoved];
      if (v3) {
LABEL_8:
      }
        v3[2](v3);
    }
  }
}

void sub_100042698(id *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    PKDisableAutomaticRegistration();
    PKDisableCloudKitEnvironmentChangeHandling();
    PKAggDClientAddValueForScalarKey();
    PKAnalyticsSendEvent();
    if ((PKHandsOnDemoModeEnabled() & 1) == 0 && (PKStoreDemoModeEnabled() & 1) == 0)
    {
      sub_1000415B4((uint64_t)a1, 0, @"Account Deleted", 0, 5);
      +[PKWalletVisibility updateWalletVisibility];
      PKSetStockholmEnvironmentDisplayName();
      int v4 = +[PKPaymentOptionsDefaults defaults];
      [v4 deleteAllLocalDefaults];

      +[PKPassOwnershipToken deleteAllLocalKeychainOwnershipTokens];
    }
    [a1[33] noteAccountDeleted];
    [a1[5] deleteCloudSyncRelatedInformation];
    [a1[6] deleteAllCloudStoreContainerChangeEventHistory];
    [a1[16] noteAccountDeletionWithCompletion:&stru_10072F4E8];
    [a1[15] noteAccountDeletionWithCompletion:&stru_10072F508];
    [a1[47] noteAccountRemoved];
    [a1[23] noteAccountDeleted];
    PKSetiCloudSignoutShouldDeleteLocalData();
    id v5 = objc_alloc_init((Class)FDAccountNotificationHandler);
    [v5 primaryAppleAccountWasDeleted];
    [a1[13] deleteSharedWebServiceWithDiagnosticReason:@"Account Deleted"];
    id v6 = objc_alloc_init((Class)PKBankAccountInformation);
    [v6 deleteAllLocalBankInformation];

    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_100042AAC;
    v8[3] = &unk_10072F530;
    id v9 = v3;
    id v7 = +[PKPeerPaymentSession startPeerPaymentSessionWithCompletion:v8];
  }
}

void sub_100042878(uint64_t a1, void *a2)
{
  id v7 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (v7 && WeakRetained)
  {
    int v4 = (void *)WeakRetained[4];
    id v5 = [v7 associatedPassUniqueID];
    [v4 deleteCardWithUniqueID:v5 forReason:6 withDiagnosticReason:@"iTunes Account Deleted"];
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6) {
    (*(void (**)(void))(v6 + 16))();
  }
}

void sub_1000429FC(id a1, unint64_t a2, PKPaymentWebServiceContext *a3, NSError *a4)
{
  id v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 134217984;
    unint64_t v7 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Device Registration result was: %lu", (uint8_t *)&v6, 0xCu);
  }
}

uint64_t sub_100042AAC(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 deleteApplet];
  [v3 invalidateSessionWithCompletion:0];

  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    id v5 = *(uint64_t (**)(void))(result + 16);
    return v5();
  }
  return result;
}

void sub_100042C8C(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) description];
    *(_DWORD *)buf = 138412290;
    int v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Starting backup with files: %@", buf, 0xCu);
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_100042DF0;
  v5[3] = &unk_10072F558;
  int v4 = *(void **)(a1 + 32);
  id v6 = *(id *)(a1 + 40);
  [v4 enumerateObjectsUsingBlock:v5];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finished backup of files.", buf, 2u);
  }
}

void sub_100042DF0(uint64_t a1, void *a2, uint64_t a3)
{
  int v4 = *(void **)(a1 + 32);
  id v5 = a2;
  id v6 = [v4 objectAtIndex:a3];
  [v6 truncateFileAtOffset:0];
  [v6 seekToFileOffset:0];
  id v7 = [objc_alloc((Class)NSData) initWithContentsOfURL:v5];

  id v15 = 0;
  [v6 writeData:v7 error:&v15];
  id v8 = v15;
  if (v8)
  {
    id v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = [v8 description];
      *(_DWORD *)buf = 138543362;
      double v17 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unable to write to file: %{public}@", buf, 0xCu);
    }
  }
  id v14 = 0;
  [v6 closeAndReturnError:&v14];
  id v11 = v14;

  if (v11)
  {
    id v12 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [v11 description];
      *(_DWORD *)buf = 138543362;
      double v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Unable to close file: %{public}@", buf, 0xCu);
    }
  }
}

void sub_100042FC8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v5 = WeakRetained;
  if (!v3 || !WeakRetained) {
    goto LABEL_12;
  }
  unsigned int v6 = [*(id *)(a1 + 32) accountStorefrontChanged];
  unsigned int v7 = objc_msgSend(*(id *)(a1 + 40), "ams_isActiveAccountCombined");
  id v8 = v7
     ? @"Apple Account storefront does not match PKAccount country code"
     : @"iCloud and iTunes Account Mismatch";
  if (v7 && !v6) {
    goto LABEL_12;
  }
  id v9 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 138412290;
    xpc_object_t v16 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@: removing Apple Account pass if needed", (uint8_t *)&v15, 0xCu);
  }

  id v10 = (void *)*((void *)v5 + 4);
  id v11 = [v3 associatedPassUniqueID];
  [v10 deleteCardWithUniqueID:v11 forReason:6 withDiagnosticReason:v8];

  if (v6)
  {
    id v12 = objc_msgSend(*(id *)(a1 + 40), "ams_activeiTunesAccount");
    id v13 = objc_msgSend(v12, "ams_storefront");

    [*((id *)v5 + 16) resolveAccountStorefrontCountryMismatchForAccount:v3 newCountryCode:v13 completion:*(void *)(a1 + 48)];
  }
  else
  {
LABEL_12:
    uint64_t v14 = *(void *)(a1 + 48);
    if (v14) {
      (*(void (**)(void))(v14 + 16))();
    }
  }
}

void sub_1000433A8(uint64_t a1)
{
  [&off_10078C198 enumerateObjectsUsingBlock:&stru_10072FD38];
  _VerifyOrUpdateDirectoryFileProtection(1);
  sub_100043480(*(void *)(a1 + 32));
  if (*(unsigned char *)(a1 + 48)) {
    sub_10004424C(*(void *)(a1 + 32));
  }
  [*(id *)(*(void *)(a1 + 32) + 32) performImageMigrationWithStartTime:*(double *)(a1 + 40)];
  [*(id *)(*(void *)(a1 + 32) + 48) migrateObjectSettings];
  sub_1000385D8(*(void *)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100044458;
  v3[3] = &unk_10072E4F8;
  v3[4] = v2;
  sub_1000388F4(v2, 0, v3);
}

void sub_100043480(uint64_t a1)
{
  if (a1)
  {
    id v1 = PKKeychainVersion();
    int v2 = [v1 intValue];

    if (v2 < 2)
    {
      id v3 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Migrating keychain to version 2", buf, 2u);
      }

      id v4 = [objc_alloc((Class)PKKeychainItemWrapper) initWithIdentifier:@"PKBillingAddressesKeychainKey" accessGroup:@"com.apple.PassbookUIService" serviceName:0 type:1 invisible:0];
      id v5 = [objc_alloc((Class)PKKeychainItemWrapper) initWithIdentifier:@"PKBillingAddressKeychainKey" accessGroup:@"com.apple.PassbookUIService" serviceName:0 type:2 invisible:0];
      unsigned int v6 = [v4 objectForKey:kSecValueData];
      uint64_t v7 = [v5 objectForKey:kSecValueData];
      id v8 = (void *)v7;
      if (!v6 && v7)
      {
        id v9 = objc_alloc((Class)NSSet);
        uint64_t v10 = objc_opt_class();
        id v11 = objc_msgSend(v9, "initWithObjects:", v10, objc_opt_class(), 0);
        id v12 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v11 fromData:v8 error:0];

        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          char v89 = v12;
          id v93 = v5;
          id v13 = +[NSMutableSet set];
          uint64_t v88 = +[NSMutableDictionary dictionary];
          long long v106 = 0u;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v109 = 0u;
          uint64_t v14 = [*(id *)(a1 + 48) passesOfType:1];
          id v15 = [v14 countByEnumeratingWithState:&v106 objects:v115 count:16];
          if (v15)
          {
            id v16 = v15;
            uint64_t v17 = *(void *)v107;
            do
            {
              for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v107 != v17) {
                  objc_enumerationMutation(v14);
                }
                id v19 = [*(id *)(*((void *)&v106 + 1) + 8 * i) primaryAccountIdentifier];
                [v13 addObject:v19];
              }
              id v16 = [v14 countByEnumeratingWithState:&v106 objects:v115 count:16];
            }
            while (v16);
          }

          id v12 = v89;
          [v88 setObject:v13 forKey:v89];
          uint64_t v20 = +[NSKeyedArchiver archivedDataWithRootObject:v88 requiringSecureCoding:1 error:0];
          [v4 setObject:v20 forKey:kSecValueData];

          id v21 = [objc_alloc((Class)PKKeychainItemWrapper) initWithIdentifier:@"PKBillingAddressKeychainKey" accessGroup:@"com.apple.PassbookUIService" serviceName:0 type:2 invisible:0];
          [v21 resetKeychainItem];

          id v5 = v93;
        }
      }
      id v22 = +[PKPaymentOptionsDefaults defaults];
      [v22 migrateToSyncable];

      PKSetKeychainVersion();
    }
    id v23 = PKKeychainVersion();
    int v24 = [v23 intValue];

    if (v24 < 3)
    {
      BOOL v25 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Migrating keychain to version 3. Inferring recents update", buf, 2u);
      }

      int v26 = +[PKPaymentOptionsDefaults defaults];
      uint64_t v27 = [v26 defaultShippingAddress];

      if (v27)
      {
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Migrating default shipping address", buf, 2u);
        }

        __int16 v28 = +[PKPaymentOptionsDefaults defaults];
        id v29 = [v27 contactWithCleanedUpDistrict];
        [v28 setDefaultShippingAddress:v29];
      }
      BOOL v90 = v27;
      long long v104 = 0u;
      long long v105 = 0u;
      long long v102 = 0u;
      long long v103 = 0u;
      id v30 = [*(id *)(a1 + 48) passesOfType:1];
      id v31 = [v30 countByEnumeratingWithState:&v102 objects:v114 count:16];
      if (v31)
      {
        id v32 = v31;
        uint64_t v33 = *(void *)v103;
        do
        {
          for (uint64_t j = 0; j != v32; uint64_t j = (char *)j + 1)
          {
            if (*(void *)v103 != v33) {
              objc_enumerationMutation(v30);
            }
            long long v35 = *(void **)(*((void *)&v102 + 1) + 8 * (void)j);
            long long v36 = +[PKPaymentOptionsDefaults defaults];
            id v37 = [v36 defaultBillingAddressForPaymentPass:v35];

            if (v37)
            {
              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
              {
                id v38 = [v35 primaryAccountIdentifier];
                *(_DWORD *)buf = 138412290;
                v113 = v38;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Migrating billing address for payment pass: %@", buf, 0xCu);
              }
              uint64_t v39 = +[PKPaymentOptionsDefaults defaults];
              long long v40 = [v37 contactWithCleanedUpDistrict];
              [v39 setDefaultBillingAddress:v40 forPaymentPass:v35];
            }
          }
          id v32 = [v30 countByEnumeratingWithState:&v102 objects:v114 count:16];
        }
        while (v32);
      }

      PKSetKeychainVersion();
    }
    long long v41 = PKKeychainVersion();
    int v42 = [v41 intValue];

    if (v42 < 4)
    {
      uint64_t v43 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Adding service name to keychain items", buf, 2u);
      }

      long long v100 = 0u;
      long long v101 = 0u;
      long long v98 = 0u;
      long long v99 = 0u;
      id v44 = [&off_10078C180 countByEnumeratingWithState:&v98 objects:v111 count:16];
      if (v44)
      {
        id v45 = v44;
        uint64_t v46 = *(void *)v99;
        do
        {
          for (k = 0; k != v45; k = (char *)k + 1)
          {
            if (*(void *)v99 != v46) {
              objc_enumerationMutation(&off_10078C180);
            }
            long long v48 = *(void **)(*((void *)&v98 + 1) + 8 * (void)k);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              v113 = v48;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Migrating keychain key: %@", buf, 0xCu);
            }

            id v49 = [objc_alloc((Class)PKKeychainItemWrapper) initWithIdentifier:v48 accessGroup:@"com.apple.PassbookUIService" serviceName:0 type:1 invisible:0];
            long long v50 = [v49 objectForKey:kSecValueData];
            if (v50)
            {
              [v49 resetKeychainItem];
              id v51 = [objc_alloc((Class)PKKeychainItemWrapper) initWithIdentifier:v48 accessGroup:@"com.apple.PassbookUIService" serviceName:@"com.apple.passkit" type:1 invisible:0];
              [v51 setObject:v50 forKey:kSecValueData];
            }
          }
          id v45 = [&off_10078C180 countByEnumeratingWithState:&v98 objects:v111 count:16];
        }
        while (v45);
      }
      PKSetKeychainVersion();
    }
    long long v52 = PKKeychainVersion();
    int v53 = [v52 intValue];

    if (v53 < 5)
    {
      long long v54 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "Migrating keychain to version 5. Transfering peer payment bank information to new keychain.", buf, 2u);
      }

      id v55 = [objc_alloc((Class)PKKeychainItemWrapper) initWithIdentifier:@"PKPeerPaymentUnitedStatesBankAccountInformationKeychainKey" accessGroup:@"com.apple.Passbook.PeerPayment" serviceName:@"com.apple.passkit" type:1 invisible:0];
      long long v56 = [v55 objectForKey:kSecValueData];
      if (v56)
      {
        [v55 resetKeychainItem];
        id v57 = [objc_alloc((Class)PKKeychainItemWrapper) initWithIdentifier:@"PKPeerPaymentUnitedStatesBankAccountInformationKeychainKey" accessGroup:@"com.apple.Passbook.PeerPayment" serviceName:@"com.apple.passkit" type:1 invisible:0];
        [v57 setLabel:@"com.apple.passkit"];
        long long v58 = [v57 objectForKey:kSecValueData];
        if (!v58) {
          [v57 setObject:v56 forKey:kSecValueData];
        }
      }
      PKSetKeychainVersion();
    }
    long long v59 = PKKeychainVersion();
    int v60 = [v59 intValue];

    if (v60 < 6)
    {
      long long v61 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "Migrating keychain to version 6. Updating billing address for card from accountIdentifier to pass primaryAccountIdentifier.", buf, 2u);
      }

      long long v62 = [*(id *)(a1 + 48) accounts];
      long long v63 = [v62 allObjects];

      if ([v63 count])
      {
        long long v64 = +[PKPaymentOptionsDefaults defaults];
        long long v94 = 0u;
        long long v95 = 0u;
        long long v96 = 0u;
        long long v97 = 0u;
        v91 = v63;
        id v65 = v63;
        id v66 = [v65 countByEnumeratingWithState:&v94 objects:v110 count:16];
        if (!v66) {
          goto LABEL_81;
        }
        id v67 = v66;
        uint64_t v68 = *(void *)v95;
        while (1)
        {
          for (m = 0; m != v67; m = (char *)m + 1)
          {
            if (*(void *)v95 != v68) {
              objc_enumerationMutation(v65);
            }
            __int16 v70 = [*(id *)(*((void *)&v94 + 1) + 8 * (void)m) accountIdentifier];
            long long v71 = [v64 defaultBillingAddressForPrimaryAccountIdentifier:v70];
            if (v71)
            {
              __int16 v72 = [*(id *)(a1 + 48) primaryAccountIdentifierForAssociatedAccountIdentifier:v70];
              if (v72)
              {
                [v64 setDefaultBillingAddress:v71 forPrimaryAccountIdentifier:v72];
                if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138412290;
                  v113 = v70;
                  long long v73 = v61;
                  __int16 v74 = "Migration added default billing address for primaryAccountIdentifier of accountIdentifier: %@";
                  goto LABEL_75;
                }
              }
              else if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                v113 = v70;
                long long v73 = v61;
                __int16 v74 = "Cannot migrate address for accountIdentifier: %@ with nil primaryAccountIdentifier";
LABEL_75:
                _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, v74, buf, 0xCu);
              }

              [v64 deleteDefaultBillingAddressForPrimaryAccountIdentifier:v70];
              if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138412290;
                v113 = v70;
                _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "Migration removed default billing address for accountIdentifier: %@", buf, 0xCu);
              }
            }
          }
          id v67 = [v65 countByEnumeratingWithState:&v94 objects:v110 count:16];
          if (!v67)
          {
LABEL_81:

            long long v63 = v91;
            break;
          }
        }
      }
      PKSetKeychainVersion();
    }
    long long v75 = PKKeychainVersion();
    int v76 = [v75 intValue];

    if (v76 < 7)
    {
      long long v77 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "Migrating keychain to version 7. Hiding ownership tokens in keychain.", buf, 2u);
      }

      +[PKPassOwnershipToken queryKeychainForOwnershipTokens:&stru_10072FB08];
      PKSetKeychainVersion();
    }
    long long v78 = PKKeychainVersion();
    int v79 = [v78 intValue];

    long long v80 = PKLogFacilityTypeGetObject();
    long long v81 = v80;
    if (v79 <= 7)
    {
      if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "Migrating keychain to version 8. Updating account attestation to type cloud in keychain.", buf, 2u);
      }

      id v82 = objc_alloc((Class)PKKeychainItemWrapper);
      uint64_t v83 = PKPassdBundleIdentifier;
      id v84 = [v82 initWithIdentifier:@"PKAnonymizationSaltKeychainKey" accessGroup:PKPassdBundleIdentifier serviceName:@"com.apple.passd.account-attestation"];
      v85 = [v84 objectForKey:kSecValueData];
      if (v85)
      {
        [v84 resetKeychainItem];
        id v86 = [objc_alloc((Class)PKKeychainItemWrapper) initWithIdentifier:@"PKAnonymizationSaltKeychainKey" accessGroup:v83 serviceName:@"com.apple.passd.account-attestation" type:1 invisible:1 accessibility:1];
        v87 = [v86 objectForKey:kSecValueData];
        if (!v87) {
          [v86 setObject:v85 forKey:kSecValueData];
        }
      }
      PKSetKeychainVersion();
    }
    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "Keychain migration complete", buf, 2u);
    }
  }
}

void sub_10004424C(uint64_t a1)
{
  if (a1)
  {
    int v2 = PKStoreDemoModeEnabled();
    int v3 = PKUIOnlyDemoModeEnabled();
    int v4 = v3;
    if ((v2 & 1) != 0 || v3)
    {
      id v5 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v10 = @"NO";
        if (v2) {
          CFStringRef v11 = @"YES";
        }
        else {
          CFStringRef v11 = @"NO";
        }
        if (v4) {
          CFStringRef v10 = @"YES";
        }
        *(_DWORD *)id v15 = 138412546;
        *(void *)&void v15[4] = v11;
        *(_WORD *)&v15[12] = 2112;
        *(void *)&v15[14] = v10;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "PDServer: Skipping applying backup exclusions to existing passes (PKStoreDemoModeEnabled: %@, PKUIOnlyDemoModeEnabled: %@).", v15, 0x16u);
      }
    }
    else
    {
      id v5 = PKCardsDirectoryURL();
      *(void *)id v15 = 0;
      *(void *)&v15[8] = v15;
      *(void *)&v15[16] = 0x2020000000;
      uint64_t v16 = 0;
      uint64_t v7 = *(void **)(a1 + 48);
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472;
      v12[2] = sub_10004BCA8;
      void v12[3] = &unk_10072FCF8;
      void v12[4] = v5;
      void v12[5] = v15;
      [v7 enumeratePassSyncabilityPropertiesWithHandler:v12];
      id v8 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = *(void *)(*(void *)&v15[8] + 24);
        *(_DWORD *)buf = 134217984;
        uint64_t v14 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDServer: Applied backup exclusions to %lu passes.", buf, 0xCu);
      }

      _Block_object_dispose(v15, 8);
    }
  }
}

void sub_100044438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100044458(uint64_t a1, int a2)
{
  if (a2)
  {
    sub_10004449C(*(void *)(a1 + 32));
    uint64_t v3 = *(void *)(a1 + 32);
    sub_100044684(v3);
  }
}

void sub_10004449C(uint64_t a1)
{
  if (a1 && PKSecureElementIsAvailable())
  {
    int v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Checking migration of primary region topic", (uint8_t *)&v14, 2u);
    }

    uint64_t v3 = [*(id *)(a1 + 96) sharedWebServiceContext];
    int v4 = [v3 primaryRegion];
    id v5 = [v4 trustedServiceManagerPushTopic];

    unsigned int v6 = [*(id *)(a1 + 72) primaryRegionTopic];
    if ([v6 length])
    {
      uint64_t v7 = [*(id *)(a1 + 72) primaryRegionTopic];
    }
    else
    {
      uint64_t v7 = 0;
    }

    id v8 = v7;
    id v9 = v5;
    CFStringRef v10 = v9;
    if (v8 == v9)
    {

      id v12 = v10;
    }
    else
    {
      if (v9 && v8)
      {
        unsigned __int8 v11 = [v8 isEqualToString:v9];

        if (v11) {
          goto LABEL_19;
        }
      }
      else
      {
      }
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = 138412290;
        id v15 = v10;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Updating secure element primaryRegionTopic to :%@", (uint8_t *)&v14, 0xCu);
      }

      id v13 = *(void **)(a1 + 72);
      id v12 = [v3 TSMURLStringByPushTopic];
      [v13 setRegistrationInformation:v12 primaryRegionTopic:v10];
    }

LABEL_19:
  }
}

void sub_100044684(uint64_t a1)
{
  if (a1)
  {
    if (PKUIOnlyDemoModeEnabled()) {
      int v2 = 1;
    }
    else {
      int v2 = PKStoreDemoModeEnabled();
    }
    if (PKSecureElementIsAvailable()
      && ((PDProtectedDataAvailable() ^ 1 | v2) & 1) == 0
      && ([*(id *)(a1 + 48) passExistsWithPassType:1] & 1) == 0)
    {
      uint64_t v3 = [*(id *)(a1 + 32) passesOfType:1];
      id v4 = [v3 count];

      if (!v4)
      {
        id v5 = *(void **)(a1 + 72);
        v6[0] = _NSConcreteStackBlock;
        v6[1] = 3221225472;
        v6[2] = sub_10004B184;
        v6[3] = &unk_10072FC20;
        void v6[4] = a1;
        [v5 allAppletsWithCompletion:v6];
      }
    }
  }
}

id sub_100044774(uint64_t a1)
{
  return [*(id *)(a1 + 40) handleDatabaseIntegrityProblem];
}

void sub_10004477C(id a1, NSError *a2)
{
  uint64_t v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [(NSError *)a2 description];
    int v5 = 138412290;
    unsigned int v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Donated pass information with error: %@", (uint8_t *)&v5, 0xCu);
  }
}

void sub_1000448B8(uint64_t a1, void *a2)
{
}

void sub_1000448D0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, int a6)
{
  id v52 = a2;
  id v11 = a5;
  if (a1 && v52 && a3 != a4)
  {
    id v12 = [v52 uniqueID];
    id v13 = [v52 localizedDescription];
    int v14 = PKPassLocalizedStringForStateWithFormat();
    id v15 = PKPassLocalizedStringForStateWithFormat();
    unsigned int v16 = objc_msgSend(v52, "supportsBarcodePayment", v13);
    if (v15) {
      goto LABEL_5;
    }
    unsigned int v19 = v16;
    if ([v52 isAccessPass]) {
      unsigned int v20 = 1;
    }
    else {
      unsigned int v20 = [v52 isIdentityPass];
    }
    id v15 = 0;
    switch(a4)
    {
      case 6:
      case 9:
        if (v19)
        {
          PKLocalizedAquamanString(@"PAYMENT_ACCOUNT_SUSPENDED_NOTIFICATION_FORMAT", @"%@", v13);
          goto LABEL_53;
        }
        CFStringRef v45 = @"PAYMENT_SUSPENDED_NOTIFICATION_FORMAT";
        CFStringRef v46 = @"GENERIC_SUSPENDED_NOTIFICATION_FORMAT";
        goto LABEL_59;
      case 7:
      case 8:
      case 11:
      case 12:
      case 13:
      case 14:
        goto LABEL_5;
      case 10:
        if (v19)
        {
          PKLocalizedAquamanString(@"PAYMENT_ACCOUNT_REMOVED_NOTIFICATION_FORMAT", @"%@", v13);
          uint64_t v44 = LABEL_53:;
          goto LABEL_56;
        }
        CFStringRef v45 = @"PAYMENT_REMOVED_NOTIFICATION_FORMAT";
        CFStringRef v46 = @"GENERIC_REMOVED_NOTIFICATION_FORMAT";
LABEL_59:
        if (v20) {
          p_isa = &v46->isa;
        }
        else {
          p_isa = &v45->isa;
        }
        long long v48 = PKLocalizedPaymentString(p_isa);
        long long v50 = v13;
        goto LABEL_87;
      case 15:
        if ([v52 isCarKeyPass])
        {
          uint64_t v44 = PKLocalizedShareableCredentialString(@"SHARE_NOTIFICATION_RECIPIENT_REVOKED", @"%@", v13);
LABEL_56:
          id v15 = (void *)v44;
        }
        else
        {
          id v15 = 0;
        }
        goto LABEL_5;
      default:
        if (a4 != 1) {
          goto LABEL_5;
        }
        if ([v52 supportsOnlyTransit])
        {
          if (a6) {
            uint64_t v27 = @"TRANSIT_CARD_READY_TO_USE_FORMAT_EXPRESS";
          }
          else {
            uint64_t v27 = @"TRANSIT_CARD_READY_TO_USE_FORMAT";
          }
          goto LABEL_84;
        }
        if ([v52 isAccessPass])
        {
          switch((unint64_t)[v52 accessType])
          {
            case 0uLL:
              if (a6) {
                uint64_t v27 = @"GENERIC_READY_TO_USE_FORMAT_EXPRESS";
              }
              else {
                uint64_t v27 = @"GENERIC_READY_TO_USE_FORMAT";
              }
              goto LABEL_84;
            case 1uLL:
            case 3uLL:
            case 4uLL:
            case 5uLL:
            case 6uLL:
              if (a6) {
                uint64_t v27 = @"GENERIC_READY_TO_USE_FORMAT_KEY_EXPRESS";
              }
              else {
                uint64_t v27 = @"GENERIC_READY_TO_USE_FORMAT_KEY";
              }
              goto LABEL_84;
            case 2uLL:
              if (a6) {
                uint64_t v27 = @"GENERIC_READY_TO_USE_FORMAT_BADGE_EXPRESS";
              }
              else {
                uint64_t v27 = @"GENERIC_READY_TO_USE_FORMAT_BADGE";
              }
              goto LABEL_84;
            default:
              long long v48 = 0;
              break;
          }
LABEL_86:
          long long v50 = v13;
LABEL_87:
          id v15 = PKStringWithValidatedFormat();

LABEL_5:
          if (a4 == 1)
          {
            if ([v52 muteReadyForUseNotification])
            {
              char v17 = 0;
              int v18 = 0;
              if (!v15) {
                goto LABEL_34;
              }
            }
            else
            {
              if ([v52 hasAssociatedPeerPaymentAccount])
              {
                id v21 = [*(id *)(a1 + 48) peerPaymentAccount];
                BOOL v22 = [v21 role] != 0;
                unsigned int v23 = objc_msgSend(v21, "isParticipantAccountLockedByOwner", v50);

                int v18 = v22 & ~v23;
              }
              else
              {
                int v18 = 1;
              }
              int v24 = objc_msgSend(v52, "associatedAccountServiceAccountIdentifier", v50);

              if (v24)
              {
                BOOL v25 = [v52 devicePrimaryPaymentApplication];
                id v26 = [v25 paymentNetworkIdentifier];

                char v17 = 0;
                if (v26 == (id)135) {
                  int v18 = 0;
                }
                if (!v15)
                {
LABEL_34:
                  if (objc_msgSend(*(id *)(a1 + 48), "hasAnyMessagesForPassWithUniqueIdentifier:", v12, v50))
                  {
                    id v51 = v15;
                    id v30 = v11;
                    id v31 = v13;
                    id v32 = v14;
                    uint64_t v33 = [*(id *)(a1 + 48) allMessagesForPassWithUniqueIdentifier:v12];
                    long long v34 = +[NSPredicate predicateWithFormat:@"messageType == %d", 1];
                    long long v35 = [v33 filteredSetUsingPredicate:v34];
                    id v36 = [v35 anyObject];

                    int v14 = v32;
                    id v13 = v31;
                    id v11 = v30;
                    if (v17)
                    {
                      id v15 = v51;
                      if (v36)
                      {
LABEL_40:
                        [v36 setMessageType:1];
                        uint64_t v39 = +[NSDate date];
                        [v36 setMessageDate:v39];

                        [v36 setContent:v15];
                        if ([v52 isAccessPass])
                        {
                          long long v40 = +[NSDate dateWithDaysFromNow:3];
                          [v36 setExpirationDate:v40];
                        }
                        else
                        {
                          [v36 setExpirationDate:0];
                        }
                        [v36 setArchived:0];
                        id v43 = [*(id *)(a1 + 48) insertOrUpdatePaymentMessage:v36 forPassUniqueIdentifier:v12 paymentApplication:0 performTruncation:0];
                        goto LABEL_46;
                      }
LABEL_39:
                      id v36 = objc_alloc_init((Class)PKPaymentMessage);
                      id v37 = +[NSUUID UUID];
                      id v38 = [v37 UUIDString];
                      [v36 setServiceIdentifier:v38];

                      goto LABEL_40;
                    }
                    id v15 = v51;
                    if (v36)
                    {
                      long long v41 = *(void **)(a1 + 48);
                      int v42 = [v36 identifier];
                      [v41 archiveMessageWithIdentifier:v42];

LABEL_46:
                    }
                  }
                  else if (v17)
                  {
                    goto LABEL_39;
                  }

                  break;
                }
              }
              else
              {
                char v17 = 1;
                if (!v15) {
                  goto LABEL_34;
                }
              }
            }
          }
          else
          {
            char v17 = 0;
            int v18 = 1;
            if (!v15) {
              goto LABEL_34;
            }
          }
          __int16 v28 = [PDWalletUserNotificationPassStateChanged stringByAppendingFormat:@":%@", v12];
          if (v18 && [v15 length])
          {
            id v29 = [(PDGenericUserNotification *)[PDWalletUserNotification alloc] initWithTitle:v14 message:v15 forPassUniqueIdentifier:v12];
            [(PDUserNotification *)v29 setNotificationIdentifier:v28];
            [(PDUserNotification *)v29 setReissueBannerOnUpdate:1];
            [(PDUserNotification *)v29 setSuppressionBehavior:2];
            [*(id *)(a1 + 56) insertUserNotification:v29];
          }
          goto LABEL_34;
        }
        if ([v52 supportsBarcodePayment])
        {
          uint64_t v27 = @"PAYMENT_READY_TO_USE_WALLET_FORMAT";
LABEL_84:
          uint64_t v49 = PKLocalizedPaymentString(&v27->isa);
          goto LABEL_85;
        }
        if ([v52 isIdentityPass])
        {
          uint64_t v49 = PKLocalizedIdentityString(@"ID_READY_TO_USE_FORMAT");
        }
        else
        {
          if (![v52 hasActiveVirtualCardAccordingToWebService:v11])
          {
            uint64_t v27 = @"PAYMENT_READY_TO_USE_FORMAT";
            goto LABEL_84;
          }
          uint64_t v49 = PKLocalizedVirtualCardString(@"VIRTUAL_CARD_PAYMENT_READY_TO_USE_FORMAT");
        }
LABEL_85:
        long long v48 = (void *)v49;
        goto LABEL_86;
    }
  }
}

BOOL sub_1000450EC(id a1, PKSecureElementPass *a2, unint64_t a3, BOOL *a4)
{
  id v4 = a2;
  BOOL v5 = ([(PKSecureElementPass *)v4 muteReadyForUseNotification] & 1) == 0
    && [(PKSecureElementPass *)v4 passActivationState] == PKSecureElementPassActivationStateActivated;

  return v5;
}

void sub_100045138(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 336);
  BOOL v5 = [*(id *)(a1 + 40) uniqueID];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100045208;
  v8[3] = &unk_10072F630;
  unsigned int v6 = *(void **)(a1 + 40);
  void v8[4] = *(void *)(a1 + 32);
  id v9 = v6;
  id v10 = v3;
  id v7 = v3;
  sub_10018DCCC(v4, v5, v8);
}

void sub_100045208(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  BOOL v5 = *(void **)(a1 + 40);
  id v6 = [v5 devicePrimaryPaymentApplication];
  sub_1000448D0(v4, v5, 0, (uint64_t)[v6 state], *(void **)(a1 + 48), a2);
}

void sub_100045284(uint64_t a1, void *a2)
{
  id v3 = objc_msgSend(a2, "pk_setByApplyingBlock:", &stru_10072F698);
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (!v5)
  {

    uint64_t v12 = *(void *)(a1 + 48);
    if (v12) {
      goto LABEL_12;
    }
    uint64_t v7 = 0;
LABEL_14:
    uint64_t v16 = v7;
    uint64_t v18 = v7;
    id v13 = @"CARDS_READY_TO_USE_EXPRESS";
    goto LABEL_15;
  }
  id v6 = v5;
  uint64_t v7 = 0;
  uint64_t v8 = *(void *)v20;
  do
  {
    for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v20 != v8) {
        objc_enumerationMutation(v4);
      }
      id v10 = [*(id *)(*((void *)&v19 + 1) + 8 * i) uniqueID];
      unsigned int v11 = [v3 containsObject:v10];

      v7 += v11;
    }
    id v6 = [v4 countByEnumeratingWithState:&v19 objects:v23 count:16];
  }
  while (v6);

  uint64_t v12 = *(void *)(a1 + 48);
  if (v7 == v12) {
    goto LABEL_14;
  }
  if (v7)
  {
    uint64_t v16 = *(void *)(a1 + 48);
    uint64_t v18 = v7;
    id v13 = @"CARDS_READY_TO_USE_SOME_EXPRESS";
LABEL_15:
    PKLocalizedPaymentString(&v13->isa, @"%lu%lu", v16, v18, (void)v19);
    goto LABEL_16;
  }
LABEL_12:
  PKLocalizedPaymentString(@"CARDS_READY_TO_USE_NO_EXPRESS", @"%lu", v12, v17, (void)v19);
  int v14 = LABEL_16:;
  id v15 = [(PDGenericUserNotification *)[PDWalletUserNotification alloc] initWithTitle:0 message:v14 forPassUniqueIdentifier:0];
  [(PDUserNotification *)v15 setSuppressionBehavior:2];
  [*(id *)(*(void *)(a1 + 40) + 56) insertUserNotification:v15];
}

id sub_10004546C(id a1, PKExpressPassConfiguration *a2)
{
  return [(PKExpressPassConfiguration *)a2 passUniqueIdentifier];
}

void sub_100045608(uint64_t a1, uint64_t a2)
{
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = PKDeviceRegistrationResultToString();
    *(_DWORD *)buf = 138412290;
    id v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed device registration from IDS message with result %@", buf, 0xCu);
  }
  id v6 = [*(id *)(a1 + 32) idsDestination];
  uint64_t v7 = [v6 name];

  uint64_t v8 = *(void **)(*(void *)(a1 + 40) + 320);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100045768;
  v10[3] = &unk_10072F6E8;
  id v11 = v7;
  id v9 = v7;
  [v8 sendRemoteRegistrationRequestResult:a2 forHandle:v9 completion:v10];
}

void sub_100045768(uint64_t a1, uint64_t a2)
{
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Finished sending device registration result response to handle %@, with error %@", (uint8_t *)&v6, 0x16u);
  }
}

void sub_100045C70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose((const void *)(v37 - 256), 8);
  _Block_object_dispose((const void *)(v37 - 208), 8);
  _Block_object_dispose((const void *)(v37 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_100045CB4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  __int16 v8 = *(void **)(*(void *)(a1 + 32) + 432);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_100045D9C;
  void v12[3] = &unk_10072F710;
  id v9 = *(id *)(a1 + 40);
  long long v16 = *(_OWORD *)(a1 + 48);
  id v14 = v6;
  id v15 = v7;
  id v13 = v9;
  id v10 = v6;
  id v11 = v7;
  [v8 familyMembersWithCachePolicy:0 completion:v12];
}

void sub_100045D9C(void *a1, void *a2)
{
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v3 = a2;
  id v4 = [v3 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v19;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v19 != v6) {
          objc_enumerationMutation(v3);
        }
        __int16 v8 = *(void **)(*((void *)&v18 + 1) + 8 * i);
        id v9 = objc_msgSend(v8, "appleID", (void)v18);
        id v10 = (void *)a1[4];
        id v11 = v9;
        id v12 = v10;
        if (v11 == v12)
        {
        }
        else
        {
          id v13 = v12;
          if (v11) {
            BOOL v14 = v12 == 0;
          }
          else {
            BOOL v14 = 1;
          }
          if (v14)
          {

LABEL_15:
            long long v16 = [v8 appleIDAliases];
            unsigned int v17 = [v16 containsObject:a1[4]];

            if (!v17) {
              goto LABEL_17;
            }
            goto LABEL_16;
          }
          unsigned __int8 v15 = [v11 isEqualToString:v12];

          if ((v15 & 1) == 0) {
            goto LABEL_15;
          }
        }
LABEL_16:
        objc_storeStrong((id *)(*(void *)(a1[7] + 8) + 40), v8);
LABEL_17:
        if ([v8 isMe]) {
          objc_storeStrong((id *)(*(void *)(a1[8] + 8) + 40), v8);
        }
        if (*(void *)(*(void *)(a1[8] + 8) + 40) && *(void *)(*(void *)(a1[7] + 8) + 40)) {
          goto LABEL_23;
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }
    while (v5);
  }
LABEL_23:

  (*(void (**)(void))(a1[6] + 16))();
}

void sub_100045F9C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  __int16 v8 = [*(id *)(a1 + 32) accountIdentifier];
  if (!v8)
  {
    long long v21 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      long long v22 = *(void **)(a1 + 32);
      int v24 = 138412290;
      BOOL v25 = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Error: cannot fetch account users for a nil account defined on %@", (uint8_t *)&v24, 0xCu);
    }

    goto LABEL_10;
  }
  id v9 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) altDSID];
  if (!v9)
  {
    id v10 = [*(id *)(*(void *)(a1 + 40) + 48) accountUserForAccountWithIdentifier:v8 handle:*(void *)(a1 + 48)];
    id v9 = [v10 altDSID];
    id v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      int v24 = 138412802;
      BOOL v25 = v10;
      __int16 v26 = 2112;
      uint64_t v27 = v12;
      __int16 v28 = 2112;
      id v29 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Found account user %@ for configuration %@ with altDSID %@", (uint8_t *)&v24, 0x20u);
    }

    if (!v9)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v23 = *(void **)(a1 + 32);
        int v24 = 138412290;
        BOOL v25 = v23;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Error: cannot fetch account users for a nil altDSID defined on %@", (uint8_t *)&v24, 0xCu);
      }

LABEL_10:
      v7[2](v7, v6, 0);
      goto LABEL_11;
    }
  }
  uint64_t v13 = [*(id *)(*(void *)(a1 + 40) + 48) accountUserWithAltDSID:v9 accountIdentifier:v8];
  uint64_t v14 = *(void *)(*(void *)(a1 + 64) + 8);
  unsigned __int8 v15 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = v13;

  long long v16 = *(void **)(*(void *)(a1 + 40) + 48);
  unsigned int v17 = PKCurrentUserAltDSID();
  uint64_t v18 = [v16 accountUserWithAltDSID:v17 accountIdentifier:v8];
  uint64_t v19 = *(void *)(*(void *)(a1 + 72) + 8);
  long long v20 = *(void **)(v19 + 40);
  *(void *)(v19 + 40) = v18;

  v7[2](v7, v6, 0);
LABEL_11:
}

void sub_10004623C(void *a1)
{
  id v2 = [objc_alloc((Class)PKSharingIDSManagerHandlerDetails) initWithFamilyMember:*(void *)(*(void *)(a1[5] + 8) + 40) accountUser:*(void *)(*(void *)(a1[6] + 8) + 40)];
  id v3 = [objc_alloc((Class)PKSharingIDSManagerHandlerDetails) initWithFamilyMember:*(void *)(*(void *)(a1[7] + 8) + 40) accountUser:*(void *)(*(void *)(a1[8] + 8) + 40)];
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412546;
    id v6 = v2;
    __int16 v7 = 2112;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Found currentUserDetails: %@, handleUserDetails: %@", (uint8_t *)&v5, 0x16u);
  }

  (*(void (**)(void))(a1[4] + 16))();
}

void sub_100046494(uint64_t a1)
{
  sub_1000464E0(*(void *)(a1 + 32));
  [*(id *)(a1 + 32) _updateQuickActions];
}

void sub_1000464E0(uint64_t a1)
{
  if (a1)
  {
    id v1 = +[NSDistributedNotificationCenter defaultCenter];
    [v1 postNotificationName:PKPassLibraryRelevantPassesDidChangeNotification object:0 userInfo:0];
  }
}

uint64_t sub_1000466E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100046850(uint64_t a1)
{
  return (*(uint64_t (**)(void, BOOL))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32) != 0);
}

void sub_100046940(id a1, BOOL a2)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Presented continuity view", v3, 2u);
  }
}

id *sub_100046B50(id *result)
{
  if (result)
  {
    id v1 = result;
    id v2 = PKPassKitCoreBundle();
    id v3 = [v2 bundlePath];
    +[CLLocationManager resetLocationAuthorizationForBundleId:0 orBundlePath:v3];

    [v1 resetApplePayWithType:1 diagnosticReason:@"Passbook deleted."];
    [v1[41] clearRelevantCardItems];
    id v4 = v1[78];
    return (id *)_[v4 removeAllPassSignalsWithCompletion:&stru_10072F8A8];
  }
  return result;
}

void sub_100046BF0(uint64_t a1)
{
}

void sub_100046BF8(uint64_t a1)
{
  if (a1)
  {
    id v1 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Notifying SystemHealthManager of fail-forward", buf, 2u);
    }

    id v2 = objc_opt_new();
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_10004BBC8;
    v3[3] = &unk_10072E570;
    id v4 = &stru_10072FC90;
    [v2 postComponentStatusEventFor:7 status:2 withReply:v3];
  }
}

void sub_100046CE8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = PKLogFacilityTypeGetObject();
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v6 = 138412290;
      id v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to un-suspend passes from Lost Mode. Asking server for latest versions. Error: %@", (uint8_t *)&v6, 0xCu);
    }

    [*(id *)(*(void *)(a1 + 32) + 96) initiateDevicePassesDownload];
  }
  else
  {
    if (v5)
    {
      LOWORD(v6) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Completed FMDFMIP lost mode exit.", (uint8_t *)&v6, 2u);
    }

    PKSetNeedsLostModeExitAuth();
  }
}

void sub_100046DF0(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v3 = a2;
    sub_1000374EC(a1);
    xpc_object_t xdict = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(xdict, "Name", (const char *)[PKPassLibraryCanAddPassChangeNotification UTF8String]);
    [*(id *)(a1 + 512) sendEvent:xdict completion:v3];
  }
}

uint64_t sub_100047368(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    id v11 = v3;
    BOOL v5 = [*(id *)(a1 + 32) serialNumber];
    int v6 = [v11 associatedPassSerialNumber];
    if ([v5 isEqualToString:v6])
    {
      id v7 = [*(id *)(a1 + 32) passTypeIdentifier];
      id v8 = [v11 associatedPassTypeIdentifier];
      unsigned int v9 = [v7 isEqualToString:v8];

      id v4 = v11;
      if (!v9) {
        goto LABEL_7;
      }
      id v3 = (id)(*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    else
    {
    }
    id v4 = v11;
  }
LABEL_7:
  return _objc_release_x1(v3, v4);
}

void sub_10004779C(id a1, BOOL a2)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Presented continuity view", v3, 2u);
  }
}

void sub_1000478DC(uint64_t a1)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
    do
    {
      int v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        objc_msgSend(*(id *)(*(void *)(a1 + 40) + 32), "deleteCardWithUniqueID:forReason:withDiagnosticReason:", *(void *)(*((void *)&v7 + 1) + 8 * (void)v6), 6, @"Database marked for deletion", (void)v7);
        int v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
    }
    while (v4);
  }
}

void sub_100047A80(uint64_t a1)
{
  sub_1000388F4(*(void *)(a1 + 32), *(void *)(a1 + 40) == 2, 0);
}

id sub_100047B44(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 360) updateContactlessPassesAvailability];
  [*(id *)(*(void *)(a1 + 32) + 160) expressPassConfigurationsChanged];
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = *(void **)(*(void *)(a1 + 32) + 56);
  return _[v3 updateUserNotificationsForUpdatedExpressPassConfigurations:v2];
}

id sub_100047D20(uint64_t a1, void *a2)
{
  return _[a2 sendDidUpdateDefaultPaymentPassWithUniqueIdentifier:*(void *)(a1 + 32)];
}

id sub_100047F18(uint64_t a1, uint64_t a2)
{
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 134217984;
    uint64_t v7 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Device Registration result was: %lu", (uint8_t *)&v6, 0xCu);
  }

  sub_100046DF0(*(void *)(a1 + 32), 0);
  return [*(id *)(*(void *)(a1 + 32) + 624) donateAllPassSignalsIfNeccessaryWithCompletion:&stru_10072F860];
}

void sub_100047FEC(id a1, NSError *a2)
{
  id v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    uint64_t v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "All pass signals donated with error: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1000481C0(id a1, NSError *a2)
{
  id v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    uint64_t v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "All pass signals removed with error: %@", (uint8_t *)&v4, 0xCu);
  }
}

id sub_100048314(uint64_t a1)
{
  if (a1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&unk_100808AB8);
    if (qword_100808AC0 && [(id)qword_100808AC0 count]) {
      id v1 = [(id)qword_100808AC0 copy];
    }
    else {
      id v1 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_100808AB8);
  }
  else
  {
    id v1 = 0;
  }
  return v1;
}

id sub_100048394(uint64_t a1, void *a2)
{
  return _[a2 sendDiscoveryArticleLayoutsUpdated:*(void *)(a1 + 32)];
}

id sub_10004844C(uint64_t a1, void *a2)
{
  return [a2 completedCTAForItem:*(void *)(a1 + 32)];
}

id sub_100048504(uint64_t a1, void *a2)
{
  return [a2 dialogRequestsChangedForPlacement:*(void *)(a1 + 32)];
}

void sub_100048558(id a1, id a2, BOOL *a3)
{
}

id sub_1000489A8(uint64_t a1, void *a2)
{
  return _[a2 sendSharesDidUpdateWithPaymentPassWithUniqueIdentifier:*(void *)(a1 + 32)];
}

void sub_100048DA4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "User declined to file a radar.", buf, 2u);
    }
  }
  else
  {
    if ([*(id *)(a1 + 32) isServerGenerated]) {
      CFStringRef v5 = @"Server Generated Wallet Bug: \"%@\"";
    }
    else {
      CFStringRef v5 = @"Generated Wallet Bug: \"%@\"";
    }
    +[NSString stringWithFormat:](NSString, "stringWithFormat:", v5, *(void *)(a1 + 40));
    id v12 = (id)objc_claimAutoreleasedReturnValue();
    if ([*(id *)(a1 + 32) isServerGenerated]) {
      CFStringRef v6 = @"[Please enter a brief description of what you were doing]\n\nServer Generation Reason: %@";
    }
    else {
      CFStringRef v6 = @"[Please enter a brief description of what you were doing]\n\nGeneration Reason: %@";
    }
    uint64_t v7 = +[NSMutableString stringWithFormat:](NSMutableString, "stringWithFormat:", v6, *(void *)(a1 + 40));
    long long v8 = [*(id *)(a1 + 32) relatedRadar];

    if (v8)
    {
      long long v9 = [*(id *)(a1 + 32) relatedRadar];
      [v7 appendFormat:@"\nRelated Radar: %@\n", v9];
    }
    long long v10 = PKCreateTapToRadarURL();
    id v11 = +[LSApplicationWorkspace defaultWorkspace];
    [v11 openURL:v10 configuration:0 completionHandler:0];
  }
}

id sub_10004901C(uint64_t a1, void *a2)
{
  return _[a2 sendDidUpdateApplicationMessages:*(void *)(a1 + 32)];
}

id sub_100049104(void *a1, void *a2)
{
  return _[a2 sendPassWithUniqueIdentifier:a1[4] didUpdateTiles:a1[5] forContext:a1[6]];
}

void sub_1000491C4(uint64_t a1)
{
  if ([*(id *)(a1 + 32) count])
  {
    id v3 = *(void **)(a1 + 32);
    uint64_t v2 = *(void *)(a1 + 40);
    sub_100049210(v2, v3);
  }
}

void sub_100049210(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (!a1)
  {
LABEL_6:

    return;
  }
  if (v3)
  {
    CFStringRef v5 = PDDefaultQueue();
    PDWakePassbookInBackground();

    CFStringRef v6 = sub_10004960C(a1);
    if ([v6 count])
    {
      uint64_t v7 = [*(id *)(a1 + 48) effectiveCatalog];
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      v10[2] = sub_1000496AC;
      v10[3] = &unk_10072F988;
      id v11 = v4;
      id v12 = v7;
      id v8 = v7;
      long long v9 = objc_retainBlock(v10);
      sub_100049380(a1, v9, v6);
    }
    goto LABEL_6;
  }
  __break(1u);
}

void sub_100049380(uint64_t a1, void *a2, void *a3)
{
  CFStringRef v5 = a2;
  id v6 = a3;
  uint64_t v7 = v6;
  if (a1 && v5 && [v6 count])
  {
    id v8 = objc_alloc_init((Class)NSMutableArray);
    id v9 = objc_alloc_init((Class)NSMutableArray);
    long long v35 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    id v10 = v7;
    id v11 = [v10 countByEnumeratingWithState:&v35 objects:v41 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v36;
      do
      {
        for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v36 != v13) {
            objc_enumerationMutation(v10);
          }
          unsigned __int8 v15 = *(void **)(*((void *)&v35 + 1) + 8 * i);
          if ([v15 willSanitizePasses]) {
            long long v16 = v9;
          }
          else {
            long long v16 = v8;
          }
          [v16 addObject:v15];
        }
        id v12 = [v10 countByEnumeratingWithState:&v35 objects:v41 count:16];
      }
      while (v12);
    }

    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    id v17 = v8;
    id v18 = [v17 countByEnumeratingWithState:&v31 objects:v40 count:16];
    if (v18)
    {
      id v19 = v18;
      uint64_t v20 = *(void *)v32;
      do
      {
        for (uint64_t j = 0; j != v19; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v32 != v20) {
            objc_enumerationMutation(v17);
          }
          v5[2](v5, *(void *)(*((void *)&v31 + 1) + 8 * (void)j));
        }
        id v19 = [v17 countByEnumeratingWithState:&v31 objects:v40 count:16];
      }
      while (v19);
    }

    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    id v22 = v9;
    id v23 = [v22 countByEnumeratingWithState:&v27 objects:v39 count:16];
    if (v23)
    {
      id v24 = v23;
      uint64_t v25 = *(void *)v28;
      do
      {
        for (k = 0; k != v24; k = (char *)k + 1)
        {
          if (*(void *)v28 != v25) {
            objc_enumerationMutation(v22);
          }
          v5[2](v5, *(void *)(*((void *)&v27 + 1) + 8 * (void)k));
        }
        id v24 = [v22 countByEnumeratingWithState:&v27 objects:v39 count:16];
      }
      while (v24);
    }
  }
}

id sub_10004960C(uint64_t a1)
{
  if (a1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&dword_100808950);
    if (qword_100808958 && [(id)qword_100808958 count]) {
      id v1 = [(id)qword_100808958 copy];
    }
    else {
      id v1 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&dword_100808950);
  }
  else
  {
    id v1 = 0;
  }
  return v1;
}

id sub_10004968C(void *a1, void *a2)
{
  return _[a2 sendPassAdded:a1[4] state:a1[5] catalog:a1[6]];
}

id sub_10004969C(void *a1, void *a2)
{
  return _[a2 sendPassUpdated:a1[4] state:a1[5] catalog:a1[6]];
}

id sub_1000496AC(uint64_t a1, void *a2)
{
  return _[a2 sendDynamicStatesUpdated:*(void *)(a1 + 32) catalog:*(void *)(a1 + 40)];
}

id sub_1000496B8(uint64_t a1, void *a2)
{
  return _[a2 sendPassRemoved:*(void *)(a1 + 32) catalog:*(void *)(a1 + 40)];
}

id sub_1000496C4(void *a1, void *a2)
{
  return _[a2 sendPassRecovered:a1[4] state:a1[5] catalog:a1[6]];
}

void sub_1000496D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (a1 && v3)
  {
    CFStringRef v5 = PDDefaultQueue();
    PDWakePassbookInBackground();

    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    id v6 = sub_10004960C(a1);
    id v7 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v13;
      do
      {
        id v10 = 0;
        do
        {
          if (*(void *)v13 != v9) {
            objc_enumerationMutation(v6);
          }
          objc_msgSend(*(id *)(*((void *)&v12 + 1) + 8 * (void)v10), "sendCatalogChanged:", v4, (void)v12);
          id v10 = (char *)v10 + 1;
        }
        while (v8 != v10);
        id v8 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v8);
    }

    id v11 = +[NSDistributedNotificationCenter defaultCenter];
    [v11 postNotificationName:PKPassLibraryCatalogDidChangeNotification object:0];
  }
}

void sub_10004983C(id a1, BOOL a2)
{
  if (!a2)
  {
    uint64_t v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Failed to update upgrade passcode policy after remove all secure element passes", v3, 2u);
    }
  }
}

void sub_1000498B0(void **a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained(a1 + 7);
  sub_100049900(WeakRetained, a1[5], a1[6]);
}

void sub_100049900(id *a1, void *a2, void *a3)
{
  id v29 = a2;
  id v27 = a3;
  if (a1)
  {
    CFStringRef v5 = [v29 creditDetails];
    long long v28 = [v5 installmentPlans];

    if ([v28 count])
    {
      long long v31 = [v29 accountIdentifier];
      uint64_t v25 = [v29 associatedPassUniqueID];
      __int16 v26 = [a1[6] transactionSourceIdentifiersForPassUniqueIdentifier:v25];
      long long v32 = [v26 anyObject];
      if (v32)
      {
        id v6 = [v27 creditDetails];
        id v24 = [v6 installmentPlans];

        id v7 = [v24 allObjects];
        long long v34 = objc_msgSend(v7, "pk_indexDictionaryByApplyingBlock:", &stru_10072FA10);

        objc_initWeak(&location, a1);
        long long v44 = 0u;
        long long v42 = 0u;
        long long v43 = 0u;
        long long v41 = 0u;
        id obj = v28;
        id v8 = [obj countByEnumeratingWithState:&v41 objects:v50 count:16];
        if (v8)
        {
          uint64_t v33 = *(void *)v42;
          do
          {
            id v35 = v8;
            for (uint64_t i = 0; i != v35; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v42 != v33) {
                objc_enumerationMutation(obj);
              }
              id v10 = *(void **)(*((void *)&v41 + 1) + 8 * i);
              id v11 = objc_msgSend(v10, "identifier", v24);
              long long v12 = [v34 objectForKey:v11];
              long long v13 = [v10 payments];
              long long v14 = [v12 payments];
              if ([v14 count])
              {
                long long v15 = objc_msgSend(v14, "pk_indexDictionaryByApplyingBlock:", &stru_10072FA50);
                v39[0] = _NSConcreteStackBlock;
                v39[1] = 3221225472;
                v39[2] = sub_100049E90;
                v39[3] = &unk_10072FA78;
                id v16 = v15;
                id v40 = v16;
                objc_msgSend(v13, "pk_objectsPassingTest:", v39);
                id v17 = (id)objc_claimAutoreleasedReturnValue();
              }
              else
              {
                id v18 = PKLogFacilityTypeGetObject();
                if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 138412290;
                  id v47 = v11;
                  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Updating all payment transactions for installment plan %@", buf, 0xCu);
                }

                id v17 = v13;
              }
              id v19 = [v17 count];
              uint64_t v20 = PKLogFacilityTypeGetObject();
              BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
              if (v19)
              {
                if (v21)
                {
                  *(_DWORD *)buf = 134218242;
                  id v47 = v19;
                  __int16 v48 = 2112;
                  uint64_t v49 = v11;
                  _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Creating or updating %ld payment transactions for installment plan %@", buf, 0x16u);
                }

                id v22 = a1[6];
                v36[0] = _NSConcreteStackBlock;
                v36[1] = 3221225472;
                v36[2] = sub_100049F68;
                v36[3] = &unk_10072FAA0;
                objc_copyWeak(&v38, &location);
                id v37 = v32;
                [v22 insertOrUpdateTransactionsForInstallmentPayments:v17 installmentPlan:v10 accountIdentifier:v31 transactionSourceIdentifier:v37 transactionProcessingBlock:v36];

                objc_destroyWeak(&v38);
              }
              else
              {
                if (v21)
                {
                  *(_DWORD *)buf = 138412290;
                  id v47 = v11;
                  _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "No changes to payment transactions for installment plan %@", buf, 0xCu);
                }
              }
            }
            id v8 = [obj countByEnumeratingWithState:&v41 objects:v50 count:16];
          }
          while (v8);
        }

        id v23 = [a1[6] installmentPlanTransactionsForTransactionSourceIdentifiers:v26];
        [a1[6] updateSuppressBehavior:1 forPaymentTransactions:v23 sourceIdentifier:v32];

        objc_destroyWeak(&location);
      }
    }
  }
}

void sub_100049E2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,id location)
{
}

NSCopying *__cdecl sub_100049E80(id a1, PKCreditInstallmentPlan *a2)
{
  return (NSCopying *)[(PKCreditInstallmentPlan *)a2 identifier];
}

NSCopying *__cdecl sub_100049E88(id a1, PKCreditInstallmentPlanPayment *a2)
{
  return (NSCopying *)[(PKCreditInstallmentPlanPayment *)a2 identifier];
}

uint64_t sub_100049E90(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = *(void **)(a1 + 32);
  CFStringRef v5 = [v3 identifier];
  id v6 = [v4 objectForKey:v5];

  if (v6)
  {
    id v7 = [v6 copy];
    id v8 = [v3 copy];
    [v7 setLineItems:0];
    [v7 setStatement:0];
    [v8 setLineItems:0];
    [v8 setStatement:0];
    uint64_t v9 = PKEqualObjects() ^ 1;
  }
  else
  {
    uint64_t v9 = 1;
  }

  return v9;
}

void sub_100049F68(uint64_t a1, void *a2)
{
  id v3 = (id *)(a1 + 40);
  id v4 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained(v3);
  [WeakRetained[10] processPaymentTransaction:v4 forTransactionSourceIdentifier:*(void *)(a1 + 32)];
}

id sub_10004A490(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  if (a1)
  {
    id v6 = *(void **)(a1 + 48);
    id v7 = a3;
    id v8 = [v6 passWithUniqueIdentifier:v5];
    id v9 = objc_alloc_init((Class)SBSApplicationShortcutItem);
    [v9 setLocalizedTitle:v7];

    [v9 setType:PKQuickActionOpenPassAction];
    uint64_t v14 = PKQuickActionPassUniqueIDKKey;
    id v15 = v5;
    id v10 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    [v9 setUserInfo:v10];

    if ([v8 passType] == (id)1)
    {
      id v11 = [objc_alloc((Class)SBSApplicationShortcutSystemIcon) initWithSystemImageName:@"creditcard"];
    }
    else
    {
      sub_10004A60C(a1, @"RelevantPass");
      id v11 = (id)objc_claimAutoreleasedReturnValue();
    }
    long long v12 = v11;
    [v9 setIcon:v11];
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

id sub_10004A60C(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v2 = a2;
    PKScreenScale();
    double v4 = v3;
    id v5 = PKPassKitUIBundle();
    uint64_t v6 = 2;
    if (v4 >= 3.0) {
      uint64_t v6 = 3;
    }
    id v7 = +[NSString stringWithFormat:@"%@@%dx", v2, v6];

    id v8 = [v5 pathForResource:v7 ofType:@"png"];

    id v9 = +[NSData dataWithContentsOfFile:v8];
    id v10 = [objc_alloc((Class)SBSApplicationShortcutCustomImageIcon) initWithImageData:v9 dataType:0 isTemplate:1];
  }
  else
  {
    id v10 = 0;
  }
  return v10;
}

uint64_t sub_10004A718(uint64_t result)
{
  if (*(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24))
  {
    int v1 = 1;
    atomic_compare_exchange_strong((atomic_uchar *volatile)(*(void *)(result + 32) + 11), (unsigned __int8 *)&v1, 2u);
    *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = v1 != 1 && v1 != 2;
  }
  return result;
}

uint64_t sub_10004A76C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (!*(void *)(v1 + 296))
  {
    uint64_t v2 = result;
    uint64_t v3 = [*(id *)(v1 + 32) catalogOfRecord];
    uint64_t v4 = *(void *)(v2 + 32);
    uint64_t v5 = *(void *)(v4 + 296);
    *(void *)(v4 + 296) = v3;
    return _objc_release_x1(v3, v5);
  }
  return result;
}

void sub_10004A7CC(id a1, NSSet *a2, NSError *a3)
{
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id obj = a2;
  id v3 = [(NSSet *)obj countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v19 = *(void *)v21;
    uint64_t v5 = PKPassdBundleIdentifier;
    uint64_t v6 = NSNumber_ptr;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v21 != v19) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(void **)(*((void *)&v20 + 1) + 8 * i);
        id v9 = objc_alloc((Class)v6[289]);
        id v10 = [v8 ownershipTokenIdentifier];
        id v11 = [v9 initWithIdentifier:v10 accessGroup:v5 serviceName:@"com.apple.passd.pass-ownership-token" type:1 invisible:0];

        long long v12 = [v11 objectForKey:kSecValueData];
        if (v12)
        {
          [v11 resetKeychainItem];
          long long v13 = v6;
          id v14 = objc_alloc((Class)v6[289]);
          id v15 = [v8 ownershipTokenIdentifier];
          id v16 = [v14 initWithIdentifier:v15 accessGroup:v5 serviceName:@"com.apple.passd.pass-ownership-token" type:1 invisible:1];

          id v17 = [v16 objectForKey:kSecValueData];
          if (!v17) {
            [v16 setObject:v12 forKey:kSecValueData];
          }

          uint64_t v6 = v13;
        }
      }
      id v4 = [(NSSet *)obj countByEnumeratingWithState:&v20 objects:v24 count:16];
    }
    while (v4);
  }
}

void sub_10004A9D0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  switch(a2)
  {
    case 0:
      id v4 = 0;
      uint64_t v5 = @"Invalid SE-SEP Pairing";
      CFStringRef v6 = @"invalid-pairing";
      goto LABEL_17;
    case 1:
      if (PKIsMac())
      {
        id v7 = [PDWalletUserNotification alloc];
        id v8 = PKLocalizedPaymentString(@"SECURE_ELEMENT_ACCESS_VIOLATION_PASSCODE_MAC");
        id v4 = [(PDGenericUserNotification *)v7 initWithMessage:v8];
      }
      else
      {
        id v4 = 0;
      }
      uint64_t v5 = @"Passcode Disabled";
      CFStringRef v6 = @"passcode-disabled";
      goto LABEL_17;
    case 2:
      id v10 = PKLocalizedPaymentString(@"SECURE_ELEMENT_ACCESS_VIOLATION_OWNERSHIP_LOST_MESSAGE");
      if ((a3 & 0xFFFFFFFFFFFFFFFELL) != 4) {
        goto LABEL_15;
      }
      id v11 = [*(id *)(*(void *)(a1 + 32) + 72) ownerUserUUID];
      uint64_t v12 = PKUserFullNameForUserUUID();
      if (v12)
      {
        long long v13 = (void *)v12;
        id v14 = PKLocalizedPaymentString(@"SECURE_ELEMENT_ACCESS_VIOLATION_OWNERSHIP_LOST_TITLE_USER_FORMAT", @"%@", v12);

        if (v14) {
          goto LABEL_16;
        }
      }
      else
      {
      }
LABEL_15:
      id v14 = PKLocalizedPaymentString(@"SECURE_ELEMENT_ACCESS_VIOLATION_OWNERSHIP_LOST_TITLE_GENERIC");
LABEL_16:
      id v4 = [(PDGenericUserNotification *)[PDWalletUserNotification alloc] initWithTitle:v14 message:v10];

      uint64_t v5 = @"Secure Element Ownership Lost";
      CFStringRef v6 = @"lost-ownership";
LABEL_17:
      id v17 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        sub_100514C5C((uint64_t)v5, v17);
      }

      CFStringRef v22 = @"reason";
      CFStringRef v23 = v6;
      id v18 = +[NSDictionary dictionaryWithObjects:&v23 forKeys:&v22 count:1];
      PKAnalyticsSendEvent();

      uint64_t v19 = PDWalletUserNotificationSecureElementAccessLost;
      [*(id *)(*(void *)(a1 + 32) + 56) removeUserNotificationWithIdentifier:PDWalletUserNotificationSecureElementAccessLost];
      [(PDUserNotification *)v4 setNotificationIdentifier:v19];
      [*(id *)(*(void *)(a1 + 32) + 56) insertUserNotification:v4];
      uint64_t v20 = *(void *)(a1 + 32);
      if (v20) {
        sub_1000415B4(v20, 0, v5, 0, 5);
      }
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21) {
        (*(void (**)(uint64_t, void))(v21 + 16))(v21, 0);
      }

      return;
    case 3:
      id v15 = [PDWalletUserNotification alloc];
      id v16 = PKLocalizedPaymentString(@"SECURE_ELEMENT_ACCESS_VIOLATION_AUTOMATIC_LOGIN");
      id v4 = [(PDGenericUserNotification *)v15 initWithMessage:v16];

      uint64_t v5 = @"Automatic Login Enabled";
      CFStringRef v6 = @"autologin-enabled";
      goto LABEL_17;
    case 4:
      id v4 = 0;
      uint64_t v5 = @"Secure Element Hardware Changed";
      CFStringRef v6 = @"se-hardware-change";
      goto LABEL_17;
    default:
      id v4 = 0;
      uint64_t v5 = 0;
      CFStringRef v6 = &stru_10075AAD8;
      goto LABEL_17;
  }
}

void sub_10004AD0C(uint64_t a1, char a2)
{
  id v4 = PDDefaultQueue();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10004ADD0;
  v8[3] = &unk_10072FB58;
  char v12 = a2;
  id v5 = *(id *)(a1 + 32);
  id v7 = *(void **)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  id v9 = v5;
  uint64_t v11 = v6;
  id v10 = v7;
  dispatch_async(v4, v8);
}

uint64_t sub_10004ADD0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
    return v2();
  }
  else
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Secure Element access is unknown!", v5, 2u);
    }

    uint64_t result = *(void *)(a1 + 40);
    if (result) {
      return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, 0);
    }
  }
  return result;
}

void sub_10004AE94(uint64_t a1, uint64_t a2)
{
  id v4 = PDDefaultQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004AF5C;
  block[3] = &unk_10072FBA8;
  uint64_t v8 = a2;
  id v6 = *(id *)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  long long v9 = *(_OWORD *)(a1 + 48);
  dispatch_async(v4, block);
}

uint64_t sub_10004AF5C(void *a1)
{
  uint64_t v2 = a1[6];
  if (v2 != 2)
  {
    if (v2 == 1)
    {
      id v3 = PKLogFacilityTypeGetObject();
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      LOWORD(v10) = 0;
      id v4 = "Secure Element is paired.";
      id v5 = v3;
      uint32_t v6 = 2;
    }
    else
    {
      id v3 = PKLogFacilityTypeGetObject();
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_15;
      }
      CFStringRef v9 = @"unknown";
      if (v2 == 3) {
        CFStringRef v9 = @"PKSecureElementPairingStateRestricted";
      }
      if (!v2) {
        CFStringRef v9 = @"PKSecureElementPairingStateUnknown";
      }
      int v10 = 138543362;
      CFStringRef v11 = v9;
      id v4 = "Secure Element is %{public}@ - assuming paired.";
      id v5 = v3;
      uint32_t v6 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v10, v6);
LABEL_15:

    uint64_t result = a1[4];
    if (result) {
      return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, 1);
    }
    return result;
  }
  id v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Secure Element is unpaired.", (uint8_t *)&v10, 2u);
  }

  return (*(uint64_t (**)(void))(a1[5] + 16))();
}

uint64_t sub_10004B0FC(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Secure Element is not owned by current user - aborting validation of access policies.", v4, 2u);
  }

  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, 1);
  }
  return result;
}

void sub_10004B184(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = PDDefaultQueue();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10004B238;
  v7[3] = &unk_10072E198;
  uint64_t v5 = *(void *)(a1 + 32);
  id v8 = v3;
  uint64_t v9 = v5;
  id v6 = v3;
  dispatch_async(v4, v7);
}

void sub_10004B238(uint64_t a1)
{
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (!v3)
  {
LABEL_13:

    return;
  }
  id v4 = v3;
  uint64_t v5 = *(void *)v17;
LABEL_3:
  uint64_t v6 = 0;
  while (1)
  {
    if (*(void *)v17 != v5) {
      objc_enumerationMutation(v2);
    }
    id v7 = *(void **)(*((void *)&v16 + 1) + 8 * v6);
    id v8 = [v7 lifecycleState];
    unsigned __int8 v9 = [v7 isLocked];
    if (v9)
    {

LABEL_21:
      uint64_t v12 = *(void *)(a1 + 40);
      long long v13 = *(void **)(v12 + 72);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      v14[2] = sub_10004B3D0;
      v14[3] = &unk_10072FBF8;
      void v14[4] = v12;
      unsigned __int8 v15 = v9;
      [v13 pairingStateWithCompletion:v14];
      return;
    }
    if (v8 == (id)15 || v8 == (id)23) {
      break;
    }
    if (v4 == (id)++v6)
    {
      id v4 = [v2 countByEnumeratingWithState:&v16 objects:v20 count:16];
      if (v4) {
        goto LABEL_3;
      }
      goto LABEL_13;
    }
  }

  if (v9) {
    goto LABEL_21;
  }
  if (v8 == (id)15 || v8 == (id)23) {
    goto LABEL_21;
  }
}

void sub_10004B3D0(uint64_t a1, uint64_t a2)
{
  id v4 = PDDefaultQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004B470;
  block[3] = &unk_10072E120;
  void block[4] = *(void *)(a1 + 32);
  void block[5] = a2;
  char v6 = *(unsigned char *)(a1 + 40);
  dispatch_async(v4, block);
}

void *sub_10004B470(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[5];
  if (v2 == 2)
  {
    if (!*((unsigned char *)result + 48)) {
      return result;
    }
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "WARNING: orphaned locked applets detected in unpaired SE...performing temporary workaround.", v5, 2u);
    }
    uint64_t v4 = 1;
  }
  else
  {
    if (v2 != 1) {
      return result;
    }
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_100514CD4();
    }
    uint64_t v4 = 0;
  }

  return [*(id *)(v1[4] + 72) markAllAppletsForDeletionWithExternalAuthorization:0 obliterate:v4 completion:0];
}

double sub_10004B550(uint64_t a1, void *a2)
{
  if (!a1) {
    return 0.0;
  }
  id v2 = a2;
  id v3 = +[NSUserDefaults standardUserDefaults];
  uint64_t v4 = [v3 objectForKey:v2];

  if (v4 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    uint64_t v5 = +[NSDate date];
    [v5 timeIntervalSinceDate:v4];
    double v7 = v6;
  }
  else
  {
    double v7 = 1.79769313e308;
  }

  return v7;
}

void sub_10004B614(uint64_t a1)
{
  if (a1)
  {
    id v1 = [*(id *)(a1 + 48) numberOfRealPasses];
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      id v8 = v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Aggregate dictionary pass count log: %lu", buf, 0xCu);
    }

    id v3 = +[NSNumber numberWithUnsignedInteger:v1, @"passcount"];
    double v6 = v3;
    uint64_t v4 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
    PKAnalyticsSendEvent();
  }
}

void sub_10004B738(uint64_t a1, void *a2)
{
  id v3 = a2;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_10004B7E4;
  v5[3] = &unk_10072E238;
  id v6 = *(id *)(a1 + 32);
  id v7 = v3;
  uint64_t v8 = *(void *)(a1 + 40);
  id v4 = v3;
  sub_100037830(v5);
}

id sub_10004B7E4(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10004B858;
  v3[3] = &unk_10072FC48;
  id v1 = *(void **)(a1 + 40);
  void v3[4] = *(void *)(a1 + 48);
  return [v1 enumerateObjectsUsingBlock:v3];
}

void sub_10004B858(uint64_t a1, void *a2)
{
  id v7 = a2;
  id v3 = [v7 passInformation];
  id v4 = (char *)[v3 cardType];

  if ((unint64_t)(v4 - 1) <= 1)
  {
    uint64_t v5 = [v7 passUniqueIdentifier];
    id v6 = [*(id *)(*(void *)(a1 + 32) + 48) notificationServiceOfType:0 forPassWithUniqueIdentifier:v5];
    [*(id *)(*(void *)(a1 + 32) + 88) requestUpdatesFromNotificationService:v6 passUniqueIdenitifer:v5 forceUpdate:1];
  }
}

void sub_10004B914(id a1)
{
  id v1 = +[NSMutableDictionary dictionary];
  [v1 setObject:&__kCFBooleanTrue forKeyedSubscript:PKUserNotificationDontDismissOnUnlock];
  [v1 setObject:&__kCFBooleanTrue forKeyedSubscript:PKUserNotificationAllowMenuButtonDismissal];
  PDDeviceSpecificLocalizedStringKeyForKey();
  id v2 = (NSString *)objc_claimAutoreleasedReturnValue();
  id v3 = PKLocalizedPaymentString(v2);
  [v1 setObject:v3 forKeyedSubscript:kCFUserNotificationAlertHeaderKey];

  PDDeviceSpecificLocalizedStringKeyForKey();
  id v4 = (NSString *)objc_claimAutoreleasedReturnValue();
  uint64_t v5 = PKLocalizedPaymentString(v4);
  [v1 setObject:v5 forKeyedSubscript:kCFUserNotificationAlertMessageKey];

  id v6 = PKLocalizedPaymentString(@"FAIL_FORWARD_LEARN_MORE_BUTTON");
  [v1 setObject:v6 forKeyedSubscript:kCFUserNotificationOtherButtonTitleKey];

  id v7 = PKLocalizedPaymentString(@"FAIL_FORWARD_DONE_BUTTON");
  [v1 setObject:v7 forKeyedSubscript:kCFUserNotificationDefaultButtonTitleKey];

  uint64_t v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned __int8 v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Notifying user of fail-forward", v9, 2u);
  }

  +[PKUserNotificationAgent presentNotificationWithParameters:v1 responseHandler:&stru_10072FCD0];
}

void sub_10004BACC(id a1, __CFUserNotification *a2, unint64_t a3)
{
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 134217984;
    unint64_t v8 = a3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Notified user of fail-forward with response: %lu", (uint8_t *)&v7, 0xCu);
  }

  if (a3 == 2)
  {
    uint64_t v5 = +[NSURL URLWithString:PKFailForwardKnowledgeBaseURL];
    id v6 = +[LSApplicationWorkspace defaultWorkspace];
    [v6 openURL:v5 configuration:0 completionHandler:0];
  }
}

void sub_10004BBC8(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67240450;
    v7[1] = a2;
    __int16 v8 = 2114;
    id v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SystemHealthManager notified of fail-forward with success:%{public}d error:%{public}@", (uint8_t *)v7, 0x12u);
  }

  if ((a2 & 1) == 0) {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_10004BCA8(uint64_t a1, void *a2)
{
  id v6 = a2;
  if ((PKPassSupportsSyncing() & 1) == 0)
  {
    id v3 = *(void **)(a1 + 32);
    id v4 = [v6 stringByAppendingPathExtension:PKRawPassExtension];
    id v5 = [v3 URLByAppendingPathComponent:v4 isDirectory:1];

    PKExcludeFileURLFromBackup();
    ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  }
}

void sub_10004BD70(id a1, NSString *a2, unint64_t a3, BOOL *a4)
{
  id v4 = a2;
  id v5 = PKHomeDirectoryPath();
  id v7 = [v5 stringByAppendingPathComponent:v4];

  id v6 = +[NSFileManager defaultManager];
  [v6 removeItemAtPath:v7 error:0];
}

uint64_t sub_10004BDF8(uint64_t a1, unint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  if (v5)
  {
    id v10 = v5;
    id v5 = [*(id *)(a1 + 32) indexOfObject:v5];
    id v6 = v10;
    if (v5 != (id)0x7FFFFFFFFFFFFFFFLL && v5 != (id)a2)
    {
      id v8 = v5;
      id v5 = [*(id *)(a1 + 32) count];
      id v6 = v10;
      if ((a2 & 0x8000000000000000) == 0 && (unint64_t)v5 > a2)
      {
        [*(id *)(a1 + 32) removeObjectAtIndex:v8];
        id v5 = [*(id *)(a1 + 32) insertObject:v10 atIndex:a2];
        id v6 = v10;
      }
    }
  }
  return _objc_release_x1(v5, v6);
}

id sub_10004BF54(uint64_t a1, void *a2)
{
  return _[a2 sendDidReceivePendingProvisioningUpdate:*(void *)(a1 + 32)];
}

Class sub_10004C568()
{
  if (qword_100808B00 != -1) {
    dispatch_once(&qword_100808B00, &stru_10072FD80);
  }
  Class result = objc_getClass("BFFSettingsManager");
  qword_100808AF0 = (uint64_t)result;
  off_100803F78 = (uint64_t (*)())sub_10004C5CC;
  return result;
}

id sub_10004C5CC()
{
  return (id)qword_100808AF0;
}

void sub_10004C5D8(id a1)
{
  qword_100808AF8 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/SetupAssistant.framework/SetupAssistant", 2);
}

Class sub_10004C604()
{
  if (qword_100808B18 != -1) {
    dispatch_once(&qword_100808B18, &stru_10072FDA0);
  }
  Class result = objc_getClass("FKPaymentTransactionProcessor");
  qword_100808B08 = (uint64_t)result;
  off_100803F80 = (uint64_t (*)())sub_10004C668;
  return result;
}

id sub_10004C668()
{
  return (id)qword_100808B08;
}

void sub_10004C674(id a1)
{
  qword_100808B10 = (uint64_t)dlopen("/System/Library/Frameworks/FinanceKit.framework/FinanceKit", 2);
}

uint64_t sub_10004C6A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t sub_10004C6B0()
{
  if (qword_100808B00 != -1) {
    dispatch_once(&qword_100808B00, &stru_10072FD80);
  }
  uint64_t result = *(void *)dlsym((void *)qword_100808AF8, "BFFBuddyDidRestoreSafeHavenNotification");
  qword_100808B20 = result;
  off_100803F88 = sub_100021550;
  return result;
}

uint64_t sub_10004C720()
{
  if (qword_100808B00 != -1) {
    dispatch_once(&qword_100808B00, &stru_10072FD80);
  }
  uint64_t result = *(void *)dlsym((void *)qword_100808AF8, "BYSetupAssistantExitedDarwinNotification");
  qword_100808B28 = result;
  off_100803F90 = sub_100021544;
  return result;
}

uint64_t sub_10004C790()
{
  if (qword_100808B00 != -1) {
    dispatch_once(&qword_100808B00, &stru_10072FD80);
  }
  v0 = (uint64_t (*)())dlsym((void *)qword_100808AF8, "BYSetupAssistantHasCompletedInitialRun");
  off_100803F98 = v0;
  return v0();
}

void sub_10004C7F8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_10004D0D0(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = PKSharedWebServiceContextPath();
  [v2 archiveAtPath:v3];

  [*(id *)(*(void *)(a1 + 40) + 16) noteWebServiceDidChange];
  id v4 = +[NSDistributedNotificationCenter defaultCenter];
  [v4 postNotificationName:PDSharedPaymentWebServiceDidChangeNotification object:0];
}

void sub_10004D200(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  PKBackgroundWebServiceContextPath();
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  [v1 archiveAtPath:v2];
}

void sub_10004DB08(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = +[NSString stringWithUTF8String:kNSURLSessionLaunchOnDemandNotificationName];
  PDXPCEventStreamRegisterObserver(v2, v3, *(void **)(*(void *)(a1 + 32) + 128));

  PDDefaultQueue();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  PDScheduledActivityClientRegister();
}

id sub_10004DD44(uint64_t a1)
{
  return [*(id *)(a1 + 32) _updateWebServiceConfigurationWithCompletion:*(void *)(a1 + 40)];
}

void sub_10004DE18(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [v4 localizedDescription];
    int v8 = 138412290;
    uint64_t v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Configure payment session complete with error: %@", (uint8_t *)&v8, 0xCu);
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7) {
    (*(void (**)(void))(v7 + 16))();
  }
}

void sub_10004DFDC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [v4 localizedDescription];
    int v8 = 138412290;
    uint64_t v9 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Configure payment session complete with error: %@", (uint8_t *)&v8, 0xCu);
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7) {
    (*(void (**)(void))(v7 + 16))();
  }
}

void sub_10004E450(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    id v2 = [*(id *)(a1 + 32) sharedWebService];
    (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
  }
}

void sub_10004E594(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    uint64_t v32 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Deleting shared webservice (reason: '%@')", buf, 0xCu);
  }

  id v4 = [*(id *)(a1 + 40) sharedWebService];
  id v5 = [v4 sessionConfiguration];
  id v6 = [v5 URLCache];
  [v6 removeAllCachedResponses];

  [*(id *)(*(void *)(a1 + 40) + 112) clearPaymentSetupFeatures];
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  id v7 = *(id *)(*(void *)(a1 + 40) + 168);
  id v8 = [v7 countByEnumeratingWithState:&v26 objects:v30 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v27;
    do
    {
      CFStringRef v11 = 0;
      do
      {
        if (*(void *)v27 != v10) {
          objc_enumerationMutation(v7);
        }
        [*(id *)(*((void *)&v26 + 1) + 8 * (void)v11) setCancelled:1];
        CFStringRef v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id v9 = [v7 countByEnumeratingWithState:&v26 objects:v30 count:16];
    }
    while (v9);
  }

  [*(id *)(a1 + 40) unscheduleDeviceCheckIn];
  [*(id *)(a1 + 40) unscheduleDeviceUpgradeTaskActivity];
  [v4 invalidateBackgroundSession];
  uint64_t v12 = [v4 context];
  unsigned int v13 = [v12 isRegistered];

  if (v13) {
    [v4 diagnosticSessionWithReason:*(void *)(a1 + 32) sessionHandler:&stru_10072FE30];
  }
  else {
    [v4 invalidate];
  }
  id v14 = +[NSFileManager defaultManager];
  unsigned __int8 v15 = PKSharedWebServiceContextPath();
  [v14 removeItemAtPath:v15 error:0];

  long long v16 = +[NSFileManager defaultManager];
  long long v17 = PKBackgroundWebServiceContextPath();
  [v16 removeItemAtPath:v17 error:0];

  long long v18 = [*(id *)(a1 + 40) sharedWebService];

  if (v18)
  {
    objc_msgSend(*(id *)(*(void *)(a1 + 40) + 8), "unregisterConsumer:");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Recreating shared webservice", buf, 2u);
    }

    long long v19 = [[PDPaymentWebServiceTargetDevice alloc] initWithDataSource:*(void *)(a1 + 40)];
    uint64_t v20 = PKSharedWebServiceContextPath();
    uint64_t v21 = +[PKPaymentWebServiceContext contextWithArchive:v20];

    id v22 = [objc_alloc((Class)PKPaymentWebService) initWithContext:v21 targetDevice:v19 archiver:*(void *)(*(void *)(a1 + 40) + 48) tapToRadarDelegate:*(void *)(*(void *)(a1 + 40) + 184)];
    [v22 configurePaymentServiceWithCompletion:0];
    [*(id *)(a1 + 40) setSharedWebService:v22];
    CFStringRef v23 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10004EA4C;
    block[3] = &unk_10072E1E8;
    void block[4] = *(void *)(a1 + 40);
    dispatch_async(v23, block);
  }
  +[PKAccountAttestationRequest removeLocalAccountAttesationData];
  [*(id *)(a1 + 40) noteWebServiceDidChange];
  id v24 = +[NSDistributedNotificationCenter defaultCenter];
  [v24 postNotificationName:PDSharedPaymentWebServiceDidChangeNotification object:0];
}

void sub_10004E984(id a1, PKWebService *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10004EA10;
  v3[3] = &unk_10072FE58;
  id v4 = a2;
  id v2 = v4;
  [(PKWebService *)v2 unregisterDeviceWithCompletion:v3];
}

id sub_10004EA10(uint64_t a1)
{
  PKSetUserHasDisabledPeerPayment();
  id v2 = *(void **)(a1 + 32);
  return [v2 invalidate];
}

id sub_10004EA4C(uint64_t a1)
{
  return objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "registerConsumer:");
}

void sub_10004EC54(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 40) sharedWebService];
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 64);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_10004ED40;
  v9[3] = &unk_10072FE80;
  id v6 = *(id *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  id v10 = v6;
  uint64_t v11 = v7;
  id v12 = v2;
  id v13 = *(id *)(a1 + 72);
  id v8 = v2;
  [v8 submitVerificationCode:v3 verificationData:v4 forPass:v5 completion:v9];
}

void sub_10004ED40(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  id v9 = PKLogFacilityTypeGetObject();
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (a2 == 1)
  {
    if (v10)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Verification code accepted", buf, 2u);
    }

    if (v7)
    {
      uint64_t v11 = *(void *)(a1 + 40);
      id v12 = *(NSObject **)(v11 + 128);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10004EED0;
      block[3] = &unk_10072E238;
      void block[4] = v11;
      id v17 = *(id *)(a1 + 48);
      id v18 = v7;
      dispatch_async(v12, block);
    }
    uint64_t v13 = *(void *)(a1 + 56);
    if (v13)
    {
      id v14 = *(void (**)(void))(v13 + 16);
LABEL_12:
      v14();
    }
  }
  else
  {
    if (v10)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Verification code FAILED", buf, 2u);
    }

    uint64_t v15 = *(void *)(a1 + 56);
    if (v15)
    {
      id v14 = *(void (**)(void))(v15 + 16);
      goto LABEL_12;
    }
  }
}

void sub_10004EED0(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10004EF78;
  v3[3] = &unk_10072E238;
  void v3[4] = v2;
  id v4 = *(id *)(a1 + 40);
  id v5 = *(id *)(a1 + 48);
  objc_msgSend(v2, "_queue_setupBackgroundWebServiceWithCompletion:", v3);
}

void sub_10004EF78(uint64_t a1)
{
  id v2 = *(NSObject **)(*(void *)(a1 + 32) + 128);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004F024;
  block[3] = &unk_10072E238;
  id v6 = *(id *)(a1 + 40);
  id v3 = *(id *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 32);
  id v7 = v3;
  uint64_t v8 = v4;
  dispatch_async(v2, block);
}

id sub_10004F024(uint64_t a1)
{
  return _[*(id *)(a1 + 32) backgroundDownloadRemotePassAssets:*(void *)(a1 + 40) cloudStoreCoordinatorDelegate:*(void *)(*(void *)(a1 + 48) + 88)];
}

void sub_10004F0B0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sharedWebService];
  id v3 = v2;
  if (*(void *)(*(void *)(a1 + 32) + 120)
    || ([v2 context],
        uint64_t v4 = objc_claimAutoreleasedReturnValue(),
        [v4 secureElementID],
        id v5 = objc_claimAutoreleasedReturnValue(),
        unsigned __int8 v6 = +[PKSecureElementConsistencyChecker isCheckingConsistencyForSecureElementID:v5], v5, v4, (v6 & 1) != 0))
  {
    id v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Consistency check already in progress...", v14, 2u);
    }
  }
  else
  {
    id v8 = [objc_alloc((Class)PKSecureElementConsistencyChecker) initWithPaymentWebService:v3 delegate:*(void *)(a1 + 32) cloudStoreCoordinatorDelegate:*(void *)(*(void *)(a1 + 32) + 88)];
    uint64_t v9 = *(void *)(a1 + 32);
    BOOL v10 = *(void **)(v9 + 120);
    *(void *)(v9 + 120) = v8;

    uint64_t v11 = (void *)PDOSTransactionCreate("PDPaymentWebServiceCoordinator.consistency_check");
    uint64_t v12 = *(void *)(a1 + 32);
    uint64_t v13 = *(void **)(v12 + 120);
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_10004F234;
    v15[3] = &unk_10072E198;
    void v15[4] = v12;
    id v16 = v11;
    id v7 = v11;
    [v13 startWithCompletion:v15];
  }
}

void sub_10004F234(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = *(void **)(v1 + 120);
  *(void *)(v1 + 120) = 0;
}

id sub_10004F2B8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10004F328;
  v3[3] = &unk_10072E1E8;
  void v3[4] = v1;
  return objc_msgSend(v1, "_queue_setupBackgroundWebServiceWithCompletion:", v3);
}

void sub_10004F328(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = *(NSObject **)(v1 + 128);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004F39C;
  block[3] = &unk_10072E1E8;
  void block[4] = v1;
  dispatch_async(v2, block);
}

void sub_10004F39C(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) sharedWebService];
  [v1 backgroundDownloadPassesSinceLastUpdatedTag:0];
}

void sub_10004F494(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) merchant];
    uint64_t v4 = [v3 identifier];
    id v5 = [v4 hexEncoding];
    int v11 = 138412290;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Processing VAS Transaction for Merchant ID: %@", (uint8_t *)&v11, 0xCu);
  }
  [*(id *)(a1 + 40) connect];
  if (PKNetworkConnectivityAvailable())
  {
    [*(id *)(a1 + 40) _processValueAddedServiceTransaction:*(void *)(a1 + 32)];
  }
  else
  {
    uint64_t v6 = [*(id *)(a1 + 32) identifier];
    id v7 = (void *)v6;
    if (v6) {
      CFStringRef v8 = (const __CFString *)v6;
    }
    else {
      CFStringRef v8 = &stru_10075AAD8;
    }
    uint64_t v9 = [@"VASTransactionProcessor." stringByAppendingString:v8];

    BOOL v10 = +[PDScheduledActivityCriteria priorityActivityCriteriaWithStartDate:0];
    [v10 setRequireNetworkConnectivity:1];
    PDScheduledActivityRegister();
  }
}

void sub_10004F810(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 192) containsObject:*(void *)(a1 + 40)])
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Ignoring receipt download because download is already in progress", v10, 2u);
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 48);
    id v4 = objc_alloc((Class)PKTransactionReceiptAuthorizationRequest);
    id v5 = [*(id *)(a1 + 56) receiptProviderIdentifier];
    uint64_t v6 = [*(id *)(a1 + 56) receiptIdentifier];
    if (v3)
    {
      id v2 = objc_msgSend(v4, "initWithReceiptServiceIdentifier:receiptIdentifier:cardNumberSuffix:featureIdentifier:", v5, v6, *(void *)(a1 + 48), objc_msgSend(*(id *)(a1 + 56), "featureIdentifier"));
    }
    else
    {
      id v7 = PKCurrentUserAltDSID();
      id v2 = objc_msgSend(v4, "initWithReceiptServiceIdentifier:receiptIdentifier:altDSID:featureIdentifier:", v5, v6, v7, objc_msgSend(*(id *)(a1 + 56), "featureIdentifier"));
    }
    if (v2)
    {
      [*(id *)(*(void *)(a1 + 32) + 192) addObject:*(void *)(a1 + 40)];
      CFStringRef v8 = [*(id *)(a1 + 32) sharedWebService];
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_10004FA08;
      void v11[3] = &unk_10072FFC0;
      void v11[4] = *(void *)(a1 + 32);
      id v12 = *(id *)(a1 + 64);
      id v13 = *(id *)(a1 + 56);
      id v14 = v8;
      id v15 = *(id *)(a1 + 40);
      id v9 = v8;
      [v9 transactionReceiptAuthorizationWithRequest:v2 completion:v11];
    }
  }
}

void sub_10004FA08(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(NSObject **)(*(void *)(a1 + 32) + 128);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004FB24;
  block[3] = &unk_10072FF98;
  id v13 = v5;
  id v14 = *(id *)(a1 + 40);
  id v15 = *(id *)(a1 + 48);
  id v8 = *(id *)(a1 + 56);
  uint64_t v9 = *(void *)(a1 + 32);
  id v16 = v8;
  uint64_t v17 = v9;
  id v18 = *(id *)(a1 + 64);
  id v19 = v6;
  id v10 = v6;
  id v11 = v5;
  dispatch_async(v7, block);
}

void sub_10004FB24(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) authorizationToken];
  uint64_t v3 = [*(id *)(a1 + 32) signature];
  id v4 = (void *)v3;
  if (v2) {
    BOOL v5 = v3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 80);
      *(_DWORD *)buf = 138412290;
      uint64_t v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Receipt authorization token error: %@", buf, 0xCu);
    }

    [*(id *)(*(void *)(a1 + 64) + 192) removeObject:*(void *)(a1 + 72)];
  }
  else
  {
    id v8 = objc_alloc((Class)PKTransactionReceiptRequest);
    uint64_t v9 = *(void *)(a1 + 40);
    id v10 = [*(id *)(a1 + 48) receiptIdentifier];
    id v11 = [v8 initWithReceiptProviderURL:v9 authorizationToken:v2 signature:v4 receiptIdentifier:v10];

    id v12 = [*(id *)(a1 + 32) conversationIdentifier];
    [v11 setConversationIdentifier:v12];

    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_10004FD0C;
    v15[3] = &unk_10072FF70;
    id v13 = *(void **)(a1 + 56);
    id v14 = *(void **)(a1 + 72);
    void v15[4] = *(void *)(a1 + 64);
    id v16 = v14;
    id v17 = *(id *)(a1 + 48);
    [v13 transactionReceiptWithRequest:v11 completion:v15];
  }
}

void sub_10004FD0C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(NSObject **)(*(void *)(a1 + 32) + 128);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004FE00;
  block[3] = &unk_10072FF48;
  id v13 = v5;
  id v8 = *(id *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 32);
  id v14 = v8;
  uint64_t v15 = v9;
  id v16 = *(id *)(a1 + 48);
  id v17 = v6;
  id v10 = v6;
  id v11 = v5;
  dispatch_async(v7, block);
}

void sub_10004FE00(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = [v2 uniqueID];

    if (!v3) {
      [*(id *)(a1 + 32) setUniqueID:*(void *)(a1 + 40)];
    }
    uint64_t v4 = *(void *)(a1 + 48);
    id v5 = *(void **)(v4 + 96);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_10004FF84;
    v9[3] = &unk_10072FF20;
    void v9[4] = v4;
    uint64_t v6 = *(void *)(a1 + 32);
    id v10 = *(id *)(a1 + 40);
    id v11 = *(id *)(a1 + 32);
    id v12 = *(id *)(a1 + 56);
    [v5 writeTransactionReceipt:v6 completion:v9];
  }
  else
  {
    uint64_t v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 64);
      *(_DWORD *)buf = 138412290;
      uint64_t v14 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Error downloading receipt: %@", buf, 0xCu);
    }

    [*(id *)(*(void *)(a1 + 48) + 192) removeObject:*(void *)(a1 + 40)];
  }
}

void sub_10004FF84(uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *(NSObject **)(v4 + 128);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100050054;
  block[3] = &unk_10072FEF8;
  void block[4] = v4;
  id v7 = *(id *)(a1 + 40);
  char v10 = a2;
  id v8 = *(id *)(a1 + 48);
  id v9 = *(id *)(a1 + 56);
  dispatch_async(v5, block);
}

void sub_100050054(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 192) removeObject:*(void *)(a1 + 40)];
  if (*(unsigned char *)(a1 + 64))
  {
    id v2 = *(void **)(a1 + 32);
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100050110;
    v3[3] = &unk_10072FED0;
    void v3[4] = v2;
    id v4 = *(id *)(a1 + 48);
    id v5 = *(id *)(a1 + 56);
    [v2 _accessObserversWithHandler:v3];
  }
}

void sub_100050110(uint64_t a1, void *a2)
{
  id v6 = a2;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    id v5 = [*(id *)(a1 + 48) identifier];
    [v6 paymentWebServiceCoordinator:v3 didDownloadTransactionReceipt:v4 forTransactionWithIdentifier:v5];
  }
}

id sub_100050240(uint64_t a1)
{
  return _[*(id *)(a1 + 32) _paymentHardwareStatusWithType:*(void *)(a1 + 48) completion:*(void *)(a1 + 40)];
}

void sub_1000505CC(uint64_t a1)
{
  id v4 = 0;
  id v2 = +[PKAccountAttestationRequest defaultAnonymizationSaltWithError:&v4];
  id v3 = v4;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100050704(uint64_t a1)
{
  uint64_t v2 = +[PKAccountAttestationRequest setDefaultAnonymizationSalt:*(void *)(a1 + 32)];
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    uint64_t v5 = v2;
    uint64_t v3 = (*(uint64_t (**)(void))(v3 + 16))();
    uint64_t v2 = v5;
  }
  return _objc_release_x1(v3, v2);
}

void sub_100050834(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sharedWebService];
  [v2 registerCredentialWithRequest:*(void *)(a1 + 40) withCompletion:*(void *)(a1 + 48)];
}

void sub_100050920(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_1000509B0;
  v2[3] = &unk_10072E198;
  void v2[4] = v1;
  id v3 = *(id *)(a1 + 40);
  objc_msgSend(v1, "_queue_setupBackgroundWebServiceWithCompletion:", v2);
}

void sub_1000509B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = *(NSObject **)(v1 + 128);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100050A44;
  v3[3] = &unk_10072E198;
  void v3[4] = v1;
  id v4 = *(id *)(a1 + 40);
  dispatch_async(v2, v3);
}

void sub_100050A44(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sharedWebService];
  [v2 backgroundRegisterCredentialWithRequest:*(void *)(a1 + 40)];
}

void sub_100050BD8(id *a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = a1[4];
    id v4 = [a1[5] description];
    *(_DWORD *)buf = 138412546;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received push for push topic: %@ userInfo:%@", buf, 0x16u);
  }
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x2020000000;
  char v16 = 1;
  uint64_t v5 = [a1[6] sharedWebServiceContext];
  id v6 = v5;
  if (v5)
  {
    id v7 = [v5 regions];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100050DD8;
    v10[3] = &unk_1007300D0;
    id v11 = a1[4];
    uint64_t v14 = buf;
    int8x16_t v9 = *(int8x16_t *)(a1 + 5);
    id v8 = (id)v9.i64[0];
    int8x16_t v12 = vextq_s8(v9, v9, 8uLL);
    id v13 = v6;
    [v7 enumerateKeysAndObjectsUsingBlock:v10];
  }
  if (*(unsigned char *)(*(void *)&buf[8] + 24)) {
    [a1[6] _fetchPassesIfNecessaryForPushTopic:a1[4]];
  }

  _Block_object_dispose(buf, 8);
}

void sub_100050DB8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_100050DD8(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v7 = a2;
  id v8 = a3;
  int8x16_t v9 = [v8 userNotificationPushTopic];
  unsigned int v10 = [v9 isEqualToString:*(void *)(a1 + 32)];

  if (v10)
  {
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
    [*(id *)(a1 + 40) _performNotificationActionWithUserInfo:*(void *)(a1 + 48)];
    goto LABEL_12;
  }
  id v11 = [v8 deviceCheckInPushTopic];
  unsigned int v12 = [v11 isEqualToString:*(void *)(a1 + 32)];

  if (v12)
  {
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
    id v13 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "passd requesting device check in from push", buf, 2u);
    }

    objc_msgSend(*(id *)(a1 + 40), "_queue_cancelAllDeviceCheckInTasks");
    [*(id *)(a1 + 56) atomicallyUpdateRegionWithIdentifier:v7 updateBlock:&stru_100730028];
    [*(id *)(*(void *)(a1 + 40) + 48) archiveContext:*(void *)(a1 + 56)];
    uint64_t v14 = objc_alloc_init(PDDeviceCheckInTask);
    objc_msgSend(*(id *)(a1 + 40), "_queue_enqueueDeviceCheckInTask:", v14);
LABEL_11:

    goto LABEL_12;
  }
  uint64_t v15 = [v8 productsPushTopic];
  unsigned int v16 = [v15 isEqualToString:*(void *)(a1 + 32)];

  if (v16)
  {
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
    id v17 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v30 = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Product update push received", v30, 2u);
    }

    [*(id *)(*(void *)(a1 + 40) + 112) markProductsDirty];
    uint64_t v14 = (PDDeviceCheckInTask *)objc_alloc_init((Class)PKPaymentAvailableProductsRequest);
    [(PDDeviceCheckInTask *)v14 addDiagnosticReason:@"passd - push"];
    [*(id *)(*(void *)(a1 + 40) + 112) handleWebServiceRequest:v14 completion:&stru_100730068];
    goto LABEL_11;
  }
  id v18 = [v8 transactionZonePushTopic];
  unsigned int v19 = [v18 isEqualToString:*(void *)(a1 + 32)];

  if (v19)
  {
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
    uint64_t v20 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v29 = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Transaction zone recreate push received", v29, 2u);
    }

    objc_msgSend(*(id *)(a1 + 40), "_queue_recreateCloudStoreTransactionZoneWithCompletion:", &stru_1007300A8);
    goto LABEL_12;
  }
  uint64_t v21 = [v8 provisioningTargetsPushTopic];
  if ([v21 isEqualToString:*(void *)(a1 + 32)])
  {

LABEL_20:
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
    CFStringRef v23 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v28 = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Provisioning sharing identifiers push recieved, will attempt to provision.", v28, 2u);
    }

    objc_msgSend(*(id *)(a1 + 40), "_queue_provisionPushProvisioningSharingIdentifiers");
    goto LABEL_12;
  }
  unsigned __int8 v22 = [*(id *)(a1 + 32) isEqualToString:@"com.apple.pay.provision"];

  if (v22) {
    goto LABEL_20;
  }
  id v24 = [v8 ownershipTokensPushTopic];
  unsigned int v25 = [v24 isEqualToString:*(void *)(a1 + 32)];

  if (v25)
  {
    *a4 = 1;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
    long long v26 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v27 = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Ownership tokens push recieved.", v27, 2u);
    }

    objc_msgSend(*(id *)(a1 + 40), "_queue_performOwnershipTokensRequestWithUserInfo:", *(void *)(a1 + 48));
  }
LABEL_12:
}

PKPaymentWebServiceRegion *__cdecl sub_1000511C8(id a1, PKPaymentWebServiceRegion *a2)
{
  return (PKPaymentWebServiceRegion *)[(PKPaymentWebServiceRegion *)a2 regionBySettingOutstandingCheckInAction:0 lastDeviceCheckInBuildVersion:0];
}

void sub_1000511D8(id a1, PKPaymentAvailableProductsResponse *a2, NSError *a3)
{
  id v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finished updating products for push", v4, 2u);
  }
}

void sub_100051244(id a1, BOOL a2, NSError *a3)
{
  id v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finished recreating transaction zone from push", v4, 2u);
  }
}

void sub_100051348(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = *(void **)(a1 + 32);
    *(_DWORD *)buf = 138412290;
    id v17 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Applying push notification token: %@", buf, 0xCu);
  }

  if (*(void *)(a1 + 32))
  {
    id v4 = [*(id *)(a1 + 40) sharedWebService];
    uint64_t v5 = [v4 context];
    id v6 = [v5 pushToken];
    unsigned __int8 v7 = [v6 isEqualToString:*(void *)(a1 + 32)];

    if ((v7 & 1) == 0)
    {
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        id v8 = [v5 pushToken];
        *(_DWORD *)buf = 138412290;
        id v17 = v8;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "New push token is different than current push token: %@", buf, 0xCu);
      }
      int8x16_t v9 = [v4 context];
      unsigned int v10 = [v9 isRegistered];

      if (v10)
      {
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Reregistering with a new push token", buf, 2u);
        }

        [v5 setNextPushToken:*(void *)(a1 + 32)];
        id v11 = *(void **)(a1 + 40);
        unsigned int v12 = [v4 primaryBrokerURL];
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 3221225472;
        v14[2] = sub_100051610;
        v14[3] = &unk_1007300F8;
        id v15 = *(id *)(a1 + 32);
        objc_msgSend(v11, "_queue_registerDeviceAtBrokerURL:completion:", v12, v14);
      }
      else
      {
        [v5 setPushToken:*(void *)(a1 + 32)];
        [*(id *)(*(void *)(a1 + 40) + 48) archiveContext:v5];
      }
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [v5 pushToken];
      *(_DWORD *)buf = 138412290;
      id v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Applied token: %@", buf, 0xCu);
    }
  }
}

void sub_100051610(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    CFStringRef v8 = @"NO";
    *(_DWORD *)id v11 = 138412802;
    if (a2) {
      CFStringRef v8 = @"YES";
    }
    *(void *)&void v11[4] = v7;
    __int16 v12 = 2112;
    CFStringRef v13 = v8;
    __int16 v14 = 2112;
    id v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Broker reregister with push token %@ succeeded %@ with error %@", v11, 0x20u);
  }

  id v9 = objc_alloc_init((Class)NSMutableDictionary);
  [v9 setObject:PKAnalyticsReportEventTypePushTokenUpdate forKeyedSubscript:PKAnalyticsReportEventKey];
  if (a2) {
    CFStringRef v10 = @"success";
  }
  else {
    CFStringRef v10 = @"failure";
  }
  objc_msgSend(v9, "setObject:forKeyedSubscript:", v10, PKAnalyticsReportPushTokenUpdateStatus, *(void *)v11);
  +[PKAnalyticsReporter sendSingularEvent:v9];
}

void sub_100051830(uint64_t a1)
{
  id v2 = [objc_alloc((Class)PKPaymentDeprovisionRequest) initWithPaymentPass:*(void *)(a1 + 32)];
  id v3 = [*(id *)(a1 + 40) sharedWebService];
  uint64_t v4 = *(void *)(a1 + 48);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100051940;
  v8[3] = &unk_100730120;
  id v9 = v2;
  id v5 = v2;
  [v3 diagnosticSessionWithReason:v4 sessionHandler:v8];

  id v6 = [*(id *)(a1 + 40) sharedWebServiceContext];
  uint64_t v7 = [*(id *)(a1 + 32) uniqueID];
  [v6 removeVerificationRequestRecordForUniqueID:v7];

  [*(id *)(*(void *)(a1 + 40) + 48) archiveContext:v6];
}

id sub_100051940(uint64_t a1, void *a2)
{
  return _[a2 deprovisionForRequest:*(void *)(a1 + 32) completion:0];
}

void sub_100051A5C(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Payment pass added. Checking if SE is already personalized", buf, 2u);
  }

  id v3 = [*(id *)(a1 + 32) uniqueID];
  uint64_t v4 = [*(id *)(*(void *)(a1 + 40) + 16) primaryPaymentApplicationForPassUniqueIdentifier:v3];
  id v5 = [v4 applicationIdentifier];

  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void **)(v6 + 32);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100051BA8;
  v10[3] = &unk_100730148;
  void v10[4] = v6;
  id v11 = v3;
  id v12 = *(id *)(a1 + 32);
  id v13 = v5;
  id v8 = v5;
  id v9 = v3;
  [v7 appletWithIdentifier:v8 completion:v10];
}

void sub_100051BA8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(*(void *)(a1 + 32) + 16) primaryPaymentApplicationForPassUniqueIdentifier:*(void *)(a1 + 40)];
  if (v3
    && ((id v5 = [v3 lifecycleState], v5 == (id)23) || v5 == (id)15)
    && ([v4 state] == (id)2 || objc_msgSend(v4, "state") == (id)3))
  {
    uint64_t v6 = dispatch_get_global_queue(0, 0);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_100051D70;
    void v11[3] = &unk_10072E238;
    id v12 = *(id *)(a1 + 48);
    id v7 = *(id *)(a1 + 56);
    uint64_t v8 = *(void *)(a1 + 32);
    id v13 = v7;
    uint64_t v14 = v8;
    id v9 = v11;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10000D758;
    block[3] = &unk_10072F788;
    id v16 = v9;
    dispatch_async(v6, block);

    CFStringRef v10 = v12;
  }
  else
  {
    CFStringRef v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "SE is not personalized yet.", (uint8_t *)block, 2u);
    }
  }
}

void sub_100051D70(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) passTypeIdentifier];
    uint64_t v4 = [*(id *)(a1 + 32) serialNumber];
    uint64_t v5 = *(void *)(a1 + 40);
    int v8 = 138412802;
    id v9 = v3;
    __int16 v10 = 2112;
    id v11 = v4;
    __int16 v12 = 2112;
    uint64_t v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SE is already perso'd for %@:%@ aid: %@, fetching passes", (uint8_t *)&v8, 0x20u);
  }
  uint64_t v6 = *(void **)(a1 + 48);
  id v7 = [*(id *)(a1 + 32) passTypeIdentifier];
  [v6 _fetchPassesIfNecessaryForPushTopic:v7];
}

void sub_100051F48(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 paymentWebServiceCoordinator:*(void *)(a1 + 32) didDownloadPass:*(void *)(a1 + 40)];
  }
}

void sub_100052088(uint64_t a1)
{
  [*(id *)(a1 + 32) _handleDownloadedPass:*(void *)(a1 + 40)];
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  id v3 = *(void **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10005213C;
  v4[3] = &unk_100730170;
  v4[4] = v3;
  id v5 = *(id *)(a1 + 40);
  [v3 _accessObserversWithHandler:v4];
}

void sub_10005213C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 paymentWebServiceCoordinator:*(void *)(a1 + 32) didDownloadPassRemoteAssets:*(void *)(a1 + 40)];
  }
}

void sub_100052420(id *a1)
{
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v2 = a1[4];
  id v3 = [v2 countByEnumeratingWithState:&v21 objects:v31 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v22;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v22 != v5) {
          objc_enumerationMutation(v2);
        }
        id v7 = *(void **)(*((void *)&v21 + 1) + 8 * i);
        int v8 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          id v9 = [v7 passTypeIdentifier];
          __int16 v10 = [v7 serialNumber];
          id v11 = a1[5];
          *(_DWORD *)buf = 138412802;
          long long v26 = v9;
          __int16 v27 = 2112;
          long long v28 = v10;
          __int16 v29 = 2112;
          id v30 = v11;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%@:%@ not found in list of passes server expects to be on device for region %@. Redownloading", buf, 0x20u);
        }
        __int16 v12 = [a1[6] sharedWebService];
        uint64_t v13 = [v7 passTypeIdentifier];
        uint64_t v14 = [v7 serialNumber];
        [v12 backgroundDownloadWithPassTypeIdentifier:v13 serialNumber:v14];
      }
      id v4 = [v2 countByEnumeratingWithState:&v21 objects:v31 count:16];
    }
    while (v4);
  }

  id v15 = PDPaymentWebServicePushTopicsNeedingUpdate();
  id v16 = v15;
  if (a1[5] && objc_msgSend(v15, "containsObject:")) {
    [a1[6] _fetchPassesIfNecessaryForPushTopic:a1[5]];
  }
  id v17 = a1[6];
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1000526B0;
  v18[3] = &unk_10072FED0;
  void v18[4] = v17;
  id v19 = a1[7];
  id v20 = a1[5];
  [v17 _accessObserversWithHandler:v18];
}

void sub_1000526B0(void *a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 paymentWebServiceCoordinator:a1[4] didDownloadSerialNumbersForInstalledPasses:a1[5] inRegion:a1[6]];
  }
}

void sub_1000527F4(void *a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 paymentWebServiceCoordinator:a1[4] didRegisterCredentialWithIdentifier:a1[5] response:a1[6] error:a1[7]];
  }
}

id sub_1000528F0(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) sharedWebService];

  if (v2 != v3) {
    objc_msgSend(*(id *)(a1 + 40), "_queue_setupBackgroundWebServiceWithCompletion:", 0);
  }
  id v4 = *(void **)(a1 + 40);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10005299C;
  v6[3] = &unk_1007301E8;
  void v6[4] = v4;
  return [v4 _accessObserversWithHandler:v6];
}

void sub_10005299C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 paymentWebServiceCoordinatorBackgroundSessionDidBecomeInvalid:*(void *)(a1 + 32)];
  }
}

void sub_100052AC0(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 80);
  if (v2)
  {
    [v2 setDelegate:0];
    [*(id *)(*(void *)(a1 + 32) + 80) stop];
  }
  id v3 = [*(id *)(a1 + 40) uniqueID];
  id v7 = +[NSString stringWithFormat:@"%@-%@", @"passd", v3];

  id v4 = [objc_alloc((Class)PKPaymentVerificationObserver) initWithPaymentPass:*(void *)(a1 + 40) verificationChannel:*(void *)(a1 + 48) identifier:v7];
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void **)(v5 + 80);
  *(void *)(v5 + 80) = v4;

  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 80), "setDelegate:");
  [*(id *)(*(void *)(a1 + 32) + 80) startObservingVerificationSourceWithTimeout:120.0];
}

uint64_t sub_100052D4C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100052D60(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sharedWebService];
  long long v31 = [v2 context];
  id v3 = [v31 configuration];
  id v30 = objc_alloc_init((Class)NSMutableArray);
  id v28 = objc_alloc_init((Class)NSMutableArray);
  id v4 = objc_alloc_init((Class)NSMutableDictionary);
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  uint64_t v27 = a1;
  id v5 = *(id *)(a1 + 40);
  id v6 = [v5 countByEnumeratingWithState:&v43 objects:v50 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v44;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v44 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = *(void *)(*((void *)&v43 + 1) + 8 * i);
        id v11 = [v3 brokerURLForRegion:v10];
        if (v11 && PKRegistrationSupportedInRegionForWebService())
        {
          uint64_t v12 = [v4 objectForKeyedSubscript:v11];
          if (v12)
          {
            id v13 = (id)v12;
          }
          else
          {
            id v13 = objc_alloc_init((Class)NSMutableArray);
            [v4 setObject:v13 forKeyedSubscript:v11];
            [v30 addObject:v11];
            if ([v31 isRegisteredForBrokerURL:v11]) {
              [v28 addObject:v11];
            }
          }
          [v13 addObject:v10];
        }
      }
      id v7 = [v5 countByEnumeratingWithState:&v43 objects:v50 count:16];
    }
    while (v7);
  }

  [v2 primaryBrokerURL];
  v38[0] = _NSConcreteStackBlock;
  v38[1] = 3221225472;
  v38[2] = sub_1000531DC;
  v38[3] = &unk_100730210;
  id v14 = (id)objc_claimAutoreleasedReturnValue();
  id v39 = v14;
  id v29 = v28;
  id v40 = v29;
  id v15 = v4;
  id v41 = v15;
  id v42 = *(id *)(v27 + 40);
  [v30 sortUsingComparator:v38];
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  id v16 = v30;
  id v17 = [v16 countByEnumeratingWithState:&v34 objects:v49 count:16];
  if (v17)
  {
    id v18 = v17;
    uint64_t v19 = *(void *)v35;
    while (2)
    {
      for (uint64_t j = 0; j != v18; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v35 != v19) {
          objc_enumerationMutation(v16);
        }
        long long v21 = [v15 objectForKeyedSubscript:*(void *)(*((void *)&v34 + 1) + 8 * (void)j)];
        long long v22 = [v21 firstObject];

        if (v22)
        {

          objc_msgSend(*(id *)(v27 + 32), "_queue_performRegistrationForRegion:force:completion:", v22, *(unsigned __int8 *)(v27 + 56), *(void *)(v27 + 48));
          unsigned int v25 = v29;
          goto LABEL_28;
        }
      }
      id v18 = [v16 countByEnumeratingWithState:&v34 objects:v49 count:16];
      if (v18) {
        continue;
      }
      break;
    }
  }

  long long v23 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = *(void *)(v27 + 40);
    *(_DWORD *)buf = 138412290;
    uint64_t v48 = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "PDPaymentWebServiceCoordinator: could not register for member of %@ - either not supported or no broker URLs.", buf, 0xCu);
  }

  unsigned int v25 = v29;
  if (*(void *)(v27 + 48))
  {
    long long v26 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10005337C;
    block[3] = &unk_10072F788;
    id v33 = *(id *)(v27 + 48);
    dispatch_async(v26, block);

    long long v22 = v33;
LABEL_28:
  }
}

uint64_t sub_1000531DC(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (PKEqualObjects())
  {
    uint64_t v7 = 0;
    goto LABEL_7;
  }
  if (PKEqualObjects())
  {
LABEL_4:
    uint64_t v7 = -1;
    goto LABEL_7;
  }
  if (PKEqualObjects()) {
    goto LABEL_6;
  }
  unsigned int v9 = [a1[5] containsObject:v5];
  unsigned int v10 = [a1[5] containsObject:v6];
  if (v9 && !v10) {
    goto LABEL_4;
  }
  if ((v9 | v10 ^ 1) != 1)
  {
LABEL_6:
    uint64_t v7 = 1;
    goto LABEL_7;
  }
  id v11 = [a1[6] objectForKeyedSubscript:v5];
  uint64_t v12 = [v11 firstObject];

  id v13 = [a1[6] objectForKeyedSubscript:v6];
  id v14 = [v13 firstObject];

  if (v12) {
    unint64_t v15 = (unint64_t)[a1[7] indexOfObject:v12];
  }
  else {
    unint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
  }
  if (v14) {
    unint64_t v16 = (unint64_t)[a1[7] indexOfObject:v14];
  }
  else {
    unint64_t v16 = 0x7FFFFFFFFFFFFFFFLL;
  }
  if (v15 == v16)
  {
    uint64_t v7 = 0;
  }
  else if (v15 == 0x7FFFFFFFFFFFFFFFLL || v16 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v15 != 0x7FFFFFFFFFFFFFFFLL || v16 == 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v15 < v16) {
        uint64_t v7 = -1;
      }
      else {
        uint64_t v7 = 1;
      }
    }
    else
    {
      uint64_t v7 = 1;
    }
  }
  else
  {
    uint64_t v7 = -1;
  }

LABEL_7:
  return v7;
}

uint64_t sub_10005337C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_10005346C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_performRegistrationForRegion:force:completion:", *(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(void *)(a1 + 48));
}

void sub_1000538E0(uint64_t a1, int a2)
{
  id v4 = PKLogFacilityTypeGetObject();
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      uint64_t v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDPaymentWebServiceCoordinator: registering for region %{public}@.", buf, 0xCu);
    }

    [*(id *)(a1 + 40) performRegistrationForBrokerURL:*(void *)(a1 + 48) force:*(unsigned __int8 *)(a1 + 64) completion:*(void *)(a1 + 56)];
  }
  else
  {
    if (v5)
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      uint64_t v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDPaymentWebServiceCoordinator: failed initial registration with device region - skipping registration for region %{public}@.", buf, 0xCu);
    }

    if (*(void *)(a1 + 56))
    {
      uint64_t v8 = PDDefaultQueue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100053A6C;
      block[3] = &unk_10072F788;
      id v10 = *(id *)(a1 + 56);
      dispatch_async(v8, block);
    }
  }
}

uint64_t sub_100053A6C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100053A80(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_100053B60(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_performRegistrationForBrokerURL:force:completion:", *(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(void *)(a1 + 48));
}

uint64_t sub_100053E84(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

uint64_t sub_100053E9C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100053EB0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100054024(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(NSObject **)(v7 + 128);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000540FC;
  block[3] = &unk_100730288;
  uint64_t v14 = a2;
  void block[4] = v7;
  id v11 = v6;
  id v12 = *(id *)(a1 + 40);
  id v13 = *(id *)(a1 + 48);
  id v9 = v6;
  dispatch_async(v8, block);
}

void sub_1000540FC(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (void *)v2[6];
  id v4 = [v2 sharedWebServiceContext];
  [v3 archiveContext:v4];

  [*(id *)(*(void *)(a1 + 32) + 112) clearPaymentSetupFeatures];
  BOOL v5 = PDDefaultQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100054204;
  block[3] = &unk_100730288;
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v7 = *(void **)(a1 + 40);
  void block[4] = *(void *)(a1 + 32);
  uint64_t v12 = v6;
  id v9 = v7;
  id v10 = *(id *)(a1 + 48);
  id v11 = *(id *)(a1 + 56);
  dispatch_async(v5, block);
}

uint64_t sub_100054204(void *a1)
{
  [*(id *)(a1[4] + 8) recalculatePushTopics];
  if (a1[8] == 1 && !a1[5])
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = a1[6];
      int v7 = 138412290;
      uint64_t v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDPaymentWebServiceCoordinator: registered with broker at %@.", (uint8_t *)&v7, 0xCu);
    }
    uint64_t v4 = 1;
  }
  else
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = a1[6];
      int v7 = 138412290;
      uint64_t v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDPaymentWebServiceCoordinator: failed to register with broker at %@.", (uint8_t *)&v7, 0xCu);
    }
    uint64_t v4 = 0;
  }

  uint64_t result = a1[7];
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(result + 16))(result, v4, a1[5]);
  }
  return result;
}

void sub_1000543C8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sharedWebService];
  uint64_t v3 = [v2 context];
  unsigned __int8 v4 = [v3 isRegistered];

  if (v4)
  {
    *(void *)buf = 0;
    unint64_t v15 = buf;
    uint64_t v16 = 0x2020000000;
    char v17 = 0;
    BOOL v5 = [*(id *)(a1 + 32) sharedWebServiceContext];
    uint64_t v6 = v5;
    if (v5)
    {
      int v7 = [v5 regions];
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_1000545BC;
      v13[3] = &unk_1007302D8;
      v13[4] = *(void *)(a1 + 32);
      v13[5] = buf;
      [v7 enumerateKeysAndObjectsUsingBlock:v13];
    }
    objc_msgSend(*(id *)(a1 + 32), "_queue_deviceCheckInRepeatInterval");
    uint64_t v9 = v8;
    id v10 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000546B0;
    block[3] = &unk_100730300;
    void block[4] = *(void *)(a1 + 32);
    void block[5] = buf;
    void block[6] = v9;
    dispatch_async(v10, block);

    _Block_object_dispose(buf, 8);
  }
  else
  {
    id v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "passd cannot start device check in as we are not registered yet", buf, 2u);
    }

    [*(id *)(a1 + 32) unscheduleDeviceCheckIn];
  }
}

void sub_1000545A0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000545BC(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v7 = a2;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = objc_msgSend(*(id *)(a1 + 32), "_queue_automaticDeviceCheckInRequiredForRegion:", a3);
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      id v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Region: %@ requires device check in", (uint8_t *)&v9, 0xCu);
    }

    *a4 = 1;
  }
}

id sub_1000546B0(uint64_t a1)
{
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    id v2 = *(void **)(a1 + 32);
    double v3 = *(double *)(a1 + 48);
    return _objc_msgSend(v2, "_queue_scheduleDeviceCheckInWithStartTimeOffset:repeatInterval:randomizeTimes:", 1, v3, v3);
  }
  else
  {
    unsigned __int8 v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "No regions require device check in", v6, 2u);
    }

    return objc_msgSend(*(id *)(a1 + 32), "_queue_unscheduleDeviceCheckIn");
  }
}

void sub_1000547E0(uint64_t a1)
{
  objc_msgSend(*(id *)(a1 + 32), "_queue_deviceCheckInRepeatInterval");
  uint64_t v3 = v2;
  unsigned __int8 v4 = PDDefaultQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100054888;
  block[3] = &unk_100730328;
  void block[4] = *(void *)(a1 + 32);
  void block[5] = *(void *)(a1 + 40);
  void block[6] = v3;
  dispatch_async(v4, block);
}

id sub_100054888(uint64_t a1)
{
  return _objc_msgSend(*(id *)(a1 + 32), "_queue_scheduleDeviceCheckInWithStartTimeOffset:repeatInterval:randomizeTimes:", 0, *(double *)(a1 + 40), *(double *)(a1 + 48));
}

id sub_100054DF0(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_unscheduleDeviceCheckIn");
}

void sub_100054F1C(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "passd - perform device check in called", buf, 2u);
  }

  uint64_t v3 = [*(id *)(a1 + 32) sharedWebService];
  unsigned __int8 v4 = [v3 context];
  unsigned __int8 v5 = [v4 isRegistered];

  if (v5)
  {
    uint64_t v6 = objc_alloc_init(PDDeviceCheckInTask);
    [(PDDeviceCheckInTask *)v6 setCanPromptForAuth:1];
    if (*(void *)(a1 + 40))
    {
      id v7 = [(PDDeviceCheckInTask *)v6 completionHandlers];
      id v8 = objc_retainBlock(*(id *)(a1 + 40));
      [v7 addObject:v8];
    }
    objc_msgSend(*(id *)(a1 + 32), "_queue_enqueueDeviceCheckInTask:", v6);
  }
  else
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "passd cannot start device check in as we are not registered yet", v10, 2u);
    }

    uint64_t v9 = *(void *)(a1 + 40);
    if (v9) {
      (*(void (**)(uint64_t, void, void))(v9 + 16))(v9, 0, 0);
    }
  }
}

void sub_100055434(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(NSObject **)(v1 + 128);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000554C8;
  v3[3] = &unk_10072E198;
  void v3[4] = v1;
  id v4 = *(id *)(a1 + 48);
  dispatch_async(v2, v3);
}

void sub_1000554C8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) sharedWebServiceContext];
  if (v2)
  {
    id v4 = *(void **)(a1 + 32);
    uint64_t v3 = *(void **)(a1 + 40);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1000555EC;
    v6[3] = &unk_100730410;
    void v6[4] = v4;
    id v7 = v3;
    id v8 = v2;
    objc_msgSend(v4, "_queue_checkContextForDeviceCheckInAuthRequirement:completion:", v7, v6);
  }
  else
  {
    unsigned __int8 v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "passd cannot start device check in as there is no context", buf, 2u);
    }

    objc_msgSend(*(id *)(a1 + 32), "_queue_completeDeviceCheckInTask:success:error:", *(void *)(a1 + 40), 0, 0);
  }
}

void sub_1000555EC(id *a1, char a2, void *a3)
{
  id v5 = a3;
  if (v5 || (a2 & 1) == 0)
  {
    objc_msgSend(a1[4], "_queue_completeDeviceCheckInTask:success:error:", a1[5], 0, v5);
  }
  else
  {
    uint64_t v6 = [a1[6] configuration];
    id v7 = PKCurrentRegion();
    if ([v6 deviceCheckInDisabledForRegion:v7])
    {
      id v8 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Check in is disabled for device region: %@ - wait for next scheduled task run and check again", (uint8_t *)&buf, 0xCu);
      }

      objc_msgSend(a1[4], "_queue_completeDeviceCheckInTask:success:error:", a1[5], 0, 0);
    }
    else
    {
      v28[0] = 0;
      v28[1] = v28;
      void v28[2] = 0x2020000000;
      char v29 = 1;
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v31 = 0x3032000000;
      uint64_t v32 = sub_10002074C;
      id v33 = sub_100020E98;
      id v34 = 0;
      dispatch_group_t v9 = dispatch_group_create();
      id v10 = [a1[6] regions];
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472;
      v20[2] = sub_100055914;
      v20[3] = &unk_1007303C0;
      id v11 = v6;
      long long v26 = v28;
      id v12 = a1[4];
      id v21 = v11;
      id v22 = v12;
      id v13 = v9;
      long long v23 = v13;
      p_long long buf = &buf;
      id v24 = a1[5];
      id v25 = a1[6];
      [v10 enumerateKeysAndObjectsUsingBlock:v20];

      id v14 = a1[4];
      unint64_t v15 = *((void *)v14 + 16);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100055E38;
      block[3] = &unk_1007303E8;
      void block[4] = v14;
      id v17 = a1[5];
      id v18 = v28;
      uint64_t v19 = &buf;
      dispatch_group_notify(v13, v15, block);

      _Block_object_dispose(&buf, 8);
      _Block_object_dispose(v28, 8);
    }
  }
}

void sub_1000558E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_100055914(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [v6 regionCode];
  if ([*(id *)(a1 + 32) deviceCheckInDisabledForRegion:v7])
  {
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v20 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Check in is disabled for region: %@ - wait for next scheduled task run and check again", buf, 0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 0;
  }
  else if (objc_msgSend(*(id *)(a1 + 40), "_queue_automaticDeviceCheckInRequiredForRegion:", v6))
  {
    dispatch_group_enter(*(dispatch_group_t *)(a1 + 48));
    id v9 = [v6 outstandingCheckInAction];
    id v10 = *(void **)(a1 + 40);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    v12[2] = sub_100055B58;
    void v12[3] = &unk_100730398;
    void v12[4] = v10;
    long long v17 = *(_OWORD *)(a1 + 72);
    id v13 = *(id *)(a1 + 56);
    id v14 = *(id *)(a1 + 64);
    id v15 = v5;
    id v18 = v9;
    id v16 = *(id *)(a1 + 48);
    objc_msgSend(v10, "_queue_handleCheckInForRegion:action:completion:", v15, v9, v12);
  }
  else
  {
    id v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v20 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Region: %@ does not require device check in", buf, 0xCu);
    }
  }
}

void sub_100055B58(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id v6 = *(NSObject **)(*(void *)(a1 + 32) + 128);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100055C6C;
  v10[3] = &unk_100730370;
  char v19 = a2;
  long long v17 = *(_OWORD *)(a1 + 72);
  id v11 = v5;
  id v12 = *(id *)(a1 + 40);
  id v13 = *(id *)(a1 + 48);
  id v7 = *(id *)(a1 + 56);
  uint64_t v18 = *(void *)(a1 + 88);
  uint64_t v8 = *(void *)(a1 + 32);
  id v14 = v7;
  uint64_t v15 = v8;
  id v16 = *(id *)(a1 + 64);
  id v9 = v5;
  dispatch_async(v6, v10);
}

void sub_100055C6C(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 80) + 8);
  if (*(unsigned char *)(v2 + 24)) {
    *(unsigned char *)(v2 + 24) = *(unsigned char *)(a1 + 104);
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 88) + 8);
  uint64_t v5 = *(void *)(v3 + 40);
  id v4 = (id *)(v3 + 40);
  if (!v5) {
    objc_storeStrong(v4, *(id *)(a1 + 32));
  }
  if ([*(id *)(a1 + 40) cancelled])
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Device check in task was cancelled - skipping context update", buf, 2u);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = 0;
  }
  else
  {
    id v7 = *(void **)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 56);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100055DA0;
    v9[3] = &unk_100730348;
    char v10 = *(unsigned char *)(a1 + 104);
    void v9[4] = *(void *)(a1 + 96);
    [v7 atomicallyUpdateRegionWithIdentifier:v8 updateBlock:v9];
    [*(id *)(*(void *)(a1 + 64) + 48) archiveContext:*(void *)(a1 + 48)];
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 72));
}

id sub_100055DA0(uint64_t a1, void *a2)
{
  if (*(unsigned char *)(a1 + 40))
  {
    id v2 = a2;
    PKDeviceBuildVersion();
    id v3 = (id)objc_claimAutoreleasedReturnValue();
    id v4 = [v2 regionBySettingOutstandingCheckInAction:0 lastDeviceCheckInBuildVersion:v3];
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
    id v3 = a2;
    id v4 = [v3 regionBySettingOutstandingCheckInAction:v5 lastDeviceCheckInBuildVersion:0];
  }

  return v4;
}

id sub_100055E38(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_completeDeviceCheckInTask:success:error:", *(void *)(a1 + 40), *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40));
}

void sub_10005605C(uint64_t a1)
{
  long long v6 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t v1 = objc_msgSend(*(id *)(a1 + 32), "completionHandlers", 0);
  id v2 = [v1 countByEnumeratingWithState:&v6 objects:v10 count:16];
  if (v2)
  {
    id v3 = v2;
    uint64_t v4 = *(void *)v7;
    do
    {
      uint64_t v5 = 0;
      do
      {
        if (*(void *)v7 != v4) {
          objc_enumerationMutation(v1);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v6 + 1) + 8 * (void)v5) + 16))();
        uint64_t v5 = (char *)v5 + 1;
      }
      while (v3 != v5);
      id v3 = [v1 countByEnumeratingWithState:&v6 objects:v10 count:16];
    }
    while (v3);
  }
}

id sub_100056160(uint64_t a1)
{
  id result = objc_msgSend(*(id *)(a1 + 32), "_queue_unscheduleDeviceCheckIn");
  if (*(unsigned char *)(a1 + 48))
  {
    id v3 = *(void **)(a1 + 32);
    double v4 = *(double *)(a1 + 40);
    return _objc_msgSend(v3, "_queue_scheduleDeviceCheckInWithStartTimeOffset:repeatInterval:randomizeTimes:", 1, v4, v4);
  }
  return result;
}

void sub_10005639C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1000563B4(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v7 = a2;
  if ([a3 outstandingCheckInAction] == (id)4)
  {
    long long v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      id v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Region: %@ requires user initalited device check in as it was waiting for auth", (uint8_t *)&v9, 0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    *a4 = 1;
  }
}

void sub_10005649C(uint64_t a1, uint64_t a2)
{
  id v2 = *(NSObject **)(*(void *)(a1 + 32) + 128);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100056530;
  v3[3] = &unk_100730488;
  uint64_t v5 = a2;
  id v4 = *(id *)(a1 + 40);
  dispatch_async(v2, v3);
}

void sub_100056530(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = PKLogFacilityTypeGetObject();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)long long v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Grand slam token renew for device check in failed", v8, 2u);
    }

    NSErrorUserInfoKey v9 = NSLocalizedDescriptionKey;
    uint64_t v5 = PKLocalizedPaymentString(@"AUTH_ERROR");
    id v10 = v5;
    long long v6 = +[NSDictionary dictionaryWithObjects:&v10 forKeys:&v9 count:1];

    id v7 = +[NSError errorWithDomain:PKWebServiceErrorDomain code:1 userInfo:v6];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    if (v4)
    {
      *(_WORD *)long long v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Grand slam token renew for device check in success", v8, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_1000568DC(uint64_t a1, uint64_t a2)
{
  BOOL v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 134218242;
    uint64_t v11 = a2;
    __int16 v12 = 2112;
    uint64_t v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "passd found outstanding action to perform: %ld for region: %@", buf, 0x16u);
  }

  uint64_t v7 = *(void *)(a1 + 32);
  long long v6 = *(void **)(a1 + 40);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100056A10;
  v8[3] = &unk_1007304D8;
  id v9 = *(id *)(a1 + 48);
  [v6 _handleDeviceCheckInAction:a2 region:v7 completion:v8];
}

uint64_t sub_100056A10(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void))(result + 16))(result, a2, 0);
  }
  return result;
}

void sub_100056A2C(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  if (!v7 || v5)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    if (v6) {
      (*(void (**)(uint64_t, void, id))(v6 + 16))(v6, 0, v5);
    }
  }
  else
  {
    (*(void (**)(void, id))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), [v7 action]);
  }
}

void sub_100056EDC(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v17 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Device check in requested reregister for: %@", buf, 0xCu);
  }

  BOOL v4 = (void *)PDOSTransactionCreate("PDPaymentWebServiceCoordinator.check_in.re_register");
  id v5 = [*(id *)(a1 + 40) sharedWebServiceContext];
  uint64_t v6 = [v5 regions];
  id v7 = [v6 objectForKey:*(void *)(a1 + 32)];

  long long v8 = [v7 brokerURL];
  [*(id *)(a1 + 48) addDiagnosticReason:@"Registering for device check in"];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1000570A4;
  void v11[3] = &unk_100730550;
  id v12 = v4;
  id v9 = *(void **)(a1 + 40);
  id v13 = *(id *)(a1 + 48);
  id v14 = @"Registering for device check in";
  id v15 = *(id *)(a1 + 56);
  id v10 = v4;
  objc_msgSend(v9, "_queue_registerDeviceAtBrokerURL:completion:", v8, v11);
}

void sub_1000570A4(uint64_t a1, char a2, void *a3)
{
  id v8 = a3;
  [*(id *)(a1 + 40) removeDiagnosticReason:*(void *)(a1 + 48)];
  uint64_t v5 = *(void *)(a1 + 56);
  if (v5)
  {
    if (a2)
    {
      BOOL v6 = 1;
    }
    else if (v8)
    {
      id v7 = [v8 domain];
      if ([v7 isEqualToString:PKPaymentWebServiceErrorDomain]) {
        BOOL v6 = [v8 code] == (id)40308;
      }
      else {
        BOOL v6 = 0;
      }

      uint64_t v5 = *(void *)(a1 + 56);
    }
    else
    {
      BOOL v6 = 0;
    }
    (*(void (**)(uint64_t, BOOL))(v5 + 16))(v5, v6);
  }
}

uint64_t sub_100057178(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_100057190(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v17 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Device check in requested registration update for: %@", buf, 0xCu);
  }

  BOOL v4 = (void *)PDOSTransactionCreate("PDPaymentWebServiceCoordinator.check_in.register");
  uint64_t v5 = [*(id *)(a1 + 40) sharedWebServiceContext];
  BOOL v6 = [v5 regions];
  id v7 = [v6 objectForKey:*(void *)(a1 + 32)];

  id v8 = [v7 brokerURL];
  [*(id *)(a1 + 48) addDiagnosticReason:@"Updating registration for device check in"];
  id v9 = *(void **)(a1 + 48);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_100057358;
  void v11[3] = &unk_1007305C8;
  id v12 = v4;
  id v13 = v9;
  id v14 = @"Updating registration for device check in";
  id v15 = *(id *)(a1 + 56);
  id v10 = v4;
  [v9 updateRegistrationDataAtBrokerURL:v8 completion:v11];
}

void sub_100057358(uint64_t a1, uint64_t a2, void *a3)
{
  id v8 = a3;
  [*(id *)(a1 + 40) removeDiagnosticReason:*(void *)(a1 + 48)];
  uint64_t v5 = *(void *)(a1 + 56);
  if (v5)
  {
    if (a2 == 1)
    {
      BOOL v6 = 1;
    }
    else if (v8)
    {
      id v7 = [v8 domain];
      if ([v7 isEqualToString:PKPaymentWebServiceErrorDomain]) {
        BOOL v6 = [v8 code] == (id)40308;
      }
      else {
        BOOL v6 = 0;
      }

      uint64_t v5 = *(void *)(a1 + 56);
    }
    else
    {
      BOOL v6 = 0;
    }
    (*(void (**)(uint64_t, BOOL))(v5 + 16))(v5, v6);
  }
}

void sub_100057430(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Device check in requested configuration update for: %@", buf, 0xCu);
  }

  BOOL v4 = (void *)PDOSTransactionCreate("PDPaymentWebServiceCoordinator.check_in.configure");
  [*(id *)(a1 + 40) addDiagnosticReason:@"Configuring web service for device check in"];
  uint64_t v5 = *(void **)(a1 + 40);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_1000575A0;
  v7[3] = &unk_1007305C8;
  id v8 = v4;
  id v9 = v5;
  id v10 = @"Configuring web service for device check in";
  id v11 = *(id *)(a1 + 48);
  id v6 = v4;
  [v5 configurePaymentServiceWithCompletion:v7];
}

uint64_t sub_1000575A0(uint64_t a1)
{
  [*(id *)(a1 + 40) removeDiagnosticReason:*(void *)(a1 + 48)];
  uint64_t result = *(void *)(a1 + 56);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(result + 16);
    return v3();
  }
  return result;
}

void sub_1000576D8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) sharedWebServiceContext];
  id v6 = _NSConcreteStackBlock;
  uint64_t v7 = 3221225472;
  id v8 = sub_100057798;
  id v9 = &unk_1007305F0;
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = *(id *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  id v10 = v4;
  uint64_t v11 = v5;
  [v2 atomicallyUpdateRegionWithIdentifier:v3 updateBlock:&v6];
  objc_msgSend(*(id *)(*(void *)(a1 + 32) + 48), "archiveContext:", v2, v6, v7, v8, v9);
}

id sub_100057798(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    id v6 = [v4 regionBySettingOutstandingCheckInAction:v2 lastDeviceCheckInBuildVersion:v3];
  }
  else
  {
    uint64_t v7 = [v4 lastDeviceCheckInBuildVersion];
    id v6 = [v5 regionBySettingOutstandingCheckInAction:v2 lastDeviceCheckInBuildVersion:v7];

    uint64_t v5 = (void *)v7;
  }

  return v6;
}

void sub_1000578EC(uint64_t a1)
{
  [*(id *)(a1 + 32) stop];
  uint64_t v2 = [*(id *)(*(void *)(a1 + 40) + 56) assertionsOfType:2];
  id v3 = [v2 count];

  if (v3)
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Foreground application is observing for verification code", v8, 2u);
    }
  }
  else
  {
    uint64_t v5 = [*(id *)(a1 + 40) sharedWebService];
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = [*(id *)(a1 + 32) pass];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100057A28;
    v9[3] = &unk_100730640;
    void v9[4] = *(void *)(a1 + 40);
    [v5 submitVerificationCode:v6 verificationData:0 forPass:v7 completion:v9];
  }
}

void sub_100057A28(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = v5;
  if (a2 == 1 && v5)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    id v8 = *(void **)(v7 + 80);
    *(void *)(v7 + 80) = 0;

    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100057AE8;
    v9[3] = &unk_100730618;
    void v9[4] = *(void *)(a1 + 32);
    id v10 = v6;
    [v10 downloadRemoteAssetsWithCompletion:v9];
  }
}

void sub_100057AE8(uint64_t a1, int a2)
{
  if (a2)
  {
    [*(id *)(a1 + 32) _handleDownloadedPass:*(void *)(a1 + 40)];
    id v3 = +[NSDistributedNotificationCenter defaultCenter];
    uint64_t v4 = PKPaymentVerificationObserverPassVerifiedNotification;
    CFStringRef v7 = @"uniqueID";
    id v5 = [*(id *)(a1 + 40) uniqueID];
    id v8 = v5;
    uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
    [v3 postNotificationName:v4 object:0 userInfo:v6 deliverImmediately:1];
  }
}

void sub_100057C4C(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(*(void *)(a1 + 32) + 80) identifier];
    int v6 = 138412290;
    CFStringRef v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Background verification observer '%@' timed out", (uint8_t *)&v6, 0xCu);
  }
  [*(id *)(*(void *)(a1 + 32) + 80) stop];
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *(void **)(v4 + 80);
  *(void *)(v4 + 80) = 0;
}

void sub_100057EBC(uint64_t a1)
{
  if ([*(id *)(a1 + 32) type] == (id)1)
  {
    uint64_t v2 = *(void **)(*(void *)(a1 + 40) + 120);
    if (v2)
    {
      [v2 invalidate];
      uint64_t v3 = *(void *)(a1 + 40);
      uint64_t v4 = *(void **)(v3 + 120);
      *(void *)(v3 + 120) = 0;

      id v5 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v8 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Provisioning starting, rescheduling consistency check", v8, 2u);
      }

      int v6 = *(void **)(a1 + 40);
      CFStringRef v7 = +[NSDate dateWithTimeIntervalSinceNow:120.0];
      [v6 scheduleConsistencyCheck:v7 pluggedIn:0 backoffLevel:0];
    }
  }
}

id sub_1000581E8(uint64_t a1)
{
  return [*(id *)(a1 + 32) _handleDownloadedPass:*(void *)(a1 + 40)];
}

void sub_1000585D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

void sub_100058618(uint64_t a1, uint64_t a2)
{
  [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setPassCredentials:a2];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_1000586D0;
  v7[3] = &unk_100730690;
  void v7[4] = v3;
  long long v6 = *(_OWORD *)(a1 + 40);
  id v5 = (id)v6;
  long long v8 = v6;
  [v4 consistencyCheckDeviceCredentialsWithCompletion:v7];
}

void sub_1000586D0(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setDeviceCredentials:v3];
  uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 296);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000587AC;
  v8[3] = &unk_100730668;
  id v9 = v3;
  long long v7 = *(_OWORD *)(a1 + 40);
  id v5 = (id)v7;
  long long v10 = v7;
  id v6 = v3;
  [v4 allCredentialsWithCompletion:v8];
}

void sub_1000587AC(void *a1, void *a2)
{
  id v7 = a2;
  if (v7)
  {
    id v3 = (void *)a1[4];
    uint64_t v4 = *(void *)(a1[6] + 8);
    id v5 = *(void **)(v4 + 40);
    if (v3)
    {
      id v6 = [v3 arrayByAddingObjectsFromArray:v7];
      [v5 setDeviceCredentials:v6];
    }
    else
    {
      [*(id *)(v4 + 40) setDeviceCredentials:v7];
    }
  }
  (*(void (**)(void))(a1[5] + 16))();
}

void sub_100058940(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) shouldStartConsistencyCheck];
  id v3 = PKLogFacilityTypeGetObject();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      if (*(unsigned char *)(a1 + 56)) {
        CFStringRef v5 = @"Y";
      }
      else {
        CFStringRef v5 = @"N";
      }
      uint64_t v6 = *(void *)(a1 + 40);
      uint64_t v7 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 138412802;
      uint64_t v19 = v6;
      __int16 v20 = 2112;
      CFStringRef v21 = v5;
      __int16 v22 = 2112;
      uint64_t v23 = v7;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Scheduling consistency check for %@. pluggedIn: %@ backoff: %@ ", buf, 0x20u);
    }

    [*(id *)(a1 + 32) connect];
    if (*(void *)(a1 + 48))
    {
      long long v8 = [*(id *)(a1 + 32) sharedWebServiceContext];
      id v9 = *(NSObject **)(*(void *)(a1 + 32) + 128);
      id v12 = _NSConcreteStackBlock;
      uint64_t v13 = 3221225472;
      id v14 = sub_100058B70;
      id v15 = &unk_10072E198;
      id v16 = v8;
      id v17 = *(id *)(a1 + 48);
      id v10 = v8;
      dispatch_sync(v9, &v12);
      objc_msgSend(*(id *)(*(void *)(a1 + 32) + 48), "archiveContext:", v10, v12, v13, v14, v15);
    }
    id v3 = +[PDScheduledActivityCriteria priorityActivityCriteriaWithStartDate:*(void *)(a1 + 40)];
    [v3 setRequireNetworkConnectivity:1];
    [v3 setRequireMainsPower:*(unsigned __int8 *)(a1 + 56)];
    PDScheduledActivityRegister();
  }
  else if (v4)
  {
    uint64_t v11 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v19 = v11;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Ignoring request to schedule consistency check for %@", buf, 0xCu);
  }
}

void sub_100058B70(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100058BF8;
  v2[3] = &unk_1007306B8;
  uint64_t v1 = *(void **)(a1 + 32);
  id v3 = *(id *)(a1 + 40);
  [v1 atomicallyUpdatePrimaryRegion:v2];
}

id sub_100058BF8(uint64_t a1, void *a2)
{
  unsigned int v2 = *(void **)(a1 + 32);
  id v3 = a2;
  BOOL v4 = objc_msgSend(v3, "regionBySettingConsistencyCheckBackoffLevel:", objc_msgSend(v2, "integerValue"));

  return v4;
}

void sub_100059458(_Unwind_Exception *a1)
{
}

void sub_100059490(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = a1[5];
  id v9 = *(void **)(a1[4] + 32);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_10005956C;
  v13[3] = &unk_100730708;
  uint64_t v10 = a1[6];
  id v15 = v7;
  uint64_t v16 = v10;
  id v14 = v6;
  id v11 = v6;
  id v12 = v7;
  [v9 markAppletsWithIdentifiersForDeletion:v8 completion:v13];
}

uint64_t sub_10005956C(void *a1, char a2)
{
  uint64_t v2 = *(void *)(a1[6] + 8);
  if (*(unsigned char *)(v2 + 24)) {
    char v3 = a2;
  }
  else {
    char v3 = 0;
  }
  *(unsigned char *)(v2 + 24) = v3;
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16))(a1[5], a1[4], 0);
}

void sub_10005959C(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 232));
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100059684;
  v13[3] = &unk_100730758;
  uint64_t v10 = a1[5];
  uint64_t v9 = a1[6];
  id v15 = v7;
  uint64_t v16 = v9;
  id v14 = v6;
  id v11 = v6;
  id v12 = v7;
  [WeakRetained requestRegistrationForCredentialWithIdentifier:v10 completion:v13];
}

uint64_t sub_100059684(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1[6] + 8);
  if (a3) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = *(unsigned char *)(v3 + 24) == 0;
  }
  char v5 = !v4;
  *(unsigned char *)(v3 + 24) = v5;
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16))(a1[5], a1[4], 0);
}

void sub_1000596B8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 232));
  uint64_t v9 = objc_msgSend(*(id *)(a1 + 40), "pk_setByApplyingBlock:", &stru_100730798);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100059814;
  v13[3] = &unk_100730708;
  uint64_t v10 = *(void *)(a1 + 48);
  id v15 = v7;
  uint64_t v16 = v10;
  id v14 = v6;
  id v11 = v6;
  id v12 = v7;
  [WeakRetained revokeSubcredentials:v9 withCompletion:v13];
}

id sub_1000597BC(id a1, NSString *a2)
{
  uint64_t v2 = a2;
  id v3 = [objc_alloc((Class)PKAppletSubcredential) initWithIdentifier:v2];

  return v3;
}

uint64_t sub_100059814(void *a1, char a2)
{
  uint64_t v2 = *(void *)(a1[6] + 8);
  if (*(unsigned char *)(v2 + 24)) {
    char v3 = a2;
  }
  else {
    char v3 = 0;
  }
  *(unsigned char *)(v2 + 24) = v3;
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16))(a1[5], a1[4], 0);
}

void sub_100059844(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = a1[5];
  uint64_t v9 = *(void **)(a1[4] + 296);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100059920;
  v13[3] = &unk_1007307C0;
  uint64_t v10 = a1[6];
  id v15 = v7;
  uint64_t v16 = v10;
  id v14 = v6;
  id v11 = v6;
  id v12 = v7;
  [v9 deleteCredentialsForCredentialIds:v8 completion:v13];
}

uint64_t sub_100059920(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1[6] + 8);
  if (a2) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = *(unsigned char *)(v2 + 24) == 0;
  }
  char v4 = !v3;
  *(unsigned char *)(v2 + 24) = v4;
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16))(a1[5], a1[4], 0);
}

void sub_100059954(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = a1[5];
  uint64_t v9 = *(void **)(a1[4] + 296);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100059A30;
  v13[3] = &unk_1007307C0;
  uint64_t v10 = a1[6];
  id v15 = v7;
  uint64_t v16 = v10;
  id v14 = v6;
  id v11 = v6;
  id v12 = v7;
  [v9 activateCredentialsForCredentialIds:v8 completion:v13];
}

uint64_t sub_100059A30(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1[6] + 8);
  if (a2) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = *(unsigned char *)(v2 + 24) == 0;
  }
  char v4 = !v3;
  *(unsigned char *)(v2 + 24) = v4;
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16))(a1[5], a1[4], 0);
}

void sub_100059A64(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = a1[5];
  uint64_t v9 = *(void **)(a1[4] + 296);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100059B40;
  v13[3] = &unk_1007307C0;
  uint64_t v10 = a1[6];
  id v15 = v7;
  uint64_t v16 = v10;
  id v14 = v6;
  id v11 = v6;
  id v12 = v7;
  [v9 suspendCredentialsForCredentialIds:v8 completion:v13];
}

uint64_t sub_100059B40(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1[6] + 8);
  if (a2) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = *(unsigned char *)(v2 + 24) == 0;
  }
  char v4 = !v3;
  *(unsigned char *)(v2 + 24) = v4;
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16))(a1[5], a1[4], 0);
}

void sub_100059B74(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(*(void *)(a1 + 32) + 16);
  uint64_t v9 = [*(id *)(a1 + 40) appletIdentifier];
  uint64_t v10 = [*(id *)(a1 + 40) subcredentialIdentifier];
  id v11 = [v8 passUniqueIdentifierWithPaymentApplicationIdentifier:v9 subcredentialIdentifier:v10];

  if (v11)
  {
    id v12 = [*(id *)(*(void *)(a1 + 32) + 16) passWithUniqueIdentifier:v11];
    uint64_t v13 = [v12 secureElementPass];

    id v14 = *(void **)(*(void *)(a1 + 32) + 296);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_100059D68;
    v17[3] = &unk_1007307C0;
    uint64_t v20 = *(void *)(a1 + 48);
    id v19 = v7;
    id v18 = v6;
    [v14 handlePaymentPassUpdateFrom:v13 priorPaymentApplications:0 completion:v17];
  }
  else
  {
    id v15 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "uploadISOCredentialsForPaymentApplicationAndSubcredentialIds unable to find pass for %@", buf, 0xCu);
    }

    (*((void (**)(id, id, void))v7 + 2))(v7, v6, 0);
  }
}

uint64_t sub_100059D68(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1[6] + 8);
  if (a2) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = *(unsigned char *)(v2 + 24) == 0;
  }
  char v4 = !v3;
  *(unsigned char *)(v2 + 24) = v4;
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16))(a1[5], a1[4], 0);
}

uint64_t sub_100059D9C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
}

id sub_10005A0E8(uint64_t a1)
{
  return _objc_msgSend(*(id *)(a1 + 32), "_queue_coeleaseDeviceCheckInCompletion:", 0);
}

void sub_10005A1C0(uint64_t a1, int a2)
{
  if (a2)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_10005A258;
    v6[3] = &unk_1007307E8;
    BOOL v3 = *(void **)(a1 + 32);
    id v4 = *(id *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    id v7 = v4;
    uint64_t v8 = v5;
    [v3 downloadPassWithCompletion:v6];
  }
}

void sub_10005A258(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  if (v5 && a2)
  {
    id v6 = +[NSFileManager defaultManager];
    id v7 = PKVASPassCacheDirectoryPath();
    uint64_t v8 = +[NSURL fileURLWithPath:v7];

    [v6 createDirectoryAtURL:v8 withIntermediateDirectories:1 attributes:0 error:0];
    uint64_t v9 = [v5 uniqueID];
    uint64_t v10 = [v8 URLByAppendingPathComponent:v9 isDirectory:0];

    id v11 = [v10 URLByAppendingPathExtension:PKRawPassExtension];

    id v12 = [v5 dataAccessor];
    uint64_t v13 = [v12 fileURL];
    [v6 removeItemAtURL:v11 error:0];
    if ([v6 copyItemAtURL:v13 toURL:v11 error:0])
    {
      id v14 = [*(id *)(a1 + 32) merchant];
      id v15 = [v14 identifier];
      uint64_t v16 = [v15 hexEncoding];

      id v17 = [PDWalletValueAddedServiceTransactionUserNotification alloc];
      id v18 = [v5 localizedDescription];
      id v19 = [(PDWalletValueAddedServiceTransactionUserNotification *)v17 initWithMerchantIdentifier:v16 localizedPassDescription:v18 passUniqueIdentifier:v9];

      id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 248));
      [WeakRetained insertUserNotification:v19];

      CFStringRef v21 = *(void **)(a1 + 32);
      uint64_t v22 = *(void **)(*(void *)(a1 + 40) + 16);
      uint64_t v23 = [v21 merchant];
      [v22 valueAddedMerchantWasPresented:v23];
    }
    else
    {
      id v24 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v25 = 0;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Couldn't copy the VAS pass to our cache", v25, 2u);
      }
    }
  }
}

void sub_10005A54C(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)PKPaymentNotificationActionRequest);
  BOOL v3 = [*(id *)(a1 + 32) PKStringForKey:@"action"];
  [v2 setAction:v3];

  id v4 = [*(id *)(a1 + 32) PKStringForKey:@"requestId"];
  [v2 setRequestID:v4];
  id v5 = [*(id *)(a1 + 40) sharedWebService];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10005A64C;
  v6[3] = &unk_100730838;
  void v6[4] = *(void *)(a1 + 40);
  [v5 performNotificationActionRequest:v2 completion:v6];
}

void sub_10005A64C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == 1 && a3 && !a4)
  {
    objc_msgSend(*(id *)(a1 + 32), "_userNotificationFromResponse:");
    id v7 = (id)objc_claimAutoreleasedReturnValue();
    if (v7)
    {
      id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248));
      [WeakRetained insertUserNotification:v7];
    }
  }
}

void sub_10005AADC(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10005AB6C;
  v2[3] = &unk_10072E198;
  void v2[4] = v1;
  id v3 = *(id *)(a1 + 40);
  objc_msgSend(v1, "_queue_setupBackgroundWebServiceWithCompletion:", v2);
}

void sub_10005AB6C(uint64_t a1)
{
  id v2 = *(NSObject **)(*(void *)(a1 + 32) + 128);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_10005AC04;
  v5[3] = &unk_10072E198;
  id v3 = *(id *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 32);
  id v6 = v3;
  uint64_t v7 = v4;
  dispatch_async(v2, v5);
}

void sub_10005AC04(uint64_t a1)
{
  id v2 = PDPaymentWebServicePushTopicsNeedingUpdate();
  id v3 = v2;
  if (v2)
  {
    id v4 = v2;
  }
  else
  {
    id v4 = +[NSSet set];
  }
  id v5 = v4;

  id v6 = [v5 setByAddingObject:*(void *)(a1 + 32)];
  PDSetPaymentWebServicePushTopicsNeedingUpdate();

  uint64_t v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v16 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Fetching passes if necessary for push topic %@.", buf, 0xCu);
  }

  uint64_t v9 = [*(id *)(a1 + 40) sharedWebService];
  uint64_t v10 = *(void **)(a1 + 32);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_10005AD94;
  void v12[3] = &unk_100730860;
  id v13 = v10;
  id v14 = v9;
  id v11 = v9;
  [v11 getHasBackgroundDownloadTaskPassesForPushTopic:v13 completion:v12];
}

void sub_10005AD94(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = PDPaymentWebServicePushTopicsNeedingUpdate();
  unsigned int v7 = [v6 containsObject:*(void *)(a1 + 32)];
  unsigned int v8 = [v6 containsObject:*(void *)(a1 + 32)];
  if (v8) {
    BOOL v9 = a2 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    [v5 timeIntervalSinceNow];
    if (fabs(v12) <= 60.0) {
      goto LABEL_9;
    }
LABEL_7:
    uint64_t v10 = PDPaymentWebServicePushTopicsNeedingUpdate();
    id v11 = objc_msgSend(v10, "pk_setByRemovingObject:", *(void *)(a1 + 32));
    PDSetPaymentWebServicePushTopicsNeedingUpdate();

    [*(id *)(a1 + 40) backgroundDownloadPassesForPushTopic:*(void *)(a1 + 32) sinceLastUpdatedTag:1];
    goto LABEL_14;
  }
  if (v8) {
    goto LABEL_7;
  }
LABEL_9:
  id v13 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(a1 + 32);
    CFStringRef v15 = @"NO";
    int v16 = 138412802;
    if (v7) {
      CFStringRef v15 = @"YES";
    }
    uint64_t v17 = v14;
    __int16 v18 = 2112;
    CFStringRef v19 = v15;
    __int16 v20 = 2112;
    id v21 = v5;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Not background downloading passes for push topic %@. Needs update: %@, last request date %@", (uint8_t *)&v16, 0x20u);
  }

LABEL_14:
}

id sub_10005B100(uint64_t a1, void *a2)
{
  return _[a2 deprovisionForRequest:*(void *)(a1 + 32) completion:0];
}

void sub_10005B264(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (objc_opt_respondsToSelector()) {
    [v3 paymentWebServiceCoordinatorWebServiceDidChange:*(void *)(a1 + 32)];
  }
}

void sub_10005B3D8(id a1, BOOL a2, NSError *a3)
{
  BOOL v4 = a2;
  id v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v6 = @"NO";
    if (v4) {
      CFStringRef v6 = @"YES";
    }
    int v7 = 138412546;
    CFStringRef v8 = v6;
    __int16 v9 = 2112;
    uint64_t v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Completed sending ownership tokens with success: %@, error %@", (uint8_t *)&v7, 0x16u);
  }
}

id sub_10005B584(void *a1)
{
  return _[*(id *)(a1[4] + 200) processSafariCredentialEligibility:a1[5] completion:a1[6]];
}

void sub_10005B618(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sharedWebService];
  id v3 = [v2 context];
  unsigned __int8 v4 = [v3 isRegistered];

  if (v4)
  {
    id v5 = [*(id *)(a1 + 32) sharedWebServiceContext];
    CFStringRef v6 = [v5 primaryRegion];
    int v7 = PKDeviceBuildVersion();
    uint64_t v8 = [v6 lastDeviceUpgradeTaskBuildVersion];
    __int16 v9 = (void *)v8;
    if (v7 && v8)
    {
      id v10 = [v7 compare:v8 options:1];
      uint64_t v11 = PDUpgradeTasksVersion();
      if (!v10 || v11 >= 2)
      {
        if (!v10)
        {
          [*(id *)(a1 + 32) unscheduleDeviceUpgradeTaskActivity];
LABEL_18:

          return;
        }
LABEL_15:
        CFStringRef v15 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = [v6 regionCode];
          int v17 = 138412802;
          __int16 v18 = v16;
          __int16 v19 = 2112;
          __int16 v20 = v7;
          __int16 v21 = 2112;
          uint64_t v22 = v9;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Device is upgraded but not pending device upgrade tasks for primary region: %@ from %@ to %@", (uint8_t *)&v17, 0x20u);
        }
        objc_msgSend(*(id *)(a1 + 32), "_queue_completeDeviceUpgradeTasks");
        goto LABEL_18;
      }
    }
    else if (PDUpgradeTasksVersion() > 1)
    {
      goto LABEL_15;
    }
    id v13 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = [v6 regionCode];
      int v17 = 138412802;
      __int16 v18 = v14;
      __int16 v19 = 2112;
      __int16 v20 = v7;
      __int16 v21 = 2112;
      uint64_t v22 = v9;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Device upgrade tasks for primary region: %@ are required with upgrade from %@ to %@", (uint8_t *)&v17, 0x20u);
    }
    [*(id *)(a1 + 32) _scheduleDeviceUpgradeTaskActivityWithRandomizeStartDate:*(unsigned __int8 *)(a1 + 40)];
    goto LABEL_18;
  }
  double v12 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v17) = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "passd cannot start device upgrade tasks as we are not registered yet", (uint8_t *)&v17, 2u);
  }

  [*(id *)(a1 + 32) unscheduleDeviceUpgradeTaskActivity];
}

void sub_10005B940(uint64_t a1)
{
  [*(id *)(a1 + 32) connect];
  id v2 = PDScheduledActivityGetCriteria();
  if (!v2)
  {
    if (*(unsigned char *)(a1 + 40)) {
      double v5 = (double)arc4random_uniform(0x15180u);
    }
    else {
      double v5 = 0.0;
    }
    double v6 = (double)arc4random_uniform(0xE10u) + 82800.0;
    id v3 = +[NSDate dateWithTimeIntervalSinceNow:v5];
    unsigned __int8 v4 = +[PDScheduledActivityCriteria maintenanceActivityCriteriaWithStartDate:v3];
    [v4 setRequireNetworkConnectivity:1];
    [v4 setRepeating:1];
    [v4 setRepeatInterval:v6];
    [v4 setReason:@"Device Upgrade Tasks"];
    int v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = [v4 debugDescription];
      int v9 = 138412290;
      id v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "passd scheduling device upgrade tasks: %@", (uint8_t *)&v9, 0xCu);
    }
    PDScheduledActivityRegister();
    goto LABEL_10;
  }
  id v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned __int8 v4 = [v2 debugDescription];
    int v9 = 138412290;
    id v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Device upgrade tasks already scheduled: %@", (uint8_t *)&v9, 0xCu);
LABEL_10:
  }
}

uint64_t sub_10005BBE4(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned __int8 v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Unscheduling device upgrade tasks", v4, 2u);
  }

  [*(id *)(a1 + 32) connect];
  return PDScheduledActivityRemove();
}

PKPaymentWebServiceRegion *__cdecl sub_10005BCE4(id a1, PKPaymentWebServiceRegion *a2)
{
  id v2 = a2;
  id v3 = PKDeviceBuildVersion();
  unsigned __int8 v4 = [(PKPaymentWebServiceRegion *)v2 regionBySettingLastDeviceUpgradeTaskBuildVersion:v3];

  return (PKPaymentWebServiceRegion *)v4;
}

void sub_10005BDC0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) sharedWebServiceContext];
  id v3 = [v2 primaryRegion];
  unsigned __int8 v4 = [v3 regionCode];

  if ([v2 contextMeetsDeviceUpgradeTasksEnablementThresholdForRegion:v4])
  {
    double v5 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
    objc_initWeak(location, *(id *)(a1 + 32));
    uint64_t v6 = PDUpgradeTasksVersion();
    if (v6 <= 0)
    {
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_10005C08C;
      v13[3] = &unk_100730940;
      objc_copyWeak(v14, location);
      v14[1] = (id)1;
      [v5 addOperation:v13];
      objc_destroyWeak(v14);
    }
    if (PDUpgradeTasksVersion() > 1)
    {
      if (v6 >= 1)
      {
        objc_msgSend(*(id *)(a1 + 32), "_queue_completeDeviceUpgradeTasks");
LABEL_11:
        objc_destroyWeak(location);
        goto LABEL_12;
      }
    }
    else
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_10005C3F4;
      void v11[3] = &unk_100730940;
      objc_copyWeak(v12, location);
      v12[1] = (id)2;
      [v5 addOperation:v11];
      objc_destroyWeak(v12);
    }
    int v7 = +[NSNull null];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_10005C760;
    v9[3] = &unk_100730990;
    objc_copyWeak(&v10, location);
    id v8 = [v5 evaluateWithInput:v7 completion:v9];

    objc_destroyWeak(&v10);
    goto LABEL_11;
  }
  double v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(location[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Skipping Device Upgrade Tasks because the threshold has been exceeded", (uint8_t *)location, 2u);
  }
LABEL_12:
}

void sub_10005C04C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 80));
  _Unwind_Resume(a1);
}

void sub_10005C08C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id WeakRetained = (NSObject **)objc_loadWeakRetained((id *)(a1 + 32));
  int v9 = WeakRetained;
  if (WeakRetained)
  {
    id v10 = WeakRetained[16];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10005C198;
    block[3] = &unk_100730918;
    void block[4] = WeakRetained;
    objc_copyWeak(v14, (id *)(a1 + 32));
    v14[1] = *(id *)(a1 + 40);
    id v13 = v7;
    id v12 = v6;
    dispatch_async(v10, block);

    objc_destroyWeak(v14);
  }
}

void sub_10005C198(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10005C278;
  v3[3] = &unk_1007308F0;
  objc_copyWeak(v6, (id *)(a1 + 56));
  v6[1] = *(id *)(a1 + 64);
  id v5 = *(id *)(a1 + 48);
  id v4 = *(id *)(a1 + 40);
  objc_msgSend(v2, "_queue_performContactInformationFetchTaskWithCompletion:", v3);

  objc_destroyWeak(v6);
}

void sub_10005C264(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_10005C278(uint64_t a1, char a2)
{
  id WeakRetained = (NSObject **)objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    id v6 = WeakRetained[16];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_10005C348;
    v7[3] = &unk_1007308C8;
    char v11 = a2;
    uint64_t v10 = *(void *)(a1 + 56);
    id v9 = *(id *)(a1 + 40);
    id v8 = *(id *)(a1 + 32);
    dispatch_async(v6, v7);
  }
}

uint64_t sub_10005C348(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Successfully fetched contact information in device upgrade task", v4, 2u);
    }

    PDSetUpgradeTasksVersion();
    PDSetUpgradeTasksRetryCount();
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005C3F4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  char v11 = WeakRetained;
  if (WeakRetained)
  {
    if ([*((id *)WeakRetained + 2) hasAccountServicingEventsWithStatus:0])
    {
      id v12 = (void *)v11[11];
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      id v14[2] = sub_10005C5A4;
      v14[3] = &unk_1007308F0;
      objc_copyWeak(v17, (id *)(a1 + 32));
      v17[1] = *(id *)(a1 + 40);
      id v16 = v9;
      id v15 = v8;
      [v12 refetchAccountEventsWithUnknownServicingStatusWithCompletion:v14];

      objc_destroyWeak(v17);
    }
    else
    {
      id v13 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "No account servicing events with unknown status to re-fetch, completing device upgrade task successfully", buf, 2u);
      }

      PDSetUpgradeTasksVersion();
      PDSetUpgradeTasksRetryCount();
      (*((void (**)(id, id, void))v9 + 2))(v9, v8, 0);
    }
  }
}

void sub_10005C590(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_10005C5A4(id *a1, char a2)
{
  id v4 = a1 + 6;
  id WeakRetained = (NSObject **)objc_loadWeakRetained(a1 + 6);
  id v6 = WeakRetained;
  if (WeakRetained)
  {
    id v7 = WeakRetained[16];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10005C698;
    block[3] = &unk_100730968;
    objc_copyWeak(v11, v4);
    char v12 = a2;
    v11[1] = a1[7];
    id v10 = a1[5];
    id v9 = a1[4];
    dispatch_async(v7, block);

    objc_destroyWeak(v11);
  }
}

void sub_10005C698(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (*(unsigned char *)(a1 + 64))
    {
      id v3 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Successfully re-fetched account servicing events with unknown status in device upgrade task", v4, 2u);
      }

      PDSetUpgradeTasksVersion();
      PDSetUpgradeTasksRetryCount();
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_10005C760(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = a4;
  id WeakRetained = (NSObject **)objc_loadWeakRetained((id *)(a1 + 32));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    id v8 = WeakRetained[16];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_10005C814;
    v9[3] = &unk_10072E198;
    id v10 = v5;
    char v11 = v7;
    dispatch_async(v8, v9);
  }
}

id sub_10005C814(uint64_t a1)
{
  if (([*(id *)(a1 + 32) isCanceled] & 1) == 0)
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      id v6 = "Successfully completed all device upgrade tasks.";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v9, 2u);
    }
LABEL_14:

    return objc_msgSend(*(id *)(a1 + 40), "_queue_completeDeviceUpgradeTasks");
  }
  uint64_t v2 = PDUpgradeTasksRetryCount();
  if (v2 > 2)
  {
    uint64_t v7 = PDUpgradeTasksVersion();
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 134217984;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Device upgrade tasks failed and have exceeded retry, marking upgrade task version: %ld as completed and resetting retries to 0", (uint8_t *)&v9, 0xCu);
    }

    PDSetUpgradeTasksVersion();
    if (v7 < 1) {
      return (id)PDSetUpgradeTasksRetryCount();
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      id v6 = "Device upgrade tasks completed after exceeding retries";
      goto LABEL_13;
    }
    goto LABEL_14;
  }
  uint64_t v3 = v2 + 1;
  id v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 134218240;
    uint64_t v10 = v3;
    __int16 v11 = 2048;
    uint64_t v12 = PDUpgradeTasksVersion();
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Device upgrade tasks failed and will retry at next scheduled activity with upgrade task version: %ld and retryCount: %ld", (uint8_t *)&v9, 0x16u);
  }

  return (id)PDSetUpgradeTasksRetryCount();
}

void sub_10005CA94(uint64_t a1)
{
  PDSetUpgradeTasksVersion();
  PDSetUpgradeTasksRetryCount();
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 40) context];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10005CB58;
  v3[3] = &unk_1007306B8;
  id v4 = *(id *)(a1 + 40);
  [v2 atomicallyUpdatePrimaryRegion:v3];
  [*(id *)(*(void *)(a1 + 32) + 48) archiveContext:v2];
}

id sub_10005CB58(uint64_t a1, void *a2)
{
  return [a2 regionBySettingLastDeviceUpgradeTaskBuildVersion:*(void *)(a1 + 32)];
}

void sub_10005CD00(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = PDDefaultQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10005CDE4;
  block[3] = &unk_10072E9D8;
  id v11 = v6;
  id v12 = v5;
  id v13 = *(id *)(a1 + 32);
  id v8 = v5;
  id v9 = v6;
  dispatch_async(v7, block);
}

uint64_t sub_10005CDE4(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      uint64_t v6 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Contact Information Fetch task failed with error: %@", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    uint64_t v3 = +[PKPaymentOptionsRecents defaultInstance];
    [v3 updateRecentsAndKeychainWithContactInformation:a1[5]];
  }

  return (*(uint64_t (**)(void, BOOL))(a1[6] + 16))(a1[6], a1[4] == 0);
}

id sub_10005D4A0(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_updateScheduledActivityIfNeccessary");
}

id sub_10005D654(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_updateScheduledActivityIfNeccessary");
}

id sub_10005D6D0(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_updateScheduledActivityIfNeccessary");
}

id sub_10005D74C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_updateScheduledActivityIfNeccessary");
}

void sub_10005D7EC(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) associatedAccountServiceAccountIdentifier];

  if (v2)
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "PDAccountStatementMetadataProcessor passAdded", v4, 2u);
    }

    objc_msgSend(*(id *)(a1 + 40), "_queue_updateScheduledActivityIfNeccessary");
  }
}

void sub_10005D914(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) associatedAccountServiceAccountIdentifier];

  if (v2)
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "PDAccountStatementMetadataProcessor passRemoved", v4, 2u);
    }

    objc_msgSend(*(id *)(a1 + 40), "_queue_updateScheduledActivityIfNeccessary");
  }
}

void sub_10005DA68(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Statement metadata process request starting %@", (uint8_t *)&buf, 0xCu);
  }

  id v4 = [*(id *)(a1 + 32) accountIdentifier];
  id v5 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v51 = 0x3032000000;
  id v52 = sub_10002075C;
  int v53 = sub_100020EA0;
  id v54 = 0;
  v48[0] = 0;
  v48[1] = v48;
  v48[2] = 0x3032000000;
  v48[3] = sub_10002075C;
  v48[4] = sub_100020EA0;
  id v49 = 0;
  v46[0] = 0;
  v46[1] = v46;
  v46[2] = 0x3032000000;
  v46[3] = sub_10002075C;
  v46[4] = sub_100020EA0;
  id v47 = 0;
  v44[0] = 0;
  v44[1] = v44;
  v44[2] = 0x3032000000;
  v44[3] = sub_10002075C;
  v44[4] = sub_100020EA0;
  id v45 = 0;
  v41[0] = _NSConcreteStackBlock;
  v41[1] = 3221225472;
  v41[2] = sub_10005DFD0;
  v41[3] = &unk_100730730;
  v41[4] = *(void *)(a1 + 40);
  id v6 = v4;
  id v42 = v6;
  p_long long buf = &buf;
  [v5 addOperation:v41];
  v36[0] = _NSConcreteStackBlock;
  v36[1] = 3221225472;
  v36[2] = sub_10005E1F4;
  v36[3] = &unk_100730AA8;
  id v39 = &buf;
  int8x16_t v15 = *(int8x16_t *)(a1 + 32);
  id v7 = (id)v15.i64[0];
  int8x16_t v37 = vextq_s8(v15, v15, 8uLL);
  id v8 = v6;
  id v38 = v8;
  id v40 = v46;
  [v5 addOperation:v36];
  v31[0] = _NSConcreteStackBlock;
  v31[1] = 3221225472;
  v31[2] = sub_10005E82C;
  v31[3] = &unk_100730AD0;
  v31[4] = *(void *)(a1 + 40);
  id v33 = v46;
  id v9 = v8;
  id v32 = v9;
  id v34 = v44;
  long long v35 = &buf;
  [v5 addOperation:v31];
  v26[0] = _NSConcreteStackBlock;
  v26[1] = 3221225472;
  v26[2] = sub_10005EB00;
  v26[3] = &unk_100730B48;
  v26[4] = *(void *)(a1 + 40);
  id v28 = &buf;
  uint64_t v29 = v46;
  id v30 = v44;
  id v10 = v9;
  id v27 = v10;
  [v5 addOperation:v26];
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  v23[2] = sub_10005F4F4;
  v23[3] = &unk_100730BC0;
  id v25 = v46;
  int8x16_t v16 = *(int8x16_t *)(a1 + 32);
  id v11 = (id)v16.i64[0];
  int8x16_t v24 = vextq_s8(v16, v16, 8uLL);
  [v5 addOperation:v23];
  id v12 = +[NSNull null];
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  id v17[2] = sub_10005F954;
  v17[3] = &unk_100730BE8;
  id v13 = v10;
  id v18 = v13;
  __int16 v20 = v46;
  __int16 v21 = &buf;
  id v19 = *(id *)(a1 + 48);
  uint64_t v22 = v48;
  id v14 = [v5 evaluateWithInput:v12 completion:v17];

  _Block_object_dispose(v44, 8);
  _Block_object_dispose(v46, 8);

  _Block_object_dispose(v48, 8);
  _Block_object_dispose(&buf, 8);
}

void sub_10005DF8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  _Block_object_dispose(&a61, 8);
  _Block_object_dispose((const void *)(v61 - 240), 8);
  _Block_object_dispose((const void *)(v61 - 192), 8);
  _Block_object_dispose((const void *)(v61 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_10005DFD0(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = a1[4];
  uint64_t v9 = a1[5];
  id v10 = *(void **)(v8 + 16);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  id v14[2] = sub_10005E0AC;
  v14[3] = &unk_100730A30;
  uint64_t v11 = a1[6];
  id v16 = v7;
  uint64_t v17 = v11;
  void v14[4] = v8;
  id v15 = v6;
  id v12 = v6;
  id v13 = v7;
  [v10 accountWithIdentifier:v9 completion:v14];
}

void sub_10005E0AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *(NSObject **)(v4 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10005E188;
  block[3] = &unk_100730A08;
  id v10 = v3;
  uint64_t v11 = v4;
  long long v8 = *(_OWORD *)(a1 + 48);
  id v6 = (id)v8;
  long long v13 = v8;
  id v12 = *(id *)(a1 + 40);
  id v7 = v3;
  dispatch_async(v5, block);
}

uint64_t sub_10005E188(uint64_t a1)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), *(id *)(a1 + 32));
  unsigned int v2 = objc_msgSend(*(id *)(a1 + 40), "_queue_isAccountEligible:", *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40));
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 56) + 16);
  uint64_t v5 = v2 ^ 1;
  uint64_t v6 = *(void *)(a1 + 56);
  return v4(v6, v3, v5);
}

void sub_10005E1F4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) type];
  long long v8 = PKAccountTypeToString();
  uint64_t v9 = [*(id *)(a1 + 40) statementIdentifier];

  if (v9)
  {
    id v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = [*(id *)(a1 + 40) statementIdentifier];
      *(_DWORD *)long long buf = 138412290;
      long long v36 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Using statement metadata from request to process %@", buf, 0xCu);
    }
    uint64_t v12 = [*(id *)(a1 + 40) statementIdentifier];
  }
  else
  {
    uint64_t v12 = objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "latestStatementIdentifierThatNeedsMetadataProcessingForAccountIdentifier:accountType:maxProcessedAttemptCount:", *(void *)(a1 + 48), objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), "type"), 3);
  }
  long long v13 = (void *)v12;
  id v14 = PKLogFacilityTypeGetObject();
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (v15)
    {
      uint64_t v16 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 138412802;
      long long v36 = v13;
      __int16 v37 = 2112;
      uint64_t v38 = v16;
      __int16 v39 = 2112;
      id v40 = v8;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Statement identifier that needs processing: %@, for account: %@, type: %@", buf, 0x20u);
    }

    uint64_t v17 = [*(id *)(*(void *)(a1 + 32) + 8) accountStatementMetadataForStatementIdentifier:v13 accountIdentifier:*(void *)(a1 + 48)];
    uint64_t v18 = *(void *)(*(void *)(a1 + 64) + 8);
    id v19 = *(void **)(v18 + 40);
    *(void *)(v18 + 40) = v17;

    if (*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40))
    {
      v7[2](v7, v6, 0);
    }
    else
    {
      __int16 v21 = *(void **)(*(void *)(a1 + 32) + 16);
      uint64_t v22 = *(void *)(a1 + 48);
      id v23 = [*(id *)(a1 + 40) reason];
      uint64_t v24 = 1;
      if (v23 != (id)1) {
        uint64_t v24 = 2;
      }
      if (v23 == (id)2) {
        uint64_t v25 = 3;
      }
      else {
        uint64_t v25 = v24;
      }
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472;
      void v28[2] = sub_10005E578;
      void v28[3] = &unk_100730A80;
      void v28[4] = *(void *)(a1 + 32);
      id v29 = v13;
      id v30 = *(id *)(a1 + 48);
      id v31 = v8;
      id v33 = v7;
      id v26 = v6;
      uint64_t v27 = *(void *)(a1 + 64);
      id v32 = v26;
      uint64_t v34 = v27;
      [v21 updateAccountStatementMetadataForStatementIdentifier:v29 accountIdentifier:v22 trigger:v25 completion:v28];
    }
  }
  else
  {
    if (v15)
    {
      __int16 v20 = *(void **)(a1 + 48);
      *(_DWORD *)long long buf = 138412290;
      long long v36 = v20;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Not processing statement metadata for account %@ since there are no statement identifiers to process", buf, 0xCu);
    }

    v7[2](v7, v6, 1);
  }
}

void sub_10005E578(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_10005E6AC;
  void v11[3] = &unk_100730A58;
  id v12 = v6;
  id v13 = *(id *)(a1 + 40);
  id v14 = *(id *)(a1 + 48);
  id v15 = *(id *)(a1 + 56);
  id v18 = *(id *)(a1 + 72);
  id v8 = *(id *)(a1 + 64);
  uint64_t v19 = *(void *)(a1 + 80);
  id v16 = v8;
  id v17 = v5;
  id v9 = v5;
  id v10 = v6;
  dispatch_async(v7, v11);
}

uint64_t sub_10005E6AC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 40);
      uint64_t v5 = *(void *)(a1 + 48);
      uint64_t v6 = *(void *)(a1 + 56);
      int v9 = 138413058;
      uint64_t v10 = v4;
      __int16 v11 = 2112;
      uint64_t v12 = v5;
      __int16 v13 = 2112;
      uint64_t v14 = v6;
      __int16 v15 = 2112;
      uint64_t v16 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Error getting statement metadata for statement identifier %@, account identifier %@, account type %@. Error %@", (uint8_t *)&v9, 0x2Au);
    }
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40), *(id *)(a1 + 72));
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40);
      int v9 = 138412290;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Recieved statement metadata %@", (uint8_t *)&v9, 0xCu);
    }
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 80) + 16))();
}

void sub_10005E82C(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  int v9 = a4;
  uint64_t v10 = *(void **)(*(void *)(a1[6] + 8) + 40);
  if (!v10)
  {
LABEL_6:
    v9[2](v9, v8, 1);
    goto LABEL_9;
  }
  if ([v10 hasBeenProcessed])
  {
    __int16 v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = (void *)a1[5];
      uint64_t v13 = *(void *)(*(void *)(a1[6] + 8) + 40);
      int v25 = 138412546;
      id v26 = v12;
      __int16 v27 = 2112;
      uint64_t v28 = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Not processing statement metadata for account %@ since it has already been processed %@", (uint8_t *)&v25, 0x16u);
    }

    goto LABEL_6;
  }
  uint64_t v14 = [*(id *)(*(void *)(a1[6] + 8) + 40) itemsMissingFromDevice];
  uint64_t v15 = *(void *)(a1[7] + 8);
  uint64_t v16 = *(void **)(v15 + 40);
  *(void *)(v15 + 40) = v14;

  if ([*(id *)(*(void *)(a1[7] + 8) + 40) count])
  {
    v9[2](v9, v8, 0);
  }
  else
  {
    id v17 = [*(id *)(*(void *)(a1[6] + 8) + 40) statementIdentifier];
    id v18 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = a1[5];
      [*(id *)(*(void *)(a1[8] + 8) + 40) type];
      __int16 v20 = PKAccountTypeToString();
      int v25 = 138412802;
      id v26 = v17;
      __int16 v27 = 2112;
      uint64_t v28 = v19;
      __int16 v29 = 2112;
      id v30 = v20;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "There are no items missing for statement %@, account identifier %@, account type %@. Marking the statement metadata items as processed.", (uint8_t *)&v25, 0x20u);
    }
    uint64_t v21 = [*(id *)(a1[4] + 8) markStatementMetadataItems:0 asProcessed:1 error:0 statementIdentifier:v17 accountIdentifier:a1[5]];
    uint64_t v22 = *(void *)(a1[6] + 8);
    id v23 = *(void **)(v22 + 40);
    *(void *)(v22 + 40) = v21;

    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = *(void **)(*(void *)(a1[6] + 8) + 40);
      int v25 = 138412290;
      id v26 = v24;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Updated statement metadata after processing: %@", (uint8_t *)&v25, 0xCu);
    }

    v9[2](v9, v8, 1);
  }
LABEL_9:
}

void sub_10005EB00(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v40 = a3;
  id v39 = a4;
  [*(id *)(*(void *)(a1[6] + 8) + 40) type];
  uint64_t v41 = PKPaymentTransactionAccountTypeFromAccountType();
  id v43 = objc_alloc_init((Class)NSMutableArray);
  id v42 = [*(id *)(*(void *)(a1[7] + 8) + 40) statementIdentifier];
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  id obj = *(id *)(*(void *)(a1[8] + 8) + 40);
  id v6 = [obj countByEnumeratingWithState:&v53 objects:v67 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v54;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v54 != v8) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = *(void **)(*((void *)&v53 + 1) + 8 * i);
        __int16 v11 = [v10 identifier];
        uint64_t v12 = [v10 zoneName];
        uint64_t v13 = [v10 originatorAltDSID];
        if (v11) {
          BOOL v14 = v12 == 0;
        }
        else {
          BOOL v14 = 1;
        }
        if (v14)
        {
          uint64_t v15 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            id v59 = v10;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "The zoneName or identifier wasnt defined on the item %@", buf, 0xCu);
          }
        }
        else
        {
          uint64_t v16 = *(void **)(a1[4] + 24);
          id v66 = v12;
          id v17 = +[NSArray arrayWithObjects:&v66 count:1];
          unsigned __int8 v18 = [v16 hasCachedCloudStoreZoneInApplePayContainerForZoneNames:v17];

          if (v18)
          {
            id v19 = [v10 type];
            if (v19 == (id)2)
            {
              __int16 v20 = [objc_alloc((Class)PKCloudStoreZoneQueryConfiguration) initWithTransactionSourceIdentifier:0 accountIdentifier:a1[5] accountType:v41 accountEventIdentifier:v11 altDSID:v13 zoneName:v12];
LABEL_21:
              uint64_t v15 = v20;
            }
            else
            {
              if (v19 == (id)1)
              {
                __int16 v20 = [objc_alloc((Class)PKCloudStoreZoneQueryConfiguration) initWithTransactionSourceIdentifier:0 accountIdentifier:a1[5] accountType:v41 serviceIdentifier:v11 altDSID:v13 zoneName:v12];
                goto LABEL_21;
              }
              uint64_t v15 = 0;
            }
            [v43 safelyAddObject:v15];
            goto LABEL_24;
          }
          uint64_t v21 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            [v10 type];
            uint64_t v22 = PKAccountStatementMetadataItemTypeToString();
            uint64_t v23 = a1[5];
            *(_DWORD *)long long buf = 138413058;
            id v59 = v12;
            __int16 v60 = 2112;
            uint64_t v61 = v11;
            __int16 v62 = 2112;
            long long v63 = v22;
            __int16 v64 = 2112;
            uint64_t v65 = v23;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "The zone %@ is not cached on device for identifier %@, type %@, and accountIdentifier %@", buf, 0x2Au);
          }
          uint64_t v24 = *(void **)(a1[4] + 8);
          id v57 = v10;
          uint64_t v15 = +[NSArray arrayWithObjects:&v57 count:1];
          id v25 = [v24 markStatementMetadataItems:v15 asProcessed:0 error:2 statementIdentifier:v42 accountIdentifier:a1[5]];
        }
LABEL_24:
      }
      id v7 = [obj countByEnumeratingWithState:&v53 objects:v67 count:16];
    }
    while (v7);
  }

  if ([v43 count])
  {
    id v26 = PKLogFacilityTypeGetObject();
    __int16 v27 = v42;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v59 = v43;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Fetching missing transactions with query configurations %@", buf, 0xCu);
    }

    uint64_t v28 = [*(id *)(a1[4] + 24) applePayContainer];
    uint64_t v29 = PKCloudStoreOperationGroupStatementMetadataProcessing;
    uint64_t v30 = PKCloudStoreOperationGroupSuffixStatementMetadataProcessing;
    v45[0] = _NSConcreteStackBlock;
    v45[1] = 3221225472;
    v45[2] = sub_10005F050;
    v45[3] = &unk_100730B20;
    uint64_t v31 = a1[7];
    id v32 = (void *)a1[5];
    void v45[4] = a1[4];
    uint64_t v50 = v31;
    id v33 = v32;
    uint64_t v34 = a1[8];
    id v46 = v33;
    uint64_t v51 = v34;
    id v35 = v42;
    uint64_t v36 = a1[6];
    id v47 = v35;
    uint64_t v52 = v36;
    __int16 v37 = v39;
    id v49 = v39;
    uint64_t v38 = v40;
    id v48 = v40;
    [v28 fetchItemsWithQueryConfigurations:v43 returnRecords:0 storeRecords:1 groupName:v29 groupSuffix:v30 completion:v45];
  }
  else
  {
    __int16 v37 = v39;
    uint64_t v38 = v40;
    (*((void (**)(id, id, void))v39 + 2))(v39, v40, 0);
    __int16 v27 = v42;
  }
}

void sub_10005F050(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = *(void *)(a1 + 32);
  id v6 = *(NSObject **)(v5 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10005F160;
  block[3] = &unk_100730AF8;
  uint64_t v19 = *(void *)(a1 + 72);
  id v13 = v4;
  uint64_t v14 = v5;
  id v7 = *(id *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 80);
  id v15 = v7;
  uint64_t v20 = v8;
  id v9 = *(id *)(a1 + 48);
  uint64_t v10 = *(void *)(a1 + 88);
  id v16 = v9;
  uint64_t v21 = v10;
  id v18 = *(id *)(a1 + 64);
  id v17 = *(id *)(a1 + 56);
  id v11 = v4;
  dispatch_async(v6, block);
}

uint64_t sub_10005F160(void *a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    int v28 = 138412290;
    uint64_t v29 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed fetching missing transactions from CloudKit with error: %@", (uint8_t *)&v28, 0xCu);
  }

  id v4 = *(void **)(a1[5] + 8);
  uint64_t v5 = [*(id *)(*(void *)(a1[10] + 8) + 40) statementIdentifier];
  uint64_t v6 = [v4 accountStatementMetadataForStatementIdentifier:v5 accountIdentifier:a1[6]];
  uint64_t v7 = *(void *)(a1[10] + 8);
  uint64_t v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(*(void *)(a1[10] + 8) + 40);
    int v28 = 138412290;
    uint64_t v29 = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Statement metadata after CloudKit fetching: %@", (uint8_t *)&v28, 0xCu);
  }

  uint64_t v10 = [*(id *)(*(void *)(a1[10] + 8) + 40) itemsMissingFromDevice];
  uint64_t v11 = *(void *)(a1[11] + 8);
  uint64_t v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  id v13 = [*(id *)(*(void *)(a1[11] + 8) + 40) count];
  BOOL v14 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (v14)
    {
      uint64_t v15 = *(void *)(*(void *)(a1[11] + 8) + 40);
      int v28 = 138412290;
      uint64_t v29 = v15;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Missing items after attempting CloudKit fetch and store: %@", (uint8_t *)&v28, 0xCu);
    }

    uint64_t v16 = [*(id *)(a1[5] + 8) markStatementMetadataItems:*(void *)(*(void *)(a1[11] + 8) + 40) asProcessed:0 error:1 statementIdentifier:a1[7] accountIdentifier:a1[6]];
    uint64_t v17 = *(void *)(a1[10] + 8);
    id v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;

    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *(void *)(*(void *)(a1[10] + 8) + 40);
      int v28 = 138412290;
      uint64_t v29 = v19;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Marking statement metadata as not processed: %@", (uint8_t *)&v28, 0xCu);
    }
  }
  else
  {
    if (v14)
    {
      uint64_t v21 = a1[6];
      uint64_t v20 = a1[7];
      [*(id *)(*(void *)(a1[12] + 8) + 40) type];
      uint64_t v22 = PKAccountTypeToString();
      int v28 = 138412802;
      uint64_t v29 = v20;
      __int16 v30 = 2112;
      uint64_t v31 = v21;
      __int16 v32 = 2112;
      id v33 = v22;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Successfully fetched all missing items from the statement metadata. Account identifier: %@, statement identifier %@, account type %@. Marking the statement metadata as processed.", (uint8_t *)&v28, 0x20u);
    }
    uint64_t v23 = [*(id *)(a1[5] + 8) markStatementMetadataItems:0 asProcessed:1 error:0 statementIdentifier:a1[7] accountIdentifier:a1[6]];
    uint64_t v24 = *(void *)(a1[10] + 8);
    id v25 = *(void **)(v24 + 40);
    *(void *)(v24 + 40) = v23;

    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = *(void *)(*(void *)(a1[10] + 8) + 40);
      int v28 = 138412290;
      uint64_t v29 = v26;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Updated statement metadata after processing: %@", (uint8_t *)&v28, 0xCu);
    }
  }

  return (*(uint64_t (**)(void))(a1[9] + 16))();
}

void sub_10005F4F4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) reportForMissingItems];
  uint64_t v9 = PKLogFacilityTypeGetObject();
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (v10)
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v23 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Sending statement metadata report to server: %@", buf, 0xCu);
    }

    uint64_t v11 = *(void **)(*(void *)(a1 + 32) + 16);
    id v12 = [*(id *)(a1 + 40) reason];
    uint64_t v13 = 1;
    if (v12 != (id)1) {
      uint64_t v13 = 2;
    }
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    id v17[2] = sub_10005F6F4;
    v17[3] = &unk_100730B98;
    uint64_t v14 = *(void *)(a1 + 32);
    uint64_t v15 = *(void *)(a1 + 48);
    if (v12 == (id)2) {
      uint64_t v16 = 3;
    }
    else {
      uint64_t v16 = v13;
    }
    void v17[4] = v14;
    uint64_t v21 = v15;
    id v18 = v8;
    id v20 = v7;
    id v19 = v6;
    [v11 sendAccountReport:v18 trigger:v16 completion:v17];
  }
  else
  {
    if (v10)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "There is no statement metadata report that needs to be sent to server", buf, 2u);
    }

    (*((void (**)(id, id, uint64_t))v7 + 2))(v7, v6, 1);
  }
}

void sub_10005F6F4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(NSObject **)(v4 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_10005F7E0;
  v7[3] = &unk_100730B70;
  uint64_t v13 = *(void *)(a1 + 64);
  id v8 = v3;
  uint64_t v9 = v4;
  id v10 = *(id *)(a1 + 40);
  id v12 = *(id *)(a1 + 56);
  id v11 = *(id *)(a1 + 48);
  id v6 = v3;
  dispatch_async(v5, v7);
}

uint64_t sub_10005F7E0(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2)
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 138412290;
      uint64_t v14 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Error sending statement metadata report to server: %@", (uint8_t *)&v13, 0xCu);
    }
  }
  uint64_t v4 = a1[6];
  uint64_t v5 = *(void **)(a1[5] + 8);
  id v6 = +[NSDate date];
  uint64_t v7 = [v5 updateStatementMetadataWithReport:v4 reportDate:v6];
  uint64_t v8 = *(void *)(a1[9] + 8);
  uint64_t v9 = *(void **)(v8 + 40);
  *(void *)(v8 + 40) = v7;

  id v10 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(*(void *)(a1[9] + 8) + 40);
    int v13 = 138412290;
    uint64_t v14 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Updated statement metadata after report sent to server: %@", (uint8_t *)&v13, 0xCu);
  }

  return (*(uint64_t (**)(void))(a1[8] + 16))();
}

void sub_10005F954(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = a1[4];
    id v10 = [*(id *)(*(void *)(a1[6] + 8) + 40) statementIdentifier];
    [*(id *)(*(void *)(a1[7] + 8) + 40) type];
    uint64_t v11 = PKAccountTypeToString();
    int v13 = 138412802;
    uint64_t v14 = v9;
    __int16 v15 = 2112;
    uint64_t v16 = v10;
    __int16 v17 = 2112;
    id v18 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Completed statement metadata processing: Account identifier: %@, statement identifier %@, account type %@.", (uint8_t *)&v13, 0x20u);
  }
  uint64_t v12 = a1[5];
  if (v12) {
    (*(void (**)(uint64_t, void, void))(v12 + 16))(v12, *(void *)(*(void *)(a1[6] + 8) + 40), *(void *)(*(void *)(a1[8] + 8) + 40));
  }
}

void sub_10005FE60(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = [PDAccountStatementMetadataProcessorRequest alloc];
  uint64_t v9 = [*(id *)(a1 + 32) accountIdentifier];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_10005FF98;
  v15[3] = &unk_100730C38;
  id v10 = *(void **)(a1 + 48);
  void v15[4] = *(void *)(a1 + 40);
  id v16 = v10;
  id v11 = *(id *)(a1 + 56);
  id v18 = v6;
  id v19 = v7;
  id v17 = v11;
  id v12 = v6;
  id v13 = v7;
  uint64_t v14 = [(PDAccountStatementMetadataProcessorRequest *)v8 initWithAccountIdentifier:v9 statementIdentifier:0 reason:2 completion:v15];

  [*(id *)(a1 + 40) _addRequestToProcessQueue:v14];
}

void sub_10005FF98(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100060068;
  v3[3] = &unk_100730C10;
  id v4 = *(id *)(a1 + 40);
  id v5 = *(id *)(a1 + 48);
  id v7 = *(id *)(a1 + 64);
  id v6 = *(id *)(a1 + 56);
  dispatch_async(v2, v3);
}

uint64_t sub_100060068(void *a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = a1[4];
    uint64_t v4 = a1[5];
    int v6 = 138412546;
    uint64_t v7 = v3;
    __int16 v8 = 2112;
    uint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed scheduled activity AccountStatementMetadataActivity for account identifier %@, type %@", (uint8_t *)&v6, 0x16u);
  }

  return (*(uint64_t (**)(void))(a1[7] + 16))();
}

id sub_100060134(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 52) = 0;
  return objc_msgSend(*(id *)(a1 + 32), "_queue_updateScheduledActivityIfNeccessary");
}

void sub_10006048C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(NSObject **)(*(void *)(a1 + 32) + 40);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_10006056C;
  void v11[3] = &unk_100730198;
  id v12 = *(id *)(a1 + 40);
  id v13 = v5;
  uint64_t v8 = *(void *)(a1 + 32);
  id v14 = v6;
  uint64_t v15 = v8;
  id v9 = v6;
  id v10 = v5;
  dispatch_async(v7, v11);
}

id sub_10006056C(uint64_t a1)
{
  [*(id *)(a1 + 32) callCompletionsWithStatementMetadata:*(void *)(a1 + 40) error:*(void *)(a1 + 48)];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 48));
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(void **)(v2 + 64);
  *(void *)(v2 + 64) = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 56) + 48));
  uint64_t v4 = *(void **)(a1 + 56);
  return [v4 _executeNextRequestIfPossible];
}

id sub_10006067C(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_isAccountEligible:", a2);
}

void sub_100061518(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100061530(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v2 + 24))
  {
    unsigned __int8 v3 = [*(id *)(a1 + 32) setValue:0 forProperty:@"processed_auth_mechanisms"];
    uint64_t v2 = *(void *)(*(void *)(a1 + 40) + 8);
  }
  else
  {
    unsigned __int8 v3 = 0;
  }
  *(unsigned char *)(v2 + 24) = v3;
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v4 + 24))
  {
    unsigned __int8 v5 = [*(id *)(a1 + 32) setValue:0 forProperty:@"data_collected_auth_mechanisms"];
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  }
  else
  {
    unsigned __int8 v5 = 0;
  }
  *(unsigned char *)(v4 + 24) = v5;
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v6 + 24))
  {
    unsigned __int8 v7 = [*(id *)(a1 + 32) setValue:0 forProperty:@"complete"];
    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  }
  else
  {
    unsigned __int8 v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v8 + 24))
  {
    unsigned __int8 v9 = [*(id *)(a1 + 32) setValue:0 forProperty:@"auth_data_payment_pin"];
    uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  }
  else
  {
    unsigned __int8 v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v10 + 24))
  {
    unsigned __int8 v11 = [*(id *)(a1 + 32) setValue:0 forProperty:@"auth_data_transaction_signature"];
    uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
  }
  else
  {
    unsigned __int8 v11 = 0;
  }
  *(unsigned char *)(v10 + 24) = v11;
  uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v12 + 24))
  {
    unsigned __int8 v13 = [*(id *)(a1 + 32) setValue:0 forProperty:@"auth_data_user_confirmation"];
    uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
  }
  else
  {
    unsigned __int8 v13 = 0;
  }
  *(unsigned char *)(v12 + 24) = v13;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
}

void sub_100061B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose((const void *)(v39 - 208), 8);
  _Block_object_dispose((const void *)(v39 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_100061BF0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_100061CB8;
  void v12[3] = &unk_100730D28;
  unsigned __int8 v9 = *(void **)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  id v14 = v7;
  uint64_t v15 = v8;
  id v13 = v6;
  id v10 = v6;
  id v11 = v7;
  [v9 fetchHomesWithCompletion:v12];
}

uint64_t sub_100061CB8(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 firstObject];
  uint64_t v4 = *(void *)(*(void *)(a1 + 48) + 8);
  unsigned __int8 v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  id v6 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  return v6();
}

void sub_100061D28(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  uint64_t v16 = *(void *)(a1 + 32);
  unsigned __int8 v9 = +[NSArray arrayWithObjects:&v16 count:1];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_100061E58;
  void v12[3] = &unk_100730D78;
  long long v15 = *(_OWORD *)(a1 + 48);
  id v13 = v6;
  id v14 = v7;
  id v10 = v6;
  id v11 = v7;
  [v8 inviteUsersWithInviteInformation:v9 completionHandler:v12];
}

void sub_100061E58(void *a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = [a2 firstObject];
  uint64_t v7 = *(void *)(a1[6] + 8);
  uint64_t v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  uint64_t v9 = *(void *)(a1[7] + 8);
  id v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v5;
  id v12 = v5;

  if (*(void *)(*(void *)(a1[7] + 8) + 40)) {
    BOOL v11 = 1;
  }
  else {
    BOOL v11 = *(void *)(*(void *)(a1[6] + 8) + 40) == 0;
  }
  (*(void (**)(void, void, BOOL))(a1[5] + 16))(a1[5], a1[4], v11);
}

void sub_100061F20(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v6 = a4;
  id v13 = a3;
  id v7 = objc_alloc((Class)PKSharingHomeInvitation);
  uint64_t v8 = [*(id *)(a1 + 32) displayInformation];
  uint64_t v9 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) appleSharingDict];
  id v10 = [v7 initWithDisplayInformation:v8 appleSharingDict:v9];
  uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
  id v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  v6[2](v6, v13, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0);
}

void sub_100062014(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (([a4 isCanceled] & 1) != 0
    || *(void *)(*(void *)(a1[6] + 8) + 40)
    || (uint64_t v7 = *(void *)(*(void *)(a1[7] + 8) + 40)) == 0)
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(*(void *)(a1[6] + 8) + 40);
      int v10 = 138412290;
      uint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SharingManagementService: Unable to created home share message, error: %@", (uint8_t *)&v10, 0xCu);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  else
  {
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412290;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "SharingManagementService: successfully created home share message. \n %@", (uint8_t *)&v10, 0xCu);
    }

    uint64_t v9 = objc_alloc_init(PDCreateShareContext);
    [(PDCreateShareContext *)v9 addInvite:*(void *)(*(void *)(a1[7] + 8) + 40) primary:1];
    (*(void (**)(void))(a1[5] + 16))();
  }
}

Class sub_100062200()
{
  if (qword_100808B48 != -1) {
    dispatch_once(&qword_100808B48, &stru_100730E10);
  }
  Class result = objc_getClass("HMUserInviteInformation");
  qword_100808B38 = (uint64_t)result;
  off_1008050E0 = (uint64_t (*)())sub_100062264;
  return result;
}

id sub_100062264()
{
  return (id)qword_100808B38;
}

void sub_100062270(id a1)
{
  qword_100808B40 = (uint64_t)dlopen("/System/Library/Frameworks/HomeKit.framework/HomeKit", 2);
}

void sub_1000626C8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = [CloudStoreContainerChangeEvent alloc];
  id v5 = [*(id *)(a1 + 32) database];
  uint64_t v8 = [(SQLiteEntity *)v4 initWithPersistentID:a2 inDatabase:v5];

  uint64_t v6 = *(void **)(a1 + 40);
  uint64_t v7 = [(CloudStoreContainerChangeEvent *)v8 event];
  [v6 safelyAddObject:v7];
}

void sub_100062C4C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_100063204(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
}

void sub_10006320C(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
  uint64_t v4 = a2;
  -[PKCloudStoreContainerChangeEvent setEventType:](v4, "setEventType:", [a3 integerValue]);
}

void sub_100063264(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
  uint64_t v4 = a2;
  -[PKCloudStoreContainerChangeEvent setChangeType:](v4, "setChangeType:", [a3 integerValue]);
}

void sub_1000632BC(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
  uint64_t v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKCloudStoreContainerChangeEvent *)v3 setTimestamp:v4];
}

void sub_10006331C(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
}

void sub_100063324(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
}

void sub_10006332C(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
}

void sub_100063334(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
}

void sub_10006333C(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
}

void sub_100063344(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
}

void sub_10006334C(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
  id v4 = a2;
  id v5 = [a3 componentsSeparatedByString:@","];
  [(PKCloudStoreContainerChangeEvent *)v4 setObjectNames:v5];
}

void sub_1000633B8(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
}

void sub_1000633C0(id a1, PKCloudStoreContainerChangeEvent *a2, id a3)
{
  id v4 = a2;
  -[PKCloudStoreContainerChangeEvent setTimeInterval:](v4, "setTimeInterval:", (double)(uint64_t)[a3 integerValue]);
}

void sub_1000636B0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = +[NSNumber numberWithLongLong:a2];
  [v2 addObject:v3];
}

void sub_100063860(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  id v8 = objc_alloc_init((Class)PKAccountPromotion);
  [*(id *)(a1 + 56) applyPropertySetters:*(void *)(a1 + 32) toObject:v8 withProperties:v7 values:a4];

  [*(id *)(a1 + 56) populateAssociatedCompletionStepsForPromotion:v8 promotionPID:a2 inDatabase:*(void *)(a1 + 40)];
  [*(id *)(a1 + 48) addObject:v8];
}

void sub_100064430(id a1, PKAccountPromotion *a2, id a3)
{
}

void sub_100064438(id a1, PKAccountPromotion *a2, id a3)
{
  id v4 = a2;
  -[PKAccountPromotion setType:](v4, "setType:", [a3 integerValue]);
}

void sub_100064490(id a1, PKAccountPromotion *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKAccountPromotion *)v3 setStartDate:v4];
}

void sub_1000644F0(id a1, PKAccountPromotion *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKAccountPromotion *)v3 setEndDate:v4];
}

void sub_100064550(id a1, PKAccountPromotion *a2, id a3)
{
}

void sub_100064558(id a1, PKAccountPromotion *a2, id a3)
{
}

void sub_100064560(id a1, PKAccountPromotion *a2, id a3)
{
  id v4 = a2;
  -[PKAccountPromotion setImpressionCount:](v4, "setImpressionCount:", [a3 integerValue]);
}

void sub_1000646F8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_10006501C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_1000651A4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v8 = objc_alloc_init((Class)PKPeerPaymentAccountInvitation);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v8 withProperties:v6 values:a4];

  id v7 = v8;
  if (v8)
  {
    objc_msgSend(*(id *)(a1 + 40), "addObject:");
    id v7 = v8;
  }
}

void sub_1000652F8(id a1, PKPeerPaymentAccountInvitation *a2, id a3)
{
}

void sub_100065300(id a1, PKPeerPaymentAccountInvitation *a2, id a3)
{
  id v4 = a2;
  -[PKPeerPaymentAccountInvitation setStatus:](v4, "setStatus:", [a3 integerValue]);
}

void sub_100065358(id a1, PKPeerPaymentAccountInvitation *a2, id a3)
{
  id v4 = a2;
  -[PKPeerPaymentAccountInvitation setRegistrationResult:](v4, "setRegistrationResult:", [a3 integerValue]);
}

void sub_1000653B0(id a1, PKPeerPaymentAccountInvitation *a2, id a3)
{
  id v4 = a2;
  -[PKPeerPaymentAccountInvitation setRemoteRegistrationRequestLevel:](v4, "setRemoteRegistrationRequestLevel:", [a3 integerValue]);
}

void sub_10006545C(id a1)
{
  id v1 = [[PDXPCEventStreamsManager alloc] _init];
  uint64_t v2 = qword_100808B50;
  qword_100808B50 = (uint64_t)v1;
  _objc_release_x1(v1, v2);
}

void sub_1000655B4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) _managerForEventStream:@"com.apple.nsurlsessiond-events"];
}

void sub_100065690(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 8);
  if (v2)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x290], 8) = v2 + 1;
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
      int v6 = 134349056;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDXPCEventStreamsManager: deferral count %{public}lu.", (uint8_t *)&v6, 0xCu);
    }
  }
}

void sub_1000657C8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(v1 + 8);
  if (v2)
  {
    *(void *)(v1 + _Block_object_dispose(&STACK[0x290], 8) = v2 - 1;
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v5 = PKLogFacilityTypeGetObject();
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (v4)
    {
      if (v6)
      {
        *(_DWORD *)long long buf = 134349056;
        uint64_t v16 = v4;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "PDXPCEventStreamsManager: deferral count %{public}lu.", buf, 0xCu);
      }
    }
    else
    {
      if (v6)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "PDXPCEventStreamsManager: delivering deferred events for all streams.", buf, 2u);
      }

      long long v13 = 0u;
      long long v14 = 0u;
      long long v11 = 0u;
      long long v12 = 0u;
      uint64_t v5 = objc_msgSend(*(id *)(*(void *)(a1 + 32) + 16), "objectEnumerator", 0);
      id v7 = [v5 countByEnumeratingWithState:&v11 objects:v17 count:16];
      if (v7)
      {
        id v8 = v7;
        uint64_t v9 = *(void *)v12;
        do
        {
          int v10 = 0;
          do
          {
            if (*(void *)v12 != v9) {
              objc_enumerationMutation(v5);
            }
            [*(id *)(*((void *)&v11 + 1) + 8 * (void)v10) beginEventDelivery];
            int v10 = (char *)v10 + 1;
          }
          while (v8 != v10);
          id v8 = [v5 countByEnumeratingWithState:&v11 objects:v17 count:16];
        }
        while (v8);
      }
    }
  }
}

void sub_100065AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100065AC4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) _managerForEventStream:*(void *)(a1 + 40)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;
  return _objc_release_x1(v2, v4);
}

void sub_100065C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100065C48(void *a1)
{
  uint64_t v2 = [*(id *)(a1[4] + 16) objectForKeyedSubscript:a1[5]];
  uint64_t v3 = *(void *)(a1[6] + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;
  return _objc_release_x1(v2, v4);
}

void PDXPCEventStreamRegisterObserver(void *a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  id v7 = a1;
  id v8 = +[PDXPCEventStreamsManager eventStreamManager];
  [v8 registerObserver:v7 forEventStream:v6 withReplyQueue:v5];
}

void PDXPCEventStreamRegisterForLaunchEvents()
{
  id v0 = +[PDXPCEventStreamsManager eventStreamManager];
  [v0 registerForLaunchEvents];
}

void PDXPCEventStreamPauseEventDelivery()
{
  id v0 = +[PDXPCEventStreamsManager eventStreamManager];
  [v0 pauseEventDelivery];
}

void PDXPCEventStreamBeginEventDelivery()
{
  id v0 = +[PDXPCEventStreamsManager eventStreamManager];
  [v0 beginEventDelivery];
}

id sub_100066238(uint64_t a1)
{
  return [*(id *)(a1 + 40) _deliverEvents:*(void *)(a1 + 48) eventsWerePreviouslyDeferred:1];
}

id *sub_1000675B8(id *result, uint64_t a2, uint64_t a3, void *a4)
{
  if (*a4) {
    return (id *)objc_msgSend(result[4], "addObject:");
  }
  return result;
}

void sub_10006782C(uint64_t a1, uint64_t a2)
{
  id v5 = [(SQLiteEntity *)[PayLaterFinancingPlan alloc] initWithPersistentID:a2 inDatabase:*(void *)(a1 + 32)];
  uint64_t v3 = *(void **)(a1 + 40);
  uint64_t v4 = [(PayLaterFinancingPlan *)v5 planIdentifier];
  objc_msgSend(v3, "pk_safelyAddObject:", v4);
}

void sub_100067AC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100067AE0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v14 = (id)objc_claimAutoreleasedReturnValue();
  id v5 = *(id *)(a3 + 8);
  if (v14) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    id v7 = PKCurrencyAmountMake();
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v9 = *(void **)(v8 + 40);
    if (v9)
    {
      uint64_t v10 = [v9 currencyAmountByAddingCurrencyAmount:v7];
      uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
      long long v12 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = v10;
    }
    else
    {
      id v13 = v7;
      long long v12 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v13;
    }
  }
}

void sub_100067D04(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  id v19 = objc_alloc_init((Class)PKPayLaterFinancingPlan);
  [*(id *)(a1 + 56) applyPropertySetters:*(void *)(a1 + 32) toObject:v19 withProperties:v7 values:a4];

  uint64_t v8 = +[PayLaterFinancingPlanSummary anyInDatabase:*(void *)(a1 + 40) forFinancingPlanPID:a2];
  uint64_t v9 = [v8 planSummary];

  [v19 setPlanSummary:v9];
  uint64_t v10 = +[PayLaterMerchant anyInDatabase:*(void *)(a1 + 40) forFinancingPlanPID:a2];
  uint64_t v11 = [v10 payLaterMerchant];

  [v19 setMerchant:v11];
  long long v12 = +[PayLaterFinancingPlanScheduleSummary anyInDatabase:*(void *)(a1 + 40) forFinancingPlanPID:a2];
  id v13 = [v12 scheduleSummary];

  [v19 setScheduleSummary:v13];
  id v14 = +[PayLaterFinancingPlanFundingSource anyInDatabase:*(void *)(a1 + 40) forPlanPID:a2];
  long long v15 = [v14 fundingSource];
  [v19 setFundingSource:v15];

  uint64_t v16 = +[PayLaterFinancingPlanDispute financingPlanDisputesForFinancingPlanPID:a2 inDatabase:*(void *)(a1 + 40)];
  [v19 setDisputes:v16];
  id v17 = +[PayLaterFinancingPlanTermsDetails anyInDatabase:*(void *)(a1 + 40) forFinancingPlanPID:a2];
  id v18 = [v17 termsDetails];

  [v19 setTermsDetails:v18];
  if (v19) {
    [*(id *)(a1 + 48) addObject:v19];
  }
}

void sub_10006848C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_100069034(id a1, PKPayLaterFinancingPlan *a2, id a3)
{
}

void sub_10006903C(id a1, PKPayLaterFinancingPlan *a2, id a3)
{
  uint64_t v4 = a2;
  -[PKPayLaterFinancingPlan setProductType:](v4, "setProductType:", [a3 integerValue]);
}

void sub_100069094(id a1, PKPayLaterFinancingPlan *a2, id a3)
{
  uint64_t v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPayLaterFinancingPlan *)v3 setLastUpdated:v4];
}

void sub_1000690F4(id a1, PKPayLaterFinancingPlan *a2, id a3)
{
  id v4 = a2;
  -[PKPayLaterFinancingPlan setState:](v4, "setState:", [a3 integerValue]);
}

void sub_10006914C(id a1, PKPayLaterFinancingPlan *a2, id a3)
{
  id v4 = a2;
  -[PKPayLaterFinancingPlan setPlanChannel:](v4, "setPlanChannel:", [a3 integerValue]);
}

void sub_1000691A4(id a1, PKPayLaterFinancingPlan *a2, id a3)
{
  id v4 = a2;
  -[PKPayLaterFinancingPlan setStateReason:](v4, "setStateReason:", [a3 integerValue]);
}

void sub_1000691FC(id a1, PKPayLaterFinancingPlan *a2, id a3)
{
  id v4 = a2;
  -[PKPayLaterFinancingPlan setRequiresGenericMessaging:](v4, "setRequiresGenericMessaging:", [a3 BOOLValue]);
}

void sub_100069254(id a1, PKPayLaterFinancingPlan *a2, id a3)
{
  id v4 = a2;
  -[PKPayLaterFinancingPlan setCancellable:](v4, "setCancellable:", [a3 BOOLValue]);
}

void sub_1000692AC(id a1, PKPayLaterFinancingPlan *a2, id a3)
{
}

void sub_100069534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10006954C(uint64_t a1)
{
  id v2 = [objc_alloc(*(Class *)(a1 + 64)) initWithPendingProvisioning:*(void *)(a1 + 32) forBasePendingProvisioning:*(void *)(a1 + 40) inDatabase:*(void *)(a1 + 48)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) != 0;
}

void sub_1000696C8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  uint64_t v9 = *(void **)(a1 + 40);
  id v10 = a3;
  uint64_t v11 = [v9 _propertySetters];
  [v9 applyPropertySetters:v11 toObject:*(void *)(a1 + 32) withProperties:v10 values:a4];

  *a6 = 1;
}

void sub_100069994(id a1, PKPendingAccountCredential *a2, id a3)
{
}

void sub_10006999C(id a1, PKPendingAccountCredential *a2, id a3)
{
  uint64_t v3 = a2;
  [(PKPendingAccountCredential *)v3 setFeature:PKFeatureIdentifierFromString()];
}

void sub_1000699F4(id a1, PKPendingAccountCredential *a2, id a3)
{
}

void sub_100069E24(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_100069E90(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v7 = objc_alloc_init((Class)PKCategoryVisualizationMagnitude);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v7 withProperties:v6 values:a4];

  [*(id *)(a1 + 40) addObject:v7];
}

void sub_10006A18C(id a1, PKCategoryVisualizationMagnitude *a2, id a3)
{
}

void sub_10006A194(id a1, PKCategoryVisualizationMagnitude *a2, id a3)
{
  id v4 = a2;
  -[PKCategoryVisualizationMagnitude setBucket:](v4, "setBucket:", [a3 integerValue]);
}

void sub_10006A1EC(id a1, PKCategoryVisualizationMagnitude *a2, id a3)
{
  id v4 = a2;
  [a3 doubleValue];
  -[PKCategoryVisualizationMagnitude setMagnitude:](v4, "setMagnitude:");
}

void sub_10006ACC4(uint64_t a1)
{
  id v6 = (id)PDOSTransactionCreate("PDPassLibrary");
  uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 88) passesOfStyles:*(void *)(a1 + 48)];
  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [*(id *)(a1 + 32) _entitlementFilteredPasses:v3];
  (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v5);
}

void sub_10006AED0(uint64_t a1)
{
  id v6 = (id)PDOSTransactionCreate("PDPassLibrary");
  uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 88) passWithProvisioningCredentialHash:*(void *)(a1 + 40)];
  uint64_t v4 = *(void *)(a1 + 48);
  id v5 = [*(id *)(a1 + 32) _sanitizePassIfNeeded:v3];
  (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v5);
}

void sub_10006B614(uint64_t a1)
{
  if (PKIsMac())
  {
    _PDOpenPaymentSetupUI(0, 0);
  }
  else if (PKPassbookIsCurrentlyDeletedByUser())
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Prompting user to install Wallet", buf, 2u);
    }

    id v6 = *(id *)(a1 + 40);
    PKShowAlertForWalletUninstalled();
  }
  else
  {
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = v3[3];
    id v5 = [v3 connection];
    sub_10020CF7C(v4, 0, v5, 0, 0);
  }
}

uint64_t sub_10006B774(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10006BF34(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10006C078(void *a1)
{
  if ([*(id *)(a1[4] + 8) passesAllAccess])
  {
    uint64_t v2 = [*(id *)(a1[4] + 88) passUniqueIdentifierWithAssociatedAccountIdentifier:a1[5]];
    uint64_t v3 = a1[6];
    id v7 = (id)v2;
    uint64_t v4 = objc_msgSend(*(id *)(a1[4] + 88), "passWithUniqueIdentifier:");
    id v5 = [v4 paymentPass];
    (*(void (**)(uint64_t, void *))(v3 + 16))(v3, v5);
  }
  else
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      uint64_t v9 = "-[PDPassLibrary paymentPassWithAssociatedAccountIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    (*(void (**)(void))(a1[6] + 16))();
  }
}

uint64_t sub_10006C428(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_10006C578(uint64_t a1)
{
  v44[0] = _NSConcreteStackBlock;
  v44[1] = 3221225472;
  v44[2] = sub_10006CB9C;
  v44[3] = &unk_100731560;
  v44[4] = *(void *)(a1 + 32);
  id v45 = *(id *)(a1 + 48);
  uint64_t v2 = objc_retainBlock(v44);
  if (([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess] & 1) == 0)
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v4 = "Must have payment all access entitlement";
LABEL_8:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, buf, 2u);
    }
LABEL_9:

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    goto LABEL_10;
  }
  if (PKPassbookIsCurrentlyDeletedByUser())
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Wallet must not be deleted", buf, 2u);
    }
    goto LABEL_9;
  }
  id v5 = *(void **)(a1 + 40);
  if (!v5 || (v6 = [v5 isPeerPaymentRequest], id v5 = *(void **)(a1 + 40), (v6 & 1) != 0))
  {
LABEL_13:
    if ([v5 requestType] == (id)3
      || [*(id *)(a1 + 40) isVirtualCardRequest])
    {
      id v7 = *(void **)(*(void *)(a1 + 32) + 88);
      uint64_t v8 = [*(id *)(a1 + 40) passTypeIdentifier];
      uint64_t v9 = [*(id *)(a1 + 40) passSerialNumber];
      id v10 = [v7 passWithPassTypeID:v8 serialNumber:v9];
      uint64_t v11 = [v10 paymentPass];
      ((void (*)(void *, void *))v2[2])(v2, v11);

      goto LABEL_10;
    }
    id v22 = [*(id *)(a1 + 40) requestType];
    uint64_t v23 = *(void **)(a1 + 40);
    if (v22 == (id)5)
    {
      uint64_t v24 = [v23 installmentConfiguration];
      [v24 feature];
      uint64_t v25 = PKFeatureIdentifierFromPaymentSetupFeatureType();

      uint64_t v26 = *(void *)(a1 + 32);
      __int16 v27 = *(void **)(v26 + 152);
      v39[0] = _NSConcreteStackBlock;
      v39[1] = 3221225472;
      v39[2] = sub_10006CF38;
      v39[3] = &unk_10072E9B0;
      void v39[4] = v26;
      id v40 = *(id *)(a1 + 48);
      [v27 defaultAccountForFeature:v25 completion:v39];
      int v28 = v40;
LABEL_29:

      goto LABEL_10;
    }
    if ([v23 requestType] == (id)4)
    {
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v31 = *(void **)(v30 + 152);
      v37[0] = _NSConcreteStackBlock;
      v37[1] = 3221225472;
      v37[2] = sub_10006D060;
      v37[3] = &unk_10072E9B0;
      v37[4] = v30;
      id v38 = *(id *)(a1 + 48);
      [v31 defaultAccountForFeature:2 completion:v37];
      int v28 = v38;
      goto LABEL_29;
    }
    if ([*(id *)(a1 + 40) isPayLaterPaymentRequest])
    {
      __int16 v32 = [*(id *)(a1 + 40) payLaterPaymentRequest];
      if ([v32 hasAvailableFundingSource]) {
        uint64_t v33 = 1;
      }
      else {
        uint64_t v33 = 2;
      }
      (*(void (**)(void, uint64_t, void, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), v33, 0, 0);

      goto LABEL_10;
    }
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v4 = "Error: Unsupported payment request type being checked";
      goto LABEL_8;
    }
    goto LABEL_9;
  }
  if ([v5 requestType]
    && [*(id *)(a1 + 40) requestType] != (id)8
    && [*(id *)(a1 + 40) requestType] != (id)10)
  {
    id v5 = *(void **)(a1 + 40);
    goto LABEL_13;
  }
  long long v12 = +[NSSet setWithObjects:](NSSet, "setWithObjects:", &off_10078A9F8, &off_10078AA10, &off_10078AA28, &off_10078AA40, &off_10078AA58, &off_10078AA70, 0);
  id v13 = [*(id *)(a1 + 40) supportedNetworks];
  id v14 = [v13 count];

  if (v14)
  {
    uint64_t v36 = *(void **)(a1 + 32);
    long long v15 = [*(id *)(a1 + 40) supportedNetworks];
    uint64_t v16 = +[NSSet setWithArray:v15];
    id v35 = [*(id *)(a1 + 40) merchantCapabilities];
    id v17 = [*(id *)(a1 + 40) originatingURL];
    id v18 = [v17 host];
    id v19 = [*(id *)(a1 + 40) supportedCountries];
    id v20 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 40) requestType]);
    unsigned __int8 v21 = [*(id *)(a1 + 40) isMultiTokenRequest];
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 3221225472;
    v41[2] = sub_10006CD1C;
    v41[3] = &unk_1007315B0;
    id v42 = v2;
    LOBYTE(v34) = v21;
    [v36 _passesWithSupportedNetworks:v16 merchantCapabilities:v35 webDomain:v18 issuerCountryCodes:v19 paymentApplicationStates:v12 paymentRequestType:v20 isMultiTokensRequest:v34 handler:v41];
  }
  else
  {
    uint64_t v29 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Error: No supported networks provided, payment request not possible to complete.", buf, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }

LABEL_10:
}

void sub_10006CB9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    id v5 = [v3 uniqueID];
    switch((unint64_t)[v4 activationState])
    {
      case 0uLL:
      case 1uLL:
      case 2uLL:
      case 4uLL:
        break;
      case 3uLL:
        unsigned __int8 v6 = [v4 devicePrimaryPaymentApplication];
        [v6 state];

        break;
      default:
        id v7 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unexpected state found, returning invalid", v8, 2u);
        }

        break;
    }
  }
  else
  {
    id v5 = 0;
    [*(id *)(*(void *)(a1 + 32) + 88) passExistsWithPassType:1];
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10006CD1C(uint64_t a1, void *a2)
{
  id v3 = [a2 allObjects];
  id v4 = [v3 mutableCopy];

  id v5 = PDDefaultPaymentPassUniqueIdentifier();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10006CDFC;
  v8[3] = &unk_100731588;
  void v8[4] = v5;
  [v4 sortUsingComparator:v8];
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = [v4 firstObject];
  (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v7);
}

uint64_t sub_10006CDFC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [v5 activationState];
  id v8 = [v6 activationState];
  if (v7 != v8)
  {
    if (!v7) {
      goto LABEL_15;
    }
    if (!v8) {
      goto LABEL_17;
    }
    if (v7 == (id)2) {
      goto LABEL_15;
    }
    if (v8 == (id)2) {
      goto LABEL_17;
    }
    if (v7 == (id)1) {
      goto LABEL_15;
    }
    if (v8 == (id)1) {
      goto LABEL_17;
    }
    if (v7 == (id)3)
    {
LABEL_15:
      uint64_t v15 = -1;
      goto LABEL_18;
    }
    if (v8 == (id)3) {
      goto LABEL_17;
    }
  }
  uint64_t v9 = [v5 uniqueID];
  unsigned __int8 v10 = [v9 isEqualToString:*(void *)(a1 + 32)];

  if (v10) {
    goto LABEL_15;
  }
  uint64_t v11 = [v6 uniqueID];
  unsigned __int8 v12 = [v11 isEqualToString:*(void *)(a1 + 32)];

  if (v12)
  {
LABEL_17:
    uint64_t v15 = 1;
    goto LABEL_18;
  }
  id v13 = [v5 ingestedDate];
  id v14 = [v6 ingestedDate];
  if ([v13 compare:v14] == (id)-1) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = -1;
  }

LABEL_18:
  return v15;
}

void sub_10006CF38(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v7 = v3;
  if (v3)
  {
    id v4 = [v3 associatedPassUniqueID];
    if ([v7 state] == (id)1)
    {
      id v5 = [*(id *)(*(void *)(a1 + 32) + 88) passWithUniqueIdentifier:v4];
      id v6 = [v5 paymentPass];

      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    else
    {
      [v7 state];
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_10006D060(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v6 = [a2 associatedPassUniqueID];
    id v3 = [*(id *)(*(void *)(a1 + 32) + 88) passWithUniqueIdentifier:v6];
    id v4 = [v3 paymentPass];

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    id v5 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v5();
  }
}

void sub_10006D3C4(uint64_t a1)
{
  uint64_t v2 = (void *)PDOSTransactionCreate("PDPassLibrary");
  id v4 = 0;
  id v5 = 0;
  [*(id *)(*(void *)(a1 + 32) + 88) getCatalog:&v4 passes:&v5 dbStates:0 ofPassTypes:*(void *)(a1 + 48) limitResults:*(unsigned __int8 *)(a1 + 56)];
  [*(id *)(a1 + 32) _sanitizePasses:v5];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t sub_10006D474(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10006D494(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10006D4A4(uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 40);
  id v4 = [v2[11] paymentPassesPendingActivation];
  id v3 = [v2 _entitlementFilteredPasses:v4];
  (*(void (**)(uint64_t, void *))(v1 + 16))(v1, v3);
}

id sub_10006D5FC(uint64_t a1)
{
  id result = [*(id *)(*(void *)(a1 + 40) + 8) passesAllAccess];
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    id v4 = *(void **)(*(void *)(a1 + 40) + 80);
    return [v4 writeCatalogOfRecord:v3 source:4];
  }
  return result;
}

void *sub_10006D6D0(void *result, uint64_t a2)
{
  if (a2) {
    return _[*(id *)(result[4] + 120) notifyPassUsed:a2 fromSource:result[5]];
  }
  return result;
}

id sub_10006D8E0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1 + 32) _entitledForObject:v3 forActions:2])
  {
    id v4 = [*(id *)(a1 + 32) _sanitizePassIfNeeded:v3];
    id v5 = [v4 secureElementPass];
  }
  else
  {
    id v5 = 0;
  }

  return v5;
}

void sub_10006DB7C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  char v6 = *(unsigned char *)(a1 + 80);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_10006DC4C;
  v10[3] = &unk_100731678;
  uint64_t v7 = *(void *)(a1 + 72);
  id v8 = *(id *)(a1 + 64);
  void v10[4] = *(void *)(a1 + 32);
  id v11 = v8;
  LOBYTE(v9) = v6;
  [v2 _paymentPassesForNetworks:v3 capabilities:v7 issuerCountryCodes:v4 webPayment:0 paymentApplicationStates:0 paymentRequestType:v5 isMultiTokensRequest:v9 withHandler:v10];
}

void sub_10006DC4C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) _entitlementFilteredPasses:a2];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_10006DDE0(uint64_t a1)
{
  id v3 = *(void **)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  char v7 = *(unsigned char *)(a1 + 80);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_10006DEE0;
  void v11[3] = &unk_1007316C8;
  id v8 = v2;
  uint64_t v9 = *(void *)(a1 + 72);
  id v12 = v8;
  uint64_t v15 = v9;
  id v13 = *(id *)(a1 + 48);
  id v14 = *(id *)(a1 + 64);
  LOBYTE(v10) = v7;
  [v3 _paymentPassesForNetworks:v8 capabilities:v4 issuerCountryCodes:v5 webPayment:0 paymentApplicationStates:0 paymentRequestType:v6 isMultiTokensRequest:v10 withHandler:v11];
}

uint64_t sub_10006DEE0(void *a1, void *a2)
{
  id v3 = [a2 count];
  uint64_t v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[7];
    uint64_t v6 = a1[4];
    uint64_t v7 = a1[5];
    int v9 = 138544130;
    uint64_t v10 = v6;
    __int16 v11 = 1026;
    int v12 = v5;
    __int16 v13 = 2114;
    uint64_t v14 = v7;
    __int16 v15 = 1026;
    BOOL v16 = v3 != 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "-hasInAppPaymentPassesForNetworks:%{public}@ capabilities:%{public}x issuerCountryCodes:%{public}@ returns %{public}d", (uint8_t *)&v9, 0x22u);
  }

  return (*(uint64_t (**)(void))(a1[6] + 16))();
}

void sub_10006E1A0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (!v5)
  {
    if (*(void *)(a1 + 40))
    {
      uint64_t v5 = 0;
    }
    else
    {
      if (![v3 count])
      {
        (*(void (**)(void, id))(*(void *)(a1 + 80) + 16))(*(void *)(a1 + 80), [*(id *)(a1 + 48) _hasPaymentPassesForNetworks:*(void *)(a1 + 56) capabilities:*(void *)(a1 + 88) paymentApplicationStates:*(void *)(a1 + 64)]);
        goto LABEL_7;
      }
      uint64_t v5 = *(void *)(a1 + 32);
    }
  }
  uint64_t v6 = *(void **)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 72);
  char v10 = *(unsigned char *)(a1 + 96);
  uint64_t v13 = *(void *)(a1 + 40);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  id v14[2] = sub_10006E2D4;
  v14[3] = &unk_1007315B0;
  uint64_t v11 = *(void *)(a1 + 88);
  id v15 = *(id *)(a1 + 80);
  LOBYTE(v12) = v10;
  [v6 _passesWithSupportedNetworks:v7 merchantCapabilities:v11 webDomain:v5 issuerCountryCodes:v13 paymentApplicationStates:v8 paymentRequestType:v9 isMultiTokensRequest:v12 handler:v14];

LABEL_7:
}

uint64_t sub_10006E2D4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = [a2 count] != 0;
  uint64_t v4 = *(uint64_t (**)(uint64_t, BOOL))(v2 + 16);
  return v4(v2, v3);
}

void sub_10006E570(uint64_t a1, void *a2)
{
  id v5 = [a2 mutableCopy];
  if ([*(id *)(a1 + 32) containsObject:PKPaymentNetworkPrivateLabel])
  {
    BOOL v3 = *(void **)(a1 + 48);
    if (*(void *)(a1 + 40)) {
      objc_msgSend(v3, "_inAppPrivateLabelPaymentPassesForWebDomain:issuerCountryCodes:paymentApplicationStates:isMultiTokensRequest:");
    }
    else {
    uint64_t v4 = objc_msgSend(v3, "_inAppPrivateLabelPaymentPassesForApplicationIdentifier:issuerCountryCodes:paymentApplicationStates:isMultiTokensRequest:");
    }
    [v5 unionSet:v4];
  }
  (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
}

void sub_10006E88C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10006E8A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v19;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v19 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v18 + 1) + 8 * i);
        if ([v8 state] != (id)1)
        {
          uint64_t v9 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
          v17[0] = _NSConcreteStackBlock;
          v17[1] = 3221225472;
          id v17[2] = sub_10006EA70;
          v17[3] = &unk_100731740;
          void v17[4] = v8;
          uint64_t v10 = [v9 objectsPassingTest:v17];
          uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
          uint64_t v12 = *(void **)(v11 + 40);
          *(void *)(v11 + 40) = v10;
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }
    while (v5);
  }
  uint64_t v13 = *(void *)(a1 + 32);
  uint64_t v14 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  if (v14)
  {
    id v15 = [v14 copy];
  }
  else
  {
    id v15 = +[NSSet set];
  }
  BOOL v16 = v15;
  (*(void (**)(uint64_t, id))(v13 + 16))(v13, v15);
}

uint64_t sub_10006EA70(uint64_t a1, void *a2)
{
  id v3 = [a2 associatedAccountServiceAccountIdentifier];
  id v4 = [*(id *)(a1 + 32) accountIdentifier];
  uint64_t v5 = [v3 isEqualToString:v4] ^ 1;

  return v5;
}

void sub_10006F000(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  id v2 = [*(id *)(a1 + 32) _inAppPrivateLabelPaymentPassesForApplicationIdentifier:*(void *)(a1 + 40) issuerCountryCodes:*(void *)(a1 + 48) paymentApplicationStates:0 isMultiTokensRequest:*(unsigned __int8 *)(a1 + 64)];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void sub_10006F1CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  id v2 = [*(id *)(a1 + 32) _inAppPrivateLabelPaymentPassesForWebDomain:*(void *)(a1 + 40) issuerCountryCodes:*(void *)(a1 + 48) paymentApplicationStates:0 isMultiTokensRequest:*(unsigned __int8 *)(a1 + 64)];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void sub_10006F3A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  id v2 = [*(id *)(a1 + 32) _inAppPrivateLabelPaymentPassesForApplicationIdentifier:*(void *)(a1 + 40) issuerCountryCodes:*(void *)(a1 + 48) paymentApplicationStates:0 isMultiTokensRequest:*(unsigned __int8 *)(a1 + 64)];
  (*(void (**)(uint64_t, BOOL))(v1 + 16))(v1, [v2 count] != 0);
}

void sub_10006F57C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  id v2 = [*(id *)(a1 + 32) _inAppPrivateLabelPaymentPassesForWebDomain:*(void *)(a1 + 40) issuerCountryCodes:*(void *)(a1 + 48) paymentApplicationStates:0 isMultiTokensRequest:*(unsigned __int8 *)(a1 + 64)];
  (*(void (**)(uint64_t, BOOL))(v1 + 16))(v1, [v2 count] != 0);
}

void sub_10006F724(uint64_t a1)
{
  id v2 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [*(id *)(a1 + 32) count]);
  uint64_t v5 = _NSConcreteStackBlock;
  uint64_t v6 = 3221225472;
  uint64_t v7 = sub_10006F800;
  uint64_t v8 = &unk_1007317B8;
  id v3 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  id v10 = v2;
  id v4 = v2;
  [v3 enumerateObjectsUsingBlock:&v5];
  objc_msgSend(*(id *)(a1 + 40), "_sanitizePasses:", v4, v5, v6, v7, v8, v9);
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

uint64_t sub_10006F800(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(*(void *)(a1 + 32) + 88) passWithUniqueIdentifier:a2];
  id v4 = v3;
  if (v3)
  {
    id v6 = v3;
    id v3 = [*(id *)(a1 + 32) _entitledForObject:v3 forActions:2];
    id v4 = v6;
    if (v3)
    {
      id v3 = [*(id *)(a1 + 40) addObject:v6];
      id v4 = v6;
    }
  }
  return _objc_release_x1(v3, v4);
}

void sub_10006FA78(uint64_t a1, void *a2)
{
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  id obj = a2;
  id v3 = [obj countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v16;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v16 != v5) {
          objc_enumerationMutation(obj);
        }
        uint64_t v7 = *(void **)(*((void *)&v15 + 1) + 8 * (void)v6);
        dispatch_group_enter(*(dispatch_group_t *)(a1 + 32));
        uint64_t v8 = *(void **)(a1 + 40);
        uint64_t v9 = [v7 uniqueID];
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 3221225472;
        id v11[2] = sub_10006FC18;
        void v11[3] = &unk_10072F630;
        id v12 = *(id *)(a1 + 48);
        uint64_t v13 = v7;
        id v14 = *(id *)(a1 + 32);
        [v8 supportsSearchForPassUniqueID:v9 completion:v11];

        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [obj countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v4);
  }
}

void sub_10006FC18(uint64_t a1, int a2)
{
  if (a2) {
    [*(id *)(a1 + 32) addObject:*(void *)(a1 + 40)];
  }
  id v3 = *(NSObject **)(a1 + 48);
  dispatch_group_leave(v3);
}

void sub_10006FC58(uint64_t a1)
{
  [*(id *)(a1 + 32) _sanitizePasses:*(void *)(a1 + 40)];
  uint64_t v2 = *(void *)(a1 + 48);
  id v3 = [*(id *)(a1 + 40) copy];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_10006FEAC(uint64_t a1)
{
  id v28 = objc_alloc_init((Class)NSMutableSet);
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 88) passes];
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  id v3 = [v2 countByEnumeratingWithState:&v34 objects:v42 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v35;
    uint64_t v30 = v2;
    uint64_t v31 = a1;
    uint64_t v29 = *(void *)v35;
    do
    {
      id v6 = 0;
      id v32 = v4;
      do
      {
        if (*(void *)v35 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void **)(*((void *)&v34 + 1) + 8 * (void)v6);
        if ([v7 passType] == (id)1)
        {
          uint64_t v8 = [v7 associatedApplicationIdentifiers];
          id v9 = *(id *)(a1 + 40);
          id v10 = v8;
          uint64_t v11 = v10;
          if (v9 && [v10 count])
          {
            long long v40 = 0u;
            long long v41 = 0u;
            long long v38 = 0u;
            long long v39 = 0u;
            uint64_t v33 = v11;
            id v12 = v11;
            id v13 = [v12 countByEnumeratingWithState:&v38 objects:v43 count:16];
            if (v13)
            {
              id v14 = v13;
              uint64_t v15 = *(void *)v39;
              while (2)
              {
                for (uint64_t i = 0; i != v14; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v39 != v15) {
                    objc_enumerationMutation(v12);
                  }
                  long long v17 = *(void **)(*((void *)&v38 + 1) + 8 * i);
                  if ([v17 hasSuffix:@".*"])
                  {
                    uint64_t v18 = objc_msgSend(v17, "substringToIndex:", (char *)objc_msgSend(v17, "length") - 1);
                    if (v18)
                    {
                      long long v19 = (void *)v18;
                      unsigned __int8 v20 = [v9 hasPrefix:v18];

                      if (v20) {
                        goto LABEL_28;
                      }
                    }
                  }
                  else
                  {
                    id v21 = v9;
                    id v22 = v17;
                    if (v22 == v21)
                    {

LABEL_28:
                      uint64_t v25 = [v7 uniqueID];
                      [v28 addObject:v25];

                      goto LABEL_29;
                    }
                    uint64_t v23 = v22;
                    if (v22)
                    {
                      unsigned __int8 v24 = [v21 isEqualToString:v22];

                      if (v24) {
                        goto LABEL_28;
                      }
                    }
                    else
                    {
                    }
                  }
                }
                id v14 = [v12 countByEnumeratingWithState:&v38 objects:v43 count:16];
                if (v14) {
                  continue;
                }
                break;
              }
            }

LABEL_29:
            uint64_t v2 = v30;
            a1 = v31;
            uint64_t v5 = v29;
            id v4 = v32;
            uint64_t v11 = v33;
          }
          else
          {
          }
        }
        id v6 = (char *)v6 + 1;
      }
      while (v6 != v4);
      id v4 = [v2 countByEnumeratingWithState:&v34 objects:v42 count:16];
    }
    while (v4);
  }
  uint64_t v26 = *(void *)(a1 + 48);
  id v27 = [v28 copy];
  (*(void (**)(uint64_t, id))(v26 + 16))(v26, v27);
}

void sub_1000702F4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = *(void **)(v1 + 88);
  uint64_t v4 = *(void *)(v1 + 96);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_1000703A8;
  v5[3] = &unk_100731808;
  id v6 = *(id *)(a1 + 48);
  [v3 fieldMetadataForFieldWithProperties:v2 withExpressPassManager:v4 completion:v5];
}

uint64_t sub_1000703A8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000705B8(void *a1)
{
  uint64_t v1 = a1[6];
  id v4 = [*(id *)(a1[4] + 80) objectWithUniqueID:a1[5]];
  uint64_t v2 = [v4 dataAccessor];
  id v3 = [v2 manifestHash];
  (*(void (**)(uint64_t, void *))(v1 + 16))(v1, v3);
}

void sub_10007075C(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess])
  {
    id v3 = [*(id *)(*(void *)(a1 + 32) + 88) passesEnabledForValuedAddedServicesWithAutomaticSelection:1];
    [*(id *)(a1 + 32) _sanitizePasses:v3];
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v2 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v2();
  }
}

id sub_1000708D4(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) _sanitizePassIfNeeded:a2];
  if ([v3 passType] == (id)1)
  {
    if (*(void *)(a1 + 40))
    {
      id v4 = [v3 associatedWebDomains];
      id v5 = [v4 containsObject:*(void *)(a1 + 40)];
    }
    else
    {
      id v5 = 0;
    }
  }
  else
  {
    id v5 = [*(id *)(a1 + 32) _entitledForObject:v3 forActions:2];
  }

  return v5;
}

id sub_100070A20(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) _sanitizePassIfNeeded:a2];
  if ([v3 passType] == (id)1)
  {
    if (*(void *)(a1 + 40))
    {
      id v4 = [v3 associatedApplicationIdentifiers];
      id v5 = [v4 containsObject:*(void *)(a1 + 40)];
    }
    else
    {
      id v5 = 0;
    }
  }
  else
  {
    id v5 = [*(id *)(a1 + 32) _entitledForObject:v3 forActions:2];
  }

  return v5;
}

void sub_10007107C(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess])
  {
    PDDefaultPaymentPassUniqueIdentifier();
    id v6 = (id)objc_claimAutoreleasedReturnValue();
    uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 88) passWithUniqueIdentifier:v6];
    uint64_t v3 = *(void *)(a1 + 40);
    id v4 = [v2 paymentPass];
    (*(void (**)(uint64_t, void *))(v3 + 16))(v3, v4);
  }
  else
  {
    id v5 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v5();
  }
}

void sub_100071344(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess]
    && (uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 96)) != 0)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    _DWORD v5[2] = sub_100071434;
    v5[3] = &unk_100731678;
    id v3 = *(id *)(a1 + 40);
    void v5[4] = *(void *)(a1 + 32);
    id v6 = v3;
    sub_10018E054(v2, 2, v5);
  }
  else
  {
    id v4 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v4();
  }
}

void sub_100071434(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = *(void **)(*(void *)(a1 + 32) + 88);
  id v6 = [a2 anyObject];
  id v4 = [v6 passUniqueIdentifier];
  id v5 = [v3 passWithUniqueIdentifier:v4];
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v5);
}

void sub_1000715E0(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess]
    && (uint64_t v2 = *(void *)(a1 + 32), *(void *)(v2 + 96)))
  {
    uint64_t v3 = [*(id *)(v2 + 88) passesOfType:1];
    id v4 = objc_alloc_init((Class)NSMutableDictionary);
    long long v49 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    uint64_t v27 = a1;
    id v28 = (void *)v3;
    id v5 = [*(id *)(a1 + 32) _entitlementFilteredPasses:v3];
    id v6 = [v5 allObjects];

    id obj = v6;
    id v31 = [v6 countByEnumeratingWithState:&v49 objects:v56 count:16];
    if (v31)
    {
      uint64_t v30 = *(void *)v50;
      do
      {
        uint64_t v7 = 0;
        do
        {
          if (*(void *)v50 != v30) {
            objc_enumerationMutation(obj);
          }
          uint64_t v32 = v7;
          uint64_t v8 = *(void **)(*((void *)&v49 + 1) + 8 * v7);
          long long v45 = 0u;
          long long v46 = 0u;
          long long v47 = 0u;
          long long v48 = 0u;
          id v35 = [v8 paymentApplications];
          id v9 = [v35 countByEnumeratingWithState:&v45 objects:v55 count:16];
          if (v9)
          {
            id v10 = v9;
            uint64_t v11 = *(void *)v46;
            uint64_t v33 = *(void *)v46;
            do
            {
              id v12 = 0;
              id v34 = v10;
              do
              {
                if (*(void *)v46 != v11) {
                  objc_enumerationMutation(v35);
                }
                id v13 = *(void **)(*((void *)&v45 + 1) + 8 * (void)v12);
                if ([v13 paymentType] == (id)1000)
                {
                  long long v36 = v12;
                  long long v43 = 0u;
                  long long v44 = 0u;
                  long long v41 = 0u;
                  long long v42 = 0u;
                  id v14 = [v13 supportedTransitNetworkIdentifiers];
                  id v15 = [v14 countByEnumeratingWithState:&v41 objects:v54 count:16];
                  if (v15)
                  {
                    id v16 = v15;
                    uint64_t v17 = *(void *)v42;
                    do
                    {
                      for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
                      {
                        if (*(void *)v42 != v17) {
                          objc_enumerationMutation(v14);
                        }
                        uint64_t v19 = *(void *)(*((void *)&v41 + 1) + 8 * i);
                        unsigned __int8 v20 = [v4 objectForKey:v19];
                        if (v20)
                        {
                          id v21 = [objc_alloc((Class)NSMutableArray) initWithArray:v20];
                          [v21 addObject:v8];
                        }
                        else
                        {
                          long long v53 = v8;
                          id v21 = +[NSArray arrayWithObjects:&v53 count:1];
                        }
                        [v4 setObject:v21 forKey:v19];
                      }
                      id v16 = [v14 countByEnumeratingWithState:&v41 objects:v54 count:16];
                    }
                    while (v16);
                  }

                  uint64_t v11 = v33;
                  id v10 = v34;
                  id v12 = v36;
                }
                id v12 = (char *)v12 + 1;
              }
              while (v12 != v10);
              id v10 = [v35 countByEnumeratingWithState:&v45 objects:v55 count:16];
            }
            while (v10);
          }

          uint64_t v7 = v32 + 1;
        }
        while ((id)(v32 + 1) != v31);
        id v31 = [obj countByEnumeratingWithState:&v49 objects:v56 count:16];
      }
      while (v31);
    }

    id v22 = PDDefaultPaymentPassUniqueIdentifier();
    uint64_t v23 = *(void *)(*(void *)(v27 + 32) + 96);
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 3221225472;
    v37[2] = sub_100071A38;
    v37[3] = &unk_1007318A8;
    id v38 = v4;
    id v39 = v22;
    id v40 = *(id *)(v27 + 40);
    id v24 = v22;
    id v25 = v4;
    sub_10018E790(v23, v37);
  }
  else
  {
    uint64_t v26 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v26();
  }
}

void sub_100071A38(uint64_t a1, void *a2)
{
  id v3 = a2;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  v23[2] = sub_100071CA4;
  v23[3] = &unk_10072FC48;
  id v4 = objc_alloc_init((Class)NSMutableSet);
  id v24 = v4;
  [v3 enumerateObjectsUsingBlock:v23];
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id obj = [*(id *)(a1 + 32) allKeys];
  id v5 = [obj countByEnumeratingWithState:&v19 objects:v25 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v20;
    do
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v20 != v7) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void *)(*((void *)&v19 + 1) + 8 * i);
        id v10 = [*(id *)(a1 + 32) objectForKey:v9];
        id v11 = [v10 copy];

        v16[0] = _NSConcreteStackBlock;
        v16[1] = 3221225472;
        v16[2] = sub_100071D34;
        v16[3] = &unk_100731880;
        id v17 = v4;
        id v18 = *(id *)(a1 + 40);
        id v12 = [v11 sortedArrayUsingComparator:v16];
        [*(id *)(a1 + 32) setObject:v12 forKey:v9];
      }
      id v6 = [obj countByEnumeratingWithState:&v19 objects:v25 count:16];
    }
    while (v6);
  }

  uint64_t v13 = *(void *)(a1 + 48);
  id v14 = [*(id *)(a1 + 32) copy];
  (*(void (**)(uint64_t, id))(v13 + 16))(v13, v14);
}

void sub_100071CA4(uint64_t a1, void *a2)
{
  id v7 = a2;
  id v3 = [v7 passInformation];
  id v4 = [v3 cardType];

  if (v4 == (id)2)
  {
    id v5 = *(void **)(a1 + 32);
    id v6 = [v7 passUniqueIdentifier];
    [v5 addObject:v6];
  }
}

uint64_t sub_100071D34(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[PKTransitPassProperties passPropertiesForPass:v5];
  uint64_t v8 = +[PKTransitPassProperties passPropertiesForPass:v6];
  unsigned int v9 = [v7 isEnRoute];
  unsigned __int8 v10 = [v8 isEnRoute];
  if (v9) {
    uint64_t v11 = -1;
  }
  else {
    uint64_t v11 = 1;
  }
  if ((v9 & 1) == 0 && (v10 & 1) == 0)
  {
    uint64_t v12 = [v7 balance];
    uint64_t v13 = [v8 balance];
    id v14 = v13;
    uint64_t v27 = (void *)v12;
    if (v12 && v13)
    {
      uint64_t v11 = (uint64_t)[v13 compare:v12];
    }
    else if (v12)
    {
      uint64_t v11 = -1;
    }
    else
    {
      uint64_t v11 = v13 != 0;
    }
    id v15 = *(void **)(a1 + 32);
    id v16 = [v5 uniqueID];
    unsigned int v17 = [v15 containsObject:v16];

    id v18 = *(void **)(a1 + 32);
    long long v19 = [v6 uniqueID];
    LODWORD(v1_Block_object_dispose(&STACK[0x290], 8) = [v18 containsObject:v19];

    if (v17 == v18)
    {
      if (v11) {
        char v20 = v17;
      }
      else {
        char v20 = 0;
      }
      if ((v20 & 1) == 0)
      {
        long long v21 = [v5 uniqueID];
        int v22 = PKEqualObjects();

        uint64_t v23 = [v6 uniqueID];
        int v24 = PKEqualObjects();

        uint64_t v25 = -1;
        if (!v22) {
          uint64_t v25 = 1;
        }
        if (v22 != v24) {
          uint64_t v11 = v25;
        }
      }
    }
    else if (v17)
    {
      uint64_t v11 = -1;
    }
    else
    {
      uint64_t v11 = 1;
    }
  }
  return v11;
}

void sub_100072068(id *a1)
{
  if ([*((id *)a1[4] + 1) passesAllAccess] && (uint64_t v2 = (id *)a1[4], v2[12]))
  {
    id v3 = [v2[11] passesOfType:1];
    id v4 = [a1[4] _entitlementFilteredPasses:v3];
    id v5 = [v4 allObjects];
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    v16[2] = sub_100072260;
    v16[3] = &unk_1007318D0;
    id v17 = a1[5];
    id v6 = objc_msgSend(v5, "pk_objectsPassingTest:", v16);

    id v7 = PDDefaultPaymentPassUniqueIdentifier();
    uint64_t v8 = *((void *)a1[4] + 12);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    id v12[2] = sub_10007239C;
    void v12[3] = &unk_1007318A8;
    id v13 = v6;
    id v14 = v7;
    id v15 = a1[6];
    id v9 = v7;
    id v10 = v6;
    sub_10018E790(v8, v12);
  }
  else
  {
    uint64_t v11 = (void (*)(void))*((void *)a1[6] + 2);
    v11();
  }
}

uint64_t sub_100072260(uint64_t a1, void *a2)
{
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  uint64_t v2 = objc_msgSend(a2, "paymentApplications", 0);
  id v3 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v13;
    while (2)
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v13 != v5) {
          objc_enumerationMutation(v2);
        }
        id v7 = *(void **)(*((void *)&v12 + 1) + 8 * i);
        if ([v7 paymentType] == (id)1000)
        {
          uint64_t v8 = [v7 appletDataFormat];
          char v9 = PKEqualObjects();

          if (v9)
          {
            uint64_t v10 = 1;
            goto LABEL_12;
          }
        }
      }
      id v4 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }
  uint64_t v10 = 0;
LABEL_12:

  return v10;
}

void sub_10007239C(uint64_t a1, void *a2)
{
  id v3 = a2;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1000724E8;
  void v11[3] = &unk_10072FC48;
  id v4 = objc_alloc_init((Class)NSMutableSet);
  id v12 = v4;
  [v3 enumerateObjectsUsingBlock:v11];

  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100072578;
  v8[3] = &unk_100731880;
  id v9 = v4;
  uint64_t v5 = *(void **)(a1 + 32);
  id v10 = *(id *)(a1 + 40);
  id v6 = v4;
  id v7 = [v5 sortedArrayUsingComparator:v8];
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1000724E8(uint64_t a1, void *a2)
{
  id v7 = a2;
  id v3 = [v7 passInformation];
  id v4 = [v3 cardType];

  if (v4 == (id)2)
  {
    uint64_t v5 = *(void **)(a1 + 32);
    id v6 = [v7 passUniqueIdentifier];
    [v5 addObject:v6];
  }
}

uint64_t sub_100072578(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = +[PKTransitPassProperties passPropertiesForPass:v5];
  uint64_t v8 = +[PKTransitPassProperties passPropertiesForPass:v6];
  unsigned int v9 = [v7 isEnRoute];
  unsigned __int8 v10 = [v8 isEnRoute];
  if (v9) {
    uint64_t v11 = -1;
  }
  else {
    uint64_t v11 = 1;
  }
  if ((v9 & 1) == 0 && (v10 & 1) == 0)
  {
    uint64_t v12 = [v7 balance];
    long long v13 = [v8 balance];
    long long v14 = v13;
    uint64_t v27 = (void *)v12;
    if (v12 && v13)
    {
      uint64_t v11 = (uint64_t)[v13 compare:v12];
    }
    else if (v12)
    {
      uint64_t v11 = -1;
    }
    else
    {
      uint64_t v11 = v13 != 0;
    }
    long long v15 = *(void **)(a1 + 32);
    id v16 = [v5 uniqueID];
    unsigned int v17 = [v15 containsObject:v16];

    id v18 = *(void **)(a1 + 32);
    long long v19 = [v6 uniqueID];
    LODWORD(v1_Block_object_dispose(&STACK[0x290], 8) = [v18 containsObject:v19];

    if (v17 == v18)
    {
      if (v11) {
        char v20 = v17;
      }
      else {
        char v20 = 0;
      }
      if ((v20 & 1) == 0)
      {
        long long v21 = [v5 uniqueID];
        int v22 = PKEqualObjects();

        uint64_t v23 = [v6 uniqueID];
        int v24 = PKEqualObjects();

        uint64_t v25 = -1;
        if (!v22) {
          uint64_t v25 = 1;
        }
        if (v22 != v24) {
          uint64_t v11 = v25;
        }
      }
    }
    else if (v17)
    {
      uint64_t v11 = -1;
    }
    else
    {
      uint64_t v11 = 1;
    }
  }
  return v11;
}

void sub_100072D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose((const void *)(v41 - 224), 8);
  _Block_object_dispose((const void *)(v41 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_100072DC8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(*(void *)(a1 + 32) + 64);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_100072EBC;
  void v12[3] = &unk_100731948;
  id v9 = *(id *)(a1 + 40);
  id v14 = v6;
  id v15 = v7;
  id v13 = v9;
  long long v16 = *(_OWORD *)(a1 + 48);
  uint64_t v17 = *(void *)(a1 + 64);
  id v10 = v6;
  id v11 = v7;
  [v8 performHandlerOnSharedWebServiceQueue:v12];
}

void sub_100072EBC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init(PDSharingManagementRetrievePartnerEncryptionCertificateRequest);
  id v5 = [v3 targetDevice];
  [(PDSharingManagementRetrievePartnerEncryptionCertificateRequest *)v4 setTargetDevice:v5];
  id v6 = [*(id *)(a1 + 32) passTypeIdentifier];
  [(PDSharingManagementRequest *)v4 setRegionIdentifier:v6];
  id v7 = [*(id *)(a1 + 32) serialNumber];
  [(PDSharingManagementRetrievePartnerEncryptionCertificateRequest *)v4 setPassSerialNumber:v7];

  uint64_t v8 = [v3 context];
  id v9 = [v8 deviceID];
  if (v9)
  {
    id v10 = [v8 regionForIdentifier:v6];
    id v11 = v10;
    if (v10)
    {
      id v12 = v10;
    }
    else
    {
      id v12 = [v8 primaryRegion];
    }
    long long v16 = v12;
    int v22 = v12;

    uint64_t v17 = [v16 brokerURL];
    id v18 = [v5 appleAccountInformation];
    long long v19 = [(PDSharingManagementRetrievePartnerEncryptionCertificateRequest *)v4 urlRequestWithServiceURL:v17 deviceIdentifier:v9 appleAccountInformation:v18];

    id v20 = [v3 nextTaskID];
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472;
    v23[2] = sub_100073138;
    v23[3] = &unk_100731920;
    id v24 = v3;
    long long v27 = *(_OWORD *)(a1 + 64);
    long long v21 = *(void **)(a1 + 48);
    uint64_t v28 = *(void *)(a1 + 56);
    id v26 = v21;
    id v25 = *(id *)(a1 + 40);
    [v24 performRequest:v19 taskIdentifier:v20 retries:1 authHandling:0 completionHandler:v23];
  }
  else
  {
    uint64_t v13 = +[NSError errorWithDomain:PKAddSecureElementPassErrorDomain code:0 userInfo:0];
    uint64_t v14 = *(void *)(*(void *)(a1 + 56) + 8);
    id v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = v13;

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_100073138(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v25 = 0;
  id v26 = &v25;
  uint64_t v27 = 0x3032000000;
  uint64_t v28 = sub_1000207AC;
  uint64_t v29 = sub_100020EC8;
  id v30 = 0;
  id v10 = (void *)a1[4];
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_100073408;
  void v22[3] = &unk_1007318F8;
  id v24 = &v25;
  id v11 = v7;
  id v23 = v11;
  if ([v10 _resultForResponse:v8 error:v9 successHandler:v22] != (id)1 && !v9)
  {
    NSErrorUserInfoKey v31 = NSLocalizedDescriptionKey;
    CFStringRef v32 = @"Received non 2XX http status code";
    id v12 = +[NSDictionary dictionaryWithObjects:&v32 forKeys:&v31 count:1];
    id v9 = +[NSError errorWithDomain:PKAddSecureElementPassErrorDomain code:0 userInfo:v12];
  }
  uint64_t v13 = (void *)v26[5];
  if (v13)
  {
    id v14 = v13;
    uint64_t v15 = [v14 certificate];
    uint64_t v16 = *(void *)(a1[7] + 8);
    uint64_t v17 = *(void **)(v16 + 40);
    *(void *)(v16 + 40) = v15;

    id v18 = [v14 supportedEncryptionSchemes];
    uint64_t v19 = [v18 firstObject];
    uint64_t v20 = *(void *)(a1[8] + 8);
    long long v21 = *(void **)(v20 + 40);
    *(void *)(v20 + 40) = v19;

    objc_storeStrong((id *)(*(void *)(a1[9] + 8) + 40), v9);
    (*(void (**)(void))(a1[6] + 16))();
  }
  else
  {
    (*(void (**)(void))(a1[6] + 16))();
  }

  _Block_object_dispose(&v25, 8);
}

void sub_1000733E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100073408(uint64_t a1)
{
  uint64_t v2 = [[PDSharingManagementRetrievePartnerEncryptionCertificateResponse alloc] initWithData:*(void *)(a1 + 32)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) != 0;
}

void sub_100073464(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  id v10 = PKPublicKeyFromCertificate();
  uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  id v14[2] = sub_100073574;
  v14[3] = &unk_100731998;
  long long v17 = *(_OWORD *)(a1 + 64);
  id v15 = v6;
  id v16 = v7;
  id v12 = v6;
  id v13 = v7;
  [v8 _getEncryptedServiceProviderDataForSecureElementPass:v9 publicKey:v10 scheme:v11 completion:v14];
}

void sub_100073574(void *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v15 = 0;
  id v6 = +[NSJSONSerialization JSONObjectWithData:a2 options:0 error:&v15];
  id v7 = v15;
  if (v7)
  {
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDPasslibary: Error converting encrypted payload to JSON string: %@", buf, 0xCu);
    }
  }
  uint64_t v9 = *(void *)(a1[6] + 8);
  id v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
  id v11 = v6;

  uint64_t v12 = *(void *)(a1[7] + 8);
  id v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v5;
  id v14 = v5;

  (*(void (**)(void))(a1[5] + 16))();
}

void sub_1000736D8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  if (v8)
  {
    uint64_t v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412290;
      uint64_t v11 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDPasslibary: Failed to encrypt serviceproviderData: %@", (uint8_t *)&v10, 0xCu);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100073CB0(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 appletWithIdentifier:a1[4]];
  if (v4)
  {
    uint64_t v5 = a1[5];
    uint64_t v6 = a1[6];
    id v13 = 0;
    id v7 = [v3 getServiceProviderDataForApplet:v4 publicKey:v5 scheme:v6 error:&v13];
    id v8 = v13;
    uint64_t v9 = v8;
    id v10 = 0;
    if (!v7) {
      id v10 = v8;
    }
  }
  else
  {
    uint64_t v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = a1[4];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v15 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to get service provider data: Couldn't get applet with identifier: %@", buf, 0xCu);
    }

    id v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-1 userInfo:0];
    id v7 = 0;
  }
  (*(void (**)(void))(a1[7] + 16))();
}

void sub_100073FA4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 appletWithIdentifier:*(void *)(a1 + 32)];
  if (v4)
  {
    id v11 = 0;
    uint64_t v5 = [v3 getServiceProviderDataForApplet:v4 error:&v11];
    id v6 = v11;
    id v7 = 0;
    if (!v5)
    {
      id v8 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v13 = v6;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Couldn't get service provider data: %@", buf, 0xCu);
      }

      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-1 userInfo:0];
    }
  }
  else
  {
    uint64_t v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = *(void **)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      id v13 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Failed to get service provider data: Couldn't get applet with identifier: %@", buf, 0xCu);
    }

    id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-1 userInfo:0];
    uint64_t v5 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100074250(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248));
  [WeakRetained checkForTransitNotification];
}

void sub_1000743A4(void *a1, void *a2)
{
  id v3 = [a2 paymentPass];
  if (v3)
  {
    id v4 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000744FC;
    block[3] = &unk_10072E238;
    uint64_t v5 = (void *)a1[5];
    void block[4] = a1[4];
    id v9 = v5;
    id v10 = v3;
    dispatch_async(v4, block);
  }
  else
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[6];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "TransitMessage could not find payment pass for uniqueID:%@. fail to post upgraded pass notification", buf, 0xCu);
    }
  }
}

void sub_1000744FC(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248));
  [WeakRetained postUpgradedPassNotificationForMarket:a1[5] pass:a1[6]];
}

void sub_1000746B0(void *a1, void *a2)
{
  id v3 = [a2 paymentPass];
  if (v3)
  {
    id v4 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100074808;
    block[3] = &unk_10072E238;
    uint64_t v5 = (void *)a1[5];
    void block[4] = a1[4];
    id v9 = v5;
    id v10 = v3;
    dispatch_async(v4, block);
  }
  else
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[6];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "TransitMessage could not find payment pass for uniqueID:%@. fail to post upgrade selection notification", buf, 0xCu);
    }
  }
}

void sub_100074808(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248));
  [WeakRetained postUpgradesAvailableNotificationForMarket:a1[5] pass:a1[6]];
}

void sub_100075344(void *a1)
{
  uint64_t v2 = [*(id *)(a1[4] + 88) passWithPassTypeID:a1[5] serialNumber:a1[6]];
  id v3 = +[PKPass classForPassType:PKPassTypeForPassTypeIdentifier()];
  id v4 = [v3 defaultSettings];
  if (v2)
  {
    id v5 = [*(id *)(a1[4] + 88) settingsForPass:v2];
  }
  else
  {
    id v5 = v4;
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = a1[5];
      uint64_t v8 = a1[6];
      id v9 = NSStringFromClass((Class)v3);
      int v12 = 138412802;
      uint64_t v13 = v7;
      __int16 v14 = 2112;
      uint64_t v15 = v8;
      __int16 v16 = 2114;
      id v17 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Notice: Didn't find a db pass with with type: %@ and serial number: %@. Falling back to default %{public}@ settings.", (uint8_t *)&v12, 0x20u);
    }
  }
  uint64_t v10 = a1[7];
  id v11 = [v2 manifestHash];
  (*(void (**)(uint64_t, void *, id))(v10 + 16))(v10, v11, v5);
}

void sub_10007559C(uint64_t a1)
{
  id v2 = +[PKPass createWithData:*(void *)(a1 + 32) warnings:0 error:0];
  objc_msgSend(*(id *)(a1 + 40), "_queue_replacePass:handler:", v2, *(void *)(a1 + 48));
}

uint64_t sub_100075740(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000758F0(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void (**)(uint64_t, id))(v2 + 16);
  id v4 = a2;
  v3(v2, v4);
  [v4 invalidate];
}

void sub_100075A24(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v4 = a2;
  id v3 = [v4 consumeImageSet];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);

  [v4 invalidate];
}

void sub_100075A90(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void (**)(uint64_t, id))(v2 + 16);
  id v4 = a2;
  v3(v2, v4);
  [v4 invalidate];
}

id sub_100075BF4(void *a1)
{
  return _[*(id *)(a1[4] + 88) updateSettings:a1[6] forObjectWithUniqueIdentifier:a1[5]];
}

uint64_t sub_100075D4C(void *a1)
{
  [*(id *)(a1[4] + 88) updatePassAnnotationsForPassWithUniqueIdentifier:a1[5] withSortingState:a1[7]];
  uint64_t result = a1[6];
  if (result)
  {
    id v3 = *(uint64_t (**)(void))(result + 16);
    return v3();
  }
  return result;
}

void sub_1000760AC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248));
  if (objc_opt_respondsToSelector()) {
    [WeakRetained rescheduleCommutePlanRenewalRemindersForPaymentPassWithUniqueIdentifier:*(void *)(a1 + 40)];
  }
}

id sub_100076228(uint64_t a1)
{
  id result = [*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess];
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    id v4 = *(void **)(*(void *)(a1 + 32) + 88);
    return _[v4 noteObjectSharedWithUniqueID:v3];
  }
  return result;
}

void sub_100076568(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_100076614;
  v6[3] = &unk_100731B00;
  id v7 = v3;
  id v5 = v3;
  [v4 enumerateObjectsWithOptions:2 usingBlock:v6];
  [*(id *)(a1 + 32) removeAllObjects];
}

uint64_t sub_100076614(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100076628(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100076848(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000768F4;
  v6[3] = &unk_100731B78;
  id v7 = v3;
  id v5 = v3;
  [v4 unarchivePassesWithOptions:2 usingBlock:v6];
  [*(id *)(a1 + 32) invalidate];
}

uint64_t sub_1000768F4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100076908(uint64_t a1)
{
  [*(id *)(a1 + 32) invalidate];
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  return v2();
}

void sub_100076AA4(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v14;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v13 + 1) + 8 * (void)v8);
        id v11 = objc_msgSend(v9, "createPass", (void)v13);
        if (v11)
        {
          int v12 = [v9 properties];
          v3[2](v3, v11, v12);

          [v9 invalidate];
        }

        uint64_t v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v6);
  }
}

uint64_t sub_100076C08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100076FB4(uint64_t a1)
{
  [*(id *)(a1 + 32) _addPassesWithEnumerator:*(void *)(a1 + 48)];
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 56) + 16);
  return v2();
}

void sub_100077000(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 40));
  id v6 = *(void **)(*(void *)(a1 + 32) + 48);
  uint64_t v7 = +[NSValue valueWithPointer:a2];
  [v6 removeObject:v7];

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 40));
  if (a3 == 1)
  {
    id v9 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100077184;
    block[3] = &unk_100731BF0;
    void block[4] = *(void *)(a1 + 32);
    id v11 = *(id *)(a1 + 48);
    id v12 = *(id *)(a1 + 40);
    dispatch_async(v9, block);
  }
  else
  {
    uint64_t v8 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v8();
  }
}

uint64_t sub_100077184(uint64_t a1)
{
  [*(id *)(a1 + 32) _addPassesWithEnumerator:*(void *)(a1 + 40)];
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v2();
}

void sub_1000773D8(uint64_t a1)
{
  id v18 = (void *)PDOSTransactionCreate("PDPassLibrary");
  uint64_t v19 = a1;
  id v20 = objc_alloc_init((Class)NSMutableArray);
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  id obj = *(id *)(a1 + 32);
  id v2 = [obj countByEnumeratingWithState:&v36 objects:v44 count:16];
  if (v2)
  {
    char v3 = 0;
    uint64_t v22 = *(void *)v37;
    do
    {
      for (uint64_t i = 0; i != v2; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v37 != v22) {
          objc_enumerationMutation(obj);
        }
        id v5 = *(void **)(*((void *)&v36 + 1) + 8 * i);
        *(void *)id v30 = 0;
        NSErrorUserInfoKey v31 = v30;
        uint64_t v32 = 0x3032000000;
        uint64_t v33 = sub_1000207AC;
        id v34 = sub_100020EC8;
        id v35 = 0;
        if (v3)
        {
          char v3 = 1;
          goto LABEL_22;
        }
        v29[0] = _NSConcreteStackBlock;
        v29[1] = 3221225472;
        void v29[2] = sub_1000778C8;
        v29[3] = &unk_100731C40;
        v29[4] = v30;
        [v5 accessFileDescriptorWithBlock:v29];
        uint64_t v7 = *((void *)v31 + 5);
        if (v7)
        {
          id v27 = 0;
          id v28 = 0;
          id v8 = +[PKPass createWithFileDataAccessor:v7 validationOptions:2 warnings:&v28 error:&v27];
          id v9 = v28;
          uint64_t v10 = v27;
          if (v10)
          {
            id v11 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412546;
              id v41 = v8;
              __int16 v42 = 2112;
              long long v43 = v10;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to add unsigned pass: %@ due to validation error: %@", buf, 0x16u);
            }
            goto LABEL_19;
          }
          uint64_t v12 = +[PKPlaceholderPassGenerator addManifestIfNecessaryToPass:v8];
          id v11 = v12;
          if (!v8 || v12)
          {
            long long v13 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412546;
              id v41 = v8;
              __int16 v42 = 2112;
              long long v43 = v11;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Failed to add unsigned pass: %@ error: %@", buf, 0x16u);
            }

LABEL_19:
            char v3 = 1;
          }
          else
          {
            [v20 addObject:v8];
            char v3 = 0;
          }

          goto LABEL_21;
        }
        char v3 = 1;
LABEL_21:
LABEL_22:
        [v5 invalidate];
        _Block_object_dispose(v30, 8);
      }
      id v2 = [obj countByEnumeratingWithState:&v36 objects:v44 count:16];
    }
    while (v2);
  }

  id v14 = [*(id *)(v19 + 32) count];
  if (v14 == [v20 count])
  {
    long long v15 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100077924;
    block[3] = &unk_100730C10;
    void block[4] = *(void *)(v19 + 40);
    id v24 = v20;
    id v26 = *(id *)(v19 + 48);
    id v25 = v18;
    dispatch_async(v15, block);
  }
  else
  {
    long long v16 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v30 = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Attempting to add unsigned passes, but unable to create PKPasses.", v30, 2u);
    }

    uint64_t v17 = *(void *)(v19 + 48);
    if (v17) {
      (*(void (**)(uint64_t, uint64_t))(v17 + 16))(v17, 2);
    }
  }
}

void sub_1000778A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

uint64_t sub_1000778C8(uint64_t a1, uint64_t a2)
{
  id v3 = [objc_alloc((Class)PKSerializedDataAccessor) initWithFileDescriptor:a2 error:0];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = *(void *)(v4 + 40);
  *(void *)(v4 + 40) = v3;
  return _objc_release_x1(v3, v5);
}

void sub_100077924(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000779D4;
  v4[3] = &unk_100731C68;
  id v6 = *(id *)(a1 + 56);
  id v5 = *(id *)(a1 + 48);
  [v2 _addPasses:v3 withCompletion:v4];
}

uint64_t sub_1000779D4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100077B54(uint64_t a1)
{
  id v2 = (void *)PDOSTransactionCreate("PDPassLibrary");
  id v3 = [*(id *)(a1 + 32) count];
  id v4 = objc_alloc_init((Class)PKHMHomeManager);
  if (v4)
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100077CB4;
    v9[3] = &unk_100731DD0;
    int8x16_t v8 = *(int8x16_t *)(a1 + 32);
    id v5 = (id)v8.i64[0];
    int8x16_t v10 = vextq_s8(v8, v8, 8uLL);
    id v14 = v3;
    id v13 = *(id *)(a1 + 48);
    id v11 = v2;
    id v12 = v4;
    [v12 fetchHomesWithCompletion:v9];
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 48);
    if (v6)
    {
      uint64_t v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:4 userInfo:0];
      (*(void (**)(uint64_t, void, void *))(v6 + 16))(v6, 0, v7);
    }
  }
}

void sub_100077CB4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
  id v5 = objc_alloc_init((Class)NSMutableArray);
  v55[0] = 0;
  v55[1] = v55;
  v55[2] = 0x3032000000;
  v55[3] = sub_1000207AC;
  v55[4] = sub_100020EC8;
  id v56 = 0;
  uint64_t v6 = +[NSUUID UUID];
  uint64_t v7 = [v6 UUIDString];

  v53[0] = _NSConcreteStackBlock;
  v53[1] = 3221225472;
  v53[2] = sub_100078224;
  v53[3] = &unk_100731CB8;
  v53[4] = *(void *)(a1 + 32);
  id v25 = v7;
  id v54 = v25;
  [v4 addOperation:v53];
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  id obj = v3;
  id v8 = [obj countByEnumeratingWithState:&v49 objects:v61 count:16];
  if (v8)
  {
    uint64_t v9 = *(void *)v50;
    do
    {
      int8x16_t v10 = 0;
      do
      {
        if (*(void *)v50 != v9) {
          objc_enumerationMutation(obj);
        }
        uint64_t v11 = *(void *)(*((void *)&v49 + 1) + 8 * (void)v10);
        v44[0] = _NSConcreteStackBlock;
        v44[1] = 3221225472;
        v44[2] = sub_100078398;
        v44[3] = &unk_100731D08;
        v44[4] = v11;
        id v12 = *(id *)(a1 + 40);
        long long v48 = v55;
        uint64_t v13 = *(void *)(a1 + 32);
        id v45 = v12;
        uint64_t v46 = v13;
        id v47 = v5;
        [v4 addOperation:v44];

        int8x16_t v10 = (char *)v10 + 1;
      }
      while (v8 != v10);
      id v8 = [obj countByEnumeratingWithState:&v49 objects:v61 count:16];
    }
    while (v8);
  }

  v41[0] = _NSConcreteStackBlock;
  v41[1] = 3221225472;
  v41[2] = sub_10007864C;
  v41[3] = &unk_100731D30;
  uint64_t v43 = *(void *)(a1 + 72);
  id v14 = v5;
  id v42 = v14;
  [v4 addOperation:v41];
  long long v15 = [*(id *)(*(void *)(a1 + 32) + 64) sharedWebService];
  long long v16 = [v15 targetDevice];
  if (PKTargetDeviceSupportsExpress())
  {
    if (*(void *)(a1 + 72))
    {
      unint64_t v17 = 0;
      do
      {
        v36[0] = _NSConcreteStackBlock;
        v36[1] = 3221225472;
        v36[2] = sub_100078764;
        v36[3] = &unk_100731D80;
        id v37 = v14;
        unint64_t v40 = v17;
        id v38 = v16;
        id v39 = v15;
        [v4 addOperation:v36];

        ++v17;
      }
      while (v17 < *(void *)(a1 + 72));
    }
  }
  else
  {
    id v18 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      id v58 = v14;
      __int16 v59 = 2112;
      __int16 v60 = v16;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Skipping adding HomeKeys (%@) to express as target device (%@) does not support express", buf, 0x16u);
    }
  }
  uint64_t v19 = +[NSNull null];
  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472;
  id v27[2] = sub_10007893C;
  v27[3] = &unk_100731DA8;
  id v35 = v55;
  id v20 = v14;
  id v28 = v20;
  id v21 = *(id *)(a1 + 40);
  uint64_t v22 = *(void *)(a1 + 32);
  id v29 = v21;
  uint64_t v30 = v22;
  id v34 = *(id *)(a1 + 64);
  id v23 = v25;
  id v31 = v23;
  id v32 = *(id *)(a1 + 48);
  id v33 = *(id *)(a1 + 56);
  id v24 = [v4 evaluateWithInput:v19 completion:v27];

  _Block_object_dispose(v55, 8);
}

void sub_1000781EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

void sub_100078224(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  int8x16_t v10 = *(void **)(v8 + 32);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100078304;
  v13[3] = &unk_100731C90;
  id v14 = v6;
  id v15 = v7;
  id v11 = v6;
  id v12 = v7;
  [v10 acquireAssertionOfType:1 withIdentifier:v9 reason:@"Unsigned pass provisioning" handler:v13];
}

uint64_t sub_100078304(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Adding HomeKey unable to aquire provisioning assertion", v5, 2u);
    }
  }
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100078398(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = [*(id *)(a1 + 32) walletKeyPassSerialNumber];
  if ([*(id *)(a1 + 40) containsObject:v8])
  {
    uint64_t v9 = *(void **)(a1 + 32);
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_1000784D0;
    v15[3] = &unk_100731CE0;
    id v10 = v8;
    uint64_t v11 = *(void *)(a1 + 64);
    id v16 = v10;
    uint64_t v21 = v11;
    id v20 = v7;
    id v12 = v6;
    uint64_t v13 = *(void *)(a1 + 48);
    id v14 = *(void **)(a1 + 56);
    id v17 = v12;
    uint64_t v18 = v13;
    id v19 = v14;
    [v9 addWalletKeyWithOptions:1 completionHandler:v15];
  }
  else
  {
    (*((void (**)(id, id, void))v7 + 2))(v7, v6, 0);
  }
}

void sub_1000784D0(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = a1[4];
      int v12 = 138412546;
      uint64_t v13 = v8;
      __int16 v14 = 2112;
      id v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Adding HomeKey for home %@ returned error %@", (uint8_t *)&v12, 0x16u);
    }

    objc_storeStrong((id *)(*(void *)(a1[9] + 8) + 40), a3);
    (*(void (**)(void))(a1[8] + 16))();
  }
  else
  {
    uint64_t v9 = [*(id *)(a1[6] + 88) passWithPassTypeID:@"paymentpass.com.apple.dev1" serialNumber:a1[4]];
    id v10 = (void *)a1[7];
    uint64_t v11 = [v9 paymentPass];
    [v10 safelyAddObject:v11];

    (*(void (**)(void))(a1[8] + 16))();
  }
}

void sub_10007864C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v5 = *(void **)(a1 + 32);
  id v6 = *(id *)(a1 + 40);
  id v7 = a4;
  id v8 = a3;
  id v9 = [v5 count];
  id v10 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v11 = @"Y";
    if (v6 != v9) {
      CFStringRef v11 = @"N";
    }
    int v12 = 138412290;
    CFStringRef v13 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Adding HomeKey provisioned all passes: %@", (uint8_t *)&v12, 0xCu);
  }

  v7[2](v7, v8, v6 != v9);
}

void sub_100078764(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [*(id *)(a1 + 32) objectAtIndex:*(void *)(a1 + 56)];
  id v10 = *(void **)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  id v14[2] = sub_100078864;
  v14[3] = &unk_100731D58;
  id v16 = v6;
  id v17 = v7;
  id v15 = v8;
  id v11 = v6;
  id v12 = v7;
  id v13 = v8;
  [v10 paymentWebService:v9 handlePotentialExpressPass:v13 withCompletionHandler:v14];
}

void sub_100078864(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3)
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      int v6 = 138412290;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Adding HomeKey failed to enable express for %@ pass.", (uint8_t *)&v6, 0xCu);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_10007893C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  if (*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40)
    || (id v8 = [*(id *)(a1 + 32) count], v8 != objc_msgSend(*(id *)(a1 + 40), "count"))
    || [v7 isCanceled])
  {
    id v31 = v7;
    id v9 = v6;
    id v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      id v11 = *(void **)(*(void *)(*(void *)(a1 + 88) + 8) + 40);
      id v12 = [*(id *)(a1 + 32) count];
      *(_DWORD *)long long buf = 138412546;
      id v38 = v11;
      __int16 v39 = 2048;
      id v40 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Adding HomeKey Error adding HomeKeys: %@. Removing %lu added HomeKeys.", buf, 0x16u);
    }

    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    id v13 = *(id *)(a1 + 32);
    id v14 = [v13 countByEnumeratingWithState:&v32 objects:v36 count:16];
    if (v14)
    {
      id v15 = v14;
      uint64_t v16 = *(void *)v33;
      do
      {
        for (uint64_t i = 0; i != v15; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v33 != v16) {
            objc_enumerationMutation(v13);
          }
          uint64_t v18 = *(void **)(*(void *)(a1 + 48) + 80);
          id v19 = [*(id *)(*((void *)&v32 + 1) + 8 * i) uniqueID];
          [v18 deleteCardWithUniqueID:v19 forReason:3 withDiagnosticReason:@"Cleaning up homekey because operation failed"];
        }
        id v15 = [v13 countByEnumeratingWithState:&v32 objects:v36 count:16];
      }
      while (v15);
    }

    uint64_t v20 = *(void *)(*(void *)(a1 + 88) + 8);
    uint64_t v21 = *(void **)(v20 + 40);
    if (v21)
    {
      id v22 = v21;
      id v23 = *(void **)(v20 + 40);
      *(void *)(v20 + 40) = v22;
    }
    else
    {
      uint64_t v24 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-1 userInfo:0];
      uint64_t v25 = *(void *)(*(void *)(a1 + 88) + 8);
      id v23 = *(void **)(v25 + 40);
      *(void *)(v25 + 40) = v24;
    }
    id v6 = v9;

    uint64_t v26 = *(void *)(a1 + 80);
    id v7 = v31;
    if (v26)
    {
      id v27 = *(void (**)(void))(v26 + 16);
LABEL_18:
      v27();
    }
  }
  else
  {
    id v28 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      id v29 = [*(id *)(a1 + 32) count];
      *(_DWORD *)long long buf = 134217984;
      id v38 = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Adding HomeKey provisioned %lu passes", buf, 0xCu);
    }

    uint64_t v30 = *(void *)(a1 + 80);
    if (v30)
    {
      id v27 = *(void (**)(void))(v30 + 16);
      goto LABEL_18;
    }
  }
  [*(id *)(*(void *)(a1 + 48) + 32) invalidateAssertionOfType:1 withIdentifier:*(void *)(a1 + 56) handler:0];
}

void sub_100078DA8(uint64_t a1)
{
  id v2 = (void *)PDOSTransactionCreate("PDPassLibrary");
  id v3 = objc_alloc_init((Class)PKHMHomeManager);
  if (v3)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    _DWORD v5[2] = sub_100078EA4;
    v5[3] = &unk_100731E48;
    id v8 = *(id *)(a1 + 32);
    id v6 = v2;
    id v7 = v3;
    [v7 fetchHomesWithCompletion:v5];
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4) {
      (*(void (**)(uint64_t, void, void))(v4 + 16))(v4, 0, 0);
    }
  }
}

void sub_100078EA4(id *a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
  id v5 = objc_alloc_init((Class)NSMutableArray);
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  id v6 = v3;
  id v7 = [v6 countByEnumeratingWithState:&v22 objects:v26 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v23;
    do
    {
      id v10 = 0;
      do
      {
        if (*(void *)v23 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = *(void *)(*((void *)&v22 + 1) + 8 * (void)v10);
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 3221225472;
        v20[2] = sub_100079100;
        v20[3] = &unk_100731CB8;
        void v20[4] = v11;
        id v21 = v5;
        [v4 addOperation:v20];

        id v10 = (char *)v10 + 1;
      }
      while (v8 != v10);
      id v8 = [v6 countByEnumeratingWithState:&v22 objects:v26 count:16];
    }
    while (v8);
  }

  id v12 = +[NSNull null];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_100079308;
  v15[3] = &unk_100731E20;
  id v16 = v5;
  id v19 = a1[6];
  id v17 = a1[4];
  id v18 = a1[5];
  id v13 = v5;
  id v14 = [v4 evaluateWithInput:v12 completion:v15];
}

void sub_100079100(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  [*(id *)(a1 + 32) walletKeyPassSerialNumber];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100079204;
  v13[3] = &unk_100731DF8;
  id v14 = (id)objc_claimAutoreleasedReturnValue();
  id v8 = *(void **)(a1 + 32);
  id v9 = *(id *)(a1 + 40);
  id v16 = v6;
  id v17 = v7;
  id v15 = v9;
  id v10 = v6;
  id v11 = v7;
  id v12 = v14;
  [v8 fetchAvailableWalletKeyEncodedPKPass:v13];
}

void sub_100079204(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      int v9 = 138412546;
      uint64_t v10 = v8;
      __int16 v11 = 2112;
      id v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Fetched available pass for home %@ returned error %@", (uint8_t *)&v9, 0x16u);
    }
  }
  else
  {
    [*(id *)(a1 + 40) addObject:v5];
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_100079308(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = [*(id *)(a1 + 32) count];
    int v11 = 134217984;
    id v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Found %lu available HomeKey passes", (uint8_t *)&v11, 0xCu);
  }

  uint64_t v10 = *(void *)(a1 + 56);
  if (v10) {
    (*(void (**)(uint64_t, void, void))(v10 + 16))(v10, *(void *)(a1 + 32), 0);
  }
}

void sub_100079544(uint64_t a1)
{
  id v2 = (void *)PDOSTransactionCreate("PDPassLibrary");
  uint64_t v13 = 0;
  id v14 = &v13;
  uint64_t v15 = 0x3032000000;
  id v16 = sub_1000207AC;
  id v17 = sub_100020EC8;
  id v18 = 0;
  id v4 = *(void **)(a1 + 32);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_100079724;
  void v12[3] = &unk_100731C40;
  void v12[4] = &v13;
  [v4 accessFileDescriptorWithBlock:v12];
  [*(id *)(a1 + 32) invalidate];
  uint64_t v5 = v14[5];
  if (v5)
  {
    id v10 = 0;
    id v11 = 0;
    id v6 = +[PKPass createWithFileDataAccessor:v5 validationOptions:2 warnings:&v11 error:&v10];
    id v7 = v11;
    unint64_t v8 = (unint64_t)v10;
    uint64_t v9 = +[PKPlaceholderPassGenerator addManifestIfNecessaryToPass:v6];
    if (v9 | v8) {
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
    else {
      objc_msgSend(*(id *)(a1 + 40), "_queue_replacePass:handler:", v6, *(void *)(a1 + 48));
    }
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  _Block_object_dispose(&v13, 8);
}

void sub_100079704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100079724(uint64_t a1, uint64_t a2)
{
  id v3 = [objc_alloc((Class)PKSerializedDataAccessor) initWithFileDescriptor:a2 error:0];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v5 = *(void *)(v4 + 40);
  *(void *)(v4 + 40) = v3;
  return _objc_release_x1(v3, v5);
}

uint64_t sub_1000798F0(void *a1)
{
  [*(id *)(a1[4] + 88) passExistsWithPassTypeID:a1[5] serialNumber:a1[6]];
  id v2 = *(uint64_t (**)(void))(a1[7] + 16);
  return v2();
}

void sub_100079AC4(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 88) passWithPassTypeID:*(void *)(a1 + 40) serialNumber:*(void *)(a1 + 48)];
  id v3 = [v2 paymentPass];

  if (v3)
  {
    uint64_t v4 = [*(id *)(*(void *)(a1 + 32) + 64) sharedWebService];
    uint64_t v5 = [v4 targetDevice];
    if (PKTargetDeviceSupportsExpress())
    {
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472;
      id v12[2] = sub_100079D08;
      void v12[3] = &unk_100731E70;
      id v13 = v3;
      id v14 = *(id *)(a1 + 56);
      [v5 paymentWebService:v4 handlePotentialExpressPass:v13 withCompletionHandler:v12];
    }
    else
    {
      id v10 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v16 = v5;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Attempting to call enableExpressForPassWithPassTypeIdentifier, but target device (%@) does not support express", buf, 0xCu);
      }

      uint64_t v11 = *(void *)(a1 + 56);
      if (v11) {
        (*(void (**)(uint64_t, void))(v11 + 16))(v11, 0);
      }
    }
  }
  else
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = *(void **)(a1 + 40);
      uint64_t v8 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 138412546;
      id v16 = v7;
      __int16 v17 = 2112;
      uint64_t v18 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "EnableExpressForPassWithPassTypeIdentifier unable to find pass with identifier: %@ serialNumber: %@", buf, 0x16u);
    }

    uint64_t v9 = *(void *)(a1 + 56);
    if (v9) {
      (*(void (**)(uint64_t, void))(v9 + 16))(v9, 0);
    }
  }
}

void sub_100079D08(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v7 = 138412546;
    id v8 = v3;
    __int16 v9 = 2112;
    uint64_t v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "EnableExpressForPassWithPassTypeIdentifier enabled %@ expressModes for %@ pass.", (uint8_t *)&v7, 0x16u);
  }

  uint64_t v6 = *(void *)(a1 + 40);
  if (v6) {
    (*(void (**)(uint64_t, BOOL))(v6 + 16))(v6, v3 != 0);
  }
}

uint64_t sub_100079EEC(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2
    && [v2 length]
    && [*(id *)(a1 + 40) _entitledForUniqueID:*(void *)(a1 + 32) forActions:8])
  {
    id v3 = [*(id *)(*(void *)(a1 + 40) + 88) passWithUniqueIdentifier:*(void *)(a1 + 32)];
    uint64_t v4 = v3;
    if (v3)
    {
      if ([v3 passType] == (id)1) {
        uint64_t v5 = 6;
      }
      else {
        uint64_t v5 = 3;
      }
      [*(id *)(*(void *)(a1 + 40) + 80) deleteCardWithUniqueID:*(void *)(a1 + 32) forReason:v5 withDiagnosticReason:*(void *)(a1 + 48)];
    }
  }
  uint64_t v6 = *(uint64_t (**)(void))(*(void *)(a1 + 56) + 16);
  return v6();
}

uint64_t sub_10007A098(uint64_t a1)
{
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v13;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v13 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v12 + 1) + 8 * (void)v6);
        if (v7
          && objc_msgSend(*(id *)(*((void *)&v12 + 1) + 8 * (void)v6), "length", (void)v12)
          && [*(id *)(a1 + 40) _entitledForUniqueID:v7 forActions:8])
        {
          id v8 = [*(id *)(*(void *)(a1 + 40) + 88) passWithUniqueIdentifier:v7];
          __int16 v9 = v8;
          if (v8)
          {
            if ([v8 passType] == (id)1) {
              uint64_t v10 = 7;
            }
            else {
              uint64_t v10 = 4;
            }
            [*(id *)(*(void *)(a1 + 40) + 80) deleteCardWithUniqueID:v7 forReason:v10 withDiagnosticReason:*(void *)(a1 + 48)];
          }
        }
        uint64_t v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v4);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16))();
}

uint64_t sub_10007A2F4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && [*(id *)(a1 + 40) _entitledForUniqueID:v2 forActions:2])
  {
    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 248));
    [WeakRetained recoverPassWithUniqueID:*(void *)(a1 + 32)];
  }
  id v4 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v4();
}

uint64_t sub_10007A44C(void *a1)
{
  if ([*(id *)(a1[4] + 8) passesAllAccess])
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248));
    [WeakRetained removePassesOfType:a1[7] withDiagnosticReason:a1[5]];
  }
  uint64_t result = a1[6];
  if (result)
  {
    id v4 = *(uint64_t (**)(void))(result + 16);
    return v4();
  }
  return result;
}

uint64_t sub_10007A5AC(void *a1)
{
  if (([*(id *)(a1[4] + 8) passesAllAccess] & 1) != 0
    || [*(id *)(a1[4] + 8) paymentAllAccess])
  {
    [*(id *)(a1[4] + 16) resetApplePayWithType:0 diagnosticReason:a1[5]];
  }
  uint64_t result = a1[6];
  if (result)
  {
    id v3 = *(uint64_t (**)(void))(result + 16);
    return v3();
  }
  return result;
}

id sub_10007A744(void *a1)
{
  if (*(void *)(a1[4] + 72)) {
    return _[*(id *)(a1[4] + 72) updatePassWithUniqueIdentifier:a1[5] handler:a1[6]];
  }
  else {
    return (id)(*(uint64_t (**)(void))(a1[6] + 16))();
  }
}

id sub_10007A8D4(void *a1)
{
  if (*(void *)(a1[4] + 72)) {
    return _[*(id *)(a1[4] + 72) personalizePassWithUniqueIdentifier:a1[5] contact:a1[6] personalizationToken:a1[7] requiredPersonalizationFields:a1[9] personalizationSource:a1[10] handler:a1[8]];
  }
  else {
    return (id)(*(uint64_t (**)(void))(a1[8] + 16))();
  }
}

id sub_10007A9C0(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 112) recomputeRelevantPassesWithSearchMode:*(void *)(a1 + 40)];
}

uint64_t sub_10007AB08(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  id v2 = [*(id *)(*(void *)(a1 + 32) + 88) hasCandidatePasses];
  id v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);
  return v3(v1, v2);
}

void sub_10007AC38(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (+[PKWalletVisibility isWalletVisible])
  {
    id v4 = [*(id *)(*(void *)(a1 + 32) + 112) currentRelevantPassInfo];
    (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);
  }
  else
  {
    id v3 = *(void (**)(uint64_t, void))(v2 + 16);
    v3(v2, 0);
  }
}

void sub_10007AEC8(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2
      && [v2 length]
      && ([*(id *)(a1 + 40) _entitledForUniqueID:*(void *)(a1 + 32) forActions:2] & 1) != 0)
    {
      if (![*(id *)(*(void *)(a1 + 40) + 8) paymentAllAccess]
        || PKForceSignDataApplicationStateForegroundRunningCheck())
      {
        id v3 = [*(id *)(a1 + 40) remoteProcessApplicationInfo];
        if (![v3 isRunning]
          || ![v3 isVisible])
        {
          id v16 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136315138;
            long long v23 = "-[PDPassLibrary signData:forPassUniqueID:completion:]_block_invoke";
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%s requires the client to be running in the foreground", buf, 0xCu);
          }

          uint64_t v17 = *(void *)(a1 + 56);
          uint64_t v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-1 userInfo:0];
          (*(void (**)(uint64_t, void, void, void *))(v17 + 16))(v17, 0, 0, v7);
          goto LABEL_24;
        }
      }
      id v3 = [*(id *)(*(void *)(a1 + 40) + 88) passWithUniqueIdentifier:*(void *)(a1 + 32)];
      id v4 = [v3 paymentPass];
      uint64_t v5 = [v4 devicePrimaryPaymentApplication];
      uint64_t v6 = [v5 subcredentials];
      uint64_t v7 = [v6 anyObject];

      if (v7)
      {
        [*(id *)(a1 + 40) remoteProcessIdentifier];
        id v8 = PKBundleIdentifierForPID();
        __int16 v9 = +[NSUUID UUID];
        uint64_t v10 = [v9 UUIDString];
        uint64_t v11 = [@"frameworkSignature-" stringByAppendingString:v10];

        uint64_t v12 = *(void *)(a1 + 48);
        long long v13 = *(void **)(*(void *)(a1 + 40) + 160);
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 3221225472;
        v20[2] = sub_10007B340;
        v20[3] = &unk_100731EE8;
        id v21 = *(id *)(a1 + 56);
        [v13 signData:v12 auth:0 bundleIdentifier:v8 nonce:v11 credential:v7 completion:v20];
      }
      else
      {
        uint64_t v18 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136315138;
          long long v23 = "-[PDPassLibrary signData:forPassUniqueID:completion:]_block_invoke";
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%s requires a pass with a credential", buf, 0xCu);
        }

        uint64_t v19 = *(void *)(a1 + 56);
        id v8 = +[NSError errorWithDomain:PKPassKitErrorDomain code:1 userInfo:0];
        (*(void (**)(uint64_t, void, void, void *))(v19 + 16))(v19, 0, 0, v8);
      }

LABEL_24:
      goto LABEL_25;
    }
    long long v14 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      long long v23 = "-[PDPassLibrary signData:forPassUniqueID:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v15 = *(void *)(a1 + 56);
    id v3 = +[NSError errorWithDomain:PKPassKitErrorDomain code:4 userInfo:0];
    (*(void (**)(uint64_t, void, void, NSObject *))(v15 + 16))(v15, 0, 0, v3);
  }
  else
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      long long v23 = "-[PDPassLibrary signData:forPassUniqueID:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%s requires a completion", buf, 0xCu);
    }
  }
LABEL_25:
}

void sub_10007B340(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = PDDefaultQueue();
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_10007B450;
  v15[3] = &unk_100731EC0;
  id v16 = v9;
  id v11 = *(id *)(a1 + 32);
  id v18 = v8;
  id v19 = v11;
  id v17 = v7;
  id v12 = v8;
  id v13 = v7;
  id v14 = v9;
  dispatch_async(v10, v15);
}

void sub_10007B450(void *a1)
{
  uint64_t v1 = a1[7];
  if (a1[4])
  {
    id v6 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-1 userInfo:0];
    (*(void (**)(uint64_t, void, void, id))(v1 + 16))(v1, 0, 0, v6);
  }
  else
  {
    uint64_t v2 = a1[5];
    uint64_t v3 = a1[6];
    id v4 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v1 + 16);
    uint64_t v5 = a1[7];
    v4(v5, v2, v3, 0);
  }
}

id sub_10007B700(void *a1)
{
  return [*(id *)(a1[4] + 56) createFidoKeyForRelyingParty:a1[5] relyingPartyAccountHash:a1[6] challenge:a1[7] externalizedAuth:a1[8] completion:a1[9]];
}

id sub_10007B8B0(void *a1)
{
  return [*(id *)(a1[4] + 56) checkFidoKeyPresenceForRelyingParty:a1[5] relyingPartyAccountHash:a1[6] fidoKeyHash:a1[7] completion:a1[8]];
}

id sub_10007BAFC(void *a1)
{
  return [*(id *)(a1[4] + 56) signWithFidoKeyForRelyingParty:a1[5] relyingPartyAccountHash:a1[6] fidoKeyHash:a1[7] challenge:a1[8] publicKeyIdentifier:a1[9] externalizedAuth:a1[10] completion:a1[11]];
}

id sub_10007BCB8(void *a1)
{
  return _[*(id *)(a1[4] + 56) generateSEEncryptionCertificateForSubCredentialId:a1[5] completion:a1[6]];
}

id sub_10007BE50(void *a1)
{
  return [*(id *)(a1[4] + 208) generateISOEncryptionCertificateForSubCredentialId:a1[5] completion:a1[6]];
}

id sub_10007BFFC(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 208);
  id v3 = objc_msgSend(objc_alloc((Class)NSSet), "initWithObjects:", *(void *)(a1 + 40), 0);
  [v2 deleteSubCredentialIdentifiers:v3 cardType:3];

  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 160);
  return [v5 revokeSubcredentialForIdentifier:v4 withCompletion:0];
}

id sub_10007C214(void *a1)
{
  return [*(id *)(a1[4] + 208) addISO18013Blobs:a1[5] cardType:a1[7] completion:a1[6]];
}

id sub_10007C3B8(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 56) longTermPrivacyKeyForCredentialGroupIdentifier:*(void *)(a1 + 40) reuseExisting:*(unsigned __int8 *)(a1 + 56) completion:*(void *)(a1 + 48)];
}

void sub_10007C598(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 224);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10007C638;
  v3[3] = &unk_100731F88;
  id v4 = *(id *)(a1 + 48);
  [v2 registerLocalAuxiliaryCapabilities:v1 withPass:0 completion:v3];
}

void sub_10007C638(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v13 = a3;
  if (a4)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    id v7 = [a2 copy];
    id v8 = [v13 keyEnumerator];
    uint64_t v9 = [v8 nextObject];
    if (v9)
    {
      uint64_t v10 = (void *)v9;
      do
      {
        id v11 = [v13 objectForKey:v10];
        [v7 setObject:v11 forKey:v10];

        uint64_t v12 = [v8 nextObject];

        uint64_t v10 = (void *)v12;
      }
      while (v12);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_10007C8B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 56);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10007C958;
  v4[3] = &unk_100731FB0;
  uint64_t v3 = *(void *)(a1 + 56);
  id v5 = *(id *)(a1 + 48);
  [v2 signChallenge:v1 signatureEntanglementMode:v3 completion:v4];
}

uint64_t sub_10007C958(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(result + 16))(result, a2, a3, 0);
  }
  return result;
}

void sub_10007D724(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) configurationType];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_10007D9A4;
  v13[3] = &unk_10072E570;
  id v14 = *(id *)(a1 + 48);
  uint64_t v3 = objc_retainBlock(v13);
  if (v2 == (id)3)
  {
    if (!*(unsigned char *)(a1 + 56))
    {
      [*(id *)(a1 + 40) canAddHomeKeyWithConfiguration:*(void *)(a1 + 32) completion:v3];
      goto LABEL_17;
    }
    id v4 = PKLogFacilityTypeGetObject();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_9;
    }
    *(_WORD *)long long buf = 0;
    id v5 = "canAddSecureElementPassWithConfiguration: HomeKey not supported synchronously";
    goto LABEL_8;
  }
  if (+[PKWalletVisibility isWalletRestricted])
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_9;
    }
    *(_WORD *)long long buf = 0;
    id v5 = "canAddSecureElementPassWithConfiguration: called while Wallet is restricted";
LABEL_8:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 2u);
LABEL_9:

LABEL_10:
    id v6 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-1 userInfo:0];
    ((void (*)(void *, void, void *))v3[2])(v3, 0, v6);

    goto LABEL_17;
  }
  switch((unint64_t)v2)
  {
    case 1uLL:
      id v8 = *(void **)(a1 + 32);
      id v7 = *(void **)(a1 + 40);
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      v10[2] = sub_10007DAA0;
      v10[3] = &unk_100731FD8;
      id v11 = v3;
      id v9 = v8;
      [v7 canAddCarKeyPassWithConfiguration:v9 completion:v10];

      break;
    case 2uLL:
    case 4uLL:
      if (![*(id *)(a1 + 32) conformsToProtocol:&OBJC_PROTOCOL___PKPushablePassConfigurationProvider])goto LABEL_10; {
      [*(id *)(a1 + 40) canAddPushablePassWithConfiguration:*(void *)(a1 + 32) completion:v3];
      }
      break;
    case 5uLL:
      [*(id *)(a1 + 40) canAddClassicApplePayCredentialWithConfiguration:*(void *)(a1 + 32) completion:*(void *)(a1 + 48)];
      break;
    default:
      goto LABEL_10;
  }
LABEL_17:
}

void sub_10007D9A4(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = @"NO";
    if (a2) {
      CFStringRef v7 = @"YES";
    }
    int v8 = 138412546;
    CFStringRef v9 = v7;
    __int16 v10 = 2112;
    id v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "canAddSecureElementPassWithConfiguration: returning result: %@, error: %@", (uint8_t *)&v8, 0x16u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10007DAA0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10007DAB4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_10007DBEC(uint64_t a1)
{
  return [*(id *)(a1 + 32) canAddCarKeyPassWithConfiguration:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

void sub_10007DE34(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v9 = v5;
  if (a2) {
    goto LABEL_5;
  }
  if (![v5 containsNotManagedAccount])
  {
    if (![*(id *)(a1 + 32) _isWatchIssuerAppProvisioningSupported])
    {
      id v6 = PKPassKitErrorDomain;
      uint64_t v7 = 1;
      goto LABEL_7;
    }
LABEL_5:
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_8;
  }
  id v6 = PKPassKitErrorDomain;
  uint64_t v7 = 4;
LABEL_7:
  int v8 = +[NSError errorWithDomain:v6 code:v7 userInfo:0];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();

LABEL_8:
}

void sub_10007E460(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  id v9 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 138412802;
    id v14 = v7;
    __int16 v15 = 2048;
    uint64_t v16 = a2;
    __int16 v17 = 2112;
    id v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDPassLibrary canAddHomeKeyWithConfiguration: %@, errorCode: %lu error: %@", (uint8_t *)&v13, 0x20u);
  }

  id v10 = objc_alloc_init((Class)NSMutableDictionary);
  [v10 setObject:v7 forKeyedSubscript:NSDebugDescriptionErrorKey];
  [v10 setObject:v8 forKeyedSubscript:NSUnderlyingErrorKey];
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = +[NSError errorWithDomain:PKPassKitErrorDomain code:a2 userInfo:v10];
  (*(void (**)(uint64_t, void, void *))(v11 + 16))(v11, 0, v12);
}

void sub_10007E5D8(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 64);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_10007E6A0;
  v6[3] = &unk_1007320F0;
  id v3 = *(id *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = *(void **)(a1 + 40);
  id v8 = v3;
  void v6[4] = v4;
  id v7 = v5;
  id v9 = *(id *)(a1 + 56);
  [v2 validatePreconditionsWithCompletion:v6];
}

void sub_10007E6A0(uint64_t a1, char a2)
{
  if (a2)
  {
    id v3 = [*(id *)(*(void *)(a1 + 32) + 64) sharedWebService];
    uint64_t v4 = [v3 targetDevice];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_10007E7D8;
    v9[3] = &unk_1007320C8;
    id v5 = *(id *)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 32);
    id v7 = *(void **)(a1 + 40);
    id v11 = v5;
    void v9[4] = v6;
    id v10 = v7;
    id v12 = *(id *)(a1 + 56);
    [v4 paymentWebService:v3 setNewAuthRandomIfNecessaryReturningPairingState:v9];
  }
  else
  {
    id v8 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
    v8();
  }
}

void sub_10007E7D8(uint64_t a1, char a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (a2)
  {
    id v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDPassLibrary canAddHomeKeyWithConfiguration: SE Valid", buf, 2u);
    }

    id v10 = *(void **)(*(void *)(a1 + 32) + 232);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_10007E954;
    v13[3] = &unk_1007320A0;
    id v16 = *(id *)(a1 + 48);
    id v14 = *(id *)(a1 + 40);
    id v11 = *(id *)(a1 + 56);
    uint64_t v12 = *(void *)(a1 + 32);
    id v17 = v11;
    uint64_t v15 = v12;
    [v10 performDeviceRegistrationForReason:@"HomeKey preflight" brokerURL:0 action:1 forceApplePayRegister:0 forcePeerPaymentRegister:0 completion:v13];
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_10007E954(uint64_t a1)
{
  if (PKDisableDynamicSEAllocation())
  {
    uint64_t v2 = PKMaxPaymentCards();
    if (v2 - 1 >= (unint64_t)[*(id *)(*(void *)(a1 + 40) + 88) countActiveSecureElementPasses])
    {
      uint64_t v4 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDPassLibrary canAddHomeKeyWithConfiguration: passed preflight!", v5, 2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    }
    else
    {
      id v3 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
      v3();
    }
  }
  else
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    id v6[2] = sub_10007EAE0;
    v6[3] = &unk_100732078;
    id v7 = *(id *)(a1 + 32);
    id v8 = *(id *)(a1 + 48);
    id v9 = *(id *)(a1 + 56);
    +[PKProvisioningSEStorageSnapshot getCurrentSnapshot:v6];
  }
}

uint64_t sub_10007EAE0(void *a1, void *a2)
{
  id v3 = (void *)a1[4];
  id v4 = a2;
  id v5 = [v3 appletTypes];
  unsigned __int8 v6 = [v4 addAppletTypesToSnapshot:v5];

  if (v6)
  {
    id v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDPassLibrary canAddHomeKeyWithConfiguration: passed preflight!", v10, 2u);
    }

    return (*(uint64_t (**)(void))(a1[6] + 16))();
  }
  else
  {
    id v9 = *(uint64_t (**)(void))(a1[5] + 16);
    return v9();
  }
}

id sub_10007EDC8(void *a1)
{
  return [*(id *)(a1[4] + 240) meetsWithRequirementsContainer:a1[5] completion:a1[6]];
}

void sub_10007EF98(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 56) secureElementIdentifiers];
  id v3 = [v2 firstObject];

  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = *(void **)(*(void *)(a1 + 32) + 56);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10007F088;
  v8[3] = &unk_100732140;
  id v9 = v3;
  uint64_t v6 = *(void *)(a1 + 48);
  id v10 = *(id *)(a1 + 56);
  id v7 = v3;
  [v5 generateTransactionKeyWithReaderIdentifier:v4 readerPublicKey:v6 withCompletion:v8];
}

void sub_10007F088(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if (v11)
  {
    int v13 = [v11 hexEncoding];
    id v14 = [v13 uppercaseString];
  }
  else
  {
    id v14 = 0;
  }
  uint64_t v15 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = *(void *)(a1 + 32);
    int v19 = 138413058;
    uint64_t v20 = v16;
    __int16 v21 = 2112;
    long long v22 = v14;
    __int16 v23 = 2112;
    id v24 = v9;
    __int16 v25 = 2112;
    id v26 = v10;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "GenerateTransactionKeyWithReaderIdentifier returned secureElementIdentifier: %@ appletIdentifier: %@ transactionKeyIdentifier: %@ transactionKey: %@", (uint8_t *)&v19, 0x2Au);
  }

  if (v12)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v17 = *(void *)(a1 + 40);
    if (v10 && v9 && *(void *)(a1 + 32) && v14)
    {
      (*(void (**)(void))(v17 + 16))(*(void *)(a1 + 40));
    }
    else
    {
      id v18 = +[NSError errorWithDomain:PKPassKitErrorDomain code:1 userInfo:0];
      (*(void (**)(uint64_t, void, void, void, void, void *))(v17 + 16))(v17, 0, 0, 0, 0, v18);
    }
  }
}

void sub_10007F480(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 88) passWithPassTypeID:@"paymentpass.com.apple.dev1" serialNumber:*(void *)(a1 + 40)];
  id v3 = [v2 secureElementPass];

  id v4 = objc_alloc_init((Class)NSMutableArray);
  if (*(void *)(a1 + 48))
  {
    id v5 = [objc_alloc((Class)PKPassAuxiliaryRegistrationSignatureRequirement) initWithType:2];
    id v6 = objc_alloc((Class)PKPassAuxiliaryCapabilitySignatureUnifiedAccessHomeKeyCreationMetadata);
    id v7 = [*(id *)(a1 + 48) readerGroupIdentifier];
    id v8 = [*(id *)(a1 + 48) readerGroupPublicKey];
    id v9 = [v6 initWithReaderIdentifier:v7 readerPublicKey:v8];

    [v5 setKeyCreationMetadata:v9];
    [v4 addObject:v5];
  }
  if (*(void *)(a1 + 56))
  {
    id v10 = [objc_alloc((Class)PKPassAuxiliaryRegistrationSignatureRequirement) initWithType:8];
    id v11 = objc_alloc((Class)PKPassAuxiliaryCapabilitySignatureAliroHomeKeyCreationMetadata);
    id v12 = [*(id *)(a1 + 56) readerGroupIdentifier];
    int v13 = [*(id *)(a1 + 56) readerGroupPublicKey];
    id v14 = [v11 initWithReaderIdentifier:v12 readerPublicKey:v13 homeIdentifier:*(void *)(a1 + 64)];

    [v10 setKeyCreationMetadata:v14];
    [v4 addObject:v10];
  }
  uint64_t v15 = *(void **)(*(void *)(a1 + 32) + 224);
  id v16 = [v4 copy];
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_10007F6B4;
  v18[3] = &unk_1007321E0;
  id v17 = *(id *)(a1 + 72);
  void v18[4] = *(void *)(a1 + 32);
  id v19 = v17;
  [v15 registerLocalAuxiliaryCapabilities:v16 withPass:v3 completion:v18];
}

void sub_10007F6B4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    id v10 = [*(id *)(*(void *)(a1 + 32) + 56) secureElementIdentifiers];
    id v11 = [v10 firstObject];

    id v12 = objc_alloc_init((Class)NSMutableArray);
    id v13 = objc_alloc_init((Class)NSMutableArray);
    id v14 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
    v27[0] = 0;
    v27[1] = v27;
    id v27[2] = 0x3032000000;
    v27[3] = sub_1000207AC;
    void v27[4] = sub_100020EC8;
    id v28 = 0;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_10007F92C;
    v21[3] = &unk_100732190;
    v21[4] = v11;
    id v22 = v7;
    id v23 = v12;
    id v24 = v8;
    id v25 = v13;
    id v26 = v27;
    [v14 addOperation:v21];
    uint64_t v15 = +[NSNull null];
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_10007FD00;
    v18[3] = &unk_1007321B8;
    uint64_t v20 = v27;
    id v16 = *(id *)(a1 + 40);
    void v18[5] = v13;
    id v19 = v16;
    void v18[4] = v12;
    id v17 = [v14 evaluateWithInput:v15 completion:v18];

    _Block_object_dispose(v27, 8);
  }
}

void sub_10007F914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_10007F92C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472;
  v25[2] = sub_10007FBA0;
  v25[3] = &unk_100732168;
  v25[4] = *(void *)(a1 + 32);
  id v8 = objc_retainBlock(v25);
  id v9 = [*(id *)(a1 + 40) keyEnumerator];
  uint64_t v10 = [v9 nextObject];
  if (v10)
  {
    id v11 = (void *)v10;
    do
    {
      id v12 = [*(id *)(a1 + 40) objectForKey:v11];
      id v13 = v11;
      id v14 = [v12 contents];
      uint64_t v15 = [v14 firstObject];

      if (v15)
      {
        id v16 = ((void (*)(void *, id, void *))v8[2])(v8, [v13 type], v15);
        [*(id *)(a1 + 48) addObject:v16];
      }
      id v11 = [v9 nextObject];
    }
    while (v11);
  }

  id v17 = [*(id *)(a1 + 56) keyEnumerator];
  uint64_t v18 = [v17 nextObject];
  if (v18)
  {
    id v19 = (void *)v18;
    do
    {
      uint64_t v20 = [*(id *)(a1 + 56) objectForKey:v19];
      id v21 = v19;
      id v22 = [v20 contents];
      id v23 = [v22 firstObject];

      if (v23)
      {
        id v24 = ((void (*)(void *, id, void *))v8[2])(v8, [v21 type], v23);
        [*(id *)(a1 + 48) addObject:v24];
        [*(id *)(a1 + 64) addObject:v24];
      }
      id v19 = [v17 nextObject];
    }
    while (v19);
  }

  v7[2](v7, v6, *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) != 0);
}

id sub_10007FBA0(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = objc_alloc((Class)PKAppletSubcredential);
  id v7 = [v5 publicKeyIdentifier];
  id v8 = [v6 initWithIdentifier:v7];

  [v8 setCredentialType:133];
  id v9 = [v5 publicKey];
  [v8 setTransactionKey:v9];

  id v10 = objc_alloc_init((Class)PKPaymentApplication);
  [v10 setSecureElementIdentifier:*(void *)(a1 + 32)];
  id v11 = [v5 applicationIdentifier];

  id v12 = [v11 hexEncoding];
  id v13 = [v12 uppercaseString];
  [v10 setApplicationIdentifier:v13];

  if (a2 == 8) {
    uint64_t v14 = 1004;
  }
  else {
    uint64_t v14 = 1003;
  }
  [v10 setPaymentType:v14];
  id v15 = objc_msgSend(objc_alloc((Class)NSSet), "initWithObjects:", v8, 0);
  [v10 setSubcredentials:v15];

  return v10;
}

void sub_10007FD00(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  id v9 = PKLogFacilityTypeGetObject();
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (v10)
    {
      int v16 = 138412290;
      id v17 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "ConfigureHomeAuxiliaryCapabilitiesForSerialNumber failed with error: %@", (uint8_t *)&v16, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    if (v10)
    {
      id v11 = [*(id *)(a1 + 32) count];
      int v16 = 134217984;
      id v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "ConfigureHomeAuxiliaryCapabilitiesForSerialNumber successfully configured %ld descriptors.", (uint8_t *)&v16, 0xCu);
    }

    uint64_t v12 = *(void *)(a1 + 48);
    id v13 = [*(id *)(a1 + 32) copy];
    id v14 = [*(id *)(a1 + 40) copy];
    id v15 = [&__NSArray0__struct copy];
    (*(void (**)(uint64_t, id, id, id, void))(v12 + 16))(v12, v13, v14, v15, *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40));
  }
}

void sub_10008002C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 88) passWithPassTypeID:*(void *)(a1 + 40) serialNumber:*(void *)(a1 + 48)];
  id v3 = [v2 secureElementPass];

  if (v3)
  {
    id v4 = [v3 devicePaymentApplications];
    id v5 = [v4 anyObject];

    id v6 = [v5 subcredentials];
    id v7 = [v6 anyObject];

    if (v7)
    {
      id v8 = *(void **)(*(void *)(a1 + 32) + 56);
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      v19[2] = sub_1000803B4;
      v19[3] = &unk_100732230;
      id v20 = v5;
      id v21 = v7;
      id v22 = *(id *)(a1 + 40);
      id v23 = *(id *)(a1 + 48);
      id v24 = *(id *)(a1 + 56);
      [v8 allAppletsAndCredentialsWithCompletion:v19];

      id v9 = v20;
    }
    else
    {
      id v14 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *(void *)(a1 + 40);
        uint64_t v16 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 138412546;
        uint64_t v30 = v15;
        __int16 v31 = 2112;
        uint64_t v32 = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "FetchTransactionKeyForPassTypeIdentifier no subcredential found for pass: %@ - %@", buf, 0x16u);
      }

      uint64_t v17 = *(void *)(a1 + 56);
      NSErrorUserInfoKey v25 = NSDebugDescriptionErrorKey;
      CFStringRef v26 = @"unable to find subcredential on pass";
      id v9 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      uint64_t v18 = +[NSError errorWithDomain:PKPassKitErrorDomain code:1 userInfo:v9];
      (*(void (**)(uint64_t, void, void *))(v17 + 16))(v17, 0, v18);
    }
  }
  else
  {
    BOOL v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 40);
      uint64_t v12 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 138412546;
      uint64_t v30 = v11;
      __int16 v31 = 2112;
      uint64_t v32 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "FetchTransactionKeyForPassTypeIdentifier unable to find pass: %@ - %@", buf, 0x16u);
    }

    uint64_t v13 = *(void *)(a1 + 56);
    NSErrorUserInfoKey v27 = NSDebugDescriptionErrorKey;
    CFStringRef v28 = @"unable to find pass";
    id v5 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
    id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:1 userInfo:v5];
    (*(void (**)(uint64_t, void, void *))(v13 + 16))(v13, 0, v7);
  }
}

void sub_1000803B4(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = *(void **)(a1 + 32);
  id v5 = a3;
  id v6 = [v4 applicationIdentifier];
  id v7 = [v5 objectForKeyedSubscript:v6];

  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_100080660;
  v20[3] = &unk_100732208;
  id v21 = *(id *)(a1 + 40);
  id v8 = objc_msgSend(v7, "pk_firstObjectPassingTest:", v20);

  id v9 = PKLogFacilityTypeGetObject();
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (v10)
    {
      uint64_t v11 = *(void *)(a1 + 48);
      uint64_t v12 = *(void *)(a1 + 56);
      uint64_t v13 = [v8 appletIdentifier];
      id v14 = [v8 identifier];
      *(_DWORD *)long long buf = 138413058;
      uint64_t v25 = v11;
      __int16 v26 = 2112;
      uint64_t v27 = v12;
      __int16 v28 = 2112;
      id v29 = v13;
      __int16 v30 = 2112;
      __int16 v31 = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "FetchTransactionKeyForPassTypeIdentifier found applet subcredential for pass %@ - %@, appletId: %@ subcredentialId: %@", buf, 0x2Au);
    }
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
  else
  {
    if (v10)
    {
      uint64_t v15 = *(void *)(a1 + 48);
      uint64_t v16 = *(void *)(a1 + 56);
      *(_DWORD *)long long buf = 138412546;
      uint64_t v25 = v15;
      __int16 v26 = 2112;
      uint64_t v27 = v16;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "FetchTransactionKeyForPassTypeIdentifier no matching applet found for pass: %@ - %@", buf, 0x16u);
    }

    uint64_t v17 = *(void *)(a1 + 64);
    NSErrorUserInfoKey v22 = NSDebugDescriptionErrorKey;
    CFStringRef v23 = @"unable to find applet on SE";
    uint64_t v18 = +[NSDictionary dictionaryWithObjects:&v23 forKeys:&v22 count:1];
    id v19 = +[NSError errorWithDomain:PKPassKitErrorDomain code:1 userInfo:v18];
    (*(void (**)(uint64_t, void, void *))(v17 + 16))(v17, 0, v19);
  }
}

uint64_t sub_100080660(uint64_t a1, void *a2)
{
  id v3 = [a2 identifier];
  id v4 = [*(id *)(a1 + 32) identifier];
  id v5 = v3;
  id v6 = v4;
  id v7 = v6;
  if (v5 == v6)
  {
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    if (v5 && v6) {
      uint64_t v8 = (uint64_t)[v5 isEqualToString:v6];
    }
  }

  return v8;
}

void sub_1000808F0(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  if (v7)
  {
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      id v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDPassLibrary pushProvisioningNoncesWithCredentialCount failied registration with error: %@", (uint8_t *)&v9, 0xCu);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  else
  {
    [*(id *)(a1[4] + 176) pushProvisioningNoncesWithCredentialCount:a1[6] completion:a1[5]];
  }
}

void sub_100080AA0(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a3;
  id v6 = [a2 shareablePassConfiguration];
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v6, v5);
}

void sub_100081154(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (*(unsigned char *)(a1 + 48))
  {
    id v7 = *(void **)(a1 + 32);
    id v8 = [objc_alloc((Class)NSOrderedSet) initWithArray:v5];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100081274;
    v9[3] = &unk_1007322A8;
    id v12 = *(id *)(a1 + 40);
    id v10 = v5;
    id v11 = v6;
    [v7 addPassesWithData:v8 handler:v9];
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

uint64_t sub_100081274(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

id sub_1000817AC(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) _sanitizePassIfNeeded:a2];
  id v4 = [*(id *)(a1 + 32) _entitledForObject:v3 forActions:2];

  return v4;
}

id sub_1000819F4(uint64_t a1)
{
  return _[*(id *)(a1 + 32) getPassWithUniqueID:*(void *)(a1 + 40) handler:*(void *)(a1 + 48)];
}

void sub_100081AC4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_100081B5C;
  v6[3] = &unk_100731B00;
  id v7 = v3;
  id v5 = v3;
  [v4 enumerateObjectsUsingBlock:v6];
}

uint64_t sub_100081B5C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100081CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_100081CEC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = [v5 uniqueID];
    if ([v5 passType] == (id)1) {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    }
    id v15 = 0;
    unsigned int v8 = [*(id *)(*(void *)(a1 + 32) + 88) passExistsWithUniqueID:v7];
    if (v6)
    {
      uint64_t v9 = [v5 secureElementPass];
      id v10 = [v6 provisioningMetadata];
      [v9 setProvisioningMetadata:v10];

      unsigned int v11 = [v6 hasCustomizedSettings];
      if (v11 & 1) != 0 || ((v8 ^ 1))
      {
        if (v11) {
          id v14 = v6;
        }
        else {
          id v14 = v5;
        }
        unint64_t v12 = (unint64_t)[v14 settings];
        goto LABEL_18;
      }
      unint64_t v12 = 0;
    }
    else
    {
      unint64_t v12 = (unint64_t)[v5 settings];
      if ((id)v12 != [(id)objc_opt_class() defaultSettings]) {
        goto LABEL_18;
      }
    }
    if (((v8 ^ 1) & 1) == 0)
    {
      if (![*(id *)(a1 + 32) _writePass:v5 error:&v15])
      {
LABEL_11:
        uint64_t v13 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
          sub_100514F50((uint64_t)v7, &v15, v13);
        }

        goto LABEL_20;
      }
LABEL_19:
      ++*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
LABEL_20:

      goto LABEL_21;
    }
LABEL_18:
    if (([*(id *)(a1 + 32) _writePass:v5 withSettings:v12 | (16 * (PKValueAddedServicesAutomaticSelectionDefaultForPass() != 0)) error:&v15] & 1) == 0)goto LABEL_11; {
    goto LABEL_19;
    }
  }
LABEL_21:
}

void sub_100081EC4(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  id v3 = PKLogFacilityTypeGetObject();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      int v8 = 138412290;
      uint64_t v9 = v2;
      id v5 = "TPSDiscoverabilitySignal - Failed to donate discoverability signal - pass added: %@";
      id v6 = v3;
      uint32_t v7 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else if (v4)
  {
    LOWORD(v_Block_object_dispose(&STACK[0x290], 8) = 0;
    id v5 = "TPSDiscoverabilitySignal - Successfully donated discoverability signal - pass added";
    id v6 = v3;
    uint32_t v7 = 2;
    goto LABEL_6;
  }
}

void sub_100082144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100082168(void *a1)
{
  id result = [*(id *)(a1[4] + 80) writeCard:a1[5] source:4 error:a1[7]];
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = (_BYTE)result;
  return result;
}

void sub_100082354(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = [a2 primaryPassDiff];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_10008243C(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess])
  {
    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248));
    [WeakRetained introduceDatabaseIntegrityProblem];
  }
}

void sub_100082590(void *a1)
{
  if ([*(id *)(a1[4] + 8) passesAllAccess])
  {
    [*(id *)(a1[4] + 88) updateIngestedDate:a1[5] forUniqueID:a1[6]];
    id v2 = [*(id *)(a1[4] + 88) passWithUniqueIdentifier:a1[6]];
    [*(id *)(a1[4] + 136) passAddedOrUpdated:v2];
  }
}

void sub_10008276C(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess]
    && [*(id *)(*(void *)(a1 + 32) + 8) peerPaymentAllAccess]
    && [*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess])
  {
    switch((unint64_t)[*(id *)(a1 + 40) type])
    {
      case 0uLL:
        id v2 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "passd was asked to respond to account change that is unsupported.", buf, 2u);
        }
        goto LABEL_9;
      case 1uLL:
        BOOL v4 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "passd was asked to respond to account addition.", buf, 2u);
        }

        id v5 = PDDefaultQueue();
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_100082AF8;
        block[3] = &unk_10072FDC8;
        void block[4] = *(void *)(a1 + 32);
        id v18 = *(id *)(a1 + 48);
        dispatch_async(v5, block);

        id v6 = v18;
        goto LABEL_21;
      case 2uLL:
        uint32_t v7 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "passd was asked to respond to account update.", buf, 2u);
        }

        int v8 = PDDefaultQueue();
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 3221225472;
        id v14[2] = sub_100082B54;
        v14[3] = &unk_10072E9D8;
        uint64_t v9 = *(void **)(a1 + 40);
        void v14[4] = *(void *)(a1 + 32);
        id v15 = v9;
        id v16 = *(id *)(a1 + 48);
        dispatch_async(v8, v14);

        id v6 = v15;
        goto LABEL_21;
      case 3uLL:
        id v10 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "passd was asked to respond to account deletetion.", buf, 2u);
        }

        unsigned int v11 = PDDefaultQueue();
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3221225472;
        id v12[2] = sub_100082BB0;
        void v12[3] = &unk_10072FDC8;
        void v12[4] = *(void *)(a1 + 32);
        id v13 = *(id *)(a1 + 48);
        dispatch_async(v11, v12);

        id v6 = v13;
LABEL_21:

        break;
      default:
        return;
    }
  }
  else
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100515038();
    }
LABEL_9:

    uint64_t v3 = *(void *)(a1 + 48);
    if (v3) {
      (*(void (**)(void))(v3 + 16))();
    }
  }
}

void sub_100082AF8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248));
  [WeakRetained primaryAppleAccountWasAdded:*(void *)(a1 + 40)];
}

void sub_100082B54(void *a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248));
  [WeakRetained primaryAppleAccountWasUpdated:a1[5] handler:a1[6]];
}

void sub_100082BB0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 248));
  [WeakRetained primaryAppleAccountWasDeleted:*(void *)(a1 + 40)];
}

void sub_100082D3C(void *a1)
{
  if ([*(id *)(a1[4] + 8) paymentAllAccess]
    && [*(id *)(a1[4] + 8) peerPaymentAllAccess]
    && [*(id *)(a1[4] + 8) passesAllAccess])
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 248));
    [WeakRetained noteACAccountChanged:a1[5] handler:a1[6]];
  }
  else
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100515038();
    }

    uint64_t v3 = a1[6];
    if (v3) {
      (*(void (**)(void))(v3 + 16))();
    }
  }
}

void sub_100082EB8(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 80) catalogOfRecord];
  [v2 shuffle:*(unsigned int *)(a1 + 40)];
  [*(id *)(*(void *)(a1 + 32) + 80) writeCatalogOfRecord:v2 source:4];
}

void sub_100083054(void *a1)
{
  id v2 = [(PDGenericUserNotification *)[PDWalletUserNotification alloc] initWithTitle:a1[4] message:a1[5] forPassUniqueIdentifier:a1[6]];
  uint64_t v3 = v2;
  BOOL v4 = v2;
  if (a1[7])
  {
    [(PDUserNotification *)v2 setCustomActionRoute:"setCustomActionRoute:"];
    uint64_t v3 = v4;
  }
  [*(id *)(a1[8] + 104) insertUserNotification:v3];
}

uint64_t sub_1000831C0(void *a1)
{
  uint64_t v2 = [*(id *)(a1[4] + 104) pendingNotificationDescriptionsWithIdentifier:a1[5]];
  uint64_t v3 = a1[6];
  if (v3)
  {
    uint64_t v5 = v2;
    uint64_t v3 = (*(uint64_t (**)(void))(v3 + 16))();
    uint64_t v2 = v5;
  }
  return _objc_release_x1(v3, v2);
}

id sub_100083314(void *a1)
{
  return _[*(id *)(a1[4] + 104) updateDate:a1[5] forPendingNotificationWithIdentifier:a1[6]];
}

id sub_1000835A4(uint64_t a1)
{
  return _[*(id *)(*(void *)(a1 + 32) + 80) forceImmediateRevocationCheck];
}

uint64_t sub_100083668(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess])
  {
    [*(id *)(*(void *)(a1 + 32) + 136) reindexAllContent];
    uint64_t result = *(void *)(a1 + 40);
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(result + 16);
      return v3();
    }
  }
  else
  {
    BOOL v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10051506C();
    }

    uint64_t result = *(void *)(a1 + 40);
    if (result) {
      return (*(uint64_t (**)(void))(result + 16))();
    }
  }
  return result;
}

uint64_t sub_1000837F4(void *a1)
{
  if ([*(id *)(a1[4] + 8) passesAllAccess])
  {
    [*(id *)(a1[4] + 136) reindexContentForIdentifiers:a1[5]];
    uint64_t result = a1[6];
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(result + 16);
      return v3();
    }
  }
  else
  {
    BOOL v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_10051506C();
    }

    uint64_t result = a1[6];
    if (result) {
      return (*(uint64_t (**)(void))(result + 16))();
    }
  }
  return result;
}

void sub_10008395C(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess])
  {
    uint64_t v2 = *(void *)(a1 + 32);
    uint64_t v3 = *(void **)(v2 + 136);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    id v6[2] = sub_100083A58;
    v6[3] = &unk_10072FDC8;
    void v6[4] = v2;
    id v7 = *(id *)(a1 + 40);
    [v3 resetWithCompletion:v6];
  }
  else
  {
    BOOL v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      sub_1005150A0();
    }

    uint64_t v5 = *(void *)(a1 + 40);
    if (v5) {
      (*(void (**)(void))(v5 + 16))();
    }
  }
}

void sub_100083A58(uint64_t a1)
{
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 136);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100083AF0;
  v2[3] = &unk_10072F788;
  id v3 = *(id *)(a1 + 40);
  [v1 deleteAllFinHealthDataWithCompletion:v2];
}

uint64_t sub_100083AF0(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_100083BB8(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) passesAllAccess])
  {
    uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 136);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    _DWORD v5[2] = sub_100083CB4;
    v5[3] = &unk_1007323E0;
    id v6 = *(id *)(a1 + 40);
    [v2 statusWithCompletion:v5];
  }
  else
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      sub_1005150D4();
    }

    uint64_t v4 = *(void *)(a1 + 40);
    if (v4) {
      (*(void (**)(uint64_t, void))(v4 + 16))(v4, 0);
    }
  }
}

uint64_t sub_100083CB4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

Class sub_100084100()
{
  if (qword_100808B70 != -1) {
    dispatch_once(&qword_100808B70, &stru_100732400);
  }
  Class result = objc_getClass("NPKCompanionAgentConnection");
  qword_100808B60 = (uint64_t)result;
  off_100805148 = (uint64_t (*)())sub_100084164;
  return result;
}

id sub_100084164()
{
  return (id)qword_100808B60;
}

void sub_100084170(id a1)
{
  qword_100808B68 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/NanoPassKit.framework/NanoPassKit", 2);
}

void sub_1000843D4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v7 = objc_alloc_init(PDMissingRemoteAssetsPersistentStoreItem);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v7 withProperties:v6 values:a4];

  [*(id *)(a1 + 40) addObject:v7];
}

void sub_1000847D4(id a1, PDMissingRemoteAssetsPersistentStoreItem *a2, id a3)
{
}

void sub_1000847DC(id a1, PDMissingRemoteAssetsPersistentStoreItem *a2, id a3)
{
  uint64_t v4 = a2;
  -[PDMissingRemoteAssetsPersistentStoreItem setDownloadRetriesCount:](v4, "setDownloadRetriesCount:", [a3 unsignedIntegerValue]);
}

void sub_100084FFC(id a1, PKFeatureApplicationOfferDetails *a2, id a3)
{
}

void sub_100085004(id a1, PKFeatureApplicationOfferDetails *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKFeatureApplicationOfferDetails *)v3 setExpiryDate:v4];
}

void sub_100085064(id a1, PKFeatureApplicationOfferDetails *a2, id a3)
{
  id v4 = a2;
  id v5 = +[NSDecimalNumber decimalNumberWithString:a3];
  [(PKFeatureApplicationOfferDetails *)v4 setCreditLimit:v5];
}

void sub_1000850DC(id a1, PKFeatureApplicationOfferDetails *a2, id a3)
{
  id v4 = a2;
  id v5 = +[NSDecimalNumber decimalNumberWithString:a3];
  [(PKFeatureApplicationOfferDetails *)v4 setAnnualFee:v5];
}

void sub_100085154(id a1, PKFeatureApplicationOfferDetails *a2, id a3)
{
  id v4 = a2;
  id v5 = +[NSDecimalNumber decimalNumberWithString:a3];
  [(PKFeatureApplicationOfferDetails *)v4 setAprForPurchase:v5];
}

void sub_1000851CC(id a1, PKFeatureApplicationOfferDetails *a2, id a3)
{
}

void sub_1000851D4(id a1, PKFeatureApplicationOfferDetails *a2, id a3)
{
  id v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKFeatureApplicationOfferDetails *)v3 setBalance:v4];
}

void sub_100085330(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_100085544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_10008555C(void *a1, void *a2)
{
  id v2 = a1;
  if (a1)
  {
    id v3 = a2;
    id v4 = objc_alloc_init((Class)NSMutableDictionary);
    id v5 = objc_opt_class();
    [v5 databaseTable];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100086E2C;
    v10[3] = &unk_1007327A0;
    id v13 = v5;
    id v11 = (id)objc_claimAutoreleasedReturnValue();
    id v6 = v4;
    id v12 = v6;
    id v7 = v11;
    [v3 enumerateKeysAndObjectsUsingBlock:v10];

    int v8 = v12;
    id v2 = v6;
  }
  return v2;
}

uint64_t sub_100085658(uint64_t a1)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_100085700;
  v7[3] = &unk_100732590;
  uint64_t v10 = *(void *)(a1 + 56);
  id v2 = *(void **)(a1 + 32);
  id v3 = *(id *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  id v8 = v3;
  uint64_t v9 = v4;
  [v2 enumerateKeysAndObjectsUsingBlock:v7];
  uint64_t v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);

  return v5;
}

void sub_100085700(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v7 = a3;
  id v8 = a2;
  id v10 = sub_1000857BC((uint64_t)SQLiteEntity, v7);
  BOOL v9 = sub_1000858E4((uint64_t)SQLiteEntity, v7, v10, *(void *)(a1 + 48), v8, *(void **)(a1 + 32));

  if (!v9)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    *a4 = 1;
  }
}

id sub_1000857BC(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = objc_alloc_init((Class)NSMutableArray);
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v4 = v2;
  id v5 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v11;
    do
    {
      id v8 = 0;
      do
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v4);
        }
        objc_msgSend(v3, "addObject:", *(void *)(*((void *)&v10 + 1) + 8 * (void)v8), (void)v10);
        id v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v6);
  }

  [v3 sortUsingComparator:&stru_100732750];
  return v3;
}

BOOL sub_1000858E4(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5, void *a6)
{
  id v27 = a2;
  id v9 = a3;
  id v10 = a5;
  id v11 = a6;
  long long v12 = self;
  uint64_t v39 = 0;
  id v40 = &v39;
  uint64_t v41 = 0x2020000000;
  char v42 = 1;
  id v13 = [objc_alloc((Class)NSMutableString) initWithString:@"INSERT OR REPLACE INTO "];
  [v13 appendString:v10];
  objc_msgSend(v13, "appendString:", @" (");
  uint64_t v14 = [v12 foreignKeyColumnForTable:v10];
  id v15 = (void *)v14;
  if (v14) {
    CFStringRef v16 = (const __CFString *)v14;
  }
  else {
    CFStringRef v16 = @"ROWID";
  }
  objc_msgSend(v13, "appendString:", v16, v27);
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  id v17 = v9;
  id v18 = [v17 countByEnumeratingWithState:&v35 objects:v43 count:16];
  if (v18)
  {
    uint64_t v19 = *(void *)v36;
    do
    {
      for (uint64_t i = 0; i != v18; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v36 != v19) {
          objc_enumerationMutation(v17);
        }
        uint64_t v21 = *(void *)(*((void *)&v35 + 1) + 8 * i);
        [v13 appendString:@", "];
        [v13 appendString:v21];
      }
      id v18 = [v17 countByEnumeratingWithState:&v35 objects:v43 count:16];
    }
    while (v18);
  }

  [v13 appendString:@") VALUES (?"];
  for (uint64_t j = (char *)[v17 count]; j; --j)
    [v13 appendString:@", ?"];
  [v13 appendString:@";"]);
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472;
  v30[2] = sub_100086CD0;
  v30[3] = &unk_100732778;
  uint64_t v34 = a4;
  id v23 = v17;
  id v31 = v23;
  id v24 = v28;
  id v32 = v24;
  long long v33 = &v39;
  sub_1000128B8((uint64_t)v11, v13, 1, v30);
  BOOL v25 = *((unsigned char *)v40 + 24) != 0;

  _Block_object_dispose(&v39, 8);
  return v25;
}

void sub_100085BC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_100085CB8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [*(id *)(a1 + 40) databasePropertyToSetClientProperty:v5];
  if (v7)
  {
    id v8 = *(void **)(a1 + 32);
    id v9 = [*(id *)(a1 + 40) databaseValueForProperty:v7 clientValue:v6];
    [v8 setObject:v9 forKey:v7];
  }
  else
  {
    id v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 138543618;
      id v13 = (id)objc_opt_class();
      __int16 v14 = 2112;
      id v15 = v5;
      id v11 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}@: Unrecognized client key: %@", (uint8_t *)&v12, 0x16u);
    }
  }
}

void sub_100085F88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100085FA0(uint64_t a1)
{
  id v2 = objc_opt_class();
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = [v2 databaseTable];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100086170(v3, v4, @"ROWID");

  [v2 foreignDatabaseTablesToDelete];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  id v6 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v15;
    while (2)
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v8) {
          objc_enumerationMutation(v5);
        }
        id v10 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        id v11 = objc_msgSend(v2, "foreignKeyColumnForTable:", v10, (void)v14);
        if (v11)
        {
          *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100086170(*(void *)(a1 + 32), v10, v11);
          if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
          {

            goto LABEL_12;
          }
        }
      }
      id v7 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
LABEL_12:

  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    *(void *)(*(void *)(a1 + 32) + _Block_object_dispose(&STACK[0x290], 8) = 0;
    BOOL v12 = *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) != 0;
  }
  else
  {
    BOOL v12 = 0;
  }

  return v12;
}

uint64_t sub_100086170(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    uint64_t v11 = 0;
    BOOL v12 = &v11;
    uint64_t v13 = 0x2020000000;
    char v14 = 0;
    id v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", @"DELETE FROM %@ WHERE %@ = ?;",
           v5,
           v6);
    uint64_t v8 = *(void *)(a1 + 8);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100086F48;
    v10[3] = &unk_100732630;
    void v10[4] = a1;
    void v10[5] = &v11;
    sub_1000128B8(v8, v7, 1, v10);
    a1 = *((unsigned char *)v12 + 24) != 0;

    _Block_object_dispose(&v11, 8);
  }

  return a1;
}

void sub_10008627C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000863A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000863B8(uint64_t a1, sqlite3_stmt *a2)
{
  sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1 + 32) + 16));
  uint64_t result = sub_1000140E0((uint64_t)SQLiteDatabase, a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

int64_t sub_10008640C(id a1, NSString *a2, NSString *a3)
{
  return [(NSString *)a2 compare:a3];
}

void sub_1000865F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100086614(uint64_t a1)
{
  id v2 = sub_10008555C(*(void **)(a1 + 32), *(void **)(a1 + 40));
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_1000866D8;
  v7[3] = &unk_100732708;
  uint64_t v11 = *(void *)(a1 + 64);
  id v3 = *(id *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 32);
  id v8 = v3;
  uint64_t v9 = v4;
  uint64_t v10 = *(void *)(a1 + 56);
  [v2 enumerateKeysAndObjectsUsingBlock:v7];
  uint64_t v5 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);

  return v5;
}

void sub_1000866D8(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = sub_1000857BC((uint64_t)SQLiteEntity, v8);
  uint64_t v10 = [*(id *)(a1 + 56) foreignKeyColumnForTable:v7];
  if (v10) {
    uint64_t v11 = (__CFString *)v10;
  }
  else {
    uint64_t v11 = @"ROWID";
  }
  uint64_t v36 = 0;
  long long v37 = &v36;
  uint64_t v38 = 0x2020000000;
  char v39 = 1;
  if (([v7 isEqualToString:*(void *)(a1 + 32)] & 1) == 0)
  {
    id v12 = [objc_alloc((Class)NSMutableString) initWithString:@"SELECT 1 FROM "];
    [v12 appendString:v7];
    [v12 appendString:@" WHERE "];
    [v12 appendString:v11];
    [v12 appendString:@" =  ? LIMIT 1;"];
    uint64_t v13 = *(void *)(a1 + 40);
    uint64_t v14 = *(void *)(v13 + 8);
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 3221225472;
    v35[2] = sub_100086AFC;
    v35[3] = &unk_100732630;
    v35[4] = v13;
    v35[5] = &v36;
    sub_1000128B8(v14, v12, 1, v35);
  }
  if (*((unsigned char *)v37 + 24))
  {
    id v15 = [objc_alloc((Class)NSMutableString) initWithString:@"UPDATE "];
    [v15 appendString:v7];
    [v15 appendString:@" SET "];
    id v23 = v9;
    id v24 = a4;
    BOOL v25 = v8;
    id v26 = v7;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    id v16 = v9;
    id v17 = [v16 countByEnumeratingWithState:&v31 objects:v40 count:16];
    if (v17)
    {
      char v18 = 0;
      uint64_t v19 = *(void *)v32;
      do
      {
        for (uint64_t i = 0; i != v17; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v32 != v19) {
            objc_enumerationMutation(v16);
          }
          uint64_t v21 = *(void *)(*((void *)&v31 + 1) + 8 * i);
          if (v18) {
            [v15 appendString:@", "];
          }
          [v15 appendString:v21];
          [v15 appendString:@" = ?"];
          char v18 = 1;
        }
        id v17 = [v16 countByEnumeratingWithState:&v31 objects:v40 count:16];
      }
      while (v17);
    }

    id v8 = v25;
    id v7 = v26;
    id v9 = v23;
    a4 = v24;
    [v15 appendString:@" WHERE "];
    [v15 appendString:v26];
    [v15 appendString:@"."];
    [v15 appendString:v11];
    [v15 appendString:@" = ?;"];
    uint64_t v22 = *(void *)(*(void *)(a1 + 40) + 8);
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472;
    id v27[2] = sub_100086B50;
    v27[3] = &unk_1007326E0;
    id v28 = v16;
    id v29 = v25;
    long long v30 = *(_OWORD *)(a1 + 40);
    sub_1000128B8(v22, v15, 1, v27);
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = sub_1000858E4((uint64_t)SQLiteEntity, v8, v9, *(void *)(*(void *)(a1 + 40) + 16), v7, *(void **)(*(void *)(a1 + 40) + 8));
  }
  *a4 = *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) ^ 1;
  _Block_object_dispose(&v36, 8);
}

void sub_100086AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

uint64_t sub_100086AFC(uint64_t a1, sqlite3_stmt *a2)
{
  sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1 + 32) + 16));
  uint64_t result = sub_1000140E0((uint64_t)SQLiteDatabase, a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

uint64_t sub_100086B50(uint64_t a1, sqlite3_stmt *a2)
{
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v15;
    int v8 = 1;
    do
    {
      id v9 = 0;
      int v10 = v8;
      do
      {
        if (*(void *)v15 != v7) {
          objc_enumerationMutation(v4);
        }
        objc_msgSend(*(id *)(a1 + 40), "objectForKeyedSubscript:", *(void *)(*((void *)&v14 + 1) + 8 * (void)v9), (void)v14);
        uint64_t v11 = (objc_object *)objc_claimAutoreleasedReturnValue();
        SQLiteBindFoundationValueToStatement(a2, v10 + v9, v11);

        id v9 = (char *)v9 + 1;
      }
      while (v6 != v9);
      id v6 = [v4 countByEnumeratingWithState:&v14 objects:v18 count:16];
      int v8 = v10 + v9;
    }
    while (v6);
    int v12 = v10 + v9;
  }
  else
  {
    int v12 = 1;
  }

  sqlite3_bind_int64(a2, v12, *(void *)(*(void *)(a1 + 48) + 16));
  uint64_t result = sub_10035CD0C((uint64_t)SQLiteDatabase, a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = result;
  return result;
}

int64_t sub_100086CC8(id a1, NSString *a2, NSString *a3)
{
  return [(NSString *)a2 compare:a3];
}

uint64_t sub_100086CD0(uint64_t a1, sqlite3_stmt *a2)
{
  sqlite3_bind_int64(a2, 1, *(void *)(a1 + 56));
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v13;
    int v8 = 2;
    do
    {
      id v9 = 0;
      do
      {
        if (*(void *)v13 != v7) {
          objc_enumerationMutation(v4);
        }
        objc_msgSend(*(id *)(a1 + 40), "objectForKey:", *(void *)(*((void *)&v12 + 1) + 8 * (void)v9), (void)v12);
        int v10 = (objc_object *)objc_claimAutoreleasedReturnValue();
        SQLiteBindFoundationValueToStatement(a2, v8 + v9, v10);

        id v9 = (char *)v9 + 1;
      }
      while (v6 != v9);
      id v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      v8 += (int)v9;
    }
    while (v6);
  }

  uint64_t result = sub_10035CD0C((uint64_t)SQLiteDatabase, a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = result;
  return result;
}

void sub_100086E2C(id *a1, void *a2, void *a3)
{
  id v12 = a2;
  id v5 = a3;
  if (([v12 isEqualToString:@"ROWID"] & 1) == 0)
  {
    id v6 = [a1[6] foreignDatabaseTableForProperty:v12];
    uint64_t v7 = v6;
    if (v6)
    {
      id v8 = v6;
      id v9 = [a1[6] foreignDatabaseColumnForProperty:v12];
    }
    else
    {
      id v8 = a1[4];
      id v9 = v12;
    }
    int v10 = v9;
    id v11 = [a1[5] objectForKeyedSubscript:v8];
    if (!v11)
    {
      id v11 = objc_alloc_init((Class)NSMutableDictionary);
      [a1[5] setObject:v11 forKeyedSubscript:v8];
    }
    [v11 setObject:v5 forKeyedSubscript:v10];
  }
}

uint64_t sub_100086F48(uint64_t a1, sqlite3_stmt *a2)
{
  sqlite3_bind_int64(a2, 1, *(void *)(*(void *)(a1 + 32) + 16));
  uint64_t result = sub_10035CD0C((uint64_t)SQLiteDatabase, a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void sub_100087520(id a1, PKPayLaterAccountProductEligibleSpend *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPayLaterAccountProductEligibleSpend *)v3 setExpirationDate:v4];
}

void sub_1000876F0(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_100087C18(uint64_t a1)
{
  objc_initWeak(&location, *(id *)(a1 + 32));
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 32);
  id v3 = objc_opt_new();
  [v3 setCredentials:*(void *)(a1 + 40)];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_100087DF0;
  void v11[3] = &unk_100732808;
  objc_copyWeak(&v13, &location);
  id v12 = *(id *)(a1 + 48);
  [v3 setCompletion:v11];
  id v4 = *(void **)(*(void *)(a1 + 32) + 32);
  if (v4)
  {
    [v4 addObject:v3];
  }
  else
  {
    uint64_t v5 = +[NSMutableArray arrayWithObject:v3];
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void **)(v6 + 32);
    *(void *)(v6 + 32) = v5;
  }
  id v8 = PKLogFacilityTypeGetObject();
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v9)
    {
      *(_WORD *)int v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Safari Import: Queue already exists, will wait for next item to pop queue", v10, 2u);
    }
  }
  else
  {
    if (v9)
    {
      *(_WORD *)int v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Safari Import: Immediately popping the queue to start the process", v10, 2u);
    }

    [*(id *)(a1 + 32) _popEligibilityQueue];
  }

  objc_destroyWeak(&v13);
  objc_destroyWeak(&location);
}

void sub_100087DC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100087DF0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v11 = a2;
  id v7 = a3;
  id v8 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v10 = *(void *)(a1 + 32);
  if (v10) {
    (*(void (**)(uint64_t, id, id, id))(v10 + 16))(v10, v11, v7, v8);
  }
  [WeakRetained _popEligibilityQueue];
}

void sub_100087F1C(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 32) count];
  id v3 = PKLogFacilityTypeGetObject();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      id v5 = [*(id *)(*(void *)(a1 + 32) + 32) count];
      int v7 = 134217984;
      id v8 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Safari Import: Popping item from the queue (count: %ld)", (uint8_t *)&v7, 0xCu);
    }

    uint64_t v6 = [*(id *)(*(void *)(a1 + 32) + 32) firstObject];
    [*(id *)(*(void *)(a1 + 32) + 32) removeObjectAtIndex:0];
    [*(id *)(a1 + 32) _processEligibilityItem:v6];
  }
  else
  {
    if (v4)
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Safari Import: Queue empty, so tearing down resources", (uint8_t *)&v7, 2u);
    }

    [*(id *)(a1 + 32) _cleanupQueueResources];
  }
}

void sub_100088200(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 8);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000882D4;
  v4[3] = &unk_100732880;
  void v4[4] = v2;
  objc_copyWeak(&v6, (id *)(a1 + 48));
  id v5 = *(id *)(a1 + 40);
  [v3 diagnosticSessionWithReason:@"CheckSafariCredentialProvisioningEligibility" sessionHandler:v4];

  objc_destroyWeak(&v6);
}

void sub_1000882C0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000882D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  BOOL v4 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000883A8;
  block[3] = &unk_100732858;
  objc_copyWeak(&v9, (id *)(a1 + 48));
  id v7 = v3;
  id v8 = *(id *)(a1 + 40);
  id v5 = v3;
  dispatch_async(v4, block);

  objc_destroyWeak(&v9);
}

void sub_1000883A8(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 48);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v4 = [objc_alloc((Class)PKPaymentProvisioningController) initWithWebService:*(void *)(a1 + 32) localPaymentService:0];
    id v5 = (void *)WeakRetained[5];
    WeakRetained[5] = v4;

    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Safari Import: Preflighting provisioning controller", buf, 2u);
    }

    id v7 = (void *)WeakRetained[5];
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_100088500;
    v8[3] = &unk_100732830;
    objc_copyWeak(&v10, v2);
    id v9 = *(id *)(a1 + 40);
    [v7 preflightWithRequirements:5 completionRequirements:5 completion:v8];

    objc_destroyWeak(&v10);
  }
}

void sub_1000884EC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_100088500(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (a2)
    {
      id v7 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Safari Import: Preflight success!", buf, 2u);
      }

      [WeakRetained _associateCredentialsForItem:*(void *)(a1 + 32)];
    }
    else
    {
      id v8 = PDDefaultQueue();
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100088634;
      block[3] = &unk_10072E238;
      id v10 = v5;
      id v11 = *(id *)(a1 + 32);
      id v12 = WeakRetained;
      dispatch_async(v8, block);
    }
  }
}

void sub_100088634(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v8 = 138412290;
    uint64_t v9 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Safari Import: Preflight failed: %@", (uint8_t *)&v8, 0xCu);
  }

  id v4 = [*(id *)(a1 + 40) completion];

  if (v4)
  {
    id v5 = [*(id *)(a1 + 40) completion];
    ((void (**)(void, void *, void *, void))v5)[2](v5, &__NSArray0__struct, &__NSArray0__struct, *(void *)(a1 + 32));
  }
  uint64_t v6 = *(void *)(a1 + 48);
  id v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = 0;
}

void sub_1000887D0(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 32) + 40))
  {
    uint64_t v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Safari Import: Associating credentials with provisioning controller", (uint8_t *)&buf, 2u);
    }

    objc_initWeak(&buf, *(id *)(a1 + 32));
    uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 40);
    id v4 = [*(id *)(a1 + 40) credentials];
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    id v6[2] = sub_100088A5C;
    v6[3] = &unk_1007328F8;
    void v6[4] = *(void *)(a1 + 32);
    objc_copyWeak(&v8, &buf);
    id v7 = *(id *)(a1 + 40);
    [v3 associateCredentials:v4 withCompletionHandler:v6];

    objc_destroyWeak(&v8);
    objc_destroyWeak(&buf);
  }
  else
  {
    id v5 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000889A4;
    block[3] = &unk_10072E1E8;
    id v11 = *(id *)(a1 + 40);
    dispatch_async(v5, block);
  }
}

void sub_100088980(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000889A4(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Safari Import: Provisioning controller already destroyed, can't associate", v5, 2u);
  }

  uint64_t v3 = [*(id *)(a1 + 32) completion];

  if (v3)
  {
    id v4 = [*(id *)(a1 + 32) completion];
    ((void (**)(void, void *, void *, void))v4)[2](v4, &__NSArray0__struct, &__NSArray0__struct, 0);
  }
}

void sub_100088A5C(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100088B44;
  block[3] = &unk_1007328D0;
  objc_copyWeak(&v14, (id *)(a1 + 48));
  char v15 = a2;
  id v11 = v5;
  id v7 = *(id *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 32);
  id v12 = v7;
  uint64_t v13 = v8;
  id v9 = v5;
  dispatch_async(v6, block);

  objc_destroyWeak(&v14);
}

void sub_100088B44(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 56));
  if (WeakRetained)
  {
    uint64_t v3 = +[NSMutableArray array];
    int v4 = *(unsigned __int8 *)(a1 + 64);
    id v5 = PKLogFacilityTypeGetObject();
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    long long v32 = WeakRetained;
    long long v33 = v3;
    if (v4)
    {
      if (v6)
      {
        *(_WORD *)id buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Safari Import: Association succeeded", buf, 2u);
      }

      long long v46 = 0u;
      long long v47 = 0u;
      long long v45 = 0u;
      long long v44 = 0u;
      id v5 = [WeakRetained[5] associatedCredentials];
      id v7 = [v5 countByEnumeratingWithState:&v44 objects:v51 count:16];
      if (v7)
      {
        id v8 = v7;
        uint64_t v9 = *(void *)v45;
        do
        {
          for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v45 != v9) {
              objc_enumerationMutation(v5);
            }
            id v11 = *(void **)(*((void *)&v44 + 1) + 8 * i);
            id v12 = [v11 safariCredential];
            [v3 safelyAddObject:v12];

            [WeakRetained[5] resolveProvisioningForCredential:v11];
          }
          id v8 = [v5 countByEnumeratingWithState:&v44 objects:v51 count:16];
        }
        while (v8);
      }
    }
    else if (v6)
    {
      uint64_t v13 = *(void *)(a1 + 32);
      *(_DWORD *)id buf = 138412290;
      uint64_t v50 = v13;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Safari Import: Association failed: %@", buf, 0xCu);
    }

    long long v34 = +[NSMutableArray array];
    uint64_t v35 = a1;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    id v14 = [*(id *)(a1 + 40) credentials];
    id v15 = [v14 countByEnumeratingWithState:&v40 objects:v48 count:16];
    if (v15)
    {
      id v16 = v15;
      uint64_t v17 = *(void *)v41;
      do
      {
        for (uint64_t j = 0; j != v16; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v41 != v17) {
            objc_enumerationMutation(v14);
          }
          uint64_t v19 = *(void **)(*((void *)&v40 + 1) + 8 * (void)j);
          id v20 = [v19 state];
          uint64_t v21 = [v20 eligibilityResponse];

          if (v21)
          {
            if ([v21 eligibilityStatus] == (id)3)
            {
              uint64_t v22 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)id buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Safari Import: Credential is already provisioned", buf, 2u);
              }

              id v23 = *(void **)(*(void *)(v35 + 48) + 24);
              id v24 = [v21 fpanIdentifier];
              BOOL v25 = [v23 passWithPrimaryAccountIdentifier:v24];
              id v26 = [v25 paymentPass];

              if (v26)
              {
                if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)id buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Safari Import: Found pass for already provisioned credential", buf, 2u);
                }

                id v27 = [[PDSafariCredentialEligibilityCredentialPassPair alloc] initWithCredential:v19 paymentPass:v26];
                [v34 safelyAddObject:v27];
              }
            }
            else if ([v21 eligibilityStatus] == (id)1 {
                   && [v21 supersededBy]
            }
                   && ([v33 containsObject:v19] & 1) == 0)
            {
              id v28 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)id buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Safari Import: Credential was a card on file, but not provisioned", buf, 2u);
              }

              [v33 safelyAddObject:v19];
            }
          }
        }
        id v16 = [v14 countByEnumeratingWithState:&v40 objects:v48 count:16];
      }
      while (v16);
    }

    id WeakRetained = v32;
    [v32[5] reset];
    id v29 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10008903C;
    block[3] = &unk_10072E238;
    id v37 = v33;
    id v38 = v34;
    id v39 = *(id *)(v35 + 40);
    id v30 = v34;
    id v31 = v33;
    dispatch_async(v29, block);
  }
}

void sub_10008903C(id *a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [a1[4] count];
    id v4 = [a1[5] count];
    int v9 = 134218240;
    id v10 = v3;
    __int16 v11 = 2048;
    id v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Safari Import: Safari count: %ld, Provisioned count: %ld", (uint8_t *)&v9, 0x16u);
  }

  id v5 = [a1[6] completion];

  if (v5)
  {
    BOOL v6 = [a1[6] completion];
    id v7 = [a1[4] copy];
    id v8 = [a1[5] copy];
    ((void (**)(void, id, id, void))v6)[2](v6, v7, v8, 0);
  }
}

void sub_10008994C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_100089B44(id a1, PDPassEndpointMetadata *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PDPassEndpointMetadata *)v3 setLastUpdated:v4];
}

void sub_100089BA4(id a1, PDPassEndpointMetadata *a2, id a3)
{
  id v4 = a2;
  -[PDPassEndpointMetadata setDirty:](v4, "setDirty:", [a3 BOOLValue]);
}

void sub_100089BFC(id a1, PDPassEndpointMetadata *a2, id a3)
{
  id v4 = a2;
  -[PDPassEndpointMetadata setType:](v4, "setType:", [a3 integerValue]);
}

void sub_100089C54(id a1, PDPassEndpointMetadata *a2, id a3)
{
}

id sub_100089EE4(uint64_t a1, uint64_t a2, void *a3)
{
  return [*(id *)(a1 + 32) addObject:*a3];
}

id sub_10008A084(uint64_t a1, uint64_t a2, void *a3)
{
  return [*(id *)(a1 + 32) addObject:*a3];
}

void sub_10008A1B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10008A1C8(uint64_t a1)
{
  uint64_t v2 = +[Pass anyInDatabase:*(void *)(a1 + 32) withUniqueID:*(void *)(a1 + 40)];
  if (v2)
  {
    id v3 = +[SQLiteContainsPredicate doesNotContainPredicateWithProperty:@"participant_identifier" values:*(void *)(a1 + 48)];
    id v4 = [*(id *)(a1 + 64) queryWithDatabase:*(void *)(a1 + 32) predicate:v3];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v4 deleteAllEntities];

    id v5 = [objc_alloc((Class)NSMutableSet) initWithSet:*(void *)(a1 + 48)];
    BOOL v6 = *(void **)(a1 + 64);
    uint64_t v7 = *(void *)(a1 + 32);
    id v8 = [v6 _predicateForPassUniqueID:*(void *)(a1 + 40)];
    int v9 = [v6 queryWithDatabase:v7 predicate:v8];

    CFStringRef v30 = @"participant_identifier";
    id v10 = +[NSArray arrayWithObjects:&v30 count:1];
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472;
    id v27[2] = sub_10008A48C;
    v27[3] = &unk_1007329C0;
    id v11 = v5;
    id v28 = v11;
    [v9 enumerateProperties:v10 usingBlock:v27];

    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    id v12 = v11;
    id v13 = [v12 countByEnumeratingWithState:&v23 objects:v29 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v24;
      do
      {
        for (uint64_t i = 0; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v24 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void *)(*(void *)(a1 + 56) + 8);
          if (*(unsigned char *)(v17 + 24))
          {
            uint64_t v18 = *(void *)(*((void *)&v23 + 1) + 8 * i);
            uint64_t v19 = [TileDescriptorStateParticipant alloc];
            id v20 = -[TileDescriptorStateParticipant _initWitParticipantID:forPass:inDatabase:](v19, "_initWitParticipantID:forPass:inDatabase:", v18, v2, *(void *)(a1 + 32), (void)v23);
            *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v20 != 0;
          }
          else
          {
            *(unsigned char *)(v17 + 24) = 0;
          }
        }
        id v14 = [v12 countByEnumeratingWithState:&v23 objects:v29 count:16];
      }
      while (v14);
    }

    BOOL v21 = *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) != 0;
  }
  else
  {
    [*(id *)(a1 + 64) removeParticipantsForPassUniqueID:*(void *)(a1 + 40) inDatabase:*(void *)(a1 + 32)];
    BOOL v21 = 0;
  }

  return v21;
}

id sub_10008A48C(uint64_t a1, uint64_t a2, void *a3)
{
  return [*(id *)(a1 + 32) removeObject:*a3];
}

void sub_10008A890(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10008A8A8(uint64_t a1)
{
  id v2 = [objc_alloc(*(Class *)(a1 + 64)) initWithPendingProvisioning:*(void *)(a1 + 32) forBasePendingProvisioning:*(void *)(a1 + 40) inDatabase:*(void *)(a1 + 48)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) != 0;
}

void sub_10008AA24(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  int v9 = *(void **)(a1 + 40);
  id v10 = a3;
  id v11 = [v9 _propertySetters];
  [v9 applyPropertySetters:v11 toObject:*(void *)(a1 + 32) withProperties:v10 values:a4];

  *a6 = 1;
}

void sub_10008AD68(id a1, PKPendingCarKeyProvisioning *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPendingCarKeyProvisioning *)a2 configuration];
  [v5 setManufacturerIdentifier:v4];
}

void sub_10008ADC8(id a1, PKPendingCarKeyProvisioning *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPendingCarKeyProvisioning *)a2 configuration];
  [v5 setIssuerIdentifier:v4];
}

void sub_10008AE28(id a1, PKPendingCarKeyProvisioning *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPendingCarKeyProvisioning *)a2 configuration];
  [v5 setProvisioningTemplateIdentifier:v4];
}

void sub_10008AE88(id a1, PKPendingCarKeyProvisioning *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPendingCarKeyProvisioning *)a2 configuration];
  LODWORD(a2) = [v4 unsignedIntValue];

  [v5 setSupportedRadioTechnologies:a2];
}

void sub_10008AEF8(id a1, PKPendingCarKeyProvisioning *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPendingCarKeyProvisioning *)a2 configuration];
  [v5 setProductPlanIdentifier:v4];
}

void sub_10008AF58(id a1, PKPendingCarKeyProvisioning *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPendingCarKeyProvisioning *)a2 configuration];
  [v5 setVehicleName:v4];
}

void sub_10008AFB8(id a1, PKPendingCarKeyProvisioning *a2, id a3)
{
  id v4 = a3;
  id v5 = [(PKPendingCarKeyProvisioning *)a2 configuration];
  [v5 setPairedReaderIdentifier:v4];
}

void sub_10008B57C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];

  id v6 = [*(id *)(a1 + 32) persistentID];
  uint64_t v7 = [*(id *)(a1 + 32) database];
  id v11 = +[PayLaterInstallment payLaterInstallmentsForScheduleSummaryPID:v6 inDatabase:v7];

  [*(id *)(a1 + 48) setInstallments:v11];
  id v8 = [*(id *)(a1 + 32) persistentID];
  int v9 = [*(id *)(a1 + 32) database];
  id v10 = +[PayLaterPayment payLaterPaymentsForScheduleSummaryPID:v8 inDatabase:v9];

  [*(id *)(a1 + 48) setPayments:v10];
}

void sub_10008B7F4(id a1, PKPayLaterFinancingPlanScheduleSummary *a2, id a3)
{
  id v4 = a2;
  -[PKPayLaterFinancingPlanScheduleSummary setScheduleSummaryReason:](v4, "setScheduleSummaryReason:", [a3 integerValue]);
}

void sub_10008BAD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10008BAEC(uint64_t a1)
{
  id v2 = [objc_alloc(*(Class *)(a1 + 64)) initWithMetadata:*(void *)(a1 + 32) forBaseMetadata:*(void *)(a1 + 40) inDatabase:*(void *)(a1 + 48)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) != 0;
}

void sub_10008BCA8(uint64_t a1, uint64_t a2, uint64_t a3, id *a4, uint64_t a5, unsigned char *a6)
{
  if (*a4)
  {
    id v8 = *a4;
    id v9 = objc_alloc((Class)NSSet);
    uint64_t v10 = objc_opt_class();
    id v11 = objc_msgSend(v9, "initWithObjects:", v10, objc_opt_class(), 0);
    id v12 = +[NSKeyedUnarchiver unarchivedObjectOfClasses:v11 fromData:v8 error:0];

    [*(id *)(a1 + 32) setVehicleFunctions:v12];
  }
  *a6 = 1;
}

void sub_10008C3F4(uint64_t a1, uint64_t a2, void *a3, id *a4)
{
  id v7 = a3;
  id v6 = *a4;
  if (v6)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      [*(id *)(a1 + 32) addObject:v6];
    }
  }
}

void sub_10008C5EC(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  id v6 = *a4;
  id v7 = +[NSNumber numberWithLongLong:a2];
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  id obj = [*(id *)(a1 + 32) objectForKey:v7];
  id v8 = [obj countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v16;
    do
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v10) {
          objc_enumerationMutation(obj);
        }
        id v12 = *(void **)(*((void *)&v15 + 1) + 8 * i);
        [v12 setTransactionSourceIdentifier:v6];
        id v13 = +[PaymentApplication anyInDatabase:withTransactionSourcePID:](PaymentApplication, "anyInDatabase:withTransactionSourcePID:", *(void *)(a1 + 40), [v7 longLongValue]);
        [v12 setHasAssociatedPaymentApplication:v13 != 0];
      }
      id v9 = [obj countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v9);
  }
}

void sub_10008D534(uint64_t a1, uint64_t a2, void *a3)
{
  id v8 = a3;
  id v6 = [objc_alloc(*(Class *)(a1 + 48)) initWithPersistentID:a2 inDatabase:*(void *)(a1 + 32)];
  id v7 = [v6 valueForProperty:@"b"];
  if (v7)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      [*(id *)(a1 + 40) addObject:v7];
    }
  }
}

void sub_10008D888(uint64_t a1, uint64_t a2, void *a3)
{
  id v9 = a3;
  id v6 = [(SQLiteEntity *)[AccountRewards alloc] initWithPersistentID:a2 inDatabase:*(void *)(a1 + 32)];
  id v7 = *(void **)(a1 + 40);
  id v8 = [(AccountRewards *)v6 rewards];
  [v7 addObject:v8];
}

void sub_10008DD34(uint64_t a1, uint64_t a2, uint64_t a3)
{
  +[SQLiteEntity applyPropertySetters:*(void *)(a1 + 32) toObject:*(void *)(a1 + 40) withProperties:a2 values:a3];
  id v4 = *(void **)(a1 + 40);
  id v5 = [*(id *)(a1 + 48) currencyAmount];
  [v4 setCurrencyAmount:v5];
}

void sub_10008E148(id a1, PKAccountRewards *a2, id a3)
{
}

void sub_10008E150(id a1, PKAccountRewards *a2, id a3)
{
  id v4 = a2;
  -[PKAccountRewards setType:](v4, "setType:", [a3 integerValue]);
}

void sub_10008E1A8(id a1, PKAccountRewards *a2, id a3)
{
}

void sub_10008E1B0(id a1, PKAccountRewards *a2, id a3)
{
  id v4 = a2;
  -[PKAccountRewards setStatusCode:](v4, "setStatusCode:", [a3 integerValue]);
}

void sub_10008E9AC(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 updateCloudStoreWithLocalItemsWithConfigurations:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService updateCloudStoreWithLocalItemsWithConfigurations:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService updateCloudStoreWithLocalItemsWithConfigurations:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService updateCloudStoreWithLocalItemsWithConfigurations:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_10008EE04(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 removeAllItems:*(void *)(a1 + 64) inZoneName:*(void *)(a1 + 40) containerName:*(void *)(a1 + 48) storeLocally:*(unsigned __int8 *)(a1 + 72) completion:*(void *)(a1 + 56)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService removeAllItems:inZoneName:containerName:storeLocally:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 56);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService removeAllItems:inZoneName:containerName:storeLocally:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 56);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService removeAllItems:inZoneName:containerName:storeLocally:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_10008F274(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 removeRecordWithRecordName:*(void *)(a1 + 40) zoneName:*(void *)(a1 + 48) containerName:*(void *)(a1 + 56) completion:*(void *)(a1 + 64)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService removeRecordWithRecordName:zoneName:containerName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 64);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService removeRecordWithRecordName:zoneName:containerName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 64);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService removeRecordWithRecordName:zoneName:containerName:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v7);

LABEL_14:
    }
  }
}

void sub_10008F680(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 allItemsOfItemType:*(void *)(a1 + 48) storeLocally:*(unsigned __int8 *)(a1 + 56) completion:*(void *)(a1 + 40)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService allItemsOfItemType:storeLocally:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 40);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService allItemsOfItemType:storeLocally:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 40);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService allItemsOfItemType:storeLocally:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_10008FAC4(uint64_t a1)
{
  if (![*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService applePayContainerItemsFromDate:toDate:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 56);
    NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
    id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService applePayContainerItemsFromDate:toDate:completion:]_block_invoke");
    id v13 = v5;
    id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
    id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
    (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

    goto LABEL_12;
  }
  id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

  if (!v2)
  {
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService applePayContainerItemsFromDate:toDate:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 56);
    NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
    CFStringRef v15 = @"Cloud store not initialized";
    id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
    (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

LABEL_12:
    return;
  }
  id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
  [v11 applePayContainerItemsFromDate:*(void *)(a1 + 40) toDate:*(void *)(a1 + 48) completion:*(void *)(a1 + 56)];
}

void sub_10008FEF8(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 itemOfItemType:*(void *)(a1 + 56) recordName:*(void *)(a1 + 40) qualityOfService:*(void *)(a1 + 64) completion:*(void *)(a1 + 48)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService itemOfItemType:recordName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService itemOfItemType:recordName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService itemOfItemType:recordName:qualityOfService:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_100090334(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 itemOfItemTypeFromAllZones:*(void *)(a1 + 56) recordName:*(void *)(a1 + 40) qualityOfService:*(void *)(a1 + 64) completion:*(void *)(a1 + 48)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService itemOfItemTypeFromAllZones:recordName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService itemOfItemTypeFromAllZones:recordName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService itemOfItemTypeFromAllZones:recordName:qualityOfService:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_100090758(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 cloudStoreRecordArrayWithConfiguration:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService cloudStoreRecordArrayWithConfiguration:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService cloudStoreRecordArrayWithConfiguration:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService cloudStoreRecordArrayWithConfiguration:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_100090B98(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 resetContainerWithIdentifier:*(void *)(a1 + 40) zoneNames:*(void *)(a1 + 48) completion:*(void *)(a1 + 56)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService resetContainerWithIdentifier:zoneNames:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 56);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService resetContainerWithIdentifier:zoneNames:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 56);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService resetContainerWithIdentifier:zoneNames:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_100090FB4(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 simulateCloudStorePushForContainerIdentifier:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService simulateCloudStorePushForContainerIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void, void *))(v9 + 16))(v9, 0, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService simulateCloudStorePushForContainerIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService simulateCloudStorePushForContainerIdentifier:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void, void *))(v4 + 16))(v4, 0, 0, v7);

LABEL_14:
    }
  }
}

void sub_1000913D4(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) transactionSourceController];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) transactionSourceController];
      [v11 simulatePassProvisioningForPassUniqueIdentifier:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService simulatePassProvisioningForPassUniqueIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      long long v17 = "-[PDCloudStoreService simulatePassProvisioningForPassUniqueIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService simulatePassProvisioningForPassUniqueIdentifier:completion:]_block_invoke");
      id v13 = v5;
      id v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v7);

LABEL_14:
    }
  }
}

void sub_1000917E4(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
    uint64_t v3 = [v2 applePayContainer];

    if (v3)
    {
      id v13 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      uint64_t v4 = [v13 applePayContainer];
      [v4 generateRandomTransactionForTransactionSourceIdentifier:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];

      return;
    }
    uint64_t v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      uint64_t v19 = "-[PDCloudStoreService generateRandomTransactionForTransactionSourceIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v11 = *(void *)(a1 + 48);
    if (v11)
    {
      NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
      CFStringRef v17 = @"Cloud store not initialized";
      id v7 = +[NSDictionary dictionaryWithObjects:&v17 forKeys:&v16 count:1];
      NSErrorUserInfoKey v12 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v7];
      (*(void (**)(uint64_t, void, void *))(v11 + 16))(v11, 0, v12);

      goto LABEL_14;
    }
  }
  else
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      uint64_t v19 = "-[PDCloudStoreService generateRandomTransactionForTransactionSourceIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v6 = *(void *)(a1 + 48);
    if (v6)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      id v7 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService generateRandomTransactionForTransactionSourceIdentifier:completion:]_block_invoke");
      CFStringRef v15 = v7;
      id v8 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v9 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v8];
      (*(void (**)(uint64_t, void, void *))(v6 + 16))(v6, 0, v9);

LABEL_14:
    }
  }
}

void sub_100091C4C(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
    uint64_t v3 = [v2 applePayContainer];

    if (v3)
    {
      id v13 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      uint64_t v4 = [v13 applePayContainer];
      [v4 uploadTransaction:*(void *)(a1 + 40) forTransactionSourceIdentifier:*(void *)(a1 + 48) includeServerData:*(unsigned __int8 *)(a1 + 64) completion:*(void *)(a1 + 56)];

      return;
    }
    uint64_t v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      uint64_t v19 = "-[PDCloudStoreService uploadTransaction:forTransactionSourceIdentifier:includeServerData:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v11 = *(void *)(a1 + 56);
    if (v11)
    {
      NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
      CFStringRef v17 = @"Cloud store not initialized";
      id v7 = +[NSDictionary dictionaryWithObjects:&v17 forKeys:&v16 count:1];
      NSErrorUserInfoKey v12 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v7];
      (*(void (**)(uint64_t, void, void *))(v11 + 16))(v11, 0, v12);

      goto LABEL_14;
    }
  }
  else
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      uint64_t v19 = "-[PDCloudStoreService uploadTransaction:forTransactionSourceIdentifier:includeServerData:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v6 = *(void *)(a1 + 56);
    if (v6)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      id v7 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService uploadTransaction:forTransactionSourceIdentifier:includeServerData:completion:]_block_invoke");
      CFStringRef v15 = v7;
      id v8 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v9 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v8];
      (*(void (**)(uint64_t, void, void *))(v6 + 16))(v6, 0, v9);

LABEL_14:
    }
  }
}

void sub_1000920B4(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 deleteZone:*(void *)(a1 + 40) containerName:*(void *)(a1 + 48) completion:*(void *)(a1 + 56)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      CFStringRef v17 = "-[PDCloudStoreService deleteZone:containerName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 56);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      CFStringRef v17 = "-[PDCloudStoreService deleteZone:containerName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 56);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService deleteZone:containerName:completion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_1000924F8(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 createZone:*(void *)(a1 + 40) containerName:*(void *)(a1 + 48) completion:*(void *)(a1 + 56)];

      return;
    }
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      CFStringRef v17 = "-[PDCloudStoreService createZone:containerName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 56);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      id v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      CFStringRef v17 = "-[PDCloudStoreService createZone:containerName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 56);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService createZone:containerName:completion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_10009293C(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
    uint64_t v3 = [v2 applePayContainer];

    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 40);
      uint64_t v5 = *(void *)(a1 + 48);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_100092C18;
      v13[3] = &unk_100732C40;
      id v14 = *(id *)(a1 + 56);
      [v3 populateEvents:v4 forAccountIdentifier:v5 completion:v13];
      uint64_t v6 = v14;
LABEL_13:

LABEL_14:
      return;
    }
    id v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      id v20 = "-[PDCloudStoreService populateEvents:forAccountIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v8 = *(void *)(a1 + 56);
    if (!v8) {
      goto LABEL_14;
    }
    NSErrorUserInfoKey v17 = NSLocalizedDescriptionKey;
    CFStringRef v18 = @"Cloud store not initialized";
    uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v18 forKeys:&v17 count:1];
    uint64_t v9 = PKPassKitErrorDomain;
    uint64_t v10 = -5000;
LABEL_12:
    NSErrorUserInfoKey v12 = +[NSError errorWithDomain:v9 code:v10 userInfo:v6];
    (*(void (**)(uint64_t, void, void *))(v8 + 16))(v8, 0, v12);

    goto LABEL_13;
  }
  id v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)id buf = 136315138;
    id v20 = "-[PDCloudStoreService populateEvents:forAccountIdentifier:completion:]_block_invoke";
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
  }

  uint64_t v8 = *(void *)(a1 + 56);
  if (v8)
  {
    NSErrorUserInfoKey v15 = NSLocalizedDescriptionKey;
    uint64_t v3 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService populateEvents:forAccountIdentifier:completion:]_block_invoke");
    NSErrorUserInfoKey v16 = v3;
    uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v16 forKeys:&v15 count:1];
    uint64_t v9 = PKPassKitErrorDomain;
    uint64_t v10 = -5002;
    goto LABEL_12;
  }
}

uint64_t sub_100092C18(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_100092DB8(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 declineInvitationForRecipientHandle:*(void *)(a1 + 40) zoneName:*(void *)(a1 + 48) containerName:*(void *)(a1 + 56) qualityOfService:*(void *)(a1 + 72) completion:*(void *)(a1 + 64)];

      return;
    }
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService declineInvitationForRecipientHandle:zoneName:containerName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 64);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService declineInvitationForRecipientHandle:zoneName:containerName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 64);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService declineInvitationForRecipientHandle:zoneName:containerName:qualityOfService:completion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_100093230(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 createInvitationForRecipientHandle:*(void *)(a1 + 40) zoneName:*(void *)(a1 + 48) containerName:*(void *)(a1 + 56) qualityOfService:*(void *)(a1 + 72) completion:*(void *)(a1 + 64)];

      return;
    }
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService createInvitationForRecipientHandle:zoneName:containerName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 64);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService createInvitationForRecipientHandle:zoneName:containerName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 64);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService createInvitationForRecipientHandle:zoneName:containerName:qualityOfService:completion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_100093680(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 shareForZoneName:*(void *)(a1 + 40) containerName:*(void *)(a1 + 48) qualityOfService:*(void *)(a1 + 64) completion:*(void *)(a1 + 56)];

      return;
    }
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService shareForZoneName:containerName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 56);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService shareForZoneName:containerName:qualityOfService:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 56);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService shareForZoneName:containerName:qualityOfService:completion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_100093A9C(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 diagnosticInfoForContainerWithName:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];

      return;
    }
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService diagnosticInfoForContainerWithName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService diagnosticInfoForContainerWithName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService diagnosticInfoForContainerWithName:completion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_100093EB4(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 diagnosticSnapshotForContainerWithName:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];

      return;
    }
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService diagnosticSnapshotForContainerWithName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService diagnosticSnapshotForContainerWithName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService diagnosticSnapshotForContainerWithName:completion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_1000942D8(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
      [v11 performAction:*(void *)(a1 + 56) inContainerWithName:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];

      return;
    }
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService performAction:inContainerWithName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService performAction:inContainerWithName:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService performAction:inContainerWithName:completion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v7);

LABEL_14:
    }
  }
}

void sub_1000946EC(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) transactionSourceController];
      [v11 performBackgroundTransactionSyncFromDate:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];

      return;
    }
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService performBackgroundTransactionSyncFromDate:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService performBackgroundTransactionSyncFromDate:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 48);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService performBackgroundTransactionSyncFromDate:completion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v7);

LABEL_14:
    }
  }
}

void sub_100094AE0(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      id v11 = [*(id *)(a1 + 32) transactionSourceController];
      [v11 performBackgroundRecordChangesSyncWithCompletion:*(void *)(a1 + 40)];

      return;
    }
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService performBackgroundRecordChangesSyncWithCompletion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 40);
    if (v9)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      CFStringRef v15 = @"Cloud store not initialized";
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v10 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v5];
      (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);

      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      NSErrorUserInfoKey v17 = "-[PDCloudStoreService performBackgroundRecordChangesSyncWithCompletion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v4 = *(void *)(a1 + 40);
    if (v4)
    {
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService performBackgroundRecordChangesSyncWithCompletion:]_block_invoke");
      id v13 = v5;
      uint64_t v6 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v6];
      (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v7);

LABEL_14:
    }
  }
}

void sub_100094EF0(uint64_t a1)
{
  if ([*(id *)(*(void *)(a1 + 32) + 8) paymentAllAccess])
  {
    id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];

    if (v2)
    {
      uint64_t v3 = *(void *)(a1 + 48);
      if (v3)
      {
        id v13 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
        uint64_t v4 = [v13 changeHistoryForContainerIdentifier:*(void *)(a1 + 40)];
        (*(void (**)(uint64_t, void *, void))(v3 + 16))(v3, v4, 0);
      }
      return;
    }
    uint64_t v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      uint64_t v19 = "-[PDCloudStoreService changeHistoryForContainerIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Cloud store not initialized. Cannot call method: %s", buf, 0xCu);
    }

    uint64_t v11 = *(void *)(a1 + 48);
    if (v11)
    {
      NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
      CFStringRef v17 = @"Cloud store not initialized";
      id v7 = +[NSDictionary dictionaryWithObjects:&v17 forKeys:&v16 count:1];
      NSErrorUserInfoKey v12 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5000 userInfo:v7];
      (*(void (**)(uint64_t, void, void *))(v11 + 16))(v11, 0, v12);

      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 136315138;
      uint64_t v19 = "-[PDCloudStoreService changeHistoryForContainerIdentifier:completion:]_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Client is not entitled for method: %s", buf, 0xCu);
    }

    uint64_t v6 = *(void *)(a1 + 48);
    if (v6)
    {
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      id v7 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Client is not entitled for method: %s", "-[PDCloudStoreService changeHistoryForContainerIdentifier:completion:]_block_invoke");
      CFStringRef v15 = v7;
      uint64_t v8 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      uint64_t v9 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5002 userInfo:v8];
      (*(void (**)(uint64_t, void, void *))(v6 + 16))(v6, 0, v9);

LABEL_15:
    }
  }
}

void sub_10009536C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100095418;
  v4[3] = &unk_10072E570;
  uint64_t v3 = *(void *)(a1 + 40);
  id v5 = *(id *)(a1 + 48);
  [v2 setupCloudDatabaseForContainerName:v3 completion:v4];
}

uint64_t sub_100095418(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_10009559C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100095648;
  v4[3] = &unk_100732C90;
  uint64_t v3 = *(void *)(a1 + 40);
  id v5 = *(id *)(a1 + 48);
  [v2 cloudStoreStatusForContainer:v3 completion:v4];
}

uint64_t sub_100095648(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_1000957A0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100095840;
  v3[3] = &unk_10072E570;
  id v4 = *(id *)(a1 + 40);
  [v2 checkTLKsMissingWithCompletion:v3];
}

uint64_t sub_100095840(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_100095998(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) cloudStoreNotificationCoordinator];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100095A38;
  v3[3] = &unk_10072E570;
  id v4 = *(id *)(a1 + 40);
  [v2 resetApplePayManateeViewWithCompletion:v3];
}

uint64_t sub_100095A38(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_100095CC4(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2 > 4) {
    CFStringRef v3 = @"unkown reason";
  }
  else {
    CFStringRef v3 = off_100732FC8[v2];
  }
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(unsigned __int8 *)(v4 + 200);
  uint64_t v6 = PKLogFacilityTypeGetObject();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      uint64_t v8 = [*(id *)(v4 + 184) logDescription];
      int v13 = 138543618;
      NSErrorUserInfoKey v14 = v8;
      __int16 v15 = 2114;
      CFStringRef v16 = v3;
      uint64_t v9 = "[PDPassCloudStore(%{public}@)] won't synchronize container is readonly: %{public}@";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v13, 0x16u);
    }
  }
  else
  {
    if (v7)
    {
      uint64_t v10 = [*(id *)(v4 + 184) logDescription];
      int v13 = 138543618;
      NSErrorUserInfoKey v14 = v10;
      __int16 v15 = 2114;
      CFStringRef v16 = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] synchronization data requested: %{public}@", (uint8_t *)&v13, 0x16u);
    }
    unsigned int v11 = [*(id *)(a1 + 32) ensureSyncPreconditionsAreMet];
    NSErrorUserInfoKey v12 = *(os_unfair_lock_s **)(a1 + 32);
    if (v11)
    {
      [(os_unfair_lock_s *)v12 downloadCloudDataWithReason:*(void *)(a1 + 40)];
      return;
    }
    os_unfair_lock_lock(v12 + 54);
    *(unsigned char *)(*(void *)(a1 + 32) + 203) = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
      int v13 = 138543618;
      NSErrorUserInfoKey v14 = v8;
      __int16 v15 = 2114;
      CFStringRef v16 = v3;
      uint64_t v9 = "[PDPassCloudStore(%{public}@)] won't synchronize container now: %{public}@ (precondition)";
      goto LABEL_13;
    }
  }
}

void sub_100095F74(uint64_t a1)
{
  CFStringRef v2 = @"unkown reason";
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3 == 1) {
    CFStringRef v2 = @"perodic check-in";
  }
  if (v3) {
    CFStringRef v5 = v2;
  }
  else {
    CFStringRef v5 = @"reachability change";
  }
  int v6 = *(unsigned __int8 *)(v4 + 200);
  BOOL v7 = PKLogFacilityTypeGetObject();
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      uint64_t v9 = [*(id *)(v4 + 184) logDescription];
      *(_DWORD *)id buf = 138543618;
      CFStringRef v16 = v9;
      __int16 v17 = 2114;
      CFStringRef v18 = v5;
      uint64_t v10 = "[PDPassCloudStore(%{public}@)] won't process pending changes because container is readonly: %{public}@";
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v10, buf, 0x16u);
    }
  }
  else
  {
    if (v8)
    {
      unsigned int v11 = [*(id *)(v4 + 184) logDescription];
      *(_DWORD *)id buf = 138543618;
      CFStringRef v16 = v11;
      __int16 v17 = 2114;
      CFStringRef v18 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] processing pending changes requested: %{public}@", buf, 0x16u);
    }
    if ([*(id *)(a1 + 32) ensureSyncPreconditionsAreMet])
    {
      NSErrorUserInfoKey v12 = *(void **)(a1 + 32);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_1000961BC;
      v13[3] = &unk_100732CB8;
      void v13[4] = v12;
      NSErrorUserInfoKey v14 = (__CFString *)v5;
      [v12 processPendingChanges:v13];

      return;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
      *(_DWORD *)id buf = 138543618;
      CFStringRef v16 = v9;
      __int16 v17 = 2114;
      CFStringRef v18 = v5;
      uint64_t v10 = "[PDPassCloudStore(%{public}@)] won't process pending changes now:%{public}@ (precondition)";
      goto LABEL_15;
    }
  }
}

void sub_1000961BC(uint64_t a1, uint64_t a2, void *a3)
{
  int v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v7 = *(void **)(*(void *)(a1 + 32) + 184);
    id v8 = a3;
    uint64_t v9 = [v7 logDescription];
    uint64_t v10 = *(void *)(a1 + 40);
    unsigned int v11 = +[NSNumber numberWithBool:a2];

    int v12 = 138544130;
    int v13 = v9;
    __int16 v14 = 2114;
    uint64_t v15 = v10;
    __int16 v16 = 2114;
    __int16 v17 = v11;
    __int16 v18 = 2114;
    id v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] because:%{public}@ did process pending changes:%{public}@ %{public}@", (uint8_t *)&v12, 0x2Au);
  }
}

void sub_100096354(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 208);
  *(void *)(v2 + 20_Block_object_dispose(&STACK[0x290], 8) = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  uint64_t v4 = [*(id *)(*(void *)(a1 + 32) + 184) stringPrefixedWithContainerName:@"PDPassSyncCloudStoreContainerLastDownloadDateKey"];
  PKSharedCacheRemoveObjectForKey();

  id v5 = [*(id *)(a1 + 32) delegate];
  [v5 cloudStoreContainer:*(void *)(a1 + 32) reinitializeContainerAndInvalidateFirst:1];
}

id sub_1000969E4()
{
  id v0 = +[ACAccountStore defaultStore];
  uint64_t v1 = objc_msgSend(v0, "aa_primaryAppleAccount");

  id v2 = [v1 isEnabledForDataclass:ACAccountDataclassShoebox];
  return v2;
}

void sub_100097198(uint64_t a1, void *a2, void *a3)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_10009725C;
  v7[3] = &unk_10072E238;
  id v8 = a2;
  id v9 = a3;
  id v10 = *(id *)(a1 + 32);
  id v5 = v9;
  id v6 = v8;
  [v10 onWorkQueue:v7];
}

void sub_10009725C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) accountStatus];
  if (*(void *)(a1 + 40))
  {
    objc_msgSend(*(id *)(a1 + 48), "setOperationError:");
    uint64_t v3 = *(void **)(a1 + 48);
    uint64_t v4 = 3;
LABEL_3:
    [v3 advanceToNextState:v4];
    return;
  }
  id v5 = v2;
  id v6 = *(void **)(a1 + 32);
  if (v6) {
    BOOL v7 = v5 == (id)1;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7 && ([v6 hasValidCredentials] & 1) != 0)
  {
    unsigned int v8 = [*(id *)(*(void *)(a1 + 48) + 184) isEndToEndEncrypted];
    unsigned __int8 v9 = [*(id *)(a1 + 32) deviceToDeviceEncryptionAvailability];
    if (!v8)
    {
      *(unsigned char *)(*(void *)(a1 + 48) + 200) = v9 & 1;
      uint64_t v3 = *(void **)(a1 + 48);
      uint64_t v4 = 5;
      goto LABEL_3;
    }
    *(unsigned char *)(*(void *)(a1 + 48) + 200) = (v9 & 1) == 0;
    unsigned __int8 v10 = [*(id *)(a1 + 32) deviceToDeviceEncryptionAvailability];
    unsigned int v11 = PKLogFacilityTypeGetObject();
    BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if ((v10 & 2) != 0)
    {
      if (v12)
      {
        __int16 v17 = [*(id *)(*(void *)(a1 + 48) + 184) logDescription];
        *(_DWORD *)id buf = 138543362;
        id v20 = v17;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] secure sync is possible now", buf, 0xCu);
      }
      [*(id *)(a1 + 48) advanceToNextState:5];
    }
    else
    {
      if (v12)
      {
        int v13 = [*(id *)(*(void *)(a1 + 48) + 184) logDescription];
        __int16 v14 = +[NSNumber numberWithInt:*(unsigned char *)(*(void *)(a1 + 48) + 200) == 0];
        *(_DWORD *)id buf = 138543618;
        id v20 = v13;
        __int16 v21 = 2114;
        uint64_t v22 = v14;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] secure sync is not possible now (supported by account:%{public}@)", buf, 0x16u);
      }
      uint64_t v15 = *(void **)(a1 + 48);
      __int16 v16 = [v15 errorWithCode:-4005 description:@"Manatee not available now"];
      [v15 advanceToNextState:3 withError:v16];
    }
  }
  else
  {
    id v18 = [*(id *)(a1 + 48) errorWithCode:-4008 description:@"User has an invalid account state"];
    objc_msgSend(*(id *)(a1 + 48), "setOperationError:");
    [*(id *)(a1 + 48) advanceToNextState:3];
  }
}

id sub_100097D70(uint64_t a1)
{
  [*(id *)(a1 + 32) markEndOfDownload:*(void *)(a1 + 40)];
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  return _[v2 finishDownloadOfCloudDataWithContents:v3 forReason:v4];
}

id sub_100097DB4(uint64_t a1)
{
  [*(id *)(a1 + 32) markEndOfDownload:*(void *)(a1 + 40)];
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  return _[v2 finishDownloadOfCloudDataWithContents:v3 forReason:v4];
}

void sub_1000984A4(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v7 = *(void **)(*(void *)(a1 + 32) + 184);
    id v8 = a3;
    unsigned __int8 v9 = [v7 logDescription];
    unsigned __int8 v10 = +[NSNumber numberWithBool:a2];

    int v11 = 138543874;
    BOOL v12 = v9;
    __int16 v13 = 2114;
    __int16 v14 = v10;
    __int16 v15 = 2114;
    id v16 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] did process pending changes:%{public}@ after graceful abort %{public}@", (uint8_t *)&v11, 0x20u);
  }
}

void sub_100098760(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (![*(id *)(a1 + 32) didEncounterChangeTokenExpiredError:v6])
  {
    [*(id *)(a1 + 32) moveItemsFromResponse:v5 duringDeltaSync:1 orError:v6 toContents:*(void *)(a1 + 48)];
    unsigned __int8 v9 = PKLogFacilityTypeGetObject();
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v10)
      {
        int v11 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
        int v14 = 138543362;
        __int16 v15 = v11;
        BOOL v12 = "[PDPassCloudStore(%{public}@)] error downloading records (delta-sync)";
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v14, 0xCu);
      }
    }
    else if (v10)
    {
      int v11 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
      int v14 = 138543362;
      __int16 v15 = v11;
      BOOL v12 = "[PDPassCloudStore(%{public}@)] did download records (delta-sync)";
      goto LABEL_10;
    }

    (*(void (**)(void, uint64_t))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), v13);
    goto LABEL_12;
  }
  BOOL v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
    int v14 = 138543362;
    __int16 v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] can't download records with expired token (delta-sync)", (uint8_t *)&v14, 0xCu);
  }
  [*(id *)(a1 + 32) doFullSyncOfZone:*(void *)(a1 + 40) andFill:*(void *)(a1 + 48) completion:*(void *)(a1 + 56)];
LABEL_12:
}

void sub_100098B98(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  BOOL v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
    *(_DWORD *)id buf = 138543362;
    __int16 v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] did download record batch (full-sync)", buf, 0xCu);
  }
  unsigned __int8 v9 = objc_alloc_init(PDPassCloudStoreContainerContent);
  [*(id *)(a1 + 32) moveItemsFromResponse:v5 duringDeltaSync:0 orError:0 toContents:v9];
  [*(id *)(a1 + 32) moveItemsFromBatchContents:v9 toFinalContents:*(void *)(a1 + 40)];
  BOOL v10 = [*(id *)(a1 + 32) localStore];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_100098D40;
  void v12[3] = &unk_10072E570;
  id v13 = v6;
  id v11 = v6;
  [v10 saveRemoteDataFromContainer:v9 completion:v12];
}

uint64_t sub_100098D40(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100098D50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  [*(id *)(a1 + 32) moveItemsFromResponse:a2 duringDeltaSync:0 orError:a3 toContents:*(void *)(a1 + 40)];
  id v5 = PKLogFacilityTypeGetObject();
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (a3)
  {
    if (v6)
    {
      BOOL v7 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
      int v11 = 138543362;
      BOOL v12 = v7;
      id v8 = "[PDPassCloudStore(%{public}@)] error downloading records (full-sync)";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v11, 0xCu);
    }
  }
  else if (v6)
  {
    BOOL v7 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
    int v11 = 138543362;
    BOOL v12 = v7;
    id v8 = "[PDPassCloudStore(%{public}@)] did download all records (full-sync)";
    goto LABEL_6;
  }

  return (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), v9);
}

void sub_100099328(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v6 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
    *(_DWORD *)id buf = 138543362;
    BOOL v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] did upload local data after download (full-sync)", buf, 0xCu);
  }
  BOOL v7 = *(void **)(a1 + 32);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_10009946C;
  v9[3] = &unk_10072E198;
  void v9[4] = v7;
  id v10 = v4;
  id v8 = v4;
  [v7 onWorkQueue:v9];
}

id sub_10009946C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) localStore];
  [v2 didFinishSync:*(void *)(a1 + 40)];

  uint64_t v3 = *(void **)(a1 + 32);
  return _[v3 retryExecutingAnyDroppedDownload];
}

void sub_1000994BC(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  BOOL v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v7 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
    id v8 = +[NSNumber numberWithBool:a2];
    *(_DWORD *)id buf = 138543874;
    int v14 = v7;
    __int16 v15 = 2114;
    id v16 = v8;
    __int16 v17 = 2114;
    id v18 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] did process pending changes:%{public}@ after download (delta-sync) %{public}@", buf, 0x20u);
  }
  uint64_t v9 = *(void **)(a1 + 32);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_10009963C;
  void v11[3] = &unk_10072E198;
  void v11[4] = v9;
  id v12 = v5;
  id v10 = v5;
  [v9 onWorkQueue:v11];
}

id sub_10009963C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) localStore];
  [v2 didFinishSync:*(void *)(a1 + 40)];

  uint64_t v3 = *(void **)(a1 + 32);
  return _[v3 retryExecutingAnyDroppedDownload];
}

void sub_100099934(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v6 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
    *(_DWORD *)id buf = 138543362;
    id v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] did upload local data after download (full-sync)", buf, 0xCu);
  }
  BOOL v7 = *(void **)(a1 + 32);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100099A78;
  v9[3] = &unk_10072E198;
  void v9[4] = v7;
  id v10 = v4;
  id v8 = v4;
  [v7 onWorkQueue:v9];
}

id sub_100099A78(uint64_t a1)
{
  [*(id *)(a1 + 32) advanceToNextState:15 withError:*(void *)(a1 + 40)];
  id v2 = [*(id *)(a1 + 32) localStore];
  [v2 didFinishSync:*(void *)(a1 + 40)];

  uint64_t v3 = *(void **)(a1 + 32);
  return _[v3 retryExecutingAnyDroppedDownload];
}

void sub_100099AD8(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  BOOL v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v7 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
    id v8 = +[NSNumber numberWithBool:a2];
    *(_DWORD *)id buf = 138543874;
    int v14 = v7;
    __int16 v15 = 2114;
    id v16 = v8;
    __int16 v17 = 2114;
    id v18 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] did process pending changes: %{public}@ after download (delta-sync) %{public}@", buf, 0x20u);
  }
  uint64_t v9 = *(void **)(a1 + 32);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_100099C58;
  void v11[3] = &unk_10072E198;
  void v11[4] = v9;
  id v12 = v5;
  id v10 = v5;
  [v9 onWorkQueue:v11];
}

id sub_100099C58(uint64_t a1)
{
  [*(id *)(a1 + 32) advanceToNextState:15 withError:*(void *)(a1 + 40)];
  id v2 = [*(id *)(a1 + 32) localStore];
  [v2 didFinishSync:*(void *)(a1 + 40)];

  uint64_t v3 = *(void **)(a1 + 32);
  return _[v3 retryExecutingAnyDroppedDownload];
}

void sub_10009A470(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int8 *)(v2 + 203);
  *(unsigned char *)(v2 + 203) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  if (v3)
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
      int v6 = 138543362;
      BOOL v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] will retry a dropped download", (uint8_t *)&v6, 0xCu);
    }
    [*(id *)(a1 + 32) synchronizeWithReason:3];
  }
}

void sub_10009A91C(id *a1)
{
  uint64_t v2 = (id *)a1[4];
  if (*((unsigned char *)v2 + 200))
  {
    int v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      id v4 = [v2[23] logDescription];
      *(_DWORD *)id buf = 138543362;
      id v19 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] won't upload passes because container is readonly", buf, 0xCu);
    }
    id v5 = a1[6];
    if (v5)
    {
      uint64_t v6 = 206;
LABEL_6:
      BOOL v7 = +[NSError errorWithDomain:@"PDPassContainerErrorDomain" code:v6 userInfo:0];
      (*((void (**)(id, void, void, void *))v5 + 2))(v5, 0, 0, v7);
LABEL_10:
    }
  }
  else if ([a1[5] count])
  {
    if ([a1[4] ensureSyncPreconditionsAreMet])
    {
      BOOL v7 = objc_msgSend(a1[5], "pk_arrayByApplyingBlock:", &stru_100732D98);
      id v8 = a1[4];
      uint64_t v9 = +[NSSet setWithArray:v7];
      uint64_t v10 = PKCloudStoreOperationGroupUserActionExplicit;
      uint64_t v11 = PKCloudStoreOperationGroupSuffixCopyRecords;
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_10009ACA8;
      v16[3] = &unk_100732DC0;
      id v17 = a1[6];
      [v8 updateCloudStoreWithLocalItemsWithConfigurations:v9 groupName:v10 groupNameSuffix:v11 qualityOfService:17 completion:v16];

      goto LABEL_10;
    }
    id v13 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = [*((id *)a1[4] + 23) logDescription];
      *(_DWORD *)id buf = 138543362;
      id v19 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] not ready for passes update (precondition)", buf, 0xCu);
    }
    id v5 = a1[6];
    if (v5)
    {
      uint64_t v6 = 205;
      goto LABEL_6;
    }
  }
  else
  {
    id v12 = a1[6];
    if (v12)
    {
      id v15 = +[NSError errorWithDomain:@"PDPassContainerErrorDomain" code:201 userInfo:0];
      (*((void (**)(id, void, void))v12 + 2))(v12, 0, 0);
    }
  }
}

PKCloudStoreUploadItemConfiguration *__cdecl sub_10009AC50(id a1, PKPass *a2)
{
  uint64_t v2 = a2;
  id v3 = [objc_alloc((Class)PKCloudStoreUploadItemConfiguration) initWithItem:v2];

  return (PKCloudStoreUploadItemConfiguration *)v3;
}

uint64_t sub_10009ACA8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_10009AD84(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 200))
  {
    BOOL v7 = [*(id *)(a1 + 32) containerManager];
    id v6 = [v7 databaseForScope:2];

    if (!v6)
    {
      uint64_t v14 = *(void *)(a1 + 48);
      if (v14)
      {
        id v15 = +[NSError errorWithDomain:@"PDPassContainerErrorDomain" code:204 userInfo:0];
        (*(void (**)(uint64_t, void, void *))(v14 + 16))(v14, 0, v15);
      }
      goto LABEL_20;
    }
    __int16 v21 = _NSConcreteStackBlock;
    uint64_t v22 = 3221225472;
    long long v23 = sub_10009B148;
    long long v24 = &unk_100732DE8;
    id v8 = *(void **)(a1 + 40);
    uint64_t v25 = *(void *)(a1 + 32);
    id v6 = v6;
    id v26 = v6;
    uint64_t v9 = objc_msgSend(v8, "pk_arrayByApplyingBlock:", &v21);
    uint64_t v10 = objc_msgSend(v9, "pk_objectsPassingTest:", &stru_100732E28, v21, v22, v23, v24, v25);

    if ([v10 count])
    {
      uint64_t v11 = [v6 identifier];
      id v27 = v11;
      id v12 = +[NSSet setWithArray:v10];
      id v28 = v12;
      id v13 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];

      if ([*(id *)(a1 + 32) ensureSyncPreconditionsAreMet])
      {
        [*(id *)(a1 + 32) performDeletes:v13 completion:*(void *)(a1 + 48)];
      }
      else
      {
        id v17 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          id v18 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
          *(_DWORD *)id buf = 138543362;
          CFStringRef v30 = v18;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] not ready for pass removal (preconditon)", buf, 0xCu);
        }
        uint64_t v19 = *(void *)(a1 + 48);
        if (v19)
        {
          id v20 = +[NSError errorWithDomain:@"PDPassContainerErrorDomain" code:205 userInfo:0];
          (*(void (**)(uint64_t, void, void *))(v19 + 16))(v19, 0, v20);
        }
      }
    }
    else
    {
      uint64_t v16 = *(void *)(a1 + 48);
      if (!v16)
      {
LABEL_19:

        goto LABEL_20;
      }
      id v13 = +[NSError errorWithDomain:@"PDPassContainerErrorDomain" code:202 userInfo:0];
      (*(void (**)(uint64_t, void, void *))(v16 + 16))(v16, 0, v13);
    }

    goto LABEL_19;
  }
  id v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [*(id *)(v2 + 184) logDescription];
    *(_DWORD *)id buf = 138543362;
    CFStringRef v30 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] won't delete passes because container is readonly", buf, 0xCu);
  }
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5)
  {
    id v6 = +[NSError errorWithDomain:@"PDPassContainerErrorDomain" code:206 userInfo:0];
    (*(void (**)(uint64_t, void, id))(v5 + 16))(v5, 0, v6);
LABEL_20:
  }
}

id sub_10009B148(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = [*(id *)(a1 + 32) cloudPassIDForLocalUniqueID:a2 inDatabase:*(void *)(a1 + 40)];
  id v3 = v2;
  if (v2)
  {
    id v4 = v2;
  }
  else
  {
    id v4 = +[NSNull null];
  }
  uint64_t v5 = v4;

  return v5;
}

BOOL sub_10009B1B4(id a1, id a2, unint64_t a3, BOOL *a4)
{
  id v4 = a2;
  id v5 = +[NSNull null];

  return v5 != v4;
}

void sub_10009B518(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  id v7 = a5;
  id v8 = a3;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_10009B618;
  void v12[3] = &unk_10072F3A0;
  id v9 = objc_alloc_init((Class)NSMutableArray);
  id v13 = v9;
  [v8 enumerateKeysAndObjectsUsingBlock:v12];

  id v10 = [v9 count];
  if (v7 && !v10)
  {

    id v9 = 0;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11) {
    (*(void (**)(uint64_t, id, id))(v11 + 16))(v11, v9, v7);
  }
}

void sub_10009B618(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v12;
    do
    {
      id v8 = 0;
      do
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = [*(id *)(*((void *)&v11 + 1) + 8 * (void)v8) recordName];
        id v10 = +[PKPass uniqueIDFromRecordName:v9];

        if (v10) {
          [*(id *)(a1 + 32) addObject:v10];
        }

        id v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v6);
  }
}

void sub_10009B814(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 200))
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      id v4 = [*(id *)(v2 + 184) logDescription];
      *(_DWORD *)id buf = 138543362;
      id v20 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] won't update cloud catalog because container is readonly", buf, 0xCu);
    }
    uint64_t v5 = *(void *)(a1 + 48);
    if (v5)
    {
      id v6 = +[NSError errorWithDomain:@"PDPassContainerErrorDomain" code:206 userInfo:0];
      (*(void (**)(uint64_t, void, id))(v5 + 16))(v5, 0, v6);
      goto LABEL_18;
    }
  }
  else
  {
    if (*(void *)(a1 + 40))
    {
      id v6 = [objc_alloc((Class)PKCloudStoreUploadItemConfiguration) initWithItem:*(void *)(a1 + 40)];
      if ([*(id *)(a1 + 32) ensureSyncPreconditionsAreMet])
      {
        uint64_t v7 = *(void **)(a1 + 32);
        id v8 = +[NSSet setWithObject:v6];
        uint64_t v9 = PKCloudStoreOperationGroupUserActionExplicit;
        uint64_t v10 = PKCloudStoreOperationGroupSuffixCatalogUpdated;
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472;
        id v17[2] = sub_10009BB64;
        v17[3] = &unk_100732DC0;
        id v18 = *(id *)(a1 + 48);
        [v7 updateCloudStoreWithLocalItemsWithConfigurations:v8 groupName:v9 groupNameSuffix:v10 qualityOfService:17 completion:v17];

        long long v11 = v18;
      }
      else
      {
        long long v13 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          long long v14 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
          *(_DWORD *)id buf = 138543362;
          id v20 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] not ready for cataog update (preconditon)", buf, 0xCu);
        }
        uint64_t v15 = *(void *)(a1 + 48);
        if (!v15) {
          goto LABEL_18;
        }
        long long v11 = +[NSError errorWithDomain:@"PDPassContainerErrorDomain" code:205 userInfo:0];
        (*(void (**)(uint64_t, void, void *))(v15 + 16))(v15, 0, v11);
      }

LABEL_18:
      return;
    }
    uint64_t v12 = *(void *)(a1 + 48);
    if (v12)
    {
      id v16 = +[NSError errorWithDomain:@"PDPassContainerErrorDomain" code:203 userInfo:0];
      (*(void (**)(uint64_t, void))(v12 + 16))(v12, 0);
    }
  }
}

void sub_10009BB64(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    id v6 = a4;
    id v7 = [a2 firstObject];
    (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v7, v6);
  }
}

void sub_10009BC64(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 208);
  *(void *)(v2 + 20_Block_object_dispose(&STACK[0x290], 8) = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  id v4 = [*(id *)(*(void *)(a1 + 32) + 184) stringPrefixedWithContainerName:@"PDPassSyncCloudStoreContainerLastDownloadDateKey"];
  PKSharedCacheRemoveObjectForKey();
}

void sub_10009BF94(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(void **)(a1 + 32);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_10009C058;
  v10[3] = &unk_10072E238;
  void v10[4] = v7;
  id v11 = v5;
  id v12 = v6;
  id v8 = v6;
  id v9 = v5;
  [v7 onWorkQueue:v10];
}

void sub_10009C058(uint64_t a1)
{
  if (([*(id *)(a1 + 32) accountChangedNotificationReceived] & 1) == 0)
  {
    id v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
      int v25 = 138543362;
      id v26 = v9;
      uint64_t v10 = "[PDPassCloudStore(%{public}@)] Old CKAccountChangedNotification handler called";
LABEL_39:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v25, 0xCu);
    }
LABEL_44:

    return;
  }
  [*(id *)(a1 + 32) setAccountChangedNotificationReceived:0];
  id v2 = [*(id *)(a1 + 32) nextExpectedState];
  if (v2 != (id)1 && v2 != (id)15)
  {
    id v11 = PKLogFacilityTypeGetObject();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_44;
    }
    id v9 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
    int v25 = 138543362;
    id v26 = v9;
    uint64_t v10 = "[PDPassCloudStore(%{public}@)] CKAccountChangedNotification received during state change";
    goto LABEL_39;
  }
  id v4 = v2;
  id v5 = *(void **)(a1 + 40);
  if (v5)
  {
    if ([v5 accountStatus] == (id)1)
    {
      unsigned int v6 = [*(id *)(a1 + 40) hasValidCredentials];
      int v7 = v6 ^ 1;
      if (v4 == (id)1 && v6 && (sub_1000969E4() & 1) != 0)
      {
        int v8 = 1;
LABEL_24:
        unsigned __int8 v15 = [*(id *)(a1 + 40) deviceToDeviceEncryptionAvailability];
        if (v15) {
          unint64_t v16 = ((unint64_t)[*(id *)(a1 + 40) deviceToDeviceEncryptionAvailability] >> 1) & 1;
        }
        else {
          LODWORD(v16) = 0;
        }
        unsigned int v17 = [*(id *)(*(void *)(a1 + 32) + 184) isEndToEndEncrypted];
        uint64_t v18 = *(void *)(a1 + 32);
        BOOL v19 = *(unsigned char *)(v18 + 200) != 0;
        if (v15) {
          BOOL v19 = *(unsigned char *)(v18 + 200) == 0;
        }
        BOOL v20 = *(unsigned char *)(v18 + 200) == 0;
        if (v16) {
          BOOL v20 = *(unsigned char *)(v18 + 200) != 0;
        }
        if (!v17) {
          BOOL v20 = v19;
        }
        if (v8)
        {
          id v11 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v21 = [*(id *)(v18 + 184) logDescription];
            int v25 = 138543362;
            id v26 = v21;
            uint64_t v22 = "[PDPassCloudStore(%{public}@)] account availabilty changed";
LABEL_42:
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&v25, 0xCu);

            goto LABEL_43;
          }
          goto LABEL_43;
        }
        char v23 = v7 | !v20;
        id v11 = PKLogFacilityTypeGetObject();
        BOOL v24 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
        if ((v23 & 1) == 0)
        {
          if (v24)
          {
            __int16 v21 = [*(id *)(v18 + 184) logDescription];
            int v25 = 138543362;
            id v26 = v21;
            uint64_t v22 = "[PDPassCloudStore(%{public}@)] secure sync availabilty changed";
            goto LABEL_42;
          }
LABEL_43:

          id v11 = [*(id *)(a1 + 32) delegate];
          [v11 cloudStoreContainer:*(void *)(a1 + 32) reinitializeContainerAndInvalidateFirst:1];
          goto LABEL_44;
        }
        if (v24)
        {
          id v9 = [*(id *)(v18 + 184) logDescription];
          int v25 = 138543362;
          id v26 = v9;
          uint64_t v10 = "[PDPassCloudStore(%{public}@)] neither account nor secure sync availabilty did change";
          goto LABEL_39;
        }
        goto LABEL_44;
      }
    }
    else
    {
      int v7 = 1;
    }
    if (v4 == (id)15) {
      int v8 = v7;
    }
    else {
      int v8 = 0;
    }
    goto LABEL_24;
  }
  long long v13 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    long long v14 = [*(id *)(*(void *)(a1 + 32) + 184) logDescription];
    int v25 = 138543362;
    id v26 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "[PDPassCloudStore(%{public}@)] CKAccountState is not available", (uint8_t *)&v25, 0xCu);
  }
  [*(id *)(a1 + 32) advanceToNextState:3 withError:*(void *)(a1 + 48)];
}

id sub_10009C4F0(id a1, PKCloudStoreUploadItemConfiguration *a2)
{
  id v2 = a2;
  id v3 = [(PKCloudStoreUploadItemConfiguration *)v2 item];
  if ([v3 itemType] == (id)3)
  {
    id v4 = +[PKCatalog catalogWithLocalCatalog:0 ubiquitousCatalog:v3];
    id v5 = (PKCloudStoreUploadItemConfiguration *)[objc_alloc((Class)PKCloudStoreUploadItemConfiguration) initWithItem:v4];
  }
  else
  {
    id v5 = v2;
  }

  return v5;
}

void sub_10009CEA4(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_10009CF34;
  v2[3] = &unk_100732EB8;
  void v2[4] = v1;
  id v3 = *(id *)(a1 + 40);
  objc_msgSend(v1, "_queue_cloudStoreAccountInformationWithCompletion:", v2);
}

void sub_10009CF34(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned __int8 v4 = [v3 deviceToDeviceEncryptionAvailability];
  unsigned __int8 v5 = [v3 deviceToDeviceEncryptionAvailability];

  id v6 = objc_alloc((Class)PKCloudStoreContainerDiagnostics);
  id v7 = [*(id *)(a1 + 32) isSetup];
  int v8 = [*(id *)(a1 + 32) stateDescription];
  id v9 = [*(id *)(a1 + 32) isWalletSyncEnabled];
  uint64_t v10 = [*(id *)(a1 + 32) syncTokenDescription];
  id v11 = [*(id *)(a1 + 32) lastSyncDateDescription];
  unsigned __int8 v12 = [*(id *)(a1 + 32) isDeltaSyncPossible];
  BOOL v13 = (v5 & 2) != 0 && *(unsigned char *)(*(void *)(a1 + 32) + 200) == 0;
  BYTE3(v14) = v13;
  LOBYTE(v14) = v12;
  BYTE2(v14) = (v5 & 2) != 0;
  BYTE1(v14) = v4 & 1;
  id v15 = objc_msgSend(v6, "initWithIsEnabled:isSetup:status:isSyncEnabled:syncToken:lastSyncDate:didFinishInitialSync:isAccountManateeCapable:isDeviceManateeCapable:isManateeEnabled:", 1, v7, v8, v9, v10, v11, v14);

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10009D0FC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) containerManager];
  id v3 = [v2 databaseForScope:2];

  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  unsigned __int8 v4 = objc_msgSend(*(id *)(a1 + 32), "containerManager", 0);
  unsigned __int8 v5 = [v4 allPossibleZoneIDsInContainerDatabase:v3];

  id v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v14;
    do
    {
      id v9 = 0;
      do
      {
        if (*(void *)v14 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = *(void *)(*((void *)&v13 + 1) + 8 * (void)v9);
        id v11 = [*(id *)(a1 + 32) containerManager];
        unsigned __int8 v12 = [v3 identifier];
        [v11 containerDatabaseIdentifier:v12 didUpdateChangeToken:0 fetchTimestamp:0 forZoneID:v10];

        id v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      id v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v7);
  }
}

void sub_10009D2E8(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 208);
  *(void *)(v2 + 20_Block_object_dispose(&STACK[0x290], 8) = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  unsigned __int8 v4 = [*(id *)(*(void *)(a1 + 32) + 184) stringPrefixedWithContainerName:@"PDPassSyncCloudStoreContainerLastDownloadDateKey"];
  PKSharedCacheRemoveObjectForKey();

  id v5 = [*(id *)(a1 + 32) localStore];
  [v5 resetMigration];
}

void sub_10009D408(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) localStore];
  [v1 clearChangeHistory];
}

id sub_10009D4B8(uint64_t a1)
{
  return [*(id *)(a1 + 32) processPendingChanges:0];
}

void sub_10009D530(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) containerManager];
  id v6 = [v2 databaseForScope:2];

  id v3 = [*(id *)(a1 + 32) containerManager];
  unsigned __int8 v4 = [v3 allPossibleZoneIDsInContainerDatabase:v6];

  id v5 = objc_msgSend(v4, "pk_setByApplyingBlock:", &stru_100732EF8);
  [*(id *)(a1 + 32) resetContainerWithZoneNames:v5 completion:&stru_100732F18];
}

NSString *__cdecl sub_10009D5F0(id a1, CKRecordZoneID *a2)
{
  return [(CKRecordZoneID *)a2 zoneName];
}

void sub_10009D8C0(uint64_t a1)
{
  if ([*(id *)(a1 + 32) isSetup])
  {
    id v2 = objc_alloc_init((Class)NSMutableDictionary);
    id v3 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_10009DA64;
    v15[3] = &unk_100731CB8;
    void v15[4] = *(void *)(a1 + 32);
    id v4 = v2;
    id v16 = v4;
    [v3 addOperation:v15];
    id v5 = +[NSNull null];
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    id v11[2] = sub_10009DBF0;
    void v11[3] = &unk_100732FA8;
    uint64_t v6 = *(void *)(a1 + 32);
    id v7 = *(void **)(a1 + 40);
    id v12 = v4;
    uint64_t v13 = v6;
    id v14 = v7;
    id v8 = v4;
    id v9 = [v3 evaluateWithInput:v5 completion:v11];
  }
  else
  {
    uint64_t v10 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v10();
  }
}

void sub_10009DA64(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_10009DB40;
  void v12[3] = &unk_100732F80;
  id v8 = *(void **)(a1 + 32);
  id v9 = *(id *)(a1 + 40);
  id v14 = v6;
  id v15 = v7;
  id v13 = v9;
  id v10 = v6;
  id v11 = v7;
  [v8 allItemsOfItemType:2 storeLocally:0 completion:v12];
}

uint64_t sub_10009DB40(uint64_t a1, void *a2, uint64_t a3)
{
  if (!a3)
  {
    id v4 = [a2 allRecordNames];
    id v5 = [v4 allObjects];
    id v6 = objc_msgSend(v5, "pk_arrayByApplyingBlock:", &stru_100732F58);
    [*(id *)(a1 + 32) setObject:v6 forKeyedSubscript:PKCloudPassRecordType];
  }
  id v7 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v7();
}

NSString *__cdecl sub_10009DBE0(id a1, NSString *a2)
{
  return (NSString *)+[PKPass uniqueIDFromRecordName:a2];
}

void sub_10009DBF0(uint64_t a1)
{
  id v2 = objc_alloc((Class)PKCloudStoreContainerDiagnosticSnapshot);
  id v3 = [*(id *)(a1 + 32) copy];
  id v4 = [*(id *)(a1 + 40) localStore];
  id v5 = [v4 localRecordIDs];
  id v6 = [v2 initWithRecordIDs:v3 localRecordIDs:v5];

  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_10009E0A8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = a3 + 1;
  id v5 = a2;
  [v5 setPaymentNumber:v4];
  [v5 setPaymentCount:*(void *)(a1 + 32)];
}

void sub_10009E514(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_10009ECF4(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = a3 + 1;
  id v5 = a2;
  [v5 setPaymentNumber:v4];
  [v5 setPaymentCount:*(void *)(a1 + 32)];
}

void sub_10009F084(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  id v8 = objc_alloc_init((Class)PKCreditInstallmentPlan);
  [*(id *)(a1 + 56) applyPropertySetters:*(void *)(a1 + 32) toObject:v8 withProperties:v7 values:a4];

  id v9 = [*(id *)(a1 + 40) database];
  id v10 = +[NSNumber numberWithLongLong:a2];
  BOOL v20 = +[CreditInstallmentPlanLineItem lineItemForInstallmentPlanPID:v10 inDatabase:v9];
  objc_msgSend(v8, "setLineItems:");
  id v11 = +[CreditInstallmentPlanPayment paymentsForInstallmentPlanPID:v10 inDatabase:v9];
  id v12 = +[NSSortDescriptor sortDescriptorWithKey:@"dueDate" ascending:1];
  __int16 v21 = v12;
  id v13 = +[NSArray arrayWithObjects:&v21 count:1];
  BOOL v19 = v11;
  id v14 = [v11 sortedArrayUsingDescriptors:v13];

  [v8 setPayments:v14];
  id v15 = +[InstallmentPlanMerchant merchantForInstallmentPlanPID:v10 inDatabase:v9];
  [v8 setMerchant:v15];
  id v16 = +[CreditInstallmentPlanProduct productForInstallmentPlanPID:v10 inDatabase:v9];
  [v8 setProduct:v16];
  unsigned int v17 = +[InstallmentPlanSummary summaryForInstallmentPlanPID:v10 inDatabase:v9];
  [v8 setSummary:v17];
  uint64_t v18 = +[PaymentTransactionReward rewardsInDatabase:v9 forInstallmentPlanPID:v10];
  [v8 setRewards:v18];
  if (v8) {
    [*(id *)(a1 + 48) addObject:v8];
  }
}

void sub_10009F6EC(id a1, PKCreditInstallmentPlan *a2, id a3)
{
}

void sub_10009F6F4(id a1, PKCreditInstallmentPlan *a2, id a3)
{
  uint64_t v4 = a2;
  -[PKCreditInstallmentPlan setState:](v4, "setState:", [a3 integerValue]);
}

void sub_10009F74C(id a1, PKCreditInstallmentPlan *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKCreditInstallmentPlan *)v3 setLastUpdated:v4];
}

void sub_10009F7AC(id a1, PKCreditInstallmentPlan *a2, id a3)
{
  id v4 = a2;
  [a3 integerValue];
  PKPercentageStorageIntegerToDecimal();
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  [(PKCreditInstallmentPlan *)v4 setApr:v5];
}

void sub_10009F814(id a1, PKCreditInstallmentPlan *a2, id a3)
{
  id v4 = a2;
  -[PKCreditInstallmentPlan setDuration:](v4, "setDuration:", [a3 unsignedIntegerValue]);
}

void sub_10009F86C(id a1, PKCreditInstallmentPlan *a2, id a3)
{
}

void sub_10009F874(id a1, PKCreditInstallmentPlan *a2, id a3)
{
  id v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKCreditInstallmentPlan *)v3 setTotalAmount:v4];
}

void sub_10009F8D8(id a1, PKCreditInstallmentPlan *a2, id a3)
{
  id v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKCreditInstallmentPlan *)v3 setTotalProductAmount:v4];
}

void sub_10009F93C(id a1, PKCreditInstallmentPlan *a2, id a3)
{
  id v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKCreditInstallmentPlan *)v3 setTotalInterestAmount:v4];
}

void sub_10009F9A0(id a1, PKCreditInstallmentPlan *a2, id a3)
{
  id v4 = a2;
  -[PKCreditInstallmentPlan setPeriodType:](v4, "setPeriodType:", [a3 integerValue]);
}

void sub_10009F9F8(id a1, PKCreditInstallmentPlan *a2, id a3)
{
  id v4 = a2;
  -[PKCreditInstallmentPlan setUserViewedIntroduction:](v4, "setUserViewedIntroduction:", [a3 BOOLValue]);
}

void sub_10009FA50(id a1, PKCreditInstallmentPlan *a2, id a3)
{
}

void sub_10009FA58(id a1, PKCreditInstallmentPlan *a2, id a3)
{
}

void sub_1000A0248(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v5 = [v3 pushToken];
  unsigned __int8 v6 = [v5 isEqualToString:*(void *)(a1 + 32)];

  if ((v6 & 1) == 0)
  {
    id v7 = [*(id *)(*(void *)(a1 + 40) + 16) passesForNotificationService:v3];
    [v3 setPushToken:*(void *)(a1 + 32)];
    [*(id *)(*(void *)(a1 + 40) + 16) updateNotificationService:v3];
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_1000A0360;
    v8[3] = &unk_1007331D8;
    void v8[4] = *(void *)(a1 + 40);
    id v9 = v3;
    [v7 enumerateObjectsUsingBlock:v8];
  }
}

void sub_1000A0360(uint64_t a1, void *a2)
{
  id v4 = a2;
  [*(id *)(a1 + 32) _updateRegistrationStatusForPass:v4 notificationService:*(void *)(a1 + 40) requestedRegistrationStatus:1 refreshRegistrationIfPossible:1];
}

void sub_1000A0964(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (objc_msgSend(*(id *)(*(void *)(a1 + 32) + 16), "notificationServiceIsEnabledForAnyPasses:"))
  {
    id v3 = *(void **)(a1 + 40);
    id v4 = [v5 pushTopic];
    [v3 addObject:v4];
  }
}

id sub_1000A0FE4(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 64))
  {
    uint64_t v4 = [*(id *)(*(void *)(a1 + 32) + 88) objectForKey:*(void *)(a1 + 40)];
    id v5 = (void *)v4;
    if (!a2 || v4)
    {
      id v11 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *(void *)(a1 + 56);
        int v14 = 138412546;
        uint64_t v15 = v12;
        __int16 v16 = 2112;
        unsigned int v17 = v5;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to cancel auto top up for pass: %@, error: %@", (uint8_t *)&v14, 0x16u);
      }

      (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
    }
    else
    {
      unsigned __int8 v6 = [*(id *)(a1 + 48) identifiers];
      id v7 = [v6 anyObject];

      id v8 = [*(id *)(*(void *)(a1 + 32) + 16) balanceReminderThresholdForBalanceIdentifier:v7 withPassUniqueIdentifier:*(void *)(a1 + 56)];
      if (v8)
      {
        id v9 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = *(void *)(a1 + 56);
          int v14 = 138412546;
          uint64_t v15 = v10;
          __int16 v16 = 2112;
          unsigned int v17 = v7;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Enable low balance reminder because auto top up is cancelled for pass: %@, balanceIdentifiers: %@", (uint8_t *)&v14, 0x16u);
        }

        [v8 setEnabled:1];
        [*(id *)(*(void *)(a1 + 32) + 16) setBalanceReminder:v8 forBalanceIdentifier:v7 withPassUniqueIdentifier:*(void *)(a1 + 56)];
      }
      (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
    }
  }
  [*(id *)(*(void *)(a1 + 32) + 80) removeObjectForKey:*(void *)(a1 + 40)];
  return [*(id *)(*(void *)(a1 + 32) + 88) removeObjectForKey:*(void *)(a1 + 40)];
}

void sub_1000A1858(id a1, NSError *a2, unint64_t a3, BOOL *a4)
{
  uint64_t v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = PDErrorDescription();
    int v6 = 138412290;
    id v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&v6, 0xCu);
  }
}

BOOL sub_1000A1E68(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  BOOL v4 = (objc_opt_isKindOfClass() & 1) != 0
    && [v3 pertainsToNotificationService:*(void *)(a1 + 32) andDPANIdentifier:*(void *)(a1 + 40)]&& objc_msgSend(v3, "requestedStatus") == (id)1;

  return v4;
}

id sub_1000A21CC(void *a1, int a2)
{
  if (a1[6])
  {
    BOOL v4 = [*(id *)(a1[4] + 80) objectForKey:a1[5]];
    uint64_t v5 = [*(id *)(a1[4] + 88) objectForKey:a1[5]];
    int v6 = (void *)v5;
    if (a2 && (v4 ? (BOOL v7 = v5 == 0) : (BOOL v7 = 0), v7))
    {
      (*(void (**)(void))(a1[6] + 16))();
    }
    else
    {
      if (!v5)
      {
        NSErrorUserInfoKey v10 = NSDebugDescriptionErrorKey;
        CFStringRef v11 = @"PDNotificationServiceTransactionAuthenticationTask failed.";
        id v8 = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
        int v6 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-1 userInfo:v8];
      }
      (*(void (**)(void))(a1[6] + 16))();
    }
  }
  [*(id *)(a1[4] + 80) removeObjectForKey:a1[5]];
  return [*(id *)(a1[4] + 88) removeObjectForKey:a1[5]];
}

void sub_1000A2D5C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1000A2D94(uint64_t a1, void *a2)
{
  id v3 = a2;
  BOOL v4 = [*(id *)(*(void *)(a1 + 32) + 48) secureElementIdentifiers];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000A2E64;
  v8[3] = &unk_1007332E0;
  id v9 = v3;
  id v5 = *(id *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  id v10 = v5;
  uint64_t v11 = v6;
  id v7 = v3;
  [v4 enumerateObjectsUsingBlock:v8];
}

void sub_1000A2E64(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  id v5 = [v3 secureElementIdentifier];
  unsigned int v6 = [v5 isEqualToString:v4];

  if (v6)
  {
    id v7 = *(void **)(a1 + 40);
    id v8 = [*(id *)(a1 + 32) dpanIdentifier];
    [v7 addObject:v8];

    if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)
      && ([*(id *)(a1 + 32) isAuxiliary] & 1) == 0)
    {
      id v9 = *(void **)(a1 + 32);
      id v10 = (id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
      objc_storeStrong(v10, v9);
    }
  }
}

void sub_1000A2F2C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)id buf = 138412290;
    id v21 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Signed Registration Data: %@", buf, 0xCu);
  }

  if (v5 && ([v6 certificates], id v8 = objc_claimAutoreleasedReturnValue(), v8, v8))
  {
    id v9 = PDDefaultQueue();
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000A312C;
    block[3] = &unk_10072FF98;
    id v13 = v5;
    id v14 = *(id *)(a1 + 32);
    id v15 = *(id *)(a1 + 40);
    id v16 = *(id *)(a1 + 48);
    id v17 = v6;
    id v10 = *(id *)(a1 + 56);
    uint64_t v11 = *(void *)(a1 + 64);
    id v18 = v10;
    uint64_t v19 = v11;
    dispatch_async(v9, block);

    id v7 = v13;
  }
  else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to Generate Signed Registration Data!", buf, 2u);
  }
}

void sub_1000A312C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) base64EncodedStringWithOptions:0];
  id v3 = [*(id *)(a1 + 40) base64EncodedStringWithOptions:0];
  uint64_t v4 = *(void *)(a1 + 56);
  id v5 = *(void **)(a1 + 64);
  if (*(void *)(a1 + 48))
  {
    id v6 = [v5 certificates];
    id v7 = [v6 dictionary];
    id v8 = [*(id *)(a1 + 64) certificateVersion];
    id v9 = [*(id *)(a1 + 48) dpanIdentifier];
    id v10 = +[PDNotificationServiceSpecificRegistrationTask registerTaskWithNotificationService:v4 registrationData:v3 signature:v2 certificates:v7 certificateVersion:v8 dpanIdentifier:v9 completionTask:*(void *)(a1 + 72)];
  }
  else
  {
    id v6 = [v5 certificates];
    id v7 = [v6 dictionary];
    +[PDNotificationServiceRegistrationTask registerTaskWithNotificationService:registrationData:signature:certificates:certificateVersion:completionTask:](PDNotificationServiceRegistrationTask, "registerTaskWithNotificationService:registrationData:signature:certificates:certificateVersion:completionTask:", v4, v3, v2, v7, [*(id *)(a1 + 64) certificateVersion], *(void *)(a1 + 72));
    id v10 = (id)objc_claimAutoreleasedReturnValue();
  }

  [*(id *)(*(void *)(a1 + 80) + 56) performTask:v10];
}

void sub_1000A32A0(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (v5)
  {
    id v8 = [v6 certificates];
    if (v8)
    {

LABEL_9:
      (*(void (**)(void))(a1[6] + 16))();
      goto LABEL_10;
    }
    if ((PKIgnoreSignatures() & 1) == 0) {
      goto LABEL_9;
    }
  }
  else if (!PKIgnoreSignatures())
  {
    goto LABEL_9;
  }
  id v9 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Could not sign data with SE lookup via application ID, attempting again with default SE since *** IGNORING SIGNATURES ***", v10, 2u);
  }

  [*(id *)(a1[4] + 48) signChallenge:a1[5] signatureEntanglementMode:0 completion:a1[6]];
LABEL_10:
}

void sub_1000A3914(uint64_t a1)
{
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 56);
  id v2 = [*(id *)(a1 + 40) completionTask];
  [v1 performTask:v2];
}

void sub_1000A40FC(uint64_t a1, void *a2, char *a3)
{
  id v21 = a2;
  id v5 = [v21 PKStringForKey:@"dpanIdentifier"];
  id v6 = [v21 PKStringForKey:@"fpanIdentifier"];
  if (v5
    && ([*(id *)(*(void *)(a1 + 32) + 16) paymentApplicationWithDPANIdentifier:v5],
        (uint64_t v7 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    id v8 = (void *)v7;
    id v9 = [*(id *)(*(void *)(a1 + 32) + 16) passUniqueIdentifierWithPaymentApplication:v7];
    char v10 = 0;
    if (!v9) {
      goto LABEL_29;
    }
  }
  else
  {
    if (!v6)
    {
      id v9 = 0;
      id v8 = 0;
      goto LABEL_29;
    }
    id v9 = [*(id *)(*(void *)(a1 + 32) + 16) passUniqueIdentifierWithPrimaryAccountIdentifier:v6];
    id v8 = 0;
    char v10 = 1;
    if (!v9) {
      goto LABEL_29;
    }
  }
  uint64_t v11 = *(void *)(a1 + 64);
  if (v11)
  {
    if (v11 == 1)
    {
      unint64_t v12 = PKMaxPerPassPaymentMessageHistory;
      unsigned int v13 = [*(id *)(*(void *)(a1 + 32) + 16) settingEnabled:64 forPassWithUniqueIdentifier:v9];
    }
    else
    {
      unsigned int v13 = 0;
      unint64_t v12 = 0;
    }
  }
  else
  {
    if ((v10 & 1) == 0) {
      [v8 paymentNetworkIdentifier];
    }
    unint64_t v12 = PKMaxPaymentTransactionsForCredentialType();
    unsigned __int8 v14 = [*(id *)(*(void *)(a1 + 32) + 16) settingEnabled:8 forPassWithUniqueIdentifier:v9];
    id v15 = [*(id *)(*(void *)(a1 + 32) + 16) passWithUniqueIdentifier:v9];
    id v16 = [v15 paymentPass];

    if (v14) {
      unsigned int v13 = 1;
    }
    else {
      unsigned int v13 = [v16 shouldIgnoreTransactionUpdatesSwitch];
    }
  }
  id v17 = [*(id *)(a1 + 40) countForObject:v9];
  if (*(unsigned char *)(a1 + 72)) {
    int v18 = 1;
  }
  else {
    int v18 = v13;
  }
  if (v18 == 1 && (unint64_t)v17 <= v12)
  {
    uint64_t v19 = (char *)[*(id *)(a1 + 48) count] - 1;
    uint64_t v20 = *(void *)(a1 + 64);
    if (v20 == 1)
    {
      [*(id *)(a1 + 32) _processMessageDictionary:v21 forPassUniqueIdentifier:v9 paymentApplication:v8 performTruncation:v19 == a3];
    }
    else if (!v20)
    {
      objc_msgSend(*(id *)(a1 + 32), "_processTransactionDictionary:forPassUniqueIdentifier:paymentApplication:performTruncation:isInitialUpdate:", v21, v9, v8, v19 == a3, objc_msgSend(*(id *)(a1 + 56), "isInitialUpdatesTask"));
    }
    [*(id *)(a1 + 40) addObject:v9];
  }
LABEL_29:
}

void sub_1000A4374(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 PKStringForKey:@"dpanIdentifier"];
  id v5 = [v3 PKStringForKey:@"fpanIdentifier"];
  if (v4
    && ([*(id *)(*(void *)(a1 + 32) + 16) paymentApplicationWithDPANIdentifier:v4],
        (uint64_t v6 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    uint64_t v7 = (void *)v6;
    id v8 = [*(id *)(*(void *)(a1 + 32) + 16) passUniqueIdentifierWithPaymentApplication:v6];
  }
  else if (v5)
  {
    id v8 = [*(id *)(*(void *)(a1 + 32) + 16) passUniqueIdentifierWithPrimaryAccountIdentifier:v5];
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 0;
    id v8 = 0;
  }
  id v9 = [objc_alloc((Class)PKPaymentBalance) initWithDictionary:v3];
  if (!v8)
  {
    char v10 = PKLogFacilityTypeGetObject();
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    unint64_t v12 = [v9 identifiers];
    int v14 = 138412290;
    id v15 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "PDNotificationServiceCoordinator: Related pass could not be found for balance: %@", (uint8_t *)&v14, 0xCu);
LABEL_17:

    goto LABEL_18;
  }
  char v10 = [*(id *)(a1 + 40) objectForKey:v8];
  unint64_t v11 = PKMaxDefaultPerPassBalanceCount;
  if (!v10)
  {
    char v10 = +[NSMutableArray arrayWithCapacity:PKMaxDefaultPerPassBalanceCount];
    [*(id *)(a1 + 40) setObject:v10 forKey:v8];
  }
  if ((unint64_t)[v10 count] >= v11)
  {
    unint64_t v12 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v13 = [v9 identifiers];
      int v14 = 138412546;
      id v15 = v8;
      __int16 v16 = 2112;
      id v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PDNotificationServiceCoordinator: Too many balances provided for pass %@, skipping: %@", (uint8_t *)&v14, 0x16u);
    }
    goto LABEL_17;
  }
  if ([*(id *)(a1 + 32) _validateBalanceResult:v9]) {
    [v10 addObject:v9];
  }
LABEL_18:
}

void sub_1000A4610(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 PKStringForKey:@"dpanIdentifier"];
  id v5 = [v3 PKStringForKey:@"fpanIdentifier"];
  if (v4
    && ([*(id *)(*(void *)(a1 + 32) + 16) paymentApplicationWithDPANIdentifier:v4],
        (uint64_t v6 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    uint64_t v7 = (void *)v6;
    id v8 = [*(id *)(*(void *)(a1 + 32) + 16) passUniqueIdentifierWithPaymentApplication:v6];
    if (!v8)
    {
LABEL_13:
      id v8 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unint64_t v11 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDNotificationServiceCoordinator: Plan's related pass could not be found", v11, 2u);
      }
      goto LABEL_15;
    }
  }
  else
  {
    if (!v5)
    {
      uint64_t v7 = 0;
      goto LABEL_13;
    }
    id v8 = [*(id *)(*(void *)(a1 + 32) + 16) passUniqueIdentifierWithPrimaryAccountIdentifier:v5];
    uint64_t v7 = 0;
    if (!v8) {
      goto LABEL_13;
    }
  }
  id v9 = [*(id *)(a1 + 40) objectForKey:v8];
  if (!v9)
  {
    id v9 = objc_alloc_init((Class)NSMutableArray);
    [*(id *)(a1 + 40) setObject:v9 forKey:v8];
  }
  id v10 = [objc_alloc((Class)PKPaymentCommutePlanDetail) initWithDictionary:v3];
  if ([*(id *)(a1 + 32) _validatePlanResult:v10]) {
    [v9 addObject:v10];
  }

LABEL_15:
}

void sub_1000A47BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 PKStringForKey:@"dpanIdentifier"];
  uint64_t v5 = [v3 PKStringForKey:@"fpanIdentifier"];
  uint64_t v6 = (void *)v5;
  if (v4 && v5)
  {
    uint64_t v7 = [*(id *)(*(void *)(a1 + 32) + 16) paymentApplicationWithDPANIdentifier:v4];
    id v8 = *(void **)(*(void *)(a1 + 32) + 16);
    if (v7) {
      [v8 passUniqueIdentifierWithPaymentApplication:v7];
    }
    else {
    uint64_t v10 = [v8 passUniqueIdentifierWithPrimaryAccountIdentifier:v6];
    }

    if (v10)
    {
      unint64_t v11 = [v3 PKStringForKey:@"identifier"];
      if (v11)
      {
        id v12 = [*(id *)(a1 + 40) objectForKeyedSubscript:v10];
        if (!v12)
        {
          id v12 = objc_alloc_init((Class)NSMutableDictionary);
          [*(id *)(a1 + 40) setObject:v12 forKeyedSubscript:v10];
        }
        [v12 setObject:v3 forKeyedSubscript:v11];
      }
      else
      {
        unsigned int v13 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v14 = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "PDNotificationServiceCoordiantor: ignoring tile configuration without a tile identifier.", v14, 2u);
        }
      }
      uint64_t v4 = v10;
    }
    else
    {
      uint64_t v4 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v15 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDNotificationServiceCoordiantor: ignoring tile configuration without a matching pass.", v15, 2u);
      }
    }
  }
  else
  {
    id v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDNotificationServiceCoordiantor: ignoring tile configuration with no fpan or dpan identifier.", buf, 2u);
    }
  }
}

void sub_1000A49E0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 96);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000A4A8C;
  v8[3] = &unk_1007333D0;
  id v9 = v5;
  id v7 = v5;
  sub_1003D5D58(v6, a2, v8);
}

id sub_1000A4A8C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = [a2 metadata];
  id v7 = [v6 identifier];
  if (v7)
  {
    id v8 = [*(id *)(a1 + 32) objectForKeyedSubscript:v7];
    if (v8)
    {
      id v9 = [v5 mutableCopy];
      uint64_t v10 = [v8 PKNumberForKey:@"enabled"];
      unint64_t v11 = v10;
      if (v10)
      {
        if ([v10 BOOLValue]) {
          uint64_t v12 = 1;
        }
        else {
          uint64_t v12 = 2;
        }
      }
      else
      {
        uint64_t v12 = 0;
      }
      [v9 setEnabled:v12];
      unsigned int v13 = [v8 PKStringForKey:@"state"];
      [v9 setStateIdentifier:v13];

      id v14 = [v6 type];
      id v15 = [v8 PKDictionaryForKey:@"stateOverride"];
      if (v15) {
        id v16 = +[PKPassTileState _createForDictionary:v15 withTileType:v14];
      }
      else {
        id v16 = 0;
      }

      [v9 setStateOverride:v16];
    }
    else
    {
      id v9 = v5;
    }
  }
  else
  {
    id v9 = v5;
  }

  return v9;
}

void sub_1000A52DC(uint64_t a1, void *a2)
{
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  id v3 = a2;
  id v4 = [v3 countByEnumeratingWithState:&v15 objects:v23 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v16;
    while (2)
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v15 + 1) + 8 * i);
        id v9 = objc_msgSend(v8, "balanceIdentifier", (void)v15);
        int v10 = PKEqualObjects();

        if (v10)
        {
          unint64_t v11 = [*(id *)(a1 + 40) value];
          uint64_t v12 = [*(id *)(a1 + 40) currencyCode];
          objc_msgSend(v8, "updateBalanceAmount:currency:exponent:", v11, v12, objc_msgSend(*(id *)(a1 + 40), "exponent"));

          [v8 setReissueBannerOnUpdate:0];
          [*(id *)(*(void *)(a1 + 48) + 24) insertUserNotification:v8];
          unsigned int v13 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v14 = *(void *)(a1 + 56);
            *(_DWORD *)id buf = 138412546;
            uint64_t v20 = v8;
            __int16 v21 = 2112;
            uint64_t v22 = v14;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "PDNotificationServiceCoordiantor: lowBalance updateLowBalanceNotificationForBalance: %@ for pass %@", buf, 0x16u);
          }

          goto LABEL_13;
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v15 objects:v23 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
LABEL_13:
}

void sub_1000A55B0(uint64_t a1, void *a2)
{
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v3 = a2;
  id v4 = [v3 countByEnumeratingWithState:&v13 objects:v21 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v14;
    while (2)
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v13 + 1) + 8 * i);
        id v9 = objc_msgSend(v8, "balanceIdentifier", (void)v13);
        int v10 = PKEqualObjects();

        if (v10)
        {
          [*(id *)(*(void *)(a1 + 40) + 24) removeUserNotification:v8];
          unint64_t v11 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = *(void *)(a1 + 48);
            *(_DWORD *)id buf = 138412546;
            long long v18 = v8;
            __int16 v19 = 2112;
            uint64_t v20 = v12;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "PDNotificationServiceCoordiantor: lowBalance removeLowBalanceNotificationForBalance: %@ for pass %@", buf, 0x16u);
          }

          goto LABEL_13;
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v13 objects:v21 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
LABEL_13:
}

void sub_1000A5BBC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = PDDefaultQueue();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000A5CB4;
  v10[3] = &unk_100731EC0;
  id v11 = v5;
  id v14 = *(id *)(a1 + 40);
  id v12 = *(id *)(a1 + 32);
  id v13 = v6;
  id v8 = v6;
  id v9 = v5;
  dispatch_async(v7, v10);
}

void sub_1000A5CB4(void *a1)
{
  id v2 = (void *)a1[4];
  if (v2)
  {
    uint64_t v3 = a1[7];
    id v8 = [v2 totalMerchantTokens];
    id v4 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", (int)[v8 intValue] > 0);
    (*(void (**)(uint64_t, void *))(v3 + 16))(v3, v4);
  }
  else
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = a1[5];
      uint64_t v7 = a1[6];
      *(_DWORD *)id buf = 138412546;
      uint64_t v10 = v6;
      __int16 v11 = 2112;
      uint64_t v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error retrieving merchant token status for transaction %@. Error: %@", buf, 0x16u);
    }

    (*(void (**)(void))(a1[7] + 16))();
  }
}

id sub_1000A6108(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 40) _updatePaymentTransaction:*(void *)(a1 + 32) withPassUniqueIdentifier:*(void *)(a1 + 48) forPaymentApplication:*(void *)(a1 + 56) insertionMode:*(void *)(a1 + 64) performTruncation:*(unsigned __int8 *)(a1 + 72)];
}

void sub_1000A63BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A63DC(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0
    || ![v3 pertainsToNotificationService:*(void *)(a1 + 32)]
    || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0) && [v3 requestedStatus] == (id)2)
  {
LABEL_10:
    uint64_t v6 = 0;
    goto LABEL_11;
  }
  if (*(unsigned char *)(a1 + 56))
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0
      || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)
      || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      id v5 = [*(id *)(a1 + 40) dpanIdentifier];
      uint64_t v6 = (uint64_t)[v3 pertainsToNotificationService:v4 andDPANIdentifier:v5];

      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v6 = 1;
LABEL_11:
  uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8);
  if (*(unsigned char *)(v7 + 24)) {
    char v8 = 1;
  }
  else {
    char v8 = v6;
  }
  *(unsigned char *)(v7 + 24) = v8;

  return v6;
}

uint64_t sub_1000A6A1C(uint64_t a1)
{
  return 1;
}

void sub_1000A6F60(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v7 = objc_alloc_init((Class)PKPaymentTransactionTag);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v7 withProperties:v6 values:a4];

  [*(id *)(a1 + 40) addObject:v7];
}

void sub_1000A72B8(id a1, PKPaymentTransactionTag *a2, id a3)
{
  uint64_t v4 = a2;
  -[PKPaymentTransactionTag setType:](v4, "setType:", [a3 unsignedIntegerValue]);
}

void sub_1000A7310(id a1, PKPaymentTransactionTag *a2, id a3)
{
  id v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKPaymentTransactionTag *)v3 setRank:v4];
}

void sub_1000A7374(id a1, PKPaymentTransactionTag *a2, id a3)
{
}

void sub_1000A737C(id a1, PKPaymentTransactionTag *a2, id a3)
{
}

void sub_1000A9670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000A9688(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) accessory];
  if (!v2)
  {
    id v3 = 0;
LABEL_5:
    id v5 = [*(id *)(a1 + 32) secondaryAccessory];
    if (v5)
    {
      id v6 = +[TileAccessory insertAccessory:v5 inDatabase:*(void *)(a1 + 40)];
      if (!v6)
      {
        BOOL v4 = 0;
LABEL_10:

        goto LABEL_11;
      }
    }
    else
    {
      id v6 = 0;
    }
    id v7 = [objc_alloc(*(Class *)(a1 + 64)) initWithState:*(void *)(a1 + 32) forBaseState:*(void *)(a1 + 48) forAccessory:v3 forSecondaryAccessory:v6 inDatabase:*(void *)(a1 + 40)];
    uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
    id v9 = *(void **)(v8 + 40);
    *(void *)(v8 + 40) = v7;

    BOOL v4 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) != 0;
    goto LABEL_10;
  }
  id v3 = +[TileAccessory insertAccessory:v2 inDatabase:*(void *)(a1 + 40)];
  if (v3) {
    goto LABEL_5;
  }
  BOOL v4 = 0;
LABEL_11:

  return v4;
}

void sub_1000A9918(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  id v19 = +[NSNull null];
  [*(id *)(a1 + 32) setTitle:*(void *)a4];
  [*(id *)(a1 + 32) setBody:*(void *)(a4 + 8)];
  id v9 = *(id *)(a4 + 16);
  if (v9) {
    BOOL v10 = v9 == v19;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    __int16 v11 = -[SQLiteEntity initWithPersistentID:inDatabase:]([TileAccessory alloc], "initWithPersistentID:inDatabase:", [v9 longLongValue], *(void *)(a1 + 40));
    uint64_t v12 = *(void **)(a1 + 32);
    id v13 = [(TileAccessory *)v11 passTileAccessory];
    [v12 setAccessory:v13];
  }
  id v14 = *(id *)(a4 + 24);
  if (v14 && v14 != v19)
  {
    id v15 = v14;
    long long v16 = -[SQLiteEntity initWithPersistentID:inDatabase:]([TileAccessory alloc], "initWithPersistentID:inDatabase:", [v15 longLongValue], *(void *)(a1 + 40));
    long long v17 = *(void **)(a1 + 32);
    long long v18 = [(TileAccessory *)v16 passTileAccessory];
    [v17 setSecondaryAccessory:v18];
  }
  *a6 = 1;
}

void sub_1000AA0D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000AA0E8(uint64_t a1)
{
  id v2 = [objc_alloc(*(Class *)(a1 + 64)) initWithValue:*(void *)(a1 + 32) forBaseValue:*(void *)(a1 + 40) inDatabase:*(void *)(a1 + 48)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8);
  BOOL v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) != 0;
}

id sub_1000AA2CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  [*(id *)(a1 + 32) setContent:*(void *)a4];
  objc_msgSend(*(id *)(a1 + 32), "setDateStyle:", (int)_PKEnumValueFromString(), 0, 0, 1, 1, 2, 2, 3, 3, 4, 4);
  objc_msgSend(*(id *)(a1 + 32), "setTimeStyle:", (int)_PKEnumValueFromString(), 0, 0, 1, 1, 2, 2, 3, 3, 4, 4);
  objc_msgSend(*(id *)(a1 + 32), "setIgnoresTimeZone:", objc_msgSend(*(id *)(a4 + 24), "BOOLValue"));
  id result = objc_msgSend(*(id *)(a1 + 32), "setIsRelative:", objc_msgSend(*(id *)(a4 + 32), "BOOLValue"));
  *a6 = 1;
  return result;
}

uint64_t PDSharingMailboxPayloadEncryptionSchemeFromKeyLength(uint64_t a1)
{
  if (a1 == 16) {
    return 1;
  }
  else {
    return 2 * (a1 == 32);
  }
}

uint64_t sub_1000AAD74(uint64_t a1)
{
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v9;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v9 != v5) {
          objc_enumerationMutation(v2);
        }
        objc_msgSend(*(id *)(*(void *)(a1 + 40) + 8), "deleteMerchantForPassUniqueIdentifier:auxiliaryPassInformationItemIdentifier:", *(void *)(a1 + 48), *(void *)(*((void *)&v8 + 1) + 8 * (void)v6), (void)v8);
        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
    }
    while (v4);
  }

  return 1;
}

void sub_1000AB528(uint64_t a1, void *a2)
{
  id v3 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 32));
  id v4 = [*(id *)(*(void *)(a1 + 32) + 40) objectForKey:*(void *)(a1 + 40)];
  uint64_t v5 = [*(id *)(a1 + 48) objectForKey:*(void *)(a1 + 56)];
  if (!v5)
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 56);
      *(_DWORD *)id buf = 138412290;
      uint64_t v49 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Missing item update for %@", buf, 0xCu);
    }
  }
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  id v8 = v4;
  id v9 = [v8 countByEnumeratingWithState:&v43 objects:v54 count:16];
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v44;
    do
    {
      for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v44 != v11) {
          objc_enumerationMutation(v8);
        }
        id v13 = *(void **)(*((void *)&v43 + 1) + 8 * i);
        id v14 = *(void **)(a1 + 64);
        id v15 = [v13 item];
        if ([v14 isEqual:v15])
        {
          unsigned int v16 = [v13 isInvalid];

          if (v16)
          {
            id v17 = v13;

            int v18 = 0;
            uint64_t v5 = v17;
            goto LABEL_19;
          }
        }
        else
        {
        }
      }
      id v10 = [v8 countByEnumeratingWithState:&v43 objects:v54 count:16];
    }
    while (v10);
    int v18 = 1;
  }
  else
  {
    int v18 = 1;
  }
LABEL_19:

  [v8 removeObject:v5];
  if (![v8 count])
  {

    id v8 = 0;
  }
  [*(id *)(*(void *)(a1 + 32) + 40) setObject:v8 forKeyedSubscript:*(void *)(a1 + 40)];
  id v19 = [*(id *)(*(void *)(a1 + 32) + 48) objectForKey:*(void *)(a1 + 40)];
  uint64_t v20 = v19;
  if (v19)
  {
    __int16 v21 = [v19 objectForKey:*(void *)(a1 + 56)];
    BOOL v22 = v21 == 0;
    if (v21) {
      [v20 removeObjectForKey:*(void *)(a1 + 56)];
    }
    if ([v20 count])
    {
      if (!v18) {
        goto LABEL_26;
      }
LABEL_31:
      uint64_t v23 = *(void *)(a1 + 32);
      BOOL v24 = *(void **)(v23 + 8);
      v39[0] = _NSConcreteStackBlock;
      v39[1] = 3221225472;
      v39[2] = sub_1000AB974;
      v39[3] = &unk_100733638;
      void v39[4] = v23;
      id v40 = *(id *)(a1 + 40);
      id v25 = v3;
      uint64_t v26 = *(void *)(a1 + 56);
      id v41 = v25;
      uint64_t v42 = v26;
      [v24 performTransactionWithBlock:v39];

      if (v22) {
        goto LABEL_42;
      }
      goto LABEL_32;
    }
    [*(id *)(*(void *)(a1 + 32) + 48) removeObjectForKey:*(void *)(a1 + 40)];
    if (v18) {
      goto LABEL_31;
    }
  }
  else
  {
    __int16 v21 = 0;
    BOOL v22 = 1;
    if (v18) {
      goto LABEL_31;
    }
  }
LABEL_26:
  if (v22) {
    goto LABEL_42;
  }
LABEL_32:
  id v27 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = *(void *)(a1 + 56);
    uint64_t v29 = *(void *)(a1 + 40);
    *(_DWORD *)id buf = 138412802;
    uint64_t v49 = v28;
    __int16 v50 = 2112;
    uint64_t v51 = v29;
    __int16 v52 = 2112;
    id v53 = v3;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "PDAuxiliaryPassInformationManager: Calling completions for %@ in pass %@ with newly fetched merchant: %@", buf, 0x20u);
  }

  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  id v30 = v21;
  id v31 = [v30 countByEnumeratingWithState:&v35 objects:v47 count:16];
  if (v31)
  {
    id v32 = v31;
    uint64_t v33 = *(void *)v36;
    do
    {
      for (uint64_t j = 0; j != v32; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v36 != v33) {
          objc_enumerationMutation(v30);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v35 + 1) + 8 * (void)j) + 16))(*(void *)(*((void *)&v35 + 1) + 8 * (void)j));
      }
      id v32 = [v30 countByEnumeratingWithState:&v35 objects:v47 count:16];
    }
    while (v32);
  }

LABEL_42:
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 32));
}

uint64_t sub_1000AB974(void *a1)
{
  if ([*(id *)(a1[4] + 8) passExistsWithUniqueID:a1[5]]) {
    [*(id *)(a1[4] + 8) insertMerchant:a1[6] forPassUniqueIdentifier:a1[5] auxiliaryPassInformationItemIdentifier:a1[7]];
  }
  return 1;
}

uint64_t sub_1000ABDBC(uint64_t a1, void *a2)
{
  id v3 = [a2 item];
  id v4 = [v3 identifier];
  uint64_t v5 = *(void **)(a1 + 32);
  id v6 = v4;
  id v7 = v5;
  id v8 = v7;
  if (v6 == v7)
  {
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
    if (v6 && v7) {
      uint64_t v9 = (uint64_t)[v6 isEqualToString:v7];
    }
  }

  return v9;
}

void sub_1000ABE50(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setUseDisplayNameIgnoringBrand:1];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000AC040(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 merchant];
  uint64_t v5 = [v3 brand];
  id v6 = [v3 result];

  id v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = [*(id *)(a1 + 32) identifier];
    int v10 = 138413058;
    uint64_t v11 = v8;
    __int16 v12 = 2048;
    id v13 = v6;
    __int16 v14 = 2112;
    id v15 = v4;
    __int16 v16 = 2112;
    id v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDAuxiliaryPassInformationManager: Completed look up of maps data for aux item %@ with result %ld. Maps merchant: %@, maps brand: %@", (uint8_t *)&v10, 0x2Au);
  }
  id v9 = objc_alloc_init((Class)PKMerchant);
  [v9 setMapsMerchant:v4];
  [v9 setMapsBrand:v5];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1000AC3A4()
{
  uint64_t v0 = self;
  id v1 = sub_1000AC3D4(v0, 1);
}

id sub_1000AC3D4(uint64_t a1, int a2)
{
  id result = self;
  if (a2)
  {
    if (qword_100808B78)
    {
LABEL_8:
      __break(1u);
      return result;
    }
    id v4 = sub_1000AC51C([PDXPCListener_ApplicationAuthorization alloc]);
    uint64_t v5 = (void *)qword_100808B78;
    qword_100808B78 = (uint64_t)v4;
  }
  id result = (id)qword_100808B78;
  if (!qword_100808B78) {
    goto LABEL_8;
  }
  return result;
}

void sub_1000AC440(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  uint64_t v3 = self;
  id v4 = sub_1000AC3D4(v3, 0);
  sub_1000AC4B0((uint64_t)v4, v2);
}

void sub_1000AC4B0(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    objc_storeStrong((id *)(a1 + 16), a2);
    [*(id *)(a1 + 8) setDelegate:a1];
    [*(id *)(a1 + 8) activate];
  }
}

void *sub_1000AC51C(void *a1)
{
  if (!a1) {
    return 0;
  }
  v6.receiver = a1;
  v6.super_class = (Class)PDXPCListener_ApplicationAuthorization;
  id v1 = objc_msgSendSuper2(&v6, "init");
  if (v1)
  {
    id v2 = objc_alloc((Class)NSXPCListener);
    id v3 = [v2 initWithMachServiceName:PKApplicationAuthorizationServiceName];
    id v4 = (void *)v1[1];
    v1[1] = v3;
  }
  return v1;
}

void sub_1000AC9F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000ACA10(uint64_t a1)
{
  id v2 = [objc_alloc(*(Class *)(a1 + 56)) initWithAccessory:*(void *)(a1 + 32) inDatabase:*(void *)(a1 + 40)];
  if (!v2) {
    goto LABEL_10;
  }
  id v3 = [*(id *)(a1 + 32) type];
  if (v3 == (id)2)
  {
    id v4 = TileAccessoryImage;
    uint64_t v5 = [*(id *)(a1 + 32) accessoryTypeImage];
    goto LABEL_8;
  }
  if (v3 == (id)1)
  {
    id v4 = TileAccessorySpinner;
    uint64_t v5 = [*(id *)(a1 + 32) accessoryTypeSpinner];
LABEL_8:
    objc_super v6 = (void *)v5;
    id v7 = [(__objc2_class *)v4 insertAccessory:v5 forBaseAccessory:v2 inDatabase:*(void *)(a1 + 40)];

    if (v7) {
      goto LABEL_9;
    }
LABEL_10:
    uint64_t v8 = 0;
    goto LABEL_11;
  }
  if (!v3)
  {
    id v4 = TileAccessoryButton;
    uint64_t v5 = [*(id *)(a1 + 32) accessoryTypeButton];
    goto LABEL_8;
  }
LABEL_9:
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), v2);
  uint64_t v8 = 1;
LABEL_11:

  return v8;
}

void sub_1000ACE9C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [v5 setOrder:a3];
  id v6 = +[PaymentTransactionAmountModifier insertPaymentTransactionAmountModifier:v5 forPaymentTransactionPID:*(void *)(a1 + 48) inDatabase:*(void *)(a1 + 32)];

  [*(id *)(a1 + 40) safelyAddObject:v6];
}

void sub_1000AD224(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v12 = objc_alloc_init((Class)PKPaymentTransactionAmountModifier);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v12 withProperties:v6 values:a4];
  id v7 = *(void **)(a1 + 48);
  uint64_t v8 = *(void *)(a4 + 8 * (void)[v6 indexOfObject:@"amount"]);
  uint64_t v9 = *(void *)(a4 + 8 * (void)[v6 indexOfObject:@"currency"]);
  id v10 = [v6 indexOfObject:@"exponent"];

  uint64_t v11 = objc_msgSend(v7, "_postProcessedAmountForDecimalAmount:currency:exponent:", v8, v9, objc_msgSend(*(id *)(a4 + 8 * (void)v10), "integerValue"));
  [v12 setAmount:v11];

  [*(id *)(a1 + 40) safelyAddObject:v12];
}

void sub_1000AD618(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v11 = objc_alloc_init((Class)PKPaymentTransactionAmountModifier);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v11 withProperties:v6 values:a4];
  id v7 = objc_msgSend(*(id *)(a1 + 48), "_postProcessedAmountForDecimalAmount:currency:exponent:", *(void *)(a4 + 8 * (void)objc_msgSend(v6, "indexOfObject:", @"amount")), *(void *)(a4 + 8 * (void)objc_msgSend(v6, "indexOfObject:", @"currency")), objc_msgSend(*(id *)(a4 + 8 * (void)objc_msgSend(v6, "indexOfObject:", @"exponent")), "integerValue"));
  [v11 setAmount:v7];

  id v8 = [v6 count];
  id v9 = *(id *)(a4 + 8 * (void)v8 - 8);
  id v10 = [*(id *)(a1 + 40) objectForKey:v9];
  if (!v10)
  {
    id v10 = objc_alloc_init((Class)NSMutableArray);
    [*(id *)(a1 + 40) setObject:v10 forKey:v9];
  }
  [v10 addObject:v11];
}

void sub_1000ADC40(id a1, PKPaymentTransactionAmountModifier *a2, id a3)
{
}

void sub_1000ADC48(id a1, PKPaymentTransactionAmountModifier *a2, id a3)
{
}

void sub_1000ADC50(id a1, PKPaymentTransactionAmountModifier *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentTransactionAmountModifier setOrder:](v4, "setOrder:", [a3 integerValue]);
}

void sub_1000AE314(id a1, PKFeatureApplicationInvitationDetails *a2, id a3)
{
}

void sub_1000AE31C(id a1, PKFeatureApplicationInvitationDetails *a2, id a3)
{
}

void sub_1000AE324(id a1, PKFeatureApplicationInvitationDetails *a2, id a3)
{
  id v4 = a2;
  -[PKFeatureApplicationInvitationDetails setAccountUserAccessLevel:](v4, "setAccountUserAccessLevel:", [a3 integerValue]);
}

void sub_1000AE37C(id a1, PKFeatureApplicationInvitationDetails *a2, id a3)
{
}

void sub_1000AE384(id a1, PKFeatureApplicationInvitationDetails *a2, id a3)
{
}

void sub_1000AE38C(id a1, PKFeatureApplicationInvitationDetails *a2, id a3)
{
}

void sub_1000AE394(id a1, PKFeatureApplicationInvitationDetails *a2, id a3)
{
}

void sub_1000AE494(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_1000AE59C(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [objc_alloc((Class)NSNumber) initWithLongLong:a2];
  [v2 addObject:v3];
}

void sub_1000AE848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000AE860(uint64_t a1, sqlite3_stmt *a2)
{
  int v5 = 1;
  [*(id *)(a1 + 32) bindToSelectStatement:a2 bindingIndex:&v5];
  if (sub_1000140E0((uint64_t)SQLiteDatabase, a2))
  {
    id v4 = SQLiteCopyFoundationIntegerValueForStatementColumn(a2, 0);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v4 integerValue];
  }
}

void sub_1000AEB6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000AEB8C(uint64_t a1, sqlite3_stmt *a2)
{
  int v6 = 1;
  id v4 = [*(id *)(a1 + 32) predicate];
  [v4 bindToStatement:a2 bindingIndex:&v6];

  uint64_t result = sub_10035CD0C((uint64_t)SQLiteDatabase, a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void sub_1000AECB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000AECCC(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 16) entityClass];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000AED68;
  v4[3] = &unk_100733930;
  id v6 = v2;
  long long v5 = *(_OWORD *)(a1 + 32);
  [(id)v5 enumeratePersistentIDsUsingBlock:v4];
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
}

void sub_1000AED68(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  id v6 = [objc_alloc(*(Class *)(a1 + 48)) initWithPersistentID:a2 inDatabase:*(void *)(*(void *)(a1 + 32) + 8)];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v6 deleteFromDatabase];
  *a4 = *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) ^ 1;
}

void sub_1000AF0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000AF10C(uint64_t a1, sqlite3_stmt *a2)
{
  int v8 = 1;
  id v4 = [*(id *)(a1 + 32) predicate];
  [v4 bindToStatement:a2 bindingIndex:&v8];

  if (sub_1000140E0((uint64_t)SQLiteDatabase, a2))
  {
    id v5 = SQLiteCopyFoundationValueForStatementColumn(a2, 0);
    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    id v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;
  }
}

void sub_1000AF460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000AF478(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  id v3 = +[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", [*(id *)(a1 + 32) persistentID]);
  [v2 setValue:v3 forKey:@"applet_subcredential_pid"];

  id v4 = +[NSNumber numberWithUnsignedInteger:*(void *)(a1 + 72)];
  [v2 setValue:v4 forKey:@"ranging_suspension_reasons"];

  id v5 = +[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", [*(id *)(a1 + 40) persistentID]);
  [v2 setValue:v5 forKey:@"payment_application_pid"];

  id v6 = [*(id *)(a1 + 48) initWithPropertyValues:v2 inDatabase:*(void *)(a1 + 56)];
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
  int v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  BOOL v9 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) != 0;
  return v9;
}

void sub_1000AF78C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000AF7B0(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  id v6 = *a4;
  uint64_t v7 = +[NSNull null];
  if (v6 == (id)v7)
  {
    id v8 = 0;
  }
  else
  {
    uint64_t v10 = v7;
    id v8 = [*a4 unsignedIntegerValue];
    uint64_t v7 = v10;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v8;
  return _objc_release_x1(v8, v7);
}

id sub_1000B02DC(uint64_t a1, void *a2)
{
  id v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "INFamilyDidChangeNotification notification fired", v5, 2u);
  }

  return [a2 ensureZoneShareIntegrity];
}

id sub_1000B0468(uint64_t a1)
{
  id result = objc_msgSend(*(id *)(a1 + 32), "_queue_canInvalidateContainer");
  if (result)
  {
    id v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "PDApplePayCloudStoreContainer: No accounts remaining, invalidating.", v4, 2u);
    }

    return [*(id *)(a1 + 32) invalidateCloudStoreWithOperationGroupNameSuffix:*(void *)(a1 + 40) clearCache:*(unsigned __int8 *)(a1 + 48) completion:0];
  }
  return result;
}

void sub_1000B0DC4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [*(id *)(a1 + 32) workQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000B0EA0;
  block[3] = &unk_10072E238;
  void block[4] = *(void *)(a1 + 32);
  id v11 = v5;
  id v12 = v6;
  id v8 = v6;
  id v9 = v5;
  dispatch_async(v7, block);
}

void sub_1000B0EA0(uint64_t a1)
{
  [*(id *)(a1 + 32) setAccountChangedNotificationReceived:0];
  [*(id *)(a1 + 40) supportsDeviceToDeviceEncryption];
  PKSharedCacheSetBoolForKey();
  id v2 = [*(id *)(a1 + 40) accountStatus];
  id v3 = *(void **)(a1 + 40);
  if (v3) {
    BOOL v4 = v2 == (id)1;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 48);
      *(_DWORD *)id buf = 138412290;
      uint64_t v17 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error: Cannot setup container with error: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 32) setNextExpectedState:3];
    [*(id *)(a1 + 32) setOperationError:*(void *)(a1 + 48)];
LABEL_16:
    objc_msgSend(*(id *)(a1 + 32), "_queue_setContainerState:operationGroupNameSuffix:retryCount:completion:", 3, PKCloudStoreOperationGroupSuffixCKAccountChangedNotification, 0, 0);
    return;
  }
  if (![v3 supportsDeviceToDeviceEncryption])
  {
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Error: Cannot setup container because account does not support device to device encryption (HSA2)", buf, 2u);
    }

    [*(id *)(a1 + 32) setNextExpectedState:3];
    id v9 = *(void **)(a1 + 32);
    uint64_t v10 = [v9 errorWithCode:-4005 description:@"Cannot setup container because account does not support device to device encryption"];
    [v9 setOperationError:v10];

    goto LABEL_16;
  }
  if ([*(id *)(a1 + 32) cloudContainerSetupInProgress])
  {
    uint64_t v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "A cloud store initialization is already in progess.", buf, 2u);
    }
  }
  else
  {
    id v11 = [*(id *)(a1 + 32) nextExpectedState];
    id v12 = PKLogFacilityTypeGetObject();
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (v11 == (id)15)
    {
      if (v13)
      {
        *(_WORD *)id buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "The container is already setup; no need to initalize it again.",
          buf,
          2u);
      }
    }
    else
    {
      if (v13)
      {
        *(_WORD *)id buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "The user supports device to device encryption. Trying to setup container.", buf, 2u);
      }

      __int16 v14 = *(void **)(a1 + 32);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      v15[2] = sub_1000B11A8;
      v15[3] = &unk_1007300F8;
      void v15[4] = v14;
      [v14 initialCloudDatabaseSetupWithOperationGroupNameSuffix:PKCloudStoreOperationGroupSuffixCKAccountChangedNotification completion:v15];
    }
  }
}

void sub_1000B11A8(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = @"NO";
    if (a2) {
      CFStringRef v7 = @"YES";
    }
    int v9 = 138543618;
    CFStringRef v10 = v7;
    __int16 v11 = 2112;
    id v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "PDApplePayCloudStoreContainer: Finished cloud database setup with success %{public}@, error: %@", (uint8_t *)&v9, 0x16u);
  }

  if (a2)
  {
    id v8 = [*(id *)(a1 + 32) delegate];
    [v8 cloudStoreContainerShouldUnscheduleAllBackgroundActivities:*(void *)(a1 + 32)];

    [*(id *)(a1 + 32) _updateFetchTaskScheduledActivityIfNeccessary];
    [*(id *)(a1 + 32) _updateUnarchivedTransactionsScheduledActivityIfNeccessary];
  }
}

void sub_1000B1A08(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  CFStringRef v7 = [*(id *)(a1 + 32) workQueue];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1000B1B08;
  v15[3] = &unk_100733A20;
  uint64_t v8 = *(void *)(a1 + 32);
  int v9 = *(void **)(a1 + 40);
  id v16 = v5;
  uint64_t v17 = v8;
  id v10 = v9;
  id v12 = *(void **)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 56);
  id v18 = v10;
  uint64_t v21 = v11;
  id v19 = v6;
  id v20 = v12;
  id v13 = v6;
  id v14 = v5;
  dispatch_async(v7, v15);
}

id sub_1000B1B08(uint64_t a1)
{
  [*(id *)(a1 + 32) supportsDeviceToDeviceEncryption];
  PKSharedCacheSetBoolForKey();
  id v2 = [*(id *)(a1 + 32) accountStatus];
  id v3 = *(void **)(a1 + 32);
  if (v3) {
    BOOL v4 = v2 == (id)1;
  }
  else {
    BOOL v4 = 0;
  }
  if (!v4)
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 56);
      int v15 = 138412290;
      uint64_t v16 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error: Cannot setup container with error: %@", (uint8_t *)&v15, 0xCu);
    }

    [*(id *)(a1 + 40) setNextExpectedState:3];
    [*(id *)(a1 + 40) setOperationError:*(void *)(a1 + 56)];
    return objc_msgSend(*(id *)(a1 + 40), "_queue_setContainerState:operationGroupNameSuffix:retryCount:completion:", 3, *(void *)(a1 + 48), *(void *)(a1 + 72), *(void *)(a1 + 64));
  }
  if (![v3 supportsDeviceToDeviceEncryption])
  {
    id v12 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Error: Cannot setup container because account does not support device to device encryption", (uint8_t *)&v15, 2u);
    }

    [*(id *)(a1 + 40) setNextExpectedState:3];
    id v13 = *(void **)(a1 + 40);
    id v14 = [v13 errorWithCode:-4005 description:@"Cannot setup container because account does not support device to device encryption"];
    [v13 setOperationError:v14];

    return objc_msgSend(*(id *)(a1 + 40), "_queue_setContainerState:operationGroupNameSuffix:retryCount:completion:", 3, *(void *)(a1 + 48), *(void *)(a1 + 72), *(void *)(a1 + 64));
  }
  [*(id *)(a1 + 40) setNextExpectedState:5];
  CFStringRef v7 = *(void **)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v10 = *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 72);
  return objc_msgSend(v7, "_queue_setContainerState:operationGroupNameSuffix:retryCount:completion:", 5, v8, v9, v10);
}

void sub_1000B2348(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v8 = [v6 allObjects];
  id v9 = objc_msgSend(v8, "pk_createArrayByApplyingBlock:", &stru_100733A88);

  uint64_t v10 = a1;
  if ([v9 count]) {
    [*(id *)(a1 + 32) reportContainerChangeSignpostEventType:34 stateName:0 objectNames:v9 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];
  }

  long long v61 = 0u;
  long long v62 = 0u;
  long long v60 = 0u;
  long long v59 = 0u;
  id obj = v6;
  id v11 = [obj countByEnumeratingWithState:&v59 objects:v67 count:16];
  if (v11)
  {
    id v12 = v11;
    uint64_t v51 = *(void *)v60;
    long long v44 = PKCloudTransactionRecordType;
    uint64_t v43 = PKCloudStoreOperationGroupPushTriggered;
    uint64_t v42 = PKCloudStoreOperationGroupSuffixRecordFetch;
    uint64_t v50 = a1;
    id v47 = v5;
    do
    {
      id v13 = 0;
      id v48 = v12;
      do
      {
        if (*(void *)v60 != v51) {
          objc_enumerationMutation(obj);
        }
        id v14 = *(void **)(*((void *)&v59 + 1) + 8 * (void)v13);
        uint64_t v16 = [v14 recordID];
        uint64_t v17 = [v16 recordName];

        id v18 = [v14 recordType];
        if ([*(id *)(v10 + 32) _isTransactionItemFromRecordType:v18])
        {
          __int16 v52 = v15;
          id v19 = +[PKPaymentTransaction recordNamePrefix];
          id v20 = [v17 stringByReplacingOccurrencesOfString:v19 withString:&stru_10075AAD8];

          uint64_t v21 = *(void **)(v10 + 32);
          BOOL v22 = [v14 recordID];
          uint64_t v23 = [v21 _transactionSourceIdentifierForTransactionRecordID:v22 recordType:v18 databaseIdentifier:v5];

          if (v23)
          {
            BOOL v24 = [*(id *)(v10 + 32) dataSource];
            id v25 = [v24 transactionWithServiceIdentifier:v20 transactionSourceIdentifier:v23];

            [v25 addUpdateReasons:16];
            uint64_t v26 = PKLogFacilityTypeGetObject();
            BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
            if (v25)
            {
              if (v27)
              {
                uint64_t v28 = [v25 serviceIdentifier];
                *(_DWORD *)id buf = 138412546;
                __int16 v64 = v25;
                __int16 v65 = 2114;
                id v66 = v28;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Deleting transaction in local database %@ with service identifier %{public}@", buf, 0x16u);
              }
              uint64_t v29 = [*(id *)(v50 + 32) dataSource];
              id v30 = [v29 insertOrUpdatePaymentTransaction:v25 withTransactionSourceIdentifier:v23 transactionArchive:0 originDeviceID:0 insertionMode:2 performTruncation:1];

              id v31 = +[PKPaymentTransaction recordNamePrefix];
              id v32 = +[NSString stringWithFormat:@"%@%@", v31, v17];

              v57[0] = _NSConcreteStackBlock;
              v57[1] = 3221225472;
              v57[2] = sub_1000B2B9C;
              v57[3] = &unk_100733AB0;
              id v58 = v20;
              if ((objc_msgSend(obj, "pk_hasObjectPassingTest:", v57) & 1) == 0)
              {
                uint64_t v33 = v18;
                if (v33 != v44)
                {
                  long long v34 = v33;
                  if (v33 && v44)
                  {
                    unsigned int v45 = -[NSObject isEqualToString:](v33, "isEqualToString:");

                    if (!v45) {
                      goto LABEL_37;
                    }
LABEL_33:
                    long long v46 = [v14 recordID];
                    id v41 = [v46 zoneID];
                    long long v34 = [v41 zoneName];

                    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)id buf = 138543618;
                      __int16 v64 = v32;
                      __int16 v65 = 2114;
                      id v66 = v34;
                      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Deleting transaction device record %{public}@ in zone %{public}@", buf, 0x16u);
                    }

                    [*(id *)(v50 + 32) removeRecordWithRecordName:v32 zoneName:v34 groupName:v43 groupNameSuffix:v42 qualityOfService:17 completion:0];
                  }

                  goto LABEL_37;
                }

                goto LABEL_33;
              }
LABEL_37:

              id v5 = v47;
            }
            else
            {
              if (v27)
              {
                *(_DWORD *)id buf = 138543362;
                __int16 v64 = v20;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Cannot delete transaction. No payment pass in local database with service identifier %{public}@", buf, 0xCu);
              }
              id v32 = v26;
            }
          }
          else
          {
            id v25 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)id buf = 138412546;
              __int16 v64 = 0;
              __int16 v65 = 2114;
              id v66 = v20;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Cannot delete transaction. No transactionSourceIdentifier %@ in local database with service identifier %{public}@", buf, 0x16u);
            }
          }
          id v12 = v48;

          uint64_t v10 = v50;
          goto LABEL_40;
        }
        if ([*(id *)(v10 + 32) _isAccountEventFromRecordType:v18])
        {
          __int16 v52 = v15;
          long long v35 = +[PKAccountEvent eventIdentifierFromRecordName:v17];
          long long v36 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = 138412290;
            __int16 v64 = v35;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Deleting event with identifier %@", buf, 0xCu);
          }

          long long v37 = *(void **)(*(void *)(v10 + 32) + 256);
          v55[0] = _NSConcreteStackBlock;
          v55[1] = 3221225472;
          v55[2] = sub_1000B2C20;
          v55[3] = &unk_10072E1E8;
          id v56 = v35;
          id v20 = v35;
          [v37 deleteEventWithIdentifier:v20 completion:v55];
          uint64_t v23 = v56;
        }
        else
        {
          if (![*(id *)(v10 + 32) _isAccountFromRecordType:v18]) {
            goto LABEL_41;
          }
          __int16 v52 = v15;
          long long v38 = +[PKAccount accountIdentifierFromRecordName:v17];
          id v39 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = 138412290;
            __int16 v64 = v38;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Deleting account with identifier %@", buf, 0xCu);
          }

          id v40 = *(void **)(*(void *)(v10 + 32) + 256);
          v53[0] = _NSConcreteStackBlock;
          v53[1] = 3221225472;
          v53[2] = sub_1000B2CCC;
          v53[3] = &unk_10072F6E8;
          id v54 = v38;
          id v20 = v38;
          [v40 deleteAccountWithIdentifier:v20 completion:v53];
          uint64_t v23 = v54;
        }
LABEL_40:

        int v15 = v52;
LABEL_41:

        id v13 = (char *)v13 + 1;
      }
      while (v12 != v13);
      id v12 = [obj countByEnumeratingWithState:&v59 objects:v67 count:16];
    }
    while (v12);
  }
}

id sub_1000B2B4C(id a1, PKCloudDeletedRecord *a2)
{
  id v2 = [(PKCloudDeletedRecord *)a2 recordID];
  id v3 = [v2 recordName];

  return v3;
}

uint64_t sub_1000B2B9C(uint64_t a1, void *a2)
{
  id v3 = [a2 recordName];
  BOOL v4 = *(void **)(a1 + 32);
  id v5 = v3;
  id v6 = v4;
  CFStringRef v7 = v6;
  if (v5 == v6)
  {
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    if (v5 && v6) {
      uint64_t v8 = (uint64_t)[v5 isEqualToString:v6];
    }
  }

  return v8;
}

void sub_1000B2C20(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 138412290;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Deleted event with identifier %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1000B2CCC(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = PKLogFacilityTypeGetObject();
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      int v11 = 138412546;
      uint64_t v12 = v6;
      __int16 v13 = 2112;
      id v14 = v3;
      CFStringRef v7 = "Failed to delete account with identifier %@, error: %@";
      uint64_t v8 = v4;
      uint32_t v9 = 22;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v11, v9);
    }
  }
  else if (v5)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    int v11 = 138412290;
    uint64_t v12 = v10;
    CFStringRef v7 = "Deleted account with identifier %@";
    uint64_t v8 = v4;
    uint32_t v9 = 12;
    goto LABEL_6;
  }
}

void sub_1000B32F4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1000B3310(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = *(void **)(a1 + 32);
  id v7 = a3;
  uint64_t v8 = [v6 containerManager];
  uint32_t v9 = [v8 databaseForIdentifier:v5];

  id v10 = [objc_alloc((Class)PDCloudStoreCounterpartRecordParser) initWithDataSource:*(void *)(a1 + 32)];
  [v10 addRecords:v7];

  if (([*(id *)(a1 + 40) storeChangesInDatabase] & 1) != 0
    || [*(id *)(a1 + 40) returnRecords])
  {
    int v11 = *(void **)(a1 + 48);
    uint64_t v42 = v9;
    v84[0] = _NSConcreteStackBlock;
    v84[1] = 3221225472;
    v84[2] = sub_1000B39CC;
    v84[3] = &unk_100733B00;
    v84[4] = *(void *)(a1 + 32);
    uint64_t v12 = &v85;
    id v13 = v10;
    id v85 = v13;
    id v14 = &v86;
    id v86 = *(id *)(a1 + 40);
    id v15 = v5;
    id v87 = v15;
    id v88 = *(id *)(a1 + 56);
    [v11 addOperation:v84];
    uint64_t v16 = *(void **)(a1 + 48);
    v79[0] = _NSConcreteStackBlock;
    v79[1] = 3221225472;
    v79[2] = sub_1000B3B10;
    v79[3] = &unk_100733B00;
    v79[4] = *(void *)(a1 + 32);
    id v17 = v13;
    id v80 = v17;
    id v81 = *(id *)(a1 + 40);
    id v18 = v15;
    id v82 = v18;
    id v83 = *(id *)(a1 + 56);
    [v16 addOperation:v79];
    id v19 = *(void **)(a1 + 48);
    v74[0] = _NSConcreteStackBlock;
    v74[1] = 3221225472;
    v74[2] = sub_1000B3C54;
    v74[3] = &unk_100733B00;
    v74[4] = *(void *)(a1 + 32);
    id v20 = v17;
    id v75 = v20;
    id v76 = *(id *)(a1 + 40);
    id v21 = v18;
    id v77 = v21;
    id v78 = *(id *)(a1 + 56);
    [v19 addOperation:v74];
    BOOL v22 = *(void **)(a1 + 48);
    v69[0] = _NSConcreteStackBlock;
    v69[1] = 3221225472;
    v69[2] = sub_1000B3D98;
    v69[3] = &unk_100733B00;
    v69[4] = *(void *)(a1 + 32);
    id v23 = v20;
    id v70 = v23;
    id v71 = *(id *)(a1 + 40);
    id v24 = v21;
    id v72 = v24;
    id v73 = *(id *)(a1 + 56);
    [v22 addOperation:v69];
    id v25 = *(void **)(a1 + 48);
    v63[0] = _NSConcreteStackBlock;
    v63[1] = 3221225472;
    void v63[2] = sub_1000B3EDC;
    v63[3] = &unk_100733B50;
    v63[4] = *(void *)(a1 + 32);
    id v26 = v23;
    id v64 = v26;
    id v65 = *(id *)(a1 + 40);
    id v27 = v24;
    uint64_t v28 = *(void *)(a1 + 80);
    id v66 = v27;
    uint64_t v68 = v28;
    id v67 = *(id *)(a1 + 56);
    [v25 addOperation:v63];
    uint64_t v29 = *(void **)(a1 + 48);
    v55[0] = _NSConcreteStackBlock;
    v55[1] = 3221225472;
    v55[2] = sub_1000B4090;
    v55[3] = &unk_100733BA0;
    void v55[4] = *(void *)(a1 + 32);
    id v30 = v26;
    id v56 = v30;
    id v57 = *(id *)(a1 + 40);
    id v31 = v27;
    id v58 = v31;
    id v32 = *(id *)(a1 + 64);
    uint64_t v33 = *(void *)(a1 + 88);
    uint64_t v34 = *(void *)(a1 + 72);
    id v59 = v32;
    uint64_t v61 = v34;
    uint64_t v62 = v33;
    id v60 = *(id *)(a1 + 56);
    [v29 addOperation:v55];
    long long v35 = *(void **)(a1 + 48);
    v50[0] = _NSConcreteStackBlock;
    v50[1] = 3221225472;
    v50[2] = sub_1000B4358;
    v50[3] = &unk_100733B00;
    v50[4] = *(void *)(a1 + 32);
    id v51 = v30;
    id v52 = v31;
    id v53 = *(id *)(a1 + 40);
    id v54 = *(id *)(a1 + 56);
    long long v36 = v35;
    uint32_t v9 = v42;
    [v36 addOperation:v50];

    long long v37 = v87;
  }
  else
  {
    if ([*(id *)(a1 + 40) requestType] != (id)6) {
      goto LABEL_5;
    }
    v47[0] = _NSConcreteStackBlock;
    v47[1] = 3221225472;
    v47[2] = sub_1000B44B4;
    v47[3] = &unk_100733BF0;
    v47[4] = *(void *)(a1 + 32);
    uint64_t v12 = &v48;
    id v38 = v9;
    id v48 = v38;
    id v14 = (id *)v49;
    id v39 = v5;
    uint64_t v40 = *(void *)(a1 + 80);
    v49[0] = v39;
    v49[1] = v40;
    [v10 enumerateKeysAndObjectsForItemType:1 usingBlock:v47];
    v45[0] = _NSConcreteStackBlock;
    v45[1] = 3221225472;
    v45[2] = sub_1000B4834;
    v45[3] = &unk_100733C40;
    void v45[4] = *(void *)(a1 + 32);
    id v41 = v38;
    id v46 = v41;
    [v10 enumerateKeysAndObjectsForItemType:9 usingBlock:v45];
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 3221225472;
    v43[2] = sub_1000B4C08;
    v43[3] = &unk_100733C40;
    v43[4] = *(void *)(a1 + 32);
    id v44 = v41;
    [v10 enumerateKeysAndObjectsForItemType:10 usingBlock:v43];

    long long v37 = v46;
  }

LABEL_5:
}

void sub_1000B39CC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 56);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1000B3AC4;
  v15[3] = &unk_100733AD8;
  id v12 = *(id *)(a1 + 64);
  id v17 = v6;
  id v18 = v7;
  id v16 = v12;
  id v13 = v6;
  id v14 = v7;
  [v8 _processShareWithRecordParser:v9 request:v10 databaseIdentifier:v11 completion:v15];
}

uint64_t sub_1000B3AC4(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) applyCloudRecordArray:a2];
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v3();
}

void sub_1000B3B10(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 56);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1000B3C08;
  v15[3] = &unk_100733AD8;
  id v12 = *(id *)(a1 + 64);
  id v17 = v6;
  id v18 = v7;
  id v16 = v12;
  id v13 = v6;
  id v14 = v7;
  [v8 _processZoneShareLockWithRecordParser:v9 request:v10 databaseIdentifier:v11 completion:v15];
}

uint64_t sub_1000B3C08(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) applyCloudRecordArray:a2];
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v3();
}

void sub_1000B3C54(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 56);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1000B3D4C;
  v15[3] = &unk_100733AD8;
  id v12 = *(id *)(a1 + 64);
  id v17 = v6;
  id v18 = v7;
  id v16 = v12;
  id v13 = v6;
  id v14 = v7;
  [v8 _processRecurringPaymentsWithRecordParser:v9 request:v10 databaseIdentifier:v11 completion:v15];
}

uint64_t sub_1000B3D4C(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) applyCloudRecordArray:a2];
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v3();
}

void sub_1000B3D98(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 56);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1000B3E90;
  v15[3] = &unk_100733AD8;
  id v12 = *(id *)(a1 + 64);
  id v17 = v6;
  id v18 = v7;
  id v16 = v12;
  id v13 = v6;
  id v14 = v7;
  [v8 _processCounterpartImageDataWithRecordParser:v9 request:v10 databaseIdentifier:v11 completion:v15];
}

uint64_t sub_1000B3E90(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) applyCloudRecordArray:a2];
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v3();
}

void sub_1000B3EDC(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v9 = (void *)a1[4];
  uint64_t v8 = (void *)a1[5];
  uint64_t v10 = a1[6];
  uint64_t v11 = a1[7];
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  id v17[2] = sub_1000B4018;
  v17[3] = &unk_100733B28;
  void v17[4] = v9;
  id v18 = v8;
  id v19 = (id)a1[6];
  id v12 = (id)a1[7];
  id v14 = (void *)a1[8];
  uint64_t v13 = a1[9];
  id v20 = v12;
  uint64_t v24 = v13;
  id v22 = v6;
  id v23 = v7;
  id v21 = v14;
  id v15 = v6;
  id v16 = v7;
  [v9 _fetchMissingTransactionRecordsWithRecordParser:v18 request:v10 databaseIdentifier:v11 completion:v17];
}

void sub_1000B4018(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) _parseTransactionRecords:*(void *)(a1 + 40) request:*(void *)(a1 + 48) databaseIdentifier:*(void *)(a1 + 56) updateReasons:*(void *)(a1 + 88)];
  [*(id *)(a1 + 64) applyCloudRecordArray:v2];
  (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
}

void sub_1000B4090(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v9 = *(void **)(a1 + 32);
  uint64_t v8 = *(void **)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 56);
  uint64_t v12 = *(void *)(a1 + 64);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  v19[2] = sub_1000B41EC;
  v19[3] = &unk_100733B78;
  uint64_t v13 = *(void *)(a1 + 88);
  uint64_t v26 = *(void *)(a1 + 80);
  void v19[4] = v9;
  id v20 = v8;
  id v21 = *(id *)(a1 + 56);
  id v14 = *(id *)(a1 + 48);
  uint64_t v15 = *(void *)(a1 + 88);
  id v22 = v14;
  uint64_t v27 = v15;
  id v16 = *(id *)(a1 + 72);
  id v24 = v6;
  id v25 = v7;
  id v23 = v16;
  id v17 = v6;
  id v18 = v7;
  [v9 _fetchMissingAccountEventsWithRecordParser:v20 request:v10 databaseIdentifier:v11 carriedOverRecordsByDatabaseIdentifier:v12 updateReasons:v13 completion:v19];
}

void sub_1000B41EC(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40), a2);
  id v4 = a2;
  id v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  id v8 = [*(id *)(a1 + 56) storeChangesInDatabase];
  id v9 = [*(id *)(a1 + 56) returnRecords];
  uint64_t v10 = *(void *)(a1 + 96);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1000B430C;
  void v11[3] = &unk_100733AD8;
  id v12 = *(id *)(a1 + 64);
  id v14 = *(id *)(a1 + 80);
  id v13 = *(id *)(a1 + 72);
  [v5 _parseAccountEventsFromRecordParser:v6 databaseIdentifier:v7 shouldUpdateLocalDatabase:v8 shouldReturn:v9 updateReasons:v10 completion:v11];
}

uint64_t sub_1000B430C(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) applyCloudRecordArray:a2];
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v3();
}

void sub_1000B4358(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  id v11 = [*(id *)(a1 + 56) storeChangesInDatabase];
  id v12 = [*(id *)(a1 + 56) returnRecords];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_1000B4468;
  v16[3] = &unk_100733AD8;
  id v13 = *(id *)(a1 + 64);
  id v18 = v6;
  id v19 = v7;
  id v17 = v13;
  id v14 = v6;
  id v15 = v7;
  [v8 _parseAccountsFromRecordParser:v9 databaseIdentifier:v10 shouldUpdateLocalDatabase:v11 shouldReturn:v12 completion:v16];
}

uint64_t sub_1000B4468(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) applyCloudRecordArray:a2];
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v3();
}

void sub_1000B44B4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000B4588;
  v8[3] = &unk_100733BC8;
  id v6 = *(void **)(a1 + 40);
  void v8[4] = *(void *)(a1 + 32);
  id v9 = v6;
  id v10 = *(id *)(a1 + 48);
  id v11 = v5;
  uint64_t v12 = *(void *)(a1 + 56);
  id v7 = v5;
  [a3 enumerateKeysAndObjectsUsingBlock:v8];
}

void sub_1000B4588(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v8 = [*(id *)(a1 + 32) containerManager];
  id v9 = [v6 firstObject];
  id v10 = [v9 recordID];
  id v11 = [v10 zoneID];
  uint64_t v12 = [v8 cloudStoreZoneForZoneID:v11 inContainerDatabase:*(void *)(a1 + 40)];

  id v13 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v6];
  id v14 = [*(id *)(a1 + 32) _transactionSourceIdentifierForTransactionCloudStoreRecord:v13 databaseIdentifier:*(void *)(a1 + 48)];
  id v15 = [*(id *)(a1 + 32) dataSource];
  id v16 = [v15 transactionWithServiceIdentifier:*(void *)(a1 + 56) transactionSourceIdentifier:v14];

  if (!v16)
  {
    id v17 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = *(void *)(a1 + 56);
      *(_DWORD *)id buf = 138543618;
      uint64_t v30 = v18;
      __int16 v31 = 2114;
      id v32 = v5;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Error finding a local transaction with service identifier: %{public}@ in zone %{public}@ aftering uploading it to CloudKit.", buf, 0x16u);
    }
  }
  [v16 addUpdateReasons:*(void *)(a1 + 64)];
  if ([*(id *)(a1 + 32) _isCloudStoreZoneThePrimaryZoneForCurrentUser:v12 containerDatabase:*(void *)(a1 + 40)])
  {
    [*(id *)(a1 + 32) dataSource];
    uint64_t v28 = v12;
    id v19 = v13;
    id v20 = v6;
    id v21 = v5;
    v23 = id v22 = v7;
    id v24 = [v16 serviceIdentifier];
    id v25 = [v23 transactionArchiveForTransactionWithServiceIdentifier:v24 transactionSourceIdentifier:v14];

    id v7 = v22;
    id v5 = v21;
    id v6 = v20;
    id v13 = v19;
    uint64_t v12 = v28;
    [v25 insertOrUpdateArchiveLocationWithCloudStoreZone:v28 isArchived:1 insertionMode:0];
  }
  else
  {
    id v25 = 0;
  }
  uint64_t v26 = [*(id *)(a1 + 32) dataSource];
  id v27 = [v26 insertOrUpdatePaymentTransaction:v16 withTransactionSourceIdentifier:v14 transactionArchive:v25 originDeviceID:0 insertionMode:1 performTruncation:0];
}

void sub_1000B4834(uint64_t a1, uint64_t a2, void *a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_1000B48C4;
  v5[3] = &unk_100733C18;
  id v4 = *(void **)(a1 + 40);
  void v5[4] = *(void *)(a1 + 32);
  id v6 = v4;
  [a3 enumerateKeysAndObjectsUsingBlock:v5];
}

void sub_1000B48C4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v8 = [v6 firstObject];
  id v9 = [*(id *)(a1 + 32) containerManager];
  id v10 = [v8 recordID];
  id v11 = [v10 zoneID];
  uint64_t v12 = [v9 cloudStoreZoneForZoneID:v11 inContainerDatabase:*(void *)(a1 + 40)];

  id v13 = [v6 firstObject];
  id v14 = [v13 recordID];
  id v15 = [v14 recordName];
  id v16 = +[PKPeerPaymentRecurringPayment recurringPaymentIdentifierFromRecordName:v15];

  if (v16)
  {
    id v17 = [*(id *)(a1 + 32) dataSource];
    uint64_t v18 = [v17 peerPaymentRecurringPaymentWithIdentifier:v16];

    if (v18)
    {
      id v27 = v7;
      id v19 = [*(id *)(a1 + 32) dataSource];
      id v20 = [v19 transactionArchiveForRecurringPayment:v18];

      [v20 insertOrUpdateArchiveLocationWithCloudStoreZone:v12 isArchived:1 insertionMode:0];
      id v21 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        id v22 = [v8 recordID];
        [v22 recordName];
        id v23 = v26 = v5;
        *(_DWORD *)id buf = 138543618;
        uint64_t v29 = v23;
        __int16 v30 = 2112;
        __int16 v31 = v20;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Record %{public}@ uploaded, updating archive %@", buf, 0x16u);

        id v5 = v26;
      }

      id v24 = [*(id *)(a1 + 32) dataSource];
      [v24 updateTransactionArchive:v20 forRecurringPayment:v18];

      id v7 = v27;
    }
    else
    {
      id v20 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138412290;
        uint64_t v29 = v16;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "No recurring payment on device with identifier %@", buf, 0xCu);
      }
    }
    goto LABEL_10;
  }
  uint64_t v18 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    id v25 = [v8 recordID];
    id v20 = [v25 recordName];
    *(_DWORD *)id buf = 138543362;
    uint64_t v29 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Couldn't get identifier from record %{public}@", buf, 0xCu);

LABEL_10:
  }
}

void sub_1000B4C08(uint64_t a1, uint64_t a2, void *a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_1000B4C98;
  v5[3] = &unk_100733C18;
  id v4 = *(void **)(a1 + 40);
  void v5[4] = *(void *)(a1 + 32);
  id v6 = v4;
  [a3 enumerateKeysAndObjectsUsingBlock:v5];
}

void sub_1000B4C98(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v8 = [v6 firstObject];
  id v9 = [*(id *)(a1 + 32) containerManager];
  id v10 = [v8 recordID];
  id v11 = [v10 zoneID];
  uint64_t v12 = [v9 cloudStoreZoneForZoneID:v11 inContainerDatabase:*(void *)(a1 + 40)];

  id v13 = [v6 firstObject];
  id v14 = [v13 recordID];
  id v15 = [v14 recordName];
  id v16 = +[PKPeerPaymentCounterpartImageData counterpartImageDataIdentifierFromRecordName:v15];

  if (v16)
  {
    id v17 = [*(id *)(a1 + 32) dataSource];
    uint64_t v18 = [v17 peerPaymentCounterpartImageDataWithIdentifier:v16];

    if (v18)
    {
      id v27 = v7;
      id v19 = [*(id *)(a1 + 32) dataSource];
      id v20 = [v19 transactionArchiveForCounterpartImageData:v18];

      [v20 insertOrUpdateArchiveLocationWithCloudStoreZone:v12 isArchived:1 insertionMode:0];
      id v21 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        id v22 = [v8 recordID];
        [v22 recordName];
        id v23 = v26 = v5;
        *(_DWORD *)id buf = 138543618;
        uint64_t v29 = v23;
        __int16 v30 = 2112;
        __int16 v31 = v20;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Record %{public}@ uploaded, updating archive %@", buf, 0x16u);

        id v5 = v26;
      }

      id v24 = [*(id *)(a1 + 32) dataSource];
      [v24 updateTransactionArchive:v20 forCounterpartImageData:v18];

      id v7 = v27;
    }
    else
    {
      id v20 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138543362;
        uint64_t v29 = v16;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "No counterpart image data on device with identifier %{public}@", buf, 0xCu);
      }
    }
    goto LABEL_10;
  }
  uint64_t v18 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    id v25 = [v8 recordID];
    id v20 = [v25 recordName];
    *(_DWORD *)id buf = 138543362;
    uint64_t v29 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Couldn't get identifier from record %{public}@", buf, 0xCu);

LABEL_10:
  }
}

void sub_1000B4FDC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [objc_alloc((Class)PDCloudStoreCounterpartRecordParser) initWithDataSource:*(void *)(a1 + 32)];
  [v7 addRecords:v6];

  if ([*(id *)(a1 + 40) returnRecords])
  {
    id v8 = *(void **)(a1 + 48);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_1000B5108;
    v9[3] = &unk_100733B00;
    void v9[4] = *(void *)(a1 + 32);
    id v10 = v7;
    id v11 = *(id *)(a1 + 40);
    id v12 = v5;
    id v13 = *(id *)(a1 + 56);
    [v8 addOperation:v9];
  }
}

void sub_1000B5108(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 56);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1000B5200;
  v15[3] = &unk_100733AD8;
  id v12 = *(id *)(a1 + 64);
  id v17 = v6;
  id v18 = v7;
  id v16 = v12;
  id v13 = v6;
  id v14 = v7;
  [v8 _processZoneShareLockWithRecordParser:v9 request:v10 databaseIdentifier:v11 completion:v15];
}

uint64_t sub_1000B5200(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) applyCloudRecordArray:a2];
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v3();
}

uint64_t sub_1000B524C(uint64_t a1)
{
  [*(id *)(a1 + 32) reportContainerChangeIntervalEndEventWithBeginUniqueIdentifier:*(void *)(a1 + 40) error:0];
  uint64_t result = *(void *)(a1 + 64);
  if (result)
  {
    id v3 = *(uint64_t (**)(void))(result + 16);
    return v3();
  }
  return result;
}

void sub_1000B6380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose((const void *)(v33 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1000B63A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  switch(*(void *)(a1 + 80))
  {
    case 0:
    case 1:
    case 2:
    case 7:
    case 8:
      goto LABEL_2;
    case 3:
      uint64_t v29 = *(void **)(*(void *)(a1 + 32) + 272);
      if (v29)
      {
        if ([v29 role] == (id)1)
        {
          *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 2;
          v47[0] = _NSConcreteStackBlock;
          v47[1] = 3221225472;
          v47[2] = sub_1000B6918;
          v47[3] = &unk_100730668;
          __int16 v30 = *(void **)(a1 + 32);
          id v31 = *(id *)(a1 + 40);
          uint64_t v32 = *(void *)(a1 + 64);
          id v48 = v31;
          uint64_t v50 = v32;
          id v49 = v3;
          objc_msgSend(v30, "_queue_familyMembersWithCompletion:", v47);

          uint64_t v28 = v48;
          goto LABEL_30;
        }
        uint64_t v38 = +[NSString stringWithFormat:@"Cannot share invitation for receipient %@ because the peer payment account is not a participant", *(void *)(a1 + 40)];
        uint64_t v39 = *(void *)(*(void *)(a1 + 64) + 8);
        uint64_t v40 = *(void **)(v39 + 40);
        *(void *)(v39 + 40) = v38;

        long long v36 = PKLogFacilityTypeGetObject();
        if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
LABEL_40:

LABEL_2:
          (*((void (**)(id, void, void))v3 + 2))(v3, 0, 0);
          goto LABEL_31;
        }
        uint64_t v41 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
        *(_DWORD *)id buf = 138543362;
        uint64_t v53 = v41;
      }
      else
      {
        uint64_t v33 = +[NSString stringWithFormat:@"Cannot share invitation for receipient %@ because the peer payment account is not defined", *(void *)(a1 + 40)];
        uint64_t v34 = *(void *)(*(void *)(a1 + 64) + 8);
        long long v35 = *(void **)(v34 + 40);
        *(void *)(v34 + 40) = v33;

        long long v36 = PKLogFacilityTypeGetObject();
        if (!os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_40;
        }
        uint64_t v37 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
        *(_DWORD *)id buf = 138543362;
        uint64_t v53 = v37;
      }
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      goto LABEL_40;
    case 4:
    case 5:
    case 6:
      *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 3;
      [*(id *)(*(void *)(a1 + 32) + 296) objectForKey:*(void *)(a1 + 48)];
      long long v43 = 0u;
      long long v44 = 0u;
      long long v45 = 0u;
      uint64_t v42 = v46 = 0u;
      id v4 = [v42 accountUsers];
      id v5 = [v4 countByEnumeratingWithState:&v43 objects:v51 count:16];
      if (!v5) {
        goto LABEL_25;
      }
      id v6 = v5;
      uint64_t v7 = *(void *)v44;
LABEL_5:
      id v8 = 0;
      break;
    default:
      goto LABEL_31;
  }
  do
  {
    if (*(void *)v44 != v7) {
      objc_enumerationMutation(v4);
    }
    uint64_t v9 = *(void **)(*((void *)&v43 + 1) + 8 * (void)v8);
    if (!*(void *)(a1 + 56)) {
      goto LABEL_19;
    }
    uint64_t v10 = [*(id *)(*((void *)&v43 + 1) + 8 * (void)v8) altDSID];
    uint64_t v11 = *(void **)(a1 + 56);
    id v12 = v10;
    id v13 = v11;
    if (v12 == v13)
    {
    }
    else
    {
      id v14 = v13;
      if (v12) {
        BOOL v15 = v13 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      if (v15)
      {

LABEL_18:
        if (*(void *)(a1 + 56)) {
          goto LABEL_23;
        }
LABEL_19:
        if (*(void *)(a1 + 80) != 4
          || [v9 accessLevel] != (id)1
          || ([v9 isCurrentUser] & 1) != 0)
        {
          goto LABEL_23;
        }
        goto LABEL_22;
      }
      unsigned __int8 v16 = [v12 isEqualToString:v13];

      if ((v16 & 1) == 0) {
        goto LABEL_18;
      }
    }
LABEL_22:
    id v17 = v9;
    if (v17)
    {
      id v23 = v17;

      id v24 = objc_alloc_init((Class)NSMutableSet);
      id v25 = [v23 appleID];
      objc_msgSend(v24, "pk_safelyAddObject:", v25);

      objc_msgSend(v24, "pk_safelyAddObject:", *(void *)(a1 + 40));
      id v26 = [v23 addressableHandles];
      [v24 unionSet:v26];

      id v27 = [v24 copy];
      (*((void (**)(id, uint64_t, id))v3 + 2))(v3, 1, v27);

      goto LABEL_29;
    }
LABEL_23:
    id v8 = (char *)v8 + 1;
  }
  while (v6 != v8);
  id v6 = [v4 countByEnumeratingWithState:&v43 objects:v51 count:16];
  if (v6) {
    goto LABEL_5;
  }
LABEL_25:

  uint64_t v18 = +[NSString stringWithFormat:@"Cannot share invitation for receipient %@ because they are not an account user", *(void *)(a1 + 40)];
  uint64_t v19 = *(void *)(*(void *)(a1 + 64) + 8);
  id v20 = *(void **)(v19 + 40);
  *(void *)(v19 + 40) = v18;

  id v21 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    *(_DWORD *)id buf = 138412290;
    uint64_t v53 = v22;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
  }

  (*((void (**)(id, void, void))v3 + 2))(v3, 0, 0);
LABEL_29:
  uint64_t v28 = v42;
LABEL_30:

LABEL_31:
}

void sub_1000B6918(uint64_t a1, void *a2)
{
  id v17 = _NSConcreteStackBlock;
  uint64_t v18 = 3221225472;
  uint64_t v19 = sub_1000B6B5C;
  id v20 = &unk_100733CE0;
  id v21 = *(id *)(a1 + 32);
  id v4 = objc_msgSend(a2, "pk_firstObjectPassingTest:", &v17);
  id v5 = v4;
  if (!v4)
  {
    uint64_t v8 = +[NSString stringWithFormat:@"Cannot share invitation for receipient %@ because they are not in the family", *(void *)(a1 + 32), v17, v18, v19, v20];
    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;

    uint64_t v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
      *(_DWORD *)id buf = 138543362;
      uint64_t v23 = v12;
LABEL_8:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
    }
LABEL_9:

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_10;
  }
  if (([v4 canSharePeerPaymentAccount] & 1) == 0)
  {
    uint64_t v13 = +[NSString stringWithFormat:@"Cannot share invitation for receipient %@ because they are not eligible to share a peer payment account", *(void *)(a1 + 32), v17, v18, v19, v20];
    uint64_t v14 = *(void *)(*(void *)(a1 + 48) + 8);
    BOOL v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = v13;

    uint64_t v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
      *(_DWORD *)id buf = 138543362;
      uint64_t v23 = v16;
      goto LABEL_8;
    }
    goto LABEL_9;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = +[NSSet setWithObject:*(void *)(a1 + 32)];
  (*(void (**)(uint64_t, uint64_t, void *))(v6 + 16))(v6, 1, v7);

LABEL_10:
}

id sub_1000B6B5C(uint64_t a1, void *a2)
{
  return [a2 hasAppleIDAlias:*(void *)(a1 + 32)];
}

void sub_1000B6B68(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = v5;
  if (a2)
  {
    if (!v5)
    {
      uint64_t v6 = +[NSSet setWithObject:*(void *)(a1 + 40)];
    }
    uint64_t v7 = [*(id *)(a1 + 32) containerManager];
    uint64_t v8 = [v7 databaseForScope:2];

    uint64_t v9 = [*(id *)(a1 + 32) containerManager];
    uint64_t v10 = [v9 cloudStoreZoneForZoneName:*(void *)(a1 + 48) inContainerDatabase:v8];

    if (v10)
    {
      uint64_t v11 = [v10 shareParticipantWithHandle:*(void *)(a1 + 40)];
      uint64_t v12 = PKLogFacilityTypeGetObject();
      uint64_t v13 = v12;
      if (!v11)
      {
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = *(void **)(a1 + 40);
          id v15 = [v6 count];
          uint64_t v16 = [v10 zoneName];
          *(_DWORD *)id buf = 138413058;
          id v65 = v14;
          __int16 v66 = 2048;
          id v67 = v15;
          __int16 v68 = 2112;
          long long v69 = v6;
          __int16 v70 = 2114;
          id v71 = v16;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Trying to find share participant with recipientHandle %@ and %lu known aliases %@ for zone %{public}@", buf, 0x2Au);
        }
        long long v61 = 0u;
        long long v62 = 0u;
        long long v59 = 0u;
        long long v60 = 0u;
        id v17 = v6;
        id v18 = [v17 countByEnumeratingWithState:&v59 objects:v63 count:16];
        if (v18)
        {
          id v19 = v18;
          uint64_t v42 = v8;
          uint64_t v20 = *(void *)v60;
          while (2)
          {
            for (uint64_t i = 0; i != v19; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v60 != v20) {
                objc_enumerationMutation(v17);
              }
              uint64_t v22 = [v10 shareParticipantWithHandle:*(void *)(*((void *)&v59 + 1) + 8 * i)];
              if (v22)
              {
                uint64_t v11 = (void *)v22;
                goto LABEL_22;
              }
            }
            id v19 = [v17 countByEnumeratingWithState:&v59 objects:v63 count:16];
            if (v19) {
              continue;
            }
            break;
          }
          uint64_t v11 = 0;
LABEL_22:
          uint64_t v8 = v42;
        }
        else
        {
          uint64_t v11 = 0;
        }
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = [v10 zoneName];
        *(_DWORD *)id buf = 138412546;
        id v65 = v11;
        __int16 v66 = 2114;
        id v67 = v28;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Zone share participant %@ for zone %{public}@", buf, 0x16u);
      }
      v55[0] = _NSConcreteStackBlock;
      v55[1] = 3221225472;
      v55[2] = sub_1000B718C;
      v55[3] = &unk_100733D58;
      uint64_t v29 = *(void **)(a1 + 40);
      void v55[4] = *(void *)(a1 + 32);
      id v56 = v29;
      id v30 = *(id *)(a1 + 48);
      uint64_t v31 = *(void *)(a1 + 72);
      id v57 = v30;
      uint64_t v58 = v31;
      uint64_t v32 = objc_retainBlock(v55);
      if (v11)
      {
        uint64_t v33 = [v11 invitationTokenData];
        if (v33)
        {
          uint64_t v41 = *(void **)(a1 + 32);
          long long v43 = v8;
          uint64_t v34 = *(void *)(a1 + 48);
          uint64_t v35 = PKCloudStoreOperationGroupSharingSetup;
          uint64_t v36 = PKCloudStoreOperationGroupSuffixShareInvitation;
          v46[0] = _NSConcreteStackBlock;
          v46[1] = 3221225472;
          v46[2] = sub_1000B72A4;
          v46[3] = &unk_100733D80;
          uint64_t v37 = (id *)&v51;
          id v51 = v32;
          id v52 = *(id *)(a1 + 56);
          id v38 = *(id *)(a1 + 48);
          uint64_t v39 = *(void *)(a1 + 32);
          id v47 = v38;
          uint64_t v48 = v39;
          id v49 = v10;
          id v50 = v33;
          uint64_t v40 = v34;
          uint64_t v8 = v43;
          [v41 shareForZoneName:v40 operationGroupName:v35 operationGroupNameSuffix:v36 qualityOfService:17 completion:v46];
        }
        else
        {
          v53[0] = _NSConcreteStackBlock;
          v53[1] = 3221225472;
          v53[2] = sub_1000B7288;
          v53[3] = &unk_100733D30;
          uint64_t v37 = &v54;
          id v54 = *(id *)(a1 + 56);
          ((void (*)(void *, void *))v32[2])(v32, v53);
        }
      }
      else
      {
        v44[0] = _NSConcreteStackBlock;
        v44[1] = 3221225472;
        v44[2] = sub_1000B75A0;
        v44[3] = &unk_100733D30;
        id v45 = *(id *)(a1 + 56);
        ((void (*)(void *, void *))v32[2])(v32, v44);
        uint64_t v33 = v45;
      }
    }
    else
    {
      uint64_t v11 = +[NSString stringWithFormat:@"There is no cloud store zone with name %@ that can be shared with %@, recipientAliases: %@", *(void *)(a1 + 48), *(void *)(a1 + 40), v6];
      id v25 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138412290;
        id v65 = v11;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
      }

      uint64_t v26 = *(void *)(a1 + 56);
      id v27 = [*(id *)(a1 + 32) errorWithCode:-4001 description:v11];
      (*(void (**)(uint64_t, void, void, void *))(v26 + 16))(v26, 0, 0, v27);
    }
  }
  else
  {
    uint64_t v23 = *(void *)(a1 + 56);
    id v24 = [*(id *)(a1 + 32) errorWithCode:-4014 description:*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40)];
    (*(void (**)(uint64_t, void, void, void *))(v23 + 16))(v23, 0, 0, v24);
  }
}

void sub_1000B718C(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = (void *)a1[4];
  uint64_t v5 = a1[5];
  uint64_t v6 = a1[6];
  uint64_t v7 = *(void *)(*(void *)(a1[7] + 8) + 24);
  uint64_t v8 = PKCloudStoreOperationGroupSharingSetup;
  uint64_t v9 = PKCloudStoreOperationGroupSuffixShareInvitation;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1000B7278;
  void v11[3] = &unk_100733D30;
  id v12 = v3;
  id v10 = v3;
  [v4 createShareInvitationForRecipientHandle:v5 zoneName:v6 permission:v7 operationGroupName:v8 operationGroupNameSuffix:v9 qualityOfService:17 completion:v11];
}

uint64_t sub_1000B7278(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000B7288(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B72A4(uint64_t a1, void *a2, int a3, void *a4)
{
  id v7 = a4;
  uint64_t v8 = [a2 allRecordsWithRecordType:CKRecordTypeShare];
  uint64_t v9 = [v8 anyObject];

  uint64_t v10 = objc_msgSend(v9, "pk_share");
  uint64_t v11 = (void *)v10;
  if (v10) {
    BOOL v12 = 1;
  }
  else {
    BOOL v12 = a3 == 0;
  }
  if (v12)
  {
    if (v7 || !v10)
    {
      id v13 = +[NSString stringWithFormat:@"Error fetching share from zone %@, %@", *(void *)(a1 + 32), v7];
      id v19 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138412290;
        id v25 = v13;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
      }

      uint64_t v20 = *(void *)(a1 + 72);
      if (v7)
      {
        (*(void (**)(void, uint64_t, void, id))(v20 + 16))(*(void *)(a1 + 72), 1, 0, v7);
      }
      else
      {
        id v21 = [*(id *)(a1 + 40) errorWithCode:-4000 description:v13];
        (*(void (**)(uint64_t, uint64_t, void, void *))(v20 + 16))(v20, 1, 0, v21);
      }
    }
    else
    {
      id v13 = objc_alloc_init((Class)PKCloudStoreZoneInvitation);
      uint64_t v14 = [v11 URL];
      [v13 setShareURL:v14];

      id v15 = +[NSDate date];
      [v13 setDateCreated:v15];

      uint64_t v16 = [*(id *)(a1 + 48) zoneName];
      [v13 setZoneName:v16];

      id v17 = [*(id *)(a1 + 48) containerName];
      [v13 setContainerIdentifier:v17];

      [v13 setShareInvitationToken:*(void *)(a1 + 56)];
      (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
    }
  }
  else
  {
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472;
    v22[2] = sub_1000B7584;
    void v22[3] = &unk_100733D30;
    uint64_t v18 = *(void *)(a1 + 64);
    id v23 = *(id *)(a1 + 72);
    (*(void (**)(uint64_t, void *))(v18 + 16))(v18, v22);
  }
}

uint64_t sub_1000B7584(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000B75A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B7728(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v41 objects:v46 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v42;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v42 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v41 + 1) + 8 * i);
        if ([v8 hasAppleIDAlias:*(void *)(a1 + 32)])
        {
          uint64_t v9 = *(void **)(a1 + 40);
          uint64_t v10 = [v8 appleIDAliases];
          [v9 unionSet:v10];
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v41 objects:v46 count:16];
    }
    while (v5);
  }
  unint64_t v11 = *(void *)(a1 + 72);
  BOOL v12 = v11 > 6;
  uint64_t v13 = (1 << v11) & 0x74;
  if (v12 || v13 == 0) {
    goto LABEL_35;
  }
  [*(id *)(*(void *)(a1 + 48) + 296) objectForKey:*(void *)(a1 + 56)];
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  uint64_t v36 = v40 = 0u;
  id v15 = [v36 accountUsers];
  id v16 = [v15 countByEnumeratingWithState:&v37 objects:v45 count:16];
  if (!v16) {
    goto LABEL_34;
  }
  id v17 = v16;
  uint64_t v18 = *(void *)v38;
  while (2)
  {
    for (uint64_t j = 0; j != v17; uint64_t j = (char *)j + 1)
    {
      if (*(void *)v38 != v18) {
        objc_enumerationMutation(v15);
      }
      uint64_t v20 = *(void **)(*((void *)&v37 + 1) + 8 * (void)j);
      id v21 = [v20 appleID];
      uint64_t v22 = *(void **)(a1 + 32);
      id v23 = v21;
      id v24 = v22;
      if (v23 == v24)
      {
      }
      else
      {
        id v25 = v24;
        if (v23) {
          BOOL v26 = v24 == 0;
        }
        else {
          BOOL v26 = 1;
        }
        if (v26)
        {

LABEL_28:
          if (![v20 hasHandle:*(void *)(a1 + 32)]) {
            continue;
          }
          goto LABEL_29;
        }
        unsigned __int8 v27 = [v23 isEqualToString:v24];

        if ((v27 & 1) == 0) {
          goto LABEL_28;
        }
      }
LABEL_29:
      id v28 = v20;
      if (v28)
      {
        uint64_t v29 = v28;
        id v30 = *(void **)(a1 + 40);
        uint64_t v31 = [v28 appleID];
        [v30 addObject:v31];

        uint64_t v32 = *(void **)(a1 + 40);
        uint64_t v33 = [v29 addressableHandles];
        [v32 unionSet:v33];

        goto LABEL_34;
      }
    }
    id v17 = [v15 countByEnumeratingWithState:&v37 objects:v45 count:16];
    if (v17) {
      continue;
    }
    break;
  }
LABEL_34:

LABEL_35:
  uint64_t v34 = *(void *)(a1 + 64);
  id v35 = [*(id *)(a1 + 40) copy];
  (*(void (**)(uint64_t, id))(v34 + 16))(v34, v35);
}

id sub_1000B7BC4(uint64_t a1)
{
  [*(id *)(a1 + 32) ensureZoneShareIntegrity];
  [*(id *)(a1 + 32) _updateFetchTaskScheduledActivityIfNeccessary];
  id v2 = *(void **)(a1 + 32);
  return [v2 _updateUnarchivedTransactionsScheduledActivityIfNeccessary];
}

void sub_1000B86F0(_Unwind_Exception *a1)
{
}

id sub_1000B872C(id a1, PKCloudStoreZone *a2)
{
  return [(PKCloudStoreZone *)a2 zoneName];
}

void sub_1000B8734(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1000B8818;
  v13[3] = &unk_100733E38;
  id v10 = *(id *)(a1 + 48);
  id v15 = v6;
  id v16 = v7;
  id v14 = v10;
  id v11 = v6;
  id v12 = v7;
  [v8 initialCloudDatabaseSetupWithOperationGroupNameSuffix:v9 completion:v13];
}

void sub_1000B8818(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if ((a2 & 1) == 0)
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v8 = 138412290;
      uint64_t v9 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Could not proactively fetching cloudkit transaction changes for transactionSourceIdentifier %@ because the cloud store failed to initalize.", (uint8_t *)&v8, 0xCu);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1000B88F4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  int v8 = [*(id *)(a1 + 32) zoneName];
  if (v8)
  {
    uint64_t v9 = [*(id *)(a1 + 32) zoneName];
    long long v39 = v9;
    id v10 = +[NSArray arrayWithObjects:&v39 count:1];
  }
  else
  {
    id v10 = 0;
  }

  id v11 = [*(id *)(a1 + 40) reportContainerChangeIntervalBeginEventWithType:37 stateName:0 objectNames:v10 operationGroupName:0 operationGroupNameSuffix:*(void *)(a1 + 48)];
  id v12 = [*(id *)(a1 + 40) containerManager];
  uint64_t v13 = [v12 fetchTimestampForCloudStoreStore:*(void *)(a1 + 32)];

  id v14 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = *(void *)(a1 + 56);
    id v16 = [*(id *)(a1 + 64) count];
    uint64_t v17 = *(void *)(a1 + 64);
    *(_DWORD *)id buf = 138413058;
    uint64_t v32 = v15;
    __int16 v33 = 2114;
    uint64_t v34 = v13;
    __int16 v35 = 2048;
    id v36 = v16;
    __int16 v37 = 2112;
    uint64_t v38 = v17;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Proactively fetching cloudkit transaction changes for transactionSourceIdentifier %@. oldestFetchDate: %{public}@. In %lu zones: %@", buf, 0x2Au);
  }

  uint64_t v18 = [(PDCloudStoreRecordsRequest *)[PDApplePayCloudStoreRecordsRequest alloc] initWithRequestType:0 storeChanges:1 returnRecords:0 qualityOfService:17 groupName:*(void *)(a1 + 72) groupNameSuffix:*(void *)(a1 + 48)];
  [(PDCloudStoreRecordsRequest *)v18 setUseLastChangeToken:1];
  [(PDCloudStoreRecordsRequest *)v18 setShouldSaveToken:1];
  if (*(void *)(a1 + 32))
  {
    -[PDCloudStoreRecordsRequest setCloudStoreZone:](v18, "setCloudStoreZone:");
    id v19 = [*(id *)(a1 + 40) containerManager];
    uint64_t v20 = [v19 databaseForCloudStoreZone:*(void *)(a1 + 32)];
    [(PDCloudStoreRecordsRequest *)v18 setContainerDatabase:v20];
  }
  id v21 = *(void **)(a1 + 40);
  v26[0] = _NSConcreteStackBlock;
  v26[1] = 3221225472;
  v26[2] = sub_1000B8BCC;
  v26[3] = &unk_100733E88;
  uint64_t v22 = *(void *)(a1 + 80);
  id v29 = v7;
  uint64_t v30 = v22;
  v26[4] = v21;
  id v27 = v11;
  id v28 = v6;
  id v23 = v6;
  id v24 = v7;
  id v25 = v11;
  [v21 executeRecordsRequest:v18 completion:v26];
}

void sub_1000B8BCC(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 64) + 8);
  int v8 = *(void **)(v5 + 40);
  id v6 = (id *)(v5 + 40);
  id v7 = v8;
  if (v8) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = a3;
  }
  objc_storeStrong(v6, v9);
  id v10 = a3;
  [*(id *)(a1 + 32) reportContainerChangeIntervalEndEventWithBeginUniqueIdentifier:*(void *)(a1 + 40) error:v10];
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_1000B8C4C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = a4;
  id v6 = [*(id *)(a1 + 32) workQueue];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000B8D20;
  v10[3] = &unk_100733ED8;
  id v11 = v5;
  id v7 = *(id *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 32);
  id v12 = v7;
  uint64_t v13 = v8;
  uint64_t v14 = *(void *)(a1 + 48);
  id v9 = v5;
  dispatch_async(v6, v10);
}

id sub_1000B8D20(uint64_t a1)
{
  if (([*(id *)(a1 + 32) isCanceled] & 1) == 0)
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 40);
      int v5 = 138412290;
      uint64_t v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Proactive cloudkit transaction change fetch completed for transactionSourceIdentifier %@.", (uint8_t *)&v5, 0xCu);
    }
  }
  return [*(id *)(a1 + 48) _fetchTaskOperationWithIdentifier:*(void *)(a1 + 40) completedWithError:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)];
}

void sub_1000B8F04(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    *(void *)&long long v60 = 0;
    *((void *)&v60 + 1) = &v60;
    uint64_t v61 = 0x3032000000;
    long long v62 = sub_10002083C;
    long long v63 = sub_100020F10;
    id v64 = 0;
    id v31 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
    if (*(unsigned char *)(a1 + 64) || *(unsigned char *)(a1 + 65)) {
      id v30 = objc_alloc_init((Class)PKCloudRecordArray);
    }
    else {
      id v30 = 0;
    }
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    id obj = *(id *)(a1 + 48);
    id v26 = [obj countByEnumeratingWithState:&v47 objects:v59 count:16];
    if (v26)
    {
      uint64_t v25 = *(void *)v48;
      uint64_t v2 = PKCloudStoreOperationGroupSuffixModificationSync;
      uint64_t v29 = PKCloudStoreOperationGroupBackgroundSync;
      do
      {
        for (uint64_t i = 0; i != v26; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v48 != v25) {
            objc_enumerationMutation(obj);
          }
          uint64_t v3 = *(void *)(*((void *)&v47 + 1) + 8 * i);
          id v4 = [*(id *)(a1 + 40) _allPossibleCloudStoreZonesForFetchingWithTransactionSourceIdentifier:v3];
          long long v45 = 0u;
          long long v46 = 0u;
          long long v43 = 0u;
          long long v44 = 0u;
          id v28 = v4;
          id v5 = [v28 countByEnumeratingWithState:&v43 objects:v58 count:16];
          if (v5)
          {
            uint64_t v6 = *(void *)v44;
            do
            {
              for (uint64_t j = 0; j != v5; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v44 != v6) {
                  objc_enumerationMutation(v28);
                }
                uint64_t v8 = *(void **)(*((void *)&v43 + 1) + 8 * (void)j);
                id v9 = PKLogFacilityTypeGetObject();
                if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v10 = *(void *)(a1 + 32);
                  id v11 = [v8 zoneName];
                  *(_DWORD *)id buf = 138543874;
                  uint64_t v53 = v10;
                  __int16 v54 = 2112;
                  uint64_t v55 = v3;
                  __int16 v56 = 2114;
                  id v57 = v11;
                  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Fetching recently modified transactions from date %{public}@ for transactionSourceIdentifier: %@. In zone %{public}@", buf, 0x20u);
                }
                id v12 = [v8 zoneName];
                if (v12)
                {
                  uint64_t v13 = [v8 zoneName];
                  id v51 = v13;
                  uint64_t v14 = +[NSArray arrayWithObjects:&v51 count:1];
                }
                else
                {
                  uint64_t v14 = 0;
                }

                uint64_t v15 = [*(id *)(a1 + 40) reportContainerChangeIntervalBeginEventWithType:38 stateName:0 objectNames:v14 operationGroupName:v29 operationGroupNameSuffix:v2];
                v36[0] = _NSConcreteStackBlock;
                v36[1] = 3221225472;
                v36[2] = sub_1000B94CC;
                v36[3] = &unk_100733F78;
                char v41 = *(unsigned char *)(a1 + 64);
                uint64_t v17 = *(void **)(a1 + 32);
                uint64_t v16 = *(void *)(a1 + 40);
                void v36[4] = v3;
                v36[5] = v16;
                v36[6] = v8;
                id v37 = v17;
                char v42 = *(unsigned char *)(a1 + 65);
                id v18 = v15;
                id v38 = v18;
                id v39 = v30;
                long long v40 = &v60;
                [v31 addOperation:v36];
              }
              id v5 = [v28 countByEnumeratingWithState:&v43 objects:v58 count:16];
            }
            while (v5);
          }
        }
        id v26 = [obj countByEnumeratingWithState:&v47 objects:v59 count:16];
      }
      while (v26);
    }

    id v19 = +[NSNull null];
    v32[0] = _NSConcreteStackBlock;
    v32[1] = 3221225472;
    v32[2] = sub_1000B9930;
    v32[3] = &unk_100733FA0;
    id v34 = *(id *)(a1 + 56);
    id v20 = v30;
    id v33 = v20;
    __int16 v35 = &v60;
    id v21 = [v31 evaluateWithInput:v19 completion:v32];

    _Block_object_dispose(&v60, 8);
    goto LABEL_29;
  }
  uint64_t v22 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v60) = 138412290;
    *(void *)((char *)&v60 + 4) = @"Cannot perform backgroundRecordSyncForTranasctionSourceIdentifiers: since fromDate is not defined";
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&v60, 0xCu);
  }

  uint64_t v23 = *(void *)(a1 + 56);
  if (v23)
  {
    id v20 = [*(id *)(a1 + 40) errorWithCode:-1 description:@"Cannot perform backgroundRecordSyncForTranasctionSourceIdentifiers: since fromDate is not defined"];
    (*(void (**)(uint64_t, void, id))(v23 + 16))(v23, 0, v20);
LABEL_29:
  }
}

void sub_1000B9484(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1000B94CC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = +[NSSet setWithObject:*(void *)(a1 + 32)];
  id v9 = [PDApplePayCloudStoreRecordsRequest alloc];
  uint64_t v10 = [(PDCloudStoreRecordsRequest *)v9 initWithRequestType:3 storeChanges:1 returnRecords:*(unsigned __int8 *)(a1 + 88) qualityOfService:17 groupName:PKCloudStoreOperationGroupBackgroundSync groupNameSuffix:PKCloudStoreOperationGroupSuffixModificationSync];
  [(PDApplePayCloudStoreRecordsRequest *)v10 setTransactionSourceIdentifiers:v8];
  id v11 = [*(id *)(a1 + 40) containerManager];
  id v12 = [v11 databaseForCloudStoreZone:*(void *)(a1 + 48)];

  [(PDCloudStoreRecordsRequest *)v10 setCloudStoreZone:*(void *)(a1 + 48)];
  [(PDCloudStoreRecordsRequest *)v10 setContainerDatabase:v12];
  [(PDCloudStoreRecordsRequest *)v10 setIgnoreRecordsBeforeDate:*(void *)(a1 + 56)];
  [(PDCloudStoreRecordsRequest *)v10 setFormReport:*(unsigned __int8 *)(a1 + 89)];
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_1000B96A8;
  v20[3] = &unk_100733F50;
  uint64_t v13 = *(void *)(a1 + 32);
  id v21 = *(id *)(a1 + 40);
  uint64_t v22 = v13;
  id v14 = *(id *)(a1 + 56);
  uint64_t v15 = *(void *)(a1 + 48);
  id v23 = v14;
  uint64_t v24 = v15;
  id v25 = *(id *)(a1 + 64);
  id v16 = *(id *)(a1 + 72);
  uint64_t v17 = *(void *)(a1 + 80);
  id v28 = v7;
  uint64_t v29 = v17;
  id v26 = v16;
  id v27 = v6;
  id v18 = v6;
  id v19 = v7;
  [v21 executeRecordsRequest:v10 completion:v20];
}

void sub_1000B96A8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [*(id *)(a1 + 32) workQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000B97F4;
  block[3] = &unk_100733F28;
  uint64_t v8 = *(void **)(a1 + 48);
  void block[4] = *(void *)(a1 + 40);
  id v9 = v8;
  uint64_t v10 = *(void *)(a1 + 56);
  id v11 = *(void **)(a1 + 64);
  id v17 = v9;
  uint64_t v18 = v10;
  uint64_t v19 = *(void *)(a1 + 32);
  id v20 = v11;
  id v21 = v6;
  id v22 = *(id *)(a1 + 72);
  id v23 = v5;
  long long v15 = *(_OWORD *)(a1 + 88);
  id v12 = (id)v15;
  long long v25 = v15;
  id v24 = *(id *)(a1 + 80);
  id v13 = v5;
  id v14 = v6;
  dispatch_async(v7, block);
}

uint64_t sub_1000B97F4(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    id v5 = [*(id *)(a1 + 48) zoneName];
    int v13 = 138412802;
    uint64_t v14 = v3;
    __int16 v15 = 2114;
    uint64_t v16 = v4;
    __int16 v17 = 2114;
    uint64_t v18 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finished fetching recently modified transactions for transactionSourceIdentifier: %@ from date %{public}@. In zone %{public}@", (uint8_t *)&v13, 0x20u);
  }
  [*(id *)(a1 + 56) reportContainerChangeIntervalEndEventWithBeginUniqueIdentifier:*(void *)(a1 + 64) error:*(void *)(a1 + 72)];
  id v6 = *(void **)(a1 + 80);
  id v7 = [*(id *)(a1 + 88) cloudStoreRecords];
  [v6 applyCloudRecordArray:v7];

  uint64_t v8 = *(void *)(*(void *)(a1 + 112) + 8);
  id v11 = *(void **)(v8 + 40);
  id v9 = (id *)(v8 + 40);
  uint64_t v10 = v11;
  if (!v11) {
    uint64_t v10 = *(void **)(a1 + 72);
  }
  objc_storeStrong(v9, v10);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 104) + 16))();
}

uint64_t sub_1000B9930(void *a1)
{
  uint64_t result = a1[5];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void, void))(result + 16))(result, a1[4], *(void *)(*(void *)(a1[6] + 8) + 40));
  }
  return result;
}

void sub_1000B9A34(id *a1)
{
  v53[0] = 0;
  v53[1] = v53;
  v53[2] = 0x3032000000;
  v53[3] = sub_10002083C;
  void v53[4] = sub_100020F10;
  id v54 = 0;
  id v29 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
  uint64_t v1 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    id v2 = a1[4];
    *(_DWORD *)id buf = 138412290;
    long long v59 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Background fetching record changes for transactionSourceIdentifiers: %@", buf, 0xCu);
  }
  oslog = v1;

  id v3 = objc_alloc_init((Class)NSMutableDictionary);
  id v27 = objc_alloc_init((Class)NSMutableSet);
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  id obj = a1[4];
  id v4 = [obj countByEnumeratingWithState:&v49 objects:v57 count:16];
  if (v4)
  {
    uint64_t v26 = *(void *)v50;
    do
    {
      id v28 = v4;
      for (uint64_t i = 0; i != v28; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v50 != v26) {
          objc_enumerationMutation(obj);
        }
        uint64_t v6 = *(void *)(*((void *)&v49 + 1) + 8 * i);
        id v7 = [a1[5] _allPossibleCloudStoreZonesForFetchingWithTransactionSourceIdentifier:v6];
        long long v47 = 0u;
        long long v48 = 0u;
        long long v45 = 0u;
        long long v46 = 0u;
        id v8 = v7;
        id v9 = [v8 countByEnumeratingWithState:&v45 objects:v56 count:16];
        if (v9)
        {
          uint64_t v10 = *(void *)v46;
          do
          {
            for (uint64_t j = 0; j != v9; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v46 != v10) {
                objc_enumerationMutation(v8);
              }
              uint64_t v12 = *(void *)(*((void *)&v45 + 1) + 8 * (void)j);
              id v13 = [v3 objectForKeyedSubscript:v12];
              if (!v13)
              {
                id v13 = objc_alloc_init((Class)NSMutableSet);
                [v3 setObject:v13 forKeyedSubscript:v12];
              }
              [v13 addObject:v6];
            }
            id v9 = [v8 countByEnumeratingWithState:&v45 objects:v56 count:16];
          }
          while (v9);
        }

        [v27 unionSet:v8];
      }
      id v4 = [obj countByEnumeratingWithState:&v49 objects:v57 count:16];
    }
    while (v4);
  }

  long long v43 = 0u;
  long long v44 = 0u;
  long long v42 = 0u;
  long long v41 = 0u;
  id v14 = v27;
  id v15 = [v14 countByEnumeratingWithState:&v41 objects:v55 count:16];
  if (v15)
  {
    uint64_t v16 = *(void *)v42;
    do
    {
      for (k = 0; k != v15; k = (char *)k + 1)
      {
        if (*(void *)v42 != v16) {
          objc_enumerationMutation(v14);
        }
        uint64_t v18 = *(void **)(*((void *)&v41 + 1) + 8 * (void)k);
        uint64_t v19 = oslog;
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
        {
          id v20 = [v18 zoneName];
          *(_DWORD *)id buf = 138543362;
          long long v59 = v20;
          _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Background fetching record starting for zone: %{public}@", buf, 0xCu);

          uint64_t v19 = oslog;
        }

        v35[0] = _NSConcreteStackBlock;
        v35[1] = 3221225472;
        v35[2] = sub_1000B9FA4;
        v35[3] = &unk_100734040;
        id v21 = a1[4];
        id v22 = a1[5];
        id v36 = v21;
        id v37 = v22;
        id v38 = v18;
        id v39 = v3;
        long long v40 = v53;
        [v29 addOperation:v35];
      }
      id v15 = [v14 countByEnumeratingWithState:&v41 objects:v55 count:16];
    }
    while (v15);
  }

  id v23 = +[NSNull null];
  v32[0] = _NSConcreteStackBlock;
  v32[1] = 3221225472;
  v32[2] = sub_1000BA36C;
  v32[3] = &unk_10072E660;
  id v33 = a1[6];
  id v34 = v53;
  id v24 = [v29 evaluateWithInput:v23 completion:v32];

  _Block_object_dispose(v53, 8);
}

void sub_1000B9F4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
}

void sub_1000B9FA4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [PDApplePayCloudStoreRecordsRequest alloc];
  id v9 = [(PDCloudStoreRecordsRequest *)v8 initWithRequestType:0 storeChanges:1 returnRecords:0 qualityOfService:17 groupName:PKCloudStoreOperationGroupBackgroundSync groupNameSuffix:PKCloudStoreOperationGroupSuffixBackgroundRecordChangesSync];
  [(PDApplePayCloudStoreRecordsRequest *)v9 setTransactionSourceIdentifiers:*(void *)(a1 + 32)];
  uint64_t v10 = [*(id *)(a1 + 40) containerManager];
  id v11 = [v10 databaseForCloudStoreZone:*(void *)(a1 + 48)];

  [(PDCloudStoreRecordsRequest *)v9 setCloudStoreZone:*(void *)(a1 + 48)];
  [(PDCloudStoreRecordsRequest *)v9 setContainerDatabase:v11];
  [(PDCloudStoreRecordsRequest *)v9 setUseLastChangeToken:1];
  [(PDCloudStoreRecordsRequest *)v9 setShouldSaveToken:1];
  uint64_t v12 = *(void **)(a1 + 40);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1000BA138;
  v18[3] = &unk_100734018;
  void v18[4] = v12;
  id v13 = *(id *)(a1 + 56);
  uint64_t v14 = *(void *)(a1 + 48);
  id v19 = v13;
  uint64_t v20 = v14;
  uint64_t v15 = *(void *)(a1 + 64);
  id v22 = v7;
  uint64_t v23 = v15;
  id v21 = v6;
  id v16 = v6;
  id v17 = v7;
  [v12 executeRecordsRequest:v9 completion:v18];
}

void sub_1000BA138(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = [*(id *)(a1 + 32) workQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BA238;
  block[3] = &unk_100733FF0;
  id v6 = *(id *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  id v12 = v6;
  uint64_t v13 = v7;
  id v14 = v4;
  long long v10 = *(_OWORD *)(a1 + 64);
  id v8 = (id)v10;
  long long v16 = v10;
  id v15 = *(id *)(a1 + 56);
  id v9 = v4;
  dispatch_async(v5, block);
}

void sub_1000BA238(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) objectForKeyedSubscript:*(void *)(a1 + 40)];
  id v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [*(id *)(a1 + 40) zoneName];
    id v5 = [v2 count];
    uint64_t v6 = *(void *)(a1 + 48);
    int v11 = 138544130;
    id v12 = v4;
    __int16 v13 = 2048;
    id v14 = v5;
    __int16 v15 = 2112;
    long long v16 = v2;
    __int16 v17 = 2112;
    uint64_t v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finished fetching background record changes zone: %{public}@. For %lu transaction source identifiers %@. error %@.", (uint8_t *)&v11, 0x2Au);
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 72) + 8);
  long long v10 = *(void **)(v7 + 40);
  id v8 = (id *)(v7 + 40);
  id v9 = v10;
  if (!v10) {
    id v9 = *(void **)(a1 + 48);
  }
  objc_storeStrong(v8, v9);
  (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
}

uint64_t sub_1000BA36C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
  }
  return result;
}

void sub_1000BB2CC(_Unwind_Exception *a1)
{
}

id sub_1000BB340(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) _fetchTaskOperationWithIdentifier:a2 completedWithError:a3];
}

void sub_1000BB350(uint64_t a1, uint64_t a2, uint64_t a3)
{
  [*(id *)(a1 + 32) reportContainerChangeIntervalEndEventWithBeginUniqueIdentifier:*(void *)(a1 + 40) error:a3];
  id v4 = *(NSObject **)(a1 + 48);
  dispatch_group_leave(v4);
}

void sub_1000BB394(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(NSObject **)(a1 + 32);
  id v9 = [*(id *)(a1 + 40) workQueue];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_1000BB46C;
  void v12[3] = &unk_10072E598;
  id v13 = v6;
  id v14 = v7;
  id v10 = v6;
  id v11 = v7;
  dispatch_group_notify(v8, v9, v12);
}

uint64_t sub_1000BB46C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_1000BB484(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = *(os_unfair_lock_s **)(a1 + 32);
  if (*(unsigned char *)(a1 + 72))
  {
    uint64_t v26 = v9;
    id v27 = v8;
    id v28 = v7;
    os_unfair_lock_lock(v10 + 54);
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    id obj = *(id *)(a1 + 40);
    id v11 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v31;
      do
      {
        for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v31 != v13) {
            objc_enumerationMutation(obj);
          }
          uint64_t v15 = *(void *)(*((void *)&v30 + 1) + 8 * i);
          __int16 v17 = [*(id *)(*(void *)(a1 + 32) + 208) objectForKeyedSubscript:v15];
          uint64_t v18 = [(PDApplePayCloudStoreRecordFetchOperation *)v17 task];
          if (![*(id *)(a1 + 48) containsObject:v15]
            || [v18 status] != (id)2
            || [v18 type] != (id)1)
          {
            id v19 = [objc_alloc((Class)PKCloudStoreRecordFetchTask) initWithTransactionSourceIdentifier:v15 type:1];

            if (!v17) {
              __int16 v17 = objc_alloc_init(PDApplePayCloudStoreRecordFetchOperation);
            }
            [(PDApplePayCloudStoreRecordFetchOperation *)v17 updateTask:v19];
            uint64_t v20 = *(void **)(*(void *)(a1 + 32) + 208);
            id v21 = [(PDApplePayCloudStoreRecordFetchOperation *)v17 identifier];
            [v20 safelySetObject:v17 forKey:v21];

            [v19 startTask];
            id v22 = [*(id *)(a1 + 32) dataSource];
            [v22 updateRecordFetchTask:v19];

            objc_msgSend(*(id *)(a1 + 56), "pk_safelyAddObject:", v15);
            uint64_t v18 = v19;
          }
        }
        id v12 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
      }
      while (v12);
    }

    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
    id v9 = v26;
    id v8 = v27;
    v26[2](v26, v27, 0);
    id v7 = v28;
  }
  else
  {
    uint64_t v23 = [(os_unfair_lock_s *)v10 setupAssistantNotCompleteError];
    uint64_t v24 = *(void *)(*(void *)(a1 + 64) + 8);
    long long v25 = *(void **)(v24 + 40);
    *(void *)(v24 + 40) = v23;

    v9[2](v9, v8, 1);
  }
}

void sub_1000BB754(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1000BB838;
  v13[3] = &unk_100733E38;
  id v10 = *(id *)(a1 + 48);
  id v15 = v6;
  id v16 = v7;
  id v14 = v10;
  id v11 = v6;
  id v12 = v7;
  [v8 initialCloudDatabaseSetupWithOperationGroupNameSuffix:v9 completion:v13];
}

void sub_1000BB838(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if (v5) {
    char v6 = 0;
  }
  else {
    char v6 = a2;
  }
  if (v6)
  {
    id v7 = 0;
  }
  else
  {
    id v7 = v5;
    if (!v5)
    {
      id v8 = +[NSString stringWithFormat:@"Could not setup the cloud store container: %@", 0];
      v16[0] = NSLocalizedDescriptionKey;
      v16[1] = NSLocalizedFailureReasonErrorKey;
      v17[0] = v8;
      v17[1] = v8;
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:v17 forKeys:v16 count:2];
      id v7 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-5001 userInfo:v9];
    }
    id v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      *(_DWORD *)id buf = 138412546;
      uint64_t v13 = v7;
      __int16 v14 = 2112;
      uint64_t v15 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Error setting up cloud store container after pass provisioning: %@, transactionSourceIdentifiers: %@", buf, 0x16u);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1000BB9D4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [*(id *)(a1 + 32) workQueue];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1000BBB34;
  v13[3] = &unk_1007340E0;
  uint64_t v9 = *(void **)(a1 + 40);
  void v13[4] = *(void *)(a1 + 32);
  id v14 = v9;
  id v15 = *(id *)(a1 + 48);
  id v16 = *(id *)(a1 + 56);
  id v17 = *(id *)(a1 + 64);
  id v18 = *(id *)(a1 + 72);
  id v19 = *(id *)(a1 + 80);
  uint64_t v10 = *(void *)(a1 + 104);
  id v22 = v7;
  uint64_t v23 = v10;
  long long v20 = *(_OWORD *)(a1 + 88);
  id v21 = v6;
  id v11 = v6;
  id v12 = v7;
  dispatch_async(v8, v13);
}

void sub_1000BBB34(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 264) transactionFetchInitiatedForPassUniqueID:*(void *)(a1 + 40)];
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  id obj = *(id *)(a1 + 48);
  id v42 = [obj countByEnumeratingWithState:&v47 objects:v63 count:16];
  if (v42)
  {
    uint64_t v41 = *(void *)v48;
    do
    {
      for (uint64_t i = 0; i != v42; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v48 != v41) {
          objc_enumerationMutation(obj);
        }
        uint64_t v3 = *(void *)(*((void *)&v47 + 1) + 8 * i);
        id v4 = [*(id *)(a1 + 32) _allPossibleCloudStoreZonesForFetchingWithTransactionSourceIdentifier:v3];
        long long v43 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        long long v46 = 0u;
        id v5 = [v4 countByEnumeratingWithState:&v43 objects:v62 count:16];
        if (v5)
        {
          id v6 = v5;
          uint64_t v7 = *(void *)v44;
          do
          {
            for (uint64_t j = 0; j != v6; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v44 != v7) {
                objc_enumerationMutation(v4);
              }
              uint64_t v9 = *(void *)(*((void *)&v43 + 1) + 8 * (void)j);
              id v10 = [*(id *)(a1 + 56) objectForKeyedSubscript:v9];
              if (!v10) {
                id v10 = objc_alloc_init((Class)NSMutableSet);
              }
              [*(id *)(a1 + 56) setObject:v10 forKeyedSubscript:v9];
              [v10 addObject:v3];
            }
            id v6 = [v4 countByEnumeratingWithState:&v43 objects:v62 count:16];
          }
          while (v6);
        }
      }
      id v42 = [obj countByEnumeratingWithState:&v47 objects:v63 count:16];
    }
    while (v42);
  }

  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  id v11 = [*(id *)(*(void *)(a1 + 32) + 208) description];
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
  v60[0] = @"transactionSourceIdentifiers";
  uint64_t v12 = [*(id *)(a1 + 64) description];
  uint64_t v13 = (void *)v12;
  if (v12) {
    CFStringRef v14 = (const __CFString *)v12;
  }
  else {
    CFStringRef v14 = &stru_10075AAD8;
  }
  CFStringRef v15 = *(const __CFString **)(a1 + 40);
  if (!v15) {
    CFStringRef v15 = &stru_10075AAD8;
  }
  v61[0] = v14;
  v61[1] = v15;
  v60[1] = @"passUniqueID";
  v60[2] = @"fetchTasks";
  if (v11) {
    CFStringRef v16 = v11;
  }
  else {
    CFStringRef v16 = &stru_10075AAD8;
  }
  v61[2] = v16;
  v60[3] = @"fetchTasksPriorToChanges";
  uint64_t v17 = [*(id *)(a1 + 72) description];
  id v18 = (void *)v17;
  if (v17) {
    CFStringRef v19 = (const __CFString *)v17;
  }
  else {
    CFStringRef v19 = &stru_10075AAD8;
  }
  v61[3] = v19;
  v60[4] = @"transactionSourceIdentifiersInProgress";
  uint64_t v20 = [*(id *)(a1 + 80) description];
  id v21 = (void *)v20;
  if (v20) {
    CFStringRef v22 = (const __CFString *)v20;
  }
  else {
    CFStringRef v22 = &stru_10075AAD8;
  }
  v61[4] = v22;
  v60[5] = @"transactionSourceIdentifiersToFetch";
  uint64_t v23 = [*(id *)(a1 + 48) description];
  uint64_t v24 = (void *)v23;
  if (v23) {
    CFStringRef v25 = (const __CFString *)v23;
  }
  else {
    CFStringRef v25 = &stru_10075AAD8;
  }
  v60[6] = @"zoneToTransactionSourceIdentifier";
  CFStringRef v26 = *(const __CFString **)(a1 + 56);
  if (!v26) {
    CFStringRef v26 = &stru_10075AAD8;
  }
  v61[5] = v25;
  v61[6] = v26;
  id v27 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:7];

  id v28 = *(void **)(a1 + 32);
  id v29 = [*(id *)(a1 + 64) description];
  long long v30 = [v27 description];
  long long v59 = v30;
  long long v31 = +[NSArray arrayWithObjects:&v59 count:1];
  uint64_t v32 = [v28 reportContainerChangeIntervalBeginEventWithType:48 stateName:v29 objectNames:v31 operationGroupName:*(void *)(a1 + 88) operationGroupNameSuffix:*(void *)(a1 + 96)];
  uint64_t v33 = *(void *)(*(void *)(a1 + 120) + 8);
  id v34 = *(void **)(v33 + 40);
  *(void *)(v33 + 40) = v32;

  __int16 v35 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v36 = *(void *)(a1 + 40);
    id v37 = [*(id *)(a1 + 48) count];
    uint64_t v38 = *(void *)(a1 + 48);
    uint64_t v39 = *(void *)(a1 + 56);
    *(_DWORD *)id buf = 138544130;
    uint64_t v52 = v36;
    __int16 v53 = 2048;
    id v54 = v37;
    __int16 v55 = 2112;
    uint64_t v56 = v38;
    __int16 v57 = 2112;
    uint64_t v58 = v39;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Pass Provisioning record download starting for passUniqueID: %{public}@, %lu transactionSourceIdentifiersToFetch: %@, zoneToTransactionSourceIdentifier: %@", buf, 0x2Au);
  }

  [*(id *)(a1 + 48) count];
  (*(void (**)(void))(*(void *)(a1 + 112) + 16))();
}

void sub_1000BBFB0(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = (void *)a1[4];
  uint64_t v9 = a1[5];
  uint64_t v10 = a1[6];
  uint64_t v11 = a1[7];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1000BC09C;
  v15[3] = &unk_100734130;
  uint64_t v12 = a1[8];
  id v17 = v7;
  uint64_t v18 = v12;
  id v16 = v6;
  id v13 = v6;
  id v14 = v7;
  [v8 _fetchAndStoreAppleCashRecordsIfNecessaryForPassUniqueID:v9 operationGroupName:v10 operationGroupNameSuffix:v11 completion:v15];
}

void sub_1000BC09C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
  id v8 = *(void **)(v5 + 40);
  id v6 = (id *)(v5 + 40);
  id v7 = v8;
  if (v8) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = a3;
  }
  objc_storeStrong(v6, v9);
  id v10 = a3;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1000BC11C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v21 = a3;
  id v20 = a4;
  id v6 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  id v7 = *(id *)(a1 + 32);
  id v8 = [v7 countByEnumeratingWithState:&v34 objects:v38 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v35;
    do
    {
      uint64_t v11 = 0;
      do
      {
        if (*(void *)v35 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v12 = *(void *)(*((void *)&v34 + 1) + 8 * (void)v11);
        v26[0] = _NSConcreteStackBlock;
        v26[1] = 3221225472;
        v26[2] = sub_1000BC3A4;
        v26[3] = &unk_1007341A8;
        int8x16_t v22 = *(int8x16_t *)(a1 + 32);
        id v13 = (id)v22.i64[0];
        int8x16_t v27 = vextq_s8(v22, v22, 8uLL);
        uint64_t v28 = v12;
        long long v29 = *(_OWORD *)(a1 + 48);
        char v33 = *(unsigned char *)(a1 + 88);
        id v30 = *(id *)(a1 + 64);
        id v14 = *(id *)(a1 + 72);
        uint64_t v15 = *(void *)(a1 + 80);
        id v31 = v14;
        uint64_t v32 = v15;
        [v6 addOperation:v26];

        uint64_t v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id v9 = [v7 countByEnumeratingWithState:&v34 objects:v38 count:16];
    }
    while (v9);
  }

  id v16 = +[NSNull null];
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  v23[2] = sub_1000BCD08;
  v23[3] = &unk_1007341D0;
  id v24 = v21;
  id v25 = v20;
  id v17 = v21;
  id v18 = v20;
  id v19 = [v6 evaluateWithInput:v16 completion:v23];
}

void sub_1000BC3A4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [*(id *)(a1 + 32) workQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BC4D4;
  block[3] = &unk_100734180;
  id v9 = *(id *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  id v16 = v9;
  uint64_t v17 = v10;
  uint64_t v18 = *(void *)(a1 + 32);
  long long v19 = *(_OWORD *)(a1 + 56);
  char v25 = *(unsigned char *)(a1 + 96);
  id v20 = *(id *)(a1 + 72);
  id v11 = *(id *)(a1 + 80);
  uint64_t v12 = *(void *)(a1 + 88);
  id v23 = v7;
  uint64_t v24 = v12;
  id v21 = v11;
  id v22 = v6;
  id v13 = v6;
  id v14 = v7;
  dispatch_async(v8, block);
}

void sub_1000BC4D4(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) objectForKeyedSubscript:*(void *)(a1 + 40)];
  uint64_t v3 = [*(id *)(a1 + 48) containerManager];
  uint64_t v4 = [v3 databaseForCloudStoreZone:*(void *)(a1 + 40)];

  uint64_t v5 = [(PDCloudStoreRecordsRequest *)[PDApplePayCloudStoreRecordsRequest alloc] initWithRequestType:0 storeChanges:1 returnRecords:0 qualityOfService:17 groupName:*(void *)(a1 + 56) groupNameSuffix:*(void *)(a1 + 64)];
  [(PDCloudStoreRecordsRequest *)v5 setCloudStoreZone:*(void *)(a1 + 40)];
  long long v60 = (void *)v4;
  [(PDCloudStoreRecordsRequest *)v5 setContainerDatabase:v4];
  [(PDCloudStoreRecordsRequest *)v5 setIgnoreExistingRecordHash:*(unsigned __int8 *)(a1 + 112)];
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  id v6 = v2;
  id v7 = [(__CFString *)v6 countByEnumeratingWithState:&v70 objects:v82 count:16];
  if (v7)
  {
    id v8 = v7;
    id v9 = 0;
    uint64_t v10 = *(void *)v71;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v71 != v10) {
          objc_enumerationMutation(v6);
        }
        uint64_t v12 = [*(id *)(a1 + 48) _accountCreateDateForTranactionSourceIdentifier:*(void *)(*((void *)&v70 + 1) + 8 * i) passUniqueID:*(void *)(a1 + 72)];
        id v13 = v12;
        if (!v9 || v12 && [v12 compare:v9] == (id)-1)
        {
          id v14 = v13;

          id v9 = v14;
        }
      }
      id v8 = [(__CFString *)v6 countByEnumeratingWithState:&v70 objects:v82 count:16];
    }
    while (v8);
  }
  else
  {
    id v9 = 0;
  }

  [(PDCloudStoreRecordsRequest *)v5 setIgnoreRecordsBeforeDate:v9];
  [(PDCloudStoreRecordsRequest *)v5 setShouldSaveToken:1];
  uint64_t v15 = objc_msgSend(*(id *)(a1 + 48), "_queue_additionalTransactionSourceIdentifiersForProvisioningWithZone:transactionSourceIdentifiers:", *(void *)(a1 + 40), v6);
  id v16 = (__CFString *)objc_alloc_init((Class)NSMutableSet);
  [(__CFString *)v16 unionSet:v6];
  uint64_t v61 = v5;
  if ([v15 count])
  {
    uint64_t v17 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = [*(id *)(a1 + 40) zoneName];
      *(_DWORD *)id buf = 138543618;
      int v79 = v18;
      __int16 v80 = 2112;
      id v81 = v15;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Additional transaction source identifiers to fetch in zone %{public}@ are %@", buf, 0x16u);
    }
    v76[0] = @"additionalTransactionSourceIdentifiersForZone";
    uint64_t v19 = [v15 description];
    id v20 = (void *)v19;
    if (v19) {
      CFStringRef v21 = (const __CFString *)v19;
    }
    else {
      CFStringRef v21 = &stru_10075AAD8;
    }
    if (v6) {
      CFStringRef v22 = v6;
    }
    else {
      CFStringRef v22 = &stru_10075AAD8;
    }
    v77[0] = v21;
    v77[1] = v22;
    v76[1] = @"transactionSourceIdentifiersForZone";
    v76[2] = @"zoneName";
    uint64_t v23 = [*(id *)(a1 + 40) zoneName];
    uint64_t v24 = (void *)v23;
    if (v23) {
      CFStringRef v25 = (const __CFString *)v23;
    }
    else {
      CFStringRef v25 = &stru_10075AAD8;
    }
    v76[3] = @"transactionSourceIdentifiers";
    CFStringRef v26 = *(const __CFString **)(a1 + 80);
    if (!v26) {
      CFStringRef v26 = &stru_10075AAD8;
    }
    v77[2] = v25;
    v77[3] = v26;
    int8x16_t v27 = +[NSDictionary dictionaryWithObjects:v77 forKeys:v76 count:4];

    uint64_t v28 = *(void **)(a1 + 48);
    long long v29 = [v27 description];
    [v28 reportContainerChangeSignpostEventType:52 stateName:v29 objectNames:0 changeToken:0 error:0 operationGroupName:*(void *)(a1 + 56) operationGroupNameSuffix:*(void *)(a1 + 64)];

    id v30 = [v15 allKeys];
    id v31 = +[NSSet setWithArray:v30];
    [(__CFString *)v16 unionSet:v31];

    uint64_t v5 = v61;
  }
  long long v59 = v15;
  [(PDApplePayCloudStoreRecordsRequest *)v5 setTransactionSourceIdentifiers:v16];
  v74[0] = @"transactionSourceIdentifiersForZone";
  uint64_t v32 = *(void **)(a1 + 80);
  char v33 = [(__CFString *)v6 allObjects];
  long long v34 = [v32 dictionaryWithValuesForKeys:v33];
  uint64_t v35 = [v34 description];
  CFStringRef v36 = v16;
  long long v37 = (void *)v35;
  if (v35) {
    CFStringRef v38 = (const __CFString *)v35;
  }
  else {
    CFStringRef v38 = &stru_10075AAD8;
  }
  v75[0] = v38;
  v74[1] = @"cloudStoreZoneToFetch";
  uint64_t v39 = [*(id *)(a1 + 40) zoneName];
  long long v40 = (void *)v39;
  if (v39) {
    CFStringRef v41 = (const __CFString *)v39;
  }
  else {
    CFStringRef v41 = &stru_10075AAD8;
  }
  CFStringRef v42 = *(const __CFString **)(a1 + 72);
  CFStringRef v43 = *(const __CFString **)(a1 + 80);
  if (!v42) {
    CFStringRef v42 = &stru_10075AAD8;
  }
  v75[1] = v41;
  v75[2] = v42;
  v74[2] = @"passUniqueID";
  v74[3] = @"transactionSourceIdentifiers";
  if (v43) {
    CFStringRef v44 = v43;
  }
  else {
    CFStringRef v44 = &stru_10075AAD8;
  }
  v74[4] = @"requestTransactionSourceIdentifiers";
  uint64_t v58 = (__CFString *)v36;
  if (v36) {
    CFStringRef v45 = v36;
  }
  else {
    CFStringRef v45 = &stru_10075AAD8;
  }
  v75[3] = v44;
  v75[4] = v45;
  long long v46 = +[NSDictionary dictionaryWithObjects:v75 forKeys:v74 count:5];

  long long v47 = *(void **)(a1 + 48);
  long long v48 = [v46 description];
  long long v49 = [(__CFString *)v6 allObjects];
  long long v50 = [v47 reportContainerChangeIntervalBeginEventWithType:39 stateName:v48 objectNames:v49 operationGroupName:*(void *)(a1 + 56) operationGroupNameSuffix:*(void *)(a1 + 64)];

  long long v51 = *(void **)(a1 + 48);
  v62[0] = _NSConcreteStackBlock;
  v62[1] = 3221225472;
  void v62[2] = sub_1000BCADC;
  v62[3] = &unk_100734158;
  long long v63 = v6;
  id v64 = v51;
  id v65 = v50;
  long long v57 = *(_OWORD *)(a1 + 96);
  id v52 = (id)v57;
  long long v69 = v57;
  id v66 = *(id *)(a1 + 88);
  id v53 = *(id *)(a1 + 72);
  uint64_t v54 = *(void *)(a1 + 40);
  id v67 = v53;
  uint64_t v68 = v54;
  id v55 = v50;
  uint64_t v56 = v6;
  [v51 executeRecordsRequest:v61 completion:v62];
}

void sub_1000BCADC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = *(void *)(*(void *)(a1 + 88) + 8);
  id v8 = *(void **)(v5 + 40);
  id v6 = (id *)(v5 + 40);
  id v7 = v8;
  if (v8) {
    id v9 = v7;
  }
  else {
    id v9 = v4;
  }
  objc_storeStrong(v6, v9);
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v10 = *(id *)(a1 + 32);
  id v11 = [v10 countByEnumeratingWithState:&v23 objects:v35 count:16];
  if (!v11)
  {

    objc_msgSend(*(id *)(a1 + 40), "reportContainerChangeIntervalEndEventWithBeginUniqueIdentifier:error:", *(void *)(a1 + 48), v4, (void)v23);
LABEL_19:
    CFStringRef v22 = *(void (**)(void))(*(void *)(a1 + 80) + 16);
    goto LABEL_20;
  }
  id v12 = v11;
  unsigned __int8 v13 = 0;
  uint64_t v14 = *(void *)v24;
  do
  {
    for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v24 != v14) {
        objc_enumerationMutation(v10);
      }
      if (v13)
      {
        unsigned __int8 v13 = 1;
      }
      else
      {
        uint64_t v16 = *(void *)(*((void *)&v23 + 1) + 8 * i);
        uint64_t v17 = objc_msgSend(*(id *)(a1 + 40), "dataSource", (void)v23);
        unsigned __int8 v13 = [v17 transactionSourceExistsWithIdentifier:v16];
      }
    }
    id v12 = [v10 countByEnumeratingWithState:&v23 objects:v35 count:16];
  }
  while (v12);

  [*(id *)(a1 + 40) reportContainerChangeIntervalEndEventWithBeginUniqueIdentifier:*(void *)(a1 + 48) error:v4];
  if ((v13 & 1) == 0) {
    goto LABEL_19;
  }
  uint64_t v18 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = *(void *)(a1 + 32);
    uint64_t v20 = *(void *)(a1 + 64);
    CFStringRef v21 = [*(id *)(a1 + 72) zoneName];
    *(_DWORD *)id buf = 138544130;
    uint64_t v28 = v20;
    __int16 v29 = 2112;
    uint64_t v30 = v19;
    __int16 v31 = 2114;
    uint64_t v32 = v21;
    __int16 v33 = 2112;
    id v34 = v4;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Completed fetching transaction records from CloudKit for payment pass with uniqueID: %{public}@. Transaction source identifiers %@. In zone %{public}@. Error: %@", buf, 0x2Au);
  }
  CFStringRef v22 = *(void (**)(void))(*(void *)(a1 + 80) + 16);
LABEL_20:
  v22();
}

uint64_t sub_1000BCD08(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  id v6 = [a4 isCanceled];
  id v7 = *(uint64_t (**)(uint64_t, uint64_t, id))(v4 + 16);
  return v7(v4, v5, v6);
}

void sub_1000BCD54(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) workQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000BCE6C;
  block[3] = &unk_100734220;
  id v8 = *(id *)(a1 + 40);
  id v3 = *(id *)(a1 + 48);
  uint64_t v4 = *(void *)(a1 + 88);
  id v9 = v3;
  uint64_t v15 = v4;
  id v5 = *(id *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 32);
  id v10 = v5;
  uint64_t v11 = v6;
  uint64_t v16 = *(void *)(a1 + 96);
  id v12 = *(id *)(a1 + 64);
  id v13 = *(id *)(a1 + 72);
  id v14 = *(id *)(a1 + 80);
  dispatch_async(v2, block);
}

uint64_t sub_1000BCE6C(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40);
    uint64_t v6 = +[NSDate date];
    [v6 timeIntervalSinceDate:*(void *)(a1 + 48)];
    *(_DWORD *)id buf = 138544130;
    uint64_t v24 = v3;
    __int16 v25 = 2112;
    uint64_t v26 = v4;
    __int16 v27 = 2112;
    uint64_t v28 = v5;
    __int16 v29 = 2048;
    uint64_t v30 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed pass provisioning transaction fetch for pass %{public}@, transactionSourceIdentifiers %@, with error %@. Total time: %f seconds.", buf, 0x2Au);
  }
  PKLogFacilityTypeGetObject();
  id v8 = (id)objc_claimAutoreleasedReturnValue();
  os_signpost_id_t v9 = os_signpost_id_make_with_pointer(v8, *(const void **)(a1 + 56));
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    os_signpost_id_t v10 = v9;
    if (os_signpost_enabled(v8))
    {
      *(_WORD *)id buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_INTERVAL_END, v10, "cloudstore:fetchPassRecords", "", buf, 2u);
    }
  }

  [*(id *)(a1 + 56) reportContainerChangeIntervalEndEventWithBeginUniqueIdentifier:*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40) error:*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40)];
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 200));
  [WeakRetained applePayCloudStoreContainer:*(void *)(a1 + 56) didFinishTransactionFetchForPassUniqueID:*(void *)(a1 + 32)];

  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v12 = *(id *)(a1 + 64);
  id v13 = (char *)[v12 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v13)
  {
    id v14 = v13;
    uint64_t v15 = *(void *)v19;
    do
    {
      uint64_t v16 = 0;
      do
      {
        if (*(void *)v19 != v15) {
          objc_enumerationMutation(v12);
        }
        (*(void (**)(void))(*(void *)(a1 + 72) + 16))(*(void *)(a1 + 72));
        ++v16;
      }
      while (v14 != v16);
      id v14 = (char *)[v12 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }
    while (v14);
  }

  uint64_t result = *(void *)(a1 + 80);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40));
  }
  return result;
}

void sub_1000BD824(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1000BD864(uint64_t a1)
{
}

void sub_1000BD86C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(NSObject **)(a1 + 32);
  os_signpost_id_t v9 = [*(id *)(a1 + 40) workQueue];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_1000BD944;
  void v12[3] = &unk_10072E598;
  id v13 = v6;
  id v14 = v7;
  id v10 = v6;
  id v11 = v7;
  dispatch_group_notify(v8, v9, v12);
}

uint64_t sub_1000BD944(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_1000BD95C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = *(os_unfair_lock_s **)(a1 + 32);
  if (*(unsigned char *)(a1 + 64))
  {
    id v7 = v6 + 54;
    id v8 = a4;
    id v9 = a3;
    os_unfair_lock_lock(v7);
    long long v19 = [*(id *)(*(void *)(a1 + 32) + 208) objectForKeyedSubscript:*(void *)(a1 + 40)];
    id v10 = [(PDApplePayCloudStoreRecordFetchOperation *)v19 task];
    if ([v10 status] == (id)2 && objc_msgSend(v10, "type") == (id)3)
    {
      id v11 = v10;
    }
    else
    {
      id v11 = [objc_alloc((Class)PKCloudStoreRecordFetchTask) initWithCloudStoreZone:*(void *)(a1 + 48) type:3];

      id v12 = v19;
      if (!v19) {
        id v12 = objc_alloc_init(PDApplePayCloudStoreRecordFetchOperation);
      }
      long long v19 = v12;
      [(PDApplePayCloudStoreRecordFetchOperation *)v12 updateTask:v11];
      id v13 = *(void **)(*(void *)(a1 + 32) + 208);
      id v14 = [(PDApplePayCloudStoreRecordFetchOperation *)v19 identifier];
      [v13 safelySetObject:v19 forKey:v14];

      [v11 startTask];
      uint64_t v15 = [*(id *)(a1 + 32) dataSource];
      [v15 updateRecordFetchTask:v11];
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 216));
    v8[2](v8, v9, 0);
  }
  else
  {
    id v11 = a4;
    long long v19 = a3;
    uint64_t v16 = [(os_unfair_lock_s *)v6 setupAssistantNotCompleteError];
    uint64_t v17 = *(void *)(*(void *)(a1 + 56) + 8);
    long long v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;

    (*((void (**)(id, PDApplePayCloudStoreRecordFetchOperation *, uint64_t))v11 + 2))(v11, v19, 1);
  }
}

void sub_1000BDB3C(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v9 = a1[7];
  id v8 = (void *)a1[8];
  uint64_t v10 = a1[4];
  uint64_t v11 = a1[5];
  uint64_t v12 = a1[6];
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1000BDC4C;
  v18[3] = &unk_1007307C0;
  uint64_t v13 = a1[9];
  uint64_t v14 = a1[10];
  id v20 = v7;
  uint64_t v21 = v13;
  id v19 = v6;
  v17.receiver = v8;
  v17.super_class = (Class)PDApplePayCloudStoreContainer;
  id v15 = v6;
  id v16 = v7;
  objc_msgSendSuper2(&v17, "fetchRecordsInAcceptedZoneShare:databaseIdentifier:operationGroupName:operationGroupNameSuffix:qualityOfService:completion:", v10, v11, v12, v9, v14, v18);
}

void sub_1000BDC4C(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a2);
  id v4 = a2;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t sub_1000BDCB8(uint64_t a1)
{
  [*(id *)(a1 + 32) _fetchTaskOperationWithIdentifier:*(void *)(a1 + 40) completedWithError:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)];
  uint64_t result = *(void *)(a1 + 48);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(result + 16);
    return v3();
  }
  return result;
}

void sub_1000BE71C(id *a1)
{
  id v2 = (void *)*((void *)a1[4] + 34);
  if (!v2) {
    goto LABEL_19;
  }
  id v3 = a1[5];
  id v4 = [v2 associatedPassUniqueID];
  id v5 = v3;
  id v6 = v4;
  if (v5 == v6)
  {
  }
  else
  {
    id v7 = v6;
    if (!v5 || !v6)
    {

      goto LABEL_19;
    }
    unsigned __int8 v8 = [v5 isEqualToString:v6];

    if ((v8 & 1) == 0)
    {
LABEL_19:
      id v32 = a1[8];
      if (v32)
      {
        __int16 v33 = (void (*)(void))*((void *)v32 + 2);
        v33();
      }
      return;
    }
  }
  v66[0] = 0;
  v66[1] = v66;
  v66[2] = 0x3032000000;
  v66[3] = sub_10002083C;
  v66[4] = sub_100020F10;
  id v67 = 0;
  uint64_t v9 = [a1[4] dataSource];
  long long v37 = [v9 transactionSourceIdentifiersForPassUniqueIdentifier:a1[5]];

  id v10 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
  uint64_t v35 = [a1[4] reportContainerChangeIntervalBeginEventWithType:51 stateName:a1[5] objectNames:0 operationGroupName:a1[6] operationGroupNameSuffix:a1[7]];
  uint64_t v11 = [a1[4] containerManager];
  uint64_t v12 = [v11 databaseForScope:2];

  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  uint64_t v13 = [a1[4] _peerPaymentZoneNamesForAccount:*((void *)a1[4] + 34) containerDatabase:v12];
  id v14 = [v13 countByEnumeratingWithState:&v62 objects:v68 count:16];
  if (v14)
  {
    uint64_t v36 = *(void *)v63;
    id obj = v13;
    do
    {
      for (uint64_t i = 0; i != v14; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v63 != v36) {
          objc_enumerationMutation(obj);
        }
        uint64_t v16 = *(void *)(*((void *)&v62 + 1) + 8 * i);
        objc_super v17 = [a1[4] containerManager];
        long long v18 = [v17 cloudStoreZoneForZoneName:v16 inContainerDatabase:v12];

        if (v18)
        {
          id v19 = a1[4];
          id v20 = [v37 anyObject];
          uint64_t v21 = [v19 _accountCreateDateForTranactionSourceIdentifier:v20 passUniqueID:a1[5]];

          v52[0] = _NSConcreteStackBlock;
          v52[1] = 3221225472;
          v52[2] = sub_1000BED28;
          v52[3] = &unk_100734338;
          id v22 = v18;
          id v23 = a1[4];
          id v53 = v22;
          id v54 = v23;
          id v55 = a1[6];
          id v56 = a1[7];
          id v24 = v12;
          id v57 = v24;
          id v25 = v37;
          id v58 = v25;
          id v26 = v21;
          id v59 = v26;
          uint64_t v61 = v66;
          id v60 = a1[5];
          [v10 addOperation:v52];
          v42[0] = _NSConcreteStackBlock;
          v42[1] = 3221225472;
          v42[2] = sub_1000BF04C;
          v42[3] = &unk_100734338;
          id v27 = v22;
          id v28 = a1[4];
          id v43 = v27;
          id v44 = v28;
          id v45 = a1[6];
          id v46 = a1[7];
          id v47 = v24;
          id v48 = v25;
          id v29 = v26;
          id v49 = v29;
          long long v51 = v66;
          id v50 = a1[5];
          [v10 addOperation:v42];
          uint64_t v30 = +[NSNull null];
          v38[0] = _NSConcreteStackBlock;
          v38[1] = 3221225472;
          v38[2] = sub_1000BF370;
          v38[3] = &unk_1007342E8;
          void v38[4] = a1[4];
          id v39 = v35;
          CFStringRef v41 = v66;
          id v40 = a1[8];
          id v31 = [v10 evaluateWithInput:v30 completion:v38];
        }
      }
      uint64_t v13 = obj;
      id v14 = [obj countByEnumeratingWithState:&v62 objects:v68 count:16];
    }
    while (v14);
  }

  _Block_object_dispose(v66, 8);
}

void sub_1000BECE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
}

void sub_1000BED28(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  unsigned __int8 v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = [*(id *)(a1 + 32) zoneName];
    *(_DWORD *)id buf = 138543362;
    uint64_t v30 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Fetching recurring memo records from CloudKit in zone %{public}@", buf, 0xCu);
  }
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v20 = *(void *)(a1 + 48);
  uint64_t v21 = PKCloudRecurringPaymentMemoRecordType;
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = *(void **)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 64);
  uint64_t v14 = *(void *)(a1 + 72);
  uint64_t v16 = *(void *)(a1 + 80);
  id v15 = *(void **)(a1 + 88);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_1000BEF08;
  void v22[3] = &unk_100734310;
  uint64_t v17 = *(void *)(a1 + 96);
  id v27 = v7;
  uint64_t v28 = v17;
  id v23 = v6;
  id v24 = v15;
  id v25 = *(id *)(a1 + 72);
  id v26 = *(id *)(a1 + 32);
  id v18 = v6;
  id v19 = v7;
  [v12 _fetchAndStoreAppleCashItemWithRecordType:v21 operationGroupName:v20 operationGroupNameSuffix:v10 zone:v11 containerDatabase:v13 transactionSourceIdentifiers:v14 accountCreationDate:v16 completion:v22];
}

void sub_1000BEF08(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void *)(*(void *)(a1 + 72) + 8);
  uint64_t v9 = *(void **)(v6 + 40);
  id v7 = (id *)(v6 + 40);
  unsigned __int8 v8 = v9;
  if (v9) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = v5;
  }
  objc_storeStrong(v7, v10);
  if (a2)
  {
    uint64_t v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 40);
      uint64_t v13 = *(void *)(a1 + 48);
      uint64_t v14 = [*(id *)(a1 + 56) zoneName];
      int v16 = 138543874;
      uint64_t v17 = v12;
      __int16 v18 = 2112;
      uint64_t v19 = v13;
      __int16 v20 = 2114;
      uint64_t v21 = v14;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Completed fetching recurring memo records from CloudKit for payment pass with uniqueID: %{public}@. Transaction source identifiers %@. In zone %{public}@", (uint8_t *)&v16, 0x20u);
    }
    id v15 = *(void (**)(void))(*(void *)(a1 + 64) + 16);
  }
  else
  {
    id v15 = *(void (**)(void))(*(void *)(a1 + 64) + 16);
  }
  v15();
}

void sub_1000BF04C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  unsigned __int8 v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = [*(id *)(a1 + 32) zoneName];
    *(_DWORD *)id buf = 138543362;
    uint64_t v30 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Fetching counterpart image data from CloudKit in zone %{public}@", buf, 0xCu);
  }
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v20 = *(void *)(a1 + 48);
  uint64_t v21 = PKCloudCounterpartImageRecordType;
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = *(void **)(a1 + 40);
  uint64_t v13 = *(void *)(a1 + 64);
  uint64_t v14 = *(void *)(a1 + 72);
  uint64_t v16 = *(void *)(a1 + 80);
  id v15 = *(void **)(a1 + 88);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_1000BF22C;
  void v22[3] = &unk_100734310;
  uint64_t v17 = *(void *)(a1 + 96);
  id v27 = v7;
  uint64_t v28 = v17;
  id v23 = v6;
  id v24 = v15;
  id v25 = *(id *)(a1 + 72);
  id v26 = *(id *)(a1 + 32);
  id v18 = v6;
  id v19 = v7;
  [v12 _fetchAndStoreAppleCashItemWithRecordType:v21 operationGroupName:v20 operationGroupNameSuffix:v10 zone:v11 containerDatabase:v13 transactionSourceIdentifiers:v14 accountCreationDate:v16 completion:v22];
}

void sub_1000BF22C(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void *)(*(void *)(a1 + 72) + 8);
  uint64_t v9 = *(void **)(v6 + 40);
  id v7 = (id *)(v6 + 40);
  unsigned __int8 v8 = v9;
  if (v9) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = v5;
  }
  objc_storeStrong(v7, v10);
  if (a2)
  {
    uint64_t v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 40);
      uint64_t v13 = *(void *)(a1 + 48);
      uint64_t v14 = [*(id *)(a1 + 56) zoneName];
      int v16 = 138543874;
      uint64_t v17 = v12;
      __int16 v18 = 2112;
      uint64_t v19 = v13;
      __int16 v20 = 2114;
      uint64_t v21 = v14;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Completed fetching counterpart image data records from CloudKit for payment pass with uniqueID: %{public}@. Transaction source identifiers %@. In zone %{public}@", (uint8_t *)&v16, 0x20u);
    }
    id v15 = *(void (**)(void))(*(void *)(a1 + 64) + 16);
  }
  else
  {
    id v15 = *(void (**)(void))(*(void *)(a1 + 64) + 16);
  }
  v15();
}

void sub_1000BF370(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  [*(id *)(a1 + 32) reportContainerChangeIntervalEndEventWithBeginUniqueIdentifier:*(void *)(a1 + 40) error:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)];
  uint64_t v5 = *(void *)(a1 + 48);
  if (v5) {
    (*(void (**)(uint64_t, id, void))(v5 + 16))(v5, [v6 isCanceled], *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40));
  }
}

void sub_1000BF5E8(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v5 = *(id *)(a1 + 32);
  id v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v6)
  {
    id v7 = v6;
    unsigned __int8 v8 = 0;
    uint64_t v9 = *(void *)v14;
    do
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v9) {
          objc_enumerationMutation(v5);
        }
        if (v8)
        {
          unsigned __int8 v8 = 1;
        }
        else
        {
          uint64_t v11 = *(void *)(*((void *)&v13 + 1) + 8 * i);
          uint64_t v12 = objc_msgSend(*(id *)(a1 + 40), "dataSource", (void)v13);
          unsigned __int8 v8 = [v12 transactionSourceExistsWithIdentifier:v11];
        }
      }
      id v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v7);
  }

  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1000BF854(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  id v7 = [v6 countByEnumeratingWithState:&v28 objects:v32 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v29;
    do
    {
      uint64_t v10 = 0;
      id v27 = v8;
      do
      {
        if (*(void *)v29 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = *(void **)(*((void *)&v28 + 1) + 8 * (void)v10);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          uint64_t v12 = [v11 transaction];
          long long v13 = [v12 transactionSourceIdentifier];
          if (!v13)
          {
            id v14 = objc_alloc((Class)PKCloudStoreRecord);
            long long v15 = [v11 records];
            [v15 allObjects];
            uint64_t v16 = a1;
            uint64_t v17 = v9;
            id v18 = v6;
            v20 = id v19 = v5;
            id v21 = [v14 initWithRecords:v20];

            id v5 = v19;
            id v6 = v18;
            uint64_t v9 = v17;
            a1 = v16;

            id v8 = v27;
            long long v13 = [*(id *)(v16 + 32) _transactionSourceIdentifierForTransactionCloudStoreRecord:v21 databaseIdentifier:v5];
          }
          if ([*(id *)(a1 + 40) count]
            && ([*(id *)(a1 + 40) containsObject:v13] & 1) == 0)
          {
            goto LABEL_18;
          }
        }
        else
        {
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0) {
            goto LABEL_19;
          }
          id v22 = [v11 event];
          uint64_t v12 = [v22 accountIdentifier];

          if (*(void *)(a1 + 56))
          {
            id v23 = [*(id *)(a1 + 32) dataSource];
            long long v13 = [v23 associatedAccountIdentifierForPassWithUniqueIdentifier:*(void *)(a1 + 56)];

            id v8 = v27;
            if ((PKEqualObjects() & 1) == 0) {
              goto LABEL_18;
            }
          }
          else
          {
            id v24 = [v11 event];
            long long v13 = [v24 altDSID];

            id v25 = [*(id *)(a1 + 32) dataSource];
            id v26 = [v25 transactionSourceIdentifierForAccountUserAltDSID:v13 accountIdentifier:v12];

            id v8 = v27;
          }
        }
        [*(id *)(a1 + 48) addCloudRecord:v11 forContainerDatabaseIdentifier:v5];
LABEL_18:

LABEL_19:
        uint64_t v10 = (char *)v10 + 1;
      }
      while (v8 != v10);
      id v8 = [v6 countByEnumeratingWithState:&v28 objects:v32 count:16];
    }
    while (v8);
  }
}

uint64_t sub_1000BFC04(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  id v2 = objc_msgSend(*(id *)(a1 + 32), "_queue_isRelevantTransactionSourceIdentifier:", *(void *)(a1 + 40));
  id v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);
  return v3(v1, v2);
}

uint64_t sub_1000BFD50(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  id v2 = objc_msgSend(*(id *)(a1 + 32), "_queue_canSyncTransactionToCloudKit:forTransactionSourceIdentifier:", *(void *)(a1 + 40), *(void *)(a1 + 48));
  id v3 = *(uint64_t (**)(uint64_t, id))(v1 + 16);
  return v3(v1, v2);
}

void sub_1000C01FC(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)id buf = 138543362;
    uint64_t v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Bootstrapping zone with name %{public}@", buf, 0xCu);
  }

  id v4 = [*(id *)(a1 + 40) containerManager];
  id v5 = [v4 databaseForScope:2];

  id v6 = [v5 identifier];
  if (v6)
  {
    id v7 = [v5 zoneForZoneName:*(void *)(a1 + 32)];
    id v8 = *(void **)(a1 + 40);
    if (v7)
    {
      uint64_t v12 = v6;
      uint64_t v9 = +[NSSet setWithObject:v7];
      long long v13 = v9;
      uint64_t v10 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      objc_msgSend(v8, "_queue_createZoneAndSubscriptionsByDatabaseIdentifier:groupSuffix:completion:", v10, 0, *(void *)(a1 + 48));
    }
    else
    {
      uint64_t v11 = +[NSString stringWithFormat:@"There is no zone defined for zone name %@", *(void *)(a1 + 32)];
      uint64_t v9 = [v8 errorWithCode:-4001 description:v11];

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
  }
  else
  {
    id v7 = [*(id *)(a1 + 40) errorWithCode:-4004 description:@"No private database defined"];
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_1000C04E8(uint64_t a1)
{
  PKCreateSimulatedPaymentTransaction();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  id v2 = +[NSUUID UUID];
  uint64_t v3 = [v2 UUIDString];
  [v4 setServiceIdentifier:v3];

  [v4 setHasNotificationServiceData:1];
  [*(id *)(a1 + 32) uploadTransaction:v4 forTransactionSourceIdentifier:*(void *)(a1 + 40) includeServerData:1 completion:*(void *)(a1 + 48)];
}

void sub_1000C0698(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) containerManager];
  uint64_t v3 = [v2 cloudStoreZonesByDatabaseIdentifierForItem:*(void *)(a1 + 40) action:1];

  if ([v3 count])
  {
    uint64_t v4 = 2 * *(unsigned __int8 *)(a1 + 64);
    id v5 = [*(id *)(a1 + 40) recordTypesAndNamesForCodingType:v4];
    if ([v5 count])
    {
      id v6 = objc_alloc_init((Class)NSMutableDictionary);
      id v7 = [*(id *)(a1 + 32) dataSource];
      id v8 = [v7 passUniqueIdentifierForTransactionSourceIdentifier:*(void *)(a1 + 48)];

      uint64_t v9 = [*(id *)(a1 + 32) dataSource];
      uint64_t v10 = [v9 passWithUniqueIdentifier:v8];
      uint64_t v11 = [v10 paymentPass];

      v31[0] = _NSConcreteStackBlock;
      v31[1] = 3221225472;
      v31[2] = sub_1000C0AA8;
      v31[3] = &unk_1007343B0;
      id v12 = *(id *)(a1 + 40);
      uint64_t v13 = *(void *)(a1 + 32);
      id v32 = v12;
      uint64_t v33 = v13;
      id v35 = v6;
      uint64_t v36 = v4;
      id v34 = v11;
      id v14 = v6;
      id v15 = v11;
      [v3 enumerateKeysAndObjectsUsingBlock:v31];
      uint64_t v16 = [PDApplePayCloudStoreRecordsRequest alloc];
      uint64_t v17 = [(PDCloudStoreRecordsRequest *)v16 initWithRequestType:6 storeChanges:1 returnRecords:1 qualityOfService:25 groupName:PKCloudStoreOperationGroupUserActionExplicit groupNameSuffix:PKCloudStoreOperationGroupSuffixPassutil];
      [(PDCloudStoreRecordsRequest *)v17 setRecordsToSaveByDatabaseIdentifier:v14];
      id v18 = *(void **)(a1 + 32);
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472;
      void v29[2] = sub_1000C0E34;
      v29[3] = &unk_1007343D8;
      id v30 = *(id *)(a1 + 56);
      [v18 executeRecordsRequest:v17 completion:v29];
    }
    else
    {
      id v24 = *(void **)(a1 + 32);
      id v25 = +[NSString stringWithFormat:@"There are no record types or names associated with item %@", *(void *)(a1 + 40)];
      id v8 = [v24 errorWithCode:-4002 description:v25];

      id v26 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        id v27 = *(void **)(a1 + 40);
        *(_DWORD *)id buf = 138412290;
        CFStringRef v38 = v27;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "There are no record types or names associated with item %@", buf, 0xCu);
      }

      uint64_t v28 = *(void *)(a1 + 56);
      if (v28) {
        (*(void (**)(uint64_t, void, void *))(v28 + 16))(v28, 0, v8);
      }
    }
  }
  else
  {
    id v19 = *(void **)(a1 + 32);
    [*(id *)(a1 + 40) itemType];
    __int16 v20 = PKCloudStoreItemTypeToString();
    id v21 = +[NSString stringWithFormat:@"There is no zone defined for item type %@", v20];
    id v5 = [v19 errorWithCode:-4001 description:v21];

    id v22 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 138412290;
      CFStringRef v38 = v5;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Error: No zone defined %@", buf, 0xCu);
    }

    uint64_t v23 = *(void *)(a1 + 56);
    if (v23) {
      (*(void (**)(uint64_t, void, void *))(v23 + 16))(v23, 0, v5);
    }
  }
}

void sub_1000C0AA8(uint64_t a1, void *a2, void *a3)
{
  id v35 = a2;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  id obj = a3;
  id v31 = [obj countByEnumeratingWithState:&v36 objects:v40 count:16];
  if (v31)
  {
    uint64_t v30 = *(void *)v37;
    uint64_t v29 = PKCloudTransactionRecordType;
    uint64_t v28 = PKCloudTransactionDeviceDataRecordType;
    do
    {
      for (uint64_t i = 0; i != v31; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v37 != v30) {
          objc_enumerationMutation(obj);
        }
        id v5 = [*(id *)(*((void *)&v36 + 1) + 8 * i) recordZone];
        if (v5)
        {
          id v32 = i;
          id v6 = objc_alloc_init((Class)NSMutableArray);
          id v7 = objc_alloc((Class)CKRecordID);
          id v8 = [*(id *)(a1 + 32) serviceIdentifier];
          uint64_t v9 = [v5 zoneID];
          id v10 = [v7 initWithRecordName:v8 zoneID:v9];

          id v11 = [objc_alloc((Class)CKRecord) initWithRecordType:v29 recordID:v10];
          [v6 addObject:v11];
          id v12 = objc_alloc((Class)CKRecordID);
          uint64_t v13 = [(id)objc_opt_class() recordNamePrefix];
          id v14 = [*(id *)(a1 + 32) serviceIdentifier];
          id v15 = +[NSString stringWithFormat:@"%@%@", v13, v14];
          uint64_t v16 = [v5 zoneID];
          id v17 = [v12 initWithRecordName:v15 zoneID:v16];

          uint64_t v33 = v17;
          id v18 = [objc_alloc((Class)CKRecord) initWithRecordType:v28 recordID:v17];

          [v6 addObject:v18];
          id v19 = [*(id *)(a1 + 40) _cloudStoreSpecificKeysForItem:*(void *)(a1 + 32) paymentPass:*(void *)(a1 + 48)];
          id v20 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v6];
          [v20 setCloudStoreSpecificKeys:v19];
          [*(id *)(a1 + 32) encodeWithCloudStoreCoder:v20 codingType:*(void *)(a1 + 64)];
          id v21 = [*(id *)(a1 + 56) objectForKey:v35];
          id v22 = v21;
          if (v21) {
            id v23 = v21;
          }
          else {
            id v23 = objc_alloc_init((Class)NSMutableSet);
          }
          id v24 = v23;

          [*(id *)(a1 + 56) setObject:v24 forKey:v35];
          id v25 = [v20 records];
          id v26 = +[NSSet setWithArray:v25];
          [v24 unionSet:v26];

          uint64_t i = v32;
        }
      }
      id v31 = [obj countByEnumeratingWithState:&v36 objects:v40 count:16];
    }
    while (v31);
  }
}

void sub_1000C0E34(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    id v5 = a3;
    id v6 = [a2 cloudStoreRecords];
    (*(void (**)(uint64_t, id, id))(v3 + 16))(v3, v6, v5);
  }
}

void sub_1000C0FA0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) containerManager];
  uint64_t v3 = [v2 cloudStoreZonesByDatabaseIdentifierForItem:*(void *)(a1 + 40) action:1];

  id v4 = [v3 count];
  id v5 = *(void **)(a1 + 32);
  if (v4)
  {
    id v6 = [*(id *)(a1 + 32) dataSource];
    id v7 = [v6 transactionArchiveForRecurringPayment:*(void *)(a1 + 40)];

    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472;
    v23[2] = sub_1000C1320;
    v23[3] = &unk_100734400;
    id v8 = objc_alloc_init((Class)NSMutableSet);
    id v24 = v8;
    id v9 = v7;
    id v25 = v9;
    [v3 enumerateKeysAndObjectsUsingBlock:v23];
    id v10 = [*(id *)(a1 + 32) dataSource];
    [v10 updateTransactionArchive:v9 forRecurringPayment:*(void *)(a1 + 40)];

    id v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = [*(id *)(a1 + 40) identifier];
      *(_DWORD *)id buf = 138412546;
      id v27 = v12;
      __int16 v28 = 2112;
      id v29 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Uploading memo for recurring payment %@ in zones %@", buf, 0x16u);
    }
    id v13 = [objc_alloc((Class)PKCloudStoreUploadItemConfiguration) initWithItem:*(void *)(a1 + 40) recordSpecificKeys:0];
    [v13 setCloudStoreZones:v8];
    id v14 = *(void **)(a1 + 32);
    id v15 = +[NSSet setWithObject:v13];
    uint64_t v16 = PKCloudStoreOperationGroupUserActionImplicit;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_1000C1448;
    v21[3] = &unk_100734428;
    id v22 = *(id *)(a1 + 40);
    [v14 updateCloudStoreWithLocalItemsWithConfigurations:v15 groupName:v16 groupNameSuffix:0 qualityOfService:17 completion:v21];
  }
  else
  {
    [*(id *)(a1 + 40) itemType];
    id v17 = PKCloudStoreItemTypeToString();
    id v18 = +[NSString stringWithFormat:@"There is no zone defined for item type %@", v17];
    id v9 = [v5 errorWithCode:-4001 description:v18];

    id v19 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 138412290;
      id v27 = v9;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Error: No zone defined %@", buf, 0xCu);
    }

    uint64_t v20 = *(void *)(a1 + 48);
    if (v20) {
      (*(void (**)(uint64_t, void, id))(v20 + 16))(v20, 0, v9);
    }
  }
}

void sub_1000C1320(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v11 + 1) + 8 * i);
        id v10 = [v9 recordZone];
        if (v10)
        {
          [*(id *)(a1 + 32) addObject:v9];
          [*(id *)(a1 + 40) insertOrUpdateArchiveLocationWithCloudStoreZone:v9 isArchived:0 insertionMode:0];
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v6);
  }
}

void sub_1000C1448(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void **)(a1 + 32);
    id v8 = a4;
    id v9 = [v7 identifier];

    int v10 = 138412546;
    long long v11 = v9;
    __int16 v12 = 2112;
    id v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Uploaded memo for recurring payment %@ with error %@", (uint8_t *)&v10, 0x16u);
  }
}

void sub_1000C1604(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) containerManager];
  uint64_t v3 = [v2 cloudStoreZonesByDatabaseIdentifierForItem:*(void *)(a1 + 40) action:1];

  id v4 = [v3 count];
  id v5 = *(void **)(a1 + 32);
  if (v4)
  {
    id v6 = [*(id *)(a1 + 32) dataSource];
    uint64_t v7 = [v6 transactionArchiveForCounterpartImageData:*(void *)(a1 + 40)];

    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472;
    v23[2] = sub_1000C1984;
    v23[3] = &unk_100734400;
    id v8 = objc_alloc_init((Class)NSMutableSet);
    id v24 = v8;
    id v9 = v7;
    id v25 = v9;
    [v3 enumerateKeysAndObjectsUsingBlock:v23];
    int v10 = [*(id *)(a1 + 32) dataSource];
    [v10 updateTransactionArchive:v9 forCounterpartImageData:*(void *)(a1 + 40)];

    long long v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v12 = [*(id *)(a1 + 40) identifier];
      *(_DWORD *)id buf = 138412546;
      id v27 = v12;
      __int16 v28 = 2112;
      id v29 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Uploading counterpart image data %@ in zones %@", buf, 0x16u);
    }
    id v13 = [objc_alloc((Class)PKCloudStoreUploadItemConfiguration) initWithItem:*(void *)(a1 + 40) recordSpecificKeys:0];
    [v13 setCloudStoreZones:v8];
    long long v14 = *(void **)(a1 + 32);
    id v15 = +[NSSet setWithObject:v13];
    uint64_t v16 = PKCloudStoreOperationGroupUserActionImplicit;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_1000C1AAC;
    v21[3] = &unk_100734428;
    id v22 = *(id *)(a1 + 40);
    [v14 updateCloudStoreWithLocalItemsWithConfigurations:v15 groupName:v16 groupNameSuffix:0 qualityOfService:17 completion:v21];
  }
  else
  {
    [*(id *)(a1 + 40) itemType];
    id v17 = PKCloudStoreItemTypeToString();
    id v18 = +[NSString stringWithFormat:@"There is no zone defined for item type %@", v17];
    id v9 = [v5 errorWithCode:-4001 description:v18];

    id v19 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 138412290;
      id v27 = v9;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Error: No zone defined %@", buf, 0xCu);
    }

    uint64_t v20 = *(void *)(a1 + 48);
    if (v20) {
      (*(void (**)(uint64_t, void, id))(v20 + 16))(v20, 0, v9);
    }
  }
}

void sub_1000C1984(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v11 + 1) + 8 * i);
        int v10 = [v9 recordZone];
        if (v10)
        {
          [*(id *)(a1 + 32) addObject:v9];
          [*(id *)(a1 + 40) insertOrUpdateArchiveLocationWithCloudStoreZone:v9 isArchived:0 insertionMode:0];
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v6);
  }
}

void sub_1000C1AAC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void **)(a1 + 32);
    id v8 = a4;
    id v9 = [v7 identifier];

    int v10 = 138412546;
    long long v11 = v9;
    __int16 v12 = 2112;
    id v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Uploaded counterpart image data %@ with error %@", (uint8_t *)&v10, 0x16u);
  }
}

void sub_1000C1C90(uint64_t a1)
{
  if ([*(id *)(a1 + 32) count])
  {
    id v2 = [*(id *)(a1 + 40) dataSource];
    uint64_t v3 = [v2 accountWithIdentifier:*(void *)(a1 + 48)];

    if (v3)
    {
      id v4 = objc_alloc_init((Class)NSMutableDictionary);
      long long v26 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      id obj = *(id *)(a1 + 32);
      id v5 = [obj countByEnumeratingWithState:&v26 objects:v30 count:16];
      if (v5)
      {
        id v6 = v5;
        uint64_t v7 = *(void *)v27;
        do
        {
          for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v27 != v7) {
              objc_enumerationMutation(obj);
            }
            uint64_t v9 = *(void *)(*((void *)&v26 + 1) + 8 * i);
            int v10 = [*(id *)(a1 + 40) containerManager];
            long long v11 = [v10 cloudStoreZonesByDatabaseIdentifierForItem:v9 action:1];

            v24[0] = _NSConcreteStackBlock;
            v24[1] = 3221225472;
            v24[2] = sub_1000C205C;
            v24[3] = &unk_100734450;
            void v24[4] = *(void *)(a1 + 40);
            v24[5] = v9;
            id v25 = v4;
            [v11 enumerateKeysAndObjectsUsingBlock:v24];
          }
          id v6 = [obj countByEnumeratingWithState:&v26 objects:v30 count:16];
        }
        while (v6);
      }

      __int16 v12 = [PDApplePayCloudStoreRecordsRequest alloc];
      id v13 = [(PDCloudStoreRecordsRequest *)v12 initWithRequestType:6 storeChanges:1 returnRecords:1 qualityOfService:25 groupName:PKCloudStoreOperationGroupUserActionExplicit groupNameSuffix:PKCloudStoreOperationGroupSuffixPassutil];
      [(PDCloudStoreRecordsRequest *)v13 setRecordsToSaveByDatabaseIdentifier:v4];
      long long v14 = *(void **)(a1 + 40);
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 3221225472;
      v22[2] = sub_1000C2248;
      void v22[3] = &unk_1007343D8;
      id v23 = *(id *)(a1 + 56);
      [v14 executeRecordsRequest:v13 completion:v22];
    }
    else
    {
      if (!*(void *)(a1 + 56))
      {
LABEL_20:

        return;
      }
      id v17 = *(void **)(a1 + 40);
      id v18 = +[NSString stringWithFormat:@"There are no account with identifier %@", *(void *)(a1 + 48)];
      id v4 = [v17 errorWithCode:-4002 description:v18];

      id v19 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = *(void *)(a1 + 48);
        *(_DWORD *)id buf = 138412290;
        uint64_t v32 = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "There are no account with identifier %@", buf, 0xCu);
      }

      (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    }

    goto LABEL_20;
  }
  id v15 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "There are no events to sync with clout kit", buf, 2u);
  }

  uint64_t v16 = *(void *)(a1 + 56);
  if (v16) {
    (*(void (**)(uint64_t, void, void))(v16 + 16))(v16, 0, 0);
  }
}

void sub_1000C205C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id v7 = [v6 countByEnumeratingWithState:&v20 objects:v26 count:16];
  if (v7)
  {
    id v9 = v7;
    uint64_t v10 = *(void *)v21;
    *(void *)&long long v8 = 138412290;
    long long v19 = v8;
    do
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v21 != v10) {
          objc_enumerationMutation(v6);
        }
        __int16 v12 = objc_msgSend(*(id *)(*((void *)&v20 + 1) + 8 * i), "recordZone", v19);
        if (v12)
        {
          id v13 = [*(id *)(a1 + 32) _recordsByFromAccountEvent:*(void *)(a1 + 40) zone:v12];
          long long v14 = [*(id *)(a1 + 48) objectForKey:v5];
          id v15 = v14;
          if (v14) {
            id v16 = v14;
          }
          else {
            id v16 = objc_alloc_init((Class)NSMutableSet);
          }
          id v18 = v16;

          [*(id *)(a1 + 48) setObject:v18 forKey:v5];
          [v18 unionSet:v13];
        }
        else
        {
          id v13 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v17 = *(void *)(a1 + 40);
            *(_DWORD *)id buf = v19;
            uint64_t v25 = v17;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Error: No zone defined for account event %@", buf, 0xCu);
          }
        }
      }
      id v9 = [v6 countByEnumeratingWithState:&v20 objects:v26 count:16];
    }
    while (v9);
  }
}

void sub_1000C2248(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    id v5 = a3;
    id v6 = [a2 cloudStoreRecords];
    (*(void (**)(uint64_t, id, id))(v3 + 16))(v3, v6, v5);
  }
}

void sub_1000C2364(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDApplePayCloudStoreContainer: Received peer payment account change notification. Updating peer payment account.", v9, 2u);
  }

  uint64_t v3 = *(id **)(a1 + 32);
  id v4 = v3[34];
  id v5 = [v3 dataSource];
  uint64_t v6 = [v5 peerPaymentAccount];
  uint64_t v7 = *(void *)(a1 + 32);
  long long v8 = *(void **)(v7 + 272);
  *(void *)(v7 + 272) = v6;

  objc_msgSend(*(id *)(a1 + 32), "_queue_processPeerPaymentAccountChangeWithOldAccount:newPeerPaymentAccount:", v4, *(void *)(*(void *)(a1 + 32) + 272));
}

void sub_1000C24E8(uint64_t a1)
{
  if (((unint64_t)[*(id *)(a1 + 32) type] | 2) != 2)
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      int v10 = 138412290;
      uint64_t v11 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDApplePayCloudStoreContainer: Received account added notification. %@", (uint8_t *)&v10, 0xCu);
    }

    id v4 = *(id **)(a1 + 40);
    id v5 = v4[35];
    uint64_t v6 = [v4 dataSource];
    uint64_t v7 = [v6 accounts];
    uint64_t v8 = *(void *)(a1 + 40);
    id v9 = *(void **)(v8 + 280);
    *(void *)(v8 + 280) = v7;

    objc_msgSend(*(id *)(a1 + 40), "_queue_processAccountChangeWithOldAccounts:newAccounts:", v5, *(void *)(*(void *)(a1 + 40) + 280));
  }
}

void sub_1000C26BC(uint64_t a1)
{
  if (((unint64_t)[*(id *)(a1 + 32) type] | 2) != 2)
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      int v10 = 138412290;
      uint64_t v11 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDApplePayCloudStoreContainer: Received account removed notification %@", (uint8_t *)&v10, 0xCu);
    }

    id v4 = *(id **)(a1 + 40);
    id v5 = v4[35];
    uint64_t v6 = [v4 dataSource];
    uint64_t v7 = [v6 accounts];
    uint64_t v8 = *(void *)(a1 + 40);
    id v9 = *(void **)(v8 + 280);
    *(void *)(v8 + 280) = v7;

    objc_msgSend(*(id *)(a1 + 40), "_queue_processAccountChangeWithOldAccounts:newAccounts:", v5, *(void *)(*(void *)(a1 + 40) + 280));
  }
}

void sub_1000C28B4(uint64_t a1)
{
  if (((unint64_t)[*(id *)(a1 + 32) type] | 2) != 2)
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      uint64_t v3 = *(void *)(a1 + 40);
      int v11 = 138412546;
      uint64_t v12 = v3;
      __int16 v13 = 2112;
      uint64_t v14 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDApplePayCloudStoreZoneManager: Received account changed notification from oldAccount %@ to newAccount %@", (uint8_t *)&v11, 0x16u);
    }

    id v5 = *(id **)(a1 + 48);
    id v6 = v5[35];
    uint64_t v7 = [v5 dataSource];
    uint64_t v8 = [v7 accounts];
    uint64_t v9 = *(void *)(a1 + 48);
    int v10 = *(void **)(v9 + 280);
    *(void *)(v9 + 280) = v8;

    objc_msgSend(*(id *)(a1 + 48), "_queue_processAccountChangeWithOldAccounts:newAccounts:", v6, *(void *)(*(void *)(a1 + 48) + 280));
  }
}

void sub_1000C2A94(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 288) objectForKey:*(void *)(a1 + 40)];
  uint64_t v3 = [*(id *)(a1 + 32) dataSource];
  uint64_t v4 = [v3 sharedAccountCloudStoreByAccountIdentifier];
  uint64_t v5 = *(void *)(a1 + 32);
  id v6 = *(void **)(v5 + 288);
  *(void *)(v5 + 28_Block_object_dispose(&STACK[0x420], 8) = v4;

  uint64_t v7 = [*(id *)(*(void *)(a1 + 32) + 288) objectForKey:*(void *)(a1 + 40)];
  uint64_t v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(a1 + 40);
    int v10 = 138412546;
    uint64_t v11 = v9;
    __int16 v12 = 2112;
    __int16 v13 = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDApplePayCloudStoreZoneManager: Received shared account changed notification for accountIdentifier %@. New shared account cloud store %@", (uint8_t *)&v10, 0x16u);
  }

  objc_msgSend(*(id *)(a1 + 32), "_queue_processSharedAccountCloudStoreChangeWithOldSharedAccountCloudStore:newSharedAccountCloudStore:", v2, v7);
}

void sub_1000C2C7C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) dataSource];
  uint64_t v3 = [v2 accountUsersByAccountIdentifier];
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void **)(v4 + 296);
  *(void *)(v4 + 296) = v3;

  id v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 40);
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 296);
    int v10 = 138412546;
    uint64_t v11 = v7;
    __int16 v12 = 2112;
    uint64_t v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "PDApplePayCloudStoreZoneManager: Received account users changed notification for accountIdentifier %@. %@", (uint8_t *)&v10, 0x16u);
  }

  uint64_t v9 = [*(id *)(*(void *)(a1 + 32) + 288) objectForKey:*(void *)(a1 + 40)];
  objc_msgSend(*(id *)(a1 + 32), "_queue_processSharedAccountCloudStoreChangeWithOldSharedAccountCloudStore:newSharedAccountCloudStore:", v9, v9);
}

void sub_1000C2F18(uint64_t a1, void *a2)
{
  id v5 = a2;
  if ([v5 role] == (id)1)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = [*(id *)(a1 + 40) _peerPaymentZoneNamesForAccount:v5 containerDatabase:*(void *)(a1 + 48)];
    [v3 unionSet:v4];
  }
}

uint64_t sub_1000C5580(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 accountIdentifier];
  uint64_t v4 = *(void **)(a1 + 32);
  id v5 = v3;
  id v6 = v4;
  uint64_t v7 = v6;
  if (v5 == v6)
  {
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    if (v5 && v6) {
      uint64_t v8 = (uint64_t)[v5 isEqualToString:v6];
    }
  }

  return v8;
}

id sub_1000C5604(id a1, PKPaymentTransactionArchiveLocation *a2)
{
  id v2 = [(PKPaymentTransactionArchiveLocation *)a2 cloudStoreZone];
  uint64_t v3 = [v2 zoneName];

  return v3;
}

id sub_1000C5A1C(id a1, PKSharedAccountCloudStoreZone *a2)
{
  return [(PKSharedAccountCloudStoreZone *)a2 zoneName];
}

id sub_1000C5F34(uint64_t a1)
{
  objc_msgSend(*(id *)(a1 + 32), "_queue_ensureZoneShareIntegrity");
  id v2 = *(void **)(a1 + 32);
  return [v2 _updateFetchTaskScheduledActivityIfNeccessary];
}

void sub_1000C5F70(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) workQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000C6010;
  block[3] = &unk_10072F788;
  id v4 = *(id *)(a1 + 40);
  dispatch_async(v2, block);
}

uint64_t sub_1000C6010(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000C676C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) workQueue];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000C6810;
  v4[3] = &unk_10072E198;
  uint64_t v3 = *(void **)(a1 + 40);
  void v4[4] = *(void *)(a1 + 32);
  id v5 = v3;
  dispatch_async(v2, v4);
}

id sub_1000C6810(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) reportContainerChangeIntervalEndEventWithBeginUniqueIdentifier:*(void *)(a1 + 40) error:0];
  *(unsigned char *)(*(void *)(a1 + 32) + 184) = 0;
  return result;
}

uint64_t sub_1000C6B60(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed ensuring zone share integrity check for peer payment.", v4, 2u);
  }

  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_1000C6BE4(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  id v4 = objc_alloc_init((Class)NSMutableSet);
  id v5 = objc_alloc_init((Class)NSMutableSet);
  v91[0] = _NSConcreteStackBlock;
  v91[1] = 3221225472;
  v91[2] = sub_1000C7784;
  v91[3] = &unk_100734548;
  id v56 = v4;
  v92 = v56;
  id v53 = v5;
  id v93 = v53;
  id v55 = v3;
  [v3 enumerateObjectsUsingBlock:v91];
  id v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(NSObject **)(a1 + 32);
    *(_DWORD *)id buf = 138412546;
    long long v98 = v55;
    __int16 v99 = 2112;
    long long v100 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Ensuring zone shares for family members %@ in zones %@", buf, 0x16u);
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)id buf = 138412290;
    long long v98 = v56;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Family members who current user can share %@", buf, 0xCu);
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)id buf = 138412290;
    long long v98 = v53;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Family members who current user cannot share %@", buf, 0xCu);
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = [v55 count];
    id v9 = [*(id *)(a1 + 32) count];
    uint64_t v10 = *(void *)(a1 + 32);
    *(_DWORD *)id buf = 134218754;
    long long v98 = v8;
    __int16 v99 = 2112;
    long long v100 = v55;
    __int16 v101 = 2048;
    id v102 = v9;
    __int16 v103 = 2112;
    uint64_t v104 = v10;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Ensuring zone shares for %lu family members %@ in %lu zones %@", buf, 0x2Au);
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = [v56 count];
    *(_DWORD *)id buf = 134218242;
    long long v98 = v11;
    __int16 v99 = 2112;
    long long v100 = v56;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%lu family members who current user can share %@", buf, 0x16u);
  }

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v12 = [v53 count];
    *(_DWORD *)id buf = 134218242;
    long long v98 = v12;
    __int16 v99 = 2112;
    long long v100 = v53;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%lu family members who current user cannot share %@", buf, 0x16u);
  }

  group = dispatch_group_create();
  long long v87 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  id obj = *(id *)(a1 + 32);
  id v51 = [obj countByEnumeratingWithState:&v87 objects:v96 count:16];
  if (v51)
  {
    uint64_t v50 = *(void *)v88;
    uint64_t v60 = a1;
    do
    {
      uint64_t v13 = 0;
      do
      {
        if (*(void *)v88 != v50) {
          objc_enumerationMutation(obj);
        }
        uint64_t v52 = v13;
        uint64_t v14 = *(NSObject **)(*((void *)&v87 + 1) + 8 * v13);
        id v15 = [v14 shareParticipants];
        long long v83 = 0u;
        long long v84 = 0u;
        long long v85 = 0u;
        long long v86 = 0u;
        id v54 = v15;
        id v16 = [v15 countByEnumeratingWithState:&v83 objects:v95 count:16];
        if (v16)
        {
          id v17 = v16;
          id v57 = *(id *)v84;
          do
          {
            for (uint64_t i = 0; i != v17; uint64_t i = (char *)i + 1)
            {
              if (*(id *)v84 != v57) {
                objc_enumerationMutation(v54);
              }
              long long v19 = [*(id *)(*((void *)&v83 + 1) + 8 * i) participantHandle];
              v81[0] = _NSConcreteStackBlock;
              v81[1] = 3221225472;
              v81[2] = sub_1000C77F4;
              v81[3] = &unk_100734570;
              id v20 = v19;
              id v82 = v20;
              long long v21 = +[NSPredicate predicateWithBlock:v81];
              [v56 filterUsingPredicate:v21];

              v79[0] = _NSConcreteStackBlock;
              v79[1] = 3221225472;
              v79[2] = sub_1000C7818;
              v79[3] = &unk_100733CE0;
              long long v22 = v20;
              __int16 v80 = v22;
              long long v23 = [v55 pk_firstObjectPassingTest:v79];
              if (*(void *)(a1 + 56) != 1)
              {
                BOOL v27 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
                long long v28 = v6;
                if (v27)
                {
                  *(_DWORD *)id buf = 138412546;
                  long long v98 = v22;
                  __int16 v99 = 2114;
                  long long v100 = v14;
                  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Removing share for %@ in zone %{public}@ since the user is not a participant anymore.", buf, 0x16u);
                  long long v28 = v6;
                }
                goto LABEL_34;
              }
              v77[0] = _NSConcreteStackBlock;
              v77[1] = 3221225472;
              v77[2] = sub_1000C7824;
              v77[3] = &unk_100733CE0;
              id v24 = v22;
              id v78 = v24;
              if (![v53 pk_hasObjectPassingTest:v77])
              {
                long long v29 = (id *)&v78;
                if (v23) {
                  goto LABEL_35;
                }
                if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_33;
                }
                *(_DWORD *)id buf = 138412546;
                long long v98 = v24;
                __int16 v99 = 2114;
                long long v100 = v14;
                uint64_t v25 = v6;
                long long v26 = "Removing share for %@ in zone %{public}@ since they are not in the family.";
                goto LABEL_32;
              }
              if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)id buf = 138412546;
                long long v98 = v24;
                __int16 v99 = 2114;
                long long v100 = v14;
                uint64_t v25 = v6;
                long long v26 = "Removing share for %@ in zone %{public}@ since the user is not a participant anymore.";
LABEL_32:
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v26, buf, 0x16u);
              }
LABEL_33:

              long long v28 = v78;
LABEL_34:

              dispatch_group_enter(group);
              uint64_t v30 = [*(id *)(a1 + 40) delegate];
              uint64_t v31 = *(void *)(a1 + 40);
              uint64_t v32 = [v14 zoneName];
              v75[0] = _NSConcreteStackBlock;
              v75[1] = 3221225472;
              v75[2] = sub_1000C7830;
              v75[3] = &unk_1007300F8;
              id v76 = group;
              [v30 cloudStoreContainer:v31 removeZoneShareInvitationForHandle:v22 zoneName:v32 qualitOfService:17 completion:v75];

              a1 = v60;
              long long v29 = (id *)&v76;
LABEL_35:
            }
            id v17 = [v54 countByEnumeratingWithState:&v83 objects:v95 count:16];
          }
          while (v17);
        }
        if (*(void *)(a1 + 56) == 1)
        {
          long long v73 = 0u;
          long long v74 = 0u;
          long long v71 = 0u;
          long long v72 = 0u;
          id v58 = v56;
          id v33 = [v58 countByEnumeratingWithState:&v71 objects:v94 count:16];
          if (v33)
          {
            id v34 = v33;
            uint64_t v35 = *(void *)v72;
            do
            {
              for (uint64_t j = 0; j != v34; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v72 != v35) {
                  objc_enumerationMutation(v58);
                }
                long long v37 = *(NSObject **)(*((void *)&v71 + 1) + 8 * (void)j);
                if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)id buf = 138412546;
                  long long v98 = v37;
                  __int16 v99 = 2114;
                  long long v100 = v14;
                  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Creating share for %@ in zone %{public}@ since we have not shared the zone yet.", buf, 0x16u);
                }

                dispatch_group_enter(group);
                long long v38 = [*(id *)(v60 + 40) delegate];
                uint64_t v39 = *(void *)(v60 + 40);
                id v40 = [v37 appleID];
                CFStringRef v41 = [v14 zoneName];
                v69[0] = _NSConcreteStackBlock;
                v69[1] = 3221225472;
                v69[2] = sub_1000C7838;
                v69[3] = &unk_1007300F8;
                long long v70 = group;
                [v38 cloudStoreContainer:v39 sendZoneShareInvitationForHandle:v40 zoneName:v41 permission:2 qualitOfService:17 completion:v69];
              }
              id v34 = [v58 countByEnumeratingWithState:&v71 objects:v94 count:16];
            }
            while (v34);
          }

          a1 = v60;
        }

        uint64_t v13 = v52 + 1;
      }
      while ((id)(v52 + 1) != v51);
      id v51 = [obj countByEnumeratingWithState:&v87 objects:v96 count:16];
    }
    while (v51);
  }

  if (!*(void *)(a1 + 56))
  {
    CFStringRef v42 = [*(id *)(a1 + 40) containerManager];
    id v43 = [v42 databaseForScope:3];

    v67[0] = _NSConcreteStackBlock;
    v67[1] = 3221225472;
    v67[2] = sub_1000C7840;
    v67[3] = &unk_100734598;
    id v44 = objc_alloc_init((Class)NSMutableDictionary);
    id v68 = v44;
    [v55 enumerateObjectsUsingBlock:v67];
    id v45 = [*(id *)(*(void *)(a1 + 40) + 272) associatedAccountInformation];
    v63[0] = _NSConcreteStackBlock;
    v63[1] = 3221225472;
    void v63[2] = sub_1000C78A4;
    v63[3] = &unk_1007345C0;
    v63[4] = *(void *)(a1 + 40);
    id v64 = v43;
    id v65 = v44;
    id v66 = group;
    id v46 = v44;
    id v47 = v43;
    [v45 enumerateAssociatedAccountsUsingBlock:v63];
  }
  id v48 = [*(id *)(a1 + 40) workQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000C7BC0;
  block[3] = &unk_10072F788;
  id v62 = *(id *)(a1 + 48);
  dispatch_group_notify(group, v48, block);
}

void sub_1000C7784(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (([v5 isMe] & 1) == 0)
  {
    unsigned int v3 = [v5 canSharePeerPaymentAccount];
    uint64_t v4 = 40;
    if (v3) {
      uint64_t v4 = 32;
    }
    [*(id *)(a1 + v4) addObject:v5];
  }
}

uint64_t sub_1000C77F4(uint64_t a1, void *a2)
{
  return [a2 hasAppleIDAlias:*(void *)(a1 + 32)] ^ 1;
}

id sub_1000C7818(uint64_t a1, void *a2)
{
  return [a2 hasAppleIDAlias:*(void *)(a1 + 32)];
}

id sub_1000C7824(uint64_t a1, void *a2)
{
  return [a2 hasAppleIDAlias:*(void *)(a1 + 32)];
}

void sub_1000C7830(uint64_t a1)
{
}

void sub_1000C7838(uint64_t a1)
{
}

void sub_1000C7840(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v3 altDSID];
  [v2 setObject:v3 forKey:v4];
}

void sub_1000C78A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([v3 role] == (id)1)
  {
    id v4 = [v3 cloudStoreZoneNames];
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    id v5 = [v4 countByEnumeratingWithState:&v28 objects:v36 count:16];
    if (!v5) {
      goto LABEL_18;
    }
    id v7 = v5;
    uint64_t v8 = *(void *)v29;
    *(void *)&long long v6 = 138412290;
    long long v22 = v6;
    long long v23 = v4;
    while (1)
    {
      id v9 = 0;
      id v24 = v7;
      do
      {
        if (*(void *)v29 != v8) {
          objc_enumerationMutation(v4);
        }
        uint64_t v10 = *(void *)(*((void *)&v28 + 1) + 8 * (void)v9);
        uint64_t v11 = objc_msgSend(*(id *)(a1 + 32), "containerManager", v22);
        __int16 v12 = [v11 cloudStoreZoneForZoneName:v10 inContainerDatabase:*(void *)(a1 + 40)];

        if (!v12)
        {
          uint64_t v25 = [v3 altDSID];
          uint64_t v13 = objc_msgSend(*(id *)(a1 + 48), "objectForKey:");
          uint64_t v14 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = 138543618;
            uint64_t v33 = v10;
            __int16 v34 = 2112;
            uint64_t v35 = v13;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "There is no zone with name %{public}@ in the shared database> Asking %@ for a zone invitation", buf, 0x16u);
          }

          if (v13)
          {
            dispatch_group_enter(*(dispatch_group_t *)(a1 + 56));
            id v15 = [*(id *)(a1 + 32) delegate];
            uint64_t v16 = v8;
            uint64_t v17 = *(void *)(a1 + 32);
            [v13 appleID];
            v19 = id v18 = v3;
            v26[0] = _NSConcreteStackBlock;
            v26[1] = 3221225472;
            v26[2] = sub_1000C7BB8;
            v26[3] = &unk_1007300F8;
            BOOL v27 = *(id *)(a1 + 56);
            uint64_t v20 = v17;
            uint64_t v8 = v16;
            id v7 = v24;
            [v15 cloudStoreContainer:v20 requestsZoneShareFromHandle:v19 zoneName:v10 completion:v26];

            id v3 = v18;
            id v4 = v23;

            uint64_t v14 = v27;
            goto LABEL_14;
          }
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = v22;
            long long v21 = (void *)v25;
            uint64_t v33 = v25;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Cannot request zone share data for altDSID %@ because there is no associated member of the family.", buf, 0xCu);
          }
          else
          {
LABEL_14:
            long long v21 = (void *)v25;
          }
        }
        id v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      id v7 = [v4 countByEnumeratingWithState:&v28 objects:v36 count:16];
      if (!v7)
      {
LABEL_18:

        break;
      }
    }
  }
}

void sub_1000C7BB8(uint64_t a1)
{
}

uint64_t sub_1000C7BC0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000C7DB4(uint64_t a1, void *a2)
{
  id v108 = a2;
  long long v160 = 0u;
  long long v161 = 0u;
  long long v162 = 0u;
  long long v163 = 0u;
  id obj = *(id *)(*(void *)(a1 + 32) + 288);
  id v106 = [obj countByEnumeratingWithState:&v160 objects:v180 count:16];
  if (v106)
  {
    uint64_t v105 = *(void *)v161;
    id v3 = PKCloudStoreTransactionsZoneName;
    v113 = PKCloudStoreTransactionsZoneName;
    do
    {
      uint64_t v4 = 0;
      do
      {
        if (*(void *)v161 != v105) {
          objc_enumerationMutation(obj);
        }
        uint64_t v107 = v4;
        id v5 = *(NSObject **)(*((void *)&v160 + 1) + 8 * v4);
        v120 = [*(id *)(*(void *)(a1 + 32) + 296) objectForKey:v5];
        uint64_t v119 = [v120 currentAccountUser];
        v110 = v5;
        long long v6 = [*(id *)(*(void *)(a1 + 32) + 288) objectForKey:v5];
        long long v156 = 0u;
        long long v157 = 0u;
        long long v158 = 0u;
        long long v159 = 0u;
        long long v109 = v6;
        id v114 = [v6 sharedAccountCloudStoreZonesWithAccess:1];
        id v7 = [v114 countByEnumeratingWithState:&v156 objects:v179 count:16];
        if (v7)
        {
          id v8 = v7;
          uint64_t v9 = *(void *)v157;
          uint64_t v111 = *(void *)v157;
          do
          {
            uint64_t v10 = 0;
            id v112 = v8;
            do
            {
              if (*(void *)v157 != v9) {
                objc_enumerationMutation(v114);
              }
              v124 = *(void **)(*((void *)&v156 + 1) + 8 * (void)v10);
              uint64_t v11 = [v124 zoneName];
              __int16 v12 = [*(id *)(a1 + 32) containerManager];
              uint64_t v13 = [v12 cloudStoreZoneForZoneName:v11 inContainerDatabase:*(void *)(a1 + 40)];

              if (v13)
              {
                uint64_t v14 = v11;
                id v15 = v3;
                if (v14 == v3) {
                  goto LABEL_94;
                }
                uint64_t v16 = v14;
                if (v14) {
                  BOOL v17 = v3 == 0;
                }
                else {
                  BOOL v17 = 1;
                }
                if (v17)
                {

                  id v18 = v120;
LABEL_22:
                  v116 = v10;
                  v117 = v13;
                  v115 = v11;
                  id v121 = objc_alloc_init((Class)NSMutableArray);
                  long long v152 = 0u;
                  long long v153 = 0u;
                  long long v154 = 0u;
                  long long v155 = 0u;
                  long long v21 = [v124 sharedUsersAltDSIDs];
                  id v22 = [v21 countByEnumeratingWithState:&v152 objects:v178 count:16];
                  uint64_t v23 = v119;
                  if (!v22) {
                    goto LABEL_41;
                  }
                  id v24 = v22;
                  uint64_t v25 = *(void *)v153;
                  while (2)
                  {
                    uint64_t v26 = 0;
LABEL_25:
                    if (*(void *)v153 != v25) {
                      objc_enumerationMutation(v21);
                    }
                    BOOL v27 = *(NSObject **)(*((void *)&v152 + 1) + 8 * v26);
                    long long v28 = [v18 accountUserWithAltDSID:v27];
                    if (v23)
                    {
                      if (+[PKAccountUser currentUser:v23 canShareZone:v124 withAccountUser:v28])
                      {
                        if (v28)
                        {
                          [v121 addObject:v28];
                          goto LABEL_39;
                        }
                        long long v31 = PKLogFacilityTypeGetObject();
                        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)id buf = 138412290;
                          v168 = v27;
                          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "There is no account user for altDSID %@", buf, 0xCu);
                        }
                      }
                      else
                      {
                        long long v31 = PKLogFacilityTypeGetObject();
                        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v32 = [v124 zoneName];
                          *(_DWORD *)id buf = 138543874;
                          v168 = v32;
                          __int16 v169 = 2112;
                          v170 = v27;
                          __int16 v171 = 2112;
                          uint64_t v172 = (uint64_t)v28;
                          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Not sharing zone %{public}@ with altDSID %@ since the account state is not acceptable %@.", buf, 0x20u);

                          uint64_t v23 = v119;
                        }
                      }

                      id v18 = v120;
                    }
                    else
                    {
                      long long v29 = PKLogFacilityTypeGetObject();
                      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
                      {
                        long long v30 = [v124 zoneName];
                        *(_DWORD *)id buf = 138543618;
                        v168 = v30;
                        __int16 v169 = 2112;
                        v170 = v28;
                        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "The current account is not defined. Cannot share zone %{public}@ for user %@.", buf, 0x16u);

                        uint64_t v23 = v119;
                      }
                    }
LABEL_39:

                    if (v24 == (id)++v26)
                    {
                      id v24 = [v21 countByEnumeratingWithState:&v152 objects:v178 count:16];
                      if (!v24)
                      {
LABEL_41:

                        id v33 = objc_alloc_init((Class)NSMutableSet);
                        long long v148 = 0u;
                        long long v149 = 0u;
                        long long v150 = 0u;
                        long long v151 = 0u;
                        __int16 v34 = [v117 shareParticipants];
                        id v35 = [v34 countByEnumeratingWithState:&v148 objects:v177 count:16];
                        if (v35)
                        {
                          id v36 = v35;
                          uint64_t v37 = *(void *)v149;
                          do
                          {
                            for (uint64_t i = 0; i != v36; uint64_t i = (char *)i + 1)
                            {
                              if (*(void *)v149 != v37) {
                                objc_enumerationMutation(v34);
                              }
                              uint64_t v39 = [*(id *)(*((void *)&v148 + 1) + 8 * i) participantHandle];
                              [v33 addObject:v39];
                            }
                            id v36 = [v34 countByEnumeratingWithState:&v148 objects:v177 count:16];
                          }
                          while (v36);
                        }

                        id v118 = objc_alloc_init((Class)NSMutableSet);
                        long long v144 = 0u;
                        long long v145 = 0u;
                        long long v146 = 0u;
                        long long v147 = 0u;
                        id v15 = v121;
                        id v40 = [v15 countByEnumeratingWithState:&v144 objects:v176 count:16];
                        if (v40)
                        {
                          id v41 = v40;
                          uint64_t v42 = *(void *)v145;
                          do
                          {
                            for (uint64_t j = 0; j != v41; uint64_t j = (char *)j + 1)
                            {
                              if (*(void *)v145 != v42) {
                                objc_enumerationMutation(v15);
                              }
                              id v44 = *(NSObject **)(*((void *)&v144 + 1) + 8 * (void)j);
                              v143[0] = _NSConcreteStackBlock;
                              v143[1] = 3221225472;
                              v143[2] = sub_1000C8E54;
                              v143[3] = &unk_100734610;
                              v143[4] = v44;
                              if ((objc_msgSend(v33, "pk_hasObjectPassingTest:", v143) & 1) == 0)
                              {
                                id v45 = [v44 appleID];
                                if (v45)
                                {
                                  [v118 addObject:v45];
                                }
                                else
                                {
                                  id v46 = PKLogFacilityTypeGetObject();
                                  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                                  {
                                    *(_DWORD *)id buf = 138412290;
                                    v168 = v44;
                                    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "There is no appleID for user %@ and no family member with the altDSID", buf, 0xCu);
                                  }
                                }
                              }
                            }
                            id v41 = [v15 countByEnumeratingWithState:&v144 objects:v176 count:16];
                          }
                          while (v41);
                        }

                        id v122 = objc_alloc_init((Class)NSMutableSet);
                        long long v139 = 0u;
                        long long v140 = 0u;
                        long long v141 = 0u;
                        long long v142 = 0u;
                        id v47 = v33;
                        id v48 = [v47 countByEnumeratingWithState:&v139 objects:v175 count:16];
                        if (v48)
                        {
                          id v49 = v48;
                          uint64_t v50 = *(void *)v140;
                          do
                          {
                            for (k = 0; k != v49; k = (char *)k + 1)
                            {
                              if (*(void *)v140 != v50) {
                                objc_enumerationMutation(v47);
                              }
                              uint64_t v52 = *(void *)(*((void *)&v139 + 1) + 8 * (void)k);
                              v138[0] = _NSConcreteStackBlock;
                              v138[1] = 3221225472;
                              v138[2] = sub_1000C8E60;
                              v138[3] = &unk_100734638;
                              v138[4] = v52;
                              if ((-[NSObject pk_containsObjectPassingTest:](v15, "pk_containsObjectPassingTest:", v138) & 1) == 0)[v122 addObject:v52]; {
                            }
                              }
                            id v49 = [v47 countByEnumeratingWithState:&v139 objects:v175 count:16];
                          }
                          while (v49);
                        }

                        if ([v118 count])
                        {
                          id v53 = PKLogFacilityTypeGetObject();
                          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
                          {
                            id v54 = [v118 count];
                            id v55 = [v124 zoneName];
                            id v56 = [v117 zoneName];
                            *(_DWORD *)id buf = 134218754;
                            v168 = v54;
                            __int16 v169 = 2114;
                            v170 = v55;
                            __int16 v171 = 2114;
                            uint64_t v172 = (uint64_t)v56;
                            __int16 v173 = 2112;
                            id v174 = v118;
                            _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "%lu account users that need a zone share for shared account zone %{public}@, cloud store zone %{public}@: %@", buf, 0x2Au);
                          }
                          long long v136 = 0u;
                          long long v137 = 0u;
                          long long v134 = 0u;
                          long long v135 = 0u;
                          id v57 = v118;
                          id v58 = [v57 countByEnumeratingWithState:&v134 objects:v166 count:16];
                          if (v58)
                          {
                            id v59 = v58;
                            uint64_t v60 = *(void *)v135;
                            do
                            {
                              for (m = 0; m != v59; m = (char *)m + 1)
                              {
                                if (*(void *)v135 != v60) {
                                  objc_enumerationMutation(v57);
                                }
                                uint64_t v62 = *(void *)(*((void *)&v134 + 1) + 8 * (void)m);
                                long long v63 = [*(id *)(a1 + 32) delegate];
                                [v63 cloudStoreContainer:*(void *)(a1 + 32) sendZoneShareInvitationForHandle:v62 zoneName:v16 permission:3 qualitOfService:17 completion:0];
                              }
                              id v59 = [v57 countByEnumeratingWithState:&v134 objects:v166 count:16];
                            }
                            while (v59);
                          }
                        }
                        uint64_t v13 = v117;
                        if ([v122 count])
                        {
                          id v64 = PKLogFacilityTypeGetObject();
                          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
                          {
                            id v65 = [v122 count];
                            id v66 = [v124 zoneName];
                            id v67 = [v117 zoneName];
                            *(_DWORD *)id buf = 134218754;
                            v168 = v65;
                            __int16 v169 = 2114;
                            v170 = v66;
                            __int16 v171 = 2114;
                            uint64_t v172 = (uint64_t)v67;
                            __int16 v173 = 2112;
                            id v174 = v122;
                            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%lu account users that need to be removed from the zone share for shared account zone %{public}@, cloud store zone %{public}@: %@", buf, 0x2Au);
                          }
                          long long v132 = 0u;
                          long long v133 = 0u;
                          long long v130 = 0u;
                          long long v131 = 0u;
                          id v68 = v122;
                          id v69 = [v68 countByEnumeratingWithState:&v130 objects:v165 count:16];
                          if (v69)
                          {
                            id v70 = v69;
                            uint64_t v71 = *(void *)v131;
                            do
                            {
                              for (n = 0; n != v70; n = (char *)n + 1)
                              {
                                if (*(void *)v131 != v71) {
                                  objc_enumerationMutation(v68);
                                }
                                uint64_t v73 = *(void *)(*((void *)&v130 + 1) + 8 * (void)n);
                                long long v74 = [*(id *)(a1 + 32) delegate];
                                [v74 cloudStoreContainer:*(void *)(a1 + 32) removeZoneShareInvitationForHandle:v73 zoneName:v16 qualitOfService:17 completion:0];
                              }
                              id v70 = [v68 countByEnumeratingWithState:&v130 objects:v165 count:16];
                            }
                            while (v70);
                          }

                          uint64_t v13 = v117;
                        }

                        id v8 = v112;
                        id v3 = v113;
                        uint64_t v9 = v111;
                        uint64_t v11 = v115;
                        uint64_t v10 = v116;
                        goto LABEL_94;
                      }
                      continue;
                    }
                    goto LABEL_25;
                  }
                }
                unsigned __int8 v20 = [v14 isEqualToString:v3];

                id v18 = v120;
                if ((v20 & 1) == 0) {
                  goto LABEL_22;
                }
              }
              else
              {
                id v15 = PKLogFacilityTypeGetObject();
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                {
                  long long v19 = [v124 zoneName];
                  *(_DWORD *)id buf = 138543362;
                  v168 = v19;
                  _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Error: A cloud store zone was not found for shared account cloud store zone %{public}@", buf, 0xCu);
                }
LABEL_94:
              }
              uint64_t v10 = (char *)v10 + 1;
            }
            while (v10 != v8);
            id v8 = [v114 countByEnumeratingWithState:&v156 objects:v179 count:16];
          }
          while (v8);
        }

        long long v128 = 0u;
        long long v129 = 0u;
        long long v126 = 0u;
        long long v127 = 0u;
        id v75 = [v109 sharedAccountCloudStoreZonesWithAccess:2];
        id v76 = [v75 countByEnumeratingWithState:&v126 objects:v164 count:16];
        id v77 = (void *)v119;
        if (!v76) {
          goto LABEL_140;
        }
        id v78 = v76;
        uint64_t v79 = *(void *)v127;
        v125 = v75;
        do
        {
          __int16 v80 = 0;
          do
          {
            if (*(void *)v127 != v79) {
              objc_enumerationMutation(v75);
            }
            id v81 = *(void **)(*((void *)&v126 + 1) + 8 * (void)v80);
            id v82 = [v81 zoneName];
            long long v83 = [*(id *)(a1 + 32) containerManager];
            long long v84 = [v83 cloudStoreZoneForZoneName:v82 inContainerDatabase:*(void *)(a1 + 48)];

            id v77 = (void *)v119;
            if (!v119)
            {
              long long v88 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
              {
                long long v89 = *(NSObject **)(a1 + 56);
                *(_DWORD *)id buf = 138412546;
                v168 = v110;
                __int16 v169 = 2112;
                v170 = v89;
                _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "An account user is not defined for the account %@ and altDSID %@", buf, 0x16u);
              }
              goto LABEL_134;
            }
            if ((+[PKAccountUser currentUser:v119 shouldRequestZoneShareForZone:v81] & 1) == 0)
            {
              long long v88 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
              {
                long long v90 = [v81 zoneName];
                v91 = *(NSObject **)(a1 + 56);
                *(_DWORD *)id buf = 138543874;
                v168 = v90;
                __int16 v169 = 2112;
                v170 = v91;
                __int16 v171 = 2112;
                uint64_t v172 = v119;
                _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "Not sharing zone => %{public}@ with altDSID => %@ since the account state is not acceptable => %@.", buf, 0x20u);
              }
              goto LABEL_134;
            }
            if (v84) {
              goto LABEL_135;
            }
            long long v85 = v82;
            if (v85 == v113)
            {

LABEL_118:
              long long v88 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)id buf = 138412290;
                v168 = v109;
                _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "Error: The transactions zone can never be shared. %@", buf, 0xCu);
              }
              id v77 = (void *)v119;
              id v75 = v125;
              goto LABEL_134;
            }
            long long v86 = v85;
            if (v85) {
              BOOL v87 = v113 == 0;
            }
            else {
              BOOL v87 = 1;
            }
            if (v87)
            {
            }
            else
            {
              unsigned int v92 = -[NSObject isEqualToString:](v85, "isEqualToString:");

              if (v92) {
                goto LABEL_118;
              }
            }
            long long v88 = [v81 originatorAltDSID];
            id v93 = [v120 accountUserWithAltDSID:v88];
            v123 = v93;
            if (!v93)
            {
              long long v96 = PKLogFacilityTypeGetObject();
              id v75 = v125;
              if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)id buf = 138412290;
                v168 = 0;
                _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "The shared account zone originator with altDSID %@ is not an account user.", buf, 0xCu);
              }
              id v77 = (void *)v119;
              goto LABEL_133;
            }
            long long v94 = v93;
            long long v95 = [v93 appleID];

            if (v95)
            {
              long long v96 = [v94 appleID];
              if (!v96)
              {
                long long v97 = [v108 objectForKey:v88];
                long long v96 = [v97 appleID];

                if (!v96)
                {
                  long long v96 = PKLogFacilityTypeGetObject();
                  if (!os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT)) {
                    goto LABEL_132;
                  }
                  *(_DWORD *)id buf = 138412290;
                  v168 = v88;
                  __int16 v99 = v96;
                  long long v100 = "There is no appleID for zone originator %@ and no family member with the altDSID";
                  goto LABEL_131;
                }
              }
              long long v98 = [*(id *)(a1 + 32) delegate];
              [v98 cloudStoreContainer:*(void *)(a1 + 32) requestsZoneShareFromHandle:v96 zoneName:v86 completion:0];
            }
            else
            {
              long long v96 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)id buf = 138412290;
                v168 = v94;
                __int16 v99 = v96;
                long long v100 = "The shared account zone originator with altDSID %@ does not have an appleID defined.";
LABEL_131:
                _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, v100, buf, 0xCu);
              }
            }
LABEL_132:
            id v77 = (void *)v119;
            id v75 = v125;
LABEL_133:

LABEL_134:
LABEL_135:

            __int16 v80 = (char *)v80 + 1;
          }
          while (v78 != v80);
          id v101 = [v75 countByEnumeratingWithState:&v126 objects:v164 count:16];
          id v78 = v101;
        }
        while (v101);
LABEL_140:

        uint64_t v4 = v107 + 1;
        id v3 = v113;
      }
      while ((id)(v107 + 1) != v106);
      id v106 = [obj countByEnumeratingWithState:&v160 objects:v180 count:16];
    }
    while (v106);
  }

  id v102 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "Completed ensuring zone share integrity check for accounts.", buf, 2u);
  }

  uint64_t v103 = *(void *)(a1 + 64);
  if (v103) {
    (*(void (**)(void))(v103 + 16))();
  }
}

id sub_1000C8E54(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) hasHandle:a2];
}

id sub_1000C8E60(uint64_t a1, void *a2)
{
  return [a2 hasHandle:*(void *)(a1 + 32)];
}

uint64_t sub_1000C903C(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Completed ensuring zone share integrity.", v4, 2u);
  }

  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(result + 16))();
  }
  return result;
}

void sub_1000C90C0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(a1 + 32);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1000C9184;
  void v11[3] = &unk_10072E598;
  id v12 = v6;
  id v13 = v7;
  id v9 = v6;
  id v10 = v7;
  objc_msgSend(v8, "_queue_createOrRemoveZoneSharesForPeerPaymentIfNecessaryWithCompletion:", v11);
}

uint64_t sub_1000C9184(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_1000C919C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(a1 + 32);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1000C9260;
  void v11[3] = &unk_10072E598;
  id v12 = v6;
  id v13 = v7;
  id v9 = v6;
  id v10 = v7;
  objc_msgSend(v8, "_queue_createOrRemoveZoneSharesForAccountsIfNecessaryWithCompletion:", v11);
}

uint64_t sub_1000C9260(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1000C9278(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000C9D24(id a1, PKSharedAccountCloudStoreZone *a2)
{
  return [(PKSharedAccountCloudStoreZone *)a2 zoneName];
}

id sub_1000C9D2C(id a1, PKSharedAccountCloudStoreZone *a2)
{
  return [(PKSharedAccountCloudStoreZone *)a2 zoneName];
}

id sub_1000C9E08(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_ensureZoneShareIntegrity");
}

void sub_1000C9EC4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) workQueue];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_1000C9F88;
  v7[3] = &unk_10072E598;
  id v5 = *(id *)(a1 + 40);
  id v8 = v3;
  id v9 = v5;
  id v6 = v3;
  dispatch_async(v4, v7);
}

uint64_t sub_1000C9F88(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_1000CA050(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) workQueue];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000CA118;
  v6[3] = &unk_10072FDC8;
  id v7 = v3;
  id v8 = *(id *)(a1 + 40);
  id v5 = v3;
  dispatch_async(v4, v6);
}

void sub_1000CA118(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v3 = *(id *)(a1 + 32);
  id v4 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (v4)
  {
    id v5 = v4;
    id v6 = 0;
    uint64_t v7 = *(void *)v15;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v15 != v7) {
          objc_enumerationMutation(v3);
        }
        id v9 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        id v10 = objc_msgSend(v9, "altDSID", (void)v14);
        [v2 setObject:v9 forKey:v10];

        if ([v9 isMe])
        {
          id v11 = v9;

          id v6 = v11;
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
    }
    while (v5);
  }
  else
  {
    id v6 = 0;
  }

  uint64_t v12 = *(void *)(a1 + 40);
  id v13 = [v2 copy];
  (*(void (**)(uint64_t, id, void *))(v12 + 16))(v12, v13, v6);
}

void sub_1000CA3F0(uint64_t a1)
{
  if ([*(id *)(a1 + 32) isSetup])
  {
    if (PDScheduledActivityExists()) {
      return;
    }
    uint64_t v2 = PKRandomIntegerInRange();
    uint64_t v3 = PKRandomIntegerInRange();
    id v4 = +[NSDate date];
    id v5 = [v4 dateByAddingTimeInterval:(double)v3 * 60.0 + (double)v2 * 3600.0];

    id v6 = +[PDScheduledActivityCriteria priorityActivityCriteriaWithStartDate:v5];
    [v6 setRepeating:0];
    [v6 setRequireNetworkConnectivity:1];
    [v6 setRequireScreenSleep:1];
    [v6 setRequireMainsPower:1];
    PDScheduledActivityRegister();
    uint64_t v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 138543618;
      CFStringRef v17 = @"ApplePayCloudStoreUnarchivedTask";
      __int16 v18 = 2114;
      long long v19 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Scheduled cloud store fetch activity %{public}@ for %{public}@", buf, 0x16u);
    }

    v14[0] = @"activityIdentifier";
    v14[1] = @"startTime";
    v15[0] = @"ApplePayCloudStoreUnarchivedTask";
    id v8 = [v5 description];
    v15[1] = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:v15 forKeys:v14 count:2];

    id v10 = *(void **)(a1 + 32);
    id v11 = [v9 description];
    id v13 = v11;
    uint64_t v12 = +[NSArray arrayWithObjects:&v13 count:1];
    [v10 reportContainerChangeSignpostEventType:56 stateName:@"ApplePayCloudStoreUnarchivedTask" objectNames:v12 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:*(void *)(a1 + 40)];
  }
  else
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 138543362;
      CFStringRef v17 = @"ApplePayCloudStoreUnarchivedTask";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Not scheduling %{public}@ since the container is not setup", buf, 0xCu);
    }
  }
}

void sub_1000CA7F0(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if ([*(id *)(a1 + 32) isSetup])
  {
    id v5 = [*(id *)(a1 + 32) dataSource];
    id v6 = [v5 allRecordFetchTasks];

    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v7 = v6;
    id v8 = [v7 countByEnumeratingWithState:&v40 objects:v56 count:16];
    if (!v8)
    {

      id v11 = 0;
      if ((PDScheduledActivityExists() & 1) == 0) {
        goto LABEL_60;
      }
      goto LABEL_35;
    }
    id v9 = v8;
    id v39 = v4;
    char v10 = 0;
    id v11 = 0;
    int v12 = 0;
    uint64_t v13 = *(void *)v41;
    do
    {
      for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v41 != v13) {
          objc_enumerationMutation(v7);
        }
        long long v15 = *(void **)(*((void *)&v40 + 1) + 8 * i);
        if ([v15 status] == (id)3)
        {
          long long v16 = [v15 identifier];

          if (v16)
          {
            CFStringRef v17 = [v15 nextPossibleFetchDate];
            __int16 v18 = v17;
            if (v17)
            {
              if (!v11 || [v17 compare:v11] == (id)-1)
              {
                long long v19 = v18;

                id v11 = v19;
              }
            }
            else
            {
              int v12 = 1;
            }

            char v10 = 1;
          }
        }
      }
      id v9 = [v7 countByEnumeratingWithState:&v40 objects:v56 count:16];
    }
    while (v9);

    if (v11)
    {
      unsigned __int8 v20 = +[NSDate date];
      BOOL v21 = [v11 compare:v20] == (id)-1;

      if ((v21 | v12))
      {
LABEL_19:

        int v22 = PDScheduledActivityExists();
        id v11 = 0;
LABEL_26:
        id v4 = v39;
        if (v10)
        {
          if (v22)
          {
            uint64_t v23 = PDScheduledActivityGetCriteria();
            id v24 = [v23 startDate];
            if (v24 && v11 && ((PKEqualObjects() & 1) != 0 || [v11 compare:v24] == (id)1))
            {

              uint64_t v25 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)id buf = 138543874;
                CFStringRef v48 = @"ApplePayCloudStorePerformFetchTasks";
                __int16 v49 = 2114;
                uint64_t v50 = v11;
                __int16 v51 = 2114;
                uint64_t v52 = v24;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Not scheduling cloud store fetch activity %{public}@ with startDate %{public}@ since the existingStartDate is %{public}@", buf, 0x20u);
              }
LABEL_59:

              goto LABEL_60;
            }
            PDScheduledActivityRemove();
          }
          else
          {
            id v24 = 0;
          }
          uint64_t v25 = +[PDScheduledActivityCriteria priorityActivityCriteriaWithStartDate:v11];
          [v25 setRepeating:0];
          [v25 setRequireNetworkConnectivity:1];
          [v25 setRequireScreenSleep:0];
          [v25 setRequireMainsPower:0];
          PDScheduledActivityRegister();
          long long v30 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = 138543618;
            CFStringRef v48 = @"ApplePayCloudStorePerformFetchTasks";
            __int16 v49 = 2114;
            uint64_t v50 = v11;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Scheduled cloud store fetch activity %{public}@ with start time %{public}@", buf, 0x16u);
          }

          v55[0] = @"ApplePayCloudStorePerformFetchTasks";
          v54[0] = @"activityIdentifier";
          v54[1] = @"startDate";
          if (v11)
          {
            long long v31 = [v11 description];
          }
          else
          {
            long long v31 = @"<nil>";
          }
          CFStringRef v32 = &stru_10075AAD8;
          if (v7) {
            CFStringRef v32 = (const __CFString *)v7;
          }
          v55[1] = v31;
          v55[2] = v32;
          v54[2] = @"allRecordFetchTasks";
          v54[3] = @"didSchedule";
          CFStringRef v33 = @"NO";
          if (v22) {
            CFStringRef v33 = @"YES";
          }
          v55[3] = @"YES";
          void v55[4] = v33;
          v54[4] = @"activityAlreadyExists";
          v54[5] = @"existingStartDate";
          if (v24)
          {
            __int16 v34 = [v24 description];
          }
          else
          {
            __int16 v34 = @"<nil>";
          }
          void v55[5] = v34;
          id v35 = +[NSDictionary dictionaryWithObjects:v55 forKeys:v54 count:6];
          if (v24) {

          }
          if (v11) {
          id v36 = *(void **)(a1 + 32);
          }
          uint64_t v37 = [v35 description];
          id v53 = v37;
          long long v38 = +[NSArray arrayWithObjects:&v53 count:1];
          [v36 reportContainerChangeSignpostEventType:56 stateName:@"ApplePayCloudStorePerformFetchTasks" objectNames:v38 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:*(void *)(a1 + 40)];

          goto LABEL_59;
        }
        if (!v22)
        {
LABEL_60:

          goto LABEL_61;
        }
LABEL_35:
        uint64_t v26 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)id buf = 138543618;
          CFStringRef v48 = @"ApplePayCloudStorePerformFetchTasks";
          __int16 v49 = 2112;
          uint64_t v50 = v7;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Removing scheduled cloud store fetch activity %{public}@ with fetchTasks %@", buf, 0x16u);
        }

        PDScheduledActivityRemove();
        v45[0] = @"activityIdentifier";
        v45[1] = @"allRecordFetchTasks";
        CFStringRef v27 = &stru_10075AAD8;
        if (v7) {
          CFStringRef v27 = (const __CFString *)v7;
        }
        v46[0] = @"ApplePayCloudStorePerformFetchTasks";
        v46[1] = v27;
        v45[2] = @"removedScheduledActivity";
        v46[2] = @"YES";
        id v24 = +[NSDictionary dictionaryWithObjects:v46 forKeys:v45 count:3];
        long long v28 = *(void **)(a1 + 32);
        uint64_t v25 = [v24 description];
        id v44 = v25;
        long long v29 = +[NSArray arrayWithObjects:&v44 count:1];
        [v28 reportContainerChangeSignpostEventType:56 stateName:@"ApplePayCloudStorePerformFetchTasks" objectNames:v29 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:*(void *)(a1 + 40)];

        goto LABEL_59;
      }
    }
    else if (v12)
    {
      goto LABEL_19;
    }
    int v22 = PDScheduledActivityExists();
    goto LABEL_26;
  }
  uint64_t v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)id buf = 138543362;
    CFStringRef v48 = @"ApplePayCloudStorePerformFetchTasks";
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Not scheduling %{public}@ since the container is not setup", buf, 0xCu);
  }
LABEL_61:
}

void sub_1000CB14C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) workQueue];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000CB1F8;
  v4[3] = &unk_100730198;
  uint64_t v3 = *(void **)(a1 + 40);
  void v4[4] = *(void *)(a1 + 32);
  id v5 = v3;
  long long v6 = *(_OWORD *)(a1 + 48);
  dispatch_async(v2, v4);
}

void sub_1000CB1F8(uint64_t a1)
{
  int v12 = _NSConcreteStackBlock;
  uint64_t v13 = 3221225472;
  long long v14 = sub_1000CB3D4;
  long long v15 = &unk_10072E198;
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t v16 = *(void *)(a1 + 32);
  id v17 = v2;
  uint64_t v3 = objc_retainBlock(&v12);
  if (objc_msgSend(*(id *)(a1 + 32), "isSetup", v12, v13, v14, v15, v16))
  {
    id v4 = (__CFString *)*(id *)(a1 + 40);
    if (v4 == @"ApplePayCloudStorePerformFetchTasks"
      || (id v5 = v4) != 0
      && (unsigned int v6 = [(__CFString *)v4 isEqualToString:@"ApplePayCloudStorePerformFetchTasks"], v5, v6))
    {
      objc_msgSend(*(id *)(a1 + 32), "_queue_performFetchTasksBackgroundActivityForGroupName:suffix:completion:", *(void *)(a1 + 48), *(void *)(a1 + 56), v3);
    }
    else
    {
      id v9 = (__CFString *)*(id *)(a1 + 40);
      if (v9 == @"ApplePayCloudStoreUnarchivedTask"
        || (char v10 = v9) != 0
        && (unsigned int v11 = [(__CFString *)v9 isEqualToString:@"ApplePayCloudStoreUnarchivedTask"], v10, v11))
      {
        objc_msgSend(*(id *)(a1 + 32), "_queue_performUnarchivedTransactionsBackgroundActivityForGroupName:suffix:completion:", *(void *)(a1 + 48), *(void *)(a1 + 56), v3);
      }
    }
  }
  else
  {
    uint64_t v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      *(_DWORD *)id buf = 138543362;
      uint64_t v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDApplePayCloudStoreContainer not running %{public}@ since the container is not setup", buf, 0xCu);
    }

    ((void (*)(void ***))v3[2])(v3);
  }
}

id sub_1000CB3D4(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 192) setObject:&__kCFBooleanFalse forKeyedSubscript:*(void *)(a1 + 40)];
}

id sub_1000CC664(id a1, PKPaymentTransactionArchive *a2)
{
  return [(PKPaymentTransactionArchive *)a2 identifier];
}

void sub_1000CC66C(uint64_t a1, NSUInteger a2, NSUInteger a3)
{
  unsigned int v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = [*(id *)(a1 + 32) count];
    v21.id location = a2;
    v21.length = a3;
    uint64_t v8 = NSStringFromRange(v21);
    *(_DWORD *)id buf = 134349314;
    id v18 = v7;
    __int16 v19 = 2114;
    unsigned __int8 v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "will upload local data batch following container setup for transactions: %{public}lu in range:%{public}@", buf, 0x16u);
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_1000CC7C8;
  void v12[3] = &unk_100734780;
  id v9 = *(void **)(a1 + 40);
  id v10 = *(id *)(a1 + 32);
  NSUInteger v15 = a2;
  NSUInteger v16 = a3;
  uint64_t v11 = *(void *)(a1 + 48);
  id v13 = v10;
  uint64_t v14 = v11;
  [v9 addOperation:v12];
}

void sub_1000CC7C8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v66 = a2;
  id v65 = a3;
  id v64 = a4;
  id v7 = objc_alloc_init((Class)NSMutableSet);
  long long v88 = 0u;
  long long v89 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  uint64_t v62 = (long long *)(a1 + 48);
  objc_msgSend(*(id *)(a1 + 32), "subarrayWithRange:", *(void *)(a1 + 48), *(void *)(a1 + 56));
  id obj = (id)objc_claimAutoreleasedReturnValue();
  id v71 = [obj countByEnumeratingWithState:&v88 objects:v101 count:16];
  if (v71)
  {
    uint64_t v70 = *(void *)v89;
    uint64_t v69 = a1;
    id v67 = v7;
    do
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v89 != v70) {
          objc_enumerationMutation(obj);
        }
        id v9 = *(void **)(*((void *)&v88 + 1) + 8 * (void)v8);
        id v10 = [v9 type];
        if (v10 == (id)2)
        {
          long long v42 = [*(id *)(a1 + 40) dataSource];
          long long v43 = [v9 identifier];
          id v13 = [v42 peerPaymentCounterpartImageDataWithIdentifier:v43];

          id v44 = [v9 archiveLocationsWithType:0 isArchived:0];
          id v20 = objc_alloc_init((Class)NSMutableSet);
          id v45 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            id v46 = [v44 count];
            *(_DWORD *)id buf = 134218242;
            id v96 = v46;
            __int16 v97 = 2112;
            id v98 = v44;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%lu locations that need syncing for counterpart image data: %@", buf, 0x16u);
          }

          long long v78 = 0u;
          long long v79 = 0u;
          long long v76 = 0u;
          long long v77 = 0u;
          id v14 = v44;
          id v47 = [v14 countByEnumeratingWithState:&v76 objects:v92 count:16];
          if (v47)
          {
            id v48 = v47;
            uint64_t v49 = *(void *)v77;
            do
            {
              for (uint64_t i = 0; i != v48; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v77 != v49) {
                  objc_enumerationMutation(v14);
                }
                __int16 v51 = *(void **)(*((void *)&v76 + 1) + 8 * i);
                uint64_t v52 = [v51 cloudStoreZone];
                if (v52 && ([v51 isArchived] & 1) == 0) {
                  [v20 addObject:v52];
                }
              }
              id v48 = [v14 countByEnumeratingWithState:&v76 objects:v92 count:16];
            }
            while (v48);
          }
          goto LABEL_50;
        }
        if (v10 == (id)1)
        {
          long long v31 = [*(id *)(a1 + 40) dataSource];
          CFStringRef v32 = [v9 identifier];
          id v13 = [v31 peerPaymentRecurringPaymentWithIdentifier:v32];

          CFStringRef v33 = [v9 archiveLocationsWithType:0 isArchived:0];
          __int16 v34 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            id v35 = [v33 count];
            *(_DWORD *)id buf = 134218242;
            id v96 = v35;
            __int16 v97 = 2112;
            id v98 = v33;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%lu locations that need syncing for recurring payment: %@", buf, 0x16u);
          }

          id v20 = objc_alloc_init((Class)NSMutableSet);
          long long v80 = 0u;
          long long v81 = 0u;
          long long v82 = 0u;
          long long v83 = 0u;
          id v14 = v33;
          id v36 = [v14 countByEnumeratingWithState:&v80 objects:v93 count:16];
          if (v36)
          {
            id v37 = v36;
            uint64_t v38 = *(void *)v81;
            do
            {
              for (uint64_t j = 0; j != v37; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v81 != v38) {
                  objc_enumerationMutation(v14);
                }
                long long v40 = *(void **)(*((void *)&v80 + 1) + 8 * (void)j);
                long long v41 = [v40 cloudStoreZone];
                if (v41 && ([v40 isArchived] & 1) == 0) {
                  [v20 addObject:v41];
                }
              }
              id v37 = [v14 countByEnumeratingWithState:&v80 objects:v93 count:16];
            }
            while (v37);
          }
LABEL_50:

          if ([v20 count])
          {
            id v19 = [objc_alloc((Class)PKCloudStoreUploadItemConfiguration) initWithItem:v13 recordSpecificKeys:0];
            id v53 = [v20 copy];
            [v19 setCloudStoreZones:v53];

            [v7 addObject:v19];
            goto LABEL_52;
          }
          a1 = v69;
LABEL_55:

          goto LABEL_56;
        }
        if (v10) {
          goto LABEL_57;
        }
        uint64_t v11 = [*(id *)(a1 + 40) dataSource];
        int v12 = [v9 identifier];
        id v13 = [v11 transactionWithTransactionIdentifier:v12];

        id v14 = [v13 transactionSourceIdentifier];
        if ([v13 hasCloudArchivableDeviceData]
          && objc_msgSend(*(id *)(a1 + 40), "_queue_canSyncTransactionToCloudKit:forTransactionSourceIdentifier:", v13, v14))
        {
          NSUInteger v15 = [v9 archiveLocationsWithType:0 isArchived:0];
          NSUInteger v16 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            id v17 = [v15 count];
            id v18 = [v13 identifier];
            *(_DWORD *)id buf = 134218498;
            id v96 = v17;
            __int16 v97 = 2114;
            id v98 = v18;
            __int16 v99 = 2112;
            long long v100 = v15;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%lu locations that need syncing for transaction with identifier %{public}@: %@", buf, 0x20u);
          }
          id v19 = objc_alloc_init((Class)NSMutableSet);
          long long v84 = 0u;
          long long v85 = 0u;
          long long v86 = 0u;
          long long v87 = 0u;
          id v20 = v15;
          id v21 = [v20 countByEnumeratingWithState:&v84 objects:v94 count:16];
          if (v21)
          {
            id v22 = v21;
            uint64_t v23 = *(void *)v85;
            do
            {
              for (k = 0; k != v22; k = (char *)k + 1)
              {
                if (*(void *)v85 != v23) {
                  objc_enumerationMutation(v20);
                }
                uint64_t v25 = *(void **)(*((void *)&v84 + 1) + 8 * (void)k);
                uint64_t v26 = [v25 cloudStoreZone];
                if (v26 && ([v25 isArchived] & 1) == 0) {
                  [v19 addObject:v26];
                }
              }
              id v22 = [v20 countByEnumeratingWithState:&v84 objects:v94 count:16];
            }
            while (v22);
          }

          if ([v19 count])
          {
            id v27 = objc_alloc((Class)PKCloudStoreUploadItemConfiguration);
            a1 = v69;
            long long v28 = [*(id *)(v69 + 40) cloudStoreSpecificKeysForItem:v13];
            id v29 = [v27 initWithItem:v13 recordSpecificKeys:v28];

            id v30 = [v19 copy];
            [v29 setCloudStoreZones:v30];

            id v7 = v67;
            [v67 addObject:v29];

            goto LABEL_53;
          }
          id v7 = v67;
LABEL_52:
          a1 = v69;
LABEL_53:

          goto LABEL_55;
        }
LABEL_56:

LABEL_57:
        uint64_t v8 = (char *)v8 + 1;
      }
      while (v8 != v71);
      id v54 = [obj countByEnumeratingWithState:&v88 objects:v101 count:16];
      id v71 = v54;
    }
    while (v54);
  }

  if ([v7 count])
  {
    id v55 = PKLogFacilityTypeGetObject();
    id v57 = v64;
    id v56 = v65;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      id v58 = [v7 count];
      id v59 = NSStringFromRange(*(NSRange *)(a1 + 48));
      *(_DWORD *)id buf = 134218498;
      id v96 = v58;
      __int16 v97 = 2112;
      id v98 = v7;
      __int16 v99 = 2114;
      long long v100 = v59;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "uploading local data following container setup for %lu transactions: %@ in range:%{public}@", buf, 0x20u);
    }
    uint64_t v60 = *(void **)(a1 + 40);
    uint64_t v61 = PKCloudStoreOperationGroupInitialUpload;
    v72[0] = _NSConcreteStackBlock;
    v72[1] = 3221225472;
    v72[2] = sub_1000CD0A0;
    v72[3] = &unk_100734758;
    long long v75 = *v62;
    id v74 = v64;
    id v73 = v65;
    [v60 updateCloudStoreWithLocalItemsWithConfigurations:v7 groupName:v61 groupNameSuffix:0 qualityOfService:17 completion:v72];
  }
  else
  {
    id v57 = v64;
    id v56 = v65;
    (*((void (**)(id, id, void))v64 + 2))(v64, v65, 0);
  }
}

void sub_1000CD0A0(NSRange *a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  id v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = [a2 count];
    id v9 = NSStringFromRange(a1[3]);
    int v10 = 134349570;
    id v11 = v8;
    __int16 v12 = 2114;
    id v13 = v9;
    __int16 v14 = 2114;
    id v15 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "uploaded local data batch following container setup for %{public}ld transactions in range:%{public}@ with error:%{public}@", (uint8_t *)&v10, 0x20u);
  }
  (*(void (**)(NSUInteger, NSUInteger, BOOL))(a1[2].length + 16))(a1[2].length, a1[2].location, v6 != 0);
}

void sub_1000CD1B4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = [*(id *)(a1 + 32) count];
    int v11 = 134349056;
    id v12 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Did upload local data following container setup for transactions:%{public}lu", (uint8_t *)&v11, 0xCu);
  }

  uint64_t v10 = *(void *)(a1 + 48);
  if (v10) {
    (*(void (**)(void))(v10 + 16))();
  }
  [*(id *)(a1 + 40) _updateUnarchivedTransactionsScheduledActivityIfNeccessary];
}

void sub_1000CDDD8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v1 = a1;
    if (!*(void *)(a1 + 32))
    {
      uint64_t v2 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Marking all transcations as not CloudKit archived so they can be re-uploaded to the cloud store later.", buf, 2u);
      }

      uint64_t v3 = [*(id *)(v1 + 40) dataSource];
      id v4 = [v3 passesOfType:1];

      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      id v5 = v4;
      id v6 = [v5 countByEnumeratingWithState:&v52 objects:v60 count:16];
      id obj = v5;
      if (v6)
      {
        id v8 = v6;
        char v9 = 0;
        uint64_t v10 = *(void *)v53;
        *(void *)&long long v7 = 138543362;
        long long v34 = v7;
        uint64_t v35 = *(void *)v53;
        id v36 = v2;
        do
        {
          int v11 = 0;
          id v37 = v8;
          do
          {
            if (*(void *)v53 != v10) {
              objc_enumerationMutation(obj);
            }
            id v12 = *(void **)(*((void *)&v52 + 1) + 8 * (void)v11);
            id v13 = objc_msgSend(v12, "paymentPass", v34);
            __int16 v14 = [v13 deviceTransactionSourceIdentifiers];
            id v15 = [v14 anyObject];

            if (objc_msgSend(*(id *)(v1 + 40), "_queue_isRelevantTransactionSourceIdentifier:", v15))
            {
              id v39 = v15;
              long long v40 = v13;
              long long v41 = v11;
              if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
              {
                NSUInteger v16 = [v12 uniqueID];
                *(_DWORD *)id buf = v34;
                id v59 = v16;
                _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Marking all transactions for pass %{public}@ as not CloudKit archived", buf, 0xCu);
              }
              id v17 = [*(id *)(v1 + 40) dataSource];
              id v18 = [v17 transactionArchivesWithType:0 isArchived:1];

              long long v50 = 0u;
              long long v51 = 0u;
              long long v48 = 0u;
              long long v49 = 0u;
              id v43 = v18;
              id v19 = [v43 countByEnumeratingWithState:&v48 objects:v57 count:16];
              if (v19)
              {
                id v20 = v19;
                uint64_t v21 = *(void *)v49;
                do
                {
                  id v22 = 0;
                  id v42 = v20;
                  do
                  {
                    if (*(void *)v49 != v21) {
                      objc_enumerationMutation(v43);
                    }
                    uint64_t v23 = *(void **)(*((void *)&v48 + 1) + 8 * (void)v22);
                    id v24 = [*(id *)(v1 + 40) dataSource];
                    uint64_t v25 = [v23 identifier];
                    uint64_t v26 = [v24 transactionWithTransactionIdentifier:v25];

                    if ([v26 hasCloudArchivableDeviceData])
                    {
                      [v26 addUpdateReasons:0x10000];
                      long long v46 = 0u;
                      long long v47 = 0u;
                      long long v44 = 0u;
                      long long v45 = 0u;
                      id v27 = [v23 archiveLocationsWithType:0 isArchived:1];
                      id v28 = [v27 countByEnumeratingWithState:&v44 objects:v56 count:16];
                      if (v28)
                      {
                        id v29 = v28;
                        uint64_t v30 = v1;
                        uint64_t v31 = *(void *)v45;
                        do
                        {
                          for (uint64_t i = 0; i != v29; uint64_t i = (char *)i + 1)
                          {
                            if (*(void *)v45 != v31) {
                              objc_enumerationMutation(v27);
                            }
                            CFStringRef v33 = [*(id *)(*((void *)&v44 + 1) + 8 * i) cloudStoreZone];
                            [v23 insertOrUpdateArchiveLocationWithCloudStoreZone:v33 isArchived:0 insertionMode:0];
                          }
                          id v29 = [v27 countByEnumeratingWithState:&v44 objects:v56 count:16];
                        }
                        while (v29);
                        char v9 = 1;
                        uint64_t v1 = v30;
                        id v20 = v42;
                      }
                    }
                    id v22 = (char *)v22 + 1;
                  }
                  while (v22 != v20);
                  id v20 = [v43 countByEnumeratingWithState:&v48 objects:v57 count:16];
                }
                while (v20);
              }

              uint64_t v10 = v35;
              uint64_t v2 = v36;
              id v8 = v37;
              id v13 = v40;
              int v11 = v41;
              id v15 = v39;
            }

            int v11 = (char *)v11 + 1;
          }
          while (v11 != v8);
          id v8 = [obj countByEnumeratingWithState:&v52 objects:v60 count:16];
        }
        while (v8);

        if ((v9 & 1) == 0) {
          goto LABEL_36;
        }
        id v5 = [*(id *)(v1 + 40) delegate];
        [v5 cloudStoreContainer:*(void *)(v1 + 40) requestsSyncTransactionsToCloudStoreOriginatedOnDevice:0];
      }

LABEL_36:
    }
  }
}

void sub_1000CEA40(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000CEB3C;
  v10[3] = &unk_1007347F8;
  id v6 = *(void **)(a1 + 40);
  void v10[4] = *(void *)(a1 + 32);
  id v11 = v6;
  id v12 = v5;
  id v7 = *(id *)(a1 + 48);
  uint64_t v8 = *(void *)(a1 + 72);
  id v13 = v7;
  uint64_t v16 = v8;
  id v14 = *(id *)(a1 + 56);
  id v15 = *(id *)(a1 + 64);
  id v9 = v5;
  [a3 enumerateKeysAndObjectsUsingBlock:v10];
}

void sub_1000CEB3C(uint64_t a1, void *a2, void *a3)
{
  id v180 = a2;
  id v5 = a3;
  id v7 = [*(id *)(a1 + 32) containerManager];
  uint64_t v8 = [v7 databaseForIdentifier:*(void *)(a1 + 40)];

  id v9 = [*(id *)(a1 + 32) containerManager];
  uint64_t v10 = [v5 firstObject];
  id v11 = [v10 recordID];
  id v12 = [v11 zoneID];
  uint64_t v13 = [v9 cloudStoreZoneForZoneID:v12 inContainerDatabase:v8];

  id v14 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v5];
  __int16 v171 = (void *)v13;
  unsigned int oslog = [*(id *)(a1 + 32) _isCloudStoreZoneThePrimaryZoneForCurrentUser:v13 containerDatabase:v8];
  uint64_t v15 = [*(id *)(a1 + 32) _transactionSourceIdentifierForTransactionCloudStoreRecord:v14 databaseIdentifier:*(void *)(a1 + 40)];
  uint64_t v16 = [*(id *)(a1 + 32) dataSource];
  id v17 = [v16 transactionSourceTypeForTransactionSourceIdentifier:v15];

  uint64_t v172 = (void *)v15;
  id v173 = v17;
  uint64_t v181 = a1;
  if (v15)
  {
    v210[0] = v15;
    id v18 = PKTransactionSourceTypeToString();
    v210[1] = v18;
    id v19 = +[NSArray arrayWithObjects:v210 count:2];

    uint64_t v20 = a1;
    uint64_t v22 = *(void *)(a1 + 48);
    uint64_t v21 = (uint64_t *)(a1 + 48);
    [(id)*(v21 - 2) reportContainerChangeSignpostEventType:45 stateName:v22 objectNames:v19 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];

    goto LABEL_4;
  }
  uint64_t v20 = a1;
  uint64_t v23 = *(void *)(a1 + 48);
  uint64_t v21 = (uint64_t *)(a1 + 48);
  [(id)*(v21 - 2) reportContainerChangeSignpostEventType:45 stateName:v23 objectNames:0 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];
  if ([(id)v21[1] returnRecords])
  {
LABEL_4:
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v24 = [*(id *)(v20 + 56) transactionSourceIdentifiers];
    }
    else
    {
      id v24 = 0;
    }
    id v25 = [v24 count];
    v170 = v24;
    if (v15 && v25 && ([v24 containsObject:v15] & 1) == 0)
    {
      id v39 = +[NSString stringWithFormat:@"Skipping processing %@ because it is for a different transaction source", v14];
      long long v51 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138412290;
        uint64_t v209 = (uint64_t)v39;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
      }

      long long v52 = *(void **)(v181 + 32);
      uint64_t v53 = *(void *)(v181 + 48);
      id v206 = v39;
      id v41 = +[NSArray arrayWithObjects:&v206 count:1];
      [v52 reportContainerChangeSignpostEventType:45 stateName:v53 objectNames:v41 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];
      long long v54 = v172;
      goto LABEL_153;
    }
    v168 = v8;
    id v169 = v14;
    v167 = v6;
    uint64_t v26 = *(void *)(v181 + 80);
    long long v191 = 0u;
    long long v192 = 0u;
    long long v193 = 0u;
    long long v194 = 0u;
    id v165 = v5;
    id obj = v5;
    id v27 = [obj countByEnumeratingWithState:&v191 objects:v205 count:16];
    if (v27)
    {
      id v28 = v27;
      uint64_t v29 = *(void *)v192;
      uint64_t v30 = PKCloudTransactionRecordType;
      uint64_t v31 = PKCloudTransactionDeviceDataRecordType;
      do
      {
        for (uint64_t i = 0; i != v28; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v192 != v29) {
            objc_enumerationMutation(obj);
          }
          CFStringRef v33 = *(void **)(*((void *)&v191 + 1) + 8 * i);
          long long v34 = [v33 recordType];
          unsigned int v35 = [v34 isEqualToString:v30];

          if (v35)
          {
            v26 |= 0x10uLL;
          }
          else
          {
            id v36 = [v33 recordType];
            unsigned int v37 = [v36 isEqualToString:v31];

            if (v37) {
              v26 |= 8uLL;
            }
          }
        }
        id v28 = [obj countByEnumeratingWithState:&v191 objects:v205 count:16];
      }
      while (v28);
    }

    uint64_t v38 = [*(id *)(v181 + 32) dataSource];
    id v39 = [v38 transactionWithServiceIdentifier:*(void *)(v181 + 48) transactionSourceIdentifier:v172];

    long long v40 = [*(id *)(v181 + 32) dataSource];
    id v41 = [v40 transactionArchiveForTransactionWithServiceIdentifier:*(void *)(v181 + 48) transactionSourceIdentifier:v172];

    if (v39)
    {
      unsigned int v163 = [v39 hasNotificationServiceData] ^ 1;
      id v42 = +[NSString stringWithFormat:@"Applying properties to existing transaction with service id %@", *v21];
      id v43 = PKLogFacilityTypeGetObject();
      id v5 = v165;
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138543362;
        uint64_t v209 = (uint64_t)v42;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }

      [v39 applyPropertiesFromCloudStoreRecord:v169];
      long long v44 = *(void **)(v181 + 32);
      uint64_t v45 = *(void *)(v181 + 48);
      v204 = v42;
      long long v46 = +[NSArray arrayWithObjects:&v204 count:1];
      [v44 reportContainerChangeSignpostEventType:45 stateName:v45 objectNames:v46 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];

      if (oslog) {
        [v41 insertOrUpdateArchiveLocationWithCloudStoreZone:v171 isArchived:0 insertionMode:1];
      }
      id v6 = v167;
      uint64_t v8 = v168;
    }
    else
    {
      id v39 = [objc_alloc((Class)PKPaymentTransaction) initWithCloudStoreCoder:v169];
      id v42 = +[NSString stringWithFormat:@"Setting properties to new transaction with service id %@", *v21];
      long long v47 = PKLogFacilityTypeGetObject();
      id v5 = v165;
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138543362;
        uint64_t v209 = (uint64_t)v42;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
      }

      long long v48 = *(void **)(v181 + 32);
      uint64_t v49 = *(void *)(v181 + 48);
      v203 = v42;
      long long v50 = +[NSArray arrayWithObjects:&v203 count:1];
      [v48 reportContainerChangeSignpostEventType:45 stateName:v49 objectNames:v50 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];

      if (!v41) {
        id v41 = objc_alloc_init((Class)PKPaymentTransactionArchive);
      }
      id v6 = v167;
      uint64_t v8 = v168;
      unsigned int v163 = 1;
      if (oslog) {
        [v41 insertOrUpdateArchiveLocationWithCloudStoreZone:v171 isArchived:1 insertionMode:0];
      }
    }

    [v39 addUpdateReasons:v26];
    id v14 = v169;
    v166 = [*(id *)(v181 + 32) _originDeviceIDForCloudStoreRecord:v169];
    if (v39)
    {
      id v59 = [v39 serviceIdentifier];

      uint64_t v60 = *(void **)(v181 + 56);
      if (v59)
      {
        if (![v60 storeChangesInDatabase])
        {
          long long v54 = v172;
          uint64_t v73 = v181;
          goto LABEL_149;
        }
        if (!v172)
        {
          id v74 = [v39 serviceIdentifier];
          long long v75 = +[NSString stringWithFormat:@"Did not find transaction source identifier for %@, transaction service id %@", 0, v74];

          long long v76 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = 138412290;
            uint64_t v209 = (uint64_t)v75;
            _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
          }

          uint64_t v73 = v181;
          long long v77 = *(void **)(v181 + 32);
          uint64_t v78 = *(void *)(v181 + 48);
          v202 = v75;
          long long v79 = +[NSArray arrayWithObjects:&v202 count:1];
          [v77 reportContainerChangeSignpostEventType:45 stateName:v78 objectNames:v79 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];

          id v6 = v167;
          id v14 = v169;
          long long v54 = 0;
          goto LABEL_149;
        }
        [v39 setHasAssociatedPaymentApplication:v173 == 0];
        [v39 setHasNotificationServiceData:1];
        uint64_t v61 = *v21;
        uint64_t v62 = PKTransactionSourceTypeToString();
        uint64_t v63 = +[NSString stringWithFormat:@"transactionSourceType for %@ is %@", v61, v62];

        id v64 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)id buf = 138543362;
          uint64_t v209 = v63;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
        }
        osloga = v64;

        id v65 = *(void **)(v181 + 32);
        uint64_t v66 = *(void *)(v181 + 48);
        long long v161 = (void *)v63;
        uint64_t v201 = v63;
        id v67 = +[NSArray arrayWithObjects:&v201 count:1];
        [v65 reportContainerChangeSignpostEventType:45 stateName:v66 objectNames:v67 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];

        uint64_t v8 = v168;
        if (v163)
        {
          id v68 = osloga;
          if (+[PKPaymentTransaction updateReasonIsInitialDownload:v26])goto LABEL_62; {
          if (v173 == (id)1)
          }
          {
            uint64_t v158 = 0x100000000;
            goto LABEL_64;
          }
          if (v173) {
LABEL_62:
          }
            uint64_t v158 = 0;
          else {
            uint64_t v158 = 1;
          }
        }
        else
        {
          uint64_t v158 = 0;
          id v68 = osloga;
        }
LABEL_64:
        uint64_t v80 = [v39 accountIdentifier];
        if (v80)
        {
          long long v81 = (void *)v80;
          id v82 = [v39 accountType];

          if (v82)
          {
LABEL_108:
            id v118 = [v39 expirationDate];
            if (v118)
            {
              uint64_t v73 = v181;
            }
            else
            {
              uint64_t v73 = v181;
              if ([v39 transactionType] == (id)3)
              {
                if ([v39 transactionStatus])
                {
LABEL_114:
                  objc_opt_class();
                  if (objc_opt_isKindOfClass())
                  {
                    id v120 = [*(id *)(v73 + 56) transactionSourceIdentifiers];
                  }
                  else
                  {
                    id v120 = 0;
                  }
                  if ([v120 count]
                    && ([v39 transactionType] == (id)1 || !objc_msgSend(v39, "transactionType"))
                    && [v39 transactionStatus] == (id)1)
                  {
                    id v121 = [v39 merchant];
                    unsigned __int8 v122 = [v121 hasMapsMatch];

                    if ((v122 & 1) == 0 && !v166)
                    {
                      if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                      {
                        id v123 = [v39 serviceIdentifier];
                        *(_DWORD *)id buf = 138543362;
                        uint64_t v209 = (uint64_t)v123;
                        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "Transaction with service id %{public}@ does not contain maps data, so this device is now owning the transaction in order for it to be processed for maps data.", buf, 0xCu);
                      }
                      [v39 setProcessedForMerchantCleanup:0];
                      [v39 setRequiresMerchantReprocessing:1];
                      [v41 insertOrUpdateArchiveLocationWithCloudStoreZone:v171 isArchived:0 insertionMode:0];
                      v166 = [*(id *)(v73 + 32) _originDeviceID];
                    }
                  }
                  v124 = [v39 serviceIdentifier];
                  uint64_t v125 = +[NSString stringWithFormat:@"Updating transaction in local database with service id %@ with archive %@", v124, v41];

                  if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)id buf = 138412290;
                    uint64_t v209 = v125;
                    _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
                  }

                  long long v126 = (void *)v125;
                  long long v127 = *(void **)(v73 + 32);
                  uint64_t v128 = *(void *)(v73 + 48);
                  long long v162 = v126;
                  v196 = v126;
                  long long v129 = +[NSArray arrayWithObjects:&v196 count:1];
                  [v127 reportContainerChangeSignpostEventType:45 stateName:v128 objectNames:v129 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];

                  PKLogFacilityTypeGetObject();
                  long long v130 = (id)objc_claimAutoreleasedReturnValue();
                  os_signpost_id_t v131 = os_signpost_id_make_with_pointer(v130, *(const void **)(v73 + 32));
                  if (v131 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
                  {
                    os_signpost_id_t v132 = v131;
                    if (os_signpost_enabled(v130))
                    {
                      *(_WORD *)id buf = 0;
                      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v130, OS_SIGNPOST_INTERVAL_BEGIN, v132, "cloudstore:insertTransaction", "", buf, 2u);
                    }
                  }

                  long long v133 = [*(id *)(v73 + 32) dataSource];
                  long long v134 = [v133 insertOrUpdatePaymentTransaction:v39 withTransactionSourceIdentifier:v172 transactionArchive:v41 originDeviceID:v166 insertionMode:0 performTruncation:0];

                  long long v135 = v130;
                  os_signpost_id_t v136 = os_signpost_id_make_with_pointer(v135, *(const void **)(v73 + 32));
                  if (v136 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
                  {
                    os_signpost_id_t v137 = v136;
                    if (os_signpost_enabled(v135))
                    {
                      *(_WORD *)id buf = 0;
                      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v135, OS_SIGNPOST_INTERVAL_END, v137, "cloudstore:insertTransaction", "", buf, 2u);
                    }
                  }

                  v138 = [*(id *)(v73 + 32) dataSource];
                  [v138 insertOrUpdateCloudStoreRecords:obj inCloudStoreZone:v171];

                  if (([*(id *)(v73 + 56) formReport] & v163) == 1)
                  {
                    id v164 = v120;
                    id v160 = v41;
                    long long v185 = 0u;
                    long long v186 = 0u;
                    long long v183 = 0u;
                    long long v184 = 0u;
                    id v176 = obj;
                    id v139 = [v176 countByEnumeratingWithState:&v183 objects:v195 count:16];
                    if (v139)
                    {
                      id v140 = v139;
                      os_log_t oslogb = *(os_log_t *)v184;
                      do
                      {
                        for (uint64_t j = 0; j != v140; uint64_t j = (char *)j + 1)
                        {
                          if (*(os_log_t *)v184 != oslogb) {
                            objc_enumerationMutation(v176);
                          }
                          long long v142 = *(void **)(*((void *)&v183 + 1) + 8 * (void)j);
                          id v143 = objc_alloc((Class)PKAccountTransactionSyncReportItem);
                          long long v144 = [v134 serviceIdentifier];
                          long long v145 = [v142 recordID];
                          long long v146 = [v145 recordName];
                          long long v147 = [v142 recordType];
                          long long v148 = [v134 altDSID];
                          id v149 = [v143 initWithTransactionServiceIdentifier:v144 recordName:v146 recordType:v147 zoneName:v180 altDSID:v148];

                          uint64_t v73 = v181;
                          long long v150 = *(void **)(v181 + 64);
                          long long v151 = [v134 accountIdentifier];
                          [v150 addTransactionSyncReportItem:v149 forAccountIdentifier:v151];
                        }
                        id v140 = [v176 countByEnumeratingWithState:&v183 objects:v195 count:16];
                      }
                      while (v140);
                    }

                    id v120 = v164;
                    id v5 = v165;
                    uint64_t v8 = v168;
                    id v41 = v160;
                  }
                  long long v152 = [v134 identifier];
                  id v6 = v167;
                  long long v54 = v172;
                  if (v152)
                  {
                    if ((HIDWORD(v158) | v158) == 1) {
                      objc_msgSend(*(id *)(*(void *)(v73 + 32) + 240), "scheduleTaskToFetchStaleAccountIfNecessary:associatedAccountEndpoint:");
                    }
                    long long v153 = [[PDPaymentTransactionProcessorConfiguration alloc] initWithTransactionIdentifier:v152 updateReasons:v26];
                    [*(id *)(v73 + 72) addObject:v153];

                    uint64_t v8 = v168;
                  }

                  if (!v134)
                  {
                    id v39 = 0;
                    id v14 = v169;
                    goto LABEL_152;
                  }
                  id v39 = v134;
                  id v14 = v169;
LABEL_149:
                  if ([*(id *)(v73 + 56) returnRecords])
                  {
                    id v154 = objc_alloc((Class)PKCloudRecordTransaction);
                    long long v155 = +[NSSet setWithArray:obj];
                    long long v156 = v154;
                    uint64_t v8 = v168;
                    uint64_t v69 = [v156 initWithRecords:v155];

                    long long v54 = v172;
                    [v69 setTransaction:v39];
                    [*(id *)(v73 + 64) addCloudRecord:v69 forContainerDatabaseIdentifier:*(void *)(v73 + 40)];
                    goto LABEL_151;
                  }
LABEL_152:

LABEL_153:
                  goto LABEL_154;
                }
                uint64_t v119 = [v39 transactionDate];
                id v118 = [v119 dateByAddingTimeInterval:604800.0];

                [v39 setExpirationDate:v118];
              }
            }

            goto LABEL_114;
          }
        }
        if (v173 == (id)1)
        {
          long long v89 = [*(id *)(v181 + 32) dataSource];
          long long v87 = [v89 peerPaymentAccountForTransactionSourceIdentifier:v172];

          long long v90 = [v39 accountIdentifier];

          if (!v90)
          {
            long long v91 = [v87 identifier];
            [v39 setAccountIdentifier:v91];
          }
          id v159 = v41;
          [v39 setAccountType:1];
          unsigned int v92 = [v87 identifier];
          id v93 = +[NSString stringWithFormat:@"Setting peer payment account identifier %@ for service identifier %@", v92, *v21];

          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = 138412290;
            uint64_t v209 = (uint64_t)v93;
            _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
          }

          long long v94 = *(void **)(v181 + 32);
          uint64_t v95 = *(void *)(v181 + 48);
          v197 = v93;
          id v96 = +[NSArray arrayWithObjects:&v197 count:1];
          [v94 reportContainerChangeSignpostEventType:45 stateName:v95 objectNames:v96 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];
        }
        else
        {
          if (v173) {
            goto LABEL_108;
          }
          long long v83 = [*(id *)(v181 + 32) dataSource];
          long long v84 = [v83 passUniqueIdentifierForTransactionSourceIdentifier:v172];

          id v85 = [*(id *)(*(void *)(v181 + 32) + 272) associatedPassUniqueID];
          id v86 = v84;
          long long v87 = v86;
          if (v85 == v86)
          {
          }
          else
          {
            if (!v86 || !v85)
            {

LABEL_85:
              long long v189 = 0u;
              long long v190 = 0u;
              long long v187 = 0u;
              long long v188 = 0u;
              id v157 = *(id *)(*(void *)(v181 + 32) + 280);
              id v175 = [v157 countByEnumeratingWithState:&v187 objects:v199 count:16];
              if (v175)
              {
                id v159 = v41;
                uint64_t v102 = *(void *)v188;
                while (2)
                {
                  for (k = 0; k != v175; k = (char *)k + 1)
                  {
                    if (*(void *)v188 != v102) {
                      objc_enumerationMutation(v157);
                    }
                    uint64_t v104 = *(void **)(*((void *)&v187 + 1) + 8 * (void)k);
                    id v105 = [v104 associatedPassUniqueID];
                    id v106 = v87;
                    uint64_t v107 = v106;
                    if (v105 == v106)
                    {

LABEL_101:
                      v110 = [v39 accountIdentifier];

                      if (!v110)
                      {
                        uint64_t v111 = [v104 accountIdentifier];
                        [v39 setAccountIdentifier:v111];
                      }
                      [v104 type];
                      [v39 setAccountType:PKPaymentTransactionAccountTypeFromAccountType()];
                      id v112 = [v104 accountIdentifier];
                      v113 = PKPaymentTransactionAccountTypeToString();
                      id v96 = +[NSString stringWithFormat:@"Setting account service accountIdentifier %@, transactionAccountType %@ for transaction %@ and pass uniqueID %@", v112, v113, *v21, v107];

                      id v5 = v165;
                      uint64_t v8 = v168;
                      if (os_log_type_enabled(osloga, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)id buf = 138412290;
                        uint64_t v209 = (uint64_t)v96;
                        _os_log_impl((void *)&_mh_execute_header, osloga, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
                      }

                      id v114 = *(void **)(v181 + 32);
                      uint64_t v115 = *(void *)(v181 + 48);
                      char v198 = v96;
                      v116 = +[NSArray arrayWithObjects:&v198 count:1];
                      uint64_t v117 = v115;
                      id v68 = osloga;
                      [v114 reportContainerChangeSignpostEventType:45 stateName:v117 objectNames:v116 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];

                      long long v87 = v107;
                      id v93 = v157;
                      goto LABEL_106;
                    }
                    id v108 = v87;
                    if (v87 && v105)
                    {
                      unsigned int v109 = [v105 isEqualToString:v106];

                      if (v109) {
                        goto LABEL_101;
                      }
                    }
                    else
                    {
                    }
                    long long v87 = v108;
                  }
                  id v175 = [v157 countByEnumeratingWithState:&v187 objects:v199 count:16];
                  if (v175) {
                    continue;
                  }
                  break;
                }
                long long v87 = v107;
                id v5 = v165;
                uint64_t v8 = v168;
                id v41 = v159;
              }
              id v68 = osloga;
              id v93 = v157;
              goto LABEL_107;
            }
            unsigned int v88 = [v85 isEqualToString:v86];

            if (!v88) {
              goto LABEL_85;
            }
          }
          id v174 = v87;
          __int16 v97 = [v39 accountIdentifier];

          if (!v97)
          {
            id v98 = [*(id *)(*(void *)(v181 + 32) + 272) identifier];
            [v39 setAccountIdentifier:v98];
          }
          id v159 = v41;
          [v39 setAccountType:1];
          __int16 v99 = [*(id *)(*(void *)(v181 + 32) + 272) identifier];
          id v93 = +[NSString stringWithFormat:@"Setting peer payment accountIdentifier %@ for transaction with service id %@ for pass uniqueID %@", v99, *(void *)(v181 + 48), v174];

          id v68 = osloga;
          if (os_log_type_enabled(osloga, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = 138412290;
            uint64_t v209 = (uint64_t)v93;
            _os_log_impl((void *)&_mh_execute_header, osloga, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
          }

          long long v100 = *(void **)(v181 + 32);
          uint64_t v101 = *(void *)(v181 + 48);
          v200 = v93;
          id v96 = +[NSArray arrayWithObjects:&v200 count:1];
          [v100 reportContainerChangeSignpostEventType:45 stateName:v101 objectNames:v96 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];
          long long v87 = v174;
        }
LABEL_106:

        id v41 = v159;
LABEL_107:

        goto LABEL_108;
      }
      if (![v60 returnRecords])
      {
        long long v54 = v172;
        goto LABEL_152;
      }
      id v70 = objc_alloc((Class)PKCloudRecordTransaction);
      id v71 = +[NSSet setWithArray:obj];
      long long v72 = v70;
      uint64_t v8 = v168;
      uint64_t v69 = [v72 initWithRecords:v71];

      [v69 setTransaction:v39];
      [*(id *)(v181 + 64) addCloudRecord:v69 forContainerDatabaseIdentifier:*(void *)(v181 + 40)];
    }
    else
    {
      uint64_t v69 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138412290;
        uint64_t v209 = (uint64_t)obj;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "Cannot parse transaction from records %@", buf, 0xCu);
      }
      id v39 = 0;
    }
    long long v54 = v172;
LABEL_151:

    goto LABEL_152;
  }
  uint64_t v55 = +[NSString stringWithFormat:@"Skipping processing %@ because pass is not on device", v14];
  id v56 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)id buf = 138412290;
    uint64_t v209 = v55;
    _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
  }

  id v57 = *(void **)(v181 + 32);
  uint64_t v58 = *(void *)(v181 + 48);
  v170 = (void *)v55;
  uint64_t v207 = v55;
  id v39 = +[NSArray arrayWithObjects:&v207 count:1];
  [v57 reportContainerChangeSignpostEventType:45 stateName:v58 objectNames:v39 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];
  long long v54 = 0;
LABEL_154:
}

id sub_1000D034C(id a1, PDPaymentTransactionProcessorConfiguration *a2)
{
  return [(PDPaymentTransactionProcessorConfiguration *)a2 transactionIdentifier];
}

void sub_1000D09E8(uint64_t a1, uint64_t a2, void *a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_1000D0A78;
  v5[3] = &unk_100733C18;
  id v4 = *(void **)(a1 + 40);
  void v5[4] = *(void *)(a1 + 32);
  id v6 = v4;
  [a3 enumerateKeysAndObjectsUsingBlock:v5];
}

void sub_1000D0A78(uint64_t a1, uint64_t a2, void *a3)
{
  id v7 = a3;
  id v4 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v7];
  if ([*(id *)(a1 + 32) _canFormShareFromCloudStoreRecord:v4])
  {
    id v5 = [v7 firstObject];
    id v6 = objc_msgSend(v5, "pk_share");
    if (v6) {
      [*(id *)(a1 + 40) addObject:v6];
    }
  }
}

void sub_1000D0B24(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v22 = a3;
  uint64_t v21 = a4;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id obj = *(id *)(a1 + 32);
  id v25 = [obj countByEnumeratingWithState:&v31 objects:v40 count:16];
  if (v25)
  {
    uint64_t v24 = *(void *)v32;
    do
    {
      for (uint64_t i = 0; i != v25; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v32 != v24) {
          objc_enumerationMutation(obj);
        }
        id v7 = *(void **)(*((void *)&v31 + 1) + 8 * i);
        long long v27 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        uint64_t v8 = objc_msgSend(v7, "participants", v21);
        id v9 = [v8 countByEnumeratingWithState:&v27 objects:v39 count:16];
        if (!v9)
        {

LABEL_20:
          [*(id *)(a1 + 56) addObject:v7];
          continue;
        }
        id v10 = v9;
        uint64_t v26 = i;
        uint64_t v11 = *(void *)v28;
        char v12 = 1;
        do
        {
          for (uint64_t j = 0; j != v10; uint64_t j = (char *)j + 1)
          {
            if (*(void *)v28 != v11) {
              objc_enumerationMutation(v8);
            }
            id v14 = *(void **)(*((void *)&v27 + 1) + 8 * (void)j);
            if ([v14 invitationTokenStatus] == (id)3)
            {
              uint64_t v15 = [v7 recordID];
              uint64_t v16 = [v15 zoneID];

              id v17 = PKLogFacilityTypeGetObject();
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
              {
                id v18 = [v16 zoneName];
                *(_DWORD *)id buf = 138412546;
                id v36 = v14;
                __int16 v37 = 2114;
                uint64_t v38 = v18;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Participant %@ needs new keys for zone %{public}@", buf, 0x16u);
              }
              [v14 setWantsNewInvitationToken:1];
              [*(id *)(a1 + 40) addObject:v7];
              id v19 = *(void **)(a1 + 48);
              uint64_t v20 = [v14 participantID];
              [v19 addObject:v20];

              char v12 = 0;
            }
          }
          id v10 = [v8 countByEnumeratingWithState:&v27 objects:v39 count:16];
        }
        while (v10);

        uint64_t i = v26;
        if (v12) {
          goto LABEL_20;
        }
      }
      id v25 = [obj countByEnumeratingWithState:&v31 objects:v40 count:16];
    }
    while (v25);
  }

  v21[2](v21, v22, 0);
}

void sub_1000D0E0C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  if ([*(id *)(a1 + 32) count])
  {
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = [*(id *)(a1 + 32) count];
      id v10 = [*(id *)(a1 + 40) count];
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(a1 + 40);
      *(_DWORD *)id buf = 134218754;
      id v32 = v9;
      __int16 v33 = 2048;
      id v34 = v10;
      __int16 v35 = 2112;
      uint64_t v36 = v11;
      __int16 v37 = 2112;
      uint64_t v38 = v12;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%lu zone shares and %lu participants identifiers needing new keys after parsing: %@, %@", buf, 0x2Au);
    }

    uint64_t v13 = *(void **)(a1 + 48);
    uint64_t v29 = *(void *)(a1 + 56);
    id v14 = [*(id *)(a1 + 32) copy];
    id v30 = v14;
    uint64_t v15 = +[NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];
    uint64_t v16 = PKCloudStoreOperationGroupShareLostKeys;
    uint64_t v17 = PKCloudStoreOperationGroupSuffixShareInvitation;
    id v18 = [*(id *)(a1 + 64) qualityOfService];
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_1000D1094;
    v21[3] = &unk_1007348B0;
    id v22 = *(id *)(a1 + 32);
    id v28 = v7;
    id v23 = v6;
    id v24 = *(id *)(a1 + 56);
    id v19 = *(id *)(a1 + 40);
    uint64_t v20 = *(void *)(a1 + 48);
    id v25 = v19;
    uint64_t v26 = v20;
    id v27 = *(id *)(a1 + 72);
    [v13 modifyRecordsOperationWithRecordsToSaveByDatabaseIdentifier:v15 recordIDsToDeleteByDatabaseIdentifier:0 recordModificationOperationConfiguration:0 emitErrorIfConflictDetected:0 isModifyingShare:1 operationGroupName:v16 operationGroupNameSuffix:v17 qualityOfService:v18 completion:v21];
  }
  else
  {
    (*((void (**)(id, id, void))v7 + 2))(v7, v6, 0);
  }
}

void sub_1000D1094(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if (v12)
  {
    uint64_t v13 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      id v14 = *(NSObject **)(a1 + 32);
      *(_DWORD *)id buf = 138412546;
      id v82 = v12;
      __int16 v83 = 2112;
      long long v84 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Error uploading the zone shares %@ for the particpants that need new keys %@", buf, 0x16u);
    }

    (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
  }
  else
  {
    id v44 = v11;
    id v45 = v10;
    id v46 = v9;
    uint64_t v15 = [v9 objectForKey:*(void *)(a1 + 48)];
    uint64_t v16 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 138412290;
      id v82 = v15;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Completed uploading zone shares for the particpants that need new keys %@", buf, 0xCu);
    }

    uint64_t v17 = dispatch_group_create();
    long long v75 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    id obj = v15;
    id v50 = [obj countByEnumeratingWithState:&v75 objects:v80 count:16];
    if (v50)
    {
      uint64_t v49 = *(void *)v76;
      long long v48 = v17;
      do
      {
        for (uint64_t i = 0; i != v50; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v76 != v49) {
            objc_enumerationMutation(obj);
          }
          id v19 = objc_msgSend(*(id *)(*((void *)&v75 + 1) + 8 * i), "pk_share");
          uint64_t v20 = [v19 recordID];
          uint64_t v55 = [v20 zoneID];

          if (v19)
          {
            long long v51 = i;
            dispatch_group_enter(v17);
            uint64_t v21 = [v19 participants];
            v73[0] = _NSConcreteStackBlock;
            v73[1] = 3221225472;
            v73[2] = sub_1000D18A8;
            v73[3] = &unk_100734888;
            id v74 = *(id *)(a1 + 56);
            id v22 = objc_msgSend(v21, "pk_objectsPassingTest:", v73);

            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)id buf = 138412546;
              id v82 = v22;
              __int16 v83 = 2112;
              long long v84 = v19;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Sending new zone share invitation to participants %@ in share %@", buf, 0x16u);
            }

            group = dispatch_group_create();
            long long v69 = 0u;
            long long v70 = 0u;
            long long v71 = 0u;
            long long v72 = 0u;
            id v52 = v22;
            id v57 = [v52 countByEnumeratingWithState:&v69 objects:v79 count:16];
            if (v57)
            {
              uint64_t v56 = *(void *)v70;
              uint64_t v53 = v19;
              do
              {
                for (uint64_t j = 0; j != v57; uint64_t j = (char *)j + 1)
                {
                  if (*(void *)v70 != v56) {
                    objc_enumerationMutation(v52);
                  }
                  id v24 = *(void **)(*((void *)&v69 + 1) + 8 * (void)j);
                  id v25 = [v24 invitationToken];
                  id v68 = 0;
                  uint64_t v26 = +[NSKeyedArchiver archivedDataWithRootObject:v25 requiringSecureCoding:1 error:&v68];
                  id v27 = v68;

                  if (v26)
                  {
                    id v28 = [v24 userIdentity];
                    uint64_t v29 = [v28 lookupInfo];
                    id v30 = [v29 emailAddress];

                    long long v31 = objc_alloc_init((Class)PKCloudStoreZoneInvitation);
                    id v32 = [v19 URL];
                    [v31 setShareURL:v32];

                    [v31 setShareInvitationToken:v26];
                    uint64_t v33 = a1;
                    id v34 = [*(id *)(a1 + 64) containerManager];
                    __int16 v35 = [v34 containerName];
                    [v31 setContainerIdentifier:v35];

                    uint64_t v36 = [v55 zoneName];
                    [v31 setZoneName:v36];

                    __int16 v37 = +[NSDate date];
                    [v31 setDateCreated:v37];

                    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)id buf = 138412546;
                      id v82 = v30;
                      __int16 v83 = 2112;
                      long long v84 = v31;
                      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Sending zone share invitation to %@, %@", buf, 0x16u);
                    }

                    dispatch_group_enter(group);
                    uint64_t v38 = [*(id *)(v33 + 64) delegate];
                    uint64_t v39 = *(void *)(v33 + 64);
                    v65[0] = _NSConcreteStackBlock;
                    v65[1] = 3221225472;
                    v65[2] = sub_1000D18F0;
                    v65[3] = &unk_100732CB8;
                    id v66 = v30;
                    id v67 = group;
                    id v40 = v30;
                    uint64_t v41 = v39;
                    a1 = v33;
                    [v38 cloudStoreContainer:v41 sendZoneShareInvitation:v31 recipientHandle:v40 completion:v65];

                    id v19 = v53;
                  }
                  else
                  {
                    long long v31 = v16;
                    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)id buf = 138412546;
                      id v82 = v24;
                      __int16 v83 = 2112;
                      long long v84 = v27;
                      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Error encoding invitiation token for participant %@, %@", buf, 0x16u);
                      long long v31 = v16;
                    }
                  }
                }
                id v57 = [v52 countByEnumeratingWithState:&v69 objects:v79 count:16];
              }
              while (v57);
            }

            id v42 = [*(id *)(a1 + 64) workQueue];
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            block[2] = sub_1000D19E8;
            block[3] = &unk_10072E238;
            id v62 = *(id *)(a1 + 72);
            uint64_t v63 = v19;
            uint64_t v17 = v48;
            id v64 = v48;
            dispatch_group_notify(group, v42, block);

            uint64_t i = v51;
          }
        }
        id v50 = [obj countByEnumeratingWithState:&v75 objects:v80 count:16];
      }
      while (v50);
    }

    id v43 = [*(id *)(a1 + 64) workQueue];
    v58[0] = _NSConcreteStackBlock;
    v58[1] = 3221225472;
    v58[2] = sub_1000D1A28;
    v58[3] = &unk_10072E598;
    id v60 = *(id *)(a1 + 80);
    id v59 = *(id *)(a1 + 40);
    dispatch_group_notify(v17, v43, v58);

    id v10 = v45;
    id v9 = v46;
    id v12 = 0;
    id v11 = v44;
  }
}

id sub_1000D18A8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = [a2 participantID];
  id v4 = [v2 containsObject:v3];

  return v4;
}

void sub_1000D18F0(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  id v6 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v7 = @"NO";
    uint64_t v8 = *(void *)(a1 + 32);
    int v9 = 138543874;
    if (a2) {
      CFStringRef v7 = @"YES";
    }
    CFStringRef v10 = v7;
    __int16 v11 = 2112;
    id v12 = v5;
    __int16 v13 = 2112;
    uint64_t v14 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sent zone share invitation with success %{public}@, error %@ to %@", (uint8_t *)&v9, 0x20u);
  }

  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000D19E8(uint64_t a1)
{
  [*(id *)(a1 + 32) addObject:*(void *)(a1 + 40)];
  uint64_t v2 = *(NSObject **)(a1 + 48);
  dispatch_group_leave(v2);
}

uint64_t sub_1000D1A28(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_1000D1A40(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v39 = a2;
  id v38 = a3;
  __int16 v37 = a4;
  CFStringRef v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = [*(id *)(a1 + 32) count];
    uint64_t v9 = *(void *)(a1 + 32);
    *(_DWORD *)id buf = 134218242;
    id v57 = v8;
    __int16 v58 = 2112;
    uint64_t v59 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%lu valid zone shares after parsing: %@", buf, 0x16u);
  }

  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  id obj = *(id *)(a1 + 32);
  id v10 = [obj countByEnumeratingWithState:&v50 objects:v55 count:16];
  if (v10)
  {
    id v11 = v10;
    uint64_t v12 = *(void *)v51;
    __int16 v13 = NSNumber_ptr;
    uint64_t v14 = NSNumber_ptr;
    uint64_t v40 = *(void *)v51;
    do
    {
      uint64_t v15 = 0;
      id v41 = v11;
      do
      {
        if (*(void *)v51 != v12) {
          objc_enumerationMutation(obj);
        }
        uint64_t v16 = *(void **)(*((void *)&v50 + 1) + 8 * (void)v15);
        id v17 = objc_alloc((Class)v13[187]);
        id v18 = [v14[9] setWithObject:v16];
        id v19 = [v17 initWithRecords:v18];

        uint64_t v20 = v19;
        [*(id *)(a1 + 40) addCloudRecord:v19 forContainerDatabaseIdentifier:*(void *)(a1 + 48)];
        uint64_t v21 = [v16 recordID];
        id v22 = [v21 zoneID];

        if ([*(id *)(a1 + 56) storeChangesInDatabase])
        {
          id v23 = [*(id *)(a1 + 64) containerManager];
          [v23 containerDatabaseIdentifier:*(void *)(a1 + 48) didUpdateShare:v16 forZoneID:v22];
        }
        if ([*(id *)(a1 + 56) returnRecords])
        {
          id v43 = v20;
          id v44 = v15;
          long long v48 = 0u;
          long long v49 = 0u;
          long long v46 = 0u;
          long long v47 = 0u;
          id v45 = [v16 participants];
          id v24 = [v45 countByEnumeratingWithState:&v46 objects:v54 count:16];
          if (v24)
          {
            id v25 = v24;
            uint64_t v26 = *(void *)v47;
            do
            {
              id v27 = 0;
              do
              {
                if (*(void *)v47 != v26) {
                  objc_enumerationMutation(v45);
                }
                id v28 = *(void **)(*((void *)&v46 + 1) + 8 * (void)v27);
                uint64_t v29 = [*(id *)(a1 + 64) containerManager];
                id v30 = [*(id *)(a1 + 64) containerManager];
                long long v31 = [v30 databaseForIdentifier:*(void *)(a1 + 48)];
                id v32 = [v29 cloudStoreZoneForZoneID:v22 inContainerDatabase:v31];

                uint64_t v33 = [v28 userIdentity];
                id v34 = [v33 lookupInfo];
                __int16 v35 = [v32 shareParticipantWithLookupInfo:v34];

                uint64_t v36 = [v35 invitationToken];
                [v28 setInvitationToken:v36];

                id v27 = (char *)v27 + 1;
              }
              while (v25 != v27);
              id v25 = [v45 countByEnumeratingWithState:&v46 objects:v54 count:16];
            }
            while (v25);
          }

          uint64_t v12 = v40;
          id v11 = v41;
          __int16 v13 = NSNumber_ptr;
          uint64_t v14 = NSNumber_ptr;
          uint64_t v20 = v43;
          uint64_t v15 = v44;
        }

        uint64_t v15 = (char *)v15 + 1;
      }
      while (v15 != v11);
      id v11 = [obj countByEnumeratingWithState:&v50 objects:v55 count:16];
    }
    while (v11);
  }

  v37[2](v37, v38, 0);
}

uint64_t sub_1000D1E0C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, *(void *)(a1 + 32));
  }
  return result;
}

void sub_1000D1F3C(uint64_t a1, uint64_t a2, void *a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_1000D1FE0;
  v5[3] = &unk_100733C18;
  id v6 = *(id *)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  [a3 enumerateKeysAndObjectsUsingBlock:v5];
}

void sub_1000D1FE0(uint64_t a1, void *a2, void *a3)
{
  id v12 = a2;
  id v5 = a3;
  id v7 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v5];
  id v8 = [objc_alloc((Class)PKCloudStoreZoneShareLock) initWithCloudStoreCoder:v7];
  if (v8)
  {
    id v9 = objc_alloc((Class)PKCloudRecordCloudStoreZoneShareLock);
    id v10 = +[NSSet setWithArray:v5];
    id v11 = [v9 initWithRecords:v10];

    [v11 setCloudStoreZoneShareLock:v8];
    [*(id *)(a1 + 32) addCloudRecord:v11 forContainerDatabaseIdentifier:*(void *)(a1 + 40)];
  }
}

void sub_1000D2210(uint64_t a1, uint64_t a2, void *a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000D22B8;
  v6[3] = &unk_100734900;
  id v5 = *(void **)(a1 + 40);
  void v6[4] = *(void *)(a1 + 32);
  id v7 = v5;
  id v8 = *(id *)(a1 + 48);
  [a3 enumerateKeysAndObjectsUsingBlock:v6];
}

void sub_1000D22B8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v8 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v6];
  id v9 = [v6 firstObject];
  id v10 = [v9 recordID];
  id v11 = [v10 recordName];
  id v12 = +[PKPeerPaymentRecurringPayment recurringPaymentIdentifierFromRecordName:v11];

  if ([v12 length])
  {
    __int16 v13 = [*(id *)(a1 + 32) dataSource];
    uint64_t v14 = [v13 peerPaymentRecurringPaymentWithIdentifier:v12];

    if (v14)
    {
      [v14 applyPropertiesFromCloudStoreRecord:v8];
LABEL_9:
      id v17 = [*(id *)(a1 + 32) dataSource];
      id v22 = v14;
      id v18 = +[NSArray arrayWithObjects:&v22 count:1];
      [v17 insertOrUpdatePeerPaymentRecurringPayments:v18];

      id v19 = objc_alloc((Class)PKCloudRecordRecurringPaymentMemo);
      uint64_t v20 = +[NSSet setWithArray:v6];
      id v21 = [v19 initWithRecords:v20];

      [v21 setRecurringPayment:v14];
      [*(id *)(a1 + 40) addCloudRecord:v21 forContainerDatabaseIdentifier:*(void *)(a1 + 48)];

      uint64_t v15 = v14;
      goto LABEL_10;
    }
    uint64_t v15 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 138412290;
      id v24 = v12;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "No recurring payment on device with identifier %@, creating a new one with the memo content", buf, 0xCu);
    }

    uint64_t v14 = [objc_alloc((Class)PKPeerPaymentRecurringPayment) initWithCloudStoreCoder:v8];
    if (v14) {
      goto LABEL_9;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)id buf = 138412290;
      id v24 = v8;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Could not create recurring payment from cloud record: %@", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v15 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = [v6 firstObject];
      *(_DWORD *)id buf = 138412290;
      id v24 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Couldn't get identifier from record %@", buf, 0xCu);
    }
  }
LABEL_10:
}

void sub_1000D26EC(uint64_t a1, uint64_t a2, void *a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000D2794;
  v6[3] = &unk_100734900;
  id v5 = *(void **)(a1 + 40);
  void v6[4] = *(void *)(a1 + 32);
  id v7 = v5;
  id v8 = *(id *)(a1 + 48);
  [a3 enumerateKeysAndObjectsUsingBlock:v6];
}

void sub_1000D2794(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v8 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v6];
  id v9 = [v6 firstObject];
  id v10 = [v9 recordID];
  id v11 = [v10 recordName];
  id v12 = +[PKPeerPaymentCounterpartImageData counterpartImageDataIdentifierFromRecordName:v11];

  if ([v12 length])
  {
    __int16 v13 = [*(id *)(a1 + 32) dataSource];
    uint64_t v14 = [v13 peerPaymentCounterpartImageDataWithIdentifier:v12];

    if (v14)
    {
      [v14 applyPropertiesFromCloudStoreRecord:v8];
LABEL_9:
      id v17 = [*(id *)(a1 + 32) dataSource];
      [v17 insertOrUpdatePeerPaymentCounterpartImageData:v14];

      id v18 = objc_alloc((Class)PKCloudRecordCounterpartImageData);
      id v19 = +[NSSet setWithArray:v6];
      id v20 = [v18 initWithRecords:v19];

      [v20 setCounterpartImageData:v14];
      [*(id *)(a1 + 40) addCloudRecord:v20 forContainerDatabaseIdentifier:*(void *)(a1 + 48)];

      uint64_t v15 = v14;
      goto LABEL_10;
    }
    uint64_t v15 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 138412290;
      id v22 = v12;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "No counterpart image data on device with identifier %@, creating a new one", (uint8_t *)&v21, 0xCu);
    }

    uint64_t v14 = [objc_alloc((Class)PKPeerPaymentCounterpartImageData) initWithCloudStoreCoder:v8];
    if (v14) {
      goto LABEL_9;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 138412290;
      id v22 = v8;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Could not create counterpart image data from cloud record: %@", (uint8_t *)&v21, 0xCu);
    }
  }
  else
  {
    uint64_t v15 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = [v6 firstObject];
      int v21 = 138412290;
      id v22 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Couldn't get identifier from record %@", (uint8_t *)&v21, 0xCu);
    }
  }
LABEL_10:
}

void sub_1000D2BA4(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableSet);
  id v3 = objc_alloc_init((Class)NSMutableSet);
  id v4 = objc_alloc_init((Class)NSMutableSet);
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472;
  v30[2] = sub_1000D2F44;
  v30[3] = &unk_100734978;
  id v5 = *(void **)(a1 + 32);
  id v6 = *(void **)(a1 + 48);
  void v30[4] = *(void *)(a1 + 40);
  id v31 = v6;
  id v7 = v4;
  id v32 = v7;
  id v8 = v2;
  id v33 = v8;
  id v34 = *(id *)(a1 + 56);
  id v9 = v3;
  id v35 = v9;
  [v5 enumerateKeysAndObjectsForItemType:1 usingBlock:v30];
  [*(id *)(a1 + 32) addRecords:v7];
  [*(id *)(a1 + 32) removeIdentifiers:v9 itemType:1];
  PKLogFacilityTypeGetObject();
  id v10 = (id)objc_claimAutoreleasedReturnValue();
  os_signpost_id_t v11 = os_signpost_id_make_with_pointer(v10, *(const void **)(a1 + 40));
  if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    os_signpost_id_t v12 = v11;
    if (os_signpost_enabled(v10))
    {
      *(_WORD *)id buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_BEGIN, v12, "cloudstore:fetchMissingTransactionRecords", "", buf, 2u);
    }
  }

  if ([v8 count])
  {
    __int16 v13 = *(void **)(a1 + 40);
    uint64_t v36 = *(void *)(a1 + 48);
    id v14 = [v8 copy];
    id v37 = v14;
    uint64_t v15 = +[NSDictionary dictionaryWithObjects:&v37 forKeys:&v36 count:1];
    uint64_t v16 = [*(id *)(a1 + 56) groupName];
    id v17 = [*(id *)(a1 + 56) groupNameSuffix];
    id v18 = [*(id *)(a1 + 56) qualityOfService];
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_1000D3864;
    v24[3] = &unk_1007349A0;
    id v25 = *(id *)(a1 + 32);
    id v19 = *(id *)(a1 + 48);
    uint64_t v20 = *(void *)(a1 + 40);
    id v26 = v19;
    uint64_t v27 = v20;
    id v28 = *(id *)(a1 + 64);
    [v13 fetchRecordsWithRecordIDsByDatabaseIdentifier:v15 operationGroupName:v16 operationGroupNameSuffix:v17 qualityOfService:v18 completion:v24];
  }
  else if (*(void *)(a1 + 64))
  {
    int v21 = v10;
    os_signpost_id_t v22 = os_signpost_id_make_with_pointer(v21, *(const void **)(a1 + 40));
    if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      os_signpost_id_t v23 = v22;
      if (os_signpost_enabled(v21))
      {
        *(_WORD *)id buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v21, OS_SIGNPOST_INTERVAL_END, v23, "cloudstore:fetchMissingTransactionRecords", "", buf, 2u);
      }
    }

    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
}

void sub_1000D2F44(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000D304C;
  v8[3] = &unk_100734950;
  id v6 = *(void **)(a1 + 40);
  void v8[4] = *(void *)(a1 + 32);
  id v9 = v6;
  id v10 = v5;
  id v11 = *(id *)(a1 + 48);
  id v12 = *(id *)(a1 + 56);
  id v13 = *(id *)(a1 + 64);
  id v14 = *(id *)(a1 + 72);
  id v7 = v5;
  [a3 enumerateKeysAndObjectsUsingBlock:v8];
}

void sub_1000D304C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v6];
  id v8 = [v6 firstObject];
  id v9 = [v8 recordID];
  id v10 = [v9 zoneID];

  id v11 = [*(id *)(a1 + 32) containerManager];
  id v12 = [v11 databaseForIdentifier:*(void *)(a1 + 40)];

  id v13 = [*(id *)(a1 + 32) containerManager];
  uint64_t v14 = [v13 cloudStoreZoneForZoneID:v10 inContainerDatabase:v12];

  uint64_t v15 = PKCloudTransactionRecordType;
  uint64_t v16 = [v7 recordsWithRecordType:PKCloudTransactionRecordType];
  id v17 = [v16 firstObject];

  id v68 = (void *)v14;
  if (!v17)
  {
    os_signpost_id_t v23 = [*(id *)(a1 + 32) dataSource];
    int v21 = [v23 cloudStoreRecordWithRecordName:*(void *)(a1 + 48) recordType:v15 inCloudStoreZone:v14];

    objc_msgSend(*(id *)(a1 + 56), "pk_safelyAddObject:", v21);
    if (v21)
    {
      id v24 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *(void *)(a1 + 48);
        *(_DWORD *)id buf = 138543362;
        uint64_t v72 = v25;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Not fetching Transaction recordType for transaction with service id %{public}@ since a cache of the TransactionDeviceData recordType is present", buf, 0xCu);
      }

      id v26 = *(void **)(a1 + 32);
      uint64_t v27 = *(void *)(a1 + 48);
      os_signpost_id_t v22 = [v21 description];
      long long v70 = v22;
      id v28 = +[NSArray arrayWithObjects:&v70 count:1];
      [v26 reportContainerChangeSignpostEventType:53 stateName:v27 objectNames:v28 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];
    }
    else
    {
      os_signpost_id_t v22 = [*(id *)(a1 + 32) _transactionSourceIdentifierForTransactionCloudStoreRecord:v7 databaseIdentifier:*(void *)(a1 + 40)];
      uint64_t v29 = [*(id *)(a1 + 32) dataSource];
      unsigned __int8 v30 = [v29 hasTransactionWithServiceIdentifier:*(void *)(a1 + 48) transactionSourceIdentifier:v22];

      id v28 = PKLogFacilityTypeGetObject();
      BOOL v31 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
      if (v30)
      {
        if (v31)
        {
          uint64_t v32 = *(void *)(a1 + 48);
          *(_DWORD *)id buf = 138543362;
          uint64_t v72 = v32;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Not fetching PKCloudTransactionRecordType for transaction with service id %{public}@ since it already exists in the database", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v63 = v10;
        if (v31)
        {
          uint64_t v45 = *(void *)(a1 + 48);
          *(_DWORD *)id buf = 138543362;
          uint64_t v72 = v45;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Need PKCloudTransactionRecordType record type for transaction with service id %{public}@.", buf, 0xCu);
        }

        long long v46 = [v7 recordsWithRecordType:PKCloudTransactionDeviceDataRecordType];
        long long v47 = [v46 firstObject];

        id v65 = v47;
        long long v48 = [v47 recordID];
        uint64_t v49 = [v48 zoneID];

        long long v50 = (void *)v49;
        if (v49)
        {
          id v28 = [objc_alloc((Class)CKRecordID) initWithRecordName:*(void *)(a1 + 48) zoneID:v49];
          [*(id *)(a1 + 64) addObject:v28];
        }
        else if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v59 = *(void *)(a1 + 48);
          *(_DWORD *)id buf = 138543362;
          uint64_t v72 = v59;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Cannot fetch PKCloudTransactionRecordType record type for transaction with service id %{public}@ because there is no associated zone.", buf, 0xCu);
        }
        id v10 = v63;

        id v28 = v65;
      }
    }

    goto LABEL_45;
  }
  uint64_t v18 = PKCloudTransactionDeviceDataRecordType;
  id v19 = [v7 recordsWithRecordType:PKCloudTransactionDeviceDataRecordType];
  uint64_t v20 = [v19 firstObject];

  if (!v20)
  {
    int v21 = [*(id *)(a1 + 32) _transactionSourceIdentifierForTransactionCloudStoreRecord:v7 databaseIdentifier:*(void *)(a1 + 40)];
    if (!v21 && ([*(id *)(a1 + 72) returnRecords] & 1) == 0)
    {
      uint64_t v55 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v56 = *(void *)(a1 + 48);
        *(_DWORD *)id buf = 138543362;
        uint64_t v72 = v56;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "Skipping processing service id %{public}@ because pass is not on this device", buf, 0xCu);
      }

      [*(id *)(a1 + 80) addObject:*(void *)(a1 + 48)];
      goto LABEL_46;
    }
    objc_opt_class();
    id v66 = v5;
    if (objc_opt_isKindOfClass())
    {
      os_signpost_id_t v22 = [*(id *)(a1 + 72) transactionSourceIdentifiers];
      if (!v21) {
        goto LABEL_18;
      }
    }
    else
    {
      os_signpost_id_t v22 = 0;
      if (!v21) {
        goto LABEL_18;
      }
    }
    if ([v22 count] && (objc_msgSend(v22, "containsObject:", v21) & 1) == 0)
    {
      id v57 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v58 = *(void *)(a1 + 48);
        *(_DWORD *)id buf = 138543362;
        uint64_t v72 = v58;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "Skipping processing service id %{public}@ because it is for a different transaction source", buf, 0xCu);
      }

      [*(id *)(a1 + 80) addObject:*(void *)(a1 + 48)];
      goto LABEL_44;
    }
LABEL_18:
    id v62 = v22;
    id v33 = +[PKPaymentTransaction recordNamePrefix];
    uint64_t v34 = [v33 stringByAppendingString:*(void *)(a1 + 48)];

    id v35 = [*(id *)(a1 + 32) dataSource];
    id v64 = (void *)v34;
    uint64_t v36 = [v35 cloudStoreRecordWithRecordName:v34 recordType:v18 inCloudStoreZone:v68];

    id v37 = (void *)v36;
    objc_msgSend(*(id *)(a1 + 56), "pk_safelyAddObject:", v36);
    id v38 = PKLogFacilityTypeGetObject();
    BOOL v39 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
    if (v37)
    {
      if (v39)
      {
        uint64_t v40 = *(void *)(a1 + 48);
        *(_DWORD *)id buf = 138543362;
        uint64_t v72 = v40;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Not fetching TransactionDeviceData recordType for transaction with service id %{public}@ since a cache of the Transaction recordType is present", buf, 0xCu);
      }

      id v41 = *(void **)(a1 + 32);
      uint64_t v42 = *(void *)(a1 + 48);
      id v43 = [v37 description];
      long long v69 = v43;
      id v44 = +[NSArray arrayWithObjects:&v69 count:1];
      [v41 reportContainerChangeSignpostEventType:53 stateName:v42 objectNames:v44 changeToken:0 error:0 operationGroupName:0 operationGroupNameSuffix:0];
    }
    else
    {
      if (v39)
      {
        uint64_t v51 = *(void *)(a1 + 48);
        *(_DWORD *)id buf = 138543362;
        uint64_t v72 = v51;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Need PKCloudTransactionDeviceDataRecordType record type for transaction with service id %{public}@.", buf, 0xCu);
      }

      long long v52 = [v7 recordsWithRecordType:v15];
      long long v53 = [v52 firstObject];

      uint64_t v61 = v53;
      long long v54 = [v53 recordID];
      id v44 = [v54 zoneID];

      if (v44)
      {
        id v38 = [objc_alloc((Class)CKRecordID) initWithRecordName:v64 zoneID:v44];
        [*(id *)(a1 + 64) addObject:v38];
      }
      else if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v60 = *(void *)(a1 + 48);
        *(_DWORD *)id buf = 138543362;
        uint64_t v72 = v60;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Cannot fetch PKCloudTransactionDeviceDataRecordType record type for transaction with service id %{public}@ because there is no associated zone.", buf, 0xCu);
      }

      id v43 = v61;
      id v37 = 0;
    }

    os_signpost_id_t v22 = v62;
LABEL_44:
    id v5 = v66;
LABEL_45:

LABEL_46:
  }
}

void sub_1000D3864(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = *(void **)(a1 + 32);
  id v7 = [a2 objectForKey:*(void *)(a1 + 40)];
  [v6 addRecords:v7];

  PKLogFacilityTypeGetObject();
  id v8 = (id)objc_claimAutoreleasedReturnValue();
  os_signpost_id_t v9 = os_signpost_id_make_with_pointer(v8, *(const void **)(a1 + 48));
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    os_signpost_id_t v10 = v9;
    if (os_signpost_enabled(v8))
    {
      *(_WORD *)id v12 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_INTERVAL_END, v10, "cloudstore:fetchMissingTransactionRecords", "", v12, 2u);
    }
  }

  uint64_t v11 = *(void *)(a1 + 56);
  if (v11) {
    (*(void (**)(uint64_t, id))(v11 + 16))(v11, v5);
  }
}

void sub_1000D5754(id *a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = a1[4];
    *(_DWORD *)id buf = 138412290;
    id v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Re-fetching account events with unknown servicing status. Event identifiers: %@", buf, 0xCu);
  }

  id v4 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
  id v5 = [a1[5] containerManager];
  id v6 = [v5 cloudStoreZonesByDatabaseIdentifierForItemType:5 action:2];

  [a1[5] primaryRecordTypesForCloudStoreItemType:5];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  void v15[2] = sub_1000D597C;
  v15[3] = &unk_100733C90;
  id v16 = (id)objc_claimAutoreleasedReturnValue();
  id v17 = v4;
  id v7 = a1[4];
  id v8 = a1[5];
  id v18 = v7;
  id v19 = v8;
  id v9 = v4;
  id v10 = v16;
  [v6 enumerateKeysAndObjectsUsingBlock:v15];
  uint64_t v11 = +[NSNull null];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1000D5E5C;
  v13[3] = &unk_100734A18;
  id v14 = a1[6];
  id v12 = [v9 evaluateWithInput:v11 completion:v13];
}

void sub_1000D597C(uint64_t a1, uint64_t a2, void *a3)
{
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id obj = a3;
  id v16 = [obj countByEnumeratingWithState:&v27 objects:v32 count:16];
  if (v16)
  {
    uint64_t v15 = *(void *)v28;
    do
    {
      uint64_t v4 = 0;
      do
      {
        if (*(void *)v28 != v15) {
          objc_enumerationMutation(obj);
        }
        uint64_t v17 = v4;
        uint64_t v5 = *(void *)(*((void *)&v27 + 1) + 8 * v4);
        long long v23 = 0u;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        id v6 = *(id *)(a1 + 32);
        id v7 = [v6 countByEnumeratingWithState:&v23 objects:v31 count:16];
        if (v7)
        {
          id v8 = v7;
          uint64_t v9 = *(void *)v24;
          do
          {
            id v10 = 0;
            do
            {
              if (*(void *)v24 != v9) {
                objc_enumerationMutation(v6);
              }
              uint64_t v11 = *(void *)(*((void *)&v23 + 1) + 8 * (void)v10);
              v18[0] = _NSConcreteStackBlock;
              v18[1] = 3221225472;
              v18[2] = sub_1000D5B88;
              v18[3] = &unk_100730C60;
              id v12 = *(void **)(a1 + 40);
              id v19 = *(id *)(a1 + 48);
              uint64_t v20 = v5;
              uint64_t v13 = *(void *)(a1 + 56);
              uint64_t v21 = v11;
              uint64_t v22 = v13;
              [v12 addOperation:v18];

              id v10 = (char *)v10 + 1;
            }
            while (v8 != v10);
            id v8 = [v6 countByEnumeratingWithState:&v23 objects:v31 count:16];
          }
          while (v8);
        }

        uint64_t v4 = v17 + 1;
      }
      while ((id)(v17 + 1) != v16);
      id v16 = [obj countByEnumeratingWithState:&v27 objects:v32 count:16];
    }
    while (v16);
  }
}

void sub_1000D5B88(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v21[2] = sub_1000D5DAC;
  v21[3] = &unk_1007349C8;
  id v8 = (void *)a1[4];
  void v21[4] = a1[5];
  uint64_t v9 = objc_msgSend(v8, "pk_setByApplyingBlock:", v21);
  uint64_t v22 = v9;
  id v10 = +[NSArray arrayWithObjects:&v22 count:1];
  uint64_t v11 = +[NSPredicate predicateWithFormat:@"recordID in %@" argumentArray:v10];

  id v12 = [objc_alloc((Class)CKQuery) initWithRecordType:a1[6] predicate:v11];
  uint64_t v13 = [PDCloudStoreRecordsRequest alloc];
  id v14 = [(PDCloudStoreRecordsRequest *)v13 initWithRequestType:4 storeChanges:1 returnRecords:0 qualityOfService:9 groupName:PKCloudStoreOperationGroupAccountServicingEventProcessing groupNameSuffix:PKCloudStoreOperationGroupSuffixAccountServicingEventProcessing];
  [(PDCloudStoreRecordsRequest *)v14 setCkQuery:v12];
  [(PDCloudStoreRecordsRequest *)v14 setCloudStoreZone:a1[5]];
  uint64_t v15 = (void *)a1[7];
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1000D5E44;
  v18[3] = &unk_1007349F0;
  id v19 = v6;
  id v20 = v7;
  id v16 = v6;
  id v17 = v7;
  [v15 executeRecordsRequest:v14 completion:v18];
}

id sub_1000D5DAC(uint64_t a1, uint64_t a2)
{
  id v3 = +[PKAccountEvent recordNameForEventIdentifier:a2];
  uint64_t v4 = [*(id *)(a1 + 32) recordZone];
  uint64_t v5 = [v4 zoneID];

  id v6 = [objc_alloc((Class)CKRecordID) initWithRecordName:v3 zoneID:v5];
  return v6;
}

uint64_t sub_1000D5E44(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

uint64_t sub_1000D5E5C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000D67CC(uint64_t a1, uint64_t a2, void *a3)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000D68EC;
  v6[3] = &unk_100734A40;
  uint64_t v5 = *(void **)(a1 + 40);
  void v6[4] = *(void *)(a1 + 32);
  id v7 = v5;
  id v8 = *(id *)(a1 + 48);
  id v9 = *(id *)(a1 + 56);
  id v10 = *(id *)(a1 + 64);
  id v11 = *(id *)(a1 + 72);
  id v12 = *(id *)(a1 + 80);
  id v13 = *(id *)(a1 + 88);
  id v14 = *(id *)(a1 + 96);
  [a3 enumerateKeysAndObjectsUsingBlock:v6];
}

void sub_1000D68EC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  id v7 = [v6 countByEnumeratingWithState:&v68 objects:v78 count:16];
  if (!v7) {
    goto LABEL_47;
  }
  id v8 = v7;
  id v9 = 0;
  id v10 = 0;
  uint64_t v11 = *(void *)v69;
  do
  {
    for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v69 != v11) {
        objc_enumerationMutation(v6);
      }
      id v13 = *(NSObject **)(*((void *)&v68 + 1) + 8 * i);
      id v14 = [v13 recordType];
      if (!v10 && ([*(id *)(a1 + 32) _isAccountEventFromRecordType:v14] & 1) != 0)
      {
        id v10 = v13;
LABEL_12:
        uint64_t v15 = v13;
        goto LABEL_14;
      }
      if (v9) {
        goto LABEL_14;
      }
      if ([*(id *)(a1 + 32) _isAccountEventAssociatedObjectFromRecordType:v14])
      {
        id v9 = v13;
        goto LABEL_12;
      }
      id v9 = 0;
LABEL_14:
    }
    id v8 = [v6 countByEnumeratingWithState:&v68 objects:v78 count:16];
  }
  while (v8);
  if (!v10)
  {
    if (v9)
    {
      id v16 = [v9 pk_referenceForKey:PKAccountEventReferenceFromAssociatedObject];
      long long v30 = [v16 recordID];
      BOOL v31 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v32 = [v9 recordType];
        *(_DWORD *)id buf = 138412290;
        id v74 = v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Received a child account event by itself of type %@", buf, 0xCu);
      }
      if (v16)
      {
        obja = v31;
        uint64_t v59 = v16;
        id v55 = v5;
        [*(id *)(a1 + 48) objectForKey:*(void *)(a1 + 56)];
        long long v60 = 0u;
        long long v61 = 0u;
        long long v62 = 0u;
        long long v63 = 0u;
        BOOL v31 = (id)objc_claimAutoreleasedReturnValue();
        id v33 = [v31 countByEnumeratingWithState:&v60 objects:v72 count:16];
        if (v33)
        {
          id v34 = v33;
          uint64_t v35 = *(void *)v61;
LABEL_40:
          uint64_t v36 = 0;
          while (1)
          {
            if (*(void *)v61 != v35) {
              objc_enumerationMutation(v31);
            }
            id v37 = *(void **)(*((void *)&v60 + 1) + 8 * v36);
            id v38 = [v37 recordID];
            if (PKEqualObjects()) {
              break;
            }

            if (v34 == (id)++v36)
            {
              id v34 = [v31 countByEnumeratingWithState:&v60 objects:v72 count:16];
              if (v34) {
                goto LABEL_40;
              }
              goto LABEL_46;
            }
          }
          id v43 = v37;
          BOOL v39 = obja;
          if (os_log_type_enabled(obja, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = 138412290;
            id v74 = v38;
            _os_log_impl((void *)&_mh_execute_header, obja, OS_LOG_TYPE_DEFAULT, "Found carried over parent record %@", buf, 0xCu);
          }

          [*(id *)(a1 + 64) addObject:v43];
          id v5 = v55;
          id v16 = v59;
          if (v43) {
            goto LABEL_81;
          }
        }
        else
        {
LABEL_46:

          id v5 = v55;
          BOOL v39 = obja;
          id v16 = v59;
        }
        if ([*(id *)(a1 + 72) useLastChangeToken])
        {
          id v44 = [v30 zoneID];
          if (v44)
          {
            [*(id *)(a1 + 96) addObject:v30];
          }
          else
          {
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)id buf = 138412290;
              id v74 = v16;
              _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Cannot create a query for the parent record because a zone does not exist for the reference %@", buf, 0xCu);
            }
          }
        }
        else
        {
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v45 = [v9 recordID];
            *(_DWORD *)id buf = 138412290;
            id v74 = v45;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Adding child record to carry over %@", buf, 0xCu);
          }
          [*(id *)(a1 + 88) addObject:v9];
        }
        id v43 = 0;
LABEL_81:
      }
      else if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Missing reference on child record", buf, 2u);
      }

      id v10 = 0;
      goto LABEL_83;
    }
LABEL_47:
    id v16 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Received account records without parent or child record", buf, 2u);
    }
    id v10 = 0;
    goto LABEL_50;
  }
  id v16 = [v10 pk_encryptedStringForKey:PKCloudTransactionAccountIdentifierKey];
  if ([*(id *)(a1 + 40) count]
    && ([*(id *)(a1 + 40) containsObject:v16] & 1) == 0)
  {
    uint64_t v40 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      id v41 = [v10 recordID];
      uint64_t v42 = [v41 recordName];
      *(_DWORD *)id buf = 138412290;
      id v74 = v42;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Skipping acount event %@ because it is from a different pass", buf, 0xCu);
    }
    goto LABEL_83;
  }

  if (!v9)
  {
    id v17 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Need to fetch child records for account event", buf, 2u);
    }

    id v16 = [v10 recordID];
    id v18 = [v16 zoneID];
    if (v18)
    {
      id v19 = [*(id *)(a1 + 32) _recordTypeForAccountEventRecord:v10];
      id v20 = [objc_alloc((Class)CKReference) initWithRecordID:v16 action:0];
      uint64_t v21 = v20;
      if (v19)
      {
        unsigned int oslog = v17;
        id v51 = v20;
        long long v52 = v19;
        long long v53 = v18;
        uint64_t v58 = v16;
        id v54 = v5;
        [*(id *)(a1 + 48) objectForKey:*(void *)(a1 + 56)];
        long long v64 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        id obj = (id)objc_claimAutoreleasedReturnValue();
        id v22 = [obj countByEnumeratingWithState:&v64 objects:v77 count:16];
        if (v22)
        {
          id v23 = v22;
          uint64_t v24 = *(void *)v65;
          uint64_t v25 = PKAccountEventReferenceFromAssociatedObject;
LABEL_26:
          uint64_t v26 = 0;
          while (1)
          {
            if (*(void *)v65 != v24) {
              objc_enumerationMutation(obj);
            }
            long long v27 = *(void **)(*((void *)&v64 + 1) + 8 * v26);
            long long v28 = objc_msgSend(v27, "pk_referenceForKey:", v25);
            long long v29 = [v28 recordID];
            if (v28)
            {
              if (PKEqualObjects()) {
                break;
              }
            }

            if (v23 == (id)++v26)
            {
              id v23 = [obj countByEnumeratingWithState:&v64 objects:v77 count:16];
              if (v23) {
                goto LABEL_26;
              }
              goto LABEL_33;
            }
          }
          if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)id buf = 138412290;
            id v74 = v29;
            _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Found carried over child record %@", buf, 0xCu);
          }

          id v46 = v27;
          [*(id *)(a1 + 64) addObject:v46];

          id v18 = v53;
          id v5 = v54;
          id v16 = v58;
          uint64_t v21 = v51;
          id v19 = v52;
          if (v46) {
            goto LABEL_90;
          }
        }
        else
        {
LABEL_33:

          id v18 = v53;
          id v5 = v54;
          id v16 = v58;
          uint64_t v21 = v51;
          id v19 = v52;
        }
        if ([*(id *)(a1 + 72) useLastChangeToken]) {
          goto LABEL_86;
        }
        long long v47 = [*(id *)(a1 + 72) ckQuery];
        if (v47)
        {

          goto LABEL_86;
        }
        if ([*(id *)(a1 + 72) requestType] == (id)5)
        {
LABEL_86:
          id v48 = [*(id *)(a1 + 80) objectForKey:v19];
          if (!v48)
          {
            id v48 = objc_alloc_init((Class)NSMutableArray);
            [*(id *)(a1 + 80) setObject:v48 forKey:v19];
          }
          [v48 addObject:v21];
        }
        else
        {
          if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v49 = [v10 recordID];
            *(_DWORD *)id buf = 138412290;
            id v74 = v49;
            _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Adding parent record to carry over %@", buf, 0xCu);
          }
          [*(id *)(a1 + 88) addObject:v10];
        }
        id v46 = 0;
LABEL_90:

        id v17 = obj;
      }
      else if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138412546;
        id v74 = v16;
        __int16 v75 = 2112;
        long long v76 = v21;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Error: cannot find a record type for parent record %@ and reference %@", buf, 0x16u);
      }
    }
    else
    {
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)id buf = 138412290;
        id v74 = v10;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Cannot create a query for a child record because a zone does not exist for parent record %@", buf, 0xCu);
      }
      id v19 = v17;
    }

LABEL_50:
    id v9 = 0;
LABEL_83:
  }
}

void sub_1000D7260(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(a1 + 32);
  uint64_t v21 = *(void *)(a1 + 40);
  id v9 = [*(id *)(a1 + 48) copy];
  id v22 = v9;
  id v10 = +[NSDictionary dictionaryWithObjects:&v22 forKeys:&v21 count:1];
  uint64_t v11 = [*(id *)(a1 + 56) groupName];
  id v12 = [*(id *)(a1 + 56) groupNameSuffix];
  id v13 = [*(id *)(a1 + 56) qualityOfService];
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_1000D73FC;
  v17[3] = &unk_100734A90;
  id v14 = *(id *)(a1 + 64);
  id v19 = v6;
  id v20 = v7;
  id v18 = v14;
  id v15 = v6;
  id v16 = v7;
  [v8 fetchRecordsWithRecordIDsByDatabaseIdentifier:v10 operationGroupName:v11 operationGroupNameSuffix:v12 qualityOfService:v13 completion:v17];
}

void sub_1000D73FC(uint64_t a1, void *a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000D74A0;
  v4[3] = &unk_10072F3A0;
  id v5 = *(id *)(a1 + 32);
  [a2 enumerateKeysAndObjectsUsingBlock:v4];
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

id sub_1000D74A0(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "addRecords:");
}

void sub_1000D74A8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v16 = *(void *)(a1 + 40);
  id v17 = *(void **)(a1 + 32);
  id v8 = [*(id *)(a1 + 48) groupName];
  id v9 = [*(id *)(a1 + 48) groupNameSuffix];
  id v10 = [*(id *)(a1 + 48) qualityOfService];
  uint64_t v11 = *(void *)(a1 + 56);
  id v12 = [*(id *)(a1 + 32) containerManager];
  id v13 = [v12 databaseForIdentifier:*(void *)(a1 + 64)];
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v21[2] = sub_1000D7658;
  v21[3] = &unk_100734AB8;
  id v22 = *(id *)(a1 + 72);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1000D771C;
  v18[3] = &unk_100731538;
  id v19 = v6;
  id v20 = v7;
  id v14 = v6;
  id v15 = v7;
  [v17 fetchRecordsWithQuery:v16 batchLimit:0 operationGroupName:v8 operationGroupNameSuffix:v9 qualityOfService:v10 zone:v11 containerDatabase:v13 batchHandler:v21 completion:v18];
}

void sub_1000D7658(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000D7714;
  v6[3] = &unk_10072F3A0;
  id v7 = *(id *)(a1 + 32);
  [a2 enumerateKeysAndObjectsUsingBlock:v6];
  if (v5) {
    v5[2](v5, 1);
  }
}

id sub_1000D7714(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "addRecords:");
}

uint64_t sub_1000D771C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_1000D7734(uint64_t a1)
{
  PKLogFacilityTypeGetObject();
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  os_signpost_id_t v3 = os_signpost_id_make_with_pointer(v2, *(const void **)(a1 + 32));
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    os_signpost_id_t v4 = v3;
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)id v9 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_END, v4, "cloudstore:fetchMissingAccountEventRecords", "", v9, 2u);
    }
  }

  uint64_t v5 = *(void *)(a1 + 56);
  if ([*(id *)(a1 + 40) count])
  {
    id v6 = *(void **)(a1 + 40);
    uint64_t v10 = *(void *)(a1 + 48);
    id v7 = [v6 copy];
    id v11 = v7;
    id v8 = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
    (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v8);
  }
  else
  {
    (*(void (**)(uint64_t, void))(v5 + 16))(v5, 0);
  }
}

void sub_1000D7D5C(uint64_t a1, uint64_t a2, void *a3)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_1000D7E30;
  v7[3] = &unk_100733BC8;
  id v8 = *(id *)(a1 + 32);
  id v5 = *(id *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 64);
  id v9 = v5;
  uint64_t v12 = v6;
  id v10 = *(id *)(a1 + 48);
  id v11 = *(id *)(a1 + 56);
  [a3 enumerateKeysAndObjectsUsingBlock:v7];
}

void sub_1000D7E30(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v8 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v6];
  id v9 = [objc_alloc((Class)PKAccountEvent) initWithCloudStoreCoder:v8];
  id v10 = [v9 altDSID];
  id v11 = [v10 length];

  if (!v11) {
    [v9 setAltDSID:*(void *)(a1 + 32)];
  }
  uint64_t v12 = [v9 items];
  id v13 = [v12 count];

  if (v13)
  {
    [*(id *)(a1 + 40) addObject:v9];
    [v9 addUpdateReasons:*(void *)(a1 + 64)];
    id v14 = objc_alloc((Class)PKCloudRecordAccountEvent);
    id v15 = +[NSSet setWithArray:v6];
    id v16 = [v14 initWithRecords:v15];

    [v16 setEvent:v9];
    [*(id *)(a1 + 48) addCloudRecord:v16 forContainerDatabaseIdentifier:*(void *)(a1 + 56)];
  }
  else
  {
    id v17 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      id v18 = [v9 description];
      int v19 = 138412290;
      id v20 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Event record does not have any items: %@", (uint8_t *)&v19, 0xCu);
    }
  }
}

id sub_1000D8024(id a1, PKAccountEvent *a2)
{
  return [(PKAccountEvent *)a2 identifier];
}

uint64_t sub_1000D802C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 40);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, *(void *)(a1 + 32));
  }
  return result;
}

void sub_1000D8308(uint64_t a1, uint64_t a2, void *a3)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000D83D4;
  v8[3] = &unk_100734B70;
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  id v7 = *(void **)(a1 + 48);
  id v9 = v5;
  uint64_t v10 = v6;
  id v11 = v7;
  id v12 = *(id *)(a1 + 56);
  id v13 = *(id *)(a1 + 64);
  [a3 enumerateKeysAndObjectsUsingBlock:v8];
}

void sub_1000D83D4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  dispatch_group_enter(*(dispatch_group_t *)(a1 + 32));
  id v8 = [objc_alloc((Class)PKCloudStoreRecord) initWithRecords:v6];
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void **)(v9 + 256);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1000D8538;
  v13[3] = &unk_100734B48;
  id v14 = v8;
  uint64_t v15 = v9;
  id v16 = *(id *)(a1 + 48);
  id v11 = v6;
  id v17 = v11;
  id v18 = *(id *)(a1 + 56);
  id v19 = *(id *)(a1 + 64);
  id v20 = *(id *)(a1 + 32);
  id v12 = v8;
  [v10 defaultAccountForFeature:4 completion:v13];
}

void sub_1000D8538(uint64_t a1, void *a2)
{
  id v3 = a2;
  os_signpost_id_t v4 = [v3 accountBaseURL];

  if (v4)
  {
    [v3 updateWithCloudStoreRecord:*(void *)(a1 + 32)];
    [*(id *)(a1 + 40) _insertAccountBalanceUpdateNotificationIfNecessaryForAccount:v3 record:*(void *)(a1 + 32)];
    [*(id *)(a1 + 48) addObject:v3];
  }
  else
  {
    id v5 = [objc_alloc((Class)PKAccount) initWithCloudStoreCoder:*(void *)(a1 + 32)];
    if (v5)
    {
      [*(id *)(a1 + 48) addObject:v5];
      id v6 = objc_alloc((Class)PKCloudRecordAccount);
      id v7 = +[NSSet setWithArray:*(void *)(a1 + 56)];
      id v8 = [v6 initWithRecords:v7];

      [v8 setAccount:v5];
      [*(id *)(a1 + 64) addCloudRecord:v8 forContainerDatabaseIdentifier:*(void *)(a1 + 72)];
      uint64_t v9 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = [v8 descriptionWithItem:1];
        int v11 = 138412290;
        id v12 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Parsed account cloud record: %@", (uint8_t *)&v11, 0xCu);
      }
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 80));
}

uint64_t sub_1000D86DC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64))
  {
    id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 56));
    if (WeakRetained)
    {
      long long v11 = 0u;
      long long v12 = 0u;
      long long v9 = 0u;
      long long v10 = 0u;
      id v3 = *(id *)(a1 + 32);
      id v4 = [v3 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v4)
      {
        id v5 = v4;
        uint64_t v6 = *(void *)v10;
        do
        {
          id v7 = 0;
          do
          {
            if (*(void *)v10 != v6) {
              objc_enumerationMutation(v3);
            }
            objc_msgSend(WeakRetained[32], "insertOrReplaceAccount:extended:deleteSensitiveData:completion:", *(void *)(*((void *)&v9 + 1) + 8 * (void)v7), 1, 0, 0, (void)v9);
            id v7 = (char *)v7 + 1;
          }
          while (v5 != v7);
          id v5 = [v3 countByEnumeratingWithState:&v9 objects:v13 count:16];
        }
        while (v5);
      }
    }
  }
  uint64_t result = *(void *)(a1 + 48);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(result + 16))(result, *(void *)(a1 + 40));
  }
  return result;
}

void PDNFSecureXPCEventHandleExpressTransactionEvent(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (!v5 || (id v7 = v6) == 0) {
    __break(1u);
  }
  id v8 = (const char *)PKGetConstantStringNF_SECURE_XPC_EVENT_KEY_EVENT_SIMPLE_STRING();
  switch(a1)
  {
    case 0:
      long long v9 = objc_alloc_init(PDExpressTransactionEventEntered);
      long long v11 = xpc_dictionary_get_value(v5, v8);
      string_ptr = xpc_string_get_string_ptr(v11);

      if (string_ptr)
      {
        id v13 = [objc_alloc((Class)NSString) initWithUTF8String:string_ptr];
        uint64_t v14 = PKPassAutomaticSelectionTechnologyTypeForExpressEnteredObject();

        if (v14)
        {
LABEL_45:
          [(PDExpressTransactionEventEntered *)v9 setTechnologyType:v14];
          goto LABEL_81;
        }
        uint64_t v15 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)id buf = 136446210;
          long long v67 = string_ptr;
          id v16 = "PDNFSecureXPCEventStreamManager: WARNING UNRECOGNIZED EXPRESS TYPE DETECTED: %{public}s! Please file a radar.";
          id v17 = v15;
          uint32_t v18 = 12;
LABEL_43:
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
        }
      }
      else
      {
        uint64_t v15 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)id buf = 0;
          id v16 = "PDNFSecureXPCEventStreamManager: entered event missing technology type.";
          id v17 = v15;
          uint32_t v18 = 2;
          goto LABEL_43;
        }
      }

      uint64_t v14 = 0;
      goto LABEL_45;
    case 1:
      id v19 = PDExpressTransactionEventExited;
      goto LABEL_16;
    case 2:
      id v20 = xpc_dictionary_get_value(v5, v8);
      uint64_t v21 = (void *)xpc_string_get_string_ptr(v20);
      if (v21)
      {
        id v22 = [objc_alloc((Class)NSString) initWithUTF8String:v21];
        id v23 = [v22 componentsSeparatedByString:@":"];
        if ([v23 count] == (id)2)
        {
          uint64_t v24 = [v23 objectAtIndexedSubscript:0];
          uint64_t v21 = [v23 objectAtIndexedSubscript:1];
        }
        else
        {
          uint64_t v24 = v22;
          uint64_t v21 = 0;
        }

        if (v24)
        {
          uint64_t v49 = PDExpressTransactionEventTransactionStart;
          goto LABEL_72;
        }
      }
      else
      {
      }
      uint64_t v24 = PKLogFacilityTypeGetObject();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_76;
      }
      *(_WORD *)id buf = 0;
      long long v50 = "PDNFSecureXPCEventStreamManager: transaction start event missing identifiers.";
      goto LABEL_75;
    case 3:
      id v19 = PDExpressTransactionEventTransactionTimeout;
LABEL_16:
      long long v9 = (PDExpressTransactionEventEntered *)objc_alloc_init(v19);
      goto LABEL_82;
    case 4:
    case 5:
    case 6:
    case 7:
      long long v9 = objc_alloc_init(PDExpressTransactionEventTransactionEnd);
      uint64_t v10 = 0;
      switch(a1)
      {
        case 4:
          break;
        case 5:
          uint64_t v10 = 2;
          break;
        case 7:
          uint64_t v45 = xpc_dictionary_get_value(v5, "PairingModeBrandCode");
          id v46 = v45;
          if (v45)
          {
            long long v47 = +[NSNumber numberWithLongLong:xpc_int64_get_value(v45)];
          }
          else
          {
            long long v47 = 0;
          }
          [(PDExpressTransactionEventEntered *)v9 setBrandCode:v47];

          uint64_t v10 = 3;
          break;
        default:
          uint64_t v10 = 1;
          break;
      }
      [(PDExpressTransactionEventEntered *)v9 setStatus:v10];
      goto LABEL_81;
    case 8:
      uint64_t v25 = xpc_dictionary_get_value(v5, v8);
      uint64_t v21 = (void *)xpc_string_get_string_ptr(v25);
      if (v21)
      {
        id v26 = [objc_alloc((Class)NSString) initWithUTF8String:v21];
        long long v27 = [v26 componentsSeparatedByString:@":"];
        if ([v27 count] == (id)2)
        {
          uint64_t v24 = [v27 objectAtIndexedSubscript:0];
          uint64_t v21 = [v27 objectAtIndexedSubscript:1];
        }
        else
        {
          uint64_t v24 = v26;
          uint64_t v21 = 0;
        }

        if (v24)
        {
          uint64_t v49 = PDExpressTransactionEventNotFound;
          goto LABEL_72;
        }
      }
      else
      {
      }
      uint64_t v24 = PKLogFacilityTypeGetObject();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_76;
      }
      *(_WORD *)id buf = 0;
      long long v50 = "PDNFSecureXPCEventStreamManager: not found start event missing identifiers.";
      goto LABEL_75;
    case 9:
      long long v9 = objc_alloc_init(PDExpressTransactionEventTCI);
      id v28 = objc_alloc_init((Class)NSMutableOrderedSet);
      long long v29 = xpc_dictionary_get_value(v5, v8);
      long long v30 = xpc_string_get_string_ptr(v29);

      if (v30)
      {
        id v31 = [objc_alloc((Class)NSString) initWithUTF8String:v30];
        uint64_t v32 = [v31 componentsSeparatedByString:@","];

        long long v62 = 0u;
        long long v63 = 0u;
        long long v60 = 0u;
        long long v61 = 0u;
        id v33 = v32;
        id v34 = [v33 countByEnumeratingWithState:&v60 objects:v65 count:16];
        if (v34)
        {
          id v35 = v34;
          uint64_t v36 = *(void *)v61;
          do
          {
            for (uint64_t i = 0; i != v35; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v61 != v36) {
                objc_enumerationMutation(v33);
              }
              id v38 = objc_msgSend(*(id *)(*((void *)&v60 + 1) + 8 * i), "pk_decodeHexadecimal");
              if (v38) {
                [v28 addObject:v38];
              }
            }
            id v35 = [v33 countByEnumeratingWithState:&v60 objects:v65 count:16];
          }
          while (v35);
        }
      }
      if ([v28 count])
      {
        [(PDExpressTransactionEventEntered *)v9 setTCIs:v28];
      }
      else
      {
        id v48 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)id buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "PDNFSecureXPCEventStreamManager: TCI event missing TCIs.", buf, 2u);
        }
      }
LABEL_81:

      goto LABEL_82;
    case 10:
      BOOL v39 = xpc_dictionary_get_value(v5, v8);
      uint64_t v21 = (void *)xpc_string_get_string_ptr(v39);
      if (v21)
      {
        id v40 = [objc_alloc((Class)NSString) initWithUTF8String:v21];
        id v41 = [v40 componentsSeparatedByString:@":"];
        if ([v41 count] == (id)2)
        {
          uint64_t v24 = [v41 objectAtIndexedSubscript:0];
          uint64_t v21 = [v41 objectAtIndexedSubscript:1];
        }
        else
        {
          uint64_t v24 = v40;
          uint64_t v21 = 0;
        }

        if (v24)
        {
          uint64_t v49 = PDExpressTransactionEventPresentPass;
          goto LABEL_72;
        }
      }
      else
      {
      }
      uint64_t v24 = PKLogFacilityTypeGetObject();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_76;
      }
      *(_WORD *)id buf = 0;
      long long v50 = "PDNFSecureXPCEventStreamManager: present pass event missing identifiers.";
      goto LABEL_75;
    case 11:
      uint64_t v42 = xpc_dictionary_get_value(v5, v8);
      uint64_t v21 = (void *)xpc_string_get_string_ptr(v42);
      if (v21)
      {
        id v43 = [objc_alloc((Class)NSString) initWithUTF8String:v21];
        id v44 = [v43 componentsSeparatedByString:@":"];
        if ([v44 count] == (id)2)
        {
          uint64_t v24 = [v44 objectAtIndexedSubscript:0];
          uint64_t v21 = [v44 objectAtIndexedSubscript:1];
        }
        else
        {
          uint64_t v24 = v43;
          uint64_t v21 = 0;
        }

        if (v24)
        {
          uint64_t v49 = PDExpressTransactionEventEnableBiometrics;
LABEL_72:
          long long v9 = (PDExpressTransactionEventEntered *)objc_alloc_init(v49);
          [(PDExpressTransactionEventEntered *)v9 setApplicationIdentifier:v24];
          [(PDExpressTransactionEventEntered *)v9 setKeyIdentifier:v21];
          goto LABEL_77;
        }
      }
      else
      {
      }
      uint64_t v24 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id buf = 0;
        long long v50 = "PDNFSecureXPCEventStreamManager: enable biometrics event missing identifiers.";
LABEL_75:
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v50, buf, 2u);
      }
LABEL_76:
      long long v9 = 0;
LABEL_77:

LABEL_82:
      if (v9)
      {
        long long v58 = 0u;
        long long v59 = 0u;
        long long v56 = 0u;
        long long v57 = 0u;
        id v51 = v7;
        id v52 = [v51 countByEnumeratingWithState:&v56 objects:v64 count:16];
        if (v52)
        {
          id v53 = v52;
          uint64_t v54 = *(void *)v57;
          do
          {
            for (uint64_t j = 0; j != v53; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v57 != v54) {
                objc_enumerationMutation(v51);
              }
              objc_msgSend(*(id *)(*((void *)&v56 + 1) + 8 * (void)j), "receivedSecureExpressTransactionEvent:", v9, (void)v56);
            }
            id v53 = [v51 countByEnumeratingWithState:&v56 objects:v64 count:16];
          }
          while (v53);
        }
      }
LABEL_91:

      return;
    default:
      goto LABEL_91;
  }
}

void sub_1000DA47C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_1000DA604(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v8 = objc_alloc_init((Class)PKSharedAccountCloudStoreZone);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v8 withProperties:v6 values:a4];

  id v7 = v8;
  if (v8)
  {
    objc_msgSend(*(id *)(a1 + 40), "addObject:");
    id v7 = v8;
  }
}

void sub_1000DA948(id a1, PKSharedAccountCloudStoreZone *a2, id a3)
{
}

void sub_1000DA950(id a1, PKSharedAccountCloudStoreZone *a2, id a3)
{
}

void sub_1000DA958(id a1, PKSharedAccountCloudStoreZone *a2, id a3)
{
  id v4 = a2;
  -[PKSharedAccountCloudStoreZone setAccountType:](v4, "setAccountType:", [a3 integerValue]);
}

void sub_1000DA9B0(id a1, PKSharedAccountCloudStoreZone *a2, id a3)
{
  id v4 = a2;
  -[PKSharedAccountCloudStoreZone setAccess:](v4, "setAccess:", [a3 integerValue]);
}

void sub_1000DAA08(id a1, PKSharedAccountCloudStoreZone *a2, id a3)
{
  id v4 = a2;
  -[PKSharedAccountCloudStoreZone setMode:](v4, "setMode:", [a3 integerValue]);
}

void sub_1000DAA60(id a1, PKSharedAccountCloudStoreZone *a2, id a3)
{
}

void sub_1000DAA68(id a1, PKSharedAccountCloudStoreZone *a2, id a3)
{
  if (a3)
  {
    id v4 = a2;
    id v6 = [a3 componentsSeparatedByString:@","];
    id v5 = +[NSSet setWithArray:](NSSet, "setWithArray:");
    [(PKSharedAccountCloudStoreZone *)v4 setSharedUsersAltDSIDs:v5];
  }
  else
  {
    id v6 = a2;
    [(PKSharedAccountCloudStoreZone *)v6 setSharedUsersAltDSIDs:0];
  }
}

void sub_1000DCA34(id *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = [a1[4] _updatePassTileDescriptor:v5 groupDescriptor:0 idx:a3 previousStates:a1[5] visitedIdentifiers:a1[6]];
  id v7 = [v5 metadata];
  unsigned int v8 = [v7 isGroupType];

  if (v8)
  {
    long long v9 = [v5 childDescriptors];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_1000DCB64;
    v10[3] = &unk_100734F00;
    void v10[4] = a1[4];
    id v11 = v6;
    id v12 = a1[5];
    id v13 = a1[6];
    [v9 enumerateObjectsUsingBlock:v10];
  }
}

id sub_1000DCB64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) _updatePassTileDescriptor:a2 groupDescriptor:*(void *)(a1 + 40) idx:a3 previousStates:*(void *)(a1 + 48) visitedIdentifiers:*(void *)(a1 + 56)];
}

void sub_1000DDDC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DDDD8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = [*(id *)(a1 + 48) _dynamicStateInDatabase:*(void *)(a1 + 32) forPassPID:a2];
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v5 = *(void *)(v4 + 40);
  *(void *)(v4 + 40) = v3;
  return _objc_release_x1(v3, v5);
}

void sub_1000DDFF0(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  if (*a4)
  {
    uint64_t v7 = *(void *)(a1 + 40);
    id v6 = *(void **)(a1 + 48);
    id v8 = *a4;
    id v9 = [v6 _dynamicStateInDatabase:v7 forPassPID:a2];
    [*(id *)(a1 + 32) setObject:v9 forKeyedSubscript:v8];
  }
}

void sub_1000DE1D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DE1EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = +[Pass _realPassInDatabase:withProperties:values:fromPass:](Pass, "_realPassInDatabase:withProperties:values:fromPass:", *(void *)(*(void *)(a1 + 32) + 8), a2, a3);
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v6 = *(void *)(v5 + 40);
  *(void *)(v5 + 40) = v4;
  return _objc_release_x1(v4, v6);
}

id *sub_1000DE410(id *result, uint64_t a2, void *a3)
{
  if (*a3) {
    return (id *)objc_msgSend(result[4], "addObject:");
  }
  return result;
}

id *sub_1000DE634(id *result, uint64_t a2, void *a3)
{
  if (*a3) {
    return (id *)objc_msgSend(result[4], "addObject:");
  }
  return result;
}

id *sub_1000DE804(id *result, uint64_t a2, void *a3)
{
  if (*a3) {
    return (id *)objc_msgSend(result[4], "addObject:");
  }
  return result;
}

id *sub_1000DE9D0(id *result, uint64_t a2, void *a3)
{
  if (*a3) {
    return (id *)objc_msgSend(result[4], "addObject:");
  }
  return result;
}

uint64_t sub_1000DEB14(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 56) queryWithDatabase:*(void *)(a1 + 32) predicate:*(void *)(a1 + 40)];
  v8[0] = @"unique_id";
  v8[1] = @"pass_type.identifier";
  v8[2] = @"serial_number";
  v8[3] = @"manifest_hash";
  void v8[4] = @"template";
  void v8[5] = @"organization_name";
  v8[6] = @"grouping_id";
  uint64_t v3 = +[NSArray arrayWithObjects:v8 count:7];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_1000DEC70;
  v5[3] = &unk_10072ED00;
  id v6 = *(id *)(a1 + 32);
  id v7 = *(id *)(a1 + 48);
  [v2 enumeratePersistentIDsAndProperties:v3 usingBlock:v5];

  return 1;
}

void sub_1000DEC70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void **)a4;
  if (*(void *)a4)
  {
    id v9 = *(void **)(a4 + 8);
    id v8 = *(void **)(a4 + 16);
    uint64_t v10 = *(void **)(a4 + 32);
    id v11 = *(id *)(a4 + 24);
    id v12 = v8;
    id v13 = v9;
    id v21 = v4;
    id v14 = [v10 integerValue];
    uint64_t v15 = *(void **)(a4 + 40);
    id v16 = *(id *)(a4 + 48);
    id v17 = v15;
    uint32_t v18 = objc_alloc_init(PDCandidateRelevantPass);
    [(PDCandidateRelevantPass *)v18 setUniqueIdentifier:v21];
    [(PDCandidateRelevantPass *)v18 setPassTypeIdentifier:v13];
    [(PDCandidateRelevantPass *)v18 setSerialNumber:v12];
    [(PDCandidateRelevantPass *)v18 setManifestHash:v11];
    [(PDCandidateRelevantPass *)v18 setStyle:v14];
    [(PDCandidateRelevantPass *)v18 setOrganizationName:v17];
    [(PDCandidateRelevantPass *)v18 setGroupingIdentifier:v16];
    id v19 = +[PassRelevancyDates relevancyDatesForPassPID:a2 inDatabase:*(void *)(a1 + 32)];
    [(PDCandidateRelevantPass *)v18 setRelevantDates:v19];

    id v20 = +[Beacon beaconsInDatabase:*(void *)(a1 + 32) forPassPID:a2];
    [(PDCandidateRelevantPass *)v18 setEmbeddedBeacons:v20];

    [(PDCandidateRelevantPass *)v18 setHasLocations:+[Location hasLocationsInDatabase:*(void *)(a1 + 32) forPassPID:a2]];
    [*(id *)(a1 + 40) addObject:v18];
  }
}

id sub_1000DEF40(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[SQLiteEntity applyPropertySetters:*(void *)(a1 + 32) toObject:*(void *)(a1 + 40) withProperties:a2 values:a3];
}

id sub_1000DF0C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[SQLiteEntity applyPropertySetters:*(void *)(a1 + 32) toObject:*(void *)(a1 + 40) withProperties:a2 values:a3];
}

id sub_1000DF83C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[SQLiteEntity applyPropertySetters:*(void *)(a1 + 32) toObject:*(void *)(a1 + 40) withProperties:a2 values:a3];
}

void sub_1000DF9E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000DFA14(uint64_t a1, void *a2, uint64_t a3)
{
  id v8 = a2;
  id v5 = *(id *)a3;
  if (*(void *)a3) {
    id v5 = [v5 integerValue];
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
  id v6 = *(void **)(a3 + 8);
  if (v6)
  {
    [v6 doubleValue];
    id v7 = +[NSDate dateWithTimeIntervalSinceReferenceDate:](NSDate, "dateWithTimeIntervalSinceReferenceDate:");
  }
  else
  {
    id v7 = 0;
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v7);
  if (v6) {
}
  }

void sub_1000DFC58(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v7 = objc_alloc_init(PDPassUpdateContext);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v7 withProperties:v6 values:a4];

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t sub_1000DFE08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000DFF20(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  id v8 = [Pass alloc];
  uint64_t v9 = [*(id *)(a1 + 32) database];
  uint64_t v11 = [(SQLiteEntity *)v8 initWithPersistentID:a2 inDatabase:v9];

  uint64_t v10 = objc_alloc_init(PDPassGroupingProfile);
  [*(id *)(a1 + 56) applyPropertySetters:*(void *)(a1 + 40) toObject:v10 withProperties:v7 values:a4];

  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

uint64_t sub_1000E0124(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *a3;
  id v8 = [(id)a3[1] unsignedIntegerValue];
  uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, id, uint64_t))(v6 + 16);
  return v9(v6, v7, v8, a5);
}

void sub_1000E02B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = *(void **)(a3 + 8);
  id v6 = *(id *)a3;
  [v5 unsignedIntegerValue];
  [*(id *)(a3 + 16) integerValue];
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000E21E0(id a1, PDPassUpdateContext *a2, id a3)
{
}

void sub_1000E21E8(id a1, PDPassUpdateContext *a2, id a3)
{
}

void sub_1000E21F0(id a1, PDPassUpdateContext *a2, id a3)
{
}

void sub_1000E21F8(id a1, PDPassUpdateContext *a2, id a3)
{
}

void sub_1000E2200(id a1, PDPassUpdateContext *a2, id a3)
{
  uint64_t v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PDPassUpdateContext *)v3 setLastModifiedDate:v4];
}

void sub_1000E2260(id a1, PDPassUpdateContext *a2, id a3)
{
  id v4 = a2;
  -[PDPassUpdateContext setLastModifiedSource:](v4, "setLastModifiedSource:", [a3 integerValue]);
}

void sub_1000E22B8(id a1, PDPassUpdateContext *a2, id a3)
{
}

void sub_1000E22C0(id a1, PDPassGroupingProfile *a2, id a3)
{
}

void sub_1000E22C8(id a1, PDPassGroupingProfile *a2, id a3)
{
}

void sub_1000E22D0(id a1, PDPassGroupingProfile *a2, id a3)
{
  id v4 = a2;
  -[PDPassGroupingProfile setPassStyle:](v4, "setPassStyle:", [a3 integerValue]);
}

void sub_1000E2328(id a1, PDPassGroupingProfile *a2, id a3)
{
  uint64_t v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PDPassGroupingProfile *)v3 setIngestedDate:v4];
}

void sub_1000E2388(id a1, PDPassGroupingProfile *a2, id a3)
{
  [(PDPassGroupingProfile *)a2 setNFCEnabled:a3 != 0];
}

void sub_1000E25B8(uint64_t a1)
{
  atomic_store(0, (unsigned __int8 *)(*(void *)(a1 + 40) + 25));
  id v2 = *(NSObject **)(*(void *)(a1 + 40) + 40);
  if (v2)
  {
    dispatch_source_cancel(v2);
    uint64_t v3 = *(void *)(a1 + 40);
    id v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = 0;
  }
  uint64_t v177 = a1;
  id v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "PDFinanceSyncManager started syncing", (uint8_t *)&buf, 2u);
  }
  unsigned int oslog = v5;

  id v6 = objc_alloc_init(off_100805630());
  id v175 = v6;
  if (v6)
  {
    id v257 = 0;
    uint64_t v7 = [v6 fetchAppleAccountsWithError:&v257];
    id v8 = v257;
    if (v8)
    {
      uint64_t v9 = v8;
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v9;
        _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Error fetching apple accounts: %@", (uint8_t *)&buf, 0xCu);
      }
    }
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v277 = 0x3032000000;
    v278 = sub_10002085C;
    v279 = sub_100020F20;
    id v280 = 0;
    uint64_t v251 = 0;
    v252 = &v251;
    uint64_t v253 = 0x3032000000;
    v254 = sub_10002085C;
    v255 = sub_100020F20;
    id v256 = 0;
    uint64_t v245 = 0;
    v246 = &v245;
    uint64_t v247 = 0x3032000000;
    v248 = sub_10002085C;
    v249 = sub_100020F20;
    id v250 = 0;
    uint64_t v239 = 0;
    v240 = &v239;
    uint64_t v241 = 0x3032000000;
    v242 = sub_10002085C;
    v243 = sub_100020F20;
    id v244 = 0;
    uint64_t v10 = *(void *)(v177 + 40);
    uint64_t v11 = *(void **)(v10 + 8);
    v233[0] = _NSConcreteStackBlock;
    v233[1] = 3221225472;
    v233[2] = sub_1000E4150;
    v233[3] = &unk_100735D58;
    v233[4] = v10;
    p_long long buf = &buf;
    __int16 v236 = &v251;
    BOOL v237 = &v245;
    id v171 = v7;
    id v234 = v171;
    __int16 v238 = &v239;
    [v11 accessDatabaseUsingBlock:v233];
    uint64_t v12 = +[NSMutableArray array];
    long long v232 = 0u;
    long long v231 = 0u;
    long long v230 = 0u;
    long long v229 = 0u;
    id v13 = *(id *)(*((void *)&buf + 1) + 40);
    id v14 = [v13 countByEnumeratingWithState:&v229 objects:v275 count:16];
    if (v14)
    {
      uint64_t v15 = *(void *)v230;
      do
      {
        for (uint64_t i = 0; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v230 != v15) {
            objc_enumerationMutation(v13);
          }
          uint64_t v17 = *(void *)(*((void *)&v229 + 1) + 8 * i);
          if ([*(id *)(v177 + 40) _canSyncAccountToFinanceKit:v17])
          {
            uint32_t v18 = [*(id *)(v177 + 40) _fkAppleAccountFromAccount:v17];
            [v12 addObject:v18];
          }
        }
        id v14 = [v13 countByEnumeratingWithState:&v229 objects:v275 count:16];
      }
      while (v14);
    }

    if (v252[5] && objc_msgSend(*(id *)(v177 + 40), "_canSyncPeerPaymentAccountToFinanceKit:"))
    {
      id v19 = [*(id *)(v177 + 40) _fkAppleAccountFromPeerPaymentAccount:v252[5]];
      [v12 addObject:v19];
    }
    id v162 = objc_alloc_init((Class)NSMutableArray);
    long long v228 = 0u;
    long long v227 = 0u;
    long long v226 = 0u;
    long long v225 = 0u;
    id obj = v12;
    id v20 = [obj countByEnumeratingWithState:&v225 objects:v274 count:16];
    id v21 = 0;
    if (v20)
    {
      uint64_t v22 = *(void *)v226;
      do
      {
        for (uint64_t j = 0; j != v20; uint64_t j = (char *)j + 1)
        {
          if (*(void *)v226 != v22) {
            objc_enumerationMutation(obj);
          }
          uint64_t v24 = *(void **)(*((void *)&v225 + 1) + 8 * (void)j);
          int v224 = v21;
          unsigned __int8 v25 = [v175 insertOrUpdateAccount:v24 error:&v224];
          id v26 = v224;

          if (v25)
          {
            id v21 = v26;
          }
          else
          {
            long long v27 = [v24 accountIdentifier];
            [v162 addObject:v27];

            if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v265 = 138412546;
              id v266 = v24;
              __int16 v267 = 2112;
              v268 = (char *)v26;
              _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Error inserting account: %@ into finance: %@", v265, 0x16u);
            }

            id v21 = 0;
          }
        }
        id v20 = [obj countByEnumeratingWithState:&v225 objects:v274 count:16];
      }
      while (v20);
    }
    id v173 = v21;

    long long v222 = 0u;
    long long v223 = 0u;
    long long v220 = 0u;
    long long v221 = 0u;
    id v169 = v171;
    id v28 = [v169 countByEnumeratingWithState:&v220 objects:v273 count:16];
    if (v28)
    {
      uint64_t v29 = *(void *)v221;
      do
      {
        for (k = 0; k != v28; k = (char *)k + 1)
        {
          if (*(void *)v221 != v29) {
            objc_enumerationMutation(v169);
          }
          id v31 = *(void **)(*((void *)&v220 + 1) + 8 * (void)k);
          uint64_t v32 = [v31 fullyQualifiedAccountIdentifier];
          id v33 = [v32 accountID];

          id v34 = *(void **)(*((void *)&buf + 1) + 40);
          v218[0] = _NSConcreteStackBlock;
          v218[1] = 3221225472;
          v218[2] = sub_1000E46E4;
          v218[3] = &unk_1007344A0;
          id v35 = v33;
          id v219 = v35;
          unsigned int v36 = objc_msgSend(v34, "pk_containsObjectPassingTest:", v218);
          id v37 = [(id)v252[5] identifier];
          id v38 = v35;
          BOOL v39 = v38;
          if (v37 == v38)
          {
            unsigned int v41 = 1;
          }
          else
          {
            if (v38) {
              BOOL v40 = v37 == 0;
            }
            else {
              BOOL v40 = 1;
            }
            if (v40) {
              unsigned int v41 = 0;
            }
            else {
              unsigned int v41 = [v37 isEqualToString:v38];
            }
          }

          if (((v36 | v41) & 1) == 0)
          {
            if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v265 = 138412290;
              id v266 = v39;
              _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Deleting account: %@ from Finance, because it is not in Wallet or doesn't have a related pass", v265, 0xCu);
            }

            uint64_t v42 = [v31 fullyQualifiedAccountIdentifier];
            id v43 = [v42 accountID];
            uint64_t v217 = v173;
            unsigned __int8 v44 = [v175 deleteAppleAccountWithIdentifier:v43 error:&v217];
            uint64_t v45 = v217;

            if (v44)
            {
              id v173 = v45;
            }
            else
            {
              if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v265 = 138412546;
                id v266 = v31;
                __int16 v267 = 2112;
                v268 = (char *)v45;
                _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Error deleting account: %@ from finance: %@", v265, 0x16u);
              }

              id v173 = 0;
            }
          }
        }
        id v28 = [v169 countByEnumeratingWithState:&v220 objects:v273 count:16];
      }
      while (v28);
    }

    id v46 = objc_alloc_init((Class)NSMutableDictionary);
    id v172 = objc_alloc_init((Class)NSMutableDictionary);
    long long v215 = 0u;
    long long v216 = 0u;
    long long v213 = 0u;
    long long v214 = 0u;
    id v47 = (id)v246[5];
    id v48 = [v47 countByEnumeratingWithState:&v213 objects:v272 count:16];
    if (v48)
    {
      uint64_t v49 = *(void *)v214;
      do
      {
        for (m = 0; m != v48; m = (char *)m + 1)
        {
          if (*(void *)v214 != v49) {
            objc_enumerationMutation(v47);
          }
          uint64_t v51 = *(void *)(*((void *)&v213 + 1) + 8 * (void)m);
          id v52 = [(id)v246[5] objectForKeyedSubscript:v51];
          id v53 = [v52 accountIdentifier];
          uint64_t v54 = [v46 getOrCreateObjectForKey:v53 creationBlock:&stru_100735D98];
          id v55 = [v52 transactionIdentifier];
          [v54 addObject:v55];

          long long v56 = [v172 getOrCreateObjectForKey:v53 creationBlock:&stru_100735DB8];
          [v56 addObject:v51];
        }
        id v48 = [v47 countByEnumeratingWithState:&v213 objects:v272 count:16];
      }
      while (v48);
    }

    id v157 = +[NSMutableArray array];
    long long v211 = 0u;
    long long v212 = 0u;
    long long v209 = 0u;
    long long v210 = 0u;
    id v170 = v46;
    long long v57 = v173;
    id v58 = [v170 countByEnumeratingWithState:&v209 objects:v271 count:16];
    if (v58)
    {
      uint64_t v59 = *(void *)v210;
      do
      {
        long long v60 = 0;
        long long v61 = v57;
        do
        {
          if (*(void *)v210 != v59) {
            objc_enumerationMutation(v170);
          }
          long long v62 = *(char **)(*((void *)&v209 + 1) + 8 * (void)v60);
          long long v63 = [v170 objectForKeyedSubscript:v62];
          long long v64 = [v172 objectForKeyedSubscript:v62];
          v208 = v61;
          unsigned int v65 = [v175 deleteTransactionsWithIdentifiers:v63 forAssociatedAppleAccountWithIdentifier:v62 error:&v208];
          long long v57 = v208;

          if (v65)
          {
            long long v66 = [v64 allObjects];
            [v157 addObjectsFromArray:v66];
          }
          else
          {
            if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v265 = 138412802;
              id v266 = v63;
              __int16 v267 = 2112;
              v268 = v62;
              __int16 v269 = 2112;
              v270 = v57;
              _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Error deleting transactions with identifiers: %@, account identifier: %@, from finance: %@", v265, 0x20u);
            }

            long long v66 = v57;
            long long v57 = 0;
          }

          long long v60 = (char *)v60 + 1;
          long long v61 = v57;
        }
        while (v58 != v60);
        id v58 = [v170 countByEnumeratingWithState:&v209 objects:v271 count:16];
      }
      while (v58);
    }
    id v174 = v57;

    if ([v157 count]) {
      [*(id *)(*(void *)(v177 + 40) + 8) deletePaymentTransactionsToDeleteFromFinanceWithPIDs:v157];
    }
    id v166 = objc_alloc_init((Class)NSMutableDictionary);
    id v165 = objc_alloc_init((Class)NSMutableDictionary);
    long long v206 = 0u;
    long long v207 = 0u;
    long long v204 = 0u;
    long long v205 = 0u;
    id v67 = (id)v240[5];
    id v68 = [v67 countByEnumeratingWithState:&v204 objects:v264 count:16];
    if (v68)
    {
      uint64_t v69 = *(void *)v205;
      do
      {
        for (n = 0; n != v68; n = (char *)n + 1)
        {
          if (*(void *)v205 != v69) {
            objc_enumerationMutation(v67);
          }
          uint64_t v71 = *(void *)(*((void *)&v204 + 1) + 8 * (void)n);
          uint64_t v72 = [(id)v240[5] objectForKeyedSubscript:v71];
          if ([*(id *)(v177 + 40) _canSyncTransactionToFinanceKit:v72])
          {
            uint64_t v73 = [v72 accountIdentifier];
            id v74 = [v166 getOrCreateObjectForKey:v73 creationBlock:&stru_100735DD8];
            [v74 setObject:v72 forKeyedSubscript:v71];
            __int16 v75 = [v165 getOrCreateObjectForKey:v73 creationBlock:&stru_100735DF8];
            long long v76 = [v72 fkPaymentTransaction];
            [v75 setObject:v76 forKeyedSubscript:v71];
          }
        }
        id v68 = [v67 countByEnumeratingWithState:&v204 objects:v264 count:16];
      }
      while (v68);
    }

    long long v202 = 0u;
    long long v203 = 0u;
    long long v200 = 0u;
    long long v201 = 0u;
    id v158 = v162;
    id v77 = [v158 countByEnumeratingWithState:&v200 objects:v263 count:16];
    long long v78 = oslog;
    if (v77)
    {
      uint64_t v79 = *(void *)v201;
      do
      {
        for (iuint64_t i = 0; ii != v77; iuint64_t i = (char *)ii + 1)
        {
          if (*(void *)v201 != v79) {
            objc_enumerationMutation(v158);
          }
          long long v81 = *(void **)(*((void *)&v200 + 1) + 8 * (void)ii);
          v199[0] = _NSConcreteStackBlock;
          v199[1] = 3221225472;
          v199[2] = sub_1000E4828;
          v199[3] = &unk_100735D30;
          v199[4] = v81;
          unsigned int v82 = [v169 pk_containsObjectPassingTest:v199];
          BOOL v83 = os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT);
          if (v82)
          {
            if (v83)
            {
              long long v84 = [v166 objectForKeyedSubscript:v81];
              id v85 = (char *)[v84 count];
              *(_DWORD *)v265 = 138412546;
              id v266 = v81;
              __int16 v267 = 2048;
              v268 = v85;
              _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "Account %@ couldn't be updated, but it is inserted into Finance, will insert %zu related transactions", v265, 0x16u);

              long long v78 = oslog;
            }

            long long v78 = oslog;
          }
          else
          {
            if (v83)
            {
              id v86 = [v166 objectForKeyedSubscript:v81];
              long long v87 = (char *)[v86 count];
              *(_DWORD *)v265 = 138412546;
              id v266 = v81;
              __int16 v267 = 2048;
              v268 = v87;
              _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "Account %@ is not in Finance, and couldn't be inserted, won't insert %zu related transactions", v265, 0x16u);

              long long v78 = oslog;
            }

            [v166 removeObjectForKey:v81];
            long long v78 = oslog;
            [v165 removeObjectForKey:v81];
          }
        }
        id v77 = [v158 countByEnumeratingWithState:&v200 objects:v263 count:16];
      }
      while (v77);
    }

    long long v197 = 0u;
    long long v198 = 0u;
    long long v195 = 0u;
    long long v196 = 0u;
    id v155 = v166;
    id v88 = [v155 countByEnumeratingWithState:&v195 objects:v262 count:16];
    long long v90 = oslog;
    if (v88)
    {
      char v152 = 0;
      uint64_t v153 = *(void *)v196;
      id v154 = v88;
      *(void *)&long long v89 = 138412802;
      long long v151 = v89;
      do
      {
        for (juint64_t j = 0; jj != v154; juint64_t j = (char *)jj + 1)
        {
          if (*(void *)v196 != v153) {
            objc_enumerationMutation(v155);
          }
          long long v91 = *(char **)(*((void *)&v195 + 1) + 8 * (void)jj);
          id v160 = objc_msgSend(v155, "objectForKeyedSubscript:", v91, v151);
          v167 = [v165 objectForKeyedSubscript:v91];
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v92 = [v167 allValues];
            id v93 = [v92 count];
            *(_DWORD *)v265 = 134218242;
            id v266 = v93;
            __int16 v267 = 2112;
            v268 = v91;
            _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "Inserting %zu transactions for account %@", v265, 0x16u);

            long long v90 = oslog;
          }

          long long v94 = [v167 allValues];
          long long v194 = v174;
          unsigned int v95 = [v175 insertOrUpdateTransactions:v94 forAppleAccountWithID:v91 error:&v194];
          long long v156 = v194;

          if (v95)
          {
            id v96 = objc_alloc_init((Class)NSMutableDictionary);
            long long v192 = 0u;
            long long v193 = 0u;
            long long v190 = 0u;
            long long v191 = 0u;
            id v97 = v160;
            id v98 = [v97 countByEnumeratingWithState:&v190 objects:v261 count:16];
            if (v98)
            {
              uint64_t v99 = *(void *)v191;
              do
              {
                for (kk = 0; kk != v98; kk = (char *)kk + 1)
                {
                  if (*(void *)v191 != v99) {
                    objc_enumerationMutation(v97);
                  }
                  uint64_t v101 = *(void *)(*((void *)&v190 + 1) + 8 * (void)kk);
                  uint64_t v102 = [v97 objectForKeyedSubscript:v101];
                  uint64_t v103 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v102 updateSequenceNumber]);
                  [v96 setObject:v103 forKeyedSubscript:v101];
                }
                id v98 = [v97 countByEnumeratingWithState:&v190 objects:v261 count:16];
              }
              while (v98);
            }

            [*(id *)(*(void *)(v177 + 40) + 8) resetNeedsSyncWithFinanceForTransactions:v96];
            uint64_t v104 = *(void **)(*(void *)(v177 + 40) + 32);
            id v105 = [v97 allKeys];
            [v104 removeObjectsForKeys:v105];
            char v152 = 1;
            id v174 = v156;
          }
          else
          {
            id v106 = oslog;
            if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
            {
              id v107 = [v167 allKeys];
              *(_DWORD *)v265 = v151;
              id v266 = v107;
              __int16 v267 = 2112;
              v268 = v91;
              __int16 v269 = 2112;
              v270 = v156;
              _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Error inserting transactions with identifiers: %@, accountIdentifier: %@, into finance: %@", v265, 0x20u);

              id v106 = oslog;
            }

            long long v188 = 0u;
            long long v189 = 0u;
            long long v186 = 0u;
            long long v187 = 0u;
            id v105 = v160;
            id v108 = [v105 countByEnumeratingWithState:&v186 objects:v260 count:16];
            if (v108)
            {
              uint64_t v109 = *(void *)v187;
              do
              {
                for (mm = 0; mm != v108; mm = (char *)mm + 1)
                {
                  if (*(void *)v187 != v109) {
                    objc_enumerationMutation(v105);
                  }
                  uint64_t v111 = *(void *)(*((void *)&v186 + 1) + 8 * (void)mm);
                  uint64_t v112 = [*(id *)(*(void *)(v177 + 40) + 32) objectForKeyedSubscript:v111];
                  v113 = (void *)v112;
                  if (v112) {
                    id v114 = (_UNKNOWN **)v112;
                  }
                  else {
                    id v114 = &off_10078AB00;
                  }
                  uint64_t v115 = v114;

                  v116 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", (char *)[v115 integerValue] + 1);
                  [*(id *)(*(void *)(v177 + 40) + 32) setObject:v116 forKeyedSubscript:v111];
                }
                id v108 = [v105 countByEnumeratingWithState:&v186 objects:v260 count:16];
              }
              while (v108);
            }
            id v174 = 0;
            id v96 = v156;
          }

          long long v90 = oslog;
        }
        id v154 = [v155 countByEnumeratingWithState:&v195 objects:v262 count:16];
      }
      while (v154);
    }
    else
    {
      char v152 = 0;
    }

    id v161 = objc_alloc_init((Class)NSMutableDictionary);
    uint64_t v117 = v177;
    long long v184 = 0u;
    long long v185 = 0u;
    long long v182 = 0u;
    long long v183 = 0u;
    id v118 = [*(id *)(*(void *)(v177 + 40) + 32) allKeys];
    id v119 = [v118 countByEnumeratingWithState:&v182 objects:v259 count:16];
    if (v119)
    {
      uint64_t v164 = *(void *)v183;
      do
      {
        id v120 = v119;
        for (nn = 0; nn != v120; nn = (char *)nn + 1)
        {
          if (*(void *)v183 != v164) {
            objc_enumerationMutation(v118);
          }
          uint64_t v122 = *(void *)(*((void *)&v182 + 1) + 8 * (void)nn);
          id v123 = [*(id *)(*(void *)(v117 + 40) + 32) objectForKeyedSubscript:v122];
          if ((uint64_t)[v123 integerValue] >= 8)
          {
            v124 = [(id)v240[5] objectForKeyedSubscript:v122];
            if (v124
              && ([*(id *)(*(void *)(v177 + 40) + 32) removeObjectForKey:v122],
                  +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v124 updateSequenceNumber]), uint64_t v125 = objc_claimAutoreleasedReturnValue(), objc_msgSend(v161, "setObject:forKeyedSubscript:", v125, v122), v125, objc_msgSend(*(id *)(v177 + 40), "_canSyncTransactionToFinanceKit:", v124)))
            {
              if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
              {
                id v126 = [v124 identifier];
                long long v127 = [v124 accountIdentifier];
                *(_DWORD *)v265 = 138412546;
                id v266 = v126;
                __int16 v267 = 2112;
                v268 = v127;
                _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Attempting for the last time to import transaction with identifier %@ of account %@", v265, 0x16u);
              }
              uint64_t v128 = [v124 fkPaymentTransaction];
              v258 = v128;
              long long v129 = +[NSArray arrayWithObjects:&v258 count:1];
              long long v130 = [v124 accountIdentifier];
              uint64_t v181 = v174;
              unsigned __int8 v131 = [v175 insertOrUpdateTransactions:v129 forAppleAccountWithID:v130 error:&v181];
              v168 = v181;

              BOOL v132 = os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT);
              if (v131)
              {
                if (v132)
                {
                  id v133 = [v124 identifier];
                  *(_DWORD *)v265 = 138412290;
                  id v266 = v133;
                  _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "The last time attempt to import transaction with identifier %@ succeeded", v265, 0xCu);
                }
                long long v134 = oslog;
              }
              else
              {
                if (v132)
                {
                  long long v135 = [(id)v240[5] objectForKeyedSubscript:v122];
                  id v136 = [v135 identifier];
                  os_signpost_id_t v137 = (char *)[v123 integerValue];
                  *(_DWORD *)v265 = 138412546;
                  id v266 = v136;
                  __int16 v267 = 2048;
                  v268 = v137 + 1;
                  _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "Unfortunately transaction with identifier: %@ couldn't be successfully synced after %ld tries, it is now marked as synced", v265, 0x16u);
                }
                long long v134 = v168;
                v168 = 0;
              }
            }
            else
            {
              v168 = v174;
            }

            id v174 = v168;
          }

          uint64_t v117 = v177;
        }
        id v119 = [v118 countByEnumeratingWithState:&v182 objects:v259 count:16];
      }
      while (v119);
    }

    v138 = oslog;
    uint64_t v139 = v177;
    if ([v161 count]) {
      [*(id *)(*(void *)(v177 + 40) + 8) resetNeedsSyncWithFinanceForTransactions:v161];
    }
    if ([*(id *)(*(void *)(v177 + 40) + 32) count])
    {
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v265 = 0;
        id v140 = "Will sync again, because there are erroneous transactions to try syncing again";
LABEL_168:
        _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, v140, v265, 2u);
      }
    }
    else
    {
      if ((([(id)v240[5] count] == (id)300) & v152) == 0
        && [(id)v246[5] count] != (id)300)
      {
        goto LABEL_170;
      }
      if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v265 = 0;
        id v140 = "Will sync again, because there may be more transactions to sync";
        goto LABEL_168;
      }
    }

    v138 = oslog;
    uint64_t v139 = v177;
    atomic_store(1u, (unsigned __int8 *)(*(void *)(v177 + 40) + 25));
LABEL_170:
    id v141 = [*(id *)(*(void *)(v139 + 40) + 32) count];
    uint64_t v142 = *(void *)(v139 + 40);
    int v143 = 15;
    if (v141)
    {
      int v144 = *(_DWORD *)(v142 + 48);
      if (v144 <= 3) {
        int v143 = 1 << v144;
      }
      else {
        int v143 = 15;
      }
      int v145 = v144 + 1;
    }
    else
    {
      int v145 = 0;
    }
    *(_DWORD *)(v142 + 4_Block_object_dispose(&STACK[0x420], 8) = v145;
    if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v265 = 67109120;
      LODWORD(v266) = v143;
      _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, "Scheduling syncIfNeeded in %d seconds", v265, 8u);
    }

    dispatch_source_t v146 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(*(void *)(v177 + 40) + 16));
    long long v147 = *(void **)(*(void *)(v177 + 40) + 40);
    *(void *)(*(void *)(v177 + 40) + 40) = v146;

    long long v148 = *(NSObject **)(*(void *)(v177 + 40) + 40);
    dispatch_time_t v149 = dispatch_time(0, 1000000000 * v143);
    dispatch_source_set_timer(v148, v149, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    objc_initWeak((id *)v265, *(id *)(v177 + 40));
    long long v150 = *(NSObject **)(*(void *)(v177 + 40) + 40);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_1000E48BC;
    handler[3] = &unk_100735E20;
    objc_copyWeak(&v180, (id *)v265);
    dispatch_source_set_event_handler(v150, handler);
    dispatch_resume(*(dispatch_object_t *)(*(void *)(v177 + 40) + 40));
    if (os_log_type_enabled(oslog, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v178 = 0;
      _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_DEFAULT, "PDFinanceSyncManager finished syncing", v178, 2u);
    }

    objc_destroyWeak(&v180);
    objc_destroyWeak((id *)v265);

    _Block_object_dispose(&v239, 8);
    _Block_object_dispose(&v245, 8);

    _Block_object_dispose(&v251, 8);
    _Block_object_dispose(&buf, 8);

    id v5 = v169;
    goto LABEL_181;
  }
  atomic_store(0, (unsigned __int8 *)(*(void *)(v177 + 40) + 24));
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Couldn't initialize FKWalletExposedDB. Bailing out.", (uint8_t *)&buf, 2u);
  }
  id v174 = 0;
LABEL_181:
}

void sub_1000E3FF0(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x4F0], 8);
  _Block_object_dispose(&STACK[0x520], 8);
  _Block_object_dispose(&STACK[0x550], 8);
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1000E4150(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableArray);
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 8) accounts];
  id v4 = [v3 countByEnumeratingWithState:&v53 objects:v63 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v54;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v54 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v53 + 1) + 8 * i);
        uint64_t v9 = [v8 associatedPassUniqueID];
        if (v9 && ![*(id *)(*(void *)(a1 + 32) + 8) passExistsWithUniqueID:v9])
        {
          uint64_t v10 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v11 = [v8 accountIdentifier];
            [v8 type];
            uint64_t v12 = PKAccountTypeToString();
            *(_DWORD *)long long buf = 138412546;
            long long v60 = v11;
            __int16 v61 = 2112;
            long long v62 = v12;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Ignoring account: %@ (%@)", buf, 0x16u);
          }
        }
        else
        {
          [v2 addObject:v8];
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v53 objects:v63 count:16];
    }
    while (v5);
  }

  id v43 = v2;
  id v13 = [v2 copy];
  uint64_t v14 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v15 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = v13;

  uint64_t v16 = [*(id *)(*(void *)(a1 + 32) + 8) peerPaymentAccount];
  uint64_t v17 = *(void *)(*(void *)(a1 + 56) + 8);
  uint32_t v18 = *(void **)(v17 + 40);
  *(void *)(v17 + 40) = v16;

  uint64_t v19 = [*(id *)(*(void *)(a1 + 32) + 8) paymentTransactionsToDeleteFromFinanceWithLimit:300];
  uint64_t v20 = *(void *)(*(void *)(a1 + 64) + 8);
  id v21 = *(void **)(v20 + 40);
  *(void *)(v20 + 40) = v19;

  id v22 = objc_alloc_init((Class)NSMutableArray);
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  id v23 = *(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  id v24 = [v23 countByEnumeratingWithState:&v49 objects:v58 count:16];
  if (v24)
  {
    id v25 = v24;
    uint64_t v26 = *(void *)v50;
    do
    {
      for (uint64_t j = 0; j != v25; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v50 != v26) {
          objc_enumerationMutation(v23);
        }
        id v28 = *(void **)(*((void *)&v49 + 1) + 8 * (void)j);
        if ([*(id *)(a1 + 32) _canSyncAccountToFinanceKit:v28])
        {
          uint64_t v29 = [v28 accountIdentifier];
          [v22 addObject:v29];
        }
      }
      id v25 = [v23 countByEnumeratingWithState:&v49 objects:v58 count:16];
    }
    while (v25);
  }

  if ([*(id *)(a1 + 32) _canSyncPeerPaymentAccountToFinanceKit:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)])
  {
    long long v30 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) identifier];
    [v22 addObject:v30];
  }
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  id v31 = v22;
  id v32 = [v31 countByEnumeratingWithState:&v45 objects:v57 count:16];
  if (v32)
  {
    id v33 = v32;
    uint64_t v34 = *(void *)v46;
    do
    {
      for (k = 0; k != v33; k = (char *)k + 1)
      {
        if (*(void *)v46 != v34) {
          objc_enumerationMutation(v31);
        }
        unsigned int v36 = *(void **)(*((void *)&v45 + 1) + 8 * (void)k);
        id v37 = *(void **)(a1 + 40);
        v44[0] = _NSConcreteStackBlock;
        v44[1] = 3221225472;
        v44[2] = sub_1000E4650;
        v44[3] = &unk_100735D30;
        void v44[4] = v36;
        unsigned __int8 v38 = objc_msgSend(v37, "pk_containsObjectPassingTest:", v44);
        if (*(void *)(a1 + 40) && (v38 & 1) == 0)
        {
          BOOL v39 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            long long v60 = v36;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Setting needs_sync_to_finance = 1 for transactions of account: %@ because it is in Wallet and not in Finance", buf, 0xCu);
          }

          [*(id *)(*(void *)(a1 + 32) + 8) setNeedsSyncWithFinanceForTransactionsWithAccountIdentifier:v36];
        }
      }
      id v33 = [v31 countByEnumeratingWithState:&v45 objects:v57 count:16];
    }
    while (v33);
  }

  uint64_t v40 = [*(id *)(*(void *)(a1 + 32) + 8) transactionsThatNeedSyncToFinanceWithAccountIdentifiers:v31 withLimit:300];
  uint64_t v41 = *(void *)(*(void *)(a1 + 72) + 8);
  uint64_t v42 = *(void **)(v41 + 40);
  *(void *)(v41 + 40) = v40;
}

uint64_t sub_1000E4650(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 fullyQualifiedAccountIdentifier];
  id v4 = [v3 accountID];
  id v5 = *(void **)(a1 + 32);
  id v6 = v4;
  id v7 = v5;
  id v8 = v7;
  if (v6 == v7)
  {
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
    if (v6 && v7) {
      uint64_t v9 = (uint64_t)[v6 isEqualToString:v7];
    }
  }

  return v9;
}

uint64_t sub_1000E46E4(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 accountIdentifier];
  id v4 = *(void **)(a1 + 32);
  id v5 = v3;
  id v6 = v4;
  id v7 = v6;
  if (v5 == v6)
  {
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    if (v5 && v6) {
      uint64_t v8 = (uint64_t)[v5 isEqualToString:v6];
    }
  }

  return v8;
}

id sub_1000E4768(id a1)
{
  id v1 = objc_alloc_init((Class)NSMutableSet);
  return v1;
}

id sub_1000E4798(id a1)
{
  id v1 = objc_alloc_init((Class)NSMutableSet);
  return v1;
}

id sub_1000E47C8(id a1)
{
  id v1 = objc_alloc_init((Class)NSMutableDictionary);
  return v1;
}

id sub_1000E47F8(id a1)
{
  id v1 = objc_alloc_init((Class)NSMutableDictionary);
  return v1;
}

uint64_t sub_1000E4828(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 fullyQualifiedAccountIdentifier];
  id v4 = [v3 accountID];
  id v5 = *(void **)(a1 + 32);
  id v6 = v4;
  id v7 = v5;
  uint64_t v8 = v7;
  if (v6 == v7)
  {
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
    if (v6 && v7) {
      uint64_t v9 = (uint64_t)[v6 isEqualToString:v7];
    }
  }

  return v9;
}

void sub_1000E48BC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained retryTimerFired];
}

Class sub_1000E57E0()
{
  if (qword_100808B90 != -1) {
    dispatch_once(&qword_100808B90, &stru_100735E40);
  }
  Class result = objc_getClass("FKWalletExposedDB");
  qword_100808B80 = (uint64_t)result;
  off_100805630 = (uint64_t (*)())sub_1000E5844;
  return result;
}

id sub_1000E5844()
{
  return (id)qword_100808B80;
}

void sub_1000E5850(id a1)
{
  qword_100808B88 = (uint64_t)dlopen("/System/Library/Frameworks/FinanceKit.framework/FinanceKit", 2);
}

Class sub_1000E587C()
{
  if (qword_100808B90 != -1) {
    dispatch_once(&qword_100808B90, &stru_100735E40);
  }
  Class result = objc_getClass("FKAppleAccount");
  qword_100808B98 = (uint64_t)result;
  off_100805638 = (uint64_t (*)())sub_1000E58E0;
  return result;
}

id sub_1000E58E0()
{
  return (id)qword_100808B98;
}

void sub_1000E65A8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v7 = objc_alloc_init((Class)PKPassCredentialShare);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v7 withProperties:v6 values:a4];

  [*(id *)(a1 + 40) safelyAddObject:v7];
}

void sub_1000E672C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_1000E6A84(id a1, PKPassCredentialShare *a2, id a3)
{
}

void sub_1000E6A8C(id a1, PKPassCredentialShare *a2, id a3)
{
}

void sub_1000E6A94(id a1, PKPassCredentialShare *a2, id a3)
{
  uint64_t v3 = a2;
  [(PKPassCredentialShare *)v3 setTargetDevice:PKPassCredentialShareTargetDeviceFromString()];
}

void sub_1000E6AEC(id a1, PKPassCredentialShare *a2, id a3)
{
  uint64_t v3 = a2;
  [(PKPassCredentialShare *)v3 setStatus:PKShareStatusFromString()];
}

void sub_1000E6FF4(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v7 = objc_alloc_init((Class)PKAccountPromotionCompletionStep);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v7 withProperties:v6 values:a4];

  [*(id *)(a1 + 40) addObject:v7];
}

void sub_1000E76FC(id a1, PKAccountPromotionCompletionStep *a2, id a3)
{
  id v4 = a2;
  -[PKAccountPromotionCompletionStep setIndex:](v4, "setIndex:", [a3 integerValue]);
}

void sub_1000E7754(id a1, PKAccountPromotionCompletionStep *a2, id a3)
{
  id v4 = a2;
  -[PKAccountPromotionCompletionStep setProgressType:](v4, "setProgressType:", [a3 integerValue]);
}

void sub_1000E77AC(id a1, PKAccountPromotionCompletionStep *a2, id a3)
{
}

void sub_1000E77B4(id a1, PKAccountPromotionCompletionStep *a2, id a3)
{
  uint64_t v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKAccountPromotionCompletionStep *)v3 setEndValue:v4];
}

void sub_1000E7818(id a1, PKAccountPromotionCompletionStep *a2, id a3)
{
  uint64_t v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKAccountPromotionCompletionStep *)v3 setCurrentValue:v4];
}

void sub_1000E787C(id a1, PKAccountPromotionCompletionStep *a2, id a3)
{
  id v4 = a2;
  -[PKAccountPromotionCompletionStep setCompleted:](v4, "setCompleted:", [a3 BOOLValue]);
}

void sub_1000E79CC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

id PKPaymentPassBalanceLabelDictionary(void *a1)
{
  id v1 = [a1 balanceFields];
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  id obj = v1;
  id v3 = [obj countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v17 = *(void *)v23;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v23 != v17) {
          objc_enumerationMutation(obj);
        }
        id v6 = *(void **)(*((void *)&v22 + 1) + 8 * i);
        id v7 = [v6 foreignReferenceIdentifiers];
        long long v18 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v21 = 0u;
        id v8 = [v7 countByEnumeratingWithState:&v18 objects:v26 count:16];
        if (v8)
        {
          id v9 = v8;
          uint64_t v10 = *(void *)v19;
          do
          {
            for (uint64_t j = 0; j != v9; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v19 != v10) {
                objc_enumerationMutation(v7);
              }
              uint64_t v12 = *(void *)(*((void *)&v18 + 1) + 8 * (void)j);
              id v13 = [v6 label];
              [v2 setObject:v13 forKeyedSubscript:v12];
            }
            id v9 = [v7 countByEnumeratingWithState:&v18 objects:v26 count:16];
          }
          while (v9);
        }
      }
      id v4 = [obj countByEnumeratingWithState:&v22 objects:v27 count:16];
    }
    while (v4);
  }

  id v14 = [v2 copy];
  return v14;
}

id PKPaymentPassPlanLabelDictionary(void *a1)
{
  id v1 = [a1 transitCommutePlans];
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  id obj = v1;
  id v19 = [obj countByEnumeratingWithState:&v25 objects:v30 count:16];
  if (v19)
  {
    uint64_t v18 = *(void *)v26;
    do
    {
      for (uint64_t i = 0; i != v19; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v26 != v18) {
          objc_enumerationMutation(obj);
        }
        id v4 = *(void **)(*((void *)&v25 + 1) + 8 * i);
        uint64_t v5 = [v4 identifier];
        id v6 = [v4 titleText];
        long long v20 = (void *)v5;
        [v2 setObject:v6 forKeyedSubscript:v5];

        id v7 = [v4 foreignReferenceIdentifiers];
        long long v21 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        id v8 = [v7 allObjects];
        id v9 = [v8 countByEnumeratingWithState:&v21 objects:v29 count:16];
        if (v9)
        {
          id v10 = v9;
          uint64_t v11 = *(void *)v22;
          do
          {
            for (uint64_t j = 0; j != v10; uint64_t j = (char *)j + 1)
            {
              if (*(void *)v22 != v11) {
                objc_enumerationMutation(v8);
              }
              uint64_t v13 = *(void *)(*((void *)&v21 + 1) + 8 * (void)j);
              id v14 = [v4 titleText];
              [v2 setObject:v14 forKeyedSubscript:v13];
            }
            id v10 = [v8 countByEnumeratingWithState:&v21 objects:v29 count:16];
          }
          while (v10);
        }
      }
      id v19 = [obj countByEnumeratingWithState:&v25 objects:v30 count:16];
    }
    while (v19);
  }

  id v15 = [v2 copy];
  return v15;
}

id PKPaymentPassUnitDictionary(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v17 = v1;
  id v3 = [v1 transitCommutePlans];
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v18 objects:v24 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v19;
    uint64_t v7 = PKTransitCommutePlanGenericCountPlanAmountRemainingKey;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v19 != v6) {
          objc_enumerationMutation(v3);
        }
        id v9 = *(void **)(*((void *)&v18 + 1) + 8 * i);
        if (([v9 properties] & 4) != 0)
        {
          id v10 = [v9 passFieldForKey:v7];
          uint64_t v11 = [v10 foreignReferenceIdentifiers];
          if ([v11 count] == (id)1)
          {
            uint64_t v12 = [v11 anyObject];
            id v13 = [v10 unitType];
            if (v13 != (id)-1)
            {
              id v14 = +[NSNumber numberWithInteger:v13];
              [v2 setObject:v14 forKeyedSubscript:v12];
            }
          }
          else
          {
            uint64_t v12 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138543362;
              long long v23 = v11;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Commute plans cannot have multiple identifiers. Identifiers: %{public}@", buf, 0xCu);
            }
          }
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v18 objects:v24 count:16];
    }
    while (v5);
  }
  id v15 = [v2 copy];

  return v15;
}

void sub_1000E87F8(uint64_t a1)
{
  id v2 = objc_alloc_init(PDTransitStateFetchRequest);
  [(PDTransitStateFetchRequest *)v2 setPassUniqueIdentifier:*(void *)(a1 + 40)];
  [(PDTransitStateFetchRequest *)v2 setSecureElementIdentifier:*(void *)(a1 + 48)];
  [(PDTransitStateFetchRequest *)v2 setPaymentApplicationIdentifier:*(void *)(a1 + 56)];
  [*(id *)(a1 + 64) _queueTransitStateFetchRequest:v2];
}

void sub_1000E8A4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000E8A78(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = WeakRetained[6];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1000E8B3C;
    v7[3] = &unk_10072E198;
    id v8 = WeakRetained;
    id v9 = v3;
    dispatch_sync(v6, v7);
  }
}

void sub_1000E8B3C(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 56) = 0;
  uint64_t v3 = a1 + 32;
  id v2 = *(id **)(a1 + 32);
  if (*(void *)(v3 + 8))
  {
    _objc_msgSend(v2, "_handleTransitRequestsWithSession:");
  }
  else
  {
    id v4 = [v2[8] copy];
    [*(id *)(*(void *)(a1 + 32) + 64) removeAllObjects];
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed to update transit applet states for:", buf, 2u);
    }

    long long v16 = 0u;
    long long v17 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    id v6 = v4;
    id v7 = [v6 countByEnumeratingWithState:&v14 objects:v22 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v15;
      do
      {
        for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v15 != v9) {
            objc_enumerationMutation(v6);
          }
          uint64_t v11 = *(void **)(*((void *)&v14 + 1) + 8 * i);
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = [v11 passUniqueIdentifier];
            id v13 = [v11 paymentApplicationIdentifier];
            *(_DWORD *)long long buf = 138412546;
            long long v19 = v12;
            __int16 v20 = 2112;
            long long v21 = v13;
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "\t%@: %@", buf, 0x16u);
          }
        }
        id v8 = [v6 countByEnumeratingWithState:&v14 objects:v22 count:16];
      }
      while (v8);
    }
  }
}

void sub_1000E9370(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2
    || (LOBYTE(v6) = 0,
        [*(id *)(a1 + 48) _ingestAppletStateHistory:v2 withTransactionDate:*(void *)(a1 + 56) forceTransactionGeneration:1 recoverMissingTransactions:0 forPaymentApplication:*(void *)(a1 + 64) withPassUniqueIdentifier:*(void *)(a1 + 72) skipQueuedRequestSanitization:v6 expressTransactionState:*(void *)(a1 + 80)], (uint64_t v3 = *(void **)(a1 + 40)) == 0)|| objc_msgSend(v3, "isBlacklisted"))
  {
    id v7 = objc_alloc_init(PDTransitStateFetchRequest);
    [(PDTransitStateFetchRequest *)v7 setPassUniqueIdentifier:*(void *)(a1 + 72)];
    id v4 = [*(id *)(a1 + 64) secureElementIdentifier];
    [(PDTransitStateFetchRequest *)v7 setSecureElementIdentifier:v4];

    id v5 = [*(id *)(a1 + 64) applicationIdentifier];
    [(PDTransitStateFetchRequest *)v7 setPaymentApplicationIdentifier:v5];

    if (!*(void *)(a1 + 40))
    {
      [(PDTransitStateFetchRequest *)v7 setForceTransactionGeneration:1];
      [(PDTransitStateFetchRequest *)v7 setTransactionDate:*(void *)(a1 + 56)];
      [(PDTransitStateFetchRequest *)v7 setExpressState:*(void *)(a1 + 80)];
    }
    [*(id *)(a1 + 48) _queueTransitStateFetchRequest:v7];
  }
}

void sub_1000E95C4(uint64_t a1)
{
  LOBYTE(v4) = 0;
  [*(id *)(a1 + 40) _ingestAppletStateHistory:*(void *)(a1 + 48) withTransactionDate:*(void *)(a1 + 56) forceTransactionGeneration:0 recoverMissingTransactions:0 forPaymentApplication:*(void *)(a1 + 64) withPassUniqueIdentifier:*(void *)(a1 + 72) skipQueuedRequestSanitization:v4 expressTransactionState:0];
  if ([*(id *)(a1 + 48) isBlacklisted])
  {
    id v5 = objc_alloc_init(PDTransitStateFetchRequest);
    [(PDTransitStateFetchRequest *)v5 setPassUniqueIdentifier:*(void *)(a1 + 72)];
    uint64_t v2 = [*(id *)(a1 + 64) secureElementIdentifier];
    [(PDTransitStateFetchRequest *)v5 setSecureElementIdentifier:v2];

    uint64_t v3 = [*(id *)(a1 + 64) applicationIdentifier];
    [(PDTransitStateFetchRequest *)v5 setPaymentApplicationIdentifier:v3];

    [(PDTransitStateFetchRequest *)v5 setTransactionDate:*(void *)(a1 + 56)];
    [*(id *)(a1 + 40) _queueTransitStateFetchRequest:v5];
  }
}

id sub_1000E9A98(void *a1, void *a2)
{
  id result = [a2 appletStateDirty];
  if (result)
  {
    uint64_t v4 = (void *)a1[4];
    uint64_t v5 = a1[5];
    uint64_t v6 = a1[6];
    return _[v4 _notifyIssuerAppletStateDirtyWithPassID:v5 forPaymentApplication:v6];
  }
  return result;
}

void sub_1000E9AE8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if ([v6 needsStationProcessing]) {
    [*(id *)(a1 + 32) _resolveStationCodesForAppletState:v6 paymentApplication:*(void *)(a1 + 40) passUniqueIdentifier:*(void *)(a1 + 48)];
  }
  id v7 = PDDefaultQueue();
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000E9BD4;
  block[3] = &unk_10072E238;
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = *(void **)(a1 + 40);
  id v12 = v5;
  uint64_t v13 = v8;
  id v14 = v9;
  id v10 = v5;
  dispatch_async(v7, block);
}

void sub_1000E9BD4(uint64_t a1)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v11;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v10 + 1) + 8 * (void)v6);
        uint64_t v8 = *(void **)(*(void *)(a1 + 40) + 32);
        uint64_t v9 = objc_msgSend(*(id *)(a1 + 48), "transactionSourceIdentifier", (void)v10);
        [v8 processPaymentTransaction:v7 forTransactionSourceIdentifier:v9];

        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v4);
  }
}

id sub_1000E9CF8(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) isEqual:a2];
}

void sub_1000E9DF4(void *a1)
{
  id v2 = [*(id *)(a1[4] + 8) transitStateWithPassUniqueIdentifier:a1[5] paymentApplication:a1[6]];
  (*(void (**)(void))(a1[7] + 16))();
}

void sub_1000EA24C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    id v6 = v3;
    char v5 = PKEqualObjects();
    id v4 = v6;
    if ((v5 & 1) == 0)
    {
      [*(id *)(a1 + 40) addObject:v6];
      id v4 = v6;
    }
  }
}

void sub_1000EA2B8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = v6;
  if (v6 && objc_msgSend(v6, "_mapkit_underlyingGEOError") != (id)-8)
  {
    uint64_t v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      long long v19 = *(void **)(a1 + 56);
      int v20 = 138412546;
      long long v21 = v7;
      __int16 v22 = 2112;
      id v23 = v19;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "An Error Occurred While Performing Stations Update (%@): %@", (uint8_t *)&v20, 0x16u);
    }
  }
  else
  {
    uint64_t v8 = [v5 mapItems];
    id v9 = [v8 count];
    long long v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      long long v11 = *(void **)(a1 + 64);
      long long v12 = [*(id *)(a1 + 32) applicationIdentifier];
      int v20 = 134218498;
      long long v21 = v11;
      __int16 v22 = 2048;
      id v23 = v9;
      __int16 v24 = 2112;
      long long v25 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Stations Update Response: (%lu, %lu), Application: %@", (uint8_t *)&v20, 0x20u);
    }
    id v13 = objc_alloc_init((Class)NSMutableDictionary);
    if ([v8 count])
    {
      unint64_t v14 = 0;
      do
      {
        long long v15 = [v8 objectAtIndexedSubscript:v14];
        long long v16 = [v15 _externalTransitStationCode];
        long long v17 = [v15 name];
        long long v18 = v17;
        if (v16 && [v17 length]) {
          [v13 setObject:v18 forKeyedSubscript:v16];
        }

        ++v14;
      }
      while (v14 < (unint64_t)[v8 count]);
    }
    [*(id *)(*(void *)(a1 + 40) + 8) updateTransitAppletStateWithStationNames:v13 forPaymentApplication:*(void *)(a1 + 32) withPassUniqueIdentifier:*(void *)(a1 + 48)];
  }
}

void sub_1000EA6C0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 48);
  id v4 = *(void **)(v2 + 8);
  id v5 = [*(id *)(v2 + 24) secureElementIdentifiers];
  id v6 = [v4 passWithPaymentApplicationIdentifier:v3 secureElementIdentifiers:v5];
  uint64_t v7 = [v6 paymentPass];

  if (v7)
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    uint64_t v8 = objc_msgSend(v7, "devicePaymentApplications", 0);
    id v9 = [v8 countByEnumeratingWithState:&v21 objects:v27 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v22;
      while (2)
      {
        for (uint64_t i = 0; i != v9; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v22 != v10) {
            objc_enumerationMutation(v8);
          }
          long long v12 = *(void **)(*((void *)&v21 + 1) + 8 * i);
          id v13 = [v12 applicationIdentifier];
          int v14 = PKEqualObjects();

          if (v14)
          {
            id v9 = v12;
            goto LABEL_12;
          }
        }
        id v9 = [v8 countByEnumeratingWithState:&v21 objects:v27 count:16];
        if (v9) {
          continue;
        }
        break;
      }
    }
LABEL_12:

    if ([v9 supportsTransit])
    {
      long long v15 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 138412290;
        uint64_t v26 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "PDTransitStateManager: %@ posseses applet data. Updating...", buf, 0xCu);
      }

      long long v17 = *(void **)(a1 + 40);
      long long v18 = [v7 uniqueID];
      long long v19 = [v9 secureElementIdentifier];
      int v20 = [v9 applicationIdentifier];
      [v17 fetchAndCacheTransitStateForPassUniqueIdentifier:v18 secureElementIdentifier:v19 paymentApplicationIdentifier:v20];
    }
  }
}

void sub_1000EA9A0(int8x16_t *a1, void *a2)
{
  id v3 = a2;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1000EAB00;
  void v11[3] = &unk_10072FC48;
  id v4 = objc_alloc_init((Class)NSMutableSet);
  id v12 = v4;
  [v3 enumerateObjectsUsingBlock:v11];

  if ([v4 count])
  {
    id v5 = [*(id *)(a1[2].i64[1] + 8) passesOfType:1];
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_1000EAB58;
    v8[3] = &unk_100736100;
    id v9 = v4;
    int8x16_t v7 = a1[2];
    id v6 = (id)v7.i64[0];
    int8x16_t v10 = vextq_s8(v7, v7, 8uLL);
    [v5 enumerateObjectsUsingBlock:v8];
  }
}

void sub_1000EAB00(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [a2 passUniqueIdentifier];
  [v2 addObject:v3];
}

void sub_1000EAB58(uint64_t a1, void *a2)
{
  id v3 = [a2 paymentPass];
  id v4 = [v3 uniqueID];
  id v5 = [v3 devicePrimaryPaymentApplication];
  unsigned int v6 = [*(id *)(a1 + 32) containsObject:v4];
  if ([v5 isParsedTransitApplication]) {
    char v7 = 0;
  }
  else {
    char v7 = [v5 supportsSuica] ^ 1;
  }
  unsigned int v8 = [v3 isTransitPass];
  if (v4 && v8 && ((v6 ^ 1) & 1) == 0 && (v7 & 1) == 0)
  {
    id v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      long long v19 = v4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Recovering missed transactions for express transit pass with unique identifier: %@", buf, 0xCu);
    }

    int8x16_t v10 = *(NSObject **)(*(void *)(a1 + 40) + 48);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_1000EAD24;
    v13[3] = &unk_100730198;
    id v14 = *(id *)(a1 + 48);
    id v15 = v4;
    id v11 = v5;
    uint64_t v12 = *(void *)(a1 + 40);
    id v16 = v11;
    uint64_t v17 = v12;
    dispatch_async(v10, v13);
  }
}

void sub_1000EAD24(uint64_t a1)
{
  id v4 = objc_alloc_init(PDTransitStateFetchRequest);
  [(PDTransitStateFetchRequest *)v4 setPassUniqueIdentifier:*(void *)(a1 + 40)];
  uint64_t v2 = [*(id *)(a1 + 48) secureElementIdentifier];
  [(PDTransitStateFetchRequest *)v4 setSecureElementIdentifier:v2];

  id v3 = [*(id *)(a1 + 48) applicationIdentifier];
  [(PDTransitStateFetchRequest *)v4 setPaymentApplicationIdentifier:v3];

  [(PDTransitStateFetchRequest *)v4 setRecoverMissingTransactions:1];
  [*(id *)(a1 + 56) _queueTransitStateFetchRequest:v4];
}

void sub_1000EAEE8(uint64_t a1)
{
  id v21 = objc_alloc_init((Class)NSMutableArray);
  id v22 = [*(id *)(a1 + 40) mutableCopy];
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  id v2 = *(id *)(a1 + 48);
  id v3 = [v2 countByEnumeratingWithState:&v30 objects:v35 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v31;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v31 != v5) {
          objc_enumerationMutation(v2);
        }
        char v7 = *(void **)(*((void *)&v30 + 1) + 8 * i);
        [v7 state];
        if (PKPaymentApplicationStateIsPersonalized()
          && [v7 supportsTransit])
        {
          unsigned int v8 = [v7 applicationIdentifier];
          id v9 = [v7 secureElementIdentifier];
          v27[0] = _NSConcreteStackBlock;
          v27[1] = 3221225472;
          id v27[2] = sub_1000EB1F0;
          v27[3] = &unk_100736128;
          id v10 = v8;
          id v28 = v10;
          id v11 = v9;
          id v29 = v11;
          uint64_t v12 = [v22 objectsPassingTest:v27];
          [v22 minusSet:v12];
          id v13 = [v12 anyObject];
          id v14 = v13;
          if (!v13 || ([v13 state], !PKPaymentApplicationStateIsPersonalized()))
          {
            id v15 = objc_alloc_init(PDTransitStateFetchRequest);
            [(PDTransitStateFetchRequest *)v15 setPassUniqueIdentifier:*(void *)(a1 + 56)];
            [(PDTransitStateFetchRequest *)v15 setSecureElementIdentifier:v11];
            [(PDTransitStateFetchRequest *)v15 setPaymentApplicationIdentifier:v10];
            [v21 addObject:v15];
          }
        }
      }
      id v4 = [v2 countByEnumeratingWithState:&v30 objects:v35 count:16];
    }
    while (v4);
  }

  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id v16 = v21;
  id v17 = [v16 countByEnumeratingWithState:&v23 objects:v34 count:16];
  if (v17)
  {
    id v18 = v17;
    uint64_t v19 = *(void *)v24;
    do
    {
      for (uint64_t j = 0; j != v18; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v24 != v19) {
          objc_enumerationMutation(v16);
        }
        [*(id *)(a1 + 64) _queueTransitStateFetchRequest:*(void *)(*((void *)&v23 + 1) + 8 * (void)j)];
      }
      id v18 = [v16 countByEnumeratingWithState:&v23 objects:v34 count:16];
    }
    while (v18);
  }
}

uint64_t sub_1000EB1F0(uint64_t a1, void *a2, unsigned char *a3)
{
  id v5 = a2;
  unsigned int v6 = [v5 applicationIdentifier];
  if (([v6 isEqualToString:*(void *)(a1 + 32)] & 1) == 0)
  {

    goto LABEL_5;
  }
  char v7 = [v5 secureElementIdentifier];
  unsigned int v8 = [v7 isEqualToString:*(void *)(a1 + 40)];

  if (!v8)
  {
LABEL_5:
    uint64_t v9 = 0;
    goto LABEL_6;
  }
  uint64_t v9 = 1;
  *a3 = 1;
LABEL_6:

  return v9;
}

void sub_1000EB3C8(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 40) + 8) passWithUniqueIdentifier:*(void *)(a1 + 48)];
  if ([v2 passType] != (id)1 || (objc_msgSend(v2, "isTransitPass") & 1) == 0)
  {

    id v2 = 0;
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  objc_msgSend(v2, "devicePaymentApplications", 0);
  id v3 = (PDTransitStateFetchRequest *)objc_claimAutoreleasedReturnValue();
  id v4 = [(PDTransitStateFetchRequest *)v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v12;
LABEL_6:
    uint64_t v6 = 0;
    while (1)
    {
      if (*(void *)v12 != v5) {
        objc_enumerationMutation(v3);
      }
      char v7 = *(void **)(*((void *)&v11 + 1) + 8 * v6);
      unsigned int v8 = [v7 applicationIdentifier];
      char v9 = PKEqualObjects();

      if (v9) {
        break;
      }
      if (v4 == (id)++v6)
      {
        id v4 = [(PDTransitStateFetchRequest *)v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
        if (v4) {
          goto LABEL_6;
        }
        goto LABEL_16;
      }
    }
    id v4 = v7;

    if (v2 && v4)
    {
      id v3 = objc_alloc_init(PDTransitStateFetchRequest);
      [(PDTransitStateFetchRequest *)v3 setPassUniqueIdentifier:*(void *)(a1 + 48)];
      id v10 = [v4 secureElementIdentifier];
      [(PDTransitStateFetchRequest *)v3 setSecureElementIdentifier:v10];

      [(PDTransitStateFetchRequest *)v3 setPaymentApplicationIdentifier:*(void *)(a1 + 56)];
      [(PDTransitStateFetchRequest *)v3 setForceTransactionGeneration:1];
      [(PDTransitStateFetchRequest *)v3 setExpressState:*(void *)(a1 + 64)];
      [*(id *)(a1 + 40) _queueTransitStateFetchRequest:v3];
      goto LABEL_16;
    }
  }
  else
  {
LABEL_16:
  }
}

void sub_1000EBC60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000EBC7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_1000EBD50;
  v5[3] = &unk_100736150;
  objc_copyWeak(&v7, (id *)(a1 + 48));
  id v6 = *(id *)(a1 + 40);
  [v3 notifyIssuerAppletStateDirtyWithRequest:v4 completion:v5];

  objc_destroyWeak(&v7);
}

void sub_1000EBD3C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000EBD50(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    os_unfair_lock_lock((os_unfair_lock_t)WeakRetained + 20);
    if (a2 && ([*((id *)WeakRetained + 9) containsObject:*(void *)(a1 + 32)] & 1) == 0) {
      [*((id *)WeakRetained + 1) deleteDirtyAppletStatesForTransitAppletStateDirty:*(void *)(a1 + 32)];
    }
    *((unsigned char *)WeakRetained + 84) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)WeakRetained + 20);
    [WeakRetained _performWebRequestToNotifyIssuerAppletDirtyIfNecessary];
  }
}

Class sub_1000EBEC4()
{
  if (qword_100808BB0 != -1) {
    dispatch_once(&qword_100808BB0, &stru_100736198);
  }
  Class result = objc_getClass("_MKLocalSearchExternalTransitLookupParameters");
  qword_100808BA0 = (uint64_t)result;
  off_100805640 = (uint64_t (*)())sub_1000EBF28;
  return result;
}

id sub_1000EBF28()
{
  return (id)qword_100808BA0;
}

void sub_1000EBF34(id a1)
{
  qword_100808BA8 = (uint64_t)dlopen("/System/Library/Frameworks/MapKit.framework/MapKit", 2);
}

Class sub_1000EBF60()
{
  if (qword_100808BB0 != -1) {
    dispatch_once(&qword_100808BB0, &stru_100736198);
  }
  Class result = objc_getClass("MKLocalSearchRequest");
  qword_100808BB8 = (uint64_t)result;
  off_100805648 = (uint64_t (*)())sub_1000EBFC4;
  return result;
}

id sub_1000EBFC4()
{
  return (id)qword_100808BB8;
}

Class sub_1000EBFD0()
{
  if (qword_100808BB0 != -1) {
    dispatch_once(&qword_100808BB0, &stru_100736198);
  }
  Class result = objc_getClass("MKLocalSearch");
  qword_100808BC0 = (uint64_t)result;
  off_100805650 = (uint64_t (*)())sub_1000EC034;
  return result;
}

id sub_1000EC034()
{
  return (id)qword_100808BC0;
}

uint64_t sub_1000EC07C(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  id v10 = *a4;
  id v6 = +[NSNull null];
  id v7 = v10;
  if (v10 != v6)
  {
    unsigned int v8 = v6;
    id v11 = *a4;

    uint64_t result = (uint64_t)v11;
    if (!v11) {
      return result;
    }
    id v6 = [*(id *)(a1 + 32) addObject:v11];
    id v7 = v11;
  }
  return _objc_release_x1(v6, v7);
}

uint64_t sub_1000EC67C(uint64_t a1)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000EC73C;
  v4[3] = &unk_1007361C0;
  uint64_t v8 = *(void *)(a1 + 64);
  id v2 = *(void **)(a1 + 32);
  id v5 = *(id *)(a1 + 40);
  id v6 = *(id *)(a1 + 48);
  id v7 = *(id *)(a1 + 56);
  [v2 enumerateObjectsUsingBlock:v4];

  return 1;
}

void sub_1000EC73C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = *(objc_class **)(a1 + 56);
  id v6 = a2;
  id v8 = [[v5 alloc] initWithTransitNetworkIdentifier:v6 networkOrder:a3 forPaymentApplication:*(void *)(a1 + 32) database:*(void *)(a1 + 40)];

  id v7 = v8;
  if (v8)
  {
    [*(id *)(a1 + 48) addObject:v8];
    id v7 = v8;
  }
}

void sub_1000ECD40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000ECD58(uint64_t a1)
{
  id v2 = [objc_alloc(*(Class *)(a1 + 64)) initWithMetadata:*(void *)(a1 + 32) forBaseMetadata:*(void *)(a1 + 40) inDatabase:*(void *)(a1 + 48)];
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) != 0;
}

id sub_1000ECF28(uint64_t a1, uint64_t a2, uint64_t a3, id *a4, uint64_t a5, unsigned char *a6)
{
  objc_msgSend(*(id *)(a1 + 32), "setRows:", objc_msgSend(*a4, "unsignedIntegerValue"));
  [*(id *)(a1 + 32) setWidthClass:PKPassTileWidthClassVerticalFlowFromString()];
  id result = [*(id *)(a1 + 32) setHeightClass:PKPassTileHeightClassFromString()];
  *a6 = 1;
  return result;
}

void sub_1000ED734(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_1000ED940(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v8 = objc_alloc_init((Class)PKPayLaterAccountFeatureDescriptor);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v8 withProperties:v6 values:a4];

  id v7 = v8;
  if (v8)
  {
    objc_msgSend(*(id *)(a1 + 40), "addObject:");
    id v7 = v8;
  }
}

void sub_1000EDC64(id a1, PKPayLaterAccountFeatureDescriptor *a2, id a3)
{
}

void sub_1000EDC6C(id a1, PKPayLaterAccountFeatureDescriptor *a2, id a3)
{
  uint64_t v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKPayLaterAccountFeatureDescriptor *)v3 setMinimumAmount:v4];
}

void sub_1000EDCD0(id a1, PKPayLaterAccountFeatureDescriptor *a2, id a3)
{
  uint64_t v3 = a2;
  PKCurrencyStorageNumberToCurrencyDecimal();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  [(PKPayLaterAccountFeatureDescriptor *)v3 setMaximumAmount:v4];
}

void sub_1000EDD34(id a1, PKPayLaterAccountFeatureDescriptor *a2, id a3)
{
  id v4 = a2;
  id v5 = [a3 componentsSeparatedByString:@","];
  [(PKPayLaterAccountFeatureDescriptor *)v4 setSupportedNetworks:v5];
}

void sub_1000EDDA0(id a1, PKPayLaterAccountFeatureDescriptor *a2, id a3)
{
}

void sub_1000EDDA8(id a1, PKPayLaterAccountFeatureDescriptor *a2, id a3)
{
  id v4 = a2;
  -[PKPayLaterAccountFeatureDescriptor setMerchantCapabilities:](v4, "setMerchantCapabilities:", [a3 unsignedIntegerValue]);
}

void sub_1000EE2B8(void *a1)
{
  id v6 = +[PKSharingRelayChannelDescriptor existingChannelForURL:a1[4]];
  id v2 = objc_msgSend(*(id *)(a1[5] + 136), "handleForDescriptor:queue:");
  uint64_t v3 = v2;
  uint64_t v4 = a1[6];
  if (v2)
  {
    [v2 pingWithCompletion:v4];
  }
  else
  {
    id v5 = PDBasicError();
    (*(void (**)(uint64_t, void, void *))(v4 + 16))(v4, 0, v5);
  }
}

void sub_1000EE470(uint64_t a1)
{
  id v5 = +[PKSharingRelayChannelDescriptor existingChannelForURL:*(void *)(a1 + 32)];
  id v2 = objc_msgSend(*(id *)(*(void *)(a1 + 40) + 136), "handleForDescriptor:queue:");
  if (v2)
  {
    sub_1000EE530(*(id **)(a1 + 40), v2, *(void **)(a1 + 48));
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v4 = PDBasicError();
    (*(void (**)(uint64_t, void, void *))(v3 + 16))(v3, 0, v4);
  }
}

void sub_1000EE530(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = [v5 transportIdentifier];
    if ([v5 wasChannelCreatedLocally])
    {
      id v8 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDSharingManager: endpoint is local, not allowing it to be accepted!", buf, 2u);
      }

      char v9 = +[NSError pkSharingError:11];
      v6[2](v6, 0, v9);
    }
    else
    {
      id v10 = [a1[3] passShareForTransportIdentifier:v7];
      char v9 = v10;
      if (v10 && ([v10 status], (PKShareStatusIsWaitingOnUserAction() & 1) == 0))
      {
        long long v24 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "PDSharingManager: existing share found for endpoint!", buf, 2u);
        }

        id v11 = +[NSError pkSharingError:10];
        v6[2](v6, 0, v11);
      }
      else
      {
        id v11 = [a1[2] sharedWebService];
        long long v12 = [v11 context];
        long long v13 = [v12 configuration];
        [v13 sharingMessageCacheTimeToLiveInterval];
        double v15 = v14;

        id v16 = [objc_alloc((Class)NSDate) initWithTimeIntervalSinceNow:-v15];
        id v17 = [a1[3] sharingMessagesForTransportIdentifier:v7 newerThanDate:v16];
        id v18 = [v17 firstObject];

        if (v18
          && ([v18 displayInformation], (uint64_t v19 = objc_claimAutoreleasedReturnValue()) != 0)
          && (v20 = (void *)v19, id v21 = [v18 type], v20, v21 == (id)1))
        {
          id v22 = sub_1000EE8E8(a1, v18);
          if (v22)
          {
            id v23 = v5;
            [a1 retrieveShareInvitationForMailboxAddress:v22 completion:v6];
            [v23 relinquishWithCompletion:&stru_100736360];
          }
          else
          {
            long long v25 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138477827;
              long long v31 = v18;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Returning cached message: %{private}@", buf, 0xCu);
            }

            ((void (**)(id, void *, void *))v6)[2](v6, v18, 0);
          }
        }
        else
        {
          v26[0] = _NSConcreteStackBlock;
          v26[1] = 3221225472;
          v26[2] = sub_1000EEA38;
          v26[3] = &unk_100736340;
          id v29 = v6;
          id v27 = v5;
          id v28 = a1;
          [v27 attachWithCompletion:v26];

          id v22 = v29;
        }
      }
    }
  }
}

id sub_1000EE8E8(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    if (PKIsWatch())
    {
      uint64_t v4 = 1;
    }
    else if (PKIsPhone())
    {
      uint64_t v4 = 0;
    }
    else
    {
      id v5 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Warning, tried to find embedded mailbox address on unsupported device!", v7, 2u);
      }

      uint64_t v4 = 0x7FFFFFFFFFFFFFFFLL;
    }
    a1 = sub_1000EEE94((uint64_t)a1, v4, v3);
  }

  return a1;
}

void sub_1000EE9BC(void *a1, uint64_t a2, void *a3, uint64_t a4)
{
  if (a1)
  {
    id v7 = a3;
    [a1 retrieveShareInvitationForMailboxAddress:a2 completion:a4];
    [v7 relinquishWithCompletion:&stru_100736360];
  }
}

void sub_1000EEA38(uint64_t a1, char a2, uint64_t a3)
{
  if (a3 || (a2 & 1) == 0)
  {
    id v6 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
    v6();
  }
  else
  {
    uint64_t v4 = *(void **)(a1 + 32);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_1000EEB24;
    v8[3] = &unk_100736318;
    id v10 = *(id *)(a1 + 48);
    int8x16_t v7 = *(int8x16_t *)(a1 + 32);
    id v5 = (id)v7.i64[0];
    int8x16_t v9 = vextq_s8(v7, v7, 8uLL);
    [v4 handleOutstandingMessage:v8];
  }
}

void sub_1000EEB24(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    int8x16_t v7 = sub_1000EECE0(*(void **)(a1 + 32), v5);
    if (v7)
    {
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
    else
    {
      id v8 = sub_1000EE8E8(*(void **)(a1 + 32), v5);
      int8x16_t v9 = *(void **)(a1 + 32);
      if (v8)
      {
        sub_1000EE9BC(v9, (uint64_t)v8, *(void **)(a1 + 40), *(void *)(a1 + 48));
      }
      else
      {
        id v10 = sub_1000EEE94((uint64_t)v9, 1, v5);
        if (v10 && PKIsPhone())
        {
          uint64_t v11 = *(void *)(a1 + 32);
          v15[0] = _NSConcreteStackBlock;
          v15[1] = 3221225472;
          void v15[2] = sub_1000EEFD8;
          v15[3] = &unk_1007362F0;
          void v15[4] = v11;
          id v16 = v10;
          sub_1000EEFF0(v11, 1, v15);
        }
        id v12 = objc_alloc_init((Class)PKMAEntitlementTemplateManager);
        [v12 entitlementTemplates:0];
        v6[2](v6, 0);
        (*(void (**)(void, id, void, uint64_t, uint64_t))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), v5, 0, v13, v14);
      }
    }
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

id sub_1000EECE0(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ([v3 type] == (id)1)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0
        || ([v4 metadatas],
            id v5 = objc_claimAutoreleasedReturnValue(),
            id v6 = [v5 count],
            v5,
            v6))
      {
        a1 = 0;
        goto LABEL_10;
      }
      uint64_t v11 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = 138477827;
        uint64_t v13 = v4;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Retreived push provisioning message does not support provisioning on an Apple device. Message: %{private}@", (uint8_t *)&v12, 0xCu);
      }

      CFStringRef v8 = @"invite missing apple metadata";
      uint64_t v9 = 8;
    }
    else
    {
      int8x16_t v7 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = 138477827;
        uint64_t v13 = v4;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Retreived message was not of type invitation. Message: %{private}@", (uint8_t *)&v12, 0xCu);
      }

      CFStringRef v8 = @"message is not invitation";
      uint64_t v9 = 6;
    }
    a1 = +[NSError pkSharingError:v9 debugDescription:v8];
  }
LABEL_10:

  return a1;
}

id sub_1000EEE94(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    uint64_t v4 = [a3 embeddedMessageURLs];
    id v5 = +[NSNumber numberWithInteger:a2];
    id v6 = [v4 objectForKeyedSubscript:v5];
    int8x16_t v7 = [v6 absoluteString];

    if (v7)
    {
      CFStringRef v8 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = PKPassCredentialShareTargetDeviceToString();
        int v11 = 138412290;
        int v12 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Found embedded message url for device '%@', following.", (uint8_t *)&v11, 0xCu);
      }
    }
  }
  else
  {
    int8x16_t v7 = 0;
  }
  return v7;
}

id *sub_1000EEFD8(id *result, uint64_t a2)
{
  if (a2 == 2) {
    return (id *)[result[4] rejectShareForMailboxAddress:result[5]];
  }
  return result;
}

void sub_1000EEFF0(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    id v6 = [*(id *)(a1 + 16) sharedWebService];
    int8x16_t v7 = [v6 targetDevice];
    CFStringRef v8 = [v7 appleAccountInformation];

    if (v8)
    {
      switch(a2)
      {
        case 0:
          CFStringRef v10 = @"iOS";
          goto LABEL_14;
        case 4:
LABEL_12:
          CFStringRef v10 = @"watchOS";
LABEL_14:
          id v11 = objc_alloc_init((Class)AKDeviceListRequestContext);
          int v12 = [v8 aaAlternateDSID];
          [v11 setAltDSID:v12];

          uint64_t v13 = PKLogFacilityTypeGetObject();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v14 = [v8 aaAlternateDSID];
            *(_DWORD *)long long buf = 138412290;
            long long v24 = v14;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Cleanup: aaAlternateDSID: %@", buf, 0xCu);
          }
          [v11 setIncludeUntrustedDevices:1];
          uint64_t v22 = AKServiceNameiCloud;
          double v15 = +[NSArray arrayWithObjects:&v22 count:1];
          [v11 setServices:v15];

          CFStringRef v21 = v10;
          id v16 = +[NSArray arrayWithObjects:&v21 count:1];
          [v11 setOperatingSystems:v16];

          v18[0] = _NSConcreteStackBlock;
          v18[1] = 3221225472;
          v18[2] = sub_1000FCBB4;
          v18[3] = &unk_100736E78;
          id v19 = objc_alloc_init((Class)AKAppleIDAuthenticationController);
          id v20 = v5;
          id v17 = v19;
          [v17 fetchDeviceListWithContext:v11 completion:v18];

          goto LABEL_17;
        case 1:
          if (PKIsPairedWithWatch())
          {
            uint64_t v9 = PKLogFacilityTypeGetObject();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Cleanup: found paired watch", buf, 2u);
            }

            (*((void (**)(id, uint64_t))v5 + 2))(v5, 1);
            goto LABEL_17;
          }
          goto LABEL_12;
      }
    }
    (*((void (**)(id, void))v5 + 2))(v5, 0);
LABEL_17:
  }
}

void sub_1000EF39C(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 24) transportIdentifierForSharingMessage:*(void *)(a1 + 40)];
  id v3 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:v2];
  uint64_t v4 = [*(id *)(*(void *)(a1 + 32) + 136) handleForDescriptor:v3 queue:*(void *)(*(void *)(a1 + 32) + 88)];
  if (v4)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    id v6[2] = sub_1000EF4EC;
    v6[3] = &unk_10072E570;
    id v7 = *(id *)(a1 + 48);
    [v4 relinquishWithCompletion:v6];
  }
  else
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error: unable to relinquish invitation, can't find endpoint for message", buf, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_1000EF4EC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (v4)
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412290;
      id v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error: Unable to relinquish invitation, %@", (uint8_t *)&v6, 0xCu);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000EF6BC(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 24) transportIdentifierForSharingMessage:*(void *)(a1 + 40)];
  id v3 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:v2];
  id v4 = [*(id *)(*(void *)(a1 + 32) + 136) handleForDescriptor:v3 queue:*(void *)(*(void *)(a1 + 32) + 88)];
  id v5 = PKLogFacilityTypeGetObject();
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      id v7 = PKSharingLoggableMailboxAddress();
      int v8 = 138412290;
      uint64_t v9 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Deleting messages on endpoint '%@'", (uint8_t *)&v8, 0xCu);
    }
    sub_1000EF81C(*(void *)(a1 + 32), v4);
  }
  else
  {
    if (v6)
    {
      LOWORD(v_Block_object_dispose(&STACK[0x420], 8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error: unable to delete message, can't find endpoint for message", (uint8_t *)&v8, 2u);
    }
  }
}

void sub_1000EF81C(uint64_t a1, void *a2)
{
  if (a1)
  {
    if (a2)
    {
      id v3 = a2;
      [v3 transportIdentifier];
      id v5 = _NSConcreteStackBlock;
      uint64_t v6 = 3221225472;
      id v7 = sub_1000FCBA8;
      int v8 = &unk_100732CB8;
      uint64_t v9 = a1;
      id v10 = (id)objc_claimAutoreleasedReturnValue();
      id v4 = v10;
      [v3 closeWithCompletion:&v5];

      objc_msgSend(*(id *)(a1 + 24), "deleteSharingMessagesForTransportIdentifier:", v4, v5, v6, v7, v8, v9);
    }
  }
}

void sub_1000EF984(uint64_t a1)
{
  id v2 = +[PKSharingRelayChannelDescriptor existingChannelForURL:*(void *)(a1 + 32)];
  id v3 = [*(id *)(*(void *)(a1 + 40) + 136) handleForDescriptor:v2 queue:*(void *)(*(void *)(a1 + 40) + 88)];
  if (v3)
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = PKSharingLoggableMailboxAddress();
      *(_DWORD *)long long buf = 138412290;
      id v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Cleanup: Rejecting share invitation on endpoint %@", buf, 0xCu);
    }
    uint64_t v6 = *(id **)(a1 + 40);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1000EFAF8;
    v7[3] = &unk_1007363A8;
    void v7[4] = v6;
    id v8 = v3;
    sub_1000EE530(v6, v8, v7);
  }
}

void sub_1000EFAF8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(NSObject **)(v5 + 88);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000EFBB8;
    block[3] = &unk_10072E238;
    void block[4] = v5;
    id v8 = v3;
    id v9 = *(id *)(a1 + 40);
    dispatch_async(v6, block);
  }
}

void sub_1000EFBB8(uint64_t a1)
{
  id v2 = sub_1000EFCCC(*(id **)(a1 + 32), *(void **)(a1 + 40));
  if (v2)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    id v6[2] = sub_1000EFD38;
    v6[3] = &unk_1007363A8;
    uint64_t v3 = *(void *)(a1 + 40);
    void v6[4] = *(void *)(a1 + 32);
    id v7 = *(id *)(a1 + 48);
    [v2 rejectInvitation:v3 completion:v6];
  }
  else
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Cleanup: unable to find service for invitation to reject. Deleting mailbox instead.", v5, 2u);
    }

    [*(id *)(a1 + 48) closeWithCompletion:0];
  }
}

id *sub_1000EFCCC(id *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (((unint64_t)[v3 format] & 0xFFFFFFFFFFFFFFFELL) == 2) {
      a1 = (id *)a1[15];
    }
    else {
      a1 = 0;
    }
  }

  return a1;
}

void sub_1000EFD38(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = *(NSObject **)(*(void *)(a1 + 32) + 88);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    _DWORD v5[2] = sub_1000EFDF4;
    v5[3] = &unk_10072E198;
    id v6 = *(id *)(a1 + 40);
    id v7 = v3;
    dispatch_async(v4, v5);
  }
}

id sub_1000EFDF4(uint64_t a1)
{
  return [*(id *)(a1 + 32) sendMessage:*(void *)(a1 + 40) completion:&stru_100736380];
}

void sub_1000EFED0(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 24) passWithUniqueIdentifier:*(void *)(a1 + 40)];
  id v3 = [v2 secureElementPass];

  if (v3)
  {
    id v4 = sub_1000F0064(*(char **)(a1 + 32), v3);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1000F00E0;
    v7[3] = &unk_1007363F8;
    void v7[4] = *(void *)(a1 + 32);
    id v8 = v3;
    id v9 = *(id *)(a1 + 48);
    [v4 prewarmCreateShareForPass:v8 completion:v7];
  }
  else
  {
    uint64_t v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Tried to prewarm create share for pass %@, but unable to find pass", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

char *sub_1000F0064(char *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if ([v3 isCarKeyPass])
    {
      uint64_t v5 = 120;
    }
    else
    {
      unsigned int v6 = [v4 isHomeKeyPass];
      uint64_t v5 = 104;
      if (v6) {
        uint64_t v5 = 112;
      }
    }
    a1 = (char *)*(id *)&a1[v5];
  }

  return a1;
}

void sub_1000F00E0(uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(NSObject **)(v4 + 88);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000F019C;
  v6[3] = &unk_100730238;
  void v6[4] = v4;
  id v7 = *(id *)(a1 + 40);
  char v9 = a2;
  id v8 = *(id *)(a1 + 48);
  dispatch_async(v5, v6);
}

void sub_1000F019C(uint64_t a1)
{
  id v2 = +[PKSharingRelayChannelDescriptor createChannelWithRegion:0 stateful:sub_1000F0284(*(id *)(a1 + 32), *(void **)(a1 + 40))];
  id v3 = *(void **)(*(void *)(a1 + 32) + 136);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000F02C4;
  v6[3] = &unk_1007363D0;
  char v8 = *(unsigned char *)(a1 + 56);
  id v7 = *(id *)(a1 + 48);
  [v3 prewarmEndpointCreationForDescriptor:v2 count:2 completion:v6];
  (*(void (**)(void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), 1, v4, v5);
}

id sub_1000F0284(id a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1) {
    a1 = [v3 isCarKeyPass];
  }

  return a1;
}

uint64_t sub_1000F02C4(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 40)) {
    int v3 = a2;
  }
  else {
    int v3 = 0;
  }
  uint64_t v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"No";
    if (v3) {
      CFStringRef v5 = @"Yes";
    }
    int v7 = 138412290;
    CFStringRef v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Prewarmed create share with success: %@", (uint8_t *)&v7, 0xCu);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000F0714(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 240), 8);
  _Block_object_dispose((const void *)(v1 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1000F0738(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000F0814;
  block[3] = &unk_100731830;
  id v8 = *(id *)(a1 + 40);
  id v13 = v5;
  id v14 = v8;
  id v12 = v6;
  id v9 = v5;
  id v10 = v6;
  dispatch_async(v7, block);
}

uint64_t sub_1000F0814(void *a1)
{
  uint64_t v2 = a1[6];
  if (a1[4]) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = a1[5];
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(v2 + 16))(v2, v3);
}

void sub_1000F083C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(NSObject **)(*(void *)(a1 + 32) + 88);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1000F0904;
  void v11[3] = &unk_10072E598;
  id v12 = v6;
  id v13 = v7;
  id v9 = v6;
  id v10 = v7;
  dispatch_async(v8, v11);
}

uint64_t sub_1000F0904(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_1000F091C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [*(id *)(a1 + 32) homeInvite];

  id v9 = *(void **)(*(void *)(a1 + 40) + 24);
  id v10 = [*(id *)(a1 + 32) pass];
  uint64_t v11 = [v10 uniqueID];
  id v12 = [v9 passWithUniqueIdentifier:v11];
  uint64_t v13 = [v12 secureElementPass];
  uint64_t v14 = *(void *)(*(void *)(a1 + 56) + 8);
  double v15 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = v13;

  id v16 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  if (v16)
  {
    uint64_t v17 = sub_1000F0064(*(char **)(a1 + 40), v16);
    uint64_t v18 = *(void *)(*(void *)(a1 + 64) + 8);
    id v19 = *(void **)(v18 + 40);
    *(void *)(v18 + 40) = v17;
LABEL_5:

    v7[2](v7, v6, 0);
    goto LABEL_6;
  }
  if (v8)
  {
    id v20 = *(void **)(*(void *)(a1 + 40) + 112);
    uint64_t v21 = *(void *)(*(void *)(a1 + 64) + 8);
    id v22 = v20;
    id v19 = *(void **)(v21 + 40);
    *(void *)(v21 + 40) = v22;
    goto LABEL_5;
  }
  id v23 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v27 = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Tried to create share but unable to locate pass.", v27, 2u);
  }

  uint64_t v24 = *(void *)(a1 + 48);
  NSErrorUserInfoKey v28 = NSLocalizedDescriptionKey;
  CFStringRef v29 = @"Unable to find pass";
  long long v25 = +[NSDictionary dictionaryWithObjects:&v29 forKeys:&v28 count:1];
  long long v26 = +[NSError errorWithDomain:PKAddSecureElementPassErrorDomain code:0 userInfo:v25];
  (*(void (**)(uint64_t, void, void *))(v24 + 16))(v24, 0, v26);

LABEL_6:
}

void sub_1000F0B58(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)
    && ([*(id *)(a1 + 32) share],
        id v10 = objc_claimAutoreleasedReturnValue(),
        v10,
        v10))
  {
    uint64_t v11 = *(void *)(a1 + 40);
    id v12 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_1000F0C94;
    v13[3] = &unk_100736470;
    id v14 = *(id *)(a1 + 32);
    id v16 = v9;
    id v15 = v8;
    sub_1000F0D08(v11, v12, v13);
  }
  else
  {
    (*((void (**)(id, id, void))v9 + 2))(v9, v8, 0);
  }
}

uint64_t sub_1000F0C94(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  id v4 = a2;
  id v5 = [v3 share];
  [v5 updateDisplayableSharedEntitlementsFromDisplayableEntitlements:v4];

  id v6 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v6();
}

void sub_1000F0D08(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = *(void **)(a1 + 24);
    id v8 = [v5 uniqueID];
    id v9 = [v7 passEntitlementsForPassUniqueIdentifier:v8];

    if (v9)
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      v10[2] = sub_1000F5594;
      v10[3] = &unk_100736918;
      id v11 = v6;
      +[PKDisplayablePassEntitlement localizedEntitlementsFromEntitlements:v9 pass:v5 useCachedTemplates:1 completion:v10];
    }
    else
    {
      (*((void (**)(id, void))v6 + 2))(v6, 0);
    }
  }
}

void sub_1000F0E18(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Attempting to create share for %@", buf, 0xCu);
  }

  id v4 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000F0F7C;
  v10[3] = &unk_1007364E8;
  id v8 = *(id *)(a1 + 56);
  void v10[4] = *(void *)(a1 + 48);
  uint64_t v9 = *(void *)(a1 + 72);
  id v12 = v8;
  uint64_t v13 = v9;
  id v11 = *(id *)(a1 + 32);
  [v4 createShareInvitationFromShare:v6 forPass:v5 authorization:v7 completion:v10];
}

void sub_1000F0F7C(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (a4)
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 32);
    id v10 = *(NSObject **)(v9 + 88);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_1000F1098;
    v13[3] = &unk_1007364C0;
    void v13[4] = v9;
    id v11 = v7;
    uint64_t v12 = *(void *)(a1 + 56);
    id v14 = v11;
    uint64_t v18 = v12;
    id v15 = v8;
    id v16 = *(id *)(a1 + 40);
    id v17 = *(id *)(a1 + 48);
    dispatch_async(v10, v13);
  }
}

void sub_1000F1098(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  uint64_t v6 = *(void **)(a1 + 48);
  if (v6)
  {
    id v7 = *(void **)(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(void **)(v4 + 40);
    sub_1000F1150(v8, v3, v9, v6, v7);
  }
  else
  {
    id v10 = [*(id *)(a1 + 56) share];
    sub_1000F1150(v2, v3, v5, v10, *(void **)(a1 + 64));
  }
}

void sub_1000F1150(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 88));
    id v13 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
    v57[0] = 0;
    v57[1] = v57;
    v57[2] = 0x3032000000;
    v57[3] = sub_10002087C;
    void v57[4] = sub_100020F30;
    id v58 = 0;
    id v14 = v10;
    unsigned __int8 v15 = [v14 isCarKeyPass];

    id v16 = [v14 passTypeIdentifier];
    v53[0] = _NSConcreteStackBlock;
    v53[1] = 3221225472;
    v53[2] = sub_1000F245C;
    v53[3] = &unk_100736628;
    id v28 = v9;
    id v17 = v9;
    uint64_t v55 = a1;
    long long v56 = v57;
    id v54 = v17;
    uint64_t v18 = objc_retainBlock(v53);
    v47[0] = _NSConcreteStackBlock;
    v47[1] = 3221225472;
    v47[2] = sub_1000F2608;
    v47[3] = &unk_1007366A0;
    id v19 = v16;
    unsigned __int8 v52 = v15;
    id v48 = v19;
    uint64_t v49 = a1;
    id v20 = v13;
    id v50 = v20;
    uint64_t v21 = v18;
    id v51 = v21;
    [v17 enumerateSecondaryInvites:v47];
    v45[0] = _NSConcreteStackBlock;
    v45[1] = 3221225472;
    v45[2] = sub_1000F2918;
    void v45[3] = &unk_10072E5C0;
    id v22 = v17;
    id v46 = v22;
    [v20 addOperation:v45];
    v43[0] = 0;
    v43[1] = v43;
    v43[2] = 0x3032000000;
    v43[3] = sub_10002087C;
    v43[4] = sub_100020F30;
    id v44 = 0;
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 3221225472;
    v36[2] = sub_1000F2AAC;
    v36[3] = &unk_100736718;
    id v23 = v22;
    id v37 = v23;
    id v24 = v19;
    unsigned __int8 v42 = v15;
    id v38 = v24;
    uint64_t v39 = a1;
    uint64_t v41 = v43;
    long long v25 = v21;
    id v40 = v25;
    [v20 addOperation:v36];
    long long v26 = +[NSNull null];
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472;
    void v29[2] = sub_1000F2CE8;
    v29[3] = &unk_100736790;
    void v29[4] = a1;
    uint64_t v34 = v57;
    id v30 = v14;
    id v31 = v11;
    id v33 = v12;
    id v32 = v23;
    id v35 = v43;
    id v27 = [v20 evaluateWithInput:v26 completion:v29];

    _Block_object_dispose(v43, 8);
    _Block_object_dispose(v57, 8);

    id v9 = v28;
  }
}

void sub_1000F1568(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1000F1A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose(&a38, 8);
  _Block_object_dispose((const void *)(v38 - 240), 8);
  _Block_object_dispose((const void *)(v38 - 192), 8);
  _Block_object_dispose((const void *)(v38 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1000F1A54(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(NSObject **)(*(void *)(a1 + 32) + 88);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1000F1B1C;
  void v11[3] = &unk_10072E598;
  id v12 = v6;
  id v13 = v7;
  id v9 = v6;
  id v10 = v7;
  dispatch_async(v8, v11);
}

uint64_t sub_1000F1B1C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_1000F1B34(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = *(void **)(a1 + 40);
  id v7 = *(void **)(*(void *)(a1 + 32) + 24);
  uint64_t v8 = a4;
  id v9 = a3;
  id v10 = [v6 pass];
  id v11 = [v10 uniqueID];
  id v12 = [v7 passWithUniqueIdentifier:v11];
  uint64_t v13 = [v12 secureElementPass];
  uint64_t v14 = *(void *)(*(void *)(a1 + 48) + 8);
  unsigned __int8 v15 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = v13;

  id v16 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  if (v16)
  {
    uint64_t v17 = sub_1000F0064(*(char **)(a1 + 32), v16);
    uint64_t v18 = *(void *)(*(void *)(a1 + 56) + 8);
    id v19 = *(void **)(v18 + 40);
    *(void *)(v18 + 40) = v17;
  }
  else
  {
    id v20 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v25 = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Tried to create share but unable to locate pass.", v25, 2u);
    }

    NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
    CFStringRef v27 = @"Unable to find pass";
    uint64_t v21 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
    uint64_t v22 = +[NSError errorWithDomain:PKAddSecureElementPassErrorDomain code:0 userInfo:v21];
    uint64_t v23 = *(void *)(*(void *)(a1 + 64) + 8);
    id v24 = *(void **)(v23 + 40);
    *(void *)(v23 + 40) = v22;
  }
  v8[2](v8, v9, *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) != 0);
}

void sub_1000F1D34(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1000F1E20;
  v13[3] = &unk_100736470;
  uint64_t v9 = *(void *)(a1 + 32);
  id v10 = *(id *)(a1 + 40);
  id v15 = v6;
  id v16 = v7;
  id v14 = v10;
  id v11 = v6;
  id v12 = v7;
  sub_1000F0D08(v9, v8, v13);
}

uint64_t sub_1000F1E20(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  id v4 = a2;
  uint64_t v5 = [v3 share];
  [v5 updateDisplayableSharedEntitlementsFromDisplayableEntitlements:v4];

  id v6 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v6();
}

void sub_1000F1E94(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v25 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Attempting to create share for %@", buf, 0xCu);
  }

  id v10 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 40);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1000F2034;
  v18[3] = &unk_100736560;
  id v21 = v7;
  id v19 = v6;
  long long v22 = *(_OWORD *)(a1 + 72);
  id v14 = *(id *)(a1 + 48);
  uint64_t v15 = *(void *)(a1 + 88);
  id v20 = v14;
  uint64_t v23 = v15;
  id v16 = v6;
  id v17 = v7;
  [v10 createShareInvitationFromShare:v12 forPass:v11 authorization:v13 completion:v18];
}

void sub_1000F2034(void *a1, void *a2, void *a3, void *a4)
{
  id v13 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    objc_storeStrong((id *)(*(void *)(a1[7] + 8) + 40), a4);
    (*(void (**)(void))(a1[6] + 16))();
  }
  else
  {
    objc_storeStrong((id *)(*(void *)(a1[8] + 8) + 40), a2);
    id v10 = *(void **)(*(void *)(a1[8] + 8) + 40);
    uint64_t v11 = a1[5];
    uint64_t v12 = [v10 primaryInvite];
    [v10 setTransportIdentifier:v11 forInvite:v12];

    objc_storeStrong((id *)(*(void *)(a1[9] + 8) + 40), a3);
  }
}

void sub_1000F2144(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(NSObject **)(v2 + 88);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000F21F8;
  block[3] = &unk_1007365B0;
  void block[4] = v2;
  long long v8 = *(_OWORD *)(a1 + 56);
  long long v5 = *(_OWORD *)(a1 + 40);
  id v4 = (id)v5;
  long long v7 = v5;
  uint64_t v9 = *(void *)(a1 + 72);
  dispatch_async(v3, block);
}

void sub_1000F21F8(uint64_t *a1)
{
  uint64_t v2 = *(void **)(*(void *)(a1[6] + 8) + 40);
  if (v2 && (uint64_t v3 = *(void **)(*(void *)(a1[7] + 8) + 40)) != 0)
  {
    sub_1000F22E8(a1[4], v2, v3, *(void **)(*(void *)(a1[8] + 8) + 40));
    uint64_t v4 = a1[5];
    id v6 = [*(id *)(*(void *)(a1[7] + 8) + 40) primaryInvite];
    (*(void (**)(uint64_t, id, void, void))(v4 + 16))(v4, v6, *(void *)(*(void *)(a1[6] + 8) + 40), 0);
  }
  else
  {
    long long v5 = *(void (**)(void))(a1[5] + 16);
    v5();
  }
}

void sub_1000F22E8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  if (a1)
  {
    id v9 = a3;
    id v10 = sub_1000F0064((char *)a1, v8);
    id v17 = _NSConcreteStackBlock;
    uint64_t v18 = 3221225472;
    id v19 = sub_1000FCB0C;
    id v20 = &unk_100736E28;
    char v24 = objc_opt_respondsToSelector() & 1;
    id v21 = v10;
    id v11 = v7;
    id v22 = v11;
    id v12 = v8;
    id v23 = v12;
    id v13 = v10;
    [v9 enumerateAllInvites:&v17];

    id v14 = +[NSDate now];
    [v11 setCreationDate:v14];

    uint64_t v15 = *(void **)(a1 + 24);
    id v16 = [v12 uniqueID];
    [v15 addPassShare:v11 forPassUniqueIdentifier:v16];
  }
}

void sub_1000F245C(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a5;
  id v14 = a6;
  if (a4) {
    [*(id *)(a1 + 32) setShareURL:a4 forInvite:v11];
  }
  [*(id *)(a1 + 32) setHandle:v12 forInvite:v11];
  uint64_t v15 = *(void *)(*(void *)(a1 + 48) + 8);
  id v16 = *(void **)(v15 + 40);
  *(void *)(v15 + 40) = v13;
  id v17 = v13;

  uint64_t v18 = *(NSObject **)(*(void *)(a1 + 40) + 88);
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v21[2] = sub_1000F258C;
  v21[3] = &unk_100736600;
  uint64_t v19 = *(void *)(a1 + 48);
  id v22 = v14;
  uint64_t v23 = v19;
  id v20 = v14;
  dispatch_async(v18, v21);
}

void sub_1000F258C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = +[NSNull null];
  (*(void (**)(uint64_t, id, BOOL))(v2 + 16))(v2, v3, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) != 0);
}

void sub_1000F2608(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = +[PKSharingRelayChannelDescriptor createChannelWithRegion:*(void *)(a1 + 32) stateful:*(unsigned __int8 *)(a1 + 64)];
  long long v5 = [*(id *)(*(void *)(a1 + 40) + 136) handleForDescriptor:v4 queue:*(void *)(*(void *)(a1 + 40) + 88)];
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_1000F2718;
  v9[3] = &unk_100736678;
  id v6 = *(void **)(a1 + 48);
  void v9[4] = *(void *)(a1 + 40);
  id v10 = v5;
  id v11 = v3;
  id v12 = *(id *)(a1 + 56);
  id v7 = v3;
  id v8 = v5;
  [v6 addOperation:v9];
}

void sub_1000F2718(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = a4;
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = *(void **)(a1 + 40);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000F2808;
  v10[3] = &unk_100736650;
  id v8 = *(void **)(a1 + 48);
  id v13 = *(id *)(a1 + 56);
  id v11 = *(id *)(a1 + 48);
  id v12 = *(id *)(a1 + 40);
  id v14 = v5;
  id v9 = v5;
  sub_1000F2828(v6, v7, v8, v10);
}

uint64_t sub_1000F2808(void *a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, void, uint64_t, uint64_t, void))(a1[6] + 16))(a1[6], a1[4], a1[5], a2, a3, a1[7]);
}

void sub_1000F2828(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 88));
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_1000F2FCC;
    v10[3] = &unk_100736808;
    void v10[4] = a1;
    id v13 = v9;
    id v11 = v8;
    id v12 = v7;
    [v12 sendMessage:v11 completion:v10];
  }
}

void sub_1000F2918(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = objc_alloc_init((Class)NSMutableArray);
  id v9 = *(void **)(a1 + 32);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_1000F2A24;
  void v12[3] = &unk_1007366C8;
  id v10 = v8;
  id v13 = v10;
  [v9 enumerateSecondaryInvites:v12];
  if ([v10 count])
  {
    id v11 = [*(id *)(a1 + 32) primaryInvite];
    [v11 addEmbeddedMessages:v10];
  }
  v7[2](v7, v6, 0);
}

void sub_1000F2A24(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v5 = *(void **)(a1 + 32);
  id v6 = a4;
  +[PKSharingMessage embeddedMessageDictionaryForShareURL:targetDevice:](PKSharingMessage, "embeddedMessageDictionaryForShareURL:targetDevice:", v6, [a3 targetDevice]);
  id v7 = (id)objc_claimAutoreleasedReturnValue();

  [v5 addObject:v7];
}

void sub_1000F2AAC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = a4;
  id v6 = [*(id *)(a1 + 32) primaryInvite];
  id v7 = +[PKSharingRelayChannelDescriptor createChannelWithRegion:*(void *)(a1 + 40) stateful:*(unsigned __int8 *)(a1 + 72)];
  id v8 = [*(id *)(*(void *)(a1 + 48) + 136) handleForDescriptor:v7 queue:*(void *)(*(void *)(a1 + 48) + 88)];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  void v14[2] = sub_1000F2BE8;
  v14[3] = &unk_1007366F0;
  uint64_t v10 = *(void *)(a1 + 48);
  id v9 = *(void **)(a1 + 56);
  uint64_t v19 = *(void *)(a1 + 64);
  id v15 = v6;
  id v16 = v8;
  id v17 = v9;
  id v18 = v5;
  id v11 = v5;
  id v12 = v8;
  id v13 = v6;
  sub_1000F2828(v10, v12, v13, v14);
}

void sub_1000F2BE8(void *a1, void *a2, void *a3)
{
  id v11 = a2;
  id v6 = a3;
  objc_storeStrong((id *)(*(void *)(a1[8] + 8) + 40), a2);
  uint64_t v8 = a1[5];
  uint64_t v7 = a1[6];
  uint64_t v9 = a1[4];
  if (*(void *)(*(void *)(a1[8] + 8) + 40))
  {
    (*(void (**)(void, void, void, id, id, void))(v7 + 16))(a1[6], a1[4], a1[5], v11, v6, a1[7]);
  }
  else
  {
    uint64_t v10 = +[NSError pkSharingError:12];
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void *, void))(v7 + 16))(v7, v9, v8, 0, v10, a1[7]);
  }
}

void sub_1000F2CE8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(NSObject **)(v2 + 88);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000F2DCC;
  block[3] = &unk_100736768;
  uint64_t v11 = *(void *)(a1 + 72);
  void block[4] = v2;
  id v7 = *(id *)(a1 + 40);
  id v8 = *(id *)(a1 + 48);
  id v10 = *(id *)(a1 + 64);
  id v4 = *(id *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 80);
  id v9 = v4;
  uint64_t v12 = v5;
  dispatch_async(v3, block);
}

void sub_1000F2DCC(uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 32);
  if (*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40))
  {
    id v3 = [*(id *)(a1 + 40) uniqueID];
    uint64_t v4 = *(void *)(a1 + 48);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    void v16[2] = sub_1000F2FAC;
    v16[3] = &unk_100736740;
    id v5 = *(id *)(a1 + 64);
    uint64_t v6 = *(void *)(a1 + 72);
    id v17 = v5;
    uint64_t v18 = v6;
    [v2 revokeShareForPassIdentifier:v3 share:v4 shouldCascade:0 completion:v16];
  }
  else
  {
    id v7 = [v2[17] monitor];
    [v7 scheduleNextCheckIfNeeded];

    id v8 = *(void **)(a1 + 48);
    if (v8) {
      sub_1000F22E8(*(void *)(a1 + 32), v8, *(void **)(a1 + 56), *(void **)(a1 + 40));
    }
    if (*(void *)(a1 + 40))
    {
      id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 80));
      id v10 = [*(id *)(a1 + 40) uniqueID];
      [WeakRetained sharesDidUpdateWithPaymentPassWithUniqueIdentifier:v10];
    }
    id v11 = objc_alloc((Class)PKCrossPlatformShareURL);
    uint64_t v12 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
    id v13 = [*(id *)(a1 + 56) expectedPairedReaderIdentifier];
    id v14 = [*(id *)(a1 + 56) expectedProvisioningCredentialHash];
    id v15 = [v11 initWithURL:v12 expectedPairedReaderIdentifier:v13 expectedProvisioningCredentialHash:v14];

    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
}

uint64_t sub_1000F2FAC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), 0, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
}

void sub_1000F2FCC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (!v4)
  {
    uint64_t v6 = objc_alloc_init(PDShareURLDecorationConfiguration);
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v7 = 2;
    }
    else
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        uint64_t v7 = 1;
      }
      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
LABEL_10:
          v9[0] = _NSConcreteStackBlock;
          v9[1] = 3221225472;
          v9[2] = sub_1000F31A0;
          v9[3] = &unk_1007367E0;
          void v9[4] = *(void *)(a1 + 32);
          id v8 = *(void **)(a1 + 48);
          id v10 = *(id *)(a1 + 56);
          [v8 universalShareURLWithDecoration:v6 completion:v9];

          goto LABEL_11;
        }
        uint64_t v7 = 3;
      }
    }
    [(PDShareURLDecorationConfiguration *)v6 setVertical:v7];
    goto LABEL_10;
  }
  id v5 = *(NSObject **)(*(void *)(a1 + 32) + 88);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000F3188;
  block[3] = &unk_10072E598;
  id v13 = (PDShareURLDecorationConfiguration *)*(id *)(a1 + 56);
  id v12 = v4;
  dispatch_async(v5, block);

  uint64_t v6 = v13;
LABEL_11:
}

uint64_t sub_1000F3188(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

void sub_1000F31A0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = v6;
  if (v5) {
    BOOL v8 = v6 == 0;
  }
  else {
    BOOL v8 = 0;
  }
  char v9 = v8;
  id v10 = *(NSObject **)(*(void *)(a1 + 32) + 88);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  void v14[2] = sub_1000F3294;
  v14[3] = &unk_1007367B8;
  id v11 = *(id *)(a1 + 40);
  id v16 = v7;
  id v17 = v11;
  char v18 = v9;
  id v15 = v5;
  id v12 = v7;
  id v13 = v5;
  dispatch_async(v10, v14);
}

uint64_t sub_1000F3294(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(unsigned char *)(a1 + 56)) {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(v2 + 16))(v2, v3, *(void *)(a1 + 40));
}

void sub_1000F33D4(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 24) passWithUniqueIdentifier:*(void *)(a1 + 40)];
  uint64_t v3 = [v2 secureElementPass];

  if (!v3)
  {
    id v13 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v26 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Tried to create share for %@ but unable to locate pass.", buf, 0xCu);
    }

    uint64_t v15 = *(void *)(a1 + 64);
    id v16 = PKAddSecureElementPassErrorDomain;
    NSErrorUserInfoKey v33 = NSLocalizedDescriptionKey;
    CFStringRef v34 = @"Unable to find pass";
    id v17 = &v34;
    char v18 = &v33;
    goto LABEL_12;
  }
  if (([*(id *)(a1 + 48) isEditable] & 1) == 0)
  {
    uint64_t v19 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v26 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Tried to update share for %@ but share isn't editable.", buf, 0xCu);
    }

    uint64_t v15 = *(void *)(a1 + 64);
    id v16 = PKAddSecureElementPassErrorDomain;
    NSErrorUserInfoKey v31 = NSLocalizedDescriptionKey;
    CFStringRef v32 = @"Share not editable";
    id v17 = &v32;
    char v18 = &v31;
LABEL_12:
    id v6 = +[NSDictionary dictionaryWithObjects:v17 forKeys:v18 count:1];
    id v10 = +[NSError errorWithDomain:v16 code:0 userInfo:v6];
    (*(void (**)(uint64_t, void, void *))(v15 + 16))(v15, 0, v10);
    goto LABEL_13;
  }
  id v4 = *(void **)(*(void *)(a1 + 32) + 24);
  id v5 = [*(id *)(a1 + 48) identifier];
  id v6 = [v4 passShareForIdentifier:v5];

  uint64_t v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138412802;
    uint64_t v26 = v8;
    __int16 v27 = 2112;
    id v28 = v6;
    __int16 v29 = 2112;
    uint64_t v30 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Attempting to update share for pass %@\n\n oldShare: %@\n\n newShare: %@", buf, 0x20u);
  }

  id v10 = sub_1000F0064(*(char **)(a1 + 32), v3);
  id v11 = *(void **)(a1 + 48);
  uint64_t v12 = *(void *)(a1 + 56);
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v21[2] = sub_1000F3748;
  v21[3] = &unk_100736858;
  void v21[4] = *(void *)(a1 + 32);
  id v22 = v11;
  id v23 = *(id *)(a1 + 40);
  id v24 = *(id *)(a1 + 64);
  [v10 updateShare:v22 forPass:v3 authorization:v12 completion:v21];

LABEL_13:
}

void sub_1000F3748(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  if (a2)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = *(NSObject **)(v7 + 88);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F3894;
    block[3] = &unk_10072E238;
    void block[4] = v7;
    id v17 = *(id *)(a1 + 40);
    id v18 = *(id *)(a1 + 48);
    dispatch_async(v8, block);
  }
  uint64_t v9 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_1000F38F8;
  void v12[3] = &unk_100736830;
  id v10 = *(id *)(a1 + 56);
  char v15 = a2;
  id v13 = v6;
  id v14 = v10;
  id v11 = v6;
  dispatch_async(v9, v12);
}

void sub_1000F3894(void *a1)
{
  [*(id *)(a1[4] + 24) addPassShare:a1[5] forPassUniqueIdentifier:a1[6]];
  id WeakRetained = objc_loadWeakRetained((id *)(a1[4] + 80));
  [WeakRetained sharesDidUpdateWithPaymentPassWithUniqueIdentifier:a1[6]];
}

uint64_t sub_1000F38F8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

void sub_1000F3ADC(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 24) passWithUniqueIdentifier:*(void *)(a1 + 40)];
  uint64_t v3 = [v2 secureElementPass];

  if (v3)
  {
    id v4 = objc_msgSend(*(id *)(a1 + 48), "pk_objectsPassingTest:", &stru_100736878);
    if ([v4 count])
    {
      id v5 = sub_1000F0064(*(char **)(a1 + 32), v3);
      uint64_t v6 = *(unsigned __int8 *)(a1 + 64);
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      void v16[2] = sub_1000F3E04;
      v16[3] = &unk_1007368C8;
      uint64_t v7 = *(void **)(a1 + 40);
      uint64_t v8 = *(void *)(a1 + 48);
      void v16[4] = *(void *)(a1 + 32);
      id v17 = v7;
      id v18 = *(id *)(a1 + 56);
      [v5 revokeShares:v8 forPass:v3 shouldCascade:v6 completion:v16];
    }
    else
    {
      uint64_t v12 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = *(void *)(a1 + 40);
        *(_DWORD *)long long buf = 138412290;
        uint64_t v24 = v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Tried to revoke shares for %@ but shares aren't revokable.", buf, 0xCu);
      }

      uint64_t v14 = *(void *)(a1 + 56);
      NSErrorUserInfoKey v19 = NSLocalizedDescriptionKey;
      CFStringRef v20 = @"Share not manageable";
      id v5 = +[NSDictionary dictionaryWithObjects:&v20 forKeys:&v19 count:1];
      char v15 = +[NSError errorWithDomain:PKAddSecureElementPassErrorDomain code:0 userInfo:v5];
      (*(void (**)(uint64_t, void, void *))(v14 + 16))(v14, 0, v15);
    }
  }
  else
  {
    uint64_t v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v24 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Tried to revoke share for %@ but unable to locate pass.", buf, 0xCu);
    }

    uint64_t v11 = *(void *)(a1 + 56);
    NSErrorUserInfoKey v21 = NSLocalizedDescriptionKey;
    CFStringRef v22 = @"Unable to find pass";
    id v4 = +[NSDictionary dictionaryWithObjects:&v22 forKeys:&v21 count:1];
    id v5 = +[NSError errorWithDomain:PKAddSecureElementPassErrorDomain code:0 userInfo:v4];
    (*(void (**)(uint64_t, void, void *))(v11 + 16))(v11, 0, v5);
  }
}

BOOL sub_1000F3DFC(id a1, PKPassShare *a2, unint64_t a3, BOOL *a4)
{
  return [(PKPassShare *)a2 isRevokable];
}

void sub_1000F3E04(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  BOOL v10 = ([v7 count] || objc_msgSend(v8, "count")) && v9 == 0;
  uint64_t v11 = *(NSObject **)(*(void *)(a1 + 32) + 88);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000F3FB8;
  block[3] = &unk_1007368A0;
  BOOL v30 = v10;
  id v12 = v9;
  id v25 = v12;
  id v26 = v7;
  uint64_t v13 = *(void *)(a1 + 32);
  uint64_t v14 = *(void **)(a1 + 40);
  id v27 = v8;
  uint64_t v28 = v13;
  id v29 = v14;
  id v15 = v8;
  id v16 = v7;
  dispatch_async(v11, block);
  id v17 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_1000F4218;
  v20[3] = &unk_100736830;
  BOOL v23 = v10;
  id v18 = *(id *)(a1 + 48);
  id v21 = v12;
  id v22 = v18;
  id v19 = v12;
  dispatch_async(v17, v20);
}

void sub_1000F3FB8(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 72)) {
      CFStringRef v3 = @"Yes";
    }
    else {
      CFStringRef v3 = @"No";
    }
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    *(_DWORD *)long long buf = 138413058;
    CFStringRef v31 = v3;
    __int16 v32 = 2112;
    uint64_t v33 = v4;
    __int16 v34 = 2112;
    uint64_t v35 = v5;
    __int16 v36 = 2112;
    uint64_t v37 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: revoked shares with success: %@, %@ \n\nUpdated Shares: %@\n\nRevoked Shares: %@", buf, 0x2Au);
  }

  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  id v7 = *(id *)(a1 + 40);
  id v8 = [v7 countByEnumeratingWithState:&v24 objects:v29 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v25;
    do
    {
      uint64_t v11 = 0;
      do
      {
        if (*(void *)v25 != v10) {
          objc_enumerationMutation(v7);
        }
        [*(id *)(*(void *)(a1 + 56) + 24) addPassShare:*(void *)(*((void *)&v24 + 1) + 8 * (void)v11) forPassUniqueIdentifier:*(void *)(a1 + 64)];
        uint64_t v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id v9 = [v7 countByEnumeratingWithState:&v24 objects:v29 count:16];
    }
    while (v9);
  }

  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v12 = *(id *)(a1 + 48);
  id v13 = [v12 countByEnumeratingWithState:&v20 objects:v28 count:16];
  if (v13)
  {
    id v14 = v13;
    uint64_t v15 = *(void *)v21;
    do
    {
      id v16 = 0;
      do
      {
        if (*(void *)v21 != v15) {
          objc_enumerationMutation(v12);
        }
        id v17 = *(void **)(*(void *)(a1 + 56) + 24);
        id v18 = objc_msgSend(*(id *)(*((void *)&v20 + 1) + 8 * (void)v16), "identifier", (void)v20);
        [v17 deletePassShareWithIdentifier:v18];

        id v16 = (char *)v16 + 1;
      }
      while (v14 != v16);
      id v14 = [v12 countByEnumeratingWithState:&v20 objects:v28 count:16];
    }
    while (v14);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 56) + 80));
  [WeakRetained sharesDidUpdateWithPaymentPassWithUniqueIdentifier:*(void *)(a1 + 64)];
}

void sub_1000F4218(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v1 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v1();
  }
  else
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (*(void *)(a1 + 32))
    {
      CFStringRef v3 = *(void (**)(uint64_t, void))(v2 + 16);
      uint64_t v4 = *(void *)(a1 + 40);
      v3(v4, 0);
    }
    else
    {
      id v5 = +[NSError errorWithDomain:PKAddSecureElementPassErrorDomain code:0 userInfo:0];
      (*(void (**)(uint64_t, void, id))(v2 + 16))(v2, 0, v5);
    }
  }
}

void sub_1000F43CC(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v3 = [*(id *)(a1 + 32) typeDescription];
    *(_DWORD *)long long buf = 138412290;
    id v13 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: creating single use share url for message type %@", buf, 0xCu);
  }
  id v4 = +[PKSharingRelayChannelDescriptor createChannelWithRegion:&stru_10075AAD8 stateful:0];
  id v5 = [*(id *)(*(void *)(a1 + 40) + 136) handleForDescriptor:v4 queue:*(void *)(*(void *)(a1 + 40) + 88)];
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_1000F454C;
  v9[3] = &unk_100733E38;
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = *(void **)(a1 + 48);
  void v9[4] = *(void *)(a1 + 40);
  id v10 = v5;
  id v11 = v7;
  id v8 = v5;
  [v8 sendMessage:v6 completion:v9];
}

void sub_1000F454C(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if (v5 || (a2 & 1) == 0)
  {
    id v8 = *(NSObject **)(*(void *)(a1 + 32) + 96);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F4680;
    block[3] = &unk_10072E598;
    id v13 = *(id *)(a1 + 48);
    id v12 = v5;
    dispatch_async(v8, block);

    id v7 = v13;
  }
  else
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_1000F4698;
    v9[3] = &unk_1007367E0;
    uint64_t v6 = *(void **)(a1 + 40);
    void v9[4] = *(void *)(a1 + 32);
    id v10 = *(id *)(a1 + 48);
    [v6 universalShareURLWithDecoration:0 completion:v9];
    id v7 = v10;
  }
}

uint64_t sub_1000F4680(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

void sub_1000F4698(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (v5) {
    BOOL v8 = v6 == 0;
  }
  else {
    BOOL v8 = 0;
  }
  char v9 = v8;
  id v10 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  void v14[2] = sub_1000F478C;
  v14[3] = &unk_1007367B8;
  id v11 = *(id *)(a1 + 40);
  id v16 = v7;
  id v17 = v11;
  char v18 = v9;
  id v15 = v5;
  id v12 = v7;
  id v13 = v5;
  dispatch_async(v10, v14);
}

uint64_t sub_1000F478C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (*(unsigned char *)(a1 + 56)) {
    uint64_t v3 = *(void *)(a1 + 32);
  }
  else {
    uint64_t v3 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(v2 + 16))(v2, v3, *(void *)(a1 + 40));
}

id sub_1000F492C(uint64_t a1)
{
  id result = [*(id *)(*(void *)(a1 + 32) + 24) activeExternalPassSharesExist];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = (_BYTE)result;
  return result;
}

void sub_1000F4A28(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 24) passSharesForPassUniqueIdentifier:*(void *)(a1 + 40)];
  uint64_t v3 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000F4AEC;
  v6[3] = &unk_10072E598;
  id v4 = *(id *)(a1 + 48);
  id v7 = v2;
  id v8 = v4;
  id v5 = v2;
  dispatch_async(v3, v6);
}

uint64_t sub_1000F4AEC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_1000F4BCC(void *a1)
{
  if ([*(id *)(a1[4] + 24) externalPassSharesExistForPassUniqueIdentifier:a1[5]]) {
    uint64_t result = 1;
  }
  else {
    uint64_t result = PKShowLocalPassShares();
  }
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = result;
  return result;
}

id sub_1000F4CE0(void *a1)
{
  id result = [*(id *)(a1[4] + 24) hasShareablePassEntitlementsForPassUniqueIdentifier:a1[5]];
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = (_BYTE)result;
  return result;
}

uint64_t sub_1000F4E28(void *a1)
{
  uint64_t v2 = [*(id *)(a1[4] + 24) passEntitlementsForPassUniqueIdentifier:a1[5]];
  uint64_t v3 = *(void *)(a1[6] + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;
  return _objc_release_x1(v2, v4);
}

void sub_1000F4F3C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 24) passWithUniqueIdentifier:*(void *)(a1 + 40)];
  uint64_t v3 = [v2 secureElementPass];

  if (v3)
  {
    uint64_t v4 = [*(id *)(*(void *)(a1 + 32) + 24) passSharesForPassUniqueIdentifier:*(void *)(a1 + 40)];
    id v5 = v4;
    uint64_t v6 = *(void *)(a1 + 32);
    if (v4)
    {
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      void v14[2] = sub_1000F51C0;
      v14[3] = &unk_1007368F0;
      id v7 = (id *)v15;
      id v8 = v4;
      uint64_t v9 = *(void *)(a1 + 32);
      v15[0] = v8;
      v15[1] = v9;
      id v16 = *(id *)(a1 + 48);
      sub_1000F0D08(v6, v3, v14);
    }
    else
    {
      id v13 = *(NSObject **)(v6 + 96);
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472;
      void v17[2] = sub_1000F51AC;
      v17[3] = &unk_10072F788;
      id v7 = &v18;
      id v18 = *(id *)(a1 + 48);
      dispatch_async(v13, v17);
    }
  }
  else
  {
    id v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Tried to render displayable entitlements for pass %@ but unable to locate pass.", buf, 0xCu);
    }

    id v12 = *(NSObject **)(*(void *)(a1 + 32) + 96);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F5198;
    block[3] = &unk_10072F788;
    id v20 = *(id *)(a1 + 48);
    dispatch_async(v12, block);
    id v5 = v20;
  }
}

uint64_t sub_1000F5198(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000F51AC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000F51C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v14;
    do
    {
      id v8 = 0;
      do
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(v4);
        }
        [*(id *)(*((void *)&v13 + 1) + 8 * (void)v8) updateDisplayableSharedEntitlementsFromDisplayableEntitlements:v3];
        id v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }
    while (v6);
  }

  uint64_t v9 = *(NSObject **)(*(void *)(a1 + 40) + 96);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000F5348;
  v10[3] = &unk_10072E598;
  id v12 = *(id *)(a1 + 48);
  id v11 = *(id *)(a1 + 32);
  dispatch_async(v9, v10);
}

uint64_t sub_1000F5348(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_1000F5420(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 24) passWithUniqueIdentifier:*(void *)(a1 + 40)];
  id v3 = [v2 secureElementPass];

  if (v3)
  {
    sub_1000F0D08(*(void *)(a1 + 32), v3, *(void **)(a1 + 48));
  }
  else
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Tried to render displayable entitlements for pass %@ but unable to locate pass.", buf, 0xCu);
    }

    id v6 = *(NSObject **)(*(void *)(a1 + 32) + 96);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F5580;
    block[3] = &unk_10072F788;
    id v8 = *(id *)(a1 + 48);
    dispatch_async(v6, block);
  }
}

uint64_t sub_1000F5580(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000F5594(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v4 = a2;
  if ([v4 count]) {
    id v3 = v4;
  }
  else {
    id v3 = 0;
  }
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_1000F56A0(void *a1)
{
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  id v2 = *(id *)(a1[4] + 128);
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        objc_msgSend(*(id *)(*((void *)&v7 + 1) + 8 * (void)v6), "userNotificationActionPerformed:notificationIdentifier:", a1[6], a1[5], (void)v7);
        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
    }
    while (v4);
  }
}

void sub_1000F5798(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v7 = v6;
  if (a1)
  {
    long long v8 = *(NSObject **)(a1 + 88);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F585C;
    block[3] = &unk_10072E238;
    id v10 = v6;
    id v11 = v5;
    uint64_t v12 = a1;
    dispatch_async(v8, block);
  }
}

void sub_1000F585C(void *a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = PKSharingLoggableMailboxAddress();
    uint64_t v4 = a1[5];
    *(_DWORD *)long long buf = 138412547;
    long long v15 = v3;
    __int16 v16 = 2113;
    uint64_t v17 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Handling outstanding continuity discovery request message on %@ \n\n %{private}@", buf, 0x16u);
  }
  id v5 = +[PKSharingExistingChannelDescriptor existingForTransportIdentifier:a1[4]];
  id v6 = [*(id *)(a1[6] + 136) handleForDescriptor:v5 queue:*(void *)(a1[6] + 88)];
  long long v7 = [[PDProvisioningContinuityHostManager alloc] initWithHandle:v6 databaseManager:*(void *)(a1[6] + 24) remoteInterfacePresenter:*(void *)(a1[6] + 64) notificationManager:*(void *)(a1[6] + 32)];
  objc_initWeak((id *)buf, v7);
  long long v8 = _NSConcreteStackBlock;
  uint64_t v9 = 3221225472;
  id v10 = sub_1000F5A58;
  id v11 = &unk_10072E288;
  objc_copyWeak(&v13, (id *)buf);
  uint64_t v12 = a1[6];
  [(PDProvisioningContinuityHostManager *)v7 setInvalidationHandler:&v8];
  objc_msgSend(*(id *)(a1[6] + 128), "addObject:", v7, v8, v9, v10, v11);
  objc_destroyWeak(&v13);
  objc_destroyWeak((id *)buf);
}

void sub_1000F5A30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000F5A58(uint64_t a1)
{
  objc_copyWeak(&to, (id *)(a1 + 40));
  id v2 = objc_loadWeakRetained(&to);

  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(NSObject **)(v3 + 88);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F5B1C;
    block[3] = &unk_100736940;
    void block[4] = v3;
    objc_copyWeak(&v6, &to);
    dispatch_async(v4, block);
    objc_destroyWeak(&v6);
  }
  objc_destroyWeak(&to);
}

void sub_1000F5B1C(uint64_t a1)
{
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 128);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  [v1 removeObject:WeakRetained];
}

void sub_1000F5B8C(uint64_t a1, void *a2, char a3, void *a4, char a5, void *a6)
{
  id v11 = a2;
  id v12 = a4;
  id v13 = a6;
  if (a1)
  {
    [*(id *)(a1 + 8) passAddedOrUpdated:v11];
    long long v14 = *(NSObject **)(a1 + 88);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F5D90;
    block[3] = &unk_100736968;
    id v16 = v11;
    uint64_t v17 = a1;
    id v18 = v12;
    id v19 = v13;
    char v20 = a3;
    char v21 = a5;
    dispatch_async(v14, block);
  }
}

void sub_1000F5D90(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) uniqueID];
  uint64_t v3 = [*(id *)(*(void *)(a1 + 40) + 24) passSharesForPassUniqueIdentifier:v2];
  uint64_t v4 = [*(id *)(*(void *)(a1 + 40) + 24) passEntitlementsForPassUniqueIdentifier:v2];
  id v5 = (void *)v4;
  if (v3 || *(void *)(a1 + 48) | v4 || *(void *)(a1 + 56))
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      long long v7 = [*(id *)(a1 + 32) uniqueID];
      uint64_t v8 = *(void *)(a1 + 48);
      uint64_t v9 = *(void *)(a1 + 56);
      int v11 = 138413314;
      id v12 = v7;
      __int16 v13 = 2112;
      uint64_t v14 = v8;
      __int16 v15 = 2112;
      id v16 = v3;
      __int16 v17 = 2112;
      uint64_t v18 = v9;
      __int16 v19 = 2112;
      char v20 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Handling pass update and checking notifications for %@. \n\nOld Shares: %@ \n\nNew Shares: %@ \n\nOld Entitlements: %@ \n\nNew Entitlements: %@", (uint8_t *)&v11, 0x34u);
    }
    if (*(unsigned char *)(a1 + 64)) {
      [*(id *)(*(void *)(a1 + 40) + 40) sendShareChangeNotificationsForPass:*(void *)(a1 + 32) oldShares:*(void *)(a1 + 48) newShares:v3];
    }
    if (*(unsigned char *)(a1 + 65)) {
      objc_msgSend(*(id *)(*(void *)(a1 + 40) + 40), "sendEntitlementChangeNotificationsForPass:oldEntitlements:newEntitlements:hasExistingShares:", *(void *)(a1 + 32), *(void *)(a1 + 56), v5, objc_msgSend(*(id *)(a1 + 48), "count") != 0);
    }
    id v10 = objc_alloc_init((Class)PKMAEntitlementTemplateManager);
    [v10 entitlementTemplates:0];
  }
}

void sub_1000F5FF4(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 24);
  uint64_t v3 = [*(id *)(a1 + 40) uniqueID];
  uint64_t v4 = [v2 passSharesForPassUniqueIdentifier:v3];

  if (v4 && [v4 count])
  {
    id v5 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134349056;
      id v32 = [v4 count];
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "PDSharingManager: removing %{public}lu shares because of pass deletion", buf, 0xCu);
    }

    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    uint64_t v18 = v4;
    id obj = v4;
    id v6 = [obj countByEnumeratingWithState:&v25 objects:v30 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v20 = *(void *)v26;
      do
      {
        uint64_t v8 = 0;
        do
        {
          if (*(void *)v26 != v20) {
            objc_enumerationMutation(obj);
          }
          uint64_t v9 = [*(id *)(*((void *)&v25 + 1) + 8 * (void)v8) credentialShares];
          id v10 = v9;
          if (v9)
          {
            long long v23 = 0u;
            long long v24 = 0u;
            long long v21 = 0u;
            long long v22 = 0u;
            id v11 = [v9 countByEnumeratingWithState:&v21 objects:v29 count:16];
            if (v11)
            {
              id v12 = v11;
              uint64_t v13 = *(void *)v22;
              do
              {
                uint64_t v14 = 0;
                do
                {
                  if (*(void *)v22 != v13) {
                    objc_enumerationMutation(v10);
                  }
                  __int16 v15 = [*(id *)(*((void *)&v21 + 1) + 8 * (void)v14) channelTransportIdentifier];
                  id v16 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:v15];

                  __int16 v17 = [*(id *)(*(void *)(a1 + 32) + 136) handleForDescriptor:v16 queue:*(void *)(*(void *)(a1 + 32) + 88)];
                  sub_1000EF81C(*(void *)(a1 + 32), v17);

                  uint64_t v14 = (char *)v14 + 1;
                }
                while (v12 != v14);
                id v12 = [v10 countByEnumeratingWithState:&v21 objects:v29 count:16];
              }
              while (v12);
            }
          }

          uint64_t v8 = (char *)v8 + 1;
        }
        while (v8 != v7);
        id v7 = [obj countByEnumeratingWithState:&v25 objects:v30 count:16];
      }
      while (v7);
    }

    uint64_t v4 = v18;
  }
}

void sub_1000F6368(uint64_t a1)
{
  if (*(void *)(a1 + 32) && *(void *)(a1 + 40))
  {
    id v2 = +[PKSharingExistingChannelDescriptor existingForTransportIdentifier:](PKSharingExistingChannelDescriptor, "existingForTransportIdentifier:");
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v3 = *(void *)(a1 + 48);
    id v5 = *(void **)(v3 + 136);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1000F6508;
    v7[3] = &unk_1007305A0;
    void v7[4] = v3;
    id v8 = *(id *)(a1 + 56);
    [v5 sendMessageToDescriptor:v2 message:v4 completion:v7];
  }
  else
  {
    id v6 = *(NSObject **)(*(void *)(a1 + 48) + 96);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F64A0;
    block[3] = &unk_10072F788;
    id v10 = *(id *)(a1 + 56);
    dispatch_async(v6, block);
    id v2 = v10;
  }
}

void sub_1000F64A0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  PDBasicError();
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v2);
}

void sub_1000F6508(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id v6 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000F65C8;
  block[3] = &unk_100736830;
  id v7 = *(id *)(a1 + 40);
  char v12 = a2;
  id v10 = v5;
  id v11 = v7;
  id v8 = v5;
  dispatch_async(v6, block);
}

uint64_t sub_1000F65C8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 48), *(void *)(a1 + 32));
}

void sub_1000F674C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000F6828;
  block[3] = &unk_100731830;
  id v8 = *(id *)(a1 + 40);
  id v13 = v6;
  id v14 = v8;
  id v12 = v5;
  id v9 = v6;
  id v10 = v5;
  dispatch_async(v7, block);
}

uint64_t sub_1000F6828(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[6] + 16))(a1[6], a1[4], a1[5]);
}

void sub_1000F6840(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = objc_msgSend(*(id *)(*(void *)(a1 + 40) + 24), "transportIdentifierForSharingMessage:");
    if (v2
      && ([*(id *)(*(void *)(a1 + 40) + 24) sharingEndpointForTransportIdentifier:v2],
          (uint64_t v3 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      uint64_t v4 = (void *)v3;
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472;
      id v12[2] = sub_1000F6A10;
      void v12[3] = &unk_1007369B8;
      void v12[4] = *(void *)(a1 + 40);
      id v13 = *(id *)(a1 + 64);
      id v5 = objc_retainBlock(v12);
      id v6 = [*(id *)(*(void *)(a1 + 40) + 24) passShareForTransportIdentifier:v2];
      id v7 = *(id **)(a1 + 40);
      if (v6) {
        sub_1000F6BDC(v7, v6, *(void **)(a1 + 32), v4, *(void **)(a1 + 48), v5);
      }
      else {
        sub_1000F6F24(v7, *(void **)(a1 + 32), v4, *(void **)(a1 + 48), v5);
      }
    }
    else
    {
      uint64_t v8 = *(void *)(a1 + 56);
      id v9 = PDBasicError();
      (*(void (**)(uint64_t, void, void *))(v8 + 16))(v8, 0, v9);
    }
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 56);
    PDBasicError();
    id v11 = (id)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t, void, id))(v10 + 16))(v10, 0, v11);
  }
}

void sub_1000F6A10(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  void v15[2] = sub_1000F6B18;
  v15[3] = &unk_100731EC0;
  id v16 = v9;
  id v11 = *(id *)(a1 + 40);
  id v18 = v7;
  id v19 = v11;
  id v17 = v8;
  id v12 = v7;
  id v13 = v8;
  id v14 = v9;
  dispatch_async(v10, v15);
}

void sub_1000F6B18(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
    v2();
  }
  else
  {
    id v4 = objc_alloc_init((Class)PKCarShareAcceptanceResponse);
    [v4 setSubcredential:*(void *)(a1 + 40)];
    uint64_t v3 = [*(id *)(a1 + 48) uniqueID];
    [v4 setPassUniqueIdentifier:v3];

    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
}

void sub_1000F6BDC(id *a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  if (a1)
  {
    id v16 = PKLogFacilityTypeGetObject();
    BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    if (v14)
    {
      if (v17)
      {
        id v18 = [v11 identifier];
        id v19 = [v13 transportIdentifier];
        uint64_t v20 = PKSharingLoggableMailboxAddress();
        *(_DWORD *)long long buf = 138412546;
        CFStringRef v31 = v18;
        __int16 v32 = 2112;
        uint64_t v33 = v20;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Attempting to retry activation code for share %@ on transportIdentifier %@", buf, 0x16u);
      }
      [a1[1] userDidEnterActivationCodeForShare:v11 activationCode:v14];
      long long v21 = objc_alloc_init(PDSharingStatefulProvisioningOperation);
      long long v22 = [v13 transportIdentifier];
      [(PDSharingStatefulProvisioningOperation *)v21 setTransportIdentifier:v22];

      long long v23 = [v11 identifier];
      [(PDSharingStatefulProvisioningOperation *)v21 setShareIdentifier:v23];

      [(PDSharingStatefulProvisioningOperation *)v21 setIsForegroundOperation:1];
      [(PDSharingStatefulProvisioningOperation *)v21 setRequiresSenderActivationVerification:1];
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472;
      void v28[2] = sub_1000F7834;
      void v28[3] = &unk_100736AD0;
      id v29 = v15;
      [(PDSharingStatefulProvisioningOperation *)v21 setCompletion:v28];
      [a1[1] addOperation:v21];
      long long v24 = sub_1000EFCCC(a1, v12);
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_1000F78FC;
      v25[3] = &unk_100736AF8;
      v25[4] = a1;
      id v26 = v11;
      id v27 = v13;
      [v24 retryActivationCodeForShare:v26 activationCode:v14 completion:v25];
    }
    else
    {
      if (v17)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Attempted to retry activation code, but no code provided", buf, 2u);
      }

      long long v21 = +[NSError pkSharingError:2];
      (*((void (**)(id, void, void, PDSharingStatefulProvisioningOperation *))v15 + 2))(v15, 0, 0, v21);
    }
  }
}

void sub_1000F6F24(id *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if (a1)
  {
    id v13 = sub_1000EFCCC(a1, v9);
    id v14 = [v10 transportIdentifier];
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    void v16[2] = sub_1000F7084;
    v16[3] = &unk_100736AA8;
    void v16[4] = a1;
    id v21 = v12;
    id v17 = v10;
    id v18 = v13;
    id v19 = v9;
    id v20 = v11;
    id v15 = v13;
    [v15 acceptStatefulSharingMessage:v19 transportIdentifier:v14 activationCode:v20 completion:v16];
  }
}

void sub_1000F7084(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(void **)(a1 + 32);
  if (v6)
  {
    id v8 = v7[12];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F7254;
    block[3] = &unk_10072E598;
    id v21 = *(id *)(a1 + 72);
    id v20 = v6;
    dispatch_async(v8, block);

    id v9 = v21;
  }
  else
  {
    id v10 = [*(id *)(a1 + 40) transportIdentifier];
    id v11 = [v5 keySignRequestMessage];
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    id v12[2] = sub_1000F7270;
    void v12[3] = &unk_100736A80;
    void v12[4] = *(void *)(a1 + 32);
    id v13 = *(id *)(a1 + 48);
    id v14 = *(id *)(a1 + 56);
    id v18 = *(id *)(a1 + 72);
    id v15 = v5;
    id v16 = *(id *)(a1 + 64);
    id v17 = *(id *)(a1 + 40);
    [v7 sendSharingMessageTo:v10 message:v11 completion:v12];

    id v9 = v13;
  }
}

uint64_t sub_1000F7254(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, 0, *(void *)(a1 + 32));
}

void sub_1000F7270(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = *(NSObject **)(*(void *)(a1 + 32) + 88);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_1000F7394;
  v9[3] = &unk_100736A58;
  id v10 = v4;
  id v11 = *(id *)(a1 + 40);
  id v6 = *(id *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 32);
  id v12 = v6;
  uint64_t v13 = v7;
  id v17 = *(id *)(a1 + 80);
  id v14 = *(id *)(a1 + 56);
  id v15 = *(id *)(a1 + 64);
  id v16 = *(id *)(a1 + 72);
  id v8 = v4;
  dispatch_async(v5, v9);
}

void sub_1000F7394(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    id v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Failed to put accept share message!", buf, 2u);
    }

    uint64_t v3 = *(void **)(a1 + 40);
    uint64_t v4 = *(void *)(a1 + 48);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_1000F7644;
    v19[3] = &unk_100736A08;
    void v19[4] = *(void *)(a1 + 56);
    id v20 = *(id *)(a1 + 88);
    [v3 rejectInvitation:v4 completion:v19];
    id v5 = v20;
  }
  else
  {
    id v6 = *(void **)(*(void *)(a1 + 56) + 8);
    uint64_t v7 = [*(id *)(a1 + 64) localAcceptedShare];
    [v6 userDidEnterActivationCodeForShare:v7 activationCode:*(void *)(a1 + 72)];

    if ([*(id *)(a1 + 64) shouldWaitForResponse])
    {
      id v8 = objc_alloc_init(PDSharingStatefulProvisioningOperation);
      id v9 = [*(id *)(a1 + 80) transportIdentifier];
      [(PDSharingStatefulProvisioningOperation *)v8 setTransportIdentifier:v9];

      id v10 = [*(id *)(a1 + 64) localAcceptedShare];
      id v11 = [v10 identifier];
      [(PDSharingStatefulProvisioningOperation *)v8 setShareIdentifier:v11];

      [(PDSharingStatefulProvisioningOperation *)v8 setIsForegroundOperation:1];
      [(PDSharingStatefulProvisioningOperation *)v8 setRequiresSenderActivationVerification:1];
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      void v16[2] = sub_1000F7744;
      v16[3] = &unk_100736A30;
      id v18 = *(id *)(a1 + 88);
      id v17 = *(id *)(a1 + 64);
      [(PDSharingStatefulProvisioningOperation *)v8 setCompletion:v16];
      [*(id *)(*(void *)(a1 + 56) + 8) addOperation:v8];

      return;
    }
    id v12 = *(NSObject **)(*(void *)(a1 + 56) + 96);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_1000F77D0;
    v13[3] = &unk_10072E598;
    id v15 = *(id *)(a1 + 88);
    id v14 = *(id *)(a1 + 64);
    dispatch_async(v12, v13);

    id v5 = v15;
  }
}

void sub_1000F7644(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000F76D4;
  block[3] = &unk_10072F788;
  id v3 = *(id *)(a1 + 40);
  dispatch_async(v1, block);
}

void sub_1000F76D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = +[NSError pkSharingError:6];
  (*(void (**)(uint64_t, void, void, id))(v1 + 16))(v1, 0, 0, v2);
}

void sub_1000F7744(uint64_t a1, void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  id v6 = a3;
  id v7 = a2;
  id v8 = [v5 subcredential];
  (*(void (**)(uint64_t, id, id, id))(v4 + 16))(v4, v7, v8, v6);
}

void sub_1000F77D0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  id v2 = [*(id *)(a1 + 32) subcredential];
  (*(void (**)(uint64_t, void, id, void))(v1 + 16))(v1, 0, v2, 0);
}

void sub_1000F7834(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = *(void *)(a1 + 32);
  id v10 = v5;
  if (v5)
  {
    id v7 = [v5 devicePrimaryPaymentApplication];
    id v8 = [v7 subcredentials];
    id v9 = [v8 anyObject];
    (*(void (**)(uint64_t, id, void *, void))(v6 + 16))(v6, v10, v9, 0);
  }
  else
  {
    (*(void (**)(uint64_t, void, void, uint64_t))(v6 + 16))(v6, 0, 0, a3);
  }
}

void sub_1000F78FC(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    id v3 = *(void **)(*(void *)(a1 + 32) + 8);
    id v4 = [*(id *)(a1 + 48) transportIdentifier];
    [v3 didReceiverActivationCodeFailureForShare:v2 attemptsRemaining:1 transportIdentifier:v4];
  }
}

void sub_1000F7AA8(void *a1)
{
  uint64_t v2 = [*(id *)(a1[4] + 24) passSharesForSubcredentialIdentifier:a1[5]];
  id v3 = [v2 firstObject];

  id v4 = [v3 credentialShares];
  id v5 = [v4 firstObject];
  uint64_t v6 = [v5 channelTransportIdentifier];

  if (v3) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = a1[5];
      int v10 = 138412290;
      uint64_t v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Received activation code failure, but unable to find share or transport identifier for credential: %@", (uint8_t *)&v10, 0xCu);
    }
  }
  else
  {
    [*(id *)(a1[4] + 8) didReceiverActivationCodeFailureForShare:v3 attemptsRemaining:a1[6] transportIdentifier:v6];
  }
}

void sub_1000F7CAC(uint64_t a1)
{
  uint64_t v2 = sub_1000F7D70(*(void *)(a1 + 32), *(void **)(a1 + 40));
  id v3 = *(NSObject **)(*(void *)(a1 + 32) + 96);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  id v6[2] = sub_1000F8028;
  v6[3] = &unk_10072E598;
  id v4 = *(id *)(a1 + 48);
  id v7 = v2;
  id v8 = v4;
  id v5 = v2;
  dispatch_async(v3, v6);
}

id sub_1000F7D70(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = [*(id *)(a1 + 8) operations];
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    void v14[2] = sub_1000F803C;
    v14[3] = &unk_100736B20;
    id v5 = v3;
    id v15 = v5;
    uint64_t v6 = objc_msgSend(v4, "pk_firstObjectPassingTest:", v14);

    if (v6)
    {
      id v7 = *(void **)(a1 + 24);
      id v8 = [v6 transportIdentifier];
      uint64_t v9 = [v7 sharingMessagesForTransportIdentifier:v8];

      int v10 = [v9 pk_firstObjectPassingTest:&stru_100736B60];
      if (v10)
      {
        id v11 = objc_alloc_init((Class)PKPassSharePendingActivation);
        [v11 setShareIdentifier:v5];
        [v11 setOriginalInvitation:v10];
        objc_msgSend(v11, "setIsWaitingOnUserAction:", objc_msgSend(v6, "isWaitingOnUserAction"));
        id v12 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          id v17 = v5;
          __int16 v18 = 2112;
          id v19 = v11;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Found pending activation for shareIdentifier %@ \n\n %@", buf, 0x16u);
        }
      }
      else
      {
        id v12 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v17 = v5;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PDSharingManager: unable to find original invitation for shareIdentifier %@", buf, 0xCu);
        }
        id v11 = 0;
      }
    }
    else
    {
      uint64_t v9 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v17 = v5;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDSharingManager: unable to find active stateful share for shareIdentifier %@", buf, 0xCu);
      }
      id v11 = 0;
    }
  }
  else
  {
    id v11 = 0;
  }

  return v11;
}

uint64_t sub_1000F8028(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_1000F803C(uint64_t a1, void *a2)
{
  id v3 = [a2 shareIdentifier];
  id v4 = *(void **)(a1 + 32);
  id v5 = v3;
  id v6 = v4;
  id v7 = v6;
  if (v5 == v6)
  {
    uint64_t v8 = 1;
  }
  else
  {
    uint64_t v8 = 0;
    if (v5 && v6) {
      uint64_t v8 = (uint64_t)[v5 isEqualToString:v6];
    }
  }

  return v8;
}

BOOL sub_1000F80C0(id a1, PKSharingMessage *a2)
{
  return [(PKSharingMessage *)a2 type] == (id)1;
}

void sub_1000F80E4(id *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (a1)
  {
    id v6 = [a1[3] sharingMessagesForTransportIdentifier:a3];
    id v7 = objc_msgSend(v6, "pk_firstObjectPassingTest:", &stru_100736B80);
    if (v7)
    {
      uint64_t v8 = sub_1000F8338(a1, v7);
      if (v8)
      {
        uint64_t v9 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = PKSharingLoggableMailboxAddress();
          *(_DWORD *)long long buf = 138412290;
          __int16 v18 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Attempting to provision embedded invite onto remote device. Address: %@", buf, 0xCu);
        }
        id v11 = objc_alloc_init(off_1008056B8());
        [v11 loadWebService];
        id v12 = [v11 webService];
        uint64_t v13 = [v12 targetDevice];

        if (v13)
        {
          v14[0] = _NSConcreteStackBlock;
          v14[1] = 3221225472;
          void v14[2] = sub_1000F840C;
          v14[3] = &unk_1007363A8;
          id v15 = v13;
          id v16 = v5;
          [v15 retrieveShareInvitationForMailboxAddress:v8 completion:v14];

          uint64_t v9 = v15;
        }
        else if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Failed to fetch embedded invite on remote device. No target device.", buf, 2u);
        }
      }
    }
  }
}

BOOL sub_1000F8314(id a1, PKSharingMessage *a2)
{
  return [(PKSharingMessage *)a2 type] == (id)1;
}

id sub_1000F8338(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    if (PKIsWatch())
    {
      uint64_t v4 = 0;
    }
    else if (PKIsPhone())
    {
      uint64_t v4 = 1;
    }
    else
    {
      id v5 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Warning, tried to find embedded mailbox address on unsupported device!", v7, 2u);
      }

      uint64_t v4 = 0x7FFFFFFFFFFFFFFFLL;
    }
    a1 = sub_1000EEE94((uint64_t)a1, v4, v3);
  }

  return a1;
}

void sub_1000F840C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v14 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Failed to fetch embedded invite on remote device with error: %@", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v8 = *(void **)(a1 + 32);
    uint64_t v9 = [*(id *)(a1 + 40) activationOptions];
    int v10 = [v9 activationCode];
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    id v11[2] = sub_1000F8574;
    void v11[3] = &unk_100736BA8;
    id v12 = *(id *)(a1 + 32);
    [v8 acceptCarKeyShareForMessage:v5 activationCode:v10 completion:v11];

    id v7 = v12;
  }
}

void sub_1000F8574(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v6 = @"Yes";
    if (!a2) {
      CFStringRef v6 = @"No";
    }
    int v7 = 138412546;
    CFStringRef v8 = v6;
    __int16 v9 = 2112;
    uint64_t v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Finished accepting remote share with success: %@ %@", (uint8_t *)&v7, 0x16u);
  }
}

void sub_1000F86E4(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableArray);
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v3 = objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "pendingShares", 0);
  id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v13;
    do
    {
      int v7 = 0;
      do
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v3);
        }
        CFStringRef v8 = [*(id *)(*((void *)&v12 + 1) + 8 * (void)v7) subcredentialIdentifier];
        if (v8)
        {
          id v9 = [objc_alloc((Class)PKAppletSubcredential) initWithIdentifier:v8];
          [v9 setState:2];
          [v2 addObject:v9];
        }
        int v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v5);
  }

  uint64_t v10 = *(void *)(a1 + 40);
  if ([v2 count])
  {
    id v11 = [v2 copy];
    (*(void (**)(uint64_t, id))(v10 + 16))(v10, v11);
  }
  else
  {
    (*(void (**)(uint64_t, void))(v10 + 16))(v10, 0);
  }
}

void sub_1000F894C(uint64_t a1)
{
  uint64_t v1 = a1;
  [*(id *)(*(void *)(a1 + 32) + 8) pendingShares];
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  id obj = (id)objc_claimAutoreleasedReturnValue();
  id v2 = [obj countByEnumeratingWithState:&v29 objects:v35 count:16];
  if (!v2)
  {
LABEL_15:

    goto LABEL_21;
  }
  id v3 = v2;
  uint64_t v4 = *(void *)v30;
  id v5 = PKSavingsAccountDetails_ptr;
LABEL_3:
  uint64_t v6 = 0;
  while (1)
  {
    if (*(void *)v30 != v4) {
      objc_enumerationMutation(obj);
    }
    int v7 = *(void **)(*((void *)&v29 + 1) + 8 * v6);
    uint64_t v8 = *(void *)(v1 + 32);
    id v9 = [v7 identifier];
    uint64_t v10 = sub_1000F7D70(v8, v9);

    id v11 = [v10 originalInvitation];
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) == 0) {
      goto LABEL_13;
    }
    id v12 = v3;
    uint64_t v13 = v4;
    long long v14 = v5;
    uint64_t v15 = v1;
    id v16 = *(void **)(v1 + 40);
    id v17 = [v11 readerIdentifier];
    id v18 = v16;
    id v19 = v17;
    if (v18 == v19) {
      break;
    }
    id v20 = v19;
    if (v18 && v19)
    {
      unsigned int v25 = [v18 isEqualToString:v19];

      id v5 = v14;
      uint64_t v1 = v15;
      uint64_t v4 = v13;
      id v3 = v12;
      if (v25) {
        goto LABEL_17;
      }
    }
    else
    {

      id v5 = v14;
      uint64_t v1 = v15;
      uint64_t v4 = v13;
      id v3 = v12;
    }
LABEL_13:

    if (v3 == (id)++v6)
    {
      id v3 = [obj countByEnumeratingWithState:&v29 objects:v35 count:16];
      if (v3) {
        goto LABEL_3;
      }
      goto LABEL_15;
    }
  }

  uint64_t v1 = v15;
LABEL_17:
  id v21 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    long long v22 = [v7 identifier];
    *(_DWORD *)long long buf = 138412290;
    __int16 v34 = v22;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Revoking share %@ to allow for new provisioning.", buf, 0xCu);
  }
  long long v23 = [v7 subcredentialIdentifier];
  [*(id *)(*(void *)(v1 + 32) + 8) userDidTerminatePendingShareActivationForShare:v7];

  if (v23)
  {
    long long v24 = *(void **)(*(void *)(v1 + 32) + 56);
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472;
    id v27[2] = sub_1000F8C90;
    v27[3] = &unk_1007304D8;
    id v28 = *(id *)(v1 + 48);
    [v24 revokeSubcredentialForIdentifier:v23 withCompletion:v27];

    goto LABEL_22;
  }
LABEL_21:
  (*(void (**)(void))(*(void *)(v1 + 48) + 16))();
LABEL_22:
}

uint64_t sub_1000F8C90(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000F8FB4(uint64_t a1)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v2 = objc_msgSend(*(id *)(*(void *)(a1 + 32) + 8), "operations", 0);
  id v3 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v2);
        }
        int v7 = *(void **)(*((void *)&v10 + 1) + 8 * i);
        if ([v7 requiresSenderActivationVerification])
        {
          id v8 = objc_alloc_init((Class)PKPassSharePendingActivation);
          id v9 = [v7 shareIdentifier];
          [v8 setShareIdentifier:v9];

          objc_msgSend(v8, "setIsWaitingOnUserAction:", objc_msgSend(v7, "isWaitingOnUserAction"));
          [*(id *)(a1 + 40) addObject:v8];
        }
      }
      id v4 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v4);
  }
}

uint64_t sub_1000F9244(uint64_t a1)
{
  uint64_t v2 = sub_1000F7D70(*(void *)(a1 + 32), *(void **)(a1 + 40));
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;
  return _objc_release_x1(v2, v4);
}

uint64_t sub_1000F9340(uint64_t a1)
{
  uint64_t v6 = [*(id *)(*(void *)(a1 + 32) + 24) passShareForIdentifier:*(void *)(a1 + 40)];
  id v2 = [v6 status];
  uint64_t v3 = v6;
  if (v6) {
    BOOL v4 = v2 == (id)5;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    id v2 = [*(id *)(*(void *)(a1 + 32) + 8) userDidTerminatePendingShareActivationForShare:v6];
    uint64_t v3 = v6;
  }
  return _objc_release_x1(v2, v3);
}

void sub_1000F9504(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = v6;
  if (a1)
  {
    id v8 = *(NSObject **)(a1 + 88);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F9C50;
    block[3] = &unk_10072E238;
    id v10 = v6;
    id v11 = v5;
    uint64_t v12 = a1;
    dispatch_async(v8, block);
  }
}

void sub_1000F95C8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = v6;
  if (a1)
  {
    id v8 = *(NSObject **)(a1 + 88);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000FB0E0;
    block[3] = &unk_10072E238;
    id v10 = v6;
    id v11 = v5;
    uint64_t v12 = a1;
    dispatch_async(v8, block);
  }
}

void sub_1000F968C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = v6;
  if (a1)
  {
    id v8 = *(NSObject **)(a1 + 88);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F9750;
    block[3] = &unk_10072E238;
    id v10 = v6;
    id v11 = v5;
    uint64_t v12 = a1;
    dispatch_async(v8, block);
  }
}

void sub_1000F9750(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PKSharingLoggableMailboxAddress();
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412547;
    id v19 = v3;
    __int16 v20 = 2113;
    uint64_t v21 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Handling outstanding message on %@ \n\n %{private}@", buf, 0x16u);
  }
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  void v15[2] = sub_1000F9B10;
  v15[3] = &unk_10072F630;
  id v16 = *(id *)(a1 + 32);
  int8x16_t v12 = *(int8x16_t *)(a1 + 40);
  id v5 = (id)v12.i64[0];
  int8x16_t v17 = vextq_s8(v12, v12, 8uLL);
  id v6 = objc_retainBlock(v15);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v7 = *(id *)(a1 + 40);
    if (PKV2SharingFlowEnabled()
      && ((unint64_t v8 = (unint64_t)[v7 type], v8 > 7) || ((1 << v8) & 0xB4) == 0))
    {
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Ignoring message because it is not a friend to owner message", buf, 2u);
      }

      ((void (*)(void *, void))v6[2])(v6, 0);
    }
    else
    {
      id v9 = sub_1000EFCCC(*(id **)(a1 + 48), v7);
      if (v9)
      {
        id v10 = [*(id *)(*(void *)(a1 + 48) + 24) passShareForTransportIdentifier:*(void *)(a1 + 32)];
        if (v10)
        {
          uint64_t v11 = *(void *)(a1 + 32);
          v13[0] = _NSConcreteStackBlock;
          v13[1] = 3221225472;
          v13[2] = sub_1000F9C40;
          v13[3] = &unk_1007304D8;
          long long v14 = v6;
          [v9 handleIncomingMessage:v7 transportIdentifier:v11 share:v10 completion:v13];
        }
        else
        {
          if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Error: Unable to find active share for message. Ignoring.", buf, 2u);
          }

          ((void (*)(void *, uint64_t))v6[2])(v6, 1);
        }
      }
      else
      {
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Error: Unable to find viable management service for message", buf, 2u);
        }

        ((void (*)(void *, uint64_t))v6[2])(v6, 1);
      }
    }
  }
  else
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Error: Message is not a generic sharing message. It should not have been processed", buf, 2u);
    }

    ((void (*)(void *, uint64_t))v6[2])(v6, 1);
  }
}

void sub_1000F9B10(void *a1, int a2)
{
  uint64_t v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PKSharingLoggableMailboxAddress();
    id v6 = (void *)v5;
    CFStringRef v7 = @"N";
    if (a2) {
      CFStringRef v7 = @"Y";
    }
    *(_DWORD *)long long buf = 138412546;
    uint64_t v12 = v5;
    __int16 v13 = 2112;
    CFStringRef v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Handled outstanding message on %@ shouldDelete %@.", buf, 0x16u);
  }
  if (a2)
  {
    unint64_t v8 = *(void **)(a1[5] + 24);
    uint64_t v10 = a1[6];
    id v9 = +[NSArray arrayWithObjects:&v10 count:1];
    [v8 insertOrUpdateSharingMessages:v9 storePayloads:0 transportIdentifier:a1[4]];
  }
}

uint64_t sub_1000F9C40(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000F9C50(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PKSharingLoggableMailboxAddress();
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412547;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&buf[12] = 2113;
    *(void *)&buf[14] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Handling outstanding invitation request message on %@ \n\n %{private}@", buf, 0x16u);
  }
  v67[0] = _NSConcreteStackBlock;
  v67[1] = 3221225472;
  v67[2] = sub_1000FA458;
  v67[3] = &unk_10072F630;
  id v68 = *(id *)(a1 + 32);
  int8x16_t v29 = *(int8x16_t *)(a1 + 40);
  id v5 = (id)v29.i64[0];
  int8x16_t v69 = vextq_s8(v29, v29, 8uLL);
  id v6 = objc_retainBlock(v67);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v7 = *(id *)(a1 + 40);
    unint64_t v8 = *(void **)(*(void *)(a1 + 48) + 24);
    id v9 = [v7 passTypeIdentifier];
    uint64_t v10 = [v7 passSerialNumber];
    uint64_t v11 = [v8 passWithPassTypeID:v9 serialNumber:v10];

    if (v11)
    {
      uint64_t v12 = sub_1000F0064(*(char **)(a1 + 48), v11);
      if (v12)
      {
        id v13 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&uint8_t buf[16] = 0x3032000000;
        uint64_t v71 = sub_10002087C;
        uint64_t v72 = sub_100020F30;
        id v73 = 0;
        id v14 = objc_alloc_init((Class)LAContext);
        id v15 = objc_alloc((Class)PKSharedPassSharesController);
        id v16 = [*(id *)(*(void *)(a1 + 48) + 16) sharedWebService];
        id v17 = [v15 initWithPass:v11 webService:v16 paymentServiceProvider:0 queue:*(void *)(*(void *)(a1 + 48) + 88)];

        v65[0] = 0;
        v65[1] = v65;
        v65[2] = 0x3032000000;
        v65[3] = sub_10002087C;
        void v65[4] = sub_100020F30;
        id v66 = 0;
        v61[0] = _NSConcreteStackBlock;
        v61[1] = 3221225472;
        v61[2] = sub_1000FA588;
        v61[3] = &unk_100730BC0;
        id v18 = v17;
        id v62 = v18;
        long long v64 = v65;
        id v19 = v11;
        id v63 = v19;
        [v13 addOperation:v61];
        v59[0] = 0;
        v59[1] = v59;
        v59[2] = 0x3032000000;
        v59[3] = sub_10002087C;
        v59[4] = sub_100020F30;
        id v60 = 0;
        v55[0] = _NSConcreteStackBlock;
        v55[1] = 3221225472;
        v55[2] = sub_1000FA710;
        v55[3] = &unk_100736BF8;
        id v20 = v14;
        id v56 = v20;
        long long v57 = buf;
        id v58 = v59;
        [v13 addOperation:v55];
        v53[0] = 0;
        v53[1] = v53;
        v53[2] = 0x3032000000;
        v53[3] = sub_10002087C;
        void v53[4] = sub_100020F30;
        id v54 = 0;
        v51[0] = 0;
        v51[1] = v51;
        v51[2] = 0x3032000000;
        v51[3] = sub_10002087C;
        void v51[4] = sub_100020F30;
        id v52 = 0;
        v43[0] = _NSConcreteStackBlock;
        v43[1] = 3221225472;
        v43[2] = sub_1000FA988;
        v43[3] = &unk_100736C48;
        id v46 = v65;
        id v44 = v12;
        id v21 = v19;
        id v45 = v21;
        long long v47 = v59;
        id v48 = v51;
        uint64_t v49 = v53;
        id v50 = buf;
        [v13 addOperation:v43];
        v38[0] = _NSConcreteStackBlock;
        v38[1] = 3221225472;
        v38[2] = sub_1000FAC04;
        v38[3] = &unk_10072E638;
        id v22 = *(id *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 48);
        id v39 = v22;
        uint64_t v40 = v23;
        uint64_t v41 = buf;
        unsigned __int8 v42 = v51;
        [v13 addOperation:v38];
        long long v24 = +[NSNull null];
        v30[0] = _NSConcreteStackBlock;
        v30[1] = 3221225472;
        v30[2] = sub_1000FAEAC;
        v30[3] = &unk_100736C98;
        id v25 = v20;
        id v31 = v25;
        id v26 = v6;
        uint64_t v35 = buf;
        __int16 v36 = v53;
        uint64_t v27 = *(void *)(a1 + 48);
        id v34 = v26;
        uint64_t v32 = v27;
        id v33 = v21;
        uint64_t v37 = v51;
        id v28 = [v13 evaluateWithInput:v24 completion:v30];

        _Block_object_dispose(v51, 8);
        _Block_object_dispose(v53, 8);

        _Block_object_dispose(v59, 8);
        _Block_object_dispose(v65, 8);

        _Block_object_dispose(buf, 8);
      }
      else
      {
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Error: Unable to find viable management service for message", buf, 2u);
        }

        ((void (*)(void *, uint64_t))v6[2])(v6, 1);
      }
    }
    else
    {
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Unable to find pass for invitation request", buf, 2u);
      }

      ((void (*)(void *, uint64_t))v6[2])(v6, 1);
    }
  }
  else
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Error: Message is not a generic sharing message. It should not have been processed", buf, 2u);
    }

    ((void (*)(void *, uint64_t))v6[2])(v6, 1);
  }
}

void sub_1000FA3EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose(&STACK[0x218], 8);
  _Block_object_dispose((const void *)(v63 - 176), 8);
  _Unwind_Resume(a1);
}

void sub_1000FA458(void *a1, int a2)
{
  uint64_t v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PKSharingLoggableMailboxAddress();
    id v6 = (void *)v5;
    CFStringRef v7 = @"N";
    if (a2) {
      CFStringRef v7 = @"Y";
    }
    *(_DWORD *)long long buf = 138412546;
    uint64_t v12 = v5;
    __int16 v13 = 2112;
    CFStringRef v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Handled outstanding message on %@ shouldDelete %@.", buf, 0x16u);
  }
  if (a2)
  {
    unint64_t v8 = *(void **)(a1[5] + 24);
    uint64_t v10 = a1[6];
    id v9 = +[NSArray arrayWithObjects:&v10 count:1];
    [v8 insertOrUpdateSharingMessages:v9 storePayloads:0 transportIdentifier:a1[4]];
  }
}

void sub_1000FA588(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  unint64_t v8 = *(void **)(a1 + 32);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_1000FA67C;
  void v12[3] = &unk_100730A08;
  uint64_t v17 = *(void *)(a1 + 48);
  id v13 = v8;
  id v9 = *(id *)(a1 + 40);
  id v15 = v6;
  id v16 = v7;
  id v14 = v9;
  id v10 = v6;
  id v11 = v7;
  [v13 updateSharesWithCompletion:v12];
}

uint64_t sub_1000FA67C(uint64_t a1)
{
  id v2 = objc_alloc((Class)PKPartialShareInvitation);
  uint64_t v3 = [*(id *)(a1 + 32) baseShareForPassTransferWithIsForCompanion:0];
  id v4 = [v2 initWithShare:v3 pass:*(void *)(a1 + 40)];
  uint64_t v5 = *(void *)(*(void *)(a1 + 64) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  id v7 = *(uint64_t (**)(void))(*(void *)(a1 + 56) + 16);
  return v7();
}

void sub_1000FA710(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  v19[0] = &off_10078AB18;
  unint64_t v8 = PKLocalizedShareableCredentialString(@"LOCAL_AUTHENTICATION_REASON");
  v20[0] = v8;
  v19[1] = &off_10078AB30;
  id v9 = PKLocalizedString(@"WALLET");
  v20[1] = v9;
  id v10 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:2];

  id v11 = *(void **)(a1 + 32);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  void v14[2] = sub_1000FA8A0;
  v14[3] = &unk_100736BD0;
  id v16 = v6;
  id v17 = v7;
  id v15 = v11;
  long long v18 = *(_OWORD *)(a1 + 40);
  id v12 = v6;
  id v13 = v7;
  [v15 evaluatePolicy:1005 options:v10 reply:v14];
}

void sub_1000FA8A0(uint64_t a1, void *a2, void *a3)
{
  id v13 = a2;
  id v5 = a3;
  if (v13
    && !v5
    && ([*(id *)(a1 + 32) externalizedContext], (id v6 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
    unint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
    id v9 = v6;

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    uint64_t v10 = PDBasicError();
    uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 8);
    id v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_1000FA988(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  unint64_t v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v22 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Attempting to create share for %@", buf, 0xCu);
  }

  uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  uint64_t v11 = *(void **)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  void v16[2] = sub_1000FAB18;
  v16[3] = &unk_100736C20;
  long long v19 = *(_OWORD *)(a1 + 64);
  uint64_t v20 = *(void *)(a1 + 80);
  id v17 = v6;
  id v18 = v7;
  id v14 = v6;
  id v15 = v7;
  [v11 createShareInvitationFromShare:v10 forPass:v12 authorization:v13 completion:v16];
}

void sub_1000FAB18(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(void *)(a1[6] + 8);
  uint64_t v11 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = v7;
  id v18 = v7;

  uint64_t v12 = *(void *)(a1[7] + 8);
  uint64_t v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v8;
  id v14 = v8;

  uint64_t v15 = *(void *)(a1[8] + 8);
  id v16 = *(void **)(v15 + 40);
  *(void *)(v15 + 40) = v9;
  id v17 = v9;

  (*(void (**)(void, void, BOOL))(a1[5] + 16))(a1[5], a1[4], *(void *)(*(void *)(a1[8] + 8) + 40) != 0);
}

void sub_1000FAC04(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Sending invitation for invitation request", buf, 2u);
  }

  id v11 = +[PKSharingExistingChannelDescriptor existingForTransportIdentifier:*(void *)(a1 + 32)];
  uint64_t v12 = [*(id *)(*(void *)(a1 + 40) + 136) handleForDescriptor:v11 queue:*(void *)(*(void *)(a1 + 40) + 88)];
  if (v12)
  {
    uint64_t v13 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) primaryInvite];
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_1000FAE00;
    v18[3] = &unk_100736C70;
    long long v23 = *(_OWORD *)(a1 + 48);
    id v19 = v12;
    id v20 = v13;
    id v22 = v9;
    id v21 = v8;
    id v14 = v13;
    [v19 sendMessage:v14 completion:v18];
  }
  else
  {
    uint64_t v15 = PDBasicError();
    uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8);
    id v17 = *(void **)(v16 + 40);
    *(void *)(v16 + 40) = v15;

    (*((void (**)(id, id, BOOL))v9 + 2))(v9, v8, *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) != 0);
  }
}

void sub_1000FAE00(void *a1, int a2, void *a3)
{
  id v6 = a3;
  objc_storeStrong((id *)(*(void *)(a1[8] + 8) + 40), a3);
  if (!v6 && a2) {
    [*(id *)(*(void *)(a1[9] + 8) + 40) setHandle:a1[4] forInvite:a1[5]];
  }
  (*(void (**)(void, void, BOOL))(a1[7] + 16))(a1[7], a1[6], *(void *)(*(void *)(a1[8] + 8) + 40) != 0);
}

void sub_1000FAEAC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = a4;
  [*(id *)(a1 + 32) invalidate];
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  if (*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) || [v5 isCanceled])
  {
    id v6 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Failed to send invitation with error: %@", buf, 0xCu);
    }

    if (*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40))
    {
      id v8 = *(void **)(a1 + 40);
      id v9 = [*(id *)(a1 + 48) uniqueID];
      uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472;
      id v12[2] = sub_1000FB0CC;
      void v12[3] = &unk_10072E570;
      id v13 = *(id *)(a1 + 56);
      [v8 revokeShareForPassIdentifier:v9 share:v10 shouldCascade:0 completion:v12];
    }
  }
  else if (*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40))
  {
    id v11 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Successfully sent invitation!", buf, 2u);
    }

    sub_1000F22E8(*(void *)(a1 + 40), *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40), *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40), *(void **)(a1 + 48));
  }
}

uint64_t sub_1000FB0CC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000FB0E0(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = PKSharingLoggableMailboxAddress();
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412547;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&buf[12] = 2113;
    *(void *)&buf[14] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Handling outstanding invitation request message on %@ \n\n %{private}@", buf, 0x16u);
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x3032000000;
  long long v87 = sub_10002087C;
  id v88 = sub_100020F30;
  id v89 = 0;
  v82[0] = _NSConcreteStackBlock;
  v82[1] = 3221225472;
  v82[2] = sub_1000FBA84;
  v82[3] = &unk_100736CC0;
  id v83 = *(id *)(a1 + 32);
  int8x16_t v36 = *(int8x16_t *)(a1 + 40);
  id v5 = (id)v36.i64[0];
  int8x16_t v84 = vextq_s8(v36, v36, 8uLL);
  id v85 = buf;
  id v6 = objc_retainBlock(v82);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v7 = *(id *)(a1 + 40);
    id v8 = *(void **)(*(void *)(a1 + 48) + 24);
    id v9 = [v7 sharingSessionIdentifier];
    uint64_t v10 = [v8 passShareForIdentifier:v9];

    if (v10)
    {
      id v11 = *(void **)(*(void *)(a1 + 48) + 24);
      uint64_t v12 = [v10 identifier];
      id v13 = [v11 passIdentifierForPassShareIdentifier:v12];

      id v14 = [*(id *)(*(void *)(a1 + 48) + 24) passWithUniqueIdentifier:v13];
      uint64_t v15 = v14;
      if (v14 && ([v14 isCarKeyPass] & 1) != 0)
      {
        uint64_t v16 = sub_1000F0064(*(char **)(a1 + 48), v15);
        if (v16)
        {
          id v17 = +[PKSharingExistingChannelDescriptor existingForTransportIdentifier:*(void *)(a1 + 32)];
          uint64_t v18 = [*(id *)(*(void *)(a1 + 48) + 136) handleForDescriptor:v17 queue:*(void *)(*(void *)(a1 + 48) + 88)];
          id v19 = *(void **)(*(void *)&buf[8] + 40);
          *(void *)(*(void *)&buf[8] + 40) = v18;

          if (*(void *)(*(void *)&buf[8] + 40))
          {
            id v34 = v17;
            id v20 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
            *(void *)long long v76 = 0;
            id v77 = v76;
            uint64_t v78 = 0x3032000000;
            uint64_t v79 = sub_10002087C;
            uint64_t v80 = sub_100020F30;
            id v81 = 0;
            v70[0] = _NSConcreteStackBlock;
            v70[1] = 3221225472;
            v70[2] = sub_1000FBBC4;
            v70[3] = &unk_100733B00;
            id v21 = v10;
            id v71 = v21;
            id v33 = v16;
            id v35 = v16;
            id v72 = v35;
            id v22 = v15;
            uint64_t v23 = *(void *)(a1 + 48);
            id v73 = v22;
            uint64_t v74 = v23;
            id v75 = v13;
            [v20 addOperation:v70];
            uint64_t v37 = v20;
            v68[0] = 0;
            v68[1] = v68;
            v68[2] = 0x3032000000;
            v68[3] = sub_10002087C;
            v68[4] = sub_100020F30;
            id v69 = 0;
            v66[0] = 0;
            v66[1] = v66;
            v66[2] = 0x3032000000;
            v66[3] = sub_10002087C;
            v66[4] = sub_100020F30;
            id v67 = 0;
            v64[0] = 0;
            v64[1] = v64;
            v64[2] = 0x3032000000;
            v64[3] = sub_10002087C;
            v64[4] = sub_100020F30;
            id v65 = 0;
            v55[0] = _NSConcreteStackBlock;
            v55[1] = 3221225472;
            v55[2] = sub_1000FBE9C;
            v55[3] = &unk_100736D60;
            id v60 = v66;
            id v24 = v21;
            id v56 = v24;
            __int16 v61 = v68;
            id v25 = v22;
            id v57 = v25;
            id v26 = v35;
            id v62 = v64;
            uint64_t v63 = v76;
            uint64_t v27 = *(void *)(a1 + 48);
            id v58 = v26;
            uint64_t v59 = v27;
            [v20 addOperation:v55];
            v53[0] = 0;
            v53[1] = v53;
            v53[2] = 0x3032000000;
            v53[3] = sub_10002087C;
            void v53[4] = sub_100020F30;
            id v54 = 0;
            v47[0] = _NSConcreteStackBlock;
            v47[1] = 3221225472;
            v47[2] = sub_1000FC254;
            v47[3] = &unk_100731970;
            id v28 = v25;
            uint64_t v29 = *(void *)(a1 + 48);
            id v48 = v28;
            uint64_t v49 = v29;
            id v50 = v64;
            id v51 = v53;
            id v52 = v76;
            [v20 addOperation:v47];
            v46[0] = _NSConcreteStackBlock;
            v46[1] = 3221225472;
            v46[2] = sub_1000FC584;
            void v46[3] = &unk_100736DD8;
            v46[6] = buf;
            v46[7] = v76;
            void v46[4] = *(void *)(a1 + 48);
            void v46[5] = v53;
            [v20 addOperation:v46];
            long long v30 = +[NSNull null];
            v38[0] = _NSConcreteStackBlock;
            v38[1] = 3221225472;
            v38[2] = sub_1000FC7D8;
            v38[3] = &unk_100736E00;
            id v43 = buf;
            id v44 = v66;
            uint64_t v31 = *(void *)(a1 + 48);
            unsigned __int8 v42 = v76;
            void v38[4] = v31;
            id v39 = v28;
            uint64_t v41 = v6;
            id v40 = v24;
            id v45 = v64;
            id v32 = [v37 evaluateWithInput:v30 completion:v38];

            uint64_t v16 = v33;
            id v17 = v34;

            _Block_object_dispose(v53, 8);
            _Block_object_dispose(v64, 8);

            _Block_object_dispose(v66, 8);
            _Block_object_dispose(v68, 8);

            _Block_object_dispose(v76, 8);
          }
          else
          {
            if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long v76 = 0;
              _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Error: unable to get handle for message", v76, 2u);
            }

            ((void (*)(void *, uint64_t))v6[2])(v6, 1);
          }
        }
        else
        {
          if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long v76 = 0;
            _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Error: Unable to find viable management service for message", v76, 2u);
          }

          ((void (*)(void *, uint64_t))v6[2])(v6, 1);
        }
      }
      else
      {
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long v76 = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Unable to find pass for invitation request or pass is invalid", v76, 2u);
        }

        ((void (*)(void *, uint64_t))v6[2])(v6, 1);
      }
    }
    else
    {
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long v76 = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Unable to find existing share for sharing session identifier", v76, 2u);
      }

      ((void (*)(void *, uint64_t))v6[2])(v6, 1);
    }
  }
  else
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v76 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Error: Message is not a generic sharing message. It should not have been processed", v76, 2u);
    }

    ((void (*)(void *, uint64_t))v6[2])(v6, 1);
  }

  _Block_object_dispose(buf, 8);
}

void sub_1000FB9F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  _Block_object_dispose(&a62, 8);
  _Block_object_dispose(&a68, 8);
  _Block_object_dispose(&STACK[0x208], 8);
  _Block_object_dispose(&STACK[0x280], 8);
  _Block_object_dispose((const void *)(v68 - 176), 8);
  _Unwind_Resume(a1);
}

id sub_1000FBA84(void *a1, int a2)
{
  uint64_t v4 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = PKSharingLoggableMailboxAddress();
    id v6 = (void *)v5;
    CFStringRef v7 = @"N";
    if (a2) {
      CFStringRef v7 = @"Y";
    }
    *(_DWORD *)long long buf = 138412546;
    uint64_t v13 = v5;
    __int16 v14 = 2112;
    CFStringRef v15 = v7;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Handled outstanding message on %@ shouldDelete %@.", buf, 0x16u);
  }
  if (a2)
  {
    id v8 = *(void **)(a1[5] + 24);
    uint64_t v11 = a1[6];
    id v9 = +[NSArray arrayWithObjects:&v11 count:1];
    [v8 insertOrUpdateSharingMessages:v9 storePayloads:0 transportIdentifier:a1[4]];
  }
  return [*(id *)(*(void *)(a1[7] + 8) + 40) invalidate];
}

void sub_1000FBBC4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = objc_alloc_init((Class)NSMutableArray);
  id v9 = objc_alloc_init((Class)NSMutableArray);
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  uint64_t v10 = [*(id *)(a1 + 32) credentialShares];
  id v11 = [v10 countByEnumeratingWithState:&v31 objects:v36 count:16];
  if (v11)
  {
    id v12 = v11;
    uint64_t v13 = *(void *)v32;
    do
    {
      for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v32 != v13) {
          objc_enumerationMutation(v10);
        }
        CFStringRef v15 = *(void **)(*((void *)&v31 + 1) + 8 * i);
        [v15 status];
        if (PKShareStatusIsPending()) {
          uint64_t v16 = v8;
        }
        else {
          uint64_t v16 = v9;
        }
        [v16 addObject:v15];
      }
      id v12 = [v10 countByEnumeratingWithState:&v31 objects:v36 count:16];
    }
    while (v12);
  }

  if ([v8 count])
  {
    id v17 = [*(id *)(a1 + 32) copy];
    [v17 setCredentialShares:v8];
    uint64_t v18 = *(void **)(a1 + 40);
    id v35 = v17;
    id v19 = +[NSArray arrayWithObjects:&v35 count:1];
    uint64_t v20 = *(void *)(a1 + 48);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_1000FBE40;
    v24[3] = &unk_100736CE8;
    id v25 = *(id *)(a1 + 32);
    id v21 = v9;
    uint64_t v22 = *(void *)(a1 + 56);
    uint64_t v23 = *(void **)(a1 + 64);
    id v26 = v21;
    uint64_t v27 = v22;
    id v28 = v23;
    id v30 = v7;
    id v29 = v6;
    [v18 revokeShares:v19 forPass:v20 shouldCascade:0 completion:v24];
  }
  else
  {
    (*((void (**)(id, id, void))v7 + 2))(v7, v6, 0);
  }
}

uint64_t sub_1000FBE40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4)
  {
    [*(id *)(a1 + 32) setCredentialShares:*(void *)(a1 + 40)];
    [*(id *)(*(void *)(a1 + 48) + 24) addPassShare:*(void *)(a1 + 32) forPassUniqueIdentifier:*(void *)(a1 + 56)];
  }
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)(a1 + 72) + 16);
  return v5();
}

void sub_1000FBE9C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = objc_alloc_init((Class)PKPassCredentialShare);
  [v8 setTargetDevice:2];
  [v8 setStatus:2];
  id v9 = [*(id *)(a1 + 32) copy];
  uint64_t v10 = *(void *)(*(void *)(a1 + 64) + 8);
  id v11 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = v9;

  id v12 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
  id v36 = v8;
  uint64_t v13 = +[NSArray arrayWithObjects:&v36 count:1];
  [v12 setCredentialShares:v13];

  id v14 = [objc_alloc((Class)PKPartialShareInvitation) initWithShare:*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) pass:*(void *)(a1 + 40)];
  uint64_t v15 = *(void *)(*(void *)(a1 + 72) + 8);
  uint64_t v16 = *(void **)(v15 + 40);
  *(void *)(v15 + 40) = v14;

  [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) setRequestSource:2];
  id v17 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v35 = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Attempting to create share for %@", buf, 0xCu);
  }

  uint64_t v19 = *(void *)(a1 + 64);
  uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
  uint64_t v22 = *(void *)(a1 + 40);
  id v21 = *(void **)(a1 + 48);
  v28[0] = _NSConcreteStackBlock;
  v28[1] = 3221225472;
  void v28[2] = sub_1000FC0EC;
  void v28[3] = &unk_100736D38;
  uint64_t v23 = *(void *)(a1 + 80);
  uint64_t v24 = *(void *)(a1 + 88);
  uint64_t v25 = *(void *)(a1 + 56);
  uint64_t v32 = v19;
  uint64_t v33 = v24;
  id v30 = v7;
  uint64_t v31 = v23;
  void v28[4] = v25;
  id v29 = v6;
  id v26 = v6;
  id v27 = v7;
  [v21 createShareInvitationFromShare:v20 forPass:v22 authorization:0 completion:v28];
}

void sub_1000FC0EC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = *(void *)(*(void *)(a1 + 56) + 8);
  id v11 = *(void **)(v10 + 40);
  *(void *)(v10 + 40) = v7;
  id v12 = v7;

  uint64_t v13 = *(void *)(*(void *)(a1 + 64) + 8);
  id v14 = *(void **)(v13 + 40);
  *(void *)(v13 + 40) = v8;
  id v15 = v8;

  uint64_t v16 = *(void *)(*(void *)(a1 + 72) + 8);
  id v17 = *(void **)(v16 + 40);
  *(void *)(v16 + 40) = v9;
  id v18 = v9;

  uint64_t v19 = *(NSObject **)(*(void *)(a1 + 32) + 88);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000FC22C;
  block[3] = &unk_100736D10;
  id v24 = *(id *)(a1 + 48);
  id v20 = *(id *)(a1 + 40);
  uint64_t v21 = *(void *)(a1 + 72);
  id v23 = v20;
  uint64_t v25 = v21;
  dispatch_async(v19, block);
}

uint64_t sub_1000FC22C(void *a1)
{
  return (*(uint64_t (**)(void, void, BOOL))(a1[5] + 16))(a1[5], a1[4], *(void *)(*(void *)(a1[6] + 8) + 40) != 0);
}

void sub_1000FC254(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDSharingManager: uploading invitation to relays erver", buf, 2u);
  }

  id v9 = [*(id *)(a1 + 32) passTypeIdentifier];
  id v10 = +[PKSharingRelayChannelDescriptor createChannelWithRegion:v9 stateful:1];

  id v11 = [*(id *)(*(void *)(a1 + 40) + 136) handleForDescriptor:v10 queue:*(void *)(*(void *)(a1 + 40) + 88)];
  id v12 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) primaryInvite];
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1000FC41C;
  v18[3] = &unk_100736D88;
  int8x16_t v24 = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
  id v19 = v11;
  id v20 = v12;
  uint64_t v25 = *(void *)(a1 + 64);
  uint64_t v13 = *(void *)(a1 + 40);
  id v22 = v6;
  id v23 = v7;
  uint64_t v21 = v13;
  id v14 = v6;
  id v15 = v7;
  id v16 = v12;
  id v17 = v11;
  sub_1000F2828(v13, v17, v16, v18);
}

void sub_1000FC41C(uint64_t a1, void *a2, void *a3)
{
  id v6 = a2;
  id v7 = a3;
  id v8 = v7;
  if (v6)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40), a2);
    [*(id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) setHandle:*(void *)(a1 + 32) forInvite:*(void *)(a1 + 40)];
  }
  else
  {
    id v9 = v7;
    if (!v7)
    {
      id v9 = PDBasicError();
    }
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 88) + 8) + 40), v9);
    if (!v8) {
  }
    }
  id v10 = *(NSObject **)(*(void *)(a1 + 48) + 88);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000FC55C;
  block[3] = &unk_100736D10;
  id v15 = *(id *)(a1 + 64);
  id v11 = *(id *)(a1 + 56);
  uint64_t v12 = *(void *)(a1 + 88);
  id v14 = v11;
  uint64_t v16 = v12;
  dispatch_async(v10, block);
}

uint64_t sub_1000FC55C(void *a1)
{
  return (*(uint64_t (**)(void, void, BOOL))(a1[5] + 16))(a1[5], a1[4], *(void *)(*(void *)(a1[6] + 8) + 40) != 0);
}

void sub_1000FC584(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Sending invitation for invitation request", buf, 2u);
  }

  id v9 = [objc_alloc((Class)PKSharingURLMessage) initWithURL:*(void *)(*(void *)(a1[5] + 8) + 40)];
  id v10 = *(void **)(*(void *)(a1[6] + 8) + 40);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  void v15[2] = sub_1000FC6D4;
  v15[3] = &unk_100736DB0;
  uint64_t v11 = a1[7];
  uint64_t v12 = a1[4];
  id v17 = v7;
  uint64_t v18 = v11;
  void v15[4] = v12;
  id v16 = v6;
  id v13 = v6;
  id v14 = v7;
  [v10 sendMessage:v9 completion:v15];
}

void sub_1000FC6D4(uint64_t a1, int a2, id obj)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), obj);
  id v5 = obj;
  id v6 = *(NSObject **)(*(void *)(a1 + 32) + 88);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000FC7B0;
  block[3] = &unk_100736D10;
  id v11 = *(id *)(a1 + 48);
  id v7 = *(id *)(a1 + 40);
  uint64_t v8 = *(void *)(a1 + 56);
  id v10 = v7;
  uint64_t v12 = v8;
  dispatch_async(v6, block);
}

uint64_t sub_1000FC7B0(void *a1)
{
  return (*(uint64_t (**)(void, void, BOOL))(a1[5] + 16))(a1[5], a1[4], *(void *)(*(void *)(a1[6] + 8) + 40) != 0);
}

void sub_1000FC7D8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = v7;
  if (!*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40)
    && ([v7 isCanceled] & 1) == 0
    && ![*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) isInvalid])
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
    {
      id v14 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Successfully sent invitation!", buf, 2u);
      }

      id v15 = *(void **)(a1 + 48);
      id v16 = [*(id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) credentialShares];
      [v15 addCredentialShares:v16];

      sub_1000F22E8(*(void *)(a1 + 32), *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40), *(void **)(*(void *)(*(void *)(a1 + 88) + 8) + 40), *(void **)(a1 + 40));
    }
    goto LABEL_12;
  }
  id v9 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v20 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Failed to send invitation with error: %@", buf, 0xCu);
  }

  [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) closeWithCompletion:0];
  if (!*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40))
  {
LABEL_12:
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    goto LABEL_13;
  }
  id v11 = *(void **)(a1 + 32);
  uint64_t v12 = [*(id *)(a1 + 40) uniqueID];
  uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_1000FCA54;
  v17[3] = &unk_10072E570;
  id v18 = *(id *)(a1 + 56);
  [v11 revokeShareForPassIdentifier:v12 share:v13 shouldCascade:0 completion:v17];

LABEL_13:
}

uint64_t sub_1000FCA54(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000FCB00(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 8) channelEndpointWasTerminatedRemotely:*(void *)(a1 + 40)];
}

void sub_1000FCB0C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v9 = a2;
  id v7 = a3;
  id v8 = a4;
  if (v8)
  {
    if (v7 && *(unsigned char *)(a1 + 56)) {
      [*(id *)(a1 + 32) didCreateAndStoreShare:*(void *)(a1 + 40) forCredentialShare:v7 pass:*(void *)(a1 + 48) transportIdentifier:v8];
    }
    [v7 setChannelTransportIdentifier:v8];
  }
}

id sub_1000FCBA8(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 24) deleteSharingEndpointForTransportIdentifier:*(void *)(a1 + 40)];
}

void sub_1000FCBB4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Cleanup: Device list: %@", buf, 0xCu);
  }

  id v8 = PKSerialNumber();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Cleanup: Serial Number: %@", buf, 0xCu);
  }

  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_1000FCE54;
  void v12[3] = &unk_100736E50;
  id v9 = v8;
  id v13 = v9;
  uint64_t v10 = objc_msgSend(v5, "pk_objectsPassingTest:", v12);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Cleanup: Remote Device List: %@", buf, 0xCu);
  }

  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Cleanup: Failed to check for paired watch with error: %@", buf, 0xCu);
    }

    goto LABEL_11;
  }
  if (![v10 count])
  {
LABEL_11:
    id v11 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    goto LABEL_16;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Cleanup: Found paired watch on account", buf, 2u);
  }

  id v11 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
LABEL_16:
  v11();
}

uint64_t sub_1000FCE54(uint64_t a1, void *a2)
{
  uint64_t v3 = [a2 serialNumber];
  uint64_t v4 = *(void **)(a1 + 32);
  id v5 = v3;
  id v6 = v4;
  id v7 = v6;
  if (v5 == v6)
  {
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 1;
    if (v5 && v6) {
      uint64_t v8 = [v5 isEqualToString:v6] ^ 1;
    }
  }

  return v8;
}

void sub_1000FCFC8(uint64_t a1)
{
  if ((unint64_t)[*(id *)(a1 + 32) count] > 1)
  {
    uint64_t v3 = [*(id *)(a1 + 32) objectAtIndexedSubscript:0];
    v243 = [*(id *)(a1 + 32) objectAtIndexedSubscript:1];
    id v4 = objc_alloc_init((Class)NSMutableDictionary);
    id v5 = [*(id *)(a1 + 32) count];
    if ((unint64_t)v5 >= 3)
    {
      id v6 = v5;
      unint64_t v7 = 2;
      do
      {
        uint64_t v8 = [*(id *)(a1 + 32) objectAtIndexedSubscript:v7];
        if ([v8 hasPrefix:@"-"])
        {
          id v9 = [v8 substringFromIndex:1];
          ++v7;
          uint64_t v10 = @"1";
          if (v7 < (unint64_t)v6)
          {
            uint64_t v10 = [*(id *)(a1 + 32) objectAtIndexedSubscript:v7];
            if ([(__CFString *)v10 hasPrefix:@"-"])
            {

              uint64_t v10 = @"1";
            }
          }
          [v4 setObject:v10 forKeyedSubscript:v9];
        }
        else
        {
          ++v7;
        }
      }
      while ((id)v7 != v6);
    }
    id v11 = [v4 objectForKeyedSubscript:@"pid"];
    uint64_t v12 = v11;
    if (v11 == @"*"
      || v11
      && (unsigned __int8 v13 = [(__CFString *)v11 isEqualToString:@"*"],
          v12,
          (v13 & 1) != 0))
    {
      long long v246 = 0u;
      long long v247 = 0u;
      long long v244 = 0u;
      long long v245 = 0u;
      id v14 = [*(id *)(*(void *)(a1 + 40) + 24) passesOfType:1];
      id v15 = [v14 countByEnumeratingWithState:&v244 objects:v248 count:16];
      if (v15)
      {
        id v16 = v15;
        uint64_t v17 = *(void *)v245;
        while (2)
        {
          for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v245 != v17) {
              objc_enumerationMutation(v14);
            }
            id v19 = *(void **)(*((void *)&v244 + 1) + 8 * i);
            if (([v19 supportsFeatureForCurrentDevice:1] & 1) != 0
              || [v19 isCarKeyPass])
            {
              uint64_t v20 = [v19 uniqueID];

              uint64_t v12 = (void *)v20;
              goto LABEL_28;
            }
          }
          id v16 = [v14 countByEnumeratingWithState:&v244 objects:v248 count:16];
          if (v16) {
            continue;
          }
          break;
        }
      }
LABEL_28:
    }
    uint64_t v21 = v243;
    id v22 = v3;
    id v23 = v22;
    if (v22 == @"mailbox") {
      goto LABEL_32;
    }
    if (!v22) {
      goto LABEL_208;
    }
    unsigned int v24 = [(__CFString *)v22 isEqualToString:@"mailbox"];

    if (v24)
    {
LABEL_32:
      uint64_t v25 = v243;
      if (v25 == @"list")
      {
LABEL_35:
        sub_1000FE900(*(void *)(a1 + 40), *(void **)(a1 + 48));
LABEL_210:

        return;
      }
      id v26 = v25;
      if (v25)
      {
        unsigned int v27 = [(__CFString *)v25 isEqualToString:@"list"];

        if (v27) {
          goto LABEL_35;
        }
        long long v34 = v26;
        if (v34 == @"create"
          || (uint64_t v35 = v34,
              unsigned int v36 = [(__CFString *)v34 isEqualToString:@"create"],
              v35,
              v36))
        {
          uint64_t v37 = *(void *)(a1 + 40);
          uint64_t v38 = [v4 objectForKeyedSubscript:@"type"];
          id v39 = [v4 objectForKeyedSubscript:@"payload"];
          id v40 = [v4 objectForKeyedSubscript:@"stateful"];
          uint64_t v41 = [v4 objectForKeyedSubscript:@"region"];
          sub_1000FEAC8(v37, v38, v39, v40 != 0, (uint64_t)v41, *(void **)(a1 + 48));

LABEL_58:
          uint64_t v21 = v243;
          goto LABEL_210;
        }
        id v51 = v35;
        if (v51 == @"store"
          || (id v52 = v51,
              unsigned int v53 = [(__CFString *)v51 isEqualToString:@"store"],
              v52,
              v53))
        {
          uint64_t v54 = *(void *)(a1 + 40);
          uint64_t v55 = [v4 objectForKeyedSubscript:@"id"];
          id v56 = [v4 objectForKeyedSubscript:@"payload"];
          sub_1000FECE8(v54, v55, v56, *(void **)(a1 + 48));
LABEL_56:

LABEL_57:
          goto LABEL_58;
        }
        uint64_t v68 = v52;
        uint64_t v21 = v243;
        if (v68 == @"get"
          || (id v69 = v68,
              unsigned int v70 = [(__CFString *)v68 isEqualToString:@"get"],
              v69,
              v70))
        {
          uint64_t v71 = *(void *)(a1 + 40);
          uint64_t v49 = [v4 objectForKeyedSubscript:@"id"];
          sub_1000FEF00(v71, v49, *(void **)(a1 + 48));
          goto LABEL_137;
        }
        id v85 = v69;
        if (v85 == @"relinquish"
          || (id v86 = v85,
              unsigned int v87 = [(__CFString *)v85 isEqualToString:@"relinquish"],
              v86,
              v87))
        {
          uint64_t v88 = *(void *)(a1 + 40);
          uint64_t v49 = [v4 objectForKeyedSubscript:@"id"];
          sub_1000FF068(v88, v49, *(void **)(a1 + 48));
          goto LABEL_137;
        }
        v113 = v86;
        if (v113 == @"delete"
          || (id v114 = v113,
              unsigned int v115 = [(__CFString *)v113 isEqualToString:@"delete"],
              v114,
              v115))
        {
          uint64_t v116 = *(void *)(a1 + 40);
          uint64_t v49 = [v4 objectForKeyedSubscript:@"id"];
          sub_1000FF1C4(v116, v49, *(void **)(a1 + 48));
          goto LABEL_137;
        }
        v138 = v114;
        if (v138 == @"delete_all"
          || (uint64_t v139 = v138,
              unsigned int v140 = [(__CFString *)v138 isEqualToString:@"delete_all"],
              v139,
              v140))
        {
          sub_1000FF32C(*(void *)(a1 + 40), *(void **)(a1 + 48));
          goto LABEL_210;
        }
      }
      if (PKEqualObjects())
      {
        sub_1000FF4B4(*(void *)(a1 + 40), *(void **)(a1 + 48));
        goto LABEL_210;
      }
      id v141 = v26;
      if (v141 == @"ping")
      {
LABEL_136:
        uint64_t v144 = *(void *)(a1 + 40);
        uint64_t v49 = [v4 objectForKeyedSubscript:@"id"];
        sub_1000FF6EC(v144, v49, *(void **)(a1 + 48));
        goto LABEL_137;
      }
      if (v26)
      {
        uint64_t v142 = v141;
        unsigned int v143 = [(__CFString *)v141 isEqualToString:@"ping"];

        if (v143) {
          goto LABEL_136;
        }
        int v145 = v142;
        if (v145 == @"pushToken"
          || (dispatch_source_t v146 = v145,
              unsigned int v147 = [(__CFString *)v145 isEqualToString:@"pushToken"],
              v146,
              v147))
        {
          uint64_t v148 = *(void *)(a1 + 40);
          uint64_t v49 = [v4 objectForKeyedSubscript:@"env"];
          sub_1000FF800(v148, (uint64_t)v49, *(void **)(a1 + 48));
          goto LABEL_137;
        }
      }
      goto LABEL_208;
    }
    id v28 = v23;
    if (v28 == @"ids"
      || (id v29 = v28,
          unsigned int v30 = [(__CFString *)v28 isEqualToString:@"ids"],
          v29,
          v30))
    {
      uint64_t v31 = v243;
      if (v31 == @"devices"
        || (uint64_t v32 = v31) != 0
        && (unsigned int v33 = [(__CFString *)v31 isEqualToString:@"devices"],
            v32,
            v33))
      {
        sub_1000FF910(*(void *)(a1 + 40), *(void **)(a1 + 48));
        goto LABEL_210;
      }
      if (PKEqualObjects())
      {
        sub_1000FF9BC(*(void *)(a1 + 40), *(void **)(a1 + 48));
        goto LABEL_210;
      }
      id v57 = v32;
      if (v57 == @"store") {
        goto LABEL_62;
      }
      if (v32)
      {
        id v58 = v57;
        unsigned int v59 = [(__CFString *)v57 isEqualToString:@"store"];

        if (v59)
        {
LABEL_62:
          uint64_t v60 = *(void *)(a1 + 40);
          uint64_t v49 = [v4 objectForKeyedSubscript:@"id"];
          id v50 = [v4 objectForKeyedSubscript:@"sid"];
          __int16 v61 = [v4 objectForKeyedSubscript:@"payload"];
          sub_1000FFB84(v60, v49, v50, v61, *(void **)(a1 + 48));
LABEL_63:

          uint64_t v21 = v243;
          goto LABEL_64;
        }
        id v81 = v58;
        if (v81 == @"listen"
          || (unsigned int v82 = v81,
              unsigned int v83 = [(__CFString *)v81 isEqualToString:@"listen"],
              v82,
              v83))
        {
          uint64_t v84 = *(void *)(a1 + 40);
          uint64_t v49 = [v4 objectForKeyedSubscript:@"sid"];
          id v50 = [v4 objectForKeyedSubscript:@"timeout"];
          sub_1000FFE04(v84, v49, v50, *(void **)(a1 + 48));
          goto LABEL_64;
        }
        uint64_t v109 = v82;
        if (v109 == @"close"
          || (v110 = v109,
              unsigned int v111 = [(__CFString *)v109 isEqualToString:@"close"],
              v110,
              v111))
        {
          uint64_t v112 = *(void *)(a1 + 40);
          uint64_t v49 = [v4 objectForKeyedSubscript:@"sid"];
          sub_1000FFFE0(v112, v49, *(void **)(a1 + 48));
          goto LABEL_137;
        }
      }
      goto LABEL_208;
    }
    unsigned __int8 v42 = v29;
    if (v42 == @"share"
      || (id v43 = v42,
          unsigned int v44 = [(__CFString *)v42 isEqualToString:@"share"],
          v43,
          v44))
    {
      id v45 = v243;
      if (v45 == @"get") {
        goto LABEL_50;
      }
      id v46 = v45;
      if (!v45) {
        goto LABEL_208;
      }
      unsigned int v47 = [(__CFString *)v45 isEqualToString:@"get"];

      if (v47)
      {
LABEL_50:
        uint64_t v48 = *(void *)(a1 + 40);
        uint64_t v49 = [v4 objectForKeyedSubscript:@"mid"];
        id v50 = [v4 objectForKeyedSubscript:@"key"];
        sub_100100140(v48, v49, v50, *(void **)(a1 + 48));
LABEL_64:

LABEL_137:
        goto LABEL_210;
      }
      id v72 = v46;
      if (v72 == @"prewarm"
        || (id v73 = v72,
            unsigned int v74 = [(__CFString *)v72 isEqualToString:@"prewarm"],
            v73,
            v74))
      {
        sub_100100240(*(void **)(a1 + 40), v12, *(void **)(a1 + 48));
        goto LABEL_210;
      }
      uint64_t v99 = v73;
      if (v99 == @"create"
        || (long long v100 = v99,
            unsigned int v101 = [(__CFString *)v99 isEqualToString:@"create"],
            v100,
            v101))
      {
        uint64_t v102 = *(void *)(a1 + 40);
        uint64_t v49 = [v4 objectForKeyedSubscript:@"n"];
        id v50 = [v4 objectForKeyedSubscript:@"car"];
        sub_100100314(v102, v12, v49, v50, *(void **)(a1 + 48));
        goto LABEL_64;
      }
      uint64_t v128 = v100;
      if (v128 == @"createMockEmbedded"
        || (long long v129 = v128,
            unsigned int v130 = [(__CFString *)v128 isEqualToString:@"createMockEmbedded"],
            v129,
            v130))
      {
        sub_1001006E0(*(void *)(a1 + 40), (uint64_t)v12, *(void **)(a1 + 48));
        goto LABEL_210;
      }
      char v152 = v129;
      if (v152 == @"update"
        || (uint64_t v153 = v152,
            unsigned int v154 = [(__CFString *)v152 isEqualToString:@"update"],
            v153,
            v154))
      {
        id v155 = *(id **)(a1 + 40);
        uint64_t v49 = [v4 objectForKeyedSubscript:@"sid"];
        sub_100100864(v155, v12, v49, *(void **)(a1 + 48));
        goto LABEL_137;
      }
      id v169 = v153;
      if (v169 == @"revoke"
        || (id v170 = v169,
            unsigned int v171 = [(__CFString *)v169 isEqualToString:@"revoke"],
            v170,
            v171))
      {
        id v172 = *(id **)(a1 + 40);
        uint64_t v55 = [v4 objectForKeyedSubscript:@"sid"];
        sub_1001009DC(v172, v12, v55, *(void **)(a1 + 48));
        goto LABEL_57;
      }
      long long v184 = v170;
      if (v184 == @"createSingleUse"
        || (long long v185 = v184,
            unsigned int v186 = [(__CFString *)v184 isEqualToString:@"createSingleUse"],
            v185,
            v186))
      {
        long long v187 = *(void **)(a1 + 40);
        uint64_t v55 = [v4 objectForKeyedSubscript:@"payload"];
        id v56 = [v4 objectForKeyedSubscript:@"title"];
        long long v188 = [v4 objectForKeyedSubscript:@"ttl"];
        if (v188)
        {
          long long v189 = [v4 objectForKeyedSubscript:@"ttl"];
          sub_100100B40(v187, v55, v56, (unint64_t)(double)(uint64_t)[v189 integerValue], *(void **)(a1 + 48));
        }
        else
        {
          sub_100100B40(v187, v55, v56, 604800, *(void **)(a1 + 48));
        }

        goto LABEL_56;
      }
      long long v198 = v185;
      if (v198 == @"accept"
        || (v199 = v198,
            unsigned int v200 = [(__CFString *)v198 isEqualToString:@"accept"],
            v199,
            v200))
      {
        v242 = *(id **)(a1 + 40);
        v240 = [v4 objectForKeyedSubscript:@"url"];
        long long v201 = [v4 objectForKeyedSubscript:@"background"];
        int v202 = [v201 BOOLValue];
        long long v203 = [v4 objectForKeyedSubscript:@"resolve"];
        int v204 = [v203 BOOLValue];
        long long v205 = [v4 objectForKeyedSubscript:@"activationCode"];
        long long v206 = [v4 objectForKeyedSubscript:@"salt"];
        sub_100100CCC(v242, v240, v202, v204, v205, v206, *(void **)(a1 + 48));

        goto LABEL_58;
      }
      long long v212 = v199;
      if (v212 == @"reject"
        || (long long v213 = v212,
            unsigned int v214 = [(__CFString *)v212 isEqualToString:@"reject"],
            v213,
            v214))
      {
        long long v215 = *(void **)(a1 + 40);
        uint64_t v55 = [v4 objectForKeyedSubscript:@"url"];
        sub_10010103C(v215, (uint64_t)v55, *(void **)(a1 + 48));
        goto LABEL_57;
      }
      long long v220 = v213;
      if (v220 == @"deviceCheck"
        || (long long v221 = v220,
            unsigned int v222 = [(__CFString *)v220 isEqualToString:@"deviceCheck"],
            v221,
            v222))
      {
        uint64_t v223 = *(void *)(a1 + 40);
        uint64_t v55 = [v4 objectForKeyedSubscript:@"type"];
        sub_1001010B0(v223, v55, *(void **)(a1 + 48));
        goto LABEL_57;
      }
      long long v227 = v221;
      if (v227 != @"requestInvitation")
      {
        long long v228 = v227;
        unsigned int v229 = [(__CFString *)v227 isEqualToString:@"requestInvitation"];

        if (!v229)
        {
          long long v232 = v228;
          uint64_t v21 = v243;
          if (v232 == @"requestLateInvitation"
            || (v233 = v232,
                unsigned int v234 = [(__CFString *)v232 isEqualToString:@"requestLateInvitation"], v233, v234))
          {
            sub_10010135C(*(void *)(a1 + 40), v12, *(void **)(a1 + 48));
            goto LABEL_210;
          }
          goto LABEL_208;
        }
      }
      uint64_t v230 = *(void *)(a1 + 40);
      uint64_t v55 = [v4 objectForKeyedSubscript:@"from"];
      id v56 = [v4 objectForKeyedSubscript:@"type"];
      long long v211 = [v4 objectForKeyedSubscript:@"serial"];
      long long v231 = [v4 objectForKeyedSubscript:@"vehicle"];
      sub_1001011A0(v230, v55, v56, v211, v231, *(void **)(a1 + 48));

LABEL_189:
      goto LABEL_56;
    }
    id v62 = v43;
    if (v62 != @"shares")
    {
      uint64_t v63 = v62;
      unsigned int v64 = [(__CFString *)v62 isEqualToString:@"shares"];

      if (!v64)
      {
        id v75 = v63;
        if (v75 == @"entitlements"
          || (long long v76 = v75,
              unsigned int v77 = [(__CFString *)v75 isEqualToString:@"entitlements"],
              v76,
              v77))
        {
          uint64_t v78 = v243;
          if (v78 == @"list") {
            goto LABEL_82;
          }
          uint64_t v79 = v78;
          if (!v78) {
            goto LABEL_210;
          }
          unsigned int v80 = [(__CFString *)v78 isEqualToString:@"list"];

          if (v80)
          {
LABEL_82:
            sub_1001027C4(*(void *)(a1 + 40), v12, *(void **)(a1 + 48));
            goto LABEL_210;
          }
          uint64_t v117 = v79;
          if (v117 != @"role")
          {
            id v118 = v117;
            unsigned int v119 = [(__CFString *)v117 isEqualToString:@"role"];

            if (!v119) {
              goto LABEL_210;
            }
          }
          uint64_t v120 = *(void *)(a1 + 40);
          uint64_t v49 = [v4 objectForKeyedSubscript:@"hex"];
          id v50 = [v4 objectForKeyedSubscript:@"int"];
          sub_10010297C(v120, v49, v50, *(void **)(a1 + 48));
          goto LABEL_64;
        }
        uint64_t v103 = v76;
        if (v103 == @"monitor"
          || (uint64_t v104 = v103,
              unsigned int v105 = [(__CFString *)v103 isEqualToString:@"monitor"],
              v104,
              v105))
        {
          id v106 = v243;
          if (v106 == @"disable"
            || (id v107 = v106) != 0
            && (unsigned int v108 = [(__CFString *)v106 isEqualToString:@"disable"],
                v107,
                v108))
          {
            sub_100102E9C(*(void *)(a1 + 40), *(void **)(a1 + 48));
            goto LABEL_210;
          }
          goto LABEL_208;
        }
        unsigned __int8 v131 = v104;
        if (v131 == @"activation"
          || (BOOL v132 = v131,
              unsigned int v133 = [(__CFString *)v131 isEqualToString:@"activation"],
              v132,
              v133))
        {
          long long v134 = v243;
          if (v134 == @"mockFailure") {
            goto LABEL_127;
          }
          long long v135 = v134;
          if (!v134) {
            goto LABEL_208;
          }
          unsigned int v136 = [(__CFString *)v134 isEqualToString:@"mockFailure"];

          if (v136)
          {
LABEL_127:
            os_signpost_id_t v137 = *(id **)(a1 + 40);
            uint64_t v49 = [v4 objectForKeyedSubscript:@"cid"];
            id v50 = [v4 objectForKeyedSubscript:@"sid"];
            __int16 v61 = [v4 objectForKeyedSubscript:@"attempts"];
            sub_100103050(v137, v49, v50, (uint64_t)[v61 integerValue], *(void **)(a1 + 48));
            goto LABEL_63;
          }
          id v166 = v135;
          if (v166 == @"list"
            || (v167 = v166,
                unsigned int v168 = [(__CFString *)v166 isEqualToString:@"list"],
                v167,
                v168))
          {
            sub_1001020E8(*(void *)(a1 + 40), *(void **)(a1 + 48));
            goto LABEL_58;
          }
          id v180 = v167;
          if (v180 == @"get"
            || (uint64_t v181 = v180,
                unsigned int v182 = [(__CFString *)v180 isEqualToString:@"get"],
                v181,
                v182))
          {
            long long v183 = *(void **)(a1 + 40);
            uint64_t v55 = [v4 objectForKeyedSubscript:@"sid"];
            sub_1001031B8(v183, v55, *(void **)(a1 + 48));
            goto LABEL_57;
          }
          long long v194 = v181;
          uint64_t v21 = v243;
          if (v194 == @"enter"
            || (long long v195 = v194,
                unsigned int v196 = [(__CFString *)v194 isEqualToString:@"enter"],
                v195,
                v196))
          {
            long long v197 = *(void **)(a1 + 40);
            uint64_t v49 = [v4 objectForKeyedSubscript:@"sid"];
            id v50 = [v4 objectForKeyedSubscript:@"code"];
            sub_10010329C(v197, v49, v50, *(void **)(a1 + 48));
            goto LABEL_64;
          }
        }
        else
        {
          long long v156 = v132;
          if (v156 == @"coms"
            || (id v157 = v156,
                unsigned int v158 = [(__CFString *)v156 isEqualToString:@"coms"],
                v157,
                v158))
          {
            id v159 = v243;
            if (v159 == @"entitlementChange"
              || (id v160 = v159) != 0
              && (unsigned int v161 = [(__CFString *)v159 isEqualToString:@"entitlementChange"], v160, v161))
            {
              sub_1001033B0(*(void *)(a1 + 40), v12, *(void **)(a1 + 48));
              goto LABEL_210;
            }
            goto LABEL_208;
          }
          id v173 = v157;
          if (v173 == @"ltpk"
            || (id v174 = v173,
                unsigned int v175 = [(__CFString *)v173 isEqualToString:@"ltpk"],
                v174,
                v175))
          {
            id v176 = v243;
            if (v176 == @"create") {
              goto LABEL_167;
            }
            uint64_t v177 = v176;
            uint64_t v21 = v243;
            if (!v176) {
              goto LABEL_208;
            }
            unsigned int v178 = [(__CFString *)v176 isEqualToString:@"create"];

            if (v178)
            {
LABEL_167:
              uint64_t v179 = *(void *)(a1 + 40);
              uint64_t v55 = [v4 objectForKeyedSubscript:@"groupId"];
              sub_1001034AC(v179, v55, *(void **)(a1 + 48));
              goto LABEL_57;
            }
            long long v190 = v177;
            if (v190 == @"list"
              || (long long v191 = v190,
                  unsigned int v192 = [(__CFString *)v190 isEqualToString:@"list"],
                  v191,
                  v192))
            {
              uint64_t v193 = *(void *)(a1 + 40);
              uint64_t v55 = [v4 objectForKeyedSubscript:@"groupId"];
              id v56 = [v4 objectForKeyedSubscript:@"keyId"];
              sub_100103598(v193, v55, v56, *(void **)(a1 + 48));
              goto LABEL_56;
            }
            long long v207 = v191;
            if (v207 != @"encrypt")
            {
              v208 = v207;
              unsigned int v209 = [(__CFString *)v207 isEqualToString:@"encrypt"];

              if (!v209)
              {
                long long v216 = v208;
                if (v216 == @"decrypt"
                  || (uint64_t v217 = v216,
                      unsigned int v218 = [(__CFString *)v216 isEqualToString:@"decrypt"],
                      v217,
                      v218))
                {
                  uint64_t v219 = *(void *)(a1 + 40);
                  uint64_t v55 = [v4 objectForKeyedSubscript:@"data"];
                  id v56 = [v4 objectForKeyedSubscript:@"groupIdentifier"];
                  sub_100103B10(v219, v55, v56, *(void **)(a1 + 48));
                  goto LABEL_56;
                }
                int v224 = v217;
                uint64_t v21 = v243;
                if (v224 == @"invalidate"
                  || (long long v225 = v224,
                      unsigned int v226 = [(__CFString *)v224 isEqualToString:@"invalidate"],
                      v225,
                      v226))
                {
                  sub_100103D2C(*(void *)(a1 + 40), v12, *(void **)(a1 + 48));
                  goto LABEL_210;
                }
                goto LABEL_208;
              }
            }
            uint64_t v210 = *(void *)(a1 + 40);
            uint64_t v55 = [v4 objectForKeyedSubscript:@"scheme"];
            id v56 = [v4 objectForKeyedSubscript:@"key"];
            long long v211 = [v4 objectForKeyedSubscript:@"data"];
            sub_100103944(v210, v55, v56, v211, *(void **)(a1 + 48));
            goto LABEL_189;
          }
        }
LABEL_208:
        uint64_t v235 = *(void *)(a1 + 48);
        (*(void (**)(uint64_t, id))(v235 + 16))(v235, v98);
        goto LABEL_209;
      }
    }
    id v65 = v243;
    if (v65 != @"list")
    {
      id v66 = v65;
      if (v65)
      {
        unsigned int v67 = [(__CFString *)v65 isEqualToString:@"list"];

        if (v67) {
          goto LABEL_70;
        }
        id v89 = v66;
        if (v89 == @"mockPassUpdate"
          || (long long v90 = v89,
              unsigned int v91 = [(__CFString *)v89 isEqualToString:@"mockPassUpdate"],
              v90,
              v91))
        {
          unsigned int v92 = *(id **)(a1 + 40);
          __int16 v238 = [v4 objectForKeyedSubscript:@"status"];
          BOOL v237 = [v4 objectForKeyedSubscript:@"entitlement"];
          uint64_t v241 = [v4 objectForKeyedSubscript:@"add"];
          uint64_t v239 = [v4 objectForKeyedSubscript:@"remove"];
          id v93 = [v4 objectForKeyedSubscript:@"sid"];
          long long v94 = [v4 objectForKeyedSubscript:@"count"];
          id v95 = [v94 integerValue];
          id v96 = [v4 objectForKeyedSubscript:@"name"];
          id v97 = [v4 objectForKeyedSubscript:@"role"];
          __int16 v236 = *(void **)(a1 + 48);
          id v98 = v238;
          sub_100101738(v92, v12, v238, v237, v241 != 0, v239 != 0, v93, (unint64_t)v95, v96, v97, v236);

          uint64_t v21 = v243;
LABEL_209:

          goto LABEL_210;
        }
        id v121 = v90;
        if (v121 == @"listPending"
          || (uint64_t v122 = v121,
              unsigned int v123 = [(__CFString *)v121 isEqualToString:@"listPending"],
              v122,
              v123))
        {
          sub_1001020E8(*(void *)(a1 + 40), *(void **)(a1 + 48));
          goto LABEL_210;
        }
      }
      if (PKEqualObjects())
      {
        sub_100102184(*(id **)(a1 + 40), v12, *(void **)(a1 + 48));
        goto LABEL_210;
      }
      v124 = v66;
      if (v124 != @"check")
      {
        if (!v66) {
          goto LABEL_208;
        }
        uint64_t v125 = v124;
        unsigned int v126 = [(__CFString *)v124 isEqualToString:@"check"];

        if (!v126)
        {
          dispatch_time_t v149 = v125;
          if (v149 == @"exist"
            || (long long v150 = v149,
                unsigned int v151 = [(__CFString *)v149 isEqualToString:@"exist"],
                v150,
                v151))
          {
            sub_1001024C0(*(void *)(a1 + 40), *(void **)(a1 + 48));
            goto LABEL_210;
          }
          id v162 = v150;
          if (v162 == @"set"
            || (unsigned int v163 = v162,
                unsigned int v164 = [(__CFString *)v162 isEqualToString:@"set"],
                v163,
                v164))
          {
            uint64_t v165 = *(void *)(a1 + 40);
            uint64_t v49 = [v4 objectForKeyedSubscript:@"limit"];
            sub_100102568(v165, (uint64_t)v12, (uint64_t)[v49 integerValue], *(void **)(a1 + 48));
            goto LABEL_137;
          }
          goto LABEL_208;
        }
      }
      uint64_t v127 = *(void *)(a1 + 40);
      uint64_t v49 = [v4 objectForKeyedSubscript:@"mid"];
      id v50 = [v4 objectForKeyedSubscript:@"force"];
      sub_1001022F8(v127, v49, v50 != 0, *(void **)(a1 + 48));
      goto LABEL_64;
    }
LABEL_70:
    sub_100101610(*(void **)(a1 + 40), v12, *(void **)(a1 + 48));
    goto LABEL_210;
  }
  id v2 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  v2();
}

void sub_1000FE900(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    id v15 = (void (**)(void, id))v3;
    id v5 = [objc_alloc((Class)NSMutableString) initWithString:@"Tracked Endpoints:\n"];
    id v6 = [*(id *)(a1 + 24) sharingEndpoints];
    long long v16 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id v7 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v17;
      do
      {
        for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v17 != v9) {
            objc_enumerationMutation(v6);
          }
          id v11 = *(void **)(*((void *)&v16 + 1) + 8 * i);
          if ([v11 channelType] == (id)1)
          {
            [v5 appendFormat:@"%@\n", v11];
            uint64_t v12 = *(void **)(a1 + 24);
            unsigned __int8 v13 = [v11 transportIdentifier];
            id v14 = [v12 sharingMessagesForTransportIdentifier:v13];

            if (v14) {
              [v5 appendFormat:@"%@\n", v14];
            }
            [v5 appendString:@"----\n"];
          }
        }
        id v8 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
      }
      while (v8);
    }
    id v4 = v15;
    v15[2](v15, v5);
  }
}

void sub_1000FEAC8(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v11 = a6;
  if (a1)
  {
    id v12 = a3;
    id v13 = a2;
    id v14 = +[PKSharingRelayChannelDescriptor createChannelWithRegion:a5 stateful:a4];
    id v15 = [*(id *)(a1 + 136) handleForDescriptor:v14 queue:*(void *)(a1 + 88)];
    uint64_t v16 = PKSecureElementAccessPassTypeFromString();

    long long v17 = [*(id *)(a1 + 16) sharedWebService];
    long long v18 = +[PKSharingMessageDisplayInformationManager displayInformationForAccessPassType:v16 pass:0 webService:v17];

    long long v19 = [v12 dataUsingEncoding:4];

    id v28 = 0;
    uint64_t v20 = +[PKSharingMessage specializedMessageFromPayload:v19 displayInformation:v18 outError:&v28];
    id v21 = v28;

    if (v21)
    {
      id v22 = +[NSString stringWithFormat:@"Unable to create message from payload: %@", v21];
      v11[2](v11, v22);
    }
    else
    {
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 3221225472;
      v23[2] = sub_100103EBC;
      v23[3] = &unk_100736EA0;
      id v24 = v15;
      id v25 = v20;
      id v26 = v11;
      uint64_t v27 = v16;
      [v24 sendMessage:v25 completion:v23];

      id v22 = v24;
    }
  }
}

void sub_1000FECE8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void (**)(void, void))v9;
  if (a1)
  {
    if (v7)
    {
      id v11 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:v7];
      id v12 = [*(id *)(a1 + 136) handleForDescriptor:v11 queue:*(void *)(a1 + 88)];
      if (v12)
      {
        id v13 = [v8 dataUsingEncoding:4];
        id v22 = 0;
        id v14 = +[PKSharingMessage specializedMessageFromPayload:v13 displayInformation:0 outError:&v22];
        id v15 = v22;

        if (v15)
        {
          uint64_t v16 = +[NSString stringWithFormat:@"Unable to create message from payload: %@", v15];
          ((void (**)(void, void *))v10)[2](v10, v16);
        }
        else
        {
          v18[0] = _NSConcreteStackBlock;
          v18[1] = 3221225472;
          v18[2] = sub_100104078;
          v18[3] = &unk_100736340;
          id v21 = v10;
          id v19 = v7;
          id v20 = v14;
          [v12 sendMessage:v20 completion:v18];

          uint64_t v16 = v21;
        }
      }
      else
      {
        long long v17 = +[NSString stringWithFormat:@"Unable to find active endpoint for %@", v7];
        ((void (**)(void, void *))v10)[2](v10, v17);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Missing mailbox identifier");
    }
  }
}

void sub_1000FEF00(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (void (**)(void, void))v6;
  if (a1)
  {
    if (v5)
    {
      id v8 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:v5];
      id v9 = [*(id *)(a1 + 136) handleForDescriptor:v8 queue:*(void *)(a1 + 88)];
      if (v9)
      {
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 3221225472;
        id v11[2] = sub_10010410C;
        void v11[3] = &unk_100736340;
        id v14 = v7;
        id v12 = v5;
        id v13 = v9;
        [v13 attachWithCompletion:v11];
      }
      else
      {
        uint64_t v10 = +[NSString stringWithFormat:@"Unable to find active endpoint for %@", v5];
        ((void (**)(void, void *))v7)[2](v7, v10);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Missing mailbox identifier");
    }
  }
}

void sub_1000FF068(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (void (**)(void, void))v6;
  if (a1)
  {
    if (v5)
    {
      id v8 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:v5];
      id v9 = [*(id *)(a1 + 136) handleForDescriptor:v8 queue:*(void *)(a1 + 88)];
      if (v9)
      {
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 3221225472;
        id v11[2] = sub_100104288;
        void v11[3] = &unk_100736EF0;
        id v13 = v7;
        id v12 = v5;
        [v9 relinquishWithCompletion:v11];
      }
      else
      {
        uint64_t v10 = +[NSString stringWithFormat:@"Unable to find active endpoint for %@", v5];
        ((void (**)(void, void *))v7)[2](v7, v10);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Missing mailbox identifier");
    }
  }
}

void sub_1000FF1C4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (void (**)(void, void))v6;
  if (a1)
  {
    if (v5)
    {
      id v8 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:v5];
      id v9 = [*(id *)(a1 + 136) handleForDescriptor:v8 queue:*(void *)(a1 + 88)];
      if (v9)
      {
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 3221225472;
        id v11[2] = sub_100104314;
        void v11[3] = &unk_100736F18;
        id v15 = v7;
        id v12 = v5;
        uint64_t v13 = a1;
        id v14 = v9;
        [v14 closeWithCompletion:v11];
      }
      else
      {
        uint64_t v10 = +[NSString stringWithFormat:@"Unable to find active endpoint for %@", v5];
        ((void (**)(void, void *))v7)[2](v7, v10);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Missing mailbox identifier");
    }
  }
}

void sub_1000FF32C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = [objc_alloc((Class)NSMutableString) initWithString:@"Deleting Endpoints:\n"];
    id v5 = [*(id *)(a1 + 24) sharingEndpoints];
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    id v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v13;
      do
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v13 != v8) {
            objc_enumerationMutation(v5);
          }
          uint64_t v10 = *(void **)(*((void *)&v12 + 1) + 8 * i);
          [v4 appendFormat:@"%@\n", v10];
          id v11 = [v10 transportIdentifier];
          sub_1000FF1C4(a1, v11, &stru_100736F58);
        }
        id v7 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v7);
    }
    v3[2](v3, v4);
  }
}

void sub_1000FF4B4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    long long v18 = (void (**)(void, id))v3;
    id v5 = [objc_alloc((Class)NSMutableString) initWithString:@"Messages On Endpoints:\n"];
    [*(id *)(a1 + 24) sharingEndpoints];
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id obj = (id)objc_claimAutoreleasedReturnValue();
    id v6 = [obj countByEnumeratingWithState:&v24 objects:v29 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v25;
      do
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v25 != v8) {
            objc_enumerationMutation(obj);
          }
          uint64_t v10 = *(void **)(*((void *)&v24 + 1) + 8 * i);
          [v5 appendFormat:@"%@\n==================\n", v10];
          long long v22 = 0u;
          long long v23 = 0u;
          long long v20 = 0u;
          long long v21 = 0u;
          id v11 = *(void **)(a1 + 24);
          long long v12 = [v10 transportIdentifier];
          long long v13 = [v11 sharingMessagesForTransportIdentifier:v12];

          id v14 = [v13 countByEnumeratingWithState:&v20 objects:v28 count:16];
          if (v14)
          {
            id v15 = v14;
            uint64_t v16 = *(void *)v21;
            do
            {
              for (uint64_t j = 0; j != v15; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v21 != v16) {
                  objc_enumerationMutation(v13);
                }
                [v5 appendFormat:@"\t%@\n", *(void *)(*((void *)&v20 + 1) + 8 * (void)j)];
              }
              id v15 = [v13 countByEnumeratingWithState:&v20 objects:v28 count:16];
            }
            while (v15);
          }

          [v5 appendString:@"\n\n"];
        }
        id v7 = [obj countByEnumeratingWithState:&v24 objects:v29 count:16];
      }
      while (v7);
    }
    id v4 = v18;
    v18[2](v18, v5);
  }
}

void sub_1000FF6EC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    if (v5)
    {
      id v8 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:v5];
      id v9 = [*(id *)(a1 + 136) handleForDescriptor:v8 queue:*(void *)(a1 + 88)];
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472;
      v10[2] = sub_1001043D8;
      v10[3] = &unk_100736EF0;
      id v12 = v7;
      id v11 = v5;
      [v9 pingWithCompletion:v10];
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Missing mailbox identifier");
    }
  }
}

void sub_1000FF800(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (a1)
  {
    uint64_t v5 = PKSharingRelayServerEnvironmentFromString();
    id v6 = PKSharingRelayServerPushTopicForEnvironment();
    id v7 = objc_alloc_init((Class)NSUUID);
    id v8 = [v7 UUIDString];

    id v9 = *(void **)(a1 + 48);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    id v11[2] = sub_100104468;
    void v11[3] = &unk_100736F80;
    uint64_t v14 = v5;
    id v12 = v6;
    id v13 = v4;
    id v10 = v6;
    [v9 generateSingleUsePushTokenForTopic:v10 identifier:v8 completion:v11];
  }
}

void sub_1000FF910(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = [*(id *)(a1 + 136) idsService];
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    _DWORD v5[2] = sub_1001045FC;
    v5[3] = &unk_100736918;
    id v6 = v3;
    [v4 devicesWithCompletion:v5];
  }
}

void sub_1000FF9BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    id v15 = (void (**)(void, id))v3;
    id v5 = [objc_alloc((Class)NSMutableString) initWithString:@"Tracked Endpoints:\n"];
    id v6 = [*(id *)(a1 + 24) sharingEndpoints];
    long long v16 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id v7 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v17;
      do
      {
        for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v17 != v9) {
            objc_enumerationMutation(v6);
          }
          id v11 = *(void **)(*((void *)&v16 + 1) + 8 * i);
          if ([v11 channelType] == (id)2)
          {
            [v5 appendFormat:@"%@\n", v11];
            id v12 = *(void **)(a1 + 24);
            id v13 = [v11 transportIdentifier];
            uint64_t v14 = [v12 sharingMessagesForTransportIdentifier:v13];

            if (v14) {
              [v5 appendFormat:@"%@\n", v14];
            }
            [v5 appendString:@"----\n"];
          }
        }
        id v8 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
      }
      while (v8);
    }
    id v4 = v15;
    v15[2](v15, v5);
  }
}

void sub_1000FFB84(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(void, void))v12;
  if (a1)
  {
    if (v9)
    {
      id v14 = objc_alloc((Class)PKSharingIDSChannelDescriptor);
      id v15 = v14;
      if (v10)
      {
        id v16 = [v14 initWithSessionIdentifier:v10 deviceIdentifier:v9];
      }
      else
      {
        id v17 = objc_alloc_init((Class)NSUUID);
        long long v18 = [v17 UUIDString];
        id v16 = [v15 initWithSessionIdentifier:v18 deviceIdentifier:v9];
      }
      long long v19 = [*(id *)(a1 + 136) handleForDescriptor:v16 queue:*(void *)(a1 + 88)];
      if (v19)
      {
        long long v20 = [v11 dataUsingEncoding:4];
        id v29 = 0;
        long long v21 = +[PKSharingMessage specializedMessageFromPayload:v20 displayInformation:0 outError:&v29];
        id v22 = v29;

        if (v22)
        {
          long long v23 = +[NSString stringWithFormat:@"Unable to create message from payload: %@", v22];
          ((void (**)(void, void *))v13)[2](v13, v23);
        }
        else
        {
          v25[0] = _NSConcreteStackBlock;
          v25[1] = 3221225472;
          v25[2] = sub_100104790;
          v25[3] = &unk_100736340;
          id v28 = v13;
          id v26 = v9;
          id v27 = v21;
          [v19 sendMessage:v27 completion:v25];

          long long v23 = v28;
        }
      }
      else
      {
        long long v24 = +[NSString stringWithFormat:@"Unable to create handle for %@", v9];
        ((void (**)(void, void *))v13)[2](v13, v24);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v12 + 2))(v12, @"Missing device identifier");
    }
  }
}

void sub_1000FFE04(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(void, void))v9;
  if (a1)
  {
    if (v7)
    {
      id v11 = +[PKSharingIDSChannelDescriptor existingForSessionIdentifier:v7];
      id v12 = [*(id *)(a1 + 136) handleForDescriptor:v11 queue:*(void *)(a1 + 88)];
      if (v12)
      {
        if (v8) {
          double v13 = (double)(uint64_t)[v8 integerValue];
        }
        else {
          double v13 = 30.0;
        }
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 3221225472;
        v18[2] = sub_100104824;
        v18[3] = &unk_100736FA8;
        long long v19 = v10;
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472;
        void v15[2] = sub_1001048D4;
        v15[3] = &unk_100731C90;
        id v17 = v19;
        id v16 = v12;
        [v16 waitForMessageWithTimeout:v18 messageHandler:v15 invalidationHandler:v13];
      }
      else
      {
        id v14 = +[NSString stringWithFormat:@"Unable to create handle for %@", v7];
        ((void (**)(void, void *))v10)[2](v10, v14);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Missing session identifier");
    }
  }
}

void sub_1000FFFE0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (void (**)(void, void))v6;
  if (a1)
  {
    if (v5)
    {
      id v8 = +[PKSharingIDSChannelDescriptor existingForSessionIdentifier:v5];
      id v9 = [*(id *)(a1 + 136) handleForDescriptor:v8 queue:*(void *)(a1 + 88)];
      id v10 = v9;
      if (v9)
      {
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3221225472;
        id v12[2] = sub_1001048FC;
        void v12[3] = &unk_1007305A0;
        id v13 = v9;
        id v14 = v7;
        [v13 closeWithCompletion:v12];
      }
      else
      {
        id v11 = +[NSString stringWithFormat:@"Unable to create handle for %@", v5];
        ((void (**)(void, void *))v7)[2](v7, v11);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Missing session identifier");
    }
  }
}

void sub_100100140(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = v9;
  if (a1)
  {
    if (v7 && v8)
    {
      id v11 = *(NSObject **)(a1 + 88);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100104994;
      block[3] = &unk_10072E9D8;
      id v13 = v7;
      uint64_t v14 = a1;
      id v15 = v10;
      dispatch_async(v11, block);
    }
    else
    {
      (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Missing mailbox identifier or key");
    }
  }
}

void sub_100100240(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    if (v5)
    {
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      v8[2] = sub_100104B08;
      v8[3] = &unk_1007304D8;
      id v9 = v6;
      [a1 prewarmCreateShareForPassIdentifier:v5 completion:v8];
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Missing pid parameter");
    }
  }
}

void sub_100100314(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = (void (**)(void, void))v12;
  if (a1)
  {
    if (v9)
    {
      id v14 = objc_alloc_init((Class)PKPassShare);
      if (v11)
      {
        id v30 = v11;
        id v15 = objc_msgSend(objc_alloc((Class)PKPassSharedEntitlement), "initWithCarKeyEntitlementValue:", objc_msgSend(v11, "integerValue"));
        id v41 = v15;
        id v16 = +[NSArray arrayWithObjects:&v41 count:1];
        [v14 setSharedEntitlements:v16];
      }
      else
      {
        id v15 = [*(id *)(a1 + 24) passSharesForPassUniqueIdentifier:v9];
        if (![v15 count])
        {
          ((void (**)(void, const __CFString *))v13)[2](v13, @"Unable to create mock share because pass doesn't have any shares");

LABEL_12:
          goto LABEL_13;
        }
        id v30 = 0;
        id v16 = [v15 firstObject];
        id v17 = [v16 sharedEntitlements];
        [v14 setSharedEntitlements:v17];
      }
      [v14 setStatus:2];
      if (v10) {
        CFStringRef v18 = v10;
      }
      else {
        CFStringRef v18 = @"Alex";
      }
      [v14 setRecipientNickname:v18];
      id v19 = objc_alloc_init((Class)NSUUID);
      long long v20 = [v19 UUIDString];
      [v14 setIdentifier:v20];

      v35[0] = _NSConcreteStackBlock;
      v35[1] = 3221225472;
      v35[2] = sub_100104B90;
      v35[3] = &unk_100737020;
      void v35[4] = a1;
      id v36 = v9;
      id v37 = v14;
      long long v21 = v13;
      id v38 = v21;
      id v22 = objc_retainBlock(v35);
      id v23 = objc_alloc_init((Class)LAContext);
      v39[0] = &off_10078AB18;
      long long v24 = PKLocalizedShareableCredentialString(@"LOCAL_AUTHENTICATION_REASON");
      v40[0] = v24;
      v39[1] = &off_10078AB30;
      PKLocalizedString(@"WALLET");
      id v26 = v25 = v10;
      v39[2] = &off_10078AB48;
      v40[1] = v26;
      v40[2] = &__kCFBooleanTrue;
      id v27 = +[NSDictionary dictionaryWithObjects:v40 forKeys:v39 count:3];

      v31[0] = _NSConcreteStackBlock;
      v31[1] = 3221225472;
      v31[2] = sub_100104D70;
      v31[3] = &unk_100737048;
      id v32 = v23;
      unsigned int v33 = v21;
      id v34 = v22;
      id v28 = v22;
      id v29 = v23;
      [v29 evaluatePolicy:2 options:v27 reply:v31];

      id v10 = v25;
      id v11 = v30;
      goto LABEL_12;
    }
    (*((void (**)(id, const __CFString *))v12 + 2))(v12, @"Missing pid parameter");
  }
LABEL_13:
}

void sub_1001006E0(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    id v6 = [*(id *)(a1 + 24) passWithUniqueIdentifier:a2];
    id v7 = [v6 secureElementPass];

    if (v7)
    {
      id v8 = objc_alloc_init((Class)PKPassCredentialShare);
      [v8 setTargetDevice:1];
      id v9 = objc_alloc_init(PDCreateShareContext);
      id v10 = sub_100104E38();
      [(PDCreateShareContext *)v9 addInvite:v10 primary:1];

      id v11 = sub_100104E38();
      [(PDCreateShareContext *)v9 addInvite:v11 forCredentialShare:v8 primary:0];

      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_100104F70;
      v13[3] = &unk_100736FF8;
      id v14 = v9;
      id v15 = v5;
      id v12 = v9;
      sub_1000F1150(a1, v12, v7, 0, v13);
    }
    else
    {
      (*((void (**)(id, const __CFString *))v5 + 2))(v5, @"Unable to find pass");
    }
  }
}

void sub_100100864(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(void, void))v9;
  if (a1)
  {
    if (v7 && v8)
    {
      id v11 = [a1[3] passShareForPassUniqueIdentifier:v7 shareIdentifier:v8];
      if (v11)
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_100105038;
        v13[3] = &unk_100736340;
        id v16 = v10;
        id v14 = v7;
        id v15 = v11;
        [a1 updateShareForPassIdentifier:v14 share:v15 authorization:0 completion:v13];
      }
      else
      {
        id v12 = +[NSString stringWithFormat:@"Unable to find share for shareIdentifier %@", v8];
        ((void (**)(void, void *))v10)[2](v10, v12);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Missing required parameter");
    }
  }
}

void sub_1001009DC(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(void, void))v9;
  if (a1)
  {
    if (v7 && v8)
    {
      id v11 = [a1[3] passShareForPassUniqueIdentifier:v7 shareIdentifier:v8];
      if (v11)
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_1001050C4;
        v13[3] = &unk_100736EF0;
        id v15 = v10;
        id v14 = v8;
        [a1 revokeShareForPassIdentifier:v7 share:v11 shouldCascade:0 completion:v13];
      }
      else
      {
        id v12 = +[NSString stringWithFormat:@"Unable to find share for shareIdentifier %@", v8];
        ((void (**)(void, void *))v10)[2](v10, v12);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Missing required parameter");
    }
  }
}

void sub_100100B40(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a3;
  id v10 = a5;
  if (a1)
  {
    id v11 = [a2 dataUsingEncoding:4];
    id v18 = 0;
    id v12 = +[PKSharingMessage specializedMessageFromPayload:v11 displayInformation:0 outError:&v18];
    id v13 = v18;

    if (v13 || !v12)
    {
      v10[2](v10, @"Unable to create message from payload");
    }
    else
    {
      id v14 = [objc_alloc((Class)PKSharingMessageDisplayInformation) initWithTitle:v9 subtitle:&stru_10075AAD8 imageURL:0];
      [v12 setDisplayInformation:v14];

      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      void v15[2] = sub_100105150;
      v15[3] = &unk_100737070;
      id v17 = v10;
      id v16 = v12;
      [a1 createSingleUseShareURLWithMessage:v16 timeToLive:a4 completion:v15];
    }
  }
}

void sub_100100CCC(id *a1, void *a2, int a3, int a4, void *a5, void *a6, void *a7)
{
  id v13 = a2;
  id v14 = a5;
  id v15 = a6;
  id v16 = a7;
  if (a1)
  {
    uint64_t v17 = PKSharingMailboxIdentifierForAddress();
    id v18 = (void *)v17;
    if (v13 && v17)
    {
      unsigned int v33 = v15;
      id v19 = [a1[2] sharedWebService];
      id v32 = [v19 targetDevice];

      id v20 = +[PKPassShare createTaggedShare];
      if (v14)
      {
        int v30 = a4;
        id v21 = [objc_alloc((Class)PKPassShareActivationOption) initWithIdentifier:@"activationCode" type:1];
        [v21 setValue:v14];
        id v22 = objc_alloc((Class)PKPassShareActivationOptions);
        id v47 = v21;
        id v23 = +[NSArray arrayWithObjects:&v47 count:1];
        id v24 = [v22 initWithOptions:v23];
        [v20 setActivationOptions:v24];

        a4 = v30;
      }
      id v31 = v14;
      if (!a3 || a4)
      {
        v37[0] = _NSConcreteStackBlock;
        v37[1] = 3221225472;
        v37[2] = sub_1001051C8;
        v37[3] = &unk_1007370C0;
        id v44 = v16;
        char v45 = a3;
        id v38 = v18;
        long long v25 = v20;
        id v39 = v20;
        id v40 = v13;
        id v15 = v33;
        id v41 = v33;
        id v29 = v32;
        id v42 = v32;
        id v43 = a1;
        [a1 retrieveShareInvitationForMailboxAddress:v40 completion:v37];

        id v28 = v44;
      }
      else
      {
        long long v25 = v20;
        id v26 = [objc_alloc((Class)PKPendingStatefulTransferProvisioningReference) initWithInvitationURL:v13 share:v20];
        [v26 setShouldAutoProvision:1];
        id v15 = v33;
        [v26 setAccountAttestationAnonymizationSalt:v33];
        id v46 = v26;
        id v27 = +[NSArray arrayWithObjects:&v46 count:1];
        v34[0] = _NSConcreteStackBlock;
        v34[1] = 3221225472;
        v34[2] = sub_100105514;
        v34[3] = &unk_100731538;
        id v35 = v26;
        id v36 = v16;
        id v28 = v26;
        id v29 = v32;
        [v32 addPendingProvisionings:v27 completion:v34];
      }
      id v14 = v31;
    }
    else
    {
      (*((void (**)(id, const __CFString *))v16 + 2))(v16, @"Missing -url parameter");
    }
  }
}

void sub_10010103C(void *a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    id v5 = a3;
    [a1 rejectShareForMailboxAddress:a2];
    v5[2](v5, @"Rejecting share url");
  }
}

void sub_1001010B0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    if (v5)
    {
      uint64_t v8 = PKPassCredentialShareTargetDeviceFromString();
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_1001055D4;
      v9[3] = &unk_1007370E8;
      id v11 = v7;
      id v10 = v5;
      sub_1000EEFF0(a1, v8, v9);
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"deviceType parameter missing. Possible: phone|watch");
    }
  }
}

void sub_1001011A0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id v16 = (void (**)(void, void))v15;
  if (a1)
  {
    if (v11 && v12 && v13)
    {
      id v17 = +[PKSharingIDSChannelDescriptor createWithDeviceIdentifier:v11];
      id v18 = [*(id *)(a1 + 136) handleForDescriptor:v17 queue:*(void *)(a1 + 88)];
      if (v18)
      {
        id v19 = [objc_alloc((Class)PKSharingInvitationRequestMessage) initWithPassTypeIdentifier:v12 passSerialNumber:v13 personalizedVehicleIdentifier:v14];
        v20[0] = _NSConcreteStackBlock;
        v20[1] = 3221225472;
        void v20[2] = sub_1001056B8;
        v20[3] = &unk_100736EF0;
        id v22 = v16;
        id v21 = v18;
        [v21 sendMessage:v19 completion:v20];
      }
      else
      {
        id v19 = +[NSString stringWithFormat:@"Unable to create handle for %@", v11];
        ((void (**)(void, id))v16)[2](v16, v19);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v15 + 2))(v15, @"Missing required parameters");
    }
  }
}

void sub_10010135C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = (void (**)(void, void))v6;
  if (a1)
  {
    if (v5)
    {
      uint64_t v8 = [*(id *)(a1 + 24) passWithUniqueIdentifier:v5];
      id v9 = [v8 secureElementPass];

      if (v9)
      {
        if ([v9 isCarKeyPass])
        {
          id v10 = [v9 devicePrimaryPaymentApplication];
          id v11 = [v10 subcredentials];
          id v12 = [v11 anyObject];

          id v13 = [v12 originatorIDSHandle];
          if (v13)
          {
            id v14 = [v12 sharingSessionIdentifier];
            id v15 = [v14 UUIDString];

            if (v15)
            {
              id v16 = +[PKSharingIDSChannelDescriptor createWithRemoteAddress:v13];
              id v17 = [*(id *)(a1 + 136) handleForDescriptor:v16 queue:*(void *)(a1 + 88)];
              if (v17)
              {
                id v18 = [objc_alloc((Class)PKSharingExternalInvitationRequestMessage) initWithSharingSessionIdentifier:v15];
                v19[0] = _NSConcreteStackBlock;
                v19[1] = 3221225472;
                void v19[2] = sub_100105938;
                v19[3] = &unk_100736EF0;
                id v21 = v7;
                id v20 = v17;
                [v20 sendMessage:v18 completion:v19];
              }
              else
              {
                id v18 = +[NSString stringWithFormat:@"Unable to create handle for %@", v13];
                ((void (**)(void, id))v7)[2](v7, v18);
              }
            }
            else
            {
              ((void (**)(void, const __CFString *))v7)[2](v7, @"Unable to find sharing session identifier for subcredential");
            }
          }
          else
          {
            id v15 = [objc_alloc((Class)NSString) initWithFormat:@"Unable to convert raw destination '%@' into IDS destination", 0];
            ((void (**)(void, id))v7)[2](v7, v15);
          }
        }
        else
        {
          ((void (**)(void, const __CFString *))v7)[2](v7, @"Pass isn't a car key pass");
        }
      }
      else
      {
        ((void (**)(void, const __CFString *))v7)[2](v7, @"Unable to find pass for pass unique ID");
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Missing required pass unique ID parameter");
    }
  }
}

void sub_100101610(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    if (v5)
    {
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_100105B78;
      v9[3] = &unk_100737110;
      id v10 = [objc_alloc((Class)NSMutableString) initWithFormat:@"Shares for %@:\n", v5];
      id v11 = a1;
      id v12 = v5;
      id v13 = v7;
      id v8 = v10;
      [a1 displayableSharesForPassIdentifier:v12 completion:v9];
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Missing pid parameter");
    }
  }
}

void sub_100101738(id *a1, void *a2, void *a3, void *a4, int a5, int a6, void *a7, unint64_t a8, void *a9, void *a10, void *a11)
{
  id v16 = a2;
  id v17 = a3;
  id v108 = a4;
  id v18 = a7;
  id v19 = a9;
  id v20 = a10;
  id v21 = a11;
  id v22 = (void (**)(void, void))v21;
  if (a1)
  {
    if (a8 <= 1) {
      unint64_t v23 = 1;
    }
    else {
      unint64_t v23 = a8;
    }
    if (v16)
    {
      id v24 = [a1[3] passWithUniqueIdentifier:v16];
      uint64_t v25 = [v24 secureElementPass];

      unsigned int v105 = (void *)v25;
      if (!v25)
      {
        ((void (**)(void, const __CFString *))v22)[2](v22, @"Unable to find pass");
        char v45 = 0;
LABEL_89:

        goto LABEL_90;
      }
      id v96 = a1;
      id v26 = [a1[3] passSharesForPassUniqueIdentifier:v16];
      id v27 = v26;
      if (!v26)
      {
        id v46 = +[NSString stringWithFormat:@"Unable to find shares for pas %@. Pass must have at least one share to mock an update.", v16];
        ((void (**)(void, void *))v22)[2](v22, v46);

        char v45 = v105;
LABEL_88:

        goto LABEL_89;
      }
      long long v94 = v22;
      CFStringRef v95 = v20;
      id v109 = v19;
      id v106 = v18;
      id v97 = v16;
      id v28 = [v26 mutableCopy];
      id v29 = [v27 firstObject];
      id v30 = [v29 copy];

      id v107 = v27;
      id v31 = v108;
      if (v17)
      {
        id v32 = [v28 count];
        if (v106)
        {
          if (v32)
          {
            unint64_t v33 = 0;
            id v99 = v30;
            id v101 = v17;
            while (1)
            {
              id v34 = [v28 objectAtIndexedSubscript:v33];
              id v35 = [v28 objectAtIndexedSubscript:v33];
              id v36 = [v35 identifier];
              id v37 = v106;
              id v38 = v37;
              if (v36 == v37)
              {
                id v40 = v37;
                id v36 = v37;
                goto LABEL_63;
              }
              if (v36)
              {
                unsigned __int8 v39 = [v36 isEqualToString:v37];

                if (v39) {
                  goto LABEL_64;
                }
              }
              else
              {
              }
              id v40 = [v28 objectAtIndexedSubscript:v33];
              id v41 = [v40 recipientNickname];
              id v42 = v38;
              id v43 = v42;
              if (v41 == v42) {
                break;
              }
              if (v41)
              {
                id v44 = [v41 caseInsensitiveCompare:v42];

                id v27 = v107;
                if (!v44) {
                  goto LABEL_65;
                }
              }
              else
              {

                id v27 = v107;
              }

              ++v33;
              id v30 = v99;
              id v17 = v101;
              id v31 = v108;
              if (v33 >= (unint64_t)[v28 count]) {
                goto LABEL_31;
              }
            }

LABEL_63:
            id v27 = v107;
LABEL_64:

LABEL_65:
            id v80 = [v34 copy];
            id v17 = v101;
            [v80 setStatus:PKShareStatusFromString()];
            [v28 replaceObjectAtIndex:v33 withObject:v80];

            id v31 = v108;
            id v30 = v99;
            if (!v108) {
              goto LABEL_72;
            }
LABEL_32:
            id v51 = [v31 integerValue];
            id v52 = v31;
            id v18 = v106;
            id v20 = (__CFString *)v95;
            if (v51
              || (uint64_t v71 = v52, v71 == @"0")
              || (id v72 = v71,
                  unsigned int v73 = [(__CFString *)v71 isEqualToString:@"0"],
                  v72,
                  v73))
            {
              id v53 = objc_alloc((Class)PKPassSharedEntitlement);
              v114[0] = @"accessProfile";
              uint64_t v54 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v52 integerValue]);
              v114[1] = @"accountRole";
              v115[0] = v54;
              CFStringRef v55 = @"0000";
              if (v95) {
                CFStringRef v55 = v95;
              }
              v115[1] = v55;
              id v56 = +[NSDictionary dictionaryWithObjects:v115 forKeys:v114 count:2];
              id v98 = [v53 initWithSubcredentialDictionary:v56];
            }
            else
            {
              uint64_t v74 = [v96[3] passEntitlementForIdentifier:v72 passIdentifier:v97];
              id v22 = v94;
              if (!v74)
              {
                id v93 = +[NSString stringWithFormat:@"Unable to find entitlement on pass for entitlementIdentifier: '%@'", v72];
                ((void (**)(void, void *))v94)[2](v94, v93);

                char v45 = v105;
LABEL_87:

                id v16 = v97;
                id v19 = v109;
                goto LABEL_88;
              }
              uint64_t v54 = (void *)v74;
              id v98 = [objc_alloc((Class)PKPassSharedEntitlement) initWithEntitlement:v74];
            }

            id v100 = v30;
            id v102 = v17;
            id v57 = [v28 count];
            if (v106)
            {
              id v58 = v98;
              if (v57)
              {
                unint64_t v59 = 0;
                while (1)
                {
                  uint64_t v60 = [v28 objectAtIndexedSubscript:v59];
                  __int16 v61 = [v28 objectAtIndexedSubscript:v59];
                  id v62 = [v61 identifier];
                  id v63 = v106;
                  unsigned int v64 = v63;
                  if (v62 == v63)
                  {
                    id v66 = v63;
                    id v62 = v63;
                    goto LABEL_68;
                  }
                  if (v62)
                  {
                    unsigned __int8 v65 = [v62 isEqualToString:v63];

                    if (v65) {
                      goto LABEL_69;
                    }
                  }
                  else
                  {
                  }
                  id v66 = [v28 objectAtIndexedSubscript:v59];
                  id v67 = [v66 recipientNickname];
                  id v68 = v64;
                  id v69 = v68;
                  if (v67 == v68) {
                    break;
                  }
                  if (v67)
                  {
                    id v70 = [v67 caseInsensitiveCompare:v68];

                    if (!v70) {
                      goto LABEL_70;
                    }
                  }
                  else
                  {
                  }
                  ++v59;
                  id v58 = v98;
                  if (v59 >= (unint64_t)[v28 count]) {
                    goto LABEL_71;
                  }
                }

LABEL_68:
LABEL_69:

LABEL_70:
                id v81 = [v60 copy];
                id v58 = v98;
                id v113 = v98;
                unsigned int v82 = +[NSArray arrayWithObjects:&v113 count:1];
                [v81 setSharedEntitlements:v82];

                [v28 replaceObjectAtIndex:v59 withObject:v81];
              }
            }
            else
            {
              id v75 = (char *)v23;
              id v58 = v98;
              if (v23 < (unint64_t)v57 || (id v75 = (char *)[v28 count]) != 0)
              {
                for (uint64_t i = 0; i != v75; ++i)
                {
                  unsigned int v77 = [v28 objectAtIndexedSubscript:i];
                  id v78 = [v77 copy];

                  id v112 = v98;
                  uint64_t v79 = +[NSArray arrayWithObjects:&v112 count:1];
                  [v78 setSharedEntitlements:v79];

                  [v28 replaceObjectAtIndex:i withObject:v78];
                }
              }
            }
LABEL_71:

            id v30 = v100;
            id v17 = v102;
LABEL_72:
            id v18 = v106;
            if (a5)
            {
              unint64_t v83 = v23;
              do
              {
                id v84 = [v30 copy];
                [v84 setStatus:1];
                id v85 = objc_alloc_init((Class)NSUUID);
                id v86 = [v85 UUIDString];
                [v84 setIdentifier:v86];

                if (v109) {
                  objc_msgSend(v84, "setRecipientNickname:");
                }
                [v28 addObject:v84];

                --v83;
              }
              while (v83);
            }
            if (a6)
            {
              do
              {
                if (v106)
                {
                  v110[0] = _NSConcreteStackBlock;
                  v110[1] = 3221225472;
                  v110[2] = sub_100105D04;
                  v110[3] = &unk_100737138;
                  id v111 = v106;
                  unsigned int v87 = objc_msgSend(v28, "pk_objectsPassingTest:", v110);
                  id v88 = [v87 mutableCopy];

                  id v28 = v88;
                }
                else
                {
                  if (!v17)
                  {
                    id v89 = v28;
                    uint64_t v90 = 0;
                    goto LABEL_84;
                  }
                  if ((unint64_t)[v107 count] >= 2)
                  {
                    id v89 = v28;
                    uint64_t v90 = 1;
LABEL_84:
                    [v89 removeObjectAtIndex:v90];
                  }
                }
                --v23;
              }
              while (v23);
            }
            [v96[3] updatePassSharesForPassUniqueIdentifier:v97 passShares:v28];
            id WeakRetained = objc_loadWeakRetained(v96 + 10);
            [WeakRetained sharesDidUpdateWithPaymentPassWithUniqueIdentifier:v97];

            char v45 = v105;
            id v27 = v107;
            [v96 passUpdated:v105 oldShares:v107];
            unsigned int v92 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Set %lu shares on pass %@", [v28 count], v97);
            id v22 = v94;
            ((void (**)(void, void *))v94)[2](v94, v92);

            id v20 = (__CFString *)v95;
            goto LABEL_87;
          }
        }
        else
        {
          id v47 = (char *)v23;
          if (v23 < (unint64_t)v32 || (id v47 = (char *)[v28 count]) != 0)
          {
            for (uint64_t j = 0; j != v47; ++j)
            {
              uint64_t v49 = [v28 objectAtIndexedSubscript:j];
              id v50 = [v49 copy];

              [v50 setStatus:PKShareStatusFromString()];
              [v28 replaceObjectAtIndex:j withObject:v50];
            }
          }
        }
      }
LABEL_31:
      if (!v31) {
        goto LABEL_72;
      }
      goto LABEL_32;
    }
    (*((void (**)(id, const __CFString *))v21 + 2))(v21, @"Missing pass unique ID");
  }
LABEL_90:
}

void sub_1001020E8(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v2 = *(void **)(a1 + 24);
    id v3 = a2;
    id v5 = [v2 passSharesWithNoPass];
    id v4 = +[NSString stringWithFormat:@"Pending Activations:\n\n %@ \n", v5];
    v3[2](v3, v4);
  }
}

void sub_100102184(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = a1[3];
    if (v5)
    {
      id v8 = [v7 passWithUniqueIdentifier:v5];
      id v9 = [v8 secureElementPass];

      if (!v9)
      {
        v6[2](v6, @"Unable to find pass");
        goto LABEL_8;
      }
      id v10 = [a1[3] passSharesForPassUniqueIdentifier:v5];
    }
    else
    {
      id v10 = [v7 passSharesWithNoPass];
      id v9 = 0;
    }
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_100105D88;
    v13[3] = &unk_100737160;
    id v14 = v10;
    id v15 = a1;
    id v16 = v5;
    id v17 = v9;
    id v18 = v6;
    id v11 = v9;
    id v12 = v10;
    [a1 revokeSharesForPassIdentifier:v16 shares:v12 shouldCascade:0 completion:v13];
  }
LABEL_8:
}

void sub_1001022F8(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  if (a1)
  {
    if (v7)
    {
      id v9 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:v7];
      id v10 = [*(id *)(a1 + 136) handleForDescriptor:v9 queue:*(void *)(a1 + 88)];
      if (v10)
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_100105ECC;
        v13[3] = &unk_100736340;
        id v16 = v8;
        id v14 = v7;
        id v15 = v10;
        [v15 attachWithCompletion:v13];
      }
      else
      {
        id v12 = +[NSString stringWithFormat:@"Unable to find active endpoint for %@", v7];
        (*((void (**)(id, void *))v8 + 2))(v8, v12);
      }
    }
    else
    {
      id v11 = [*(id *)(a1 + 136) monitor];
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472;
      void v17[2] = sub_100105EB4;
      v17[3] = &unk_10072F788;
      id v18 = v8;
      [v11 checkForNewSharingMessagesWithShouldCheckAllEndpoint:a3 completion:v17];

      id v9 = v18;
    }
  }
}

void sub_1001024C0(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v2 = *(void **)(a1 + 24);
    id v3 = a2;
    LODWORD(v2) = [v2 activeExternalPassSharesExist];
    id v4 = objc_alloc((Class)NSString);
    CFStringRef v5 = @"No";
    if (v2) {
      CFStringRef v5 = @"Yes";
    }
    id v6 = [v4 initWithFormat:@"\nDo active shares exist: %@\n", v5];
    v3[2](v3, v6);
  }
}

void sub_100102568(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  if (a1)
  {
    id v8 = [*(id *)(a1 + 24) passWithUniqueIdentifier:a2];
    id v9 = [v8 secureElementPass];

    if (v9)
    {
      if ([v9 isCarKeyPass])
      {
        id v21 = v9;
        id v22 = v7;
        long long v30 = 0u;
        long long v31 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        id obj = [v9 devicePaymentApplications];
        id v10 = [obj countByEnumeratingWithState:&v28 objects:v33 count:16];
        if (v10)
        {
          id v11 = v10;
          uint64_t v12 = *(void *)v29;
          do
          {
            id v13 = 0;
            do
            {
              if (*(void *)v29 != v12) {
                objc_enumerationMutation(obj);
              }
              id v14 = [*(id *)(*((void *)&v28 + 1) + 8 * (void)v13) subcredentials];
              long long v24 = 0u;
              long long v25 = 0u;
              long long v26 = 0u;
              long long v27 = 0u;
              id v15 = [v14 countByEnumeratingWithState:&v24 objects:v32 count:16];
              if (v15)
              {
                id v16 = v15;
                uint64_t v17 = *(void *)v25;
                do
                {
                  id v18 = 0;
                  do
                  {
                    if (*(void *)v25 != v17) {
                      objc_enumerationMutation(v14);
                    }
                    id v19 = [*(id *)(*((void *)&v24 + 1) + 8 * (void)v18) sharingConfiguration];
                    id v20 = v19;
                    if (v19) {
                      [v19 setNumberOfShareableCredentials:a3];
                    }

                    id v18 = (char *)v18 + 1;
                  }
                  while (v16 != v18);
                  id v16 = [v14 countByEnumeratingWithState:&v24 objects:v32 count:16];
                }
                while (v16);
              }
              [*(id *)(a1 + 24) updateAppletSubcredentials:v14];

              id v13 = (char *)v13 + 1;
            }
            while (v13 != v11);
            id v11 = [obj countByEnumeratingWithState:&v28 objects:v33 count:16];
          }
          while (v11);
        }

        id v7 = v22;
        v22[2](v22, @"Updated limit");
        id v9 = v21;
      }
      else
      {
        v7[2](v7, @"Set limit only works for car key passes");
      }
    }
    else
    {
      v7[2](v7, @"Unable to find pass");
    }
  }
}

void sub_1001027C4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = [*(id *)(a1 + 24) passWithUniqueIdentifier:v5];
    id v8 = [v7 secureElementPass];

    if (v8)
    {
      id v9 = [objc_alloc((Class)NSMutableString) initWithString:@"\nEntitlements:\n\n"];
      long long v15 = 0u;
      long long v16 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      id v10 = [*(id *)(a1 + 24) passEntitlementsForPassUniqueIdentifier:v5];
      id v11 = [v10 countByEnumeratingWithState:&v15 objects:v19 count:16];
      if (v11)
      {
        id v12 = v11;
        uint64_t v13 = *(void *)v16;
        do
        {
          id v14 = 0;
          do
          {
            if (*(void *)v16 != v13) {
              objc_enumerationMutation(v10);
            }
            [v9 appendFormat:@"- %@ \n\n", *(void *)(*((void *)&v15 + 1) + 8 * (void)v14)];
            id v14 = (char *)v14 + 1;
          }
          while (v12 != v14);
          id v12 = [v10 countByEnumeratingWithState:&v15 objects:v19 count:16];
        }
        while (v12);
      }

      v6[2](v6, v9);
    }
    else
    {
      v6[2](v6, @"Unable to find pass");
    }
  }
}

void sub_10010297C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(void, void))v9;
  if (a1)
  {
    if (v8)
    {
      unsigned __int16 v54 = bswap32([v8 integerValue]) >> 16;
      id v11 = [objc_alloc((Class)NSData) initWithBytes:&v54 length:2];
      id v12 = [v11 hexEncoding];
      sub_10010297C(a1, v12, 0, v10);
    }
    else if (v7)
    {
      id v13 = [objc_alloc((Class)PKPassEntitlementCapabilitySet) initWithRole:v7];
      id v14 = v13;
      if (v13)
      {
        uint64_t v48 = v10;
        id v15 = [v13 shareability];
        id v16 = [v14 visibility];
        id v47 = v14;
        id v49 = [v14 manageability];
        unsigned __int16 v54 = 0;
        long long v17 = objc_msgSend(v7, "pk_decodeHexadecimal");
        [v17 getBytes:&v54 length:2];

        unsigned __int16 v54 = bswap32(v54) >> 16;
        id v18 = [objc_alloc((Class)NSMutableString) initWithString:@"\n"];
        [v18 appendFormat:@"Hex Role: '%@'\n", v7];
        objc_msgSend(v18, "appendFormat:", @"Int Role: '%hu'\n", v54);
        [v18 appendFormat:@"Binary: '"];
        for (uint64_t i = 15; i != -1; --i)
        {
          if ((v54 >> i)) {
            CFStringRef v20 = @"1";
          }
          else {
            CFStringRef v20 = @"0";
          }
          [v18 appendString:v20];
          if (i && (i & 3) == 0) {
            [v18 appendString:@" "];
          }
        }
        [v18 appendString:@"'\n\n"];
        id v21 = PKSharingCapabilityShareabilityToString();
        [v18 appendFormat:@"Shareability: '%@'\n", v21];

        if ((v54 & 8) != 0) {
          CFStringRef v22 = @"Yes";
        }
        else {
          CFStringRef v22 = @"No";
        }
        [v18 appendFormat:@"\tIntra Account: %@\n", v22];
        unint64_t v23 = PKSharingCapabilityVisibilityToString();
        [v18 appendFormat:@"Visibility: '%@'\n", v23];

        long long v24 = PKSharingCapabilityManageabilityToString();
        [v18 appendFormat:@"Manageability: '%@'\n\n", v24];

        long long v25 = [*(id *)(a1 + 24) passesOfType:1];
        long long v26 = [v25 objectsPassingTest:&stru_1007371C8];
        long long v27 = [v26 anyObject];

        if (v27)
        {
          id v46 = v7;
          id v28 = objc_alloc((Class)PKSharedPassSharesController);
          long long v29 = [*(id *)(a1 + 16) sharedWebService];
          uint64_t v30 = PDDefaultQueue();
          long long v31 = v27;
          id v32 = (void *)v30;
          char v45 = v31;
          id v33 = objc_msgSend(v28, "initWithPass:webService:paymentServiceProvider:queue:");

          long long v52 = 0u;
          long long v53 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          id v44 = v33;
          id v34 = [v33 possiblePredefinedEntitlements];
          id v35 = [v34 countByEnumeratingWithState:&v50 objects:v55 count:16];
          if (v35)
          {
            id v36 = v35;
            uint64_t v37 = *(void *)v51;
            do
            {
              for (uint64_t j = 0; j != v36; uint64_t j = (char *)j + 1)
              {
                if (*(void *)v51 != v37) {
                  objc_enumerationMutation(v34);
                }
                unsigned __int8 v39 = *(void **)(*((void *)&v50 + 1) + 8 * (void)j);
                id v40 = [v39 sharedEntitlements];
                id v41 = [v40 firstObject];

                if ([v41 recipientShareability] == v15
                  && [v41 recipientVisibility] == v16
                  && [v41 recipientManageability] == v49)
                {
                  id v42 = [v39 localizedTitle];
                  [v18 appendFormat:@"Matching Predefined Selection: '%@'\n", v42];
                }
              }
              id v36 = [v34 countByEnumeratingWithState:&v50 objects:v55 count:16];
            }
            while (v36);
          }

          id v8 = 0;
          id v7 = v46;
          long long v27 = v45;
        }
        id v10 = v48;
        ((void (**)(void, id))v48)[2](v48, v18);

        id v14 = v47;
      }
      else
      {
        id v43 = +[NSString stringWithFormat:@"Unable to convert '%@' to capability", v7];
        ((void (**)(void, void *))v10)[2](v10, v43);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Missing role parameter");
    }
  }
}

void sub_100102E9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Disabling monitor", buf, 2u);
    }

    id v5 = [*(id *)(a1 + 136) monitor];
    [v5 setDisabled:1];

    id v6 = objc_alloc_init((Class)NSMutableDictionary);
    [v6 setObject:&__kCFBooleanTrue forKeyedSubscript:PKUserNotificationDontDismissOnUnlock];
    [v6 setObject:&__kCFBooleanTrue forKeyedSubscript:PKUserNotificationAllowMenuButtonDismissal];
    [v6 setObject:@"Offline" forKeyedSubscript:kCFUserNotificationAlertHeaderKey];
    [v6 setObject:@"The device is now simulating being offline for Pinsir shares." forKeyedSubscript:kCFUserNotificationAlertMessageKey];
    [v6 setObject:@"Go Back Online" forKeyedSubscript:kCFUserNotificationDefaultButtonTitleKey];
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_100106068;
    v7[3] = &unk_100737210;
    void v7[4] = a1;
    +[PKUserNotificationAgent presentNotificationWithParameters:v6 responseHandler:v7];
    v3[2](v3, @"Monitor successfully disabled");
  }
}

void sub_100103050(id *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v9 = a2;
  unint64_t v10 = a3;
  id v11 = a5;
  id v12 = (void (**)(void, void))v11;
  if (a1)
  {
    if (v9 | v10)
    {
      if (v9)
      {
LABEL_6:
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 3221225472;
        void v16[2] = sub_100106124;
        v16[3] = &unk_1007304D8;
        long long v17 = v12;
        [a1 didReceiveActivationCodeFailureForCredentialIdentifier:v9 attemptsRemaining:a4 completion:v16];

        goto LABEL_9;
      }
      id v13 = [a1[3] passShareForIdentifier:v10];
      uint64_t v14 = [v13 subcredentialIdentifier];
      if (v14)
      {
        uint64_t v9 = v14;

        goto LABEL_6;
      }
      id v15 = +[NSString stringWithFormat:@"Unable to find credential identifier for share '%@'", v10];
      ((void (**)(void, void *))v12)[2](v12, v15);
    }
    else
    {
      (*((void (**)(id, const __CFString *))v11 + 2))(v11, @"A credential identifier or a share identifier must be provided");
    }
    uint64_t v9 = 0;
  }
LABEL_9:
}

void sub_1001031B8(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    if (v5)
    {
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      v8[2] = sub_10010622C;
      v8[3] = &unk_1007372A0;
      id v10 = v6;
      id v9 = v5;
      [a1 pendingShareActivationForShareIdentifier:v9 completion:v8];
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Share identifier required");
    }
  }
}

void sub_10010329C(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = v9;
  if (a1)
  {
    if (v7 && v8)
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      id v11[2] = sub_10010613C;
      void v11[3] = &unk_100737278;
      id v15 = v9;
      id v12 = v7;
      id v13 = a1;
      id v14 = v8;
      [a1 pendingShareActivationForShareIdentifier:v12 completion:v11];
    }
    else
    {
      (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Missing share identifier or activation code");
    }
  }
}

void sub_1001033B0(uint64_t a1, void *a2, void *a3)
{
  id v9 = a2;
  id v5 = a3;
  if (a1)
  {
    id v6 = [*(id *)(a1 + 24) passWithUniqueIdentifier:v9];
    id v7 = [v6 secureElementPass];

    if (v7)
    {
      id v8 = [*(id *)(a1 + 24) passEntitlementsForPassUniqueIdentifier:v9];
      objc_msgSend(*(id *)(a1 + 40), "sendEntitlementChangeNotificationsForPass:oldEntitlements:newEntitlements:hasExistingShares:", v7, 0, v8, objc_msgSend(*(id *)(a1 + 24), "hasSharesForPassUniqueIdentifier:", v9));
      v5[2](v5, @"Sent entitlement change notification\n");
    }
    else
    {
      v5[2](v5, @"Unable to find pass");
    }
  }
}

void sub_1001034AC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    if (v5)
    {
      id v8 = objc_alloc_init((Class)PKSecureElement);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_1001062A0;
      v9[3] = &unk_1007372C8;
      id v10 = v7;
      [v8 longTermPrivacyKeyForCredentialGroupIdentifier:v5 reuseExisting:0 completion:v9];
    }
    else
    {
      (*((void (**)(id, const __CFString *))v6 + 2))(v6, @"Missing groupId");
    }
  }
}

void sub_100103598(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v30 = a3;
  id v8 = a4;
  if (a1)
  {
    id v29 = objc_alloc_init((Class)PKSecureElement);
    id v9 = objc_alloc_init((Class)NSMutableString);
    id v10 = objc_alloc_init((Class)NSMutableArray);
    id v11 = v10;
    if (v7)
    {
      CFStringRef v12 = v7;
    }
    else
    {
      long long v45 = 0u;
      long long v46 = 0u;
      long long v43 = 0u;
      long long v44 = 0u;
      id v13 = [*(id *)(a1 + 24) passesOfType:1];
      id v14 = [v13 countByEnumeratingWithState:&v43 objects:v48 count:16];
      if (v14)
      {
        id v15 = v14;
        uint64_t v16 = *(void *)v44;
        do
        {
          for (uint64_t i = 0; i != v15; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v44 != v16) {
              objc_enumerationMutation(v13);
            }
            id v18 = [*(id *)(*((void *)&v43 + 1) + 8 * i) longTermPrivacyKeyGroupIdentifier];
            [v11 safelyAddObject:v18];
          }
          id v15 = [v13 countByEnumeratingWithState:&v43 objects:v48 count:16];
        }
        while (v15);
      }

      CFStringRef v12 = @"magic-key";
      id v10 = v11;
    }
    [v10 addObject:v12];
    if ([v11 count])
    {
      id v28 = v7;
      id v19 = objc_alloc_init((Class)PKAsyncUnaryOperationComposer);
      long long v39 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      id v20 = v11;
      id v21 = [v20 countByEnumeratingWithState:&v39 objects:v47 count:16];
      if (v21)
      {
        id v22 = v21;
        uint64_t v23 = *(void *)v40;
        do
        {
          for (uint64_t j = 0; j != v22; uint64_t j = (char *)j + 1)
          {
            if (*(void *)v40 != v23) {
              objc_enumerationMutation(v20);
            }
            uint64_t v25 = *(void *)(*((void *)&v39 + 1) + 8 * (void)j);
            v34[0] = _NSConcreteStackBlock;
            v34[1] = 3221225472;
            v34[2] = sub_100106364;
            v34[3] = &unk_100730C60;
            id v35 = v29;
            uint64_t v36 = v25;
            id v37 = v30;
            id v38 = v9;
            [v19 addOperation:v34];
          }
          id v22 = [v20 countByEnumeratingWithState:&v39 objects:v47 count:16];
        }
        while (v22);
      }

      long long v26 = +[NSNull null];
      v31[0] = _NSConcreteStackBlock;
      v31[1] = 3221225472;
      v31[2] = sub_100106738;
      v31[3] = &unk_1007341D0;
      id v33 = v8;
      id v32 = v9;
      id v27 = [v19 evaluateWithInput:v26 completion:v31];

      id v7 = v28;
    }
    else
    {
      (*((void (**)(id, const __CFString *))v8 + 2))(v8, @"No groupId provided and no passes have groupId.");
    }
  }
}

void sub_100103944(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v19 = a2;
  id v9 = a3;
  id v10 = a4;
  id v11 = a5;
  CFStringRef v12 = (void (**)(void, void))v11;
  if (a1)
  {
    if (v9 && v10)
    {
      id v13 = [v10 dataUsingEncoding:4];
      if (v19) {
        PKPrivacyEncryptionSchemeFromString();
      }
      id v14 = objc_msgSend(v9, "pk_decodeHexadecimal");
      id v15 = PKEncryptDataUsingPrivacyScheme();
      if (v15)
      {
        uint64_t v16 = +[NSJSONSerialization dataWithJSONObject:v15 options:2 error:0];
        id v17 = [objc_alloc((Class)NSString) initWithData:v16 encoding:4];
        id v18 = +[NSString stringWithFormat:@"Encrypted data dict: \n\n\"%@\"", v17];
        ((void (**)(void, void *))v12)[2](v12, v18);
      }
      else
      {
        uint64_t v16 = +[NSString stringWithFormat:@"Unable to encrypt data"];
        ((void (**)(void, void *))v12)[2](v12, v16);
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v11 + 2))(v11, @"Missing key or data");
    }
  }
}

void sub_100103B10(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = (void (**)(void, void))v9;
  if (!a1) {
    goto LABEL_11;
  }
  if (!v7)
  {
    (*((void (**)(id, const __CFString *))v9 + 2))(v9, @"Missing key or data");
LABEL_11:
    CFStringRef v12 = v8;
    goto LABEL_16;
  }
  id v11 = @"magic-key";
  if (v8) {
    id v11 = v8;
  }
  CFStringRef v12 = v11;

  id v13 = [v7 dataUsingEncoding:4];
  id v23 = 0;
  id v14 = +[NSJSONSerialization JSONObjectWithData:v13 options:0 error:&v23];
  id v15 = v23;
  uint64_t v16 = v15;
  if (!v14 || v15)
  {
    id v17 = +[NSString stringWithFormat:@"Unable to create encrypted dict: %@", v15];
    ((void (**)(void, id))v10)[2](v10, v17);
  }
  else
  {
    id v17 = objc_alloc_init((Class)PKDAManager);
    id v22 = 0;
    id v18 = [v17 decryptPayload:v14 groupIdentifier:v12 outError:&v22];
    id v19 = v22;
    uint64_t v16 = v19;
    if (!v18 || v19)
    {
      id v20 = +[NSString stringWithFormat:@"Unable to create encrypted dict: %@", v19];
      ((void (**)(void, id))v10)[2](v10, v20);
    }
    else
    {
      id v20 = [objc_alloc((Class)NSString) initWithData:v18 encoding:4];
      id v21 = +[NSString stringWithFormat:@"Decrypted text: %@", v20];
      ((void (**)(void, void *))v10)[2](v10, v21);
    }
  }

LABEL_16:
}

void sub_100103D2C(uint64_t a1, void *a2, void *a3)
{
  id v14 = a2;
  id v5 = a3;
  id v6 = (void (**)(void, void))v5;
  if (a1)
  {
    if (v14)
    {
      id v7 = objc_msgSend(*(id *)(a1 + 24), "passWithUniqueIdentifier:");
      id v8 = [v7 secureElementPass];

      if (v8)
      {
        id v9 = [v8 auxiliaryRegistrationRequirements];
        id v10 = [v9 deviceDecryptionRequirements];
        id v11 = objc_msgSend(v10, "pk_firstObjectPassingTest:", &stru_100737330);

        if (v11)
        {
          [*(id *)(a1 + 24) updateAuxiliaryRegistrationRequirement:v11 pass:v8 isRegistered:0];
          CFStringRef v12 = [v8 uniqueID];
          id v13 = +[NSString stringWithFormat:@"Invalidated LTPK for pass %@", v12];
          ((void (**)(void, void *))v6)[2](v6, v13);
        }
        else
        {
          ((void (**)(void, const __CFString *))v6)[2](v6, @"unable to find LTPK for pass");
        }
      }
      else
      {
        ((void (**)(void, const __CFString *))v6)[2](v6, @"Unable to find pass");
      }
    }
    else
    {
      (*((void (**)(id, const __CFString *))v5 + 2))(v5, @"Missing pass unique ID");
    }
  }
}

void sub_100103EBC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = objc_alloc((Class)NSMutableString);
  id v6 = [*(id *)(a1 + 32) transportIdentifier];
  id v7 = [v5 initWithFormat:@"Mailbox %@ created for message: \n%@", v6, *(void *)(a1 + 40)];

  if (v4)
  {
    [v7 appendFormat:@"\nError: %@", v4];
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    id v8 = objc_alloc_init(PDShareURLDecorationConfiguration);
    id v9 = v8;
    uint64_t v10 = *(void *)(a1 + 56);
    uint64_t v11 = 1;
    if (v10 == 4) {
      uint64_t v11 = 2;
    }
    if (v10 == 3) {
      uint64_t v12 = 3;
    }
    else {
      uint64_t v12 = v11;
    }
    [(PDShareURLDecorationConfiguration *)v8 setVertical:v12];
    id v13 = *(void **)(a1 + 32);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    void v14[2] = sub_100104020;
    v14[3] = &unk_1007367E0;
    id v15 = v7;
    id v16 = *(id *)(a1 + 48);
    [v13 universalShareURLWithDecoration:v9 completion:v14];
  }
}

uint64_t sub_100104020(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) appendFormat:@"\n\nSuccess! Share url: %@", a2];
  id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  return v3();
}

void sub_100104078(void *a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1[6];
  CFStringRef v4 = @"N";
  if (a2) {
    CFStringRef v4 = @"Y";
  }
  id v5 = +[NSString stringWithFormat:@"Message sent to mailbox %@\nMessage: %@\nResult: Success %@ Error: %@", a1[4], a1[5], v4, a3];
  (*(void (**)(uint64_t, void *))(v3 + 16))(v3, v5);
}

void sub_10010410C(uint64_t a1, char a2, uint64_t a3)
{
  if (a3 || (a2 & 1) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 48);
    id v6 = +[NSString stringWithFormat:@"Fetches messages from mailbox %@ \nError: %@", *(void *)(a1 + 32), a3];
    (*(void (**)(uint64_t, id))(v5 + 16))(v5, v6);
  }
  else
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_100104214;
    v7[3] = &unk_100736EC8;
    CFStringRef v4 = *(void **)(a1 + 40);
    id v9 = *(id *)(a1 + 48);
    id v8 = *(id *)(a1 + 32);
    [v4 handleOutstandingMessage:v7];
  }
}

void sub_100104214(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = +[NSString stringWithFormat:@"Fetches messages from mailbox %@ \nMessage: %@", *(void *)(a1 + 32), a2];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_100104288(uint64_t a1, char a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  if (a3 || (a2 & 1) == 0) {
    +[NSString stringWithFormat:@"Failed to relinquish mailbox %@ \nError: %@", v3, a3];
  }
  else {
  id v6 = +[NSString stringWithFormat:@"Relinquished mailbox %@", v3, v5];
  }
  (*(void (**)(uint64_t))(v4 + 16))(v4);
}

void sub_100104314(void *a1, int a2, uint64_t a3)
{
  uint64_t v4 = a1[7];
  CFStringRef v5 = @"N";
  if (a2) {
    CFStringRef v5 = @"Y";
  }
  id v6 = +[NSString stringWithFormat:@"Mailbox %@ deleted\n\nResult: Success %@ Error: %@", a1[4], v5, a3];
  (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v6);

  id v7 = (void *)a1[6];
  id v8 = *(void **)(a1[5] + 8);
  id v9 = [v7 transportIdentifier];
  [v8 channelEndpointWasTerminatedRemotely:v9];
}

void sub_1001043D8(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  CFStringRef v4 = @"No";
  if (a2) {
    CFStringRef v4 = @"Yes";
  }
  id v5 = +[NSString stringWithFormat:@"\nPinged endpoint '%@'\n\nSucces: %@\nError: %@\n\n", *(void *)(a1 + 32), v4, a3];
  (*(void (**)(uint64_t, id))(v3 + 16))(v3, v5);
}

void sub_100104468(void *a1, void *a2, void *a3)
{
  id v11 = a2;
  id v5 = a3;
  id v6 = [v11 hexEncoding];
  id v7 = [objc_alloc((Class)NSMutableString) initWithString:@"\nGenerated Push Token\n"];
  if (a1[6])
  {
    id v8 = PKSharingRelayServerEnvironmentToString();
    [v7 appendFormat:@"Environment: %@\n", v8];
  }
  else
  {
    id v8 = PKSharingRelayServerEnvironmentToString();
    PKSharingResolvedRelayServerEnvironment();
    id v9 = PKSharingRelayServerEnvironmentToString();
    [v7 appendFormat:@"Environment: %@ (%@)\n", v8, v9];
  }
  [v7 appendFormat:@"Topic: %@\n\n", a1[4]];
  if (v6)
  {
    [v7 appendFormat:@"Hex Token: %@\n", v6];
    uint64_t v10 = [v11 base64EncodedStringWithOptions:0];
    [v7 appendFormat:@"Base64 Token: %@\n", v10];
  }
  else
  {
    [v7 appendFormat:@"Error: %@\n", v5];
  }
  [v7 appendFormat:@"\n"];
  (*(void (**)(void))(a1[5] + 16))();
}

void sub_1001045FC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = [objc_alloc((Class)NSMutableString) initWithString:@"\nDevices:\n"];
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    id v5 = v3;
    id v6 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v13;
      do
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v13 != v8) {
            objc_enumerationMutation(v5);
          }
          uint64_t v10 = [*(id *)(*((void *)&v12 + 1) + 8 * i) name];
          id v11 = (void *)IDSCopyIDForDevice();
          [v4 appendFormat:@"Device: %@ \n\tDestination: '%@'\n\n", v10, v11, (void)v12];
        }
        id v7 = [v5 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }
      while (v7);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_100104790(void *a1, int a2, uint64_t a3)
{
  uint64_t v3 = a1[6];
  CFStringRef v4 = @"N";
  if (a2) {
    CFStringRef v4 = @"Y";
  }
  id v5 = +[NSString stringWithFormat:@"Message sent to IDS device %@\nMessage: %@\nResult: Success %@ Error: %@", a1[4], a1[5], v4, a3];
  (*(void (**)(uint64_t, void *))(v3 + 16))(v3, v5);
}

void sub_100104824(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  id v7 = [objc_alloc((Class)NSString) initWithFormat:@"\nReceived message: %@\n", v6];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  v5[2](v5, 1, 1);
}

uint64_t sub_1001048D4(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (a2) {
    CFStringRef v3 = @"Handle timed out waiting for message";
  }
  else {
    CFStringRef v3 = @"Handle was invalidated";
  }
  return (*(uint64_t (**)(uint64_t, const __CFString *))(v2 + 16))(v2, v3);
}

void sub_1001048FC(uint64_t a1, int a2)
{
  [*(id *)(a1 + 32) invalidate];
  uint64_t v4 = *(void *)(a1 + 40);
  CFStringRef v5 = @"No";
  if (a2) {
    CFStringRef v5 = @"Yes";
  }
  id v6 = +[NSString stringWithFormat:@"Closed session: %@", v5];
  (*(void (**)(uint64_t, id))(v4 + 16))(v4, v6);
}

void sub_100104994(uint64_t a1)
{
  id v2 = +[PKSharingRelayChannelDescriptor existingChannelForMailboxIdentifier:*(void *)(a1 + 32)];
  CFStringRef v3 = [*(id *)(*(void *)(a1 + 40) + 136) handleForDescriptor:v2 queue:*(void *)(*(void *)(a1 + 40) + 88)];
  if (v3)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    _DWORD v5[2] = sub_100104A84;
    v5[3] = &unk_100736FD0;
    uint64_t v4 = *(id **)(a1 + 40);
    id v6 = *(id *)(a1 + 48);
    sub_1000EE530(v4, v3, v5);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_100104A84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (a2) {
    +[NSString stringWithFormat:@"Found valid invitation: %@", a2];
  }
  else {
  id v4 = +[NSString stringWithFormat:@"Unable to find valid invitation. Error: %@", a3];
  }
  (*(void (**)(uint64_t))(v3 + 16))(v3);
}

void sub_100104B08(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFStringRef v3 = @"Failure";
  if (a2) {
    CFStringRef v3 = @"Success";
  }
  id v4 = +[NSString stringWithFormat:@"\nFinished prewarming create share with result: %@\n", v3];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v4);
}

void sub_100104B90(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = *(void **)(*(void *)(a1 + 32) + 24);
  id v5 = a2;
  id v6 = [v4 passWithUniqueIdentifier:v3];
  id v7 = [v6 secureElementPass];

  id v8 = [objc_alloc((Class)PKPartialShareInvitation) initWithShare:*(void *)(a1 + 48) pass:v7];
  id v9 = *(void **)(a1 + 32);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100104CA8;
  v10[3] = &unk_100736FF8;
  id v12 = *(id *)(a1 + 56);
  id v11 = *(id *)(a1 + 48);
  [v9 createShareForPartialShareInvitation:v8 authorization:v5 completion:v10];
}

void sub_100104CA8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (a3)
  {
    id v6 = +[NSString stringWithFormat:@"Unable to create share error: %@", a3];
    (*(void (**)(uint64_t))(v3 + 16))(v3);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 32);
    id v6 = [a2 url];
    id v5 = +[NSString stringWithFormat:@"Created share for %@\n\n%@", v4, v6];
    (*(void (**)(uint64_t, void *))(v3 + 16))(v3, v5);
  }
}

void sub_100104D70(uint64_t a1, void *a2, void *a3)
{
  id v10 = a2;
  id v5 = a3;
  if (v10
    && !v5
    && ([*(id *)(a1 + 32) externalizedContext], (uint64_t v6 = objc_claimAutoreleasedReturnValue()) != 0))
  {
    id v7 = (void *)v6;
    id v8 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 40);
    id v7 = +[NSString stringWithFormat:@"Unable to get auth with error: %@", v5];
    id v8 = *(void (**)(void))(v9 + 16);
  }
  v8();
}

id sub_100104E38()
{
  id v0 = objc_alloc((Class)PKSharingMessageDisplayInformation);
  id v1 = [objc_alloc((Class)NSURL) initWithString:@"https://cdn.macsfera.com/wp-content/uploads/2017/09/14170027/Keynote-Lets-meet-at-our-place.jpg"];
  id v2 = [v0 initWithTitle:@"Car Key" subtitle:@"Car Key" imageURL:v1];

  id v3 = objc_alloc((Class)PKSharingCarKeyInvitation);
  uint64_t v4 = objc_msgSend(@"AAAA", "pk_decodeHexadecimal");
  id v5 = objc_alloc_init((Class)NSUUID);
  uint64_t v6 = [v5 UUIDString];
  id v7 = [v3 initWithRawInvite:v4 shareIdentifier:v6 radioTechnology:3 vehicleModel:@"CarModel" vehicleIssuer:@"CarMake" readerIdentifier:@"AAAAA" partnerIdentifier:@"V.MOCK.USM" brandIdentifier:@"BRND" carKeySharingDict:&__NSDictionary0__struct proprietaryData:0 activationOptions:0 displayInformation:v2];

  return v7;
}

void sub_100104F70(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (a3)
  {
    id v6 = +[NSString stringWithFormat:@"Failed to create embedded share url: %@", a3];
    (*(void (**)(uint64_t))(v3 + 16))(v3);
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 32);
    id v6 = [a2 url];
    id v5 = +[NSString stringWithFormat:@"Created mock share for %@\n\n\n%@", v4, v6];
    (*(void (**)(uint64_t, void *))(v3 + 16))(v3, v5);
  }
}

void sub_100105038(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a1[6];
  if (a3) {
    +[NSString stringWithFormat:@"Unable to edit share error: %@", a3, v4];
  }
  else {
  id v5 = +[NSString stringWithFormat:@"Updated share for %@ to: %@", a1[4], a1[5]];
  }
  (*(void (**)(uint64_t))(v3 + 16))(v3);
}

void sub_1001050C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (a3) {
    +[NSString stringWithFormat:@"Unable to revoke share error: %@", a3];
  }
  else {
  id v4 = +[NSString stringWithFormat:@"Revoked share for %@", *(void *)(a1 + 32)];
  }
  (*(void (**)(uint64_t))(v3 + 16))(v3);
}

void sub_100105150(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  id v4 = +[NSString stringWithFormat:@"Message:%@\n\nshareURL: %@\nerror:%@", *(void *)(a1 + 32), a2, a3];
  (*(void (**)(uint64_t, id))(v3 + 16))(v3, v4);
}

void sub_1001051C8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    if (*(unsigned char *)(a1 + 88))
    {
      id v7 = [objc_alloc((Class)PKPendingStatefulTransferProvisioning) initWithTransportIdentifier:*(void *)(a1 + 32) invitation:v5 share:*(void *)(a1 + 40)];
      [v7 setOriginalShareURL:*(void *)(a1 + 48)];
      [v7 setAccountAttestationAnonymizationSalt:*(void *)(a1 + 56)];
      [v7 setShouldAutoProvision:1];
      id v8 = *(void **)(a1 + 64);
      id v20 = v7;
      uint64_t v9 = +[NSArray arrayWithObjects:&v20 count:1];
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472;
      void v17[2] = sub_1001053E4;
      v17[3] = &unk_100731538;
      id v10 = *(id *)(a1 + 80);
      id v18 = v7;
      id v19 = v10;
      id v11 = v7;
      [v8 addPendingProvisionings:v9 completion:v17];
    }
    else
    {
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      void v15[2] = sub_1001054A4;
      v15[3] = &unk_100737098;
      long long v14 = *(void **)(a1 + 72);
      id v16 = *(id *)(a1 + 80);
      [v14 acceptCarKeyShareForMessage:v5 activationCode:0 completion:v15];
    }
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 80);
    long long v13 = +[NSString stringWithFormat:@"Unable to retrieve share, %@", v6];
    (*(void (**)(uint64_t, void *))(v12 + 16))(v12, v13);
  }
}

void sub_1001053E4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (a2)
  {
    id v4 = +[NSString stringWithFormat:@"Failed to queue pending provisioning with error: %@", a2];
    (*(void (**)(uint64_t))(v2 + 16))(v2);
  }
  else
  {
    id v4 = [*(id *)(a1 + 32) uniqueIdentifier];
    uint64_t v3 = +[NSString stringWithFormat:@"Queued pending provisioning with identifier: %@", v4];
    (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v3);
  }
}

void sub_1001054A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = +[NSString stringWithFormat:@"Accepted share response: %@, error: %@", a2, a3];
  (*(void (**)(uint64_t, id))(v3 + 16))(v3, v4);
}

void sub_100105514(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (a2)
  {
    id v4 = +[NSString stringWithFormat:@"Failed to queue pending provisioning with error: %@", a2];
    (*(void (**)(uint64_t))(v2 + 16))(v2);
  }
  else
  {
    id v4 = [*(id *)(a1 + 32) uniqueIdentifier];
    uint64_t v3 = +[NSString stringWithFormat:@"Queued pending provisioning with identifier: %@", v4];
    (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v3);
  }
}

void sub_1001055D4(uint64_t a1, uint64_t a2)
{
  if (a2 == 2)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    id v3 = [objc_alloc((Class)NSString) initWithFormat:@"Account has %@ device - NO", *(void *)(a1 + 32)];
  }
  else if (a2 == 1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    id v3 = [objc_alloc((Class)NSString) initWithFormat:@"Account has %@ device - YES", *(void *)(a1 + 32)];
  }
  else
  {
    if (a2) {
      return;
    }
    uint64_t v2 = *(void *)(a1 + 40);
    id v3 = [objc_alloc((Class)NSString) initWithFormat:@"Unable to determine if account has %@ device", *(void *)(a1 + 32)];
  }
  id v4 = v3;
  (*(void (**)(uint64_t))(v2 + 16))(v2);
}

void sub_1001056B8(uint64_t a1, char a2, uint64_t a3)
{
  if (a3 || (a2 & 1) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    id v6 = +[NSString stringWithFormat:@"Failed to send message with error %@", a3];
    (*(void (**)(uint64_t, id))(v5 + 16))(v5, v6);
  }
  else
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_1001057EC;
    v7[3] = &unk_10072FDC8;
    id v8 = *(id *)(a1 + 32);
    id v9 = *(id *)(a1 + 40);
    id v4 = objc_retainBlock(v7);
    if ([*(id *)(a1 + 32) hasOutstandingMessage]) {
      ((void (*)(void *))v4[2])(v4);
    }
    else {
      [*(id *)(a1 + 32) setMessageReceivedHandler:v4];
    }
  }
}

void sub_1001057EC(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10010588C;
  v3[3] = &unk_100736EC8;
  uint64_t v2 = *(void **)(a1 + 32);
  id v5 = *(id *)(a1 + 40);
  id v4 = *(id *)(a1 + 32);
  [v2 handleOutstandingMessage:v3];
}

id sub_10010588C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = *(void (**)(uint64_t, uint64_t))(a3 + 16);
  id v6 = a2;
  v5(a3, 1);
  uint64_t v7 = *(void *)(a1 + 40);
  id v8 = +[NSString stringWithFormat:@"Received invitation %@", v6];

  (*(void (**)(uint64_t, void *))(v7 + 16))(v7, v8);
  id v9 = *(void **)(a1 + 32);
  return [v9 invalidate];
}

void sub_100105938(uint64_t a1, char a2, uint64_t a3)
{
  if (a3 || (a2 & 1) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    id v6 = +[NSString stringWithFormat:@"Failed to send message with error %@", a3];
    (*(void (**)(uint64_t, id))(v5 + 16))(v5, v6);
  }
  else
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100105AA4;
    v10[3] = &unk_100736FA8;
    id v4 = *(void **)(a1 + 32);
    id v11 = *(id *)(a1 + 40);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    _DWORD v7[2] = sub_100105B50;
    v7[3] = &unk_100731C90;
    id v9 = *(id *)(a1 + 40);
    id v8 = *(id *)(a1 + 32);
    [v4 waitForMessageWithTimeout:v10 messageHandler:v7 invalidationHandler:300.0];
  }
}

void sub_100105AA4(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void (**)(uint64_t, uint64_t, uint64_t))(a3 + 16);
  id v6 = a2;
  v5(a3, 1, 1);
  uint64_t v7 = *(void *)(a1 + 32);
  id v8 = +[NSString stringWithFormat:@"\n\nReceived invitation: %@\n", v6];

  (*(void (**)(uint64_t, id))(v7 + 16))(v7, v8);
}

uint64_t sub_100105B50(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (a2) {
    CFStringRef v3 = @"\nTimed out waiting for response\n";
  }
  else {
    CFStringRef v3 = @"\nHandle invalidated\n";
  }
  return (*(uint64_t (**)(uint64_t, const __CFString *))(v2 + 16))(v2, v3);
}

void sub_100105B78(uint64_t a1, const __CFString *a2)
{
  CFStringRef v3 = *(void **)(a1 + 32);
  CFStringRef v4 = @"nil";
  if (a2) {
    CFStringRef v4 = a2;
  }
  [v3 appendFormat:@"%@", v4];
  uint64_t v5 = *(void **)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_100105C60;
  v7[3] = &unk_1007368F0;
  id v8 = *(id *)(a1 + 32);
  id v9 = *(id *)(a1 + 48);
  id v10 = *(id *)(a1 + 56);
  [v5 displayableEntitlementsForPassIdentifier:v6 completion:v7];
}

uint64_t sub_100105C60(void *a1, void *a2)
{
  CFStringRef v3 = (void *)a1[4];
  uint64_t v4 = a1[5];
  id v5 = a2;
  [v3 appendFormat:@"\n\nEntitlements for %@:\n", v4];
  uint64_t v6 = (void *)a1[4];
  uint64_t v7 = [v5 description];

  if (v7) {
    CFStringRef v8 = v7;
  }
  else {
    CFStringRef v8 = @"nil";
  }
  [v6 appendString:v8];

  id v9 = *(uint64_t (**)(void))(a1[6] + 16);
  return v9();
}

uint64_t sub_100105D04(uint64_t a1, void *a2)
{
  CFStringRef v3 = [a2 identifier];
  uint64_t v4 = *(void **)(a1 + 32);
  id v5 = v3;
  id v6 = v4;
  uint64_t v7 = v6;
  if (v5 == v6)
  {
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 1;
    if (v5 && v6) {
      uint64_t v8 = [v5 isEqualToString:v6] ^ 1;
    }
  }

  return v8;
}

void sub_100105D88(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "PDSharingManager CLI: Revoked %@", buf, 0xCu);
  }

  [*(id *)(*(void *)(a1 + 40) + 24) updatePassSharesForPassUniqueIdentifier:*(void *)(a1 + 48) passShares:0];
  uint64_t v7 = *(void *)(a1 + 56);
  if (v7) {
    [*(id *)(a1 + 40) passUpdated:v7 oldShares:*(void *)(a1 + 32)];
  }
  uint64_t v8 = *(void *)(a1 + 64);
  id v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Removed %lu shares on pass %@", [*(id *)(a1 + 32) count], *(void *)(a1 + 48));
  (*(void (**)(uint64_t, void *))(v8 + 16))(v8, v9);
}

uint64_t sub_100105EB4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100105ECC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    id v5 = +[NSString stringWithFormat:@"Fetches messages from mailbox %@ \nError: %@", *(void *)(a1 + 32), a3];
    (*(void (**)(uint64_t, id))(v3 + 16))(v3, v5);
  }
  else
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    id v6[2] = sub_100105FBC;
    v6[3] = &unk_100737188;
    id v4 = *(void **)(a1 + 40);
    id v7 = *(id *)(a1 + 48);
    [v4 handleOutstandingMessage:v6];
  }
}

void sub_100105FBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, 1);
  uint64_t v5 = *(void *)(a1 + 32);
  CFStringRef v6 = @"YES";
  if (!a2) {
    CFStringRef v6 = @"NO";
  }
  id v7 = +[NSString stringWithFormat:@"Handling message: %@", v6];
  (*(void (**)(uint64_t, id))(v5 + 16))(v5, v7);
}

BOOL sub_100106060(id a1, PKSecureElementPass *a2, BOOL *a3)
{
  return [(PKSecureElementPass *)a2 isCarKeyPass];
}

void sub_100106068(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PDSharingManager: Enabling monitor", v5, 2u);
  }

  uint64_t v3 = [*(id *)(*(void *)(a1 + 32) + 136) monitor];
  [v3 setDisabled:0];

  id v4 = [*(id *)(*(void *)(a1 + 32) + 136) monitor];
  [v4 checkForNewSharingMessagesWithShouldCheckAllEndpoint:1 completion:&stru_1007371E8];
}

uint64_t sub_100106124(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10010613C(void *a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)a1[5];
    id v4 = [a2 originalInvitation];
    [v3 acceptCarKeyShareForMessage:v4 activationCode:a1[6] completion:&stru_100737250];

    uint64_t v5 = *(void (**)(void))(a1[7] + 16);
    v5();
  }
  else
  {
    uint64_t v6 = a1[7];
    id v7 = +[NSString stringWithFormat:@"Unable to find pending activation for share '%@'\n", a1[4]];
    (*(void (**)(uint64_t, id))(v6 + 16))(v6, v7);
  }
}

void sub_10010622C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = +[NSString stringWithFormat:@"Pending activation for share '%@': \n\n %@ \n", *(void *)(a1 + 32), a2];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_1001062A0(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2)
  {
    id v6 = [a2 hexEncoding];
    id v3 = +[NSString stringWithFormat:@"Created long term privacy key: %@", v6];
    (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v3);
  }
  else
  {
    id v4 = *(void (**)(uint64_t, const __CFString *))(v2 + 16);
    uint64_t v5 = *(void *)(a1 + 32);
    v4(v5, @"Failed to create long term privacy key");
  }
}

void sub_100106364(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  void v15[2] = sub_100106450;
  v15[3] = &unk_1007372F0;
  uint64_t v10 = *(void *)(a1 + 48);
  id v11 = *(id *)(a1 + 56);
  uint64_t v12 = *(void *)(a1 + 40);
  id v16 = v11;
  uint64_t v17 = v12;
  id v18 = v6;
  id v19 = v7;
  id v13 = v6;
  id v14 = v7;
  [v8 longTermPrivacyKeysForCredentialGroupIdentifier:v9 privacyKeyIdentifier:v10 completion:v15];
}

void sub_100106450(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = *(void **)(a1 + 32);
  if (v5)
  {
    if ([*(id *)(a1 + 32) length]) {
      CFStringRef v7 = @"========================\n\n";
    }
    else {
      CFStringRef v7 = @"\n";
    }
    [v6 appendString:v7];
    uint64_t v8 = *(void **)(a1 + 32);
    uint64_t v9 = +[NSString stringWithFormat:@"GroupID: '%@'\n", *(void *)(a1 + 40)];
    [v8 appendString:v9];

    uint64_t v10 = *(void **)(a1 + 32);
    id v11 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Found %lu keys\n\n", [v5 count]);
    [v10 appendString:v11];

    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    id v28 = v5;
    id obj = v5;
    id v12 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v31;
      do
      {
        for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v31 != v14) {
            objc_enumerationMutation(obj);
          }
          id v16 = *(void **)(*((void *)&v30 + 1) + 8 * i);
          uint64_t v17 = *(void **)(a1 + 32);
          id v18 = [v16 keyIdentifier];
          id v19 = +[NSString stringWithFormat:@"KeyID: %@\n", v18];
          [v17 appendString:v19];

          id v20 = [v16 publicKey];
          id v21 = [v20 base64EncodedStringWithOptions:0];

          id v22 = *(void **)(a1 + 32);
          id v23 = +[NSString stringWithFormat:@"Public Key: %@\n", v21];
          [v22 appendString:v23];

          long long v24 = *(void **)(a1 + 32);
          uint64_t v25 = [v16 creationDate];
          long long v26 = +[NSString stringWithFormat:@"Created: %@\n\n", v25];
          [v24 appendString:v26];
        }
        id v13 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
      }
      while (v13);
    }

    id v5 = v28;
  }
  else
  {
    id v27 = +[NSString stringWithFormat:@"Failed to get long term privacy keys: %@", a3];
    [v6 appendString:v27];
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

uint64_t sub_100106738(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

BOOL sub_10010674C(id a1, PKPassAuxiliaryRegistrationDecryptionRequirement *a2)
{
  return [(PKPassAuxiliaryRegistrationDecryptionRequirement *)a2 type] == (id)2;
}

Class sub_10010686C()
{
  if (qword_100808BD8 != -1) {
    dispatch_once(&qword_100808BD8, &stru_100737350);
  }
  Class result = objc_getClass("NPKSharedWebServiceProvider");
  qword_100808BC8 = (uint64_t)result;
  off_1008056B8 = (uint64_t (*)())sub_1001068D0;
  return result;
}

id sub_1001068D0()
{
  return (id)qword_100808BC8;
}

void sub_1001068DC(id a1)
{
  qword_100808BD0 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/NanoPassKit.framework/NanoPassKit", 2);
}

void sub_1001069F8(id a1)
{
  int IsAvailable = PKSecureElementIsAvailable();
  unsigned int v2 = +[PKDAManager isSupported];
  int v3 = v2 & (PKIsSRD() ^ 1);
  if (!IsAvailable) {
    LOBYTE(v3) = 0;
  }
  byte_100808BE0 = v3;
}

BOOL sub_100107218(id a1, PKSecureElementPass *a2)
{
  return PKPaymentApplicationStateAllowsReplacementInvitation() == 0;
}

void sub_100107CDC(uint64_t a1, uint64_t a2, void *a3, id *a4)
{
  id v7 = a3;
  id v6 = *a4;
  if (v6)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      objc_msgSend(*(id *)(a1 + 32), "pk_safelyAddObject:", v6);
    }
  }
}

void sub_10010834C(id a1, PKPeerPaymentEncryptionCertificatesVersions *a2, id a3)
{
  id v4 = a2;
  -[PKPeerPaymentEncryptionCertificatesVersions setRecipientData:](v4, "setRecipientData:", [a3 integerValue]);
}

void sub_10010849C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

uint64_t sub_100108608(uint64_t a1)
{
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v14;
    while (2)
    {
      id v6 = 0;
      do
      {
        if (*(void *)v14 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v13 + 1) + 8 * (void)v6);
        id v8 = objc_alloc(*(Class *)(a1 + 48));
        uint64_t v9 = objc_msgSend(*(id *)(a1 + 48), "_propertyValuesForPassRelevancyDates:passPID:", v7, *(void *)(a1 + 56), (void)v13);
        id v10 = [v8 initWithPropertyValues:v9 inDatabase:*(void *)(a1 + 40)];

        if (!v10)
        {
          uint64_t v11 = 0;
          goto LABEL_11;
        }
        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }
  uint64_t v11 = 1;
LABEL_11:

  return v11;
}

int64_t sub_100108850(id a1, PKPassRelevantDate *a2, PKPassRelevantDate *a3)
{
  id v4 = a3;
  uint64_t v5 = [(PKPassRelevantDate *)a2 relevantDateWithPriority:0];
  id v6 = [(PKPassRelevantDate *)v4 relevantDateWithPriority:0];

  id v7 = [v5 compare:v6];
  return (int64_t)v7;
}

uint64_t sub_100108C94(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  id v10 = *a4;
  id v6 = +[NSNull null];
  id v7 = v10;
  if (v10 != v6)
  {
    id v8 = v6;
    id v11 = *a4;

    uint64_t result = (uint64_t)v11;
    if (!v11) {
      return result;
    }
    id v6 = [*(id *)(a1 + 32) addObject:v11];
    id v7 = v11;
  }
  return _objc_release_x1(v6, v7);
}

uint64_t sub_100108EA4(uint64_t a1)
{
  [*(id *)(a1 + 56) deleteSupportedCountryCodes:1 forPaymentApplication:*(void *)(a1 + 32) inDatabase:*(void *)(a1 + 40)];
  id v2 = [*(id *)(a1 + 56) insertCountryCodes:*(void *)(a1 + 48) supported:1 withPaymentApplication:*(void *)(a1 + 32) inDatabase:*(void *)(a1 + 40)];
  return 1;
}

uint64_t sub_100108FD4(uint64_t a1)
{
  [*(id *)(a1 + 56) deleteSupportedCountryCodes:0 forPaymentApplication:*(void *)(a1 + 32) inDatabase:*(void *)(a1 + 40)];
  id v2 = [*(id *)(a1 + 56) insertCountryCodes:*(void *)(a1 + 48) supported:0 withPaymentApplication:*(void *)(a1 + 32) inDatabase:*(void *)(a1 + 40)];
  return 1;
}

void sub_1001097A4(_Unwind_Exception *a1)
{
  id v4 = v1;
  objc_destroyWeak(v4);
  objc_destroyWeak(v2);
  objc_destroyWeak((id *)(v3 - 56));
  _Unwind_Resume(a1);
}

void sub_1001097D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (id *)(a1 + 32);
  id WeakRetained = (os_unfair_lock_s *)objc_loadWeakRetained((id *)(a1 + 32));
  id v6 = WeakRetained;
  if (WeakRetained)
  {
    os_unfair_lock_lock(WeakRetained + 6);
    id v7 = (void (**)(id, id))objc_retainBlock(*(id *)&v6[14]._os_unfair_lock_opaque);
    id v8 = *(void **)&v6[14]._os_unfair_lock_opaque;
    *(void *)&v6[14]._os_unfair_lock_opaque = 0;

    os_unfair_lock_unlock(v6 + 6);
    if (v3)
    {
      uint64_t v9 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = 138412290;
        id v12 = v3;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Failed to start proximity advertising with error: %@", (uint8_t *)&v11, 0xCu);
      }

      if (v7) {
        v7[2](v7, v3);
      }
      id v10 = objc_loadWeakRetained(v4);
      [v10 _invalidateWithShouldNotify:1];
    }
    else if (v7)
    {
      v7[2](v7, 0);
    }
  }
}

void sub_100109934(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5 = (id *)(a1 + 32);
  id WeakRetained = (os_unfair_lock_s *)objc_loadWeakRetained((id *)(a1 + 32));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    os_unfair_lock_lock(WeakRetained + 6);
    id v8 = (void (**)(id, id))objc_retainBlock(*(id *)&v7[10]._os_unfair_lock_opaque);
    uint64_t v9 = *(void **)&v7[10]._os_unfair_lock_opaque;
    *(void *)&v7[10]._os_unfair_lock_opaque = 0;

    os_unfair_lock_unlock(v7 + 6);
    if (v8)
    {
      id v10 = PKLogFacilityTypeGetObject();
      BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (a4)
      {
        if (v11)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Verified proximity verification", buf, 2u);
        }

        id v12 = objc_alloc_init((Class)PKContinuityProximityBLEVerification);
        v8[2](v8, v12);
      }
      else
      {
        if (v11)
        {
          v14[0] = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Failed to verify proximity verification", (uint8_t *)v14, 2u);
        }

        v8[2](v8, 0);
      }
    }
    id v13 = objc_loadWeakRetained(v5);
    [v13 _invalidateWithShouldNotify:1];
  }
}

void sub_100109A8C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
    [WeakRetained _invalidateWithShouldNotify:1];
  }
}

void sub_10010AD60(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v8 = objc_alloc_init((Class)PKAccountPendingFamilyMember);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v8 withProperties:v6 values:a4];

  id v7 = v8;
  if (v8)
  {
    objc_msgSend(*(id *)(a1 + 40), "addObject:");
    id v7 = v8;
  }
}

void sub_10010AECC(id a1, PKAccountPendingFamilyMember *a2, id a3)
{
}

void sub_10010AED4(id a1, PKAccountPendingFamilyMember *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKAccountPendingFamilyMember *)v3 setInviteDate:v4];
}

void sub_10010AF34(id a1, PKAccountPendingFamilyMember *a2, id a3)
{
}

void sub_10010AF3C(id a1, PKAccountPendingFamilyMember *a2, id a3)
{
  id v4 = a2;
  -[PKAccountPendingFamilyMember setDisplayedNotification:](v4, "setDisplayedNotification:", [a3 BOOLValue]);
}

void sub_10010AF94(id a1, PKAccountPendingFamilyMember *a2, id a3)
{
}

void sub_10010B56C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];

  id v6 = [*(id *)(a1 + 32) database];
  id v7 = [*(id *)(a1 + 32) valueForProperty:@"b"];
  id v10 = +[PayLaterFundingSourceDetails anyInDatabase:v6 forPID:v7];

  id v8 = *(void **)(a1 + 48);
  uint64_t v9 = [v10 fundingSourceDetails];
  [v8 setDetails:v9];
}

void sub_10010B83C(id a1, PKPayLaterFinancingPlanFundingSource *a2, id a3)
{
}

void sub_10010B844(id a1, PKPayLaterFinancingPlanFundingSource *a2, id a3)
{
  id v4 = a2;
  -[PKPayLaterFinancingPlanFundingSource setType:](v4, "setType:", [a3 integerValue]);
}

void sub_10010B89C(id a1, PKPayLaterFinancingPlanFundingSource *a2, id a3)
{
  id v4 = a2;
  -[PKPayLaterFinancingPlanFundingSource setAutoPayment:](v4, "setAutoPayment:", [a3 BOOLValue]);
}

void sub_10010C330(uint64_t a1, uint64_t a2)
{
  id v5 = [(SQLiteEntity *)[CreditRecoveryPaymentPlan alloc] initWithPersistentID:a2 inDatabase:*(void *)(a1 + 32)];
  id v3 = *(void **)(a1 + 40);
  id v4 = [(CreditRecoveryPaymentPlan *)v5 creditRecoveryPaymentPlan];
  [v3 addObject:v4];
}

uint64_t sub_10010C560(uint64_t a1)
{
  +[CreditRecoveryPaymentPlan deleteCreditRecoveryPaymentPlansForAccountIdentifier:*(void *)(a1 + 32) inDatabase:*(void *)(a1 + 40)];
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v2 = *(id *)(a1 + 48);
  id v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v12;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v12 != v5) {
          objc_enumerationMutation(v2);
        }
        id v7 = +[CreditRecoveryPaymentPlan _insertPaymentPlan:forAccountIdentifier:inDatabase:](CreditRecoveryPaymentPlan, "_insertPaymentPlan:forAccountIdentifier:inDatabase:", *(void *)(*((void *)&v11 + 1) + 8 * (void)v6), *(void *)(a1 + 32), *(void *)(a1 + 40), (void)v11);
        id v8 = *(void **)(a1 + 56);
        uint64_t v9 = [v7 creditRecoveryPaymentPlan];
        [v8 addObject:v9];

        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v4);
  }

  return 1;
}

void sub_10010C9D4(id a1, PKCreditRecoveryPaymentPlan *a2, id a3)
{
  id v4 = a2;
  -[PKCreditRecoveryPaymentPlan setEnrolled:](v4, "setEnrolled:", [a3 BOOLValue]);
}

void sub_10010CA2C(id a1, PKCreditRecoveryPaymentPlan *a2, id a3)
{
}

void sub_10010CA34(id a1, PKCreditRecoveryPaymentPlan *a2, id a3)
{
}

void sub_10010CA3C(id a1, PKCreditRecoveryPaymentPlan *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKCreditRecoveryPaymentPlan *)v3 setEnrollmentDate:v4];
}

void sub_10010CB94(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

id sub_10010CE94(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "_queue_performBackgroundPushProvisioningWithTransaction:", 0);
}

void sub_10010CF4C(uint64_t a1, char a2, char a3, void *a4)
{
  id v7 = a4;
  id v8 = *(NSObject **)(*(void *)(a1 + 32) + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10010D01C;
  block[3] = &unk_1007376B0;
  id v9 = *(id *)(a1 + 40);
  char v14 = a2;
  char v15 = a3;
  id v12 = v7;
  id v13 = v9;
  id v10 = v7;
  dispatch_async(v8, block);
}

uint64_t sub_10010D01C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(unsigned char *)(a1 + 48)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = *(unsigned char *)(a1 + 49) != 0;
  }
  return (*(uint64_t (**)(uint64_t, BOOL, void))(v2 + 16))(v2, v3, *(void *)(a1 + 32));
}

void sub_10010D340(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_10010D364(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(*(void *)(a1 + 32) + 80);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_10010D42C;
  void v11[3] = &unk_10072E598;
  id v12 = v6;
  id v13 = v7;
  id v9 = v6;
  id v10 = v7;
  [v8 updateWebServiceConfigurationWithCompletion:v11];
}

uint64_t sub_10010D42C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_10010D444(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(*(void *)(a1 + 32) + 80);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_10010D524;
  v13[3] = &unk_100737728;
  id v9 = *(id *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 48);
  id v16 = v7;
  uint64_t v17 = v10;
  id v14 = v9;
  id v15 = v6;
  id v11 = v6;
  id v12 = v7;
  [v8 performHandlerOnSharedWebServiceQueue:v13];
}

void sub_10010D524(uint64_t a1, void *a2)
{
  BOOL v3 = [a2 targetDevice];
  uint64_t v4 = *(void *)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_10010D5F4;
  v7[3] = &unk_100737700;
  long long v6 = *(_OWORD *)(a1 + 48);
  id v5 = (id)v6;
  long long v9 = v6;
  id v8 = *(id *)(a1 + 40);
  [v3 meetsProvisioningRequirements:v4 completion:v7];
}

uint64_t sub_10010D5F4(uint64_t a1, char a2, void *a3)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = a2;
  [a3 containsNotManagedAccount];
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
  return v4();
}

void sub_10010D648(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = [*(id *)(a1 + 32) shareablePassConfiguration];
  long long v9 = v8;
  if (v8 && [v8 primaryAction] == (id)1)
  {
    v7[2](v7, v6, 0);
  }
  else
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_10010D784;
    v13[3] = &unk_100737778;
    uint64_t v10 = *(void **)(a1 + 40);
    id v11 = *(id *)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 64);
    id v14 = v11;
    uint64_t v18 = v12;
    uint64_t v17 = v7;
    id v15 = v6;
    id v16 = *(id *)(a1 + 56);
    [v10 _webServiceForTargetDevice:2 completion:v13];
  }
}

void sub_10010D784(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [v5 targetDevice];
  if ((objc_opt_respondsToSelector() & 1) != 0
    && [v7 supportsCheckingProvisioningRequirements]
    && (objc_opt_respondsToSelector() & 1) != 0)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    void v20[2] = sub_10010D958;
    v20[3] = &unk_100737700;
    long long v9 = (id *)&v22;
    long long v14 = *(_OWORD *)(a1 + 56);
    id v10 = (id)v14;
    long long v22 = v14;
    id v11 = &v21;
    id v21 = *(id *)(a1 + 40);
    [v7 meetsProvisioningRequirements:v8 completion:v20];
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 48);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    void v16[2] = sub_10010D97C;
    v16[3] = &unk_100737750;
    long long v9 = &v18;
    id v18 = v6;
    id v11 = (id *)&v19;
    long long v15 = *(_OWORD *)(a1 + 56);
    id v13 = (id)v15;
    long long v19 = v15;
    id v17 = *(id *)(a1 + 40);
    [v7 paymentWebService:v5 canAddSecureElementPassWithConfiguration:v12 completion:v16];
  }
}

uint64_t sub_10010D958(void *a1, char a2)
{
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = a2;
  return (*(uint64_t (**)(void, void, void))(a1[5] + 16))(a1[5], a1[4], 0);
}

uint64_t sub_10010D97C(void *a1, char a2)
{
  (*(void (**)(void))(a1[5] + 16))();
  *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = a2;
  uint64_t v4 = *(uint64_t (**)(void))(a1[6] + 16);
  return v4();
}

void sub_10010D9E0(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void *)(a1[5] + 8);
  int v9 = *(unsigned __int8 *)(v8 + 24);
  if (*(unsigned char *)(v8 + 24) || *(unsigned char *)(*(void *)(a1[6] + 8) + 24))
  {
    id v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v11 = @"Y";
      if (v9) {
        CFStringRef v12 = @"Y";
      }
      else {
        CFStringRef v12 = @"N";
      }
      if (!*(unsigned char *)(*(void *)(a1[6] + 8) + 24)) {
        CFStringRef v11 = @"N";
      }
      int v16 = 138412546;
      CFStringRef v17 = v12;
      __int16 v18 = 2112;
      CFStringRef v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Push provisioning: _isPushProvisioningSupportedForConfiguration returning currentDeviceSupported: %@ companionDeviceSupported: %@", (uint8_t *)&v16, 0x16u);
    }

    (*(void (**)(void))(a1[4] + 16))();
  }
  else
  {
    id v13 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v16) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Push provisioning: Device nor watch supports push provisioning.", (uint8_t *)&v16, 2u);
    }

    uint64_t v14 = a1[4];
    long long v15 = +[NSError errorWithDomain:PKAddSecureElementPassErrorDomain code:4 userInfo:0];
    (*(void (**)(uint64_t, void, void, void *))(v14 + 16))(v14, 0, 0, v15);
  }
}

void sub_10010DE2C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)PKPaymentPushProvisioningSharingIdentifiersRequest);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_10010DEE8;
  v5[3] = &unk_1007377F0;
  id v6 = *(id *)(a1 + 32);
  [v3 pushProvisioningSharingIdentifiersWithRequest:v4 completion:v5];
}

void sub_10010DEE8(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a3;
  id v6 = [a2 sharedCredentials];
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v6, v5);
}

void sub_10010E164(uint64_t a1, void *a2)
{
  id v3 = a2;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_10010E2EC;
  void v12[3] = &unk_100737868;
  id v4 = *(id *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  id v6 = *(void **)(a1 + 48);
  id v13 = v4;
  uint64_t v14 = v5;
  id v15 = v6;
  id v7 = objc_retainBlock(v12);
  if ([v3 needsRegistration])
  {
    uint64_t v8 = [*(id *)(*(void *)(a1 + 40) + 80) deviceRegistrationServiceCoordinator];
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_10010E71C;
    v9[3] = &unk_100737890;
    void v9[4] = *(void *)(a1 + 40);
    id v10 = v7;
    id v11 = *(id *)(a1 + 48);
    [v8 performDeviceRegistrationForReason:@"Shareable Credential Status" brokerURL:0 action:1 forceApplePayRegister:0 forcePeerPaymentRegister:0 completion:v9];
  }
  else
  {
    ((void (*)(void *, id))v7[2])(v7, v3);
  }
}

void sub_10010E2EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = dispatch_group_create();
  v29[0] = 0;
  v29[1] = v29;
  void v29[2] = 0x3032000000;
  v29[3] = sub_10002088C;
  void v29[4] = sub_100020F38;
  id v30 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  uint64_t v16 = a1;
  id obj = *(id *)(a1 + 32);
  id v5 = [obj countByEnumeratingWithState:&v25 objects:v31 count:16];
  if (v5)
  {
    uint64_t v6 = *(void *)v26;
    do
    {
      id v7 = 0;
      do
      {
        if (*(void *)v26 != v6) {
          objc_enumerationMutation(obj);
        }
        uint64_t v8 = *(void **)(*((void *)&v25 + 1) + 8 * (void)v7);
        dispatch_group_enter(v4);
        int v9 = [v8 encryptedPushProvisioningTarget];

        if (v9)
        {
          id v10 = objc_alloc((Class)PKPaymentPushProvisioningSharingStatusRequest);
          id v11 = [v8 encryptedPushProvisioningTarget];
          id v12 = [v10 initWithEncryptedProvisioningTarget:v11];
        }
        else
        {
          id v13 = objc_alloc((Class)PKPaymentPushProvisioningSharingStatusRequest);
          id v11 = [v8 sharingInstanceIdentifier];
          uint64_t v14 = [v8 cardConfigurationIdentifier];
          id v12 = [v13 initWithProvisioningSharingIdentifier:v11 cardCardConfigurationIdentifer:v14];
        }
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 3221225472;
        v22[2] = sub_10010E634;
        void v22[3] = &unk_100737840;
        long long v24 = v29;
        void v22[4] = v8;
        id v23 = v4;
        [v3 pushProvisioningSharingStatusRequest:v12 completion:v22];

        id v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [obj countByEnumeratingWithState:&v25 objects:v31 count:16];
    }
    while (v5);
  }

  id v15 = *(NSObject **)(*(void *)(v16 + 40) + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10010E6C4;
  block[3] = &unk_100736D10;
  id v20 = *(id *)(v16 + 48);
  id v19 = *(id *)(v16 + 32);
  id v21 = v29;
  dispatch_group_notify(v4, v15, block);

  _Block_object_dispose(v29, 8);
}

void sub_10010E608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_10010E634(uint64_t a1, void *a2, id obj)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), obj);
  id v8 = obj;
  id v6 = a2;
  id v7 = [v6 sharingStatus];

  [*(id *)(a1 + 32) setStatus:v7];
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

uint64_t sub_10010E6C4(void *a1)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = PKAggregateSharingStatusForShareableCredentials();
  uint64_t v4 = a1[4];
  uint64_t v5 = *(void *)(*(void *)(a1[6] + 8) + 40);
  id v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 16);
  return v6(v2, v3, v4, v5);
}

void sub_10010E71C(uint64_t a1, char a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if ((a2 & 0x10) != 0)
  {
    id v10 = *(void **)(*(void *)(a1 + 32) + 80);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    id v12[2] = sub_10010E844;
    void v12[3] = &unk_100737818;
    id v13 = *(id *)(a1 + 40);
    [v10 performHandlerOnSharedWebServiceQueue:v12];
  }
  else
  {
    int v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Broker register failed. Returning unknown status for credentials", v11, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

uint64_t sub_10010E844(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10010E938(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [objc_alloc((Class)PKPaymentPushProvisioningProvideEncryptedPushProvisioningTargetRequest) initWithEncryptedPushProvisioningTarget:*(void *)(a1 + 32) sharingInstanceIdentifier:*(void *)(a1 + 40)];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_10010E9FC;
  v5[3] = &unk_1007378B8;
  id v6 = *(id *)(a1 + 48);
  [v3 provideEncryptedPushProvisioningTargetWithRequest:v4 completion:v5];
}

uint64_t sub_10010E9FC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10010EAB4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = dispatch_group_create();
  uint64_t v5 = +[NSMutableArray array];
  v17[0] = 0;
  v17[1] = v17;
  void v17[2] = 0x3032000000;
  v17[3] = sub_10002088C;
  void v17[4] = sub_100020F38;
  id v18 = 0;
  if (*(void *)(a1 + 48))
  {
    unint64_t v6 = 0;
    do
    {
      dispatch_group_enter(v4);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_10010ECC0;
      v13[3] = &unk_100737908;
      void v13[4] = *(void *)(a1 + 32);
      id v14 = v5;
      uint64_t v16 = v17;
      id v15 = v4;
      [v3 paymentProvisioningNonceOfType:0 completion:v13];

      ++v6;
    }
    while (v6 < *(void *)(a1 + 48));
  }
  id v7 = *(NSObject **)(*(void *)(a1 + 32) + 24);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_10010EE48;
  v9[3] = &unk_100737930;
  id v11 = *(id *)(a1 + 40);
  id v12 = v17;
  id v10 = v5;
  id v8 = v5;
  dispatch_group_notify(v4, v7, v9);

  _Block_object_dispose(v17, 8);
}

void sub_10010ECA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10010ECC0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10010EDBC;
  block[3] = &unk_1007378E0;
  id v13 = v5;
  id v14 = *(id *)(a1 + 40);
  id v15 = v6;
  long long v11 = *(_OWORD *)(a1 + 48);
  id v8 = (id)v11;
  long long v16 = v11;
  id v9 = v6;
  id v10 = v5;
  dispatch_async(v7, block);
}

void sub_10010EDBC(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) nonce];

  if (v2)
  {
    id v3 = *(void **)(a1 + 40);
    id v4 = [*(id *)(a1 + 32) nonce];
    [v3 addObject:v4];
  }
  id v5 = *(void **)(a1 + 48);
  if (v5) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), v5);
  }
  id v6 = *(NSObject **)(a1 + 56);
  dispatch_group_leave(v6);
}

void sub_10010EE48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40))
    {
      id v3 = *(void (**)(uint64_t, void))(v1 + 16);
      uint64_t v4 = *(void *)(a1 + 40);
      v3(v4, 0);
    }
    else
    {
      id v5 = [*(id *)(a1 + 32) copy];
      (*(void (**)(uint64_t, id, void))(v1 + 16))(v1, v5, *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
    }
  }
}

void sub_10010F300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
}

void sub_10010F358(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(*(void *)(a1 + 32) + 120);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_10010F440;
  void v12[3] = &unk_100737980;
  uint64_t v9 = *(void *)(a1 + 40);
  id v14 = v7;
  uint64_t v15 = v9;
  id v13 = v6;
  id v10 = v6;
  id v11 = v7;
  [v8 performDeviceRegistrationForReason:@"push provisioning nonces" brokerURL:0 action:1 forceApplePayRegister:0 forcePeerPaymentRegister:0 completion:v12];
}

void sub_10010F440(void *a1, char a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = v8;
  if ((a2 & 0x10) == 0 && v8)
  {
    id v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      id v12 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Push provisioning: configurePushProvisioningConfiguration failed registration with error: %@", (uint8_t *)&v11, 0xCu);
    }

    objc_storeStrong((id *)(*(void *)(a1[6] + 8) + 40), a4);
  }
  (*(void (**)(void, void, BOOL))(a1[5] + 16))(a1[5], a1[4], *(void *)(*(void *)(a1[6] + 8) + 40) != 0);
}

void sub_10010F558(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id v8 = *(void **)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_10010F638;
  void v12[3] = &unk_1007379A8;
  long long v15 = *(_OWORD *)(a1 + 48);
  uint64_t v16 = *(void *)(a1 + 64);
  id v13 = v6;
  id v14 = v7;
  id v10 = v6;
  id v11 = v7;
  [v8 _isPushProvisioningSupportedForConfiguration:v9 completion:v12];
}

void sub_10010F638(void *a1, int a2, int a3, void *a4)
{
  id v7 = a4;
  id v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v9 = @"N";
    if (a2) {
      CFStringRef v10 = @"Y";
    }
    else {
      CFStringRef v10 = @"N";
    }
    if (a3) {
      CFStringRef v9 = @"Y";
    }
    int v14 = 138412546;
    CFStringRef v15 = v10;
    __int16 v16 = 2112;
    CFStringRef v17 = v9;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Push provisioning: currentDeviceSupported: %@ companionDeviceSupported: %@", (uint8_t *)&v14, 0x16u);
  }

  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = a2;
  *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = a3;
  uint64_t v11 = *(void *)(a1[8] + 8);
  id v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v7;
  id v13 = v7;

  (*(void (**)(void, void, BOOL))(a1[5] + 16))(a1[5], a1[4], v13 != 0);
}

void sub_10010F77C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 3221225472;
  v24[2] = sub_10010F9AC;
  v24[3] = &unk_1007379D0;
  char v28 = *(unsigned char *)(a1 + 80);
  long long v27 = *(_OWORD *)(a1 + 56);
  id v8 = *(id *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  id v25 = v8;
  uint64_t v26 = v9;
  uint64_t v10 = sub_10010F9AC((uint64_t)v24);
  [*(id *)(a1 + 32) setTargetDevice:v10];
  uint64_t v11 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    id v12 = +[NSNumber numberWithUnsignedInteger:v10];
    *(_DWORD *)long long buf = 138412290;
    id v30 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Push provisioning: TargetDevice: %@", buf, 0xCu);
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_10010FAA4;
  v17[3] = &unk_100737A20;
  char v23 = *(unsigned char *)(a1 + 80);
  uint64_t v22 = *(void *)(a1 + 72);
  id v13 = *(void **)(a1 + 40);
  id v18 = *(id *)(a1 + 48);
  id v14 = *(id *)(a1 + 32);
  id v20 = v6;
  id v21 = v7;
  id v19 = v14;
  id v15 = v6;
  id v16 = v7;
  [v13 _webServiceForTargetDevice:v10 completion:v17];
}

uint64_t sub_10010F9AC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 64)) {
    return 1;
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
  {
    if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
      return 1;
    }
  }
  else if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24))
  {
    return 2;
  }
  id v3 = [*(id *)(a1 + 32) provisioningCredentialIdentifier];
  uint64_t v4 = [v3 dataUsingEncoding:4];

  id v5 = [v4 SHA256Hash];
  id v6 = [v5 base64EncodedStringWithOptions:0];

  unsigned int v7 = [*(id *)(a1 + 40) _hasProvisionedPassForCredentialHash:v6];
  unsigned int v8 = [*(id *)(a1 + 40) _companionHasProvisionedPassForCredentialHash:v6];
  uint64_t v9 = 1;
  if (!(v7 ^ 1 | v8)) {
    uint64_t v9 = 2;
  }
  if (v7 | v8 ^ 1) {
    uint64_t v1 = v9;
  }
  else {
    uint64_t v1 = 1;
  }

  return v1;
}

void sub_10010FAA4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_10010FBAC;
  v7[3] = &unk_1007379F8;
  char v14 = *(unsigned char *)(a1 + 72);
  uint64_t v13 = *(void *)(a1 + 64);
  id v8 = *(id *)(a1 + 32);
  id v9 = *(id *)(a1 + 40);
  id v11 = v5;
  id v12 = *(id *)(a1 + 56);
  id v10 = *(id *)(a1 + 48);
  id v6 = v5;
  [a2 paymentProvisioningNonceOfType:0 completion:v7];
}

void sub_10010FBAC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = [a2 nonce];
  unsigned int v7 = v6;
  if (v5)
  {
    if (*(unsigned char *)(a1 + 80))
    {
      id v8 = PKAddSecureElementPassErrorDomain;
      NSErrorUserInfoKey v13 = NSUnderlyingErrorKey;
      id v14 = v5;
      id v9 = +[NSDictionary dictionaryWithObjects:&v14 forKeys:&v13 count:1];
      goto LABEL_4;
    }
LABEL_10:
    [*(id *)(a1 + 32) setRequiresNonceValidityChecks:0];
    goto LABEL_11;
  }
  if ([v6 length])
  {
    [*(id *)(a1 + 40) setNonce:v7];
    goto LABEL_11;
  }
  if (!*(unsigned char *)(a1 + 80)) {
    goto LABEL_10;
  }
  id v9 = 0;
  id v8 = PKAddSecureElementPassErrorDomain;
LABEL_4:
  uint64_t v10 = +[NSError errorWithDomain:v8 code:4 userInfo:v9];
  uint64_t v11 = *(void *)(*(void *)(a1 + 72) + 8);
  id v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  if (v5) {
LABEL_11:
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  (*(void (**)(void, void, BOOL))(*(void *)(a1 + 64) + 16))(*(void *)(a1 + 64), *(void *)(a1 + 48), *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) != 0);
}

void sub_10010FD3C(uint64_t a1)
{
  uint64_t v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    *(_DWORD *)long long buf = 138412546;
    uint64_t v12 = v3;
    __int16 v13 = 2112;
    uint64_t v14 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Push provisioning: configurePushProvisioningConfiguration return configuration: %@ error: %@", buf, 0x16u);
  }

  id v5 = *(NSObject **)(*(void *)(a1 + 40) + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10010FE8C;
  block[3] = &unk_100737A70;
  long long v7 = *(_OWORD *)(a1 + 48);
  id v6 = (id)v7;
  long long v10 = v7;
  id v9 = *(id *)(a1 + 32);
  dispatch_async(v5, block);
}

uint64_t sub_10010FE8C(uint64_t a1)
{
  uint64_t v3 = a1 + 40;
  uint64_t v2 = *(void *)(a1 + 40);
  if (*(void *)(*(void *)(*(void *)(v3 + 8) + 8) + 40)) {
    return (*(uint64_t (**)(uint64_t, void))(v2 + 16))(v2, 0);
  }
  else {
    return (*(uint64_t (**)(uint64_t, void))(v2 + 16))(v2, *(void *)(a1 + 32));
  }
}

id sub_10011009C(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 40) + 41) = 1;
  return objc_msgSend(*(id *)(a1 + 40), "_queue_performBackgroundPushProvisioningWithTransaction:", 0);
}

void sub_100110254(uint64_t a1, int a2)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 40) = 0;
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(unsigned __int8 *)(v4 + 42);
  *(unsigned char *)(v4 + 42) = 0;
  id v6 = PKLogFacilityTypeGetObject();
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v7)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Push provisioning: Finished background provision sharing identifiers", buf, 2u);
    }

    id v8 = *(unsigned char **)(a1 + 32);
    if (v5 || v8[41]) {
      objc_msgSend(v8, "_queue_performBackgroundPushProvisioningWithTransaction:", *(void *)(a1 + 40));
    }
  }
  else
  {
    if (v7)
    {
      *(_WORD *)id v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Push provisioning: failed to background provision sharing identifiers", v9, 2u);
    }
  }
}

void sub_1001105B0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1001105C8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = *(void *)(a1 + 32);
  id v9 = *(void **)(v8 + 80);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_100110694;
  void v12[3] = &unk_100737B10;
  id v13 = v6;
  id v14 = v7;
  void v12[4] = v8;
  id v10 = v6;
  id v11 = v7;
  [v9 performHandlerOnSharedWebServiceQueue:v12];
}

void sub_100110694(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 80) deviceRegistrationServiceCoordinator];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100110764;
  v3[3] = &unk_100737AE8;
  id v5 = *(id *)(a1 + 48);
  id v4 = *(id *)(a1 + 40);
  [v2 performDeviceRegistrationForReason:@"background push provisioning" brokerURL:0 action:1 forceApplePayRegister:0 forcePeerPaymentRegister:0 completion:v3];
}

uint64_t sub_100110764(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_10011077C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_100110844;
  void v12[3] = &unk_100737B60;
  id v9 = *(void **)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  id v14 = v7;
  uint64_t v15 = v8;
  void v12[4] = v9;
  id v13 = v6;
  id v10 = v6;
  id v11 = v7;
  [v9 pushProvisioningSharingIdentifiers:v12];
}

void sub_100110844(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100110948;
  block[3] = &unk_100737B38;
  id v13 = v6;
  long long v11 = *(_OWORD *)(a1 + 48);
  id v8 = (id)v11;
  long long v17 = v11;
  id v14 = *(id *)(a1 + 40);
  id v15 = v5;
  uint64_t v16 = *(void *)(a1 + 32);
  id v9 = v5;
  id v10 = v6;
  dispatch_async(v7, block);
}

uint64_t sub_100110948(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (!v2)
  {
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v6 = *(id *)(a1 + 48);
    id v7 = [v6 countByEnumeratingWithState:&v22 objects:v30 count:16];
    if (!v7) {
      goto LABEL_19;
    }
    id v9 = v7;
    uint64_t v10 = *(void *)v23;
    *(void *)&long long v8 = 138412546;
    long long v21 = v8;
LABEL_7:
    uint64_t v11 = 0;
    while (1)
    {
      if (*(void *)v23 != v10) {
        objc_enumerationMutation(v6);
      }
      uint64_t v12 = *(void **)(*((void *)&v22 + 1) + 8 * v11);
      id v13 = objc_msgSend(v12, "type", v21, (void)v22);
      if (v13 == (id)2)
      {
        id v15 = objc_alloc((Class)PKPendingAccountCredential);
        uint64_t v16 = [v12 accountIdentifier];
        id v17 = [v12 feature];
        id v18 = [v12 sharingInstanceIdentifier];
        id v14 = [v15 initWithAccountIdentifier:v16 feature:v17 sharingInstanceIdentifier:v18];

        if (!v14) {
          goto LABEL_15;
        }
      }
      else if (v13 != (id)1 {
             || (id v14 = [objc_alloc((Class)PKPendingShareableCredential) initWithSharedCredential:v12]) == 0)
      }
      {
LABEL_15:
        id v14 = PKLogFacilityTypeGetObject();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          id v19 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v12 type]);
          *(_DWORD *)long long buf = v21;
          long long v27 = v12;
          __int16 v28 = 2112;
          id v29 = v19;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Push provisioning: failed to parse credential %@ \n\n type: %@", buf, 0x16u);
        }
        goto LABEL_17;
      }
      [v14 setShouldAutoProvision:1];
      [*(id *)(*(void *)(a1 + 56) + 136) storePendingProvisioning:v14];
LABEL_17:

      if (v9 == (id)++v11)
      {
        id v9 = [v6 countByEnumeratingWithState:&v22 objects:v30 count:16];
        if (!v9) {
          goto LABEL_19;
        }
        goto LABEL_7;
      }
    }
  }
  uint64_t v3 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    long long v27 = v2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Push provisioning: failed to get shared credentials, error: %@", buf, 0xCu);
  }

  uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 8);
  id v5 = *(id *)(a1 + 32);
  id v6 = *(id *)(v4 + 40);
  *(void *)(v4 + 40) = v5;
LABEL_19:

  return (*(uint64_t (**)(void))(*(void *)(a1 + 64) + 16))();
}

void sub_100110C18(uint64_t a1)
{
  uint64_t v1 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100110CB4;
  block[3] = &unk_100737B88;
  long long v3 = *(_OWORD *)(a1 + 40);
  id v2 = (id)v3;
  long long v5 = v3;
  dispatch_async(v1, block);
}

uint64_t sub_100110CB4(uint64_t a1)
{
  return (*(uint64_t (**)(void, BOOL))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0);
}

uint64_t sub_100110D80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(result + 16))(result, a2, a4);
  }
  return result;
}

void sub_1001111A8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1001111FC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  long long v8 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1001112C4;
  void v11[3] = &unk_10072E598;
  id v12 = v6;
  id v13 = v7;
  id v9 = v6;
  id v10 = v7;
  dispatch_async(v8, v11);
}

uint64_t sub_1001112C4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32), 0);
}

void sub_1001112DC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  long long v8 = v7;
  if (*(unsigned char *)(a1 + 56))
  {
    uint64_t v9 = *(void *)(a1 + 32);
    id v10 = *(void **)(v9 + 104);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_1001113E8;
    v13[3] = &unk_100737C28;
    void v13[4] = v9;
    id v11 = *(id *)(a1 + 40);
    uint64_t v12 = *(void *)(a1 + 48);
    id v14 = v11;
    uint64_t v17 = v12;
    id v16 = v8;
    id v15 = v6;
    [v10 familyMembersWithCachePolicy:0 completion:v13];
  }
  else
  {
    (*((void (**)(id, id, void))v7 + 2))(v7, v6, 0);
  }
}

void sub_1001113E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(NSObject **)(*(void *)(a1 + 32) + 16);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001114D8;
  block[3] = &unk_100737C00;
  id v9 = v3;
  id v10 = *(id *)(a1 + 40);
  long long v7 = *(_OWORD *)(a1 + 56);
  id v5 = (id)v7;
  long long v12 = v7;
  id v11 = *(id *)(a1 + 48);
  id v6 = v3;
  dispatch_async(v4, block);
}

void sub_1001114D8(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) count];
    *(_DWORD *)long long buf = 134217984;
    id v33 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Push provisioning: Retrived %lu family members", buf, 0xCu);
  }

  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v27 = [v4 countByEnumeratingWithState:&v28 objects:v36 count:16];
  if (!v27)
  {

    long long v7 = 0;
    id v6 = 0;
    goto LABEL_36;
  }
  id v6 = 0;
  long long v7 = 0;
  uint64_t v26 = *(void *)v29;
  *(void *)&long long v5 = 138412546;
  long long v24 = v5;
  uint64_t v8 = a1;
  id obj = v4;
  while (2)
  {
    for (uint64_t i = 0; i != v27; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v29 != v26) {
        objc_enumerationMutation(obj);
      }
      id v10 = *(void **)(*((void *)&v28 + 1) + 8 * i);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        id v11 = [*(id *)(a1 + 40) appleIdentifier];
        long long v12 = PKIDSNormalizedAddress();
        id v13 = [v10 appleID];
        id v14 = PKIDSNormalizedAddress();
        *(_DWORD *)long long buf = v24;
        id v33 = v12;
        __int16 v34 = 2112;
        id v35 = v14;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Push provisioning: Attempting to match recipient: %@ to familyMember: %@", buf, 0x16u);

        a1 = v8;
      }

      id v15 = [v10 appleID];
      id v16 = PKIDSNormalizedAddress();
      uint64_t v17 = [*(id *)(a1 + 40) appleIdentifier];
      unsigned int v18 = [v16 isEqualToString:v17];

      if (v18)
      {
        id v19 = v10;

        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Push provisioning: Found family member with matching AppleAccount", buf, 2u);
        }

        id v6 = v19;
      }
      a1 = v8;
      if (objc_msgSend(v10, "isMe", v24))
      {
        id v20 = v10;

        long long v7 = v20;
      }
      if (v6 && v7)
      {

LABEL_23:
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Push provisioning: Found family member with matching AppleAccount", buf, 2u);
        }

        if (([v6 memberType] == (id)1 || objc_msgSend(v6, "memberType") == (id)2)
          && (([v7 isOrganizer] & 1) != 0 || objc_msgSend(v7, "isParent")))
        {
          if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Push provisioning: recipient is child member of iCloud family and sender is an organizer or parent. Updating provisioning target", buf, 2u);
          }

          long long v21 = *(void **)(v8 + 40);
          long long v22 = [v6 dsid];
          long long v23 = [v22 stringValue];
          [v21 setAppleIdentifier:v23];

          [*(id *)(v8 + 40) setAppleIdentifierType:3];
          *(unsigned char *)(*(void *)(*(void *)(v8 + 64) + 8) + 24) = 1;
        }
        else
        {
          if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Push provisioning: Family member is not an adult or sender is not a parent or organizer.", buf, 2u);
          }
        }
        goto LABEL_36;
      }
    }
    id v27 = [obj countByEnumeratingWithState:&v28 objects:v36 count:16];
    if (v27) {
      continue;
    }
    break;
  }

  if (v6) {
    goto LABEL_23;
  }
LABEL_36:
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_100111934(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = a1[6];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100111A0C;
  v13[3] = &unk_100737C78;
  id v10 = (void *)a1[4];
  uint64_t v9 = a1[5];
  id v15 = v7;
  uint64_t v16 = v9;
  id v14 = v6;
  id v11 = v6;
  id v12 = v7;
  [v10 _webServiceForTargetDevice:v8 completion:v13];
}

void sub_100111A0C(uint64_t a1, void *a2, void *a3)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a2);
  id v7 = a2;
  id v6 = a3;
  v6[2]();

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100111A9C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = [*(id *)(a1 + 32) nonce];

  if (v8)
  {
    v7[2](v7, v6, 0);
  }
  else
  {
    uint64_t v9 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    id v12[2] = sub_100111BB8;
    void v12[3] = &unk_100737CC8;
    id v10 = *(id *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 48);
    id v13 = v10;
    uint64_t v16 = v11;
    id v15 = v7;
    id v14 = v6;
    [v9 paymentProvisioningNonceOfType:0 completion:v12];
  }
}

void sub_100111BB8(uint64_t a1, void *a2, void *a3)
{
  id v6 = a3;
  id v7 = *(void **)(a1 + 32);
  uint64_t v8 = [a2 nonce];
  [v7 setNonce:v8];

  if (v6
    || ([*(id *)(a1 + 32) nonce],
        id v12 = objc_claimAutoreleasedReturnValue(),
        v12,
        !v12))
  {
    uint64_t v9 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      int v13 = 138412546;
      id v14 = v6;
      __int16 v15 = 2112;
      uint64_t v16 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Push provisioning: Failed to set fetch nonce with error: %@ from target: %@", (uint8_t *)&v13, 0x16u);
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), a3);
    uint64_t v11 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  }
  else
  {
    uint64_t v11 = *(void (**)(void))(*(void *)(a1 + 48) + 16);
  }
  v11();
}

void sub_100111D10(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = [*(id *)(*(void *)(a1[6] + 8) + 40) context];
  uint64_t v9 = [v8 primaryRegion];
  uint64_t v10 = [v9 certificates];

  if (v10)
  {
    uint64_t v11 = (void *)a1[4];
    uint64_t v12 = a1[5];
    int v13 = [*(id *)(*(void *)(a1[6] + 8) + 40) context];
    id v14 = [v13 devSigned];
    uint64_t v15 = *(void *)(a1[8] + 8);
    id obj = *(id *)(v15 + 40);
    uint64_t v16 = [v11 _encryptProvisioningTarget:v12 devSigned:v14 certificateChain:v10 error:&obj];
    objc_storeStrong((id *)(v15 + 40), obj);
    uint64_t v17 = *(void *)(a1[7] + 8);
    unsigned int v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;

    [*(id *)(*(void *)(a1[7] + 8) + 40) setTargetDevice:a1[10]];
    if (*(unsigned char *)(*(void *)(a1[9] + 8) + 24) && !*(void *)(*(void *)(a1[8] + 8) + 40))
    {
      id v23 = objc_alloc((Class)PKPaymentPushProvisioningProvideEncryptedPushProvisioningTargetRequest);
      uint64_t v24 = *(void *)(*(void *)(a1[7] + 8) + 40);
      long long v25 = [(id)a1[5] sharingInstanceIdentifier];
      id v26 = [v23 initWithEncryptedPushProvisioningTarget:v24 sharingInstanceIdentifier:v25];

      id v27 = *(void **)(*(void *)(a1[6] + 8) + 40);
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472;
      void v29[2] = sub_100111FC4;
      v29[3] = &unk_1007307C0;
      uint64_t v32 = a1[8];
      id v31 = v7;
      id v30 = v6;
      [v27 provideEncryptedPushProvisioningTargetWithRequest:v26 completion:v29];
    }
    else
    {
      (*((void (**)(id, id, void))v7 + 2))(v7, v6, 0);
    }
  }
  else
  {
    id v19 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v28 = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Push provisioning: Certificate chain is missing! Not encrypting provisioning target", v28, 2u);
    }

    uint64_t v20 = +[NSError errorWithDomain:PKPassKitErrorDomain code:-1 userInfo:0];
    uint64_t v21 = *(void *)(a1[8] + 8);
    long long v22 = *(void **)(v21 + 40);
    *(void *)(v21 + 40) = v20;
  }
}

void sub_100111FC4(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a2);
  id v4 = a2;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100112030(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  uint64_t v8 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = a1[9];
    uint64_t v10 = *(void *)(*(void *)(a1[6] + 8) + 40);
    *(_DWORD *)long long buf = 134218242;
    uint64_t v18 = v9;
    __int16 v19 = 2112;
    uint64_t v20 = v10;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Push provisioning: Created encryptedProvisioningTarget for targetType: %lu error: %@", buf, 0x16u);
  }

  uint64_t v11 = (void *)a1[5];
  if (v11)
  {
    uint64_t v12 = *(NSObject **)(a1[4] + 24);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_100112198;
    v13[3] = &unk_100737D18;
    id v14 = v11;
    long long v15 = *((_OWORD *)a1 + 3);
    uint64_t v16 = a1[8];
    dispatch_async(v12, v13);
  }
}

uint64_t sub_100112198(void *a1)
{
  uint64_t v2 = a1[4];
  if (*(void *)(*(void *)(a1[5] + 8) + 40)) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = *(void *)(*(void *)(a1[6] + 8) + 40);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(v2 + 16))(v2, v3, *(unsigned __int8 *)(*(void *)(a1[7] + 8) + 24));
}

void sub_1001125A0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  id v7 = [objc_alloc((Class)PKPaymentProvisioningController) initWithWebService:v6 localPaymentService:0];

  uint64_t v8 = [*(id *)(a1 + 32) externalizedAuth];
  [v7 storeExternalizedAuth:v8];

  [v7 setCloudStoreCoordinator:*(void *)(*(void *)(a1 + 40) + 112)];
  id v9 = [objc_alloc((Class)PKProvisioningContext) initWithEnvironment:0 provisioningController:v7 groupsController:0];
  objc_msgSend(v9, "setIsBackground:", objc_msgSend(*(id *)(a1 + 32), "isBackgroundProvisioning"));
  id v10 = [objc_alloc((Class)PKProvisioningBackgroundCoordinator) initWithSetupContext:v9 credential:*(void *)(a1 + 32) previouslyAcceptedTerms:1];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100112740;
  v13[3] = &unk_100737D68;
  id v14 = *(id *)(a1 + 32);
  id v16 = *(id *)(a1 + 48);
  id v17 = v5;
  id v15 = v10;
  id v11 = v10;
  id v12 = v5;
  [v11 startWithCompletion:v13];
}

void sub_100112740(void *a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = [a2 firstObject];
  id v7 = [v6 secureElementPass];
  uint64_t v8 = [v7 paymentPass];

  id v9 = PKLogFacilityTypeGetObject();
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (v10)
    {
      uint64_t v11 = a1[4];
      id v12 = [v8 uniqueID];
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      id v17 = v12;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Push provisioning (%@): Successfully provisioned pass %@", (uint8_t *)&v14, 0x16u);
    }
  }
  else if (v10)
  {
    uint64_t v13 = a1[4];
    int v14 = 138412546;
    uint64_t v15 = v13;
    __int16 v16 = 2112;
    id v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Push provisioning (%@): failed with error: %@", (uint8_t *)&v14, 0x16u);
  }

  (*(void (**)(void))(a1[6] + 16))();
  (*(void (**)(void))(a1[7] + 16))();
}

uint64_t sub_100112A54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(result + 16))(result, a2, a3, a5);
  }
  return result;
}

uint64_t sub_100112BFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(result + 16))(result, a2, a3, a5);
  }
  return result;
}

void sub_100112F98(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  _Block_object_dispose((const void *)(v3 - 160), 8);
  objc_destroyWeak((id *)(v3 - 168));
  _Unwind_Resume(a1);
}

void sub_100112FE0(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)) {
    BOOL v3 = WeakRetained == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    id v6 = WeakRetained;
    objc_msgSend(WeakRetained[1], "invalidateAssertionOfType:withIdentifier:handler:", 1);
    uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
    id v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = 0;

    id WeakRetained = v6;
  }
}

uint64_t sub_100113064(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  BOOL v3 = *(uint64_t (**)(void))(*(void *)(a1 + 48) + 16);
  return v3();
}

void sub_1001130B4(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    BOOL v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
      *(_DWORD *)long long buf = 138412546;
      uint64_t v19 = v4;
      __int16 v20 = 2112;
      uint64_t v21 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Push provisioning (%@): Unable to acquire provisioning in progress assertion with id %@; Continuing anyway...",
        buf,
        0x16u);
    }
  }
  id v6 = *(void **)(a1 + 40);
  id v7 = [*(id *)(a1 + 32) encryptedProvisioningTarget];
  id v8 = [v7 targetDevice];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_1001132B0;
  void v11[3] = &unk_100737E80;
  int8x16_t v10 = *(int8x16_t *)(a1 + 32);
  id v9 = (id)v10.i64[0];
  int8x16_t v12 = vextq_s8(v10, v10, 8uLL);
  id v13 = *(id *)(a1 + 48);
  objc_copyWeak(&v17, (id *)(a1 + 88));
  id v14 = *(id *)(a1 + 56);
  id v15 = *(id *)(a1 + 64);
  id v16 = *(id *)(a1 + 72);
  [v6 _webServiceForTargetDevice:v8 completion:v11];

  objc_destroyWeak(&v17);
}

void sub_100113294(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1001132B0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [objc_alloc((Class)PKPaymentProvisioningController) initWithWebService:v5 localPaymentService:0];
  [v7 setCloudStoreCoordinator:*(void *)(*(void *)(a1 + 32) + 112)];
  id v8 = [objc_alloc((Class)PKPaymentEligibilityRequest) initWithPaymentCredential:*(void *)(a1 + 40)];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  id v11[2] = sub_100113458;
  void v11[3] = &unk_100737E58;
  id v12 = *(id *)(a1 + 40);
  id v9 = v6;
  id v14 = v9;
  id v15 = *(id *)(a1 + 48);
  objc_copyWeak(&v19, (id *)(a1 + 80));
  id v16 = *(id *)(a1 + 56);
  id v17 = *(id *)(a1 + 64);
  id v10 = v7;
  id v13 = v10;
  id v18 = *(id *)(a1 + 72);
  [v10 requestEligibility:v8 withCompletionHandler:v11];

  objc_destroyWeak(&v19);
}

void sub_100113444(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_100113458(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unint64_t v7 = (unint64_t)[v5 eligibilityStatus];
  if (v6)
  {
    id v8 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412546;
      uint64_t v27 = v9;
      __int16 v28 = 2112;
      CFStringRef v29 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Push provisioning (%@): eligibility request failed with error: %@", buf, 0x16u);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    unint64_t v10 = v7;
    if ((v7 & 0xFFFFFFFFFFFFFFFELL) == 4)
    {
      uint64_t v11 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v12 = @"OS";
        uint64_t v13 = *(void *)(a1 + 32);
        if (v10 == 5) {
          CFStringRef v12 = @"hardware";
        }
        *(_DWORD *)long long buf = 138412546;
        uint64_t v27 = v13;
        __int16 v28 = 2112;
        CFStringRef v29 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Push provisioning (%@): device %@ not supported", buf, 0x16u);
      }

      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));
      [WeakRetained _handleUnsupportedDeviceResponse:v5 completion:*(void *)(a1 + 64)];
    }
    else if ((v7 & 0xFFFFFFFFFFFFFFFBLL) == 3)
    {
      (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));
      [WeakRetained _handleExpectedPassUpdateForEligibilityResponse:v5 completion:*(void *)(a1 + 64)];
    }
    else if (v7 == 1)
    {
      [*(id *)(a1 + 40) passcodeUpgradeCompleted:1];
      [*(id *)(a1 + 40) acceptTerms];
      id WeakRetained = (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
      id v15 = *(void **)(a1 + 40);
      id v16 = [*(id *)(a1 + 32) externalizedAuth];
      [v15 storeExternalizedAuth:v16];

      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472;
      v21[2] = sub_100113818;
      v21[3] = &unk_100737E30;
      id v17 = *(void **)(a1 + 40);
      id v22 = *(id *)(a1 + 32);
      id v24 = *(id *)(a1 + 48);
      id v25 = *(id *)(a1 + 56);
      id v23 = *(id *)(a1 + 40);
      [v17 requestProvisioning:WeakRetained withCompletion:v21];
    }
    else
    {
      id v18 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 138412546;
        uint64_t v27 = v19;
        __int16 v28 = 1024;
        LODWORD(v29) = [v5 eligibilityStatus];
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Push provisioning (%@): got eligibility status %d", buf, 0x12u);
      }

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      uint64_t v20 = *(void *)(a1 + 56);
      id WeakRetained = PKDisplayableErrorForCommonType();
      (*(void (**)(uint64_t, void, void, void, void *))(v20 + 16))(v20, 0, 0, 0, WeakRetained);
    }
  }
}

void sub_100113818(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    unint64_t v10 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      int v14 = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      id v17 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Push provisioning (%@): failed with error: %@", (uint8_t *)&v14, 0x16u);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  uint64_t v12 = *(void *)(a1 + 56);
  uint64_t v13 = [*(id *)(a1 + 40) moreInfoItems];
  (*(void (**)(uint64_t, BOOL, id, void *, id))(v12 + 16))(v12, v7 != 0, v7, v13, v9);
}

uint64_t sub_100113BB8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, 0, 0, *(void *)(a1 + 32));
}

void sub_100113DF4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = *(NSObject **)(*(void *)(a1 + 32) + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100113ED0;
  block[3] = &unk_10072E9D8;
  id v11 = v6;
  id v12 = v5;
  id v13 = *(id *)(a1 + 40);
  id v8 = v5;
  id v9 = v6;
  dispatch_async(v7, block);
}

void sub_100113ED0(void *a1)
{
  if (a1[4])
  {
    uint64_t v2 = a1[6];
LABEL_3:
    BOOL v3 = *(void (**)(uint64_t, void, void, void))(v2 + 16);
    v3(v2, 0, 0, 0);
    return;
  }
  uint64_t v4 = (void *)a1[5];
  uint64_t v2 = a1[6];
  if (!v4) {
    goto LABEL_3;
  }
  id v5 = [v4 paymentPass];
  (*(void (**)(uint64_t, uint64_t, id, void, void))(v2 + 16))(v2, 1, v5, 0, a1[4]);
}

void sub_100113F8C(void *a1)
{
  uint64_t v2 = [*(id *)(a1[4] + 64) paymentApplicationWithDPANIdentifier:a1[5]];
  BOOL v3 = [*(id *)(a1[4] + 64) passWithPaymentApplication:v2];
  uint64_t v4 = [v3 secureElementPass];

  id v5 = PKLogFacilityTypeGetObject();
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      LOWORD(v10) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Push provisioning: Found pass being updated for DPAN. Returning it.", (uint8_t *)&v10, 2u);
    }

    (*(void (**)(void))(a1[6] + 16))();
  }
  else
  {
    if (v6)
    {
      uint64_t v7 = a1[5];
      int v10 = 138412290;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Push provisioning: Unable to find pass on device for DPAN identifier '%@'", (uint8_t *)&v10, 0xCu);
    }

    uint64_t v8 = a1[6];
    id v9 = +[NSError errorWithDomain:PKAddSecureElementPassErrorDomain code:2 userInfo:0];
    (*(void (**)(uint64_t, void, void *))(v8 + 16))(v8, 0, v9);
  }
}

BOOL sub_100114260(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 secureElementPass];
  if (v4)
  {
    id v5 = [v3 provisioningCredentialHash];
    BOOL v6 = *(void **)(a1 + 32);
    id v7 = v5;
    id v8 = v6;
    if (v7 == v8)
    {
    }
    else
    {
      id v9 = v8;
      if (!v7 || !v8)
      {

LABEL_11:
        BOOL v11 = 0;
        goto LABEL_12;
      }
      unsigned int v10 = [v7 isEqualToString:v8];

      if (!v10) {
        goto LABEL_11;
      }
    }
    BOOL v11 = [v4 passActivationState] != (id)4;
LABEL_12:

    goto LABEL_13;
  }
  BOOL v11 = 0;
LABEL_13:

  return v11;
}

void sub_1001144A0(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 44));
  --*(void *)(*(void *)(a1 + 32) + 48);
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(void *)(v2 + 48))
  {
    id v3 = *(void **)(v2 + 56);
    *(void *)(v2 + 56) = 0;

    uint64_t v2 = *(void *)(a1 + 32);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 44));
}

uint64_t sub_10011450C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

Class sub_1001146D0()
{
  if (qword_100808C00 != -1) {
    dispatch_once(&qword_100808C00, &stru_100737F38);
  }
  Class result = objc_getClass("NPKSharedWebServiceProvider");
  qword_100808BF0 = (uint64_t)result;
  off_1008058A0 = (uint64_t (*)())sub_100114734;
  return result;
}

id sub_100114734()
{
  return (id)qword_100808BF0;
}

void sub_100114740(id a1)
{
  qword_100808BF8 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/NanoPassKit.framework/NanoPassKit", 2);
}

void sub_100114EB0(id a1, PKSavingsAccountDetails *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKSavingsAccountDetails *)v3 setLastUpdatedDate:v4];
}

void sub_100114F10(id a1, PKSavingsAccountDetails *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKSavingsAccountDetails *)v3 setCreatedDate:v4];
}

void sub_100114F70(id a1, PKSavingsAccountDetails *a2, id a3)
{
}

void sub_100114F78(id a1, PKSavingsAccountDetails *a2, id a3)
{
}

void sub_100114F80(id a1, PKSavingsAccountDetails *a2, id a3)
{
  if (a3)
  {
    id v4 = a2;
    id v5 = +[NSTimeZone timeZoneWithName:a3];
    [(PKSavingsAccountDetails *)v4 setProductTimeZone:v5];
  }
}

void sub_100115000(id a1, PKSavingsAccountDetails *a2, id a3)
{
  id v4 = a2;
  -[PKSavingsAccountDetails setMoreInfoRequired:](v4, "setMoreInfoRequired:", [a3 BOOLValue]);
}

void sub_100115058(id a1, PKSavingsAccountDetails *a2, id a3)
{
  id v4 = a2;
  -[PKSavingsAccountDetails setTermsAcceptanceRequired:](v4, "setTermsAcceptanceRequired:", [a3 BOOLValue]);
}

void sub_1001150B0(id a1, PKSavingsAccountDetails *a2, id a3)
{
}

void sub_1001150B8(id a1, PKSavingsAccountDetails *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKSavingsAccountDetails *)v3 setPrivacyPolicyURL:v4];
}

void sub_100115118(id a1, PKSavingsAccountDetails *a2, id a3)
{
}

void sub_100115120(id a1, PKSavingsAccountDetails *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_URLForSQLValue();
  [(PKSavingsAccountDetails *)v3 setContactWebsite:v4];
}

void sub_100115180(id a1, PKSavingsAccountDetails *a2, id a3)
{
}

void sub_100115188(id a1, PKSavingsAccountDetails *a2, id a3)
{
}

void sub_100115190(id a1, PKSavingsAccountDetails *a2, id a3)
{
}

void sub_100115198(id a1, PKSavingsAccountDetails *a2, id a3)
{
  id v4 = a2;
  -[PKSavingsAccountDetails setFccStepUpRequired:](v4, "setFccStepUpRequired:", [a3 BOOLValue]);
}

void sub_100115384(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

uint64_t sub_1001156BC(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  uint64_t result = self;
  if (v4 && v5)
  {
    char v7 = [v4 contactlessActivationGroupingType] == (id)2;
    id v8 = [PDSECredentialEntry alloc];
    id v9 = [v4 uniqueID];
    unsigned int v10 = [v5 automaticSelectionCriteria];
    BOOL v11 = sub_100115780((id *)&v8->super.isa, v9, v7, v10);

    return (uint64_t)v11;
  }
  else
  {
    __break(1u);
  }
  return result;
}

id *sub_100115780(id *a1, void *a2, char a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  id v9 = v8;
  if (!a1) {
    goto LABEL_81;
  }
  unsigned int v10 = 0;
  if (!v7 || !v8) {
    goto LABEL_82;
  }
  if (![v8 count])
  {
LABEL_81:
    unsigned int v10 = 0;
    goto LABEL_82;
  }
  v89.receiver = a1;
  v89.super_class = (Class)PDSECredentialEntry;
  a1 = (id *)objc_msgSendSuper2(&v89, "init");
  if (!a1) {
    goto LABEL_72;
  }
  id v11 = [v7 copy];
  id v12 = a1[4];
  a1[4] = v11;

  objc_storeStrong(a1 + 5, a4);
  id v81 = [v9 firstObject];
  id v13 = (char *)[v81 technologyType];
  if ((unint64_t)(v13 - 1) > 6)
  {
    id v17 = v81;
LABEL_80:

    goto LABEL_81;
  }
  unint64_t v14 = (unint64_t)v13;
  uint64_t v15 = (uint64_t)*(&off_100738308 + (void)(v13 - 1));
  unsigned int v16 = [v81 supportsExpress];
  unsigned int v83 = [v81 supportsInSessionExpress];
  unsigned int v84 = v16;
  *((unsigned char *)a1 + _Block_object_dispose(&STACK[0x420], 8) = v16;
  *((unsigned char *)a1 + 9) = v83;
  *((unsigned char *)a1 + 27) = v83;
  *((unsigned char *)a1 + 29) = a3;
  id v17 = objc_alloc_init((Class)NSMutableDictionary);
  [v17 setObject:v7 forKeyedSubscript:@"passUniqueID"];
  [v17 setObject:v15 forKeyedSubscript:@"ExpressType"];
  BOOL v18 = *((unsigned char *)a1 + 8) && *((unsigned char *)a1 + 24) && *((unsigned char *)a1 + 26) == 0;
  uint64_t v19 = +[NSNumber numberWithBool:v18];
  [v17 setObject:v19 forKeyedSubscript:@"expressEnabled"];

  BOOL v20 = *((unsigned char *)a1 + 28) && *((unsigned char *)a1 + 25) && *((unsigned char *)a1 + 26) == 0;
  uint64_t v21 = +[NSNumber numberWithBool:v20];
  [v17 setObject:v21 forKeyedSubscript:@"UWBExpressEnabled"];

  if (*((unsigned char *)a1 + 9)) {
    BOOL v22 = *((unsigned char *)a1 + 27) != 0;
  }
  else {
    BOOL v22 = 0;
  }
  id v23 = +[NSNumber numberWithBool:v22];
  [v17 setObject:v23 forKeyedSubscript:@"inSessionOnly"];

  id v24 = +[NSNumber numberWithBool:*((unsigned __int8 *)a1 + 29)];
  [v17 setObject:v24 forKeyedSubscript:@"userChoice"];

  if ((v14 & 0xFFFFFFFFFFFFFFFELL) == 4)
  {
    id v76 = objc_alloc_init((Class)NSMutableDictionary);
    objc_msgSend(v17, "setObject:forKeyedSubscript:");
  }
  else
  {
    id v76 = 0;
  }
  long long v87 = 0u;
  long long v88 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  id obj = v9;
  id v25 = [obj countByEnumeratingWithState:&v85 objects:v90 count:16];
  if (!v25) {
    goto LABEL_65;
  }
  id v26 = v25;
  uint64_t v82 = *(void *)v86;
  unint64_t v74 = v14;
  id v75 = v17;
  id v73 = v7;
  while (2)
  {
    uint64_t v27 = 0;
    id v79 = v26;
    do
    {
      if (*(void *)v86 != v82) {
        objc_enumerationMutation(obj);
      }
      __int16 v28 = *(void **)(*((void *)&v85 + 1) + 8 * (void)v27);
      if ([v28 technologyType] != (id)v14
        || v84 != [v28 supportsExpress]
        || v83 != [v28 supportsInSessionExpress])
      {
        goto LABEL_79;
      }
      id v29 = v17;
      id v30 = v28;
      unint64_t v31 = (unint64_t)[v30 technologyType];
      if (v31 <= 7)
      {
        if (((1 << v31) & 0xCF) != 0) {
          goto LABEL_63;
        }
        if (v31 == 4)
        {
          uint64_t v32 = [v29 objectForKey:@"ECP2Info"];
          if (!v32) {
            goto LABEL_78;
          }
          id v33 = (void *)v32;
          __int16 v34 = [v30 primaryTCIs];
          id v35 = [v30 TCIs];
          unint64_t v36 = (unint64_t)[v34 count];
          unint64_t v37 = (unint64_t)[v35 count];
          if (!(v36 | v37)) {
            goto LABEL_75;
          }
          unint64_t v38 = v37;
          unsigned int v77 = v33;
          if (v36)
          {
            long long v39 = [v33 objectForKey:@"primaryTCIs"];
            long long v40 = v39;
            if (v39)
            {
              [v39 unionSet:v34];
            }
            else
            {
              id v43 = [v34 mutableCopy];
              long long v44 = v33;
              long long v45 = v43;
              objc_msgSend(v44, "setObject:forKeyedSubscript:");
            }
            id v33 = v77;
          }
          id v26 = v79;
          if (v38)
          {
            long long v46 = [v33 objectForKey:@"TCIs"];
            id v47 = v46;
            if (v46)
            {
              [v46 unionSet:v35];
            }
            else
            {
              id v48 = [v35 mutableCopy];
              [v33 setObject:v48 forKeyedSubscript:@"TCIs"];

              id v26 = v79;
            }

            id v33 = v77;
          }
        }
        else
        {
          long long v41 = [v29 objectForKey:@"ECP2Info"];
          id v33 = v41;
          if (!v41) {
            goto LABEL_77;
          }
          long long v42 = [v41 objectForKeyedSubscript:@"Bitfield"];

          if (v42) {
            goto LABEL_77;
          }
          __int16 v34 = [v30 mask];
          if ([v34 length] != (id)5) {
            goto LABEL_76;
          }
          [v33 setObject:v34 forKeyedSubscript:@"Bitfield"];
        }
      }
      id v33 = [v30 readerIDs];
      __int16 v34 = [v33 anyObject];
      if (v34)
      {
        if ((unint64_t)[v33 count] > 1) {
          goto LABEL_76;
        }
        id v78 = v33;
        uint64_t v49 = [v34 hexEncoding];
        long long v50 = v29;
        long long v51 = (void *)v49;
        long long v52 = v50;
        long long v53 = [v50 objectForKey:@"readerIdentifier"];
        if (v53)
        {
          id v35 = v51;
          id v54 = v53;
          if (v35 == v54)
          {
          }
          else
          {
            CFStringRef v55 = v54;
            if (!v35)
            {

LABEL_74:
              id v29 = v52;
              id v33 = v78;
LABEL_75:

LABEL_76:
              id v17 = v75;
LABEL_77:

LABEL_78:
LABEL_79:

              id v7 = v73;
              goto LABEL_80;
            }
            unsigned int v72 = [v35 isEqualToString:v54];

            if (!v72) {
              goto LABEL_74;
            }
          }
        }
        [v52 setObject:v51 forKeyedSubscript:@"readerIdentifier"];

        id v29 = v52;
        id v33 = v78;
        id v26 = v79;
      }
      id v56 = [v30 associatedReaderIDs];
      if ([v56 count])
      {
        id v57 = [v56 allObjects];
        objc_msgSend(v57, "pk_arrayByApplyingBlock:", &stru_1007382A8);
        id v58 = v33;
        v60 = unint64_t v59 = v29;
        [v59 setObject:v60 forKeyedSubscript:@"associatedReaderIdentifiers"];

        id v29 = v59;
        id v33 = v58;

        id v26 = v79;
      }

      unint64_t v14 = v74;
      id v17 = v75;
LABEL_63:

      uint64_t v27 = (char *)v27 + 1;
    }
    while (v26 != v27);
    id v26 = [obj countByEnumeratingWithState:&v85 objects:v90 count:16];
    id v7 = v73;
    if (v26) {
      continue;
    }
    break;
  }
LABEL_65:

  __int16 v61 = v76;
  if (v76)
  {
    id v62 = [v76 objectForKey:@"primaryTCIs"];
    id v63 = v62;
    if (v62)
    {
      id v64 = objc_msgSend(v62, "pk_mutableArrayCopy");
      [v64 sortUsingComparator:&stru_1007382E8];
      id v65 = [v64 copy];

      [v76 setObject:v65 forKeyedSubscript:@"primaryTCIs"];
    }
    id v66 = [v76 objectForKey:@"TCIs"];
    id v67 = v66;
    if (v66)
    {
      id v68 = objc_msgSend(v66, "pk_mutableArrayCopy");
      [v68 sortUsingComparator:&stru_1007382E8];
      id v69 = [v68 copy];

      [v76 setObject:v69 forKeyedSubscript:@"TCIs"];
      __int16 v61 = v76;
    }
  }
  id v70 = a1[2];
  a1[2] = v17;

LABEL_72:
  a1 = a1;
  unsigned int v10 = a1;
LABEL_82:

  return v10;
}

void *sub_100115FC4(void *result, uint64_t a2, void *a3)
{
  if (result)
  {
    id v4 = result;
    id v5 = (void *)result[2];
    id v6 = a3;
    [v5 setObject:a2 forKeyedSubscript:@"appletIdentifier"];
    [(id)v4[2] setObject:v6 forKeyedSubscript:@"keyIdentifier"];

    id v7 = (void *)v4[2];
    return [v7 copy];
  }
  return result;
}

void sub_100116044(uint64_t a1, int a2)
{
  if (a1 && *(unsigned __int8 *)(a1 + 24) != a2)
  {
    *(unsigned char *)(a1 + 24) = a2;
    if (*(unsigned char *)(a1 + 8)) {
      BOOL v3 = a2 == 0;
    }
    else {
      BOOL v3 = 1;
    }
    BOOL v4 = !v3 && *(unsigned char *)(a1 + 26) == 0;
    id v5 = +[NSNumber numberWithBool:v4];
    [*(id *)(a1 + 16) setObject:v5 forKeyedSubscript:@"expressEnabled"];
  }
}

void sub_1001160F0(uint64_t a1, int a2)
{
  if (a1 && *(unsigned __int8 *)(a1 + 25) != a2)
  {
    *(unsigned char *)(a1 + 25) = a2;
    if (*(unsigned char *)(a1 + 28)) {
      BOOL v3 = a2 == 0;
    }
    else {
      BOOL v3 = 1;
    }
    BOOL v4 = !v3 && *(unsigned char *)(a1 + 26) == 0;
    id v5 = +[NSNumber numberWithBool:v4];
    [*(id *)(a1 + 16) setObject:v5 forKeyedSubscript:@"UWBExpressEnabled"];
  }
}

void sub_10011619C(uint64_t a1, int a2)
{
  if (a1 && *(unsigned __int8 *)(a1 + 26) != a2)
  {
    *(unsigned char *)(a1 + 26) = a2;
    if (*(unsigned char *)(a1 + 8))
    {
      if (*(unsigned char *)(a1 + 24)) {
        uint64_t v3 = a2 ^ 1u;
      }
      else {
        uint64_t v3 = 0;
      }
    }
    else
    {
      uint64_t v3 = 0;
    }
    BOOL v4 = +[NSNumber numberWithBool:v3];
    [*(id *)(a1 + 16) setObject:v4 forKeyedSubscript:@"expressEnabled"];

    BOOL v5 = *(unsigned char *)(a1 + 28) && *(unsigned char *)(a1 + 25) && *(unsigned char *)(a1 + 26) == 0;
    id v6 = +[NSNumber numberWithBool:v5];
    [*(id *)(a1 + 16) setObject:v6 forKeyedSubscript:@"UWBExpressEnabled"];
  }
}

void sub_10011629C(uint64_t a1, unsigned int a2)
{
  if (a1 && *(unsigned __int8 *)(a1 + 27) != a2)
  {
    *(unsigned char *)(a1 + 27) = a2;
    if (*(unsigned char *)(a1 + 9)) {
      uint64_t v3 = a2;
    }
    else {
      uint64_t v3 = 0;
    }
    id v4 = +[NSNumber numberWithBool:v3];
    [*(id *)(a1 + 16) setObject:v4 forKeyedSubscript:@"inSessionOnly"];
  }
}

void sub_100116330(uint64_t a1, int a2)
{
  if (a1 && *(unsigned __int8 *)(a1 + 28) != a2)
  {
    *(unsigned char *)(a1 + 2_Block_object_dispose(&STACK[0x420], 8) = a2;
    uint64_t v3 = *(void **)(a1 + 16);
    if (a2) {
      id v4 = &__kCFBooleanTrue;
    }
    else {
      id v4 = 0;
    }
    [v3 setObject:v4 forKeyedSubscript:@"supportsUWB"];
    BOOL v5 = *(unsigned char *)(a1 + 28) && *(unsigned char *)(a1 + 25) && *(unsigned char *)(a1 + 26) == 0;
    id v6 = +[NSNumber numberWithBool:v5];
    [*(id *)(a1 + 16) setObject:v6 forKeyedSubscript:@"UWBExpressEnabled"];
  }
}

void sub_100116408(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (a1 && (PKEqualObjects() & 1) == 0)
  {
    objc_storeStrong((id *)(a1 + 48), a2);
    id v4 = [v5 allObjects];
    [*(id *)(a1 + 16) setObject:v4 forKeyedSubscript:@"aliroGroupResolvingKeys"];
  }
}

void *sub_10011662C(void *a1, void *a2)
{
  uint64_t result = a2;
  id v4 = result;
  if (!a1) {
    goto LABEL_5;
  }
  if (result)
  {
    v9.receiver = a1;
    v9.super_class = (Class)PDSECredentialPass;
    a1 = objc_msgSendSuper2(&v9, "init");
    if (a1)
    {
      id v5 = [v4 copy];
      id v6 = (void *)a1[2];
      a1[2] = v5;

      id v7 = objc_alloc_init((Class)NSMutableDictionary);
      id v8 = (void *)a1[1];
      a1[1] = v7;
    }
LABEL_5:

    return a1;
  }
  __break(1u);
  return result;
}

void sub_1001166C0(void *a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  id v6 = v5;
  if (a1)
  {
    if (!v7 || !v5)
    {
      __break(1u);
      return;
    }
    sub_10011674C((uint64_t)a1, v7, v5);
    if (a1 != v6) {
      sub_10011674C((uint64_t)v6, v7, a1);
    }
  }
}

void sub_10011674C(uint64_t a1, void *a2, void *a3)
{
  id v10 = a2;
  id v5 = a3;
  id v6 = v5;
  if (a1)
  {
    if (v5) {
      id v7 = (void *)*((void *)v5 + 2);
    }
    else {
      id v7 = 0;
    }
    id v8 = v7;
    id v9 = [*(id *)(a1 + 8) objectForKeyedSubscript:v8];
    if (!v9)
    {
      id v9 = objc_alloc_init((Class)NSMutableSet);
      [*(id *)(a1 + 8) setObject:v9 forKeyedSubscript:v8];
    }
    [v9 addObject:v10];
  }
}

void sub_100116810(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1) {
    goto LABEL_4;
  }
  if (v3)
  {
    v9[0] = 0;
    v9[1] = v9;
    v9[2] = 0x2020000000;
    char v10 = 0;
    id v5 = *(void **)(a1 + 8);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    id v6[2] = sub_1001168FC;
    v6[3] = &unk_100738188;
    void v6[4] = a1;
    id v7 = v3;
    id v8 = v9;
    [v5 enumerateKeysAndObjectsUsingBlock:v6];

    _Block_object_dispose(v9, 8);
LABEL_4:

    return;
  }
  __break(1u);
}

void sub_1001168E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001168FC(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v7 = a2;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  id v12[2] = sub_1001169E0;
  void v12[3] = &unk_100738160;
  id v8 = *(id *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 32);
  id v14 = v8;
  void v12[4] = v9;
  id v10 = v7;
  uint64_t v11 = *(void *)(a1 + 48);
  id v13 = v10;
  uint64_t v15 = v11;
  [a3 enumerateObjectsUsingBlock:v12];
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
    *a4 = 1;
  }
}

uint64_t sub_1001169E0(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
    *a3 = 1;
  }
  return result;
}

BOOL sub_100116A84(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  if (!v4 || !v5) {
    __break(1u);
  }
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  id obj = v4;
  id v6 = [obj countByEnumeratingWithState:&v32 objects:v37 count:16];
  if (!v6)
  {
    char v28 = 0;
    goto LABEL_34;
  }
  id v7 = v6;
  id v8 = &selRef_handleOutstandingShareMessage_transportIdentifier_;
  uint64_t v9 = *(void *)v33;
  do
  {
    id v10 = 0;
    uint64_t v11 = v8[317];
    do
    {
      if (*(void *)v33 != v9) {
        objc_enumerationMutation(obj);
      }
      id v12 = *(void **)(*((void *)&v32 + 1) + 8 * (void)v10);
      id v13 = [v12 objectForKeyedSubscript:@"reason"];
      id v14 = v13;
      if (!v13)
      {
        char v28 = 1;
        goto LABEL_33;
      }
      uint64_t v15 = (__CFString *)v13;
      unsigned int v16 = v15;
      if (v15 == @"conflict"
        || (unsigned __int8 v17 = [(__CFString *)v15 isEqualToString:@"conflict"],
            v16,
            (v17 & 1) != 0))
      {

        uint64_t v18 = [v12 objectForKeyedSubscript:@"passID"];
        if (v18)
        {
          uint64_t v19 = (void *)v18;
        }
        else
        {
          uint64_t v19 = [v12 objectForKeyedSubscript:@"PassUniqueID"];
          if (!v19) {
            goto LABEL_31;
          }
        }
        uint64_t v22 = 0;
      }
      else
      {

        BOOL v20 = v16;
        uint64_t v19 = v20;
        if (v20 != @"suppressed")
        {
          unsigned __int8 v21 = -[__CFString isEqualToString:](v20, "isEqualToString:");

          if ((v21 & 1) == 0)
          {

LABEL_31:
            char v28 = 1;
LABEL_32:

LABEL_33:
            goto LABEL_34;
          }
        }

        uint64_t v19 = 0;
        uint64_t v22 = 1;
      }
      unsigned __int8 v31 = 0;
      id v23 = [PDSECredentialConflict alloc];
      if (v23)
      {
        v36.receiver = v23;
        v36.super_class = (Class)PDSECredentialConflict;
        id v24 = objc_msgSendSuper2(&v36, v11);
        id v25 = v24;
        if (v24) {
          *((void *)v24 + 1) = v22;
        }
      }
      else
      {
        id v25 = 0;
      }
      v5[2](v5, v25, v19, &v31);
      int v26 = v31;

      if (v26)
      {
        char v28 = 2;
        goto LABEL_32;
      }

      id v10 = (char *)v10 + 1;
    }
    while (v7 != v10);
    id v27 = [obj countByEnumeratingWithState:&v32 objects:v37 count:16];
    id v7 = v27;
    char v28 = 0;
    id v8 = &selRef_handleOutstandingShareMessage_transportIdentifier_;
  }
  while (v27);
LABEL_34:

  return (v28 & 1) == 0;
}

BOOL sub_100116D60(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  uint64_t v17 = self;
  if (!v4 || (uint64_t v18 = v5) == 0) {
    __break(1u);
  }
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  id v6 = v4;
  id v7 = [v6 countByEnumeratingWithState:&v27 objects:v31 count:16];
  if (v7)
  {
    uint64_t v8 = *(void *)v28;
    while (2)
    {
      for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v28 != v8) {
          objc_enumerationMutation(v6);
        }
        id v10 = *(void **)(*((void *)&v27 + 1) + 8 * i);
        uint64_t v11 = [v10 objectForKeyedSubscript:@"passID"];
        if (!v11)
        {
          uint64_t v11 = [v10 objectForKeyedSubscript:@"PassUniqueID"];
          if (!v11)
          {
            LOWORD(v15) = 1;
            goto LABEL_21;
          }
        }
        id v12 = [v10 objectForKeyedSubscript:@"conflicts"];
        id v13 = v12;
        if (v12 && [v12 count])
        {
          uint64_t v23 = 0;
          id v24 = &v23;
          uint64_t v25 = 0x2020000000;
          char v26 = 0;
          v19[0] = _NSConcreteStackBlock;
          v19[1] = 3221225472;
          void v19[2] = sub_100117018;
          v19[3] = &unk_1007381B0;
          id v21 = v18;
          id v14 = v11;
          id v20 = v14;
          uint64_t v22 = &v23;
          if (sub_100116A84(v17, v13, v19)) {
            int v15 = 2 * *((unsigned __int8 *)v24 + 24);
          }
          else {
            int v15 = 1;
          }

          _Block_object_dispose(&v23, 8);
          if (v15) {
            goto LABEL_21;
          }
        }
        else
        {
        }
      }
      id v7 = [v6 countByEnumeratingWithState:&v27 objects:v31 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
  LOWORD(v15) = 0;
LABEL_21:

  return (v15 & 0x1FD) == 0;
}

void sub_100116FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100117018(void *a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v6 = a1[5];
  if (a3) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = a1[4];
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t))(v6 + 16))(v6, a2, a1[4], v7, *(void *)(a1[6] + 8) + 24);
  if (*(unsigned char *)(*(void *)(a1[6] + 8) + 24)) {
    *a4 = 1;
  }
  return result;
}

uint64_t sub_100117140(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 8);
    if (v1)
    {
      if (v1 == 1) {
        return 1;
      }
      else {
        __break(1u);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *sub_100117168()
{
  self;
  id v0 = [PDSECredentialNode alloc];
  return sub_10011719C(v0);
}

void *sub_10011719C(void *a1)
{
  if (!a1) {
    return 0;
  }
  v5.receiver = a1;
  v5.super_class = (Class)PDSECredentialNode;
  uint64_t v1 = objc_msgSendSuper2(&v5, "init");
  if (v1)
  {
    id v2 = objc_alloc_init((Class)NSMutableArray);
    id v3 = (void *)v1[1];
    v1[1] = v2;
  }
  return v1;
}

void *sub_100117228(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1 && v3)
  {
    objc_super v5 = sub_10011719C(a1);
    if (v5)
    {
      id v6 = [v4 copy];
      uint64_t v7 = (void *)v5[4];
      void v5[4] = v6;
    }
    a1 = v5;
    uint64_t v8 = a1;
  }
  else
  {
    uint64_t v8 = 0;
  }

  return v8;
}

uint64_t sub_1001172A4(uint64_t a1, void *a2, char a3)
{
  objc_super v5 = a2;
  id v6 = v5;
  if (a1)
  {
    if (!*(void *)(a1 + 32))
    {
LABEL_6:
      a1 = 0;
      goto LABEL_10;
    }
    if ((a3 & 1) == 0 || (uint64_t v7 = *(void *)(a1 + 40)) == 0)
    {
      uint64_t v8 = v5;
      id v9 = *(id *)(a1 + 40);
      *(void *)(a1 + 40) = v8;
LABEL_8:

      goto LABEL_9;
    }
    if ((a3 & 2) == 0) {
      goto LABEL_6;
    }
    if (!v5)
    {
LABEL_9:
      a1 = 1;
      goto LABEL_10;
    }
    id v9 = *(id *)(v7 + 32);
    uint64_t v11 = *(void **)(a1 + 16);
    if (v11)
    {
      id v12 = [v11 objectForKeyedSubscript:v9];
      if (v12)
      {
LABEL_17:
        [v12 addObject:v6[4]];

        goto LABEL_8;
      }
    }
    else
    {
      id v13 = objc_alloc_init((Class)NSMutableDictionary);
      id v14 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = v13;
    }
    id v12 = objc_alloc_init((Class)NSMutableSet);
    [*(id *)(a1 + 16) setObject:v12 forKeyedSubscript:v9];
    goto LABEL_17;
  }
LABEL_10:

  return a1;
}

id sub_100117394(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  id v6 = v5;
  uint64_t v7 = 0;
  if (a1 && v5)
  {
    uint64_t v8 = *(void **)(a1 + 8);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    id v11[2] = sub_10011749C;
    void v11[3] = &unk_1007381D8;
    id v9 = v5;
    id v12 = v9;
    uint64_t v7 = objc_msgSend(v8, "pk_firstObjectPassingTest:", v11);
    if (!v7 && a3)
    {
      uint64_t v7 = sub_100117228([PDSECredentialNode alloc], v9);
      [*(id *)(a1 + 8) addObject:v7];
      *(unsigned char *)(a1 + 24) = 0;
    }
  }
  return v7;
}

uint64_t sub_10011749C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3) {
    id v5 = (void *)*((void *)v3 + 4);
  }
  else {
    id v5 = 0;
  }
  id v6 = v5;
  uint64_t v7 = *(void **)(a1 + 32);
  id v8 = v6;
  id v9 = v7;
  id v10 = v9;
  if (v8 == v9)
  {
    uint64_t v11 = 1;
  }
  else
  {
    uint64_t v11 = 0;
    if (v8 && v9) {
      uint64_t v11 = (uint64_t)[v8 isEqualToString:v9];
    }
  }

  return v11;
}

void sub_100117534(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1 && !*(void *)(a1 + 32))
  {
    char v7 = 0;
    id v4 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithObjects:", a1, 0);
    if ([v4 count])
    {
      while (1)
      {
        id v5 = [v4 lastObject];
        [v4 removeLastObject];
        uint64_t v6 = v5[5];
        if (v6)
        {
          v3[2](v3, v6, &v7);
          if (v7) {
            break;
          }
        }
        if (v5[1]) {
          objc_msgSend(v4, "addObjectsFromArray:");
        }

        if (![v4 count]) {
          goto LABEL_11;
        }
      }
    }
LABEL_11:
  }
}

void sub_10011760C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1 && !*(void *)(a1 + 32))
  {
    id v4 = +[NSNull null];
    id v5 = [objc_alloc((Class)NSMutableArray) initWithCapacity:2];
    id v6 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithObjects:", a1, 0);
    do
    {
      if (![v6 count]) {
        break;
      }
      uint64_t v7 = [v6 lastObject];
      [v6 removeLastObject];
      if ((void *)v7 == v4)
      {
        [v5 removeLastObject];
        int v10 = 2;
      }
      else
      {
        if (v7)
        {
          id v8 = *(id *)(v7 + 32);
          if (v8)
          {
            [v5 addObject:v8];
            [v6 addObject:v4];
          }
        }
        else
        {
          id v8 = 0;
        }
        uint64_t v9 = *(void *)(v7 + 40);
        if (v9 && (char v12 = 0, v3[2](v3, v5, v9, &v12), v12))
        {
          int v10 = 3;
        }
        else
        {
          uint64_t v11 = *(void **)(v7 + 8);
          if (v11)
          {
            if (!*(unsigned char *)(v7 + 24))
            {
              *(unsigned char *)(v7 + 24) = 1;
              [v11 sortUsingComparator:&stru_100738218];
              uint64_t v11 = *(void **)(v7 + 8);
            }
            [v6 addObjectsFromArray:v11];
          }
          int v10 = 0;
        }
      }
    }
    while (v10 != 3);
  }
}

int64_t sub_1001177B0(id a1, PDSECredentialNode *a2, PDSECredentialNode *a3)
{
  id v4 = a3;
  if (a2) {
    identifier = a2->_identifier;
  }
  else {
    identifier = 0;
  }
  id v6 = identifier;
  if (v4)
  {
    uint64_t v7 = v4->_identifier;
    if (!v6) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v7 = 0;
    if (!v6) {
      goto LABEL_9;
    }
  }
  if (v7)
  {
    int64_t v8 = [(NSString *)v7 compare:v6];
    goto LABEL_15;
  }
LABEL_9:
  if (v7) {
    uint64_t v9 = -1;
  }
  else {
    uint64_t v9 = 0;
  }
  if (v6) {
    int64_t v8 = 1;
  }
  else {
    int64_t v8 = v9;
  }
LABEL_15:

  return v8;
}

uint64_t sub_10011783C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1) {
    goto LABEL_4;
  }
  if (v3)
  {
    if (*(void *)(a1 + 32))
    {
LABEL_4:
      uint64_t v5 = 0;
      goto LABEL_16;
    }
    id v6 = [PDSECredentialConflict alloc];
    if (v6)
    {
      v17.receiver = v6;
      v17.super_class = (Class)PDSECredentialConflict;
      id v7 = objc_msgSendSuper2(&v17, "init");
      int64_t v8 = v7;
      if (v7) {
        *((void *)v7 + 1) = 0;
      }
      goto LABEL_8;
    }
  }
  else
  {
    __break(1u);
  }
  int64_t v8 = 0;
LABEL_8:
  v17.receiver = 0;
  v17.super_class = (Class)&v17;
  uint64_t v18 = 0x2020000000;
  char v19 = 0;
  id v9 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithObjects:", a1, 0);
  while ([v9 count])
  {
    int v10 = [v9 lastObject];
    [v9 removeLastObject];
    uint64_t v11 = (void *)v10[2];
    if (v11)
    {
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_100117A20;
      v13[3] = &unk_100738188;
      id v15 = v4;
      id v14 = v8;
      unsigned int v16 = &v17;
      [v11 enumerateKeysAndObjectsUsingBlock:v13];
    }
    if (v10[1]) {
      objc_msgSend(v9, "addObjectsFromArray:");
    }
  }
  _Block_object_dispose(&v17, 8);

  uint64_t v5 = 1;
LABEL_16:

  return v5;
}

void sub_100117A00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100117A20(uint64_t a1, void *a2, void *a3, unsigned char *a4)
{
  id v7 = a2;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100117B10;
  v10[3] = &unk_100738240;
  id v13 = *(id *)(a1 + 40);
  id v11 = *(id *)(a1 + 32);
  id v8 = v7;
  uint64_t v9 = *(void *)(a1 + 48);
  id v12 = v8;
  uint64_t v14 = v9;
  [a3 enumerateObjectsUsingBlock:v10];
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
    *a4 = 1;
  }
}

uint64_t sub_100117B10(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
    *a3 = 1;
  }
  return result;
}

void *sub_100117B70(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    if (a1[4])
    {
      a1 = 0;
    }
    else
    {
      id v4 = objc_alloc_init((Class)NSMutableArray);
      id v7 = _NSConcreteStackBlock;
      uint64_t v8 = 3221225472;
      uint64_t v9 = sub_100117C54;
      int v10 = &unk_100738268;
      id v11 = v3;
      id v12 = v4;
      id v5 = v4;
      sub_10011760C((uint64_t)a1, &v7);
      a1 = objc_msgSend(v5, "copy", v7, v8, v9, v10);
    }
  }

  return a1;
}

void sub_100117C54(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v11 = 0;
  id v12 = 0;
  if (+[PKExpressPassInformation extractApplicationIdentifier:&v12 subcredentialIdentifier:&v11 fromIdentifiers:a2])
  {
    id v6 = *(void **)(a1 + 32);
    if (!v6
      || v12
      && (objc_msgSend(v6, "appletWithIdentifier:"), (id v7 = objc_claimAutoreleasedReturnValue()) != 0)
      && (uint64_t v8 = v7, v9 = [v7 lifecycleState], v8, v9 == 15))
    {
      int v10 = sub_100115FC4(v5, (uint64_t)v12, v11);
      if (v10) {
        [*(id *)(a1 + 40) addObject:v10];
      }
    }
  }
}

uint64_t sub_100117D1C(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

id sub_100117D84(id a1, PKASCAssociatedReaderID *a2)
{
  id v2 = a2;
  id v3 = objc_alloc_init((Class)NSMutableDictionary);
  id v4 = [(PKASCAssociatedReaderID *)v2 readerID];
  [v3 setObject:v4 forKeyedSubscript:@"associatedReaderID"];

  id v5 = +[NSNumber numberWithUnsignedInteger:[(PKASCAssociatedReaderID *)v2 priority]];
  [v3 setObject:v5 forKeyedSubscript:@"associatedReaderPriority"];

  id v6 = [(PKASCAssociatedReaderID *)v2 readerCA];

  if (v6)
  {
    id v7 = [v6 publicKey];
    [v3 setObject:v7 forKeyedSubscript:@"associatedReaderCAPK"];

    uint64_t v8 = [v6 attestation];
    [v3 setObject:v8 forKeyedSubscript:@"associatedReaderSignature"];
  }
  id v9 = [v3 copy];

  return v9;
}

int64_t sub_100117EB8(id a1, NSData *a2, NSData *a3)
{
  id v4 = a2;
  id v5 = a3;
  size_t v6 = [(NSData *)v4 length];
  NSUInteger v7 = [(NSData *)v5 length];
  if (v6 | v7)
  {
    if (v6 >= v7)
    {
      if (v6 > v7)
      {
        int64_t v8 = 1;
      }
      else
      {
        int v9 = memcmp([(NSData *)v4 bytes], [(NSData *)objc_retainAutorelease(v5) bytes], v6);
        if (v9 < 0) {
          int64_t v8 = -1;
        }
        else {
          int64_t v8 = v9 != 0;
        }
      }
    }
    else
    {
      int64_t v8 = -1;
    }
  }
  else
  {
    int64_t v8 = 0;
  }

  return v8;
}

void sub_1001184B0(id a1, PKAppleBalanceAccountDetails *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKAppleBalanceAccountDetails *)v3 setLastUpdatedDate:v4];
}

void sub_100118510(id a1, PKAppleBalanceAccountDetails *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKAppleBalanceAccountDetails *)v3 setCreatedDate:v4];
}

void sub_100118570(id a1, PKAppleBalanceAccountDetails *a2, id a3)
{
}

void sub_100118578(id a1, PKAppleBalanceAccountDetails *a2, id a3)
{
}

void sub_100118580(id a1, PKAppleBalanceAccountDetails *a2, id a3)
{
}

void sub_100118588(id a1, PKAppleBalanceAccountDetails *a2, id a3)
{
}

void sub_100118590(id a1, PKAppleBalanceAccountDetails *a2, id a3)
{
}

void sub_100118598(id a1, PKAppleBalanceAccountDetails *a2, id a3)
{
  id v4 = a2;
  -[PKAppleBalanceAccountDetails setCardType:](v4, "setCardType:", [a3 integerValue]);
}

void sub_100118750(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

id _SQLValueForIntegerArray(void *a1)
{
  if (a1) {
    [a1 componentsJoinedByString:@","];
  }
  else {
  uint64_t v1 = +[NSNull null];
  }
  return v1;
}

id _IntegerArrayForSQLValue(void *a1)
{
  if (a1)
  {
    uint64_t v1 = [a1 componentsSeparatedByString:@","];
    id v2 = objc_msgSend(v1, "pk_arrayByApplyingBlock:", &stru_100738460);
  }
  else
  {
    id v2 = 0;
  }
  return v2;
}

id sub_100118B0C(id a1, NSString *a2)
{
  NSInteger v2 = [(NSString *)a2 integerValue];
  return +[NSNumber numberWithInteger:v2];
}

void sub_100118FAC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v6 = a3;
  id v7 = objc_alloc_init((Class)PKPassShareTimeSchedule);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v7 withProperties:v6 values:a4];

  [*(id *)(a1 + 40) safelyAddObject:v7];
}

void sub_100119130(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_100119454(id a1, PKPassShareTimeSchedule *a2, id a3)
{
  id v4 = a2;
  _IntegerArrayForSQLValue(a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  [(PKPassShareTimeSchedule *)v4 setHoursOfDay:v5];
}

void sub_1001194B8(id a1, PKPassShareTimeSchedule *a2, id a3)
{
  id v4 = a2;
  _IntegerArrayForSQLValue(a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  [(PKPassShareTimeSchedule *)v4 setDaysOfWeek:v5];
}

void sub_10011951C(id a1, PKPassShareTimeSchedule *a2, id a3)
{
  id v4 = a2;
  _IntegerArrayForSQLValue(a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  [(PKPassShareTimeSchedule *)v4 setDaysOfMonth:v5];
}

void sub_100119580(id a1, PKPassShareTimeSchedule *a2, id a3)
{
  id v4 = a2;
  -[PKPassShareTimeSchedule setInterval:](v4, "setInterval:", [a3 unsignedIntegerValue]);
}

void sub_1001195D8(id a1, PKPassShareTimeSchedule *a2, id a3)
{
  id v3 = a2;
  [(PKPassShareTimeSchedule *)v3 setFrequency:PKPassShareTimeScheduleFrequencyFromString()];
}

void sub_100119F8C(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119F94(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119F9C(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119FA4(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119FAC(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119FB4(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119FBC(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119FC4(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119FCC(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119FD4(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119FDC(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_100119FE4(id a1, PKAccountAdditionalPushTopics *a2, id a3)
{
}

void sub_10011A0E4(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

uint64_t sub_10011A544(uint64_t a1)
{
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v3 = *(id *)(a1 + 32);
  id v4 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v14;
    while (2)
    {
      id v7 = 0;
      do
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void *)(*((void *)&v13 + 1) + 8 * (void)v7);
        id v9 = objc_alloc(*(Class *)(a1 + 56));
        id v10 = objc_msgSend(v9, "initWithLocation:source:inDatabase:", v8, *(void *)(a1 + 40), *(void *)(a1 + 48), (void)v13);

        if (!v10)
        {
          uint64_t v11 = 0;
          goto LABEL_11;
        }
        id v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
  uint64_t v11 = 1;
LABEL_11:

  return v11;
}

void sub_10011AAB8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  id v10 = objc_alloc_init((Class)PKPaymentTransactionToDeleteFromFinance);
  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:v10 withProperties:v7 values:a4];

  uint64_t v8 = *(void **)(a1 + 40);
  id v9 = +[NSNumber numberWithLongLong:a2];
  [v8 setObject:v10 forKeyedSubscript:v9];
}

void sub_10011AD58(id a1, PKPaymentTransactionToDeleteFromFinance *a2, id a3)
{
}

void sub_10011AD60(id a1, PKPaymentTransactionToDeleteFromFinance *a2, id a3)
{
}

id sub_10011B504(uint64_t a1, uint64_t a2)
{
  return +[PassShareTimeSchedule deletePassShareTimeSchedulesForTimeConfigurationPID:a2 inDatabase:*(void *)(a1 + 32)];
}

void sub_10011B670(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  id v9 = objc_alloc_init((Class)PKPassShareTimeConfiguration);
  [*(id *)(a1 + 56) applyPropertySetters:*(void *)(a1 + 32) toObject:v9 withProperties:v7 values:a4];

  uint64_t v8 = +[PassShareTimeSchedule passShareTimeSchedulesForTimeConfigurationPID:a2 inDatabase:*(void *)(a1 + 40)];
  [v9 setSchedules:v8];

  [*(id *)(a1 + 48) safelyAddObject:v9];
}

void sub_10011B878(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [(id)objc_opt_class() applyPropertySetters:*(void *)(a1 + 40) toObject:*(void *)(a1 + 48) withProperties:v5 values:a3];
}

void sub_10011BB64(id a1, PKPassShareTimeConfiguration *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPassShareTimeConfiguration *)v3 setStartDate:v4];
}

void sub_10011BBC4(id a1, PKPassShareTimeConfiguration *a2, id a3)
{
  id v3 = a2;
  id v4 = (id)_DateForSQLValue();
  [(PKPassShareTimeConfiguration *)v3 setExpirationDate:v4];
}

void sub_10011BC24(id a1, PKPassShareTimeConfiguration *a2, id a3)
{
  id v3 = a2;
  [(PKPassShareTimeConfiguration *)v3 setSupport:PKPassShareTimeConfigurationSupportFromString()];
}

void sub_10011BF8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10011BFB0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  id v9 = a3;
  id v10 = objc_alloc_init((Class)PKPaymentBalanceReminder);
  uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
  id v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  [*(id *)(a1 + 48) applyPropertySetters:*(void *)(a1 + 32) toObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) withProperties:v9 values:a4];
  *a6 = 1;
}

void sub_10011C2F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10011C314(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  uint64_t v8 = [(SQLiteEntity *)[BalanceReminder alloc] initWithPersistentID:a2 inDatabase:*(void *)(a1 + 32)];
  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
  id v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;

  *a6 = 1;
}

id sub_10011C9C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return +[SQLiteEntity applyPropertySetters:*(void *)(a1 + 32) toObject:*(void *)(a1 + 40) withProperties:a2 values:a3];
}

void sub_10011CB38(id a1, PKPaymentBalanceReminder *a2, id a3)
{
  id v4 = a2;
  id v5 = +[NSDecimalNumber decimalNumberWithString:a3];
  [(PKPaymentBalanceReminder *)v4 setThreshold:v5];
}

void sub_10011CBB0(id a1, PKPaymentBalanceReminder *a2, id a3)
{
  id v4 = a2;
  -[PKPaymentBalanceReminder setEnabled:](v4, "setEnabled:", [a3 BOOLValue]);
}

id sub_10011CDC0(uint64_t a1)
{
  objc_storeStrong((id *)(*(void *)(a1 + 32) + 8), *(id *)(a1 + 40));
  objc_storeStrong((id *)(*(void *)(a1 + 32) + 16), *(id *)(a1 + 48));
  objc_storeStrong((id *)(*(void *)(a1 + 32) + 24), *(id *)(a1 + 56));
  objc_storeWeak((id *)(*(void *)(a1 + 32) + 240), *(id *)(a1 + 64));
  id v2 = objc_alloc_init((Class)NSMutableSet);
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 192);
  *(void *)(v3 + 192) = v2;

  id v5 = objc_alloc_init((Class)NSMutableSet);
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = *(void **)(v6 + 200);
  *(void *)(v6 + 200) = v5;

  id v8 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v9 = *(void *)(a1 + 32);
  id v10 = *(void **)(v9 + 48);
  *(void *)(v9 + 4_Block_object_dispose(&STACK[0x420], 8) = v8;

  uint64_t v11 = [[PDRelevantPassLiveActivityManager alloc] initWithDatabaseManager:*(void *)(a1 + 40) cardFileManager:*(void *)(a1 + 48)];
  uint64_t v12 = *(void *)(a1 + 32);
  long long v13 = *(void **)(v12 + 232);
  *(void *)(v12 + 232) = v11;

  id v14 = [objc_alloc((Class)SBSCardItemsController) initWithIdentifier:@"passes"];
  uint64_t v15 = *(void *)(a1 + 32);
  long long v16 = *(void **)(v15 + 208);
  *(void *)(v15 + 20_Block_object_dispose(&STACK[0x420], 8) = v14;

  objc_storeStrong((id *)(*(void *)(a1 + 32) + 224), *(id *)(a1 + 72));
  objc_super v17 = *(void **)(*(void *)(a1 + 32) + 224);
  return objc_msgSend(v17, "registerConsumer:");
}

void sub_10011CFD4(uint64_t a1)
{
  id v2 = (void *)PDOSTransactionCreate("PDRelevantPassProvider");
  uint64_t v3 = PKPassRelevancyBundle();
  id v4 = [v3 bundlePath];

  id v5 = PKPassKitCoreBundle();
  uint64_t v6 = [v5 bundlePath];

  id v7 = objc_alloc((Class)CLLocationManager);
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = PDDefaultQueue();
  id v10 = [v7 initWithEffectiveBundlePath:v4 delegate:v8 onQueue:v9];
  uint64_t v11 = *(void *)(a1 + 32);
  uint64_t v12 = *(void **)(v11 + 64);
  *(void *)(v11 + 64) = v10;

  id v13 = objc_alloc((Class)CLLocationManager);
  uint64_t v14 = *(void *)(a1 + 32);
  uint64_t v15 = PDDefaultQueue();
  id v16 = [v13 initWithEffectiveBundlePath:v6 delegate:v14 onQueue:v15];
  uint64_t v17 = *(void *)(a1 + 32);
  uint64_t v18 = *(void **)(v17 + 80);
  *(void *)(v17 + 80) = v16;

  PDScheduledActivityClientRegister();
  uint64_t v19 = *(void *)(a1 + 32);
  id v20 = *(NSObject **)(v19 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10011D188;
  block[3] = &unk_10072E238;
  void block[4] = v19;
  id v24 = v4;
  id v25 = v6;
  id v21 = v6;
  id v22 = v4;
  dispatch_sync(v20, block);
}

id sub_10011D188(void *a1)
{
  *(_DWORD *)(a1[4] + 72) = +[CLLocationManager authorizationStatusForBundlePath:a1[5]];
  id result = +[CLLocationManager authorizationStatusForBundlePath:a1[6]];
  *(_DWORD *)(a1[4] + 8_Block_object_dispose(&STACK[0x420], 8) = result;
  *(unsigned char *)(a1[4] + 40) = 1;
  return result;
}

void sub_10011D254(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) delegate];
  unsigned int v3 = [v2 shouldRecomputeRelevantPassesWithSearchMode:*(void *)(a1 + 40)];

  if (v3)
  {
    id v4 = *(void **)(a1 + 32);
    BOOL v5 = *(void *)(a1 + 40) != 0;
    objc_msgSend(v4, "_startCardSearchUpdatingWithCachedProximity:refreshingProximity:searchMode:", v5, 1);
  }
}

id sub_10011D360(uint64_t a1)
{
  return [*(id *)(a1 + 32) _startCardSearchUpdatingWithCachedProximity:1 refreshingProximity:0];
}

uint64_t sub_10011D460(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 216) copy];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void *)(v3 + 40);
  *(void *)(v3 + 40) = v2;
  return _objc_release_x1(v2, v4);
}

void *sub_10011D520(void *result)
{
  uint64_t v1 = result[4];
  if (!*(_DWORD *)(v1 + 88)) {
    return _[*(id *)(v1 + 80) requestWhenInUseAuthorization];
  }
  return result;
}

id sub_10011D89C(uint64_t a1)
{
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 48);
    uint64_t v4 = *(unsigned __int8 *)(a1 + 49);
    uint64_t v5 = *(void *)(a1 + 40);
    int v7 = 134218496;
    uint64_t v8 = v3;
    __int16 v9 = 2048;
    uint64_t v10 = v4;
    __int16 v11 = 2048;
    uint64_t v12 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Delaying relevance update %ld, %ld, %ld", (uint8_t *)&v7, 0x20u);
  }

  return [*(id *)(a1 + 32) _reallyStartCardSearchUpdatingWithCachedProximity:*(unsigned __int8 *)(a1 + 48) refreshingProximity:*(unsigned __int8 *)(a1 + 49) searchMode:*(void *)(a1 + 40)];
}

id sub_10011DBEC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _reallyStartCardSearchUpdatingWithCachedProximity:*(unsigned __int8 *)(a1 + 48) refreshingProximity:*(unsigned __int8 *)(a1 + 49) searchMode:*(void *)(a1 + 40)];
}

void sub_10011DC00(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 192) removeAllObjects];
  [*(id *)(*(void *)(a1 + 32) + 200) removeAllObjects];
  for (uint64_t i = 0; i != 12; ++i)
    [*(id *)(a1 + 32) _addDateRelevantAndLocationPendingCardsForStyle:i locationAvailable:*(unsigned __int8 *)(a1 + 40)];
  if (![*(id *)(*(void *)(a1 + 32) + 200) count]) {
    [*(id *)(a1 + 32) _clearPersistedProximityInfo];
  }
}

void sub_10011E180(void *a1)
{
  id v6 = a1;
  if (v6)
  {
    id v2 = +[NSKeyedArchiver archivedDataWithRootObject:v6 requiringSecureCoding:1 error:0];
    uint64_t v3 = sub_100122FE0();
    [v2 writeToFile:v3 atomically:1];
  }
  else
  {
    uint64_t v4 = +[NSFileManager defaultManager];
    uint64_t v5 = sub_100122FE0();
    [v4 removeItemAtPath:v5 error:0];
  }
}

void sub_10011E25C(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    v9[0] = @"beacons";
    v9[1] = @"timestamp";
    v10[0] = v1;
    uint64_t v3 = +[NSDate date];
    v10[1] = v3;
    uint64_t v4 = +[NSDictionary dictionaryWithObjects:v10 forKeys:v9 count:2];

    uint64_t v5 = +[NSKeyedArchiver archivedDataWithRootObject:v4 requiringSecureCoding:1 error:0];
    id v6 = sub_100123034();
    [v5 writeToFile:v6 atomically:1];
  }
  else
  {
    int v7 = +[NSFileManager defaultManager];
    uint64_t v8 = sub_100123034();
    [v7 removeItemAtPath:v8 error:0];
  }
}

id sub_10011F390(uint64_t a1)
{
  [*(id *)(a1 + 32) _clearLocationSearchTimer];
  id v2 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 104);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Search timer expired. Using %@", (uint8_t *)&v5, 0xCu);
  }

  return [*(id *)(a1 + 32) _handleNewLocation:*(void *)(*(void *)(a1 + 32) + 104) forceAcceptance:1 from:@"Expired Search Timer"];
}

void sub_10011F918(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v3 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Beacon search timer fired; stopping beacon search.",
        v4,
        2u);
    }

    [*(id *)(a1 + 32) _handleNewBeacons:0];
  }
}

double *sub_10011FE60(double *result, double *a2, double *a3, double a4, double a5, double a6, double a7)
{
  if (a4 >= a6) {
    double v7 = a6;
  }
  else {
    double v7 = a4;
  }
  if (a4 <= a6) {
    a4 = a6;
  }
  if (a5 >= a7) {
    double v8 = a7;
  }
  else {
    double v8 = a5;
  }
  if (a5 <= a7) {
    a5 = a7;
  }
  if (v7 >= a4)
  {
    if (result)
    {
      *id result = 0.0;
      result[1] = 0.0;
    }
  }
  else if (result)
  {
    if (a4 >= v8) {
      double v9 = v8;
    }
    else {
      double v9 = a4;
    }
    *id result = v7;
    result[1] = v9;
  }
  if (a4 >= v8)
  {
    if (a2)
    {
      *a2 = 0.0;
      a2[1] = 0.0;
    }
  }
  else if (a2)
  {
    *a2 = a4;
    a2[1] = v8;
  }
  if (v8 >= a5)
  {
    if (a3)
    {
      *a3 = 0.0;
      a3[1] = 0.0;
    }
  }
  else if (a3)
  {
    if (a4 <= v8) {
      a4 = v8;
    }
    *a3 = a4;
    a3[1] = a5;
  }
  return result;
}

void sub_10012071C(uint64_t a1)
{
  [*(id *)(a1 + 32) _unscheduleEagerRecalculation];
  id v2 = objc_alloc_init((Class)NSMutableSet);
  id v3 = objc_alloc_init((Class)NSMutableDictionary);
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  id v4 = *(id *)(*(void *)(a1 + 32) + 192);
  id v5 = [v4 countByEnumeratingWithState:&v63 objects:v69 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v64;
    do
    {
      for (uint64_t i = 0; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v64 != v7) {
          objc_enumerationMutation(v4);
        }
        double v9 = *(void **)(*((void *)&v63 + 1) + 8 * i);
        [v2 addObject:v9];
        uint64_t v10 = *(void **)(a1 + 32);
        __int16 v11 = [v9 matchedRelevantDate];
        [v10 _insertPass:v9 intoGroups:v3 forDate:v11];
      }
      id v6 = [v4 countByEnumeratingWithState:&v63 objects:v69 count:16];
    }
    while (v6);
  }

  uint64_t v12 = (char *)&__PassStyleMatchConditions;
  if ([*(id *)(*(void *)(a1 + 32) + 200) count])
  {
    id v13 = objc_alloc((Class)CLCircularRegion);
    [*(id *)(*(void *)(a1 + 32) + 96) coordinate];
    double v15 = v14;
    double v17 = v16;
    uint64_t v18 = 0;
    double v19 = 0.0;
    do
    {
      double v20 = *(double *)((char *)&__PassStyleMatchConditions + v18 + 16);
      if (v20 <= *(double *)((char *)&__PassStyleMatchConditions + v18 + 24)) {
        double v20 = *(double *)((char *)&__PassStyleMatchConditions + v18 + 24);
      }
      if (v19 <= v20) {
        double v19 = v20;
      }
      v18 += 64;
    }
    while (v18 != 768);
    [*(id *)(*(void *)(a1 + 32) + 96) horizontalAccuracy];
    id v22 = objc_msgSend(v13, "initWithCenter:radius:identifier:", @"nearby-pass-search", v15, v17, v19 + v21);
    id v57 = [*(id *)(*(void *)(a1 + 32) + 8) locationsByUniqueIDInBoundingBoxOfRegion:v22];
    uint64_t v23 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v57;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Nearby pass locations: %@", buf, 0xCu);
    }
  }
  else
  {
    id v57 = 0;
  }
  CFStringRef v55 = v3;
  id v53 = objc_alloc_init((Class)NSMutableSet);
  long long v59 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  id obj = *(id *)(*(void *)(a1 + 32) + 200);
  id v24 = [obj countByEnumeratingWithState:&v59 objects:v67 count:16];
  if (!v24)
  {
    uint64_t v56 = 0;
    double v27 = 1.79769313e308;
    goto LABEL_53;
  }
  id v25 = v24;
  uint64_t v56 = 0;
  uint64_t v26 = *(void *)v60;
  double v27 = 1.79769313e308;
  do
  {
    long long v28 = 0;
    do
    {
      long long v29 = v2;
      if (*(void *)v60 != v26) {
        objc_enumerationMutation(obj);
      }
      long long v30 = *(void **)(*((void *)&v59 + 1) + 8 * (void)v28);
      unsigned __int8 v31 = v12;
      long long v32 = (double *)&v12[64 * (void)objc_msgSend(v30, "style", v53)];
      long long v33 = v32 + 2;
      long long v34 = v32 + 3;
      double v35 = v32[4];
      double v36 = v32[5];
      double v37 = v32[6];
      double v38 = v32[7];
      long long v39 = [v30 matchedRelevantDate];
      if (v39) {
        long long v40 = v34;
      }
      else {
        long long v40 = v33;
      }
      double v41 = *v40;
      *(void *)long long buf = 0;
      id v58 = 0;
      unsigned int v42 = [*(id *)(a1 + 32) _findMatchingLocation:buf beacon:&v58 forCandidatePass:v30 passStyleRadius:v57 usingNearbyLocations:v41] ^ 1;
      if (v39) {
        BOOL v43 = 0;
      }
      else {
        BOOL v43 = v42 == 0;
      }
      if (!v43)
      {
        if (v39) {
          char v44 = v42;
        }
        else {
          char v44 = 1;
        }
        if (v44)
        {
          char v47 = v42 ^ 1;
          if (!v39) {
            char v47 = 1;
          }
          if (v47) {
            goto LABEL_44;
          }
          id v48 = +[NSDate date];
          BOOL IsWithinWindowAroundReferenceDate = PDDateIsWithinWindowAroundReferenceDate(v48, v39, v37, v38);

          if (!IsWithinWindowAroundReferenceDate) {
            goto LABEL_44;
          }
        }
        else
        {
          long long v45 = +[NSDate date];
          BOOL v46 = PDDateIsWithinWindowAroundReferenceDate(v45, v39, v35, v36);

          if (!v46) {
            goto LABEL_44;
          }
        }
      }
      [v29 addObject:v30];
      if (*(void *)buf)
      {
        objc_msgSend(*(id *)(a1 + 32), "_insertPass:intoGroups:forLocation:", v30, v55);
        ++v56;
        if (v27 >= v41) {
          double v27 = v41;
        }
LABEL_44:
        uint64_t v12 = v31;
        goto LABEL_45;
      }
      long long v50 = *(void **)(a1 + 32);
      uint64_t v12 = v31;
      if (v58)
      {
        objc_msgSend(v50, "_insertPass:intoGroups:forBeacon:", v30, v55);
        long long v51 = [v58 proximityUUID];
        [v53 addObject:v51];
      }
      else
      {
        [v50 _insertPass:v30 intoGroups:v55 forDate:v39];
      }
LABEL_45:
      id v2 = v29;

      long long v28 = (char *)v28 + 1;
    }
    while (v25 != v28);
    id v52 = [obj countByEnumeratingWithState:&v59 objects:v67 count:16];
    id v25 = v52;
  }
  while (v52);
LABEL_53:

  [*(id *)(a1 + 32) _processStateChangesFromRelevantCandidates:v2];
  [*(id *)(a1 + 32) _sendGroups:v55 candidatePasses:v2];
  if ([*(id *)(a1 + 32) _shouldScheduleEagerRecalculation]) {
    [*(id *)(a1 + 32) _scheduleEagerRecalculationWithPasses:v2 fenceLocation:v56 != 0 minRadius:v53 beaconUUIDs:v27];
  }
}

void sub_1001212A0(id *a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 UUID];
  id v5 = [a1[4] proximityUUID];
  unsigned int v6 = [v4 isEqual:v5];

  if (!v6)
  {
    CFStringRef v12 = @"NO";
    CFStringRef v13 = @"N/A";
    CFStringRef v14 = @"N/A";
    goto LABEL_11;
  }
  uint64_t v7 = [a1[4] major];

  if (v7)
  {
    double v8 = [v3 major];
    unsigned int v9 = [v8 unsignedShortValue];
    uint64_t v10 = [a1[4] major];
    unsigned int v11 = [v10 unsignedShortValue];

    CFStringRef v12 = @"YES";
    if (v9 != v11)
    {
      CFStringRef v14 = @"N/A";
      CFStringRef v13 = @"NO";
LABEL_11:
      double v20 = PKLogFacilityTypeGetObject();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        double v21 = [a1[6] passTypeIdentifier];
        id v22 = [a1[6] serialNumber];
        id v23 = a1[4];
        int v26 = 138413570;
        double v27 = v21;
        __int16 v28 = 2112;
        long long v29 = v22;
        __int16 v30 = 2112;
        id v31 = v23;
        __int16 v32 = 2112;
        CFStringRef v33 = v12;
        __int16 v34 = 2112;
        CFStringRef v35 = v13;
        __int16 v36 = 2112;
        CFStringRef v37 = v14;
        id v24 = "   %@:%@ card beacon %@ DOES NOT match - UUID: %@ Major: %@ Minor: %@";
LABEL_16:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v24, (uint8_t *)&v26, 0x3Eu);

        goto LABEL_17;
      }
      goto LABEL_17;
    }
    CFStringRef v13 = @"YES";
  }
  else
  {
    CFStringRef v13 = @"N/A";
  }
  double v15 = [a1[4] minor];

  if (v15)
  {
    double v16 = [v3 minor];
    unsigned int v17 = [v16 unsignedShortValue];
    uint64_t v18 = [a1[4] minor];
    unsigned int v19 = [v18 unsignedShortValue];

    CFStringRef v12 = @"YES";
    if (v17 != v19)
    {
      CFStringRef v14 = @"NO";
      goto LABEL_11;
    }
  }
  else
  {
    CFStringRef v12 = @"N/A";
  }
  [a1[5] addObject:a1[4]];
  double v20 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    double v21 = [a1[6] passTypeIdentifier];
    id v22 = [a1[6] serialNumber];
    id v25 = a1[4];
    int v26 = 138413570;
    double v27 = v21;
    __int16 v28 = 2112;
    long long v29 = v22;
    __int16 v30 = 2112;
    id v31 = v25;
    __int16 v32 = 2112;
    CFStringRef v33 = @"YES";
    __int16 v34 = 2112;
    CFStringRef v35 = v13;
    __int16 v36 = 2112;
    CFStringRef v37 = v12;
    id v24 = "   %@:%@ card beacon %@ MATCHES - UUID: %@ Major: %@ Minor: %@";
    goto LABEL_16;
  }
LABEL_17:
}

int64_t sub_1001215A8(id a1, PKBeacon *a2, PKBeacon *a3)
{
  id v4 = a2;
  id v5 = a3;
  unsigned int v6 = [(PKBeacon *)v4 major];
  BOOL v7 = v6 != 0;

  double v8 = [(PKBeacon *)v5 major];
  BOOL v9 = v8 != 0;

  uint64_t v10 = [(PKBeacon *)v4 minor];
  BOOL v11 = v10 != 0;

  unsigned int v12 = v11 | (2 * v7);
  CFStringRef v13 = [(PKBeacon *)v5 minor];
  BOOL v14 = v13 != 0;

  unsigned int v15 = v14 | (2 * v9);
  if (v12 <= v15)
  {
    if (v12 >= v15)
    {
      uint64_t v17 = [(PKBeacon *)v4 relevantText];
      uint64_t v18 = [(PKBeacon *)v5 relevantText];
      unsigned int v19 = (void *)v18;
      if (v17 | v18)
      {
        if (!v17 || v18)
        {
          if (v17 || !v18) {
            int64_t v16 = (int64_t)[(id)v17 compare:v18];
          }
          else {
            int64_t v16 = 1;
          }
        }
        else
        {
          int64_t v16 = -1;
        }
      }
      else
      {
        double v20 = [(PKBeacon *)v4 proximityUUIDAsString];
        double v21 = [(PKBeacon *)v5 proximityUUIDAsString];
        int64_t v16 = (int64_t)[v20 compare:v21];
      }
    }
    else
    {
      int64_t v16 = 1;
    }
  }
  else
  {
    int64_t v16 = -1;
  }

  return v16;
}

uint64_t sub_100121860(uint64_t a1)
{
  id v2 = sub_100218A9C(*(void *)(*(void *)(a1 + 32) + 8));
  id v3 = objc_msgSend(*(id *)(a1 + 40), "pk_setByApplyingBlock:", &stru_1007389D8);
  id v4 = [objc_alloc((Class)NSMutableSet) initWithSet:v2];
  [v4 unionSet:v3];
  id v5 = objc_alloc_init((Class)NSMutableArray);
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v6 = v4;
  id v7 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v17;
    do
    {
      for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v17 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = *(void *)(*((void *)&v16 + 1) + 8 * i);
        unsigned int v12 = objc_msgSend(v2, "containsObject:", v11, (void)v16);
        int v13 = [v3 containsObject:v11];
        if (v12 != v13)
        {
          id v14 = sub_100218C54(*(void **)(*(void *)(a1 + 32) + 8), v13, v11);
          [v5 addObject:v11];
        }
      }
      id v8 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }
    while (v8);
  }

  [*(id *)(*(void *)(a1 + 32) + 24) setDidUpdateDynamicStatesForPassUniqueIDs:v5];
  return 1;
}

NSString *__cdecl sub_100121A24(id a1, PDCandidateRelevantPass *a2)
{
  return [(PDCandidateRelevantPass *)a2 uniqueIdentifier];
}

void sub_10012217C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc_init((Class)NSMutableDictionary);
  [v4 setObject:v3 forKeyedSubscript:PKPassLibraryRelevantInfoUniqueID];

  [v4 setObject:*(void *)(a1 + 32) forKeyedSubscript:PKPassLibraryRelevantInfoRelevantText];
  [*(id *)(a1 + 40) addObject:v4];
}

id sub_10012236C(id *a1)
{
  if ([a1[4] isEqualToString:PKDarwinNotificationEventBacklightStateChanged])
  {
    uint64_t v2 = *((void *)a1[5] + 23);
    id result = (id)xpc_dictionary_get_uint64(a1[6], "_State");
    id v4 = result;
    if (v2) {
      BOOL v5 = result == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (v5) {
      id result = [a1[5] recomputeRelevantPassesWithSearchMode:1];
    }
    *((void *)a1[5] + 23) = v4;
  }
  else
  {
    id result = [a1[4] isEqualToString:PDDarwinNotificationEventSignificantTimeChanged];
    if (result)
    {
      id v6 = a1[5];
      return _[v6 handleSignificantTimeChangedEvent];
    }
  }
  return result;
}

id sub_10012258C(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _isDoingLocationSearch];
  if (result && *(void *)(a1 + 40) == *(void *)(*(void *)(a1 + 32) + 64))
  {
    id v3 = [*(id *)(a1 + 48) lastObject];
    id v4 = v3;
    if (v3)
    {
      id v5 = v3;
      id v3 = [*(id *)(a1 + 32) _handleNewLocation:v3 forceAcceptance:0 from:@"CLLocationManager Delegate"];
      id v4 = v5;
    }
    return (id)_objc_release_x1(v3, v4);
  }
  return result;
}

void *sub_1001226E8(void *result)
{
  if (result[4] == *(void *)(result[5] + 64))
  {
    uint64_t v1 = (uint64_t)result;
    uint64_t v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_100515108(v1, v2);
    }

    return [*(id *)(v1 + 40) _startCardSearchUpdatingWithCachedProximity:0 refreshingProximity:1];
  }
  return result;
}

void *sub_10012281C(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _isDoingBeaconSearch];
  if (result)
  {
    id result = *(void **)(a1 + 32);
    if (*(void *)(a1 + 40) == result[8])
    {
      uint64_t v3 = *(void *)(a1 + 48);
      return [result _handleNewBeacons:v3];
    }
  }
  return result;
}

void sub_10012293C(void *a1)
{
  if (a1[4] == *(void *)(a1[5] + 64))
  {
    uint64_t v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = a1[6];
      int v4 = 138412290;
      uint64_t v5 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Location manager ranging beacons failed with error: %@", (uint8_t *)&v4, 0xCu);
    }
  }
}

void *sub_100122B64(void *result)
{
  if (result[4] == *(void *)(result[5] + 64))
  {
    uint64_t v1 = result;
    uint64_t v2 = PKLogFacilityTypeGetObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = v1[6];
      int v6 = 138412290;
      uint64_t v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Location manager failed with error: %@", (uint8_t *)&v6, 0xCu);
    }

    uint64_t v4 = v1[5];
    uint64_t v5 = *(void **)(v4 + 96);
    *(void *)(v4 + 96) = 0;

    return [(id)v1[5] _startCardSearchUpdatingWithCachedProximity:1 refreshingProximity:0];
  }
  return result;
}

void sub_100122CEC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if (*(void *)(v2 + 64) == v3)
  {
    int v5 = *(_DWORD *)(a1 + 48);
    if (*(_DWORD *)(v2 + 72) != v5)
    {
      *(_DWORD *)(v2 + 72) = v5;
      goto LABEL_8;
    }
LABEL_6:
    int v6 = 0;
    goto LABEL_9;
  }
  if (*(void *)(v2 + 80) != v3) {
    goto LABEL_6;
  }
  int v4 = *(_DWORD *)(a1 + 48);
  if (*(_DWORD *)(v2 + 88) == v4) {
    goto LABEL_6;
  }
  *(_DWORD *)(v2 + 8_Block_object_dispose(&STACK[0x420], 8) = v4;
LABEL_8:
  int v6 = 1;
LABEL_9:
  uint64_t v7 = PKLogFacilityTypeGetObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v8 = @"NO";
    if (v6) {
      CFStringRef v8 = @"YES";
    }
    uint64_t v9 = *(void *)(a1 + 32);
    uint64_t v10 = *(int *)(v9 + 72);
    uint64_t v11 = *(int *)(v9 + 88);
    int v12 = 138543874;
    CFStringRef v13 = v8;
    __int16 v14 = 2048;
    uint64_t v15 = v10;
    __int16 v16 = 2048;
    uint64_t v17 = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Change detected %{public}@, Relevancy auth status: %ld, Passbook auth status: %ld", (uint8_t *)&v12, 0x20u);
  }

  if (v6)
  {
    if ((PKRelevancyLocationServicesEnabled() & 1) == 0)
    {
      [*(id *)(a1 + 32) _stopLocationSearch];
      [*(id *)(a1 + 32) _stopBeaconSearch];
    }
    [*(id *)(a1 + 32) _startCardSearchUpdatingWithCachedProximity:0 refreshingProximity:1 searchMode:1];
  }
}