void __VTLogInitIfNeeded_block_invoke()
{
  os_log_t v0;
  void *v1;
  id v2;
  void *v3;
  void *v4;
  void *v5;
  NSObject *v6;
  uint8_t v7[16];

  NSLog(&cfstr_InitializingVo.isa);
  v0 = os_log_create((const char *)VTLoggingSubsystem, (const char *)kVTLoggingContextFramework);
  v1 = (void *)VTLogContextFacilityVoiceTrigger;
  VTLogContextFacilityVoiceTrigger = (uint64_t)v0;

  v2 = objc_alloc_init(MEMORY[0x263F08790]);
  v3 = (void *)_dateFormatter;
  _dateFormatter = (uint64_t)v2;

  v4 = (void *)_dateFormatter;
  v5 = [MEMORY[0x263EFF960] localeWithLocaleIdentifier:@"en_US_POSIX"];
  [v4 setLocale:v5];

  [(id)_dateFormatter setDateFormat:@"yyyyMMdd-HHmmss"];
  v6 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl(&dword_21844F000, v6, OS_LOG_TYPE_DEFAULT, "::: VoiceTrigger logging initialized", v7, 2u);
  }
}

double AccelerateML_sigmoid_h8(float16x8_t a1)
{
  v1.i64[0] = 0x6400640064006400;
  v1.i64[1] = 0x6400640064006400;
  v2.i64[0] = 0x1400140014001400;
  v2.i64[1] = 0x1400140014001400;
  int8x16_t v3 = (int8x16_t)vcltzq_f16(a1);
  v4.i64[0] = 0x3800380038003800;
  v4.i64[1] = 0x3800380038003800;
  float16x8_t v5 = vmaxq_f16(vminq_f16(a1, (float16x8_t)vdupq_lane_s16((int16x4_t)0x8AF4398CBDC54C29, 0)), (float16x8_t)vdupq_laneq_s16((int16x8_t)xmmword_21852DBC0, 4));
  int16x8_t v6 = vcvtq_s16_f16(vmulq_lane_f16(v5, (float16x4_t)0x8AF4398CBDC54C29, 1));
  float16x8_t v7 = vcvtq_f16_s16(v6);
  float16x8_t v8 = vmlaq_lane_f16(vmlaq_lane_f16(v5, v7, (float16x4_t)0x8AF4398CBDC54C29, 2), v7, (float16x4_t)0x8AF4398CBDC54C29, 3);
  v7.i64[0] = 0x4000400040004000;
  v7.i64[1] = 0x4000400040004000;
  *(void *)&double result = vdivq_f16((float16x8_t)xmmword_21852DBB0, vmlaq_f16((float16x8_t)xmmword_21852DBB0, vmulq_f16(vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16(*(float16x8_t *)"", vmlsq_f16(*(float16x8_t *)"b1b1b1b1b1b1b1b1", *(float16x8_t *)"d)d)d)d)d)d)d)d)b1b1b1b1b1b1b1b1", v8), v8), v8), v8), (float16x8_t)vaddq_s16(vshlq_n_s16(v6, 0xAuLL), (int16x8_t)vbslq_s8(v3, v4, v1))), (float16x8_t)vbslq_s8(v3, (int8x16_t)v7, v2))).u64[0];
  return result;
}

uint64_t AccelerateMLSigmoid_FP16(float16x8_t *a1, float16x8_t *a2, uint64_t a3)
{
  if ((int)a3 >= 8)
  {
    uint64_t v85 = v3;
    uint64_t v86 = v4;
    if ((a3 & 7) != 0)
    {
      *(double *)v16.i64 = AccelerateML_sigmoid_h8(*(float16x8_t *)((char *)a2 + 2 * a3 - 16));
      float16x8_t v84 = v16;
    }
    BOOL v14 = __OFSUB__(a3, 32);
    int v17 = a3 - 32;
    if (v17 < 0 == v14)
    {
      v18.i64[0] = 0x3800380038003800;
      v18.i64[1] = 0x3800380038003800;
      float16x8_t v20 = *a2;
      float16x8_t v21 = a2[1];
      v19 = a2 + 2;
      v22.i64[0] = 0x6400640064006400;
      v22.i64[1] = 0x6400640064006400;
      v23.i64[0] = 0x1400140014001400;
      v23.i64[1] = 0x1400140014001400;
      float16x8_t v24 = *v19;
      float16x8_t v25 = v19[1];
      a2 = v19 + 2;
      v26.i64[0] = 0x4000400040004000;
      v26.i64[1] = 0x4000400040004000;
      float16x8_t v27 = (float16x8_t)vdupq_lane_s16((int16x4_t)0x8AF4398CBDC54C29, 0);
      float16x8_t v28 = (float16x8_t)vdupq_laneq_s16((int16x8_t)xmmword_21852DBC0, 4);
      float16x8_t v29 = vmaxq_f16(vminq_f16(v20, v27), v28);
      float16x8_t v30 = vmaxq_f16(vminq_f16(v21, v27), v28);
      float16x8_t v31 = vmaxq_f16(vminq_f16(v24, v27), v28);
      float16x8_t v32 = vmaxq_f16(vminq_f16(v25, v27), v28);
      int8x16_t v87 = v18;
      while (1)
      {
        float16x8_t v46 = vmaxq_f16(v29, v28);
        float16x8_t v47 = vmaxq_f16(v30, v28);
        float16x8_t v48 = vmaxq_f16(v31, v28);
        float16x8_t v49 = vmaxq_f16(v32, v28);
        int8x16_t v50 = (int8x16_t)vcltzq_f16(v46);
        int8x16_t v51 = (int8x16_t)vcltzq_f16(v47);
        int8x16_t v52 = (int8x16_t)vcltzq_f16(v48);
        int8x16_t v53 = (int8x16_t)vcltzq_f16(v49);
        int16x8_t v54 = vcvtq_s16_f16(vmulq_lane_f16(v46, (float16x4_t)0x8AF4398CBDC54C29, 1));
        int16x8_t v55 = vcvtq_s16_f16(vmulq_lane_f16(v47, (float16x4_t)0x8AF4398CBDC54C29, 1));
        int16x8_t v56 = vcvtq_s16_f16(vmulq_lane_f16(v48, (float16x4_t)0x8AF4398CBDC54C29, 1));
        int16x8_t v57 = vcvtq_s16_f16(vmulq_lane_f16(v49, (float16x4_t)0x8AF4398CBDC54C29, 1));
        float16x8_t v58 = vcvtq_f16_s16(v54);
        float16x8_t v59 = vcvtq_f16_s16(v55);
        float16x8_t v60 = vcvtq_f16_s16(v56);
        float16x8_t v61 = vcvtq_f16_s16(v57);
        float16x8_t v62 = vmlaq_lane_f16(vmlaq_lane_f16(v46, v58, (float16x4_t)0x8AF4398CBDC54C29, 2), v58, (float16x4_t)0x8AF4398CBDC54C29, 3);
        float16x8_t v63 = vmlaq_lane_f16(vmlaq_lane_f16(v47, v59, (float16x4_t)0x8AF4398CBDC54C29, 2), v59, (float16x4_t)0x8AF4398CBDC54C29, 3);
        float16x8_t v64 = vmlaq_lane_f16(vmlaq_lane_f16(v48, v60, (float16x4_t)0x8AF4398CBDC54C29, 2), v60, (float16x4_t)0x8AF4398CBDC54C29, 3);
        float16x8_t v65 = vmlaq_lane_f16(vmlaq_lane_f16(v49, v61, (float16x4_t)0x8AF4398CBDC54C29, 2), v61, (float16x4_t)0x8AF4398CBDC54C29, 3);
        float16x8_t v66 = vmlaq_f16((float16x8_t)xmmword_21852DBB0, vmulq_f16(vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16(*(float16x8_t *)"", vmlsq_f16(*(float16x8_t *)"b1b1b1b1b1b1b1b1", *(float16x8_t *)"d)d)d)d)d)d)d)d)b1b1b1b1b1b1b1b1", v62), v62), v62), v62), (float16x8_t)vaddq_s16(vshlq_n_s16(v54, 0xAuLL), (int16x8_t)vbslq_s8(v50, v87, v22))), (float16x8_t)vbslq_s8(v50, v26, v23));
        float16x8_t v67 = vmlaq_f16((float16x8_t)xmmword_21852DBB0, vmulq_f16(vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16(*(float16x8_t *)"", vmlsq_f16(*(float16x8_t *)"b1b1b1b1b1b1b1b1", *(float16x8_t *)"d)d)d)d)d)d)d)d)b1b1b1b1b1b1b1b1", v63), v63), v63), v63), (float16x8_t)vaddq_s16(vshlq_n_s16(v55, 0xAuLL), (int16x8_t)vbslq_s8(v51, v87, v22))), (float16x8_t)vbslq_s8(v51, v26, v23));
        float16x8_t v68 = vmlaq_f16((float16x8_t)xmmword_21852DBB0, vmulq_f16(vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16(*(float16x8_t *)"", vmlsq_f16(*(float16x8_t *)"b1b1b1b1b1b1b1b1", *(float16x8_t *)"d)d)d)d)d)d)d)d)b1b1b1b1b1b1b1b1", v64), v64), v64), v64), (float16x8_t)vaddq_s16(vshlq_n_s16(v56, 0xAuLL), (int16x8_t)vbslq_s8(v52, v87, v22))), (float16x8_t)vbslq_s8(v52, v26, v23));
        float16x8_t v69 = vmlaq_f16((float16x8_t)xmmword_21852DBB0, vmulq_f16(vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16((float16x8_t)xmmword_21852DBB0, vmlsq_f16(*(float16x8_t *)"", vmlsq_f16(*(float16x8_t *)"b1b1b1b1b1b1b1b1", *(float16x8_t *)"d)d)d)d)d)d)d)d)b1b1b1b1b1b1b1b1", v65), v65), v65), v65), (float16x8_t)vaddq_s16(vshlq_n_s16(v57, 0xAuLL), (int16x8_t)vbslq_s8(v53, v87, v22))), (float16x8_t)vbslq_s8(v53, v26, v23));
        float16x8_t v70 = vrecpeq_f16(v66);
        float16x8_t v71 = vrecpeq_f16(v67);
        float16x8_t v72 = vrecpeq_f16(v68);
        float16x8_t v73 = vrecpeq_f16(v69);
        float16x8_t v74 = vrecpsq_f16(v70, v66);
        float16x8_t v75 = vrecpsq_f16(v71, v67);
        float16x8_t v76 = vrecpsq_f16(v72, v68);
        float16x8_t v77 = vrecpsq_f16(v73, v69);
        BOOL v14 = __OFSUB__(v17, 32);
        v17 -= 32;
        if (v17 < 0 != v14) {
          break;
        }
        float16x8_t v33 = vmulq_f16(v74, v70);
        float16x8_t v35 = *a2;
        v34 = a2 + 1;
        float16x8_t v36 = v35;
        float16x8_t v37 = vmulq_f16(v75, v71);
        float16x8_t v38 = *v34++;
        float16x8_t v39 = v38;
        float16x8_t v40 = vmulq_f16(v76, v72);
        float16x8_t v41 = *v34++;
        float16x8_t v42 = v41;
        float16x8_t v43 = vmulq_f16(v77, v73);
        float16x8_t v44 = *v34;
        a2 = v34 + 1;
        float16x8_t v29 = vminq_f16(v36, v27);
        *a1 = v33;
        v45 = a1 + 1;
        float16x8_t v30 = vminq_f16(v39, v27);
        *v45++ = v37;
        float16x8_t v31 = vminq_f16(v42, v27);
        *v45++ = v40;
        float16x8_t v32 = vminq_f16(v44, v27);
        float16x8_t *v45 = v43;
        a1 = v45 + 1;
      }
      *a1 = vmulq_f16(v74, v70);
      v78 = a1 + 1;
      *v78++ = vmulq_f16(v75, v71);
      *v78++ = vmulq_f16(v76, v72);
      float16x8_t *v78 = vmulq_f16(v77, v73);
      a1 = v78 + 1;
    }
    BOOL v14 = __OFADD__(v17, 24);
    for (int i = v17 + 24; i < 0 == v14; int i = v82 - 8)
    {
      *(double *)v80.i64 = AccelerateML_sigmoid_h8(*a2);
      float16x8_t *v81 = v80;
      a1 = v81 + 1;
      BOOL v14 = __OFSUB__(v82, 8);
    }
    uint64_t v83 = (i + 8);
    if (v83) {
      *(float16x8_t *)((char *)a1 + 2 * v83 - 16) = v84;
    }
    return 0;
  }
  else
  {
    float16x8_t v5 = &v84;
    uint64_t v6 = a3;
    do
    {
      __int16 v7 = a2->i16[0];
      a2 = (float16x8_t *)((char *)a2 + 2);
      v5->i16[0] = v7;
      float16x8_t v5 = (float16x8_t *)((char *)v5 + 2);
    }
    while (v6-- > 1);
    *(double *)v11.i64 = AccelerateML_sigmoid_h8(v84);
    float16x8_t v84 = v11;
    v12 = &v84;
    do
    {
      __int16 v13 = v12->i16[0];
      v12 = (float16x8_t *)((char *)v12 + 2);
      *v9++ = v13;
      BOOL v14 = __OFSUB__(v10--, 1);
    }
    while (!((v10 < 0) ^ v14 | (v10 == 0)));
    return 0;
  }
}

void sub_2184525A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getCSUtilsClass_block_invoke(uint64_t a1)
{
  if (!CoreSpeechFoundationLibraryCore_frameworkLibrary) {
    CoreSpeechFoundationLibraryCore_frameworkLibrary = _sl_dlopen();
  }
  Class result = objc_getClass("CSUtils");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCSUtilsClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __CoreSpeechFoundationLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreSpeechFoundationLibraryCore_frameworkLibrary = result;
  return result;
}

void sub_218452A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_218452F70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_218453A98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,int a52,__int16 a53,char a54,char a55,void *__p,uint64_t a57,int a58,__int16 a59,char a60,char a61)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)&a15);
  _Unwind_Resume(a1);
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void voicetrigger::VTAudioCircularBufferImpl<unsigned short>::copySamples(void *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  unint64_t v7 = *(void *)(a2 + 24);
  unint64_t v8 = *(void *)(a2 + 40);
  if (v8 >= v7) {
    unint64_t v9 = v8 - v7;
  }
  else {
    unint64_t v9 = 0;
  }
  if (v9 <= a3 && a4 > a3 && v8 >= a4 && v8 > a3 && v9 < a4) {
    operator new[]();
  }
  BOOL v14 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134349824;
    unint64_t v16 = a3;
    __int16 v17 = 2050;
    unint64_t v18 = a4;
    __int16 v19 = 2050;
    unint64_t v20 = v9;
    __int16 v21 = 2050;
    unint64_t v22 = v8;
    _os_log_error_impl(&dword_21844F000, v14, OS_LOG_TYPE_ERROR, "Invalid request: reqStartSample=%{public}ld, reqEndSample=%{public}ld, oldestSampleInBuffer: %{public}ld, latestSampleInBuffer=%{public}ld", buf, 0x2Au);
  }
  *a1 = 0;
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B8];
  uint64_t v3 = *MEMORY[0x263F8C2B8];
  *(void *)a1 = *MEMORY[0x263F8C2B8];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x21D46B200](a1 + 128);
  return a1;
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_264325138, MEMORY[0x263F8C060]);
}

void sub_218453F10(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x21D46B140](v24, a1);
  if (v24[0])
  {
    uint64_t v6 = (char *)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *((void *)v6 + 5);
    int v8 = *((_DWORD *)v6 + 2);
    int v9 = *((_DWORD *)v6 + 36);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      int v10 = std::locale::use_facet(&__b, MEMORY[0x263F8C108]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&__b);
      *((_DWORD *)v6 + 36) = v9;
    }
    uint64_t v11 = a2 + a3;
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v12 = a2 + a3;
    }
    else {
      uint64_t v12 = a2;
    }
    if (!v7) {
      goto LABEL_30;
    }
    uint64_t v13 = *((void *)v6 + 3);
    BOOL v14 = v13 <= a3;
    uint64_t v15 = v13 - a3;
    size_t v16 = v14 ? 0 : v15;
    if (v12 - a2 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, v12 - a2) != v12 - a2)
    {
      goto LABEL_30;
    }
    if ((uint64_t)v16 >= 1)
    {
      if (v16 >= 0x7FFFFFFFFFFFFFF8) {
        std::string::__throw_length_error[abi:ne180100]();
      }
      if (v16 >= 0x17)
      {
        uint64_t v18 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v16 | 7) != 0x17) {
          uint64_t v18 = v16 | 7;
        }
        uint64_t v19 = v18 + 1;
        p_b = (std::locale::__imp *)operator new(v18 + 1);
        size_t v26 = v16;
        int64_t v27 = v19 | 0x8000000000000000;
        __b.__locale_ = p_b;
      }
      else
      {
        HIBYTE(v27) = v16;
        p_b = (std::locale::__imp *)&__b;
      }
      memset(p_b, v9, v16);
      *((unsigned char *)p_b + v16) = 0;
      if (v27 >= 0) {
        locale = &__b;
      }
      else {
        locale = __b.__locale_;
      }
      uint64_t v21 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v7 + 96))(v7, locale, v16);
      uint64_t v22 = v21;
      if (SHIBYTE(v27) < 0)
      {
        operator delete(__b.__locale_);
        if (v22 != v16)
        {
LABEL_30:
          std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
          goto LABEL_31;
        }
      }
      else if (v21 != v16)
      {
        goto LABEL_30;
      }
    }
    if (v11 - v12 >= 1
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v12, v11 - v12) != v11 - v12)
    {
      goto LABEL_30;
    }
    *((void *)v6 + 3) = 0;
  }
LABEL_31:
  MEMORY[0x21D46B150](v24);
  return a1;
}

void sub_218454200(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  MEMORY[0x21D46B150](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x2184541D4);
}

void sub_21845426C(_Unwind_Exception *a1)
{
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2C8];
  uint64_t v3 = *MEMORY[0x263F8C2C8];
  *(void *)a1 = *MEMORY[0x263F8C2C8];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x21D46B200](a1 + 112);
  return a1;
}

void __clang_call_terminate(void *a1)
{
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_2184547B4(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B220](v1, 0x1000C80BDFB0063);
  _Unwind_Resume(a1);
}

void sub_218454C68(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v2, 0x1090C4018C15A78);

  _Unwind_Resume(a1);
}

void std::vector<unsigned short const*>::__throw_length_error[abi:ne180100]()
{
}

void NConfigSectionExt::sOpt(NConfigSectionExt *this, const NString *a2, const NString *a3)
{
}

void NConfigSectionExt::fOpt(NConfigSectionExt *this, const NString *a2, const float *a3)
{
}

void NConfigSectionExt::iOpt(NConfigSectionExt *this, const NString *a2, const int *a3)
{
}

void NConfigSectionExt::bOpt(NConfigSectionExt *this, const NString *a2, const BOOL *a3)
{
}

void sub_218455628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__127(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__128(uint64_t a1)
{
}

void sub_218455898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_218456620(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    MEMORY[0x21D46B240](v2, 0x10F0C404F423172);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x21845648CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_218456860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__190(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__191(uint64_t a1)
{
}

void sub_218457464(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21845758C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184575E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21845783C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_218457CA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_218457F4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184582EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184582FC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, long long buf)
{
  if (a2)
  {
    BOOL v14 = __cxa_begin_catch(a1);
    uint64_t v15 = *(void **)(v11 + 32);
    if (a2 == 2)
    {
      [v15 setTdPsrCanProcessRequest:0];
      size_t v16 = NSString;
      (*(void (**)(void *))(*(void *)v14 + 16))(v14);
      __int16 v17 = [v16 stringWithFormat:@"Exception ending audio: %s"];
      uint64_t v18 = *(NSObject **)(v12 + 1952);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v17;
        _os_log_impl(&dword_21844F000, v18, OS_LOG_TYPE_DEFAULT, "TDSR:: %{public}@", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v19 = +[VTTextDependentSpeakerRecognizer errorWithCode:1003 message:v17];
      id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(v11 + 32) + 40));
      [WeakRetained textDependentSpeakerRecognizer:*(void *)(v11 + 32) failedWithError:v19];

      __cxa_end_catch();
    }
    else
    {
      [v15 setTdPsrCanProcessRequest:0];
      uint64_t v21 = *(NSObject **)(v12 + 1952);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_21844F000, v21, OS_LOG_TYPE_DEFAULT, "TDSR:: Unknown Exception adding audio:", (uint8_t *)&buf, 2u);
      }
      uint64_t v22 = +[VTTextDependentSpeakerRecognizer errorWithCode:1003 message:@"Unknown exception adding audio"];
      id v23 = objc_loadWeakRetained((id *)(*(void *)(v11 + 32) + 40));
      [v23 textDependentSpeakerRecognizer:*(void *)(v11 + 32) failedWithError:v22];

      __cxa_end_catch();
    }
    JUMPOUT(0x2184582B8);
  }
  _Unwind_Resume(a1);
}

void sub_2184586BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184586CC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, long long buf)
{
  if (a2)
  {
    uint64_t v13 = __cxa_begin_catch(a1);
    BOOL v14 = *(void **)(v11 + 32);
    if (a2 == 2)
    {
      [v14 setTdPsrCanProcessRequest:0];
      uint64_t v15 = NSString;
      (*(void (**)(void *))(*(void *)v13 + 16))(v13);
      size_t v16 = [v15 stringWithFormat:@"Exception adding audio: %s"];
      __int16 v17 = VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138543362;
        *(void *)((char *)&buf + 4) = v16;
        _os_log_impl(&dword_21844F000, v17, OS_LOG_TYPE_DEFAULT, "TDSR:: %{public}@", (uint8_t *)&buf, 0xCu);
      }
      uint64_t v18 = +[VTTextDependentSpeakerRecognizer errorWithCode:1002 message:v16];
      id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(v11 + 32) + 40));
      [WeakRetained textDependentSpeakerRecognizer:*(void *)(v11 + 32) failedWithError:v18];

      __cxa_end_catch();
    }
    else
    {
      [v14 setTdPsrCanProcessRequest:0];
      unint64_t v20 = VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_21844F000, v20, OS_LOG_TYPE_DEFAULT, "TDSR:: Unknown Exception adding audio:", (uint8_t *)&buf, 2u);
      }
      uint64_t v21 = +[VTTextDependentSpeakerRecognizer errorWithCode:1002 message:@"Unknown exception adding audio"];
      id v22 = objc_loadWeakRetained((id *)(*(void *)(v11 + 32) + 40));
      [v22 textDependentSpeakerRecognizer:*(void *)(v11 + 32) failedWithError:v21];

      __cxa_end_catch();
    }
    JUMPOUT(0x218458688);
  }
  _Unwind_Resume(a1);
}

void sub_218458C78(_Unwind_Exception *a1)
{
  uint64_t v4 = v2;

  _Unwind_Resume(a1);
}

void sub_2184599F8(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, long long buf)
{
  if (a2)
  {
    uint64_t v19 = __cxa_begin_catch(a1);
    unint64_t v20 = *(NSObject **)(v17 + 1952);
    BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
    if (a2 == 2)
    {
      if (v21)
      {
        id v22 = *(uint64_t (**)(void *))(*(void *)v19 + 16);
        id v23 = v20;
        uint64_t v24 = v22(v19);
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v24;
        _os_log_impl(&dword_21844F000, v23, OS_LOG_TYPE_DEFAULT, "TDSR:: Exception creating VTTextDependentSpeakerRecognizer: %{public}s", (uint8_t *)&buf, 0xCu);
      }
    }
    else if (v21)
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_21844F000, v20, OS_LOG_TYPE_DEFAULT, "TDSR:: Unknown exception creating VTTextDependentSpeakerRecognizer", (uint8_t *)&buf, 2u);
    }
    __cxa_end_catch();
    JUMPOUT(0x218459974);
  }
  _Unwind_Resume(a1);
}

void sub_218459DBC(_Unwind_Exception *a1)
{
  float16x8_t v5 = v4;

  _Unwind_Resume(a1);
}

void sub_218459EE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21845A024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void BlobBuilder::buildBlob(BlobBuilder *this, const NConfig *a2, N16ByteAlignedString *a3)
{
  long long v12 = xmmword_21852DE10;
  uint64_t v13 = 0;
  int v14 = 0;
  __asm { FMOV            V1.2S, #-1.0 }
  uint64_t v15 = _D1;
  int v16 = 1056964608;
  int v17 = 1;
  uint64_t v18 = &unk_26C99C348;
  uint64_t v19 = 0;
  int v20 = 0;
  BOOL v21 = &unk_26C99C348;
  uint64_t v22 = 0;
  int v23 = 0;
  uint64_t v24 = &unk_26C99C3B8;
  uint64_t v25 = 0;
  int v26 = 0;
  uint64_t v27 = 0x4874240047C35000;
  int v28 = 1064849900;
  int v29 = 257;
  int v30 = 26;
  long long v31 = xmmword_21852DE20;
  uint64_t v32 = 0x160000000CLL;
  char v33 = 1;
  *(void *)&v34[3] = 0x3F80000000000000;
  *(_DWORD *)v34 = 0;
  char v35 = 0;
  uint64_t v38 = 0x200000002;
  char v37 = 0;
  __int16 v36 = 0;
  uint64_t v39 = 51;
  int v40 = 1065353216;
  int v43 = 0;
  float16x8_t v41 = &unk_26C99AB50;
  uint64_t v42 = 0;
  v45 = &unk_26C99BE78;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  int v48 = 0;
  float16x8_t v44 = &unk_26C99A930;
  float16x8_t v49 = &unk_26C99B388;
  unsigned int v52 = 16;
  memptr = 0;
  if (!malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
  {
    int v50 = 0;
    int8x16_t v51 = memptr;
    float16x8_t v49 = &unk_26C99B388;
    *(unsigned char *)memptr = 0;
    NDeepnetDistribution::NDeepnetDistribution((NDeepnetDistribution *)v53);
    v53[384] = 0;
    int16x8_t v54 = &unk_26C99C348;
    uint64_t v55 = 0;
    int v56 = 0;
    int16x8_t v57 = &unk_26C99C348;
    uint64_t v58 = 0;
    int v59 = 0;
    float16x8_t v60 = &unk_26C99C348;
    uint64_t v61 = 0;
    int v62 = 0;
    char v63 = 0;
    char v64 = 0;
    float16x8_t v65 = &unk_26C99C348;
    uint64_t v66 = 0;
    int v67 = 0;
    uint64_t v68 = 0;
    char v69 = 0;
    float16x8_t v70 = &unk_26C99C348;
    uint64_t v71 = 0;
    int v72 = 0;
    char v73 = 0;
    char v74 = 0;
    float16x8_t v75 = &unk_26C99C3F0;
    uint64_t v76 = 0;
    int v77 = 0;
    v78 = &unk_26C99C2A0;
    uint64_t v79 = 0;
    int v80 = 0;
    v81 = &unk_26C99C348;
    uint64_t v82 = 0;
    int v83 = 0;
    char v84 = 0;
    char v85 = 0;
    uint64_t v87 = 0;
    uint64_t v86 = &unk_26C99C678;
    uint64_t v88 = 0;
    int v89 = 0;
    v90 = &unk_26C99C348;
    uint64_t v91 = 0;
    int v92 = 0;
    v95 = &unk_26C99C348;
    uint64_t v96 = 0;
    int v97 = 0;
    uint64_t v93 = 0;
    uint64_t v94 = 0;
    v98 = &unk_26C99C348;
    uint64_t v99 = 0;
    int v100 = 0;
    uint64_t v102 = 0;
    int v103 = 0;
    v101 = &unk_26C99C498;
    char v104 = 0;
    int v105 = 1203982336;
    uint64_t v106 = 0x3F7851EC48742400;
    int v107 = 257;
    int v108 = 26;
    long long v109 = xmmword_21852DE20;
    uint64_t v110 = 0x160000000CLL;
    char v111 = 1;
    *(void *)&v112[3] = 0x3F80000000000000;
    *(_DWORD *)v112 = 0;
    char v113 = 0;
    uint64_t v116 = 0x200000002;
    __int16 v114 = 0;
    char v115 = 0;
    BlobBuilder::build((BlobBuilder *)v11, this, a2);
  }
  Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v10, 1, v52);
}

void sub_21845A648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  BlobBuilder::~BlobBuilder((BlobBuilder *)va);
  _Unwind_Resume(a1);
}

void sub_21845A65C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39)
{
  N16ByteAlignedString::~N16ByteAlignedString(v40);
  NPhoneHMMArray::~NPhoneHMMArray(v39);
  if (a39) {
    MEMORY[0x21D46B220](a39, 0x1000C8052888210);
  }
  if (a36) {
    MEMORY[0x21D46B220](a36, 0x1000C8052888210);
  }
  if (a33) {
    MEMORY[0x21D46B220](a33, 0x1000C8052888210);
  }
  _Unwind_Resume(a1);
}

void BlobBuilder::build(BlobBuilder *this, const NConfig *a2, N16ByteAlignedString *a3)
{
  uint64_t v3 = &unk_26C99C5B0;
  int v4 = 4;
  operator new[]();
}

void sub_21845AE88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a18) {
    MEMORY[0x21D46B220](a18, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NDEAcAnal::~NDEAcAnal(NDEAcAnal *this)
{
  *((void *)this + 69) = &unk_26C99C348;
  uint64_t v2 = *((void *)this + 70);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  *((void *)this + 66) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 67);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  AccelWin2MFCC::~AccelWin2MFCC((void **)this + 11);
  *((void *)this + 7) = &unk_26C99C348;
  uint64_t v4 = *((void *)this + 8);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  *((void *)this + 4) = &unk_26C99C348;
  uint64_t v5 = *((void *)this + 5);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  *((void *)this + 1) = &unk_26C99C348;
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8052888210);
  }
}

void BlobBuilder::~BlobBuilder(BlobBuilder *this)
{
  NDEAcAnal::~NDEAcAnal((BlobBuilder *)((char *)this + 752));
  NDeepnetDistribution::~NDeepnetDistribution((BlobBuilder *)((char *)this + 368));
  *((void *)this + 42) = &unk_26C99B388;
  free(*((void **)this + 44));
  *((void *)this + 44) = 0;
  *((void *)this + 42) = &unk_26C99C5B0;
  NPhoneHMMArray::~NPhoneHMMArray((BlobBuilder *)((char *)this + 272));
  *((void *)this + 20) = &unk_26C99C3B8;
  uint64_t v2 = *((void *)this + 21);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  *((void *)this + 17) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 18);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 14) = &unk_26C99C348;
  uint64_t v4 = *((void *)this + 15);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
}

uint64_t NArray<float>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

float NArray<float>::fromArray(uint64_t a1, uint64_t a2, int *a3)
{
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C8052888210);
      int v5 = *a3;
    }
    *(_DWORD *)(a1 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = v4;
    if (v4 < 8 || (unint64_t)(v8 - a2) <= 0x1F)
    {
      uint64_t v11 = 0;
LABEL_14:
      uint64_t v17 = v9 - v11;
      uint64_t v18 = 4 * v11;
      uint64_t v19 = (_DWORD *)(v8 + v18);
      int v20 = (int *)(a2 + v18);
      do
      {
        int v21 = *v20++;
        LODWORD(v15) = v21;
        *v19++ = v21;
        --v17;
      }
      while (v17);
      return *(float *)&v15;
    }
    uint64_t v11 = v4 & 0xFFFFFFF8;
    long long v12 = (_OWORD *)(v8 + 16);
    uint64_t v13 = (long long *)(a2 + 16);
    uint64_t v14 = v9 & 0xFFFFFFF8;
    do
    {
      long long v15 = *(v13 - 1);
      long long v16 = *v13;
      *(v12 - 1) = v15;
      _OWORD *v12 = v16;
      v12 += 2;
      v13 += 2;
      v14 -= 8;
    }
    while (v14);
    if (v11 != v9) {
      goto LABEL_14;
    }
  }
  return *(float *)&v15;
}

uint64_t NArray<float>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      uint64_t v10 = v4;
      if (v4 < 8) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFF8;
      uint64_t v11 = (_OWORD *)(v9 + 16);
      long long v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFF8;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *uint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 4 * v7;
        uint64_t v17 = (_DWORD *)(v9 + v16);
        uint64_t v18 = (int *)(v8 + v16);
        do
        {
          int v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  return result;
}

void NArray<float>::~NArray(void *a1)
{
  *a1 = &unk_26C99C348;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8052888210);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<float>::~NArray(void *a1)
{
  *a1 = &unk_26C99C348;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  return a1;
}

uint64_t NArray<int>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<int>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C8052888210);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    unint64_t v8 = 0;
    uint64_t v9 = *(void *)(result + 8);
    do
    {
      *(_DWORD *)(v9 + 4 * v8) = *(_DWORD *)(a2 + 4 * v8);
      ++v8;
    }
    while (v8 < *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t NArray<int>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      unint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(result + 16));
    }
  }
  return result;
}

void NArray<int>::~NArray(void *a1)
{
  *a1 = &unk_26C99C3B8;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8052888210);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<int>::~NArray(void *a1)
{
  *a1 = &unk_26C99C3B8;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  return a1;
}

void BlobBuilder::buildDistBlob(BlobBuilder *this, const NConfigSection *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = &unk_26C99B388;
  unsigned int v6 = 16;
  memptr = 0;
  if (!malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL))
  {
    int v4 = 0;
    int v5 = memptr;
    uint64_t v3 = &unk_26C99B388;
    *(unsigned char *)memptr = 0;
    memptr = &unk_26C99C5B0;
    LODWORD(v8) = 16;
    operator new[]();
  }
  Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, v6);
}

void sub_21845C2DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,_Unwind_Exception *exception_object,uint64_t a40)
{
  if (a30) {
    MEMORY[0x21D46B220](a30, 0x1000C8077774924);
  }
  if (a33) {
    MEMORY[0x21D46B220](a33, 0x1000C8077774924);
  }
  if (exception_object) {
    MEMORY[0x21D46B220](exception_object, 0x1000C8052888210);
  }
  N16ByteAlignedString::~N16ByteAlignedString(&a34);
  _Unwind_Resume(a1);
}

void BlobBuilder::buildPhoneHmmArray(BlobBuilder *this, const NConfigSection *a2)
{
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 8;
  operator new[]();
}

void sub_21845C740(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void BlobBuilder::buildAcAnalConfig(BlobBuilder *this, const NConfigSection *a2)
{
  uint64_t v2 = &unk_26C99C5B0;
  LODWORD(v3) = 11;
  operator new[]();
}

void sub_21845DA88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  if (a7) {
    MEMORY[0x21D46B220](a7, 0x1000C8077774924);
  }
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8077774924);
  }
  *(void *)(v11 - 88) = v10;
  uint64_t v13 = *(void *)(v11 - 72);
  if (v13) {
    MEMORY[0x21D46B220](v13, 0x1000C8077774924);
  }
  NConfig::~NConfig((NConfig *)va);
  _Unwind_Resume(a1);
}

void BlobBuilder::buildNormConfig(BlobBuilder *this, const NConfigSection *a2)
{
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 11;
  operator new[]();
}

void sub_21845DF98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void BlobBuilder::buildDetectConfig(BlobBuilder *this, const NConfigSection *a2, const NConfigSection *a3, const NConfigSection *a4)
{
  int v4 = &unk_26C99C5B0;
  int v5 = 11;
  operator new[]();
}

void sub_21845FE9C(_Unwind_Exception *a1)
{
  *(void *)(v3 - 176) = v1;
  uint64_t v5 = *(void *)(v2 + 8);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NArray<NString>::~NArray((void *)(v3 - 152));
  NArray<NString>::~NArray((void *)(v3 - 128));
  _Unwind_Resume(a1);
}

uint64_t BlobBuilder::buildConfgHeader(uint64_t this, int a2)
{
  *(void *)this = 0xA3176424F4C4243;
  if (a2) {
    int v2 = 64;
  }
  else {
    int v2 = 48;
  }
  *(_DWORD *)(this + 8) = 2;
  *(_DWORD *)(this + 12) = v2;
  int v3 = v2 | 0x80;
  *(_DWORD *)(this + 16) = v2 + 48;
  *(_DWORD *)(this + 20) = v2 | 0x80;
  int v4 = v2 + 144;
  if (*(unsigned char *)(this + 252)) {
    int v5 = v4;
  }
  else {
    int v5 = v3;
  }
  int v6 = *(_DWORD *)(this + 344);
  *(_DWORD *)(this + 24) = v5;
  *(_DWORD *)(this + 28) = v6;
  unsigned int v7 = ((v6 + 15) & 0xFFFFFFF0) + v5;
  *(_DWORD *)(this + 32) = v7;
  uint64_t v8 = *(unsigned int *)(this + 176);
  if (!v8)
  {
    int v14 = 4;
    *(_DWORD *)(this + 36) = 4;
    goto LABEL_41;
  }
  int v9 = *(_DWORD *)(this + 68);
  uint64_t v10 = *(void *)(this + 168);
  uint64_t v11 = *(void *)(this + 280);
  if (v9 >= -1)
  {
    if (v8 == 1)
    {
      uint64_t v15 = 0;
      int v13 = 4;
    }
    else
    {
      int v23 = 0;
      uint64_t v15 = v8 & 0xFFFFFFFE;
      uint64_t v24 = (unsigned int *)(v10 + 4);
      int v25 = 4;
      uint64_t v26 = v15;
      do
      {
        v25 += 8 * *(_DWORD *)(v11 + 48 * *(v24 - 1) + 16) + 4;
        v23 += 8 * *(_DWORD *)(v11 + 48 * *v24 + 16) + 4;
        v24 += 2;
        v26 -= 2;
      }
      while (v26);
      int v13 = v23 + v25;
      if (v15 == v8) {
        goto LABEL_25;
      }
    }
    uint64_t v27 = v8 - v15;
    int v28 = (unsigned int *)(v10 + 4 * v15);
    do
    {
      unsigned int v29 = *v28++;
      v13 += 8 * *(_DWORD *)(v11 + 48 * v29 + 16) + 4;
      --v27;
    }
    while (v27);
    goto LABEL_25;
  }
  if (v8 == 1)
  {
    uint64_t v12 = 0;
    int v13 = 4;
LABEL_17:
    uint64_t v20 = v8 - v12;
    int v21 = (unsigned int *)(v10 + 4 * v12);
    do
    {
      unsigned int v22 = *v21++;
      v13 += 8 * *(_DWORD *)(v11 + 48 * v22 + 16) + 12;
      --v20;
    }
    while (v20);
    goto LABEL_25;
  }
  int v16 = 0;
  uint64_t v12 = v8 & 0xFFFFFFFE;
  uint64_t v17 = (unsigned int *)(v10 + 4);
  int v18 = 4;
  uint64_t v19 = v12;
  do
  {
    v18 += 8 * *(_DWORD *)(v11 + 48 * *(v17 - 1) + 16) + 12;
    v16 += 8 * *(_DWORD *)(v11 + 48 * *v17 + 16) + 12;
    v17 += 2;
    v19 -= 2;
  }
  while (v19);
  int v13 = v16 + v18;
  if (v12 != v8) {
    goto LABEL_17;
  }
LABEL_25:
  *(_DWORD *)(this + 36) = v13;
  if (v9 >= -1)
  {
    if (v8 == 1)
    {
      uint64_t v31 = 0;
      int v14 = 4;
    }
    else
    {
      int v39 = 0;
      uint64_t v31 = v8 & 0xFFFFFFFE;
      int v40 = (unsigned int *)(v10 + 4);
      int v41 = 4;
      uint64_t v42 = v31;
      do
      {
        v41 += 8 * *(_DWORD *)(v11 + 48 * *(v40 - 1) + 16) + 4;
        v39 += 8 * *(_DWORD *)(v11 + 48 * *v40 + 16) + 4;
        v40 += 2;
        v42 -= 2;
      }
      while (v42);
      int v14 = v39 + v41;
      if (v31 == v8) {
        goto LABEL_41;
      }
    }
    uint64_t v43 = v8 - v31;
    float16x8_t v44 = (unsigned int *)(v10 + 4 * v31);
    do
    {
      unsigned int v45 = *v44++;
      v14 += 8 * *(_DWORD *)(v11 + 48 * v45 + 16) + 4;
      --v43;
    }
    while (v43);
    goto LABEL_41;
  }
  if (v8 == 1)
  {
    uint64_t v30 = 0;
    int v14 = 4;
LABEL_33:
    uint64_t v36 = v8 - v30;
    char v37 = (unsigned int *)(v10 + 4 * v30);
    do
    {
      unsigned int v38 = *v37++;
      v14 += 8 * *(_DWORD *)(v11 + 48 * v38 + 16) + 12;
      --v36;
    }
    while (v36);
    goto LABEL_41;
  }
  int v32 = 0;
  uint64_t v30 = v8 & 0xFFFFFFFE;
  char v33 = (unsigned int *)(v10 + 4);
  int v34 = 4;
  uint64_t v35 = v30;
  do
  {
    v34 += 8 * *(_DWORD *)(v11 + 48 * *(v33 - 1) + 16) + 12;
    v32 += 8 * *(_DWORD *)(v11 + 48 * *v33 + 16) + 12;
    v33 += 2;
    v35 -= 2;
  }
  while (v35);
  int v14 = v32 + v34;
  if (v30 != v8) {
    goto LABEL_33;
  }
LABEL_41:
  unsigned int v46 = ((v14 + 15) & 0xFFFFFFF0) + v7;
  *(_DWORD *)(this + 40) = v46;
  *(_DWORD *)(this + 44) = 40960 - v46;
  return this;
}

void BlobBuilder::serializeDetectConfig(BlobBuilder *this, N16ByteAlignedString *a2)
{
  LODWORD(v2) = 44;
  (*(void (**)(N16ByteAlignedString *, char *, void **))(*(void *)a2 + 72))(a2, (char *)this + 64, &v2);
  int v2 = &unk_26C99C380;
  operator new[]();
}

void sub_2184607A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void BlobBuilder::serializeAcAnalConfig(BlobBuilder *this, N16ByteAlignedString *a2)
{
  LODWORD(v2) = 68;
  (*(void (**)(N16ByteAlignedString *, char *, void **))(*(void *)a2 + 72))(a2, (char *)this + 184, &v2);
  int v2 = &unk_26C99C380;
  operator new[]();
}

void sub_2184608E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void BlobBuilder::serializeNormConfig(BlobBuilder *this, N16ByteAlignedString *a2)
{
  LODWORD(v2) = 12;
  (*(void (**)(N16ByteAlignedString *, char *, void **))(*(void *)a2 + 72))(a2, (char *)this + 256, &v2);
  int v2 = &unk_26C99C380;
  operator new[]();
}

void sub_218460A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BlobBuilder::serializeDistBlob(BlobBuilder *this, N16ByteAlignedString *a2)
{
  uint64_t v4 = *((void *)this + 44);
  LODWORD(v7) = *((_DWORD *)this + 86);
  (*(void (**)(N16ByteAlignedString *, uint64_t, void **))(*(void *)a2 + 72))(a2, v4, &v7);
  int v5 = *((_DWORD *)this + 86);
  uint64_t result = (v5 + 15) & 0xFFFFFFF0;
  if (result != v5)
  {
    unsigned int v7 = &unk_26C99C380;
    operator new[]();
  }
  return result;
}

void sub_218460B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t BlobBuilder::serializeHmmArray(BlobBuilder *this, N16ByteAlignedString *a2)
{
  int v4 = *((_DWORD *)a2 + 2);
  unsigned int v16 = *((_DWORD *)this + 44);
  LODWORD(v17) = 4;
  (*(void (**)(N16ByteAlignedString *, unsigned int *, void **))(*(void *)a2 + 72))(a2, &v16, &v17);
  if (v16)
  {
    for (unint64_t i = 0; i < v16; ++i)
    {
      if (*((int *)this + 17) <= -2)
      {
        unsigned int v18 = 0;
        if (i < *((unsigned int *)this + 32)) {
          unsigned int v18 = *(_DWORD *)(*((void *)this + 15) + 4 * i);
        }
        LODWORD(v17) = 4;
        (*(void (**)(N16ByteAlignedString *, unsigned int *, void **))(*(void *)a2 + 72))(a2, &v18, &v17);
        unsigned int v18 = 0;
        if (i < *((unsigned int *)this + 38)) {
          unsigned int v18 = *(_DWORD *)(*((void *)this + 18) + 4 * i);
        }
        LODWORD(v17) = 4;
        (*(void (**)(N16ByteAlignedString *, unsigned int *, void **))(*(void *)a2 + 72))(a2, &v18, &v17);
      }
      uint64_t v6 = *((void *)this + 35) + 48 * *(unsigned int *)(*((void *)this + 21) + 4 * i);
      unsigned int v18 = 0;
      unsigned int v18 = *(_DWORD *)(v6 + 16);
      LODWORD(v17) = 4;
      (*(void (**)(N16ByteAlignedString *, unsigned int *, void **))(*(void *)a2 + 72))(a2, &v18, &v17);
      if (v18)
      {
        uint64_t v7 = 0;
        for (unint64_t j = 0; j < v18; ++j)
        {
          float v15 = 0.0;
          int v9 = (float *)(*(void *)(v6 + 8) + v7);
          float v10 = *v9;
          float v14 = 0.0;
          float v15 = v10;
          float v11 = 1.0 / (1.0 - v9[1]);
          float v14 = v11;
          LODWORD(v17) = 4;
          (*(void (**)(N16ByteAlignedString *, float *, void **))(*(void *)a2 + 72))(a2, &v15, &v17);
          LODWORD(v17) = 4;
          (*(void (**)(N16ByteAlignedString *, float *, void **))(*(void *)a2 + 72))(a2, &v14, &v17);
          v7 += 8;
        }
      }
    }
  }
  int v12 = *((_DWORD *)a2 + 2) - v4;
  if (((v12 + 15) & 0xFFFFFFF0) != v12)
  {
    uint64_t v17 = &unk_26C99C380;
    operator new[]();
  }
  return (v12 + 15) & 0xFFFFFFF0;
}

void sub_218460EDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void BlobBuilder::serializeHeap(BlobBuilder *this, N16ByteAlignedString *a2)
{
  if (40960 - *((_DWORD *)a2 + 2) > 0) {
    operator new[]();
  }
  Error::chuck((Error *)"BlobBuilder: Cannot allocate heap", (const char *)a2);
}

void sub_218461000(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void BlobBuilder::insertChecksum(BlobBuilder *this, N16ByteAlignedString *a2)
{
  unsigned int v2 = *((_DWORD *)a2 + 2);
  if (v2 < 0x30) {
    goto LABEL_31;
  }
  int v3 = (_DWORD *)*((void *)a2 + 2);
  unsigned int v4 = v3[9] + v3[8];
  if (v4 > v2) {
    goto LABEL_31;
  }
  unsigned int v5 = v3[3];
  if (v5 > v2) {
    goto LABEL_31;
  }
  if (v5 >= 0x40 && v3[12] == 1919706177)
  {
    int v6 = 0;
    int v7 = v3[13];
    unint64_t v8 = 52;
    unsigned int v9 = 52;
  }
  else
  {
    int v7 = 0;
    int v6 = -1;
    if (!v4)
    {
      unsigned int v13 = 1;
      unsigned int v9 = 0;
      unsigned int v12 = 0;
      goto LABEL_16;
    }
    unint64_t v8 = (v3[9] + v3[8]);
    unsigned int v9 = v3[9] + v3[8];
  }
  unsigned int v10 = 0;
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  unsigned int v13 = 1;
  while (1)
  {
    while (1)
    {
      v13 += *((unsigned __int8 *)v3 + v11);
      v12 += v13;
      unint64_t v14 = v11 + 1;
      if (v10 > 0xFFE || v14 >= v8) {
        break;
      }
      ++v10;
      ++v11;
    }
    v13 %= 0xFFF1u;
    v12 %= 0xFFF1u;
    if (v14 >= v8) {
      break;
    }
    unsigned int v10 = 0;
    ++v11;
  }
LABEL_16:
  if (v9 < v4)
  {
    unsigned int v12 = (v12 + 4 * v13) % 0xFFF1;
    uint64_t v15 = v9 + 4;
    unint64_t v16 = v4 - v15;
    if (v16)
    {
      unsigned int v21 = 0;
      uint64_t v22 = 0;
      int v23 = (char *)v3 + v15;
      while (1)
      {
        while (1)
        {
          v13 += v23[v22];
          v12 += v13;
          unint64_t v24 = v22 + 1;
          if (v21 > 0xFFE || v24 >= v16) {
            break;
          }
          ++v21;
          ++v22;
        }
        v13 %= 0xFFF1u;
        v12 %= 0xFFF1u;
        if (v24 >= v16) {
          break;
        }
        unsigned int v21 = 0;
        ++v22;
      }
    }
  }
  int v17 = v13 | (v12 << 16);
  if (v6) {
LABEL_31:
  }
    Error::chuck((Error *)"BlobBuilder: failed to compute checksum", (const char *)a2);
  if (v7) {
    Error::chuck((Error *)"BlobBuilder: checksum already set", (const char *)a2);
  }
  if (v2 <= 0x34)
  {
    uint64_t v25 = v2 - 1;
    uint64_t v26 = 52;
    goto LABEL_37;
  }
  *((unsigned char *)v3 + 52) = v17;
  unsigned int v18 = *((_DWORD *)a2 + 2);
  if (v18 <= 0x35)
  {
    uint64_t v25 = v18 - 1;
    uint64_t v26 = 53;
    goto LABEL_37;
  }
  *(unsigned char *)(*((void *)a2 + 2) + 53) = BYTE1(v17);
  unsigned int v19 = *((_DWORD *)a2 + 2);
  if (v19 <= 0x36)
  {
    uint64_t v25 = v19 - 1;
    uint64_t v26 = 54;
    goto LABEL_37;
  }
  *(unsigned char *)(*((void *)a2 + 2) + 54) = BYTE2(v17);
  unsigned int v20 = *((_DWORD *)a2 + 2);
  if (v20 <= 0x37)
  {
    uint64_t v25 = v20 - 1;
    uint64_t v26 = 55;
LABEL_37:
    Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, v26, v25);
  }
  *(unsigned char *)(*((void *)a2 + 2) + 55) = HIBYTE(v17);
}

uint64_t NArray<unsigned char>::resize(uint64_t a1, unsigned int *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  uint64_t result = *a2;
  if (v3 != result)
  {
    *(_DWORD *)(a1 + 16) = result;
    operator new[]();
  }
  return result;
}

uint64_t NArray<unsigned char>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C8077774924);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    unint64_t v8 = 0;
    do
    {
      *(unsigned char *)(*(void *)(result + 8) + v8) = *(unsigned char *)(a2 + v8);
      ++v8;
    }
    while (v8 < *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t NArray<unsigned char>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8077774924);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      unint64_t v7 = 0;
      do
      {
        *(unsigned char *)(*(void *)(result + 8) + v7) = *(unsigned char *)(*(void *)(a2 + 8) + v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(result + 16));
    }
  }
  return result;
}

void NArray<unsigned char>::~NArray(void *a1)
{
  *a1 = &unk_26C99C380;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<unsigned char>::~NArray(void *a1)
{
  *a1 = &unk_26C99C380;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NArray<NString>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

void *NArray<NString>::~NArray(void *a1)
{
  *a1 = &unk_26C99C0A8;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 24 * v3;
      do
      {
        *(void *)(v2 + v4 - 24) = &unk_26C99C5B0;
        uint64_t v5 = *(void *)(v2 + v4 - 8);
        if (v5) {
          MEMORY[0x21D46B220](v5, 0x1000C8077774924);
        }
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1091C800F2A5985);
  }
  return a1;
}

uint64_t NArray<NString>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = 24 * v9;
        do
        {
          *(void *)(v7 + v10 - 24) = &unk_26C99C5B0;
          uint64_t v11 = *(void *)(v7 + v10 - 8);
          if (v11) {
            MEMORY[0x21D46B220](v11, 0x1000C8077774924);
          }
          v10 -= 24;
        }
        while (v10);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x1091C800F2A5985);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v4 + 8) + v12) + 32))(*(void *)(v4 + 8) + v12, a2 + v12);
      ++v13;
      v12 += 24;
    }
    while (v13 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NString>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 24 * v7;
          do
          {
            *(void *)(v6 + v8 - 24) = &unk_26C99C5B0;
            uint64_t v9 = *(void *)(v6 + v8 - 8);
            if (v9) {
              MEMORY[0x21D46B220](v9, 0x1000C8077774924);
            }
            v8 -= 24;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x1091C800F2A5985);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v10 = 0;
      unint64_t v11 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 8) + v10) + 32))(*(void *)(a1 + 8) + v10, *(void *)(a2 + 8) + v10);
        ++v11;
        v10 += 24;
      }
      while (v11 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void NArray<NString>::~NArray(void *a1)
{
  *a1 = &unk_26C99C0A8;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 24 * v2;
      do
      {
        *(void *)(v1 + v3 - 24) = &unk_26C99C5B0;
        uint64_t v4 = *(void *)(v1 + v3 - 8);
        if (v4) {
          MEMORY[0x21D46B220](v4, 0x1000C8077774924);
        }
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1091C800F2A5985);
  }

  JUMPOUT(0x21D46B240);
}

void BlobBuilder::sanityCheckAcAnalOption(BlobBuilder *this, const NConfigSection *a2)
{
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 10;
  operator new[]();
}

void sub_218462DA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void BlobBuilder::analysisTargetKind()
{
  v0 = &unk_26C99C5B0;
  int v1 = 10;
  operator new[]();
}

void sub_21846331C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22) {
    MEMORY[0x21D46B220](a22, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void NConfig::~NConfig(NConfig *this)
{
  *(void *)this = &unk_26C99BD10;
  *((void *)this + 1) = &unk_26C99BEE8;
  uint64_t v1 = *((void *)this + 2);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A6A0;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::deleteElement(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void NLinkedList<NMap<NString,NConfigSection>::HashItem>::newElement()
{
}

void sub_2184636DC(_Unwind_Exception *a1)
{
  v1[5] = v3;
  uint64_t v5 = v1[7];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  v1[2] = v2;
  uint64_t v6 = v1[4];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  MEMORY[0x21D46B240](v1, 0x10B1C402CAC5B7ELL);
  _Unwind_Resume(a1);
}

uint64_t NMap<NString,NString>::NMap(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C99BD30;
  *(void *)(a1 + 8) = &unk_26C99BE40;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  if (a1 != a2)
  {
    *(void *)(a1 + 28) = *(void *)(a2 + 28);
    NArray<NLinkedList<NMap<NString,NString>::HashItem>>::operator=(a1 + 8, a2 + 8);
  }
  return a1;
}

void sub_2184637E0(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 8) = &unk_26C99BF20;
  uint64_t v3 = *(void *)(v1 + 16);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 - 8);
    if (v4)
    {
      uint64_t v5 = v3 + 32 * v4;
      do
      {
        uint64_t v6 = v5 - 32;
        for (*(void *)(v5 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v5 - 32) + 72))(v5 - 32))
        {
          uint64_t v7 = *(void *)(v5 - 24);
          if (!v7) {
            break;
          }
          *(void *)(v5 - 24) = *(void *)(v7 + 8);
        }
        *(void *)(v5 - 16) = 0;
        *(_DWORD *)(v5 - 8) = 0;
        v5 -= 32;
      }
      while (v6 != v3);
    }
    MEMORY[0x21D46B220](v3 - 16, 0x10A1C80F4A7E088);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NArray<NLinkedList<NMap<NString,NString>::HashItem>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = v6 + 32 * v7;
          do
          {
            uint64_t v9 = v8 - 32;
            for (*(void *)(v8 - 32) = &unk_26C99A700;
                  ;
                  (*(void (**)(uint64_t))(*(void *)(v8 - 32) + 72))(v8 - 32))
            {
              uint64_t v10 = *(void *)(v8 - 24);
              if (!v10) {
                break;
              }
              *(void *)(v8 - 24) = *(void *)(v10 + 8);
            }
            *(void *)(v8 - 16) = 0;
            *(_DWORD *)(v8 - 8) = 0;
            v8 -= 32;
          }
          while (v9 != v6);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x10A1C80F4A7E088);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 8) + v11) + 24))(*(void *)(a1 + 8) + v11, *(void *)(a2 + 8) + v11);
        ++v12;
        v11 += 32;
      }
      while (v12 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::deleteElement(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void NLinkedList<NMap<NString,NString>::HashItem>::newElement()
{
}

void sub_218463BB8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 16) = v2;
  uint64_t v4 = *(void *)(v1 + 32);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  MEMORY[0x21D46B240](v1, 0x10B1C40C03CEF6FLL);
  _Unwind_Resume(a1);
}

void NLinkedList<NMap<NString,NString>::HashItem>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C8F0;
  a1[5] = &unk_26C99C5B0;
  uint64_t v2 = a1[7];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  a1[2] = &unk_26C99C5B0;
  uint64_t v3 = a1[4];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NLinkedList<NMap<NString,NString>::HashItem>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C8F0;
  a1[5] = &unk_26C99C5B0;
  uint64_t v2 = a1[7];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  a1[2] = &unk_26C99C5B0;
  uint64_t v3 = a1[4];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::reset(uint64_t result)
{
  uint64_t v1 = result;
  for (uint64_t i = *(void *)(result + 8); i; uint64_t i = *(void *)(v1 + 8))
  {
    *(void *)(v1 + 8) = *(void *)(i + 8);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 72))(v1);
  }
  *(void *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)a2;
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4) {
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  }
  if (!v3)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 32);
    return v6();
  }
  if (v3 == v4)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 40);
    return v6();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  for (int i = v3 - 1; i; --i)
    uint64_t v8 = *(void *)(v8 + 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 64))(a1, a3);
  *(void *)(result + 8) = *(void *)(v8 + 8);
  *(void *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::append(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = (uint64_t *)(a1 + 16);
  if (*(void *)(a1 + 8))
  {
    unsigned int v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    unsigned int v4 = (uint64_t *)(a1 + 16);
    uint64_t v3 = (uint64_t *)(a1 + 8);
  }
  *unsigned int v4 = result;
  *uint64_t v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::prepend(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    *(void *)(result + 8) = v3;
  }
  else {
    *(void *)(a1 + 16) = result;
  }
  *(void *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    for (uint64_t i = *(void *)(a2 + 8); i; uint64_t i = *(void *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

void NLinkedList<NMap<NString,NString>::HashItem>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A700;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;

  JUMPOUT(0x21D46B240);
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A700;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t NLinkedList<NMap<NString,NString>::HashItem>::removeElement(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v4 = (void *)(a1 + 8);
  if (v3 == v5)
  {
    *unsigned int v4 = 0;
    *(void *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *unsigned int v4 = *(void *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      uint64_t v7 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v7 + 8) = 0;
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      uint64_t v6 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v6 + 8) = *(void *)(a2 + 8);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,NString>::HashItem>>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,NString>::HashItem>>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = v7 + 32 * v9;
        do
        {
          uint64_t v11 = v10 - 32;
          for (*(void *)(v10 - 32) = &unk_26C99A700;
                ;
                (*(void (**)(uint64_t))(*(void *)(v10 - 32) + 72))(v10 - 32))
          {
            uint64_t v12 = *(void *)(v10 - 24);
            if (!v12) {
              break;
            }
            *(void *)(v10 - 24) = *(void *)(v12 + 8);
          }
          *(void *)(v10 - 16) = 0;
          *(_DWORD *)(v10 - 8) = 0;
          v10 -= 32;
        }
        while (v11 != v7);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x10A1C80F4A7E088);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v4 + 8) + v13) + 24))(*(void *)(v4 + 8) + v13, a2 + v13);
      ++v14;
      v13 += 32;
    }
    while (v14 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

void NArray<NLinkedList<NMap<NString,NString>::HashItem>>::~NArray(void *a1)
{
  *a1 = &unk_26C99BF20;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NLinkedList<NMap<NString,NString>::HashItem>>::~NArray(void *a1)
{
  *a1 = &unk_26C99BF20;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NHash<NMap<NString,NString>::HashItem>::~NHash(void *a1)
{
  *a1 = &unk_26C99BF20;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NHash<NMap<NString,NString>::HashItem>::~NHash(void *a1)
{
  *a1 = &unk_26C99BF20;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NMap<NString,NString>::~NMap(void *a1)
{
  *a1 = &unk_26C99BD30;
  a1[1] = &unk_26C99BF20;
  uint64_t v1 = a1[2];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NMap<NString,NString>::~NMap(void *a1)
{
  *a1 = &unk_26C99BD30;
  a1[1] = &unk_26C99BF20;
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NLinkedList<NMap<NString,NConfigSection>::HashItem>::NElement::~NElement(void *a1)
{
  NLinkedList<NMap<NString,NConfigSection>::HashItem>::NElement::~NElement(a1);

  JUMPOUT(0x21D46B240);
}

void *NLinkedList<NMap<NString,NConfigSection>::HashItem>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C8D0;
  a1[8] = &unk_26C99BD30;
  a1[9] = &unk_26C99BF20;
  uint64_t v2 = a1[10];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  a1[5] = &unk_26C99C5B0;
  uint64_t v7 = a1[7];
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  a1[2] = &unk_26C99C5B0;
  uint64_t v8 = a1[4];
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::reset(uint64_t result)
{
  uint64_t v1 = result;
  for (uint64_t i = *(void *)(result + 8); i; uint64_t i = *(void *)(v1 + 8))
  {
    *(void *)(v1 + 8) = *(void *)(i + 8);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 72))(v1);
  }
  *(void *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)a2;
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4) {
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  }
  if (!v3)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 32);
    return v6();
  }
  if (v3 == v4)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 40);
    return v6();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  for (int i = v3 - 1; i; --i)
    uint64_t v8 = *(void *)(v8 + 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 64))(a1, a3);
  *(void *)(result + 8) = *(void *)(v8 + 8);
  *(void *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::append(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = (uint64_t *)(a1 + 16);
  if (*(void *)(a1 + 8))
  {
    unsigned int v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    unsigned int v4 = (uint64_t *)(a1 + 16);
    uint64_t v3 = (uint64_t *)(a1 + 8);
  }
  *unsigned int v4 = result;
  *uint64_t v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::prepend(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    *(void *)(result + 8) = v3;
  }
  else {
    *(void *)(a1 + 16) = result;
  }
  *(void *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    for (uint64_t i = *(void *)(a2 + 8); i; uint64_t i = *(void *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

void NLinkedList<NMap<NString,NConfigSection>::HashItem>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A6A0;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;

  JUMPOUT(0x21D46B240);
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A6A0;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t NLinkedList<NMap<NString,NConfigSection>::HashItem>::removeElement(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v4 = (void *)(a1 + 8);
  if (v3 == v5)
  {
    *unsigned int v4 = 0;
    *(void *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *unsigned int v4 = *(void *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      uint64_t v7 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v7 + 8) = 0;
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      uint64_t v6 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v6 + 8) = *(void *)(a2 + 8);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = v7 + 32 * v9;
        do
        {
          uint64_t v11 = v10 - 32;
          for (*(void *)(v10 - 32) = &unk_26C99A6A0;
                ;
                (*(void (**)(uint64_t))(*(void *)(v10 - 32) + 72))(v10 - 32))
          {
            uint64_t v12 = *(void *)(v10 - 24);
            if (!v12) {
              break;
            }
            *(void *)(v10 - 24) = *(void *)(v12 + 8);
          }
          *(void *)(v10 - 16) = 0;
          *(_DWORD *)(v10 - 8) = 0;
          v10 -= 32;
        }
        while (v11 != v7);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x10A1C80F4A7E088);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v4 + 8) + v13) + 24))(*(void *)(v4 + 8) + v13, a2 + v13);
      ++v14;
      v13 += 32;
    }
    while (v14 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = v6 + 32 * v7;
          do
          {
            uint64_t v9 = v8 - 32;
            for (*(void *)(v8 - 32) = &unk_26C99A6A0;
                  ;
                  (*(void (**)(uint64_t))(*(void *)(v8 - 32) + 72))(v8 - 32))
            {
              uint64_t v10 = *(void *)(v8 - 24);
              if (!v10) {
                break;
              }
              *(void *)(v8 - 24) = *(void *)(v10 + 8);
            }
            *(void *)(v8 - 16) = 0;
            *(_DWORD *)(v8 - 8) = 0;
            v8 -= 32;
          }
          while (v9 != v6);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x10A1C80F4A7E088);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 8) + v11) + 24))(*(void *)(a1 + 8) + v11, *(void *)(a2 + 8) + v11);
        ++v12;
        v11 += 32;
      }
      while (v12 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::~NArray(void *a1)
{
  *a1 = &unk_26C99BEE8;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A6A0;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::~NArray(void *a1)
{
  *a1 = &unk_26C99BEE8;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A6A0;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NMap<NString,NConfigSection>::~NMap(void *a1)
{
  *a1 = &unk_26C99BD10;
  a1[1] = &unk_26C99BEE8;
  uint64_t v1 = a1[2];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A6A0;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NMap<NString,NConfigSection>::~NMap(void *a1)
{
  *a1 = &unk_26C99BD10;
  a1[1] = &unk_26C99BEE8;
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A6A0;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

uint64_t NLinkedList<NString>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A640;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t NLinkedList<NString>::deleteElement(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void NLinkedList<NString>::newElement()
{
}

void sub_218465E80(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x10B1C403C52864DLL);
  _Unwind_Resume(a1);
}

void NLinkedList<NString>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C8B0;
  a1[2] = &unk_26C99C5B0;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NLinkedList<NString>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C8B0;
  a1[2] = &unk_26C99C5B0;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NLinkedList<NString>::reset(uint64_t result)
{
  uint64_t v1 = result;
  for (uint64_t i = *(void *)(result + 8); i; uint64_t i = *(void *)(v1 + 8))
  {
    *(void *)(v1 + 8) = *(void *)(i + 8);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 72))(v1);
  }
  *(void *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NString>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)a2;
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4) {
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  }
  if (!v3)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 32);
    return v6();
  }
  if (v3 == v4)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 40);
    return v6();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  for (int i = v3 - 1; i; --i)
    uint64_t v8 = *(void *)(v8 + 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 64))(a1, a3);
  *(void *)(result + 8) = *(void *)(v8 + 8);
  *(void *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NString>::append(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = (uint64_t *)(a1 + 16);
  if (*(void *)(a1 + 8))
  {
    unsigned int v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    unsigned int v4 = (uint64_t *)(a1 + 16);
    uint64_t v3 = (uint64_t *)(a1 + 8);
  }
  *unsigned int v4 = result;
  *uint64_t v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NString>::prepend(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    *(void *)(result + 8) = v3;
  }
  else {
    *(void *)(a1 + 16) = result;
  }
  *(void *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NString>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    for (uint64_t i = *(void *)(a2 + 8); i; uint64_t i = *(void *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

void NLinkedList<NString>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A640;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;

  JUMPOUT(0x21D46B240);
}

uint64_t NLinkedList<NString>::removeElement(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v4 = (void *)(a1 + 8);
  if (v3 == v5)
  {
    *unsigned int v4 = 0;
    *(void *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *unsigned int v4 = *(void *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      uint64_t v7 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v7 + 8) = 0;
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      uint64_t v6 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v6 + 8) = *(void *)(a2 + 8);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NArray<unsigned int>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<unsigned int>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C8052888210);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    unint64_t v8 = 0;
    uint64_t v9 = *(void *)(result + 8);
    do
    {
      *(_DWORD *)(v9 + 4 * v8) = *(_DWORD *)(a2 + 4 * v8);
      ++v8;
    }
    while (v8 < *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t NArray<unsigned int>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      unint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(result + 16));
    }
  }
  return result;
}

void NArray<unsigned int>::~NArray(void *a1)
{
  *a1 = &unk_26C99C3F0;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8052888210);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<unsigned int>::~NArray(void *a1)
{
  *a1 = &unk_26C99C3F0;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  return a1;
}

void NFrame::~NFrame(NFrame *this)
{
  *(void *)this = &unk_26C99C348;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8052888210);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99C348;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8052888210);
  }
}

double BlobBuilder::buildChecksumHeader(BlobBuilder *this)
{
  *(void *)&double result = 1919706177;
  *((_OWORD *)this + 3) = xmmword_21852DE30;
  return result;
}

uint64_t BlobBuilder::serializeConfigHeader(uint64_t a1, uint64_t a2)
{
  int v3 = 48;
  (*(void (**)(uint64_t, uint64_t, int *))(*(void *)a2 + 72))(a2, a1, &v3);
  return 48;
}

uint64_t BlobBuilder::serializeChecksumHeader(uint64_t a1, uint64_t a2)
{
  int v3 = 16;
  (*(void (**)(uint64_t, uint64_t, int *))(*(void *)a2 + 72))(a2, a1 + 48, &v3);
  return 16;
}

uint64_t BlobBuilder::getConfigHeaderSize(BlobBuilder *this)
{
  return 48;
}

uint64_t BlobBuilder::getChecksumHeaderSize(BlobBuilder *this)
{
  return 16;
}

uint64_t BlobBuilder::getDetectorConfigSize(BlobBuilder *this)
{
  return 48;
}

uint64_t BlobBuilder::getAcAnalConfigSize(BlobBuilder *this)
{
  return 80;
}

uint64_t BlobBuilder::getNormConfigSize(BlobBuilder *this)
{
  return 16;
}

uint64_t BlobBuilder::getActualDistributionSize(BlobBuilder *this)
{
  return *((unsigned int *)this + 86);
}

uint64_t BlobBuilder::getDistributionSize(BlobBuilder *this)
{
  return (*((_DWORD *)this + 86) + 15) & 0xFFFFFFF0;
}

uint64_t BlobBuilder::getActualHmmArraySize(BlobBuilder *this)
{
  uint64_t v1 = *((unsigned int *)this + 44);
  if (!v1) {
    return 4;
  }
  uint64_t v2 = *((void *)this + 21);
  uint64_t v3 = *((void *)this + 35);
  if (*((int *)this + 17) >= -1)
  {
    if (v1 == 1)
    {
      uint64_t v6 = 0;
      LODWORD(result) = 4;
    }
    else
    {
      int v14 = 0;
      uint64_t v6 = v1 & 0xFFFFFFFE;
      uint64_t v15 = (unsigned int *)(v2 + 4);
      int v16 = 4;
      uint64_t v17 = v6;
      do
      {
        v16 += 8 * *(_DWORD *)(v3 + 48 * *(v15 - 1) + 16) + 4;
        v14 += 8 * *(_DWORD *)(v3 + 48 * *v15 + 16) + 4;
        v15 += 2;
        v17 -= 2;
      }
      while (v17);
      uint64_t result = (v14 + v16);
      if (v6 == v1) {
        return result;
      }
    }
    uint64_t v18 = v1 - v6;
    unsigned int v19 = (unsigned int *)(v2 + 4 * v6);
    do
    {
      unsigned int v20 = *v19++;
      uint64_t result = (result + 8 * *(_DWORD *)(v3 + 48 * v20 + 16) + 4);
      --v18;
    }
    while (v18);
    return result;
  }
  if (v1 == 1)
  {
    uint64_t v4 = 0;
    LODWORD(result) = 4;
LABEL_11:
    uint64_t v11 = v1 - v4;
    unint64_t v12 = (unsigned int *)(v2 + 4 * v4);
    do
    {
      unsigned int v13 = *v12++;
      uint64_t result = (result + 8 * *(_DWORD *)(v3 + 48 * v13 + 16) + 12);
      --v11;
    }
    while (v11);
    return result;
  }
  int v7 = 0;
  uint64_t v4 = v1 & 0xFFFFFFFE;
  uint64_t v8 = (unsigned int *)(v2 + 4);
  int v9 = 4;
  uint64_t v10 = v4;
  do
  {
    v9 += 8 * *(_DWORD *)(v3 + 48 * *(v8 - 1) + 16) + 12;
    v7 += 8 * *(_DWORD *)(v3 + 48 * *v8 + 16) + 12;
    v8 += 2;
    v10 -= 2;
  }
  while (v10);
  uint64_t result = (v7 + v9);
  if (v4 != v1) {
    goto LABEL_11;
  }
  return result;
}

uint64_t BlobBuilder::getHmmArraySize(BlobBuilder *this)
{
  uint64_t v1 = *((unsigned int *)this + 44);
  if (!v1)
  {
    int v5 = 4;
    return (v5 + 15) & 0xFFFFFFF0;
  }
  uint64_t v2 = *((void *)this + 21);
  uint64_t v3 = *((void *)this + 35);
  if (*((int *)this + 17) >= -1)
  {
    if (v1 == 1)
    {
      uint64_t v6 = 0;
      int v5 = 4;
    }
    else
    {
      int v14 = 0;
      uint64_t v6 = v1 & 0xFFFFFFFE;
      uint64_t v15 = (unsigned int *)(v2 + 4);
      int v16 = 4;
      uint64_t v17 = v6;
      do
      {
        v16 += 8 * *(_DWORD *)(v3 + 48 * *(v15 - 1) + 16) + 4;
        v14 += 8 * *(_DWORD *)(v3 + 48 * *v15 + 16) + 4;
        v15 += 2;
        v17 -= 2;
      }
      while (v17);
      int v5 = v14 + v16;
      if (v6 == v1) {
        return (v5 + 15) & 0xFFFFFFF0;
      }
    }
    uint64_t v18 = v1 - v6;
    unsigned int v19 = (unsigned int *)(v2 + 4 * v6);
    do
    {
      unsigned int v20 = *v19++;
      v5 += 8 * *(_DWORD *)(v3 + 48 * v20 + 16) + 4;
      --v18;
    }
    while (v18);
    return (v5 + 15) & 0xFFFFFFF0;
  }
  if (v1 == 1)
  {
    uint64_t v4 = 0;
    int v5 = 4;
LABEL_11:
    uint64_t v11 = v1 - v4;
    unint64_t v12 = (unsigned int *)(v2 + 4 * v4);
    do
    {
      unsigned int v13 = *v12++;
      v5 += 8 * *(_DWORD *)(v3 + 48 * v13 + 16) + 12;
      --v11;
    }
    while (v11);
    return (v5 + 15) & 0xFFFFFFF0;
  }
  int v7 = 0;
  uint64_t v4 = v1 & 0xFFFFFFFE;
  uint64_t v8 = (unsigned int *)(v2 + 4);
  int v9 = 4;
  uint64_t v10 = v4;
  do
  {
    v9 += 8 * *(_DWORD *)(v3 + 48 * *(v8 - 1) + 16) + 12;
    v7 += 8 * *(_DWORD *)(v3 + 48 * *v8 + 16) + 12;
    v8 += 2;
    v10 -= 2;
  }
  while (v10);
  int v5 = v7 + v9;
  if (v4 != v1) {
    goto LABEL_11;
  }
  return (v5 + 15) & 0xFFFFFFF0;
}

float BlobBuilder::convertStrArrToFloatArr(uint64_t a1, uint64_t a2, void *a3)
{
  int v5 = (unsigned int *)(a2 + 16);
  (*(void (**)(void *, uint64_t))(*a3 + 32))(a3, a2 + 16);
  if (*(_DWORD *)(a2 + 16))
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = *(void *)(a2 + 8);
    do
    {
      uint64_t v11 = v10 + v8;
      if (!*(_DWORD *)(v10 + v8 + 8)
        || (unint64_t v12 = 0,
            strtod(*(const char **)(v11 + 16), &v12),
            uint64_t v10 = *(void *)(a2 + 8),
            v12 != (char *)(*(void *)(v11 + 16) + *(unsigned int *)(v11 + 8))))
      {
        Error::chuck((Error *)"BlobBuilder: unable to convert %s to float", v6, *(void *)(v10 + 24 * v9 + 16));
      }
      float result = atof(*(const char **)(v10 + v8 + 16));
      *(float *)(a3[1] + 4 * v9++) = result;
      v8 += 24;
    }
    while (v9 < *v5);
  }
  return result;
}

void BlobBuilder::serializePadding(BlobBuilder *this, int a2, N16ByteAlignedString *a3)
{
  if (a2) {
    operator new[]();
  }
}

void sub_218466E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NMemPool::getAlignedSize(NMemPool *this)
{
  unsigned int v1 = NMemPool::m_iAlignBytes - this % NMemPool::m_iAlignBytes;
  if (!(this % NMemPool::m_iAlignBytes)) {
    unsigned int v1 = 0;
  }
  return v1 + this;
}

void NMemPool::init(NMemPool *this, const char *a2, int a3)
{
  if (!this) {
    Error::chuck((Error *)"NMemPool::init - no memory provided", a2);
  }
  if (!a3) {
    Error::chuck((Error *)"NMemPool::init - byte alignment should be >1", a2);
  }
  if (!NMemPool::m_bLocked) {
    Error::chuck((Error *)"NMemPool::init - second call to init() before lock()", a2);
  }
  if (a2 >> 30) {
    Error::chuck((Error *)"NMemPool::init - pool size too large", a2);
  }
  NMemPool::m_pData = (uint64_t)this;
  NMemPool::m_iSize = (int)a2;
  NMemPool::m_iAlignBytes = a3;
  NMemPool::m_bLocked = 0;
  NMemPool::m_iPos = 0;

  bzero(this, a2);
}

uint64_t NMemPool::getMem(NMemPool *this, const char *a2)
{
  if (NMemPool::m_bLocked) {
    Error::chuck((Error *)"NMemPool::getMem - memory locked", a2);
  }
  if (this % NMemPool::m_iAlignBytes) {
    unsigned int v2 = NMemPool::m_iAlignBytes - this % NMemPool::m_iAlignBytes;
  }
  else {
    unsigned int v2 = 0;
  }
  if (this >> 30
    || (uint64_t v3 = NMemPool::m_iPos, v4 = NMemPool::m_iPos + this + v2, v4 > NMemPool::m_iSize))
  {
    Error::chuck((Error *)"NMemPool::getMem - memory bound violation", a2);
  }
  NMemPool::m_iPos = v4;
  return NMemPool::m_pData + v3;
}

uint64_t NMemPool::lock(uint64_t this)
{
  NMemPool::m_bLocked = this;
  return this;
}

uint64_t NMemPool::isLocked(NMemPool *this)
{
  return NMemPool::m_bLocked;
}

uint64_t NMemPool::report(NMemPool *this, const char *a2)
{
  return Error::warning((Error *)"MemPool::report - size: %d align: %d:  pos: %d  locked: %d", a2, NMemPool::m_iSize, NMemPool::m_iAlignBytes, NMemPool::m_iPos, NMemPool::m_bLocked);
}

uint64_t _AFLanguageDidChangeCallback(uint64_t a1, void *a2)
{
  return [a2 _didReceiveLanguageCodeUpdate];
}

void sub_218467CE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21)
{
  objc_destroyWeak(v23);
  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  objc_destroyWeak(v21);
  objc_destroyWeak(&a21);
  _Unwind_Resume(a1);
}

void TSHMMDetector::~TSHMMDetector(TSHMMDetector *this)
{
  TSHMMDetector::~TSHMMDetector(this);

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  *(void *)this = &unk_26C99AAA0;
  unsigned int v2 = *((void *)this + 1);
  if (v2)
  {
    if (!*((void *)this + 3)
      || ((*(void (**)(uint64_t))(*(void *)v2 + 152))(v2), (unsigned int v2 = *((void *)this + 1)) != 0))
    {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 40) = &unk_26C99C2D8;
  unsigned int v4 = *((void *)this + 41);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  *((void *)this + 37) = &unk_26C99C000;
  int v5 = *((void *)this + 38);
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 - 8);
    if (v6)
    {
      int v7 = 48 * v6;
      uint64_t v8 = v5 - 24;
      do
      {
        unint64_t v9 = v8 + v7;
        *(void *)(v8 + v7) = &unk_26C99C3F0;
        uint64_t v10 = *(void *)(v8 + v7 + 8);
        if (v10) {
          MEMORY[0x21D46B220](v10, 0x1000C8052888210);
        }
        *(void *)(v9 - 24) = &unk_26C99C348;
        uint64_t v11 = *(void *)(v9 - 16);
        if (v11) {
          MEMORY[0x21D46B220](v11, 0x1000C8052888210);
        }
        v7 -= 48;
      }
      while (v7);
    }
    MEMORY[0x21D46B220](v5 - 16, 0x1090C80405A4B77);
  }
  *((void *)this + 34) = &unk_26C99C348;
  unint64_t v12 = *((void *)this + 35);
  if (v12) {
    MEMORY[0x21D46B220](v12, 0x1000C8052888210);
  }
  *((void *)this + 31) = &unk_26C99C348;
  unsigned int v13 = *((void *)this + 32);
  if (v13) {
    MEMORY[0x21D46B220](v13, 0x1000C8052888210);
  }
  *((void *)this + 28) = &unk_26C99C348;
  int v14 = *((void *)this + 29);
  if (v14) {
    MEMORY[0x21D46B220](v14, 0x1000C8052888210);
  }
  NArray<NLRHMMModel>::~NArray((void *)this + 20);
  *((void *)this + 14) = &unk_26C99C268;
  uint64_t v15 = *((void *)this + 15);
  if (v15)
  {
    int v16 = *(void *)(v15 - 8);
    if (v16)
    {
      uint64_t v17 = 24 * v16;
      do
      {
        *(void *)(v15 + v17 - 24) = &unk_26C99C2D8;
        uint64_t v18 = *(void *)(v15 + v17 - 16);
        if (v18) {
          MEMORY[0x21D46B220](v18, 0x1000C8077774924);
        }
        v17 -= 24;
      }
      while (v17);
    }
    MEMORY[0x21D46B220](v15 - 16, 0x1091C80FBD4B0D6);
  }
  *((void *)this + 10) = &unk_26C99C348;
  unsigned int v19 = *((void *)this + 11);
  if (v19) {
    MEMORY[0x21D46B220](v19, 0x1000C8052888210);
  }
}

void *NArray<NLRHMMModel>::~NArray(void *a1)
{
  *a1 = &unk_26C99BEB0;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 88 * v3;
      uint64_t v5 = v2 - 32;
      do
      {
        uint64_t v6 = v5 + v4;
        *(void *)(v5 + v4) = &unk_26C99C3F0;
        uint64_t v7 = *(void *)(v5 + v4 + 8);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        *(void *)(v6 - 24) = &unk_26C99C348;
        uint64_t v8 = *(void *)(v6 - 16);
        if (v8) {
          MEMORY[0x21D46B220](v8, 0x1000C8052888210);
        }
        *(void *)(v5 + v4 - 48) = &unk_26C99C348;
        uint64_t v9 = *(void *)(v5 + v4 - 40);
        if (v9) {
          MEMORY[0x21D46B220](v9, 0x1000C8052888210);
        }
        v4 -= 88;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1090C806998C76BLL);
  }
  return a1;
}

uint64_t NArray<NArray<BOOL>>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<NArray<BOOL>>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = 24 * v9;
        do
        {
          *(void *)(v7 + v10 - 24) = &unk_26C99C2D8;
          uint64_t v11 = *(void *)(v7 + v10 - 16);
          if (v11) {
            MEMORY[0x21D46B220](v11, 0x1000C8077774924);
          }
          v10 -= 24;
        }
        while (v10);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x1091C80FBD4B0D6);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    do
    {
      float result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v4 + 8) + v12) + 16))(*(void *)(v4 + 8) + v12, a2 + v12);
      ++v13;
      v12 += 24;
    }
    while (v13 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NArray<BOOL>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 24 * v7;
          do
          {
            *(void *)(v6 + v8 - 24) = &unk_26C99C2D8;
            uint64_t v9 = *(void *)(v6 + v8 - 16);
            if (v9) {
              MEMORY[0x21D46B220](v9, 0x1000C8077774924);
            }
            v8 -= 24;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x1091C80FBD4B0D6);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v10 = 0;
      unint64_t v11 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 8) + v10) + 16))(*(void *)(a1 + 8) + v10, *(void *)(a2 + 8) + v10);
        ++v11;
        v10 += 24;
      }
      while (v11 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void NArray<NArray<BOOL>>::~NArray(void *a1)
{
  *a1 = &unk_26C99C268;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 24 * v2;
      do
      {
        *(void *)(v1 + v3 - 24) = &unk_26C99C2D8;
        uint64_t v4 = *(void *)(v1 + v3 - 16);
        if (v4) {
          MEMORY[0x21D46B220](v4, 0x1000C8077774924);
        }
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1091C80FBD4B0D6);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NArray<BOOL>>::~NArray(void *a1)
{
  *a1 = &unk_26C99C268;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 24 * v3;
      do
      {
        *(void *)(v2 + v4 - 24) = &unk_26C99C2D8;
        uint64_t v5 = *(void *)(v2 + v4 - 16);
        if (v5) {
          MEMORY[0x21D46B220](v5, 0x1000C8077774924);
        }
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1091C80FBD4B0D6);
  }
  return a1;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *a1 = &unk_26C99C268;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 24 * v3;
      do
      {
        *(void *)(v2 + v4 - 24) = &unk_26C99C2D8;
        uint64_t v5 = *(void *)(v2 + v4 - 16);
        if (v5) {
          MEMORY[0x21D46B220](v5, 0x1000C8077774924);
        }
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1091C80FBD4B0D6);
  }
  return a1;
}

uint64_t NArray<NLRHMMModel>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NLRHMMModel::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (_DWORD *)result;
  *(_DWORD *)float result = *(_DWORD *)a2;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 24);
    int v5 = *(_DWORD *)(a2 + 24);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 16);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 24);
      }
      v3[6] = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 16);
      uint64_t v9 = *(void *)(result + 16);
      uint64_t v10 = v4;
      if (v4 < 8) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFF8;
      unint64_t v11 = (_OWORD *)(v9 + 16);
      uint64_t v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFF8;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *unint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 4 * v7;
        uint64_t v17 = (_DWORD *)(v9 + v16);
        uint64_t v18 = (int *)(v8 + v16);
        do
        {
          int v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
    unsigned int v20 = *(_DWORD *)(result + 48);
    int v21 = *(_DWORD *)(a2 + 48);
    if (v20 != v21)
    {
      uint64_t v22 = *(void *)(result + 40);
      if (v22)
      {
        MEMORY[0x21D46B220](v22, 0x1000C8052888210);
        int v21 = *(_DWORD *)(a2 + 48);
      }
      v3[12] = v21;
      operator new[]();
    }
    if (v20)
    {
      uint64_t v23 = 0;
      uint64_t v24 = *(void *)(a2 + 40);
      uint64_t v25 = *(void *)(result + 40);
      uint64_t v26 = v20;
      if (v20 < 8) {
        goto LABEL_24;
      }
      if ((unint64_t)(v25 - v24) < 0x20) {
        goto LABEL_24;
      }
      uint64_t v23 = v20 & 0xFFFFFFF8;
      uint64_t v27 = (_OWORD *)(v25 + 16);
      int v28 = (long long *)(v24 + 16);
      uint64_t v29 = v26 & 0xFFFFFFF8;
      do
      {
        long long v30 = *v28;
        *(v27 - 1) = *(v28 - 1);
        *uint64_t v27 = v30;
        v27 += 2;
        v28 += 2;
        v29 -= 8;
      }
      while (v29);
      if (v23 != v26)
      {
LABEL_24:
        uint64_t v31 = v26 - v23;
        uint64_t v32 = 4 * v23;
        char v33 = (_DWORD *)(v25 + v32);
        int v34 = (int *)(v24 + v32);
        do
        {
          int v35 = *v34++;
          *v33++ = v35;
          --v31;
        }
        while (v31);
      }
    }
    int v36 = *(_DWORD *)(result + 72);
    int v37 = *(_DWORD *)(a2 + 72);
    if (v36 != v37)
    {
      uint64_t v38 = *(void *)(result + 64);
      if (v38)
      {
        MEMORY[0x21D46B220](v38, 0x1000C8052888210);
        int v37 = *(_DWORD *)(a2 + 72);
      }
      v3[18] = v37;
      operator new[]();
    }
    if (v36)
    {
      unint64_t v39 = 0;
      uint64_t v40 = *(void *)(a2 + 64);
      uint64_t v41 = *(void *)(result + 64);
      do
      {
        *(_DWORD *)(v41 + 4 * v39) = *(_DWORD *)(v40 + 4 * v39);
        ++v39;
      }
      while (v39 < *(unsigned int *)(result + 72));
    }
  }
  *(unsigned char *)(result + 80) = *(unsigned char *)(a2 + 80);
  return result;
}

uint64_t NArray<NLRHMMModel>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = 88 * v9;
        uint64_t v11 = v7 - 32;
        do
        {
          uint64_t v12 = v11 + v10;
          *(void *)(v11 + v10) = &unk_26C99C3F0;
          uint64_t v13 = *(void *)(v11 + v10 + 8);
          if (v13) {
            MEMORY[0x21D46B220](v13, 0x1000C8052888210);
          }
          *(void *)(v12 - 24) = &unk_26C99C348;
          uint64_t v14 = *(void *)(v12 - 16);
          if (v14) {
            MEMORY[0x21D46B220](v14, 0x1000C8052888210);
          }
          *(void *)(v11 + v10 - 48) = &unk_26C99C348;
          uint64_t v15 = *(void *)(v11 + v10 - 40);
          if (v15) {
            MEMORY[0x21D46B220](v15, 0x1000C8052888210);
          }
          v10 -= 88;
        }
        while (v10);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x1090C806998C76BLL);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    do
    {
      float result = NLRHMMModel::operator=(*(void *)(v4 + 8) + v16, a2 + v16);
      ++v17;
      v16 += 88;
    }
    while (v17 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NLRHMMModel>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 88 * v7;
          uint64_t v9 = v6 - 32;
          do
          {
            uint64_t v10 = v9 + v8;
            *(void *)(v9 + v8) = &unk_26C99C3F0;
            uint64_t v11 = *(void *)(v9 + v8 + 8);
            if (v11) {
              MEMORY[0x21D46B220](v11, 0x1000C8052888210);
            }
            *(void *)(v10 - 24) = &unk_26C99C348;
            uint64_t v12 = *(void *)(v10 - 16);
            if (v12) {
              MEMORY[0x21D46B220](v12, 0x1000C8052888210);
            }
            *(void *)(v9 + v8 - 48) = &unk_26C99C348;
            uint64_t v13 = *(void *)(v9 + v8 - 40);
            if (v13) {
              MEMORY[0x21D46B220](v13, 0x1000C8052888210);
            }
            v8 -= 88;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x1090C806998C76BLL);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v14 = 0;
      unint64_t v15 = 0;
      do
      {
        NLRHMMModel::operator=(*(void *)(a1 + 8) + v14, *(void *)(a2 + 8) + v14);
        ++v15;
        v14 += 88;
      }
      while (v15 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void NArray<NLRHMMModel>::~NArray(void *a1)
{
  NArray<NLRHMMModel>::~NArray(a1);

  JUMPOUT(0x21D46B240);
}

uint64_t NArray<NLRHMMStateTokens>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NLRHMMStateTokens::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      uint64_t v10 = v4;
      if (v4 < 8) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFF8;
      uint64_t v11 = (_OWORD *)(v9 + 16);
      uint64_t v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFF8;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *uint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 4 * v7;
        unint64_t v17 = (_DWORD *)(v9 + v16);
        uint64_t v18 = (int *)(v8 + v16);
        do
        {
          int v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
    int v20 = *(_DWORD *)(result + 40);
    int v21 = *(_DWORD *)(a2 + 40);
    if (v20 != v21)
    {
      uint64_t v22 = *(void *)(result + 32);
      if (v22)
      {
        MEMORY[0x21D46B220](v22, 0x1000C8052888210);
        int v21 = *(_DWORD *)(a2 + 40);
      }
      *(_DWORD *)(v2 + 40) = v21;
      operator new[]();
    }
    if (v20)
    {
      unint64_t v23 = 0;
      uint64_t v24 = *(void *)(a2 + 32);
      uint64_t v25 = *(void *)(result + 32);
      do
      {
        *(_DWORD *)(v25 + 4 * v23) = *(_DWORD *)(v24 + 4 * v23);
        ++v23;
      }
      while (v23 < *(unsigned int *)(result + 40));
    }
  }
  return result;
}

uint64_t NArray<NLRHMMStateTokens>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = 48 * v9;
        uint64_t v11 = v7 - 24;
        do
        {
          uint64_t v12 = v11 + v10;
          *(void *)(v11 + v10) = &unk_26C99C3F0;
          uint64_t v13 = *(void *)(v11 + v10 + 8);
          if (v13) {
            MEMORY[0x21D46B220](v13, 0x1000C8052888210);
          }
          *(void *)(v12 - 24) = &unk_26C99C348;
          uint64_t v14 = *(void *)(v12 - 16);
          if (v14) {
            MEMORY[0x21D46B220](v14, 0x1000C8052888210);
          }
          v10 -= 48;
        }
        while (v10);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x1090C80405A4B77);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    do
    {
      float result = NLRHMMStateTokens::operator=(*(void *)(v4 + 8) + v15, a2 + v15);
      ++v16;
      v15 += 48;
    }
    while (v16 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NLRHMMStateTokens>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 48 * v7;
          uint64_t v9 = v6 - 24;
          do
          {
            uint64_t v10 = v9 + v8;
            *(void *)(v9 + v8) = &unk_26C99C3F0;
            uint64_t v11 = *(void *)(v9 + v8 + 8);
            if (v11) {
              MEMORY[0x21D46B220](v11, 0x1000C8052888210);
            }
            *(void *)(v10 - 24) = &unk_26C99C348;
            uint64_t v12 = *(void *)(v10 - 16);
            if (v12) {
              MEMORY[0x21D46B220](v12, 0x1000C8052888210);
            }
            v8 -= 48;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x1090C80405A4B77);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      do
      {
        NLRHMMStateTokens::operator=(*(void *)(a1 + 8) + v13, *(void *)(a2 + 8) + v13);
        ++v14;
        v13 += 48;
      }
      while (v14 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void NArray<NLRHMMStateTokens>::~NArray(void *a1)
{
  *a1 = &unk_26C99C000;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 48 * v2;
      uint64_t v4 = v1 - 24;
      do
      {
        uint64_t v5 = v4 + v3;
        *(void *)(v4 + v3) = &unk_26C99C3F0;
        uint64_t v6 = *(void *)(v4 + v3 + 8);
        if (v6) {
          MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        }
        *(void *)(v5 - 24) = &unk_26C99C348;
        uint64_t v7 = *(void *)(v5 - 16);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        v3 -= 48;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1090C80405A4B77);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NLRHMMStateTokens>::~NArray(void *a1)
{
  *a1 = &unk_26C99C000;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 48 * v3;
      uint64_t v5 = v2 - 24;
      do
      {
        uint64_t v6 = v5 + v4;
        *(void *)(v5 + v4) = &unk_26C99C3F0;
        uint64_t v7 = *(void *)(v5 + v4 + 8);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        *(void *)(v6 - 24) = &unk_26C99C348;
        uint64_t v8 = *(void *)(v6 - 16);
        if (v8) {
          MEMORY[0x21D46B220](v8, 0x1000C8052888210);
        }
        v4 -= 48;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1090C80405A4B77);
  }
  return a1;
}

uint64_t NArray<BOOL>::resize(uint64_t a1, unsigned int *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  uint64_t result = *a2;
  if (v3 != result)
  {
    *(_DWORD *)(a1 + 16) = result;
    operator new[]();
  }
  return result;
}

uint64_t NArray<BOOL>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C8077774924);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = *(void *)(result + 8);
    uint64_t v9 = v4;
    if (v4 < 8 || (unint64_t)(v8 - a2) <= 0x1F)
    {
      uint64_t v11 = 0;
      goto LABEL_20;
    }
    if (v4 >= 0x20)
    {
      uint64_t v11 = v4 & 0xFFFFFFE0;
      uint64_t v12 = (_OWORD *)(v8 + 16);
      uint64_t v13 = (long long *)(a2 + 16);
      uint64_t v14 = v9 & 0xFFFFFFE0;
      do
      {
        long long v15 = *v13;
        *(v12 - 1) = *(v13 - 1);
        _OWORD *v12 = v15;
        v12 += 2;
        v13 += 2;
        v14 -= 32;
      }
      while (v14);
      if (v11 == v9) {
        return result;
      }
      if ((v9 & 0x18) == 0)
      {
LABEL_20:
        uint64_t v21 = v9 - v11;
        uint64_t v22 = (unsigned char *)(v8 + v11);
        unint64_t v23 = (char *)(a2 + v11);
        do
        {
          char v24 = *v23++;
          *v22++ = v24;
          --v21;
        }
        while (v21);
        return result;
      }
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v16 = v11;
    uint64_t v11 = v9 & 0xFFFFFFF8;
    uint64_t v17 = v16 - v11;
    uint64_t v18 = (void *)(v8 + v16);
    int v19 = (uint64_t *)(a2 + v16);
    do
    {
      uint64_t v20 = *v19++;
      *v18++ = v20;
      v17 += 8;
    }
    while (v17);
    if (v11 != v9) {
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t NArray<BOOL>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8077774924);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      uint64_t v10 = v4;
      if (v4 < 8 || (unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_18;
      }
      if (v4 >= 0x20)
      {
        uint64_t v7 = v4 & 0xFFFFFFE0;
        uint64_t v11 = (_OWORD *)(v9 + 16);
        uint64_t v12 = (long long *)(v8 + 16);
        uint64_t v13 = v10 & 0xFFFFFFE0;
        do
        {
          long long v14 = *v12;
          *(v11 - 1) = *(v12 - 1);
          *uint64_t v11 = v14;
          v11 += 2;
          v12 += 2;
          v13 -= 32;
        }
        while (v13);
        if (v7 == v10) {
          return result;
        }
        if ((v10 & 0x18) == 0)
        {
LABEL_18:
          uint64_t v20 = v10 - v7;
          uint64_t v21 = (unsigned char *)(v9 + v7);
          uint64_t v22 = (char *)(v8 + v7);
          do
          {
            char v23 = *v22++;
            *v21++ = v23;
            --v20;
          }
          while (v20);
          return result;
        }
      }
      else
      {
        uint64_t v7 = 0;
      }
      uint64_t v15 = v7;
      uint64_t v7 = v10 & 0xFFFFFFF8;
      uint64_t v16 = v15 - v7;
      uint64_t v17 = (void *)(v9 + v15);
      uint64_t v18 = (uint64_t *)(v8 + v15);
      do
      {
        uint64_t v19 = *v18++;
        *v17++ = v19;
        v16 += 8;
      }
      while (v16);
      if (v7 != v10) {
        goto LABEL_18;
      }
    }
  }
  return result;
}

void NArray<BOOL>::~NArray(void *a1)
{
  *a1 = &unk_26C99C2D8;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<BOOL>::~NArray(void *a1)
{
  *a1 = &unk_26C99C2D8;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  return a1;
}

void NLRHMMModel::init(NLRHMMModel *this, const NPhoneHMM *a2, const int *a3, float *a4, float *a5)
{
  int v5 = a5;
  uint64_t v6 = a4;
  uint64_t v7 = a3;
  unsigned int v10 = *((_DWORD *)a2 + 4) + 1;
  *(_DWORD *)this = v10;
  if (*((_DWORD *)this + 6) != v10)
  {
    *((_DWORD *)this + 6) = v10;
    operator new[]();
  }
  if (*((_DWORD *)this + 12) != v10)
  {
    *((_DWORD *)this + 12) = v10;
    operator new[]();
  }
  if (*((_DWORD *)this + 18) != v10)
  {
    *((_DWORD *)this + 18) = v10;
    operator new[]();
  }
  if (v10 <= 1)
  {
    uint64_t v12 = (int *)*((void *)this + 8);
    goto LABEL_16;
  }
  uint64_t v11 = *((void *)a2 + 1);
  uint64_t v12 = (int *)*((void *)this + 8);
  unint64_t v13 = 1;
  long long v14 = (int *)v11;
  do
  {
    int v15 = *v14;
    v14 += 2;
    v12[v13++] = v15;
    unint64_t v16 = *(unsigned int *)this;
  }
  while (v13 < v16);
  if (v16 <= 1)
  {
    unsigned int v10 = *(_DWORD *)this;
LABEL_16:
    uint64_t v19 = (float *)*((void *)this + 5);
    uint64_t v18 = (float *)*((void *)this + 2);
    LODWORD(v16) = v10;
    goto LABEL_17;
  }
  uint64_t v18 = (float *)*((void *)this + 2);
  uint64_t v19 = (float *)*((void *)this + 5);
  uint64_t v20 = (float *)(v11 + 4);
  uint64_t v21 = 1;
  do
  {
    float v22 = *v20;
    v20 += 2;
    v18[v21] = logf(v22);
    v19[v21++] = logf(1.0 - v22);
  }
  while (v16 != v21);
  uint64_t v7 = a3;
  int v5 = a5;
  uint64_t v6 = a4;
LABEL_17:
  v19[(v16 - 1)] = *v5 + v19[(v16 - 1)];
  float v23 = 1.0 - 1.0 / *v6;
  *uint64_t v18 = logf(v23);
  float *v19 = logf(1.0 - v23);
  int *v12 = *v7;
  unsigned int v24 = *((_DWORD *)a2 + 8);
  BOOL v25 = v24 >= 7;
  uint64_t v26 = v24 - 7;
  if (v25)
  {
    int v28 = (int *)(*((void *)a2 + 5) + v26);
    int v29 = *v28;
    int v30 = *(int *)((char *)v28 + 3);
    BOOL v27 = v29 == 1935959151 && v30 == 1885956979;
  }
  else
  {
    BOOL v27 = 0;
  }
  *((unsigned char *)this + 80) = v27;
}

uint64_t NLRHMMStateTokens::init(uint64_t this, const unsigned int *a2)
{
  unsigned int v2 = *a2 + 1;
  if (*(_DWORD *)(this + 16) != v2)
  {
    *(_DWORD *)(this + 16) = v2;
    operator new[]();
  }
  unsigned int v3 = *a2 + 1;
  if (*(_DWORD *)(this + 40) != v3)
  {
    *(_DWORD *)(this + 40) = v3;
    operator new[]();
  }
  return this;
}

void NLRHMMStateTokens::reset(NLRHMMStateTokens *this)
{
  if (*((_DWORD *)this + 10))
  {
    unint64_t v1 = 0;
    uint64_t v2 = *((void *)this + 4);
    do
      *(_DWORD *)(v2 + 4 * v1++) = 0;
    while (v1 < *((unsigned int *)this + 10));
  }
  int v3 = *((_DWORD *)this + 4);
  if (v3)
  {
    unsigned int v4 = (_DWORD *)*((void *)this + 1);
    *unsigned int v4 = 0;
    if (v3 != 1) {
      memset_pattern16(v4 + 1, &unk_21852DEC0, 4 * (v3 - 2) + 4);
    }
  }
}

void TSHMMDetector::TSHMMDetector(TSHMMDetector *this)
{
  *(void *)this = &unk_26C99AAA0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 10) = &unk_26C99C498;
  *((_WORD *)this + 52) = 1;
  N2DArray<BOOL>::N2DArray((void *)this + 14);
}

void sub_21846AB30(_Unwind_Exception *exception_object)
{
  *unint64_t v1 = &unk_26C99C348;
  if (*v2) {
    MEMORY[0x21D46B220](*v2, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void TSHMMDetector::init(TSHMMDetector *this, const NString *a2, const NString *a3, const NString *a4, const NString *a5, const NString *a6, const NString *a7, const NString *a8, float a9, unsigned int a10, unsigned int a11, unsigned int a12, unsigned int a13, unsigned int a14, unsigned int a15, unsigned int a16, unsigned int a17, int a18)
{
  float v19 = a9;
  if (!*((unsigned char *)this + 396))
  {
    v18[0] = &unk_26C99B258;
    v18[1] = 0;
    NDistributionLoader::read((NDistributionLoader *)v18, a2, a3);
  }
  Error::chuck((Error *)"TSHMMDetector::init() - init() already called", (const char *)a2, a3, a4, a5, a6, a7, a8);
}

void sub_21846C010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  NArray<NString>::~NArray(&a32);
  NArray<NString>::~NArray((void *)(v32 - 192));
  NPhoneHMMArray::~NPhoneHMMArray((NPhoneHMMArray *)(v32 - 160));
  _Unwind_Resume(a1);
}

uint64_t TSHMMDetector::reset(TSHMMDetector *this)
{
  *((void *)this + 43) = 4286578687;
  *((_DWORD *)this + 88) = -8388609;
  *((unsigned char *)this + 397) = 0;
  *((unsigned char *)this + 403) = 0;
  *(_OWORD *)((char *)this + 356) = 0u;
  *(_OWORD *)((char *)this + 372) = 0u;
  if (*((_DWORD *)this + 78))
  {
    unint64_t v2 = 0;
    uint64_t v3 = *((void *)this + 38);
    do
    {
      uint64_t v4 = v3 + 48 * v2;
      if (*(_DWORD *)(v4 + 40))
      {
        unint64_t v5 = 0;
        uint64_t v6 = *(void *)(v3 + 48 * v2 + 32);
        do
          *(_DWORD *)(v6 + 4 * v5++) = 0;
        while (v5 < *(unsigned int *)(v4 + 40));
      }
      int v7 = *(_DWORD *)(v4 + 16);
      if (v7)
      {
        uint64_t v8 = *(_DWORD **)(v4 + 8);
        *uint64_t v8 = 0;
        if (v7 != 1) {
          memset_pattern16(v8 + 1, &unk_21852DEC0, 4 * (v7 - 2) + 4);
        }
      }
      ++v2;
    }
    while (v2 < *((unsigned int *)this + 78));
  }
  *((_WORD *)this + 52) = 1;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 0;
  *((_DWORD *)this + 97) = 1;
  if (*((unsigned char *)this + 398))
  {
    uint64_t v9 = *((void *)this + 1);
    if (v9) {
      *((_DWORD *)this + 97) = ((*(unsigned int (**)(uint64_t))(*(void *)v9 + 32))(v9) >> 1) + 1;
    }
  }
  *((_DWORD *)this + 98) = 0;
  *((unsigned char *)this + 402) = 0;
  *((void *)this + 19) = 0;
  uint64_t result = *((void *)this + 1);
  if (result && *((void *)this + 3))
  {
    uint64_t v11 = *(uint64_t (**)(void))(*(void *)result + 160);
    return v11();
  }
  return result;
}

uint64_t TSHMMDetector::disablePriming(uint64_t this)
{
  *(unsigned char *)(this + 402) = 1;
  return this;
}

void TSHMMDetector::feedFrame(TSHMMDetector *this, const NFrame *a2, double a3)
{
  if (!*((unsigned char *)this + 396)) {
    Error::chuck((Error *)"TSHMMDetector::feedFrame() - init() not called", (const char *)a2);
  }
  if (*((unsigned char *)this + 397)) {
    Error::chuck((Error *)"TSHMMDetector::feedFrame() - endFrame() was called", (const char *)a2);
  }
  uint64_t v4 = a2;
  while ((TSHMMDetector::updateResult(this, (const char *)a2, a3) & 1) != 0)
    ;
  if (!*((unsigned char *)this + 398)) {
    goto LABEL_13;
  }
  int v5 = *((_DWORD *)v4 + 4);
  if (!v5) {
    Error::chuck((Error *)"NFrameWindow::pushFrame() - cannot feed zero-sized frames", (const char *)a2);
  }
  uint64_t v6 = *((unsigned int *)this + 10);
  if (v5 != v6) {
    Error::chuck((Error *)"NFrameWindow::pushFrame() - mismatched input frame size (%d != %d)", (const char *)a2, *((unsigned int *)v4 + 4), v6);
  }
  v7.n128_u64[0] = (unint64_t)NFrameWindow::pushFrame((TSHMMDetector *)((char *)this + 32), *((const float **)v4 + 1));
  int v8 = *((_DWORD *)this + 18);
  if (*((unsigned char *)this + 105) && v8 || v8 == *((_DWORD *)this + 9) + 1)
  {
    uint64_t v9 = (char *)this + 52;
    if (!*((_DWORD *)this + 13)) {
      Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - frame window not configured", v9, v7.n128_f64[0]);
    }
    uint64_t v4 = (TSHMMDetector *)((char *)this + 224);
    (*(void (**)(char *, const char *, __n128))(*((void *)this + 28) + 32))((char *)this + 224, v9, v7);
    NFrameWindow::setOutputFrameWindow((uint64_t)this + 32, *((float **)this + 29));
LABEL_13:
    TSHMMDetector::stepFrame(this, v4);
  }
  ++*((_DWORD *)this + 91);
}

uint64_t TSHMMDetector::updateResult(TSHMMDetector *this, const char *a2, double a3)
{
  if (!*((unsigned char *)this + 396)) {
    Error::chuck((Error *)"TSHMMDetector::updateResult() - init() not called", a2);
  }
  int v4 = *((_DWORD *)this + 96);
  if (v4)
  {
    int v5 = (char *)this + 384;
  }
  else
  {
    if (!*((_DWORD *)this + 94)) {
      return 0;
    }
    if (*((_DWORD *)this + 51) != 1) {
      operator new[]();
    }
    TSHMMDetector::advanceHMMScores((uint64_t)this, (uint64_t)this + 272, a3);
    int v5 = (char *)this + 376;
    int v4 = *((_DWORD *)this + 94);
  }
  *(_DWORD *)int v5 = v4 - 1;
  return 1;
}

void sub_21846C710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSHMMDetector::stepFrame(TSHMMDetector *this, const NFrame *a2)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    goto LABEL_6;
  }
  int v5 = *((_DWORD *)this + 97);
  if (!v5) {
    goto LABEL_6;
  }
  int v6 = v5 - 1;
  *((_DWORD *)this + 97) = v6;
  if (v6)
  {
    ++*((_DWORD *)this + 92);
    return result;
  }
  if (!*((unsigned char *)this + 402))
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, const NFrame *, char *, void))(*(void *)result + 72))(result, a2, (char *)this + 248, 0);
    int v16 = **((_DWORD **)this + 21);
    uint64_t v17 = *((void *)this + 38);
    uint64_t v18 = (v16 - 1);
    if (v16 == 1)
    {
      uint64_t v21 = *(_DWORD **)(v17 + 32);
      float v22 = *(_DWORD **)(v17 + 8);
    }
    else
    {
      uint64_t v19 = 0;
      uint64_t v20 = *((void *)this + 32);
      uint64_t v21 = *(_DWORD **)(v17 + 32);
      float v22 = *(_DWORD **)(v17 + 8);
      do
      {
        float v23 = *(float *)(v20 + 4 * (v18 + v19));
        if (v23 < 0.0) {
          float v23 = 0.0;
        }
        v21[v19 + 1] = *((_DWORD *)this + 92) - (uint64_t)rintf(v23);
        v22[v19 + 1] = *(_DWORD *)(v20 + 4 * v19);
        ++v19;
      }
      while (v18 != v19);
    }
    *uint64_t v21 = *((_DWORD *)this + 92);
    *float v22 = 0;
    int v7 = *((_DWORD *)this + 95);
    if (v7) {
      goto LABEL_7;
    }
  }
  else
  {
LABEL_6:
    int v7 = *((_DWORD *)this + 95);
    if (v7)
    {
LABEL_7:
      if (*((unsigned char *)this + 401))
      {
        int v8 = **((_DWORD **)this + 21);
        size_t v9 = (v8 - 1);
        if (v8 != 1) {
          bzero(*((void **)this + 41), v9);
        }
        uint64_t v10 = *((unsigned int *)this + 37);
        if (*((_DWORD *)this + 84) != v10) {
          Error::chuck((Error *)"NLRHMMTraceback::drop() - mismatched number of states (%d != %d)", (const char *)v9, *((unsigned int *)this + 84), v10);
        }
        uint64_t v11 = *((void *)this + 15) + 24 * *((unsigned int *)this + 38);
        uint64_t result = (*(uint64_t (**)(uint64_t, char *))(*(void *)v11 + 16))(v11, (char *)this + 320);
        int v13 = *((_DWORD *)this + 38);
        unsigned int v12 = *((_DWORD *)this + 39);
        unsigned int v14 = *((_DWORD *)this + 36);
        if (v13 + 1 < v14) {
          int v15 = v13 + 1;
        }
        else {
          int v15 = 0;
        }
        *((_DWORD *)this + 38) = v15;
        if (v12 < v14) {
          *((_DWORD *)this + 39) = v12 + 1;
        }
        int v7 = *((_DWORD *)this + 95);
      }
      ++*((_DWORD *)this + 96);
      *((_DWORD *)this + 95) = v7 - 1;
      return result;
    }
  }
  int v24 = *((_DWORD *)this + 92);
  if (v24 && *((_DWORD *)this + 51) == 1) {
    *((_DWORD *)this + 92) = *((_DWORD *)this + 48) + v24;
  }
  *((_DWORD *)this + 95) = *((_DWORD *)this + 48);
  if (*((unsigned char *)this + 216))
  {
    unsigned int v25 = (*(uint64_t (**)(void))(**((void **)this + 1) + 32))(*((void *)this + 1)) - 2;
    if (*((_DWORD *)this + 98) > v25) {
      *((_DWORD *)this + 98) = v25;
    }
    int v26 = *((_DWORD *)this + 60);
    int v27 = *(_DWORD *)(*(uint64_t (**)(void))(**((void **)this + 1) + 40))(*((void *)this + 1));
    uint64_t v28 = *((void *)this + 29);
    *(float *)(v28 + 4 * (v26 - v27)) = (float)*((unsigned int *)this + 98);
    unsigned int v29 = *((_DWORD *)a2 + 4);
    unsigned int v30 = v26 - v27 + 1;
    if (v30 < v29) {
      bzero((void *)(v28 + 4 * v30), 4 * (v27 + v29 - v26 - 2) + 4);
    }
    TSHMMDetector::quasarCMNBatch((uint64_t)this);
  }
  uint64_t result = (*(uint64_t (**)(void, const NFrame *, char *, void))(**((void **)this + 1) + 72))(*((void *)this + 1), a2, (char *)this + 272, *((void *)this + 3));
  int v31 = 1;
  *((unsigned char *)this + 403) = 1;
  int v32 = *((_DWORD *)this + 51);
  *((_DWORD *)this + 93) = 0;
  unsigned int v33 = *((_DWORD *)this + 98);
  if (v32 + 1 > v33) {
    int v31 = v32 - v33;
  }
  *((_DWORD *)this + 94) = v31;
  return result;
}

uint64_t TSHMMDetector::quasarCMNBatch(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 208);
  if (v1)
  {
    uint64_t v2 = this;
    unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(this + 8) + 32))(*(void *)(this + 8))
       - *(unsigned __int8 *)(this + 216);
    this = (*(uint64_t (**)(void))(**(void **)(v2 + 8) + 40))(*(void *)(v2 + 8));
    unsigned int v5 = *(_DWORD *)(v2 + 392);
    BOOL v6 = v3 >= v5;
    unsigned int v7 = v3 - v5;
    if (v6) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 0;
    }
    if (v8 > v1) {
      Error::chuck((Error *)"TSHMMDetector::quasarCMNBatch() - small maxframes=%d not supported for batch=%d", v4, v1, v8);
    }
    if (*(_DWORD *)this) {
      operator new[]();
    }
  }
  return this;
}

void sub_21846CFD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSHMMDetector::advanceHMMScores(uint64_t result, uint64_t a2, double a3)
{
  uint64_t v4 = result;
  if (*(unsigned char *)(result + 399))
  {
    uint64_t v5 = *(unsigned int *)(a2 + 16);
    if (v5)
    {
      BOOL v6 = *(_DWORD **)(a2 + 8);
      LODWORD(a3) = *v6;
      if (v5 != 1)
      {
        uint64_t v7 = v5 - 1;
        uint64_t v8 = (float *)(v6 + 1);
        do
        {
          float v9 = *v8++;
          float v10 = v9;
          if (v9 > *(float *)&a3) {
            *(float *)&a3 = v10;
          }
          --v7;
        }
        while (v7);
      }
    }
    else
    {
      a3 = 0.0;
    }
  }
  else
  {
    if (*(unsigned char *)(result + 400))
    {
      int v37 = 0;
      if (*(_DWORD *)(result + 176)) {
        goto LABEL_15;
      }
LABEL_11:
      LODWORD(v11) = 0;
      goto LABEL_23;
    }
    LODWORD(a3) = *(_DWORD *)(*(void *)(a2 + 8) + 4 * **(unsigned int **)(*(void *)(result + 168) + 64));
  }
  int v37 = LODWORD(a3);
  if (!*(_DWORD *)(result + 176)) {
    goto LABEL_11;
  }
LABEL_15:
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unint64_t v14 = 0;
  do
  {
    uint64_t v15 = *(void *)(v4 + 168) + v12;
    uint64_t v16 = *(void *)(v4 + 304) + v13;
    if (v14) {
      BOOL v17 = 1;
    }
    else {
      BOOL v17 = *(unsigned char *)(v4 + 401) == 0;
    }
    char v18 = !v17;
    char v36 = v18;
    uint64_t result = TSHMMDetector::updateStateProbs(v4, v15, v16, a2, (float *)&v37, &v36, a3);
    ++v14;
    unint64_t v11 = *(unsigned int *)(v4 + 176);
    v13 += 48;
    v12 += 88;
  }
  while (v14 < v11);
LABEL_23:
  uint64_t v19 = *(unsigned int **)(v4 + 168);
  uint64_t v20 = *(void **)(v4 + 304);
  uint64_t v21 = v20[1];
  uint64_t v22 = 4 * *v19;
  float v23 = *(float *)(v21 + v22);
  uint64_t v24 = v20[4];
  int v25 = *(_DWORD *)(v24 + v22);
  if (v11 < 2)
  {
    int v26 = 0;
  }
  else
  {
    int v26 = 0;
    int v27 = v20 + 10;
    uint64_t v28 = v19 + 22;
    uint64_t v29 = 1;
    do
    {
      unsigned int v31 = *v28;
      v28 += 22;
      uint64_t v30 = v31;
      float v32 = *(float *)(*(v27 - 3) + 4 * v31);
      if (v32 > v23)
      {
        int v25 = *(_DWORD *)(*v27 + 4 * v30);
        int v26 = v29;
        float v23 = v32;
      }
      ++v29;
      v27 += 6;
    }
    while (v11 != v29);
  }
  float v33 = (float)*(unsigned int *)(v4 + 196);
  *(float *)(v4 + 352) = v23 * v33;
  *(_DWORD *)(v4 + 356) = v25;
  *(_DWORD *)(v4 + 360) = v26;
  uint64_t v34 = *(unsigned int *)(v4 + 188);
  if (v34)
  {
    uint64_t v35 = 4 * v34;
    *(float *)(v4 + 344) = *(float *)(v21 + v35) * v33;
    *(_DWORD *)(v4 + 348) = *(_DWORD *)(v24 + v35);
  }
  ++*(_DWORD *)(v4 + 368);
  return result;
}

uint64_t TSHMMDetector::updateStateProbs(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, float *a5, unsigned char *a6, double a7)
{
  uint64_t v10 = a2;
  uint64_t v11 = result;
  uint64_t v12 = *(unsigned int *)a2;
  if (*(unsigned char *)(a2 + 80))
  {
    uint64_t v13 = (v12 - 1);
    if (v12 != 1)
    {
      uint64_t v14 = 0;
      uint64_t v15 = *(void *)(a3 + 8);
      uint64_t v16 = *(void *)(a3 + 32);
      uint64_t v17 = 4 * (v12 - 1);
      uint64_t v18 = v16 + v17;
      uint64_t v19 = *(void *)(a2 + 40);
      int v20 = v12 - 3;
      uint64_t v21 = *(void *)(a2 + 16) + v17;
      uint64_t v22 = v15 + v17;
      do
      {
        uint64_t v23 = (v12 - 2 + v14);
        float v24 = *(float *)(v22 + 4 * v14) + *(float *)(v21 + 4 * v14);
        float v25 = *(float *)(v15 + 4 * v23) + *(float *)(v19 + 4 * v23);
        a2 = v25 >= v24;
        if (v25 >= v24)
        {
          *(_DWORD *)(v18 + 4 * v14) = *(_DWORD *)(v16 + 4 * v23);
          float v24 = v25;
        }
        if (unint64_t)(v13 + v14) >= 2 && ((v13 + v14))
        {
          float v26 = *(float *)(v15 + 4 * (v20 + v14)) + *(float *)(v19 + 4 * (v20 + v14));
          if (v26 >= v24)
          {
            *(_DWORD *)(v18 + 4 * v14) = *(_DWORD *)(v16 + 4 * (v20 + v14));
            a2 = 1;
            float v24 = v26;
          }
        }
        *(float *)(v22 + 4 * v14) = v24;
        if (*a6) {
          *(unsigned char *)(*(void *)(v11 + 328) + v23) = a2;
        }
        uint64_t result = (v13 + v14--);
      }
      while (result != 1);
    }
    if (*a6)
    {
LABEL_14:
      uint64_t v27 = *(unsigned int *)(v11 + 148);
      if (*(_DWORD *)(v11 + 336) != v27) {
        Error::chuck((Error *)"NLRHMMTraceback::drop() - mismatched number of states (%d != %d)", (const char *)a2, *(unsigned int *)(v11 + 336), v27);
      }
      uint64_t v28 = *(void *)(v11 + 120) + 24 * *(unsigned int *)(v11 + 152);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v28 + 16))(v28, v11 + 320);
      int v30 = *(_DWORD *)(v11 + 152);
      unsigned int v29 = *(_DWORD *)(v11 + 156);
      unsigned int v31 = *(_DWORD *)(v11 + 144);
      if (v30 + 1 < v31) {
        int v32 = v30 + 1;
      }
      else {
        int v32 = 0;
      }
      *(_DWORD *)(v11 + 152) = v32;
      if (v29 < v31) {
        *(_DWORD *)(v11 + 156) = v29 + 1;
      }
    }
  }
  else
  {
    uint64_t v37 = (v12 - 1);
    if (*a6)
    {
      if (v12 != 1)
      {
        uint64_t v38 = *(void *)(a3 + 8);
        uint64_t v39 = *(void *)(a2 + 16);
        uint64_t v40 = *(void *)(a2 + 40);
        unsigned int v41 = v12 - 2;
        uint64_t v42 = *(void *)(a3 + 32);
        do
        {
          float v44 = *(float *)(v38 + 4 * v37) + *(float *)(v39 + 4 * v37);
          uint64_t v45 = v41;
          float v46 = *(float *)(v38 + 4 * v41) + *(float *)(v40 + 4 * v41);
          if (v44 <= v46)
          {
            *(_DWORD *)(v42 + 4 * v37) = *(_DWORD *)(v42 + 4 * v41);
            char v43 = 1;
            float v44 = v46;
          }
          else
          {
            char v43 = 0;
          }
          *(unsigned char *)(*(void *)(result + 328) + v45) = v43;
          *(float *)(v38 + 4 * v37) = v44;
          unsigned int v41 = v45 - 1;
          --v37;
        }
        while (v37);
      }
      goto LABEL_14;
    }
    if (v12 == 1) {
      goto LABEL_36;
    }
    uint64_t v47 = *(void *)(a3 + 8);
    uint64_t v48 = *(void *)(a2 + 16);
    uint64_t v49 = *(void *)(a2 + 40);
    unsigned int v50 = v12 - 2;
    uint64_t v51 = *(void *)(a3 + 32);
    do
    {
      float v52 = *(float *)(v47 + 4 * v37) + *(float *)(v48 + 4 * v37);
      float v53 = *(float *)(v47 + 4 * v50) + *(float *)(v49 + 4 * v50);
      if (v52 <= v53)
      {
        *(_DWORD *)(v51 + 4 * v37) = *(_DWORD *)(v51 + 4 * v50);
        float v52 = v53;
      }
      *(float *)(v47 + 4 * v37) = v52;
      --v50;
      --v37;
    }
    while (v37);
  }
  if (v12 > 1)
  {
    uint64_t v33 = *(void *)(v10 + 64);
    uint64_t v34 = *(void *)(a4 + 8);
    uint64_t v35 = 1;
    char v36 = *(float **)(a3 + 8);
    do
    {
      v36[v35] = *(float *)(v34 + 4 * *(unsigned int *)(v33 + v35 * 4)) + v36[v35];
      ++v35;
    }
    while (v12 != v35);
    goto LABEL_37;
  }
LABEL_36:
  char v36 = *(float **)(a3 + 8);
LABEL_37:
  float v54 = *v36 + **(float **)(v10 + 16);
  *char v36 = v54;
  *char v36 = v54 + *a5;
  uint64_t v55 = *(_DWORD **)(a3 + 32);
  *uint64_t v55 = *(_DWORD *)(v11 + 368) + 1;
  uint64_t v56 = (v12 - 1);
  int16x8_t v57 = *(float **)(v10 + 40);
  v36[v12] = v36[v56] + v57[v56];
  v55[v12] = v55[v56];
  *(float *)&a7 = *v36 + *v57;
  if ((v12 + 1) > 1) {
    uint64_t v58 = (v12 + 1);
  }
  else {
    uint64_t v58 = 1;
  }
  if (v58 <= 7)
  {
    uint64_t v59 = 0;
LABEL_45:
    uint64_t v64 = v58 - v59;
    float16x8_t v65 = &v36[v59];
    do
    {
      *float16x8_t v65 = *v65 - *(float *)&a7;
      ++v65;
      --v64;
    }
    while (v64);
    return result;
  }
  uint64_t v59 = v58 & 0xFFFFFFF8;
  float32x4_t v60 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a7, 0);
  uint64_t v61 = (float32x4_t *)(v36 + 4);
  uint64_t v62 = v59;
  do
  {
    float32x4_t v63 = vsubq_f32(*v61, v60);
    v61[-1] = vsubq_f32(v61[-1], v60);
    *uint64_t v61 = v63;
    v61 += 2;
    v62 -= 8;
  }
  while (v62);
  if (v59 != v58) {
    goto LABEL_45;
  }
  return result;
}

uint64_t TSHMMDetector::endFrame(TSHMMDetector *this, const char *a2, double a3)
{
  if (!*((unsigned char *)this + 396)) {
    Error::chuck((Error *)"TSHMMDetector::endFrame() - init() not called", a2);
  }
  int v4 = *((unsigned __int8 *)this + 397);
  *((unsigned char *)this + 397) = 1;
  while ((TSHMMDetector::updateResult(this, a2, a3) & 1) != 0)
    ;
  if (!*((unsigned char *)this + 398)) {
    return 0;
  }
  if (v4)
  {
    uint64_t v5 = (char *)this + 32;
    int v6 = *((_DWORD *)this + 18);
    if (*((unsigned char *)this + 105) && v6) {
      goto LABEL_11;
    }
LABEL_10:
    if (v6 == *((_DWORD *)this + 9) + 1) {
      goto LABEL_11;
    }
    return 0;
  }
  *((unsigned char *)this + 105) = 1;
  uint64_t v5 = (char *)this + 32;
  int v6 = *((_DWORD *)this + 18);
  if (!v6) {
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v7 = (char *)this + 52;
  if (!*((_DWORD *)this + 13)) {
    Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - frame window not configured", v7);
  }
  (*(void (**)(char *, const char *))(*((void *)this + 28) + 32))((char *)this + 224, v7);
  NFrameWindow::setOutputFrameWindow((uint64_t)v5, *((float **)this + 29));
  TSHMMDetector::stepFrame(this, (TSHMMDetector *)((char *)this + 224));
  unsigned int v8 = *((_DWORD *)this + 91);
  unsigned int v9 = *((_DWORD *)this + 92);
  BOOL v10 = v8 >= v9;
  unsigned int v11 = v8 - v9;
  if (v11 != 0 && v10)
  {
    if (*((_DWORD *)this + 94) > v11) {
      *((_DWORD *)this + 94) = v11;
    }
  }
  else
  {
    *((_DWORD *)this + 94) = 0;
  }
  return 1;
}

void TSHMMDetector::padToEndOfBatch(TSHMMDetector *this)
{
  unsigned int v2 = *((_DWORD *)this + 95);
  if (v2 < (*(unsigned int (**)(void))(**((void **)this + 1) + 32))(*((void *)this + 1)))
  {
    int v8 = 0;
    int v6 = &unk_26C99C498;
    uint64_t v7 = 0;
    if (!*((unsigned char *)this + 396)) {
      Error::chuck((Error *)"TSHMMDetector::frameSize() - init() not called", v3);
    }
    if (*((_DWORD *)this + 46))
    {
      int v8 = *((_DWORD *)this + 46);
      operator new[]();
    }
    uint64_t v5 = 0;
    *((_DWORD *)this + 98) = 0;
    if (!*((_DWORD *)this + 94))
    {
      do
      {
        TSHMMDetector::feedFrame(this, (const NFrame *)&v6, v4);
        --*((_DWORD *)this + 91);
        ++*((_DWORD *)this + 98);
      }
      while (!*((_DWORD *)this + 94));
      uint64_t v5 = v7;
    }
    int v6 = &unk_26C99C348;
    if (v5) {
      MEMORY[0x21D46B220](v5, 0x1000C8052888210);
    }
  }
}

void sub_21846D840(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSHMMDetector::frameSize(TSHMMDetector *this, const char *a2)
{
  if (!*((unsigned char *)this + 396)) {
    Error::chuck((Error *)"TSHMMDetector::frameSize() - init() not called", a2);
  }
  return *((unsigned int *)this + 46);
}

uint64_t TSHMMDetector::skipUntilInitialize(TSHMMDetector *this, const NFrame *a2)
{
  uint64_t result = *((void *)this + 2);
  if (result)
  {
    int v4 = *((_DWORD *)this + 97);
    if (!v4) {
      return 0;
    }
    int v5 = v4 - 1;
    *((_DWORD *)this + 97) = v5;
    if (v5)
    {
      ++*((_DWORD *)this + 92);
      return 1;
    }
    if (!*((unsigned char *)this + 402))
    {
      (*(void (**)(uint64_t, const NFrame *, char *, void))(*(void *)result + 72))(result, a2, (char *)this + 248, 0);
      int v6 = **((_DWORD **)this + 21);
      uint64_t v7 = *((void *)this + 38);
      uint64_t v8 = (v6 - 1);
      if (v6 == 1)
      {
        unsigned int v11 = *(_DWORD **)(v7 + 32);
        uint64_t v12 = *(_DWORD **)(v7 + 8);
      }
      else
      {
        uint64_t v9 = 0;
        uint64_t v10 = *((void *)this + 32);
        unsigned int v11 = *(_DWORD **)(v7 + 32);
        uint64_t v12 = *(_DWORD **)(v7 + 8);
        do
        {
          float v13 = *(float *)(v10 + 4 * (v8 + v9));
          if (v13 < 0.0) {
            float v13 = 0.0;
          }
          v11[v9 + 1] = *((_DWORD *)this + 92) - (uint64_t)rintf(v13);
          v12[v9 + 1] = *(_DWORD *)(v10 + 4 * v9);
          ++v9;
        }
        while (v8 != v9);
      }
      uint64_t result = 0;
      *unsigned int v11 = *((_DWORD *)this + 92);
      _DWORD *v12 = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL TSHMMDetector::skipUntilProcessedFrame(TSHMMDetector *this)
{
  int v2 = *((_DWORD *)this + 95);
  if (v2)
  {
    if (*((unsigned char *)this + 401))
    {
      int v3 = **((_DWORD **)this + 21);
      size_t v4 = (v3 - 1);
      if (v3 != 1) {
        bzero(*((void **)this + 41), v4);
      }
      uint64_t v5 = *((unsigned int *)this + 37);
      if (*((_DWORD *)this + 84) != v5) {
        Error::chuck((Error *)"NLRHMMTraceback::drop() - mismatched number of states (%d != %d)", (const char *)v4, *((unsigned int *)this + 84), v5);
      }
      uint64_t v6 = *((void *)this + 15) + 24 * *((unsigned int *)this + 38);
      (*(void (**)(uint64_t, char *))(*(void *)v6 + 16))(v6, (char *)this + 320);
      int v8 = *((_DWORD *)this + 38);
      unsigned int v7 = *((_DWORD *)this + 39);
      unsigned int v9 = *((_DWORD *)this + 36);
      if (v8 + 1 < v9) {
        int v10 = v8 + 1;
      }
      else {
        int v10 = 0;
      }
      *((_DWORD *)this + 38) = v10;
      if (v7 < v9) {
        *((_DWORD *)this + 39) = v7 + 1;
      }
      int v11 = *((_DWORD *)this + 95);
    }
    else
    {
      int v11 = *((_DWORD *)this + 95);
    }
    ++*((_DWORD *)this + 96);
    int v13 = v11 - 1;
  }
  else
  {
    int v12 = *((_DWORD *)this + 92);
    if (v12 && *((_DWORD *)this + 51) == 1) {
      *((_DWORD *)this + 92) = *((_DWORD *)this + 48) + v12;
    }
    int v13 = *((_DWORD *)this + 48);
  }
  BOOL result = v2 != 0;
  *((_DWORD *)this + 95) = v13;
  return result;
}

double TSHMMDetector::maxScore(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 16);
  if (!v2) {
    return 0.0;
  }
  int v3 = *(_DWORD **)(a2 + 8);
  LODWORD(result) = *v3;
  if (v2 != 1)
  {
    uint64_t v5 = v2 - 1;
    uint64_t v6 = (float *)(v3 + 1);
    do
    {
      float v7 = *v6++;
      float v8 = v7;
      if (v7 > *(float *)&result) {
        *(float *)&double result = v8;
      }
      --v5;
    }
    while (v5);
  }
  return result;
}

float TSHMMDetector::partialScore(TSHMMDetector *this)
{
  return *((float *)this + 86);
}

uint64_t TSHMMDetector::partialLength(TSHMMDetector *this)
{
  if (*((_DWORD *)this + 47)) {
    return (*((_DWORD *)this + 92) - *((_DWORD *)this + 87));
  }
  else {
    return 0;
  }
}

float TSHMMDetector::score(TSHMMDetector *this)
{
  return *((float *)this + 88);
}

uint64_t TSHMMDetector::bestLength(TSHMMDetector *this)
{
  return (*((_DWORD *)this + 92) - *((_DWORD *)this + 89));
}

uint64_t TSHMMDetector::bestPhrase(TSHMMDetector *this)
{
  return *((unsigned int *)this + 90);
}

float TSHMMDetector::scorePhrase(TSHMMDetector *this, const char *a2)
{
  uint64_t v2 = *((unsigned int *)this + 44);
  if (*(_DWORD *)a2 >= v2) {
    Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", a2, *(unsigned int *)a2, v2);
  }
  return *(float *)(*(void *)(*((void *)this + 38) + 48 * *(unsigned int *)a2 + 8)
                  + 4 * *(unsigned int *)(*((void *)this + 21) + 88 * *(unsigned int *)a2))
       * (float)*((unsigned int *)this + 49);
}

uint64_t TSHMMDetector::bestLengthPhrase(TSHMMDetector *this, const char *a2)
{
  uint64_t v2 = *((unsigned int *)this + 44);
  if (*(_DWORD *)a2 >= v2) {
    Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", a2, *(unsigned int *)a2, v2);
  }
  return (*((_DWORD *)this + 92)
                      - *(_DWORD *)(*(void *)(*((void *)this + 38) + 48 * *(unsigned int *)a2 + 32)
                                  + 4 * *(unsigned int *)(*((void *)this + 21) + 88 * *(unsigned int *)a2)));
}

uint64_t TSHMMDetector::numPhrases(TSHMMDetector *this)
{
  return *((unsigned int *)this + 44);
}

uint64_t TSHMMDetector::frameLatency(TSHMMDetector *this)
{
  int v1 = *((_DWORD *)this + 91) - *((_DWORD *)this + 92) + *((_DWORD *)this + 50);
  return v1 & ~(v1 >> 31);
}

uint64_t TSHMMDetector::numStates(TSHMMDetector *this)
{
  if (*((_DWORD *)this + 44)) {
    return (**((_DWORD **)this + 21) - 1);
  }
  else {
    return 0;
  }
}

uint64_t TSHMMDetector::stateAlignment(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = a3;
  return NLRHMMTraceback::stateAlignment(a1 + 112, a2, &v4);
}

uint64_t TSHMMDetector::lastOutputDistSize(TSHMMDetector *this)
{
  return *((unsigned int *)this + 72);
}

BOOL TSHMMDetector::lastOutputDist(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 288);
  if (*(_DWORD *)(a2 + 16) != v2) {
    Error::chuck((Error *)"TSHMMDetector::lastModelOutput() - mismatched size in output array (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v2);
  }
  int v3 = *(unsigned __int8 *)(a1 + 403);
  if (*(unsigned char *)(a1 + 403)) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1 + 272);
  }
  return v3 != 0;
}

void sub_21846E350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__603(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__604(uint64_t a1)
{
}

void sub_21846E6C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_21846EB24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_21846EF48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void TSSATScorer::~TSSATScorer(TSSATScorer *this)
{
  *(void *)this = &unk_26C99A950;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 1) = 0;
  *((void *)this + 30) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 31);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 27) = &unk_26C99C348;
  uint64_t v4 = *((void *)this + 28);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  *((void *)this + 11) = &unk_26C99A8F0;
  *((void *)this + 24) = &unk_26C99C5B0;
  uint64_t v5 = *((void *)this + 26);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  *((void *)this + 21) = &unk_26C99C5B0;
  uint64_t v6 = *((void *)this + 23);
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  *((void *)this + 12) = &unk_26C99C5B0;
  uint64_t v7 = *((void *)this + 14);
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  *((void *)this + 2) = &unk_26C99AA10;
  *((void *)this + 3) = &unk_26C99C5B0;
  uint64_t v8 = *((void *)this + 5);
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(void *)this = &unk_26C99A950;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 1) = 0;
  *((void *)this + 30) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 31);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 27) = &unk_26C99C348;
  uint64_t v4 = *((void *)this + 28);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  *((void *)this + 11) = &unk_26C99A8F0;
  *((void *)this + 24) = &unk_26C99C5B0;
  uint64_t v5 = *((void *)this + 26);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  *((void *)this + 21) = &unk_26C99C5B0;
  uint64_t v6 = *((void *)this + 23);
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  *((void *)this + 12) = &unk_26C99C5B0;
  uint64_t v7 = *((void *)this + 14);
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  *((void *)this + 2) = &unk_26C99AA10;
  *((void *)this + 3) = &unk_26C99C5B0;
  uint64_t v8 = *((void *)this + 5);
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8077774924);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *(void *)this = &unk_26C99A950;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 1) = 0;
  *((void *)this + 30) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 31);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 27) = &unk_26C99C348;
  uint64_t v4 = *((void *)this + 28);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  *((void *)this + 11) = &unk_26C99A8F0;
  *((void *)this + 24) = &unk_26C99C5B0;
  uint64_t v5 = *((void *)this + 26);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  *((void *)this + 21) = &unk_26C99C5B0;
  uint64_t v6 = *((void *)this + 23);
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  *((void *)this + 12) = &unk_26C99C5B0;
  uint64_t v7 = *((void *)this + 14);
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  *((void *)this + 2) = &unk_26C99AA10;
  *((void *)this + 3) = &unk_26C99C5B0;
  uint64_t v8 = *((void *)this + 5);
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8077774924);
  }
}

void TSSATScorer::TSSATScorer(TSSATScorer *this)
{
  *(void *)this = &unk_26C99A950;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &unk_26C99AA10;
  *((void *)this + 3) = &unk_26C99C5B0;
  *((_DWORD *)this + 8) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99A950;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = &unk_26C99AA10;
  *((void *)this + 3) = &unk_26C99C5B0;
  *((_DWORD *)this + 8) = 0;
  operator new[]();
}

void sub_21846FF60(_Unwind_Exception *a1)
{
  NSATImpostor::~NSATImpostor(v1);
  _Unwind_Resume(a1);
}

void sub_218470088(_Unwind_Exception *a1)
{
  NSATImpostor::~NSATImpostor(v1);
  _Unwind_Resume(a1);
}

void TSSATScorer::init(TSSATScorer *this, const NString *a2, const NString *a3, const unsigned int *a4, const BOOL *a5, const BOOL *a6, const BOOL *a7, const float *a8, const unsigned int *a9, const unsigned int *a10, const unsigned int *a11)
{
  if (!*((unsigned char *)this + 295))
  {
    uint64_t v11 = *((void *)this + 1);
    if (v11) {
      (*(void (**)(uint64_t, const NString *, const NString *, const unsigned int *, const BOOL *, const BOOL *, const BOOL *, const float *))(*(void *)v11 + 8))(v11, a2, a3, a4, a5, a6, a7, a8);
    }
    operator new[]();
  }
  Error::chuck((Error *)"TSSATScorer::init() - init() already called", (const char *)a2, a3, a4, a5, a6, a7, a8);
}

void sub_21847084C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a18) {
    (*(void (**)(uint64_t))(*(void *)a18 + 8))(a18);
  }
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void TSSATScorer::setModelFile(TSSATScorer *this, const NString *a2)
{
  if (*((unsigned char *)this + 295))
  {
    *((unsigned char *)this + 296) = 0;
    (*(void (**)(void))(**((void **)this + 1) + 16))(*((void *)this + 1));
    operator new[]();
  }
  Error::chuck((Error *)"TSSATScorer::setModelFile() - init() not called", (const char *)a2);
}

void sub_218470A00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void TSSATScorer::score(TSSATScorer *this, const float *a2, uint64_t a3)
{
  *((unsigned char *)this + 297) = 0;
  if (!*((unsigned char *)this + 296)) {
    Error::chuck((Error *)"TSSATScorer::score() - setModelFile() not called", (const char *)a2);
  }
  uint64_t v4 = *((unsigned int *)this + 66);
  if (v4 != a3) {
    Error::chuck((Error *)"TSSATScorer::score() - supervector size (%d) does not match scorer input size (%d)", (const char *)a2, a3, v4);
  }
  if (!a2) {
    Error::chuck((Error *)"TSSATScorer::score() - NULL supervector pointer", 0);
  }
  uint64_t v5 = *((unsigned int *)this + 67);
  unsigned int v6 = *((_DWORD *)this + 58);
  int v7 = *((_DWORD *)this + 68);
  if (v6 != v7)
  {
    uint64_t v8 = *((void *)this + 28);
    if (v8)
    {
      MEMORY[0x21D46B220](v8, 0x1000C8052888210);
      int v7 = *((_DWORD *)this + 68);
    }
    *((_DWORD *)this + 58) = v7;
    operator new[]();
  }
  if (v6)
  {
    uint64_t v9 = *((void *)this + 28);
    uint64_t v10 = v6;
    if (v6 < 8 || (unint64_t)(v9 - (void)a2 - 4 * v5) < 0x20)
    {
      uint64_t v11 = 0;
LABEL_12:
      uint64_t v12 = v10 - v11;
      uint64_t v13 = v11;
      uint64_t v14 = (_DWORD *)(v9 + v13 * 4);
      uint64_t v15 = &a2[v5 + v13];
      do
      {
        int v16 = *(_DWORD *)v15++;
        *v14++ = v16;
        --v12;
      }
      while (v12);
      goto LABEL_14;
    }
    uint64_t v11 = v6 & 0xFFFFFFF8;
    uint64_t v28 = (_OWORD *)(v9 + 16);
    unsigned int v29 = &a2[v5 + 4];
    uint64_t v30 = v10 & 0xFFFFFFF8;
    do
    {
      long long v31 = *(_OWORD *)v29;
      *(v28 - 1) = *((_OWORD *)v29 - 1);
      *uint64_t v28 = v31;
      v28 += 2;
      v29 += 8;
      v30 -= 8;
    }
    while (v30);
    if (v11 != v10) {
      goto LABEL_12;
    }
  }
LABEL_14:
  if (!*((unsigned char *)this + 293)) {
    goto LABEL_35;
  }
  uint64_t v17 = *((unsigned int *)this + 58);
  if (!v17) {
    goto LABEL_35;
  }
  uint64_t v18 = (float32x4_t *)*((void *)this + 28);
  if (v17 == 1)
  {
    uint64_t v19 = 0;
    float v20 = 0.0;
  }
  else
  {
    uint64_t v19 = v17 & 0xFFFFFFFE;
    uint64_t v21 = &v18->f32[1];
    float v20 = 0.0;
    uint64_t v22 = v19;
    do
    {
      float v20 = (float)(v20 + (float)(*(v21 - 1) * *(v21 - 1))) + (float)(*v21 * *v21);
      v21 += 2;
      v22 -= 2;
    }
    while (v22);
    if (v19 == v17) {
      goto LABEL_23;
    }
  }
  uint64_t v23 = v17 - v19;
  float v24 = &v18->f32[v19];
  do
  {
    float v25 = *v24++;
    float v20 = v20 + (float)(v25 * v25);
    --v23;
  }
  while (v23);
LABEL_23:
  if (v20 <= 0.0) {
    goto LABEL_35;
  }
  float v26 = sqrtf((float)v17 / v20);
  if (v17 < 8)
  {
    uint64_t v27 = 0;
LABEL_33:
    uint64_t v35 = v17 - v27;
    char v36 = &v18->f32[v27];
    do
    {
      *char v36 = v26 * *v36;
      ++v36;
      --v35;
    }
    while (v35);
    goto LABEL_35;
  }
  uint64_t v27 = v17 & 0xFFFFFFF8;
  int v32 = v18 + 1;
  uint64_t v33 = v27;
  do
  {
    float32x4_t v34 = vmulq_n_f32(*v32, v26);
    v32[-1] = vmulq_n_f32(v32[-1], v26);
    *int v32 = v34;
    v32 += 2;
    v33 -= 8;
  }
  while (v33);
  if (v27 != v17) {
    goto LABEL_33;
  }
LABEL_35:
  (*(void (**)(void, char *, char *, void))(**((void **)this + 1) + 72))(*((void *)this + 1), (char *)this + 216, (char *)this + 240, 0);
  uint64_t v38 = *((unsigned int *)this + 64);
  if (!v38) {
    goto LABEL_51;
  }
  uint64_t v39 = (float32x4_t *)*((void *)this + 31);
  if (v38 == 1)
  {
    uint64_t v40 = 0;
    v37.n128_u64[0] = 0;
LABEL_41:
    uint64_t v43 = v38 - v40;
    float v44 = &v39->f32[v40];
    do
    {
      float v45 = *v44++;
      v37.n128_f32[0] = v37.n128_f32[0] + (float)(v45 * v45);
      --v43;
    }
    while (v43);
    goto LABEL_43;
  }
  uint64_t v40 = v38 & 0xFFFFFFFE;
  unsigned int v41 = &v39->f32[1];
  v37.n128_u64[0] = 0;
  uint64_t v42 = v40;
  do
  {
    v37.n128_f32[0] = (float)(v37.n128_f32[0] + (float)(*(v41 - 1) * *(v41 - 1))) + (float)(*v41 * *v41);
    v41 += 2;
    v42 -= 2;
  }
  while (v42);
  if (v40 != v38) {
    goto LABEL_41;
  }
LABEL_43:
  if (v37.n128_f32[0] <= 0.0) {
    goto LABEL_51;
  }
  v37.n128_f32[0] = sqrtf((float)v38 / v37.n128_f32[0]);
  if (v38 < 8)
  {
    uint64_t v46 = 0;
LABEL_49:
    uint64_t v50 = v38 - v46;
    uint64_t v51 = &v39->f32[v46];
    do
    {
      *uint64_t v51 = v37.n128_f32[0] * *v51;
      ++v51;
      --v50;
    }
    while (v50);
    goto LABEL_51;
  }
  uint64_t v46 = v38 & 0xFFFFFFF8;
  uint64_t v47 = v39 + 1;
  uint64_t v48 = v46;
  do
  {
    float32x4_t v49 = vmulq_n_f32(*v47, v37.n128_f32[0]);
    v47[-1] = vmulq_n_f32(v47[-1], v37.n128_f32[0]);
    *uint64_t v47 = v49;
    v47 += 2;
    v48 -= 8;
  }
  while (v48);
  if (v46 != v38) {
    goto LABEL_49;
  }
LABEL_51:
  __int32 v52 = 1065353216;
  unsigned __int32 v53 = 0;
  if (*((unsigned char *)this + 292)) {
    NSATImpostor::score((uint64_t)this + 16, (uint64_t)this + 240, &v53, &v52, v37);
  }
  NSATSpeaker::score((uint64_t)this + 88, (uint64_t)this + 240, &v53, &v52, v37);
  *((unsigned char *)this + 297) = 1;
}

void TSSATScorer::normaliseVector(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 16);
  if (!v2) {
    return;
  }
  uint64_t v3 = *(float32x4_t **)(a2 + 8);
  if (v2 == 1)
  {
    uint64_t v4 = 0;
    float v5 = 0.0;
  }
  else
  {
    uint64_t v4 = v2 & 0xFFFFFFFE;
    unsigned int v6 = &v3->f32[1];
    float v5 = 0.0;
    uint64_t v7 = v4;
    do
    {
      float v5 = (float)(v5 + (float)(*(v6 - 1) * *(v6 - 1))) + (float)(*v6 * *v6);
      v6 += 2;
      v7 -= 2;
    }
    while (v7);
    if (v4 == v2) {
      goto LABEL_9;
    }
  }
  uint64_t v8 = v2 - v4;
  uint64_t v9 = &v3->f32[v4];
  do
  {
    float v10 = *v9++;
    float v5 = v5 + (float)(v10 * v10);
    --v8;
  }
  while (v8);
LABEL_9:
  if (v5 <= 0.0) {
    return;
  }
  float v11 = sqrtf((float)v2 / v5);
  if (v2 < 8)
  {
    uint64_t v12 = 0;
LABEL_15:
    uint64_t v16 = v2 - v12;
    uint64_t v17 = &v3->f32[v12];
    do
    {
      *uint64_t v17 = v11 * *v17;
      ++v17;
      --v16;
    }
    while (v16);
    return;
  }
  uint64_t v12 = v2 & 0xFFFFFFF8;
  uint64_t v13 = v3 + 1;
  uint64_t v14 = v12;
  do
  {
    float32x4_t v15 = vmulq_n_f32(*v13, v11);
    v13[-1] = vmulq_n_f32(v13[-1], v11);
    *uint64_t v13 = v15;
    v13 += 2;
    v14 -= 8;
  }
  while (v14);
  if (v12 != v2) {
    goto LABEL_15;
  }
}

uint64_t TSSATScorer::applyTransform(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8), a2, a3, 0);
}

void TSSATScorer::scoreTransformed(TSSATScorer *this, __n128 a2)
{
  __int32 v3 = 1065353216;
  unsigned __int32 v4 = 0;
  if (*((unsigned char *)this + 292)) {
    NSATImpostor::score((uint64_t)this + 16, (uint64_t)this + 240, &v4, &v3, a2);
  }
  NSATSpeaker::score((uint64_t)this + 88, (uint64_t)this + 240, &v4, &v3, a2);
  *((unsigned char *)this + 297) = 1;
}

void TSSATScorer::scoreSpeakerVector(TSSATScorer *this, const float *a2, uint64_t a3)
{
  *((unsigned char *)this + 297) = 0;
  if (!*((unsigned char *)this + 296)) {
    Error::chuck((Error *)"TSSATScorer::scorespeakervector() - setModelFile() not called", (const char *)a2);
  }
  if ((*(unsigned int (**)(void))(**((void **)this + 1) + 16))(*((void *)this + 1)) != a3)
  {
    uint64_t v20 = (*(uint64_t (**)(void))(**((void **)this + 1) + 16))(*((void *)this + 1));
    Error::chuck((Error *)"TSSATScorer::scorespeakervector() - speakervector size (%d) does not match scorer transform size (%d)", v21, a3, v20);
  }
  if (!a2) {
    Error::chuck((Error *)"TSSATScorer::score() - NULL supervector pointer", v6);
  }
  if (*((_DWORD *)this + 64) != a3)
  {
    uint64_t v8 = *((void *)this + 31);
    if (v8) {
      MEMORY[0x21D46B220](v8, 0x1000C8052888210);
    }
    *((_DWORD *)this + 64) = a3;
    operator new[]();
  }
  if (a3)
  {
    uint64_t v9 = 0;
    uint64_t v10 = *((void *)this + 31);
    if (a3 < 8) {
      goto LABEL_14;
    }
    if ((unint64_t)(v10 - (void)a2) < 0x20) {
      goto LABEL_14;
    }
    uint64_t v9 = a3 & 0xFFFFFFF8;
    float v11 = (_OWORD *)(v10 + 16);
    uint64_t v12 = a2 + 4;
    uint64_t v13 = v9;
    do
    {
      __n128 v7 = *(__n128 *)(v12 - 4);
      long long v14 = *(_OWORD *)v12;
      *(v11 - 1) = v7;
      *float v11 = v14;
      v11 += 2;
      v12 += 8;
      v13 -= 8;
    }
    while (v13);
    if (v9 != a3)
    {
LABEL_14:
      uint64_t v15 = a3 - v9;
      uint64_t v16 = v9;
      uint64_t v17 = (unsigned __int32 *)(v10 + v16 * 4);
      uint64_t v18 = &a2[v16];
      do
      {
        unsigned __int32 v19 = *(_DWORD *)v18++;
        v7.n128_u32[0] = v19;
        *v17++ = v19;
        --v15;
      }
      while (v15);
    }
  }
  __int32 v22 = 1065353216;
  unsigned __int32 v23 = 0;
  if (*((unsigned char *)this + 292)) {
    NSATImpostor::score((uint64_t)this + 16, (uint64_t)this + 240, &v23, &v22, v7);
  }
  NSATSpeaker::score((uint64_t)this + 88, (uint64_t)this + 240, &v23, &v22, v7);
  *((unsigned char *)this + 297) = 1;
}

unsigned char *TSSATScorer::update(TSSATScorer *this, const char *a2)
{
  if (!*((unsigned char *)this + 297)) {
    Error::chuck((Error *)"TSSATScorer::update() - no valid vector prepared", a2);
  }
  *((unsigned char *)this + 297) = 0;
  __int32 v3 = (TSSATScorer *)((char *)this + 88);
  double result = NSATSpeaker::insert((unsigned char *)this + 88, (uint64_t)this + 240);
  if (*((unsigned char *)this + 166)) {
    NSATSpeaker::write(v3, v5);
  }
  return result;
}

void *TSSATScorer::deleteVector(TSSATScorer *this, const char *a2)
{
  if (!*((unsigned char *)this + 296)) {
    Error::chuck((Error *)"TSSATScorer::deleteVector() - setModelFile() not called", a2);
  }
  __int32 v3 = (TSSATScorer *)((char *)this + 88);
  double result = NSATSpeaker::remove((TSSATScorer *)((char *)this + 88), a2);
  if (*((unsigned char *)this + 166)) {
    NSATSpeaker::write(v3, v5);
  }
  return result;
}

void TSSATScorer::getSpeakerVector(uint64_t a1, const char *a2, unsigned int *a3)
{
  if (*(unsigned char *)(a1 + 296))
  {
    uint64_t v3 = a1 + 88;
    NSATSpeaker::getVector(v3, a2, a3);
  }
  Error::chuck((Error *)"TSSATScorer::getSuperVector() - setModelFile() not called", a2);
}

uint64_t TSSATScorer::getSpeakerVectorDimen(TSSATScorer *this, const char *a2)
{
  if (!*((unsigned char *)this + 295)) {
    Error::chuck((Error *)"TSSATScorer::setModelFile() - init() not called", a2);
  }
  return *((unsigned int *)this + 64);
}

uint64_t TSSATScorer::vectorCount(TSSATScorer *this)
{
  return *((unsigned int *)this + 31);
}

void TSSATScorer::reset(TSSATScorer *this, const char *a2)
{
  *((unsigned char *)this + 297) = 0;
  NSATSpeaker::reset((TSSATScorer *)((char *)this + 88), a2);
}

void TSSupervectorScorer::~TSSupervectorScorer(TSSupervectorScorer *this)
{
  *(void *)this = &unk_26C99B368;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 1) = 0;
  *((void *)this + 6) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 7);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 3) = &unk_26C99C348;
  uint64_t v4 = *((void *)this + 4);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(void *)this = &unk_26C99B368;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 1) = 0;
  *((void *)this + 6) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 7);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 3) = &unk_26C99C348;
  uint64_t v4 = *((void *)this + 4);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(void *)this = &unk_26C99B368;
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 1) = 0;
  *((void *)this + 6) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 7);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 3) = &unk_26C99C348;
  uint64_t v4 = *((void *)this + 4);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
}

void TSSupervectorScorer::TSSupervectorScorer(TSSupervectorScorer *this)
{
  *(void *)this = &unk_26C99B368;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = &unk_26C99C498;
  *((void *)this + 6) = &unk_26C99C348;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((unsigned char *)this + 72) = 0;
}

{
  *(void *)this = &unk_26C99B368;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = &unk_26C99C498;
  *((void *)this + 6) = &unk_26C99C348;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((unsigned char *)this + 72) = 0;
}

void TSSupervectorScorer::init(TSSupervectorScorer *this, const NString *a2)
{
  if (!*((unsigned char *)this + 72))
  {
    uint64_t v2 = *((void *)this + 1);
    if (v2) {
      (*(void (**)(uint64_t, const NString *))(*(void *)v2 + 8))(v2, a2);
    }
    operator new[]();
  }
  Error::chuck((Error *)"TSSupervectorScorer::init() - init() already called", (const char *)a2);
}

void sub_2184719F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    (*(void (**)(uint64_t))(*(void *)a16 + 8))(a16);
  }
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

float TSSupervectorScorer::score(TSSupervectorScorer *this, const float *a2, uint64_t a3)
{
  if (!*((unsigned char *)this + 72)) {
    Error::chuck((Error *)"TSSupervectorScorer::score() - init() not called", (const char *)a2);
  }
  uint64_t v4 = *((unsigned int *)this + 10);
  if (v4 != a3) {
    Error::chuck((Error *)"TSSupervectorScorer::score() - supervector size (%d) does not match scorer input size (%d)", (const char *)a2, a3, v4);
  }
  if (!a2) {
    Error::chuck((Error *)"TSSupervectorScorer::score() - NULL supervector pointer", 0);
  }
  if (a3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *((void *)this + 4);
    if (a3 < 8) {
      goto LABEL_10;
    }
    if ((unint64_t)(v6 - (void)a2) < 0x20) {
      goto LABEL_10;
    }
    uint64_t v5 = a3 & 0xFFFFFFF8;
    __n128 v7 = (_OWORD *)(v6 + 16);
    uint64_t v8 = a2 + 4;
    uint64_t v9 = v5;
    do
    {
      long long v10 = *(_OWORD *)v8;
      *(v7 - 1) = *((_OWORD *)v8 - 1);
      *__n128 v7 = v10;
      v7 += 2;
      v8 += 8;
      v9 -= 8;
    }
    while (v9);
    if (v5 != a3)
    {
LABEL_10:
      uint64_t v11 = a3 - v5;
      uint64_t v12 = v5;
      uint64_t v13 = (_DWORD *)(v6 + v12 * 4);
      long long v14 = &a2[v12];
      do
      {
        int v15 = *(_DWORD *)v14++;
        *v13++ = v15;
        --v11;
      }
      while (v11);
    }
  }
  (*(void (**)(void, char *, char *, void))(**((void **)this + 1) + 72))(*((void *)this + 1), (char *)this + 24, (char *)this + 48, 0);
  return *(float *)(*((void *)this + 7) + 4 * *((unsigned int *)this + 4));
}

void NSATImpostor::~NSATImpostor(NSATImpostor *this)
{
  *(void *)this = &unk_26C99AA10;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99AA10;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99AA10;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }
}

void NSATImpostor::NSATImpostor(NSATImpostor *this)
{
  *(void *)this = &unk_26C99AA10;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99AA10;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void NSATImpostor::load(NSATImpostor *this, const NString *a2)
{
  *((unsigned char *)this + 64) = 0;
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 1;
  operator new[]();
}

void sub_218472604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  if (a19) {
    MEMORY[0x21D46B220](a19, 0x1000C8052888210);
  }
  if (a23) {
    MEMORY[0x21D46B220](a23, 0x1000C8077774924);
  }
  *(void *)(v23 - 72) = &unk_26C99AA78;
  uint64_t v25 = *(void *)(v23 - 64);
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NSmartPointer<NBaseFile>::setPointer(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  *(void *)(a1 + 8) = a2;
  return result;
}

void NSmartPointer<NBaseFile>::~NSmartPointer(void *a1)
{
  *a1 = &unk_26C99AA78;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x21D46B240);
}

void *NSmartPointer<NBaseFile>::~NSmartPointer(void *a1)
{
  *a1 = &unk_26C99AA78;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void NFilePtr::~NFilePtr(NFilePtr *this)
{
  *(void *)this = &unk_26C99AA78;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99AA78;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

uint64_t NSATImpostor::score(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, __n128 a5)
{
  v61[1] = *MEMORY[0x263EF8340];
  *a3 = 0;
  *a4 = 0;
  if (!*(unsigned char *)(a1 + 64)) {
    Error::chuck((Error *)"NSATImpostor::score() - model not loaded", (const char *)a2);
  }
  uint64_t v5 = *(unsigned int *)(a2 + 16);
  uint64_t v6 = *(unsigned int *)(a1 + 32);
  if (v5 != v6) {
    Error::chuck((Error *)"NSATImpostor::score() - mismatched vector dimension (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v6);
  }
  if (!v5)
  {
    a5.n128_u64[0] = 0;
    goto LABEL_12;
  }
  __n128 v7 = *(float32x4_t **)(a1 + 48);
  uint64_t v8 = *(float32x4_t **)(a2 + 8);
  if (v5 < 8)
  {
    uint64_t v9 = 0;
    a5.n128_u64[0] = 0;
LABEL_10:
    uint64_t v15 = v5 - v9;
    uint64_t v16 = v9;
    uint64_t v17 = &v7->f32[v16];
    uint64_t v18 = &v8->f32[v16];
    do
    {
      float v19 = *v18++;
      float v20 = v19;
      float v21 = *v17++;
      a5.n128_f32[0] = a5.n128_f32[0] + (float)(v20 * v21);
      --v15;
    }
    while (v15);
    goto LABEL_12;
  }
  uint64_t v9 = v5 & 0xFFFFFFF8;
  long long v10 = v7 + 1;
  uint64_t v11 = v8 + 1;
  a5.n128_u64[0] = 0;
  uint64_t v12 = v9;
  do
  {
    float32x4_t v13 = vmulq_f32(v11[-1], v10[-1]);
    float32x4_t v14 = vmulq_f32(*v11, *v10);
    a5.n128_f32[0] = (float)((float)((float)((float)((float)((float)((float)(a5.n128_f32[0] + v13.f32[0]) + v13.f32[1])
                                                           + v13.f32[2])
                                                   + v13.f32[3])
                                           + v14.f32[0])
                                   + v14.f32[1])
                           + v14.f32[2])
                   + v14.f32[3];
    v10 += 2;
    v11 += 2;
    v12 -= 8;
  }
  while (v12);
  if (v9 != v5) {
    goto LABEL_10;
  }
LABEL_12:
  uint64_t result = MEMORY[0x270FA5388](a5);
  unsigned int v29 = (float32x4_t *)((char *)v61 - ((v28 + 15) & 0x7FFFFFFF0));
  uint64_t v30 = *(unsigned int *)(result + 36);
  if (v30)
  {
    if (!v26)
    {
LABEL_35:
      float v48 = 0.0;
      goto LABEL_41;
    }
    uint64_t v31 = *(void *)(result + 56);
    uint64_t v32 = (*(_DWORD *)(result + 40) - v26);
    uint64_t v33 = *(float **)(v23 + 8);
    uint64_t v34 = 4 * (v26 - 1);
    if (v26 >= 8)
    {
      uint64_t v39 = 0;
      uint64_t v40 = v34 + 4 * v32 + 4;
      do
      {
        unint64_t v41 = 0;
        float v42 = 0.0;
        do
        {
          uint64_t result = (uint64_t)&v33[v41 / 4];
          float32x4_t v43 = vmulq_f32(*(float32x4_t *)(v31 + v41), *(float32x4_t *)&v33[v41 / 4]);
          float32x4_t v44 = vmulq_f32(*(float32x4_t *)(v31 + v41 + 16), *(float32x4_t *)&v33[v41 / 4 + 4]);
          float v42 = (float)((float)((float)((float)((float)((float)((float)(v42 + v43.f32[0]) + v43.f32[1]) + v43.f32[2])
                                              + v43.f32[3])
                                      + v44.f32[0])
                              + v44.f32[1])
                      + v44.f32[2])
              + v44.f32[3];
          v41 += 32;
        }
        while (((4 * v26) & 0x3FFFFFFE0) != v41);
        if ((v26 & 0xFFFFFFF8) != v26)
        {
          uint64_t v45 = v26 & 0xFFFFFFF8;
          do
          {
            uint64_t result = 4 * v45;
            float v42 = v42 + (float)(*(float *)(v31 + 4 * v45) * v33[v45]);
            ++v45;
          }
          while (v26 != v45);
        }
        v29->f32[v39++] = v42;
        v31 += v40;
      }
      while (v39 != v30);
    }
    else
    {
      float v35 = *v33;
      char v36 = (float *)(v31 + 12);
      __n128 v37 = (float *)v29;
      do
      {
        float v38 = (float)(*(v36 - 3) * v35) + 0.0;
        if (v26 != 1)
        {
          float v38 = v38 + (float)(*(v36 - 2) * v33[1]);
          if (v26 != 2)
          {
            float v38 = v38 + (float)(*(v36 - 1) * v33[2]);
            if (v26 != 3)
            {
              float v38 = v38 + (float)(*v36 * v33[3]);
              if (v26 != 4)
              {
                float v38 = v38 + (float)(v36[1] * v33[4]);
                if (v26 != 5)
                {
                  float v38 = v38 + (float)(v36[2] * v33[5]);
                  if (v26 != 6) {
                    float v38 = v38 + (float)(v36[3] * v33[6]);
                  }
                }
              }
            }
          }
        }
        *v37++ = v38;
        char v36 = (float *)((char *)v36 + 4 * v32 + v34 + 4);
        --v30;
      }
      while (v30);
    }
  }
  if (!v26) {
    goto LABEL_35;
  }
  uint64_t v46 = *(float32x4_t **)(v23 + 8);
  if (v26 < 8)
  {
    uint64_t v47 = 0;
    float v48 = 0.0;
LABEL_39:
    uint64_t v54 = v26 - v47;
    uint64_t v55 = v47;
    uint64_t v56 = &v29->f32[v55];
    int16x8_t v57 = &v46->f32[v55];
    do
    {
      float v58 = *v57++;
      float v59 = v58;
      float v60 = *v56++;
      float v48 = v48 + (float)(v59 * v60);
      --v54;
    }
    while (v54);
    goto LABEL_41;
  }
  uint64_t v47 = v26 & 0xFFFFFFF8;
  float32x4_t v49 = v29 + 1;
  uint64_t v50 = v46 + 1;
  float v48 = 0.0;
  uint64_t v51 = v47;
  do
  {
    float32x4_t v52 = vmulq_f32(v50[-1], v49[-1]);
    float32x4_t v53 = vmulq_f32(*v50, *v49);
    float v48 = (float)((float)((float)((float)((float)((float)((float)(v48 + v52.f32[0]) + v52.f32[1]) + v52.f32[2])
                                        + v52.f32[3])
                                + v53.f32[0])
                        + v53.f32[1])
                + v53.f32[2])
        + v53.f32[3];
    v49 += 2;
    v50 += 2;
    v51 -= 8;
  }
  while (v51);
  if (v47 != v26) {
    goto LABEL_39;
  }
LABEL_41:
  *float v24 = v27;
  *uint64_t v25 = sqrtf(v48);
  return result;
}

float NSATImpostor::dotproduct(uint64_t a1, uint64_t a2, float32x4_t *a3, unsigned int *a4)
{
  uint64_t v4 = *a4;
  if (!v4) {
    return 0.0;
  }
  uint64_t v5 = *(float32x4_t **)(a2 + 8);
  if (v4 <= 7)
  {
    uint64_t v6 = 0;
    float result = 0.0;
LABEL_8:
    uint64_t v13 = v4 - v6;
    uint64_t v14 = v6;
    uint64_t v15 = &a3->f32[v6];
    uint64_t v16 = &v5->f32[v14];
    do
    {
      float v17 = *v16++;
      float v18 = v17;
      float v19 = *v15++;
      float result = result + (float)(v18 * v19);
      --v13;
    }
    while (v13);
    return result;
  }
  uint64_t v6 = v4 & 0xFFFFFFF8;
  uint64_t v8 = a3 + 1;
  uint64_t v9 = v5 + 1;
  float result = 0.0;
  uint64_t v10 = v6;
  do
  {
    float32x4_t v11 = vmulq_f32(v9[-1], v8[-1]);
    float32x4_t v12 = vmulq_f32(*v9, *v8);
    float result = (float)((float)((float)((float)((float)((float)((float)(result + v11.f32[0]) + v11.f32[1]) + v11.f32[2])
                                           + v11.f32[3])
                                   + v12.f32[0])
                           + v12.f32[1])
                   + v12.f32[2])
           + v12.f32[3];
    v8 += 2;
    v9 += 2;
    v10 -= 8;
  }
  while (v10);
  if (v6 != v4) {
    goto LABEL_8;
  }
  return result;
}

void NSATImpostor::matrixvector(int a1, uint64_t a2, uint64_t a3, float *a4, unsigned int *a5, unsigned int *a6, _DWORD *a7)
{
  uint64_t v7 = *a5;
  if (v7)
  {
    uint64_t v8 = *a6;
    if (v8)
    {
      uint64_t v9 = (*a7 - v8);
      uint64_t v10 = *(float **)(a3 + 8);
      uint64_t v11 = 4 * (v8 - 1);
      if (v8 >= 8)
      {
        uint64_t v14 = 0;
        uint64_t v15 = v11 + 4 * v9 + 4;
        do
        {
          unint64_t v16 = 0;
          float v17 = 0.0;
          do
          {
            float32x4_t v18 = vmulq_f32(*(float32x4_t *)(a2 + v16), *(float32x4_t *)&v10[v16 / 4]);
            float32x4_t v19 = vmulq_f32(*(float32x4_t *)(a2 + v16 + 16), *(float32x4_t *)&v10[v16 / 4 + 4]);
            float v17 = (float)((float)((float)((float)((float)((float)((float)(v17 + v18.f32[0]) + v18.f32[1]) + v18.f32[2])
                                                + v18.f32[3])
                                        + v19.f32[0])
                                + v19.f32[1])
                        + v19.f32[2])
                + v19.f32[3];
            v16 += 32;
          }
          while (((4 * v8) & 0x3FFFFFFE0) != v16);
          if ((v8 & 0xFFFFFFF8) != v8)
          {
            uint64_t v20 = v8 & 0xFFFFFFF8;
            do
            {
              float v17 = v17 + (float)(*(float *)(a2 + 4 * v20) * v10[v20]);
              ++v20;
            }
            while (v8 != v20);
          }
          a4[v14++] = v17;
          a2 += v15;
        }
        while (v14 != v7);
      }
      else
      {
        float32x4_t v12 = (float *)(a2 + 12);
        do
        {
          float v13 = (float)(*(v12 - 3) * *v10) + 0.0;
          if (v8 != 1)
          {
            float v13 = v13 + (float)(*(v12 - 2) * v10[1]);
            if (v8 != 2)
            {
              float v13 = v13 + (float)(*(v12 - 1) * v10[2]);
              if (v8 != 3)
              {
                float v13 = v13 + (float)(*v12 * v10[3]);
                if (v8 != 4)
                {
                  float v13 = v13 + (float)(v12[1] * v10[4]);
                  if (v8 != 5)
                  {
                    float v13 = v13 + (float)(v12[2] * v10[5]);
                    if (v8 != 6) {
                      float v13 = v13 + (float)(v12[3] * v10[6]);
                    }
                  }
                }
              }
            }
          }
          *a4++ = v13;
          float32x4_t v12 = (float *)((char *)v12 + 4 * v9 + v11 + 4);
          --v7;
        }
        while (v7);
      }
    }
    else
    {
      bzero(a4, 4 * v7);
    }
  }
}

uint64_t NSATImpostor::dimen(NSATImpostor *this)
{
  return (uint64_t)this + 32;
}

void NSATSpeaker::~NSATSpeaker(NSATSpeaker *this)
{
  *(void *)this = &unk_26C99A8F0;
  *((void *)this + 13) = &unk_26C99C5B0;
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  *((void *)this + 10) = &unk_26C99C5B0;
  uint64_t v3 = *((void *)this + 12);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 3);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(void *)this = &unk_26C99A8F0;
  *((void *)this + 13) = &unk_26C99C5B0;
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  *((void *)this + 10) = &unk_26C99C5B0;
  uint64_t v3 = *((void *)this + 12);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 3);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(void *)this = &unk_26C99A8F0;
  *((void *)this + 13) = &unk_26C99C5B0;
  uint64_t v2 = *((void *)this + 15);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  *((void *)this + 10) = &unk_26C99C5B0;
  uint64_t v3 = *((void *)this + 12);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 3);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
}

void NSATSpeaker::NSATSpeaker(NSATSpeaker *this)
{
  *(void *)this = &unk_26C99A8F0;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99A8F0;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void sub_21847337C(_Unwind_Exception *exception_object)
{
  v1[10] = v3;
  uint64_t v5 = v1[12];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  v1[1] = v2;
  uint64_t v6 = v1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_218473504(_Unwind_Exception *exception_object)
{
  v1[10] = v3;
  uint64_t v5 = v1[12];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  v1[1] = v2;
  uint64_t v6 = v1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NSATSpeaker::configure(NSATSpeaker *this, const unsigned int *a2, const unsigned int *a3, const BOOL *a4, const BOOL *a5, const BOOL *a6, float *a7, const unsigned int *a8, const NString *a9, const NString *a10)
{
  if ((NSATSpeaker *)((char *)this + 80) != a9) {
    (*(void (**)(char *, void, char *))(*((void *)this + 10) + 64))((char *)this + 80, *((void *)a9 + 2), (char *)a9 + 8);
  }
  if (!*((_DWORD *)a10 + 2)) {
    operator new[]();
  }
  uint64_t result = (uint64_t)this + 104;
  if ((NSATSpeaker *)((char *)this + 104) != a10) {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, char *))(*(void *)result + 64))(result, *((void *)a10 + 2), (char *)a10 + 8);
  }
  *((unsigned char *)this + 73) = *a5;
  float v19 = *a7;
  *((float *)this + 16) = *a7;
  *((unsigned char *)this + 74) = *a6;
  int v20 = 0;
  if (v19 < 0.0 || (int v20 = 1120403456, v19 > 100.0)) {
    *((_DWORD *)this + 16) = v20;
  }
  BOOL v21 = 0;
  *((_DWORD *)this + 17) = *a8;
  int v22 = *a2;
  *((_DWORD *)this + 8) = *a2;
  *((_DWORD *)this + 9) = 0;
  int v23 = *a3;
  *((_DWORD *)this + 10) = *a3;
  *((_DWORD *)this + 11) = (v22 + 3) & 0xFFFFFFFC;
  *((_DWORD *)this + 12) = (v23 + 3) & 0xFFFFFFFC;
  *((unsigned char *)this + 72) = *a4;
  *((unsigned char *)this + 75) = 1;
  *(_WORD *)((char *)this + 77) = 256;
  if (*((_DWORD *)this + 22) >= 7u)
  {
    float v24 = (int *)*((void *)this + 12);
    int v25 = *v24;
    int v26 = *(int *)((char *)v24 + 3);
    BOOL v21 = v25 == 1684957549 && v26 == 980968804;
  }
  *((unsigned char *)this + 76) = v21;
  return result;
}

void sub_2184738F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NSATSpeaker::loadOrInit(NSATSpeaker *this, const char *a2, uint64_t a3, unsigned int *a4)
{
  if (!*((unsigned char *)this + 75)) {
    Error::chuck((Error *)"NSATSpeaker::loadOrInit() - not configured", a2);
  }
  if (!*((unsigned char *)this + 76))
  {
    uint64_t v6 = fopen(*((const char **)this + 12), "r");
    if (v6)
    {
      fclose(v6);
      NSATSpeaker::read(this);
    }
    NSATSpeaker::reset(this, v7);
  }

  return NSATSpeaker::useModelFromMemory(this, (uint64_t)a2, a3, a4);
}

uint64_t NSATSpeaker::useModelFromMemory(NSATSpeaker *this, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  *((unsigned char *)this + 77) = 0;
  LODWORD(v11) = 0;
  uint64_t v10 = 0;
  uint64_t result = NMemoryFile::getMemoryBlockParams((NSATSpeaker *)((char *)this + 80), (const NString *)&v10, (const void **)&v11, a4);
  if ((result & 1) == 0) {
    Error::chuck((Error *)"NSATSpeaker::useModelFromMemory() - %s does not define a memory block", v6, *((void *)this + 12));
  }
  uint64_t v7 = *((unsigned int *)this + 8);
  uint64_t v8 = (v11 / v7) >> 2;
  if (v11 != 4 * (v8 * v7)) {
    Error::chuck((Error *)"NSATSpeaker::useModelFromMemory() - Speaker vector block size (%d) not a multiple of dimen (%d*4)", v6, v11, v7);
  }
  uint64_t v9 = *((unsigned int *)this + 10);
  if (v8 > v9) {
    Error::chuck((Error *)"NSATSpeaker::useModelFromMemory() - Number of speaker vectors (%d) exceeds maximum (%d)", v6, v8, v9);
  }
  *((_DWORD *)this + 9) = v8;
  *((_DWORD *)this + 11) = v7;
  *((_DWORD *)this + 12) = v8;
  *((void *)this + 7) = v10;
  *(_WORD *)((char *)this + 77) = 1;
  return result;
}

void NSATSpeaker::read(NSATSpeaker *this)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  *((unsigned char *)this + 77) = 0;
  uint64_t v1 = &unk_26C99C5B0;
  int v2 = 1;
  operator new[]();
}

void sub_21847407C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8052888210);
  }
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  NFile::~NFile((NFile *)va);
  _Unwind_Resume(a1);
}

void NSATSpeaker::reset(NSATSpeaker *this, const char *a2)
{
  if (*((unsigned char *)this + 75))
  {
    if (!*((unsigned char *)this + 76))
    {
      *((_DWORD *)this + 9) = 0;
      operator new[]();
    }
    Error::chuck((Error *)"NSATSpeaker::reset() - model readonly", a2);
  }
  Error::chuck((Error *)"NSATSpeaker::reset() - not configured", a2);
}

void sub_2184742D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

float NSATSpeaker::score(uint64_t a1, uint64_t a2, unsigned __int32 *a3, __int32 *a4, __n128 a5)
{
  v33[1] = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 77)) {
    Error::chuck((Error *)"NSATSpeaker::score() - model not loaded", (const char *)a2);
  }
  uint64_t v7 = *(unsigned int *)(a1 + 32);
  if (*(_DWORD *)(a2 + 16) != v7) {
    Error::chuck((Error *)"NSATSpeaker::score() - vector wrong size (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v7);
  }
  MEMORY[0x270FA5388](a5);
  uint64_t v10 = (const float *)((char *)v33 - ((v9 + 15) & 0x7FFFFFFF0));
  uint64_t v11 = (NSATSpeaker *)cblas_sgemv_NEWLAPACK_ILP64();
  uint64_t v15 = *(unsigned int *)(a1 + 36);
  if (v15)
  {
    v13.n128_u32[0] = *a3;
    v14.i32[0] = *a4;
    if (v15 <= 7)
    {
      uint64_t v16 = 0;
LABEL_9:
      uint64_t v22 = v15 - v16;
      int v23 = (float *)&v10[v16];
      do
      {
        *int v23 = (float)(*v23 - v13.n128_f32[0]) / *(float *)v14.i32;
        ++v23;
        --v22;
      }
      while (v22);
      goto LABEL_11;
    }
    uint64_t v16 = v15 & 0xFFFFFFF8;
    float32x4_t v17 = (float32x4_t)vdupq_lane_s32((int32x2_t)v13.n128_u64[0], 0);
    float32x4_t v18 = (float32x4_t)vdupq_lane_s32(v14, 0);
    float v19 = (float32x4_t *)(v10 + 4);
    uint64_t v20 = v16;
    do
    {
      float32x4_t v21 = vdivq_f32(vsubq_f32(*v19, v17), v18);
      v19[-1] = vdivq_f32(vsubq_f32(v19[-1], v17), v18);
      float32x4_t *v19 = v21;
      v19 += 2;
      v20 -= 8;
    }
    while (v20);
    if (v16 != v15) {
      goto LABEL_9;
    }
  }
LABEL_11:
  float v24 = (const BOOL *)(a1 + 73);
  if (*(_DWORD *)(a1 + 68)) {
    return NSATSpeaker::findTopNAverage(v11, v10, (const unsigned int *)(a1 + 36), (const unsigned int *)(a1 + 68), v24, (const float *)(a1 + 64), v13);
  }
  if (*v24) {
    return NSATSpeaker::findPercentile(v11, v10, (const unsigned int *)(a1 + 36), (const float *)(a1 + 64), v13);
  }
  if (!v15)
  {
    float v25 = 0.0;
    goto LABEL_25;
  }
  if (v15 == 1)
  {
    uint64_t v26 = 0;
    v13.n128_u64[0] = 0;
  }
  else
  {
    uint64_t v26 = v15 & 0xFFFFFFFE;
    int v27 = (float *)(v10 + 1);
    v13.n128_u64[0] = 0;
    uint64_t v28 = v26;
    do
    {
      v13.n128_f32[0] = (float)(v13.n128_f32[0] + *(v27 - 1)) + *v27;
      v27 += 2;
      v28 -= 2;
    }
    while (v28);
    if (v26 == v15) {
      goto LABEL_24;
    }
  }
  uint64_t v29 = v15 - v26;
  uint64_t v30 = (float *)&v10[v26];
  do
  {
    float v31 = *v30++;
    v13.n128_f32[0] = v13.n128_f32[0] + v31;
    --v29;
  }
  while (v29);
LABEL_24:
  float v25 = v13.n128_f32[0] / (float)v15;
LABEL_25:
  if (*(unsigned char *)(a1 + 74)) {
    return v25 * NSATSpeaker::calcModelNormScale((NSATSpeaker *)a1, v12, v13);
  }
  return v25;
}

float NSATSpeaker::findTopNAverage(NSATSpeaker *this, const float *a2, const unsigned int *a3, const unsigned int *a4, const BOOL *a5, const float *a6, __n128 a7)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (*a3 >= *a4) {
    uint64_t v7 = *a4;
  }
  else {
    uint64_t v7 = *a3;
  }
  unsigned int v32 = v7;
  if (!v7) {
    return 0.0;
  }
  uint64_t v10 = (NSATSpeaker *)MEMORY[0x270FA5388](a7);
  uint64_t v14 = (v13 + 15) & 0x7FFFFFFF0;
  uint64_t v15 = (unsigned __int32 *)&v31[-v14];
  uint64_t v17 = *v16;
  if (v17)
  {
    uint64_t v10 = (NSATSpeaker *)memcpy(&v31[-v14], v11, 4 * v17);
    unsigned int v18 = v17 - 1;
    if (v17 == 1) {
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v18 = -1;
  }
  do
  {
    char v21 = 0;
    v12.n128_u32[0] = *v15;
    uint64_t v22 = v18;
    int v23 = v15 + 1;
    do
    {
      if (v12.n128_f32[0] > *(float *)v23)
      {
        *(v23 - 1) = *v23;
        *int v23 = v12.n128_u32[0];
        char v21 = 1;
      }
      else
      {
        v12.n128_u32[0] = *v23;
      }
      ++v23;
      --v22;
    }
    while (v22);
  }
  while ((v21 & 1) != 0);
LABEL_7:
  uint64_t v19 = (v17 - v7);
  if (*a5) {
    return NSATSpeaker::findPercentile(v10, (const float *)&v15[v19], &v32, a6, v12);
  }
  if (v7 >= 2)
  {
    uint64_t v24 = v7 & 0xFFFFFFFE;
    uint64_t v26 = (float *)&v15[v19 + 1];
    float v25 = 0.0;
    uint64_t v27 = v24;
    do
    {
      float v25 = (float)(v25 + *(v26 - 1)) + *v26;
      v26 += 2;
      v27 -= 2;
    }
    while (v27);
    if (v24 == v7) {
      return v25 / (float)v7;
    }
  }
  else
  {
    uint64_t v24 = 0;
    float v25 = 0.0;
  }
  uint64_t v28 = v7 - v24;
  uint64_t v29 = (float *)&v15[v24 + v19];
  do
  {
    float v30 = *v29++;
    float v25 = v25 + v30;
    --v28;
  }
  while (v28);
  return v25 / (float)v7;
}

float NSATSpeaker::findPercentile(NSATSpeaker *this, const float *a2, const unsigned int *a3, const float *a4, __n128 a5)
{
  v20[1] = *MEMORY[0x263EF8340];
  if (!*a3) {
    return 0.0;
  }
  MEMORY[0x270FA5388](a5);
  uint64_t v8 = (v7 + 15) & 0x7FFFFFFF0;
  uint64_t v9 = (float *)((char *)v20 - v8);
  uint64_t v11 = *v10;
  if (!v11)
  {
    unsigned int v12 = -1;
    do
    {
LABEL_9:
      char v14 = 0;
      float v15 = *v9;
      uint64_t v16 = v12;
      uint64_t v17 = v9 + 1;
      do
      {
        if (v15 > *(float *)v17)
        {
          *(v17 - 1) = *v17;
          *(float *)uint64_t v17 = v15;
          char v14 = 1;
        }
        else
        {
          float v15 = *(float *)v17;
        }
        ++v17;
        --v16;
      }
      while (v16);
    }
    while ((v14 & 1) != 0);
    unsigned int v12 = v11 - 1;
    goto LABEL_15;
  }
  memcpy((char *)v20 - v8, v6, 4 * v11);
  unsigned int v12 = v11 - 1;
  if (v11 != 1) {
    goto LABEL_9;
  }
LABEL_15:
  float v18 = *a4 * 0.01 * (float)v12;
  unsigned int v19 = v18 + 1;
  if (v19 >= v11) {
    return v9[v12];
  }
  else {
    return (float)((float)(v18 - (float)v18) * v9[v19])
  }
         + (1.0 - (float)(v18 - (float)v18)) * v9[v18];
}

float NSATSpeaker::calcModelNormScale(NSATSpeaker *this, const char *a2, __n128 a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)this + 75)) {
    Error::chuck((Error *)"NSATSpeaker::reset() - not configured", a2);
  }
  if (!*((_DWORD *)this + 9)) {
    return 0.0;
  }
  float __C = 0.0;
  MEMORY[0x270FA5388](a3);
  uint64_t v5 = (float *)((char *)&__A - ((v4 + 15) & 0x7FFFFFFF0));
  MEMORY[0x270FA5388](v6);
  uint64_t v8 = (float *)((char *)&__A - ((v7 + 15) & 0x7FFFFFFF0));
  vDSP_Length v9 = *((unsigned int *)this + 9);
  float __A = 1.0 / (float)v9;
  vDSP_vfill(&__A, v5, 1, v9);
  float v10 = 0.0;
  cblas_sgemv_NEWLAPACK_ILP64();
  vDSP_svesq(v8, 1, &__C, *((unsigned int *)this + 8));
  if (__C > 0.0) {
    return sqrtf((float)*((unsigned int *)this + 8) / __C);
  }
  return v10;
}

float NSATSpeaker::findMean(NSATSpeaker *this, const float *a2, const unsigned int *a3)
{
  uint64_t v3 = *a3;
  if (!v3) {
    return 0.0;
  }
  if (v3 == 1)
  {
    uint64_t v4 = 0;
    float v5 = 0.0;
  }
  else
  {
    uint64_t v4 = v3 & 0xFFFFFFFE;
    uint64_t v7 = (float *)(a2 + 1);
    float v5 = 0.0;
    uint64_t v8 = v4;
    do
    {
      float v5 = (float)(v5 + *(v7 - 1)) + *v7;
      v7 += 2;
      v8 -= 2;
    }
    while (v8);
    if (v4 == v3) {
      return v5 / (float)v3;
    }
  }
  uint64_t v9 = v3 - v4;
  float v10 = (float *)&a2[v4];
  do
  {
    float v11 = *v10++;
    float v5 = v5 + v11;
    --v9;
  }
  while (v9);
  return v5 / (float)v3;
}

uint64_t NSATSpeaker::numInserted(NSATSpeaker *this)
{
  return (uint64_t)this + 36;
}

unsigned char *NSATSpeaker::insert(unsigned char *result, uint64_t a2)
{
  if (!result[77]) {
    Error::chuck((Error *)"NSATSpeaker::insert() - model not initialized", (const char *)a2);
  }
  int v2 = result;
  if (result[76]) {
    Error::chuck((Error *)"NSATSpeaker::insert() - model readonly", (const char *)a2);
  }
  uint64_t v3 = *(unsigned int *)(a2 + 16);
  uint64_t v4 = *((unsigned int *)result + 8);
  if (v3 != v4) {
    Error::chuck((Error *)"NSATSpeaker::insert() - vector wrong size (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v4);
  }
  unsigned int v5 = *((_DWORD *)result + 9);
  if (v5 < *((_DWORD *)result + 10))
  {
    if (!*((_DWORD *)result + 4)) {
      Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, 0, 0xFFFFFFFFLL);
    }
    uint64_t result = memcpy((void *)(*((void *)result + 3) + 4 * v5 * *((_DWORD *)result + 11)), *(const void **)(a2 + 8), 4 * v3);
    ++*((_DWORD *)v2 + 9);
    v2[78] = 1;
  }
  return result;
}

void *NSATSpeaker::remove(NSATSpeaker *this, const char *a2)
{
  if (!*((unsigned char *)this + 77)) {
    Error::chuck((Error *)"NSATSpeaker::deleteVector() - model not initialized", a2);
  }
  if (*((unsigned char *)this + 76)) {
    Error::chuck((Error *)"NSATSpeaker::deleteVector() - model readonly", a2);
  }
  int v3 = *(_DWORD *)a2;
  uint64_t v4 = *((unsigned int *)this + 9);
  if (*(_DWORD *)a2 >= v4) {
    Error::chuck((Error *)"NSATSpeaker::deleteVector() - index out of range (%u >= %u)", a2, *(unsigned int *)a2, v4);
  }
  if (!*((_DWORD *)this + 4)) {
    Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, 0, 0xFFFFFFFFLL);
  }
  uint64_t v5 = *((unsigned int *)this + 11);
  __n128 v6 = (char *)(*((void *)this + 3) + 4 * (v3 * v5));
  uint64_t result = memmove(v6, &v6[4 * v5], 4 * ((v4 + ~v3) * v5));
  --*((_DWORD *)this + 9);
  *((unsigned char *)this + 78) = 1;
  return result;
}

void NSATSpeaker::getVector(uint64_t a1, const char *a2, unsigned int *a3)
{
  if (*(unsigned char *)(a1 + 77))
  {
    if (!*(unsigned char *)(a1 + 76))
    {
      uint64_t v3 = *(unsigned int *)(a1 + 36);
      if (*a3 < v3) {
        operator new[]();
      }
      Error::chuck((Error *)"NSATSpeaker::getVector() - index out of range (%u >= %u)", a2, *a3, v3);
    }
    Error::chuck((Error *)"NSATSpeaker::getVector() - model readonly", a2);
  }
  Error::chuck((Error *)"NSATSpeaker::getVector() - model not initialized", a2);
}

void NSATSpeaker::write(NSATSpeaker *this, const char *a2)
{
  if (!*((unsigned char *)this + 76))
  {
    if (*((unsigned char *)this + 77)) {
      operator new[]();
    }
    Error::chuck((Error *)"NSATSpeaker::write() - model not initialized", a2);
  }
  Error::chuck((Error *)"NSATSpeaker::write() - model readonly", a2);
}

void sub_218475400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  NFile::~NFile((NFile *)va);
  _Unwind_Resume(a1);
}

NSATSpeaker *NSATSpeaker::writeIfModified(NSATSpeaker *this, const char *a2)
{
  if (*((unsigned char *)this + 78)) {
    NSATSpeaker::write(this, a2);
  }
  return this;
}

void NSATSpeaker::matrixvector(int a1, uint64_t a2, uint64_t a3, float *a4, unsigned int *a5, unsigned int *a6, _DWORD *a7)
{
  uint64_t v7 = *a5;
  if (v7)
  {
    uint64_t v8 = *a6;
    if (v8)
    {
      uint64_t v9 = (*a7 - v8);
      float v10 = *(float **)(a3 + 8);
      uint64_t v11 = 4 * (v8 - 1);
      if (v8 >= 8)
      {
        uint64_t v14 = 0;
        uint64_t v15 = v11 + 4 * v9 + 4;
        do
        {
          unint64_t v16 = 0;
          float v17 = 0.0;
          do
          {
            float32x4_t v18 = vmulq_f32(*(float32x4_t *)(a2 + v16), *(float32x4_t *)&v10[v16 / 4]);
            float32x4_t v19 = vmulq_f32(*(float32x4_t *)(a2 + v16 + 16), *(float32x4_t *)&v10[v16 / 4 + 4]);
            float v17 = (float)((float)((float)((float)((float)((float)((float)(v17 + v18.f32[0]) + v18.f32[1]) + v18.f32[2])
                                                + v18.f32[3])
                                        + v19.f32[0])
                                + v19.f32[1])
                        + v19.f32[2])
                + v19.f32[3];
            v16 += 32;
          }
          while (((4 * v8) & 0x3FFFFFFE0) != v16);
          if ((v8 & 0xFFFFFFF8) != v8)
          {
            uint64_t v20 = v8 & 0xFFFFFFF8;
            do
            {
              float v17 = v17 + (float)(*(float *)(a2 + 4 * v20) * v10[v20]);
              ++v20;
            }
            while (v8 != v20);
          }
          a4[v14++] = v17;
          a2 += v15;
        }
        while (v14 != v7);
      }
      else
      {
        unsigned int v12 = (float *)(a2 + 12);
        do
        {
          float v13 = (float)(*(v12 - 3) * *v10) + 0.0;
          if (v8 != 1)
          {
            float v13 = v13 + (float)(*(v12 - 2) * v10[1]);
            if (v8 != 2)
            {
              float v13 = v13 + (float)(*(v12 - 1) * v10[2]);
              if (v8 != 3)
              {
                float v13 = v13 + (float)(*v12 * v10[3]);
                if (v8 != 4)
                {
                  float v13 = v13 + (float)(v12[1] * v10[4]);
                  if (v8 != 5)
                  {
                    float v13 = v13 + (float)(v12[2] * v10[5]);
                    if (v8 != 6) {
                      float v13 = v13 + (float)(v12[3] * v10[6]);
                    }
                  }
                }
              }
            }
          }
          *a4++ = v13;
          unsigned int v12 = (float *)((char *)v12 + 4 * v9 + v11 + 4);
          --v7;
        }
        while (v7);
      }
    }
    else
    {
      bzero(a4, 4 * v7);
    }
  }
}

void NSATSpeaker::bubbleSort(NSATSpeaker *this, const float *a2, float *a3, const unsigned int *a4)
{
  uint64_t v4 = *a4;
  if (v4)
  {
    if (v4 >= 8 && (unint64_t)((char *)a3 - (char *)a2) > 0x1F)
    {
      uint64_t v6 = v4 & 0xFFFFFFF8;
      uint64_t v8 = a3 + 4;
      uint64_t v9 = a2 + 4;
      uint64_t v10 = v6;
      do
      {
        long long v11 = *(_OWORD *)v9;
        *((_OWORD *)v8 - 1) = *((_OWORD *)v9 - 1);
        *(_OWORD *)uint64_t v8 = v11;
        v8 += 8;
        v9 += 8;
        v10 -= 8;
      }
      while (v10);
      if (v6 == v4)
      {
LABEL_13:
        unsigned int v7 = v4 - 1;
        if (!v7) {
          return;
        }
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
    uint64_t v12 = v4 - v6;
    uint64_t v13 = v6;
    uint64_t v14 = &a3[v6];
    uint64_t v15 = &a2[v13];
    do
    {
      int v16 = *(_DWORD *)v15++;
      *(_DWORD *)v14++ = v16;
      --v12;
    }
    while (v12);
    goto LABEL_13;
  }
  unsigned int v7 = -1;
  do
  {
LABEL_16:
    char v17 = 0;
    float v18 = *a3;
    uint64_t v19 = v7;
    uint64_t v20 = a3 + 1;
    do
    {
      if (v18 > *v20)
      {
        *(v20 - 1) = *v20;
        *uint64_t v20 = v18;
        char v17 = 1;
      }
      else
      {
        float v18 = *v20;
      }
      ++v20;
      --v19;
    }
    while (v19);
  }
  while ((v17 & 1) != 0);
}

void *createFloatArray(int a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  id v3 = a2;
  int v4 = 4 * a1;
  uint64_t v5 = malloc_type_malloc(4 * a1, 0x94A3413DuLL);
  uint64_t v6 = v5;
  if (v5)
  {
    bzero(v5, v4);
  }
  else
  {
    unsigned int v7 = VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      v9[0] = 67240450;
      v9[1] = v4;
      __int16 v10 = 2114;
      id v11 = v3;
      _os_log_error_impl(&dword_21844F000, v7, OS_LOG_TYPE_ERROR, "could not allocate %{public}d bytes for %{public}@", (uint8_t *)v9, 0x12u);
    }
  }

  return v6;
}

float *fftEnergies(OpaqueFFTSetup *a1, float *a2, int a3)
{
  FloatArray = (float *)createFloatArray(a3, @"complex part zero vec");
  __C.realp = a2;
  __C.imagp = FloatArray;
  long double v7 = log2((double)a3);
  vDSP_fft_zip(a1, &__C, 1, (unint64_t)v7, 1);
  uint64_t v8 = (float *)createFloatArray(a3, @"fft magnitudes array");
  vDSP_Length v9 = a3;
  vDSP_zvmags(&__C, 1, v8, 1, a3);
  int __B = a3;
  __int16 v10 = (float *)createFloatArray(a3, @"sqrt");
  vvsqrtf(v10, v8, &__B);
  id v11 = (float *)createFloatArray(a3, @"normalized fft magnitudes");
  int __B = 0x40000000;
  vDSP_vsmul(v10, 1, (const float *)&__B, v11, 1, v9);
  free(FloatArray);
  free(v8);
  free(v10);
  return v11;
}

uint64_t zeroCrossingVAD(uint64_t a1, int a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  int v4 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67240192;
    int v23 = a2;
    _os_log_impl(&dword_21844F000, v4, OS_LOG_TYPE_INFO, "begin zerocross vad, lentotal = %{public}d", buf, 8u);
  }
  if (a2 >= 1)
  {
    uint64_t v5 = 0;
    int v6 = 0;
    LODWORD(v7) = 0;
    BOOL v8 = 0;
    vDSP_Length v9 = VTLogContextFacilityVoiceTrigger;
    float v10 = 0.0;
    uint64_t v11 = a1;
    do
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67240448;
        int v23 = v5;
        __int16 v24 = 2050;
        double v25 = v10;
        _os_log_impl(&dword_21844F000, v9, OS_LOG_TYPE_INFO, "vad fr = %{public}d, delta=%{public}f", buf, 0x12u);
        vDSP_Length v9 = VTLogContextFacilityVoiceTrigger;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      float v14 = *(float *)(a1 + 4 * v5 + 4);
      float v15 = 3.4028e38;
      float v16 = 1.1755e-38;
      do
      {
        float v17 = v14;
        float v14 = *(float *)(v11 + v12);
        if (v14 < v15) {
          float v15 = *(float *)(v11 + v12);
        }
        if (v14 > v16) {
          float v16 = *(float *)(v11 + v12);
        }
        if (v17 > 0.0 && v14 <= 0.0 || v17 < 0.0 && v14 >= 0.0) {
          ++v13;
        }
        v12 += 4;
      }
      while (v12 != 640);
      float v10 = vabds_f32(v16, v15);
      unsigned int v18 = v13 - 5;
      BOOL v20 = v10 > 200.0 && v18 < 0x1A;
      if (v20)
      {
        if (v8) {
          uint64_t v7 = v7;
        }
        else {
          uint64_t v7 = v5;
        }
        if (v6 > 3) {
          return v7;
        }
        ++v6;
      }
      else
      {
        LODWORD(v7) = 0;
        int v6 = 0;
      }
      v5 += 160;
      v11 += 640;
      BOOL v8 = v20;
    }
    while ((int)v5 < a2);
  }
  return 0xFFFFFFFFLL;
}

float *vecsqrt(const float *a1, int a2)
{
  int v5 = a2;
  FloatArray = (float *)createFloatArray(a2, @"sqrt");
  vvsqrtf(FloatArray, a1, &v5);
  return FloatArray;
}

float countZeroCrossings(float *a1, int a2, float *a3)
{
  if (a2 < 1)
  {
    float v10 = -3.4028e38;
  }
  else
  {
    int v4 = 0;
    uint64_t v5 = a2;
    float v6 = a1[1];
    float v7 = 3.4028e38;
    float v8 = 1.1755e-38;
    do
    {
      float v9 = v6;
      float v6 = *a1;
      if (*a1 < v7) {
        float v7 = *a1;
      }
      if (v6 > v8) {
        float v8 = *a1;
      }
      if (v9 > 0.0 && v6 <= 0.0 || v9 < 0.0 && v6 >= 0.0) {
        ++v4;
      }
      ++a1;
      --v5;
    }
    while (v5);
    float v10 = v8 - v7;
  }
  float result = fabsf(v10);
  *a3 = result;
  return result;
}

float sumsegment(uint64_t a1, int a2, int a3)
{
  if (a3 < 1) {
    return 0.0;
  }
  if (a3 <= 7)
  {
    uint64_t v3 = 0;
    float result = 0.0;
LABEL_8:
    uint64_t v7 = a3 - v3;
    float v8 = (float *)(a1 + 4 * (v3 + a2));
    do
    {
      float v9 = *v8++;
      float result = result + v9;
      --v7;
    }
    while (v7);
    return result;
  }
  uint64_t v3 = a3 & 0x7FFFFFF8;
  uint64_t v5 = a1 + 4 * a2 + 16;
  float result = 0.0;
  uint64_t v6 = a3 & 0xFFFFFFF8;
  do
  {
    float result = (float)((float)((float)((float)((float)((float)((float)(result + COERCE_FLOAT(*(_OWORD *)(v5 - 16)))
                                                           + COERCE_FLOAT(HIDWORD(*(void *)(v5 - 16))))
                                                   + COERCE_FLOAT(*(void *)(v5 - 8)))
                                           + COERCE_FLOAT(HIDWORD(*(_OWORD *)(v5 - 16))))
                                   + COERCE_FLOAT(*(_OWORD *)v5))
                           + COERCE_FLOAT(HIDWORD(*(void *)v5)))
                   + COERCE_FLOAT(*(void *)(v5 + 8)))
           + COERCE_FLOAT(HIDWORD(*(_OWORD *)v5));
    v5 += 32;
    v6 -= 8;
  }
  while (v6);
  if (v3 != a3) {
    goto LABEL_8;
  }
  return result;
}

void NBase64File::openNamed(NBase64File *this, const NString *a2, const NString *a3, const NString *a4)
{
  (*(void (**)(NBase64File *))(*(void *)this + 24))(this);
  if (*((_DWORD *)a4 + 2) == 1 && **((unsigned char **)a4 + 2) == 114)
  {
    *((_DWORD *)this + 17) = 0;
    base64_decode(a3);
  }
  uint64_t v7 = *((void *)a4 + 2);
  if (NString::operator==((uint64_t)a4, "w")) {
    Error::chuck((Error *)"NBase64File::open() - does not support write mode \"%s\"", v8, v7);
  }
  Error::chuck((Error *)"NBase64File::open() - unrecognized file mode \"%s\"", v8, v7);
}

void sub_2184765A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NBase64File::getPosition(NBase64File *this)
{
  if (((*(uint64_t (**)(NBase64File *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NBase64File::getPosition() - cannot get position, file %s is not open", v2, *((void *)this + 3));
  }
  return *((unsigned int *)this + 16);
}

uint64_t NBase64File::setPosition(NBase64File *this, const unsigned int *a2)
{
  if (((*(uint64_t (**)(NBase64File *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NBase64File::getPosition() - cannot set position, file %s is not open", v4, *((void *)this + 3));
  }
  int v5 = *a2;
  if (*a2 > *((_DWORD *)this + 12)) {
    int v5 = -1;
  }
  *((_DWORD *)this + 16) = v5;
  return (*(unsigned int (**)(NBase64File *))(*(void *)this + 40))(this) ^ 1;
}

void NBaseFile::writeLine(NBaseFile *this, const NString *a2)
{
}

void sub_218476824(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NBase64File::write(NBase64File *this, const NString *a2)
{
}

void NBase64File::readString(NBase64File *this, const char *a2)
{
}

void NBase64File::readLine(NBase64File *this@<X0>, uint64_t a2@<X8>)
{
  if ((*(uint64_t (**)(NBase64File *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 17))
    {
      if (((*(uint64_t (**)(NBase64File *))(*(void *)this + 40))(this) & 1) == 0)
      {
        if (*((_DWORD *)this + 16) < *((_DWORD *)this + 12))
        {
          uint64_t v6 = &unk_26C99C5B0;
          int v7 = 1;
          operator new[]();
        }
        *((_DWORD *)this + 16) = -1;
      }
      *(void *)a2 = &unk_26C99C5B0;
      *(_DWORD *)(a2 + 8) = 0;
      operator new[]();
    }
    Error::chuck((Error *)"NBase64File::readLine() - file \"%s\" not opened in read mode", v5, *((void *)this + 3));
  }
  Error::chuck((Error *)"NBase64File::readLine() - file \"%s\" is not open", v5, *((void *)this + 3));
}

void sub_218476E60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  *float v16 = v17;
  uint64_t v19 = v16[2];
  if (v19) {
    MEMORY[0x21D46B220](v19, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NBase64File::read(NBase64File *this, const unsigned int *a2, NString *a3)
{
  if (((*(uint64_t (**)(NBase64File *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NBase64File::read() - file \"%s\" is not open", v6, *((void *)this + 3));
  }
  if (*((_DWORD *)this + 17)) {
    Error::chuck((Error *)"NBase64File::read() - file \"%s\" not opened in read mode", v6, *((void *)this + 3));
  }
  if (*a2 == -1) {
    Error::chuck((Error *)"NBase64File::read() - attempting impossibly long read in file \"%s\"", v6, *((void *)this + 3));
  }
  if ((*(unsigned int (**)(NBase64File *))(*(void *)this + 40))(this))
  {
    int __n_4 = 0;
    (*(void (**)(NString *, int *))(*(void *)a3 + 56))(a3, &__n_4);
    return 0;
  }
  else
  {
    uint64_t v8 = *((unsigned int *)this + 16);
    unsigned int v9 = *a2 + v8;
    BOOL v10 = __CFADD__(*a2, v8);
    unsigned int v11 = *((_DWORD *)this + 12);
    if (v9 > v11) {
      BOOL v10 = 1;
    }
    BOOL v12 = !v10;
    if (v10) {
      int v13 = -1;
    }
    else {
      int v13 = *a2 + v8;
    }
    *((_DWORD *)this + 16) = v13;
    if (!v12) {
      unsigned int v9 = v11;
    }
    unsigned int __n = v9 - v8;
    float v14 = (void *)(*(uint64_t (**)(NString *, unsigned int *))(*(void *)a3 + 56))(a3, &__n);
    memcpy(v14, (const void *)(*((void *)this + 7) + v8), __n);
    return *((unsigned int *)a3 + 2);
  }
}

void NBase64File::read(NBase64File *this@<X0>, const unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  if ((*(uint64_t (**)(NBase64File *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 17))
    {
      if (*a2 != -1)
      {
        if ((*(unsigned int (**)(NBase64File *))(*(void *)this + 40))(this))
        {
          *(void *)a3 = &unk_26C99C5B0;
          *(_DWORD *)(a3 + 8) = 0;
          operator new[]();
        }
        unsigned int v7 = *((_DWORD *)this + 16);
        unsigned int v8 = *a2 + v7;
        BOOL v9 = __CFADD__(*a2, v7);
        unsigned int v11 = *a2 + v7;
        unsigned int v12 = v7;
        *((_DWORD *)this + 16) = v8;
        if (v8 > *((_DWORD *)this + 12) || v9)
        {
          unsigned int v11 = *((_DWORD *)this + 12);
          *((_DWORD *)this + 16) = -1;
        }
        NString::slice((NBase64File *)((char *)this + 40), &v12, &v11, a3);
      }
      Error::chuck((Error *)"NBase64File::read() - attempting impossibly long read in file \"%s\"", v6, *((void *)this + 3));
    }
    Error::chuck((Error *)"NBase64File::read() - file \"%s\" not opened in read mode", v6, *((void *)this + 3));
  }
  Error::chuck((Error *)"NBase64File::read() - file \"%s\" is not open", v6, *((void *)this + 3));
}

void NBase64File::read(NBase64File *this@<X0>, uint64_t a2@<X8>)
{
  if ((*(unsigned int (**)(NBase64File *))(*(void *)this + 40))(this))
  {
    *(void *)a2 = &unk_26C99C5B0;
    *(_DWORD *)(a2 + 8) = 0;
    operator new[]();
  }
  uint64_t v5 = *((unsigned int *)this + 16);
  *((_DWORD *)this + 16) = -1;
  uint64_t v6 = *((unsigned int *)this + 12);
  if (v6 >= v5)
  {
    uint64_t v7 = *((void *)this + 7);
    *(void *)a2 = &unk_26C99C5B0;
    if (v7)
    {
      *(_DWORD *)(a2 + 8) = v6 - v5;
      operator new[]();
    }
    Error::chuck((Error *)"Null pointer passed to string constructor", v4);
  }
  Error::chuck((Error *)"Index %d outside of range [0,%d]", v4, v5, v6);
}

uint64_t NBase64File::good(NBase64File *this)
{
  if ((*(uint64_t (**)(NBase64File *))(*(void *)this + 40))(this)) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(NBase64File *))(*(void *)this + 32);

  return v3(this);
}

BOOL NBase64File::eof(NBase64File *this)
{
  return *((_DWORD *)this + 16) == -1;
}

uint64_t NBase64File::isOpen(NBase64File *this)
{
  return *((unsigned __int8 *)this + 72);
}

uint64_t NBase64File::close(NBase64File *this)
{
  uint64_t v1 = this;
  int v4 = 0;
  (*(void (**)(void))(*((void *)this + 5) + 64))();
  int v5 = 0;
  uint64_t v2 = *((void *)v1 + 1);
  uint64_t v1 = (NBase64File *)((char *)v1 + 8);
  uint64_t result = (*(uint64_t (**)(NBase64File *, const char *, int *))(v2 + 64))(v1, "", &v5);
  *((unsigned char *)v1 + 64) = 0;
  *((_DWORD *)v1 + 14) = 0;
  return result;
}

void NBase64File::open(NBase64File *this, const NString *a2, const NString *a3)
{
  uint64_t v3 = &unk_26C99C5B0;
  int v4 = 17;
  operator new[]();
}

void sub_218477550(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NBase64File::~NBase64File(NBase64File *this)
{
  *(void *)this = &unk_26C99A4E8;
  uint64_t v2 = *((void *)this + 5);
  int v6 = 0;
  (*(void (**)(char *, const char *, int *))(v2 + 64))((char *)this + 40, "", &v6);
  uint64_t v3 = *((void *)this + 1);
  int v7 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 8, "", &v7);
  *((unsigned char *)this + 72) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 5) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 7);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;

  *(void *)this = &unk_26C99A4E8;
  uint64_t v2 = *((void *)this + 5);
  int v6 = 0;
  (*(void (**)(char *, const char *, int *))(v2 + 64))((char *)this + 40, "", &v6);
  uint64_t v3 = *((void *)this + 1);
  int v7 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 8, "", &v7);
  *((unsigned char *)this + 72) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 5) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 7);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;

  *(void *)this = &unk_26C99A4E8;
  uint64_t v2 = *((void *)this + 5);
  int v6 = 0;
  (*(void (**)(char *, const char *, int *))(v2 + 64))((char *)this + 40, "", &v6);
  uint64_t v3 = *((void *)this + 1);
  int v7 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 8, "", &v7);
  *((unsigned char *)this + 72) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 5) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 7);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
}

void NBase64File::NBase64File(NBase64File *this)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void sub_218477964(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v5 = v1[3];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_218477A90(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v5 = v1[3];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NBase64File::NBase64File(NBase64File *this, const NString *a2, const NString *a3)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void sub_218477C00(_Unwind_Exception *exception_object)
{
  v1[5] = v4;
  uint64_t v6 = v1[7];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v7 = v1[3];
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_218477D98(_Unwind_Exception *exception_object)
{
  v1[5] = v4;
  uint64_t v6 = v1[7];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v7 = v1[3];
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NBase64File::NBase64File(NBase64File *this, const NString *a2, const NString *a3, const NString *a4)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void sub_218477F40(_Unwind_Exception *exception_object)
{
  v1[5] = v4;
  uint64_t v6 = v1[7];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v7 = v1[3];
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_2184780E8(_Unwind_Exception *exception_object)
{
  v1[5] = v4;
  uint64_t v6 = v1[7];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v7 = v1[3];
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NLRHMMTraceback::NLRHMMTraceback(NLRHMMTraceback *this, const unsigned int *a2, const unsigned int *a3)
{
}

{
  N2DArray<BOOL>::N2DArray(this);
}

void N2DArray<BOOL>::N2DArray(void *a1)
{
  *a1 = &unk_26C99C268;
  operator new[]();
}

void sub_21847842C(_Unwind_Exception *a1)
{
  NArray<NArray<BOOL>>::~NArray(v1);
  _Unwind_Resume(a1);
}

void N2DArray<BOOL>::~N2DArray(void *a1)
{
  *a1 = &unk_26C99C268;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 24 * v2;
      do
      {
        *(void *)(v1 + v3 - 24) = &unk_26C99C2D8;
        uint64_t v4 = *(void *)(v1 + v3 - 16);
        if (v4) {
          MEMORY[0x21D46B220](v4, 0x1000C8077774924);
        }
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1091C80FBD4B0D6);
  }

  JUMPOUT(0x21D46B240);
}

void *N2DArray<BOOL>::~N2DArray(void *a1)
{
  *a1 = &unk_26C99C268;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 24 * v3;
      do
      {
        *(void *)(v2 + v4 - 24) = &unk_26C99C2D8;
        uint64_t v5 = *(void *)(v2 + v4 - 16);
        if (v5) {
          MEMORY[0x21D46B220](v5, 0x1000C8077774924);
        }
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1091C80FBD4B0D6);
  }
  return a1;
}

uint64_t NLRHMMTraceback::resize(NLRHMMTraceback *this, char *a2, const unsigned int *a3)
{
  if (*((_DWORD *)this + 11)) {
    Error::chuck((Error *)"NLRHMMTraceback::resize() - cannot resize unless empty", a2, a3);
  }
  if (!*(_DWORD *)a2) {
    Error::chuck((Error *)"NLRHMMTraceback::resize() - must be at least 1 frame in buffer", a2, a3);
  }
  *((_DWORD *)this + 5) = *(_DWORD *)a2;
  *((_DWORD *)this + 6) = *a3;
  uint64_t v6 = (char *)this + 24;
  uint64_t result = NArray<NArray<BOOL>>::resize((uint64_t)this, a2);
  if (*((_DWORD *)this + 5))
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, char *))(*(void *)(*((void *)this + 1) + v8) + 32))(*((void *)this + 1) + v8, v6);
      ++v9;
      v8 += 24;
    }
    while (v9 < *((unsigned int *)this + 5));
  }
  *((_DWORD *)this + 8) = *(_DWORD *)a2;
  int v10 = *a3;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 9) = v10;
  return result;
}

uint64_t NLRHMMTraceback::reset(uint64_t this)
{
  *(void *)(this + 40) = 0;
  return this;
}

uint64_t NLRHMMTraceback::drop(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 36);
  if (*(_DWORD *)(a2 + 16) != v2) {
    Error::chuck((Error *)"NLRHMMTraceback::drop() - mismatched number of states (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v2);
  }
  uint64_t v4 = *(void *)(a1 + 8) + 24 * *(unsigned int *)(a1 + 40);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
  int v7 = *(_DWORD *)(a1 + 40);
  unsigned int v6 = *(_DWORD *)(a1 + 44);
  unsigned int v8 = *(_DWORD *)(a1 + 32);
  if (v7 + 1 < v8) {
    int v9 = v7 + 1;
  }
  else {
    int v9 = 0;
  }
  *(_DWORD *)(a1 + 40) = v9;
  if (v6 < v8) {
    *(_DWORD *)(a1 + 44) = v6 + 1;
  }
  return result;
}

uint64_t NLRHMMTraceback::stateAlignment(uint64_t result, uint64_t a2, _DWORD *a3)
{
  unsigned int v3 = *(_DWORD *)(a2 + 16);
  uint64_t v4 = *(unsigned int *)(result + 36);
  if (v3 != v4) {
    Error::chuck((Error *)"NLRHMMTraceback::stateAlignment() - mismatched number of states in duration array (%d != %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v4);
  }
  unsigned int v5 = *(_DWORD *)(result + 44);
  unsigned int v6 = v5 - *a3;
  if (v5 <= *a3)
  {
    if (v3)
    {
      unint64_t v15 = 0;
      uint64_t v16 = *(void *)(a2 + 8);
      do
        *(_DWORD *)(v16 + 4 * v15++) = 0;
      while (v15 < *(unsigned int *)(result + 36));
    }
  }
  else if (v3)
  {
    int v7 = 0;
    unsigned int v8 = v3 - 1;
    unsigned int v9 = *(_DWORD *)(result + 40) + ~*a3;
    int v10 = *(_DWORD *)(result + 32);
    BOOL v11 = __CFADD__(v9, v10);
    unsigned int v12 = v9 + v10;
    if (v11) {
      unsigned int v9 = v12;
    }
    uint64_t v13 = *(void *)(result + 8);
    uint64_t v14 = *(void *)(a2 + 8);
    do
    {
      ++v7;
      if (*(unsigned char *)(*(void *)(v13 + 24 * v9 + 8) + v8))
      {
        *(_DWORD *)(v14 + 4 * v8--) = v7;
        unsigned int v3 = *(_DWORD *)(result + 36);
        if (v8 >= v3) {
          break;
        }
        int v7 = 0;
      }
      if (!v9) {
        unsigned int v9 = *(_DWORD *)(result + 32);
      }
      --v9;
      --v6;
    }
    while (v6);
    if (v8 < v3)
    {
      uint64_t v17 = *(void *)(a2 + 8);
      do
        *(_DWORD *)(v17 + 4 * v8--) = 0;
      while (v8 < *(_DWORD *)(result + 36));
    }
  }
  return result;
}

void NRingDropBuffer::NRingDropBuffer(NRingDropBuffer *this, char *a2)
{
  *(void *)this = &unk_26C99C038;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0;
  if (!*(_DWORD *)a2) {
    Error::chuck((Error *)"NRingDropBuffer::resize() - cannot set size < 1", a2);
  }
  NArray<NFrame>::resize((uint64_t)this, a2);
  *((void *)this + 3) = 0;
}

{
  *(void *)this = &unk_26C99C038;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0;
  if (!*(_DWORD *)a2) {
    Error::chuck((Error *)"NRingDropBuffer::resize() - cannot set size < 1", a2);
  }
  NArray<NFrame>::resize((uint64_t)this, a2);
  *((void *)this + 3) = 0;
}

void sub_21847A028(_Unwind_Exception *a1)
{
  NArray<NFrame>::~NArray(v1);
  _Unwind_Resume(a1);
}

uint64_t NArray<NFrame>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

void *NArray<NFrame>::~NArray(void *a1)
{
  *a1 = &unk_26C99C038;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 24 * v3;
      do
      {
        *(void *)(v2 + v4 - 24) = &unk_26C99C348;
        uint64_t v5 = *(void *)(v2 + v4 - 16);
        if (v5) {
          MEMORY[0x21D46B220](v5, 0x1000C8052888210);
        }
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1081C80622C3295);
  }
  return a1;
}

uint64_t NArray<NFrame>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      uint64_t v8 = *(void *)(v6 - 8);
      if (v8)
      {
        uint64_t v9 = 24 * v8;
        do
        {
          *(void *)(v6 + v9 - 24) = &unk_26C99C348;
          uint64_t v10 = *(void *)(v6 + v9 - 16);
          if (v10) {
            MEMORY[0x21D46B220](v10, 0x1000C8052888210);
          }
          v9 -= 24;
        }
        while (v9);
      }
      MEMORY[0x21D46B220](v6 - 16, 0x1081C80622C3295);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4 && *(void *)(result + 8) != a2)
  {
    unint64_t v11 = 0;
    do
    {
      uint64_t v12 = *(void *)(result + 8);
      if (v12 != a2)
      {
        uint64_t v13 = a2 + 24 * v11;
        uint64_t v14 = v12 + 24 * v11;
        unint64_t v15 = *(unsigned int *)(v14 + 16);
        uint64_t v16 = *(unsigned int *)(v13 + 16);
        if (v15 != v16)
        {
          uint64_t v17 = *(void *)(v14 + 8);
          if (v17)
          {
            MEMORY[0x21D46B220](v17, 0x1000C8052888210);
            LODWORD(v16) = *(_DWORD *)(v13 + 16);
          }
          *(_DWORD *)(v14 + 16) = v16;
          operator new[]();
        }
        if (*(_DWORD *)(v14 + 16))
        {
          uint64_t v18 = 0;
          uint64_t v19 = *(void *)(v13 + 8);
          uint64_t v20 = *(void *)(v14 + 8);
          if (v15 < 8) {
            goto LABEL_25;
          }
          if ((unint64_t)(v20 - v19) < 0x20) {
            goto LABEL_25;
          }
          uint64_t v18 = v15 & 0xFFFFFFF8;
          char v21 = (_OWORD *)(v20 + 16);
          uint64_t v22 = (long long *)(v19 + 16);
          uint64_t v23 = v18;
          do
          {
            long long v24 = *v22;
            *(v21 - 1) = *(v22 - 1);
            *char v21 = v24;
            v21 += 2;
            v22 += 2;
            v23 -= 8;
          }
          while (v23);
          if (v18 != v15)
          {
LABEL_25:
            uint64_t v25 = v15 - v18;
            uint64_t v26 = 4 * v18;
            uint64_t v27 = (_DWORD *)(v20 + v26);
            uint64_t v28 = (int *)(v19 + v26);
            do
            {
              int v29 = *v28++;
              *v27++ = v29;
              --v25;
            }
            while (v25);
          }
        }
      }
      ++v11;
    }
    while (v11 < *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t NArray<NFrame>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 24 * v7;
          do
          {
            *(void *)(v6 + v8 - 24) = &unk_26C99C348;
            uint64_t v9 = *(void *)(v6 + v8 - 16);
            if (v9) {
              MEMORY[0x21D46B220](v9, 0x1000C8052888210);
            }
            v8 -= 24;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x1081C80622C3295);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4 && *(void *)(result + 8) != *(void *)(a2 + 8))
    {
      unint64_t v10 = 0;
      do
      {
        uint64_t v11 = *(void *)(a2 + 8);
        uint64_t v12 = *(void *)(result + 8);
        if (v12 != v11)
        {
          uint64_t v13 = v11 + 24 * v10;
          uint64_t v14 = v12 + 24 * v10;
          unint64_t v15 = *(unsigned int *)(v14 + 16);
          uint64_t v16 = *(unsigned int *)(v13 + 16);
          if (v15 != v16)
          {
            uint64_t v17 = *(void *)(v14 + 8);
            if (v17)
            {
              MEMORY[0x21D46B220](v17, 0x1000C8052888210);
              LODWORD(v16) = *(_DWORD *)(v13 + 16);
            }
            *(_DWORD *)(v14 + 16) = v16;
            operator new[]();
          }
          if (*(_DWORD *)(v14 + 16))
          {
            uint64_t v18 = 0;
            uint64_t v19 = *(void *)(v13 + 8);
            uint64_t v20 = *(void *)(v14 + 8);
            if (v15 < 8) {
              goto LABEL_26;
            }
            if ((unint64_t)(v20 - v19) < 0x20) {
              goto LABEL_26;
            }
            uint64_t v18 = v15 & 0xFFFFFFF8;
            char v21 = (_OWORD *)(v20 + 16);
            uint64_t v22 = (long long *)(v19 + 16);
            uint64_t v23 = v18;
            do
            {
              long long v24 = *v22;
              *(v21 - 1) = *(v22 - 1);
              *char v21 = v24;
              v21 += 2;
              v22 += 2;
              v23 -= 8;
            }
            while (v23);
            if (v18 != v15)
            {
LABEL_26:
              uint64_t v25 = v15 - v18;
              uint64_t v26 = 4 * v18;
              uint64_t v27 = (_DWORD *)(v20 + v26);
              uint64_t v28 = (int *)(v19 + v26);
              do
              {
                int v29 = *v28++;
                *v27++ = v29;
                --v25;
              }
              while (v25);
            }
          }
        }
        ++v10;
      }
      while (v10 < *(unsigned int *)(result + 16));
    }
  }
  return result;
}

void NArray<NFrame>::~NArray(void *a1)
{
  *a1 = &unk_26C99C038;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 24 * v2;
      do
      {
        *(void *)(v1 + v3 - 24) = &unk_26C99C348;
        uint64_t v4 = *(void *)(v1 + v3 - 16);
        if (v4) {
          MEMORY[0x21D46B220](v4, 0x1000C8052888210);
        }
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1081C80622C3295);
  }

  JUMPOUT(0x21D46B240);
}

uint64_t NRingDropBuffer::resize(NRingDropBuffer *this, char *a2)
{
  if (*((_DWORD *)this + 7)) {
    Error::chuck((Error *)"RingDropBuffer::resize() - cannot resize unless empty", a2);
  }
  if (!*(_DWORD *)a2) {
    Error::chuck((Error *)"NRingDropBuffer::resize() - cannot set size < 1", a2);
  }
  uint64_t result = NArray<NFrame>::resize((uint64_t)this, a2);
  *((void *)this + 3) = 0;
  return result;
}

void sub_21847AA34(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1;
  *uint64_t v3 = v2;
  uint64_t v5 = v3[1];
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 - 8);
    if (v6)
    {
      uint64_t v7 = 24 * v6;
      do
      {
        *(void *)(v5 + v7 - 24) = &unk_26C99C348;
        uint64_t v8 = *(void *)(v5 + v7 - 16);
        if (v8) {
          MEMORY[0x21D46B220](v8, 0x1000C8052888210);
        }
        v7 -= 24;
      }
      while (v7);
    }
    MEMORY[0x21D46B220](v5 - 16, 0x1081C80622C3295);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NRingDropBuffer::size(NRingDropBuffer *this)
{
  return (uint64_t)this + 28;
}

uint64_t NRingDropBuffer::reset(uint64_t this)
{
  *(void *)(this + 24) = 0;
  return this;
}

uint64_t NRingDropBuffer::pushFrame(uint64_t this, const NFrame *a2)
{
  uint64_t v2 = *(void *)(this + 8) + 24 * *(unsigned int *)(this + 24);
  if ((const NFrame *)v2 != a2)
  {
    unsigned int v4 = *(_DWORD *)(v2 + 16);
    int v5 = *((_DWORD *)a2 + 4);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(v2 + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *((_DWORD *)a2 + 4);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *((void *)a2 + 1);
      uint64_t v9 = *(void *)(v2 + 8);
      uint64_t v10 = v4;
      if (v4 < 8) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFF8;
      uint64_t v11 = (_OWORD *)(v9 + 16);
      uint64_t v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFF8;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *uint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 4 * v7;
        uint64_t v17 = (_DWORD *)(v9 + v16);
        uint64_t v18 = (int *)(v8 + v16);
        do
        {
          int v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  int v21 = *(_DWORD *)(this + 24);
  unsigned int v20 = *(_DWORD *)(this + 28);
  unsigned int v22 = *(_DWORD *)(this + 16);
  if (v21 + 1 < v22) {
    int v23 = v21 + 1;
  }
  else {
    int v23 = 0;
  }
  *(_DWORD *)(this + 24) = v23;
  if (v20 < v22) {
    *(_DWORD *)(this + 28) = v20 + 1;
  }
  return this;
}

uint64_t NRingDropBuffer::operator[](uint64_t a1, const char *a2)
{
  uint64_t v2 = *(unsigned int *)a2;
  unsigned int v3 = *(_DWORD *)(a1 + 28);
  if (v2 >= v3) {
    Error::chuck((Error *)"NRingDropBuffer[] - out-of-bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 28), v2);
  }
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  unsigned int v5 = *(_DWORD *)(a1 + 24) + v2 + v4 - v3;
  if (v5 >= v4) {
    int v6 = *(_DWORD *)(a1 + 16);
  }
  else {
    int v6 = 0;
  }
  return *(void *)(a1 + 8) + 24 * (v5 - v6);
}

uint64_t NRingDropBuffer::maxSize(NRingDropBuffer *this)
{
  return (uint64_t)this + 16;
}

uint64_t NDelta::init(uint64_t this, const unsigned int *a2, const unsigned int *a3)
{
  int v3 = *a2;
  *(_DWORD *)(this + 4) = *a2;
  int v4 = *a3;
  *(_DWORD *)(this + 8) = *a3;
  float v5 = (double)((v3 + v3 * v3) * ((4 * v3) | 2u)) / 6.0;
  *(float *)(this + 12) = v5;
  if (*(_DWORD *)(this + 40) != v4)
  {
    *(_DWORD *)(this + 40) = v4;
    operator new[]();
  }
  *(unsigned char *)(this + 16) = 0;
  *(unsigned char *)this = 1;
  return this;
}

BOOL NDelta::isFrame(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t a4)
{
  if (!*(unsigned char *)a1) {
    Error::chuck((Error *)"NDelta::isFrame - NDelta::init() has to be called before computing the first frame", (const char *)a2);
  }
  uint64_t v4 = *(unsigned int *)(a2 + 24);
  int v5 = *(_DWORD *)(a1 + 4);
  unsigned int v6 = v5 + 1;
  if (v4 >= v5 + 1)
  {
    if (!v4) {
      Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, a3, *(double *)a4.i64, 0, 0);
    }
    uint64_t v7 = *(void *)(a2 + 8);
    unint64_t v8 = *(unsigned int *)(v7 + 32);
    if (v8 != *(_DWORD *)(a1 + 8)) {
      Error::chuck((Error *)"NDelta::isFrame - head of the list should have %d elements, not %d", (const char *)a2, *(unsigned int *)(a1 + 8), v8);
    }
    if (!v8) {
      goto LABEL_33;
    }
    if (v5)
    {
      unint64_t v9 = 0;
      int v10 = *(_DWORD *)(a1 + 4);
      do
      {
        if (v10)
        {
          int v11 = 0;
          uint64_t v12 = *(unsigned int *)(a2 + 24);
          double v13 = 0.0;
          do
          {
            int v14 = 2 * v10;
            uint64_t v15 = (2 * v10 - v11);
            if ((int)v15 + 1 <= v4)
            {
              if (v15 >= v4) {
                Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, v15, v13, v4, (v14 - v11));
              }
              uint64_t v16 = v7;
              if (v14 != v11)
              {
                uint64_t v16 = v7;
                do
                {
                  uint64_t v16 = *(void *)(v16 + 8);
                  --v14;
                }
                while (v11 != v14);
              }
            }
            else
            {
              uint64_t v16 = v7;
              if (v4 != 1)
              {
                int v17 = v4 - 1;
                uint64_t v16 = v7;
                do
                {
                  uint64_t v16 = *(void *)(v16 + 8);
                  --v17;
                }
                while (v17);
              }
            }
            if (v11 == v12) {
              Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, v16, v13, *(unsigned int *)(a2 + 24), v12);
            }
            int v18 = v11;
            for (uint64_t i = *(void *)(a2 + 8); v18; --v18)
              uint64_t i = *(void *)(i + 8);
            *(float *)&double v13 = *(float *)&v13
                           + (float)((float)(v5 - v11++)
                                   * (float)(*(float *)(*(void *)(i + 24) + 4 * v9)
                                           - *(float *)(*(void *)(v16 + 24) + 4 * v9)));
            int v10 = v5;
          }
          while (v11 != v5);
          int v10 = v5;
        }
        else
        {
          LODWORD(v13) = 0;
        }
        *(float *)(*(void *)(a1 + 32) + 4 * v9++) = *(float *)&v13 / *(float *)(a1 + 12);
      }
      while (v9 < v8);
      goto LABEL_33;
    }
    unsigned int v20 = (unsigned __int32 *)(a1 + 12);
    unint64_t v21 = *(void *)(a1 + 32);
    if (v8 >= 8 && (v21 >= a1 + 16 || (unint64_t)v20 >= v21 + 4 * v8))
    {
      uint64_t v22 = v8 & 0xFFFFFFF8;
      a4.i32[0] = *v20;
      int32x4_t v26 = vdupq_lane_s32((int32x2_t)*(_OWORD *)&vdivq_f32((float32x4_t)0, a4), 0);
      uint64_t v27 = (int32x4_t *)(v21 + 16);
      uint64_t v28 = v22;
      do
      {
        v27[-1] = v26;
        *uint64_t v27 = v26;
        v27 += 2;
        v28 -= 8;
      }
      while (v28);
      if (v22 == v8) {
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v22 = 0;
    }
    uint64_t v23 = v8 - v22;
    long long v24 = (float *)(v21 + 4 * v22);
    do
    {
      *v24++ = 0.0 / *(float *)v20;
      --v23;
    }
    while (v23);
LABEL_33:
    *(unsigned char *)(a1 + 16) = 1;
  }
  return v4 >= v6;
}

uint64_t NDelta::getFrame(NDelta *this, const char *a2)
{
  if (!*((unsigned char *)this + 16)) {
    Error::chuck((Error *)"NDelta::getFrame - called NDelta::getFrame while no available frame", a2);
  }
  return (uint64_t)this + 24;
}

uint64_t NDynamicMFCC::init(NDynamicMFCC *this, const unsigned int *a2, const unsigned int *a3, const unsigned int *a4)
{
  *((_DWORD *)this + 30) = *a4;
  *((_DWORD *)this + 24) = *a2;
  *((_DWORD *)this + 25) = *a3;
  uint64_t result = NDynamicMFCC::reset(this);
  *((unsigned char *)this + 25) = 1;
  return result;
}

uint64_t NDynamicMFCC::reset(NDynamicMFCC *this)
{
  int v3 = (const unsigned int *)((char *)this + 96);
  int v2 = *((_DWORD *)this + 24);
  int v5 = (const unsigned int *)((char *)this + 100);
  int v4 = *((_DWORD *)this + 25);
  *((_DWORD *)this + 28) = v4 + v2;
  *((_DWORD *)this + 29) = v2;
  *((_DWORD *)this + 26) = v2;
  *((_DWORD *)this + 27) = v4;
  NDelta::init((uint64_t)this + 128, (const unsigned int *)this + 24, (const unsigned int *)this + 30);
  uint64_t result = NDelta::init((uint64_t)(v3 + 20), v5, v3 + 6);
  int v7 = 3 * v3[6];
  if (*(v3 - 20) != v7)
  {
    *((_DWORD *)this + 4) = v7;
    operator new[]();
  }
  for (uint64_t i = *((void *)this + 5); i; uint64_t i = *((void *)this + 5))
  {
    *((void *)this + 5) = *(void *)(i + 8);
    uint64_t result = (*(uint64_t (**)(char *))(*((void *)this + 4) + 72))((char *)this + 32);
  }
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  for (uint64_t j = *((void *)this + 9); j; uint64_t j = *((void *)this + 9))
  {
    *((void *)this + 9) = *(void *)(j + 8);
    uint64_t result = (*(uint64_t (**)(char *))(*((void *)this + 8) + 72))((char *)this + 64);
  }
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((unsigned char *)this + 24) = 0;
  return result;
}

BOOL NDynamicMFCC::isFrame(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 25)) {
    Error::chuck((Error *)"NDynamicMFCC::isFrame() - NDynamicMFCC::init() has to be called before starting computing frames", (const char *)a2);
  }
  uint64_t v3 = *(unsigned int *)(a2 + 16);
  if (v3 != *(_DWORD *)(a1 + 120)) {
    Error::chuck((Error *)"NDynamicMFCC::isFrame() - input length should be %d, not %d", (const char *)a2, *(unsigned int *)(a1 + 120), v3);
  }
  int v5 = *(_DWORD *)(a1 + 96);
  int v4 = *(_DWORD *)(a1 + 100);
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 64))(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9) {
    *(void *)(v6 + 8) = v9;
  }
  else {
    *(void *)(a1 + 48) = v6;
  }
  *(void *)(a1 + 40) = v6;
  ++*(_DWORD *)(a1 + 56);
  BOOL result = NDelta::isFrame(a1 + 128, a1 + 32, v7, v8);
  if (result)
  {
    if (!*(unsigned char *)(a1 + 144)) {
      goto LABEL_25;
    }
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 64) + 64))(a1 + 64, a1 + 152);
    uint64_t v15 = *(void *)(a1 + 72);
    if (v15) {
      *(void *)(v12 + 8) = v15;
    }
    else {
      *(void *)(a1 + 80) = v12;
    }
    *(void *)(a1 + 72) = v12;
    ++*(_DWORD *)(a1 + 88);
    BOOL result = NDelta::isFrame(a1 + 176, a1 + 64, v13, v14);
    if (result)
    {
      unsigned int v16 = v4 + 2 * v5 + 1;
      while (*(_DWORD *)(a1 + 56) > v16)
      {
        if (!*(void *)(a1 + 40)) {
LABEL_22:
        }
          Error::chuck((Error *)"NLinkedList::removeTail Attempted to remove tail of empty list", v11);
        (**(void (***)(uint64_t, void))(a1 + 32))(a1 + 32, *(void *)(a1 + 48));
      }
      while (*(_DWORD *)(a1 + 88) > ((2 * v4) | 1u))
      {
        if (!*(void *)(a1 + 72)) {
          goto LABEL_22;
        }
        (**(void (***)(uint64_t, void))(a1 + 64))(a1 + 64, *(void *)(a1 + 80));
      }
      if (*(unsigned char *)(a1 + 192))
      {
        NDynamicMFCC::makeFrame(a1, a1 + 200);
        BOOL result = 1;
        *(unsigned char *)(a1 + 24) = 1;
        return result;
      }
LABEL_25:
      Error::chuck((Error *)"NDelta::getFrame - called NDelta::getFrame while no available frame", v11);
    }
  }
  return result;
}

float NDynamicMFCC::makeFrame(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 120);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(unsigned int *)(a1 + 112);
    uint64_t v5 = *(unsigned int *)(a1 + 56);
    uint64_t v6 = *(void *)(a2 + 8);
    do
    {
      if (v4 >= v5) {
        Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, v5, v4);
      }
      uint64_t v8 = *(void *)(a1 + 40);
      for (int i = v4; i; --i)
        uint64_t v8 = *(void *)(v8 + 8);
      uint64_t v10 = *(void *)(a1 + 8);
      *(_DWORD *)(v10 + 4 * v3) = *(_DWORD *)(*(void *)(v8 + 24) + 4 * v3);
      uint64_t v11 = *(unsigned int *)(a1 + 116);
      if (v11 >= *(_DWORD *)(a1 + 88)) {
        Error::chuck((Error *)"NLinkedList::operator[] List index out of bounds (size = %d, [] = %d)", (const char *)a2, *(unsigned int *)(a1 + 88), v11);
      }
      for (uint64_t j = *(void *)(a1 + 72); v11; LODWORD(v11) = v11 - 1)
        uint64_t j = *(void *)(j + 8);
      *(_DWORD *)(v10 + 4 * (v2 + v3)) = *(_DWORD *)(*(void *)(j + 24) + 4 * v3);
      float result = *(float *)(v6 + 4 * v3);
      *(float *)(v10 + 4 * (2 * v2 + v3++)) = result;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t NDynamicMFCC::finish(NDynamicMFCC *this, const char *a2)
{
  if (!*((unsigned char *)this + 25)) {
    Error::chuck((Error *)"NDynamicMFCC::finish() - NDynamicMFCC::init() has to be called before finishing", a2);
  }
  if (*((_DWORD *)this + 26) && *((unsigned char *)this + 24))
  {
    uint64_t v3 = *((void *)this + 5);
    if (v3)
    {
      uint64_t v4 = (*(uint64_t (**)(char *, uint64_t))(*((void *)this + 4) + 64))((char *)this + 32, v3 + 16);
      uint64_t v7 = *((void *)this + 5);
      if (v7) {
        *(void *)(v4 + 8) = v7;
      }
      else {
        *((void *)this + 6) = v4;
      }
      *((void *)this + 5) = v4;
      ++*((_DWORD *)this + 14);
      NDelta::isFrame((uint64_t)this + 128, (uint64_t)this + 32, v5, v6);
      if (*((unsigned char *)this + 144))
      {
        uint64_t v13 = (*(uint64_t (**)(char *, char *))(*((void *)this + 8) + 64))((char *)this + 64, (char *)this + 152);
        uint64_t v16 = *((void *)this + 9);
        if (v16) {
          *(void *)(v13 + 8) = v16;
        }
        else {
          *((void *)this + 10) = v13;
        }
        *((void *)this + 9) = v13;
        ++*((_DWORD *)this + 22);
        NDelta::isFrame((uint64_t)this + 176, (uint64_t)this + 64, v14, v15);
        if (*((unsigned char *)this + 192))
        {
          NDynamicMFCC::makeFrame((uint64_t)this, (uint64_t)this + 200);
          uint64_t result = 0;
          --*((_DWORD *)this + 26);
          return result;
        }
      }
LABEL_28:
      Error::chuck((Error *)"NDelta::getFrame - called NDelta::getFrame while no available frame", v12);
    }
LABEL_29:
    Error::chuck((Error *)"NLinkedList::head() - cannot access head of empty list", a2);
  }
  if (!*((_DWORD *)this + 27) || !*((unsigned char *)this + 24))
  {
    NDynamicMFCC::reset(this);
    return 1;
  }
  uint64_t v8 = *((void *)this + 5);
  if (!v8) {
    goto LABEL_29;
  }
  uint64_t v9 = (*(uint64_t (**)(char *, uint64_t))(*((void *)this + 4) + 64))((char *)this + 32, v8 + 16);
  uint64_t v10 = *((void *)this + 5);
  if (v10) {
    *(void *)(v9 + 8) = v10;
  }
  else {
    *((void *)this + 6) = v9;
  }
  *((void *)this + 5) = v9;
  ++*((_DWORD *)this + 14);
  uint64_t v17 = *((void *)this + 9);
  if (!v17) {
    goto LABEL_29;
  }
  uint64_t v18 = (*(uint64_t (**)(char *, uint64_t))(*((void *)this + 8) + 64))((char *)this + 64, v17 + 16);
  uint64_t v21 = *((void *)this + 9);
  if (v21) {
    *(void *)(v18 + 8) = v21;
  }
  else {
    *((void *)this + 10) = v18;
  }
  *((void *)this + 9) = v18;
  ++*((_DWORD *)this + 22);
  NDelta::isFrame((uint64_t)this + 176, (uint64_t)this + 64, v19, v20);
  if (!*((unsigned char *)this + 192)) {
    goto LABEL_28;
  }
  NDynamicMFCC::makeFrame((uint64_t)this, (uint64_t)this + 200);
  uint64_t result = 0;
  --*((_DWORD *)this + 27);
  return result;
}

uint64_t NDynamicMFCC::getFrame(uint64_t this, const char *a2)
{
  if (!*(unsigned char *)(this + 24)) {
    Error::chuck((Error *)"NDynamicMFCC::getFrame() - no frame available", a2);
  }
  return this;
}

uint64_t nextPowerOf2(int *a1)
{
  int v1 = *a1;
  uint64_t v2 = 1;
  do
  {
    uint64_t result = v2;
    uint64_t v2 = (2 * v2);
  }
  while ((int)result < v1);
  return result;
}

void AccelMelFilter::init(AccelMelFilter *this, const char *a2, const unsigned int *a3, const unsigned int *a4, const float *a5, const float *a6, const float *a7, const float *a8)
{
  int v8 = *(_DWORD *)a2;
  uint64_t v9 = *a3;
  if (*(_DWORD *)a2 <= v9)
  {
    *(_DWORD *)this = v8;
    *((_DWORD *)this + 1) = *a3;
    *((_DWORD *)this + 2) = *a4;
    if (*((_DWORD *)this + 8) != v8)
    {
      *((_DWORD *)this + 8) = v8;
      operator new[]();
    }
    NArray<NArray<float>>::resize((uint64_t)this + 40, this);
    uint64_t v17 = &unk_26C99C348;
    uint64_t v18 = 0;
    int v19 = 0;
    uint64_t v14 = &unk_26C99C348;
    uint64_t v15 = 0;
    int v16 = 0;
    uint64_t v11 = &unk_26C99C348;
    uint64_t v12 = 0;
    int v13 = 0;
    if (*(_DWORD *)this != -2)
    {
      int v16 = *(_DWORD *)this + 2;
      operator new[]();
    }
    int v13 = -1;
    operator new[]();
  }
  Error::chuck((Error *)"AccelMelFilter::init - NUMCHANS %d > %d spectral samples", a2, *(unsigned int *)a2, v9);
}

void sub_21847BDBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8052888210);
  }
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8052888210);
  }
  if (a19) {
    MEMORY[0x21D46B220](a19, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NArray<NArray<float>>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

void AccelMelFilter::setPoints(unsigned int *a1, const char *a2, float *a3, float *a4, float *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float v15 = *(float *)a2;
  float v16 = 0.0;
  if (*(float *)a2 >= 0.0)
  {
    float v17 = v15 / 700.0 + 1.0;
    float v16 = log10f(v17) * 2595.0;
  }
  float v18 = *a3;
  if (*a3 >= 0.0)
  {
    double v21 = v18;
    uint64_t v19 = a1[2];
    float v20 = (float)v19;
    if ((float)v19 + 1.0 < v18) {
      Error::chuck((Error *)"NMelFilter::setPoints() - HIFREQ %f > NYQUIST %d", a2, v18, a1[2]);
    }
    if (v18 <= v20)
    {
      if (v15 >= v18) {
        Error::chuck((Error *)"NMelFilter::setPoints() - LOFREQ %f >= HIFREQ %f", a2, v15, *(void *)&v21);
      }
    }
    else
    {
      double v21 = (float)v19;
    }
  }
  else
  {
    uint64_t v19 = a1[2];
    float v20 = (float)v19;
    double v21 = (float)v19;
  }
  float v22 = v21 / 700.0 + 1.0;
  float v24 = log10f(v22);
  if (*a5 > v20) {
    Error::chuck((Error *)"NMelFilter::setPoints() - MINBW %f > nyquist %d", v23, *a5, v19);
  }
  float v25 = v24 * 2595.0;
  float v26 = *a4;
  if (*a4 <= 0.0)
  {
LABEL_27:
    float v46 = __exp10f(v25 / 2595.0);
    Error::chuck((Error *)"NMelFilter::setPoints() - freqscale %f -ve or > NYQUIST/HIFREQ (%f/%d)", v47, v26, (float)((float)(v46 + -1.0) * 700.0), a1[2]);
  }
  unsigned int v27 = *a1;
  float v28 = __exp10f(v25 / 2595.0);
  unsigned int v29 = a1[2];
  if ((float)(v26 * (float)((float)(v28 + -1.0) * 700.0)) * 0.98 > (double)v29)
  {
    float v26 = *a4;
    goto LABEL_27;
  }
  if (*a1 == -2)
  {
    float v30 = (float)(*a5 / (float)v29) * (float)a1[1];
    uint64_t v31 = *(void *)(a7 + 8);
    unsigned int v32 = -1;
  }
  else
  {
    unint64_t v33 = 0;
    do
    {
      float v34 = (float)(v25 - v16) / ((float)v27 + 1.0);
      float v35 = __exp10f((float)(v16 + (float)((float)v33 * v34)) / 2595.0);
      float v36 = (float)a1[2];
      float v37 = (float)(*a4 * (float)((float)(v35 + -1.0) * 700.0)) / v36;
      float v38 = (float)a1[1];
      uint64_t v31 = *(void *)(a7 + 8);
      *(float *)(v31 + 4 * v33++) = v37 * v38;
    }
    while (v33 < *a1 + 2);
    unsigned int v32 = *a1 + 1;
    if (v32 < 2) {
      return;
    }
    float v30 = (float)(*a5 / v36) * v38;
  }
  uint64_t v39 = v32;
  uint64_t v40 = (float *)(*(void *)(a6 + 8) + 4);
  unint64_t v41 = (float *)(*(void *)(a8 + 8) + 4);
  uint64_t v42 = v39 - 1;
  float32x4_t v43 = (float *)(v31 + 4);
  do
  {
    *uint64_t v40 = *(v43 - 1);
    float v44 = v43[1];
    *unint64_t v41 = v44;
    float v45 = *v43;
    if ((float)(*v43 - *v40) < v30)
    {
      *uint64_t v40 = v45 - v30;
      float v44 = *v41;
      float v45 = *v43;
    }
    if ((float)(v44 - v45) < v30) {
      *unint64_t v41 = v30 + v45;
    }
    ++v40;
    ++v41;
    ++v43;
    --v42;
  }
  while (v42);
}

unsigned int *AccelMelFilter::setFilters(unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*result)
  {
    uint64_t v7 = result;
    uint64_t v8 = 0;
    __asm { FMOV            V0.4S, #1.0 }
    float32x4_t v66 = _Q0;
    while (1)
    {
      unint64_t v12 = v8 + 1;
      uint64_t v13 = 4 * (v8 + 1);
      float v14 = *(float *)(*(void *)(a2 + 8) + v13);
      float v15 = *(float *)(*(void *)(a3 + 8) + v13);
      float v16 = *(float *)(*(void *)(a4 + 8) + v13);
      uint64_t v17 = (uint64_t)rintf(v14);
      uint64_t v18 = (uint64_t)rintf(v15);
      uint64_t v19 = (uint64_t)rintf(v16);
      int v20 = v17 & ~((int)v17 >> 31);
      int v21 = v7[1] - 1;
      if (v21 >= (int)v19) {
        uint64_t v22 = v19;
      }
      else {
        uint64_t v22 = v21;
      }
      if (v20 > (int)v18 || (int)v22 < (int)v18) {
        Error::chuck((Error *)"AccelMelFilter::setFilters() - point locations out of order %d %d %d", (const char *)a2, v17 & ~((int)v17 >> 31), v18, v22);
      }
      *(_DWORD *)(*((void *)v7 + 3) + 4 * v8) = v20;
      uint64_t v24 = *((void *)v7 + 6) + 24 * v8;
      int v67 = v22 - v20 + 1;
      uint64_t result = (unsigned int *)(*(uint64_t (**)(uint64_t, int *))(*(void *)v24 + 32))(v24, &v67);
      float v27 = (float)(int)v18;
      int v28 = *(_DWORD *)(*((void *)v7 + 3) + 4 * v8);
      LODWORD(v29) = v18 - v17;
      uint64_t v30 = (v28 - v17);
      unsigned int v31 = v15 > (float)(int)v18;
      if (v15 <= (float)(int)v18) {
        uint64_t v29 = v29;
      }
      else {
        uint64_t v29 = (v29 + 1);
      }
      v32.i64[0] = 0x400000004;
      v32.i64[1] = 0x400000004;
      v33.i64[0] = 0x800000008;
      v33.i64[1] = 0x800000008;
      if (v30 >= v29) {
        goto LABEL_24;
      }
      *(float *)v25.i32 = v15 - v14;
      *(float *)v26.i32 = (float)(int)v17 - v14;
      float v34 = *(int8x16_t **)(*((void *)v7 + 6) + 24 * v8 + 8);
      uint64_t v35 = v29 - v30;
      uint64_t v36 = (v28 - v17);
      if ((unint64_t)(v29 - v30) < 8) {
        goto LABEL_20;
      }
      unint64_t v37 = v35 & 0xFFFFFFFFFFFFFFF8;
      int32x4_t v38 = vaddq_s32(vdupq_n_s32(v30), (int32x4_t)xmmword_21852DE50);
      float32x4_t v39 = (float32x4_t)vdupq_lane_s32(v26, 0);
      float32x4_t v40 = (float32x4_t)vdupq_lane_s32(v25, 0);
      unint64_t v41 = v34 + 1;
      unint64_t v42 = v35 & 0xFFFFFFFFFFFFFFF8;
      do
      {
        float32x4_t v43 = vdivq_f32(vaddq_f32(v39, vcvtq_f32_u32((uint32x4_t)v38)), v40);
        float32x4_t v44 = vdivq_f32(vaddq_f32(v39, vcvtq_f32_u32((uint32x4_t)vaddq_s32(v38, v32))), v40);
        v41[-1] = vbicq_s8((int8x16_t)v43, (int8x16_t)vcltzq_f32(v43));
        *unint64_t v41 = vbicq_s8((int8x16_t)v44, (int8x16_t)vcltzq_f32(v44));
        int32x4_t v38 = vaddq_s32(v38, v33);
        v41 += 2;
        v42 -= 8;
      }
      while (v42);
      if (v35 != v37) {
        break;
      }
LABEL_24:
      uint64_t v47 = (v22 - v18 + 1);
      if (v47 > v31)
      {
        *(float *)v25.i32 = v16 - v15;
        *(float *)v26.i32 = v15 - v27;
        uint64_t v48 = v15 > v27;
        uint64_t v49 = *(void *)(*((void *)v7 + 6) + 24 * v8 + 8);
        uint64_t v50 = v47 - v48;
        unint64_t v51 = ~v48 + v47;
        _CF = (unint64_t)(v47 - v48) >= 8 && v28 + ~(v31 + v18) >= v51;
        unint64_t v53 = HIDWORD(v51);
        if (!_CF || v53 != 0) {
          goto LABEL_32;
        }
        unint64_t v57 = v50 & 0xFFFFFFFFFFFFFFF8;
        int32x4_t v58 = vaddq_s32(vdupq_n_s32(v31), (int32x4_t)xmmword_21852DE50);
        float32x4_t v59 = (float32x4_t)vdupq_lane_s32(v26, 0);
        float32x4_t v60 = (float32x4_t)vdupq_lane_s32(v25, 0);
        unsigned int v61 = v31 + v18 - v28;
        unint64_t v62 = v50 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          float32x4_t v63 = vaddq_f32(vdivq_f32(vsubq_f32(v59, vcvtq_f32_u32((uint32x4_t)v58)), v60), v66);
          float32x4_t v64 = vaddq_f32(vdivq_f32(vsubq_f32(v59, vcvtq_f32_u32((uint32x4_t)vaddq_s32(v58, v32))), v60), v66);
          float16x8_t v65 = (int8x16_t *)(v49 + 4 * v61);
          *float16x8_t v65 = vbicq_s8((int8x16_t)v63, (int8x16_t)vcltzq_f32(v63));
          v65[1] = vbicq_s8((int8x16_t)v64, (int8x16_t)vcltzq_f32(v64));
          int32x4_t v58 = vaddq_s32(v58, v33);
          v61 += 8;
          v62 -= 8;
        }
        while (v62);
        if (v50 != v57)
        {
          v48 |= v57;
LABEL_32:
          int v55 = v18 - v28;
          do
          {
            float v56 = (float)((float)(*(float *)v26.i32 - (float)v48) / *(float *)v25.i32) + 1.0;
            if (v56 < 0.0) {
              float v56 = 0.0;
            }
            *(float *)(v49 + 4 * (v55 + v48++)) = v56;
          }
          while (v47 != v48);
        }
      }
      ++v8;
      if (v12 >= *v7) {
        return result;
      }
    }
    uint64_t v36 = v37 + v30;
LABEL_20:
    float v45 = &v34->i8[-4 * v30];
    do
    {
      float v46 = (float)(*(float *)v26.i32 + (float)v36) / *(float *)v25.i32;
      if (v46 < 0.0) {
        float v46 = 0.0;
      }
      *(float *)&v45[4 * v36++] = v46;
    }
    while (v29 != v36);
    goto LABEL_24;
  }
  return result;
}

float AccelMelFilter::freq2mel(AccelMelFilter *this, const float *a2)
{
  float v2 = *a2 / 700.0 + 1.0;
  return log10f(v2) * 2595.0;
}

float AccelMelFilter::mel2freq(AccelMelFilter *this, const float *a2)
{
  return (float)(__exp10f(*a2 / 2595.0) + -1.0) * 700.0;
}

void *AccelMelFilter::run(AccelMelFilter *this, float *a2)
{
  if (!*((unsigned char *)this + 12)) {
    Error::chuck((Error *)"AccelMelFilter::run - AccelMelFilter::init() must be called before running", (const char *)a2);
  }
  if (*(_DWORD *)this)
  {
    unint64_t v4 = 0;
    do
    {
      vDSP_dotpr(&a2[*(unsigned int *)(*((void *)this + 3) + 4 * v4)], 1, *(const float **)(*((void *)this + 6) + 24 * v4 + 8), 1, (float *)(*((void *)this + 9) + 4 * v4), *(unsigned int *)(*((void *)this + 6) + 24 * v4 + 16));
      ++v4;
      unint64_t v5 = *(unsigned int *)this;
    }
    while (v4 < v5);
    size_t v6 = 4 * v5;
  }
  else
  {
    size_t v6 = 0;
  }
  uint64_t v7 = (const void *)*((void *)this + 9);

  return memcpy(a2, v7, v6);
}

float AccelMelFilter::getScalingFactor(AccelMelFilter *this)
{
  return 256.0;
}

void AccelCosine::init(AccelCosine *this, const char *a2, const unsigned int *a3, const unsigned int *a4)
{
  int v4 = *(_DWORD *)a2;
  uint64_t v5 = *a3;
  if (*(_DWORD *)a2) {
    _ZF = v5 == 0;
  }
  else {
    _ZF = 1;
  }
  if (_ZF) {
    Error::chuck((Error *)"AccelCosine::init() - those arguments must be strictly positive : a_iNumChans (=%d), a_iNumCep (=%d)", a2, *(unsigned int *)a2, v5);
  }
  *(_DWORD *)this = v4;
  int v8 = *a3;
  *((_DWORD *)this + 1) = *a3;
  int v9 = *a4;
  *((_DWORD *)this + 10) = v4;
  uint64_t v10 = (char *)this + 40;
  *((_DWORD *)this + 2) = v9;
  *((_DWORD *)this + 9) = v8;
  NArray<NArray<float>>::resize((uint64_t)this + 16, (_DWORD *)this + 1);
  if (*((_DWORD *)v10 - 1))
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    do
    {
      (*(void (**)(uint64_t, char *))(*(void *)(*((void *)this + 3) + v12) + 32))(*((void *)this + 3) + v12, v10);
      ++v13;
      v12 += 24;
    }
    while (v13 < *((unsigned int *)this + 9));
  }
  unsigned int v14 = *((_DWORD *)this + 16);
  int v15 = *((_DWORD *)this + 1);
  if (v14 != v15)
  {
    *((_DWORD *)this + 16) = v15;
    operator new[]();
  }
  unsigned int v54 = *((_DWORD *)this + 16);
  if (v14)
  {
    uint64_t v16 = *(unsigned int *)this;
    if (v16)
    {
      uint64_t v17 = 0;
      float v62 = sqrtf(2.0 / (float)v16);
      uint64_t v19 = *((void *)this + 3);
      __asm
      {
        FMOV            V13.2S, #1.0
        FMOV            V1.2D, #-0.5
      }
      float64x2_t v56 = _Q1;
      do
      {
        float v18 = 3.14159 / (double)v16;
        *(double *)&long long v11 = (float)(v18 * (float)v17);
        uint64_t v25 = *(void *)(v19 + 24 * v17 + 8);
        long long v64 = v11;
        if (v16 >= 2)
        {
          float v27 = *(float32x2_t **)(v19 + 24 * v17 + 8);
          uint64_t v28 = v16 & 0xFFFFFFFE;
          int32x2_t v29 = (int32x2_t)0x100000000;
          do
          {
            float32x2_t v30 = vcvt_f32_f64(vmulq_n_f64(vaddq_f64(vcvtq_f64_f32(vadd_f32(vcvt_f32_u32((uint32x2_t)v29), _D13)), v56), *(double *)&v11));
            float v58 = v30.f32[0];
            float v60 = cosf(v30.f32[1]);
            v31.f32[0] = cosf(v58);
            v31.f32[1] = v60;
            long long v11 = v64;
            *v27++ = vmul_n_f32(v31, v62);
            int32x2_t v29 = vadd_s32(v29, (int32x2_t)0x200000002);
            v28 -= 2;
          }
          while (v28);
          uint64_t v26 = v16 & 0xFFFFFFFE;
          if (v26 == v16) {
            goto LABEL_13;
          }
        }
        else
        {
          uint64_t v26 = 0;
        }
        do
        {
          float v32 = ((float)((float)v26 + 1.0) + -0.5) * *(double *)&v11;
          float v33 = cosf(v32);
          long long v11 = v64;
          *(float *)(v25 + 4 * v26++) = v62 * v33;
        }
        while (v16 != v26);
LABEL_13:
        ++v17;
      }
      while (v17 != v14);
    }
  }
  unsigned int v34 = *((_DWORD *)this + 2);
  uint64_t v35 = (_DWORD *)*((void *)this + 7);
  *uint64_t v35 = 1065354483;
  if (v34)
  {
    unsigned int v36 = v14;
    if (v14 < 2) {
      goto LABEL_32;
    }
    *(double *)&uint64_t v37 = (float)v34;
    uint64_t v38 = v14;
    double v59 = *(double *)&v37 * 0.5;
    uint64_t v61 = v37;
    if (v14 == 2)
    {
      uint64_t v39 = 1;
      goto LABEL_31;
    }
    uint64_t v40 = v14 - 1;
    unint64_t v41 = (v54 - 1) & 0xFFFFFFFFFFFFFFFELL;
    float64x2_t v55 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(double *)&v37 * 0.5), 0);
    float64x2_t v57 = (float64x2_t)vdupq_lane_s64(v37, 0);
    int32x2_t v42 = (int32x2_t)0x200000001;
    float32x4_t v43 = (float32x2_t *)(v35 + 1);
    __asm { FMOV            V0.2D, #1.0 }
    float64x2_t v52 = _Q0;
    float64x2_t v53 = (float64x2_t)vdupq_n_s64(0x400921F9F01B866EuLL);
    unint64_t v45 = (v36 - 1) & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v46.i64[0] = v42.u32[0];
      v46.i64[1] = v42.u32[1];
      float32x2_t v47 = vcvt_f32_f64(vdivq_f64(vmulq_f64(vcvtq_f64_u64(v46), v53), v57));
      float v63 = v47.f32[0];
      float v65 = sinf(v47.f32[1]);
      v48.f32[0] = sinf(v63);
      v48.f32[1] = v65;
      *v43++ = vcvt_f32_f64(vmlaq_f64(v52, vcvtq_f64_f32(v48), v55));
      int32x2_t v42 = vadd_s32(v42, (int32x2_t)0x200000002);
      v45 -= 2;
    }
    while (v45);
    uint64_t v37 = v61;
    if (v40 != v41)
    {
      uint64_t v39 = v40 | 1;
      do
      {
LABEL_31:
        float v49 = (double)v39 * 3.14159 / *(double *)&v37;
        float v50 = sinf(v49);
        uint64_t v37 = v61;
        float v51 = v59 * v50 + 1.0;
        *(float *)&v35[v39++] = v51;
      }
      while (v38 != v39);
    }
  }
  else if (v14 >= 2)
  {
    memset_pattern16(v35 + 1, &unk_21852DED0, 4 * (v14 - 2) + 4);
  }
LABEL_32:
  *((unsigned char *)this + 12) = 1;
}

void AccelCosine::dctCoef(AccelCosine *this, double a2, __n128 a3)
{
  uint64_t v3 = *((unsigned int *)this + 1);
  if (v3)
  {
    uint64_t v4 = *(unsigned int *)this;
    if (v4)
    {
      float v28 = sqrtf(2.0 / (float)v4);
      float v5 = 3.14159 / (double)v4;
      uint64_t v6 = *((void *)this + 3);
      if (v4 >= 2)
      {
        uint64_t v10 = 0;
        __asm
        {
          FMOV            V10.2S, #1.0
          FMOV            V0.2D, #-0.5
        }
        float64x2_t v26 = _Q0;
        do
        {
          a3.n128_f64[0] = (float)(v5 * (float)v10);
          uint64_t v17 = *(float32x2_t **)(v6 + 24 * v10 + 8);
          float v18 = v17;
          uint64_t v19 = v4 & 0xFFFFFFFE;
          int32x2_t v20 = (int32x2_t)0x100000000;
          __n128 v27 = a3;
          do
          {
            float32x2_t v21 = vcvt_f32_f64(vmulq_n_f64(vaddq_f64(vcvtq_f64_f32(vadd_f32(vcvt_f32_u32((uint32x2_t)v20), _D10)), v26), a3.n128_f64[0]));
            float v29 = v21.f32[0];
            float v30 = cosf(v21.f32[1]);
            v22.f32[0] = cosf(v29);
            v22.f32[1] = v30;
            a3 = v27;
            *v18++ = vmul_n_f32(v22, v28);
            int32x2_t v20 = vadd_s32(v20, (int32x2_t)0x200000002);
            v19 -= 2;
          }
          while (v19);
          if ((v4 & 0xFFFFFFFE) != v4)
          {
            uint64_t v23 = v4 & 0xFFFFFFFE;
            do
            {
              float v24 = ((float)((float)v23 + 1.0) + -0.5) * a3.n128_f64[0];
              float v25 = cosf(v24);
              a3 = v27;
              v17->f32[v23++] = v28 * v25;
            }
            while (v4 != v23);
          }
          ++v10;
        }
        while (v10 != v3);
      }
      else
      {
        uint64_t v7 = 0;
        int v8 = (float **)(v6 + 8);
        do
        {
          int v9 = *v8;
          v8 += 3;
          float *v9 = v28 * cosf((float)(v5 * (float)v7++) * 0.5);
        }
        while (v3 != v7);
      }
    }
  }
}

void AccelCosine::lifterCoef(AccelCosine *this)
{
  int v1 = (_DWORD *)*((void *)this + 7);
  *int v1 = 1065354483;
  uint64_t v3 = *((unsigned int *)this + 1);
  unsigned int v2 = *((_DWORD *)this + 2);
  if (v2)
  {
    if (v3 < 2) {
      return;
    }
    *(double *)&uint64_t v4 = (float)v2;
    double v25 = *(double *)&v4 * 0.5;
    uint64_t v26 = v4;
    if (v3 == 2)
    {
      uint64_t v5 = 1;
      goto LABEL_13;
    }
    uint64_t v6 = v3 - 1;
    float64x2_t v23 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(double *)&v4 * 0.5), 0);
    float64x2_t v24 = (float64x2_t)vdupq_lane_s64(v4, 0);
    int32x2_t v7 = (int32x2_t)0x200000001;
    int v8 = (float32x2_t *)(v1 + 1);
    __asm { FMOV            V0.2D, #1.0 }
    float64x2_t v21 = _Q0;
    float64x2_t v22 = (float64x2_t)vdupq_n_s64(0x400921F9F01B866EuLL);
    unint64_t v14 = (v3 - 1) & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      v15.i64[0] = v7.u32[0];
      v15.i64[1] = v7.u32[1];
      float32x2_t v16 = vcvt_f32_f64(vdivq_f64(vmulq_f64(vcvtq_f64_u64(v15), v22), v24));
      float v27 = v16.f32[0];
      float v28 = sinf(v16.f32[1]);
      v17.f32[0] = sinf(v27);
      v17.f32[1] = v28;
      *v8++ = vcvt_f32_f64(vmlaq_f64(v21, vcvtq_f64_f32(v17), v23));
      int32x2_t v7 = vadd_s32(v7, (int32x2_t)0x200000002);
      v14 -= 2;
    }
    while (v14);
    uint64_t v4 = v26;
    if (v6 != ((v3 - 1) & 0xFFFFFFFFFFFFFFFELL))
    {
      uint64_t v5 = v6 | 1;
      do
      {
LABEL_13:
        float v18 = (double)v5 * 3.14159 / *(double *)&v4;
        float v19 = sinf(v18);
        uint64_t v4 = v26;
        float v20 = v25 * v19 + 1.0;
        *(float *)&v1[v5++] = v20;
      }
      while (v3 != v5);
    }
  }
  else if (v3 >= 2)
  {
    memset_pattern16(v1 + 1, &unk_21852DED0, 4 * (v3 - 2) + 4);
  }
}

float AccelCosine::run(unsigned int *a1, float *__A, uint64_t a3)
{
  if (!*((unsigned char *)a1 + 12)) {
    Error::chuck((Error *)"AccelCosine::run() - AccelCosine::init() has to be called before running", (const char *)__A);
  }
  uint64_t v5 = *(unsigned int *)(a3 + 16);
  if (v5 != a1[1]) {
    Error::chuck((Error *)"AccelCosine::run() - length of output should be %d, not %d", (const char *)__A, a1[1], v5);
  }
  if (v5)
  {
    unint64_t v7 = 0;
    uint64_t v8 = 8;
    do
    {
      float __C = 0.0;
      vDSP_dotpr(__A, 1, *(const float **)(*((void *)a1 + 3) + v8), 1, &__C, *a1);
      float result = *(float *)(*((void *)a1 + 7) + 4 * v7) * __C;
      *(float *)(*(void *)(a3 + 8) + 4 * v7++) = result;
      v8 += 24;
    }
    while (v7 < a1[1]);
  }
  return result;
}

uint64_t AccelPSD::init(uint64_t this, const unsigned int *a2, const BOOL *a3)
{
  *(_DWORD *)(this + 8) = *a2;
  *(unsigned char *)(this + 12) = *a3;
  *(_DWORD *)this = 0;
  *(unsigned char *)(this + 4) = 1;
  return this;
}

uint64_t AccelPSD::fixp_sqrt(AccelPSD *this, int a2)
{
  int v2 = a2 > 0x40000000;
  if (a2 <= 0x40000000) {
    int v3 = 0;
  }
  else {
    int v3 = -1073741824;
  }
  int v4 = v3 + a2;
  int v5 = v2 << 16;
  int v6 = (v2 << 30) | 0x10000000;
  int v7 = v6 < v4;
  if (v6 >= v4) {
    int v6 = 0;
  }
  int v8 = v4 - v6;
  unsigned int v9 = v5 | (v7 << 15);
  int v10 = (((v9 >> 15) & 3) << 28) | 0x4000000;
  int v11 = v10 < v8;
  if (v10 >= v8) {
    int v10 = 0;
  }
  int v12 = v8 - v10;
  unsigned int v13 = v9 | (v11 << 14);
  int v14 = (((v13 >> 14) & 7) << 26) | 0x1000000;
  int v15 = v14 < v12;
  if (v14 >= v12) {
    int v14 = 0;
  }
  int v16 = v12 - v14;
  unsigned int v17 = v13 | (v15 << 13);
  int v18 = (((v17 >> 13) & 0xF) << 24) | 0x400000;
  int v19 = v18 < v16;
  if (v18 >= v16) {
    int v18 = 0;
  }
  int v20 = v16 - v18;
  unsigned int v21 = v17 | (v19 << 12);
  int v22 = ((unsigned __int16)(v21 >> 12) << 22) | 0x100000;
  int v23 = v22 < v20;
  if (v22 >= v20) {
    int v22 = 0;
  }
  int v24 = v20 - v22;
  int v25 = v21 | (v23 << 11);
  int v26 = (v25 << 9) | 0x40000;
  int v27 = v26 < v24;
  if (v26 >= v24) {
    int v26 = 0;
  }
  int v28 = v24 - v26;
  int v29 = v25 | (v27 << 10);
  int v30 = (v29 << 8) + 0x10000;
  int v31 = v30 < v28;
  if (v30 >= v28) {
    int v30 = 0;
  }
  int v32 = v28 - v30;
  int v33 = v29 | (v31 << 9);
  int v34 = (v33 << 7) + 0x4000;
  int v35 = v34 < v32;
  if (v34 >= v32) {
    int v34 = 0;
  }
  int v36 = v32 - v34;
  int v37 = v33 | (v35 << 8);
  int v38 = (v37 << 6) + 4096;
  int v39 = v38 < v36;
  if (v38 >= v36) {
    int v38 = 0;
  }
  int v40 = v36 - v38;
  int v41 = v37 | (v39 << 7);
  int v42 = 32 * v41 + 1024;
  int v43 = v42 < v40;
  if (v42 >= v40) {
    int v42 = 0;
  }
  int v44 = v40 - v42;
  int v45 = v41 | (v43 << 6);
  int v46 = 16 * v45 + 256;
  BOOL v47 = v46 < v44;
  if (v46 >= v44) {
    int v46 = 0;
  }
  int v48 = v44 - v46;
  int v49 = v45 | (32 * v47);
  int v50 = 8 * v49 + 64;
  BOOL v51 = v50 < v48;
  if (v50 >= v48) {
    int v50 = 0;
  }
  int v52 = v48 - v50;
  int v53 = v49 | (16 * v51);
  int v54 = 4 * v53 + 16;
  BOOL v55 = v54 < v52;
  if (v54 >= v52) {
    int v54 = 0;
  }
  int v56 = v52 - v54;
  int v57 = v53 | (8 * v55);
  int v58 = 2 * v57 + 4;
  BOOL v59 = v58 < v56;
  if (v58 >= v56) {
    int v58 = 0;
  }
  return (((v57 | (4 * v59)) + 1 < v56 - v58) << 16) | ((v57 | (4 * v59)) << 15);
}

uint64_t AccelPSD::fixp_sqrt_range(AccelPSD *this, const int *a2, const int *a3, int a4, char a5)
{
  int v5 = (*a2 >> 31) & -*a2 | *a2 & ~(*a2 >> 31);
  int v6 = (*a3 >> 31) & -*a3 | *a3 & ~(*a3 >> 31);
  unsigned int v7 = (v5 >> 14) * (v5 >> 14) + (v6 >> 14) * (v6 >> 14);
  if (v7)
  {
    char v8 = -1;
    do
    {
      char v9 = v8++;
      BOOL v10 = v7 > 3;
      v7 >>= 2;
    }
    while (v10);
    char v11 = ~v8;
    int v5 = ((v5 >> v8) + 1) >> 1;
    int v6 = ((v6 >> v8) + 1) >> 1;
    a4 = ((a4 >> (2 * (v9 + 2) - 1)) + 1) >> 1;
  }
  else
  {
    char v11 = 0;
  }
  return ((int)AccelPSD::fixp_sqrt(this, v6 * v6 + v5 * v5 + a4) >> (a5 + v11 + 16));
}

void AccelPSD::run(AccelPSD *this, DSPSplitComplex *__A)
{
  if (!*((unsigned char *)this + 4)) {
    Error::chuck((Error *)"AccelPSD::run() - AccelPSD::init() has to be called before runing", (const char *)__A);
  }
  float __B = 1.0;
  realp = __A->realp;
  imagp = __A->imagp;
  float v6 = *imagp;
  float *imagp = 0.0;
  vDSP_zvmags(__A, 1, realp, 1, (*((_DWORD *)this + 2) - 1));
  unsigned int v7 = __A->realp;
  vDSP_Length v8 = *((unsigned int *)this + 2);
  __A->realp[(v8 - 1)] = v6 * v6;
  vDSP_vsadd(v7, 1, &__B, v7, 1, v8);
  if (!*((unsigned char *)this + 12))
  {
    int v9 = *((_DWORD *)this + 2);
    vvsqrtf(__A->realp, __A->realp, &v9);
  }
}

float AccelPSD::getScalingFactor(AccelPSD *this)
{
  if (*((unsigned char *)this + 12)) {
    char v1 = 2 * *(unsigned char *)this + 16;
  }
  else {
    char v1 = *(_DWORD *)this;
  }
  return 256.0 / (float)(1 << v1);
}

void NWavChunk2HTKFrames::init(NWavChunk2HTKFrames *this, const NString *a2, const unsigned int *a3, const BOOL *a4, const BOOL *a5)
{
  unsigned int v7 = (char *)this + 936;
  vDSP_Length v8 = (NWavChunk2HTKFrames *)((char *)this + 808);
  if ((NWavChunk2HTKFrames *)((char *)this + 808) != a2) {
    (*(void (**)(char *, void, char *, const BOOL *))(*(void *)v8 + 64))((char *)this + 808, *((void *)a2 + 2), (char *)a2 + 8, a4);
  }
  int v9 = 10;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 104) + 64))((char *)this + 832, "MFCC_D_A_0", &v9);
  int v10 = 8;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 107) + 64))((char *)this + 856, "WAVEFORM", &v10);
  int v11 = 3;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 110) + 64))((char *)this + 880, "WAV", &v11);
  *((void *)this + 113) = 0x47C3500000000000;
  *((_WORD *)this + 456) = 0;
  *((_DWORD *)this + 229) = 1243365376;
  *((unsigned char *)this + 920) = 1;
  *((_DWORD *)this + 231) = 1064849900;
  *((_WORD *)this + 464) = 0;
  *((unsigned char *)this + 930) = 0;
  *((_DWORD *)this + 233) = 26;
  *((_DWORD *)this + 238) = 12;
  *((_DWORD *)this + 240) = 22;
  *(void *)(v7 + 28) = 0x3F80000000000000;
  *(_OWORD *)unsigned int v7 = xmmword_21852DE60;
  *((unsigned char *)this + 984) = 1;
  *(void *)(v7 + 52) = 0x200000002;
  *((unsigned char *)this + 801) = 0;
  *((unsigned char *)this + 956) = 1;
  NWavChunk2HTKFrames::loadCfg(this, v8, a5);
}

void NWavChunk2HTKFrames::loadCfg(NWavChunk2HTKFrames *this, const NString *a2, const BOOL *a3)
{
  v6[7] = 0;
  v6[8] = 0;
  v6[6] = &unk_26C99A640;
  int v7 = 0;
  v3[0] = 1;
  NConfig::NConfig((NConfig *)v6, v3);
  int v4 = &unk_26C99C5B0;
  int v5 = 0;
  operator new[]();
}

void sub_21847F1B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  NLinkedList<NString>::~NLinkedList((uint64_t)&a16);
  a23 = a13;
  if (a25) {
    MEMORY[0x21D46B220](a25, 0x1000C8077774924);
  }
  NConfig::~NConfig((NConfig *)&a26);
  NLinkedList<NString>::~NLinkedList(v26 - 120);
  _Unwind_Resume(a1);
}

double NWavChunk2HTKFrames::resetOpt(NWavChunk2HTKFrames *this)
{
  (*(void (**)(void))(*((void *)this + 104) + 64))();
  int v3 = 8;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 107) + 64))((char *)this + 856, "WAVEFORM", &v3);
  int v4 = 3;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 110) + 64))((char *)this + 880, "WAV", &v4);
  *((void *)this + 113) = 0x47C3500000000000;
  *((_WORD *)this + 456) = 0;
  *((_DWORD *)this + 229) = 1243365376;
  *((unsigned char *)this + 920) = 1;
  *((_DWORD *)this + 231) = 1064849900;
  *((_WORD *)this + 464) = 0;
  *((unsigned char *)this + 930) = 0;
  *((_DWORD *)this + 233) = 26;
  *((_DWORD *)this + 238) = 12;
  *((_DWORD *)this + 240) = 22;
  *(void *)((char *)this + 964) = 0x3F80000000000000;
  double result = -0.00781250557;
  *(_OWORD *)((char *)this + 936) = xmmword_21852DE60;
  *((unsigned char *)this + 984) = 1;
  *(void *)((char *)this + 988) = 0x200000002;
  *((unsigned char *)this + 801) = 0;
  *((unsigned char *)this + 956) = 1;
  return result;
}

uint64_t NWavChunk2HTKFrames::changeSamRate(uint64_t this, const char *a2)
{
  unsigned int v2 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2) {
    Error::chuck((Error *)"NWavChunk2HTKFrames::changeSamRate - a_iSampleRate = %d has to be strictly positive", a2, 0);
  }
  *(_DWORD *)(this + 972) = v2;
  *(_DWORD *)(this + 976) = (float)((float)(*(float *)(this + 916) * (float)v2) / 10000000.0);
  unsigned int v3 = (float)((float)(*(float *)(this + 908) * (float)v2) / 10000000.0);
  if (v3 <= 1) {
    unsigned int v3 = 1;
  }
  *(_DWORD *)(this + 980) = v3;
  return this;
}

uint64_t NWavChunk2HTKFrames::initStatic(NWavChunk2HTKFrames *this, double a2)
{
  return AccelStaticMFCC::init((NWavChunk2HTKFrames *)((char *)this + 48), (const char *)this + 980, (unsigned int *)this + 243, (const unsigned int *)this + 244, (const BOOL *)this + 920, (float *)this + 231, (const BOOL *)this + 928, (const BOOL *)this + 929, a2, (const BOOL *)this + 930, (const unsigned int *)this + 233, (const float *)this + 234, (const float *)this + 235, (const unsigned int *)this + 240, (const unsigned int *)this + 238, (const float *)this + 241, (const float *)this + 242, (const float *)this + 236, (const float *)this + 237);
}

uint64_t NWavChunk2HTKFrames::initDyn(NWavChunk2HTKFrames *this)
{
  *((_DWORD *)this + 174) = *((_DWORD *)this + 238);
  *((void *)this + 84) = *(void *)((char *)this + 988);
  uint64_t result = NDynamicMFCC::reset((NWavChunk2HTKFrames *)((char *)this + 576));
  *((unsigned char *)this + 601) = 1;
  return result;
}

uint64_t NWavChunk2HTKFrames::parmCode(NWavChunk2HTKFrames *this)
{
  if (*((unsigned char *)this + 929)) {
    __int16 v1 = 0;
  }
  else {
    __int16 v1 = (3 * *((unsigned char *)this + 801));
  }
  return (unsigned __int16)((v1 + (*((unsigned __int8 *)this + 929) | 6) + 768 * *((unsigned __int8 *)this + 984)) | (*((unsigned __int8 *)this + 956) << 13));
}

uint64_t NWavChunk2HTKFrames::frameSize(NWavChunk2HTKFrames *this)
{
  return *((_DWORD *)this + 238) * ((2 * *((unsigned __int8 *)this + 984)) | 1u);
}

uint64_t NWavChunk2HTKFrames::numStatic(NWavChunk2HTKFrames *this)
{
  return *((unsigned int *)this + 238);
}

uint64_t NWavChunk2HTKFrames::reset(NWavChunk2HTKFrames *this)
{
  *((_DWORD *)this + 32) = 0;
  *((_DWORD *)this + 138) = *((_DWORD *)this + 134) + 1;
  *((void *)this + 70) = 0;
  *((unsigned char *)this + 556) = 0;
  return NDynamicMFCC::reset((NWavChunk2HTKFrames *)((char *)this + 576));
}

uint64_t NWavChunk2HTKFrames::run(uint64_t a1, const char *a2, int *a3, int *a4, uint64_t a5)
{
  if (!*(unsigned char *)(a1 + 800)) {
    Error::chuck((Error *)"NWavChunk2HTKFrames::run - NWavChunk2HTKFrames::init() must be called before running", a2);
  }
  float v6 = (AccelStaticMFCC *)(a1 + 48);
  if (!*(unsigned char *)(a1 + 48)) {
    Error::chuck((Error *)"AccelStaticMFCC::start() - AccelStaticMFCC::init() has to be called before starting", a2);
  }
  if (*(void *)(a1 + 560)) {
    Error::chuck((Error *)"AccelStaticMFCC::start() - frames undrained from previous chunk - call isFrame() or reset()", a2);
  }
  int v8 = *a3;
  if (!a2 && v8) {
    Error::chuck((Error *)"AccelStaticMFCC::start() - pointer to chunk is NULL", 0);
  }
  int v9 = *a4;
  if (*a4 >= 2) {
    Error::chuck((Error *)"NAccelStaticMFCC::start() - unsupported sample type", a2);
  }
  *(void *)(a1 + 560) = a2;
  *(_DWORD *)(a1 + 568) = v8;
  *(_DWORD *)(a1 + 572) = v9;
  *(unsigned char *)(a1 + 556) = 0;
  while (1)
  {
    uint64_t result = AccelStaticMFCC::isFrame(v6, a2);
    if (!result) {
      return result;
    }
    unint64_t v11 = *(unsigned int *)(a1 + 16);
    uint64_t v12 = *(unsigned int *)(a1 + 72);
    if (v11 != v12)
    {
      uint64_t v13 = *(void *)(a1 + 8);
      if (v13)
      {
        MEMORY[0x21D46B220](v13, 0x1000C8052888210);
        LODWORD(v12) = *(_DWORD *)(a1 + 72);
      }
      *(_DWORD *)(a1 + 16) = v12;
      operator new[]();
    }
    if (*(_DWORD *)(a1 + 16))
    {
      uint64_t v14 = 0;
      uint64_t v15 = *(void *)(a1 + 64);
      uint64_t v16 = *(void *)(a1 + 8);
      if (v11 < 8) {
        goto LABEL_20;
      }
      if ((unint64_t)(v16 - v15) < 0x20) {
        goto LABEL_20;
      }
      uint64_t v14 = v11 & 0xFFFFFFF8;
      unsigned int v17 = (_OWORD *)(v16 + 16);
      int v18 = (long long *)(v15 + 16);
      uint64_t v19 = v14;
      do
      {
        long long v20 = *v18;
        *(v17 - 1) = *(v18 - 1);
        *unsigned int v17 = v20;
        v17 += 2;
        v18 += 2;
        v19 -= 8;
      }
      while (v19);
      if (v14 != v11)
      {
LABEL_20:
        uint64_t v21 = v11 - v14;
        uint64_t v22 = 4 * v14;
        int v23 = (_DWORD *)(v16 + v22);
        int v24 = (int *)(v15 + v22);
        do
        {
          int v25 = *v24++;
          *v23++ = v25;
          --v21;
        }
        while (v21);
      }
    }
    if (*(unsigned char *)(a1 + 956) && !*(unsigned char *)(a1 + 801))
    {
      int v39 = *(int **)(a1 + 8);
      int v40 = *v39;
      int v41 = *(_DWORD *)(a1 + 952);
      uint64_t v42 = (v41 - 1);
      if (v41 == 1) {
        uint64_t v42 = 0;
      }
      else {
        memmove(*(void **)(a1 + 8), v39 + 1, 4 * (v41 - 1));
      }
      v39[v42] = v40;
      if (*(unsigned char *)(a1 + 984)) {
        goto LABEL_25;
      }
LABEL_40:
      uint64_t v43 = *(unsigned int *)(a1 + 40);
      if (v43)
      {
        uint64_t v44 = 0;
        uint64_t v45 = *(void *)(a1 + 8);
        uint64_t v46 = *(void *)(a1 + 32);
        if (v43 < 8) {
          goto LABEL_46;
        }
        if ((unint64_t)(v46 - v45) < 0x20) {
          goto LABEL_46;
        }
        uint64_t v44 = v43 & 0xFFFFFFF8;
        BOOL v47 = (_OWORD *)(v46 + 16);
        int v48 = (long long *)(v45 + 16);
        uint64_t v49 = v44;
        do
        {
          long long v50 = *v48;
          *(v47 - 1) = *(v48 - 1);
          *BOOL v47 = v50;
          v47 += 2;
          v48 += 2;
          v49 -= 8;
        }
        while (v49);
        if (v44 != v43)
        {
LABEL_46:
          uint64_t v51 = v43 - v44;
          uint64_t v52 = 4 * v44;
          int v53 = (_DWORD *)(v46 + 4 * v44);
          int v54 = (int *)(v45 + v52);
          do
          {
            int v55 = *v54++;
            *v53++ = v55;
            --v51;
          }
          while (v51);
        }
      }
LABEL_8:
      NResizingQueue<NFrame>::push(a5, a1 + 24);
    }
    else
    {
      if (!*(unsigned char *)(a1 + 984)) {
        goto LABEL_40;
      }
LABEL_25:
      if (NDynamicMFCC::isFrame(a1 + 576, a1))
      {
        if (!*(unsigned char *)(a1 + 600)) {
          Error::chuck((Error *)"NDynamicMFCC::getFrame() - no frame available", a2);
        }
        uint64_t v26 = *(unsigned int *)(a1 + 40);
        if (v26)
        {
          uint64_t v27 = 0;
          uint64_t v28 = *(void *)(a1 + 584);
          uint64_t v29 = *(void *)(a1 + 32);
          if (v26 < 8) {
            goto LABEL_33;
          }
          if ((unint64_t)(v29 - v28) < 0x20) {
            goto LABEL_33;
          }
          uint64_t v27 = v26 & 0xFFFFFFF8;
          int v30 = (_OWORD *)(v29 + 16);
          int v31 = (long long *)(v28 + 16);
          uint64_t v32 = v27;
          do
          {
            long long v33 = *v31;
            *(v30 - 1) = *(v31 - 1);
            *int v30 = v33;
            v30 += 2;
            v31 += 2;
            v32 -= 8;
          }
          while (v32);
          if (v27 != v26)
          {
LABEL_33:
            uint64_t v34 = v26 - v27;
            uint64_t v35 = 4 * v27;
            int v36 = (_DWORD *)(v29 + 4 * v27);
            int v37 = (int *)(v28 + v35);
            do
            {
              int v38 = *v37++;
              *v36++ = v38;
              --v34;
            }
            while (v34);
          }
        }
        goto LABEL_8;
      }
    }
  }
}

uint64_t NResizingQueue<NFrame>::push(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(result + 68)) {
    Error::chuck((Error *)"NResizingQueue::push() - tried pushing a new element after NResizingQueue::finish() has been called", (const char *)a2);
  }
  uint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(result + 64);
  if (*(_DWORD *)(result + 56) - *(_DWORD *)(result + 60) >= v4 - 2)
  {
    unsigned int v5 = (float)(*(float *)(result + 76) * (float)v4);
    if (v5 <= 1) {
      unsigned int v5 = 1;
    }
    unsigned int v23 = v5;
    uint64_t result = NResizingQueue<NFrame>::enlargeBy(result, (int *)&v23);
  }
  uint64_t v6 = *(void *)(v3 + 40);
  if (v6 + 16 != a2)
  {
    unsigned int v7 = *(_DWORD *)(v6 + 32);
    int v8 = *(_DWORD *)(a2 + 16);
    if (v7 != v8)
    {
      uint64_t v9 = *(void *)(v6 + 24);
      if (v9)
      {
        MEMORY[0x21D46B220](v9, 0x1000C8052888210);
        int v8 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v6 + 32) = v8;
      operator new[]();
    }
    if (v7)
    {
      uint64_t v10 = 0;
      uint64_t v11 = *(void *)(a2 + 8);
      uint64_t v12 = *(void *)(v6 + 24);
      uint64_t v13 = v7;
      if (v7 < 8) {
        goto LABEL_17;
      }
      if ((unint64_t)(v12 - v11) < 0x20) {
        goto LABEL_17;
      }
      uint64_t v10 = v7 & 0xFFFFFFF8;
      uint64_t v14 = (_OWORD *)(v12 + 16);
      uint64_t v15 = (long long *)(v11 + 16);
      uint64_t v16 = v13 & 0xFFFFFFF8;
      do
      {
        long long v17 = *v15;
        *(v14 - 1) = *(v15 - 1);
        *uint64_t v14 = v17;
        v14 += 2;
        v15 += 2;
        v16 -= 8;
      }
      while (v16);
      if (v10 != v13)
      {
LABEL_17:
        uint64_t v18 = v13 - v10;
        uint64_t v19 = 4 * v10;
        long long v20 = (_DWORD *)(v12 + v19);
        uint64_t v21 = (int *)(v11 + v19);
        do
        {
          int v22 = *v21++;
          *v20++ = v22;
          --v18;
        }
        while (v18);
      }
    }
  }
  *(void *)(v3 + 40) = *(void *)(*(void *)(v3 + 40) + 8);
  ++*(_DWORD *)(v3 + 56);
  return result;
}

uint64_t NResizingQueue<NFrame>::enlargeBy(uint64_t a1, int *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 64))();
  uint64_t v6 = (uint64_t *)(a1 + 16);
  unsigned int v7 = (void *)(a1 + 24);
  if (*(void *)(a1 + 16))
  {
    int v8 = (uint64_t *)(*v7 + 8);
    uint64_t v6 = (uint64_t *)(a1 + 24);
  }
  else
  {
    int v8 = (uint64_t *)(a1 + 24);
  }
  *int v8 = v4;
  *uint64_t v6 = v4;
  ++*(_DWORD *)(a1 + 32);
  uint64_t v9 = *v7;
  if (!*v7) {
    Error::chuck((Error *)"NLinkedList::tail() - cannot access tail of empty list", v5);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, int *))(*(void *)(v9 + 16) + 32))(v9 + 16, a2);
  int v11 = *a2;
  uint64_t v12 = (*a2 - 1);
  if (*a2 != 1)
  {
    uint64_t v13 = *(void *)(v9 + 24);
    if (*a2 == 2)
    {
      uint64_t v14 = 0;
    }
    else
    {
      uint64_t v14 = v12 & 0xFFFFFFFE;
      uint64_t v15 = v13 + 40;
      uint64_t v16 = v14;
      do
      {
        *(void *)(v15 - 32) = v15;
        *(void *)(v15 + 8) = v15 + 40;
        v15 += 80;
        v16 -= 2;
      }
      while (v16);
      if (v14 == v12) {
        goto LABEL_13;
      }
    }
    uint64_t v17 = v13 + 40 * v14 + 40;
    uint64_t v18 = v12 - v14;
    do
    {
      *(void *)(v17 - 32) = v17;
      v17 += 40;
      --v18;
    }
    while (v18);
  }
LABEL_13:
  uint64_t v19 = *(void *)(a1 + 40);
  if (v19)
  {
    uint64_t v20 = *(void *)(v9 + 24);
    *(void *)(v20 + 40 * v12 + 8) = *(void *)(v19 + 8);
    *(void *)(v19 + 8) = v20;
  }
  else
  {
    uint64_t v21 = *(void *)(v9 + 24);
    *(void *)(v21 + 40 * v12 + 8) = v21;
    *(void *)(a1 + 40) = v21;
    *(void *)(a1 + 48) = v21;
  }
  *(_DWORD *)(a1 + 64) += v11;
  return result;
}

void sub_21847FDBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  NArray<NResizingQueue<NFrame>::NElement>::~NArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *NArray<NResizingQueue<NFrame>::NElement>::~NArray(void *a1)
{
  *a1 = &unk_26C99C188;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 40 * v3;
      uint64_t v5 = v2 - 40;
      do
      {
        uint64_t v6 = (void *)(v5 + v4);
        *uint64_t v6 = &unk_26C99C930;
        v6[2] = &unk_26C99C348;
        uint64_t v7 = *(void *)(v5 + v4 + 24);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        v4 -= 40;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80C9FAA55CLL);
  }
  return a1;
}

void NResizingQueue<NFrame>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C930;
  a1[2] = &unk_26C99C348;
  uint64_t v1 = a1[3];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8052888210);
  }

  JUMPOUT(0x21D46B240);
}

void *NResizingQueue<NFrame>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C930;
  a1[2] = &unk_26C99C348;
  uint64_t v2 = a1[3];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  return a1;
}

uint64_t NArray<NResizingQueue<NFrame>::NElement>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<NResizingQueue<NFrame>::NElement>::fromArray(uint64_t result, const char *a2, int *a3)
{
  int v3 = *(_DWORD *)(result + 16);
  int v4 = *a3;
  if (v3 != *a3)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      uint64_t v8 = *(void *)(v6 - 8);
      if (v8)
      {
        uint64_t v9 = 40 * v8;
        uint64_t v10 = v6 - 40;
        do
        {
          int v11 = (void *)(v10 + v9);
          *int v11 = &unk_26C99C930;
          v11[2] = &unk_26C99C348;
          uint64_t v12 = *(void *)(v10 + v9 + 24);
          if (v12) {
            MEMORY[0x21D46B220](v12, 0x1000C8052888210);
          }
          v9 -= 40;
        }
        while (v9);
      }
      MEMORY[0x21D46B220](v6 - 16, 0x10A1C80C9FAA55CLL);
      int v4 = *a3;
    }
    *(_DWORD *)(v5 + 16) = v4;
    operator new[]();
  }
  if (v3) {
    Error::chuck((Error *)"NLinkedList::NElement::operator=() -this method should never be called", a2);
  }
  return result;
}

uint64_t NArray<NResizingQueue<NFrame>::NElement>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 40 * v7;
          uint64_t v9 = v6 - 40;
          do
          {
            uint64_t v10 = (void *)(v9 + v8);
            *uint64_t v10 = &unk_26C99C930;
            v10[2] = &unk_26C99C348;
            uint64_t v11 = *(void *)(v9 + v8 + 24);
            if (v11) {
              MEMORY[0x21D46B220](v11, 0x1000C8052888210);
            }
            v8 -= 40;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x10A1C80C9FAA55CLL);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4) {
      Error::chuck((Error *)"NLinkedList::NElement::operator=() -this method should never be called", (const char *)a2);
    }
  }
  return result;
}

void NArray<NResizingQueue<NFrame>::NElement>::~NArray(void *a1)
{
  *a1 = &unk_26C99C188;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 40 * v2;
      uint64_t v4 = v1 - 40;
      do
      {
        int v5 = (void *)(v4 + v3);
        *int v5 = &unk_26C99C930;
        v5[2] = &unk_26C99C348;
        uint64_t v6 = *(void *)(v4 + v3 + 24);
        if (v6) {
          MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        }
        v3 -= 40;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80C9FAA55CLL);
  }

  JUMPOUT(0x21D46B240);
}

void *NWavChunk2HTKFrames::c0Invert(void *this)
{
  uint64_t v1 = (int *)*((void *)this + 1);
  int v2 = *v1;
  int v3 = *((_DWORD *)this + 238);
  uint64_t v4 = (v3 - 1);
  if (v3 == 1) {
    uint64_t v4 = 0;
  }
  else {
    this = memmove(*((void **)this + 1), v1 + 1, 4 * (v3 - 1));
  }
  v1[v4] = v2;
  return this;
}

float NWavChunk2HTKFrames::toOutType(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *(void *)(a2 + 8);
    uint64_t v5 = *(void *)(a1 + 32);
    if (v2 < 8) {
      goto LABEL_7;
    }
    if ((unint64_t)(v5 - v4) < 0x20) {
      goto LABEL_7;
    }
    uint64_t v3 = v2 & 0xFFFFFFF8;
    uint64_t v6 = (_OWORD *)(v5 + 16);
    uint64_t v7 = (long long *)(v4 + 16);
    uint64_t v8 = v3;
    do
    {
      long long v9 = *(v7 - 1);
      long long v10 = *v7;
      *(v6 - 1) = v9;
      *uint64_t v6 = v10;
      v6 += 2;
      v7 += 2;
      v8 -= 8;
    }
    while (v8);
    if (v3 != v2)
    {
LABEL_7:
      uint64_t v11 = v2 - v3;
      uint64_t v12 = 4 * v3;
      uint64_t v13 = (_DWORD *)(v5 + 4 * v3);
      uint64_t v14 = (int *)(v4 + v12);
      do
      {
        int v15 = *v14++;
        LODWORD(v9) = v15;
        *v13++ = v15;
        --v11;
      }
      while (v11);
    }
  }
  return *(float *)&v9;
}

uint64_t NWavChunk2HTKFrames::finish(uint64_t result, const char *a2)
{
  if (!*(unsigned char *)(result + 800)) {
    Error::chuck((Error *)"NWavChunk2HTKFrames::finish - NWavChunk2HTKFrames::init() must be called before finishing", a2);
  }
  uint64_t v2 = result;
  if (*(unsigned char *)(result + 984))
  {
    while (1)
    {
      uint64_t result = NDynamicMFCC::finish((NDynamicMFCC *)(v2 + 576), a2);
      if (result) {
        break;
      }
      if (!*(unsigned char *)(v2 + 600)) {
        Error::chuck((Error *)"NDynamicMFCC::getFrame() - no frame available", v4);
      }
      uint64_t v5 = *(unsigned int *)(v2 + 40);
      if (v5)
      {
        uint64_t v6 = 0;
        uint64_t v7 = *(void *)(v2 + 584);
        uint64_t v8 = *(void *)(v2 + 32);
        if (v5 < 8) {
          goto LABEL_13;
        }
        if ((unint64_t)(v8 - v7) < 0x20) {
          goto LABEL_13;
        }
        uint64_t v6 = v5 & 0xFFFFFFF8;
        long long v9 = (_OWORD *)(v8 + 16);
        long long v10 = (long long *)(v7 + 16);
        uint64_t v11 = v6;
        do
        {
          long long v12 = *v10;
          *(v9 - 1) = *(v10 - 1);
          _OWORD *v9 = v12;
          v9 += 2;
          v10 += 2;
          v11 -= 8;
        }
        while (v11);
        if (v6 != v5)
        {
LABEL_13:
          uint64_t v13 = v5 - v6;
          uint64_t v14 = 4 * v6;
          int v15 = (_DWORD *)(v8 + 4 * v6);
          uint64_t v16 = (int *)(v7 + v14);
          do
          {
            int v17 = *v16++;
            *v15++ = v17;
            --v13;
          }
          while (v13);
        }
      }
      NResizingQueue<NFrame>::push((uint64_t)a2, v2 + 24);
    }
  }
  return result;
}

float NWavChunk2HTKFrames::getFrameRate(NWavChunk2HTKFrames *this)
{
  return (float)*((unsigned int *)this + 243) / (float)*((unsigned int *)this + 245);
}

uint64_t NWavChunk2HTKFrames::isTypeInt4(NWavChunk2HTKFrames *this)
{
  return 0;
}

uint64_t NDEAcAnal::init(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  if (a2)
  {
    *(_OWORD *)(a1 + 580) = *(_OWORD *)a2;
    long long v4 = *(_OWORD *)(a2 + 16);
    long long v5 = *(_OWORD *)(a2 + 32);
    long long v6 = *(_OWORD *)(a2 + 48);
    *(_DWORD *)(a1 + 644) = *(_DWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 612) = v5;
    *(_OWORD *)(a1 + 628) = v6;
    *(_OWORD *)(a1 + 596) = v4;
  }
  unsigned int v7 = *a3;
  if (!*a3) {
    Error::chuck((Error *)"NDEAcAnal::setSamRate() - a_iSamRate (= %d) must be strictly positive\n", (const char *)a2, 0);
  }
  *(_DWORD *)(a1 + 648) = v7;
  float v8 = (float)(*(float *)(a1 + 584) * (float)v7) / 10000000.0;
  float v9 = 2147500000.0;
  if (v8 <= 2147500000.0)
  {
    float v9 = (float)(*(float *)(a1 + 584) * (float)v7) / 10000000.0;
    if (v8 < 0.0) {
      float v9 = 0.0;
    }
  }
  *(_DWORD *)(a1 + 652) = v9;
  float v10 = (float)(*(float *)(a1 + 580) * (float)v7) / 10000000.0;
  double v11 = 3.53369517e72;
  if (v10 <= 2147500000.0)
  {
    *(float *)&double v11 = (float)(*(float *)(a1 + 580) * (float)v7) / 10000000.0;
    if (v10 < 0.0) {
      double v11 = 0.0;
    }
  }
  unsigned int v12 = *(float *)&v11;
  if (*(float *)&v11 <= 1) {
    unsigned int v12 = 1;
  }
  *(_DWORD *)(a1 + 656) = v12;
  if (*(unsigned char *)(a1 + 624)) {
    ++*(_DWORD *)(a1 + 616);
  }
  if (*(unsigned char *)(a1 + 594)) {
    *(_DWORD *)(a1 + 616) = *(_DWORD *)(a1 + 596);
  }
  uint64_t result = AccelStaticMFCC::init((AccelStaticMFCC *)a1, (const char *)(a1 + 656), (unsigned int *)(a1 + 648), (const unsigned int *)(a1 + 652), (const BOOL *)(a1 + 593), (float *)(a1 + 588), (const BOOL *)(a1 + 592), (const BOOL *)(a1 + 594), v11, (const BOOL *)(a1 + 595), (const unsigned int *)(a1 + 596), (const float *)(a1 + 600), (const float *)(a1 + 604), (const unsigned int *)(a1 + 620), (const unsigned int *)(a1 + 616), (const float *)(a1 + 628), (const float *)(a1 + 632), (const float *)(a1 + 608), (const float *)(a1 + 612));
  if (*(unsigned char *)(a1 + 636)) {
    Error::chuck((Error *)"NDEAcAnal::init() - deltas not supported", v14);
  }
  int v15 = *(_DWORD *)(a1 + 568);
  int v16 = *(_DWORD *)(a1 + 616);
  if (v15 != v16)
  {
    *(_DWORD *)(a1 + 568) = v16;
    operator new[]();
  }
  if (*(_DWORD *)(a1 + 544) != v15)
  {
    *(_DWORD *)(a1 + 544) = v15;
    operator new[]();
  }
  *(unsigned char *)(a1 + 576) = 1;
  return result;
}

uint64_t NDEAcAnal::setSamRate(uint64_t this, const char *a2)
{
  unsigned int v2 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2) {
    Error::chuck((Error *)"NDEAcAnal::setSamRate() - a_iSamRate (= %d) must be strictly positive\n", a2, 0);
  }
  *(_DWORD *)(this + 648) = v2;
  float v3 = (float)(*(float *)(this + 584) * (float)v2) / 10000000.0;
  float v4 = 2147500000.0;
  if (v3 <= 2147500000.0)
  {
    float v4 = (float)(*(float *)(this + 584) * (float)v2) / 10000000.0;
    if (v3 < 0.0) {
      float v4 = 0.0;
    }
  }
  *(_DWORD *)(this + 652) = v4;
  float v5 = (float)(*(float *)(this + 580) * (float)v2) / 10000000.0;
  float v6 = 2147500000.0;
  if (v5 <= 2147500000.0)
  {
    float v6 = (float)(*(float *)(this + 580) * (float)v2) / 10000000.0;
    if (v5 < 0.0) {
      float v6 = 0.0;
    }
  }
  unsigned int v7 = v6;
  if (v6 <= 1) {
    unsigned int v7 = 1;
  }
  *(_DWORD *)(this + 656) = v7;
  return this;
}

uint64_t NDEAcAnal::initStatic(NDEAcAnal *this, double a2)
{
  return AccelStaticMFCC::init(this, (const char *)this + 656, (unsigned int *)this + 162, (const unsigned int *)this + 163, (const BOOL *)this + 593, (float *)this + 147, (const BOOL *)this + 592, (const BOOL *)this + 594, a2, (const BOOL *)this + 595, (const unsigned int *)this + 149, (const float *)this + 150, (const float *)this + 151, (const unsigned int *)this + 155, (const unsigned int *)this + 154, (const float *)this + 157, (const float *)this + 158, (const float *)this + 152, (const float *)this + 153);
}

uint64_t NDEAcAnal::feedFromInt(NDEAcAnal *this, const char *a2, const unsigned int *a3)
{
  if (!*((unsigned char *)this + 576)) {
    Error::chuck((Error *)"NDEAcAnal::feedFromInt() - you must call NDEAcAnal::init() before feeding the program", a2, a3);
  }
  int v4 = *a3;
  uint64_t v5 = *((unsigned int *)this + 164);
  if (*a3 > v5) {
    Error::chuck((Error *)"NDEAcAnal::feedFromInt() - we are supposed to get only one frame at a time feed size (%d) must be less than step size (%d) ", a2, *a3, v5);
  }
  if (!*(unsigned char *)this) {
    Error::chuck((Error *)"AccelStaticMFCC::start() - AccelStaticMFCC::init() has to be called before starting", a2);
  }
  if (*((void *)this + 64)) {
    Error::chuck((Error *)"AccelStaticMFCC::start() - frames undrained from previous chunk - call isFrame() or reset()", a2);
  }
  if (!a2 && v4) {
    Error::chuck((Error *)"AccelStaticMFCC::start() - pointer to chunk is NULL", 0);
  }
  uint64_t v6 = 0;
  *((void *)this + 64) = a2;
  *((_DWORD *)this + 130) = v4;
  *((_DWORD *)this + 131) = 0;
  *((unsigned char *)this + 508) = 0;
  *((unsigned char *)this + 660) = 0;
  while (1)
  {
    uint64_t result = AccelStaticMFCC::isFrame(this, a2);
    if (!result) {
      break;
    }
    unint64_t v8 = *((unsigned int *)this + 136);
    uint64_t v9 = *((unsigned int *)this + 6);
    if (v8 != v9)
    {
      uint64_t v10 = *((void *)this + 67);
      if (v10)
      {
        MEMORY[0x21D46B220](v10, 0x1000C8052888210);
        LODWORD(v9) = *((_DWORD *)this + 6);
      }
      *((_DWORD *)this + 136) = v9;
      operator new[]();
    }
    if (*((_DWORD *)this + 136))
    {
      uint64_t v11 = 0;
      uint64_t v12 = *((void *)this + 2);
      uint64_t v13 = *((void *)this + 67);
      if (v8 < 8) {
        goto LABEL_20;
      }
      if ((unint64_t)(v13 - v12) < 0x20) {
        goto LABEL_20;
      }
      uint64_t v11 = v8 & 0xFFFFFFF8;
      uint64_t v14 = (_OWORD *)(v13 + 16);
      int v15 = (long long *)(v12 + 16);
      uint64_t v16 = v11;
      do
      {
        long long v17 = *v15;
        *(v14 - 1) = *(v15 - 1);
        *uint64_t v14 = v17;
        v14 += 2;
        v15 += 2;
        v16 -= 8;
      }
      while (v16);
      if (v11 != v8)
      {
LABEL_20:
        uint64_t v18 = v8 - v11;
        uint64_t v19 = 4 * v11;
        uint64_t v20 = (_DWORD *)(v13 + v19);
        uint64_t v21 = (int *)(v12 + v19);
        do
        {
          int v22 = *v21++;
          *v20++ = v22;
          --v18;
        }
        while (v18);
      }
    }
    if (*((unsigned char *)this + 624) && !*((unsigned char *)this + 625))
    {
      unsigned int v23 = (int *)*((void *)this + 67);
      int v24 = *v23;
      int v25 = *((_DWORD *)this + 154);
      uint64_t v26 = (v25 - 1);
      if (v25 == 1) {
        uint64_t v26 = 0;
      }
      else {
        memmove(*((void **)this + 67), v23 + 1, 4 * (v25 - 1));
      }
      v23[v26] = v24;
    }
    if (*((unsigned char *)this + 636)) {
      Error::chuck((Error *)"NDEAcAnal::feedFromInt() - deltas not supported", a2);
    }
    uint64_t v27 = *((unsigned int *)this + 142);
    if (v27)
    {
      uint64_t v28 = 0;
      uint64_t v29 = *((void *)this + 67);
      uint64_t v30 = *((void *)this + 70);
      if (v27 < 8) {
        goto LABEL_35;
      }
      if ((unint64_t)(v30 - v29) < 0x20) {
        goto LABEL_35;
      }
      uint64_t v28 = v27 & 0xFFFFFFF8;
      int v31 = (_OWORD *)(v30 + 16);
      uint64_t v32 = (long long *)(v29 + 16);
      uint64_t v33 = v28;
      do
      {
        long long v34 = *v32;
        *(v31 - 1) = *(v32 - 1);
        *int v31 = v34;
        v31 += 2;
        v32 += 2;
        v33 -= 8;
      }
      while (v33);
      if (v28 != v27)
      {
LABEL_35:
        uint64_t v35 = v27 - v28;
        uint64_t v36 = 4 * v28;
        int v37 = (_DWORD *)(v30 + 4 * v28);
        int v38 = (int *)(v29 + v36);
        do
        {
          int v39 = *v38++;
          *v37++ = v39;
          --v35;
        }
        while (v35);
      }
    }
    *((unsigned char *)this + 660) = 1;
    uint64_t v6 = (v6 + 1);
  }
  if (v6 >= 2) {
    Error::chuck((Error *)"NDEAcAnal::feedFromInt() - we are supposed to get *at most* one frame at a time (num frames = %d) ", a2, v6);
  }
  return result;
}

void *NDEAcAnal::c0Invert(void *this)
{
  uint64_t v1 = (int *)*((void *)this + 67);
  int v2 = *v1;
  int v3 = *((_DWORD *)this + 154);
  uint64_t v4 = (v3 - 1);
  if (v3 == 1) {
    uint64_t v4 = 0;
  }
  else {
    this = memmove(*((void **)this + 67), v1 + 1, 4 * (v3 - 1));
  }
  v1[v4] = v2;
  return this;
}

float NDEAcAnal::toOutType(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 568);
  if (v2)
  {
    uint64_t v3 = *(void *)(a2 + 8);
    uint64_t v4 = *(void *)(a1 + 560);
    if (v2 < 8 || (unint64_t)(v4 - v3) <= 0x1F)
    {
      uint64_t v6 = 0;
LABEL_10:
      uint64_t v12 = v2 - v6;
      uint64_t v13 = 4 * v6;
      uint64_t v14 = (_DWORD *)(v4 + v13);
      int v15 = (int *)(v3 + v13);
      do
      {
        int v16 = *v15++;
        LODWORD(v10) = v16;
        *v14++ = v16;
        --v12;
      }
      while (v12);
      return *(float *)&v10;
    }
    uint64_t v6 = v2 & 0xFFFFFFF8;
    unsigned int v7 = (_OWORD *)(v4 + 16);
    unint64_t v8 = (long long *)(v3 + 16);
    uint64_t v9 = v6;
    do
    {
      long long v10 = *(v8 - 1);
      long long v11 = *v8;
      *(v7 - 1) = v10;
      *unsigned int v7 = v11;
      v7 += 2;
      v8 += 2;
      v9 -= 8;
    }
    while (v9);
    if (v6 != v2) {
      goto LABEL_10;
    }
  }
  return *(float *)&v10;
}

uint64_t NDEAcAnal::reset(uint64_t this)
{
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 504) = *(_DWORD *)(this + 488) + 1;
  *(void *)(this + 512) = 0;
  *(unsigned char *)(this + 508) = 0;
  return this;
}

float NDEAcAnal::get_framerate(NDEAcAnal *this)
{
  return (float)*((unsigned int *)this + 162) / (float)*((unsigned int *)this + 164);
}

uint64_t NDEAcAnal::frameAvailable(NDEAcAnal *this)
{
  return *((unsigned __int8 *)this + 660);
}

uint64_t NDEAcAnal::getFrameByRef(NDEAcAnal *this)
{
  return (uint64_t)this + 552;
}

uint64_t NDEAcAnal::frameSize(NDEAcAnal *this)
{
  return *((_DWORD *)this + 154) * ((2 * *((unsigned __int8 *)this + 636)) | 1u);
}

void AccelWin2MFCC::AccelWin2MFCC(AccelWin2MFCC *this)
{
  *(unsigned char *)this = 0;
  *((unsigned char *)this + 12) = 0;
  *((void *)this + 2) = &unk_26C99C348;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 6) = 0;
  *((unsigned char *)this + 56) = 0;
  *((void *)this + 9) = &unk_26C99C348;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((unsigned char *)this + 100) = 0;
  *((unsigned char *)this + 124) = 0;
  *((void *)this + 16) = &unk_26C99C3F0;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 19) = &unk_26C99C2A0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 22) = &unk_26C99C348;
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((unsigned char *)this + 204) = 0;
  *((unsigned char *)this + 228) = 0;
  *((void *)this + 29) = &unk_26C99C678;
  *((void *)this + 30) = 0;
  *((void *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((void *)this + 33) = &unk_26C99C348;
  *((void *)this + 34) = 0;
  *((_DWORD *)this + 70) = 0;
  *((void *)this + 38) = &unk_26C99C348;
  *((void *)this + 39) = 0;
  *((_DWORD *)this + 80) = 0;
  *((void *)this + 36) = 0;
  *((void *)this + 37) = 0;
}

{
  *(unsigned char *)this = 0;
  *((unsigned char *)this + 12) = 0;
  *((void *)this + 2) = &unk_26C99C348;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 6) = 0;
  *((unsigned char *)this + 56) = 0;
  *((void *)this + 9) = &unk_26C99C348;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((unsigned char *)this + 100) = 0;
  *((unsigned char *)this + 124) = 0;
  *((void *)this + 16) = &unk_26C99C3F0;
  *((void *)this + 17) = 0;
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 19) = &unk_26C99C2A0;
  *((void *)this + 20) = 0;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 22) = &unk_26C99C348;
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((unsigned char *)this + 204) = 0;
  *((unsigned char *)this + 228) = 0;
  *((void *)this + 29) = &unk_26C99C678;
  *((void *)this + 30) = 0;
  *((void *)this + 31) = 0;
  *((_DWORD *)this + 64) = 0;
  *((void *)this + 33) = &unk_26C99C348;
  *((void *)this + 34) = 0;
  *((_DWORD *)this + 70) = 0;
  *((void *)this + 38) = &unk_26C99C348;
  *((void *)this + 39) = 0;
  *((_DWORD *)this + 80) = 0;
  *((void *)this + 36) = 0;
  *((void *)this + 37) = 0;
}

uint64_t NArray<NArray<float>>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = 24 * v9;
        do
        {
          *(void *)(v7 + v10 - 24) = &unk_26C99C348;
          uint64_t v11 = *(void *)(v7 + v10 - 16);
          if (v11) {
            MEMORY[0x21D46B220](v11, 0x1000C8052888210);
          }
          v10 -= 24;
        }
        while (v10);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x1081C80622C3295);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v4 + 8) + v12) + 16))(*(void *)(v4 + 8) + v12, a2 + v12);
      ++v13;
      v12 += 24;
    }
    while (v13 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NArray<float>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 24 * v7;
          do
          {
            *(void *)(v6 + v8 - 24) = &unk_26C99C348;
            uint64_t v9 = *(void *)(v6 + v8 - 16);
            if (v9) {
              MEMORY[0x21D46B220](v9, 0x1000C8052888210);
            }
            v8 -= 24;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x1081C80622C3295);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v10 = 0;
      unint64_t v11 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 8) + v10) + 16))(*(void *)(a1 + 8) + v10, *(void *)(a2 + 8) + v10);
        ++v11;
        v10 += 24;
      }
      while (v11 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void N2DArray<float>::~N2DArray(void *a1)
{
  *a1 = &unk_26C99C2A0;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 24 * v2;
      do
      {
        *(void *)(v1 + v3 - 24) = &unk_26C99C348;
        uint64_t v4 = *(void *)(v1 + v3 - 16);
        if (v4) {
          MEMORY[0x21D46B220](v4, 0x1000C8052888210);
        }
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1081C80622C3295);
  }

  JUMPOUT(0x21D46B240);
}

void *N2DArray<float>::~N2DArray(void *a1)
{
  *a1 = &unk_26C99C2A0;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 24 * v3;
      do
      {
        *(void *)(v2 + v4 - 24) = &unk_26C99C348;
        uint64_t v5 = *(void *)(v2 + v4 - 16);
        if (v5) {
          MEMORY[0x21D46B220](v5, 0x1000C8052888210);
        }
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1081C80622C3295);
  }
  return a1;
}

void NArray<NArray<float>>::~NArray(void *a1)
{
  *a1 = &unk_26C99C2A0;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 24 * v2;
      do
      {
        *(void *)(v1 + v3 - 24) = &unk_26C99C348;
        uint64_t v4 = *(void *)(v1 + v3 - 16);
        if (v4) {
          MEMORY[0x21D46B220](v4, 0x1000C8052888210);
        }
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1081C80622C3295);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NArray<float>>::~NArray(void *a1)
{
  *a1 = &unk_26C99C2A0;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 24 * v3;
      do
      {
        *(void *)(v2 + v4 - 24) = &unk_26C99C348;
        uint64_t v5 = *(void *)(v2 + v4 - 16);
        if (v5) {
          MEMORY[0x21D46B220](v5, 0x1000C8052888210);
        }
        v4 -= 24;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1081C80622C3295);
  }
  return a1;
}

uint64_t AccelWin2MFCC::init(AccelWin2MFCC *this, unsigned int *a2, const unsigned int *a3, const BOOL *a4, const BOOL *a5, const BOOL *a6, const BOOL *a7, const unsigned int *a8, double a9, const float *a10, const float *a11, const unsigned int *a12, const unsigned int *a13, const float *a14, const float *a15, const float *a16, const float *a17)
{
  *(unsigned char *)this = 0;
  unsigned int v18 = *a2;
  *((_DWORD *)this + 83) = *a2;
  int v19 = *a3;
  *((_DWORD *)this + 84) = *a3;
  *((unsigned char *)this + 340) = *a4;
  int v20 = 1;
  do
  {
    int v21 = v20;
    v20 *= 2;
  }
  while (v21 < v19);
  *((_DWORD *)this + 86) = v21;
  *((_DWORD *)this + 87) = (v21 >> 1) + 1;
  *((unsigned char *)this + 352) = *a7;
  *((float *)this + 89) = *a14 * *a15;
  *((unsigned char *)this + 360) = *a5;
  int v22 = *a8;
  *((_DWORD *)this + 91) = *a8;
  *((_DWORD *)this + 92) = v18 >> 1;
  *((float *)this + 93) = *a10;
  *((float *)this + 94) = *a11;
  *((float *)this + 95) = *a16;
  *(float *)&a9 = *a17;
  *((float *)this + 96) = *a17;
  int v23 = *(unsigned __int8 *)a6;
  *((unsigned char *)this + 361) = v23;
  *((_DWORD *)this + 97) = *a12;
  if (v23) {
    int v24 = v22;
  }
  else {
    int v24 = *a13;
  }
  *((_DWORD *)this + 98) = v24;
  AccelWin2MFCC::initProc(this, a9);
  uint64_t result = AccelWin2MFCC::initData((void **)this);
  *((_DWORD *)this + 82) = 1065353216;
  *(unsigned char *)this = 1;
  return result;
}

void AccelWin2MFCC::initProc(AccelWin2MFCC *this, double a2)
{
  AccelWindow::init((AccelWin2MFCC *)((char *)this + 8), (const char *)this + 336, (const BOOL *)this + 340, (const BOOL *)this + 360, a2);
  AccelFFT::init((vDSP_DFT_SetupStruct **)this + 6, (const char *)this + 336, (unsigned int *)this + 86, (const unsigned int *)this + 87);
  *((_DWORD *)this + 26) = *((_DWORD *)this + 87);
  *((unsigned char *)this + 108) = *((unsigned char *)this + 352);
  *((_DWORD *)this + 24) = 0;
  *((unsigned char *)this + 100) = 1;
  AccelMelFilter::init((AccelWin2MFCC *)((char *)this + 112), (const char *)this + 364, (const unsigned int *)this + 87, (const unsigned int *)this + 92, (const float *)this + 93, (const float *)this + 94, (const float *)this + 95, (const float *)this + 96);
  int v3 = *((_DWORD *)this + 89);
  *((_DWORD *)this + 50) = *((_DWORD *)this + 91);
  *((unsigned char *)this + 204) = 1;
  *((_DWORD *)this + 52) = v3;
  if (!*((unsigned char *)this + 361))
  {
    AccelCosine::init((AccelWin2MFCC *)((char *)this + 216), (const char *)this + 364, (const unsigned int *)this + 98, (const unsigned int *)this + 97);
  }
}

uint64_t AccelWin2MFCC::initData(void **this)
{
  uint64_t v2 = this + 36;
  free(this[36]);
  this[36] = 0;
  this[37] = 0;
  uint64_t result = malloc_type_posix_memalign(v2, 0x10uLL, 4 * *((unsigned int *)this + 86), 0x100004052888210uLL);
  if (result) {
    Error::chuck((Error *)"AccelWin2MFCC::initData - posix_memalign returned an error", v4);
  }
  this[37] = (char *)this[36] + ((2 * *((unsigned int *)this + 86)) & 0x1FFFFFFFCLL);
  int v5 = *((_DWORD *)this + 98);
  if (*((_DWORD *)this + 80) != v5)
  {
    *((_DWORD *)this + 80) = v5;
    operator new[]();
  }
  return result;
}

void AccelWin2MFCC::~AccelWin2MFCC(void **this)
{
  free(this[36]);
  this[38] = &unk_26C99C348;
  uint64_t v2 = this[39];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  this[33] = &unk_26C99C348;
  int v3 = this[34];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  this[29] = &unk_26C99C2A0;
  uint64_t v4 = this[30];
  if (v4)
  {
    uint64_t v5 = *(v4 - 1);
    if (v5)
    {
      uint64_t v6 = 3 * v5;
      do
      {
        v4[v6 - 3] = &unk_26C99C348;
        uint64_t v7 = v4[v6 - 2];
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        v6 -= 3;
      }
      while (v6 * 8);
    }
    MEMORY[0x21D46B220](v4 - 2, 0x1081C80622C3295);
  }
  this[22] = &unk_26C99C348;
  uint64_t v8 = this[23];
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8052888210);
  }
  this[19] = &unk_26C99C2A0;
  uint64_t v9 = this[20];
  if (v9)
  {
    uint64_t v10 = *(v9 - 1);
    if (v10)
    {
      uint64_t v11 = 3 * v10;
      do
      {
        v9[v11 - 3] = &unk_26C99C348;
        uint64_t v12 = v9[v11 - 2];
        if (v12) {
          MEMORY[0x21D46B220](v12, 0x1000C8052888210);
        }
        v11 -= 3;
      }
      while (v11 * 8);
    }
    MEMORY[0x21D46B220](v9 - 2, 0x1081C80622C3295);
  }
  this[16] = &unk_26C99C3F0;
  unint64_t v13 = this[17];
  if (v13) {
    MEMORY[0x21D46B220](v13, 0x1000C8052888210);
  }
  uint64_t v14 = (vDSP_DFT_SetupStruct *)this[6];
  if (v14) {
    vDSP_DFT_DestroySetup(v14);
  }
  this[9] = &unk_26C99C348;
  int v15 = this[10];
  if (v15) {
    MEMORY[0x21D46B220](v15, 0x1000C8052888210);
  }
  this[2] = &unk_26C99C348;
  int v16 = this[3];
  if (v16) {
    MEMORY[0x21D46B220](v16, 0x1000C8052888210);
  }
}

uint64_t AccelWin2MFCC::run(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)a1) {
    Error::chuck((Error *)"AccelWin2MFCC::run - AccelWin2MFCC::init() has to be called before running", (const char *)a2);
  }
  uint64_t v4 = *(unsigned int *)(a2 + 16);
  if (v4 != *(_DWORD *)(a1 + 336)) {
    Error::chuck((Error *)"AccelWin2MFCC::run - length of input should be %d, not %d", (const char *)a2, *(unsigned int *)(a1 + 336), v4);
  }
  if (!*(unsigned char *)(a1 + 12)) {
    Error::chuck((Error *)"AccelWindow::apply() - AccelWindow::init() has to be called before running", (const char *)a2);
  }
  uint64_t v5 = (unsigned int *)(a1 + 8);
  if (v4 != *(_DWORD *)(a1 + 8)) {
    Error::chuck((Error *)"AccelWindow::apply() - length of input array should be %d, not %d", (const char *)a2, *(unsigned int *)(a1 + 8), v4);
  }
  AccelWindow::applyHamming(v5, a2);
  AccelFFT::run(a1 + 48, a2, (const DSPSplitComplex *)(a1 + 288));
  AccelPSD::run((AccelPSD *)(a1 + 96), (DSPSplitComplex *)(a1 + 288));
  if (!*(unsigned char *)(a1 + 124)) {
    Error::chuck((Error *)"AccelMelFilter::run - AccelMelFilter::init() must be called before running", v6);
  }
  uint64_t v7 = *(float **)(a1 + 288);
  if (*(_DWORD *)(a1 + 112))
  {
    unint64_t v8 = 0;
    do
    {
      vDSP_dotpr(&v7[*(unsigned int *)(*(void *)(a1 + 136) + 4 * v8)], 1, *(const float **)(*(void *)(a1 + 160) + 24 * v8 + 8), 1, (float *)(*(void *)(a1 + 184) + 4 * v8), *(unsigned int *)(*(void *)(a1 + 160) + 24 * v8 + 16));
      ++v8;
      unint64_t v9 = *(unsigned int *)(a1 + 112);
    }
    while (v8 < v9);
    size_t v10 = 4 * v9;
  }
  else
  {
    size_t v10 = 0;
  }
  memcpy(v7, *(const void **)(a1 + 184), v10);
  if (!*(unsigned char *)(a1 + 204)) {
    Error::chuck((Error *)"AccelLoga::run - AccelLoga::init() has to be called before running", v11);
  }
  uint64_t v12 = *(float **)(a1 + 288);
  vDSP_vsadd(v12, 1, (const float *)(a1 + 208), v12, 1, *(unsigned int *)(a1 + 200));
  int v32 = *(_DWORD *)(a1 + 200);
  vvlogf(v12, v12, &v32);
  if (*(unsigned char *)(a1 + 361))
  {
    uint64_t v14 = *(unsigned int *)(a1 + 392);
    if (v14)
    {
      uint64_t v15 = 0;
      uint64_t v16 = *(void *)(a1 + 288);
      uint64_t v17 = *(void *)(a1 + 312);
      if (v14 < 8) {
        goto LABEL_19;
      }
      if ((unint64_t)(v17 - v16) < 0x20) {
        goto LABEL_19;
      }
      uint64_t v15 = v14 & 0xFFFFFFF8;
      unsigned int v18 = (_OWORD *)(v17 + 16);
      int v19 = (long long *)(v16 + 16);
      uint64_t v20 = v15;
      do
      {
        long long v21 = *v19;
        *(v18 - 1) = *(v19 - 1);
        *unsigned int v18 = v21;
        v18 += 2;
        v19 += 2;
        v20 -= 8;
      }
      while (v20);
      if (v15 != v14)
      {
LABEL_19:
        uint64_t v22 = v14 - v15;
        uint64_t v23 = 4 * v15;
        int v24 = (_DWORD *)(v17 + 4 * v15);
        int v25 = (int *)(v16 + v23);
        do
        {
          int v26 = *v25++;
          *v24++ = v26;
          --v22;
        }
        while (v22);
      }
    }
  }
  else
  {
    if (!*(unsigned char *)(a1 + 228)) {
      Error::chuck((Error *)"AccelCosine::run() - AccelCosine::init() has to be called before running", v13);
    }
    uint64_t v27 = *(unsigned int *)(a1 + 320);
    if (v27 != *(_DWORD *)(a1 + 220)) {
      Error::chuck((Error *)"AccelCosine::run() - length of output should be %d, not %d", v13, *(unsigned int *)(a1 + 220), v27);
    }
    if (v27)
    {
      unint64_t v28 = 0;
      uint64_t v29 = *(const float **)(a1 + 288);
      uint64_t v30 = 8;
      do
      {
        float __C = 0.0;
        vDSP_dotpr(v29, 1, *(const float **)(*(void *)(a1 + 240) + v30), 1, &__C, *(unsigned int *)(a1 + 216));
        *(float *)(*(void *)(a1 + 312) + 4 * v28) = *(float *)(*(void *)(a1 + 272) + 4 * v28) * __C;
        ++v28;
        v30 += 24;
      }
      while (v28 < *(unsigned int *)(a1 + 220));
    }
  }
  return a1 + 304;
}

uint64_t AccelWin2MFCC::getScalingFactor(AccelWin2MFCC *this)
{
  return (uint64_t)this + 328;
}

void TSAcAnal::init(TSAcAnal *this, const NString *a2, uint64_t a3, const NString *a4, char a5, BOOL a6)
{
  BOOL v14 = a6;
  if (!a3) {
    Error::chuck((Error *)"TSAcAnal::init() - a_iSamRate (= %d) must be strictly positive\n", (const char *)a2, a3, a4, 0);
  }
  int v8 = *((_DWORD *)a4 + 2);
  if (v8 == 8)
  {
    if (**((void **)a4 + 2) != 0x454C5F54414F4C46) {
      goto LABEL_15;
    }
    int v13 = 4;
  }
  else
  {
    if (v8 != 6
      || ((v9 = (int *)*((void *)a4 + 2), int v10 = *v9, v11 = *((unsigned __int16 *)v9 + 2), v10 == 1597387091)
        ? (BOOL v12 = v11 == 17740)
        : (BOOL v12 = 0),
          !v12))
    {
LABEL_15:
      Error::chuck((Error *)"TSAcAnal::init() - sorry, format must be 'S16_LE' or 'FLOAT_LE'", (const char *)a2);
    }
    int v13 = 2;
  }
  *((_DWORD *)this + 285) = v13;
  *((_DWORD *)this + 284) = a3;
  if ((TSAcAnal *)((char *)this + 1112) != a2) {
    (*(void (**)(char *, void, char *))(*((void *)this + 139) + 64))((char *)this + 1112, *((void *)a2 + 2), (char *)a2 + 8);
  }
  *((unsigned char *)this + 1104) = a5;
  NWavChunk2HTKFrames::init(this, (TSAcAnal *)((char *)this + 1112), (const unsigned int *)this + 284, (const BOOL *)this + 1104, &v14);
}

uint64_t TSAcAnal::reset(TSAcAnal *this)
{
  *((unsigned char *)this + 1148) = 0;
  *((_DWORD *)this + 32) = 0;
  *((_DWORD *)this + 138) = *((_DWORD *)this + 134) + 1;
  *((void *)this + 70) = 0;
  *((unsigned char *)this + 556) = 0;
  NDynamicMFCC::reset((TSAcAnal *)((char *)this + 576));
  *((void *)this + 131) = 0;
  *((void *)this + 130) = 0;
  for (uint64_t i = *((void *)this + 127); i; uint64_t i = *((void *)this + 127))
  {
    *((void *)this + 127) = *(void *)(i + 8);
    (*(void (**)(char *))(*((void *)this + 126) + 72))((char *)this + 1008);
  }
  *((void *)this + 128) = 0;
  *((_DWORD *)this + 258) = 0;
  *((void *)this + 132) = 0;
  *(void *)((char *)this + 1061) = 0;

  return NResizingQueue<NFrame>::enlargeBy((uint64_t)this + 1000, (int *)this + 268);
}

float TSAcAnal::get_framerate(TSAcAnal *this)
{
  return *((float *)this + 286);
}

uint64_t TSAcAnal::feedFromInt(TSAcAnal *this, const char *a2, unsigned int *a3)
{
  if (!*((unsigned char *)this + 1149)) {
    Error::chuck((Error *)"TSAcAnal::feedFromInt() - you must call TSAcAnal::init() before feedFromInt()", a2, a3);
  }
  if (*((unsigned char *)this + 1148)) {
    Error::chuck((Error *)"TSAcAnal::feedFromInt() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffer "
  }
               "(m_queue) has been emptied (call reset())",
      a2,
      a3);
  int v4 = 0;
  return NWavChunk2HTKFrames::run((uint64_t)this, a2, (int *)a3, &v4, (uint64_t)this + 1000);
}

uint64_t TSAcAnal::feedFromFloat(TSAcAnal *this, const float *a2, unsigned int *a3)
{
  if (!*((unsigned char *)this + 1149)) {
    Error::chuck((Error *)"TSAcAnal::feedFromFloat() - you must call TSAcAnal::init() before feedFromFloat()", (const char *)a2, a3);
  }
  if (*((unsigned char *)this + 1148)) {
    Error::chuck((Error *)"TSAcAnal::feedFromFloat() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffe"
  }
               "r (m_queue) has been emptied (call reset())",
      (const char *)a2,
      a3);
  int v4 = 1;
  return NWavChunk2HTKFrames::run((uint64_t)this, (const char *)a2, (int *)a3, &v4, (uint64_t)this + 1000);
}

uint64_t TSAcAnal::feed(TSAcAnal *this, const NString *a2)
{
  if (!*((unsigned char *)this + 1149)) {
    Error::chuck((Error *)"TSAcAnal::feed() - you must call TSAcAnal::init() before feed()", (const char *)a2);
  }
  if (*((unsigned char *)this + 1148)) {
    Error::chuck((Error *)"TSAcAnal::feed() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffer (m_queu"
  }
               "e) has been emptied (call reset())",
      (const char *)a2);
  unsigned int v2 = *((_DWORD *)this + 285);
  BOOL v6 = v2 == 4;
  int v3 = (const char *)*((void *)a2 + 2);
  unsigned int v5 = *((_DWORD *)a2 + 2) / v2;
  return NWavChunk2HTKFrames::run((uint64_t)this, v3, (int *)&v5, (int *)&v6, (uint64_t)this + 1000);
}

uint64_t TSAcAnal::endfeed(TSAcAnal *this, const char *a2)
{
  if (!*((unsigned char *)this + 1149)) {
    Error::chuck((Error *)"TSAcAnal::endfeed() - you must call TSAcAnal::init() before endfeed()\n", a2);
  }
  if (*((unsigned char *)this + 1148)) {
    Error::chuck((Error *)"TSAcAnal::endfeed() - TSAcAnal::endfeed() has been called before; is cannot be called againbefore the buf"
  }
               "fer (m_queue) has been emptied\n",
      a2);
  uint64_t result = NWavChunk2HTKFrames::finish((uint64_t)this, (const char *)this + 1000);
  *((unsigned char *)this + 1068) = 1;
  *((unsigned char *)this + 1148) = 1;
  return result;
}

BOOL TSAcAnal::eos(TSAcAnal *this)
{
  if (!*((unsigned char *)this + 1148)) {
    return 0;
  }
  if (*((unsigned char *)this + 1068)) {
    return *((_DWORD *)this + 264) == *((_DWORD *)this + 265);
  }
  return (*((_DWORD *)this + 264) - *((_DWORD *)this + 265)) < 2;
}

BOOL TSAcAnal::framesAvailable(TSAcAnal *this)
{
  if (*((unsigned char *)this + 1068)) {
    return *((_DWORD *)this + 264) != *((_DWORD *)this + 265);
  }
  else {
    return (*((_DWORD *)this + 264) - *((_DWORD *)this + 265)) > 1;
  }
}

void TSAcAnal::getframe(TSAcAnal *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t FrameByRef = TSAcAnal::getFrameByRef(this, a2);
  *(void *)a3 = &unk_26C99C348;
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(FrameByRef + 16);
  operator new[]();
}

uint64_t TSAcAnal::getFrameByRef(TSAcAnal *this, const char *a2)
{
  int v2 = *((_DWORD *)this + 265);
  if (*((unsigned char *)this + 1068)) {
    BOOL v3 = *((_DWORD *)this + 264) != v2;
  }
  else {
    BOOL v3 = (*((_DWORD *)this + 264) - v2) > 1;
  }
  if (!v3) {
    Error::chuck((Error *)"TSAcAnal::getframe() - no frame available", a2);
  }
  uint64_t v5 = *((void *)this + 131);
  *((void *)this + 131) = *(void *)(v5 + 8);
  *((_DWORD *)this + 265) = v2 + 1;
  if ((TSAcAnal *)((char *)this + 1080) != (TSAcAnal *)(v5 + 16))
  {
    unsigned int v6 = *((_DWORD *)this + 274);
    int v7 = *(_DWORD *)(v5 + 32);
    if (v6 != v7)
    {
      uint64_t v8 = *((void *)this + 136);
      if (v8)
      {
        MEMORY[0x21D46B220](v8, 0x1000C8052888210);
        int v7 = *(_DWORD *)(v5 + 32);
      }
      *((_DWORD *)this + 274) = v7;
      operator new[]();
    }
    if (v6)
    {
      uint64_t v9 = 0;
      uint64_t v10 = *(void *)(v5 + 24);
      uint64_t v11 = *((void *)this + 136);
      uint64_t v12 = v6;
      if (v6 < 8) {
        goto LABEL_16;
      }
      if ((unint64_t)(v11 - v10) < 0x20) {
        goto LABEL_16;
      }
      uint64_t v9 = v6 & 0xFFFFFFF8;
      int v13 = (_OWORD *)(v11 + 16);
      BOOL v14 = (long long *)(v10 + 16);
      uint64_t v15 = v12 & 0xFFFFFFF8;
      do
      {
        long long v16 = *v14;
        *(v13 - 1) = *(v14 - 1);
        *int v13 = v16;
        v13 += 2;
        v14 += 2;
        v15 -= 8;
      }
      while (v15);
      if (v9 != v12)
      {
LABEL_16:
        uint64_t v17 = v12 - v9;
        uint64_t v18 = 4 * v9;
        int v19 = (_DWORD *)(v11 + v18);
        uint64_t v20 = (int *)(v10 + v18);
        do
        {
          int v21 = *v20++;
          *v19++ = v21;
          --v17;
        }
        while (v17);
      }
    }
  }
  return (uint64_t)this + 1080;
}

void TSAcAnal::getStringFrame(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 5;
  operator new[]();
}

void sub_218484CD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  *int v13 = a10;
  uint64_t v15 = v13[2];
  if (v15) {
    MEMORY[0x21D46B220](v15, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t TSAcAnal::framesQueued(TSAcAnal *this)
{
  return (*((_DWORD *)this + 264) - *((_DWORD *)this + 265));
}

uint64_t TSAcAnal::isTypeInt4(TSAcAnal *this)
{
  return 0;
}

uint64_t TSAcAnal::parmCode(TSAcAnal *this)
{
  if (*((unsigned char *)this + 929)) {
    int v1 = 0;
  }
  else {
    int v1 = 3 * *((unsigned __int8 *)this + 801);
  }
  return (v1 + (*((unsigned __int8 *)this + 929) | 6) + 768 * *((unsigned __int8 *)this + 984)) | (*((unsigned __int8 *)this + 956) << 13);
}

uint64_t TSAcAnal::frameSize(TSAcAnal *this)
{
  return *((_DWORD *)this + 238) * ((2 * *((unsigned __int8 *)this + 984)) | 1u);
}

uint64_t TSAcAnal::numStatic(TSAcAnal *this)
{
  return *((unsigned int *)this + 238);
}

void sub_218484F14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_2184850A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184853F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_218485530(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_218485790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184858D0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  __cxa_begin_catch(a1);
  uint64_t v10 = *(NSObject **)(v9 + 1952);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_21844F000, v10, OS_LOG_TYPE_DEFAULT, "VTTranscriber endAudio failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x2184858BCLL);
}

void sub_218485948(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  __cxa_begin_catch(a1);
  uint64_t v9 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_21844F000, v9, OS_LOG_TYPE_DEFAULT, "VTTranscriber recognizeWavData failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x218485938);
}

void sub_218485A3C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  __cxa_begin_catch(a1);
  uint64_t v10 = *(NSObject **)(v9 + 1952);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_21844F000, v10, OS_LOG_TYPE_DEFAULT, "VTTranscriber runRecognitionWithCallback failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x218485A24);
}

void sub_218485A84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_218485C34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, __int16 buf)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    uint64_t v11 = VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
    {
      buf = 0;
      _os_log_impl(&dword_21844F000, v11, OS_LOG_TYPE_DEFAULT, "VTTranscriber failed : _EARSpeechRecognizer initWithConfiguration", (uint8_t *)&buf, 2u);
    }
    __cxa_end_catch();
    JUMPOUT(0x218485BF0);
  }
  _Unwind_Resume(exception_object);
}

void nd_create()
{
  if ((initndlib(void)::bNDLibInitialized & 1) == 0) {
    initndlib(void)::bNDLibInitialized = 1;
  }
  operator new();
}

void sub_218485D04(void *a1)
{
  MEMORY[0x21D46B240](v1, 0x10F0C404F423172);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x218485CF4);
}

uint64_t nd_addresource(IntNovDetect *a1, const char *a2, const void *a3)
{
  if (a1) {
    IntNovDetect::addresource(a1, a2, a3);
  }
  return 0xFFFFFFFFLL;
}

void sub_218485E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_initialize(IntNovDetect *a1, const char *a2, const char *a3)
{
  if (a1) {
    IntNovDetect::initialize(a1, a2, a3);
  }
  return 0xFFFFFFFFLL;
}

void sub_218485FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_wavedata(IntNovDetect *a1, const char *a2, int a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  IntNovDetect::wavedata(a1, a2, a3);
  return 0;
}

void sub_2184861AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_wavedataf(IntNovDetect *a1, const float *a2, int a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  IntNovDetect::wavedataf(a1, a2, a3);
  return 0;
}

void sub_218486360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

char *nd_getresults(char *result, const char *a2)
{
  if (result) {
    return IntNovDetect::getresults((IntNovDetect *)result, a2);
  }
  return result;
}

char *nd_getphraseresults(char *result, const char *a2)
{
  if (result) {
    return IntNovDetect::getphraseresults((IntNovDetect *)result, a2);
  }
  return result;
}

uint64_t nd_phrasecount(uint64_t a1, const char *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1838836561)
  {
    int v4 = "Invalid NovDetect Object Signature";
    goto LABEL_9;
  }
  if (*(_DWORD *)(a1 + 4) != 1)
  {
    int v4 = "NovDetect: phrasecount() can only be called after initialize()";
LABEL_9:
    Error::chuck((Error *)v4, a2);
  }
  if (*(unsigned char *)(a1 + 40))
  {
    (*(void (**)(void))(*(void *)(a1 + 16) + 64))();
    *(unsigned char *)(a1 + 40) = 0;
  }
  return *(unsigned int *)(a1 + 3080);
}

void sub_2184868F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

IntNovDetect *nd_getresultsstr(IntNovDetect *result, const char *a2)
{
  if (result) {
    return (IntNovDetect *)IntNovDetect::getresultsstr(result, a2);
  }
  return result;
}

char *nd_getsupervector(char *result, const char *a2, double a3)
{
  if (result) {
    return IntNovDetect::getsupervector((IntNovDetect *)result, a2, a3);
  }
  return result;
}

char *nd_scoresupervector(char *result, const float *a2, uint64_t a3)
{
  if (result) {
    return IntNovDetect::scoresupervector((IntNovDetect *)result, a2, a3);
  }
  return result;
}

uint64_t nd_resetbest(IntNovDetect *a1, const char *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  IntNovDetect::resetbest(a1, a2);
  return 0;
}

void sub_218486FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_reset(IntNovDetect *a1, const char *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  IntNovDetect::reset(a1, a2);
  return 0;
}

void sub_21848716C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_endwavedata(IntNovDetect *a1, const char *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  IntNovDetect::endwavedata(a1, a2);
  return 0;
}

void sub_218487320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_close(IntNovDetect *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  IntNovDetect::~IntNovDetect(a1);
  MEMORY[0x21D46B240]();
  return 0;
}

IntNovDetect *nd_getoption(IntNovDetect *result, const char *a2)
{
  if (result) {
    IntNovDetect::getoption(result, a2);
  }
  return result;
}

uint64_t nd_sat_initialize(IntNovDetect *a1, const char *a2)
{
  if (a1) {
    IntNovDetect::sat_initialize(a1, a2);
  }
  return 0xFFFFFFFFLL;
}

void sub_2184876C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_analyze(uint64_t a1, const char *a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (*(_DWORD *)a1 != -1838836561)
  {
    unsigned int v6 = "Invalid NovDetect Object Signature";
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 12) != 1)
  {
    unsigned int v6 = "NovDetect: sat_analyze() can only be called after sat_initialize()";
LABEL_8:
    Error::chuck((Error *)v6, a2);
  }
  *(_DWORD *)(a1 + 2680) = 0;
  TSSATScorer::score((TSSATScorer *)(a1 + 2184), (const float *)a2, a3);
  uint64_t v4 = a1 + 2680;
  *(_DWORD *)(a1 + 2680) = v5;
  if (*(unsigned char *)(a1 + 40))
  {
    int v8 = 6;
    (*(void (**)(uint64_t, const char *, int *))(*(void *)(a1 + 16) + 64))(a1 + 16, "all ok", &v8);
    *(unsigned char *)(a1 + 40) = 0;
  }
  return v4;
}

void sub_21848790C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_analyzetransformed(uint64_t a1, const char *a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  if (*(_DWORD *)a1 != -1838836561)
  {
    unsigned int v6 = "Invalid NovDetect Object Signature";
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 12) != 1)
  {
    unsigned int v6 = "NovDetect: sat_analyzetransformed() can only be called after sat_initialize()";
LABEL_8:
    Error::chuck((Error *)v6, a2);
  }
  *(_DWORD *)(a1 + 2728) = 0;
  TSSATScorer::scoreSpeakerVector((TSSATScorer *)(a1 + 2184), (const float *)a2, a3);
  uint64_t v4 = a1 + 2728;
  *(_DWORD *)(a1 + 2728) = v5;
  if (*(unsigned char *)(a1 + 40))
  {
    int v8 = 6;
    (*(void (**)(uint64_t, const char *, int *))(*(void *)(a1 + 16) + 64))(a1 + 16, "all ok", &v8);
    *(unsigned char *)(a1 + 40) = 0;
  }
  return v4;
}

void sub_218487B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_update(IntNovDetect *a1, const char *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  IntNovDetect::sat_update(a1, a2);
  return 0;
}

void sub_218487D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_deletevector(IntNovDetect *a1, const char *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  IntNovDetect::sat_deletevector(a1, a2);
  return 0;
}

void sub_218487EBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_vectorcount(uint64_t a1, const char *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != -1838836561)
  {
    uint64_t v4 = "Invalid NovDetect Object Signature";
    goto LABEL_8;
  }
  if (*(_DWORD *)(a1 + 12) != 1)
  {
    uint64_t v4 = "NovDetect: sat_vectorcount() can only be called after sat_initialize()";
LABEL_8:
    Error::chuck((Error *)v4, a2);
  }
  uint64_t v3 = *(unsigned int *)(a1 + 2308);
  if (*(unsigned char *)(a1 + 40))
  {
    (*(void (**)(void))(*(void *)(a1 + 16) + 64))();
    *(unsigned char *)(a1 + 40) = 0;
  }
  return v3;
}

void sub_2184880F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t nd_sat_reset(IntNovDetect *a1, const char *a2)
{
  if (a1) {
    IntNovDetect::sat_reset(a1, a2);
  }
  return 0xFFFFFFFFLL;
}

void sub_2184882A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

IntNovDetect *nd_sat_getspeakervector(IntNovDetect *result, const char *a2)
{
  if (result) {
    IntNovDetect::sat_getspeakervector(result, a2);
  }
  return result;
}

const char *nd_error(uint64_t a1)
{
  if (!a1) {
    return "Invalid NovDetect pointer (NULL)";
  }
  if (*(_DWORD *)(a1 + 4) == 2 || *(_DWORD *)a1 != -1838836561) {
    return "Invalid NovDetect object";
  }
  return *(const char **)(a1 + 32);
}

uint64_t nd_initlog(uint64_t a1)
{
  if ((initndlib(void)::bNDLibInitialized & 1) == 0) {
    initndlib(void)::bNDLibInitialized = 1;
  }
  if (a1) {
    operator new[]();
  }
  return 0;
}

void sub_218488624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x218488610);
  }
  _Unwind_Resume(exception_object);
}

void nd_logcontrol(const char *a1, const char *a2)
{
  if (a1)
  {
    strlen(a1);
    operator new[]();
  }
  Error::chuck((Error *)"Null pointer passed to string constructor", a2);
}

void sub_218488850(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  NLinkedList<NString>::~NLinkedList((uint64_t)va);
  if (a7) {
    MEMORY[0x21D46B220](a7, 0x1000C8077774924);
  }
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8077774924);
  }
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x21848882CLL);
  }
  _Unwind_Resume(a1);
}

void IntNovDetect::IntNovDetect(IntNovDetect *this)
{
  *((void *)this + 2) = &unk_26C99C5B0;
  *((_DWORD *)this + 6) = 0;
  operator new[]();
}

void sub_2184896B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, TSHMMDetector *a14, NLocalCepNorm *a15, uint64_t a16, NConfigSection *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,TSSATScorer *a23,TSSupervectorScorer *a24,TSHMMDetector *a25,uint64_t a26,uint64_t a27,NRingDropBuffer *a28,NWavChunk2HTKFrames *a29)
{
  NLinkedList<NMap<NString,NString>::HashItem>::~NLinkedList(v30 - 152);
  NHash<NMap<NString,NString>::HashItem>::~NHash((void *)(v30 - 120));
  NStringHash<NString>::~NStringHash(a9);
  v29[382] = a10;
  uint64_t v32 = v29[383];
  if (v32) {
    MEMORY[0x21D46B220](v32, 0x1000C8052888210);
  }
  v29[379] = a11;
  uint64_t v33 = v29[380];
  if (v33) {
    MEMORY[0x21D46B220](v33, 0x1000C8052888210);
  }
  v29[376] = a12;
  uint64_t v34 = v29[377];
  if (v34) {
    MEMORY[0x21D46B220](v34, 0x1000C8052888210);
  }
  v29[373] = a13;
  uint64_t v35 = v29[374];
  if (v35) {
    MEMORY[0x21D46B220](v35, 0x1000C80BDFB0063);
  }
  NConfigSection::~NConfigSection(a17);
  v29[354] = a18;
  uint64_t v36 = v29[355];
  if (v36) {
    MEMORY[0x21D46B220](v36, 0x1000C8052888210);
  }
  v29[351] = a19;
  uint64_t v37 = v29[352];
  if (v37) {
    MEMORY[0x21D46B220](v37, 0x1000C8052888210);
  }
  v29[342] = a20;
  uint64_t v38 = v29[343];
  if (v38) {
    MEMORY[0x21D46B220](v38, 0x1000C8052888210);
  }
  v29[338] = a21;
  uint64_t v39 = v29[339];
  if (v39) {
    MEMORY[0x21D46B220](v39, 0x1000C8052888210);
  }
  v29[332] = a22;
  uint64_t v40 = v29[333];
  if (v40) {
    MEMORY[0x21D46B220](v40, 0x1000C8052888210);
  }
  v29[318] = a26;
  uint64_t v41 = v29[320];
  if (v41) {
    MEMORY[0x21D46B220](v41, 0x1000C8077774924);
  }
  v29[315] = &unk_26C99C348;
  uint64_t v42 = v29[316];
  if (v42) {
    MEMORY[0x21D46B220](v42, 0x1000C8052888210);
  }
  NRingDropBuffer::~NRingDropBuffer(a28);
  TSSATScorer::~TSSATScorer(a23);
  TSSupervectorScorer::~TSSupervectorScorer(a24);
  TSHMMDetector::~TSHMMDetector(a25);
  TSHMMDetector::~TSHMMDetector(a14);
  NLocalCepNorm::~NLocalCepNorm(a15);
  TSAcAnal::~TSAcAnal(a29);
  v29[2] = a16;
  uint64_t v43 = v29[4];
  if (v43) {
    MEMORY[0x21D46B220](v43, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void *NStringHash<NString>::~NStringHash(void *a1)
{
  *a1 = &unk_26C99BD30;
  a1[1] = &unk_26C99BF20;
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NConfigSection::~NConfigSection(NConfigSection *this)
{
  *((void *)this + 3) = &unk_26C99BD30;
  *((void *)this + 4) = &unk_26C99BF20;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  *(void *)this = &unk_26C99C5B0;
  uint64_t v7 = *((void *)this + 2);
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
}

void NRingDropBuffer::~NRingDropBuffer(NRingDropBuffer *this)
{
  *(void *)this = &unk_26C99C038;
  uint64_t v1 = *((void *)this + 1);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 24 * v2;
      do
      {
        *(void *)(v1 + v3 - 24) = &unk_26C99C348;
        uint64_t v4 = *(void *)(v1 + v3 - 16);
        if (v4) {
          MEMORY[0x21D46B220](v4, 0x1000C8052888210);
        }
        v3 -= 24;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1081C80622C3295);
  }
}

void NLocalCepNorm::~NLocalCepNorm(NLocalCepNorm *this)
{
  *((void *)this + 7) = &unk_26C99C348;
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  *((void *)this + 4) = &unk_26C99C038;
  uint64_t v3 = *((void *)this + 5);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 - 8);
    if (v4)
    {
      uint64_t v5 = 24 * v4;
      do
      {
        *(void *)(v3 + v5 - 24) = &unk_26C99C348;
        uint64_t v6 = *(void *)(v3 + v5 - 16);
        if (v6) {
          MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        }
        v5 -= 24;
      }
      while (v5);
    }
    MEMORY[0x21D46B220](v3 - 16, 0x1081C80622C3295);
  }
}

void TSAcAnal::~TSAcAnal(TSAcAnal *this)
{
  *((void *)this + 139) = &unk_26C99C5B0;
  uint64_t v2 = *((void *)this + 141);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  *((void *)this + 135) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 136);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 125) = &unk_26C99AB88;
  for (*((void *)this + 126) = &unk_26C99A580;
        ;
        (*(void (**)(char *))(*((void *)this + 126) + 72))((char *)this + 1008))
  {
    uint64_t v4 = *((void *)this + 127);
    if (!v4) {
      break;
    }
    *((void *)this + 127) = *(void *)(v4 + 8);
  }
  *((void *)this + 128) = 0;
  *((_DWORD *)this + 258) = 0;

  NWavChunk2HTKFrames::~NWavChunk2HTKFrames(this);
}

void NWavChunk2HTKFrames::~NWavChunk2HTKFrames(NWavChunk2HTKFrames *this)
{
  *((void *)this + 110) = &unk_26C99C5B0;
  uint64_t v2 = *((void *)this + 112);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  *((void *)this + 107) = &unk_26C99C5B0;
  uint64_t v3 = *((void *)this + 109);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  *((void *)this + 104) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 106);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  *((void *)this + 101) = &unk_26C99C5B0;
  uint64_t v5 = *((void *)this + 103);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  NDynamicMFCC::~NDynamicMFCC((NWavChunk2HTKFrames *)((char *)this + 576));
  AccelWin2MFCC::~AccelWin2MFCC((void **)this + 17);
  *((void *)this + 13) = &unk_26C99C348;
  uint64_t v6 = *((void *)this + 14);
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8052888210);
  }
  *((void *)this + 10) = &unk_26C99C348;
  uint64_t v7 = *((void *)this + 11);
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8052888210);
  }
  *((void *)this + 7) = &unk_26C99C348;
  uint64_t v8 = *((void *)this + 8);
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8052888210);
  }
  *((void *)this + 3) = &unk_26C99C348;
  uint64_t v9 = *((void *)this + 4);
  if (v9) {
    MEMORY[0x21D46B220](v9, 0x1000C8052888210);
  }
  *(void *)this = &unk_26C99C348;
  uint64_t v10 = *((void *)this + 1);
  if (v10) {
    MEMORY[0x21D46B220](v10, 0x1000C8052888210);
  }
}

void NDynamicMFCC::~NDynamicMFCC(NDynamicMFCC *this)
{
  *((void *)this + 25) = &unk_26C99C348;
  uint64_t v2 = *((void *)this + 26);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  *((void *)this + 19) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 20);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  for (*((void *)this + 8) = &unk_26C99A5E0;
        ;
        (*(void (**)(char *))(*((void *)this + 8) + 72))((char *)this + 64))
  {
    uint64_t v4 = *((void *)this + 9);
    if (!v4) {
      break;
    }
    *((void *)this + 9) = *(void *)(v4 + 8);
  }
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  for (*((void *)this + 4) = &unk_26C99A5E0;
        ;
        (*(void (**)(char *))(*((void *)this + 4) + 72))((char *)this + 32))
  {
    uint64_t v5 = *((void *)this + 5);
    if (!v5) {
      break;
    }
    *((void *)this + 5) = *(void *)(v5 + 8);
  }
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *(void *)this = &unk_26C99C348;
  uint64_t v6 = *((void *)this + 1);
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8052888210);
  }
}

uint64_t NLinkedList<NArray<float>>::deleteElement(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void NLinkedList<NArray<float>>::newElement()
{
}

void sub_21848A608(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x10A1C40C9FAA55CLL);
  _Unwind_Resume(a1);
}

void NLinkedList<NArray<float>>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C890;
  a1[2] = &unk_26C99C348;
  uint64_t v1 = a1[3];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8052888210);
  }

  JUMPOUT(0x21D46B240);
}

void *NLinkedList<NArray<float>>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C890;
  a1[2] = &unk_26C99C348;
  uint64_t v2 = a1[3];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  return a1;
}

uint64_t NLinkedList<NArray<float>>::reset(uint64_t result)
{
  uint64_t v1 = result;
  for (uint64_t i = *(void *)(result + 8); i; uint64_t i = *(void *)(v1 + 8))
  {
    *(void *)(v1 + 8) = *(void *)(i + 8);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 72))(v1);
  }
  *(void *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NArray<float>>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)a2;
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4) {
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  }
  if (!v3)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 32);
    return v6();
  }
  if (v3 == v4)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 40);
    return v6();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  for (int i = v3 - 1; i; --i)
    uint64_t v8 = *(void *)(v8 + 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 64))(a1, a3);
  *(void *)(result + 8) = *(void *)(v8 + 8);
  *(void *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<float>>::append(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = (uint64_t *)(a1 + 16);
  if (*(void *)(a1 + 8))
  {
    unsigned int v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    unsigned int v4 = (uint64_t *)(a1 + 16);
    uint64_t v3 = (uint64_t *)(a1 + 8);
  }
  *unsigned int v4 = result;
  *uint64_t v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<float>>::prepend(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    *(void *)(result + 8) = v3;
  }
  else {
    *(void *)(a1 + 16) = result;
  }
  *(void *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<float>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    for (uint64_t i = *(void *)(a2 + 8); i; uint64_t i = *(void *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

void NLinkedList<NArray<float>>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A5E0;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;

  JUMPOUT(0x21D46B240);
}

uint64_t NLinkedList<NArray<float>>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A5E0;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t NLinkedList<NArray<float>>::removeElement(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v4 = (void *)(a1 + 8);
  if (v3 == v5)
  {
    *unsigned int v4 = 0;
    *(void *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *unsigned int v4 = *(void *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      uint64_t v7 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v7 + 8) = 0;
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      uint64_t v6 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v6 + 8) = *(void *)(a2 + 8);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::deleteElement(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::newElement()
{
}

void sub_21848ADD0(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x10A1C40DF491954);
  _Unwind_Resume(a1);
}

void NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C870;
  a1[2] = &unk_26C99C188;
  uint64_t v1 = a1[3];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 40 * v2;
      uint64_t v4 = v1 - 40;
      do
      {
        uint64_t v5 = (void *)(v4 + v3);
        *uint64_t v5 = &unk_26C99C930;
        v5[2] = &unk_26C99C348;
        uint64_t v6 = *(void *)(v4 + v3 + 24);
        if (v6) {
          MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        }
        v3 -= 40;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80C9FAA55CLL);
  }

  JUMPOUT(0x21D46B240);
}

void *NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C870;
  a1[2] = &unk_26C99C188;
  uint64_t v2 = a1[3];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 40 * v3;
      uint64_t v5 = v2 - 40;
      do
      {
        uint64_t v6 = (void *)(v5 + v4);
        *uint64_t v6 = &unk_26C99C930;
        v6[2] = &unk_26C99C348;
        uint64_t v7 = *(void *)(v5 + v4 + 24);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        v4 -= 40;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80C9FAA55CLL);
  }
  return a1;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::reset(uint64_t result)
{
  uint64_t v1 = result;
  for (uint64_t i = *(void *)(result + 8); i; uint64_t i = *(void *)(v1 + 8))
  {
    *(void *)(v1 + 8) = *(void *)(i + 8);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 72))(v1);
  }
  *(void *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)a2;
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4) {
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  }
  if (!v3)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 32);
    return v6();
  }
  if (v3 == v4)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 40);
    return v6();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  for (int i = v3 - 1; i; --i)
    uint64_t v8 = *(void *)(v8 + 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 64))(a1, a3);
  *(void *)(result + 8) = *(void *)(v8 + 8);
  *(void *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::append(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = (uint64_t *)(a1 + 16);
  if (*(void *)(a1 + 8))
  {
    unsigned int v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    unsigned int v4 = (uint64_t *)(a1 + 16);
    uint64_t v3 = (uint64_t *)(a1 + 8);
  }
  *unsigned int v4 = result;
  *uint64_t v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::prepend(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    *(void *)(result + 8) = v3;
  }
  else {
    *(void *)(a1 + 16) = result;
  }
  *(void *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    for (uint64_t i = *(void *)(a2 + 8); i; uint64_t i = *(void *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

void NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A580;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;

  JUMPOUT(0x21D46B240);
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A580;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t NLinkedList<NArray<NResizingQueue<NFrame>::NElement>>::removeElement(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v4 = (void *)(a1 + 8);
  if (v3 == v5)
  {
    *unsigned int v4 = 0;
    *(void *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *unsigned int v4 = *(void *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      uint64_t v7 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v7 + 8) = 0;
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      uint64_t v6 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v6 + 8) = *(void *)(a2 + 8);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

void NResizingQueue<NFrame>::~NResizingQueue(uint64_t a1)
{
  *(void *)a1 = &unk_26C99AB88;
  uint64_t v2 = a1 + 8;
  *(void *)(a1 + 8) = &unk_26C99A580;
  for (uint64_t i = *(void *)(a1 + 16); i; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 72))(v2);
  }
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;

  JUMPOUT(0x21D46B240);
}

uint64_t NResizingQueue<NFrame>::~NResizingQueue(uint64_t a1)
{
  *(void *)a1 = &unk_26C99AB88;
  uint64_t v2 = a1 + 8;
  *(void *)(a1 + 8) = &unk_26C99A580;
  for (uint64_t i = *(void *)(a1 + 16); i; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 72))(v2);
  }
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  return a1;
}

uint64_t NHash<NMap<NString,NString>::HashItem>::NHash(uint64_t a1, unsigned int *a2, char a3)
{
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)a1 = &unk_26C99BE40;
  *(void *)(a1 + 8) = 0;
  unsigned int v4 = *a2;
  if (!a3 && v4 - 1 >= 2)
  {
    unsigned int v5 = v4 | 1;
    if ((v4 & 0xFFFFFFFE) >= 3)
    {
      while (v5 >= 9)
      {
        int v7 = 5;
        while (v5 % (v7 - 2))
        {
          unsigned int v8 = v7 * v7;
          v7 += 2;
          if (v8 > v5) {
            goto LABEL_4;
          }
        }
        unsigned int v4 = v5 + 2;
        unsigned int v9 = v5 + 1;
        v5 += 2;
        if (v9 < 3) {
          goto LABEL_5;
        }
      }
    }
LABEL_4:
    unsigned int v4 = v5;
  }
LABEL_5:
  *(_DWORD *)(a1 + 20) = v4;
  NArray<NLinkedList<NMap<NString,NString>::HashItem>>::resize(a1, (_DWORD *)(a1 + 20));
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

void sub_21848B7C0(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_26C99BF20;
  uint64_t v3 = v1[1];
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 - 8);
    if (v4)
    {
      uint64_t v5 = v3 + 32 * v4;
      do
      {
        uint64_t v6 = v5 - 32;
        for (*(void *)(v5 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v5 - 32) + 72))(v5 - 32))
        {
          uint64_t v7 = *(void *)(v5 - 24);
          if (!v7) {
            break;
          }
          *(void *)(v5 - 24) = *(void *)(v7 + 8);
        }
        *(void *)(v5 - 16) = 0;
        *(_DWORD *)(v5 - 8) = 0;
        v5 -= 32;
      }
      while (v6 != v3);
    }
    MEMORY[0x21D46B220](v3 - 16, 0x10A1C80F4A7E088);
  }
  _Unwind_Resume(exception_object);
}

void NStringHash<NString>::~NStringHash(void *a1)
{
  *a1 = &unk_26C99BD30;
  a1[1] = &unk_26C99BF20;
  uint64_t v1 = a1[2];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

uint64_t NArray<short>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<short>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C80BDFB0063);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = *(void *)(result + 8);
    uint64_t v9 = v4;
    if (v4 < 0x10 || (unint64_t)(v8 - a2) <= 0x1F)
    {
      uint64_t v11 = 0;
LABEL_14:
      uint64_t v16 = v9 - v11;
      uint64_t v17 = 2 * v11;
      uint64_t v18 = (_WORD *)(v8 + v17);
      int v19 = (__int16 *)(a2 + v17);
      do
      {
        __int16 v20 = *v19++;
        *v18++ = v20;
        --v16;
      }
      while (v16);
      return result;
    }
    uint64_t v11 = v4 & 0xFFFFFFF0;
    uint64_t v12 = (_OWORD *)(v8 + 16);
    int v13 = (long long *)(a2 + 16);
    uint64_t v14 = v9 & 0xFFFFFFF0;
    do
    {
      long long v15 = *v13;
      *(v12 - 1) = *(v13 - 1);
      _OWORD *v12 = v15;
      v12 += 2;
      v13 += 2;
      v14 -= 16;
    }
    while (v14);
    if (v11 != v9) {
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t NArray<short>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C80BDFB0063);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      uint64_t v10 = v4;
      if (v4 < 0x10) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFF0;
      uint64_t v11 = (_OWORD *)(v9 + 16);
      uint64_t v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFF0;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *uint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 16;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 2 * v7;
        uint64_t v17 = (_WORD *)(v9 + v16);
        uint64_t v18 = (__int16 *)(v8 + v16);
        do
        {
          __int16 v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  return result;
}

void NArray<short>::~NArray(void *a1)
{
  *a1 = &unk_26C99C428;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C80BDFB0063);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<short>::~NArray(void *a1)
{
  *a1 = &unk_26C99C428;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C80BDFB0063);
  }
  return a1;
}

void AccelStaticMFCC::~AccelStaticMFCC(void **this)
{
  AccelWin2MFCC::~AccelWin2MFCC(this + 11);
  this[7] = &unk_26C99C348;
  uint64_t v2 = this[8];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  this[4] = &unk_26C99C348;
  uint64_t v3 = this[5];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  this[1] = &unk_26C99C348;
  unsigned int v4 = this[2];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
}

uint64_t IntNovDetect::clearError(uint64_t this)
{
  if (*(unsigned char *)(this + 40))
  {
    int v2 = 6;
    uint64_t v1 = this + 16;
    this = (*(uint64_t (**)(uint64_t, const char *, int *))(*(void *)(this + 16) + 64))(this + 16, "all ok", &v2);
    *(unsigned char *)(v1 + 24) = 0;
  }
  return this;
}

void IntNovDetect::~IntNovDetect(IntNovDetect *this)
{
  *(_OWORD *)this = xmmword_21852DE70;
  *((void *)this + 386) = &unk_26C99BD30;
  *((void *)this + 387) = &unk_26C99BF20;
  uint64_t v2 = *((void *)this + 388);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  *((void *)this + 382) = &unk_26C99C348;
  uint64_t v7 = *((void *)this + 383);
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8052888210);
  }
  *((void *)this + 379) = &unk_26C99C3F0;
  uint64_t v8 = *((void *)this + 380);
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8052888210);
  }
  *((void *)this + 376) = &unk_26C99C3F0;
  uint64_t v9 = *((void *)this + 377);
  if (v9) {
    MEMORY[0x21D46B220](v9, 0x1000C8052888210);
  }
  *((void *)this + 373) = &unk_26C99C428;
  uint64_t v10 = *((void *)this + 374);
  if (v10) {
    MEMORY[0x21D46B220](v10, 0x1000C80BDFB0063);
  }
  *((void *)this + 365) = &unk_26C99BD30;
  *((void *)this + 366) = &unk_26C99BF20;
  uint64_t v11 = *((void *)this + 367);
  if (v11)
  {
    uint64_t v12 = *(void *)(v11 - 8);
    if (v12)
    {
      uint64_t v13 = v11 + 32 * v12;
      do
      {
        uint64_t v14 = v13 - 32;
        for (*(void *)(v13 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v13 - 32) + 72))(v13 - 32))
        {
          uint64_t v15 = *(void *)(v13 - 24);
          if (!v15) {
            break;
          }
          *(void *)(v13 - 24) = *(void *)(v15 + 8);
        }
        *(void *)(v13 - 16) = 0;
        *(_DWORD *)(v13 - 8) = 0;
        v13 -= 32;
      }
      while (v14 != v11);
    }
    MEMORY[0x21D46B220](v11 - 16, 0x10A1C80F4A7E088);
  }
  *((void *)this + 362) = &unk_26C99C5B0;
  uint64_t v16 = *((void *)this + 364);
  if (v16) {
    MEMORY[0x21D46B220](v16, 0x1000C8077774924);
  }
  *((void *)this + 354) = &unk_26C99C348;
  uint64_t v17 = *((void *)this + 355);
  if (v17) {
    MEMORY[0x21D46B220](v17, 0x1000C8052888210);
  }
  *((void *)this + 351) = &unk_26C99C348;
  uint64_t v18 = *((void *)this + 352);
  if (v18) {
    MEMORY[0x21D46B220](v18, 0x1000C8052888210);
  }
  *((void *)this + 342) = &unk_26C99C3F0;
  uint64_t v19 = *((void *)this + 343);
  if (v19) {
    MEMORY[0x21D46B220](v19, 0x1000C8052888210);
  }
  *((void *)this + 338) = &unk_26C99C348;
  uint64_t v20 = *((void *)this + 339);
  if (v20) {
    MEMORY[0x21D46B220](v20, 0x1000C8052888210);
  }
  *((void *)this + 332) = &unk_26C99C348;
  uint64_t v21 = *((void *)this + 333);
  if (v21) {
    MEMORY[0x21D46B220](v21, 0x1000C8052888210);
  }
  *((void *)this + 318) = &unk_26C99C5B0;
  uint64_t v22 = *((void *)this + 320);
  if (v22) {
    MEMORY[0x21D46B220](v22, 0x1000C8077774924);
  }
  *((void *)this + 315) = &unk_26C99C348;
  uint64_t v23 = *((void *)this + 316);
  if (v23) {
    MEMORY[0x21D46B220](v23, 0x1000C8052888210);
  }
  *((void *)this + 311) = &unk_26C99C038;
  uint64_t v24 = *((void *)this + 312);
  if (v24)
  {
    uint64_t v25 = *(void *)(v24 - 8);
    if (v25)
    {
      uint64_t v26 = 24 * v25;
      do
      {
        *(void *)(v24 + v26 - 24) = &unk_26C99C348;
        uint64_t v27 = *(void *)(v24 + v26 - 16);
        if (v27) {
          MEMORY[0x21D46B220](v27, 0x1000C8052888210);
        }
        v26 -= 24;
      }
      while (v26);
    }
    MEMORY[0x21D46B220](v24 - 16, 0x1081C80622C3295);
  }
  TSSATScorer::~TSSATScorer((IntNovDetect *)((char *)this + 2184));
  *((void *)this + 263) = &unk_26C99B368;
  uint64_t v28 = *((void *)this + 264);
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  *((void *)this + 264) = 0;
  *((void *)this + 269) = &unk_26C99C348;
  uint64_t v29 = *((void *)this + 270);
  if (v29) {
    MEMORY[0x21D46B220](v29, 0x1000C8052888210);
  }
  *((void *)this + 266) = &unk_26C99C348;
  uint64_t v30 = *((void *)this + 267);
  if (v30) {
    MEMORY[0x21D46B220](v30, 0x1000C8052888210);
  }
  TSHMMDetector::~TSHMMDetector((IntNovDetect *)((char *)this + 1696));
  TSHMMDetector::~TSHMMDetector((IntNovDetect *)((char *)this + 1288));
  *((void *)this + 157) = &unk_26C99C348;
  uint64_t v31 = *((void *)this + 158);
  if (v31) {
    MEMORY[0x21D46B220](v31, 0x1000C8052888210);
  }
  *((void *)this + 154) = &unk_26C99C038;
  uint64_t v32 = *((void *)this + 155);
  if (v32)
  {
    uint64_t v33 = *(void *)(v32 - 8);
    if (v33)
    {
      uint64_t v34 = 24 * v33;
      do
      {
        *(void *)(v32 + v34 - 24) = &unk_26C99C348;
        uint64_t v35 = *(void *)(v32 + v34 - 16);
        if (v35) {
          MEMORY[0x21D46B220](v35, 0x1000C8052888210);
        }
        v34 -= 24;
      }
      while (v34);
    }
    MEMORY[0x21D46B220](v32 - 16, 0x1081C80622C3295);
  }
  *((void *)this + 145) = &unk_26C99C5B0;
  uint64_t v36 = *((void *)this + 147);
  if (v36) {
    MEMORY[0x21D46B220](v36, 0x1000C8077774924);
  }
  *((void *)this + 141) = &unk_26C99C348;
  uint64_t v37 = *((void *)this + 142);
  if (v37) {
    MEMORY[0x21D46B220](v37, 0x1000C8052888210);
  }
  *((void *)this + 131) = &unk_26C99AB88;
  for (*((void *)this + 132) = &unk_26C99A580;
        ;
        (*(void (**)(char *))(*((void *)this + 132) + 72))((char *)this + 1056))
  {
    uint64_t v38 = *((void *)this + 133);
    if (!v38) {
      break;
    }
    *((void *)this + 133) = *(void *)(v38 + 8);
  }
  *((void *)this + 134) = 0;
  *((_DWORD *)this + 270) = 0;
  NWavChunk2HTKFrames::~NWavChunk2HTKFrames((IntNovDetect *)((char *)this + 48));
  *((void *)this + 2) = &unk_26C99C5B0;
  uint64_t v39 = *((void *)this + 4);
  if (v39) {
    MEMORY[0x21D46B220](v39, 0x1000C8077774924);
  }
}

void IntNovDetect::addresource(IntNovDetect *this, const char *__s, const void *a3)
{
  if (*(_DWORD *)this == -1838836561)
  {
    if (!*((_DWORD *)this + 1))
    {
      if (__s)
      {
        strlen(__s);
        operator new[]();
      }
      Error::chuck((Error *)"Null pointer passed to string constructor", 0, a3);
    }
    Error::chuck((Error *)"NovDetect: addresource() can only be called after create()", __s, a3);
  }
  Error::chuck((Error *)"Invalid NovDetect Object Signature", __s, a3);
}

void sub_21848CA30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a15) {
    MEMORY[0x21D46B220](a15, 0x1000C8077774924);
  }
  if (a18) {
    MEMORY[0x21D46B220](a18, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NMap<NString,NString>::operator[]()
{
}

{
  operator new[]();
}

void sub_21848CE08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a15) {
    MEMORY[0x21D46B220](a15, 0x1000C8077774924);
  }
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

const NString *IntNovDetect::mapfile(IntNovDetect *this, const NString *a2)
{
  if (*((_DWORD *)a2 + 2) >= 7u)
  {
    uint64_t v2 = (int *)*((void *)a2 + 2);
    int v3 = *v2;
    int v4 = *(int *)((char *)v2 + 3);
    if (v3 == 1684957549 && v4 == 980968804) {
      NMap<NString,NString>::find();
    }
  }
  return a2;
}

void NMap<NString,NString>::find()
{
}

void sub_21848D134(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a18) {
    MEMORY[0x21D46B220](a18, 0x1000C8077774924);
  }
  if (a15) {
    MEMORY[0x21D46B220](a15, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void IntNovDetect::initialize(IntNovDetect *this, const char *a2, const char *a3)
{
  if (*(_DWORD *)this == -1838836561)
  {
    if (!*((_DWORD *)this + 1))
    {
      LOBYTE(v7) = 0;
      NConfig::NConfig((NConfig *)v9, (const BOOL *)&v7);
      if (a2)
      {
        if (a3)
        {
          if (strncmp(a2, "CONFIGSTR: ", 0xBuLL))
          {
            uint64_t v7 = &unk_26C99C5B0;
            int v8 = strlen(a2);
            operator new[]();
          }
          uint64_t v7 = &unk_26C99C5B0;
          int v8 = strlen(a2 + 11);
          operator new[]();
        }
        uint64_t v6 = "NovDetect: initialize() cannot be called with rootpath = NULL";
      }
      else
      {
        uint64_t v6 = "NovDetect: initialize() cannot be called with filename = NULL";
      }
      Error::chuck((Error *)v6, v5);
    }
    Error::chuck((Error *)"NovDetect: initialize() can only be called after create()", a2, a3);
  }
  Error::chuck((Error *)"Invalid NovDetect Object Signature", a2, a3);
}

void sub_2184931FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  v41[24] = a32;
  uint64_t v44 = v41[26];
  if (v44) {
    MEMORY[0x21D46B220](v44, 0x1000C8077774924);
  }
  v41[27] = a33;
  uint64_t v45 = v41[29];
  if (v45) {
    MEMORY[0x21D46B220](v45, 0x1000C8077774924);
  }
  v41[30] = a35;
  uint64_t v46 = v41[32];
  if (v46) {
    MEMORY[0x21D46B220](v46, 0x1000C8077774924);
  }
  v41[33] = a36;
  uint64_t v47 = v41[35];
  if (v47) {
    MEMORY[0x21D46B220](v47, 0x1000C8077774924);
  }
  v41[36] = a37;
  uint64_t v48 = v41[38];
  if (v48) {
    MEMORY[0x21D46B220](v48, 0x1000C8077774924);
  }
  v41[39] = a38;
  uint64_t v49 = v41[41];
  if (v49) {
    MEMORY[0x21D46B220](v49, 0x1000C8077774924);
  }
  v41[42] = a39;
  uint64_t v50 = v41[44];
  if (v50) {
    MEMORY[0x21D46B220](v50, 0x1000C8077774924);
  }
  v41[45] = a40;
  uint64_t v51 = v41[47];
  if (v51) {
    MEMORY[0x21D46B220](v51, 0x1000C8077774924);
  }
  v41[48] = a41;
  uint64_t v52 = v41[50];
  if (v52) {
    MEMORY[0x21D46B220](v52, 0x1000C8077774924);
  }
  NConfig::~NConfig((NConfig *)(v42 - 184));
  _Unwind_Resume(a1);
}

void IntNovDetect::addLengthKeywords(IntNovDetect *this, const NString *a2)
{
  int v4 = &unk_26C99C0A8;
  uint64_t v5 = 0;
  int v6 = 0;
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 1;
  operator new[]();
}

void sub_218494980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  if (a7) {
    MEMORY[0x21D46B220](a7, 0x1000C8077774924);
  }
  if (a4) {
    MEMORY[0x21D46B220](a4, 0x1000C8077774924);
  }
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
  }
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8077774924);
  }
  NArray<NString>::~NArray((uint64_t *)va);
  _Unwind_Resume(a1);
}

void IntNovDetect::zeroWavePrime(IntNovDetect *this, const char *a2)
{
  int v3 = (int *)((char *)this + 3000);
  int v4 = *((_DWORD *)this + 690);
  if (*((_DWORD *)this + 750) != v4)
  {
    *((_DWORD *)this + 750) = v4;
    operator new[]();
  }
  if (*((_DWORD *)this + 745))
  {
    unsigned int v5 = 0;
    do
    {
      if (!*((unsigned char *)this + 1197)) {
        Error::chuck((Error *)"TSAcAnal::feedFromInt() - you must call TSAcAnal::init() before feedFromInt()", a2);
      }
      if (*((unsigned char *)this + 1196)) {
        Error::chuck((Error *)"TSAcAnal::feedFromInt() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buf"
      }
                   "fer (m_queue) has been emptied (call reset())",
          a2);
      int v6 = (const char *)*((void *)this + 374);
      int v9 = 0;
      NWavChunk2HTKFrames::run((uint64_t)this + 48, v6, v3, &v9, (uint64_t)this + 1048);
      IntNovDetect::advanceDetection(this, v7, v8);
      ++v5;
    }
    while (v5 < *((_DWORD *)this + 745));
  }
}

void IntNovDetect::advanceDetection(IntNovDetect *this, const char *a2, double a3)
{
  int v4 = (IntNovDetect *)((char *)this + 48);
  unsigned int v5 = (int32x2_t *)((char *)this + 1200);
  int v6 = (IntNovDetect *)((char *)this + 2520);
  uint64_t v7 = (IntNovDetect *)((char *)this + 1288);
  double v8 = (char *)this + 2488;
  int v9 = (IntNovDetect *)((char *)this + 1696);
LABEL_2:
  while (1)
  {
    uint64_t v10 = (const NFrame *)*((void *)this + 370);
    if (!v10) {
      break;
    }
    int v11 = *((_DWORD *)this + 743);
    if (!v11)
    {
      *((void *)this + 370) = 0;
      break;
    }
    *((_DWORD *)this + 743) = v11 - 1;
LABEL_18:
    if (*((unsigned char *)this + 2884))
    {
      *(int32x2_t *)&a3 = NLocalCepNorm::pushFrame(v5, v10);
      int v16 = *((_DWORD *)this + 304);
      if (*((unsigned char *)this + 1284) && v16 || v16 == *((_DWORD *)this + 307) + 1)
      {
        NLocalCepNorm::setOutputFrame((NLocalCepNorm *)v5, v6);
        TSHMMDetector::feedFrame(v7, v6, v17);
        if (!*((unsigned char *)this + 2891)) {
          goto LABEL_29;
        }
        NRingDropBuffer::pushFrame((uint64_t)v8, v6);
        uint64_t v10 = v6;
        if (!*((unsigned char *)this + 2892)) {
          goto LABEL_29;
        }
LABEL_27:
        uint64_t v18 = v9;
        uint64_t v19 = v10;
        goto LABEL_28;
      }
    }
    else
    {
      TSHMMDetector::feedFrame(v7, v10, a3);
      if (*((unsigned char *)this + 2891))
      {
        NRingDropBuffer::pushFrame((uint64_t)v8, v10);
        if (*((unsigned char *)this + 2892)) {
          goto LABEL_27;
        }
      }
      while (1)
      {
LABEL_29:
        int v20 = *((_DWORD *)this + 744);
        if (v20)
        {
          *((_DWORD *)this + 744) = v20 - 1;
          if (!*((unsigned char *)this + 2884)) {
            goto LABEL_2;
          }
        }
        else
        {
          ++*((_DWORD *)this + 693);
          IntNovDetect::innerAdvanceDetection(this, a2, a3);
          if (!*((unsigned char *)this + 2884)) {
            goto LABEL_2;
          }
        }
        int v21 = *((_DWORD *)this + 304);
        if ((!*((unsigned char *)this + 1284) || !v21) && v21 != *((_DWORD *)this + 307) + 1) {
          break;
        }
        NLocalCepNorm::setOutputFrame((NLocalCepNorm *)v5, v6);
        TSHMMDetector::feedFrame(v7, v6, v22);
        if (*((unsigned char *)this + 2891))
        {
          NRingDropBuffer::pushFrame((uint64_t)v8, v6);
          if (*((unsigned char *)this + 2892))
          {
            uint64_t v18 = v9;
            uint64_t v19 = v6;
LABEL_28:
            TSHMMDetector::feedFrame(v18, v19, a3);
          }
        }
      }
    }
  }
  if (*((unsigned char *)this + 1116)) {
    BOOL v12 = *((_DWORD *)this + 276) != *((_DWORD *)this + 277);
  }
  else {
    BOOL v12 = (*((_DWORD *)this + 276) - *((_DWORD *)this + 277)) > 1;
  }
  if (v12)
  {
    uint64_t FrameByRef = TSAcAnal::getFrameByRef(v4, a2);
    uint64_t v10 = (const NFrame *)FrameByRef;
    if (*((_DWORD *)this + 2) != 2
      && *((unsigned char *)this + 1196)
      && (*((unsigned char *)this + 1116)
        ? *((_DWORD *)this + 276) == *((_DWORD *)this + 277)
        : (*((_DWORD *)this + 276) - *((_DWORD *)this + 277)) < 2))
    {
      Error::chuck((Error *)"NovDetect: advanceDetection() - acanal has shut down!", v14);
    }
    if (*((_DWORD *)this + 743)) {
      *((void *)this + 370) = FrameByRef;
    }
    goto LABEL_18;
  }
}

void IntNovDetect::innerAdvanceDetection(IntNovDetect *this, const char *a2, double a3)
{
  int v4 = (IntNovDetect *)((char *)this + 1288);
  unsigned int v5 = (float *)((char *)this + 2872);
  int v6 = (float *)((char *)this + 2856);
  uint64_t v7 = (char *)this + 2882;
  double v8 = (char *)this + 2808;
  int v9 = (unsigned __int8 *)this + 2880;
  uint64_t v10 = (unsigned int *)((char *)this + 2772);
  while ((TSHMMDetector::updateResult(v4, a2, a3) & 1) != 0)
  {
    int v11 = *((_DWORD *)this + 414);
    if (*((_DWORD *)this + 369))
    {
      int v12 = v11 - *((_DWORD *)this + 409);
      if (v12)
      {
        float v13 = *((float *)this + 408);
        float v14 = *((float *)this + 718);
        if (v14 == 1.0)
        {
          *(float *)&a3 = (float)v12;
          goto LABEL_8;
        }
        if (v14 != 0.0)
        {
          *(float *)&a3 = powf((float)v12, v14);
LABEL_8:
          float v13 = v13 / *(float *)&a3;
        }
        *(float *)&a3 = v13 + *((float *)this + 714);
        if (*(float *)&a3 > *((float *)this + 716)) {
          *((unsigned char *)this + 2893) = 1;
        }
      }
    }
    int v33 = v11 - *((_DWORD *)this + 411);
    if (v33)
    {
      int v32 = 0;
      *(float *)&a3 = IntNovDetect::getBestLengthNormalizedPhraseScore((uint64_t)this, (uint64_t)v4, v5, v7, (uint64_t)v8, &v33, &v32, v9);
      float v15 = *(float *)&a3;
      if (!*((unsigned char *)this + 2891)) {
        goto LABEL_20;
      }
      LODWORD(a3) = *((_DWORD *)this + 715);
      if (v15 > *(float *)&a3)
      {
        if (!*((unsigned char *)this + 2892))
        {
          IntNovDetect::rescoreInit(this);
          *((unsigned char *)this + 2892) = 1;
        }
        *((_DWORD *)this + 697) = *((_DWORD *)this + 698);
        goto LABEL_20;
      }
      int v16 = *((_DWORD *)this + 697);
      if (v16 && (int v17 = v16 - 1, (*((_DWORD *)this + 697) = v17) == 0))
      {
        IntNovDetect::rescoreComplete(this, a2, a3);
        *((unsigned char *)this + 2892) = 0;
LABEL_21:
        float v18 = v15 + *((float *)this + 714);
        if (v18 > *((float *)this + 700))
        {
          int v19 = *((_DWORD *)this + 413) - *((_DWORD *)this + 414) + *((_DWORD *)this + 372);
          unsigned int v20 = v19 & ~(v19 >> 31);
          BOOL v21 = *v10 >= v20;
          unsigned int v22 = *v10 - v20;
          if (v22 != 0 && v21)
          {
            *((_DWORD *)this + 694) = v22;
            *((_DWORD *)this + 695) = v33;
            *((_DWORD *)this + 696) = v32;
            *((float *)this + 700) = v18;
          }
        }
        IntNovDetect::updateMultiphraseResults((uint64_t)this, (uint64_t)v4, v5, v6, (uint64_t)v8, v10, v9);
      }
      else
      {
LABEL_20:
        if (!*((unsigned char *)this + 2892)) {
          goto LABEL_21;
        }
      }
    }
  }
  if (*((unsigned char *)this + 2892))
  {
    while (1)
    {
      if (!TSHMMDetector::updateResult((IntNovDetect *)((char *)this + 1696), a2, a3)) {
        return;
      }
      int v23 = *((_DWORD *)this + 516);
      if (*((_DWORD *)this + 471))
      {
        int v24 = v23 - *((_DWORD *)this + 511);
        if (v24) {
          break;
        }
      }
LABEL_40:
      int v33 = v23 - *((_DWORD *)this + 513);
      if (v33)
      {
        int v32 = 0;
        float BestLengthNormalizedPhraseScore = IntNovDetect::getBestLengthNormalizedPhraseScore((uint64_t)this, (uint64_t)this + 1696, (float *)this + 719, (unsigned char *)this + 2883, (uint64_t)this + 2832, &v33, &v32, (unsigned __int8 *)this + 2881);
        if (BestLengthNormalizedPhraseScore > *((float *)this + 700))
        {
          int v28 = *((_DWORD *)this + 515) - *((_DWORD *)this + 516) + *((_DWORD *)this + 474);
          unsigned int v29 = v28 & ~(v28 >> 31);
          BOOL v21 = *v10 >= v29;
          unsigned int v30 = *v10 - v29;
          if (v30 != 0 && v21)
          {
            *((_DWORD *)this + 694) = v30;
            *((_DWORD *)this + 695) = v33;
            *((_DWORD *)this + 696) = v32;
            *((float *)this + 700) = BestLengthNormalizedPhraseScore;
          }
        }
        int v31 = 0;
        IntNovDetect::updateMultiphraseResults((uint64_t)this, (uint64_t)this + 1696, (float *)this + 719, (float *)&v31, (uint64_t)this + 2832, v10, (unsigned __int8 *)this + 2881);
      }
      if (!*((unsigned char *)this + 2892)) {
        return;
      }
    }
    float v25 = *((float *)this + 510);
    float v26 = *((float *)this + 719);
    if (v26 == 1.0)
    {
      *(float *)&a3 = (float)v24;
    }
    else
    {
      if (v26 == 0.0)
      {
LABEL_38:
        LODWORD(a3) = *((_DWORD *)this + 717);
        if (v25 > *(float *)&a3) {
          *((unsigned char *)this + 2893) = 1;
        }
        goto LABEL_40;
      }
      *(float *)&a3 = powf((float)v24, v26);
    }
    float v25 = v25 / *(float *)&a3;
    goto LABEL_38;
  }
}

float IntNovDetect::getBestLengthNormalizedPhraseScore(uint64_t a1, uint64_t a2, float *a3, unsigned char *a4, uint64_t a5, _DWORD *a6, _DWORD *a7, unsigned __int8 *a8)
{
  if (!*a4)
  {
    *a7 = *(_DWORD *)(a2 + 360);
    int v20 = *(_DWORD *)(a2 + 368) - *(_DWORD *)(a2 + 356);
    *a6 = v20;
    float v13 = *(float *)(a2 + 352);
    float v21 = *a3;
    if (*a3 == 1.0)
    {
      float v22 = (float)v20;
    }
    else
    {
      if (v21 == 0.0)
      {
LABEL_31:
        uint64_t v40 = *a7;
        if (v40 < *(_DWORD *)(a5 + 16)) {
          return v13 + *(float *)(*(void *)(a5 + 8) + 4 * v40);
        }
        return v13;
      }
      float v22 = powf((float)v20, v21);
    }
    float v13 = v13 / v22;
    goto LABEL_31;
  }
  unsigned int v12 = *(_DWORD *)(a2 + 176);
  int v44 = *a8;
  if (v12 >= v44 + 1)
  {
    unint64_t v23 = 0;
    unsigned int v24 = v12 / (v44 + 1);
    float v25 = *(unsigned int **)(a2 + 168);
    float v26 = *a3;
    uint64_t v27 = *(void *)(a5 + 8);
    if (v24 <= 1) {
      uint64_t v28 = 1;
    }
    else {
      uint64_t v28 = v24;
    }
    unsigned int v29 = (void *)(*(void *)(a2 + 304) + 32);
    float v13 = -1000000.0;
    while (1)
    {
      unint64_t v30 = *(unsigned int *)(a2 + 176);
      if (v23 >= v30) {
        Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, v23, v30);
      }
      uint64_t v31 = *v25;
      int v32 = *(_DWORD *)(*v29 + 4 * v31);
      int v33 = *(_DWORD *)(a2 + 368);
      int v34 = v33 - v32;
      if (v33 == v32) {
        goto LABEL_15;
      }
      float v35 = *(float *)(*(v29 - 3) + 4 * v31) * (float)*(unsigned int *)(a2 + 196);
      if (v26 == 1.0)
      {
        float v36 = (float)v34;
      }
      else
      {
        if (v26 == 0.0) {
          goto LABEL_22;
        }
        float v36 = powf((float)v34, v26);
      }
      float v35 = v35 / v36;
LABEL_22:
      if (v23 < *(unsigned int *)(a5 + 16)) {
        float v35 = v35 + *(float *)(v27 + 4 * v23);
      }
      if (v35 > v13)
      {
        *a6 = v34;
        *a7 = v23;
        float v13 = v35;
      }
LABEL_15:
      ++v23;
      v25 += 22;
      v29 += 6;
      if (v28 == v23) {
        goto LABEL_4;
      }
    }
  }
  float v13 = -1000000.0;
LABEL_4:
  if (v44)
  {
    uint64_t v14 = *(unsigned int *)(a2 + 176);
    unsigned int v15 = *a7 + (v14 >> 1);
    if (v15 >= v14) {
      Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, *a7 + (v14 >> 1), v14);
    }
    uint64_t v16 = *(unsigned int *)(*(void *)(a2 + 168) + 88 * v15);
    uint64_t v17 = *(void *)(a2 + 304);
    int v18 = *(_DWORD *)(a2 + 368) - *(_DWORD *)(*(void *)(v17 + 48 * v15 + 32) + 4 * v16);
    if (!v18)
    {
      unsigned int v19 = 0;
LABEL_35:
      *a6 = v19;
      return v13;
    }
    float v37 = *(float *)(*(void *)(v17 + 48 * v15 + 8) + 4 * v16) * (float)*(unsigned int *)(a2 + 196);
    float v38 = *a3;
    if (*a3 == 1.0)
    {
      float v39 = (float)v18;
    }
    else
    {
      if (v38 == 0.0) {
        goto LABEL_34;
      }
      float v39 = powf((float)v18, v38);
    }
    float v37 = v37 / v39;
LABEL_34:
    unsigned int v19 = ((float)(fmaxf(v37, 0.0) * *(float *)(a1 + 1192)) + 0.5);
    goto LABEL_35;
  }
  return v13;
}

void IntNovDetect::rescoreInit(IntNovDetect *this)
{
  int v2 = *((_DWORD *)this + 414);
  int v3 = v2 - *((_DWORD *)this + 411);
  int v4 = *((_DWORD *)this + 413) - v2 + *((_DWORD *)this + 372);
  int v5 = (v4 & ~(v4 >> 31)) + v3;
  int v6 = (IntNovDetect *)((char *)this + 1696);
  int v7 = *((_DWORD *)this + 515) - *((_DWORD *)this + 516) + *((_DWORD *)this + 474);
  unsigned int v8 = v5 + (v7 & ~(v7 >> 31)) + *((_DWORD *)this + 699) - (v7 > 0);
  unsigned int v9 = *((_DWORD *)this + 629);
  uint64_t v10 = (IntNovDetect *)((char *)this + 1696);
  unsigned int v11 = v9 - v8;
  if (v9 <= v8)
  {
    TSHMMDetector::reset(v10);
LABEL_5:
    unsigned int v11 = 0;
    unsigned int v14 = 0;
    unsigned int v13 = *((_DWORD *)this + 629);
    if (v13 != *((_DWORD *)this + 626)) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  TSHMMDetector::reset(v10);
  if (!v11) {
    goto LABEL_5;
  }
  unsigned int v13 = *((_DWORD *)this + 629);
LABEL_6:
  *((unsigned char *)this + 2098) = 1;
  unsigned int v14 = v11;
LABEL_7:
  unsigned int v15 = *((_DWORD *)this + 693);
  unsigned int v16 = v15 + v14 - v13;
  if (v15 >= v13 - v14) {
    unsigned int v17 = 0;
  }
  else {
    unsigned int v17 = v13 - (v15 + v14);
  }
  while (v14 < v13)
  {
    unsigned int v18 = *((_DWORD *)this + 626);
    unsigned int v19 = *((_DWORD *)this + 628) + v14 + v18 - v13;
    if (v19 >= v18) {
      int v20 = *((_DWORD *)this + 626);
    }
    else {
      int v20 = 0;
    }
    TSHMMDetector::feedFrame(v6, (const NFrame *)(*((void *)this + 312) + 24 * (v19 - v20)), v12);
    int v29 = ++v16;
    if (v17)
    {
      --v17;
    }
    else
    {
      while (TSHMMDetector::updateResult(v6, v21, v12))
      {
        int v28 = *((_DWORD *)this + 516) - *((_DWORD *)this + 513);
        if (v28)
        {
          int v27 = 0;
          float BestLengthNormalizedPhraseScore = IntNovDetect::getBestLengthNormalizedPhraseScore((uint64_t)this, (uint64_t)v6, (float *)this + 719, (unsigned char *)this + 2883, (uint64_t)this + 2832, &v28, &v27, (unsigned __int8 *)this + 2881);
          int v23 = *((_DWORD *)this + 515) - *((_DWORD *)this + 516) + *((_DWORD *)this + 474);
          unsigned int v24 = v23 & ~(v23 >> 31);
          if (BestLengthNormalizedPhraseScore > *((float *)this + 700) && v16 > v24)
          {
            *((_DWORD *)this + 694) = v16 - v24;
            *((_DWORD *)this + 695) = v28;
            *((_DWORD *)this + 696) = v27;
            *((float *)this + 700) = BestLengthNormalizedPhraseScore;
          }
          int v26 = 0;
          IntNovDetect::updateMultiphraseResults((uint64_t)this, (uint64_t)v6, (float *)this + 719, (float *)&v26, (uint64_t)this + 2832, &v29, (unsigned __int8 *)this + 2881);
        }
      }
      unsigned int v17 = 0;
    }
    ++v14;
    unsigned int v13 = *((_DWORD *)this + 629);
  }
}

uint64_t IntNovDetect::rescoreComplete(IntNovDetect *this, const char *a2, double a3)
{
  if (*((unsigned char *)this + 2887)) {
    TSHMMDetector::padToEndOfBatch((IntNovDetect *)((char *)this + 1696));
  }
  unsigned int v4 = *((_DWORD *)this + 693);
  unsigned int v13 = v4;
  while (1)
  {
    uint64_t result = TSHMMDetector::updateResult((IntNovDetect *)((char *)this + 1696), a2, a3);
    if ((result & 1) == 0)
    {
      if (!*((unsigned char *)this + 2888)) {
        break;
      }
      uint64_t result = TSHMMDetector::endFrame((IntNovDetect *)((char *)this + 1696), a2, a3);
      if (!result) {
        break;
      }
    }
    int v12 = *((_DWORD *)this + 516) - *((_DWORD *)this + 513);
    if (v12)
    {
      int v11 = 0;
      float BestLengthNormalizedPhraseScore = IntNovDetect::getBestLengthNormalizedPhraseScore((uint64_t)this, (uint64_t)this + 1696, (float *)this + 719, (unsigned char *)this + 2883, (uint64_t)this + 2832, &v12, &v11, (unsigned __int8 *)this + 2881);
      int v7 = *((_DWORD *)this + 515) - *((_DWORD *)this + 516) + *((_DWORD *)this + 474);
      unsigned int v8 = v7 & ~(v7 >> 31);
      if (BestLengthNormalizedPhraseScore > *((float *)this + 700) && v4 > v8)
      {
        *((_DWORD *)this + 694) = v4 - v8;
        *((_DWORD *)this + 695) = v12;
        *((_DWORD *)this + 696) = v11;
        *((float *)this + 700) = BestLengthNormalizedPhraseScore;
      }
      int v10 = 0;
      IntNovDetect::updateMultiphraseResults((uint64_t)this, (uint64_t)this + 1696, (float *)this + 719, (float *)&v10, (uint64_t)this + 2832, &v13, (unsigned __int8 *)this + 2881);
    }
  }
  *((unsigned char *)this + 2892) = 0;
  return result;
}

void IntNovDetect::updateMultiphraseResults(uint64_t a1, uint64_t a2, float *a3, float *a4, uint64_t a5, _DWORD *a6, unsigned __int8 *a7)
{
  unsigned int v7 = *(_DWORD *)(a1 + 3080);
  if (!v7) {
    return;
  }
  unsigned int v9 = *(_DWORD *)(a2 + 176) / (*a7 + 1);
  uint64_t v10 = v7 >= v9 ? v9 : v7;
  if (!v10) {
    return;
  }
  int v41 = *a7;
  unint64_t v13 = 0;
  int v14 = *(_DWORD *)(a2 + 364) - *(_DWORD *)(a2 + 368) + *(_DWORD *)(a2 + 200);
  unsigned int v15 = v14 & ~(v14 >> 31);
  unsigned int v16 = *(unsigned int **)(a2 + 168);
  uint64_t v17 = *(void *)(a5 + 8);
  unsigned int v18 = (void *)(*(void *)(a2 + 304) + 32);
  int v44 = a6;
  unsigned int v43 = v15;
  uint64_t v42 = a4;
  do
  {
    unint64_t v19 = *(unsigned int *)(a2 + 176);
    if (v13 >= v19) {
      Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, v13, v19);
    }
    uint64_t v20 = *v16;
    int v21 = *(_DWORD *)(*v18 + 4 * v20);
    int v22 = *(_DWORD *)(a2 + 368);
    int v23 = v22 - v21;
    if (v22 != v21)
    {
      float v24 = *(float *)(*(v18 - 3) + 4 * v20) * (float)*(unsigned int *)(a2 + 196);
      float v25 = *a3;
      if (*a3 == 1.0)
      {
        float v26 = (float)v23;
      }
      else
      {
        if (v25 == 0.0) {
          goto LABEL_14;
        }
        unint64_t v30 = a3;
        float v26 = powf((float)v23, v25);
        unsigned int v15 = v43;
        a4 = v42;
        a3 = v30;
        a6 = v44;
      }
      float v24 = v24 / v26;
LABEL_14:
      float v27 = v24 + *a4;
      if (v13 < *(unsigned int *)(a5 + 16)) {
        float v27 = v27 + *(float *)(v17 + 4 * v13);
      }
      uint64_t v28 = *(void *)(a1 + 3064);
      if (v27 > *(float *)(v28 + 4 * v13) && *a6 > v15)
      {
        uint64_t v29 = 4 * v13;
        *(_DWORD *)(*(void *)(a1 + 3016) + v29) = *a6 - v15;
        *(_DWORD *)(*(void *)(a1 + 3040) + v29) = v23;
        *(float *)(v28 + v29) = v27;
      }
    }
    ++v13;
    v16 += 22;
    v18 += 6;
  }
  while (v10 != v13);
  if (v41)
  {
    uint64_t v31 = 0;
    uint64_t v32 = *(void *)(a2 + 168);
    uint64_t v33 = *(void *)(a2 + 304);
    float v34 = *a3;
    while (2)
    {
      unint64_t v38 = *(unsigned int *)(a2 + 176);
      uint64_t v39 = v31 + (v38 >> 1);
      if (v39 >= v38) {
        Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, v31 + (v38 >> 1), v38);
      }
      uint64_t v40 = *(unsigned int *)(v32 + 88 * v39);
      int v37 = *(_DWORD *)(a2 + 368) - *(_DWORD *)(*(void *)(v33 + 48 * v39 + 32) + 4 * v40);
      if (!v37) {
        goto LABEL_25;
      }
      float v36 = *(float *)(*(void *)(v33 + 48 * v39 + 8) + 4 * v40) * (float)*(unsigned int *)(a2 + 196);
      if (v34 != 1.0)
      {
        if (v34 != 0.0)
        {
          float v35 = powf((float)v37, v34);
LABEL_23:
          float v36 = v36 / v35;
        }
        int v37 = ((float)(fmaxf(v36, 0.0) * *(float *)(a1 + 1192)) + 0.5);
LABEL_25:
        *(_DWORD *)(*(void *)(a1 + 3040) + 4 * v31++) = v37;
        if (v10 == v31) {
          return;
        }
        continue;
      }
      break;
    }
    float v35 = (float)v37;
    goto LABEL_23;
  }
}

float IntNovDetect::convertStrArrToFloatArr(uint64_t a1, uint64_t a2, void *a3)
{
  (*(void (**)(void *, uint64_t))(*a3 + 32))(a3, a2 + 16);
  if (*(_DWORD *)(a2 + 16))
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      uint64_t v10 = v9 + v7;
      if (!*(_DWORD *)(v10 + 8)
        || (int v11 = 0,
            strtod(*(const char **)(v10 + 16), &v11),
            v11 != (char *)(*(void *)(v10 + 16) + *(unsigned int *)(v10 + 8))))
      {
        Error::chuck((Error *)"NovDetect: cannot convert element to float", v5);
      }
      uint64_t v9 = *(void *)(a2 + 8);
      float result = atof(*(const char **)(v9 + v7 + 16));
      *(float *)(a3[1] + 4 * v8++) = result;
      v7 += 24;
    }
    while (v8 < *(unsigned int *)(a2 + 16));
  }
  return result;
}

uint64_t IntNovDetect::resetMultiphraseResults(uint64_t this)
{
  if (*(_DWORD *)(this + 3080))
  {
    unint64_t v1 = 0;
    uint64_t v2 = *(void *)(this + 3016);
    uint64_t v3 = *(void *)(this + 3040);
    uint64_t v4 = *(void *)(this + 3064);
    do
    {
      uint64_t v5 = 4 * v1;
      *(_DWORD *)(v2 + v5) = 0;
      *(_DWORD *)(v3 + v5) = 0;
      *(_DWORD *)(v4 + v5) = -915135488;
      ++v1;
    }
    while (v1 < *(unsigned int *)(this + 3080));
  }
  return this;
}

uint64_t IntNovDetect::handleWavedataOverflow(IntNovDetect *this, const char *a2, int *a3, const BOOL *a4)
{
  int v7 = *((_DWORD *)this + 692);
  uint64_t v8 = (*a3 - v7);
  int v13 = *a3 - v7;
  int v14 = v7;
  uint64_t v9 = (char *)this + 48;
  if (*a4)
  {
    if (!*((unsigned char *)this + 1197)) {
      goto LABEL_20;
    }
    if (*((unsigned char *)this + 1196)) {
      goto LABEL_21;
    }
    int v15 = 1;
  }
  else
  {
    if (!*((unsigned char *)this + 1197)) {
      goto LABEL_22;
    }
    if (*((unsigned char *)this + 1196)) {
      goto LABEL_23;
    }
    int v15 = 0;
  }
  NWavChunk2HTKFrames::run((uint64_t)this + 48, a2, &v13, &v15, (uint64_t)this + 1048);
  TSHMMDetector::reset((IntNovDetect *)((char *)this + 1288));
  TSHMMDetector::reset((IntNovDetect *)((char *)this + 1696));
  *((unsigned char *)this + 1196) = 0;
  *((_DWORD *)this + 44) = 0;
  *((_DWORD *)this + 150) = *((_DWORD *)this + 146) + 1;
  *((void *)this + 76) = 0;
  *((unsigned char *)this + 604) = 0;
  NDynamicMFCC::reset((IntNovDetect *)((char *)this + 624));
  *((void *)this + 137) = 0;
  *((void *)this + 136) = 0;
  for (uint64_t i = *((void *)this + 133); i; uint64_t i = *((void *)this + 133))
  {
    *((void *)this + 133) = *(void *)(i + 8);
    (*(void (**)(char *))(*((void *)this + 132) + 72))((char *)this + 1056);
  }
  *((void *)this + 134) = 0;
  *((_DWORD *)this + 270) = 0;
  *((void *)this + 138) = 0;
  *(void *)((char *)this + 1109) = 0;
  NResizingQueue<NFrame>::enlargeBy((uint64_t)this + 1048, (int *)this + 280);
  if (*((unsigned char *)this + 2884)) {
    NLocalCepNorm::resync((void **)this + 150);
  }
  *((void *)this + 346) = 0;
  if (!*a4)
  {
    if (*((unsigned char *)this + 1197))
    {
      if (!*((unsigned char *)this + 1196))
      {
        int v11 = &a2[2 * v8];
        int v15 = 0;
        goto LABEL_19;
      }
LABEL_23:
      Error::chuck((Error *)"TSAcAnal::feedFromInt() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffe"
                 "r (m_queue) has been emptied (call reset())",
        a2);
    }
LABEL_22:
    Error::chuck((Error *)"TSAcAnal::feedFromInt() - you must call TSAcAnal::init() before feedFromInt()", a2);
  }
  if (!*((unsigned char *)this + 1197)) {
LABEL_20:
  }
    Error::chuck((Error *)"TSAcAnal::feedFromFloat() - you must call TSAcAnal::init() before feedFromFloat()", a2);
  if (*((unsigned char *)this + 1196)) {
LABEL_21:
  }
    Error::chuck((Error *)"TSAcAnal::feedFromFloat() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffe"
               "r (m_queue) has been emptied (call reset())",
      a2);
  int v11 = &a2[4 * v8];
  int v15 = 1;
LABEL_19:
  uint64_t result = NWavChunk2HTKFrames::run((uint64_t)v9, v11, &v14, &v15, (uint64_t)this + 1048);
  *((_DWORD *)this + 692) += v7;
  return result;
}

uint64_t IntNovDetect::wavedata(IntNovDetect *this, const char *a2, int a3)
{
  int v11 = a3;
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: wavedata() can only be called after initialize()", a2);
  }
  if (*((_DWORD *)this + 2) != 1) {
    Error::chuck((Error *)"NovDetect: wavedata() cannot be called after endwavedata()", a2);
  }
  if (!a2) {
    Error::chuck((Error *)"NovDetect: wavedata() data is NULL pointer", 0);
  }
  if (a3 < 0) {
    Error::chuck((Error *)"NovDetect: wavedata() length must be positive", a2);
  }
  int v4 = *((_DWORD *)this + 692);
  *((_DWORD *)this + 692) = v4 + a3;
  if (__CFADD__(v4, a3))
  {
    v12[0] = 0;
    IntNovDetect::handleWavedataOverflow(this, a2, &v11, v12);
  }
  else
  {
    int v10 = a3;
    if (!*((unsigned char *)this + 1197)) {
      Error::chuck((Error *)"TSAcAnal::feedFromInt() - you must call TSAcAnal::init() before feedFromInt()", a2);
    }
    if (*((unsigned char *)this + 1196)) {
      Error::chuck((Error *)"TSAcAnal::feedFromInt() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buffe"
    }
                 "r (m_queue) has been emptied (call reset())",
        a2);
    *(_DWORD *)int v12 = 0;
    NWavChunk2HTKFrames::run((uint64_t)this + 48, a2, &v10, (int *)v12, (uint64_t)this + 1048);
  }
  IntNovDetect::advanceDetection(this, v5, v6);
  if (*((unsigned char *)this + 40))
  {
    *(_DWORD *)int v12 = 6;
    uint64_t v8 = *((void *)this + 2);
    int v7 = (char *)this + 16;
    (*(void (**)(char *, const char *, BOOL *))(v8 + 64))(v7, "all ok", v12);
    v7[24] = 0;
  }
  return 0;
}

uint64_t IntNovDetect::wavedataf(IntNovDetect *this, const float *a2, int a3)
{
  int v11 = a3;
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", (const char *)a2);
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: wavedataf() can only be called after initialize()", (const char *)a2);
  }
  if (*((_DWORD *)this + 2) != 1) {
    Error::chuck((Error *)"NovDetect: wavedata() cannot be called after endwavedata()", (const char *)a2);
  }
  if (!a2) {
    Error::chuck((Error *)"NovDetect: wavedataf() data is NULL pointer", 0);
  }
  if (a3 < 0) {
    Error::chuck((Error *)"NovDetect: wavedataf() length must be positive", (const char *)a2);
  }
  int v4 = *((_DWORD *)this + 692);
  *((_DWORD *)this + 692) = v4 + a3;
  if (__CFADD__(v4, a3))
  {
    v12[0] = 1;
    IntNovDetect::handleWavedataOverflow(this, (const char *)a2, &v11, v12);
  }
  else
  {
    int v10 = a3;
    if (!*((unsigned char *)this + 1197)) {
      Error::chuck((Error *)"TSAcAnal::feedFromFloat() - you must call TSAcAnal::init() before feedFromFloat()", (const char *)a2);
    }
    if (*((unsigned char *)this + 1196)) {
      Error::chuck((Error *)"TSAcAnal::feedFromFloat() - TSAcAnal::endfeed() has been called; no new frame can be fed before the buf"
    }
                 "fer (m_queue) has been emptied (call reset())",
        (const char *)a2);
    *(_DWORD *)int v12 = 1;
    NWavChunk2HTKFrames::run((uint64_t)this + 48, (const char *)a2, &v10, (int *)v12, (uint64_t)this + 1048);
  }
  IntNovDetect::advanceDetection(this, v5, v6);
  if (*((unsigned char *)this + 40))
  {
    *(_DWORD *)int v12 = 6;
    uint64_t v8 = *((void *)this + 2);
    int v7 = (char *)this + 16;
    (*(void (**)(char *, const char *, BOOL *))(v8 + 64))(v7, "all ok", v12);
    v7[24] = 0;
  }
  return 0;
}

char *IntNovDetect::getresults(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: getresults() can only be called after initialize()", a2);
  }
  unsigned int v2 = *((_DWORD *)this + 694);
  int v3 = *((_DWORD *)this + 690);
  int v4 = *((_DWORD *)this + 691);
  unsigned int v5 = *((_DWORD *)this + 695);
  BOOL v6 = v2 >= v5;
  unsigned int v8 = v2 - v5;
  BOOL v7 = v8 != 0 && v6;
  int v9 = v8 * v3;
  if (!v7) {
    int v9 = 0;
  }
  int v10 = (char *)this + 2568;
  *((_DWORD *)this + 642) = *((_DWORD *)this + 692);
  *((_DWORD *)this + 643) = v9;
  *((_DWORD *)this + 644) = v4 + v3 * v2;
  *((_DWORD *)this + 645) = *((_DWORD *)this + 696);
  *((_DWORD *)this + 646) = *((_DWORD *)this + 700);
  *((unsigned char *)this + 2588) = *((unsigned char *)this + 2893);
  *((unsigned char *)this + 2589) = *((unsigned char *)this + 2892);
  if (*((unsigned char *)this + 40))
  {
    int v13 = 6;
    int v11 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "all ok", &v13);
    v11[24] = 0;
  }
  return v10;
}

char *IntNovDetect::getphraseresults(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: getphraseresults() can only be called after initialize()", a2);
  }
  uint64_t v2 = *((unsigned int *)this + 770);
  if (v2 <= a2)
  {
    if (!v2) {
      Error::chuck((Error *)"NovDetect: getphraseresults() phrase results not set up", a2);
    }
    Error::chuck((Error *)"NovDetect: getphraseresults() phrase %d out of range (0-%d)", a2, a2, v2);
  }
  uint64_t v3 = 4 * a2;
  unsigned int v4 = *(_DWORD *)(*((void *)this + 377) + v3);
  int v5 = *((_DWORD *)this + 690);
  int v6 = *((_DWORD *)this + 691);
  unsigned int v7 = *(_DWORD *)(*((void *)this + 380) + v3);
  BOOL v8 = v4 >= v7;
  unsigned int v10 = v4 - v7;
  BOOL v9 = v10 != 0 && v8;
  int v11 = v10 * v5;
  if (!v9) {
    int v11 = 0;
  }
  int v12 = (char *)this + 2568;
  *((_DWORD *)this + 642) = *((_DWORD *)this + 692);
  *((_DWORD *)this + 643) = v11;
  *((_DWORD *)this + 644) = v6 + v5 * v4;
  *((_DWORD *)this + 645) = *((_DWORD *)this + 696);
  *((_DWORD *)this + 646) = *(_DWORD *)(*((void *)this + 383) + 4 * a2);
  *((unsigned char *)this + 2588) = *((unsigned char *)this + 2893);
  *((unsigned char *)this + 2589) = *((unsigned char *)this + 2892);
  if (*((unsigned char *)this + 40))
  {
    int v15 = 6;
    int v13 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "all ok", &v15);
    v13[24] = 0;
  }
  return v12;
}

uint64_t IntNovDetect::phrasecount(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: phrasecount() can only be called after initialize()", a2);
  }
  if (*((unsigned char *)this + 40))
  {
    int v4 = 6;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "all ok", &v4);
    *((unsigned char *)this + 40) = 0;
  }
  return *((unsigned int *)this + 770);
}

uint64_t IntNovDetect::getresultsstr(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: getresultsstr() can only be called after initialize()", a2);
  }
  unsigned int v3 = *((_DWORD *)this + 694);
  int v4 = *((_DWORD *)this + 690);
  unsigned int v5 = *((_DWORD *)this + 695);
  BOOL v6 = v3 >= v5;
  unsigned int v8 = v3 - v5;
  BOOL v7 = v8 != 0 && v6;
  int v9 = v8 * v4;
  if (!v7) {
    int v9 = 0;
  }
  NString::printf((IntNovDetect *)((char *)this + 2544), "samples_fed: %u\nbest_start: %u\nbest_end: %u\nbest_score: %.3f\n", *((_DWORD *)this + 692), v9, *((_DWORD *)this + 691) + v4 * v3, *((float *)this + 700));
  if (*((unsigned char *)this + 40))
  {
    int v11 = 6;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "all ok", &v11);
    *((unsigned char *)this + 40) = 0;
  }
  return *((void *)this + 320);
}

char *IntNovDetect::getsupervector(IntNovDetect *this, const char *a2, double a3)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  unsigned int v3 = a2;
  if (*((unsigned char *)this + 40))
  {
    int v66 = 6;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "all ok", &v66);
    *((unsigned char *)this + 40) = 0;
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: getsupervector() can only be called after initialize()", a2);
  }
  if (!*((unsigned char *)this + 2885)) {
    Error::chuck((Error *)"NovDetect: supervector not enabled in config", a2);
  }
  if (*((unsigned char *)this + 2886))
  {
    uint64_t v5 = *((unsigned int *)this + 496);
    if (*((_DWORD *)this + 668) != v5) {
      Error::chuck((Error *)"TSHMMDetector::lastModelOutput() - mismatched size in output array (%d != %d)", a2, *((unsigned int *)this + 668), v5);
    }
    int v6 = *((unsigned __int8 *)this + 2099);
    if (*((unsigned char *)this + 2099)) {
      (*(void (**)(char *, char *))(*((void *)this + 332) + 16))((char *)this + 2656, (char *)this + 1968);
    }
    if (v6) {
      return (char *)this + 2592;
    }
    else {
      return (char *)this + 2624;
    }
  }
  if (!*((unsigned char *)this + 2891) || !*((unsigned char *)this + 2892)) {
    return (char *)this + 2624;
  }
  while ((TSHMMDetector::updateResult((IntNovDetect *)((char *)this + 1696), a2, a3) & 1) != 0)
    ;
  int v8 = *((_DWORD *)this + 516);
  if (v8 == *((_DWORD *)this + 513)) {
    return (char *)this + 2624;
  }
  unsigned int v9 = *((_DWORD *)this + 691);
  BOOL v10 = v3 >= v9;
  unsigned int v11 = (v3 - v9 + (*((_DWORD *)this + 690) >> 1)) / *((_DWORD *)this + 690);
  if (!v10) {
    unsigned int v11 = 0;
  }
  int v12 = *((_DWORD *)this + 515) - v8 + *((_DWORD *)this + 474);
  int v13 = v12 & ~(v12 >> 31);
  unsigned int v14 = *((_DWORD *)this + 693);
  if (v14 < v11 + v13) {
    return (char *)this + 2624;
  }
  unsigned int v15 = v14 - v11;
  unsigned int v67 = v14 - v11 - v13;
  NLRHMMTraceback::stateAlignment((uint64_t)this + 1808, (uint64_t)this + 2736, &v67);
  uint64_t v17 = *((unsigned int *)this + 688);
  if (v17)
  {
    int v18 = 0;
    unint64_t v19 = (int *)*((void *)this + 343);
    uint64_t v20 = *((unsigned int *)this + 688);
    while (1)
    {
      int v22 = *v19++;
      int v21 = v22;
      if (!v22) {
        return (char *)this + 2624;
      }
      v18 += v21;
      if (!--v20) {
        goto LABEL_26;
      }
    }
  }
  int v18 = 0;
LABEL_26:
  uint64_t v23 = *((unsigned int *)this + 629);
  unsigned int v24 = v18 + v15;
  BOOL v10 = v23 >= v24;
  int v25 = v23 - v24;
  if (!v10) {
    return (char *)this + 2624;
  }
  unsigned int v27 = 0;
  int v28 = *((_DWORD *)this + 250);
  int v29 = *((unsigned __int8 *)this + 1032);
  if (*((_DWORD *)this + 651) && v17)
  {
    unint64_t v30 = (uint32x4_t *)*((void *)this + 343);
    uint64_t v31 = (float32x4_t *)*((void *)this + 333);
    if (v17 >= 8)
    {
      uint64_t v32 = v17 & 0xFFFFFFF8;
      uint64_t v33 = v31 + 1;
      float v34 = v30 + 1;
      uint64_t v35 = v32;
      do
      {
        float32x4_t v16 = vcvtq_f32_u32(v34[-1]);
        float32x4_t v36 = vcvtq_f32_u32(*v34);
        v33[-1] = v16;
        *uint64_t v33 = v36;
        v33 += 2;
        v34 += 2;
        v35 -= 8;
      }
      while (v35);
      if (v32 == v17) {
        goto LABEL_38;
      }
    }
    else
    {
      uint64_t v32 = 0;
    }
    uint64_t v37 = v17 - v32;
    uint64_t v38 = v32;
    uint64_t v39 = &v31->f32[v38];
    uint64_t v40 = &v30->u32[v38];
    do
    {
      unsigned int v41 = *v40++;
      *v39++ = (float)v41;
      --v37;
    }
    while (v37);
LABEL_38:
    unsigned int v27 = v17;
  }
  if (*((_DWORD *)this + 653)) {
    BOOL v42 = v17 == 0;
  }
  else {
    BOOL v42 = 1;
  }
  if (!v42)
  {
    uint64_t v43 = 0;
    uint64_t v44 = v28 * ((2 * v29) | 1u);
    unint64_t v45 = v44 - 1;
    uint64_t v46 = v44 & 0xFFFFFFF8;
    v16.i32[0] = 1.0;
    while (1)
    {
      if (!v28)
      {
        LODWORD(v51) = *(_DWORD *)(*((void *)this + 343) + 4 * v43);
        if (!v51) {
          goto LABEL_48;
        }
        goto LABEL_65;
      }
      uint64_t v47 = *((void *)this + 333);
      if (v44 <= 7) {
        break;
      }
      uint64_t v48 = 0;
      if (__CFADD__(v27, v45)) {
        goto LABEL_52;
      }
      if (HIDWORD(v45)) {
        goto LABEL_52;
      }
      unsigned int v58 = v27;
      uint64_t v59 = v44 & 0xFFFFFFF8;
      do
      {
        float v60 = (_OWORD *)(v47 + 4 * v58);
        *float v60 = 0uLL;
        v60[1] = 0uLL;
        v58 += 8;
        v59 -= 8;
      }
      while (v59);
      uint64_t v48 = v44 & 0xFFFFFFF8;
      if (v46 != v44) {
        goto LABEL_52;
      }
LABEL_55:
      uint64_t v51 = (const char *)*(unsigned int *)(*((void *)this + 343) + 4 * v43);
      if (v51)
      {
        int v52 = 0;
        do
        {
          uint64_t v53 = 0;
          unsigned int v54 = v52 + v25;
          do
          {
            if (v54 >= v23) {
              Error::chuck((Error *)"NRingDropBuffer[] - out-of-bounds (size = %d, [] = %d)", v51, *(double *)v16.i64, 0.0, v23, (v52 + v25));
            }
            unsigned int v55 = *((_DWORD *)this + 626);
            unsigned int v56 = *((_DWORD *)this + 628) + v54 + v55 - v23;
            if (v56 < v55) {
              unsigned int v55 = 0;
            }
            *(float *)(v47 + 4 * (v27 + v53)) = *(float *)(*(void *)(*((void *)this + 312)
                                                                                     + 24 * (v56 - v55)
                                                                                     + 8)
                                                                         + 4 * v53)
                                                              + *(float *)(v47 + 4 * (v27 + v53));
            ++v53;
          }
          while (v44 != v53);
          ++v52;
        }
        while (v52 != v51);
LABEL_65:
        float v57 = 1.0 / (float)v51;
        if (!v28) {
          goto LABEL_48;
        }
        goto LABEL_74;
      }
      float v57 = 0.0;
LABEL_74:
      uint64_t v61 = *((void *)this + 333);
      if (v44 > 7)
      {
        uint64_t v62 = 0;
        if (!__CFADD__(v27, v45) && !HIDWORD(v45))
        {
          uint64_t v63 = 0;
          do
          {
            long long v64 = (float32x4_t *)(v61 + 4 * (v27 + v63));
            float32x4_t v65 = vmulq_n_f32(v64[1], v57);
            *long long v64 = vmulq_n_f32(*v64, v57);
            v64[1] = v65;
            v63 += 8;
          }
          while (v46 != v63);
          uint64_t v62 = v44 & 0xFFFFFFF8;
          if (v46 == v44) {
            goto LABEL_48;
          }
        }
      }
      else
      {
        uint64_t v62 = 0;
      }
      do
      {
        *(float *)(v61 + 4 * (v27 + v62)) = v57 * *(float *)(v61 + 4 * (v27 + v62));
        ++v62;
      }
      while (v44 != v62);
LABEL_48:
      v25 += (int)v51;
      v27 += v44;
      if (++v43 == v17) {
        goto LABEL_44;
      }
    }
    uint64_t v48 = 0;
LABEL_52:
    uint64_t v49 = v48 - v44;
    unsigned int v50 = v27 + v48;
    do
    {
      *(_DWORD *)(v47 + 4 * v50++) = 0;
      BOOL v10 = __CFADD__(v49++, 1);
    }
    while (!v10);
    goto LABEL_55;
  }
LABEL_44:
  BOOL v7 = (char *)this + 2592;
  if (*((_DWORD *)this + 654)) {
    *(_DWORD *)(*((void *)this + 333) + 4 * v27) = *((_DWORD *)this + 700);
  }
  if (*((unsigned char *)this + 40))
  {
    NString::operator=((uint64_t)this + 16, "all ok");
    *((unsigned char *)this + 40) = 0;
  }
  return v7;
}

char *IntNovDetect::scoresupervector(IntNovDetect *this, const float *a2, uint64_t a3)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", (const char *)a2);
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: scoresupervector() can only be called after initialize()", (const char *)a2);
  }
  if (!*((unsigned char *)this + 2889)) {
    Error::chuck((Error *)"NovDetect: supervector scorer not initialized in config", (const char *)a2);
  }
  int v4 = (char *)this + 2680;
  *((_DWORD *)this + 670) = 0;
  *((float *)this + 670) = TSSupervectorScorer::score((IntNovDetect *)((char *)this + 2104), a2, a3);
  if (*((unsigned char *)this + 40))
  {
    int v8 = 6;
    uint64_t v6 = *((void *)this + 2);
    uint64_t v5 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v6 + 64))(v5, "all ok", &v8);
    v5[24] = 0;
  }
  return v4;
}

uint64_t IntNovDetect::resetbest(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: resetbest() can only be called after initialize()", a2);
  }
  *((void *)this + 347) = 0;
  *((_DWORD *)this + 696) = 0;
  *((_DWORD *)this + 700) = -915135488;
  *((unsigned char *)this + 2893) = 0;
  if (*((_DWORD *)this + 770))
  {
    unint64_t v2 = 0;
    uint64_t v3 = *((void *)this + 377);
    uint64_t v4 = *((void *)this + 380);
    uint64_t v5 = *((void *)this + 383);
    do
    {
      uint64_t v6 = 4 * v2;
      *(_DWORD *)(v3 + v6) = 0;
      *(_DWORD *)(v4 + v6) = 0;
      *(_DWORD *)(v5 + v6) = -915135488;
      ++v2;
    }
    while (v2 < *((unsigned int *)this + 770));
  }
  if (*((unsigned char *)this + 40))
  {
    int v9 = 6;
    BOOL v7 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "all ok", &v9);
    v7[24] = 0;
  }
  return 0;
}

uint64_t IntNovDetect::reset(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    goto LABEL_22;
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: reset() can only be called after initialize()", a2);
  }
  TSHMMDetector::reset((IntNovDetect *)((char *)this + 1288));
  TSHMMDetector::reset((IntNovDetect *)((char *)this + 1696));
  if (*((unsigned char *)this + 2884))
  {
    *((unsigned char *)this + 1284) = 0;
    *(void *)((char *)this + 1220) = 0;
    *(void *)((char *)this + 1212) = 0;
    int v3 = *((_DWORD *)this + 300);
    *((_DWORD *)this + 307) = v3;
    unsigned int v4 = *((_DWORD *)this + 302);
    if (v4 > v3 + 1) {
      *((_DWORD *)this + 307) = v4 - 1;
    }
    uint64_t v5 = *((unsigned int *)this + 301);
    if (v5) {
      bzero(*((void **)this + 158), 4 * v5);
    }
  }
  *((unsigned char *)this + 1196) = 0;
  *((_DWORD *)this + 44) = 0;
  *((_DWORD *)this + 150) = *((_DWORD *)this + 146) + 1;
  *((void *)this + 76) = 0;
  *((unsigned char *)this + 604) = 0;
  NDynamicMFCC::reset((IntNovDetect *)((char *)this + 624));
  *((void *)this + 137) = 0;
  *((void *)this + 136) = 0;
  for (uint64_t i = *((void *)this + 133); i; uint64_t i = *((void *)this + 133))
  {
    *((void *)this + 133) = *(void *)(i + 8);
    (*(void (**)(char *))(*((void *)this + 132) + 72))((char *)this + 1056);
  }
  *((void *)this + 134) = 0;
  *((_DWORD *)this + 270) = 0;
  *((void *)this + 138) = 0;
  *(void *)((char *)this + 1109) = 0;
  NResizingQueue<NFrame>::enlargeBy((uint64_t)this + 1048, (int *)this + 280);
  *((void *)this + 314) = 0;
  *((void *)this + 370) = 0;
  int v7 = *((_DWORD *)this + 742);
  *((_DWORD *)this + 743) = v7;
  *((_DWORD *)this + 744) = *((_DWORD *)this + 745) + v7;
  *((void *)this + 346) = 0;
  *((_DWORD *)this + 697) = 0;
  *((_WORD *)this + 1446) = 0;
  if (*(_DWORD *)this != -1838836561) {
LABEL_22:
  }
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: resetbest() can only be called after initialize()", a2);
  }
  *((void *)this + 347) = 0;
  *((_DWORD *)this + 696) = 0;
  *((_DWORD *)this + 700) = -915135488;
  *((unsigned char *)this + 2893) = 0;
  if (*((_DWORD *)this + 770))
  {
    unint64_t v8 = 0;
    uint64_t v9 = *((void *)this + 377);
    uint64_t v10 = *((void *)this + 380);
    uint64_t v11 = *((void *)this + 383);
    do
    {
      uint64_t v12 = 4 * v8;
      *(_DWORD *)(v9 + v12) = 0;
      *(_DWORD *)(v10 + v12) = 0;
      *(_DWORD *)(v11 + v12) = -915135488;
      ++v8;
    }
    while (v8 < *((unsigned int *)this + 770));
  }
  if (*((unsigned char *)this + 40))
  {
    int v17 = 6;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "all ok", &v17);
    *((unsigned char *)this + 40) = 0;
  }
  if (*((_DWORD *)this + 745))
  {
    IntNovDetect::zeroWavePrime(this, a2);
    int v13 = *((unsigned __int8 *)this + 40);
    *((_DWORD *)this + 2) = 1;
    if (v13)
    {
      int v18 = 6;
      uint64_t v15 = *((void *)this + 2);
      unsigned int v14 = (char *)this + 16;
      (*(void (**)(char *, const char *, int *))(v15 + 64))(v14, "all ok", &v18);
      v14[24] = 0;
    }
  }
  else
  {
    *((_DWORD *)this + 2) = 1;
  }
  return 0;
}

uint64_t IntNovDetect::endwavedata(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 1) != 1) {
    Error::chuck((Error *)"NovDetect: endwavedata() can only be called after initialize()", a2);
  }
  if (*((_DWORD *)this + 2) != 1) {
    Error::chuck((Error *)"NovDetect: endwavedata() cannot be called twice in a row", a2);
  }
  *((_DWORD *)this + 2) = 2;
  if (!*((unsigned char *)this + 1197)) {
    Error::chuck((Error *)"TSAcAnal::endfeed() - you must call TSAcAnal::init() before endfeed()\n", a2);
  }
  if (*((unsigned char *)this + 1196)) {
    Error::chuck((Error *)"TSAcAnal::endfeed() - TSAcAnal::endfeed() has been called before; is cannot be called againbefore the buf"
  }
               "fer (m_queue) has been emptied\n",
      a2);
  NWavChunk2HTKFrames::finish((uint64_t)this + 48, (const char *)this + 1048);
  *((unsigned char *)this + 1116) = 1;
  *((unsigned char *)this + 1196) = 1;
  IntNovDetect::advanceDetection(this, v3, v4);
  if (*((unsigned char *)this + 2884))
  {
    NLocalCepNorm::endFrames((unsigned int *)this + 300, v5);
    while (1)
    {
      int v7 = *((_DWORD *)this + 304);
      if ((!*((unsigned char *)this + 1284) || !v7) && v7 != *((_DWORD *)this + 307) + 1) {
        break;
      }
      NLocalCepNorm::setOutputFrame((IntNovDetect *)((char *)this + 1200), (IntNovDetect *)((char *)this + 2520));
      TSHMMDetector::feedFrame((IntNovDetect *)((char *)this + 1288), (IntNovDetect *)((char *)this + 2520), v8);
      if (*((unsigned char *)this + 2891))
      {
        NRingDropBuffer::pushFrame((uint64_t)this + 2488, (IntNovDetect *)((char *)this + 2520));
        if (*((unsigned char *)this + 2892)) {
          TSHMMDetector::feedFrame((IntNovDetect *)((char *)this + 1696), (IntNovDetect *)((char *)this + 2520), v10);
        }
      }
      ++*((_DWORD *)this + 693);
      IntNovDetect::innerAdvanceDetection(this, v9, v10);
    }
  }
  while (TSHMMDetector::endFrame((IntNovDetect *)((char *)this + 1288), v5, v6))
    IntNovDetect::innerAdvanceDetection(this, v11, v12);
  if (*((unsigned char *)this + 2892))
  {
    IntNovDetect::rescoreComplete(this, v11, v12);
    *((unsigned char *)this + 2892) = 0;
  }
  if (*((unsigned char *)this + 40))
  {
    int v16 = 6;
    uint64_t v14 = *((void *)this + 2);
    int v13 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v14 + 64))(v13, "all ok", &v16);
    v13[24] = 0;
  }
  return 0;
}

void IntNovDetect::feedFrameToDetector(IntNovDetect *this, const NFrame *a2, double a3)
{
  TSHMMDetector::feedFrame((IntNovDetect *)((char *)this + 1288), a2, a3);
  if (*((unsigned char *)this + 2891))
  {
    NRingDropBuffer::pushFrame((uint64_t)this + 2488, a2);
    if (*((unsigned char *)this + 2892))
    {
      TSHMMDetector::feedFrame((IntNovDetect *)((char *)this + 1696), a2, v5);
    }
  }
}

void IntNovDetect::getoption(IntNovDetect *this, const char *__s)
{
  if (*(_DWORD *)this == -1838836561)
  {
    if (*((_DWORD *)this + 1) == 1)
    {
      if (__s)
      {
        strlen(__s);
        operator new[]();
      }
      Error::chuck((Error *)"NovDetect: getoption() cannot be called with NULL", 0);
    }
    Error::chuck((Error *)"NovDetect: getoption() can only be called after initialize()", __s);
  }
  Error::chuck((Error *)"Invalid NovDetect Object Signature", __s);
}

void sub_21849716C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void IntNovDetect::sat_initialize(IntNovDetect *this, const char *__s)
{
  if (*(_DWORD *)this == -1838836561)
  {
    *((_DWORD *)this + 3) = 0;
    if (*((_DWORD *)this + 1) == 1)
    {
      if (*((unsigned char *)this + 2890))
      {
        if (__s)
        {
          strlen(__s);
          operator new[]();
        }
        Error::chuck((Error *)"Null pointer passed to string constructor", 0);
      }
      Error::chuck((Error *)"NovDetect: SAT scoring not initialized in config", __s);
    }
    Error::chuck((Error *)"NovDetect: sat_initialize() can only be called after initialize()", __s);
  }
  Error::chuck((Error *)"Invalid NovDetect Object Signature", __s);
}

void sub_21849735C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

char *IntNovDetect::sat_analyze(IntNovDetect *this, const float *a2, uint64_t a3)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", (const char *)a2);
  }
  if (*((_DWORD *)this + 3) != 1) {
    Error::chuck((Error *)"NovDetect: sat_analyze() can only be called after sat_initialize()", (const char *)a2);
  }
  double v4 = (char *)this + 2680;
  *((_DWORD *)this + 670) = 0;
  TSSATScorer::score((IntNovDetect *)((char *)this + 2184), a2, a3);
  *((_DWORD *)this + 670) = v5;
  if (*((unsigned char *)this + 40))
  {
    int v9 = 6;
    uint64_t v7 = *((void *)this + 2);
    double v6 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v7 + 64))(v6, "all ok", &v9);
    v6[24] = 0;
  }
  return v4;
}

char *IntNovDetect::sat_analyzetransformed(IntNovDetect *this, const float *a2, uint64_t a3)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", (const char *)a2);
  }
  if (*((_DWORD *)this + 3) != 1) {
    Error::chuck((Error *)"NovDetect: sat_analyzetransformed() can only be called after sat_initialize()", (const char *)a2);
  }
  double v4 = (char *)this + 2728;
  *((_DWORD *)this + 682) = 0;
  TSSATScorer::scoreSpeakerVector((IntNovDetect *)((char *)this + 2184), a2, a3);
  *((_DWORD *)this + 682) = v5;
  if (*((unsigned char *)this + 40))
  {
    int v9 = 6;
    uint64_t v7 = *((void *)this + 2);
    double v6 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v7 + 64))(v6, "all ok", &v9);
    v6[24] = 0;
  }
  return v4;
}

uint64_t IntNovDetect::sat_update(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 3) != 1) {
    Error::chuck((Error *)"NovDetect: sat_update() can only be called after sat_initialize()", a2);
  }
  if (!*((unsigned char *)this + 2481)) {
    Error::chuck((Error *)"TSSATScorer::update() - no valid vector prepared", a2);
  }
  *((unsigned char *)this + 2481) = 0;
  NSATSpeaker::insert((unsigned char *)this + 2272, (uint64_t)this + 2424);
  if (*((unsigned char *)this + 2350)) {
    NSATSpeaker::write((IntNovDetect *)((char *)this + 2272), v3);
  }
  if (*((unsigned char *)this + 40))
  {
    int v7 = 6;
    uint64_t v5 = *((void *)this + 2);
    double v4 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v5 + 64))(v4, "all ok", &v7);
    v4[24] = 0;
  }
  return 0;
}

uint64_t IntNovDetect::sat_deletevector(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 3) != 1) {
    Error::chuck((Error *)"NovDetect: sat_deletevector() can only be called after sat_initialize()", a2);
  }
  if (a2 != -1)
  {
    int v12 = (int)a2;
    if (*((unsigned char *)this + 2480))
    {
      int v3 = (IntNovDetect *)((char *)this + 2272);
      double v4 = (unsigned int *)&v12;
      goto LABEL_9;
    }
LABEL_16:
    Error::chuck((Error *)"TSSATScorer::deleteVector() - setModelFile() not called", a2);
  }
  int v5 = *((_DWORD *)this + 577);
  BOOL v6 = __OFSUB__(v5, 1);
  signed int v7 = v5 - 1;
  if (v7 < 0 != v6) {
    goto LABEL_11;
  }
  unsigned int v13 = v7;
  if (!*((unsigned char *)this + 2480)) {
    goto LABEL_16;
  }
  int v3 = (IntNovDetect *)((char *)this + 2272);
  double v4 = &v13;
LABEL_9:
  NSATSpeaker::remove(v3, (const char *)v4);
  if (*((unsigned char *)this + 2350)) {
    NSATSpeaker::write(v3, v8);
  }
LABEL_11:
  if (*((unsigned char *)this + 40))
  {
    int v14 = 6;
    uint64_t v10 = *((void *)this + 2);
    int v9 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(v10 + 64))(v9, "all ok", &v14);
    v9[24] = 0;
  }
  return 0;
}

uint64_t IntNovDetect::sat_vectorcount(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this != -1838836561) {
    Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
  }
  if (*((_DWORD *)this + 3) != 1) {
    Error::chuck((Error *)"NovDetect: sat_vectorcount() can only be called after sat_initialize()", a2);
  }
  uint64_t v2 = *((unsigned int *)this + 577);
  if (*((unsigned char *)this + 40))
  {
    int v5 = 6;
    int v3 = (char *)this + 16;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "all ok", &v5);
    v3[24] = 0;
  }
  return v2;
}

void IntNovDetect::sat_getspeakervector(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this == -1838836561)
  {
    if (*((_DWORD *)this + 3) == 1)
    {
      if (a2 == -1) {
        a2 = (const char *)(*((_DWORD *)this + 577) - 1);
      }
      unsigned int v2 = a2;
      if (*((unsigned char *)this + 2480)) {
        NSATSpeaker::getVector((uint64_t)this + 2272, (const char *)this + 2704, &v2);
      }
      Error::chuck((Error *)"TSSATScorer::getSuperVector() - setModelFile() not called", a2);
    }
    Error::chuck((Error *)"NovDetect: sat_getspeakervector() can only be called after sat_initialize()", a2);
  }
  Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
}

void IntNovDetect::sat_reset(IntNovDetect *this, const char *a2)
{
  if (*(_DWORD *)this == -1838836561)
  {
    if (*((_DWORD *)this + 3) == 1)
    {
      *((unsigned char *)this + 2481) = 0;
      NSATSpeaker::reset((IntNovDetect *)((char *)this + 2272), a2);
    }
    Error::chuck((Error *)"NovDetect: sat_reset() can only be called after sat_initialize()", a2);
  }
  Error::chuck((Error *)"Invalid NovDetect Object Signature", a2);
}

const char *IntNovDetect::error(IntNovDetect *this)
{
  if (*((_DWORD *)this + 1) == 2 || *(_DWORD *)this != -1838836561) {
    return "Invalid NovDetect object";
  }
  else {
    return (const char *)*((void *)this + 4);
  }
}

_DWORD *IntNovDetect::setError(_DWORD *result, uint64_t a2)
{
  if (result[1] != 2)
  {
    unsigned int v2 = result;
    if (*result == -1838836561)
    {
      result += 4;
      if (v2 + 4 != (_DWORD *)a2) {
        uint64_t result = (_DWORD *)(*(uint64_t (**)(_DWORD *, void, uint64_t))(*(void *)result + 64))(result, *(void *)(a2 + 16), a2 + 8);
      }
      *((unsigned char *)v2 + 40) = 1;
    }
  }
  return result;
}

uint64_t IntNovDetect::nextFrameFromAcanal(IntNovDetect *this, const char *a2)
{
  uint64_t result = *((void *)this + 370);
  if (result)
  {
    int v4 = *((_DWORD *)this + 743);
    if (v4)
    {
      *((_DWORD *)this + 743) = v4 - 1;
      return result;
    }
    *((void *)this + 370) = 0;
  }
  if (*((unsigned char *)this + 1116)) {
    BOOL v5 = *((_DWORD *)this + 276) != *((_DWORD *)this + 277);
  }
  else {
    BOOL v5 = (*((_DWORD *)this + 276) - *((_DWORD *)this + 277)) > 1;
  }
  if (!v5) {
    return 0;
  }
  uint64_t result = TSAcAnal::getFrameByRef((IntNovDetect *)((char *)this + 48), a2);
  if (*((_DWORD *)this + 2) != 2 && *((unsigned char *)this + 1196))
  {
    if (*((unsigned char *)this + 1116)) {
      BOOL v7 = *((_DWORD *)this + 276) == *((_DWORD *)this + 277);
    }
    else {
      BOOL v7 = (*((_DWORD *)this + 276) - *((_DWORD *)this + 277)) < 2;
    }
    if (v7) {
      Error::chuck((Error *)"NovDetect: advanceDetection() - acanal has shut down!", v6);
    }
  }
  if (*((_DWORD *)this + 743)) {
    *((void *)this + 370) = result;
  }
  return result;
}

uint64_t IntNovDetect::directlyComputedLength(IntNovDetect *this, const TSHMMDetector *a2, float *a3, const unsigned int *a4)
{
  uint64_t v4 = *((unsigned int *)a2 + 44);
  unsigned int v5 = *a4 + (v4 >> 1);
  if (v5 >= v4) {
    Error::chuck((Error *)"TSHMMDetector::scorePhrase() - phrase %d out of range %d", (const char *)a2, a3, *a4 + (v4 >> 1), v4);
  }
  uint64_t v6 = *(unsigned int *)(*((void *)a2 + 21) + 88 * v5);
  uint64_t v7 = *((void *)a2 + 38);
  int v8 = *((_DWORD *)a2 + 92) - *(_DWORD *)(*(void *)(v7 + 48 * v5 + 32) + 4 * v6);
  if (!v8) {
    return 0;
  }
  float v11 = *(float *)(*(void *)(v7 + 48 * v5 + 8) + 4 * v6) * (float)*((unsigned int *)a2 + 49);
  float v12 = *a3;
  if (*a3 == 1.0)
  {
    float v13 = (float)v8;
  }
  else
  {
    if (v12 == 0.0) {
      return ((float)(fmaxf(v11, 0.0) * *((float *)this + 298)) + 0.5);
    }
    float v13 = powf((float)v8, v12);
  }
  float v11 = v11 / v13;
  return ((float)(fmaxf(v11, 0.0) * *((float *)this + 298)) + 0.5);
}

uint64_t IntNovDetect::feedFrameToNorm(int32x2_t *this, const NFrame *a2, double a3)
{
  int v3 = a2;
  if (!this[360].i8[4])
  {
    if (a2) {
      goto LABEL_9;
    }
    return 0;
  }
  if (a2) {
    NLocalCepNorm::pushFrame(this + 150, a2);
  }
  __int32 v5 = this[152].i32[0];
  if ((!this[160].i8[4] || !v5) && v5 != this[153].i32[1] + 1) {
    return 0;
  }
  int v3 = (const NFrame *)&this[315];
  NLocalCepNorm::setOutputFrame((NLocalCepNorm *)&this[150], (NFrame *)&this[315]);
LABEL_9:
  TSHMMDetector::feedFrame((TSHMMDetector *)&this[161], v3, a3);
  if (this[361].i8[3])
  {
    NRingDropBuffer::pushFrame((uint64_t)&this[311], v3);
    if (this[361].i8[4]) {
      TSHMMDetector::feedFrame((TSHMMDetector *)&this[212], v3, v6);
    }
  }
  return 1;
}

float *IntNovDetect::updateBestScore(float *this, const float *a2, float *a3, float *a4, const unsigned int *a5, const unsigned int *a6)
{
  int v6 = *(_DWORD *)a2;
  if (*a2 > this[700] && *a6 > *a5)
  {
    *((_DWORD *)this + 694) = *a6 - *a5;
    this[695] = *a3;
    this[696] = *a4;
    *((_DWORD *)this + 700) = v6;
  }
  return this;
}

void initndlib(void)
{
  if ((initndlib(void)::bNDLibInitialized & 1) == 0) {
    initndlib(void)::bNDLibInitialized = 1;
  }
}

void IntNovDetectE::IntNovDetectE(IntNovDetectE *this)
{
  *(_DWORD *)this = 2;
  *((unsigned char *)this + 8) = 0;
  *((void *)this + 2) = &unk_26C99C348;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = &unk_26C99C348;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = &unk_26C99C348;
  *((void *)this + 9) = 0;
  *((_DWORD *)this + 20) = 0;
  *((unsigned char *)this + 96) = 0;
  *((unsigned char *)this + 108) = 0;
  *((void *)this + 14) = &unk_26C99C348;
  *((void *)this + 15) = 0;
  *((_DWORD *)this + 32) = 0;
  *((void *)this + 18) = 0;
  *((unsigned char *)this + 152) = 0;
  *((void *)this + 21) = &unk_26C99C348;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((unsigned char *)this + 196) = 0;
  *((unsigned char *)this + 220) = 0;
  *((void *)this + 28) = &unk_26C99C3F0;
  *((void *)this + 29) = 0;
  *((_DWORD *)this + 60) = 0;
  *((void *)this + 31) = &unk_26C99C2A0;
  *((void *)this + 32) = 0;
  *((_DWORD *)this + 66) = 0;
  *((void *)this + 34) = &unk_26C99C348;
  *((void *)this + 35) = 0;
  *((_DWORD *)this + 72) = 0;
  *((unsigned char *)this + 300) = 0;
  *((unsigned char *)this + 324) = 0;
  *((void *)this + 41) = &unk_26C99C678;
  *((void *)this + 42) = 0;
  *((void *)this + 43) = 0;
  *((_DWORD *)this + 88) = 0;
  *((void *)this + 45) = &unk_26C99C348;
  *((void *)this + 46) = 0;
  *((_DWORD *)this + 94) = 0;
  *((void *)this + 50) = &unk_26C99C348;
  *((void *)this + 51) = 0;
  *((_DWORD *)this + 104) = 0;
  *((void *)this + 48) = 0;
  *((void *)this + 49) = 0;
  *((void *)this + 67) = &unk_26C99C348;
  *((void *)this + 68) = 0;
  *((_DWORD *)this + 138) = 0;
  *((void *)this + 71) = 0;
  *((_DWORD *)this + 144) = 0;
  *((void *)this + 70) = &unk_26C99C498;
  *((unsigned char *)this + 584) = 0;
  *((_DWORD *)this + 147) = 1203982336;
  *((void *)this + 74) = 0x3F7851EC48742400;
  *((_DWORD *)this + 150) = 257;
  *((_DWORD *)this + 151) = 26;
  *((_OWORD *)this + 38) = xmmword_21852DE20;
  *((void *)this + 78) = 0x160000000CLL;
  *((unsigned char *)this + 632) = 1;
  *(void *)((char *)this + 636) = 0x3F80000000000000;
  *(_DWORD *)((char *)this + 633) = 0;
  *((unsigned char *)this + 644) = 0;
  *((void *)this + 81) = 0x200000002;
  *(_WORD *)((char *)this + 645) = 0;
  *((unsigned char *)this + 647) = 0;
  *((void *)this + 86) = 0;
  *((void *)this + 85) = 0;
  *((void *)this + 84) = &unk_26C99C498;
  *((unsigned char *)this + 696) = 0;
  *((unsigned char *)this + 708) = 0;
  *(void *)((char *)this + 700) = 0;
  NLocalCepNorm::NLocalCepNorm((IntNovDetectE *)((char *)this + 712));
  *((void *)this + 100) = &unk_26C99AB30;
  *((void *)this + 102) = 0;
  *((void *)this + 101) = 0;
  *((void *)this + 103) = &unk_26C99BF90;
  *((void *)this + 104) = 0;
  *((_DWORD *)this + 210) = 0;
  *((_OWORD *)this + 53) = 0u;
  *((_OWORD *)this + 54) = 0u;
  *(_OWORD *)((char *)this + 876) = 0u;
  *((void *)this + 114) = 0;
  *((void *)this + 113) = 0;
  *((void *)this + 112) = &unk_26C99C498;
  *((_WORD *)this + 460) = 1;
  *((_OWORD *)this + 58) = 0u;
  *((_OWORD *)this + 59) = 0u;
  *((void *)this + 120) = 0;
  *((void *)this + 118) = &unk_26C99C498;
  *((void *)this + 121) = &unk_26C99C348;
  *((void *)this + 122) = 0;
  *((_DWORD *)this + 246) = 0;
  *((_DWORD *)this + 248) = -8388609;
  *(void *)((char *)this + 1004) = 0;
  *(void *)((char *)this + 996) = 0;
  *(_DWORD *)((char *)this + 1011) = 0;
  *((void *)this + 128) = 0;
  *((_DWORD *)this + 258) = 0;
  *((void *)this + 127) = &unk_26C99C498;
  *((_OWORD *)this + 65) = 0u;
  *((_OWORD *)this + 66) = 0u;
  *((_DWORD *)this + 268) = 0x10000;
  *(void *)((char *)this + 1076) = 0x4974240049742400;
  *((_DWORD *)this + 271) = 0;
  *((void *)this + 136) = 0;
  *(_DWORD *)this = 0;
}

void sub_218498F54(_Unwind_Exception *a1)
{
  *unsigned int v2 = &unk_26C99C348;
  if (*v3) {
    MEMORY[0x21D46B220](*v3, 0x1000C8052888210);
  }
  NDEAcAnal::~NDEAcAnal(v1);
  _Unwind_Resume(a1);
}

void IntNovDetectE::~IntNovDetectE(IntNovDetectE *this)
{
  *(_DWORD *)this = 2;
  *((void *)this + 127) = &unk_26C99C348;
  uint64_t v2 = *((void *)this + 128);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  NDEHMMDetector::~NDEHMMDetector((IntNovDetectE *)((char *)this + 800));
  *((void *)this + 96) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 97);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 93) = &unk_26C99C038;
  uint64_t v4 = *((void *)this + 94);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 - 8);
    if (v5)
    {
      uint64_t v6 = 24 * v5;
      do
      {
        *(void *)(v4 + v6 - 24) = &unk_26C99C348;
        uint64_t v7 = *(void *)(v4 + v6 - 16);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        v6 -= 24;
      }
      while (v6);
    }
    MEMORY[0x21D46B220](v4 - 16, 0x1081C80622C3295);
  }
  *((void *)this + 84) = &unk_26C99C348;
  uint64_t v8 = *((void *)this + 85);
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8052888210);
  }
  NDEAcAnal::~NDEAcAnal((IntNovDetectE *)((char *)this + 8));
}

uint64_t IntNovDetectE::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a3 + 46))
  {
    int v7 = *(_DWORD *)(a3 + 16);
    float v8 = 10000000.0 / *(float *)a3;
    if (*(_DWORD *)(a1 + 688) != v7)
    {
      *(_DWORD *)(a1 + 688) = v7;
      operator new[]();
    }
    *(float *)(a1 + 700) = *(float *)(a3 + 52) * *(float *)(a3 + 48);
    *(unsigned char *)(a1 + 708) = *(unsigned char *)(a3 + 47);
    *(float *)(a1 + 704) = v8;
    char v9 = 1;
    *(unsigned char *)(a1 + 696) = 1;
    unsigned int v10 = *(_DWORD *)(a1 + 688);
  }
  else
  {
    NDEAcAnal::init(a1 + 8, a3, (unsigned int *)a2);
    char v9 = 0;
    unsigned int v10 = *(_DWORD *)(a1 + 624) * ((2 * *(unsigned __int8 *)(a1 + 644)) | 1);
    float v8 = (float)*(unsigned int *)(a1 + 656) / (float)*(unsigned int *)(a1 + 664);
  }
  unsigned int v19 = v10;
  *(unsigned char *)(a1 + 1073) = v9;
  double v11 = (float)((float)*(unsigned int *)a2 / v8) + 0.5;
  *(void *)(a1 + 1040) = v11;
  if ((v11 & 0x80000000) != 0) {
    Error::chuck((Error *)"NovDetectE: unsupportable frame advance %u", (const char *)a2, v11);
  }
  if (!v11) {
    *(_DWORD *)(a1 + 1040) = 1;
  }
  if (a4) {
    BOOL v12 = *(unsigned char *)(a2 + 40) == 0;
  }
  else {
    BOOL v12 = 1;
  }
  char v13 = !v12;
  *(unsigned char *)(a1 + 1072) = v13;
  if (v12) {
LABEL_20:
  }
    NDEHMMDetector::init(a1 + 800, (const char *)a2);
  unsigned int v14 = *(_DWORD *)(a4 + 4) + (*(_DWORD *)a4 >> 1);
  if (v14 < *(_DWORD *)a4)
  {
    unsigned int v17 = 0;
    int v18 = v14;
    NLocalCepNorm::configure((NLocalCepNorm *)(a1 + 712), (char *)a4, &v19, (float *)(a4 + 8), (unsigned int *)&v18, &v17);
    int v15 = *(_DWORD *)(a1 + 624) * ((2 * *(unsigned __int8 *)(a1 + 644)) | 1);
    if (*(_DWORD *)(a1 + 1032) != v15)
    {
      *(_DWORD *)(a1 + 1032) = v15;
      operator new[]();
    }
    goto LABEL_20;
  }
  return 0xFFFFFFFFLL;
}

uint64_t IntNovDetectE::reset(IntNovDetectE *this)
{
  if (*((unsigned char *)this + 1072))
  {
    *((unsigned char *)this + 796) = 0;
    *(void *)((char *)this + 732) = 0;
    *(void *)((char *)this + 724) = 0;
    int v2 = *((_DWORD *)this + 178);
    *((_DWORD *)this + 185) = v2;
    unsigned int v3 = *((_DWORD *)this + 180);
    if (v3 > v2 + 1) {
      *((_DWORD *)this + 185) = v3 - 1;
    }
    uint64_t v4 = *((unsigned int *)this + 179);
    if (v4) {
      bzero(*((void **)this + 97), 4 * v4);
    }
  }
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 128) = *((_DWORD *)this + 124) + 1;
  *((void *)this + 65) = 0;
  *((unsigned char *)this + 516) = 0;
  *((_DWORD *)this + 248) = -8388609;
  *(void *)((char *)this + 1004) = 0;
  *(void *)((char *)this + 996) = 0;
  if (*((_DWORD *)this + 210))
  {
    unint64_t v5 = 0;
    uint64_t v6 = *((void *)this + 104);
    do
    {
      uint64_t v7 = v6 + 136 * v5;
      int v9 = *(_DWORD *)(v7 + 72);
      float v8 = (unsigned int *)(v7 + 72);
      if (v9)
      {
        uint64_t v10 = v6 + 136 * v5;
        double v11 = *(_DWORD **)(v10 + 88);
        *double v11 = 0;
        BOOL v12 = *(_DWORD **)(v10 + 112);
        _DWORD *v12 = 0;
        if (*v8)
        {
          unsigned int v13 = 1;
          do
          {
            uint64_t v14 = v13;
            v11[v14] = -8388609;
            v12[v14] = 0;
            ++v13;
          }
          while (v13 <= *v8);
        }
      }
      ++v5;
    }
    while (v5 < *((unsigned int *)this + 210));
  }
  *((_WORD *)this + 460) = 1;
  *((_DWORD *)this + 222) = 0;
  *((_DWORD *)this + 221) = 0;
  uint64_t v15 = *((void *)this + 101);
  if (v15 && *((void *)this + 102)) {
    (*(void (**)(uint64_t))(*(void *)v15 + 160))(v15);
  }
  *((void *)this + 136) = 0;
  *(_OWORD *)((char *)this + 1048) = 0u;
  *((int32x2_t *)this + 133) = vdup_n_s32(0xC9742400);
  return 0;
}

uint64_t IntNovDetectE::process(uint64_t a1, const char *a2, signed int a3, unsigned char *a4, unsigned char *a5, uint64_t a6)
{
  if (*(_DWORD *)a1 != 1) {
    Error::chuck((Error *)"NovDetectE: process() can only be called after initialize()", a2);
  }
  if (*(unsigned char *)(a1 + 1073)) {
    return 0xFFFFFFFFLL;
  }
  int v11 = *(_DWORD *)(a1 + 1052);
  int v12 = *(_DWORD *)(a1 + 1040);
  if (a3 < 1)
  {
    int v15 = *(_DWORD *)(a1 + 1052);
  }
  else
  {
    unsigned int v13 = a2;
    do
    {
      int v14 = a3 - v12;
      if (a3 >= v12) {
        a3 = v12;
      }
      IntNovDetectE::wavedata((IntNovDetectE *)a1, v13, a3);
      v13 += 2 * v12;
      a3 = v14;
    }
    while (v14 > 0);
    int v15 = *(_DWORD *)(a1 + 1052);
    int v12 = *(_DWORD *)(a1 + 1040);
  }
  uint64_t result = 0;
  unsigned int v16 = *(_DWORD *)(a1 + 1056);
  unsigned int v17 = *(_DWORD *)(a1 + 1060);
  BOOL v18 = v16 >= v17;
  unsigned int v20 = v16 - v17;
  BOOL v19 = v20 != 0 && v18;
  int v21 = *(_DWORD *)(a1 + 1044) + v12 * v16;
  int v22 = v20 * v12;
  if (!v19) {
    int v22 = 0;
  }
  *(_DWORD *)a6 = *(_DWORD *)(a1 + 1048);
  *(_DWORD *)(a6 + 4) = v22;
  *(_DWORD *)(a6 + 8) = v21;
  float v23 = *(float *)(a1 + 1064);
  *(float *)(a6 + 12) = v23;
  *(unsigned char *)(a6 + 16) = 0;
  *a4 = 0;
  *a5 = 0;
  int v24 = v15 - v11;
  if (v24)
  {
    int v25 = *(_DWORD *)(a1 + 1088);
    if (v23 <= *(float *)(a1 + 1076))
    {
      if (v25 < 1) {
        goto LABEL_21;
      }
      int v27 = v25 - v24;
      *(_DWORD *)(a1 + 1088) = v27;
      if (v27 <= 0) {
        goto LABEL_21;
      }
    }
    else
    {
      if (v25 <= 0) {
        *a4 = 1;
      }
      int v26 = *(_DWORD *)(a1 + 1084);
      *(_DWORD *)(a1 + 1088) = v26;
      *(void *)(a1 + 1056) = 0;
      *(int32x2_t *)(a1 + 1064) = vdup_n_s32(0xC9742400);
      if (v26 <= 0)
      {
LABEL_21:
        if (*(float *)(a1 + 1068) > *(float *)(a1 + 1080))
        {
          if (*(int *)(a1 + 1092) <= 0) {
            *a5 = 1;
          }
          uint64_t result = 0;
          *(_DWORD *)(a1 + 1092) = *(_DWORD *)(a1 + 1084);
          *(_DWORD *)(a1 + 1068) = -915135488;
          return result;
        }
      }
    }
    int v28 = *(_DWORD *)(a1 + 1092);
    uint64_t result = 0;
    if (v28 >= 1) {
      *(_DWORD *)(a1 + 1092) = v28 - v24;
    }
  }
  return result;
}

uint64_t IntNovDetectE::wavedata(IntNovDetectE *this, const char *a2, unsigned int a3)
{
  int v5 = *((_DWORD *)this + 262);
  int v6 = v5 + a3;
  *((_DWORD *)this + 262) = v5 + a3;
  if (!__CFADD__(v5, a3))
  {
    unsigned int v20 = a3;
    NDEAcAnal::feedFromInt((IntNovDetectE *)((char *)this + 8), a2, &v20);
    if (!*((unsigned char *)this + 668)) {
      return 0;
    }
LABEL_19:
    IntNovDetectE::feedFrameToNorm((int32x2_t *)this, (IntNovDetectE *)((char *)this + 560));
    return 0;
  }
  int v7 = -v5;
  unsigned int v21 = -v5;
  unsigned int v22 = v5 + a3;
  NDEAcAnal::feedFromInt((IntNovDetectE *)((char *)this + 8), a2, &v21);
  *((_DWORD *)this + 248) = -8388609;
  *(void *)((char *)this + 1004) = 0;
  *(void *)((char *)this + 996) = 0;
  if (*((_DWORD *)this + 210))
  {
    unint64_t v8 = 0;
    uint64_t v9 = *((void *)this + 104);
    do
    {
      uint64_t v10 = v9 + 136 * v8;
      int v12 = *(_DWORD *)(v10 + 72);
      int v11 = (unsigned int *)(v10 + 72);
      if (v12)
      {
        uint64_t v13 = v9 + 136 * v8;
        int v14 = *(_DWORD **)(v13 + 88);
        *int v14 = 0;
        int v15 = *(_DWORD **)(v13 + 112);
        *int v15 = 0;
        if (*v11)
        {
          unsigned int v16 = 1;
          do
          {
            uint64_t v17 = v16;
            v14[v17] = -8388609;
            v15[v17] = 0;
            ++v16;
          }
          while (v16 <= *v11);
        }
      }
      ++v8;
    }
    while (v8 < *((unsigned int *)this + 210));
  }
  *((_WORD *)this + 460) = 1;
  *((_DWORD *)this + 222) = 0;
  *((_DWORD *)this + 221) = 0;
  uint64_t v18 = *((void *)this + 101);
  if (v18 && *((void *)this + 102)) {
    (*(void (**)(uint64_t))(*(void *)v18 + 160))(v18);
  }
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 128) = *((_DWORD *)this + 124) + 1;
  *((void *)this + 65) = 0;
  *((unsigned char *)this + 516) = 0;
  if (*((unsigned char *)this + 1072)) {
    NLocalCepNorm::resync((void **)this + 89);
  }
  *((void *)this + 131) = 0;
  NDEAcAnal::feedFromInt((IntNovDetectE *)((char *)this + 8), &a2[2 * v7], &v22);
  *((_DWORD *)this + 262) += v6;
  if (*((unsigned char *)this + 668)) {
    goto LABEL_19;
  }
  return 0;
}

uint64_t IntNovDetectE::feedFrameToNorm(int32x2_t *this, const NFrame *a2)
{
  if (!this[134].i8[0])
  {
    NDEHMMDetector::feedFrame((NDEHMMDetector *)&this[100], a2);
    IntNovDetectE::advanceDetectionAfterFeed((uint64_t)this);
    return 1;
  }
  NLocalCepNorm::pushFrame(this + 89, a2);
  int v3 = this[99].u8[4];
  __int32 v4 = this[91].i32[0];
  __int32 v5 = v4;
  if (this[99].i8[4])
  {
    if (v4) {
      goto LABEL_9;
    }
    __int32 v5 = 0;
  }
  if (v5 == this[92].i32[1] + 1)
  {
LABEL_9:
    while (v3 && v4 || v4 == this[92].i32[1] + 1)
    {
      NLocalCepNorm::setOutputFrame((NLocalCepNorm *)&this[89], (NFrame *)&this[127]);
      NDEHMMDetector::feedFrame((NDEHMMDetector *)&this[100], (const NFrame *)&this[127]);
      IntNovDetectE::advanceDetectionAfterFeed((uint64_t)this);
      int v3 = this[99].u8[4];
      __int32 v4 = this[91].i32[0];
    }
    return 1;
  }
  return 0;
}

uint64_t IntNovDetectE::advanceDetectionAfterFeed(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 1052) + 1;
  *(_DWORD *)(this + 1052) = v1;
  int v2 = *(unsigned __int8 *)(this + 1075);
  if (*(unsigned char *)(this + 1075)) {
    float v3 = (float)*(unsigned int *)(this + 656) / (float)*(unsigned int *)(this + 664);
  }
  else {
    float v3 = 100.0;
  }
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  unint64_t v6 = *(unsigned int *)(this + 840);
  float v7 = 0.0;
  while (v6 != v5)
  {
    if (v5 < v6)
    {
      int v8 = *(_DWORD *)(this + 1004);
      uint64_t v9 = *(void *)(this + 832);
      uint64_t v10 = *(unsigned int *)(v9 + v4 + 72);
      unsigned int v11 = v8 - *(_DWORD *)(*(void *)(v9 + v4 + 112) + 4 * v10);
      if (v11)
      {
        float v12 = *(float *)(*(void *)(v9 + v4 + 88) + 4 * v10) * (float)(*(_DWORD *)(this + 936) + 1);
        if (*(unsigned char *)(this + 1074)) {
          float v12 = v12 / (float)v11;
        }
        float v13 = v12 + *(float *)(v9 + v4 + 128);
        if (v2 && (v5 & 1) == 0)
        {
          float v7 = v13;
        }
        else if (v13 > *(float *)(this + 1064))
        {
          if (v2)
          {
            unsigned int v11 = ((float)(v3 * fmaxf(v7, 0.0)) + 0.5);
            float v7 = 0.0;
          }
          *(_DWORD *)(this + 1056) = v1
                                   - ((*(_DWORD *)(this + 1000) - v8 + *(_DWORD *)(this + 940)) & ~((*(_DWORD *)(this + 1000) - v8 + *(_DWORD *)(this + 940)) >> 31));
          *(_DWORD *)(this + 1060) = v11;
          *(float *)(this + 1064) = v13;
        }
      }
    }
    ++v5;
    v4 += 136;
  }
  if (*(_DWORD *)(this + 932))
  {
    unsigned int v14 = *(_DWORD *)(this + 1004) - *(_DWORD *)(this + 996);
    if (v14)
    {
      float v15 = *(float *)(this + 992);
      if (*(unsigned char *)(this + 1074)) {
        float v15 = v15 / (float)v14;
      }
      if (v15 > *(float *)(this + 1068)) {
        *(float *)(this + 1068) = v15;
      }
    }
  }
  return this;
}

float IntNovDetectE::getResult(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 1056);
  int v3 = *(_DWORD *)(a1 + 1040);
  int v4 = *(_DWORD *)(a1 + 1044);
  unsigned int v5 = *(_DWORD *)(a1 + 1060);
  BOOL v6 = v2 >= v5;
  unsigned int v8 = v2 - v5;
  BOOL v7 = v8 != 0 && v6;
  int v9 = v8 * v3;
  if (!v7) {
    int v9 = 0;
  }
  *(_DWORD *)a2 = *(_DWORD *)(a1 + 1048);
  *(_DWORD *)(a2 + 4) = v9;
  *(_DWORD *)(a2 + 8) = v4 + v3 * v2;
  float result = *(float *)(a1 + 1064);
  *(float *)(a2 + 12) = result;
  *(unsigned char *)(a2 + 16) = 0;
  return result;
}

uint64_t IntNovDetectE::setTriggerSignal(uint64_t this, BOOL *a2, BOOL *a3, const unsigned int *a4)
{
  *a2 = 0;
  *a3 = 0;
  if (!*a4) {
    return this;
  }
  int v4 = *(_DWORD *)(this + 1088);
  if (*(float *)(this + 1064) <= *(float *)(this + 1076))
  {
    if (v4 >= 1)
    {
      int v6 = v4 - *a4;
      *(_DWORD *)(this + 1088) = v6;
      if (v6 > 0) {
        goto LABEL_13;
      }
    }
  }
  else
  {
    if (v4 <= 0) {
      *a2 = 1;
    }
    int v5 = *(_DWORD *)(this + 1084);
    *(_DWORD *)(this + 1088) = v5;
    *(void *)(this + 1056) = 0;
    *(int32x2_t *)(this + 1064) = vdup_n_s32(0xC9742400);
    if (v5 > 0) {
      goto LABEL_13;
    }
  }
  if (*(float *)(this + 1068) > *(float *)(this + 1080))
  {
    if (*(int *)(this + 1092) <= 0) {
      *a3 = 1;
    }
    *(_DWORD *)(this + 1092) = *(_DWORD *)(this + 1084);
    *(_DWORD *)(this + 1068) = -915135488;
    return this;
  }
LABEL_13:
  int v7 = *(_DWORD *)(this + 1092);
  if (v7 >= 1) {
    *(_DWORD *)(this + 1092) = v7 - *a4;
  }
  return this;
}

uint64_t IntNovDetectE::processframe(uint64_t a1, float32x4_t *a2, unsigned int a3, unsigned char *a4, unsigned char *a5, uint64_t a6)
{
  if (*(_DWORD *)a1 != 1) {
    Error::chuck((Error *)"NovDetectE: process() can only be called after initialize()", (const char *)a2);
  }
  if (!*(unsigned char *)(a1 + 1073)) {
    return 0xFFFFFFFFLL;
  }
  int v10 = *(_DWORD *)(a1 + 1048);
  int v11 = *(_DWORD *)(a1 + 1040);
  *(_DWORD *)(a1 + 1048) = v11 + v10;
  if (__CFADD__(v11, v10))
  {
    *(_DWORD *)(a1 + 992) = -8388609;
    *(void *)(a1 + 1004) = 0;
    *(void *)(a1 + 996) = 0;
    if (*(_DWORD *)(a1 + 840))
    {
      unint64_t v12 = 0;
      uint64_t v13 = *(void *)(a1 + 832);
      do
      {
        uint64_t v14 = v13 + 136 * v12;
        int v16 = *(_DWORD *)(v14 + 72);
        float v15 = (unsigned int *)(v14 + 72);
        if (v16)
        {
          uint64_t v17 = v13 + 136 * v12;
          uint64_t v18 = *(_DWORD **)(v17 + 88);
          *uint64_t v18 = 0;
          BOOL v19 = *(_DWORD **)(v17 + 112);
          _DWORD *v19 = 0;
          if (*v15)
          {
            unsigned int v20 = 1;
            do
            {
              uint64_t v21 = v20;
              v18[v21] = -8388609;
              v19[v21] = 0;
              ++v20;
            }
            while (v20 <= *v15);
          }
        }
        ++v12;
      }
      while (v12 < *(unsigned int *)(a1 + 840));
    }
    *(_WORD *)(a1 + 920) = 1;
    *(_DWORD *)(a1 + 888) = 0;
    *(_DWORD *)(a1 + 884) = 0;
    uint64_t v23 = *(void *)(a1 + 808);
    if (v23 && *(void *)(a1 + 816)) {
      (*(void (**)(uint64_t))(*(void *)v23 + 160))(v23);
    }
    *(_DWORD *)(a1 + 88) = 0;
    *(_DWORD *)(a1 + 512) = *(_DWORD *)(a1 + 496) + 1;
    *(void *)(a1 + 520) = 0;
    *(unsigned char *)(a1 + 516) = 0;
    if (*(unsigned char *)(a1 + 1072)) {
      NLocalCepNorm::resync((void **)(a1 + 712));
    }
    *(_DWORD *)(a1 + 1052) = 0;
  }
  else
  {
    unsigned int v39 = a3;
    NDEFrameProc::apply((NDEFrameProc *)(a1 + 672), a2, &v39);
    IntNovDetectE::feedFrameToNorm((int32x2_t *)a1, (const NFrame *)(a1 + 672));
  }
  unsigned int v24 = *(_DWORD *)(a1 + 1056);
  int v25 = *(_DWORD *)(a1 + 1040);
  int v26 = *(_DWORD *)(a1 + 1044);
  unsigned int v27 = *(_DWORD *)(a1 + 1060);
  BOOL v28 = v24 >= v27;
  unsigned int v30 = v24 - v27;
  BOOL v29 = v30 != 0 && v28;
  int v31 = v30 * v25;
  if (!v29) {
    int v31 = 0;
  }
  *(_DWORD *)a6 = *(_DWORD *)(a1 + 1048);
  *(_DWORD *)(a6 + 4) = v31;
  *(_DWORD *)(a6 + 8) = v26 + v25 * v24;
  float v32 = *(float *)(a1 + 1064);
  *(float *)(a6 + 12) = v32;
  *(unsigned char *)(a6 + 16) = 0;
  *a4 = 0;
  *a5 = 0;
  int v33 = *(_DWORD *)(a1 + 1088);
  if (v32 <= *(float *)(a1 + 1076))
  {
    BOOL v35 = __OFSUB__(v33, 1);
    int v36 = v33 - 1;
    if (v36 < 0 == v35)
    {
      *(_DWORD *)(a1 + 1088) = v36;
      if (v36 > 0) {
        goto LABEL_33;
      }
    }
  }
  else
  {
    if (v33 <= 0) {
      *a4 = 1;
    }
    int v34 = *(_DWORD *)(a1 + 1084);
    *(_DWORD *)(a1 + 1088) = v34;
    *(void *)(a1 + 1056) = 0;
    *(int32x2_t *)(a1 + 1064) = vdup_n_s32(0xC9742400);
    if (v34 > 0) {
      goto LABEL_33;
    }
  }
  if (*(float *)(a1 + 1068) > *(float *)(a1 + 1080))
  {
    if (*(int *)(a1 + 1092) <= 0) {
      *a5 = 1;
    }
    uint64_t result = 0;
    *(_DWORD *)(a1 + 1092) = *(_DWORD *)(a1 + 1084);
    *(_DWORD *)(a1 + 1068) = -915135488;
    return result;
  }
LABEL_33:
  int v37 = *(_DWORD *)(a1 + 1092);
  uint64_t result = 0;
  BOOL v35 = __OFSUB__(v37, 1);
  int v38 = v37 - 1;
  if (v38 < 0 == v35) {
    *(_DWORD *)(a1 + 1092) = v38;
  }
  return result;
}

uint64_t IntNovDetectE::framedata(IntNovDetectE *this, float32x4_t *a2, unsigned int a3)
{
  int v4 = *((_DWORD *)this + 262);
  int v5 = *((_DWORD *)this + 260);
  *((_DWORD *)this + 262) = v5 + v4;
  if (__CFADD__(v5, v4))
  {
    *((_DWORD *)this + 248) = -8388609;
    *(void *)((char *)this + 1004) = 0;
    *(void *)((char *)this + 996) = 0;
    if (*((_DWORD *)this + 210))
    {
      unint64_t v6 = 0;
      uint64_t v7 = *((void *)this + 104);
      do
      {
        uint64_t v8 = v7 + 136 * v6;
        int v10 = *(_DWORD *)(v8 + 72);
        int v9 = (unsigned int *)(v8 + 72);
        if (v10)
        {
          uint64_t v11 = v7 + 136 * v6;
          unint64_t v12 = *(_DWORD **)(v11 + 88);
          _DWORD *v12 = 0;
          uint64_t v13 = *(_DWORD **)(v11 + 112);
          *uint64_t v13 = 0;
          if (*v9)
          {
            unsigned int v14 = 1;
            do
            {
              uint64_t v15 = v14;
              v12[v15] = -8388609;
              v13[v15] = 0;
              ++v14;
            }
            while (v14 <= *v9);
          }
        }
        ++v6;
      }
      while (v6 < *((unsigned int *)this + 210));
    }
    *((_WORD *)this + 460) = 1;
    *((_DWORD *)this + 222) = 0;
    *((_DWORD *)this + 221) = 0;
    uint64_t v16 = *((void *)this + 101);
    if (v16 && *((void *)this + 102)) {
      (*(void (**)(uint64_t))(*(void *)v16 + 160))(v16);
    }
    *((_DWORD *)this + 22) = 0;
    *((_DWORD *)this + 128) = *((_DWORD *)this + 124) + 1;
    *((void *)this + 65) = 0;
    *((unsigned char *)this + 516) = 0;
    if (*((unsigned char *)this + 1072)) {
      NLocalCepNorm::resync((void **)this + 89);
    }
    *((_DWORD *)this + 263) = 0;
  }
  else
  {
    unsigned int v18 = a3;
    NDEFrameProc::apply((IntNovDetectE *)((char *)this + 672), a2, &v18);
    IntNovDetectE::feedFrameToNorm((int32x2_t *)this, (IntNovDetectE *)((char *)this + 672));
  }
  return 0;
}

uint64_t IntNovDetectE::resetbest(int32x2_t *this)
{
  this[132] = 0;
  this[133] = vdup_n_s32(0xC9742400);
  return 0;
}

uint64_t IntNovDetectE::handleWavedataOverflow(IntNovDetectE *this, const char *a2, const int *a3)
{
  unsigned int v5 = *((_DWORD *)this + 262);
  unsigned int v6 = *a3 - v5;
  unsigned int v20 = v6;
  unsigned int v21 = v5;
  uint64_t v7 = (IntNovDetectE *)((char *)this + 8);
  NDEAcAnal::feedFromInt((IntNovDetectE *)((char *)this + 8), a2, &v20);
  *((_DWORD *)this + 248) = -8388609;
  *(void *)((char *)this + 1004) = 0;
  *(void *)((char *)this + 996) = 0;
  if (*((_DWORD *)this + 210))
  {
    unint64_t v8 = 0;
    uint64_t v9 = *((void *)this + 104);
    do
    {
      uint64_t v10 = v9 + 136 * v8;
      int v12 = *(_DWORD *)(v10 + 72);
      uint64_t v11 = (unsigned int *)(v10 + 72);
      if (v12)
      {
        uint64_t v13 = v9 + 136 * v8;
        unsigned int v14 = *(_DWORD **)(v13 + 88);
        *unsigned int v14 = 0;
        uint64_t v15 = *(_DWORD **)(v13 + 112);
        *uint64_t v15 = 0;
        if (*v11)
        {
          unsigned int v16 = 1;
          do
          {
            uint64_t v17 = v16;
            v14[v17] = -8388609;
            v15[v17] = 0;
            ++v16;
          }
          while (v16 <= *v11);
        }
      }
      ++v8;
    }
    while (v8 < *((unsigned int *)this + 210));
  }
  *((_WORD *)this + 460) = 1;
  *((_DWORD *)this + 222) = 0;
  *((_DWORD *)this + 221) = 0;
  uint64_t v18 = *((void *)this + 101);
  if (v18 && *((void *)this + 102)) {
    (*(void (**)(uint64_t))(*(void *)v18 + 160))(v18);
  }
  *((_DWORD *)this + 22) = 0;
  *((_DWORD *)this + 128) = *((_DWORD *)this + 124) + 1;
  *((void *)this + 65) = 0;
  *((unsigned char *)this + 516) = 0;
  if (*((unsigned char *)this + 1072)) {
    NLocalCepNorm::resync((void **)this + 89);
  }
  *((void *)this + 131) = 0;
  uint64_t result = NDEAcAnal::feedFromInt(v7, &a2[2 * v6], &v21);
  *((_DWORD *)this + 262) += v5;
  return result;
}

void IntNovDetectE::feedFrameToDetector(IntNovDetectE *this, const NFrame *a2)
{
}

uint64_t __Block_byref_object_copy__2037(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2038(uint64_t a1)
{
}

uint64_t _AssistantPrefsChangedNotification(uint64_t a1, void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v3 = AFPreferencesAssistantEnabled();
  int v4 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = @"Disabled";
    if (v3) {
      unsigned int v5 = @"Enabled";
    }
    int v7 = 138543362;
    unint64_t v8 = v5;
    _os_log_impl(&dword_21844F000, v4, OS_LOG_TYPE_DEFAULT, "Siri Enabled = %{public}@", (uint8_t *)&v7, 0xCu);
  }
  return [a2 _didReceiveSiriSettingChanged:v3 != 0];
}

void NLocalCepNorm::NLocalCepNorm(NLocalCepNorm *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = &unk_26C99C038;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = &unk_26C99C498;
  *((_DWORD *)this + 20) = 1065353048;
  *((unsigned char *)this + 84) = 0;
  int v1 = 1;
  NArray<NFrame>::resize((uint64_t)this + 32, &v1);
}

{
  int v1;

  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = &unk_26C99C038;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = &unk_26C99C498;
  *((_DWORD *)this + 20) = 1065353048;
  *((unsigned char *)this + 84) = 0;
  int v1 = 1;
  NArray<NFrame>::resize((uint64_t)this + 32, &v1);
}

void sub_21849C84C(_Unwind_Exception *a1)
{
  *unsigned int v2 = &unk_26C99C348;
  if (*v3) {
    MEMORY[0x21D46B220](*v3, 0x1000C8052888210);
  }
  NArray<NFrame>::~NArray(v1);
  _Unwind_Resume(a1);
}

void sub_21849C950(_Unwind_Exception *exception_object)
{
  unsigned int v5 = v1;
  *unsigned int v5 = &unk_26C99C348;
  if (*v4) {
    MEMORY[0x21D46B220](*v4, 0x1000C8052888210);
  }
  *(void *)(v2 + 32) = v3;
  uint64_t v7 = *(void *)(v2 + 40);
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 - 8);
    if (v8)
    {
      uint64_t v9 = 24 * v8;
      do
      {
        *(void *)(v7 + v9 - 24) = &unk_26C99C348;
        uint64_t v10 = *(void *)(v7 + v9 - 16);
        if (v10) {
          MEMORY[0x21D46B220](v10, 0x1000C8052888210);
        }
        v9 -= 24;
      }
      while (v9);
    }
    MEMORY[0x21D46B220](v7 - 16, 0x1081C80622C3295);
  }
  _Unwind_Resume(exception_object);
}

void NLocalCepNorm::configure(NLocalCepNorm *this, char *a2, const unsigned int *a3, float *a4, unsigned int *a5, const unsigned int *a6)
{
  unsigned int v9 = *a5;
  if (*a5 == -1)
  {
    unsigned int v10 = 0;
  }
  else if (v9 == -2)
  {
    if ((*(_DWORD *)a2 & 1) == 0) {
      Error::chuck((Error *)"NLocalCepNorm::configure() - only an odd number of frames supported", a2, a3, a4);
    }
    unsigned int v10 = *(_DWORD *)a2 >> 1;
  }
  else
  {
    uint64_t v11 = *(unsigned int *)a2;
    if (v9 >= v11) {
      Error::chuck((Error *)"NLocalCepNorm::configure() - offset %d lies outside window %d", a2, a3, a4, *a5, v11);
    }
    unsigned int v10 = v11 + ~v9;
  }
  *(_DWORD *)this = v10;
  uint64_t v12 = *(unsigned int *)a2;
  if (*((_DWORD *)this + 2) > v12) {
    Error::chuck((Error *)"NLocalCepNorm::configure() - minframes %d cannot exceed total buffer size %d", a2, a3, a4, *((unsigned int *)this + 2), v12);
  }
  *((_DWORD *)this + 2) = *a6;
  *((_DWORD *)this + 1) = *a3;
  *((float *)this + 20) = *a4;
  NArray<NFrame>::resize((uint64_t)this + 32, a2);
  if (*((_DWORD *)this + 18) != *a3)
  {
    *((_DWORD *)this + 18) = *a3;
    operator new[]();
  }
  if (*(_DWORD *)a2)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      (*(void (**)(uint64_t, const unsigned int *))(*(void *)(*((void *)this + 5) + v13) + 32))(*((void *)this + 5) + v13, a3);
      ++v14;
      v13 += 24;
    }
    while (v14 < *(unsigned int *)a2);
  }
  *((unsigned char *)this + 84) = 0;
  *(void *)((char *)this + 20) = 0;
  *(void *)((char *)this + 12) = 0;
  int v15 = *(_DWORD *)this;
  *((_DWORD *)this + 7) = *(_DWORD *)this;
  unsigned int v16 = *((_DWORD *)this + 2);
  if (v16 > v15 + 1) {
    *((_DWORD *)this + 7) = v16 - 1;
  }
  uint64_t v17 = *((unsigned int *)this + 1);
  if (v17)
  {
    uint64_t v18 = (void *)*((void *)this + 8);
    bzero(v18, 4 * v17);
  }
}

void NLocalCepNorm::reset(NLocalCepNorm *this)
{
  *((unsigned char *)this + 84) = 0;
  *(void *)((char *)this + 20) = 0;
  *(void *)((char *)this + 12) = 0;
  int v1 = *(_DWORD *)this;
  *((_DWORD *)this + 7) = *(_DWORD *)this;
  unsigned int v2 = *((_DWORD *)this + 2);
  if (v2 > v1 + 1) {
    *((_DWORD *)this + 7) = v2 - 1;
  }
  uint64_t v3 = *((unsigned int *)this + 1);
  if (v3) {
    bzero(*((void **)this + 8), 4 * v3);
  }
}

void NLocalCepNorm::resync(void **this)
{
  if (!*((unsigned char *)this + 84))
  {
    uint64_t v2 = *((unsigned int *)this + 1);
    if (v2) {
      bzero(this[8], 4 * v2);
    }
    unsigned int v3 = *((_DWORD *)this + 5);
    unsigned int v4 = *((_DWORD *)this + 3);
    if (v3 <= v4)
    {
      if (!v3) {
        return;
      }
      unsigned int v5 = *((_DWORD *)this + 12);
      if (!v2) {
        return;
      }
    }
    else
    {
      unsigned int v5 = *((_DWORD *)this + 12);
      v4 += v5;
      if (!v2) {
        return;
      }
    }
    unsigned int v6 = v4 - v3;
    uint64_t v7 = this[5];
    uint64_t v8 = (float *)this[8];
    if (v2 > 7)
    {
      uint64_t v11 = v2;
      uint64_t v12 = &v8[v2];
      if ((v2 & 0xFFFFFFF8) == v2)
      {
        int v13 = 0;
        do
        {
          unint64_t v14 = (float *)v7[3 * v6 + 1];
          if (v8 >= &v14[v11] || v14 >= v12)
          {
            unsigned int v16 = (float32x4_t *)(v14 + 4);
            uint64_t v17 = (float32x4_t *)(v8 + 4);
            uint64_t v18 = v2 & 0xFFFFFFF8;
            do
            {
              float32x4_t v19 = vaddq_f32(*v16, *v17);
              v17[-1] = vaddq_f32(v16[-1], v17[-1]);
              *uint64_t v17 = v19;
              v17 += 2;
              v16 += 2;
              v18 -= 8;
            }
            while (v18);
          }
          else
          {
            unsigned int v20 = v8;
            uint64_t v21 = v2;
            do
            {
              float v22 = *v14++;
              *unsigned int v20 = v22 + *v20;
              ++v20;
              --v21;
            }
            while (v21);
          }
          if (v6 + 1 < v5) {
            ++v6;
          }
          else {
            unsigned int v6 = 0;
          }
          ++v13;
        }
        while (v13 != v3);
      }
      else
      {
        int v23 = 0;
        do
        {
          unsigned int v24 = (float32x4_t *)v7[3 * v6 + 1];
          if (v8 >= &v24->f32[v11] || v24 >= (float32x4_t *)v12)
          {
            int v26 = v24 + 1;
            unsigned int v27 = (float32x4_t *)(v8 + 4);
            uint64_t v28 = v2 & 0xFFFFFFF8;
            do
            {
              float32x4_t v29 = vaddq_f32(*v26, *v27);
              v27[-1] = vaddq_f32(v26[-1], v27[-1]);
              *unsigned int v27 = v29;
              v27 += 2;
              v26 += 2;
              v28 -= 8;
            }
            while (v28);
            uint64_t v30 = v2 & 0xFFFFFFF8;
          }
          else
          {
            uint64_t v30 = 0;
          }
          uint64_t v31 = v2 - v30;
          uint64_t v32 = v30;
          int v33 = &v8[v30];
          int v34 = &v24->f32[v32];
          do
          {
            float v35 = *v34++;
            *int v33 = v35 + *v33;
            ++v33;
            --v31;
          }
          while (v31);
          if (v6 + 1 < v5) {
            ++v6;
          }
          else {
            unsigned int v6 = 0;
          }
          ++v23;
        }
        while (v23 != v3);
      }
    }
    else
    {
      float v9 = *v8;
      do
      {
        unsigned int v10 = (float *)v7[3 * v6 + 1];
        float v9 = *v10 + v9;
        *uint64_t v8 = v9;
        if (v2 != 1)
        {
          v8[1] = v10[1] + v8[1];
          if (v2 != 2)
          {
            v8[2] = v10[2] + v8[2];
            if (v2 != 3)
            {
              v8[3] = v10[3] + v8[3];
              if (v2 != 4)
              {
                v8[4] = v10[4] + v8[4];
                if (v2 != 5)
                {
                  v8[5] = v10[5] + v8[5];
                  if (v2 != 6) {
                    v8[6] = v10[6] + v8[6];
                  }
                }
              }
            }
          }
        }
        if (v6 + 1 < v5) {
          ++v6;
        }
        else {
          unsigned int v6 = 0;
        }
        --v3;
      }
      while (v3);
    }
  }
}

unsigned int *NLocalCepNorm::endFrames(unsigned int *this, const char *a2)
{
  if (*((unsigned char *)this + 84)) {
    Error::chuck((Error *)"NLocalCepNorm::endFrames() - endFrames() already called", a2);
  }
  unsigned int v2 = this[7];
  if (this[4] > v2) {
    Error::chuck((Error *)"NLocalCepNorm::endFrames() - buffer full", a2);
  }
  unsigned int v3 = this[5];
  unsigned int v4 = this[12];
  if (v3 >= v4) {
    Error::chuck((Error *)"NLocalCepNorm::endFrames() - buffer full - redundant test", a2);
  }
  unsigned int v5 = v4 + ~v3;
  this[6] = v5;
  unsigned int v6 = v4 + ~v2;
  if (v5 <= v6)
  {
    unsigned int v6 = v5;
  }
  else
  {
    unsigned int v7 = this[3];
    do
    {
      if (v7 + 1 < v4) {
        ++v7;
      }
      else {
        unsigned int v7 = 0;
      }
      --v5;
    }
    while (v5 > v6);
    this[3] = v7;
    this[6] = v6;
  }
  unsigned int v8 = *this;
  if (v2 > *this)
  {
    unsigned int v9 = this[3];
    unsigned int v10 = v2;
    do
    {
      if (--v9 >= v4) {
        unsigned int v9 = v4 - 1;
      }
      --v10;
    }
    while (v10 > v8);
    this[3] = v9;
    this[6] = v2 + v6 - v8;
    this[7] = v8;
  }
  *((unsigned char *)this + 84) = 1;
  return this;
}

int32x2_t NLocalCepNorm::pushFrame(int32x2_t *this, const NFrame *a2)
{
  unsigned int v2 = *((_DWORD *)a2 + 4);
  if (v2 != this->i32[1]) {
    Error::chuck((Error *)"NLocalCepNorm::pushFrame() - mismatched input frame size", (const char *)a2);
  }
  if (this[10].i8[4]) {
    Error::chuck((Error *)"NLocalCepNorm::pushFrame() - endFrames() already called", (const char *)a2);
  }
  if (this[2].i32[0] > (unsigned __int32)this[3].i32[1]) {
    Error::chuck((Error *)"NLocalCepNorm::pushFrame() - buffer full", (const char *)a2);
  }
  if (this[2].i32[1] >= (unsigned __int32)this[6].i32[0]) {
    Error::chuck((Error *)"NLocalCepNorm::pushFrame() - buffer full - redundant test", (const char *)a2);
  }
  uint64_t v4 = *(void *)&this[5] + 24 * this[1].u32[1];
  if ((const NFrame *)v4 != a2)
  {
    if (*(_DWORD *)(v4 + 16) != v2)
    {
      uint64_t v5 = *(void *)(v4 + 8);
      if (v5)
      {
        MEMORY[0x21D46B220](v5, 0x1000C8052888210);
        unsigned int v2 = *((_DWORD *)a2 + 4);
      }
      *(_DWORD *)(v4 + 16) = v2;
      operator new[]();
    }
    if (v2)
    {
      uint64_t v6 = 0;
      uint64_t v7 = *((void *)a2 + 1);
      uint64_t v8 = *(void *)(v4 + 8);
      uint64_t v9 = v2;
      if (v2 < 8) {
        goto LABEL_16;
      }
      if ((unint64_t)(v8 - v7) < 0x20) {
        goto LABEL_16;
      }
      uint64_t v6 = v2 & 0xFFFFFFF8;
      unsigned int v10 = (_OWORD *)(v8 + 16);
      uint64_t v11 = (long long *)(v7 + 16);
      uint64_t v12 = v9 & 0xFFFFFFF8;
      do
      {
        long long v13 = *v11;
        *(v10 - 1) = *(v11 - 1);
        *unsigned int v10 = v13;
        v10 += 2;
        v11 += 2;
        v12 -= 8;
      }
      while (v12);
      if (v6 != v9)
      {
LABEL_16:
        uint64_t v14 = v9 - v6;
        uint64_t v15 = 4 * v6;
        unsigned int v16 = (_DWORD *)(v8 + v15);
        uint64_t v17 = (int *)(v7 + v15);
        do
        {
          int v18 = *v17++;
          *v16++ = v18;
          --v14;
        }
        while (v14);
      }
    }
  }
  __int32 v19 = this[1].i32[1];
  if ((v19 + 1) < this[6].i32[0]) {
    __int32 v20 = v19 + 1;
  }
  else {
    __int32 v20 = 0;
  }
  this[1].i32[1] = v20;
  uint64_t v21 = this->u32[1];
  if (v21)
  {
    unint64_t v22 = *((void *)a2 + 1);
    unint64_t v23 = (unint64_t)this[8];
    if (v21 <= 7 || (v23 < v22 + 4 * v21 ? (BOOL v24 = v22 >= v23 + 4 * v21) : (BOOL v24 = 1), !v24))
    {
      uint64_t v25 = 0;
LABEL_33:
      uint64_t v30 = v21 - v25;
      uint64_t v31 = 4 * v25;
      uint64_t v32 = (float *)(v23 + v31);
      int v33 = (float *)(v22 + v31);
      do
      {
        float v34 = *v33++;
        *uint64_t v32 = v34 + *v32;
        ++v32;
        --v30;
      }
      while (v30);
      goto LABEL_35;
    }
    uint64_t v25 = v21 & 0xFFFFFFF8;
    int v26 = (float32x4_t *)(v23 + 16);
    unsigned int v27 = (float32x4_t *)(v22 + 16);
    uint64_t v28 = v25;
    do
    {
      float32x4_t v29 = vaddq_f32(*v27, *v26);
      v26[-1] = vaddq_f32(v27[-1], v26[-1]);
      *int v26 = v29;
      v26 += 2;
      v27 += 2;
      v28 -= 8;
    }
    while (v28);
    if (v25 != v21) {
      goto LABEL_33;
    }
  }
LABEL_35:
  int32x2_t result = vadd_s32(this[2], (int32x2_t)0x100000001);
  this[2] = result;
  return result;
}

BOOL NLocalCepNorm::frameReady(NLocalCepNorm *this)
{
  int v1 = *((_DWORD *)this + 4);
  return *((unsigned char *)this + 84) && v1 || v1 == *((_DWORD *)this + 7) + 1;
}

uint64_t NLocalCepNorm::setOutputFrame(NLocalCepNorm *this, NFrame *a2)
{
  uint64_t v5 = (char *)this + 84;
  int v6 = *((_DWORD *)this + 4);
  if (*((unsigned char *)this + 84))
  {
    int v7 = *((_DWORD *)this + 7);
    if (v6) {
      _ZF = 1;
    }
    else {
      _ZF = v7 == -1;
    }
    if (!_ZF) {
LABEL_71:
    }
      Error::chuck((Error *)"NLocalCepNorm::setOutputFrame() - buffer empty", (const char *)a2);
    int v9 = *((_DWORD *)this + 3);
    unsigned int v10 = *((_DWORD *)this + 12);
    if (v9 + 1 < v10) {
      int v11 = v9 + 1;
    }
    else {
      int v11 = 0;
    }
    *((_DWORD *)this + 3) = v11;
  }
  else
  {
    int v7 = *((_DWORD *)this + 7);
    if (v6 != v7 + 1) {
      goto LABEL_71;
    }
    unsigned int v10 = *((_DWORD *)this + 12);
    int v11 = *((_DWORD *)this + 3);
  }
  LODWORD(v2) = *((_DWORD *)this + 5);
  uint64_t v12 = *((void *)this + 5);
  uint64_t result = (*(uint64_t (**)(NFrame *, char *))(*(void *)a2 + 32))(a2, (char *)this + 4);
  uint64_t v15 = *((unsigned int *)this + 1);
  if (v15)
  {
    v14.i64[0] = 1.0;
    double v16 = 1.0 / (double)v2;
    *(float *)&double v16 = v16;
    uint64_t v17 = *(float32x4_t **)(v12 + 24 * ((v10 + ~v7 + v11) % v10) + 8);
    int v18 = (float32x4_t *)*((void *)this + 8);
    __int32 v19 = (float32x4_t *)*((void *)a2 + 1);
    if (v15 <= 7)
    {
      uint64_t v20 = 0;
LABEL_21:
      uint64_t v26 = v15 - v20;
      uint64_t v27 = v20;
      uint64_t v28 = &v19->f32[v27];
      float32x4_t v29 = &v18->f32[v27];
      uint64_t v30 = &v17->f32[v27];
      do
      {
        float v31 = *v30++;
        float v32 = v31;
        float v33 = *v29++;
        *v28++ = v32 - (float)(v33 * *(float *)&v16);
        --v26;
      }
      while (v26);
      goto LABEL_23;
    }
    uint64_t v20 = 0;
    if ((unint64_t)((char *)v19 - (char *)v17) < 0x20) {
      goto LABEL_21;
    }
    if ((unint64_t)((char *)v19 - (char *)v18) < 0x20) {
      goto LABEL_21;
    }
    uint64_t v20 = v15 & 0xFFFFFFF8;
    float32x4_t v14 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v16, 0);
    uint64_t v21 = v19 + 1;
    unint64_t v22 = v18 + 1;
    unint64_t v23 = v17 + 1;
    uint64_t v24 = v20;
    do
    {
      float32x4_t v25 = vmlsq_f32(*v23, v14, *v22);
      v21[-1] = vmlsq_f32(v23[-1], v14, v22[-1]);
      *uint64_t v21 = v25;
      v21 += 2;
      v22 += 2;
      v23 += 2;
      v24 -= 8;
    }
    while (v24);
    if (v20 != v15) {
      goto LABEL_21;
    }
  }
LABEL_23:
  int v34 = *((_DWORD *)this + 6);
  if (v34)
  {
    *((_DWORD *)this + 6) = v34 - 1;
    goto LABEL_50;
  }
  unsigned int v35 = *((_DWORD *)this + 5);
  if (v35 == *((_DWORD *)this + 12) || *v5)
  {
    int v36 = (float *)((char *)this + 80);
    v14.i32[0] = *((_DWORD *)this + 20);
    if (v14.f32[0] < 1.0 && v15 != 0)
    {
      double v38 = (double)v35;
      unint64_t v39 = *((void *)a2 + 1);
      unint64_t v40 = *((void *)this + 8);
      if (v15 < 8)
      {
        uint64_t v41 = 0;
LABEL_33:
        uint64_t v42 = v15 - v41;
        uint64_t v43 = 4 * v41;
        uint64_t v44 = (float *)(v40 + v43);
        unint64_t v45 = (float *)(v39 + v43);
        do
        {
          float v46 = *v45++;
          float v47 = *v44 + (1.0 - *v36) * v38 * v46;
          *v44++ = v47;
          --v42;
        }
        while (v42);
        goto LABEL_35;
      }
      uint64_t v41 = 0;
      unint64_t v63 = v40 + 4 * v15;
      BOOL v65 = v40 < v39 + 4 * v15 && v39 < v63;
      if ((unint64_t)v36 < v63 && v40 < (unint64_t)v5) {
        goto LABEL_33;
      }
      if (v65) {
        goto LABEL_33;
      }
      uint64_t v41 = v15 & 0xFFFFFFFC;
      __asm { FMOV            V2.2D, #1.0 }
      float64x2_t v70 = vmulq_n_f64(vsubq_f64(_Q2, vcvtq_f64_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v14.f32, 0))), v38);
      uint64_t v71 = (float32x4_t *)*((void *)a2 + 1);
      int v72 = (float32x2_t *)*((void *)this + 8);
      uint64_t v73 = v41;
      do
      {
        float32x4_t v74 = *v71++;
        *(float32x4_t *)v72->f32 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(vcvtq_f64_f32(*v72), vcvtq_f64_f32(*(float32x2_t *)v74.f32), v70)), vmlaq_f64(vcvt_hight_f64_f32(*(float32x4_t *)v72->f32), vcvt_hight_f64_f32(v74), v70));
        v72 += 2;
        v73 -= 4;
      }
      while (v73);
      if (v41 != v15) {
        goto LABEL_33;
      }
    }
LABEL_35:
    if (v15)
    {
      unint64_t v48 = *(void *)(*((void *)this + 5) + 24 * *((unsigned int *)this + 3) + 8);
      unint64_t v49 = *((void *)this + 8);
      if (v15 > 7 && (v49 < v48 + 4 * v15 ? (_CF = v48 >= v49 + 4 * v15) : (_CF = 1), _CF))
      {
        uint64_t v51 = v15 & 0xFFFFFFF8;
        int v52 = (float32x4_t *)(v49 + 16);
        uint64_t v53 = (float32x4_t *)(v48 + 16);
        uint64_t v54 = v51;
        do
        {
          float32x4_t v55 = vsubq_f32(*v52, *v53);
          v52[-1] = vsubq_f32(v52[-1], v53[-1]);
          *int v52 = v55;
          v52 += 2;
          v53 += 2;
          v54 -= 8;
        }
        while (v54);
        if (v51 == v15) {
          goto LABEL_49;
        }
      }
      else
      {
        uint64_t v51 = 0;
      }
      uint64_t v56 = v15 - v51;
      uint64_t v57 = 4 * v51;
      unsigned int v58 = (float *)(v49 + v57);
      uint64_t v59 = (float *)(v48 + v57);
      do
      {
        float v60 = *v59++;
        *unsigned int v58 = *v58 - v60;
        ++v58;
        --v56;
      }
      while (v56);
    }
LABEL_49:
    *((_DWORD *)this + 5) = v35 - 1;
LABEL_50:
    int v61 = *((unsigned __int8 *)this + 84);
    --*((_DWORD *)this + 4);
    if (v61) {
      return result;
    }
    goto LABEL_51;
  }
  --*((_DWORD *)this + 4);
LABEL_51:
  unsigned int v62 = *((_DWORD *)this + 7);
  if (v62 > *(_DWORD *)this) {
    *((_DWORD *)this + 7) = v62 - 1;
  }
  return result;
}

uint64_t NLocalCepNorm::getFrame@<X0>(NLocalCepNorm *this@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a2 + 16) = 0;
  *(void *)a2 = &unk_26C99C498;
  *(void *)(a2 + 8) = 0;
  return NLocalCepNorm::setOutputFrame(this, (NFrame *)a2);
}

void sub_21849D6D8(_Unwind_Exception *exception_object)
{
  *int v1 = &unk_26C99C348;
  uint64_t v3 = v1[1];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NChunkGaussianMixtureModelsHeader::NChunkGaussianMixtureModelsHeader(NChunkGaussianMixtureModelsHeader *this)
{
  *(_DWORD *)this = 0;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(_DWORD *)this = 0;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader(NChunkGaussianMixtureModelsHeader *this)
{
  unint64_t v2 = (NChunkGaussianMixtureModelsHeader *)((char *)this + 40);
  *((void *)this + 5) = &unk_26C99BC98;
  *((void *)this + 26) = &unk_26C99C3B8;
  uint64_t v3 = *((void *)this + 27);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 22) = &unk_26C99C3B8;
  uint64_t v4 = *((void *)this + 23);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales(v2);
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
}

{
  NFixedPointScales *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  unint64_t v2 = (NChunkGaussianMixtureModelsHeader *)((char *)this + 40);
  *((void *)this + 5) = &unk_26C99BC98;
  *((void *)this + 26) = &unk_26C99C3B8;
  uint64_t v3 = *((void *)this + 27);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 22) = &unk_26C99C3B8;
  uint64_t v4 = *((void *)this + 23);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales(v2);
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
}

void NChunkGaussianMixtureModelsHeader::read(NChunkGaussianMixtureModelsHeader *this, const NString *a2, NFilePtr *a3, const NString *a4, const BOOL *a5)
{
  uint64_t v5 = &unk_26C99C5B0;
  int v6 = *((_DWORD *)a4 + 2);
  operator new[]();
}

void sub_21849E894(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
  }
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  if (a19) {
    MEMORY[0x21D46B220](a19, 0x1000C8077774924);
  }
  if (a22) {
    MEMORY[0x21D46B220](a22, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NChunkGaussianMixtureModelsHeader::readField(NChunkGaussianMixtureModelsHeader *this, const NString *a2, NFilePtr *a3, const NString *a4, NString *a5)
{
  if (!*((unsigned char *)this + 252))
  {
    uint64_t v8 = &unk_26C99C5B0;
    int v9 = 0;
    operator new[]();
  }
  uint64_t v6 = *((void *)a3 + 1);
  if (!v6) {
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  }
  (*(void (**)(void **__return_ptr))(*(void *)v6 + 88))(&v8);
  (*(void (**)(NString *, void **))(*(void *)a5 + 32))(a5, &v8);
  uint64_t v8 = &unk_26C99C5B0;
  uint64_t result = v10;
  if (v10) {
    return MEMORY[0x21D46B220](v10, 0x1000C8077774924);
  }
  return result;
}

void sub_21849EFBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a25) {
    MEMORY[0x21D46B220](a25, 0x1000C8077774924);
  }
  *(void *)(v25 - 120) = a14;
  uint64_t v27 = *(void *)(v25 - 104);
  if (v27) {
    MEMORY[0x21D46B220](v27, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NChunkGaussianMixtureModelsHeader::readField<unsigned int>(char a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (!a1)
  {
    int v11 = &unk_26C99C5B0;
    int v12 = 0;
    operator new[]();
  }
  uint64_t v7 = *(void *)(a3 + 8);
  if (!v7) {
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  }
  (*(void (**)(void **__return_ptr))(*(void *)v7 + 64))(&v11);
  if (v12 != 4)
  {
    *a5 = 0;
    NString::~NString((NString *)&v11);
    Error::chuck((Error *)"NChunkGaussianMixtureModelsHeader::readBinary() - failed to read %s from file %s", v9, *(void *)(a4 + 16), *(void *)(a2 + 16));
  }
  *a5 = *v13;
  int v11 = &unk_26C99C5B0;
  return MEMORY[0x21D46B220]();
}

void sub_21849F728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  *(void *)(v25 - 120) = a14;
  uint64_t v27 = *(void *)(v25 - 104);
  if (v27) {
    MEMORY[0x21D46B220](v27, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NChunkGaussianMixtureModelsHeader::readField<unsigned char>(char a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  if (!a1)
  {
    int v11 = &unk_26C99C5B0;
    int v12 = 0;
    operator new[]();
  }
  uint64_t v7 = *(void *)(a3 + 8);
  if (!v7) {
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  }
  (*(void (**)(void **__return_ptr))(*(void *)v7 + 64))(&v11);
  if (v12 != 1)
  {
    *a5 = 0;
    NString::~NString((NString *)&v11);
    Error::chuck((Error *)"NChunkGaussianMixtureModelsHeader::readBinary() - failed to read %s from file %s", v9, *(void *)(a4 + 16), *(void *)(a2 + 16));
  }
  *a5 = *v13;
  int v11 = &unk_26C99C5B0;
  return MEMORY[0x21D46B220]();
}

void sub_21849FE70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  *(void *)(v25 - 120) = a14;
  uint64_t v27 = *(void *)(v25 - 104);
  if (v27) {
    MEMORY[0x21D46B220](v27, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NChunkGaussianMixtureModelsHeader::write(NChunkGaussianMixtureModelsHeader *this, NFilePtr *a2)
{
  uint64_t v2 = *((void *)a2 + 1);
  if (*((unsigned char *)this + 253))
  {
    if (v2) {
      operator new[]();
    }
  }
  else if (v2)
  {
    operator new[]();
  }
  Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
}

void sub_2184A16AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22)
  {
    MEMORY[0x21D46B220](a22, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void NChunkGaussianMixtureModelsHeader::writeBinary(NChunkGaussianMixtureModelsHeader *this, NFilePtr *a2)
{
  uint64_t v2 = *((void *)a2 + 1);
  if (*((unsigned char *)this + 253))
  {
    if (v2) {
      operator new[]();
    }
  }
  else if (v2)
  {
    operator new[]();
  }
  Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
}

void sub_2184A2310(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NChunkGaussianMixtureModelsHeader::encodingString(NChunkGaussianMixtureModelsHeader *this)
{
  int v1 = &unk_26C99C5B0;
  int v2 = 0;
  operator new[]();
}

void sub_2184A249C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a18) {
    MEMORY[0x21D46B220](a18, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NFastFixedGaussians<signed char,int,unsigned char>::score(uint64_t a1, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int32x4_t a11)
{
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v12 = (*(_DWORD *)(a1 + 232) * *a2);
  uint64_t v13 = *(unsigned int *)(a1 + 216);
  int v14 = *(_DWORD *)(v11 + v12);
  if (v13)
  {
    uint64_t v15 = (char *)(v11 + v12 + 4);
    double v16 = *(int16x8_t **)(a3 + 8);
    uint64_t v17 = *(int32x4_t **)(a1 + 208);
    if (v13 < 8)
    {
      uint64_t v18 = 0;
      goto LABEL_15;
    }
    if (v13 >= 0x20)
    {
      uint64_t v18 = v13 & 0xFFFFFFE0;
      int32x4_t v19 = (int32x4_t)*(unsigned int *)(v11 + v12);
      int32x4_t v20 = 0uLL;
      uint64_t v21 = (const char *)(v12 + v11 + 36);
      unint64_t v22 = v17 + 4;
      unint64_t v23 = v16 + 2;
      uint64_t v24 = v18;
      int32x4_t v25 = 0uLL;
      a11 = 0uLL;
      int32x4_t v26 = 0uLL;
      int32x4_t v27 = 0uLL;
      int32x4_t v28 = 0uLL;
      int32x4_t v29 = 0uLL;
      do
      {
        uint64_t v30 = v21 - 32;
        int8x16x2_t v92 = vld2q_s8(v30);
        int8x16x2_t v93 = vld2q_s8(v21);
        int16x8_t v31 = v23[-2];
        int16x8_t v32 = v23[-1];
        int32x4_t v33 = vmovl_high_s16(v32);
        int32x4_t v34 = vmovl_high_s16(v31);
        int16x8_t v35 = *v23;
        int16x8_t v36 = v23[1];
        v23 += 4;
        int32x4_t v37 = vmovl_high_s16(v36);
        int32x4_t v38 = vmovl_high_s16(v35);
        int16x8_t v39 = vmovl_s8(*(int8x8_t *)v92.val[0].i8);
        int16x8_t v40 = vmovl_high_s8(v92.val[0]);
        int16x8_t v41 = vmovl_s8(*(int8x8_t *)v93.val[0].i8);
        int16x8_t v42 = vmovl_high_s8(v93.val[0]);
        int32x4_t v43 = vsubq_s32(vmovl_s16(*(int16x4_t *)v31.i8), vshll_n_s16(*(int16x4_t *)v39.i8, 8uLL));
        int32x4_t v44 = vsubq_s32(v34, vshll_high_n_s16(v39, 8uLL));
        int32x4_t v45 = vsubq_s32(vmovl_s16(*(int16x4_t *)v32.i8), vshll_n_s16(*(int16x4_t *)v40.i8, 8uLL));
        int32x4_t v46 = vsubq_s32(v33, vshll_high_n_s16(v40, 8uLL));
        int32x4_t v47 = vsubq_s32(vmovl_s16(*(int16x4_t *)v35.i8), vshll_n_s16(*(int16x4_t *)v41.i8, 8uLL));
        int32x4_t v48 = vsubq_s32(v38, vshll_high_n_s16(v41, 8uLL));
        int32x4_t v49 = vsubq_s32(vmovl_s16(*(int16x4_t *)v36.i8), vshll_n_s16(*(int16x4_t *)v42.i8, 8uLL));
        int32x4_t v50 = vsubq_s32(v37, vshll_high_n_s16(v42, 8uLL));
        int32x4_t v51 = (int32x4_t)vqtbl1q_s8(v92.val[1], (int8x16_t)xmmword_21852DE80);
        int32x4_t v52 = (int32x4_t)vqtbl1q_s8(v92.val[1], (int8x16_t)xmmword_21852DE90);
        int32x4_t v53 = (int32x4_t)vqtbl1q_s8(v92.val[1], (int8x16_t)xmmword_21852DEA0);
        v92.val[0] = vqtbl1q_s8(v92.val[1], (int8x16_t)xmmword_21852DEB0);
        v92.val[1] = vqtbl1q_s8(v93.val[1], (int8x16_t)xmmword_21852DE80);
        int32x4_t v54 = (int32x4_t)vqtbl1q_s8(v93.val[1], (int8x16_t)xmmword_21852DE90);
        int32x4_t v55 = (int32x4_t)vqtbl1q_s8(v93.val[1], (int8x16_t)xmmword_21852DEA0);
        v93.val[0] = vqtbl1q_s8(v93.val[1], (int8x16_t)xmmword_21852DEB0);
        v92.val[0] = (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v92.val[0], (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v46, v46), 0xFuLL)), 8uLL);
        v93.val[1] = (int8x16_t)vshlq_n_s32(vmulq_s32(v53, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v45, v45), 0xFuLL)), 8uLL);
        uint32x4_t v56 = (uint32x4_t)vshlq_n_s32(vmulq_s32(v52, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v44, v44), 0xFuLL)), 8uLL);
        uint32x4_t v57 = (uint32x4_t)vshlq_n_s32(vmulq_s32(v51, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v43, v43), 0xFuLL)), 8uLL);
        v93.val[0] = (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v93.val[0], (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v50, v50), 0xFuLL)), 8uLL);
        uint32x4_t v58 = (uint32x4_t)vshlq_n_s32(vmulq_s32(v55, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v49, v49), 0xFuLL)), 8uLL);
        uint32x4_t v59 = (uint32x4_t)vshlq_n_s32(vmulq_s32(v54, (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v48, v48), 0xFuLL)), 8uLL);
        v92.val[1] = (int8x16_t)vshlq_n_s32(vmulq_s32((int32x4_t)v92.val[1], (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v47, v47), 0xFuLL)), 8uLL);
        int32x4_t v61 = v22[-2];
        int32x4_t v60 = v22[-1];
        int32x4_t v63 = v22[-4];
        int32x4_t v62 = v22[-3];
        int32x4_t v65 = v22[2];
        int32x4_t v64 = v22[3];
        int32x4_t v67 = *v22;
        int32x4_t v66 = v22[1];
        v22 += 8;
        a11 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v92.val[0], (uint32x4_t)vnegq_s32(v60)), a11);
        int32x4_t v25 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v93.val[1], (uint32x4_t)vnegq_s32(v61)), v25);
        int32x4_t v20 = vaddq_s32((int32x4_t)vshlq_u32(v56, (uint32x4_t)vnegq_s32(v62)), v20);
        int32x4_t v19 = vaddq_s32((int32x4_t)vshlq_u32(v57, (uint32x4_t)vnegq_s32(v63)), v19);
        int32x4_t v29 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v93.val[0], (uint32x4_t)vnegq_s32(v64)), v29);
        v21 += 64;
        int32x4_t v28 = vaddq_s32((int32x4_t)vshlq_u32(v58, (uint32x4_t)vnegq_s32(v65)), v28);
        int32x4_t v27 = vaddq_s32((int32x4_t)vshlq_u32(v59, (uint32x4_t)vnegq_s32(v66)), v27);
        int32x4_t v26 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v92.val[1], (uint32x4_t)vnegq_s32(v67)), v26);
        v24 -= 32;
      }
      while (v24);
      int v14 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v26, v19), vaddq_s32(v28, v25)), vaddq_s32(vaddq_s32(v27, v20), vaddq_s32(v29, a11))));
      if (v18 == v13) {
        return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
      }
      if ((v13 & 0x18) == 0)
      {
        v15 += 2 * v18;
LABEL_15:
        uint64_t v85 = v13 - v18;
        uint64_t v86 = &v17->i32[v18];
        uint64_t v87 = &v16->i16[v18];
        do
        {
          int v88 = *v87++;
          unsigned int v89 = (v15[1] * (((v88 - (*v15 << 8)) * (v88 - (*v15 << 8))) >> 15)) << 8;
          int v90 = *v86++;
          v14 += v89 >> v90;
          v15 += 2;
          --v85;
        }
        while (v85);
        return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    uint64_t v68 = v18;
    uint64_t v18 = v13 & 0xFFFFFFF8;
    int32x4_t v69 = 0uLL;
    int32x4_t v70 = (int32x4_t)v14;
    uint64_t v71 = v68 - v18;
    int v72 = (int32x4_t *)((char *)v17 + 4 * v68);
    uint64_t v73 = 2 * v68;
    float32x4_t v74 = (int16x8_t *)((char *)v16 + 2 * v68);
    float16x8_t v75 = (const char *)(v73 + v11 + v12 + 4);
    do
    {
      int16x8_t v76 = *v74++;
      *(int8x8x2_t *)((char *)&a11 - 8) = vld2_s8(v75);
      v75 += 16;
      int16x8_t v78 = vmovl_s8(v77);
      int32x4_t v79 = vsubq_s32(vmovl_s16(*(int16x4_t *)v76.i8), vshll_n_s16(*(int16x4_t *)v78.i8, 8uLL));
      int32x4_t v80 = vsubq_s32(vmovl_high_s16(v76), vshll_high_n_s16(v78, 8uLL));
      uint32x4_t v81 = (uint32x4_t)vshlq_n_s32(vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)a11, (int8x16_t)xmmword_21852DE90), (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v80, v80), 0xFuLL)), 8uLL);
      uint32x4_t v82 = (uint32x4_t)vshlq_n_s32(vmulq_s32((int32x4_t)vqtbl1q_s8((int8x16_t)a11, (int8x16_t)xmmword_21852DE80), (int32x4_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v79, v79), 0xFuLL)), 8uLL);
      int32x4_t v84 = *v72;
      int32x4_t v83 = v72[1];
      v72 += 2;
      a11 = vnegq_s32(v84);
      int32x4_t v69 = vaddq_s32((int32x4_t)vshlq_u32(v81, (uint32x4_t)vnegq_s32(v83)), v69);
      int32x4_t v70 = vaddq_s32((int32x4_t)vshlq_u32(v82, (uint32x4_t)a11), v70);
      v71 += 8;
    }
    while (v71);
    int v14 = vaddvq_s32(vaddq_s32(v70, v69));
    if (v18 != v13)
    {
      v15 += 2 * (v13 & 0xFFFFFFF8);
      goto LABEL_15;
    }
  }
  return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
}

uint64_t NFastFixedGaussians<short,int,unsigned char>::score(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = (*(_DWORD *)(a1 + 232) * *a2);
  uint64_t v5 = *(unsigned int *)(a1 + 216);
  int v6 = *(_DWORD *)(v3 + v4);
  if (v5)
  {
    uint64_t v7 = (__int16 *)(v3 + v4 + 4);
    uint64_t v8 = *(int16x8_t **)(a3 + 8);
    int v9 = *(int32x4_t **)(a1 + 208);
    if (v5 < 0x10)
    {
      uint64_t v10 = 0;
      goto LABEL_8;
    }
    uint64_t v10 = v5 & 0xFFFFFFF0;
    int16x8_t v11 = 0uLL;
    int32x4_t v12 = (int32x4_t)*(unsigned int *)(v3 + v4);
    uint64_t v13 = (const __int16 *)(v4 + v3 + 36);
    int v14 = v9 + 2;
    uint64_t v15 = v8 + 1;
    uint64_t v16 = v10;
    int32x4_t v17 = 0uLL;
    int32x4_t v18 = 0uLL;
    do
    {
      int32x4_t v19 = v13 - 16;
      int16x8_t v20 = v15[-1];
      int16x8x2_t v36 = vld2q_s16(v19);
      int16x8x2_t v37 = vld2q_s16(v13);
      int32x4_t v21 = vsubl_high_s16(v20, v36.val[0]);
      int32x4_t v22 = vsubl_s16(*(int16x4_t *)v20.i8, *(int16x4_t *)v36.val[0].i8);
      int32x4_t v23 = vsubl_high_s16(*v15, v37.val[0]);
      int32x4_t v24 = vsubl_s16(*(int16x4_t *)v15->i8, *(int16x4_t *)v37.val[0].i8);
      uint32x4_t v25 = vmull_high_u16((uint16x8_t)vuzp1q_s16(v11, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v21, v21), 0xFuLL)), (uint16x8_t)v36.val[1]);
      uint32x4_t v26 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v22, v22), 0xFuLL), *(uint16x4_t *)v36.val[1].i8);
      v36.val[0] = (int16x8_t)vmull_high_u16((uint16x8_t)vuzp1q_s16(v11, (int16x8_t)vshrq_n_u32((uint32x4_t)vmulq_s32(v23, v23), 0xFuLL)), (uint16x8_t)v37.val[1]);
      uint32x4_t v27 = vmull_u16((uint16x4_t)vshrn_n_s32(vmulq_s32(v24, v24), 0xFuLL), *(uint16x4_t *)v37.val[1].i8);
      v37.val[0] = (int16x8_t)v14[-2];
      v36.val[1] = (int16x8_t)v14[-1];
      int32x4_t v28 = *v14;
      v37.val[1] = (int16x8_t)v14[1];
      v14 += 4;
      int16x8_t v11 = (int16x8_t)vaddq_s32((int32x4_t)vshlq_u32(v25, (uint32x4_t)vnegq_s32((int32x4_t)v36.val[1])), (int32x4_t)v11);
      int32x4_t v12 = vaddq_s32((int32x4_t)vshlq_u32(v26, (uint32x4_t)vnegq_s32((int32x4_t)v37.val[0])), v12);
      int32x4_t v18 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)v36.val[0], (uint32x4_t)vnegq_s32((int32x4_t)v37.val[1])), v18);
      int32x4_t v17 = vaddq_s32((int32x4_t)vshlq_u32(v27, (uint32x4_t)vnegq_s32(v28)), v17);
      v13 += 32;
      v15 += 2;
      v16 -= 16;
    }
    while (v16);
    int v6 = vaddvq_s32(vaddq_s32(vaddq_s32(v17, v12), vaddq_s32(v18, (int32x4_t)v11)));
    if (v10 != v5)
    {
      v7 += 2 * (v5 & 0xFFFFFFF0);
LABEL_8:
      uint64_t v29 = v5 - v10;
      uint64_t v30 = &v9->i32[v10];
      int16x8_t v31 = &v8->i16[v10];
      do
      {
        int v32 = *v31++;
        unsigned int v33 = (((v32 - *v7) * (v32 - *v7)) >> 15) * (unsigned __int16)v7[1];
        int v34 = *v30++;
        v6 += v33 >> v34;
        v7 += 2;
        --v29;
      }
      while (v29);
    }
  }
  return ((1 - (v6 >> *(_DWORD *)(a1 + 164))) >> 1);
}

uint64_t NFastFixedGaussians<signed char,int,unsigned short>::score(uint64_t a1, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, int32x4_t a11)
{
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v12 = (*(_DWORD *)(a1 + 232) * *a2);
  uint64_t v13 = *(unsigned int *)(a1 + 216);
  int v14 = *(_DWORD *)(v11 + v12);
  if (v13)
  {
    uint64_t v15 = (char *)(v11 + v12 + 4);
    uint64_t v16 = *(int16x8_t **)(a3 + 8);
    int32x4_t v17 = *(int32x4_t **)(a1 + 208);
    if (v13 < 8)
    {
      uint64_t v18 = 0;
      goto LABEL_15;
    }
    if (v13 >= 0x20)
    {
      uint64_t v18 = v13 & 0xFFFFFFE0;
      int32x4_t v19 = (int32x4_t)*(unsigned int *)(v11 + v12);
      int32x4_t v20 = 0uLL;
      int32x4_t v21 = (const char *)(v12 + v11 + 36);
      int32x4_t v22 = v17 + 4;
      int32x4_t v23 = v16 + 2;
      uint64_t v24 = v18;
      int32x4_t v25 = 0uLL;
      a11 = 0uLL;
      int32x4_t v26 = 0uLL;
      int32x4_t v27 = 0uLL;
      int32x4_t v28 = 0uLL;
      int32x4_t v29 = 0uLL;
      do
      {
        uint64_t v30 = v21 - 32;
        int8x16x2_t v90 = vld2q_s8(v30);
        int8x16x2_t v91 = vld2q_s8(v21);
        int16x8_t v31 = v23[-2];
        int16x8_t v32 = v23[-1];
        int32x4_t v33 = vmovl_high_s16(v32);
        int32x4_t v34 = vmovl_high_s16(v31);
        int16x8_t v35 = *v23;
        int16x8_t v36 = v23[1];
        v23 += 4;
        int32x4_t v37 = vmovl_high_s16(v36);
        int32x4_t v38 = vmovl_high_s16(v35);
        int16x8_t v39 = vmovl_s8(*(int8x8_t *)v90.val[0].i8);
        int16x8_t v40 = vmovl_high_s8(v90.val[0]);
        int16x8_t v41 = vmovl_s8(*(int8x8_t *)v91.val[0].i8);
        int16x8_t v42 = vmovl_high_s8(v91.val[0]);
        int32x4_t v43 = vshll_high_n_s16(v39, 7uLL);
        int32x4_t v44 = vshll_high_n_s16(v42, 7uLL);
        int32x4_t v45 = vshll_high_n_s16(v41, 7uLL);
        int32x4_t v46 = vsubq_s32(vmovl_s16(*(int16x4_t *)v31.i8), vshll_n_s16(*(int16x4_t *)v39.i8, 7uLL));
        int32x4_t v47 = vsubq_s32(vmovl_s16(*(int16x4_t *)v32.i8), vshll_n_s16(*(int16x4_t *)v40.i8, 7uLL));
        int32x4_t v48 = vsubq_s32(v33, vshll_high_n_s16(v40, 7uLL));
        int32x4_t v49 = vsubq_s32(vmovl_s16(*(int16x4_t *)v35.i8), vshll_n_s16(*(int16x4_t *)v41.i8, 7uLL));
        int32x4_t v50 = vsubq_s32(vmovl_s16(*(int16x4_t *)v36.i8), vshll_n_s16(*(int16x4_t *)v42.i8, 7uLL));
        int32x4_t v51 = (int32x4_t)vqtbl1q_s8(v90.val[1], (int8x16_t)xmmword_21852DE80);
        int32x4_t v52 = (int32x4_t)vqtbl1q_s8(v90.val[1], (int8x16_t)xmmword_21852DE90);
        int32x4_t v53 = (int32x4_t)vqtbl1q_s8(v90.val[1], (int8x16_t)xmmword_21852DEA0);
        v90.val[0] = vqtbl1q_s8(v90.val[1], (int8x16_t)xmmword_21852DEB0);
        v90.val[1] = vqtbl1q_s8(v91.val[1], (int8x16_t)xmmword_21852DE80);
        int32x4_t v54 = (int32x4_t)vqtbl1q_s8(v91.val[1], (int8x16_t)xmmword_21852DE90);
        int32x4_t v55 = (int32x4_t)vqtbl1q_s8(v91.val[1], (int8x16_t)xmmword_21852DEA0);
        v91.val[0] = vqtbl1q_s8(v91.val[1], (int8x16_t)xmmword_21852DEB0);
        v91.val[1] = (int8x16_t)vmulq_s32(v47, v53);
        int32x4_t v56 = vshrq_n_s32(vmulq_s32(v46, v51), 7uLL);
        int32x4_t v57 = vshrq_n_s32(vmulq_s32(vsubq_s32(v34, v43), v52), 7uLL);
        v91.val[1] = (int8x16_t)vshrq_n_s32((int32x4_t)v91.val[1], 7uLL);
        v90.val[0] = (int8x16_t)vshrq_n_s32(vmulq_s32(v48, (int32x4_t)v90.val[0]), 7uLL);
        v90.val[1] = (int8x16_t)vshrq_n_s32(vmulq_s32(v49, (int32x4_t)v90.val[1]), 7uLL);
        int32x4_t v58 = vshrq_n_s32(vmulq_s32(vsubq_s32(v38, v45), v54), 7uLL);
        int32x4_t v59 = vshrq_n_s32(vmulq_s32(v50, v55), 7uLL);
        v91.val[0] = (int8x16_t)vshrq_n_s32(vmulq_s32(vsubq_s32(v37, v44), (int32x4_t)v91.val[0]), 7uLL);
        int32x4_t v61 = v22[-2];
        int32x4_t v60 = v22[-1];
        int32x4_t v63 = v22[-4];
        int32x4_t v62 = v22[-3];
        int32x4_t v65 = v22[2];
        int32x4_t v64 = v22[3];
        int32x4_t v67 = *v22;
        int32x4_t v66 = v22[1];
        v22 += 8;
        a11 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)v90.val[0], (int32x4_t)v90.val[0]), (uint32x4_t)vnegq_s32(v60)), a11);
        int32x4_t v25 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)v91.val[1], (int32x4_t)v91.val[1]), (uint32x4_t)vnegq_s32(v61)), v25);
        int32x4_t v20 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v57, v57), (uint32x4_t)vnegq_s32(v62)), v20);
        int32x4_t v19 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v56, v56), (uint32x4_t)vnegq_s32(v63)), v19);
        int32x4_t v29 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)v91.val[0], (int32x4_t)v91.val[0]), (uint32x4_t)vnegq_s32(v64)), v29);
        v21 += 64;
        int32x4_t v28 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v59, v59), (uint32x4_t)vnegq_s32(v65)), v28);
        int32x4_t v27 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v58, v58), (uint32x4_t)vnegq_s32(v66)), v27);
        int32x4_t v26 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32((int32x4_t)v90.val[1], (int32x4_t)v90.val[1]), (uint32x4_t)vnegq_s32(v67)), v26);
        v24 -= 32;
      }
      while (v24);
      int v14 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v26, v19), vaddq_s32(v28, v25)), vaddq_s32(vaddq_s32(v27, v20), vaddq_s32(v29, a11))));
      if (v18 == v13) {
        return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
      }
      if ((v13 & 0x18) == 0)
      {
        v15 += 2 * v18;
LABEL_15:
        uint64_t v83 = v13 - v18;
        int32x4_t v84 = &v17->i32[v18];
        uint64_t v85 = &v16->i16[v18];
        do
        {
          int v86 = *v85++;
          int v87 = ((v86 - (*v15 << 7)) * v15[1]) >> 7;
          int v88 = *v84++;
          v14 += (v87 * v87) >> v88;
          v15 += 2;
          --v83;
        }
        while (v83);
        return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
      }
    }
    else
    {
      uint64_t v18 = 0;
    }
    uint64_t v68 = v18;
    uint64_t v18 = v13 & 0xFFFFFFF8;
    int32x4_t v69 = 0uLL;
    int32x4_t v70 = (int32x4_t)v14;
    uint64_t v71 = v68 - v18;
    int v72 = (int32x4_t *)((char *)v17 + 4 * v68);
    uint64_t v73 = 2 * v68;
    float32x4_t v74 = (int16x8_t *)((char *)v16 + 2 * v68);
    float16x8_t v75 = (const char *)(v73 + v11 + v12 + 4);
    do
    {
      int16x8_t v76 = *v74++;
      *(int8x8x2_t *)((char *)&a11 - 8) = vld2_s8(v75);
      v75 += 16;
      int16x8_t v78 = vmovl_s8(v77);
      int32x4_t v79 = vshrq_n_s32(vmulq_s32(vsubq_s32(vmovl_s16(*(int16x4_t *)v76.i8), vshll_n_s16(*(int16x4_t *)v78.i8, 7uLL)), (int32x4_t)vqtbl1q_s8((int8x16_t)a11, (int8x16_t)xmmword_21852DE80)), 7uLL);
      int32x4_t v80 = vshrq_n_s32(vmulq_s32(vsubq_s32(vmovl_high_s16(v76), vshll_high_n_s16(v78, 7uLL)), (int32x4_t)vqtbl1q_s8((int8x16_t)a11, (int8x16_t)xmmword_21852DE90)), 7uLL);
      int32x4_t v82 = *v72;
      int32x4_t v81 = v72[1];
      v72 += 2;
      a11 = vnegq_s32(v82);
      int32x4_t v69 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v80, v80), (uint32x4_t)vnegq_s32(v81)), v69);
      int32x4_t v70 = vaddq_s32((int32x4_t)vshlq_u32((uint32x4_t)vmulq_s32(v79, v79), (uint32x4_t)a11), v70);
      v71 += 8;
    }
    while (v71);
    int v14 = vaddvq_s32(vaddq_s32(v70, v69));
    if (v18 != v13)
    {
      v15 += 2 * (v13 & 0xFFFFFFF8);
      goto LABEL_15;
    }
  }
  return ((1 - (v14 >> *(_DWORD *)(a1 + 164))) >> 1);
}

void sub_2184A3644(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

uint64_t __deviceReportCallback()
{
  v0 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl(&dword_21844F000, v0, OS_LOG_TYPE_DEFAULT, "Posting HID device report received (Indicating VT first pass triggered in remote darwin)", v2, 2u);
  }
  return notify_post("com.apple.voicetrigger.RemoteDarwin.EarlyDetect");
}

uint64_t __deviceCallback(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v2 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = @"Connected";
    if (!a1) {
      uint64_t v3 = @"Disconnected";
    }
    int v5 = 138543362;
    int v6 = v3;
    _os_log_impl(&dword_21844F000, v2, OS_LOG_TYPE_DEFAULT, "Posting HID device connection changed : %{public}@", (uint8_t *)&v5, 0xCu);
  }
  return notify_post("com.apple.voicetrigger.RemoteDarwin.ConnectionChanged");
}

void NBaseFile::writeString(NBaseFile *this, const NString *a2)
{
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 0;
  operator new[]();
}

void sub_2184A4030(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a15) {
    MEMORY[0x21D46B220](a15, 0x1000C8077774924);
  }
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NBaseFile::print(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 96))();
}

void NBaseFile::printf(NBaseFile *this, const char *a2, ...)
{
}

void sub_2184A41A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NDeepnetDistribution::resetState(uint64_t this, void *a2)
{
  if (a2)
  {
    uint64_t v2 = this;
    uint64_t v3 = *(unsigned int *)(this + 48);
    if (v3)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 8 * v3;
      uint64_t v7 = 8;
      do
      {
        uint64_t v8 = *(const char **)(a2[1] + v5);
        if (v8)
        {
          uint64_t v9 = *(void *)(*(void *)(v2 + 40) + v7);
          if (!v9) {
            Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
          }
          this = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 56))(v9);
        }
        v5 += 8;
        v7 += 16;
      }
      while (v6 != v5);
    }
  }
  return this;
}

uint64_t NDeepnetDistribution::deallocateState(uint64_t this, void *a2)
{
  if (a2)
  {
    uint64_t v3 = this;
    uint64_t v4 = *(unsigned int *)(this + 48);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 8 * v4;
      uint64_t v7 = 8;
      do
      {
        uint64_t v8 = *(const char **)(a2[1] + v5);
        if (v8)
        {
          uint64_t v9 = *(void *)(*(void *)(v3 + 40) + v7);
          if (!v9) {
            Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v8);
          }
          (*(void (**)(uint64_t))(*(void *)v9 + 48))(v9);
        }
        v5 += 8;
        v7 += 16;
      }
      while (v6 != v5);
    }
    uint64_t v10 = *(uint64_t (**)(void *))(*a2 + 8);
    return v10(a2);
  }
  return this;
}

uint64_t NDeepnetDistribution::allocateStateP(NDeepnetDistribution *this, __n128 a2)
{
  v14[1] = *MEMORY[0x263EF8340];
  uint64_t v3 = *((unsigned int *)this + 12);
  MEMORY[0x270FA5388](a2);
  uint64_t v5 = (char *)v14 - v4;
  if (v3)
  {
    if ((unint64_t)(8 * v3) >= 0x200) {
      size_t v6 = 512;
    }
    else {
      size_t v6 = 8 * v3;
    }
    bzero(v5, v6);
    uint64_t v8 = 0;
    char v9 = 0;
    uint64_t v10 = (uint64_t *)v5;
    do
    {
      uint64_t v11 = *(void *)(*((void *)this + 5) + v8 + 8);
      if (!v11) {
        Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v7);
      }
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 40))(v11);
      *v10++ = v12;
      v9 |= v12 != 0;
      v8 += 16;
    }
    while (16 * v3 != v8);
    if (v9) {
      operator new();
    }
  }
  return 0;
}

void sub_2184A4660(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x1081C40622C3295);
  _Unwind_Resume(a1);
}

uint64_t NArray<void *>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<void *>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x80C80B8603338);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 8 * *(unsigned int *)(result + 16);
    do
    {
      *(void *)(*(void *)(result + 8) + v8) = *(void *)(a2 + v8);
      v8 += 8;
    }
    while (v9 != v8);
  }
  return result;
}

uint64_t NArray<void *>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x80C80B8603338);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * *(unsigned int *)(result + 16);
      do
      {
        *(void *)(*(void *)(result + 8) + v7) = *(void *)(*(void *)(a2 + 8) + v7);
        v7 += 8;
      }
      while (v8 != v7);
    }
  }
  return result;
}

void NArray<void *>::~NArray(void *a1)
{
  *a1 = &unk_26C99C230;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x80C80B8603338);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<void *>::~NArray(void *a1)
{
  *a1 = &unk_26C99C230;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x80C80B8603338);
  }
  return a1;
}

uint64_t NDeepnetDistribution::fixedPointScalesP(NDeepnetDistribution *this)
{
  return (uint64_t)this + 160;
}

void NDeepnetDistribution::baseGMM(NDeepnetDistribution *this, const char *a2)
{
}

void NDeepnetDistribution::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

void NDeepnetDistribution::firstComponentId(NDeepnetDistribution *this, const char *a2)
{
}

void NDeepnetDistribution::setComponentMask(uint64_t a1, const char *a2)
{
}

void NDeepnetDistribution::numComponents(NDeepnetDistribution *this, const char *a2)
{
}

void NDeepnetDistribution::componentScore(uint64_t a1, const char *a2)
{
}

void NDeepnetDistribution::scoreUsingCache(uint64_t a1, const char *a2)
{
}

void NDeepnetDistribution::scoreAll(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  uint64_t v5 = *(unsigned int *)(a1 + 12);
  if (*(_DWORD *)(a2 + 16) != v5) {
    Error::chuck((Error *)"NDeepnetDistribution::scoreAll() - input vector has wrong size (%d, should be %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v5);
  }
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if (*(_DWORD *)(a3 + 16) != v6) {
    Error::chuck((Error *)"NDeepnetDistribution::scoreAll() - output (dist) vector has wrong size (%d, should be %d)", (const char *)a2, *(unsigned int *)(a3 + 16), v6);
  }
  if (*(unsigned char *)(a1 + 376))
  {
    NDeepnetDistribution::forwardComputeFixed(a1, a5, a2, a3);
  }
  else
  {
    NDeepnetDistribution::forwardComputeFloat(a1, a2, a5, a3, a4);
  }
}

void NDeepnetDistribution::forwardComputeFixed(uint64_t a1, __n128 a2, uint64_t a3, uint64_t a4)
{
  v39[1] = *MEMORY[0x263EF8340];
  __n128 v6 = MEMORY[0x270FA5388](a2);
  __n128 v10 = MEMORY[0x270FA5388](v6);
  uint64_t v11 = (char *)v39 - v9;
  uint64_t v13 = *(unsigned int *)(v12 + 12);
  if (v13)
  {
    int v14 = *(float **)(v7 + 8);
    uint64_t v15 = *(float **)(a1 + 216);
    v10.n128_u64[0] = 0xC7000000C7000000;
    uint64_t v16 = (_DWORD *)((char *)v39 - v9);
    do
    {
      float v17 = *v14++;
      float v18 = v17;
      float v19 = *v15++;
      float v20 = v18 * v19;
      if (v20 > 32767.0) {
        float v20 = 32767.0;
      }
      if (v20 < -32768.0) {
        float v20 = -32768.0;
      }
      *v16++ = (uint64_t)rintf(v20);
      --v13;
    }
    while (v13);
  }
  uint64_t v21 = *(unsigned int *)(a1 + 48);
  if (!v21)
  {
    int32x4_t v25 = (int32x4_t *)v11;
    uint64_t v26 = *(unsigned int *)(a1 + 8);
    if (!v26) {
      return;
    }
LABEL_15:
    int32x4_t v27 = *(float32x4_t **)(a4 + 8);
    if (v26 >= 8)
    {
      uint64_t v28 = v26 & 0xFFFFFFF8;
      int32x4_t v29 = v27 + 1;
      uint64_t v30 = v25 + 1;
      v31.i64[0] = 0x3800000038000000;
      v31.i64[1] = 0x3800000038000000;
      uint64_t v32 = v28;
      do
      {
        float32x4_t v33 = vmulq_f32(vcvtq_f32_s32(*v30), v31);
        v29[-1] = vmulq_f32(vcvtq_f32_s32(v30[-1]), v31);
        *int32x4_t v29 = v33;
        v29 += 2;
        v30 += 2;
        v32 -= 8;
      }
      while (v32);
      if (v28 == v26) {
        return;
      }
    }
    else
    {
      uint64_t v28 = 0;
    }
    uint64_t v34 = v26 - v28;
    uint64_t v35 = v28;
    int16x8_t v36 = &v27->f32[v35];
    int32x4_t v37 = &v25->i32[v35];
    do
    {
      int v38 = *v37++;
      *v36++ = (float)v38 * 0.000030518;
      --v34;
    }
    while (v34);
    return;
  }
  uint64_t v22 = 0;
  uint64_t v23 = 16 * v21;
  do
  {
    uint64_t v24 = *(void *)(*(void *)(a1 + 40) + v22 + 8);
    if (!v24) {
      Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)v7, v10.n128_f64[0]);
    }
    int32x4_t v25 = v8;
    (*(void (**)(uint64_t, char *, int32x4_t *, __n128))(*(void *)v24 + 32))(v24, v11, v8, v10);
    v22 += 16;
    uint64_t v8 = (int32x4_t *)v11;
    uint64_t v11 = (char *)v25;
  }
  while (v23 != v22);
  uint64_t v26 = *(unsigned int *)(a1 + 8);
  if (v26) {
    goto LABEL_15;
  }
}

uint64_t NDeepnetDistribution::forwardComputeFloat(uint64_t a1, uint64_t a2, __n128 a3, uint64_t a4, uint64_t a5)
{
  v30[1] = *MEMORY[0x263EF8340];
  uint64_t v7 = *(const char **)(a2 + 8);
  int v8 = *(_DWORD *)(a1 + 48);
  uint64_t v9 = (v8 - 1);
  if (v8 != 1)
  {
    __n128 v10 = MEMORY[0x270FA5388](a3);
    uint64_t v12 = (char *)v30 - ((v11 + 15) & 0x7FFFFFFF0);
    a3 = MEMORY[0x270FA5388](v10);
    int v14 = (char *)v30 - ((v13 + 15) & 0x7FFFFFFF0);
    uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 8);
    if (a5)
    {
      if (!v15) {
        goto LABEL_26;
      }
      (*(void (**)(uint64_t, __n128))(*(void *)v15 + 24))(v15, a3);
      if (v9 >= 2)
      {
        uint64_t v16 = 1;
        uint64_t v17 = 24;
        while (1)
        {
          uint64_t v18 = *(void *)(*(void *)(a1 + 40) + v17);
          if (!v18) {
            goto LABEL_26;
          }
          float v19 = v12;
          uint64_t v12 = v14;
          (*(void (**)(uint64_t, char *, char *, void))(*(void *)v18 + 24))(v18, v14, v19, *(void *)(*(void *)(a5 + 8) + 8 * v16++));
          v17 += 16;
          int v14 = v19;
          if (v9 == v16) {
            goto LABEL_20;
          }
        }
      }
      uint64_t v9 = 1;
LABEL_20:
      uint64_t v27 = *(void *)(*(void *)(a1 + 40) + 16 * v9 + 8);
      if (v27)
      {
        uint64_t v28 = *(uint64_t (**)(void))(*(void *)v27 + 24);
        return v28();
      }
    }
    else
    {
      if (!v15) {
        goto LABEL_26;
      }
      (*(void (**)(uint64_t, __n128))(*(void *)v15 + 24))(v15, a3);
      if (v9 < 2)
      {
        uint64_t v9 = 1;
LABEL_23:
        uint64_t v29 = *(void *)(*(void *)(a1 + 40) + 16 * v9 + 8);
        if (v29)
        {
          uint64_t v28 = *(uint64_t (**)(void))(*(void *)v29 + 24);
          return v28();
        }
      }
      else
      {
        uint64_t v23 = v9 - 1;
        uint64_t v24 = 24;
        while (1)
        {
          uint64_t v25 = *(void *)(*(void *)(a1 + 40) + v24);
          if (!v25) {
            break;
          }
          uint64_t v26 = v12;
          uint64_t v12 = v14;
          (*(void (**)(uint64_t, char *, char *, void))(*(void *)v25 + 24))(v25, v14, v26, 0);
          v24 += 16;
          int v14 = v26;
          if (!--v23) {
            goto LABEL_23;
          }
        }
      }
    }
LABEL_26:
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v7, a3.n128_f64[0]);
  }
  uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8);
  if (!v20) {
    goto LABEL_26;
  }
  uint64_t v21 = *(uint64_t (**)(void))(*(void *)v20 + 24);

  return v21();
}

void NDeepnetDistribution::score(uint64_t a1, const char *a2)
{
}

void NDeepnetDistribution::read(NDeepnetDistribution *this, const NString *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  LODWORD(v11) = 0;
  NArray<NLayer>::resize((uint64_t)this + 32, &v11);
  uint64_t v4 = *((void *)this + 7);
  LODWORD(v11) = 0;
  (*(void (**)(char *, const char *, void **))(v4 + 64))((char *)this + 56, "", &v11);
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 13) = 0;
  size_t v5 = *((unsigned int *)this + 36);
  if (v5) {
    munmap(*((void **)this + 19), v5);
  }
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 19) = 0;
  LODWORD(v11) = 0;
  (*(void (**)(char *, const char *, void **))(*((void *)this + 14) + 64))((char *)this + 112, "", &v11);
  unsigned int v6 = *((_DWORD *)a2 + 2);
  if (v6 >= 7)
  {
    uint64_t v7 = (int *)*((void *)a2 + 2);
    int v8 = *v7;
    int v9 = *(int *)((char *)v7 + 3);
    if (v8 == 1684957549 && v9 == 980968804) {
      goto LABEL_12;
    }
  }
  else if (v6 < 4)
  {
LABEL_11:
    uint64_t v11 = &unk_26C99C5B0;
    int v12 = 1;
    operator new[]();
  }
  if (**((_DWORD **)a2 + 2) != 980443501) {
    goto LABEL_11;
  }
LABEL_12:
  NLoadedMemory::load((NDeepnetDistribution *)((char *)this + 88), a2);
  NDeepnetDistribution::mapFromMemory(this, *((const char **)this + 13), (const unsigned int *)this + 24, *((const char **)a2 + 2));
}

void sub_2184A6080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32)
{
  if (a26) {
    MEMORY[0x21D46B220](a26, 0x1000C8052888210);
  }
  if (a32) {
    MEMORY[0x21D46B220](a32, 0x1000C8077774924);
  }
  *(void *)(v32 - 160) = a18;
  uint64_t v34 = *(void *)(v32 - 152);
  if (v34) {
    MEMORY[0x21D46B220](v34, 0x1000C8052888210);
  }
  *(void *)(v32 - 136) = &unk_26C99C5B0;
  uint64_t v35 = *(void *)(v32 - 120);
  if (v35) {
    MEMORY[0x21D46B220](v35, 0x1000C8077774924);
  }
  *(void *)(v32 - 112) = &unk_26C99AA78;
  uint64_t v36 = *(void *)(v32 - 104);
  if (v36) {
    (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NArray<NLayer>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

void NDeepnetDistribution::mapFromMemory(NDeepnetDistribution *this, const char *a2, const unsigned int *a3, const char *a4)
{
  if (!a2)
  {
    int32x4_t v46 = "null pointer";
    goto LABEL_64;
  }
  uint64_t v5 = *a3;
  if (v5 <= 0x33)
  {
    int32x4_t v46 = "DNN image smaller than minimum";
    goto LABEL_64;
  }
  if (*(void *)a2 != 0x20624C4E4E442023 || *((void *)a2 + 1) != 0xA0A0A30302E3176)
  {
    int32x4_t v46 = "cannot read cookie from";
    goto LABEL_64;
  }
  int v9 = *((_DWORD *)a2 + 4);
  uint64_t v10 = *((unsigned int *)a2 + 5);
  uint64_t v11 = *((unsigned int *)a2 + 6);
  int v12 = *((_DWORD *)a2 + 7);
  uint64_t v13 = *((unsigned int *)a2 + 9);
  int v54 = *((_DWORD *)a2 + 9);
  uint64_t v14 = *((unsigned int *)a2 + 10);
  uint64_t v15 = *((unsigned int *)a2 + 11);
  if ((v9 & 0xF) == 2)
  {
    uint64_t v16 = BYTE1(v9);
  }
  else
  {
    if (v9 != 1)
    {
      int32x4_t v46 = "only version 1 or 2 of DNN file supported:";
      goto LABEL_64;
    }
    uint64_t v16 = 0;
  }
  if ((v11 & 1) != 0 || v16 >= 2) {
    Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - DNN image %s contains unsupported feature (required set = 0x%.6X%.8X, available = 0x%.6X%.8X)", a2, v14, a4, v16, v11, 1, 4294967294);
  }
  if (!v13) {
    Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - DNN image %s contains no layers (must be at least 1)", a2, v14, a4);
  }
  if (v13 >= 0x4000001) {
    Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - DNN image %s implies %u layers (too many)", a2, v14, a4, v13);
  }
  int v48 = v12;
  uint64_t v17 = &a2[v5];
  uint64_t v18 = *((_DWORD *)a2 + 12) + (-*((_DWORD *)a2 + 12) & 3u);
  float v19 = &a2[v18 + 52];
  if (v19 > &a2[v5])
  {
    int32x4_t v46 = "cannot read comment from";
  }
  else
  {
    *((unsigned char *)this + 376) = 0;
    if ((v11 & 0x20) != 0)
    {
      int32x4_t v50 = &unk_26C99C3B8;
      uint64_t v51 = 0;
      int v52 = 0;
      unsigned int v21 = *(_DWORD *)v19;
      uint64_t v20 = v19 + 4;
      unsigned int v53 = v21;
      if (&v20[(4 * v15)] > v17) {
        Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - %s %s", a2, "cannot read fixpoint scaling from", a4);
      }
      if (v15 * v14)
      {
        int v52 = v15 * v14;
        operator new[]();
      }
      if (v14 && v15)
      {
        if (v15 > 0xB)
        {
          unsigned int v34 = 0;
          for (uint64_t i = 0; i != v14; ++i)
          {
            uint64_t v36 = 0;
            if (__CFADD__(v15 * i, v15 - 1)) {
              goto LABEL_51;
            }
            if (4 * (unint64_t)(v15 * i) - (unint64_t)&a2[v18 + 56] < 0x20) {
              goto LABEL_51;
            }
            unsigned int v37 = v34;
            int v38 = &a2[v18 + 72];
            uint64_t v39 = v15 & 0xFFFFFFF8;
            do
            {
              long long v40 = *(_OWORD *)v38;
              int16x8_t v41 = (_OWORD *)(4 * v37);
              *int16x8_t v41 = *((_OWORD *)v38 - 1);
              v41[1] = v40;
              v38 += 32;
              v37 += 8;
              v39 -= 8;
            }
            while (v39);
            uint64_t v36 = v15 & 0xFFFFFFF8;
            if (v36 != v15)
            {
LABEL_51:
              uint64_t v42 = v15 - v36;
              unsigned int v43 = v34 + v36;
              int32x4_t v44 = &a2[4 * v36 + 56 + v18];
              do
              {
                int v45 = *(_DWORD *)v44;
                v44 += 4;
                *(_DWORD *)(4 * v43++) = v45;
                --v42;
              }
              while (v42);
            }
            v34 += v15;
          }
        }
        else
        {
          unsigned int v22 = 0;
          int v23 = 0;
          do
          {
            uint64_t v24 = v20;
            unsigned int v25 = v22;
            uint64_t v26 = v15;
            do
            {
              int v27 = *(_DWORD *)v24;
              v24 += 4;
              *(_DWORD *)(4 * v25++) = v27;
              --v26;
            }
            while (v26);
            ++v23;
            v22 += v15;
          }
          while (v23 != v14);
        }
      }
      NFixedPointScales::initialize((uint64_t)this + 160, &v53, (uint64_t)&v50);
      NFixedPointSigmoidTable::initialize((NDeepnetDistribution *)((char *)this + 288), (const unsigned int *)0x100, v28, 8.0);
      *((unsigned char *)this + 368) = 1;
      NFixedPointLogaddTable::initialize((NDeepnetDistribution *)((char *)this + 328), (const unsigned int *)0x100, v29, 8.0);
      *((unsigned char *)this + 369) = 1;
      *((unsigned char *)this + 376) = 1;
      int32x4_t v50 = &unk_26C99C3B8;
      if (v51) {
        MEMORY[0x21D46B220](v51, 0x1000C8052888210);
      }
      float v19 = &v20[(4 * v15)];
    }
    uint64_t v30 = &v19[(16 * v13)];
    if (v30 > v17)
    {
      int32x4_t v46 = "cannot read layer definitions from";
    }
    else
    {
      if (&v30[v10] <= v17)
      {
        if (&v30[v10] == v17)
        {
          LODWORD(v50) = v48;
          NArray<NLayer>::resize((uint64_t)this + 32, &v54);
          unsigned int v53 = *(_DWORD *)v19;
          int v31 = *((_DWORD *)v19 + 2);
          int v49 = *((_DWORD *)v19 + 3);
          BOOL v32 = __CFADD__(v49, v31);
          if (v49 + v31 <= v10 && !v32) {
            NLayer::initialize(*((void *)this + 5), &v53);
          }
          int32x4_t v47 = "layer incorrectly defined in";
        }
        else
        {
          int32x4_t v47 = "extra junk at end of image:";
        }
        Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - %s %s", a2, v47, a4);
      }
      int32x4_t v46 = "cannot read enough data from image:";
    }
  }
LABEL_64:
  Error::chuck((Error *)"NDeepnetDistribution::mapFromMemory() - %s %s", a2, v46, a4);
}

void sub_2184A697C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22) {
    MEMORY[0x21D46B220](a22, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NFixedPointSigmoidTable::initialize(NFixedPointSigmoidTable *this, const unsigned int *a2, const float *a3, float a4)
{
  int v4 = (int)a2;
  *(float *)this = a4;
  *((_DWORD *)this + 1) = a2;
  float v6 = a4 / (float)a2;
  *((float *)this + 2) = v6;
  float v8 = logf(v6) / -0.69315;
  unsigned int v9 = (int)(v8 + 0.5);
  *((_DWORD *)this + 3) = v9;
  if (vabds_f32(v8, (float)v9) > 0.0001) {
    Error::chuck((Error *)"NFixedPointSigmoidTable::initialize() - scale is not a power of 2", v7);
  }
  if (*((_DWORD *)this + 8) != v4)
  {
    *((_DWORD *)this + 8) = v4;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v10 = 0;
    float v11 = -*((float *)this + 2);
    uint64_t v12 = *((void *)this + 3);
    do
    {
      float v13 = 1.0 / (expf((float)v10 * v11) + 1.0);
      *(_WORD *)(v12 + 2 * v10++) = (uint64_t)rintf(v13 * 32767.0);
    }
    while (v4 != v10);
  }
}

void NFixedPointLogaddTable::initialize(NFixedPointLogaddTable *this, const unsigned int *a2, const float *a3, float a4)
{
  int v4 = (int)a2;
  *(float *)this = a4;
  *((_DWORD *)this + 1) = a2;
  float v6 = a4 / (float)a2;
  float v8 = logf(v6) / -0.69315;
  int v9 = (int)(v8 + 0.5);
  if (vabds_f32(v8, (float)v9) > 0.0001) {
    Error::chuck((Error *)"NFixedPointLogaddTable::initialize() - scale is not a power of 2", v7);
  }
  *((float *)this + 2) = 2.0 / v6;
  *((_DWORD *)this + 3) = v9 + 1;
  if (*((_DWORD *)this + 8) != v4)
  {
    *((_DWORD *)this + 8) = v4;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v10 = 0;
    float v11 = -v6;
    float v12 = *((float *)this + 2);
    uint64_t v13 = *((void *)this + 3);
    do
    {
      float v14 = expf(v11 * (float)v10);
      *(_WORD *)(v13 + 2 * v10++) = (int)((float)(logf(v14 + 1.0) * v12) + 0.5);
    }
    while (v4 != v10);
  }
}

void NLayer::initialize(uint64_t a1, unsigned int *a2)
{
  switch(*a2)
  {
    case 1u:
      operator new();
    case 2u:
      operator new();
    case 3u:
      operator new();
    case 4u:
      operator new();
    case 6u:
      operator new();
    case 7u:
      operator new();
    case 8u:
      operator new();
    case 9u:
      operator new();
    case 0xAu:
      operator new();
    case 0xBu:
      operator new();
    case 0xCu:
      operator new();
    case 0xDu:
      operator new();
    case 0xEu:
      operator new();
    case 0xFu:
      operator new();
    case 0x10u:
      operator new();
    case 0x11u:
      operator new();
    case 0x12u:
      operator new();
    case 0x13u:
      operator new();
    case 0x14u:
      operator new();
    case 0x15u:
      operator new();
    case 0x16u:
      operator new();
    case 0x17u:
      operator new();
    case 0x18u:
      operator new();
    case 0x19u:
      operator new();
    case 0x1Au:
      operator new();
    case 0x1Bu:
      operator new();
    case 0x1Cu:
      operator new();
    case 0x1Du:
      operator new();
    case 0x1Eu:
      operator new();
    case 0x1Fu:
      operator new();
    case 0x20u:
      operator new();
    default:
      (*(void (**)(uint64_t, void))(*(void *)a1 + 16))(a1, 0);
      Error::chuck((Error *)"NLayer::initialize() - unsupported layer type %d", v3, *a2);
  }
}

void sub_2184A76B8(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x10F1C4069C8BB13);
  _Unwind_Resume(a1);
}

uint64_t NBaseLayer::allocateStateP(NBaseLayer *this)
{
  return 0;
}

void NBaseLayer::compute(NBaseLayer *this, const char *a2, int *a3)
{
}

void Nfp16AMPalettizedLayer::compute(Nfp16AMPalettizedLayer *this, float *a2, float16x8_t *a3, void *a4)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  int v4 = (int8x16_t *)*((void *)this + 3);
  if (!v4) {
    Error::chuck((Error *)"Nfp16AMPalettizedLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  int v7 = *((_DWORD *)this + 3);
  unint64_t v8 = (2 * *((_DWORD *)this + 2));
  unint64_t v9 = (2 * v7);
  if (v9 == 64 && v8 == 64)
  {
    _ZN12accelerateml53AccelerateMLFullyConnected_InOutBiasFP16_WeightsUINT4ILm64ELm64ELm64ELm64EL39AccelerateMLFullyConnectedWeightsLayout2ELm1ELb0EXtl32AccelerateMLActivationDescriptorEEEEiPDF16_PKDF16_PKhS5_(a3, (__int32 *)a2, v4);
    return;
  }
  if (v9 == 64 && v8 == 248)
  {
    _ZN12accelerateml53AccelerateMLFullyConnected_InOutBiasFP16_WeightsUINT4ILm64ELm64ELm248ELm248EL39AccelerateMLFullyConnectedWeightsLayout2ELm1ELb0EXtl32AccelerateMLActivationDescriptorEEEEiPDF16_PKDF16_PKhS5_(a3, (__int32 *)a2, v4);
    return;
  }
  if (v9 == 48 && v8 == 64)
  {
    _ZN12accelerateml53AccelerateMLFullyConnected_InOutBiasFP16_WeightsUINT4ILm48ELm48ELm64ELm64EL39AccelerateMLFullyConnectedWeightsLayout2ELm1ELb0EXtl32AccelerateMLActivationDescriptorEEEEiPDF16_PKDF16_PKhS5_(a3, (uint64_t)a2, v4);
    return;
  }
  bzero(a3, 2 * (2 * v7));
  int8x16_t v14 = *v4;
  int8x16_t v15 = v4[1];
  if ((v7 & 7) != 0)
  {
    v43[0] = vzip1q_s8(v14, v15);
    v43[1] = vzip2q_s8(v14, v15);
  }
  if (v9 && v8)
  {
    unint64_t v16 = 0;
    uint64_t v17 = (int8x8_t *)&v4[2];
    v18.i64[0] = 0xF0F0F0F0F0F0F0FLL;
    v18.i64[1] = 0xF0F0F0F0F0F0F0FLL;
    unsigned int v19 = 2 * v7;
    do
    {
      unint64_t v20 = 0;
      unsigned int v21 = v19 - 64;
      if (v19 >= 0x40) {
        LOBYTE(v19) = 64;
      }
      unsigned int v22 = (((v19 & 0x70) - 1) & 0xFFFFFFF0) + 16;
      unsigned int v23 = v9 - v16;
      if ((v9 - v16) >= 0x40) {
        unsigned int v23 = 64;
      }
      do
      {
        short float v24 = *(short float *)&a2[v20 / 2];
        short float v25 = *(short float *)((char *)a2 + ((2 * v20) | 2));
        if ((v23 & 0x70) != 0)
        {
          uint64_t v26 = 0;
          i32 = (float *)a3[v16 / 8].i32;
          do
          {
            int8x16_t v28 = *(int8x16_t *)v17[v26].i8;
            int8x16_t v29 = vandq_s8(v28, v18);
            int8x16_t v30 = (int8x16_t)vshrq_n_u8((uint8x16_t)v28, 4uLL);
            int8x16_t v31 = vqtbl1q_s8(v14, v29);
            int8x16_t v32 = vqtbl1q_s8(v15, v29);
            int8x16_t v33 = vqtbl1q_s8(v14, v30);
            int8x16_t v34 = vqtbl1q_s8(v15, v30);
            float16x8_t v35 = (float16x8_t)vzip1q_s8(v31, v32);
            float16x8_t v36 = (float16x8_t)vzip2q_s8(v31, v32);
            float16x8_t v12 = vaddq_f16(vmulq_n_f16(v35, v24), vmulq_n_f16((float16x8_t)vzip1q_s8(v33, v34), v25));
            float16x8_t v37 = vaddq_f16(vmulq_n_f16(v36, v24), vmulq_n_f16((float16x8_t)vzip2q_s8(v33, v34), v25));
            float16x8_t v13 = *(float16x8_t *)(i32 + 4);
            int8x16_t v11 = (int8x16_t)vaddq_f16(*(float16x8_t *)i32, v12);
            int8x16_t v10 = (int8x16_t)vaddq_f16(v13, v37);
            *(int8x16_t *)i32 = v11;
            *((int8x16_t *)i32 + 1) = v10;
            i32 += 8;
            v26 += 2;
          }
          while ((v26 * 8) < (v23 & 0x70));
          uint64_t v17 = (int8x8_t *)((char *)v17 + v26 * 8);
          unsigned int v38 = v22;
          if ((v23 & 8) == 0) {
            goto LABEL_34;
          }
        }
        else
        {
          unsigned int v38 = 0;
          i32 = (float *)a3[v16 / 8].i32;
          if ((v23 & 8) == 0) {
            goto LABEL_34;
          }
        }
        int8x8_t v39 = *v17++;
        *(int8x8_t *)v11.i8 = vand_s8(v39, (int8x8_t)0xF0F0F0F0F0F0F0FLL);
        *(uint8x8_t *)v10.i8 = vshr_n_u8((uint8x8_t)v39, 4uLL);
        *(int8x8_t *)v12.i8 = vqtbl1_s8(v14, *(int8x8_t *)v11.i8);
        *(int8x8_t *)v11.i8 = vqtbl1_s8(v15, *(int8x8_t *)v11.i8);
        *(int8x8_t *)v13.i8 = vqtbl1_s8(v14, *(int8x8_t *)v10.i8);
        *(int8x8_t *)v10.i8 = vqtbl1_s8(v15, *(int8x8_t *)v10.i8);
        float16x8_t v40 = vaddq_f16(vmulq_n_f16((float16x8_t)vzip1q_s8((int8x16_t)v12, v11), v24), vmulq_n_f16((float16x8_t)vzip1q_s8((int8x16_t)v13, v10), v25));
        int8x16_t v11 = *(int8x16_t *)i32;
        int8x16_t v10 = (int8x16_t)vaddq_f16(*(float16x8_t *)i32, v40);
        *(int8x16_t *)i32 = v10;
        i32 += 4;
        v38 |= 8u;
LABEL_34:
        while (v38 < v23)
        {
          unsigned int v41 = v17->u16[0];
          uint64_t v17 = (int8x8_t *)((char *)v17 + 2);
          short float v42 = (short float)(v25 * *((short float *)v43 + (v41 >> 12)))
              + (short float)(*((short float *)v43 + ((v41 >> 8) & 0xF)) * v24);
          *(short float *)i32 = (short float)((short float)(v25 * *((short float *)v43 + (v41 >> 4)))
                                            + (short float)(*((short float *)v43 + (v41 & 0xF)) * v24))
                              + *(short float *)i32;
          *((short float *)i32 + 1) = v42 + *((short float *)i32 + 1);
          v38 += 2;
          ++i32;
        }
        v20 += 2;
      }
      while (v20 < v8);
      v16 += 64;
      unsigned int v19 = v21;
    }
    while (v16 < v9);
  }
}

float16x8_t *_ZN12accelerateml53AccelerateMLFullyConnected_InOutBiasFP16_WeightsUINT4ILm64ELm64ELm64ELm64EL39AccelerateMLFullyConnectedWeightsLayout2ELm1ELb0EXtl32AccelerateMLActivationDescriptorEEEEiPDF16_PKDF16_PKhS5_(float16x8_t *result, __int32 *a2, int8x16_t *a3)
{
  uint64_t v3 = a3 + 2;
  v4.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v4.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  int8x16_t v5 = *a3;
  int8x16_t v6 = a3[1];
  uint64_t v7 = 32;
  float16x8_t v8 = 0uLL;
  float16x8_t v9 = 0uLL;
  float16x8_t v10 = 0uLL;
  float16x8_t v11 = 0uLL;
  float16x8_t v12 = 0uLL;
  float16x8_t v13 = 0uLL;
  float16x8_t v14 = 0uLL;
  float16x8_t v15 = 0uLL;
  do
  {
    int8x16_t v17 = *v3;
    unint64_t v16 = v3 + 1;
    int8x16_t v18 = vandq_s8(v17, v4);
    int8x16_t v19 = (int8x16_t)vshrq_n_u8((uint8x16_t)v17, 4uLL);
    int8x16_t v20 = vqtbl1q_s8(v5, v18);
    int8x16_t v21 = vqtbl1q_s8(v6, v18);
    int8x16_t v22 = *v16++;
    int8x16_t v23 = vqtbl1q_s8(v5, v19);
    int8x16_t v24 = vqtbl1q_s8(v6, v19);
    float16x8_t v25 = (float16x8_t)vzip1q_s8(v20, v21);
    float16x8_t v26 = (float16x8_t)vzip2q_s8(v20, v21);
    float16x8_t v27 = (float16x8_t)vzip1q_s8(v23, v24);
    float16x8_t v28 = (float16x8_t)vzip2q_s8(v23, v24);
    int8x16_t v29 = vandq_s8(v22, v4);
    int8x16_t v30 = (int8x16_t)vshrq_n_u8((uint8x16_t)v22, 4uLL);
    int8x16_t v31 = vqtbl1q_s8(v5, v29);
    int8x16_t v32 = vqtbl1q_s8(v6, v29);
    int8x16_t v33 = *v16++;
    int8x16_t v34 = vqtbl1q_s8(v5, v30);
    int8x16_t v35 = vqtbl1q_s8(v6, v30);
    float16x8_t v36 = (float16x8_t)vzip1q_s8(v31, v32);
    float16x8_t v37 = (float16x8_t)vzip2q_s8(v31, v32);
    float16x8_t v38 = (float16x8_t)vzip1q_s8(v34, v35);
    float16x8_t v39 = (float16x8_t)vzip2q_s8(v34, v35);
    int8x16_t v40 = vandq_s8(v33, v4);
    int8x16_t v41 = (int8x16_t)vshrq_n_u8((uint8x16_t)v33, 4uLL);
    int8x16_t v42 = vqtbl1q_s8(v5, v40);
    int8x16_t v43 = vqtbl1q_s8(v6, v40);
    int8x16_t v44 = *v16;
    uint64_t v3 = v16 + 1;
    int8x16_t v45 = vqtbl1q_s8(v5, v41);
    int8x16_t v46 = vqtbl1q_s8(v6, v41);
    float16x8_t v47 = (float16x8_t)vzip1q_s8(v42, v43);
    float16x8_t v48 = (float16x8_t)vzip2q_s8(v42, v43);
    float16x8_t v49 = (float16x8_t)vzip1q_s8(v45, v46);
    float16x8_t v50 = (float16x8_t)vzip2q_s8(v45, v46);
    int8x16_t v51 = vandq_s8(v44, v4);
    int8x16_t v52 = (int8x16_t)vshrq_n_u8((uint8x16_t)v44, 4uLL);
    int8x16_t v53 = vqtbl1q_s8(v5, v51);
    int8x16_t v54 = vqtbl1q_s8(v6, v51);
    v44.i32[0] = *a2++;
    v51.i32[0] = v44.i32[0];
    int8x16_t v55 = vqtbl1q_s8(v5, v52);
    int8x16_t v56 = vqtbl1q_s8(v6, v52);
    float16x8_t v8 = vmlaq_lane_f16(vmlaq_n_f16(v8, v25, *(short float *)v44.i16), v27, *(float16x4_t *)v51.i8, 1);
    float16x8_t v9 = vmlaq_lane_f16(vmlaq_n_f16(v9, v26, *(short float *)v44.i16), v28, *(float16x4_t *)v51.i8, 1);
    float16x8_t v10 = vmlaq_lane_f16(vmlaq_n_f16(v10, v36, *(short float *)v44.i16), v38, *(float16x4_t *)v51.i8, 1);
    float16x8_t v11 = vmlaq_lane_f16(vmlaq_n_f16(v11, v37, *(short float *)v44.i16), v39, *(float16x4_t *)v51.i8, 1);
    float16x8_t v12 = vmlaq_lane_f16(vmlaq_n_f16(v12, v47, *(short float *)v44.i16), v49, *(float16x4_t *)v51.i8, 1);
    float16x8_t v13 = vmlaq_lane_f16(vmlaq_n_f16(v13, v48, *(short float *)v44.i16), v50, *(float16x4_t *)v51.i8, 1);
    float16x8_t v14 = vmlaq_lane_f16(vmlaq_n_f16(v14, (float16x8_t)vzip1q_s8(v53, v54), *(short float *)v44.i16), (float16x8_t)vzip1q_s8(v55, v56), *(float16x4_t *)v51.i8, 1);
    float16x8_t v15 = vmlaq_lane_f16(vmlaq_n_f16(v15, (float16x8_t)vzip2q_s8(v53, v54), *(short float *)v44.i16), (float16x8_t)vzip2q_s8(v55, v56), *(float16x4_t *)v51.i8, 1);
  }
  while (v7-- > 1);
  *uint64_t result = v8;
  result[1] = v9;
  result[2] = v10;
  result[3] = v11;
  result[4] = v12;
  result[5] = v13;
  result[6] = v14;
  result[7] = v15;
  return result;
}

float16x8_t *_ZN12accelerateml53AccelerateMLFullyConnected_InOutBiasFP16_WeightsUINT4ILm64ELm64ELm248ELm248EL39AccelerateMLFullyConnectedWeightsLayout2ELm1ELb0EXtl32AccelerateMLActivationDescriptorEEEEiPDF16_PKDF16_PKhS5_(float16x8_t *result, __int32 *a2, int8x16_t *a3)
{
  uint64_t v3 = a3 + 2;
  v4.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v4.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  int8x16_t v5 = *a3;
  int8x16_t v6 = a3[1];
  uint64_t v7 = 124;
  float16x8_t v8 = 0uLL;
  float16x8_t v9 = 0uLL;
  float16x8_t v10 = 0uLL;
  float16x8_t v11 = 0uLL;
  float16x8_t v12 = 0uLL;
  float16x8_t v13 = 0uLL;
  float16x8_t v14 = 0uLL;
  float16x8_t v15 = 0uLL;
  do
  {
    int8x16_t v17 = *v3;
    unint64_t v16 = v3 + 1;
    int8x16_t v18 = vandq_s8(v17, v4);
    int8x16_t v19 = (int8x16_t)vshrq_n_u8((uint8x16_t)v17, 4uLL);
    int8x16_t v20 = vqtbl1q_s8(v5, v18);
    int8x16_t v21 = vqtbl1q_s8(v6, v18);
    int8x16_t v22 = *v16++;
    int8x16_t v23 = vqtbl1q_s8(v5, v19);
    int8x16_t v24 = vqtbl1q_s8(v6, v19);
    float16x8_t v25 = (float16x8_t)vzip1q_s8(v20, v21);
    float16x8_t v26 = (float16x8_t)vzip2q_s8(v20, v21);
    float16x8_t v27 = (float16x8_t)vzip1q_s8(v23, v24);
    float16x8_t v28 = (float16x8_t)vzip2q_s8(v23, v24);
    int8x16_t v29 = vandq_s8(v22, v4);
    int8x16_t v30 = (int8x16_t)vshrq_n_u8((uint8x16_t)v22, 4uLL);
    int8x16_t v31 = vqtbl1q_s8(v5, v29);
    int8x16_t v32 = vqtbl1q_s8(v6, v29);
    int8x16_t v33 = *v16++;
    int8x16_t v34 = vqtbl1q_s8(v5, v30);
    int8x16_t v35 = vqtbl1q_s8(v6, v30);
    float16x8_t v36 = (float16x8_t)vzip1q_s8(v31, v32);
    float16x8_t v37 = (float16x8_t)vzip2q_s8(v31, v32);
    float16x8_t v38 = (float16x8_t)vzip1q_s8(v34, v35);
    float16x8_t v39 = (float16x8_t)vzip2q_s8(v34, v35);
    int8x16_t v40 = vandq_s8(v33, v4);
    int8x16_t v41 = (int8x16_t)vshrq_n_u8((uint8x16_t)v33, 4uLL);
    int8x16_t v42 = vqtbl1q_s8(v5, v40);
    int8x16_t v43 = vqtbl1q_s8(v6, v40);
    int8x16_t v44 = *v16;
    uint64_t v3 = v16 + 1;
    int8x16_t v45 = vqtbl1q_s8(v5, v41);
    int8x16_t v46 = vqtbl1q_s8(v6, v41);
    float16x8_t v47 = (float16x8_t)vzip1q_s8(v42, v43);
    float16x8_t v48 = (float16x8_t)vzip2q_s8(v42, v43);
    float16x8_t v49 = (float16x8_t)vzip1q_s8(v45, v46);
    float16x8_t v50 = (float16x8_t)vzip2q_s8(v45, v46);
    int8x16_t v51 = vandq_s8(v44, v4);
    int8x16_t v52 = (int8x16_t)vshrq_n_u8((uint8x16_t)v44, 4uLL);
    int8x16_t v53 = vqtbl1q_s8(v5, v51);
    int8x16_t v54 = vqtbl1q_s8(v6, v51);
    v44.i32[0] = *a2++;
    v51.i32[0] = v44.i32[0];
    int8x16_t v55 = vqtbl1q_s8(v5, v52);
    int8x16_t v56 = vqtbl1q_s8(v6, v52);
    float16x8_t v8 = vmlaq_lane_f16(vmlaq_n_f16(v8, v25, *(short float *)v44.i16), v27, *(float16x4_t *)v51.i8, 1);
    float16x8_t v9 = vmlaq_lane_f16(vmlaq_n_f16(v9, v26, *(short float *)v44.i16), v28, *(float16x4_t *)v51.i8, 1);
    float16x8_t v10 = vmlaq_lane_f16(vmlaq_n_f16(v10, v36, *(short float *)v44.i16), v38, *(float16x4_t *)v51.i8, 1);
    float16x8_t v11 = vmlaq_lane_f16(vmlaq_n_f16(v11, v37, *(short float *)v44.i16), v39, *(float16x4_t *)v51.i8, 1);
    float16x8_t v12 = vmlaq_lane_f16(vmlaq_n_f16(v12, v47, *(short float *)v44.i16), v49, *(float16x4_t *)v51.i8, 1);
    float16x8_t v13 = vmlaq_lane_f16(vmlaq_n_f16(v13, v48, *(short float *)v44.i16), v50, *(float16x4_t *)v51.i8, 1);
    float16x8_t v14 = vmlaq_lane_f16(vmlaq_n_f16(v14, (float16x8_t)vzip1q_s8(v53, v54), *(short float *)v44.i16), (float16x8_t)vzip1q_s8(v55, v56), *(float16x4_t *)v51.i8, 1);
    float16x8_t v15 = vmlaq_lane_f16(vmlaq_n_f16(v15, (float16x8_t)vzip2q_s8(v53, v54), *(short float *)v44.i16), (float16x8_t)vzip2q_s8(v55, v56), *(float16x4_t *)v51.i8, 1);
  }
  while (v7-- > 1);
  *uint64_t result = v8;
  result[1] = v9;
  result[2] = v10;
  result[3] = v11;
  result[4] = v12;
  result[5] = v13;
  result[6] = v14;
  result[7] = v15;
  return result;
}

float16x8_t *_ZN12accelerateml53AccelerateMLFullyConnected_InOutBiasFP16_WeightsUINT4ILm48ELm48ELm64ELm64EL39AccelerateMLFullyConnectedWeightsLayout2ELm1ELb0EXtl32AccelerateMLActivationDescriptorEEEEiPDF16_PKDF16_PKhS5_(float16x8_t *result, uint64_t a2, int8x16_t *a3)
{
  unint64_t v3 = 0;
  int8x16_t v4 = a3 + 2;
  float16x8_t v5 = 0uLL;
  int8x16_t v6 = *a3;
  int8x16_t v7 = a3[1];
  v8.i64[0] = 0xF0F0F0F0F0F0F0FLL;
  v8.i64[1] = 0xF0F0F0F0F0F0F0FLL;
  float16x8_t v9 = 0uLL;
  float16x8_t v10 = 0uLL;
  float16x8_t v11 = 0uLL;
  float16x8_t v12 = 0uLL;
  float16x8_t v13 = 0uLL;
  do
  {
    float16x8_t v14 = (const __int16 *)(a2 + 2 * v3);
    float16x8_t v15 = (float16x8_t)vld1q_dup_s16(v14++);
    int8x16_t v16 = v4[1];
    int8x16_t v17 = vandq_s8(*v4, v8);
    int8x16_t v18 = (int8x16_t)vshrq_n_u8(*(uint8x16_t *)v4, 4uLL);
    int8x16_t v19 = vqtbl1q_s8(v6, v17);
    int8x16_t v20 = vqtbl1q_s8(v7, v17);
    float16x8_t v21 = (float16x8_t)vzip1q_s8(v19, v20);
    float16x8_t v22 = (float16x8_t)vzip2q_s8(v19, v20);
    int8x16_t v23 = vqtbl1q_s8(v6, v18);
    int8x16_t v24 = vqtbl1q_s8(v7, v18);
    float16x8_t v25 = (float16x8_t)vzip1q_s8(v23, v24);
    float16x8_t v26 = (float16x8_t)vzip2q_s8(v23, v24);
    int8x16_t v27 = vandq_s8(v16, v8);
    int8x16_t v28 = (int8x16_t)vshrq_n_u8((uint8x16_t)v16, 4uLL);
    int8x16_t v29 = vqtbl1q_s8(v6, v27);
    int8x16_t v30 = vqtbl1q_s8(v7, v27);
    float16x8_t v31 = (float16x8_t)vzip1q_s8(v29, v30);
    float16x8_t v32 = (float16x8_t)vzip2q_s8(v29, v30);
    int8x16_t v33 = vqtbl1q_s8(v6, v28);
    int8x16_t v34 = vqtbl1q_s8(v7, v28);
    float16x8_t v35 = (float16x8_t)vzip1q_s8(v33, v34);
    float16x8_t v36 = (float16x8_t)vzip2q_s8(v33, v34);
    int8x16_t v37 = v4[2];
    int8x16_t v38 = vandq_s8(v37, v8);
    int8x16_t v39 = (int8x16_t)vshrq_n_u8((uint8x16_t)v37, 4uLL);
    int8x16_t v40 = vqtbl1q_s8(v6, v38);
    int8x16_t v41 = vqtbl1q_s8(v7, v38);
    float16x8_t v42 = (float16x8_t)vzip1q_s8(v40, v41);
    float16x8_t v43 = (float16x8_t)vzip2q_s8(v40, v41);
    int8x16_t v44 = vqtbl1q_s8(v6, v39);
    int8x16_t v45 = vqtbl1q_s8(v7, v39);
    float16x8_t v13 = vmlaq_n_f16(vmlaq_f16(v13, v21, v15), v25, *(short float *)v14);
    float16x8_t v12 = vmlaq_n_f16(vmlaq_f16(v12, v22, v15), v26, *(short float *)v14);
    float16x8_t v11 = vmlaq_n_f16(vmlaq_f16(v11, v31, v15), v35, *(short float *)v14);
    float16x8_t v10 = vmlaq_n_f16(vmlaq_f16(v10, v32, v15), v36, *(short float *)v14);
    float16x8_t v9 = vmlaq_n_f16(vmlaq_f16(v9, v42, v15), (float16x8_t)vzip1q_s8(v44, v45), *(short float *)v14);
    float16x8_t v5 = vmlaq_n_f16(vmlaq_f16(v5, v43, v15), (float16x8_t)vzip2q_s8(v44, v45), *(short float *)v14);
    v3 += 2;
    v4 += 3;
  }
  while (v3 < 0x3F);
  *uint64_t result = v13;
  result[1] = v12;
  result[2] = v11;
  result[3] = v10;
  result[4] = v9;
  result[5] = v5;
  return result;
}

uint64_t Nfp16AMPalettizedLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  if (*a5 != ((2 * ((*(_DWORD *)a2 * *a3) & 0x3FFFFFFF) + 16 * ((*a3 & 3) != 0) + 15) & 0xFFFFFFF0) + 32) {
    Error::chuck((Error *)"Nfp16AMPalettizedLayer::initialize() - Incorrect data size", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!*a3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  *(void *)(this + 24) = a4;
  return this;
}

void Nfp16AMPalettizedLayer::~Nfp16AMPalettizedLayer(Nfp16AMPalettizedLayer *this)
{
}

uint64_t Nfp16SigmoidOnlyLayer::compute(Nfp16SigmoidOnlyLayer *this, float16x8_t *a2, float16x8_t *a3, void *a4)
{
  if (!*((void *)this + 2)) {
    Error::chuck((Error *)"Nfp16SigmoidOnlyLayer::compute() - Layer uninitialized", a2->i8, a3, a4);
  }
  uint64_t v4 = (2 * *((_DWORD *)this + 3));

  return AccelerateMLSigmoid_FP16(a3, a2, v4);
}

uint64_t Nfp16SigmoidOnlyLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != *a3) {
    Error::chuck((Error *)"Nfp16SigmoidOnlyLayer::initialize() - input and output size must be the same", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void Nfp16SigmoidOnlyLayer::~Nfp16SigmoidOnlyLayer(Nfp16SigmoidOnlyLayer *this)
{
}

void Nfp16PalettizedLayer::compute(Nfp16PalettizedLayer *this, const float *a2, float *a3, void *a4)
{
  uint64_t v4 = (unsigned __int8 *)*((void *)this + 3);
  if (!v4) {
    Error::chuck((Error *)"Nfp16PalettizedLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  uint64_t v5 = (2 * *((_DWORD *)this + 3));
  if (v5)
  {
    unint64_t v6 = (2 * *((_DWORD *)this + 2));
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *((void *)this + 2);
      do
      {
        unint64_t v9 = 0;
        _S0 = 0.0;
        float16x8_t v11 = v4;
        do
        {
          unsigned int v12 = *v11++;
          _H1 = (short float)(*(short float *)(v8 + 2 * (v12 >> 4)) * *((short float *)&a2[v9 / 2] + 1))
              + (short float)(*(short float *)(v8 + 2 * (v12 & 0xF)) * *(short float *)&a2[v9 / 2]);
          __asm { FCVT            S1, H1 }
          _S0 = _S0 + _S1;
          v9 += 2;
        }
        while (v9 < v6);
        v4 += ((v6 - 1) >> 1) + 1;
        __asm { FCVT            H0, S0 }
        *((_WORD *)a3 + v7++) = _H0;
      }
      while (v7 != v5);
    }
    else
    {
      bzero(a3, 2 * v5);
    }
  }
}

uint64_t Nfp16PalettizedLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  if (*a5 != ((2 * ((*(_DWORD *)a2 * *a3) & 0x3FFFFFFF) + 15) & 0xFFFFFFF0) + 32) {
    Error::chuck((Error *)"Nfp16PalettizedLayer::initialize() - Incorrect data size", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!*a3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  *(void *)(this + 24) = a4 + 32;
  return this;
}

void Nfp16PalettizedLayer::~Nfp16PalettizedLayer(Nfp16PalettizedLayer *this)
{
}

unsigned __int16 Nfp16MatrixLayer::compute@<H0>(Nfp16MatrixLayer *this@<X0>, const float *a2@<X1>, float *a3@<X2>, void *a4@<X3>, __n128 a5@<Q0>)
{
  v57[1] = *MEMORY[0x263EF8340];
  int v5 = (float16x8_t *)*((void *)this + 2);
  if (!v5) {
    Error::chuck((Error *)"Nfp16MatrixLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  int v7 = *((_DWORD *)this + 3);
  int v8 = (-2 * *((_DWORD *)this + 2)) & 6;
  uint64_t v9 = (v8 + 2 * *((_DWORD *)this + 2));
  _Q0.i16[0] = MEMORY[0x270FA5388](a5).n128_u16[0];
  float16x8_t v14 = (char *)v57 - v12;
  if (v8)
  {
    size_t v15 = 2 * v11;
    memcpy((char *)v57 - v12, v10, v15);
    bzero(&v14[v15], (2 * v8));
    float16x8_t v10 = v14;
  }
  uint64_t v16 = (2 * v7);
  unint64_t v17 = v7 & 0xFFFFFFFC;
  if ((v7 & 0xFFFFFFFC) != 0)
  {
    uint64_t v18 = (4 * v9);
    unint64_t v19 = 0;
    if (v9)
    {
      int8x16_t v20 = &v5->i8[2 * (3 * v9)];
      uint64_t v21 = 2 * v18;
      float16x8_t v22 = &v5->i8[2 * (2 * v9)];
      int8x16_t v23 = &v5->i8[2 * v9];
      do
      {
        unint64_t v24 = 0;
        unsigned int v25 = 0;
        float16x8_t v26 = 0uLL;
        float16x8_t v27 = 0uLL;
        float16x8_t v28 = 0uLL;
        float16x8_t v29 = 0uLL;
        do
        {
          float16x8_t v30 = *(float16x8_t *)&v10[v24];
          float16x8_t v26 = vmlaq_f16(v26, v5[v24 / 0x10], v30);
          float16x8_t v27 = vmlaq_f16(v27, *(float16x8_t *)&v23[v24], v30);
          float16x8_t v28 = vmlaq_f16(v28, *(float16x8_t *)&v22[v24], v30);
          float16x8_t v29 = vmlaq_f16(v29, *(float16x8_t *)&v20[v24], v30);
          v25 += 8;
          v24 += 16;
        }
        while (v25 < v9);
        _Q0 = vpaddq_f16(vpaddq_f16(v26, v27), vpaddq_f16(v28, v29));
        _Q0.i64[0] = vpaddq_f16(_Q0, _Q0).u64[0];
        *(void *)((char *)a3 + 2 * v19) = _Q0.i64[0];
        int v5 = (float16x8_t *)((char *)v5 + v21);
        v19 += 4;
        v20 += v21;
        v22 += v21;
        v23 += v21;
      }
      while (v19 < v17);
    }
    else
    {
      float16x8_t v31 = vpaddq_f16((float16x8_t)0, (float16x8_t)0);
      _Q0 = vpaddq_f16(v31, v31);
      _Q0.i64[0] = vpaddq_f16(_Q0, _Q0).u64[0];
      uint64_t v32 = 2 * v18;
      int8x16_t v33 = a3;
      do
      {
        *(void *)int8x16_t v33 = _Q0.i64[0];
        v33 += 2;
        v19 += 4;
        int v5 = (float16x8_t *)((char *)v5 + v32);
      }
      while (v19 < v17);
    }
  }
  else
  {
    LODWORD(v19) = 0;
  }
  if (v19 < v16)
  {
    unint64_t v19 = v19;
    do
    {
      if (v9)
      {
        uint64_t v40 = 0;
        unsigned int v41 = 0;
        _Q0 = 0uLL;
        do
        {
          _Q0 = vmlaq_f16(_Q0, v5[v40], *(float16x8_t *)&v10[v40 * 16]);
          v41 += 8;
          ++v40;
        }
        while (v41 < v9);
      }
      else
      {
        _Q0 = 0uLL;
      }
      int v5 = (float16x8_t *)((char *)v5 + 2 * v9);
      _Q0.i64[0] = vpaddq_f16(_Q0, _Q0).u64[0];
      float v34 = vaddv_f32((float32x2_t)*(_OWORD *)&vcvtq_f32_f16(*(float16x4_t *)_Q0.i8));
      _H2 = _Q0.u16[2];
      __asm { FCVT            S2, H2 }
      _Q0.i16[0] = _Q0.i16[3];
      __asm { FCVT            S0, H0 }
      *(float *)_Q0.i32 = (float)(v34 + _S2) + *(float *)_Q0.i32;
      __asm { FCVT            H0, S0 }
      *((_WORD *)a3 + v19++) = _Q0.i16[0];
    }
    while (v19 != v16);
  }
  LODWORD(v42) = v7 & 0xFFFFFFF8;
  if ((v7 & 0xFFFFFFF8) != 0)
  {
    unsigned int v43 = 0;
    int8x16_t v44 = (float16x8_t *)a3;
    do
    {
      float16x8_t v45 = *v5++;
      _Q0 = vaddq_f16(*v44, v45);
      *v44++ = _Q0;
      v43 += 8;
    }
    while (v43 < v42);
    LODWORD(v42) = ((v42 - 1) & 0xFFFFFFF8) + 8;
  }
  if (v42 < v16)
  {
    unint64_t v42 = v42;
    unint64_t v46 = v16 - v42;
    if (v46 <= 0xF) {
      goto LABEL_37;
    }
    if ((char *)a3 + 2 * v42 < (char *)v5->i32 + 2 * v16 - 2 * v42
      && v5 < (float16x8_t *)((char *)a3 + 2 * v16))
    {
      goto LABEL_37;
    }
    unint64_t v48 = v46 & 0xFFFFFFFFFFFFFFF0;
    float16x8_t v49 = (float16x8_t *)((char *)a3 + 2 * v42 + 16);
    float16x8_t v50 = v5 + 1;
    unint64_t v51 = v46 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      _Q0 = vaddq_f16(v50[-1], v49[-1]);
      float16x8_t v52 = vaddq_f16(*v50, *v49);
      v49[-1] = _Q0;
      *float16x8_t v49 = v52;
      v49 += 2;
      v50 += 2;
      v51 -= 16;
    }
    while (v51);
    if (v46 != v48)
    {
      unint64_t v42 = v48 + v42;
      int v5 = (float16x8_t *)((char *)v5 + 2 * (v46 & 0xFFFFFFFFFFFFFFF0));
LABEL_37:
      uint64_t v53 = v16 - v42;
      int8x16_t v54 = (short float *)a3 + v42;
      do
      {
        short float v55 = *(short float *)v5->i16;
        int v5 = (float16x8_t *)((char *)v5 + 2);
        *(short float *)_Q0.i16 = v55 + *v54;
        *v54++ = *(short float *)_Q0.i16;
        --v53;
      }
      while (v53);
    }
  }
  return _Q0.i16[0];
}

uint64_t Nfp16MatrixLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  int v6 = *a3;
  if (((2 * v6 + 7) & 0xFFFFFFF8) + ((2 * *(_DWORD *)a2 + 7) & 0xFFFFFFF8) * 2 * v6 != *a5 >> 1) {
    Error::chuck((Error *)"Nfp16MatrixLayer::initialize() - Incorrect data size", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!v6) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void Nfp16MatrixLayer::~Nfp16MatrixLayer(Nfp16MatrixLayer *this)
{
}

__int16 Nfp16OffsetLayer::compute@<H0>(Nfp16OffsetLayer *this@<X0>, const float *a2@<X1>, float *a3@<X2>, void *a4@<X3>)
{
  uint64_t v4 = *((void *)this + 2);
  if (!v4) {
    Error::chuck((Error *)"Nfp16OffsetLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  unint64_t v5 = *((unsigned int *)this + 2);
  uint64_t v6 = (2 * v5);
  if (v6 >= 8)
  {
    unsigned int v7 = v6 >> 3;
    int v8 = a3;
    uint64_t v9 = a2;
    float16x8_t v10 = (float16x8_t *)*((void *)this + 2);
    do
    {
      float16x8_t v11 = *v10++;
      float16x8_t v12 = v11;
      float16x8_t v13 = *(float16x8_t *)v9;
      v9 += 4;
      float16x8_t v14 = vaddq_f16(v12, v13);
      *(float16x8_t *)int v8 = v14;
      v8 += 4;
      --v7;
    }
    while (v7);
  }
  uint64_t v15 = v6 & 0xFFFFFFF8;
  if (v15 < v6)
  {
    uint64_t v16 = v6 - v15;
    if ((unint64_t)(v6 - v15) <= 0xF) {
      goto LABEL_13;
    }
    uint64_t v17 = 4 * ((v5 >> 2) & 0x1FFFFFFF);
    if ((unint64_t)((char *)a3 - (char *)a2) < 0x20 || (unint64_t)a3 - v4 < 0x20) {
      goto LABEL_13;
    }
    unint64_t v18 = v16 & 0xFFFFFFFFFFFFFFF0;
    uint64_t v19 = v17 * 4 + 16;
    int8x16_t v20 = (float16x8_t *)&a2[v17 + 4];
    uint64_t v21 = (float16x8_t *)((char *)a3 + v19);
    float16x8_t v22 = (float16x8_t *)(v4 + v19);
    unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      float16x8_t v14 = vaddq_f16(v20[-1], v22[-1]);
      float16x8_t v24 = vaddq_f16(*v20, *v22);
      v21[-1] = v14;
      *uint64_t v21 = v24;
      v20 += 2;
      v21 += 2;
      v22 += 2;
      v23 -= 16;
    }
    while (v23);
    if (v16 != v18)
    {
      v15 += v18;
LABEL_13:
      uint64_t v25 = v6 - v15;
      uint64_t v26 = 2 * v15;
      float16x8_t v27 = (_WORD *)a3 + v15;
      float16x8_t v28 = (short float *)(v4 + v26);
      float16x8_t v29 = (short float *)((char *)a2 + v26);
      do
      {
        short float v30 = *v29++;
        short float v31 = v30;
        short float v32 = *v28++;
        *(short float *)v14.i16 = v31 + v32;
        *v27++ = v14.i16[0];
        --v25;
      }
      while (v25);
    }
  }
  return v14.i16[0];
}

uint64_t Nfp16OffsetLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5 = *a5 >> 2;
  if (v5 != *(_DWORD *)a2) {
    Error::chuck((Error *)"Nfp16OffsetLayer::initialize() - Incorrect data size", a2, a3, a4);
  }
  if (v5 != *a3) {
    Error::chuck((Error *)"Nfp16OffsetLayer::initialize() - Input and output not same", a2);
  }
  if (*a5 <= 3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void Nfp16OffsetLayer::~Nfp16OffsetLayer(Nfp16OffsetLayer *this)
{
}

__int16 Nfp16ScaleLayer::compute@<H0>(Nfp16ScaleLayer *this@<X0>, const float *a2@<X1>, float *a3@<X2>, void *a4@<X3>)
{
  uint64_t v4 = *((void *)this + 2);
  if (!v4) {
    Error::chuck((Error *)"Nfp16ScaleLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  unint64_t v5 = *((unsigned int *)this + 2);
  uint64_t v6 = (2 * v5);
  if (v6 >= 8)
  {
    unsigned int v7 = v6 >> 3;
    int v8 = a3;
    uint64_t v9 = a2;
    float16x8_t v10 = (float16x8_t *)*((void *)this + 2);
    do
    {
      float16x8_t v11 = *v10++;
      float16x8_t v12 = v11;
      float16x8_t v13 = *(float16x8_t *)v9;
      v9 += 4;
      float16x8_t v14 = vmulq_f16(v12, v13);
      *(float16x8_t *)int v8 = v14;
      v8 += 4;
      --v7;
    }
    while (v7);
  }
  uint64_t v15 = v6 & 0xFFFFFFF8;
  if (v15 < v6)
  {
    uint64_t v16 = v6 - v15;
    if ((unint64_t)(v6 - v15) <= 0xF) {
      goto LABEL_13;
    }
    uint64_t v17 = 4 * ((v5 >> 2) & 0x1FFFFFFF);
    if ((unint64_t)((char *)a3 - (char *)a2) < 0x20 || (unint64_t)a3 - v4 < 0x20) {
      goto LABEL_13;
    }
    unint64_t v18 = v16 & 0xFFFFFFFFFFFFFFF0;
    uint64_t v19 = v17 * 4 + 16;
    int8x16_t v20 = (float16x8_t *)&a2[v17 + 4];
    uint64_t v21 = (float16x8_t *)((char *)a3 + v19);
    float16x8_t v22 = (float16x8_t *)(v4 + v19);
    unint64_t v23 = v16 & 0xFFFFFFFFFFFFFFF0;
    do
    {
      float16x8_t v14 = vmulq_f16(v20[-1], v22[-1]);
      float16x8_t v24 = vmulq_f16(*v20, *v22);
      v21[-1] = v14;
      *uint64_t v21 = v24;
      v20 += 2;
      v21 += 2;
      v22 += 2;
      v23 -= 16;
    }
    while (v23);
    if (v16 != v18)
    {
      v15 += v18;
LABEL_13:
      uint64_t v25 = v6 - v15;
      uint64_t v26 = 2 * v15;
      float16x8_t v27 = (_WORD *)a3 + v15;
      float16x8_t v28 = (short float *)(v4 + v26);
      float16x8_t v29 = (short float *)((char *)a2 + v26);
      do
      {
        short float v30 = *v29++;
        short float v31 = v30;
        short float v32 = *v28++;
        *(short float *)v14.i16 = v31 * v32;
        *v27++ = v14.i16[0];
        --v25;
      }
      while (v25);
    }
  }
  return v14.i16[0];
}

uint64_t Nfp16ScaleLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5 = *a5 >> 2;
  if (v5 != *(_DWORD *)a2) {
    Error::chuck((Error *)"Nfp16ScaleLayer::initialize() - Incorrect data size", a2, a3, a4);
  }
  if (v5 != *a3) {
    Error::chuck((Error *)"Nfp16ScaleLayer::initialize() - Input and output not same", a2);
  }
  if (*a5 <= 3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void Nfp16ScaleLayer::~Nfp16ScaleLayer(Nfp16ScaleLayer *this)
{
}

float32_t Nfp16tofp32Layer::compute(Nfp16tofp32Layer *this, float16x4_t *a2, float *a3, void *a4)
{
  if (!*((void *)this + 2)) {
    Error::chuck((Error *)"Nfp16tofp32Layer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  uint64_t v4 = *((unsigned int *)this + 3);
  if (v4)
  {
    if (v4 <= 0xF)
    {
      uint64_t v5 = 0;
LABEL_8:
      uint64_t v14 = v4 - v5;
      uint64_t v15 = &a3[v5];
      uint64_t v16 = (__int16 *)a2 + v5;
      do
      {
        __int16 v17 = *v16++;
        _H0 = v17;
        __asm { FCVT            S0, H0 }
        *v15++ = _Q0.f32[0];
        --v14;
      }
      while (v14);
      return _Q0.f32[0];
    }
    uint64_t v5 = v4 & 0xFFFFFFF0;
    uint64_t v6 = a3 + 8;
    unsigned int v7 = a2 + 2;
    uint64_t v8 = v5;
    do
    {
      float16x8_t v9 = *(float16x8_t *)v7[-2].i8;
      float32x4_t v10 = vcvtq_f32_f16(*(float16x4_t *)v9.i8);
      _Q0 = vcvt_hight_f32_f16(v9);
      float32x4_t v12 = vcvtq_f32_f16(*v7);
      float32x4_t v13 = vcvt_hight_f32_f16(*(float16x8_t *)v7->i8);
      *((float32x4_t *)v6 - 2) = v10;
      *((float32x4_t *)v6 - 1) = _Q0;
      *(float32x4_t *)uint64_t v6 = v12;
      *((float32x4_t *)v6 + 1) = v13;
      v6 += 16;
      v7 += 4;
      v8 -= 16;
    }
    while (v8);
    if (v5 != v4) {
      goto LABEL_8;
    }
  }
  return _Q0.f32[0];
}

uint64_t Nfp16tofp32Layer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5 = *a3 + 1;
  if (v5 >> 1 != *(_DWORD *)a2) {
    Error::chuck((Error *)"Nfp16tofp32Layer::initialize() - input and output size must be in ratio 1:2", a2);
  }
  if (v5 <= 1) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5 >> 1;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void Nfp16tofp32Layer::~Nfp16tofp32Layer(Nfp16tofp32Layer *this)
{
}

__int16 Nfp32tofp16Layer::compute@<H0>(Nfp32tofp16Layer *this@<X0>, const float *a2@<X1>, float *a3@<X2>, void *a4@<X3>)
{
  if (!*((void *)this + 2)) {
    Error::chuck((Error *)"Nfp32tofp16Layer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  uint64_t v4 = *((unsigned int *)this + 2);
  a3[*((_DWORD *)this + 3) - 1] = 0.0;
  if (v4)
  {
    if (v4 <= 0xF)
    {
      uint64_t v5 = 0;
LABEL_8:
      uint64_t v15 = v4 - v5;
      uint64_t v16 = (_WORD *)a3 + v5;
      __int16 v17 = &a2[v5];
      do
      {
        __int32 v18 = *(_DWORD *)v17++;
        _Q0.i32[0] = v18;
        __asm { FCVT            H0, S0 }
        *v16++ = _Q0.i16[0];
        --v15;
      }
      while (v15);
      return _Q0.i16[0];
    }
    uint64_t v5 = v4 & 0xFFFFFFF0;
    uint64_t v6 = a3 + 4;
    unsigned int v7 = a2 + 8;
    uint64_t v8 = v5;
    do
    {
      float32x4_t v10 = *(float32x4_t *)(v7 - 8);
      float32x4_t v9 = *(float32x4_t *)(v7 - 4);
      float32x4_t v12 = *(float32x4_t *)v7;
      float32x4_t v11 = *(float32x4_t *)(v7 + 4);
      v7 += 16;
      float16x8_t v13 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v10), v9);
      _Q0 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v12), v11);
      *((float16x8_t *)v6 - 1) = v13;
      *(float16x8_t *)uint64_t v6 = _Q0;
      v6 += 8;
      v8 -= 16;
    }
    while (v8);
    if (v5 != v4) {
      goto LABEL_8;
    }
  }
  return _Q0.i16[0];
}

uint64_t Nfp32tofp16Layer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  if (*a3 != (*(_DWORD *)a2 + 1) >> 1) {
    Error::chuck((Error *)"Nfp32tofp16Layer::initialize() - input and output size must be in ratio 2:1", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if ((v5 + 1) <= 1) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void Nfp32tofp16Layer::~Nfp32tofp16Layer(Nfp32tofp16Layer *this)
{
}

uint64_t NSigned8BitMatrixLayer::compute(void **this, const float *a2, float *a3, void *a4, __n128 a5)
{
  v61[1] = *MEMORY[0x263EF8340];
  __n128 v11 = MEMORY[0x270FA5388](a5);
  float16x8_t v13 = (char *)v61 - v12;
  if (v9 >= 0x10)
  {
    unint64_t v14 = v9 >> 4;
    uint64_t v15 = v7 + 2;
    uint64_t v16 = (int8x8_t *)(v13 + 8);
    __n128 v11 = (__n128)vdupq_n_s32(0x437F0000u);
    do
    {
      float32x4_t v17 = vmulq_f32(v15[-2], (float32x4_t)v11);
      float32x4_t v18 = vmulq_f32(v15[-1], (float32x4_t)v11);
      float32x4_t v19 = *v15;
      float32x4_t v20 = v15[1];
      v15 += 4;
      v16[-1] = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(v17), (int16x8_t)vcvtnq_s32_f32(v18)));
      *uint64_t v16 = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(vmulq_f32(v19, (float32x4_t)v11)), (int16x8_t)vcvtnq_s32_f32(vmulq_f32(v20, (float32x4_t)v11))));
      v16 += 2;
      --v14;
    }
    while (v14);
  }
  uint64_t v21 = v9 & 0xFFFFFFF0;
  if ((v9 & 0xFFFFFFF0) < v9)
  {
    uint64_t v22 = v9 - v21;
    unint64_t v23 = &v13[v21];
    float16x8_t v24 = (float *)((char *)v7->f32 + ((4 * v9) & 0x3FFFFFFC0));
    do
    {
      float v25 = *v24++;
      v11.n128_f32[0] = rintf(v25 * 255.0);
      *v23++ = (uint64_t)v11.n128_f32[0];
      --v22;
    }
    while (v22);
  }
  if (v9)
  {
    if (v9 < 8)
    {
      uint64_t v26 = 0;
      goto LABEL_19;
    }
    if (v9 >= 0x20)
    {
      uint64_t v26 = v9 & 0xFFFFFFE0;
      float16x8_t v27 = (int8x16_t *)(v13 + 16);
      v11.n128_u64[0] = 0x8080808080808080;
      v11.n128_u64[1] = 0x8080808080808080;
      uint64_t v28 = v26;
      do
      {
        int8x16_t v29 = veorq_s8(*v27, (int8x16_t)v11);
        v27[-1] = veorq_s8(v27[-1], (int8x16_t)v11);
        *float16x8_t v27 = v29;
        v27 += 2;
        v28 -= 32;
      }
      while (v28);
      if (v26 == v9) {
        goto LABEL_21;
      }
      if ((v9 & 0x18) == 0)
      {
LABEL_19:
        uint64_t v33 = v9 - v26;
        float v34 = &v13[v26];
        do
        {
          *v34++ ^= 0x80u;
          --v33;
        }
        while (v33);
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    uint64_t v30 = v26;
    uint64_t v26 = v9 & 0xFFFFFFF8;
    uint64_t v31 = v30 - v26;
    short float v32 = (int8x8_t *)&v13[v30];
    v11.n128_u64[0] = 0x8080808080808080;
    do
    {
      *short float v32 = veor_s8(*v32, (int8x8_t)0x8080808080808080);
      ++v32;
      v31 += 8;
    }
    while (v31);
    if (v26 != v9) {
      goto LABEL_19;
    }
  }
LABEL_21:
  if (v9 < v8) {
    bzero(&v13[v9], (v10 - 1) + 1);
  }
  MEMORY[0x270FA5388](v11);
  float16x8_t v36 = (float32x4_t *)((char *)v61 - ((v35 + 15) & 0x7FFFFFFF0));
  uint64_t result = BNNSFilterApply(this[5], v13, v36);
  if (result == -1) {
    Error::chuck((Error *)"NSigned8BitMatrixLayer::compute() - BNNSFilterApply failed", v38);
  }
  uint64_t v39 = *((unsigned int *)this + 3);
  if (!v39) {
    return result;
  }
  uint64_t v40 = (int32x4_t *)this[3];
  if (v39 > 7)
  {
    uint64_t v41 = v39 & 0xFFFFFFF8;
    unint64_t v42 = v36 + 1;
    unsigned int v43 = v40 + 1;
    uint64_t v44 = v41;
    do
    {
      float32x4_t v45 = vaddq_f32(*v42, vcvtq_f32_s32(*v43));
      v42[-1] = vaddq_f32(v42[-1], vcvtq_f32_s32(v43[-1]));
      *unint64_t v42 = v45;
      v42 += 2;
      v43 += 2;
      v44 -= 8;
    }
    while (v44);
    if (v41 == v39) {
      goto LABEL_33;
    }
    uint64_t v40 = (int32x4_t *)((char *)v40 + 4 * (v39 & 0xFFFFFFF8));
  }
  else
  {
    uint64_t v41 = 0;
  }
  uint64_t v46 = v39 - v41;
  float16x8_t v47 = &v36->f32[v41];
  do
  {
    int v48 = v40->i32[0];
    uint64_t v40 = (int32x4_t *)((char *)v40 + 4);
    *float16x8_t v47 = *v47 + (float)v48;
    ++v47;
    --v46;
  }
  while (v46);
LABEL_33:
  float16x8_t v49 = (const float *)this + 9;
  if (v39 <= 7 || this + 5 > (void **)a3 && v49 < &a3[v39])
  {
    uint64_t v50 = 0;
LABEL_37:
    uint64_t v51 = v39 - v50;
    uint64_t v52 = v50;
    uint64_t v53 = &a3[v50];
    int8x16_t v54 = &v36->f32[v52];
    do
    {
      float v55 = *v54++;
      *v53++ = v55 * *v49;
      --v51;
    }
    while (v51);
    return result;
  }
  uint64_t v50 = v39 & 0xFFFFFFF8;
  float32x4_t v56 = vld1q_dup_f32(v49);
  int32x4_t v57 = a3 + 4;
  int32x4_t v58 = v36 + 1;
  uint64_t v59 = v50;
  do
  {
    float32x4_t v60 = vmulq_f32(*v58, v56);
    *((float32x4_t *)v57 - 1) = vmulq_f32(v58[-1], v56);
    *(float32x4_t *)int32x4_t v57 = v60;
    v57 += 8;
    v58 += 2;
    v59 -= 8;
  }
  while (v59);
  if (v50 != v39) {
    goto LABEL_37;
  }
  return result;
}

void *NSigned8BitMatrixLayer::initialize(NSigned8BitMatrixLayer *this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  N8BitMatrixLayer::initialize(this, a2, a3, a4, a5);
  size_t v6 = *((unsigned int *)this + 3);
  size_t v7 = (*((_DWORD *)this + 8) + *((_DWORD *)this + 2));
  unsigned int v8 = (void *)*((void *)this + 2);
  *(void *)&layer_params.i_desc.flags = 0x1000000000000;
  layer_params.i_desc.size[0] = v7;
  memset(&layer_params.i_desc.size[1], 0, 128);
  *(void *)(&layer_params.i_desc.data_type + 1) = 0;
  layer_params.i_desc.data_type = BNNSDataTypeInt8;
  HIDWORD(layer_params.i_desc.table_data) = 0;
  *(void *)&layer_params.i_desc.table_data_type = 0x3F80000000020008;
  *(void *)&layer_params.i_desc.data_bias = 0;
  *(void *)&layer_params.w_desc.flags = 0x2000000000000;
  layer_params.w_desc.size[0] = v7;
  layer_params.w_desc.size[1] = v6;
  memset(&layer_params.w_desc.size[2], 0, 112);
  layer_params.w_desc.data = v8;
  *(void *)&layer_params.w_desc.data_type = 131080;
  layer_params.w_desc.table_data = 0;
  *(void *)&layer_params.w_desc.table_data_type = 0x3F80000000020008;
  *(void *)&layer_params.w_desc.data_bias = 0;
  *(void *)&layer_params.o_desc.flags = 0x1000000000000;
  layer_params.o_desc.size[0] = v6;
  memset(&layer_params.o_desc.size[1], 0, 128);
  layer_params.o_desc.data_type = BNNSDataTypeFloat32;
  *(void *)(&layer_params.o_desc.data_type + 1) = 0;
  HIDWORD(layer_params.o_desc.table_data) = 0;
  *(void *)&layer_params.o_desc.table_data_type = 0x3F80000000010020;
  memset(&layer_params.o_desc.data_bias, 0, 232);
  *(_OWORD *)&v11.alloc_memory = 0u;
  *(void *)&v11.flags = 1;
  v11.n_threads = 1;
  uint64_t result = BNNSFilterCreateLayerFullyConnected(&layer_params, &v11);
  *((void *)this + 5) = result;
  if (!result) {
    Error::chuck((Error *)"NSigned8BitMatrixLayer::compute() - BNNSFilter has not been successfully created at initialization", v10);
  }
  return result;
}

float N8BitMatrixLayer::initialize(N8BitMatrixLayer *this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  if ((a4 & 0xF) != 0) {
    Error::chuck((Error *)"N8BitMatrixLayer::initialize() - Unaligned data block", a2, a3);
  }
  int v5 = *(_DWORD *)a2;
  unsigned int v6 = (*(_DWORD *)a2 + 15) & 0xFFFFFFF0;
  unsigned int v7 = v6 * *a3;
  if (*a5 != ((((4 * *a3 + 15) & 0xFFFFFFF0) + v7) | 4)) {
    Error::chuck((Error *)"N8BitMatrixLayer::initialize() - Incorrect data size", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!*a3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *((_DWORD *)this + 2) = v5;
  *((_DWORD *)this + 3) = *a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = &a4[v7];
  *((_DWORD *)this + 8) = v6 - *(_DWORD *)a2;
  float result = *(float *)&a4[*a5 - 4] * 0.00392156863;
  *((float *)this + 9) = result;
  return result;
}

void NSigned8BitMatrixLayer::~NSigned8BitMatrixLayer(NSigned8BitMatrixLayer *this)
{
  *(void *)this = &unk_26C99BAF0;
  uint64_t v1 = (void *)*((void *)this + 5);
  if (v1) {
    BNNSFilterDestroy(v1);
  }

  JUMPOUT(0x21D46B240);
}

{
  void *v1;

  *(void *)this = &unk_26C99BAF0;
  uint64_t v1 = (void *)*((void *)this + 5);
  if (v1) {
    BNNSFilterDestroy(v1);
  }
}

void N8BitLSTMLayer::MatrixMultiply8Bit(N8BitLSTMLayer *this, const unsigned int *a2, const unsigned int *a3, const signed __int8 *a4, float *a5, float32x4_t *a6, const float *a7, const BOOL *a8, __n128 a9)
{
  v104[1] = *MEMORY[0x263EF8340];
  if (*a3)
  {
    a9.n128_u64[0] = 0;
    uint64_t v15 = *a3;
    do
    {
      float v16 = *a5++;
      float v17 = v16;
      if (v16 > a9.n128_f32[0]) {
        a9.n128_f32[0] = v17;
      }
      float v18 = -v17;
      if (a9.n128_f32[0] < v18) {
        a9.n128_f32[0] = v18;
      }
      --v15;
    }
    while (v15);
  }
  else
  {
    a9.n128_u64[0] = 0;
  }
  if (a9.n128_f32[0] == 0.0) {
    float v19 = 127.0;
  }
  else {
    float v19 = 127.0 / a9.n128_f32[0];
  }
  uint64_t v20 = (*a3 + 15) & 0xFFFFFFF0;
  __n128 v21 = MEMORY[0x270FA5388](a9);
  uint64_t v22 = (char *)v104 - v20;
  uint64_t v24 = *v23;
  int32x4_t v27 = (int32x4_t)MEMORY[0x270FA5388](v21);
  int8x16_t v29 = (int32x4_t *)((char *)v104 - ((v28 + 15) & 0x7FFFFFFF0));
  if (v26)
  {
    uint64_t v30 = (char *)v104 - v20;
    uint64_t v31 = v26;
    do
    {
      float v32 = *v25++;
      *v30++ = (uint64_t)rintf(v19 * v32);
      --v31;
    }
    while (v31);
  }
  if (v26 < v20) {
    bzero(&v22[v26], (v20 + ~v26) + 1);
  }
  unint64_t v33 = *((_DWORD *)this + 3) & 0xFFFFFFFC;
  if (v33)
  {
    unint64_t v34 = 0;
    uint64_t v35 = (4 * v20);
    float16x8_t v36 = &a4[(3 * v20)];
    int8x16_t v37 = &a4[(2 * v20)];
    int8x16_t v38 = &a4[v20];
    do
    {
      if (v20)
      {
        uint64_t v48 = 0;
        int32x4_t v42 = 0uLL;
        int32x4_t v41 = 0uLL;
        int32x4_t v40 = 0uLL;
        int32x4_t v39 = 0uLL;
        do
        {
          int16x8_t v49 = vmovl_s8(*(int8x8_t *)&v22[v48]);
          int16x8_t v50 = vmovl_s8(*(int8x8_t *)&a4[v48]);
          int16x8_t v51 = vmovl_s8(*(int8x8_t *)&v38[v48]);
          int16x8_t v52 = vmovl_s8(*(int8x8_t *)&v37[v48]);
          int16x8_t v53 = vmovl_s8(*(int8x8_t *)&v36[v48]);
          int32x4_t v42 = vmlal_s16(vmlal_high_s16(v42, v49, v50), *(int16x4_t *)v49.i8, *(int16x4_t *)v50.i8);
          int32x4_t v39 = vmlal_s16(vmlal_high_s16(v39, v49, v51), *(int16x4_t *)v49.i8, *(int16x4_t *)v51.i8);
          int32x4_t v40 = vmlal_s16(vmlal_high_s16(v40, v49, v52), *(int16x4_t *)v49.i8, *(int16x4_t *)v52.i8);
          int32x4_t v41 = vmlal_s16(vmlal_high_s16(v41, v49, v53), *(int16x4_t *)v49.i8, *(int16x4_t *)v53.i8);
          v48 += 8;
        }
        while (v48 < v20);
      }
      else
      {
        int32x4_t v39 = 0uLL;
        int32x4_t v40 = 0uLL;
        int32x4_t v41 = 0uLL;
        int32x4_t v42 = 0uLL;
      }
      int32x4_t v43 = (int32x4_t)vpaddlq_s32(v42);
      int32x4_t v44 = (int32x4_t)vpaddlq_s32(v39);
      int64x2_t v45 = vpaddlq_s32(v40);
      v46.i64[0] = vzip1q_s32(v43, v44).u64[0];
      v46.i32[2] = v45.i32[0];
      int64x2_t v47 = vpaddlq_s32(v41);
      v46.i32[3] = v47.i32[0];
      v43.i64[0] = vzip2q_s32(v43, v44).u64[0];
      v43.i64[1] = __PAIR64__(v47.u32[2], v45.u32[2]);
      int32x4_t v27 = vaddq_s32(v46, v43);
      *(int32x4_t *)((char *)v29 + 4 * v34) = v27;
      a4 += v35;
      v34 += 4;
      v36 += v35;
      v37 += v35;
      v38 += v35;
    }
    while (v34 < v33);
  }
  else
  {
    LODWORD(v34) = 0;
  }
  if (v34 < v24)
  {
    if (v20)
    {
      unint64_t v34 = v34;
      uint64_t v54 = v20 & 0xFFFFFFE0;
      while (1)
      {
        if (v20 >= 0x20)
        {
          uint64_t v57 = 0;
          int32x4_t v58 = 0uLL;
          int32x4_t v59 = 0uLL;
          int32x4_t v60 = 0uLL;
          int32x4_t v61 = 0uLL;
          int32x4_t v62 = 0uLL;
          int32x4_t v63 = 0uLL;
          int32x4_t v64 = 0uLL;
          int32x4_t v65 = 0uLL;
          do
          {
            int8x16_t v66 = *(int8x16_t *)&a4[v57];
            int8x16_t v67 = *(int8x16_t *)&a4[v57 + 16];
            int16x8_t v68 = vmovl_s8(*(int8x8_t *)v66.i8);
            int16x8_t v69 = vmovl_high_s8(v66);
            int16x8_t v70 = vmovl_s8(*(int8x8_t *)v67.i8);
            int16x8_t v71 = vmovl_high_s8(v67);
            int8x16_t v72 = *(int8x16_t *)&v22[v57];
            int8x16_t v73 = *(int8x16_t *)&v22[v57 + 16];
            int16x8_t v74 = vmovl_s8(*(int8x8_t *)v72.i8);
            int16x8_t v75 = vmovl_high_s8(v72);
            int16x8_t v76 = vmovl_s8(*(int8x8_t *)v73.i8);
            int16x8_t v77 = vmovl_high_s8(v73);
            int32x4_t v61 = vmlal_high_s16(v61, v75, v69);
            int32x4_t v60 = vmlal_s16(v60, *(int16x4_t *)v75.i8, *(int16x4_t *)v69.i8);
            int32x4_t v59 = vmlal_high_s16(v59, v74, v68);
            int32x4_t v58 = vmlal_s16(v58, *(int16x4_t *)v74.i8, *(int16x4_t *)v68.i8);
            int32x4_t v65 = vmlal_high_s16(v65, v77, v71);
            int32x4_t v64 = vmlal_s16(v64, *(int16x4_t *)v77.i8, *(int16x4_t *)v71.i8);
            int32x4_t v63 = vmlal_high_s16(v63, v76, v70);
            int32x4_t v62 = vmlal_s16(v62, *(int16x4_t *)v76.i8, *(int16x4_t *)v70.i8);
            v57 += 32;
          }
          while (v54 != v57);
          int32x4_t v27 = vaddq_s32(vaddq_s32(vaddq_s32(v62, v58), vaddq_s32(v64, v60)), vaddq_s32(vaddq_s32(v63, v59), vaddq_s32(v65, v61)));
          unsigned int v55 = vaddvq_s32(v27);
          if (v54 == v20) {
            goto LABEL_30;
          }
          uint64_t v56 = v20 & 0xFFFFFFE0;
          uint64_t v78 = v56;
          if ((v20 & 0x10) == 0)
          {
            do
            {
              v55 += v22[v78] * a4[v78];
              ++v78;
            }
            while (v20 != v78);
            goto LABEL_30;
          }
        }
        else
        {
          unsigned int v55 = 0;
          uint64_t v56 = 0;
        }
        int32x4_t v79 = 0uLL;
        int32x4_t v80 = (int32x4_t)v55;
        do
        {
          int16x8_t v81 = vmovl_s8(*(int8x8_t *)&a4[v56]);
          int16x8_t v82 = vmovl_s8(*(int8x8_t *)&v22[v56]);
          int32x4_t v79 = vmlal_high_s16(v79, v82, v81);
          int32x4_t v80 = vmlal_s16(v80, *(int16x4_t *)v82.i8, *(int16x4_t *)v81.i8);
          v56 += 8;
        }
        while (v20 != v56);
        int32x4_t v27 = vaddq_s32(v80, v79);
        unsigned int v55 = vaddvq_s32(v27);
LABEL_30:
        a4 += (v20 - 16) + 16;
        v29->i32[v34++] = v55;
        if (v34 == v24) {
          goto LABEL_43;
        }
      }
    }
    bzero((char *)v29 + 4 * v34, 4 * (v24 + ~v34) + 4);
  }
LABEL_43:
  *(float *)v27.i32 = *a7 / v19;
  if (!*a8)
  {
    if (!v24) {
      return;
    }
    if (v24 > 7)
    {
      uint64_t v84 = v24 & 0xFFFFFFF8;
      f32 = a6[1].f32;
      uint64_t v96 = v29 + 1;
      uint64_t v97 = v84;
      do
      {
        float32x4_t v98 = vmulq_n_f32(vcvtq_f32_s32(*v96), *(float *)v27.i32);
        *((float32x4_t *)f32 - 1) = vmulq_n_f32(vcvtq_f32_s32(v96[-1]), *(float *)v27.i32);
        *(float32x4_t *)f32 = v98;
        f32 += 8;
        v96 += 2;
        v97 -= 8;
      }
      while (v97);
      if (v84 == v24) {
        return;
      }
    }
    else
    {
      uint64_t v84 = 0;
    }
    uint64_t v99 = v24 - v84;
    uint64_t v100 = v84;
    v101 = &a6->f32[v84];
    uint64_t v102 = &v29->i32[v100];
    do
    {
      int v103 = *v102++;
      *v101++ = *(float *)v27.i32 * (float)v103;
      --v99;
    }
    while (v99);
    return;
  }
  if (!v24) {
    return;
  }
  if (v24 <= 7)
  {
    uint64_t v83 = 0;
LABEL_53:
    uint64_t v90 = v24 - v83;
    uint64_t v91 = v83;
    int8x16x2_t v92 = &a6->f32[v83];
    int8x16x2_t v93 = &v29->i32[v91];
    do
    {
      int v94 = *v93++;
      *int8x16x2_t v92 = *v92 + (float)((float)v94 * *(float *)v27.i32);
      ++v92;
      --v90;
    }
    while (v90);
    return;
  }
  uint64_t v83 = v24 & 0xFFFFFFF8;
  float32x4_t v85 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v27.i8, 0);
  int v86 = a6 + 1;
  int v87 = v29 + 1;
  uint64_t v88 = v83;
  do
  {
    float32x4_t v89 = vmlaq_f32(*v86, v85, vcvtq_f32_s32(*v87));
    v86[-1] = vmlaq_f32(v86[-1], v85, vcvtq_f32_s32(v87[-1]));
    *int v86 = v89;
    v86 += 2;
    v87 += 2;
    v88 -= 8;
  }
  while (v88);
  if (v83 != v24) {
    goto LABEL_53;
  }
}

uint64_t N8BitLSTMLayer::computeProjection(N8BitLSTMLayer *this, const unsigned int *a2, const float *a3, const float *a4, float *a5)
{
  char v6 = 0;
  return (*(uint64_t (**)(N8BitLSTMLayer *, char *, const unsigned int *, const float *, const float *, float *, char *, char *))(*(void *)this + 88))(this, (char *)this + 12, a2, a3, a4, a5, (char *)this + 100, &v6);
}

uint64_t N8BitLSTMLayer::computeIFOC(N8BitLSTMLayer *this, const unsigned int *a2, const float *a3, const float *a4, const float *a5, const float *a6, float *a7)
{
  unsigned int v17 = 4 * *a2;
  char v16 = 0;
  uint64_t v12 = (char *)this + 12;
  (*(void (**)(N8BitLSTMLayer *, unsigned int *, char *, const float *, const float *, float *, char *, char *))(*(void *)this + 88))(this, &v17, (char *)this + 8, a3, a5, a7, (char *)this + 92, &v16);
  unsigned int v15 = 4 * *a2;
  char v14 = 1;
  return (*(uint64_t (**)(N8BitLSTMLayer *, unsigned int *, char *, const float *, const float *, float *, char *, char *))(*(void *)this + 88))(this, &v15, v12, a4, a6, a7, (char *)this + 96, &v14);
}

uint64_t N8BitLSTMLayer::loadHeader(N8BitLSTMLayer *this, const char *a2, const char **a3, unsigned int *a4, BOOL *a5, BOOL *a6)
{
  if (*(int *)a2 <= 31) {
    Error::chuck((Error *)"N8BitLSTMLayer::initialize() - data block too small for header", a2, a3, a4, a5, a6);
  }
  char v6 = (unsigned int *)*a3;
  *a4 = *(_DWORD *)*a3;
  *((_DWORD *)this + 22) = v6[1];
  *a5 = *((unsigned char *)v6 + 8);
  *a6 = *((unsigned char *)v6 + 9);
  unsigned int v7 = (char *)v6 + ((6 - (_BYTE)v6) & 0xF);
  *((_DWORD *)this + 23) = *(_DWORD *)(v7 + 10);
  *((_DWORD *)this + 24) = *(_DWORD *)(v7 + 14);
  *((_DWORD *)this + 25) = *(_DWORD *)(v7 + 18);
  *a3 = v7 + 26;
  return 1;
}

void NLSTMLayer::resetState(NLSTMLayer *this, void *a2)
{
  if (!a2) {
    Error::chuck((Error *)"NLSTMLayer::compute() - State uninitialized", 0);
  }
  uint64_t v2 = *((unsigned int *)this + 5);
  if (v2)
  {
    unint64_t v3 = (void *)a2[1];
    bzero(v3, 4 * v2);
  }
}

uint64_t NLSTMLayer::deallocateState(NLSTMLayer *this, void *a2)
{
  if (!a2) {
    Error::chuck((Error *)"NLSTMLayer::compute() - State uninitialized", 0);
  }
  uint64_t v2 = *(uint64_t (**)(void *))(*(void *)a2 + 8);

  return v2(a2);
}

void NLSTMLayer::allocateStateP(NLSTMLayer *this)
{
}

void sub_2184A99C4(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x1081C40622C3295);
  _Unwind_Resume(a1);
}

float32_t NLSTMLayer::compute(NLSTMLayer *this, const float *a2, float *a3, void *a4, __n128 a5)
{
  uint64_t v183 = *MEMORY[0x263EF8340];
  char v6 = (int *)((char *)this + 16);
  uint64_t v5 = *((unsigned int *)this + 4);
  if (!v5) {
    Error::chuck((Error *)"NLSTMLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  if (!a4) {
    Error::chuck((Error *)"NLSTMLayer::compute() - State uninitialized", (const char *)a2, a3);
  }
  unint64_t v9 = (float *)a4[1];
  uint64_t v10 = *((unsigned int *)this + 6);
  __n128 v11 = MEMORY[0x270FA5388](a5);
  float16x8_t v13 = (float *)((char *)&v177 - v12);
  uint64_t v14 = (2 * v5);
  uint64_t v15 = (3 * v5);
  v179 = (float *)((char *)&v177 + 4 * v15 - v12);
  (*(void (**)(void *, int *, void, void, __n128))(*v16 + 72))(v16, v6, v16[4], v16[5], v11);
  uint64_t v17 = *((unsigned int *)this + 4);
  uint64_t v18 = (4 * v17);
  if (v18)
  {
    unint64_t v19 = *((void *)this + 6);
    if (v18 > 7
      && ((unint64_t)v13 < v19 + 4 * v18 ? (BOOL v20 = v19 >= (unint64_t)&v13[v18]) : (BOOL v20 = 1), v20))
    {
      uint64_t v21 = v18 & 0xFFFFFFF8;
      uint64_t v22 = (float32x4_t *)(v13 + 4);
      unint64_t v23 = (float32x4_t *)(v19 + 16);
      uint64_t v24 = v21;
      do
      {
        float32x4_t v25 = vaddq_f32(*v23, *v22);
        v22[-1] = vaddq_f32(v23[-1], v22[-1]);
        *uint64_t v22 = v25;
        v22 += 2;
        v23 += 2;
        v24 -= 8;
      }
      while (v24);
      if (v21 == v18) {
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v21 = 0;
    }
    uint64_t v26 = v18 - v21;
    uint64_t v27 = 4 * v21;
    uint64_t v28 = &v13[v21];
    int8x16_t v29 = (float *)(v19 + v27);
    do
    {
      float v30 = *v29++;
      *uint64_t v28 = v30 + *v28;
      ++v28;
      --v26;
    }
    while (v26);
  }
LABEL_17:
  v180 = v6;
  v178 = a3;
  uint64_t v31 = &v9[v10];
  unint64_t v32 = (unint64_t)&v13[v14];
  unint64_t v33 = (unint64_t)&v13[v5];
  unint64_t v34 = (float32x4_t *)*((void *)this + 7);
  if (v34) {
    BOOL v35 = v17 == 0;
  }
  else {
    BOOL v35 = 1;
  }
  if (v35) {
    goto LABEL_59;
  }
  if (v17 > 0xB)
  {
    uint64_t v36 = 0;
    int8x16_t v37 = &v13[v17];
    BOOL v39 = v13 < &v9[v17 + v10] && v31 < v37;
    if ((v34 >= (float32x4_t *)v37 || v13 >= &v34->f32[v17]) && !v39)
    {
      uint64_t v36 = v17 & 0xFFFFFFF8;
      int32x4_t v41 = (float32x4_t *)(v13 + 4);
      int32x4_t v42 = (float32x4_t *)&v9[v10 + 4];
      int32x4_t v43 = v34 + 1;
      uint64_t v44 = v36;
      do
      {
        float32x4_t v45 = vmlaq_f32(*v41, *v42, *v43);
        v41[-1] = vmlaq_f32(v41[-1], v42[-1], v43[-1]);
        *int32x4_t v41 = v45;
        v41 += 2;
        v42 += 2;
        v43 += 2;
        v44 -= 8;
      }
      while (v44);
      if (v36 == v17) {
        goto LABEL_40;
      }
    }
  }
  else
  {
    uint64_t v36 = 0;
  }
  uint64_t v46 = v17 - v36;
  uint64_t v47 = v36;
  uint64_t v48 = &v13[v36];
  int16x8_t v49 = &v9[v10 + v47];
  int16x8_t v50 = &v34->f32[v47];
  do
  {
    float v51 = *v50++;
    float v52 = v51;
    float v53 = *v49++;
    *uint64_t v48 = *v48 + (float)(v52 * v53);
    ++v48;
    --v46;
  }
  while (v46);
LABEL_40:
  uint64_t v54 = (float32x4_t *)*((void *)this + 8);
  if (v17 <= 0xB)
  {
    uint64_t v55 = 0;
LABEL_57:
    uint64_t v65 = v17 - v55;
    uint64_t v66 = v55;
    int8x16_t v67 = &v13[v55 + v5];
    int16x8_t v68 = &v9[v10 + v66];
    int16x8_t v69 = &v54->f32[v66];
    do
    {
      float v70 = *v69++;
      float v71 = v70;
      float v72 = *v68++;
      *int8x16_t v67 = *v67 + (float)(v71 * v72);
      ++v67;
      --v65;
    }
    while (v65);
    goto LABEL_59;
  }
  uint64_t v55 = 0;
  uint64_t v56 = &v13[v17 + v5];
  BOOL v58 = v33 < (unint64_t)&v9[v17 + v10] && v31 < v56;
  if (v54 < (float32x4_t *)v56 && v33 < (unint64_t)v54->u64 + 4 * v17) {
    goto LABEL_57;
  }
  if (v58) {
    goto LABEL_57;
  }
  uint64_t v55 = v17 & 0xFFFFFFF8;
  int32x4_t v60 = v54 + 1;
  int32x4_t v61 = (float32x4_t *)&v13[v5 + 4];
  int32x4_t v62 = (float32x4_t *)&v9[v10 + 4];
  uint64_t v63 = v55;
  do
  {
    float32x4_t v64 = vmlaq_f32(*v61, *v62, *v60);
    v61[-1] = vmlaq_f32(v61[-1], v62[-1], v60[-1]);
    *int32x4_t v61 = v64;
    v60 += 2;
    v61 += 2;
    v62 += 2;
    v63 -= 8;
  }
  while (v63);
  if (v55 != v17) {
    goto LABEL_57;
  }
LABEL_59:
  unint64_t v177 = (unint64_t)&v13[v5];
  vDSP_Length v73 = (2 * v17);
  vDSP_vneg(v13, 1, v13, 1, v73);
  int v182 = v73;
  vvexpf(v13, v13, &v182);
  float __B = 1.0;
  vDSP_vsadd(v13, 1, &__B, v13, 1, v73);
  vvrecf(v13, v13, &v182);
  int16x8_t v74 = v180;
  int v182 = *v180;
  vvtanhf(v179, v179, &v182);
  vDSP_Length v75 = *v74;
  if (!v75)
  {
    vDSP_Length v75 = 0;
    uint64_t v78 = v180;
    goto LABEL_92;
  }
  if (v75 <= 7)
  {
    uint64_t v76 = 0;
    unint64_t v77 = (unint64_t)&v9[v10];
LABEL_66:
    uint64_t v78 = v180;
LABEL_67:
    vDSP_Length v79 = v75 - v76;
    int32x4_t v80 = &v13[v76];
    do
    {
      *int32x4_t v80 = v80[v15] * *v80;
      ++v80;
      --v79;
    }
    while (v79);
    goto LABEL_69;
  }
  unint64_t v77 = (unint64_t)&v9[v10];
  if (v13 < &v13[v75 + v15] && v179 < &v13[v75])
  {
    uint64_t v76 = 0;
    goto LABEL_66;
  }
  uint64_t v76 = v75 & 0xFFFFFFF8;
  v128 = (float32x4_t *)v13;
  uint64_t v129 = v76;
  uint64_t v78 = v180;
  do
  {
    float32x4_t v130 = vmulq_f32(*(float32x4_t *)((char *)v128 + 4 * v15 + 16), v128[1]);
    float32x4_t *v128 = vmulq_f32(*(float32x4_t *)((char *)v128 + 4 * v15), *v128);
    v128[1] = v130;
    v128 += 2;
    v129 -= 8;
  }
  while (v129);
  if (v76 != v75) {
    goto LABEL_67;
  }
LABEL_69:
  if (v75 <= 7 || v177 < (unint64_t)&v9[v75 + v10] && v77 < (unint64_t)&v13[v75 + v5])
  {
    uint64_t v81 = 0;
LABEL_73:
    vDSP_Length v82 = v75 - v81;
    uint64_t v83 = v81;
    uint64_t v84 = &v13[v81 + v5];
    float32x4_t v85 = &v9[v10 + v83];
    do
    {
      float v86 = *v85++;
      *uint64_t v84 = v86 * *v84;
      ++v84;
      --v82;
    }
    while (v82);
    goto LABEL_75;
  }
  uint64_t v81 = v75 & 0xFFFFFFF8;
  v131 = (float32x4_t *)&v13[v5 + 4];
  v132 = (float32x4_t *)&v9[v10 + 4];
  uint64_t v133 = v81;
  do
  {
    float32x4_t v134 = vmulq_f32(*v132, *v131);
    v131[-1] = vmulq_f32(v132[-1], v131[-1]);
    float32x4_t *v131 = v134;
    v131 += 2;
    v132 += 2;
    v133 -= 8;
  }
  while (v133);
  if (v81 != v75) {
    goto LABEL_73;
  }
LABEL_75:
  if (v75 <= 0xB)
  {
    uint64_t v87 = 0;
LABEL_77:
    vDSP_Length v88 = v75 - v87;
    uint64_t v89 = v87;
    uint64_t v90 = &v9[v87 + v10];
    uint64_t v91 = &v13[v89];
    do
    {
      float v92 = v91[v5];
      float v93 = *v91++;
      *v90++ = v93 + v92;
      --v88;
    }
    while (v88);
    goto LABEL_79;
  }
  uint64_t v87 = 0;
  __int16 v114 = &v9[v10];
  if ((unint64_t)((char *)v114 - (char *)&v13[v5]) < 0x20) {
    goto LABEL_77;
  }
  if ((unint64_t)((char *)v114 - (char *)v13) < 0x20) {
    goto LABEL_77;
  }
  uint64_t v87 = v75 & 0xFFFFFFF8;
  char v115 = (float32x4_t *)&v9[v10 + 4];
  uint64_t v116 = (float32x4_t *)v13;
  uint64_t v117 = v87;
  do
  {
    float32x4_t v118 = vaddq_f32(v116[1], *(float32x4_t *)((char *)v116 + 4 * v5 + 16));
    v115[-1] = vaddq_f32(*v116, *(float32x4_t *)((char *)v116 + 4 * v5));
    *char v115 = v118;
    v116 += 2;
    v115 += 2;
    v117 -= 8;
  }
  while (v117);
  if (v87 != v75) {
    goto LABEL_77;
  }
LABEL_79:
  if (*((float *)this + 22) != 0.0)
  {
    int v94 = (float *)v77;
    vDSP_Length v95 = v75;
    do
    {
      float v96 = *((float *)this + 22);
      if (*v94 <= v96)
      {
        float v97 = *((float *)this + 22);
        float v96 = *v94;
      }
      else
      {
        *int v94 = v96;
        float v97 = *((float *)this + 22);
      }
      float v98 = -v97;
      if (v96 < v98) {
        *int v94 = v98;
      }
      ++v94;
      --v95;
    }
    while (v95);
  }
  uint64_t v99 = (float32x4_t *)*((void *)this + 9);
  if (v99)
  {
    if (v75 < 0xC)
    {
      uint64_t v100 = 0;
LABEL_90:
      vDSP_Length v101 = v75 - v100;
      uint64_t v102 = v100;
      int v103 = &v13[v100 + v14];
      char v104 = &v9[v10 + v102];
      int v105 = &v99->f32[v102];
      do
      {
        float v106 = *v105++;
        float v107 = v106;
        float v108 = *v104++;
        *int v103 = *v103 + (float)(v107 * v108);
        ++v103;
        --v101;
      }
      while (v101);
      goto LABEL_92;
    }
    uint64_t v100 = 0;
    v119 = &v13[v75 + v14];
    BOOL v121 = v32 < (unint64_t)&v9[v75 + v10] && v77 < (unint64_t)v119;
    if (v99 < (float32x4_t *)v119 && v32 < (unint64_t)v99->u64 + 4 * v75) {
      goto LABEL_90;
    }
    if (v121) {
      goto LABEL_90;
    }
    uint64_t v100 = v75 & 0xFFFFFFF8;
    v123 = v99 + 1;
    v124 = (float32x4_t *)&v13[v14 + 4];
    v125 = (float32x4_t *)&v9[v10 + 4];
    uint64_t v126 = v100;
    do
    {
      float32x4_t v127 = vmlaq_f32(*v124, *v125, *v123);
      v124[-1] = vmlaq_f32(v124[-1], v125[-1], v123[-1]);
      float32x4_t *v124 = v127;
      v123 += 2;
      v124 += 2;
      v125 += 2;
      v126 -= 8;
    }
    while (v126);
    if (v100 != v75) {
      goto LABEL_90;
    }
  }
LABEL_92:
  vDSP_vneg(&v13[v14], 1, &v13[v14], 1, v75);
  int v182 = *v78;
  vvexpf(&v13[v14], &v13[v14], &v182);
  float __B = 1.0;
  vDSP_vsadd(&v13[v14], 1, &__B, &v13[v14], 1, *v78);
  vvrecf(&v13[v14], &v13[v14], &v182);
  uint64_t v109 = *v78;
  if (!v109) {
    goto LABEL_132;
  }
  if (v109 < 8)
  {
    uint64_t v110 = 0;
LABEL_130:
    uint64_t v135 = v109 - v110;
    v136 = &v9[v110];
    do
    {
      float *v136 = v136[v10];
      ++v136;
      --v135;
    }
    while (v135);
    goto LABEL_132;
  }
  uint64_t v110 = 0;
  if ((unint64_t)(-4 * v10) <= 0x1F) {
    goto LABEL_130;
  }
  uint64_t v110 = v109 & 0xFFFFFFF8;
  char v111 = v9;
  uint64_t v112 = v110;
  do
  {
    long long v113 = *(_OWORD *)&v111[v10 + 4];
    *(_OWORD *)char v111 = *(_OWORD *)&v111[v10];
    *((_OWORD *)v111 + 1) = v113;
    v111 += 8;
    v112 -= 8;
  }
  while (v112);
  if (v110 != v109) {
    goto LABEL_130;
  }
LABEL_132:
  int v182 = v109;
  vvtanhf(v9, v9, &v182);
  uint64_t v138 = *v78;
  if (!v138) {
    goto LABEL_146;
  }
  if (v138 <= 7
    || (v9 < &v13[v138 + v14] ? (BOOL v139 = v32 >= (unint64_t)&v9[v138]) : (BOOL v139 = 1), !v139))
  {
    uint64_t v140 = 0;
LABEL_144:
    uint64_t v145 = v138 - v140;
    uint64_t v146 = v140;
    v147 = &v9[v140];
    v148 = &v13[v14 + v146];
    do
    {
      float v149 = *v148++;
      v137.f32[0] = v149 * *v147;
      *v147++ = v137.f32[0];
      --v145;
    }
    while (v145);
    goto LABEL_146;
  }
  uint64_t v140 = v138 & 0xFFFFFFF8;
  v141 = (float32x4_t *)(v9 + 4);
  v142 = (float32x4_t *)&v13[v14 + 4];
  uint64_t v143 = v140;
  do
  {
    float32x4_t v137 = vmulq_f32(v142[-1], v141[-1]);
    float32x4_t v144 = vmulq_f32(*v142, *v141);
    v141[-1] = v137;
    float32x4_t *v141 = v144;
    v141 += 2;
    v142 += 2;
    v143 -= 8;
  }
  while (v143);
  if (v140 != v138) {
    goto LABEL_144;
  }
LABEL_146:
  uint64_t v150 = *((void *)this + 10);
  if (!v150)
  {
    uint64_t v163 = *((unsigned int *)this + 3);
    v164 = v178;
    if (!v163) {
      return v137.f32[0];
    }
    if (v163 >= 8 && (unint64_t)((char *)v178 - (char *)v9) > 0x1F)
    {
      uint64_t v166 = v163 & 0xFFFFFFF8;
      v167 = (float32x4_t *)(v178 + 4);
      v168 = (float32x4_t *)(v9 + 4);
      uint64_t v169 = v166;
      do
      {
        float32x4_t v137 = v168[-1];
        float32x4_t v170 = *v168;
        v167[-1] = v137;
        float32x4_t *v167 = v170;
        v167 += 2;
        v168 += 2;
        v169 -= 8;
      }
      while (v169);
      if (v166 == v163) {
        return v137.f32[0];
      }
    }
    else
    {
      uint64_t v166 = 0;
    }
    uint64_t v171 = v163 - v166;
    uint64_t v172 = v166;
    v173 = (__int32 *)&v164[v166];
    v174 = &v9[v172];
    do
    {
      __int32 v175 = *(_DWORD *)v174++;
      v137.i32[0] = v175;
      *v173++ = v175;
      --v171;
    }
    while (v171);
    return v137.f32[0];
  }
  v151 = v178;
  (*(void (**)(NLSTMLayer *, int *, uint64_t, float *, float *))(*(void *)this + 80))(this, v78, v150, v9, v178);
  uint64_t v152 = *((unsigned int *)this + 3);
  if (v152)
  {
    uint64_t v153 = 0;
    if (v152 < 8) {
      goto LABEL_153;
    }
    if ((unint64_t)((char *)v9 - (char *)v151) < 0x20) {
      goto LABEL_153;
    }
    uint64_t v153 = v152 & 0xFFFFFFF8;
    v154 = (float32x4_t *)(v9 + 4);
    v155 = (float32x4_t *)(v151 + 4);
    uint64_t v156 = v153;
    do
    {
      float32x4_t v137 = v155[-1];
      float32x4_t v157 = *v155;
      v154[-1] = v137;
      float32x4_t *v154 = v157;
      v154 += 2;
      v155 += 2;
      v156 -= 8;
    }
    while (v156);
    if (v153 != v152)
    {
LABEL_153:
      uint64_t v158 = v152 - v153;
      uint64_t v159 = v153;
      v160 = &v9[v153];
      v161 = (__int32 *)&v151[v159];
      do
      {
        __int32 v162 = *v161++;
        v137.i32[0] = v162;
        *(_DWORD *)v160++ = v162;
        --v158;
      }
      while (v158);
    }
  }
  return v137.f32[0];
}

uint64_t NLSTMLayer::initialize(NLSTMLayer *this, const char *a2, unsigned int *a3, const char *a4, const unsigned int *a5)
{
  if ((a4 & 0xF) != 0) {
    Error::chuck((Error *)"NLSTMLayer::initialize() - Unaligned data block", a2, a3);
  }
  int8x16_t v29 = a4;
  unsigned int v28 = 0;
  __int16 v27 = 0;
  int v26 = *a5;
  uint64_t result = (*(uint64_t (**)(NLSTMLayer *, int *, const char **, unsigned int *, char *, __int16 *))(*(void *)this + 64))(this, &v26, &v29, &v28, (char *)&v27 + 1, &v27);
  int v12 = v27;
  unsigned int v13 = v28;
  unsigned int v14 = *a3;
  if ((_BYTE)v27)
  {
    if (v28 <= v14) {
      Error::chuck((Error *)"NLSTMLayer::initialize() - must be fewer outputs than cells when projecting", v11);
    }
  }
  else if (v28 != v14)
  {
  }
  int v15 = *(_DWORD *)a2;
  uint64_t v16 = 4 * v28;
  uint64_t v17 = v16 * ((*(_DWORD *)a2 * result + 15) & 0x3FFFFFF0);
  uint64_t v18 = v29;
  int v19 = -(int)v29;
  BOOL v20 = (const char *)(v16 * ((v14 * result + 15) & 0x3FFFFFF0));
  uint64_t v21 = &v29[(v16 * ((*(_DWORD *)a2 * result + 15) & 0x3FFFFFF0)) & 0xFFFFFFF0 | -(int)v29 & 0xFLL];
  *((void *)this + 4) = v29;
  *((void *)this + 5) = v21;
  *((void *)this + 6) = &v20[(void)v21];
  uint64_t v22 = 16 * v13;
  uint64_t v23 = (uint64_t)&v20[(void)v21 + v22];
  int8x16_t v29 = (const char *)v23;
  if (HIBYTE(v27))
  {
    *((void *)this + 7) = v23;
    *((void *)this + 8) = v23 + v16;
    *((void *)this + 9) = v23 + v16 + v16;
    uint64_t v23 = (uint64_t)&v18[(v19 & 0xF) + (void)&v20[12 * v13 + (v16 & 0xC) + v17 + v22]];
    int8x16_t v29 = (const char *)v23;
  }
  if (v12)
  {
    *((void *)this + 10) = v23;
    v23 += (((v13 * result + 15) & 0xFFFFFFF0) * v14) & 0xFFFFFFF0 | -(int)v23 & 0xFLL;
    int8x16_t v29 = (const char *)v23;
  }
  uint64_t v24 = *a5;
  if (v23 - (void)a4 != v24) {
    Error::chuck((Error *)"NLSTMLayer::initialize() - data block wrong size (%d != %d)", v20, v23 - (void)a4, v24);
  }
  if ((v18 & 0xF) != 0 || (v21 & 0xF) != 0 || (*((unsigned char *)this + 80) & 0xF) != 0) {
    Error::chuck((Error *)"NLSTMLayer::initialize() - Unaligned matrix", v20);
  }
  if (!v15) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", v20);
  }
  if (!v14) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", v20);
  }
  *((_DWORD *)this + 2) = v15;
  *((_DWORD *)this + 3) = *a3;
  *((_DWORD *)this + 4) = v13;
  unsigned int v25 = v13 + (-v13 & 0xF);
  *((_DWORD *)this + 5) = 2 * v25;
  *((_DWORD *)this + 6) = v25;
  return result;
}

void N8BitLSTMLayer::~N8BitLSTMLayer(N8BitLSTMLayer *this)
{
}

void NLSTMLayer::computeProjection(NLSTMLayer *this, const unsigned int *a2, const float *a3, const float *a4, float *a5)
{
  uint64_t v5 = *((unsigned int *)this + 3);
  if (v5)
  {
    uint64_t v6 = *a2;
    if (v6)
    {
      uint64_t v7 = 4 * (v6 - 1) + 4;
      if (v6 >= 8)
      {
        for (uint64_t i = 0; i != v5; ++i)
        {
          unint64_t v11 = 0;
          float v12 = 0.0;
          do
          {
            float32x4_t v13 = vmulq_f32(*(float32x4_t *)&a3[v11 / 4], *(float32x4_t *)&a4[v11 / 4]);
            float32x4_t v14 = vmulq_f32(*(float32x4_t *)&a3[v11 / 4 + 4], *(float32x4_t *)&a4[v11 / 4 + 4]);
            float v12 = (float)((float)((float)((float)((float)((float)((float)(v12 + v13.f32[0]) + v13.f32[1]) + v13.f32[2])
                                                + v13.f32[3])
                                        + v14.f32[0])
                                + v14.f32[1])
                        + v14.f32[2])
                + v14.f32[3];
            v11 += 32;
          }
          while (((4 * v6) & 0x3FFFFFFE0) != v11);
          if ((v6 & 0xFFFFFFF8) != v6)
          {
            uint64_t v15 = v6 & 0xFFFFFFF8;
            do
            {
              float v12 = v12 + (float)(a3[v15] * a4[v15]);
              ++v15;
            }
            while (v6 != v15);
          }
          a3 = (const float *)((char *)a3 + v7);
          a5[i] = v12;
        }
      }
      else
      {
        unsigned int v8 = a3 + 3;
        do
        {
          float v9 = (float)(*(v8 - 3) * *a4) + 0.0;
          if (v6 != 1)
          {
            float v9 = v9 + (float)(*(v8 - 2) * a4[1]);
            if (v6 != 2)
            {
              float v9 = v9 + (float)(*(v8 - 1) * a4[2]);
              if (v6 != 3)
              {
                float v9 = v9 + (float)(*v8 * a4[3]);
                if (v6 != 4)
                {
                  float v9 = v9 + (float)(v8[1] * a4[4]);
                  if (v6 != 5)
                  {
                    float v9 = v9 + (float)(v8[2] * a4[5]);
                    if (v6 != 6) {
                      float v9 = v9 + (float)(v8[3] * a4[6]);
                    }
                  }
                }
              }
            }
          }
          *a5++ = v9;
          unsigned int v8 = (const float *)((char *)v8 + v7);
          --v5;
        }
        while (v5);
      }
    }
    else
    {
      bzero(a5, 4 * v5);
    }
  }
}

void NLSTMLayer::computeIFOC(NLSTMLayer *this, const unsigned int *a2, const float *a3, const float *a4, const float *a5, const float *a6, float *a7)
{
  uint64_t v8 = 4 * *a2;
  if (v8)
  {
    uint64_t v10 = *((unsigned int *)this + 2);
    uint64_t v9 = *((unsigned int *)this + 3);
    uint64_t v11 = -(int)v9 & 3;
    if (v10)
    {
      uint64_t v12 = -(int)v10 & 3;
      uint64_t v13 = 4 * (v10 - 1);
      if (v9)
      {
        uint64_t v14 = 0;
        uint64_t v15 = v13 + 4 * v12 + 4;
        uint64_t v16 = 4 * v11 + 4 * (v9 - 1) + 4;
        while (v10 >= 8)
        {
          unint64_t v20 = 0;
          float v18 = 0.0;
          do
          {
            float32x4_t v21 = vmulq_f32(*(float32x4_t *)&a3[v20 / 4], *(float32x4_t *)&a5[v20 / 4]);
            float32x4_t v22 = vmulq_f32(*(float32x4_t *)&a3[v20 / 4 + 4], *(float32x4_t *)&a5[v20 / 4 + 4]);
            float v18 = (float)((float)((float)((float)((float)((float)((float)(v18 + v21.f32[0]) + v21.f32[1]) + v21.f32[2])
                                                + v21.f32[3])
                                        + v22.f32[0])
                                + v22.f32[1])
                        + v22.f32[2])
                + v22.f32[3];
            v20 += 32;
          }
          while (((4 * v10) & 0x3FFFFFFE0) != v20);
          if ((v10 & 0xFFFFFFF8) != v10)
          {
            int v19 = &a3[v10 & 0xFFFFFFF8];
            uint64_t v17 = v10 & 0xFFFFFFF8;
LABEL_12:
            uint64_t v23 = v10 - v17;
            uint64_t v24 = (float *)&a5[v17];
            do
            {
              float v25 = *v19++;
              float v26 = v25;
              float v27 = *v24++;
              float v18 = v18 + (float)(v26 * v27);
              --v23;
            }
            while (v23);
          }
          if (v9 >= 8)
          {
            unint64_t v30 = 0;
            do
            {
              float32x4_t v31 = vmulq_f32(*(float32x4_t *)&a4[v30 / 4], *(float32x4_t *)&a6[v30 / 4]);
              float32x4_t v32 = vmulq_f32(*(float32x4_t *)&a4[v30 / 4 + 4], *(float32x4_t *)&a6[v30 / 4 + 4]);
              float v18 = (float)((float)((float)((float)((float)((float)((float)(v18 + v31.f32[0]) + v31.f32[1]) + v31.f32[2])
                                                  + v31.f32[3])
                                          + v32.f32[0])
                                  + v32.f32[1])
                          + v32.f32[2])
                  + v32.f32[3];
              v30 += 32;
            }
            while (((4 * v9) & 0x3FFFFFFE0) != v30);
            if ((v9 & 0xFFFFFFF8) == v9) {
              goto LABEL_5;
            }
            int8x16_t v29 = &a4[v9 & 0xFFFFFFF8];
            uint64_t v28 = v9 & 0xFFFFFFF8;
          }
          else
          {
            uint64_t v28 = 0;
            int8x16_t v29 = a4;
          }
          uint64_t v33 = v9 - v28;
          unint64_t v34 = (float *)&a6[v28];
          do
          {
            float v35 = *v29++;
            float v36 = v35;
            float v37 = *v34++;
            float v18 = v18 + (float)(v36 * v37);
            --v33;
          }
          while (v33);
LABEL_5:
          a3 = (const float *)((char *)a3 + v15);
          a4 = (const float *)((char *)a4 + v16);
          a7[v14++] = v18;
          if (v14 == v8) {
            return;
          }
        }
        uint64_t v17 = 0;
        float v18 = 0.0;
        int v19 = a3;
        goto LABEL_12;
      }
      if (v10 >= 8)
      {
        for (uint64_t i = 0; i != v8; ++i)
        {
          unint64_t v51 = 0;
          float v52 = 0.0;
          do
          {
            float32x4_t v53 = vmulq_f32(*(float32x4_t *)&a3[v51 / 4], *(float32x4_t *)&a5[v51 / 4]);
            float32x4_t v54 = vmulq_f32(*(float32x4_t *)&a3[v51 / 4 + 4], *(float32x4_t *)&a5[v51 / 4 + 4]);
            float v52 = (float)((float)((float)((float)((float)((float)((float)(v52 + v53.f32[0]) + v53.f32[1]) + v53.f32[2])
                                                + v53.f32[3])
                                        + v54.f32[0])
                                + v54.f32[1])
                        + v54.f32[2])
                + v54.f32[3];
            v51 += 32;
          }
          while (((4 * v10) & 0x3FFFFFFE0) != v51);
          if ((v10 & 0xFFFFFFF8) != v10)
          {
            uint64_t v55 = v10 & 0xFFFFFFF8;
            do
            {
              float v52 = v52 + (float)(a3[v55] * a5[v55]);
              ++v55;
            }
            while (v10 != v55);
          }
          a7[i] = v52;
          a3 = (const float *)((char *)a3 + 4 * v12 + v13 + 4);
        }
      }
      else
      {
        int32x4_t v41 = a3 + 3;
        do
        {
          float v42 = (float)(*(v41 - 3) * *a5) + 0.0;
          if (v10 != 1)
          {
            float v42 = v42 + (float)(*(v41 - 2) * a5[1]);
            if (v10 != 2)
            {
              float v42 = v42 + (float)(*(v41 - 1) * a5[2]);
              if (v10 != 3)
              {
                float v42 = v42 + (float)(*v41 * a5[3]);
                if (v10 != 4)
                {
                  float v42 = v42 + (float)(v41[1] * a5[4]);
                  if (v10 != 5)
                  {
                    float v42 = v42 + (float)(v41[2] * a5[5]);
                    if (v10 != 6) {
                      float v42 = v42 + (float)(v41[3] * a5[6]);
                    }
                  }
                }
              }
            }
          }
          *a7++ = v42;
          int32x4_t v41 = (const float *)((char *)v41 + 4 * v12 + v13 + 4);
          --v8;
        }
        while (v8);
      }
    }
    else if (v9)
    {
      uint64_t v38 = 4 * (v9 - 1);
      if (v9 >= 8)
      {
        uint64_t v43 = 0;
        uint64_t v44 = v38 + 4 * v11 + 4;
        do
        {
          unint64_t v45 = 0;
          float v46 = 0.0;
          do
          {
            float32x4_t v47 = vmulq_f32(*(float32x4_t *)&a4[v45 / 4], *(float32x4_t *)&a6[v45 / 4]);
            float32x4_t v48 = vmulq_f32(*(float32x4_t *)&a4[v45 / 4 + 4], *(float32x4_t *)&a6[v45 / 4 + 4]);
            float v46 = (float)((float)((float)((float)((float)((float)((float)(v46 + v47.f32[0]) + v47.f32[1]) + v47.f32[2])
                                                + v47.f32[3])
                                        + v48.f32[0])
                                + v48.f32[1])
                        + v48.f32[2])
                + v48.f32[3];
            v45 += 32;
          }
          while (((4 * v9) & 0x3FFFFFFE0) != v45);
          if ((v9 & 0xFFFFFFF8) != v9)
          {
            uint64_t v49 = v9 & 0xFFFFFFF8;
            do
            {
              float v46 = v46 + (float)(a4[v49] * a6[v49]);
              ++v49;
            }
            while (v9 != v49);
          }
          a7[v43++] = v46;
          a4 = (const float *)((char *)a4 + v44);
        }
        while (v43 != v8);
      }
      else
      {
        BOOL v39 = a4 + 3;
        do
        {
          float v40 = (float)(*(v39 - 3) * *a6) + 0.0;
          if (v9 != 1)
          {
            float v40 = v40 + (float)(*(v39 - 2) * a6[1]);
            if (v9 != 2)
            {
              float v40 = v40 + (float)(*(v39 - 1) * a6[2]);
              if (v9 != 3)
              {
                float v40 = v40 + (float)(*v39 * a6[3]);
                if (v9 != 4)
                {
                  float v40 = v40 + (float)(v39[1] * a6[4]);
                  if (v9 != 5)
                  {
                    float v40 = v40 + (float)(v39[2] * a6[5]);
                    if (v9 != 6) {
                      float v40 = v40 + (float)(v39[3] * a6[6]);
                    }
                  }
                }
              }
            }
          }
          *a7++ = v40;
          BOOL v39 = (const float *)((char *)v39 + 4 * v11 + v38 + 4);
          --v8;
        }
        while (v8);
      }
    }
    else
    {
      bzero(a7, 4 * v8);
    }
  }
}

uint64_t NLSTMLayer::loadHeader(NLSTMLayer *this, const char *a2, const char **a3, unsigned int *a4, BOOL *a5, BOOL *a6)
{
  if (*(int *)a2 <= 15) {
    Error::chuck((Error *)"NLSTMLayer::initialize() - data block too small for header", a2, a3, a4, a5, a6);
  }
  uint64_t v6 = (unsigned int *)*a3;
  *a4 = *(_DWORD *)*a3;
  *((_DWORD *)this + 22) = v6[1];
  *a5 = *((unsigned char *)v6 + 8);
  *a6 = *((unsigned char *)v6 + 9);
  *a3 = (char *)v6 + ((6 - v6) & 0xF) + 10;
  return 4;
}

void NLSTMLayer::~NLSTMLayer(NLSTMLayer *this)
{
}

void N4BitMatrixLayer::compute(N4BitMatrixLayer *this, const float *a2, float *a3, void *a4, __n128 a5)
{
  v80[1] = *MEMORY[0x263EF8340];
  uint64_t v5 = (int8x16_t *)*((void *)this + 2);
  if (!v5) {
    Error::chuck((Error *)"N4BitMatrixLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  unint64_t v8 = (*((_DWORD *)this + 6) + *((_DWORD *)this + 2));
  __n128 v13 = MEMORY[0x270FA5388](a5);
  uint64_t v14 = (char *)v80 - v12;
  if (v10)
  {
    uint64_t v15 = (char *)v80 - v12;
    uint64_t v16 = v10;
    do
    {
      float v17 = *v9++;
      v13.n128_f32[0] = rintf(v17 * 255.0);
      *v15++ = (uint64_t)v13.n128_f32[0] ^ 0x80;
      --v16;
    }
    while (v16);
  }
  if (v10 < v8) {
    bzero(&v14[v10], (v11 - 1) + 1);
  }
  uint64_t v18 = *((unsigned int *)this + 3);
  MEMORY[0x270FA5388](v13);
  unint64_t v20 = (int32x4_t *)((char *)v80 - ((v19 + 15) & 0x7FFFFFFF0));
  if (v18)
  {
    if (v8)
    {
      unint64_t v21 = ((v8 - 1) >> 1) + 1;
      if (v8 >= 0x3F)
      {
        uint64_t v34 = 0;
        unint64_t v35 = v21 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          int32x4_t v36 = 0uLL;
          float v37 = v5 + 1;
          int32x4_t v38 = 0uLL;
          BOOL v39 = v14 + 32;
          unint64_t v40 = v21 & 0xFFFFFFFFFFFFFFE0;
          int32x4_t v41 = 0uLL;
          int32x4_t v42 = 0uLL;
          int32x4_t v43 = 0uLL;
          int32x4_t v44 = 0uLL;
          int32x4_t v45 = 0uLL;
          int32x4_t v46 = 0uLL;
          do
          {
            float32x4_t v47 = v39 - 32;
            int8x16x2_t v81 = vld2q_s8(v47);
            int8x16_t v48 = v37[-1];
            int8x16x2_t v82 = vld2q_s8(v39);
            int8x16_t v49 = vshrq_n_s8(vshlq_n_s8(v48, 4uLL), 4uLL);
            int8x16_t v50 = vshrq_n_s8(vshlq_n_s8(*v37, 4uLL), 4uLL);
            int16x8_t v51 = vmovl_high_s8(v49);
            int16x8_t v52 = vmovl_s8(*(int8x8_t *)v49.i8);
            int16x8_t v53 = vmovl_high_s8(v50);
            int16x8_t v54 = vmovl_s8(*(int8x8_t *)v50.i8);
            int16x8_t v55 = vmovl_high_s8(v81.val[0]);
            int16x8_t v56 = vmovl_s8(*(int8x8_t *)v81.val[0].i8);
            int16x8_t v57 = vmovl_high_s8(v82.val[0]);
            int16x8_t v58 = vmovl_s8(*(int8x8_t *)v82.val[0].i8);
            int32x4_t v59 = vmlal_s16(v36, *(int16x4_t *)v52.i8, *(int16x4_t *)v56.i8);
            int32x4_t v60 = vmlal_high_s16(v38, v52, v56);
            int32x4_t v61 = vmlal_s16(v41, *(int16x4_t *)v51.i8, *(int16x4_t *)v55.i8);
            int32x4_t v62 = vmlal_high_s16(v42, v51, v55);
            int32x4_t v63 = vmlal_s16(v43, *(int16x4_t *)v54.i8, *(int16x4_t *)v58.i8);
            int32x4_t v64 = vmlal_high_s16(v44, v54, v58);
            int8x16_t v65 = vshrq_n_s8(v48, 4uLL);
            int8x16_t v66 = vshrq_n_s8(*v37, 4uLL);
            int16x8_t v67 = vmovl_s8(*(int8x8_t *)v65.i8);
            int16x8_t v68 = vmovl_high_s8(v65);
            int16x8_t v69 = vmovl_s8(*(int8x8_t *)v66.i8);
            int16x8_t v70 = vmovl_high_s8(v66);
            int16x8_t v71 = vmovl_s8(*(int8x8_t *)v81.val[1].i8);
            v81.val[0] = (int8x16_t)vmovl_high_s8(v81.val[1]);
            v81.val[1] = (int8x16_t)vmovl_s8(*(int8x8_t *)v82.val[1].i8);
            v82.val[0] = (int8x16_t)vmovl_high_s8(v82.val[1]);
            int32x4_t v42 = vmlal_high_s16(v62, (int16x8_t)v81.val[0], v68);
            int32x4_t v41 = vmlal_s16(v61, *(int16x4_t *)v81.val[0].i8, *(int16x4_t *)v68.i8);
            int32x4_t v38 = vmlal_high_s16(v60, v71, v67);
            int32x4_t v36 = vmlal_s16(v59, *(int16x4_t *)v71.i8, *(int16x4_t *)v67.i8);
            int32x4_t v46 = vmlal_high_s16(vmlal_high_s16(v46, v53, v57), (int16x8_t)v82.val[0], v70);
            int32x4_t v45 = vmlal_s16(vmlal_s16(v45, *(int16x4_t *)v53.i8, *(int16x4_t *)v57.i8), *(int16x4_t *)v82.val[0].i8, *(int16x4_t *)v70.i8);
            int32x4_t v44 = vmlal_high_s16(v64, (int16x8_t)v81.val[1], v69);
            int32x4_t v43 = vmlal_s16(v63, *(int16x4_t *)v81.val[1].i8, *(int16x4_t *)v69.i8);
            v39 += 64;
            v37 += 2;
            v40 -= 32;
          }
          while (v40);
          uint64_t v5 = (int8x16_t *)((char *)v5 + v35);
          int v72 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v43, v36), vaddq_s32(v45, v41)), vaddq_s32(vaddq_s32(v44, v38), vaddq_s32(v46, v42))));
          if (v21 != v35)
          {
            unint64_t v73 = 2 * (v21 & 0xFFFFFFFFFFFFFFE0);
            do
            {
              int v74 = v5->i8[0];
              uint64_t v5 = (int8x16_t *)((char *)v5 + 1);
              v72 += (v74 << 28 >> 28) * v14[v73] + v14[v73 + 1] * (v74 >> 4);
              v73 += 2;
            }
            while (v73 < v8);
          }
          v20->i32[v34++] = v72;
        }
        while (v34 != v18);
      }
      else
      {
        for (uint64_t i = 0; i != v18; ++i)
        {
          unint64_t v23 = 0;
          __int32 v24 = 0;
          float v25 = v5;
          do
          {
            int v26 = v25->i8[0];
            float v25 = (int8x16_t *)((char *)v25 + 1);
            v24 += (v26 << 28 >> 28) * v14[v23] + v14[v23 + 1] * (v26 >> 4);
            v23 += 2;
          }
          while (v23 < v8);
          uint64_t v5 = (int8x16_t *)((char *)v5 + v21);
          v20->i32[i] = v24;
        }
      }
    }
    else
    {
      bzero((char *)v80 - ((v19 + 15) & 0x7FFFFFFF0), v19);
    }
    float v27 = (const float *)((char *)this + 28);
    if (v18 <= 7 || (char *)this + 32 > (char *)a3 && v27 < &a3[v18])
    {
      uint64_t v28 = 0;
LABEL_20:
      uint64_t v29 = v18 - v28;
      uint64_t v30 = v28;
      float32x4_t v31 = &a3[v28];
      float32x4_t v32 = &v20->i32[v30];
      do
      {
        int v33 = *v32++;
        *v31++ = *v27 * (float)v33;
        --v29;
      }
      while (v29);
      return;
    }
    uint64_t v28 = v18 & 0xFFFFFFF8;
    float32x4_t v75 = vld1q_dup_f32(v27);
    uint64_t v76 = a3 + 4;
    unint64_t v77 = v20 + 1;
    uint64_t v78 = v28;
    do
    {
      float32x4_t v79 = vmulq_f32(v75, vcvtq_f32_s32(*v77));
      *((float32x4_t *)v76 - 1) = vmulq_f32(v75, vcvtq_f32_s32(v77[-1]));
      *(float32x4_t *)uint64_t v76 = v79;
      v76 += 8;
      v77 += 2;
      v78 -= 8;
    }
    while (v78);
    if (v28 != v18) {
      goto LABEL_20;
    }
  }
}

float N4BitMatrixLayer::initialize(N4BitMatrixLayer *this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  if ((a4 & 0xF) != 0) {
    Error::chuck((Error *)"N4BitMatrixLayer::initialize() - Unaligned data block", a2, a3);
  }
  int v5 = *(_DWORD *)a2;
  unsigned int v6 = (((*(_DWORD *)a2 + 1) >> 1) + 15) & 0xFFFFFFF0;
  if (*a5 != ((v6 * *a3) | 4)) {
    Error::chuck((Error *)"N4BitMatrixLayer::initialize() - Incorrect data size", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!*a3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *((_DWORD *)this + 2) = v5;
  *((_DWORD *)this + 3) = *a3;
  *((void *)this + 2) = a4;
  *((_DWORD *)this + 6) = 2 * v6 - *(_DWORD *)a2;
  float result = *(float *)&a4[*a5 - 4] * 0.00392156863;
  *((float *)this + 7) = result;
  return result;
}

void N4BitMatrixLayer::~N4BitMatrixLayer(N4BitMatrixLayer *this)
{
}

void NSigned8BitInput1DConvLayer::compute(NSigned8BitInput1DConvLayer *this, const float *a2, float *a3, void *a4, __n128 a5)
{
  uint64_t v102 = a2;
  uint64_t v104 = *MEMORY[0x263EF8340];
  uint64_t v5 = *((void *)this + 2);
  if (!v5) {
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  uint64_t v7 = *((unsigned int *)this + 3);
  __n128 v8 = MEMORY[0x270FA5388](a5);
  uint64_t v10 = (int32x4_t *)((char *)&v97 - ((v9 + 15) & 0x7FFFFFFF0));
  unint64_t v12 = *(unsigned int *)(v11 + 36);
  MEMORY[0x270FA5388](v8);
  size_t v103 = v14;
  uint64_t v15 = (char *)&v97 - ((v14 + 15) & 0x7FFFFFFF0);
  if (!v7) {
    return;
  }
  float v98 = v13;
  uint64_t v16 = *((unsigned int *)this + 12);
  unsigned int v17 = *((_DWORD *)this + 10);
  uint64_t v18 = (v12 - 1);
  unsigned int v19 = 0;
  if ((v12 & 7) != 0)
  {
    uint64_t v100 = v18 + 1;
    LODWORD(v101) = v17 - 1;
    unsigned int v20 = v17 & 0xFFFFFFF8;
    long long v21 = 0uLL;
    while (1)
    {
      if (v12)
      {
        bzero(v15, v103);
        int v22 = *((_DWORD *)this + 8);
        if (!v22)
        {
          v5 += v100;
          long long v21 = 0uLL;
          if (!v17) {
            goto LABEL_6;
          }
          goto LABEL_14;
        }
        uint64_t v23 = 0;
        __int32 v24 = v102;
        long long v21 = 0uLL;
        do
        {
          uint64_t v25 = 0;
          int v26 = 0;
          int v27 = v22;
          do
          {
            v26 += *((char *)v24 + v25) * *(char *)(v5 + v25);
            v25 += v12;
            --v27;
          }
          while (v27);
          *(_DWORD *)&v15[4 * v23] = v26;
          ++v5;
          __int32 v24 = (const float *)((char *)v24 + 1);
          ++v23;
        }
        while (v23 != v12);
      }
      if (!v17) {
        goto LABEL_6;
      }
LABEL_14:
      unsigned int v28 = *((_DWORD *)this + 11);
      unsigned int v29 = v17 + v19;
      if (v28)
      {
        int v30 = 0;
        unsigned int v31 = v28 & 0xFFFFFFF8;
        while (1)
        {
          unsigned int v32 = 0;
          BOOL v33 = __CFADD__(v30, v28 - 1);
          int v34 = 0;
          int v35 = v30;
          if (v28 >= 8 && !v33)
          {
            int32x4_t v36 = 0uLL;
            uint64_t v37 = v28 & 0xFFFFFFF8;
            int v38 = v30;
            int32x4_t v39 = 0uLL;
            do
            {
              unint64_t v40 = (int32x4_t *)&v15[4 * v38];
              int32x4_t v36 = vaddq_s32(*v40, v36);
              int32x4_t v39 = vaddq_s32(v40[1], v39);
              v38 += 8;
              v37 -= 8;
            }
            while (v37);
            int v34 = vaddvq_s32(vaddq_s32(v39, v36));
            if (v28 == v31) {
              goto LABEL_16;
            }
            int v35 = v30 + v31;
            unsigned int v32 = v28 & 0xFFFFFFF8;
          }
          unsigned int v41 = v28 - v32;
          do
          {
            v34 += *(_DWORD *)&v15[4 * v35++];
            --v41;
          }
          while (v41);
LABEL_16:
          v30 += v28;
          v10->i32[v19++] = v34;
          if (v19 == v29) {
            goto LABEL_5;
          }
        }
      }
      BOOL v42 = __CFADD__(v19, v101);
      if (v17 >= 8)
      {
        uint64_t v43 = v17 & 0xFFFFFFF8;
        unsigned int v44 = v19;
        if (!v42)
        {
          do
          {
            int32x4_t v45 = &v10->i8[4 * v44];
            *(_OWORD *)int32x4_t v45 = v21;
            *((_OWORD *)v45 + 1) = v21;
            v44 += 8;
            v43 -= 8;
          }
          while (v43);
          if (v17 == v20) {
            goto LABEL_5;
          }
          v19 += v20;
        }
      }
      do
        v10->i32[v19++] = 0;
      while (v29 != v19);
LABEL_5:
      unsigned int v19 = v29;
LABEL_6:
      v5 += v16;
      if (v19 >= v7) {
        goto LABEL_78;
      }
    }
  }
  unsigned int v46 = v18 >> 3;
  uint64_t v100 = 8 * v46 + 8;
  size_t v101 = 32 * v46 + 32;
  unsigned int v99 = v17 - 1;
  unsigned int v47 = v17 & 0xFFFFFFF8;
  long long v48 = 0uLL;
  do
  {
    if (!v12) {
      goto LABEL_50;
    }
    bzero(v15, v103);
    int v49 = *((_DWORD *)this + 8);
    if (v49)
    {
      unint64_t v50 = 0;
      int16x8_t v51 = v102;
      long long v48 = 0uLL;
      do
      {
        uint64_t v52 = 0;
        int32x4_t v53 = 0uLL;
        int v54 = v49;
        int32x4_t v55 = 0uLL;
        do
        {
          int16x8_t v56 = vmull_s8(*(int8x8_t *)((char *)v51 + v52), *(int8x8_t *)(v5 + v52));
          int32x4_t v55 = vaddw_s16(v55, *(int16x4_t *)v56.i8);
          int32x4_t v53 = vaddw_high_s16(v53, v56);
          v52 += v12;
          --v54;
        }
        while (v54);
        *(int32x4_t *)&v15[4 * v50] = v55;
        *(int32x4_t *)&v15[(4 * v50) | 0x10] = v53;
        v5 += 8;
        v51 += 2;
        v50 += 8;
      }
      while (v50 < v12);
LABEL_50:
      if (v17) {
        goto LABEL_51;
      }
      goto LABEL_43;
    }
    bzero(v15, v101);
    v5 += v100;
    long long v48 = 0uLL;
    if (v17)
    {
LABEL_51:
      unsigned int v57 = *((_DWORD *)this + 11);
      unsigned int v58 = v17 + v19;
      if (v57)
      {
        int v59 = 0;
        unsigned int v60 = v57 & 0xFFFFFFF8;
        while (1)
        {
          unsigned int v61 = 0;
          BOOL v62 = __CFADD__(v59, v57 - 1);
          int v63 = 0;
          int v64 = v59;
          if (v57 >= 8 && !v62)
          {
            int32x4_t v65 = 0uLL;
            uint64_t v66 = v57 & 0xFFFFFFF8;
            int v67 = v59;
            int32x4_t v68 = 0uLL;
            do
            {
              int16x8_t v69 = (int32x4_t *)&v15[4 * v67];
              int32x4_t v65 = vaddq_s32(*v69, v65);
              int32x4_t v68 = vaddq_s32(v69[1], v68);
              v67 += 8;
              v66 -= 8;
            }
            while (v66);
            int v63 = vaddvq_s32(vaddq_s32(v68, v65));
            if (v57 == v60) {
              goto LABEL_53;
            }
            int v64 = v59 + v60;
            unsigned int v61 = v57 & 0xFFFFFFF8;
          }
          unsigned int v70 = v57 - v61;
          do
          {
            v63 += *(_DWORD *)&v15[4 * v64++];
            --v70;
          }
          while (v70);
LABEL_53:
          v59 += v57;
          v10->i32[v19++] = v63;
          if (v19 == v58) {
            goto LABEL_42;
          }
        }
      }
      BOOL v71 = __CFADD__(v19, v99);
      if (v17 < 8 || (uint64_t v72 = v17 & 0xFFFFFFF8, v73 = v19, v71))
      {
        do
LABEL_76:
          v10->i32[v19++] = 0;
        while (v58 != v19);
      }
      else
      {
        do
        {
          int v74 = &v10->i8[4 * v73];
          *(_OWORD *)int v74 = v48;
          *((_OWORD *)v74 + 1) = v48;
          v73 += 8;
          v72 -= 8;
        }
        while (v72);
        if (v17 != v47)
        {
          v19 += v47;
          goto LABEL_76;
        }
      }
LABEL_42:
      unsigned int v19 = v58;
    }
LABEL_43:
    v5 += v16;
  }
  while (v19 < v7);
LABEL_78:
  float32x4_t v75 = (int32x4_t *)*((void *)this + 3);
  if (v7 > 7)
  {
    uint64_t v76 = v7 & 0xFFFFFFF8;
    uint64_t v78 = v10 + 1;
    float32x4_t v79 = v75 + 1;
    uint64_t v80 = v76;
    unint64_t v77 = v98;
    do
    {
      int32x4_t v81 = vaddq_s32(*v78, *v79);
      v78[-1] = vaddq_s32(v78[-1], v79[-1]);
      int32x4_t *v78 = v81;
      v78 += 2;
      v79 += 2;
      v80 -= 8;
    }
    while (v80);
    if (v76 != v7)
    {
      float32x4_t v75 = (int32x4_t *)((char *)v75 + 4 * (v7 & 0xFFFFFFF8));
      goto LABEL_84;
    }
  }
  else
  {
    uint64_t v76 = 0;
    unint64_t v77 = v98;
LABEL_84:
    uint64_t v82 = v7 - v76;
    uint64_t v83 = &v10->i8[4 * v76];
    do
    {
      __int32 v84 = v75->i32[0];
      float32x4_t v75 = (int32x4_t *)((char *)v75 + 4);
      *(_DWORD *)v83 += v84;
      v83 += 4;
      --v82;
    }
    while (v82);
  }
  float32x4_t v85 = (const float *)((char *)this + 52);
  if (v7 <= 7 || (char *)this + 56 > (char *)v77 && v85 < &v77->f32[v7])
  {
    uint64_t v86 = 0;
    goto LABEL_90;
  }
  uint64_t v86 = v7 & 0xFFFFFFF8;
  float32x4_t v92 = vld1q_dup_f32(v85);
  float v93 = v77 + 1;
  int v94 = v10 + 1;
  uint64_t v95 = v86;
  do
  {
    float32x4_t v96 = vmulq_f32(v92, vcvtq_f32_s32(*v94));
    v93[-1] = vmulq_f32(v92, vcvtq_f32_s32(v94[-1]));
    *float v93 = v96;
    v93 += 2;
    v94 += 2;
    v95 -= 8;
  }
  while (v95);
  if (v86 != v7)
  {
LABEL_90:
    uint64_t v87 = v7 - v86;
    uint64_t v88 = v86;
    uint64_t v89 = &v77->f32[v86];
    uint64_t v90 = &v10->i32[v88];
    do
    {
      int v91 = *v90++;
      *v89++ = *v85 * (float)v91;
      --v87;
    }
    while (v87);
  }
}

uint64_t NSigned8BitInput1DConvLayer::initialize(uint64_t this, const char *a2, unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5 = 4 * *(_DWORD *)a2;
  unsigned int v6 = *(_DWORD *)a4;
  *(_DWORD *)(this + 36) = *(_DWORD *)a4;
  unsigned int v7 = *((_DWORD *)a4 + 1);
  *(_DWORD *)(this + 40) = v7;
  int v8 = *((_DWORD *)a4 + 2);
  float v9 = *((float *)a4 + 3) * 0.00392156863;
  *(float *)(this + 52) = v9;
  *(_DWORD *)(this + 32) = v5 / v6;
  unsigned int v10 = *a3;
  *(_DWORD *)(this + 44) = v6 / v7;
  if (v5 / v6 * v6 != v5) {
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - inputsize not divisible by rowsize", a2);
  }
  int v11 = v10 / v7;
  int v12 = v7 * (v10 / v7);
  if (v12 != *a3) {
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - outputsize not divisible by numgroups", a2);
  }
  if (v7 * (v6 / v7) != v6) {
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - inputsize not divisible by numgroups", a2);
  }
  if (v8 != 1) {
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - numties not equal to 1 not supported", a2);
  }
  unsigned int v13 = (v5 + 15) & 0xFFFFFFF0;
  if (*a5 != v11 * v13 + ((4 * v12 + 15) & 0xFFFFFFF0) + 16) {
    Error::chuck((Error *)"NSigned8BitInput1DConvLayer::initialize() - Incorrect data size", a2);
  }
  if (!*(_DWORD *)a2) {
    goto LABEL_11;
  }
  if (!v12) {
    goto LABEL_12;
  }
  *(_DWORD *)(this + 8) = *(_DWORD *)a2;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4 + 16;
  *(void *)(this + 24) = &a4[v11 * v13 + 16];
  *(_DWORD *)(this + 48) = v13 - v6;
  if (!*(_DWORD *)a2) {
LABEL_11:
  }
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  if (!*a3) {
LABEL_12:
  }
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  *(_DWORD *)(this + 8) = *(_DWORD *)a2;
  *(_DWORD *)(this + 12) = *a3;
  return this;
}

void NSigned8BitInput1DConvLayer::~NSigned8BitInput1DConvLayer(NSigned8BitInput1DConvLayer *this)
{
}

uint64_t NSigned8BitQuantizeLayer::compute(uint64_t this, const float *a2, int8x8_t *a3, void *a4)
{
  if (!*(void *)(this + 16)) {
    Error::chuck((Error *)"NSigned8BitQuantizeLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  unint64_t v4 = *(unsigned int *)(this + 8);
  LODWORD(v5) = v4;
  if (v4 >= 0x10)
  {
    unint64_t v6 = v4 >> 4;
    unsigned int v7 = a2 + 8;
    int v8 = a3 + 1;
    float32x4_t v9 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      float32x4_t v10 = vmulq_f32(*(float32x4_t *)(v7 - 8), v9);
      float32x4_t v11 = vmulq_f32(*(float32x4_t *)(v7 - 4), v9);
      float32x4_t v12 = *(float32x4_t *)v7;
      float32x4_t v13 = *(float32x4_t *)(v7 + 4);
      v7 += 16;
      v8[-1] = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(v10), (int16x8_t)vcvtnq_s32_f32(v11)));
      *int v8 = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(vmulq_f32(v12, v9)), (int16x8_t)vcvtnq_s32_f32(vmulq_f32(v13, v9))));
      v8 += 2;
      --v6;
    }
    while (v6);
    LODWORD(v5) = *(_DWORD *)(this + 8);
  }
  unint64_t v14 = v4 & 0xFFFFFFF0;
  if (v14 < v5)
  {
    do
    {
      a3->i8[v14] = (uint64_t)rintf(a2[v14] * 255.0);
      ++v14;
      unint64_t v5 = *(unsigned int *)(this + 8);
    }
    while (v14 < v5);
  }
  if (v5)
  {
    unint64_t v15 = 0;
    do
      a3->i8[v15++] ^= 0x80u;
    while (v15 < *(unsigned int *)(this + 8));
  }
  return this;
}

uint64_t NSigned8BitQuantizeLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != 4 * *a3) {
    Error::chuck((Error *)"NSigned8BitQuantizeLayer::initialize() - input and output size must be in ratio 4:1", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!*a3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void NSigned8BitQuantizeLayer::~NSigned8BitQuantizeLayer(NSigned8BitQuantizeLayer *this)
{
}

void NLogSoftmaxOnlyLayer::compute(NLogSoftmaxOnlyLayer *this, const float *a2, float32x4_t *__dst, void *a4)
{
  if (!*((void *)this + 2)) {
    Error::chuck((Error *)"NLogSoftmaxOnlyLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  }
  memcpy(__dst, a2, 4 * *((unsigned int *)this + 3));
  uint64_t v6 = *((unsigned int *)this + 3);
  float v7 = __dst->f32[0];
  if (v6 >= 2)
  {
    uint64_t v8 = v6 - 1;
    float32x4_t v9 = &__dst->f32[1];
    do
    {
      float v10 = *v9++;
      float v11 = v10;
      if (v10 > v7) {
        float v7 = v11;
      }
      --v8;
    }
    while (v8);
  }
  if (!v6) {
    return;
  }
  if (v6 == 1)
  {
    uint64_t v12 = 0;
    float v13 = 0.0;
  }
  else
  {
    uint64_t v12 = v6 & 0xFFFFFFFE;
    unint64_t v14 = &__dst->f32[1];
    float v13 = 0.0;
    uint64_t v15 = v12;
    do
    {
      float v16 = *v14 - v7;
      float v17 = expf(*(v14 - 1) - v7);
      float v13 = (float)(v13 + v17) + expf(v16);
      v14 += 2;
      v15 -= 2;
    }
    while (v15);
    if (v12 == v6) {
      goto LABEL_15;
    }
  }
  uint64_t v18 = v6 - v12;
  unsigned int v19 = &__dst->f32[v12];
  do
  {
    float v20 = *v19++;
    float v13 = v13 + expf(v20 - v7);
    --v18;
  }
  while (v18);
LABEL_15:
  *(float *)v21.i32 = v7 + logf(v13);
  if (v6 < 8)
  {
    uint64_t v22 = 0;
LABEL_20:
    uint64_t v27 = v6 - v22;
    unsigned int v28 = &__dst->f32[v22];
    do
    {
      *unsigned int v28 = *v28 - *(float *)v21.i32;
      ++v28;
      --v27;
    }
    while (v27);
    return;
  }
  uint64_t v22 = v6 & 0xFFFFFFF8;
  float32x4_t v23 = (float32x4_t)vdupq_lane_s32(v21, 0);
  __int32 v24 = __dst + 1;
  uint64_t v25 = v22;
  do
  {
    float32x4_t v26 = vsubq_f32(*v24, v23);
    v24[-1] = vsubq_f32(v24[-1], v23);
    *__int32 v24 = v26;
    v24 += 2;
    v25 -= 8;
  }
  while (v25);
  if (v22 != v6) {
    goto LABEL_20;
  }
}

uint64_t NLogSoftmaxOnlyLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != *a3) {
    Error::chuck((Error *)"NLogSoftmaxOnlyLayer::initialize() - input and output size must be the same", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void NLogSoftmaxOnlyLayer::~NLogSoftmaxOnlyLayer(NLogSoftmaxOnlyLayer *this)
{
}

void NVectorScaleLayer::compute(NVectorScaleLayer *this, const float *__A, float *__C, void *a4)
{
  int v5 = (const float *)*((void *)this + 2);
  if (!v5) {
    Error::chuck((Error *)"NVectorScaleLayer::compute() - Layer uninitialized", (const char *)__A, 0, a4, __C);
  }
  vDSP_Length v6 = *((unsigned int *)this + 2);

  vDSP_vmul(__A, 1, v5, 1, __C, 1, v6);
}

uint64_t NVectorScaleLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5 = *a5 >> 2;
  if (v5 != *(_DWORD *)a2) {
    Error::chuck((Error *)"NVectorScaleLayer::initialize() - Incorrect data size", a2, a3, a4);
  }
  if (v5 != *a3) {
    Error::chuck((Error *)"NVectorScaleLayer::initialize() - Input and output not same", a2);
  }
  if (*a5 <= 3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void NVectorScaleLayer::~NVectorScaleLayer(NVectorScaleLayer *this)
{
}

void *NSubVectorSelectLayer::compute(void *this, const float *a2, float *a3, void *a4)
{
  uint64_t v4 = this[2];
  if (!v4) {
    Error::chuck((Error *)"NSubVectorSelectLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  unsigned int v5 = *(_DWORD *)(v4 + 4);
  if (v5)
  {
    uint64_t v8 = this;
    int v9 = 0;
    unsigned int v10 = 3;
    do
    {
      this = memcpy(&a3[v9], &a2[*(unsigned int *)(v4 + 4 * (v10 - 3))], 4 * v5);
      v9 += v5;
      uint64_t v4 = v8[2];
      unsigned int v5 = *(_DWORD *)(v4 + 4 * v10);
      v10 += 2;
    }
    while (v5);
  }
  return this;
}

uint64_t NSubVectorSelectLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, unsigned int *a5)
{
  unsigned int v5 = *a5;
  if (*a5 < 0x10 || (*a5 & 4) != 0) {
    Error::chuck((Error *)"NSubVectorSelectLayer::initialize() - invalid layer size", a2, a3, a4);
  }
  unsigned int v7 = v5 >> 2;
  unsigned int v8 = (v5 >> 2) - 2;
  if (v5 >> 2 == 2)
  {
    int v10 = 0;
    if (*(_DWORD *)&a4[4 * v8]) {
      goto LABEL_20;
    }
  }
  else
  {
    unsigned int v9 = 0;
    int v10 = 0;
    unsigned int v11 = *(_DWORD *)a2;
    do
    {
      unsigned int v12 = *(_DWORD *)&a4[4 * v9];
      if (v12 >= v11) {
        goto LABEL_19;
      }
      int v13 = *(_DWORD *)&a4[4 * v9 + 4];
      if (v12 + v13 - 1 >= v11) {
        goto LABEL_19;
      }
      v10 += v13;
      v9 += 2;
    }
    while (v9 < v8);
    if (*(_DWORD *)&a4[4 * v8]) {
LABEL_20:
    }
      Error::chuck((Error *)"NSubVectorSelectLayer::initialize() - missing subvector list termination", a2, a3);
  }
  if (*(_DWORD *)&a4[4 * v7 - 4]) {
    goto LABEL_20;
  }
  if (v10 != *a3) {
LABEL_19:
  }
    Error::chuck((Error *)"NSubVectorSelectLayer::initialize() - invalid subvector specification", a2, a3);
  if (!*(_DWORD *)a2) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!v10) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = *(_DWORD *)a2;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void NSubVectorSelectLayer::~NSubVectorSelectLayer(NSubVectorSelectLayer *this)
{
}

uint64_t NBlockDiagonalLayer::compute(NBlockDiagonalLayer *this, const float *a2, float *a3, void *a4)
{
  uint64_t v4 = *((void *)this + 2);
  if (!v4) {
    Error::chuck((Error *)"NBlockDiagonalLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  if (*((_DWORD *)this + 8))
  {
    unsigned int v7 = 0;
    unsigned int v8 = (const void *)(v4 + 4 * (*((_DWORD *)this + 6) * *((_DWORD *)this + 7)));
    do
      memcpy(&a3[*((_DWORD *)this + 7) * v7++], v8, 4 * *((unsigned int *)this + 7));
    while (v7 < *((_DWORD *)this + 8));
  }
  return cblas_sgemm_NEWLAPACK_ILP64();
}

uint64_t NBlockDiagonalLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  uint64_t v5 = *a5;
  unsigned int v6 = *(_DWORD *)&a4[v5 - 4];
  int v7 = *(_DWORD *)a2;
  unsigned int v8 = *(_DWORD *)a2 / v6;
  unsigned int v9 = *a3 / v6;
  if (*a3 != v9 * v6 || v7 != v8 * v6) {
    Error::chuck((Error *)"NBlockDiagonalLayer::initialize() - dimen not divisible", a2);
  }
  if (v9 + v9 * v8 + 1 != v5 >> 2) {
    Error::chuck((Error *)"NBlockDiagonalLayer::initialize() - Incorrect data size", a2);
  }
  if ((a4 & 0xF) != 0) {
    Error::chuck((Error *)"NMatrixLayer::initialize() - Unaligned data block", a2);
  }
  if (!v7) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!*a3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = v7;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  *(_DWORD *)(this + 28) = v9;
  *(_DWORD *)(this + 32) = v6;
  *(_DWORD *)(this + 24) = v8;
  return this;
}

void NBlockDiagonalLayer::~NBlockDiagonalLayer(NBlockDiagonalLayer *this)
{
}

void NShiftRegisterLayer::resetState(NShiftRegisterLayer *this, _WORD *a2)
{
  if (!a2) {
    Error::chuck((Error *)"NShiftRegisterLayer::compute() - State uninitialized", 0);
  }
  a2[36] = 1;
  *((_DWORD *)a2 + 9) = 0;
  *((_DWORD *)a2 + 10) = 0;
}

void NShiftRegisterLayer::deallocateState(NShiftRegisterLayer *this, void *a2)
{
  if (a2)
  {
    a2[6] = &unk_26C99C348;
    uint64_t v2 = a2[7];
    if (v2) {
      MEMORY[0x21D46B220](v2, 0x1000C8052888210);
    }
    JUMPOUT(0x21D46B240);
  }
  Error::chuck((Error *)"NShiftRegisterLayer::compute() - State uninitialized", 0);
}

void NShiftRegisterLayer::allocateStateP(NShiftRegisterLayer *this)
{
}

uint64_t NShiftRegisterLayer::compute(NShiftRegisterLayer *this, const float *a2, float *a3, NFrameWindow *a4)
{
  if (!*((void *)this + 2)) {
    Error::chuck((Error *)"NShiftRegisterLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  if (!a4) {
    Error::chuck((Error *)"NShiftRegisterLayer::compute() - State uninitialized", (const char *)a2, a3);
  }
  NFrameWindow::pushFrame(a4, a2);

  return NFrameWindow::setOutputFrameWindow((uint64_t)a4, a3);
}

uint64_t NShiftRegisterLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5 = *a3 / *(_DWORD *)a2;
  if (v5 * *(_DWORD *)a2 != *a3) {
    Error::chuck((Error *)"NShiftRegisterLayer::initialize() - output size must integer-multiple of input", a2);
  }
  if (*a5 != 8) {
    Error::chuck((Error *)"NShiftRegisterLayer::initialize() - Incorrect data size", a2);
  }
  int v6 = *(_DWORD *)a4;
  int v7 = *((_DWORD *)a4 + 1);
  if (*(_DWORD *)a4 + v5 + (v5 - 1) * v7 >= 0x7A121) {
    Error::chuck((Error *)"NShiftRegisterLayer::initialize() - settings result in unreasonable storage requirement", a2);
  }
  if (!*a3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = *(_DWORD *)a2;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  *(_DWORD *)(this + 24) = v6;
  *(_DWORD *)(this + 28) = v7;
  return this;
}

void NShiftRegisterLayer::~NShiftRegisterLayer(NShiftRegisterLayer *this)
{
}

void NSigmoidOnlyLayer::compute(NSigmoidOnlyLayer *this, const float *a2, float *__dst, void *a4)
{
  if (!*((void *)this + 2)) {
    Error::chuck((Error *)"NSigmoidOnlyLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  }
  memcpy(__dst, a2, 4 * *((unsigned int *)this + 3));
  vDSP_vneg(__dst, 1, __dst, 1, *((unsigned int *)this + 3));
  int v7 = *((_DWORD *)this + 3);
  vvexpf(__dst, __dst, &v7);
  float __B = 1.0;
  vDSP_vsadd(__dst, 1, &__B, __dst, 1, *((unsigned int *)this + 3));
  vvrecf(__dst, __dst, &v7);
}

uint64_t NSigmoidOnlyLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != *a3) {
    Error::chuck((Error *)"NSigmoidOnlyLayer::initialize() - input and output size must be the same", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void NSigmoidOnlyLayer::~NSigmoidOnlyLayer(NSigmoidOnlyLayer *this)
{
}

void N8BitMatrixLayer::compute(N8BitMatrixLayer *this, const float *a2, float *a3, void *a4, __n128 a5)
{
  v105[1] = *MEMORY[0x263EF8340];
  int v5 = (char *)*((void *)this + 2);
  if (!v5) {
    Error::chuck((Error *)"N8BitMatrixLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  uint64_t v8 = (*((_DWORD *)this + 8) + *((_DWORD *)this + 2));
  __n128 v9 = MEMORY[0x270FA5388](a5);
  unsigned int v11 = (int8x8_t *)((char *)v105 - v10);
  uint64_t v13 = *(unsigned int *)(v12 + 12);
  MEMORY[0x270FA5388](v9);
  unsigned int v19 = (int32x4_t *)((char *)v105 - ((v18 + 15) & 0x7FFFFFFF0));
  if (v15 >= 0x10)
  {
    unint64_t v20 = v15 >> 4;
    int32x2_t v21 = v14 + 2;
    uint64_t v22 = v11 + 1;
    float32x4_t v23 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    do
    {
      float32x4_t v24 = vmulq_f32(v21[-2], v23);
      float32x4_t v25 = vmulq_f32(v21[-1], v23);
      float32x4_t v26 = *v21;
      float32x4_t v27 = v21[1];
      v21 += 4;
      v22[-1] = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(v24), (int16x8_t)vcvtnq_s32_f32(v25)));
      *uint64_t v22 = vmovn_s16(vuzp1q_s16((int16x8_t)vcvtnq_s32_f32(vmulq_f32(v26, v23)), (int16x8_t)vcvtnq_s32_f32(vmulq_f32(v27, v23))));
      v22 += 2;
      --v20;
    }
    while (v20);
  }
  uint64_t v28 = v15 & 0xFFFFFFF0;
  if ((v15 & 0xFFFFFFF0) < v15)
  {
    uint64_t v29 = v15 - v28;
    int v30 = (char *)v11 + v28;
    unsigned int v31 = (float *)((char *)v14->f32 + ((4 * v15) & 0x3FFFFFFC0));
    do
    {
      float v32 = *v31++;
      *v30++ = (uint64_t)rintf(v32 * 255.0);
      --v29;
    }
    while (v29);
  }
  if (v15 < v8) {
    bzero((char *)v11 + v15, (v16 - 1) + 1);
  }
  if ((v13 & 0xFFFFFFFC) != 0)
  {
    unint64_t v33 = 0;
    uint64_t v34 = (4 * v8);
    int v35 = &v5[(3 * v8)];
    int32x4_t v36 = &v5[(2 * v8)];
    uint64_t v37 = &v5[v8];
    do
    {
      if (v8)
      {
        unint64_t v47 = 0;
        int32x4_t v41 = 0uLL;
        int32x4_t v40 = 0uLL;
        int32x4_t v39 = 0uLL;
        int32x4_t v38 = 0uLL;
        do
        {
          int16x8_t v48 = (int16x8_t)vmovl_u8((uint8x8_t)v11[v47 / 8]);
          int16x8_t v49 = vmovl_s8(*(int8x8_t *)&v5[v47]);
          int16x8_t v50 = vmovl_s8(*(int8x8_t *)&v37[v47]);
          int16x8_t v51 = vmovl_s8(*(int8x8_t *)&v36[v47]);
          int16x8_t v17 = vmovl_s8(*(int8x8_t *)&v35[v47]);
          int32x4_t v41 = vmlal_s16(vmlal_high_s16(v41, v48, v49), *(int16x4_t *)v48.i8, *(int16x4_t *)v49.i8);
          int32x4_t v40 = vmlal_s16(vmlal_high_s16(v40, v48, v50), *(int16x4_t *)v48.i8, *(int16x4_t *)v50.i8);
          int32x4_t v39 = vmlal_s16(vmlal_high_s16(v39, v48, v51), *(int16x4_t *)v48.i8, *(int16x4_t *)v51.i8);
          int32x4_t v38 = vmlal_s16(vmlal_high_s16(v38, v48, v17), *(int16x4_t *)v48.i8, *(int16x4_t *)v17.i8);
          v47 += 8;
        }
        while (v47 < v8);
      }
      else
      {
        int32x4_t v38 = 0uLL;
        int32x4_t v39 = 0uLL;
        int32x4_t v40 = 0uLL;
        int32x4_t v41 = 0uLL;
      }
      int32x4_t v42 = (int32x4_t)vpaddlq_s32(v41);
      int32x4_t v43 = (int32x4_t)vpaddlq_s32(v40);
      int64x2_t v44 = vpaddlq_s32(v39);
      v45.i64[0] = vzip1q_s32(v42, v43).u64[0];
      v45.i32[2] = v44.i32[0];
      int64x2_t v46 = vpaddlq_s32(v38);
      v45.i32[3] = v46.i32[0];
      v42.i64[0] = vzip2q_s32(v42, v43).u64[0];
      v42.i64[1] = __PAIR64__(v46.u32[2], v44.u32[2]);
      *(int32x4_t *)((char *)v19 + 4 * v33) = vaddq_s32(v45, v42);
      v5 += v34;
      v33 += 4;
      v35 += v34;
      v36 += v34;
      v37 += v34;
    }
    while (v33 < (v13 & 0xFFFFFFFC));
  }
  else
  {
    LODWORD(v33) = 0;
  }
  if (v33 >= v13)
  {
LABEL_40:
    if (!v13) {
      return;
    }
  }
  else
  {
    uint64_t v52 = v33;
    if (v8)
    {
      uint64_t v53 = v8 & 0xFFFFFFE0;
      uint64_t v54 = v8 & 0xFFFFFFF8;
      while (1)
      {
        if (v8 < 8)
        {
          uint64_t v55 = 0;
          unsigned int v56 = 0;
          unsigned int v57 = v5;
          goto LABEL_37;
        }
        if (v8 >= 0x20)
        {
          unint64_t v59 = 0;
          int32x4_t v60 = 0uLL;
          int32x4_t v61 = 0uLL;
          int32x4_t v62 = 0uLL;
          int32x4_t v63 = 0uLL;
          int16x8_t v17 = 0uLL;
          int32x4_t v64 = 0uLL;
          int32x4_t v65 = 0uLL;
          int32x4_t v66 = 0uLL;
          do
          {
            int8x16_t v67 = *(int8x16_t *)&v5[v59];
            int8x16_t v68 = *(int8x16_t *)&v5[v59 + 16];
            int16x8_t v69 = vmovl_high_s8(v67);
            int16x8_t v70 = vmovl_s8(*(int8x8_t *)v67.i8);
            int16x8_t v71 = vmovl_high_s8(v68);
            int16x8_t v72 = vmovl_s8(*(int8x8_t *)v68.i8);
            int8x16_t v73 = *(int8x16_t *)v11[v59 / 8].i8;
            int8x16_t v74 = *(int8x16_t *)v11[v59 / 8 + 2].i8;
            int32x4_t v63 = vmlaq_s32(v63, (int32x4_t)vqtbl1q_s8(v73, (int8x16_t)xmmword_21852DEB0), vmovl_high_s16(v69));
            int32x4_t v62 = vmlaq_s32(v62, (int32x4_t)vqtbl1q_s8(v73, (int8x16_t)xmmword_21852DEA0), vmovl_s16(*(int16x4_t *)v69.i8));
            int32x4_t v61 = vmlaq_s32(v61, (int32x4_t)vqtbl1q_s8(v73, (int8x16_t)xmmword_21852DE90), vmovl_high_s16(v70));
            int32x4_t v60 = vmlaq_s32(v60, (int32x4_t)vqtbl1q_s8(v73, (int8x16_t)xmmword_21852DE80), vmovl_s16(*(int16x4_t *)v70.i8));
            int32x4_t v66 = vmlaq_s32(v66, (int32x4_t)vqtbl1q_s8(v74, (int8x16_t)xmmword_21852DEB0), vmovl_high_s16(v71));
            int32x4_t v65 = vmlaq_s32(v65, (int32x4_t)vqtbl1q_s8(v74, (int8x16_t)xmmword_21852DEA0), vmovl_s16(*(int16x4_t *)v71.i8));
            int32x4_t v64 = vmlaq_s32(v64, (int32x4_t)vqtbl1q_s8(v74, (int8x16_t)xmmword_21852DE90), vmovl_high_s16(v72));
            int16x8_t v17 = (int16x8_t)vmlaq_s32((int32x4_t)v17, (int32x4_t)vqtbl1q_s8(v74, (int8x16_t)xmmword_21852DE80), vmovl_s16(*(int16x4_t *)v72.i8));
            v59 += 32;
          }
          while (v53 != v59);
          unsigned int v56 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32((int32x4_t)v17, v60), vaddq_s32(v65, v62)), vaddq_s32(vaddq_s32(v64, v61), vaddq_s32(v66, v63))));
          if (v53 == v8) {
            goto LABEL_22;
          }
          if ((v8 & 0x18) == 0)
          {
            unsigned int v57 = &v5[v53];
            uint64_t v55 = v8 & 0xFFFFFFE0;
            goto LABEL_37;
          }
          uint64_t v58 = v8 & 0xFFFFFFE0;
        }
        else
        {
          unsigned int v56 = 0;
          uint64_t v58 = 0;
        }
        int32x4_t v75 = 0uLL;
        int32x4_t v76 = (int32x4_t)v56;
        do
        {
          int16x8_t v77 = vmovl_s8(*(int8x8_t *)&v5[v58]);
          *(int8x8_t *)v17.i8 = *(int8x8_t *)((char *)v11 + v58);
          int32x4_t v78 = (int32x4_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_21852DE90);
          int16x8_t v17 = (int16x8_t)vqtbl1q_s8((int8x16_t)v17, (int8x16_t)xmmword_21852DE80);
          int32x4_t v75 = vmlaq_s32(v75, v78, vmovl_high_s16(v77));
          int32x4_t v76 = vmlaq_s32(v76, (int32x4_t)v17, vmovl_s16(*(int16x4_t *)v77.i8));
          v58 += 8;
        }
        while (v54 != v58);
        unsigned int v56 = vaddvq_s32(vaddq_s32(v76, v75));
        if (v54 == v8) {
          goto LABEL_22;
        }
        unsigned int v57 = &v5[v54];
        uint64_t v55 = v8 & 0xFFFFFFF8;
LABEL_37:
        uint64_t v79 = v8 - v55;
        uint64_t v80 = (char *)v11 + v55;
        do
        {
          int v82 = *v57++;
          int v81 = v82;
          int v83 = *v80++;
          v56 += v83 * v81;
          --v79;
        }
        while (v79);
LABEL_22:
        v5 += v8;
        v19->i32[v52++] = v56;
        if (v52 == v13) {
          goto LABEL_40;
        }
      }
    }
    bzero((char *)v19 + 4 * v33, 4 * (v13 + ~v33) + 4);
  }
  __int32 v84 = (int32x4_t *)*((void *)this + 3);
  if (v13 <= 7)
  {
    uint64_t v85 = 0;
    goto LABEL_49;
  }
  uint64_t v85 = v13 & 0xFFFFFFF8;
  uint64_t v86 = v19 + 1;
  uint64_t v87 = v84 + 1;
  uint64_t v88 = v85;
  do
  {
    int32x4_t v89 = vaddq_s32(*v86, *v87);
    v86[-1] = vaddq_s32(v86[-1], v87[-1]);
    *uint64_t v86 = v89;
    v86 += 2;
    v87 += 2;
    v88 -= 8;
  }
  while (v88);
  if (v85 != v13)
  {
    __int32 v84 = (int32x4_t *)((char *)v84 + 4 * (v13 & 0xFFFFFFF8));
LABEL_49:
    uint64_t v90 = v13 - v85;
    int v91 = &v19->i8[4 * v85];
    do
    {
      __int32 v92 = v84->i32[0];
      __int32 v84 = (int32x4_t *)((char *)v84 + 4);
      *(_DWORD *)v91 += v92;
      v91 += 4;
      --v90;
    }
    while (v90);
  }
  float v93 = (const float *)((char *)this + 36);
  if (v13 <= 7 || (char *)this + 40 > (char *)a3 && v93 < &a3[v13])
  {
    uint64_t v94 = 0;
LABEL_55:
    uint64_t v95 = v13 - v94;
    uint64_t v96 = v94;
    uint64_t v97 = &a3[v94];
    float v98 = &v19->i32[v96];
    do
    {
      int v99 = *v98++;
      *v97++ = *v93 * (float)v99;
      --v95;
    }
    while (v95);
    return;
  }
  uint64_t v94 = v13 & 0xFFFFFFF8;
  float32x4_t v100 = vld1q_dup_f32(v93);
  size_t v101 = a3 + 4;
  uint64_t v102 = v19 + 1;
  uint64_t v103 = v94;
  do
  {
    float32x4_t v104 = vmulq_f32(v100, vcvtq_f32_s32(*v102));
    *((float32x4_t *)v101 - 1) = vmulq_f32(v100, vcvtq_f32_s32(v102[-1]));
    *(float32x4_t *)size_t v101 = v104;
    v101 += 8;
    v102 += 2;
    v103 -= 8;
  }
  while (v103);
  if (v94 != v13) {
    goto LABEL_55;
  }
}

void N8BitMatrixLayer::~N8BitMatrixLayer(N8BitMatrixLayer *this)
{
}

void NClipLayer::compute(NClipLayer *this, const float *__A, float *__D, void *a4)
{
  if (!*((void *)this + 2)) {
    Error::chuck((Error *)"NClipLayer::compute() - Layer uninitialized", (const char *)__A, __D, a4);
  }
  float __B = 0.0;
  float __C = 1.0;
  vDSP_vclip(__A, 1, &__B, &__C, __D, 1, *((unsigned int *)this + 2));
}

uint64_t NClipLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 != *a3) {
    Error::chuck((Error *)"NClipLayer::initialize() - input and output size must be the same", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void NClipLayer::~NClipLayer(NClipLayer *this)
{
}

uint64_t NMatrixLayer::compute(NMatrixLayer *this, const float *a2, float *__dst, void *a4)
{
  uint64_t v4 = *((void *)this + 2);
  if (!v4) {
    Error::chuck((Error *)"NMatrixLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  }
  memcpy(__dst, (const void *)(v4 + 4 * (*((_DWORD *)this + 2) * *((_DWORD *)this + 3))), 4 * *((unsigned int *)this + 3));
  return cblas_sgemv_NEWLAPACK_ILP64();
}

uint64_t NMatrixLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  int v6 = *a3;
  if (v6 + v6 * *(_DWORD *)a2 != *a5 >> 2) {
    Error::chuck((Error *)"NMatrixLayer::initialize() - Incorrect data size", a2);
  }
  if ((a4 & 0xF) != 0) {
    Error::chuck((Error *)"NMatrixLayer::initialize() - Unaligned data block", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!v6) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void NMatrixLayer::~NMatrixLayer(NMatrixLayer *this)
{
}

void N8BitLogSoftmaxLayer::compute(N8BitLogSoftmaxLayer *this, const float *a2, float32x4_t *a3, void *a4, __n128 a5)
{
  N8BitMatrixLayer::compute(this, a2, a3->f32, a4, a5);
  uint64_t v7 = *((unsigned int *)this + 3);
  float v8 = a3->f32[0];
  if (v7 >= 2)
  {
    uint64_t v9 = v7 - 1;
    uint64_t v10 = &a3->f32[1];
    do
    {
      float v11 = *v10++;
      float v12 = v11;
      if (v11 > v8) {
        float v8 = v12;
      }
      --v9;
    }
    while (v9);
  }
  if (!v7) {
    return;
  }
  if (v7 == 1)
  {
    uint64_t v13 = 0;
    float v14 = 0.0;
  }
  else
  {
    uint64_t v13 = v7 & 0xFFFFFFFE;
    unint64_t v15 = &a3->f32[1];
    float v14 = 0.0;
    uint64_t v16 = v13;
    do
    {
      float v17 = *v15 - v8;
      float v18 = expf(*(v15 - 1) - v8);
      float v14 = (float)(v14 + v18) + expf(v17);
      v15 += 2;
      v16 -= 2;
    }
    while (v16);
    if (v13 == v7) {
      goto LABEL_14;
    }
  }
  uint64_t v19 = v7 - v13;
  unint64_t v20 = &a3->f32[v13];
  do
  {
    float v21 = *v20++;
    float v14 = v14 + expf(v21 - v8);
    --v19;
  }
  while (v19);
LABEL_14:
  *(float *)v22.i32 = v8 + logf(v14);
  if (v7 < 8)
  {
    uint64_t v23 = 0;
LABEL_19:
    uint64_t v28 = v7 - v23;
    uint64_t v29 = &a3->f32[v23];
    do
    {
      *uint64_t v29 = *v29 - *(float *)v22.i32;
      ++v29;
      --v28;
    }
    while (v28);
    return;
  }
  uint64_t v23 = v7 & 0xFFFFFFF8;
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32(v22, 0);
  float32x4_t v25 = a3 + 1;
  uint64_t v26 = v23;
  do
  {
    float32x4_t v27 = vsubq_f32(*v25, v24);
    v25[-1] = vsubq_f32(v25[-1], v24);
    *float32x4_t v25 = v27;
    v25 += 2;
    v26 -= 8;
  }
  while (v26);
  if (v23 != v7) {
    goto LABEL_19;
  }
}

void N8BitLogSoftmaxLayer::~N8BitLogSoftmaxLayer(N8BitLogSoftmaxLayer *this)
{
}

void N8BitSigmoidalLayer::compute(N8BitSigmoidalLayer *this, const float *a2, float *a3, void *a4, __n128 a5)
{
  N8BitMatrixLayer::compute(this, a2, a3, a4, a5);
  vDSP_vneg(a3, 1, a3, 1, *((unsigned int *)this + 3));
  int v8 = *((_DWORD *)this + 3);
  vvexpf(a3, a3, &v8);
  float __B = 1.0;
  vDSP_vsadd(a3, 1, &__B, a3, 1, *((unsigned int *)this + 3));
  vvrecf(a3, a3, &v8);
}

void N8BitSigmoidalLayer::~N8BitSigmoidalLayer(N8BitSigmoidalLayer *this)
{
}

uint64_t NFixLogSoftmaxLayer::compute(uint64_t this, const char *a2, int *a3)
{
  unint64_t v3 = *(int16x8_t **)(this + 16);
  if (!v3) {
    Error::chuck((Error *)"NFixMatrixBaseLayer::compute() - Layer uninitialized", a2, a3);
  }
  LODWORD(v4) = *(_DWORD *)(this + 12);
  if (v4)
  {
    unint64_t v5 = 0;
    while (1)
    {
      uint64_t v8 = *(unsigned int *)(this + 8);
      if (v8) {
        break;
      }
      int v6 = 0;
LABEL_5:
      a3[v5++] = v6;
      unint64_t v7 = *(unsigned int *)(this + 12);
      if (v5 >= v7)
      {
        if (v7)
        {
          unint64_t v32 = 0;
          do
          {
            a3[v32] += (0x7FFF * v3->i16[v32]) >> *(_DWORD *)(this + 24);
            ++v32;
            unint64_t v4 = *(unsigned int *)(this + 12);
          }
          while (v32 < v4);
        }
        else
        {
          LODWORD(v4) = 0;
        }
        goto LABEL_21;
      }
    }
    unsigned int v9 = *(_DWORD *)(this + 24);
    if (v8 > 0xF)
    {
      uint64_t v10 = v8 & 0xFFFFFFF0;
      int32x4_t v12 = vdupq_n_s32(v9);
      uint64_t v13 = v3 + 1;
      int32x4_t v14 = 0uLL;
      unint64_t v15 = (const int *)(a2 + 32);
      uint64_t v16 = v10;
      int32x4_t v17 = 0uLL;
      int32x4_t v18 = 0uLL;
      int32x4_t v19 = 0uLL;
      do
      {
        int16x8_t v20 = v13[-1];
        int32x4_t v21 = *((int32x4_t *)v15 - 2);
        int32x4_t v22 = *((int32x4_t *)v15 - 1);
        int32x4_t v23 = *(int32x4_t *)v15;
        int32x4_t v24 = *((int32x4_t *)v15 + 1);
        v15 += 16;
        int32x4_t v25 = vmulq_s32(v21, vmovl_s16(*(int16x4_t *)v20.i8));
        int32x4_t v26 = vnegq_s32(v12);
        int32x4_t v17 = vaddq_s32(vshlq_s32(vmulq_s32(v22, vmovl_high_s16(v20)), v26), v17);
        int32x4_t v14 = vaddq_s32(vshlq_s32(v25, v26), v14);
        int32x4_t v19 = vaddq_s32(vshlq_s32(vmulq_s32(v24, vmovl_high_s16(*v13)), v26), v19);
        int32x4_t v18 = vaddq_s32(vshlq_s32(vmulq_s32(v23, vmovl_s16(*(int16x4_t *)v13->i8)), v26), v18);
        v13 += 2;
        v16 -= 16;
      }
      while (v16);
      int v6 = vaddvq_s32(vaddq_s32(vaddq_s32(v18, v14), vaddq_s32(v19, v17)));
      if (v10 == v8) {
        goto LABEL_15;
      }
      float v11 = (int16x8_t *)((char *)v3 + 2 * (v8 & 0xFFFFFFF0));
    }
    else
    {
      uint64_t v10 = 0;
      int v6 = 0;
      float v11 = v3;
    }
    uint64_t v27 = v8 - v10;
    uint64_t v28 = (const int *)&a2[4 * v10];
    do
    {
      int v30 = v11->i16[0];
      float v11 = (int16x8_t *)((char *)v11 + 2);
      int v29 = v30;
      int v31 = *v28++;
      v6 += (v31 * v29) >> v9;
      --v27;
    }
    while (v27);
LABEL_15:
    unint64_t v3 = (int16x8_t *)((char *)v3 + 2 * (v8 - 1) + 2);
    goto LABEL_5;
  }
LABEL_21:
  int v33 = *(_DWORD *)(this + 28) - *(_DWORD *)(this + 24);
  uint64_t v34 = *(void *)(this + 32);
  int v35 = v33 - *(_DWORD *)(v34 + 12) + 15;
  int v36 = *a3 >> (*(unsigned char *)(this + 28) - *(unsigned char *)(this + 24) - *(unsigned char *)(v34 + 12) + 15);
  if (v4 >= 2)
  {
    unsigned int v37 = *(_DWORD *)(v34 + 4);
    uint64_t v38 = v4 - 1;
    int32x4_t v39 = a3 + 1;
    do
    {
      int v41 = *v39++;
      int v42 = v41 >> v35;
      unsigned int v43 = v36 - (v41 >> v35);
      if (v36 <= v41 >> v35)
      {
        unsigned int v44 = (v42 - v36) >> 1;
        if (v44 < v37) {
          int v40 = *(__int16 *)(*(void *)(v34 + 24) + 2 * v44);
        }
        else {
          int v40 = 0;
        }
        int v36 = v40 + v42;
      }
      else if (v43 >> 1 < v37)
      {
        v36 += *(__int16 *)(*(void *)(v34 + 24) + 2 * (v43 >> 1));
      }
      --v38;
    }
    while (v38);
  }
  if (v4)
  {
    unint64_t v45 = 0;
    int v46 = v36 << (15 - *(unsigned char *)(v34 + 12));
    do
    {
      a3[v45] = (a3[v45] >> v33) - v46;
      ++v45;
    }
    while (v45 < *(unsigned int *)(this + 12));
  }
  return this;
}

void NBaseLayer::compute(NBaseLayer *this, const float *a2, float *a3, void *a4)
{
}

uint64_t NFixMatrixBaseLayer::initialize(uint64_t this, const char *a2, unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5 = *a5 >> 1;
  int v6 = *(_DWORD *)a2;
  unsigned int v7 = *a3;
  if (v5 != v7 + v7 * *(_DWORD *)a2 + 1) {
    Error::chuck((Error *)"NFixMatrixBaseLayer::initialize() - Incorrect data size", a2);
  }
  if (!v6) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  if (!v7) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size output", a2);
  }
  *(_DWORD *)(this + 8) = v6;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  unsigned int v8 = *a3;
  if (*a3)
  {
    int v9 = 0;
    do
    {
      ++v9;
      BOOL v10 = v8 > 1;
      v8 >>= 1;
    }
    while (v10);
  }
  else
  {
    int v9 = 0;
  }
  int v11 = *(__int16 *)&a4[2 * v5 - 2];
  *(_DWORD *)(this + 24) = v9;
  *(_DWORD *)(this + 28) = v11;
  return this;
}

void NFixLogSoftmaxLayer::~NFixLogSoftmaxLayer(NFixLogSoftmaxLayer *this)
{
}

uint64_t NFixSigmoidalLayer::compute(uint64_t this, const char *a2, int *a3)
{
  unint64_t v3 = *(int16x8_t **)(this + 16);
  if (!v3) {
    Error::chuck((Error *)"NFixMatrixBaseLayer::compute() - Layer uninitialized", a2, a3);
  }
  if (*(_DWORD *)(this + 12))
  {
    unint64_t v4 = 0;
    while (1)
    {
      uint64_t v7 = *(unsigned int *)(this + 8);
      if (v7) {
        break;
      }
      int v5 = 0;
LABEL_5:
      a3[v4++] = v5;
      unint64_t v6 = *(unsigned int *)(this + 12);
      if (v4 >= v6)
      {
        if (v6)
        {
          unint64_t v31 = 0;
          do
          {
            a3[v31] += (0x7FFF * v3->i16[v31]) >> *(_DWORD *)(this + 24);
            ++v31;
            unint64_t v32 = *(unsigned int *)(this + 12);
          }
          while (v31 < v32);
          if (v32)
          {
            unint64_t v33 = 0;
            uint64_t v34 = *(void *)(this + 32);
            int v35 = *(_DWORD *)(this + 28) - *(_DWORD *)(this + 24) - *(_DWORD *)(v34 + 12) + 15;
            do
            {
              unsigned int v37 = a3[v33] >> v35;
              if ((v37 & 0x80000000) != 0)
              {
                int v36 = 0;
                unsigned int v38 = -v37;
                if (*(_DWORD *)(v34 + 4) > v38) {
                  int v36 = 0x7FFF - *(__int16 *)(*(void *)(v34 + 24) + 2 * v38);
                }
              }
              else if (v37 < *(_DWORD *)(v34 + 4))
              {
                int v36 = *(__int16 *)(*(void *)(v34 + 24) + 2 * v37);
              }
              else
              {
                int v36 = 0x7FFF;
              }
              a3[v33++] = v36;
            }
            while (v33 < *(unsigned int *)(this + 12));
          }
        }
        return this;
      }
    }
    unsigned int v8 = *(_DWORD *)(this + 24);
    if (v7 > 0xF)
    {
      uint64_t v9 = v7 & 0xFFFFFFF0;
      int32x4_t v11 = vdupq_n_s32(v8);
      int32x4_t v12 = v3 + 1;
      int32x4_t v13 = 0uLL;
      int32x4_t v14 = (const int *)(a2 + 32);
      uint64_t v15 = v9;
      int32x4_t v16 = 0uLL;
      int32x4_t v17 = 0uLL;
      int32x4_t v18 = 0uLL;
      do
      {
        int16x8_t v19 = v12[-1];
        int32x4_t v20 = *((int32x4_t *)v14 - 2);
        int32x4_t v21 = *((int32x4_t *)v14 - 1);
        int32x4_t v22 = *(int32x4_t *)v14;
        int32x4_t v23 = *((int32x4_t *)v14 + 1);
        v14 += 16;
        int32x4_t v24 = vmulq_s32(v20, vmovl_s16(*(int16x4_t *)v19.i8));
        int32x4_t v25 = vnegq_s32(v11);
        int32x4_t v16 = vaddq_s32(vshlq_s32(vmulq_s32(v21, vmovl_high_s16(v19)), v25), v16);
        int32x4_t v13 = vaddq_s32(vshlq_s32(v24, v25), v13);
        int32x4_t v18 = vaddq_s32(vshlq_s32(vmulq_s32(v23, vmovl_high_s16(*v12)), v25), v18);
        int32x4_t v17 = vaddq_s32(vshlq_s32(vmulq_s32(v22, vmovl_s16(*(int16x4_t *)v12->i8)), v25), v17);
        v12 += 2;
        v15 -= 16;
      }
      while (v15);
      int v5 = vaddvq_s32(vaddq_s32(vaddq_s32(v17, v13), vaddq_s32(v18, v16)));
      if (v9 == v7) {
        goto LABEL_15;
      }
      BOOL v10 = (int16x8_t *)((char *)v3 + 2 * (v7 & 0xFFFFFFF0));
    }
    else
    {
      uint64_t v9 = 0;
      int v5 = 0;
      BOOL v10 = v3;
    }
    uint64_t v26 = v7 - v9;
    uint64_t v27 = (const int *)&a2[4 * v9];
    do
    {
      int v29 = v10->i16[0];
      BOOL v10 = (int16x8_t *)((char *)v10 + 2);
      int v28 = v29;
      int v30 = *v27++;
      v5 += (v30 * v28) >> v8;
      --v26;
    }
    while (v26);
LABEL_15:
    unint64_t v3 = (int16x8_t *)((char *)v3 + 2 * (v7 - 1) + 2);
    goto LABEL_5;
  }
  return this;
}

void NFixSigmoidalLayer::~NFixSigmoidalLayer(NFixSigmoidalLayer *this)
{
}

void NOffsetLayer::compute(NOffsetLayer *this, const float *__A, float *__C, void *a4)
{
  int v5 = (const float *)*((void *)this + 2);
  if (!v5) {
    Error::chuck((Error *)"NOffsetLayer::compute() - Layer uninitialized", (const char *)__A, 0, a4, __C);
  }
  vDSP_Length v6 = *((unsigned int *)this + 2);

  vDSP_vadd(__A, 1, v5, 1, __C, 1, v6);
}

uint64_t NOffsetLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  unsigned int v5 = *a5 >> 2;
  if (v5 != *(_DWORD *)a2) {
    Error::chuck((Error *)"NOffsetLayer::initialize() - Incorrect data size", a2, a3, a4);
  }
  if (v5 != *a3) {
    Error::chuck((Error *)"NOffsetLayer::initialize() - Input and output not same", a2);
  }
  if (*a5 <= 3) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void NOffsetLayer::~NOffsetLayer(NOffsetLayer *this)
{
}

float32_t NNormalizationLayer::compute(NNormalizationLayer *this, float32x4_t *a2, const float *a3, void *a4)
{
  unint64_t v4 = (float *)*((void *)this + 2);
  if (!v4) {
    Error::chuck((Error *)"NNormalizationLayer::compute() - Layer uninitialized", (const char *)a2, a3, a4);
  }
  uint64_t v5 = *((unsigned int *)this + 2);
  if (v5)
  {
    if (v5 <= 7)
    {
      uint64_t v6 = 0;
      goto LABEL_20;
    }
    uint64_t v6 = 0;
    uint64_t v7 = (float *)&a3[v5];
    BOOL v9 = &v4[2 * v5] > a3 && v4 < v7;
    BOOL v10 = v7 > (float *)a2 && &a2->f32[v5] > a3;
    if (v10 || v9) {
      goto LABEL_20;
    }
    uint64_t v6 = v5 & 0xFFFFFFF8;
    int32x4_t v11 = (float32x4_t *)(a3 + 4);
    int32x4_t v12 = a2 + 1;
    int32x4_t v13 = v4 + 8;
    uint64_t v14 = v6;
    do
    {
      uint64_t v15 = v13 - 8;
      float32x4x2_t v25 = vld2q_f32(v15);
      float32x4x2_t v26 = vld2q_f32(v13);
      float32x4_t v16 = vmulq_f32(vaddq_f32(v12[-1], v25.val[0]), v25.val[1]);
      v25.val[1] = vmulq_f32(vaddq_f32(*v12, v26.val[0]), v26.val[1]);
      v11[-1] = v16;
      *int32x4_t v11 = v25.val[1];
      v11 += 2;
      v12 += 2;
      v13 += 16;
      v14 -= 8;
    }
    while (v14);
    if (v6 != v5)
    {
      v4 += 2 * (v5 & 0xFFFFFFF8);
LABEL_20:
      uint64_t v17 = v5 - v6;
      uint64_t v18 = v6;
      int16x8_t v19 = (float *)&a3[v6];
      int32x4_t v20 = &a2->f32[v18];
      do
      {
        float v21 = *v20++;
        float v22 = *v4;
        float v23 = v4[1];
        v4 += 2;
        v16.f32[0] = (float)(v21 + v22) * v23;
        *v19++ = v16.f32[0];
        --v17;
      }
      while (v17);
    }
  }
  return v16.f32[0];
}

uint64_t NNormalizationLayer::initialize(uint64_t this, const char *a2, const unsigned int *a3, const char *a4, const unsigned int *a5)
{
  int v5 = *(_DWORD *)a2;
  if (*a5 >> 2 != 2 * *(_DWORD *)a2) {
    Error::chuck((Error *)"NNormalizationLayer::initialize() - Incorrect data size", a2, a3, a4);
  }
  if (v5 != *a3) {
    Error::chuck((Error *)"NNormalizationLayer::initialize() - Input and output not same size", a2);
  }
  if (!v5) {
    Error::chuck((Error *)"NBaseLayer::initialize() - Zero size input", a2);
  }
  *(_DWORD *)(this + 8) = v5;
  *(_DWORD *)(this + 12) = *a3;
  *(void *)(this + 16) = a4;
  return this;
}

void NNormalizationLayer::~NNormalizationLayer(NNormalizationLayer *this)
{
}

void NLogSoftmaxLayer::compute(NLogSoftmaxLayer *this, const float *a2, float32x4_t *__dst, void *a4)
{
  uint64_t v4 = *((void *)this + 2);
  if (!v4) {
    Error::chuck((Error *)"NMatrixLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  }
  memcpy(__dst, (const void *)(v4 + 4 * (*((_DWORD *)this + 2) * *((_DWORD *)this + 3))), 4 * *((unsigned int *)this + 3));
  cblas_sgemv_NEWLAPACK_ILP64();
  uint64_t v7 = *((unsigned int *)this + 3);
  float v8 = __dst->f32[0];
  if (v7 >= 2)
  {
    uint64_t v9 = v7 - 1;
    BOOL v10 = &__dst->f32[1];
    do
    {
      float v11 = *v10++;
      float v12 = v11;
      if (v11 > v8) {
        float v8 = v12;
      }
      --v9;
    }
    while (v9);
  }
  if (!v7) {
    return;
  }
  if (v7 == 1)
  {
    uint64_t v13 = 0;
    float v14 = 0.0;
  }
  else
  {
    uint64_t v13 = v7 & 0xFFFFFFFE;
    uint64_t v15 = &__dst->f32[1];
    float v14 = 0.0;
    uint64_t v16 = v13;
    do
    {
      float v17 = *v15 - v8;
      float v18 = expf(*(v15 - 1) - v8);
      float v14 = (float)(v14 + v18) + expf(v17);
      v15 += 2;
      v16 -= 2;
    }
    while (v16);
    if (v13 == v7) {
      goto LABEL_15;
    }
  }
  uint64_t v19 = v7 - v13;
  int32x4_t v20 = &__dst->f32[v13];
  do
  {
    float v21 = *v20++;
    float v14 = v14 + expf(v21 - v8);
    --v19;
  }
  while (v19);
LABEL_15:
  *(float *)v22.i32 = v8 + logf(v14);
  if (v7 < 8)
  {
    uint64_t v23 = 0;
LABEL_20:
    uint64_t v28 = v7 - v23;
    int v29 = &__dst->f32[v23];
    do
    {
      *int v29 = *v29 - *(float *)v22.i32;
      ++v29;
      --v28;
    }
    while (v28);
    return;
  }
  uint64_t v23 = v7 & 0xFFFFFFF8;
  float32x4_t v24 = (float32x4_t)vdupq_lane_s32(v22, 0);
  float32x4x2_t v25 = __dst + 1;
  uint64_t v26 = v23;
  do
  {
    float32x4_t v27 = vsubq_f32(*v25, v24);
    v25[-1] = vsubq_f32(v25[-1], v24);
    *float32x4x2_t v25 = v27;
    v25 += 2;
    v26 -= 8;
  }
  while (v26);
  if (v23 != v7) {
    goto LABEL_20;
  }
}

void NLogSoftmaxLayer::~NLogSoftmaxLayer(NLogSoftmaxLayer *this)
{
}

void NSigmoidalLayer::compute(NSigmoidalLayer *this, const float *a2, float *__dst, void *a4)
{
  uint64_t v4 = *((void *)this + 2);
  if (!v4) {
    Error::chuck((Error *)"NMatrixLayer::compute() - Layer uninitialized", (const char *)a2, __dst, a4);
  }
  memcpy(__dst, (const void *)(v4 + 4 * (*((_DWORD *)this + 2) * *((_DWORD *)this + 3))), 4 * *((unsigned int *)this + 3));
  cblas_sgemv_NEWLAPACK_ILP64();
  vDSP_vneg(__dst, 1, __dst, 1, *((unsigned int *)this + 3));
  int v8 = *((_DWORD *)this + 3);
  vvexpf(__dst, __dst, &v8);
  float __B = 1.0;
  vDSP_vsadd(__dst, 1, &__B, __dst, 1, *((unsigned int *)this + 3));
  vvrecf(__dst, __dst, &v8);
}

void NSigmoidalLayer::~NSigmoidalLayer(NSigmoidalLayer *this)
{
}

uint64_t NSmartPointer<NBaseLayer>::setPointer(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 8);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  *(void *)(a1 + 8) = a2;
  return result;
}

void NSmartPointer<NBaseLayer>::~NSmartPointer(void *a1)
{
  *a1 = &unk_26C99AA50;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x21D46B240);
}

void *NSmartPointer<NBaseLayer>::~NSmartPointer(void *a1)
{
  *a1 = &unk_26C99AA50;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void NLayer::~NLayer(NLayer *this)
{
  *(void *)this = &unk_26C99AA50;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99AA50;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

uint64_t NDeepnetDistribution::scoreCacheTypes(NDeepnetDistribution *this)
{
  return 4;
}

uint64_t NDeepnetDistribution::frameSize(NDeepnetDistribution *this)
{
  return (uint64_t)this + 20;
}

uint64_t NDeepnetDistribution::numFrames(NDeepnetDistribution *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t NDeepnetDistribution::dimen(NDeepnetDistribution *this)
{
  return (uint64_t)this + 12;
}

uint64_t NDeepnetDistribution::size(NDeepnetDistribution *this)
{
  return *((unsigned int *)this + 2);
}

void NDeepnetDistribution::~NDeepnetDistribution(NDeepnetDistribution *this)
{
  NDeepnetDistribution::~NDeepnetDistribution(this);

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;

  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C99B470;
  *((_DWORD *)this + 6) = 0;
  BOOL v10 = 0;
  NArray<NLayer>::resize((uint64_t)this + 32, &v10);
  uint64_t v2 = *((void *)this + 7);
  float v11 = 0;
  (*(void (**)(char *, const char *, int *))(v2 + 64))((char *)this + 56, "", &v11);
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 13) = 0;
  unint64_t v3 = *((unsigned int *)this + 36);
  if (v3) {
    munmap(*((void **)this + 19), v3);
  }
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 19) = 0;
  float v12 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 14) + 64))((char *)this + 112, "", &v12);
  *((void *)this + 43) = &unk_26C99C428;
  uint64_t v4 = *((void *)this + 44);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C80BDFB0063);
  }
  *((void *)this + 38) = &unk_26C99C428;
  int v5 = *((void *)this + 39);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C80BDFB0063);
  }
  NFixedPointScales::~NFixedPointScales((NDeepnetDistribution *)((char *)this + 160));
  NLoadedMemory::~NLoadedMemory((NDeepnetDistribution *)((char *)this + 88));
  *((void *)this + 7) = &unk_26C99B388;
  free(*((void **)this + 9));
  *((void *)this + 9) = 0;
  *((void *)this + 7) = &unk_26C99C5B0;
  uint64_t v6 = *((void *)this + 5);
  *((void *)this + 4) = &unk_26C99C070;
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 - 8);
    if (v7)
    {
      int v8 = 16 * v7;
      do
      {
        *(void *)(v6 + v8 - 16) = &unk_26C99AA50;
        uint64_t v9 = *(void *)(v6 + v8 - 8);
        if (v9) {
          (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
        }
        v8 -= 16;
      }
      while (v8);
    }
    MEMORY[0x21D46B220](v6 - 16, 0xA1C80BD48D6D6);
  }
}

uint64_t NArray<NLayer>::fromArray(uint64_t result, const char *a2, int *a3)
{
  int v3 = *(_DWORD *)(result + 16);
  int v4 = *a3;
  if (v3 != *a3)
  {
    uint64_t v5 = result;
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      uint64_t v8 = *(void *)(v6 - 8);
      if (v8)
      {
        uint64_t v9 = 16 * v8;
        do
        {
          *(void *)(v6 + v9 - 16) = &unk_26C99AA50;
          uint64_t v10 = *(void *)(v6 + v9 - 8);
          if (v10) {
            (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
          }
          v9 -= 16;
        }
        while (v9);
      }
      MEMORY[0x21D46B220](v6 - 16, 0xA1C80BD48D6D6);
      int v4 = *a3;
    }
    *(_DWORD *)(v5 + 16) = v4;
    operator new[]();
  }
  if (v3) {
    Error::chuck((Error *)"NLayer::operator=() - attempting to copy layer prohibited", a2);
  }
  return result;
}

uint64_t NArray<NLayer>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 16 * v7;
          do
          {
            *(void *)(v6 + v8 - 16) = &unk_26C99AA50;
            uint64_t v9 = *(void *)(v6 + v8 - 8);
            if (v9) {
              (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
            }
            v8 -= 16;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0xA1C80BD48D6D6);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4) {
      Error::chuck((Error *)"NLayer::operator=() - attempting to copy layer prohibited", (const char *)a2);
    }
  }
  return result;
}

void NArray<NLayer>::~NArray(void *a1)
{
  *a1 = &unk_26C99C070;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 16 * v2;
      do
      {
        *(void *)(v1 + v3 - 16) = &unk_26C99AA50;
        uint64_t v4 = *(void *)(v1 + v3 - 8);
        if (v4) {
          (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
        }
        v3 -= 16;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0xA1C80BD48D6D6);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NLayer>::~NArray(void *a1)
{
  *a1 = &unk_26C99C070;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 16 * v3;
      do
      {
        *(void *)(v2 + v4 - 16) = &unk_26C99AA50;
        uint64_t v5 = *(void *)(v2 + v4 - 8);
        if (v5) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
        v4 -= 16;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0xA1C80BD48D6D6);
  }
  return a1;
}

void NDeepnetDistribution::NDeepnetDistribution(NDeepnetDistribution *this)
{
  *(void *)this = &unk_26C99B470;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 4) = &unk_26C99C070;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 7) = &unk_26C99B388;
  *((_DWORD *)this + 20) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 20));
  }
  uint64_t v3 = memptr;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = v3;
  *((void *)this + 7) = &unk_26C99B388;
  *uint64_t v3 = 0;
  *((void *)this + 11) = &unk_26C99AA30;
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = &unk_26C99B388;
  *((_DWORD *)this + 34) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v4, 1, *((unsigned int *)this + 34));
  }
  uint64_t v5 = memptr;
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 16) = v5;
  *((void *)this + 14) = &unk_26C99B388;
  *uint64_t v5 = 0;
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = &unk_26C99AE78;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 22) = &unk_26C99C3B8;
  *((void *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = &unk_26C99C348;
  *((void *)this + 27) = 0;
  *((_DWORD *)this + 56) = 0;
  *((void *)this + 29) = &unk_26C99C348;
  *((void *)this + 30) = 0;
  *((_DWORD *)this + 62) = 0;
  *((void *)this + 32) = &unk_26C99C348;
  *((void *)this + 33) = 0;
  *((_DWORD *)this + 68) = 0;
  *((unsigned char *)this + 280) = 0;
  *((void *)this + 36) = 0;
  *((void *)this + 37) = 0;
  *((void *)this + 38) = &unk_26C99C428;
  *((void *)this + 39) = 0;
  *((_DWORD *)this + 80) = 0;
  *((void *)this + 41) = 0;
  *((void *)this + 42) = 0;
  *((void *)this + 43) = &unk_26C99C428;
  *((void *)this + 44) = 0;
  *((_DWORD *)this + 90) = 0;
  *((_WORD *)this + 184) = 0;
  *((unsigned char *)this + 376) = 0;
}

void sub_2184AE4F4(_Unwind_Exception *a1)
{
  N16ByteAlignedString::~N16ByteAlignedString(v2);
  NArray<NLayer>::~NArray(v1);
  _Unwind_Resume(a1);
}

uint64_t NDeepnetDistribution::reset(NDeepnetDistribution *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  int v4 = 0;
  NArray<NLayer>::resize((uint64_t)this + 32, &v4);
  int v5 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 7) + 64))((char *)this + 56, "", &v5);
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 13) = 0;
  size_t v2 = *((unsigned int *)this + 36);
  if (v2) {
    munmap(*((void **)this + 19), v2);
  }
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 19) = 0;
  int v6 = 0;
  return (*(uint64_t (**)(char *, const char *, int *))(*((void *)this + 14) + 64))((char *)this + 112, "", &v6);
}

uint64_t NDeepnetDistribution::verifyMemoryImage(NDeepnetDistribution *this, const char *a2, const unsigned int *a3)
{
  if (!this) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v3 = *(unsigned int *)a2;
  if (v3 < 0x34) {
    return 4294967294;
  }
  if (*(void *)this != 0x20624C4E4E442023 || *((void *)this + 1) != 0xA0A0A30302E3176) {
    return 4294967293;
  }
  int v7 = *((_DWORD *)this + 4);
  uint64_t v8 = *((unsigned int *)this + 5);
  int v10 = *((_DWORD *)this + 6);
  int v9 = *((_DWORD *)this + 7);
  int v11 = *((_DWORD *)this + 8);
  uint64_t v12 = *((unsigned int *)this + 9);
  int v13 = *((_DWORD *)this + 10);
  int v14 = *((_DWORD *)this + 11);
  if ((v7 & 0xF) == 2)
  {
    BOOL v15 = (v7 & 0xFE00) == 0;
    uint64_t v5 = 4294967291;
    if (v10) {
      return v5;
    }
    goto LABEL_16;
  }
  if (v7 != 1) {
    return 4294967292;
  }
  BOOL v15 = 1;
  uint64_t v5 = 4294967291;
  if (v10) {
    return v5;
  }
LABEL_16:
  if (!v15) {
    return v5;
  }
  if (!v12) {
    return 4294967290;
  }
  if (v12 > 0x4000000) {
    return 4294967289;
  }
  uint64_t v16 = (char *)this + v3;
  float v17 = (char *)this + *((_DWORD *)this + 12) + (-*((_DWORD *)this + 12) & 3u) + 52;
  if (v17 > v16) {
    return 4294967288;
  }
  if ((v10 & 0x20) != 0)
  {
    v17 += (4 * v14) + 4;
    if (v17 > v16) {
      return 4294967287;
    }
  }
  float v18 = &v17[16 * v12];
  if (v18 > v16) {
    return 4294967286;
  }
  uint64_t v19 = &v18[v8];
  if (v19 > v16) {
    return 4294967285;
  }
  if (v19 != v16) {
    return 4294967284;
  }
  int v20 = 4 * v12;
  float v21 = v17 + 12;
  do
  {
    unsigned int v22 = *(v21 - 1);
    unsigned int v23 = *v21 + v22;
    if (v23 > v8 || v23 < v22) {
      return 4294967283;
    }
    v21 += 4;
    --v12;
  }
  while (v12);
  int v25 = *(_DWORD *)&v17[4 * (v20 - 3)];
  if (v14 * v13 == v9) {
    unsigned int v26 = 0;
  }
  else {
    unsigned int v26 = -15;
  }
  if (v25 == v11) {
    return v26;
  }
  else {
    return 4294967282;
  }
}

void NDeepnetDistribution::init(NDeepnetDistribution *this, const char *a2, const unsigned int *a3)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  int v7 = 0;
  NArray<NLayer>::resize((uint64_t)this + 32, &v7);
  int v8 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 7) + 64))((char *)this + 56, "", &v8);
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 13) = 0;
  size_t v6 = *((unsigned int *)this + 36);
  if (v6) {
    munmap(*((void **)this + 19), v6);
  }
  *((_DWORD *)this + 36) = 0;
  *((void *)this + 19) = 0;
  int v9 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 14) + 64))((char *)this + 112, "", &v9);
  NDeepnetDistribution::mapFromMemory(this, a2, a3, "Blob");
}

uint64_t NDeepnetDistribution::loadFixedInputLayer(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(result + 12))
  {
    unint64_t v3 = 0;
    uint64_t v4 = *(void *)(a2 + 8);
    uint64_t v5 = *(void *)(result + 216);
    do
    {
      float v6 = *(float *)(v4 + 4 * v3) * *(float *)(v5 + 4 * v3);
      if (v6 > 32767.0) {
        float v6 = 32767.0;
      }
      if (v6 < -32768.0) {
        float v6 = -32768.0;
      }
      *(_DWORD *)(a3 + 4 * v3++) = (uint64_t)rintf(v6);
    }
    while (v3 < *(unsigned int *)(result + 12));
  }
  return result;
}

uint64_t NDeepnetDistribution::extractFixedOutputLayer(uint64_t result, int32x4_t *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(result + 8);
  if (v3)
  {
    uint64_t v4 = *(float32x4_t **)(a3 + 8);
    if (v3 < 8)
    {
      uint64_t v5 = 0;
LABEL_7:
      uint64_t v11 = v3 - v5;
      uint64_t v12 = v5;
      int v13 = &v4->f32[v12];
      int v14 = &a2->i32[v12];
      do
      {
        int v15 = *v14++;
        *v13++ = (float)v15 * 0.000030518;
        --v11;
      }
      while (v11);
      return result;
    }
    uint64_t v5 = v3 & 0xFFFFFFF8;
    float v6 = v4 + 1;
    int v7 = a2 + 1;
    v8.i64[0] = 0x3800000038000000;
    v8.i64[1] = 0x3800000038000000;
    uint64_t v9 = v5;
    do
    {
      float32x4_t v10 = vmulq_f32(vcvtq_f32_s32(*v7), v8);
      v6[-1] = vmulq_f32(vcvtq_f32_s32(v7[-1]), v8);
      *float v6 = v10;
      v6 += 2;
      v7 += 2;
      v9 -= 8;
    }
    while (v9);
    if (v5 != v3) {
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t NMemoryFile::getPosition(NMemoryFile *this)
{
  if (((*(uint64_t (**)(NMemoryFile *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NMemoryFile::getPosition() - cannot get position, file %s is not open", v2, *((void *)this + 3));
  }
  return (*((_DWORD *)this + 14) - *((_DWORD *)this + 10));
}

uint64_t NMemoryFile::setPosition(NMemoryFile *this, const unsigned int *a2)
{
  if (((*(uint64_t (**)(NMemoryFile *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NMemoryFile::setPosition() - cannot get position, file %s is not open", v4, *((void *)this + 3));
  }
  uint64_t v5 = *a2;
  if (v5 == -1)
  {
    uint64_t v8 = *((void *)this + 6);
  }
  else
  {
    uint64_t v6 = *((void *)this + 5);
    if (*((void *)this + 6) - v6 < v5) {
      return 0;
    }
    uint64_t v8 = v6 + v5;
  }
  *((void *)this + 7) = v8;
  return 1;
}

void *NMemoryFile::write(NMemoryFile *this, const NString *a2)
{
  if (((*(uint64_t (**)(NMemoryFile *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NMemoryFile::write() - file %s is not open", v4, *((void *)this + 3));
  }
  if (*((_DWORD *)this + 16) != 1) {
    Error::chuck((Error *)"NMemoryFile::write() - file %s not opened in write mode", v4, *((void *)this + 3));
  }
  unsigned int v5 = *((_DWORD *)a2 + 2);
  uint64_t v6 = (void *)*((void *)this + 7);
  unsigned int v7 = *((_DWORD *)this + 12) - v6;
  if (v5 >= v7) {
    size_t v8 = v7;
  }
  else {
    size_t v8 = v5;
  }
  uint64_t result = memcpy(v6, *((const void **)a2 + 2), v8);
  *((void *)this + 7) += v8;
  return result;
}

void NMemoryFile::readString(NMemoryFile *this@<X0>, uint64_t a2@<X8>)
{
  if ((*(uint64_t (**)(NMemoryFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 16))
    {
      uint64_t v5 = *((void *)this + 6);
      uint64_t v6 = (unsigned int *)*((void *)this + 7);
      if (v5 - (uint64_t)v6 > 3)
      {
        unsigned int v9 = *v6;
        unsigned int v7 = v6 + 1;
        uint64_t v8 = v9;
        *((void *)this + 7) = v7;
        if (v5 - (uint64_t)v7 >= v9)
        {
          *((void *)this + 7) = (char *)v7 + v8;
          *(void *)a2 = &unk_26C99C5B0;
          *(_DWORD *)(a2 + 8) = v8;
          operator new[]();
        }
        *((void *)this + 6) = v7;
        Error::chuck((Error *)"NMemoryFile::readString() - failed to read embedded binary string in %s", v4, *((void *)this + 3));
      }
      *((void *)this + 6) = v6;
      Error::chuck((Error *)"NMemoryFile::readString() - failed to read length for embedded binary string in %s", v4, *((void *)this + 3));
    }
    Error::chuck((Error *)"NMemoryFile::readString() - file %s not opened in read mode", v4, *((void *)this + 3));
  }
  Error::chuck((Error *)"NMemoryFile::readString() - file %s is not open", v4, *((void *)this + 3));
}

void NMemoryFile::readLine(NMemoryFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  if (((*(uint64_t (**)(NMemoryFile *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NMemoryFile::readLine() - file %s is not open", v6, *((void *)this + 3));
  }
  if (*((_DWORD *)this + 16)) {
    Error::chuck((Error *)"NMemoryFile::readLine() - file %s not opened in read mode", v6, *((void *)this + 3));
  }
  unint64_t v7 = *((void *)this + 6);
  unint64_t v8 = *((void *)this + 7);
  if (v8 >= v7)
  {
    uint64_t v9 = 0;
    BOOL v10 = 0;
  }
  else if (*(unsigned char *)v8 == 10)
  {
    uint64_t v9 = 0;
    BOOL v10 = 1;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v11 = (unsigned char *)*((void *)this + 6);
    while (~v8 + v7 != v9)
    {
      int v12 = *(unsigned __int8 *)(v8 + 1 + v9++);
      if (v12 == 10)
      {
        uint64_t v11 = (unsigned char *)(v8 + v9);
        goto LABEL_12;
      }
    }
    uint64_t v9 = v7 - v8;
LABEL_12:
    BOOL v10 = (unint64_t)v11 < v7;
  }
  int v13 = (unsigned __int8 *)(v8 + (v9 & (v9 >> 63)));
  uint64_t v14 = v9;
  do
  {
    unint64_t v15 = v14;
    if (v14-- < 1) {
      goto LABEL_26;
    }
  }
  while (*(unsigned char *)(v8 + v15 - 1) == 13);
  int v17 = *(unsigned __int8 *)a2;
  if (*a2)
  {
    int v18 = *(unsigned __int8 *)v8;
    int v13 = (unsigned __int8 *)*((void *)this + 7);
    if (v18 != v17)
    {
      int v13 = (unsigned __int8 *)(v8 + 1);
      if (v15 >= 2)
      {
        if (v18 != 32) {
          goto LABEL_20;
        }
LABEL_21:
        if (*v13 != v17)
        {
          while ((unint64_t)(v13 + 1) < v8 + v15)
          {
            int v18 = *v13++;
            if (v18 == 32) {
              goto LABEL_21;
            }
LABEL_20:
            if (v18 == 9) {
              goto LABEL_21;
            }
          }
          LODWORD(v13) = v13 + 1;
        }
      }
    }
  }
  else
  {
    LODWORD(v13) = v8 + v15;
  }
LABEL_26:
  *((void *)this + 7) = v8 + v9 + v10;
  *(void *)a3 = &unk_26C99C5B0;
  if (v8)
  {
    *(_DWORD *)(a3 + 8) = v13 - v8;
    operator new[]();
  }
  Error::chuck((Error *)"Null pointer passed to string constructor", v6);
}

uint64_t NMemoryFile::read(NMemoryFile *this, unsigned int *a2, NString *a3)
{
  if (((*(uint64_t (**)(NMemoryFile *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NMemoryFile::read() - file %s is not open", v6, *((void *)this + 3));
  }
  if (*((_DWORD *)this + 16)) {
    Error::chuck((Error *)"NMemoryFile::read() - file %s not opened in read mode", v6, *((void *)this + 3));
  }
  if (*a2 == -1) {
    Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v6, *((void *)this + 3));
  }
  unsigned int v8 = *a2;
  if (*a2 > *((_DWORD *)this + 12) - *((void *)this + 7)) {
    unsigned int v8 = *((_DWORD *)this + 12) - *((void *)this + 7);
  }
  (*(void (**)(NString *))(*(void *)a3 + 64))(a3);
  *((void *)this + 7) += v8;
  return *((unsigned int *)a3 + 2);
}

void NMemoryFile::read(NMemoryFile *this@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  if ((*(uint64_t (**)(NMemoryFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 16))
    {
      unsigned int v7 = *a2;
      if (*a2 != -1)
      {
        uint64_t v8 = *((void *)this + 7);
        unsigned int v9 = *((_DWORD *)this + 12) - v8;
        if (v7 >= v9) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = v7;
        }
        *((void *)this + 7) = v8 + v10;
        *(void *)a3 = &unk_26C99C5B0;
        if (v8)
        {
          *(_DWORD *)(a3 + 8) = v10;
          operator new[]();
        }
        Error::chuck((Error *)"Null pointer passed to string constructor", v6);
      }
      Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v6, *((void *)this + 3));
    }
    Error::chuck((Error *)"NMemoryFile::read() - file %s not opened in read mode", v6, *((void *)this + 3));
  }
  Error::chuck((Error *)"NMemoryFile::read() - file %s is not open", v6, *((void *)this + 3));
}

void NMemoryFile::read(NMemoryFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((void *)this + 6);
  uint64_t v5 = *((void *)this + 7);
  *((void *)this + 7) = v4;
  *(void *)a3 = &unk_26C99C5B0;
  if (v5)
  {
    *(_DWORD *)(a3 + 8) = v4 - v5;
    operator new[]();
  }
  Error::chuck((Error *)"Null pointer passed to string constructor", a2);
}

uint64_t NMemoryFile::good(NMemoryFile *this)
{
  if ((*(uint64_t (**)(NMemoryFile *))(*(void *)this + 40))(this)) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(NMemoryFile *))(*(void *)this + 32);

  return v3(this);
}

BOOL NMemoryFile::eof(NMemoryFile *this)
{
  return *((void *)this + 7) >= *((void *)this + 6);
}

uint64_t NMemoryFile::isOpen(NMemoryFile *this)
{
  return *((unsigned __int8 *)this + 68);
}

uint64_t NMemoryFile::close(NMemoryFile *this)
{
  int v3 = 0;
  uint64_t v1 = (char *)this + 8;
  uint64_t result = (*(uint64_t (**)(char *, const char *, int *))(*((void *)this + 1) + 64))((char *)this + 8, "", &v3);
  v1[60] = 0;
  *((void *)v1 + 5) = 0;
  *((void *)v1 + 6) = 0;
  *((void *)v1 + 4) = 0;
  return result;
}

void NMemoryFile::open(NMemoryFile *this, const NString *a2, const NString *a3)
{
  (*(void (**)(NMemoryFile *))(*(void *)this + 24))(this);
  unsigned int v7 = (unsigned char *)*((void *)a3 + 2);
  if (*((_DWORD *)a3 + 2) == 1)
  {
    if (*v7 == 114)
    {
      int v8 = 0;
LABEL_6:
      *((_DWORD *)this + 16) = v8;
      uint64_t v9 = *((unsigned int *)a2 + 2);
      if (v9)
      {
        uint64_t v10 = (char *)*((void *)a2 + 2);
        uint64_t v11 = memchr(v10, 0, *((unsigned int *)a2 + 2));
        if (v11)
        {
          int64_t v12 = v11 - v10;
          if (((v11 - v10) & 0x80000000) == 0 && (v11 - v10) + 17 == v9)
          {
            uint64_t v13 = (v12 + 1);
            if (v13 >= v9)
            {
              uint64_t v18 = (v9 - 1);
              uint64_t v19 = v13;
            }
            else
            {
              uint64_t v14 = *(void *)&v10[v13];
              *((void *)this + 5) = v14;
              uint64_t v15 = (v12 + 9);
              unsigned int v16 = *((_DWORD *)a2 + 2);
              if (v15 < v16)
              {
                *((void *)this + 6) = *(void *)(*((void *)a2 + 2) + v15);
                *((void *)this + 7) = v14;
                uint64_t v17 = *((unsigned int *)a2 + 2);
                if (v17 >= v12)
                {
                  if (*((void *)a2 + 2)) {
                    operator new[]();
                  }
                  Error::chuck((Error *)"Null pointer passed to string constructor", v6);
                }
                Error::chuck((Error *)"Index %d outside of range [0,%d]", v6, v12, v17);
              }
              uint64_t v18 = v16 - 1;
              uint64_t v19 = v15;
            }
            Error::chuck((Error *)"Index %d outside of range [0,%d]", v6, v19, v18);
          }
        }
      }
      Error::chuck((Error *)"NMemoryFile::open() - mindex: filespec has no memory pointer", v6);
    }
    unsigned int v7 = (unsigned char *)*((void *)a3 + 2);
    if (*v7 == 119)
    {
      int v8 = 1;
      goto LABEL_6;
    }
  }
  Error::chuck((Error *)"NMemoryFile::open() - unrecognized file mode %s", v6, v7);
}

void sub_2184AF4B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NMemoryFile::~NMemoryFile(NMemoryFile *this)
{
  *(void *)this = &unk_26C99A7C0;
  uint64_t v2 = *((void *)this + 1);
  int v4 = 0;
  (*(void (**)(char *, const char *, int *))(v2 + 64))((char *)this + 8, "", &v4);
  *((unsigned char *)this + 68) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  int v4;

  *(void *)this = &unk_26C99A7C0;
  uint64_t v2 = *((void *)this + 1);
  int v4 = 0;
  (*(void (**)(char *, const char *, int *))(v2 + 64))((char *)this + 8, "", &v4);
  *((unsigned char *)this + 68) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  int v4;

  *(void *)this = &unk_26C99A7C0;
  uint64_t v2 = *((void *)this + 1);
  int v4 = 0;
  (*(void (**)(char *, const char *, int *))(v2 + 64))((char *)this + 8, "", &v4);
  *((unsigned char *)this + 68) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
}

void NMemoryFile::NMemoryFile(NMemoryFile *this)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void NMemoryFile::NMemoryFile(NMemoryFile *this, const NString *a2, const NString *a3)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void sub_2184AF91C(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v5 = v1[3];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_2184AFA2C(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v5 = v1[3];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NMemoryFile::newMemoryBlockDef(NMemoryFile *this, const NString *a2, const void *a3)
{
  uint64_t v5 = a2;
  uint64_t v3 = &unk_26C99C5B0;
  int v4 = 1;
  operator new[]();
}

void sub_2184AFDEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  *(void *)(v21 - 88) = &unk_26C99C5B0;
  uint64_t v23 = *(void *)(v21 - 72);
  if (v23) {
    MEMORY[0x21D46B220](v23, 0x1000C8077774924);
  }
  if (a15) {
    MEMORY[0x21D46B220](a15, 0x1000C8077774924);
  }
  if (a21) {
    MEMORY[0x21D46B220](a21, 0x1000C8077774924);
  }
  if (a18) {
    MEMORY[0x21D46B220](a18, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NMemoryFile::getMemoryBlockParams(NMemoryFile *this, const NString *a2, const void **a3, unsigned int *a4)
{
  size_t v4 = *((unsigned int *)this + 2);
  if (!v4) {
    return 0;
  }
  unsigned int v7 = (char *)*((void *)this + 2);
  uint64_t result = (uint64_t)memchr(v7, 0, v4);
  if (!result) {
    return result;
  }
  unsigned int v10 = result - v7;
  if (result - v7 < 0 || (result - v7) + 17 != v4) {
    return 0;
  }
  uint64_t v11 = v10;
  uint64_t v12 = v10 + 1;
  if (v12 >= v4) {
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v9, v12, (v4 - 1));
  }
  uint64_t v13 = v11 + 9;
  if (v13 >= v4) {
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v9, v13, (v4 - 1));
  }
  uint64_t v14 = *(void *)&v7[v12];
  int v15 = *(_DWORD *)&v7[v13];
  *(void *)a2 = v14;
  *(_DWORD *)a3 = v15 - v14;
  return 1;
}

uint64_t NFixedPointScales::paramLimit(NFixedPointScales *this)
{
  return 0x7FFFLL;
}

void NFixedPointScales::~NFixedPointScales(NFixedPointScales *this)
{
  NFixedPointScales::~NFixedPointScales(this);

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(void *)this = &unk_26C99AE78;
  *((void *)this + 12) = &unk_26C99C348;
  uint64_t v2 = *((void *)this + 13);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  *((void *)this + 9) = &unk_26C99C348;
  uint64_t v3 = *((void *)this + 10);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 6) = &unk_26C99C348;
  size_t v4 = *((void *)this + 7);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  *((void *)this + 2) = &unk_26C99C3B8;
  uint64_t v5 = *((void *)this + 3);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
}

uint64_t NGaussianFixedPointScales::paramLimit(NGaussianFixedPointScales *this)
{
  return 23170;
}

void NGaussianFixedPointScales::~NGaussianFixedPointScales(NGaussianFixedPointScales *this)
{
  *(void *)this = &unk_26C99BC98;
  *((void *)this + 21) = &unk_26C99C3B8;
  uint64_t v2 = *((void *)this + 22);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  *((void *)this + 17) = &unk_26C99C3B8;
  uint64_t v3 = *((void *)this + 18);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales(this);

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26C99BC98;
  *((void *)this + 21) = &unk_26C99C3B8;
  uint64_t v2 = *((void *)this + 22);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  *((void *)this + 17) = &unk_26C99C3B8;
  uint64_t v3 = *((void *)this + 18);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }

  NFixedPointScales::~NFixedPointScales(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26C99BC98;
  *((void *)this + 21) = &unk_26C99C3B8;
  uint64_t v2 = *((void *)this + 22);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  *((void *)this + 17) = &unk_26C99C3B8;
  uint64_t v3 = *((void *)this + 18);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }

  NFixedPointScales::~NFixedPointScales(this);
}

void NFixedPointScales::NFixedPointScales(NFixedPointScales *this)
{
  *(void *)this = &unk_26C99AE78;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = &unk_26C99C3B8;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = &unk_26C99C348;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = &unk_26C99C348;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 12) = &unk_26C99C348;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((unsigned char *)this + 120) = 0;
}

{
  *(void *)this = &unk_26C99AE78;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = &unk_26C99C3B8;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = &unk_26C99C348;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = &unk_26C99C348;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 12) = &unk_26C99C348;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((unsigned char *)this + 120) = 0;
}

void NFixedPointScales::initialize(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)(a1 + 8) = *a2;
  if (a1 + 16 != a3)
  {
    int v5 = *(_DWORD *)(a1 + 32);
    int v6 = *(_DWORD *)(a3 + 16);
    if (v5 != v6)
    {
      uint64_t v7 = *(void *)(a1 + 24);
      if (v7)
      {
        MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        int v6 = *(_DWORD *)(a3 + 16);
      }
      *(_DWORD *)(a1 + 32) = v6;
      operator new[]();
    }
    if (v5)
    {
      unint64_t v8 = 0;
      uint64_t v9 = *(void *)(a3 + 8);
      uint64_t v10 = *(void *)(a1 + 24);
      do
      {
        *(_DWORD *)(v10 + 4 * v8) = *(_DWORD *)(v9 + 4 * v8);
        ++v8;
      }
      while (v8 < *(unsigned int *)(a1 + 32));
    }
  }
  float v11 = ldexp(1.0, *(_DWORD *)(a1 + 8));
  *(float *)(a1 + 40) = v11;
  *(float *)(a1 + 44) = 1.0 / v11;
  NFixedPointScales::makeParamScales((NFixedPointScales *)a1);
  *(unsigned char *)(a1 + 120) = 1;
}

void NFixedPointScales::makeParamScales(NFixedPointScales *this)
{
  int v2 = (*(uint64_t (**)(NFixedPointScales *))(*(void *)this + 16))(this);
  int v3 = *((_DWORD *)this + 16);
  int v4 = *((_DWORD *)this + 8);
  if (v3 != v4)
  {
    *((_DWORD *)this + 16) = v4;
    operator new[]();
  }
  if (*((_DWORD *)this + 22) != v3)
  {
    *((_DWORD *)this + 22) = v3;
    operator new[]();
  }
  if (*((_DWORD *)this + 28) != v3)
  {
    *((_DWORD *)this + 28) = v3;
    operator new[]();
  }
  if (v3)
  {
    unint64_t v5 = 0;
    do
    {
      float v6 = ldexp(1.0, *(_DWORD *)(*((void *)this + 3) + 4 * v5));
      *(float *)(*((void *)this + 7) + 4 * v5) = v6;
      float v7 = 1.0 / v6;
      *(float *)(*((void *)this + 10) + 4 * v5) = v7;
      *(float *)(*((void *)this + 13) + 4 * v5++) = v7 * (float)v2;
    }
    while (v5 < *((unsigned int *)this + 8));
  }
}

void NFixedPointScales::setUp(NFixedPointScales *this)
{
  float v2 = ldexp(1.0, *((_DWORD *)this + 2));
  *((float *)this + 10) = v2;
  *((float *)this + 11) = 1.0 / v2;
  NFixedPointScales::makeParamScales(this);
  *((unsigned char *)this + 120) = 1;
}

void NFixedPointScales::toFloatVec(void *a1@<X8>)
{
  *a1 = &unk_26C99C348;
  operator new[]();
}

void NFixedPointScales::toFixVec(void *a1@<X8>)
{
  *a1 = &unk_26C99C428;
  operator new[]();
}

uint64_t NFixedPointScales::readInt(NFixedPointScales *this, NFilePtr *a2, const BOOL *a3, const NString *a4)
{
  if (!*a3)
  {
    uint64_t v8 = *((void *)a2 + 1);
    if (v8)
    {
      (*(void (**)(void **__return_ptr))(*(void *)v8 + 80))(&v11);
      operator new[]();
    }
LABEL_10:
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  }
  uint64_t v6 = *((void *)a2 + 1);
  if (!v6) {
    goto LABEL_10;
  }
  (*(void (**)(void **__return_ptr))(*(void *)v6 + 64))(&v11);
  if (v12 != 4)
  {
    float v11 = &unk_26C99C5B0;
    if (v13) {
      MEMORY[0x21D46B220](v13, 0x1000C8077774924);
    }
    uint64_t v10 = *((void *)a2 + 1);
    if (v10) {
      Error::chuck((Error *)"NGaussianFixedPointScales::read() - failed to read %s from file %s", (const char *)a2, *((void *)a4 + 2), *(void *)(v10 + 24));
    }
    goto LABEL_10;
  }
  uint64_t v7 = *v13;
  float v11 = &unk_26C99C5B0;
  MEMORY[0x21D46B220]();
  return v7;
}

void sub_2184B1254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (a20) {
    MEMORY[0x21D46B220](a20, 0x1000C8077774924);
  }
  if (a23) {
    MEMORY[0x21D46B220](a23, 0x1000C8077774924);
  }
  *(void *)(v26 - 128) = &unk_26C99C5B0;
  uint64_t v28 = *(void *)(v26 - 112);
  if (v28) {
    MEMORY[0x21D46B220](v28, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void *NFixedPointScales::readIntVec(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, _DWORD *a5, uint64_t a6)
{
  if (!*a3)
  {
    uint64_t v11 = *(void *)(a2 + 8);
    if (v11)
    {
      char v18 = 0;
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v11 + 80))(&v19);
      unsigned int v16 = &unk_26C99C5B0;
      LODWORD(v17) = 4;
      operator new[]();
    }
LABEL_11:
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
  }
  uint64_t v9 = *(void *)(a2 + 8);
  if (!v9) {
    goto LABEL_11;
  }
  LODWORD(v16) = 4 * *a5;
  (*(void (**)(char **__return_ptr))(*(void *)v9 + 64))(&__endptr);
  if ((v14 & 3) != 0)
  {
    __endptr = (char *)&unk_26C99C5B0;
    if (__s1) {
      MEMORY[0x21D46B220](__s1, 0x1000C8077774924);
    }
    uint64_t v12 = *(void *)(a2 + 8);
    if (v12) {
      Error::chuck((Error *)"NGaussianFixedPointScales::read() - failed to read %s from file %s", (const char *)a2, *(void *)(a4 + 16), *(void *)(v12 + 24));
    }
    goto LABEL_11;
  }
  LODWORD(v19) = v14 >> 2;
  (*(void (**)(uint64_t, void *, uint64_t *))(*(void *)a6 + 24))(a6, __s1, &v19);
  __endptr = (char *)&unk_26C99C5B0;
  uint64_t result = __s1;
  if (__s1) {
    return (void *)MEMORY[0x21D46B220](__s1, 0x1000C8077774924);
  }
  return result;
}

void sub_2184B1D00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  NArray<NString>::~NArray((uint64_t *)va);
  *(void *)(v15 - 112) = &unk_26C99C5B0;
  uint64_t v17 = *(void *)(v15 - 96);
  if (v17) {
    MEMORY[0x21D46B220](v17, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void NArray<NString>::NArray(void *a1)
{
  *a1 = &unk_26C99C0A8;
  operator new[]();
}

void NFixedPointScales::read(NFixedPointScales *this, NFilePtr *a2, const unsigned int *a3, const BOOL *a4)
{
  int v4 = &unk_26C99C5B0;
  int v5 = 8;
  operator new[]();
}

void sub_2184B21D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NFixedPointScales::write(NFixedPointScales *this, NFilePtr *a2, const BOOL *a3)
{
  uint64_t v3 = *((void *)a2 + 1);
  if (*a3)
  {
    if (v3) {
      operator new[]();
    }
  }
  else if (v3)
  {
    operator new[]();
  }
  Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
}

void sub_2184B284C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22)
  {
    MEMORY[0x21D46B220](a22, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void operator<<<int>()
{
  v0 = &unk_26C99C5B0;
  int v1 = 1;
  operator new[]();
}

void sub_2184B2CDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NGaussianFixedPointScales::NGaussianFixedPointScales(NGaussianFixedPointScales *this)
{
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = &unk_26C99C3B8;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = &unk_26C99C348;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = &unk_26C99C348;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 12) = &unk_26C99C348;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((unsigned char *)this + 120) = 0;
  *(void *)this = &unk_26C99BC98;
  *(void *)((char *)this + 124) = 0;
  *((_DWORD *)this + 33) = 0;
  *((void *)this + 17) = &unk_26C99C3B8;
  *((void *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = &unk_26C99C3B8;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
}

{
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = &unk_26C99C3B8;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = &unk_26C99C348;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = &unk_26C99C348;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 12) = &unk_26C99C348;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  *((unsigned char *)this + 120) = 0;
  *(void *)this = &unk_26C99BC98;
  *(void *)((char *)this + 124) = 0;
  *((_DWORD *)this + 33) = 0;
  *((void *)this + 17) = &unk_26C99C3B8;
  *((void *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = &unk_26C99C3B8;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
}

void NGaussianFixedPointScales::initialize(uint64_t a1, const char *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(unsigned int *)(a5 + 16);
  uint64_t v7 = *(unsigned int *)(a6 + 16);
  if (v6 != v7) {
    Error::chuck((Error *)"NGaussianFixedPointScales::initialize() - inconsistent dimensionality (paramQ=%d, dimenShift=%d)", a2, *(unsigned int *)(a5 + 16), v7);
  }
  if (*a4 > *(_DWORD *)a2) {
    Error::chuck((Error *)"NGaussianFixedPointScales::initialize() - logprobQ > gaussianQ", a2);
  }
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      uint64_t v13 = *(unsigned int *)(*(void *)(a6 + 8) + 4 * i);
      if ((v13 & 0x80000000) != 0) {
        Error::chuck((Error *)"NGaussianFixedPointScales::initialize() - dimenShift[%d] -ve (%d)", a2, i, v13);
      }
    }
  }
  NFixedPointScales::initialize(a1, a4, a5);
  *(_DWORD *)(a1 + 128) = *(_DWORD *)a2;
  *(_DWORD *)(a1 + 124) = *a3;
  if (a1 + 168 != a6)
  {
    int v14 = *(_DWORD *)(a1 + 184);
    int v15 = *(_DWORD *)(a6 + 16);
    if (v14 != v15)
    {
      uint64_t v16 = *(void *)(a1 + 176);
      if (v16)
      {
        MEMORY[0x21D46B220](v16, 0x1000C8052888210);
        int v15 = *(_DWORD *)(a6 + 16);
      }
      *(_DWORD *)(a1 + 184) = v15;
      operator new[]();
    }
    if (v14)
    {
      unint64_t v17 = 0;
      uint64_t v18 = *(void *)(a6 + 8);
      uint64_t v19 = *(void *)(a1 + 176);
      do
      {
        *(_DWORD *)(v19 + 4 * v17) = *(_DWORD *)(v18 + 4 * v17);
        ++v17;
      }
      while (v17 < *(unsigned int *)(a1 + 184));
    }
  }
  *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 128) - *(_DWORD *)(a1 + 8);
  unsigned int v21 = 0x2000;
  NGaussianFixedPointScales::makeLogAddTable((NGaussianFixedPointScales *)a1, (const char *)&v21);
  float v20 = ldexp(1.0, *(_DWORD *)(a1 + 8));
  *(float *)(a1 + 40) = v20;
  *(float *)(a1 + 44) = 1.0 / v20;
  NFixedPointScales::makeParamScales((NFixedPointScales *)a1);
  *(unsigned char *)(a1 + 120) = 1;
}

void NGaussianFixedPointScales::makeLogAddTable(NGaussianFixedPointScales *this, const char *a2)
{
  if (!*(_DWORD *)a2) {
    Error::chuck((Error *)"NGaussianFixedPointScales::makeLogAddTable() - table size must be >0", a2);
  }
  unsigned int v3 = 0;
  unsigned int v4 = *(_DWORD *)a2 - 1;
  if (*(_DWORD *)a2 != 1)
  {
    do
    {
      ++v3;
      BOOL v5 = v4 > 1;
      v4 >>= 1;
    }
    while (v5);
  }
  int v6 = *((_DWORD *)this + 2);
  double v7 = ldexp(1.0, v6);
  long double v8 = exp(0.5 / v7);
  float v9 = -(v7 * log(v8 + -1.0));
  frexpf(v9, &v43);
  unsigned int v10 = v43;
  if (v43 >= (*((_DWORD *)this + 31) + v6)) {
    unsigned int v10 = *((_DWORD *)this + 31) + v6;
  }
  if (v3 >= v10) {
    unsigned int v11 = v10;
  }
  else {
    unsigned int v11 = v3;
  }
  uint64_t v12 = (1 << v11);
  *((_DWORD *)this + 40) = v10 - v11;
  *((_DWORD *)this + 41) = ~(-1 << v10);
  if (*((_DWORD *)this + 38) != v12)
  {
    *((_DWORD *)this + 38) = v12;
    operator new[]();
  }
  int v13 = *((_DWORD *)this + 2);
  double v14 = ldexp(1.0, *((_DWORD *)this + 40) - v13);
  double v15 = ldexp(1.0, v13);
  if (v12)
  {
    float v16 = v14;
    float v17 = -v16;
    float v18 = v15;
    double v41 = v18;
    float v42 = v17;
    uint64_t v19 = *((void *)this + 18);
    if (v12 == 1)
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
LABEL_17:
        float v33 = expf(v17 * (float)i);
        long double v34 = log(v33 + 1.0);
        float v17 = v42;
        *(float *)&long double v34 = v34 * v41;
        *(_DWORD *)(v19 + 4 * i) = (int)(*(float *)&v34 + 0.5);
      }
      goto LABEL_18;
    }
    uint64_t i = v12 & 0xFFFFFFFE;
    int32x2_t v21 = (int32x2_t)0x100000000;
    __asm
    {
      FMOV            V2.2D, #1.0
      FMOV            V0.2D, #0.5
    }
    float64x2_t v35 = _Q0;
    float64x2_t v36 = _Q2;
    uint64_t v28 = (int32x2_t *)*((void *)this + 18);
    uint64_t v29 = i;
    do
    {
      float32x2_t v30 = vmul_n_f32(vcvt_f32_u32((uint32x2_t)v21), v17);
      float __x = v30.f32[0];
      float v39 = expf(v30.f32[1]);
      v31.f32[0] = expf(__x);
      v31.f32[1] = v39;
      float64x2_t __xa = vaddq_f64(vcvtq_f64_f32(v31), v36);
      long double v40 = log(__xa.f64[1]);
      v32.f64[0] = log(__xa.f64[0]);
      v32.f64[1] = v40;
      float v17 = v42;
      *v28++ = vmovn_s64(vcvtq_s64_f64(vaddq_f64(vcvtq_f64_f32(vcvt_f32_f64(vmulq_n_f64(v32, v41))), v35)));
      int32x2_t v21 = vadd_s32(v21, (int32x2_t)0x200000002);
      v29 -= 2;
    }
    while (v29);
    if (i != v12) {
      goto LABEL_17;
    }
  }
LABEL_18:
  *((unsigned char *)this + 192) = 1;
}

void NGaussianFixedPointScales::setUp(NGaussianFixedPointScales *this)
{
  *((_DWORD *)this + 33) = *((_DWORD *)this + 32) - *((_DWORD *)this + 2);
  unsigned int v3 = 0x2000;
  NGaussianFixedPointScales::makeLogAddTable(this, (const char *)&v3);
  float v2 = ldexp(1.0, *((_DWORD *)this + 2));
  *((float *)this + 10) = v2;
  *((float *)this + 11) = 1.0 / v2;
  NFixedPointScales::makeParamScales(this);
  *((unsigned char *)this + 120) = 1;
}

void NGaussianFixedPointScales::read(NGaussianFixedPointScales *this, NFilePtr *a2, const unsigned int *a3, const BOOL *a4)
{
  *(void *)unsigned int v4 = &unk_26C99C5B0;
  int v5 = 9;
  operator new[]();
}

void sub_2184B38C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NGaussianFixedPointScales::write(NGaussianFixedPointScales *this, NFilePtr *a2, const BOOL *a3)
{
  uint64_t v3 = *((void *)a2 + 1);
  if (*a3)
  {
    if (v3) {
      operator new[]();
    }
  }
  else if (v3)
  {
    operator new[]();
  }
  Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", (const char *)a2);
}

void sub_2184B4734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22)
  {
    MEMORY[0x21D46B220](a22, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NGaussianFixedPointScales::logadd(NGaussianFixedPointScales *this, signed int a2, signed int a3)
{
  if (a3 <= a2) {
    uint64_t result = a2;
  }
  else {
    uint64_t result = a3;
  }
  if (a3 >= a2) {
    int v5 = a2;
  }
  else {
    int v5 = a3;
  }
  if (v5 != -1073741823)
  {
    int v6 = result - v5;
    if (v6 <= *((_DWORD *)this + 41)) {
      return (*(_DWORD *)(*((void *)this + 18) + 4 * (v6 >> *((_DWORD *)this + 40)))
    }
                          + result);
  }
  return result;
}

uint64_t NGaussianFixedPointScales::setDimenShift(uint64_t result, uint64_t a2)
{
  if (result + 168 != a2)
  {
    uint64_t v3 = result;
    int v4 = *(_DWORD *)(result + 184);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 176);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v3 + 184) = v5;
      operator new[]();
    }
    if (v4)
    {
      unint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 176);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(result + 184));
    }
  }
  return result;
}

void NFrameWindow::NFrameWindow(NFrameWindow *this)
{
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = &unk_26C99C498;
  *((_WORD *)this + 36) = 1;
}

{
  *(_OWORD *)((char *)this + 28) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = &unk_26C99C498;
  *((_WORD *)this + 36) = 1;
}

uint64_t NFrameWindow::configure(uint64_t this, const char *a2, unsigned int *a3, const unsigned int *a4, unsigned int *a5, unsigned int *a6, const unsigned int *a7, const unsigned int *a8)
{
  unsigned int v8 = *a5;
  uint64_t v9 = *a4;
  uint64_t v10 = *a3;
  if (*a5 - 1 < v9 || v9 > v8 || v8 > v10) {
    Error::chuck((Error *)"NFrameWindow::configure() - Invalid frame subset %d-%d from 0-%d", a2, v9, *a5, v10);
  }
  *(_DWORD *)(this + 12) = v9;
  unsigned int v13 = *a5;
  *(_DWORD *)(this + 16) = *a5;
  if (!v13)
  {
    unsigned int v13 = *a3;
    *(_DWORD *)(this + 16) = *a3;
  }
  int v14 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2) {
    Error::chuck((Error *)"NFrameWindow::configure() - must be at least one frame in window", a2);
  }
  unsigned int v15 = v14 - 1 + (v14 - 1) * *a7 + *a8;
  uint64_t v16 = v14 + (v14 - 1) * *a7 + *a8;
  unsigned int v17 = *a6;
  if (*a6 == -1)
  {
    unsigned int v18 = 0;
    *(_DWORD *)this = v15;
  }
  else if (v17 == -2)
  {
    if ((v16 & 1) == 0) {
      Error::chuck((Error *)"NFrameWindow::configure() - only an odd number of frames supported for centered window (%d)", a2, v16);
    }
    unsigned int v18 = v16 >> 1;
    *(_DWORD *)this = v16 >> 1;
  }
  else
  {
    if (v17 >= v16) {
      Error::chuck((Error *)"NFrameWindow::configure() - frame window offset %d located outside window (%d)", a2, *a6, v16);
    }
    *(_DWORD *)this = v17;
    unsigned int v18 = v15 - v17;
  }
  *(_DWORD *)(this + 4) = v18;
  if (*a8 >= v16) {
    Error::chuck((Error *)"NFrameWindow::configure() - start frame %d located outside window (%d)", a2, *a8, v16);
  }
  *(_DWORD *)(this + 28) = *a8;
  *(_DWORD *)(this + 32) = *a7;
  int v19 = v13 - v9;
  *(_DWORD *)(this + 8) = *a3;
  unsigned int v20 = *(_DWORD *)a2 * v19;
  int v21 = v19 * v16;
  *(_DWORD *)(this + 20) = v20;
  *(_DWORD *)(this + 24) = v21;
  if (*(_DWORD *)(this + 64) != v21)
  {
    *(_DWORD *)(this + 64) = v21;
    operator new[]();
  }
  *(_WORD *)(this + 72) = 1;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t NFrameWindow::reset(uint64_t this)
{
  *(_WORD *)(this + 72) = 1;
  *(_DWORD *)(this + 36) = 0;
  *(_DWORD *)(this + 40) = 0;
  return this;
}

uint64_t NFrameWindow::endFrames(uint64_t this)
{
  *(unsigned char *)(this + 73) = 1;
  return this;
}

int32x2_t NFrameWindow::pushFrame(NFrameWindow *this, const NFrame *a2)
{
  int v2 = *((_DWORD *)a2 + 4);
  if (!v2) {
    Error::chuck((Error *)"NFrameWindow::pushFrame() - cannot feed zero-sized frames", (const char *)a2);
  }
  uint64_t v3 = *((unsigned int *)this + 2);
  if (v2 != v3) {
    Error::chuck((Error *)"NFrameWindow::pushFrame() - mismatched input frame size (%d != %d)", (const char *)a2, *((unsigned int *)a2 + 4), v3);
  }
  int v4 = (const float *)*((void *)a2 + 1);

  return NFrameWindow::pushFrame(this, v4);
}

int32x2_t NFrameWindow::pushFrame(NFrameWindow *this, const float *a2)
{
  if (*((unsigned char *)this + 73)) {
    Error::chuck((Error *)"NFrameWindow::pushFrame() - endFrames() already called", (const char *)a2);
  }
  if (*((_DWORD *)this + 10) > *((_DWORD *)this + 1)) {
    Error::chuck((Error *)"NFrameWindow::pushFrame() - buffer full", (const char *)a2);
  }
  if (*((unsigned char *)this + 72))
  {
    if (*(_DWORD *)this)
    {
      unsigned int v4 = 0;
      unsigned int v5 = *((_DWORD *)this + 9);
      do
      {
        if (v5 >= *((_DWORD *)this + 6))
        {
          unsigned int v5 = 0;
          *((_DWORD *)this + 9) = 0;
        }
        uint64_t v6 = *((unsigned int *)this + 3);
        unsigned int v7 = *((_DWORD *)this + 4) - v6;
        memcpy((void *)(*((void *)this + 7) + 4 * v5), &a2[v6], 4 * v7);
        unsigned int v5 = *((_DWORD *)this + 9) + v7;
        *((_DWORD *)this + 9) = v5;
        ++v4;
      }
      while (v4 < *(_DWORD *)this);
    }
    *((unsigned char *)this + 72) = 0;
  }
  unsigned int v8 = *((_DWORD *)this + 9);
  if (v8 >= *((_DWORD *)this + 6))
  {
    unsigned int v8 = 0;
    *((_DWORD *)this + 9) = 0;
  }
  uint64_t v9 = *((unsigned int *)this + 3);
  unsigned int v10 = *((_DWORD *)this + 4) - v9;
  memcpy((void *)(*((void *)this + 7) + 4 * v8), &a2[v9], 4 * v10);
  int32x2_t result = vadd_s32(*(int32x2_t *)((char *)this + 36), (int32x2_t)(v10 | 0x100000000));
  *(int32x2_t *)((char *)this + 36) = result;
  return result;
}

void *NFrameWindow::copyInFrame(NFrameWindow *this, const float *a2)
{
  unsigned int v3 = *((_DWORD *)this + 9);
  if (v3 >= *((_DWORD *)this + 6))
  {
    unsigned int v3 = 0;
    *((_DWORD *)this + 9) = 0;
  }
  uint64_t v4 = *((unsigned int *)this + 3);
  unsigned int v5 = *((_DWORD *)this + 4) - v4;
  int32x2_t result = memcpy((void *)(*((void *)this + 7) + 4 * v3), &a2[v4], 4 * v5);
  *((_DWORD *)this + 9) += v5;
  return result;
}

BOOL NFrameWindow::frameReady(NFrameWindow *this)
{
  int v1 = *((_DWORD *)this + 10);
  return *((unsigned char *)this + 73) && v1 || v1 == *((_DWORD *)this + 1) + 1;
}

uint64_t NFrameWindow::setOutputFrameWindow(NFrameWindow *this, float **a2)
{
  unsigned int v3 = (char *)this + 20;
  if (!*((_DWORD *)this + 5)) {
    Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - frame window not configured", v3);
  }
  (*((void (**)(float **, const char *))*a2 + 4))(a2, v3);
  unsigned int v5 = a2[1];

  return NFrameWindow::setOutputFrameWindow((uint64_t)this, v5);
}

uint64_t NFrameWindow::setOutputFrameWindow(uint64_t this, float *__dst)
{
  uint64_t v3 = this;
  int v4 = *(_DWORD *)(this + 40);
  if (*(unsigned char *)(this + 73))
  {
    if (!v4) {
      Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - buffer empty after endFrames()", (const char *)__dst);
    }
    if (v4 != *(_DWORD *)(this + 4) + 1)
    {
      unsigned int v5 = *(_DWORD *)(this + 36);
      unsigned int v6 = *(_DWORD *)(this + 24);
      if (v5 >= v6)
      {
        unsigned int v5 = 0;
        *(_DWORD *)(this + 36) = 0;
      }
      int v8 = *(_DWORD *)(this + 12);
      int v7 = *(_DWORD *)(this + 16);
      unsigned int v9 = v7 - v8;
      if (v7 != v8)
      {
        if (v5 >= v9) {
          unsigned int v10 = 0;
        }
        else {
          unsigned int v10 = v6;
        }
        unsigned int v11 = v5 - v9 + v10;
        uint64_t v12 = *(void *)(this + 56);
        if (v9 < 0x14) {
          goto LABEL_20;
        }
        unsigned int v13 = 0;
        int v14 = v7 + ~v8;
        this = __CFADD__(v5, v14);
        BOOL v15 = __CFADD__(v11, v14);
        if ((this & 1) != 0 || v15) {
          goto LABEL_21;
        }
        if (4 * v5 - 4 * (unint64_t)v11 >= 0x20)
        {
          unsigned int v13 = v9 & 0xFFFFFFF8;
          unsigned int v17 = v5 + (v9 & 0xFFFFFFF8);
          int v29 = v10 + v8 - v7;
          this = v9 & 0xFFFFFFF8;
          do
          {
            float32x2_t v30 = (long long *)(v12 + 4 * (v29 + v5));
            long long v31 = *v30;
            long long v32 = v30[1];
            float v33 = (_OWORD *)(v12 + 4 * v5);
            *float v33 = v31;
            v33[1] = v32;
            v5 += 8;
            this -= 8;
          }
          while (this);
          if (v9 == v13) {
            goto LABEL_24;
          }
          v11 += v13;
          unsigned int v5 = v17;
        }
        else
        {
LABEL_20:
          unsigned int v13 = 0;
        }
LABEL_21:
        int v16 = v13 + v8 - v7;
        unsigned int v17 = v5;
        do
          *(_DWORD *)(v12 + 4 * v17++) = *(_DWORD *)(v12 + 4 * v11++);
        while (!__CFADD__(v16++, 1));
LABEL_24:
        *(_DWORD *)(v3 + 36) = v17;
      }
    }
  }
  else if (v4 != *(_DWORD *)(this + 4) + 1)
  {
    Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - buffer empty", (const char *)__dst);
  }
  *(_DWORD *)(v3 + 40) = v4 - 1;
  if (*(_DWORD *)(v3 + 28) || *(_DWORD *)(v3 + 32))
  {
    if (*(_DWORD *)(v3 + 20))
    {
      unsigned int v19 = 0;
      unsigned int v20 = *(_DWORD *)(v3 + 16) - *(_DWORD *)(v3 + 12);
      unsigned int v21 = *(_DWORD *)(v3 + 36);
      unsigned int v22 = v20 + v20 * *(_DWORD *)(v3 + 32);
      do
      {
        unsigned int v23 = *(_DWORD *)(v3 + 24);
        if (v21 < v23) {
          unsigned int v23 = 0;
        }
        unsigned int v24 = v21 - v23;
        this = (uint64_t)memcpy(&__dst[v19], (const void *)(*(void *)(v3 + 56) + 4 * (v21 - v23)), 4 * v20);
        v19 += v20;
        unsigned int v21 = v22 + v24;
      }
      while (v19 < *(_DWORD *)(v3 + 20));
    }
  }
  else
  {
    unsigned int v25 = *(_DWORD *)(v3 + 20);
    uint64_t v26 = *(unsigned int *)(v3 + 36);
    uint64_t v27 = v25 - v26;
    if (v25 != v26)
    {
      memcpy(__dst, (const void *)(*(void *)(v3 + 56) + 4 * v26), 4 * (v25 - v26));
      unsigned int v25 = *(_DWORD *)(v3 + 36);
    }
    uint64_t v28 = *(const void **)(v3 + 56);
    return (uint64_t)memcpy(&__dst[v27], v28, 4 * v25);
  }
  return this;
}

uint64_t NFrameWindow::endPadOneFrame(uint64_t this)
{
  unsigned int v1 = *(_DWORD *)(this + 36);
  unsigned int v2 = *(_DWORD *)(this + 24);
  if (v1 >= v2)
  {
    unsigned int v1 = 0;
    *(_DWORD *)(this + 36) = 0;
  }
  int v4 = *(_DWORD *)(this + 12);
  int v3 = *(_DWORD *)(this + 16);
  unsigned int v5 = v3 - v4;
  if (v3 != v4)
  {
    if (v1 >= v5) {
      unsigned int v6 = 0;
    }
    else {
      unsigned int v6 = v2;
    }
    unsigned int v7 = v1 - v5 + v6;
    uint64_t v8 = *(void *)(this + 56);
    if (v5 < 0x14) {
      goto LABEL_17;
    }
    unsigned int v9 = 0;
    int v10 = v3 + ~v4;
    BOOL v11 = __CFADD__(v1, v10);
    BOOL v12 = __CFADD__(v7, v10);
    if (v11 || v12) {
      goto LABEL_18;
    }
    if (4 * v1 - 4 * (unint64_t)v7 >= 0x20)
    {
      unsigned int v9 = v5 & 0xFFFFFFF8;
      unsigned int v14 = v1 + (v5 & 0xFFFFFFF8);
      int v16 = v6 + v4 - v3;
      uint64_t v17 = v5 & 0xFFFFFFF8;
      do
      {
        unsigned int v18 = (long long *)(v8 + 4 * (v16 + v1));
        long long v19 = *v18;
        long long v20 = v18[1];
        unsigned int v21 = (_OWORD *)(v8 + 4 * v1);
        *unsigned int v21 = v19;
        v21[1] = v20;
        v1 += 8;
        v17 -= 8;
      }
      while (v17);
      if (v5 == v9) {
        goto LABEL_21;
      }
      v7 += v9;
      unsigned int v1 = v14;
    }
    else
    {
LABEL_17:
      unsigned int v9 = 0;
    }
LABEL_18:
    int v13 = v9 + v4 - v3;
    unsigned int v14 = v1;
    do
      *(_DWORD *)(v8 + 4 * v14++) = *(_DWORD *)(v8 + 4 * v7++);
    while (!__CFADD__(v13++, 1));
LABEL_21:
    *(_DWORD *)(this + 36) = v14;
  }
  return this;
}

void NDEHMMDetector::~NDEHMMDetector(NDEHMMDetector *this)
{
  NDEHMMDetector::~NDEHMMDetector(this);

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(void *)this = &unk_26C99AB30;
  unsigned int v2 = *((void *)this + 1);
  if (v2)
  {
    if (!*((void *)this + 2)
      || ((*(void (**)(uint64_t))(*(void *)v2 + 152))(v2), (unsigned int v2 = *((void *)this + 1)) != 0))
    {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }
  *((void *)this + 21) = &unk_26C99C348;
  int v3 = *((void *)this + 22);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
  *((void *)this + 18) = &unk_26C99C348;
  int v4 = *((void *)this + 19);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  *((void *)this + 12) = &unk_26C99C348;
  unsigned int v5 = *((void *)this + 13);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NArray<NDELRHMMModel>::~NArray((void *)this + 3);
}

void *NArray<NDELRHMMModel>::~NArray(void *a1)
{
  *a1 = &unk_26C99BF90;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = v2 - 16;
    uint64_t v4 = *(void *)(v2 - 8);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 136 * v4;
      uint64_t v7 = v2 - 56;
      do
      {
        uint64_t v8 = (void *)(v7 + v6);
        *(void *)(v7 + v6 + 24) = &unk_26C99C3F0;
        uint64_t v9 = *(void *)(v7 + v6 + 32);
        if (v9) {
          MEMORY[0x21D46B220](v9, 0x1000C8052888210);
        }
        *uint64_t v8 = &unk_26C99C348;
        uint64_t v10 = v8[1];
        if (v10) {
          MEMORY[0x21D46B220](v10, 0x1000C8052888210);
        }
        uint64_t v11 = v7 + v6;
        *(void *)(v7 + v6 - 32) = &unk_26C99C3F0;
        uint64_t v12 = *(void *)(v7 + v6 - 24);
        if (v12) {
          MEMORY[0x21D46B220](v12, 0x1000C8052888210);
        }
        *(void *)(v11 - 56) = &unk_26C99C348;
        uint64_t v13 = *(void *)(v11 - 48);
        if (v13) {
          MEMORY[0x21D46B220](v13, 0x1000C8052888210);
        }
        *(v8 - 10) = &unk_26C99C348;
        uint64_t v14 = *(void *)(v7 + v6 - 72);
        if (v14) {
          MEMORY[0x21D46B220](v14, 0x1000C8052888210);
        }
        v2 -= 136;
        v5 += 136;
        v7 -= 136;
      }
      while (v6 != v5);
    }
    MEMORY[0x21D46B220](v3, 0x1090C80C1CE278ELL);
  }
  return a1;
}

uint64_t NArray<NDELRHMMModel>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NDELRHMMModel::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (_DWORD *)result;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      v3[4] = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      uint64_t v10 = v4;
      if (v4 < 8) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFF8;
      uint64_t v11 = (_OWORD *)(v9 + 16);
      uint64_t v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFF8;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *uint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 4 * v7;
        uint64_t v17 = (_DWORD *)(v9 + v16);
        unsigned int v18 = (int *)(v8 + v16);
        do
        {
          int v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
    unsigned int v20 = *(_DWORD *)(result + 40);
    int v21 = *(_DWORD *)(a2 + 40);
    if (v20 != v21)
    {
      uint64_t v22 = *(void *)(result + 32);
      if (v22)
      {
        MEMORY[0x21D46B220](v22, 0x1000C8052888210);
        int v21 = *(_DWORD *)(a2 + 40);
      }
      v3[10] = v21;
      operator new[]();
    }
    if (v20)
    {
      uint64_t v23 = 0;
      uint64_t v24 = *(void *)(a2 + 32);
      uint64_t v25 = *(void *)(result + 32);
      uint64_t v26 = v20;
      if (v20 < 8) {
        goto LABEL_24;
      }
      if ((unint64_t)(v25 - v24) < 0x20) {
        goto LABEL_24;
      }
      uint64_t v23 = v20 & 0xFFFFFFF8;
      uint64_t v27 = (_OWORD *)(v25 + 16);
      uint64_t v28 = (long long *)(v24 + 16);
      uint64_t v29 = v26 & 0xFFFFFFF8;
      do
      {
        long long v30 = *v28;
        *(v27 - 1) = *(v28 - 1);
        *uint64_t v27 = v30;
        v27 += 2;
        v28 += 2;
        v29 -= 8;
      }
      while (v29);
      if (v23 != v26)
      {
LABEL_24:
        uint64_t v31 = v26 - v23;
        uint64_t v32 = 4 * v23;
        float v33 = (_DWORD *)(v25 + v32);
        long double v34 = (int *)(v24 + v32);
        do
        {
          int v35 = *v34++;
          *v33++ = v35;
          --v31;
        }
        while (v31);
      }
    }
    int v36 = *(_DWORD *)(result + 64);
    int v37 = *(_DWORD *)(a2 + 64);
    if (v36 != v37)
    {
      uint64_t v38 = *(void *)(result + 56);
      if (v38)
      {
        MEMORY[0x21D46B220](v38, 0x1000C8052888210);
        int v37 = *(_DWORD *)(a2 + 64);
      }
      v3[16] = v37;
      operator new[]();
    }
    if (v36)
    {
      unint64_t v39 = 0;
      uint64_t v40 = *(void *)(a2 + 56);
      uint64_t v41 = *(void *)(result + 56);
      do
      {
        *(_DWORD *)(v41 + 4 * v39) = *(_DWORD *)(v40 + 4 * v39);
        ++v39;
      }
      while (v39 < *(unsigned int *)(result + 64));
    }
    *(_DWORD *)(result + 72) = *(_DWORD *)(a2 + 72);
    unsigned int v42 = *(_DWORD *)(result + 96);
    int v43 = *(_DWORD *)(a2 + 96);
    if (v42 != v43)
    {
      uint64_t v44 = *(void *)(result + 88);
      if (v44)
      {
        MEMORY[0x21D46B220](v44, 0x1000C8052888210);
        int v43 = *(_DWORD *)(a2 + 96);
      }
      v3[24] = v43;
      operator new[]();
    }
    if (v42)
    {
      uint64_t v45 = 0;
      uint64_t v46 = *(void *)(a2 + 88);
      uint64_t v47 = *(void *)(result + 88);
      uint64_t v48 = v42;
      if (v42 < 8) {
        goto LABEL_43;
      }
      if ((unint64_t)(v47 - v46) < 0x20) {
        goto LABEL_43;
      }
      uint64_t v45 = v42 & 0xFFFFFFF8;
      int16x8_t v49 = (_OWORD *)(v47 + 16);
      int16x8_t v50 = (long long *)(v46 + 16);
      uint64_t v51 = v48 & 0xFFFFFFF8;
      do
      {
        long long v52 = *v50;
        *(v49 - 1) = *(v50 - 1);
        *int16x8_t v49 = v52;
        v49 += 2;
        v50 += 2;
        v51 -= 8;
      }
      while (v51);
      if (v45 != v48)
      {
LABEL_43:
        uint64_t v53 = v48 - v45;
        uint64_t v54 = 4 * v45;
        uint64_t v55 = (_DWORD *)(v47 + v54);
        unsigned int v56 = (int *)(v46 + v54);
        do
        {
          int v57 = *v56++;
          *v55++ = v57;
          --v53;
        }
        while (v53);
      }
    }
    int v58 = *(_DWORD *)(result + 120);
    int v59 = *(_DWORD *)(a2 + 120);
    if (v58 != v59)
    {
      uint64_t v60 = *(void *)(result + 112);
      if (v60)
      {
        MEMORY[0x21D46B220](v60, 0x1000C8052888210);
        int v59 = *(_DWORD *)(a2 + 120);
      }
      v3[30] = v59;
      operator new[]();
    }
    if (v58)
    {
      unint64_t v61 = 0;
      uint64_t v62 = *(void *)(a2 + 112);
      uint64_t v63 = *(void *)(result + 112);
      do
      {
        *(_DWORD *)(v63 + 4 * v61) = *(_DWORD *)(v62 + 4 * v61);
        ++v61;
      }
      while (v61 < *(unsigned int *)(result + 120));
    }
  }
  *(_DWORD *)(result + 128) = *(_DWORD *)(a2 + 128);
  return result;
}

uint64_t NArray<NDELRHMMModel>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v22 = v7 - 16;
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 136 * v9;
        uint64_t v12 = v7 - 56;
        do
        {
          uint64_t v13 = (void *)(v12 + v11);
          *(void *)(v12 + v11 + 24) = &unk_26C99C3F0;
          uint64_t v14 = *(void *)(v12 + v11 + 32);
          if (v14) {
            MEMORY[0x21D46B220](v14, 0x1000C8052888210);
          }
          *uint64_t v13 = &unk_26C99C348;
          uint64_t v15 = v13[1];
          if (v15) {
            MEMORY[0x21D46B220](v15, 0x1000C8052888210);
          }
          uint64_t v16 = v12 + v11;
          *(void *)(v12 + v11 - 32) = &unk_26C99C3F0;
          uint64_t v17 = *(void *)(v12 + v11 - 24);
          if (v17) {
            MEMORY[0x21D46B220](v17, 0x1000C8052888210);
          }
          *(void *)(v16 - 56) = &unk_26C99C348;
          uint64_t v18 = *(void *)(v16 - 48);
          if (v18) {
            MEMORY[0x21D46B220](v18, 0x1000C8052888210);
          }
          *(v13 - 10) = &unk_26C99C348;
          uint64_t v19 = *(void *)(v12 + v11 - 72);
          if (v19) {
            MEMORY[0x21D46B220](v19, 0x1000C8052888210);
          }
          v7 -= 136;
          v10 += 136;
          v12 -= 136;
        }
        while (v11 != v10);
      }
      MEMORY[0x21D46B220](v22, 0x1090C80C1CE278ELL);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v20 = 0;
    unint64_t v21 = 0;
    do
    {
      int32x2_t result = NDELRHMMModel::operator=(*(void *)(v4 + 8) + v20, a2 + v20);
      ++v21;
      v20 += 136;
    }
    while (v21 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NDELRHMMModel>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = v6 - 16;
        uint64_t v8 = *(void *)(v6 - 8);
        if (v8)
        {
          uint64_t v9 = 0;
          uint64_t v10 = 136 * v8;
          uint64_t v11 = v6 - 56;
          do
          {
            uint64_t v12 = (void *)(v11 + v10);
            *(void *)(v11 + v10 + 24) = &unk_26C99C3F0;
            uint64_t v13 = *(void *)(v11 + v10 + 32);
            if (v13) {
              MEMORY[0x21D46B220](v13, 0x1000C8052888210);
            }
            void *v12 = &unk_26C99C348;
            uint64_t v14 = v12[1];
            if (v14) {
              MEMORY[0x21D46B220](v14, 0x1000C8052888210);
            }
            uint64_t v15 = v11 + v10;
            *(void *)(v11 + v10 - 32) = &unk_26C99C3F0;
            uint64_t v16 = *(void *)(v11 + v10 - 24);
            if (v16) {
              MEMORY[0x21D46B220](v16, 0x1000C8052888210);
            }
            *(void *)(v15 - 56) = &unk_26C99C348;
            uint64_t v17 = *(void *)(v15 - 48);
            if (v17) {
              MEMORY[0x21D46B220](v17, 0x1000C8052888210);
            }
            *(v12 - 10) = &unk_26C99C348;
            uint64_t v18 = *(void *)(v11 + v10 - 72);
            if (v18) {
              MEMORY[0x21D46B220](v18, 0x1000C8052888210);
            }
            v6 -= 136;
            v9 += 136;
            v11 -= 136;
          }
          while (v10 != v9);
        }
        MEMORY[0x21D46B220](v7, 0x1090C80C1CE278ELL);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v19 = 0;
      unint64_t v20 = 0;
      do
      {
        NDELRHMMModel::operator=(*(void *)(a1 + 8) + v19, *(void *)(a2 + 8) + v19);
        ++v20;
        v19 += 136;
      }
      while (v20 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void NArray<NDELRHMMModel>::~NArray(void *a1)
{
  NArray<NDELRHMMModel>::~NArray(a1);

  JUMPOUT(0x21D46B240);
}

void NDELRHMMModel::NDELRHMMModel(NDELRHMMModel *this)
{
  *(void *)this = &unk_26C99C348;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = &unk_26C99C348;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 6) = &unk_26C99C3F0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 10) = &unk_26C99C348;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 13) = &unk_26C99C3F0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 32) = 0;
}

{
  *(void *)this = &unk_26C99C348;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = &unk_26C99C348;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 6) = &unk_26C99C3F0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_DWORD *)this + 18) = 0;
  *((void *)this + 10) = &unk_26C99C348;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 13) = &unk_26C99C3F0;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_DWORD *)this + 32) = 0;
}

void NDELRHMMModel::init(uint64_t a1, const char *a2, _DWORD *a3, unsigned int *a4, float *a5, _DWORD *a6, float *a7)
{
  int v10 = *a3 + 1;
  *(_DWORD *)(a1 + 72) = v10;
  if (*(_DWORD *)(a1 + 16) != v10)
  {
    *(_DWORD *)(a1 + 16) = v10;
    operator new[]();
  }
  if (*(_DWORD *)(a1 + 40) != v10)
  {
    *(_DWORD *)(a1 + 40) = v10;
    operator new[]();
  }
  if (*(_DWORD *)(a1 + 64) != v10)
  {
    *(_DWORD *)(a1 + 64) = v10;
    operator new[]();
  }
  if (*(_DWORD *)(a1 + 96) != v10 + 1)
  {
    *(_DWORD *)(a1 + 96) = v10 + 1;
    operator new[]();
  }
  int v11 = *(_DWORD *)(a1 + 72) + 1;
  if (*(_DWORD *)(a1 + 120) != v11)
  {
    *(_DWORD *)(a1 + 120) = v11;
    operator new[]();
  }
  *(_DWORD *)(a1 + 128) = *a6;
  LODWORD(v12) = *(_DWORD *)(a1 + 72);
  if (v12 < 2)
  {
    uint64_t v18 = *(_DWORD **)(a1 + 56);
LABEL_21:
    uint64_t v26 = *(float **)(a1 + 32);
    uint64_t v24 = *(float **)(a1 + 8);
    goto LABEL_22;
  }
  unint64_t v13 = 1;
  uint64_t v14 = (unsigned int *)a2;
  do
  {
    unsigned int v16 = *v14;
    v14 += 2;
    uint64_t v15 = v16;
    uint64_t v17 = *a4;
    if (v16 >= v17) {
      Error::chuck((Error *)"NDELRHMMModel::init() - HMM includes invalid index %d (>=%d)", a2, v15, v17);
    }
    uint64_t v18 = *(_DWORD **)(a1 + 56);
    v18[v13++] = v15;
    unint64_t v12 = *(unsigned int *)(a1 + 72);
  }
  while (v13 < v12);
  if (v12 <= 1) {
    goto LABEL_21;
  }
  uint64_t v19 = (float *)(a2 + 4);
  for (uint64_t i = 1; i != v12; ++i)
  {
    double v21 = *v19;
    if (*v19 <= 1.0) {
      Error::chuck((Error *)"NDELRHMMModel::init() - Duration %f less than or equal to 1.0 on hmmstate: %d", a2, *(void *)&v21, i);
    }
    float v22 = 1.0 - 1.0 / v21;
    float v23 = logf(v22);
    uint64_t v24 = *(float **)(a1 + 8);
    v24[i] = v23;
    float v25 = logf(1.0 - v22);
    uint64_t v26 = *(float **)(a1 + 32);
    v26[i] = v25;
    v19 += 2;
  }
LABEL_22:
  v26[(v12 - 1)] = *a5 + v26[(v12 - 1)];
  float v27 = 1.0 - 1.0 / *a7;
  *uint64_t v24 = logf(v27);
  *uint64_t v26 = logf(1.0 - v27);
  *uint64_t v18 = -1;
}

uint64_t NDELRHMMModel::updateFirstStateOutputID(uint64_t this, const unsigned int *a2)
{
  if (*(_DWORD *)(this + 64)) {
    **(_DWORD **)(this + 56) = *a2;
  }
  return this;
}

uint64_t NDELRHMMModel::reset(uint64_t this)
{
  if (*(_DWORD *)(this + 72))
  {
    unsigned int v1 = *(_DWORD **)(this + 88);
    *unsigned int v1 = 0;
    uint64_t v2 = *(_DWORD **)(this + 112);
    *uint64_t v2 = 0;
    if (*(_DWORD *)(this + 72))
    {
      unsigned int v3 = 1;
      do
      {
        uint64_t v4 = v3;
        v1[v4] = -8388609;
        v2[v4] = 0;
        ++v3;
      }
      while (v3 <= *(_DWORD *)(this + 72));
    }
  }
  return this;
}

uint64_t NDELRHMMModel::stepFrame(uint64_t result, uint64_t a2, float *a3, _DWORD *a4, double a5)
{
  int v5 = *(_DWORD *)(result + 72);
  uint64_t v6 = (v5 - 1);
  if (v5 == 1) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)(result + 88);
  uint64_t v8 = *(void *)(result + 8);
  unsigned int v9 = v5 - 2;
  uint64_t v10 = *(void *)(result + 32);
  do
  {
    float v11 = *(float *)(v7 + 4 * v6) + *(float *)(v8 + 4 * v6);
    float v12 = *(float *)(v7 + 4 * v9) + *(float *)(v10 + 4 * v9);
    if (v11 <= v12)
    {
      *(_DWORD *)(*(void *)(result + 112) + 4 * v6) = *(_DWORD *)(*(void *)(result + 112) + 4 * v9);
      float v11 = v12;
    }
    *(float *)(v7 + 4 * v6) = v11;
    --v9;
    --v6;
  }
  while (v6);
  uint64_t v13 = *(unsigned int *)(result + 72);
  if (v13 <= 1)
  {
LABEL_10:
    uint64_t v18 = *(float **)(result + 88);
  }
  else
  {
    uint64_t v14 = *(void *)(result + 56);
    uint64_t v15 = *(void *)(a2 + 8);
    uint64_t v16 = 4 * v13;
    uint64_t v17 = 4;
    uint64_t v18 = *(float **)(result + 88);
    do
    {
      v18[(unint64_t)v17 / 4] = *(float *)(v15 + 4 * *(unsigned int *)(v14 + v17))
                                     + v18[(unint64_t)v17 / 4];
      v17 += 4;
    }
    while (v16 != v17);
  }
  float v19 = *v18 + **(float **)(result + 8);
  *uint64_t v18 = v19;
  *uint64_t v18 = v19 + *a3;
  unint64_t v20 = *(_DWORD **)(result + 112);
  *unint64_t v20 = *a4 + 1;
  uint64_t v21 = *(unsigned int *)(result + 72);
  uint64_t v22 = (v21 - 1);
  float v23 = *(float **)(result + 32);
  v21 *= 4;
  *(float *)((char *)v18 + v21) = v18[v22] + v23[v22];
  *(_DWORD *)((char *)v20 + v21) = v20[v22];
  *(float *)&a5 = *v18 + *v23;
  int v24 = *(_DWORD *)(result + 72);
  if ((v24 + 1) > 1) {
    uint64_t v25 = (v24 + 1);
  }
  else {
    uint64_t v25 = 1;
  }
  if (v25 < 8)
  {
    uint64_t v26 = 0;
LABEL_19:
    uint64_t v31 = v25 - v26;
    uint64_t v32 = &v18[v26];
    do
    {
      *uint64_t v32 = *v32 - *(float *)&a5;
      ++v32;
      --v31;
    }
    while (v31);
    return result;
  }
  uint64_t v26 = v25 & 0xFFFFFFF8;
  float32x4_t v27 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a5, 0);
  uint64_t v28 = (float32x4_t *)(v18 + 4);
  uint64_t v29 = v26;
  do
  {
    float32x4_t v30 = vsubq_f32(*v28, v27);
    v28[-1] = vsubq_f32(v28[-1], v27);
    *uint64_t v28 = v30;
    v28 += 2;
    v29 -= 8;
  }
  while (v29);
  if (v26 != v25) {
    goto LABEL_19;
  }
  return result;
}

void NDEHMMDetector::NDEHMMDetector(NDEHMMDetector *this)
{
  *(void *)this = &unk_26C99AB30;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = &unk_26C99BF90;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = &unk_26C99C498;
  *((_OWORD *)this + 9) = 0u;
  *((_WORD *)this + 60) = 1;
  *((_OWORD *)this + 8) = 0u;
  *((void *)this + 20) = 0;
  *((void *)this + 18) = &unk_26C99C498;
  *((void *)this + 21) = &unk_26C99C348;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 48) = -8388609;
  *(void *)((char *)this + 204) = 0;
  *(void *)((char *)this + 196) = 0;
  *(_DWORD *)((char *)this + 211) = 0;
}

{
  *(void *)this = &unk_26C99AB30;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = &unk_26C99BF90;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *(_OWORD *)((char *)this + 76) = 0u;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 12) = &unk_26C99C498;
  *((_OWORD *)this + 9) = 0u;
  *((_WORD *)this + 60) = 1;
  *((_OWORD *)this + 8) = 0u;
  *((void *)this + 20) = 0;
  *((void *)this + 18) = &unk_26C99C498;
  *((void *)this + 21) = &unk_26C99C348;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 48) = -8388609;
  *(void *)((char *)this + 204) = 0;
  *(void *)((char *)this + 196) = 0;
  *(_DWORD *)((char *)this + 211) = 0;
}

void NDEHMMDetector::init(uint64_t a1, const char *a2)
{
  if (!*(unsigned char *)(a1 + 212)) {
    operator new();
  }
  Error::chuck((Error *)"NDEHMMDetector::init() - init() already called", a2);
}

void sub_2184B7460(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x10F1C40D53CD75ELL);
  _Unwind_Resume(a1);
}

void NDEHMMDetector::initHMM(NDEHMMDetector *this, const char *a2, const unsigned int *a3, unsigned int *a4, const int *a5, int *a6, float *a7)
{
  if (!a2) {
    Error::chuck((Error *)"NDEHMMDetector::initHMM() - NULL blob provided", 0, a3, a4, a5, a6);
  }
  uint64_t v9 = *(unsigned int *)a5;
  int v10 = *a6;
  *((unsigned char *)this + 214) = *a6 < 0;
  if ((int)v9 >= -1) {
    uint64_t v11 = 1;
  }
  else {
    uint64_t v11 = 3;
  }
  uint64_t v12 = *a3;
  if (v12 <= 3) {
    goto LABEL_39;
  }
  uint64_t v13 = a2;
  uint64_t v14 = *(unsigned int *)a2;
  if (v9 == -1 || (int)v9 < -256 || (int)v9 >= (int)v14) {
    Error::chuck((Error *)"NDEHMMDetector::initHMM() - wrong keyword_id %d (%d)", a2, v9, v14);
  }
  int v37 = 1;
  if ((int)v9 <= -2)
  {
    int v37 = v14 + (~v10 >> 31);
    if (!v37) {
      Error::chuck((Error *)"NDEHMMDetector::initHMM() - wrong num_keywords", a2);
    }
  }
  NArray<NDELRHMMModel>::resize((uint64_t)this + 24, &v37);
  if (v14)
  {
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    uint64_t v17 = &v13[v12];
    uint64_t v18 = (unsigned int *)(v13 + 4);
    int v19 = -1;
    unint64_t v20 = a6;
    while (&v18[v11] <= (unsigned int *)v17)
    {
      unsigned int v35 = 0;
      unsigned int v36 = 0;
      if ((int)v9 <= -2)
      {
        unsigned int v21 = *v18;
        unsigned int v22 = v18[1];
        v18 += 2;
        unsigned int v35 = v22;
        unsigned int v36 = v21;
      }
      a2 = (const char *)(v18 + 1);
      uint64_t v23 = *v18;
      v18 += 2 * v23 + 1;
      if (v18 > (unsigned int *)v17) {
        break;
      }
      int v24 = *v20;
      if ((*v20 & 0x80000000) == 0 && v15 == v24)
      {
        if (v23 != 1) {
          Error::chuck((Error *)"NDEHMMDetector::initHMM() - GSM HMM (id %d) must be single state", a2, v15);
        }
        int v19 = *(_DWORD *)a2;
      }
      BOOL v26 = *a5 >= 0 || v15 == v24;
      if ((v15 == *a5 || !v26) && v16 < *((unsigned int *)this + 10))
      {
        uint64_t v27 = *((void *)this + 4) + 136 * v16;
        int v34 = v23;
        NDELRHMMModel::init(v27, a2, &v34, a4, (float *)&v36, &v35, a7);
        unint64_t v20 = a6;
        ++v16;
      }
      uint64_t v15 = (v15 + 1);
      if (v14 == v15) {
        goto LABEL_33;
      }
    }
LABEL_39:
    Error::chuck((Error *)"NDEHMMDetector::initHMM() - blobsize too small", a2);
  }
  int v19 = -1;
LABEL_33:
  unint64_t v28 = *((unsigned int *)this + 10);
  if (v28)
  {
    unint64_t v29 = 0;
    float32x4_t v30 = (_DWORD *)(*((void *)this + 4) + 64);
    do
    {
      if (*v30)
      {
        **((_DWORD **)v30 - 1) = v19;
        unint64_t v28 = *((unsigned int *)this + 10);
      }
      ++v29;
      v30 += 34;
    }
    while (v29 < v28);
  }
}

uint64_t NDEHMMDetector::reset(uint64_t this)
{
  *(_DWORD *)(this + 192) = -8388609;
  *(void *)(this + 204) = 0;
  *(void *)(this + 196) = 0;
  if (*(_DWORD *)(this + 40))
  {
    unint64_t v1 = 0;
    uint64_t v2 = *(void *)(this + 32);
    do
    {
      uint64_t v3 = v2 + 136 * v1;
      int v5 = *(_DWORD *)(v3 + 72);
      uint64_t v4 = (unsigned int *)(v3 + 72);
      if (v5)
      {
        uint64_t v6 = v2 + 136 * v1;
        uint64_t v7 = *(_DWORD **)(v6 + 88);
        *uint64_t v7 = 0;
        uint64_t v8 = *(_DWORD **)(v6 + 112);
        *uint64_t v8 = 0;
        if (*v4)
        {
          unsigned int v9 = 1;
          do
          {
            uint64_t v10 = v9;
            v7[v10] = -8388609;
            v8[v10] = 0;
            ++v9;
          }
          while (v9 <= *v4);
        }
      }
      ++v1;
    }
    while (v1 < *(unsigned int *)(this + 40));
  }
  *(_WORD *)(this + 120) = 1;
  *(_DWORD *)(this + 84) = 0;
  *(_DWORD *)(this + 88) = 0;
  uint64_t v11 = *(void *)(this + 8);
  if (v11)
  {
    if (*(void *)(this + 16)) {
      return (*(uint64_t (**)(void))(*(void *)v11 + 160))(*(void *)(this + 8));
    }
  }
  return this;
}

void NDEHMMDetector::feedFrame(NDEHMMDetector *this, const NFrame *a2)
{
  if (!*((unsigned char *)this + 212)) {
    Error::chuck((Error *)"NDEHMMDetector::feedFrame() - init() not called", (const char *)a2);
  }
  uint64_t v2 = a2;
  if (!*((unsigned char *)this + 213)) {
    goto LABEL_10;
  }
  int v4 = *((_DWORD *)a2 + 4);
  if (!v4) {
    Error::chuck((Error *)"NFrameWindow::pushFrame() - cannot feed zero-sized frames", (const char *)a2);
  }
  uint64_t v5 = *((unsigned int *)this + 14);
  if (v4 != v5) {
    Error::chuck((Error *)"NFrameWindow::pushFrame() - mismatched input frame size (%d != %d)", (const char *)a2, *((unsigned int *)a2 + 4), v5);
  }
  v6.n128_u64[0] = (unint64_t)NFrameWindow::pushFrame((NDEHMMDetector *)((char *)this + 48), *((const float **)a2 + 1));
  int v7 = *((_DWORD *)this + 22);
  if (*((unsigned char *)this + 121) && v7 || v7 == *((_DWORD *)this + 13) + 1)
  {
    uint64_t v8 = (char *)this + 68;
    if (!*((_DWORD *)this + 17)) {
      Error::chuck((Error *)"NFrameWindow::setOutputFrameWindow() - frame window not configured", v8, v6.n128_f64[0]);
    }
    uint64_t v2 = (NDEHMMDetector *)((char *)this + 144);
    (*(void (**)(char *, const char *, __n128))(*((void *)this + 18) + 32))((char *)this + 144, v8, v6);
    NFrameWindow::setOutputFrameWindow((uint64_t)this + 48, *((float **)this + 19));
LABEL_10:
    NDEHMMDetector::stepFrame((uint64_t)this, v2);
  }
  ++*((_DWORD *)this + 50);
}

uint64_t NDEHMMDetector::stepFrame(uint64_t this, const NFrame *a2)
{
  uint64_t v2 = this;
  int v3 = *(_DWORD *)(this + 208);
  if (v3)
  {
    *(_DWORD *)(this + 208) = v3 - 1;
  }
  else
  {
    uint64_t v5 = (_DWORD *)(this + 204);
    int v4 = *(_DWORD *)(this + 204);
    int v6 = *(_DWORD *)(this + 136);
    if (v4) {
      *uint64_t v5 = v6 + v4;
    }
    *(_DWORD *)(this + 208) = v6;
    this = (*(uint64_t (**)(void, const NFrame *, uint64_t, void))(**(void **)(this + 8) + 72))(*(void *)(this + 8), a2, this + 168, *(void *)(this + 16));
    if (*(unsigned char *)(v2 + 214))
    {
      uint64_t v8 = *(unsigned int *)(v2 + 184);
      if (v8)
      {
        unsigned int v9 = *(_DWORD **)(v2 + 176);
        LODWORD(v7) = *v9;
        if (v8 != 1)
        {
          uint64_t v10 = v8 - 1;
          uint64_t v11 = (float *)(v9 + 1);
          do
          {
            float v12 = *v11++;
            float v13 = v12;
            if (v12 > *(float *)&v7) {
              *(float *)&double v7 = v13;
            }
            --v10;
          }
          while (v10);
        }
      }
      else
      {
        double v7 = 0.0;
      }
    }
    else
    {
      LODWORD(v7) = *(_DWORD *)(*(void *)(v2 + 176) + 4 * **(unsigned int **)(*(void *)(v2 + 32) + 56));
    }
    int v19 = LODWORD(v7);
    if (*(_DWORD *)(v2 + 40))
    {
      uint64_t v14 = 0;
      unint64_t v15 = 0;
      do
      {
        this = NDELRHMMModel::stepFrame(*(void *)(v2 + 32) + v14, v2 + 168, (float *)&v19, (_DWORD *)(v2 + 204), v7);
        ++v15;
        v14 += 136;
      }
      while (v15 < *(unsigned int *)(v2 + 40));
    }
    uint64_t v16 = *(unsigned int *)(v2 + 132);
    if (v16)
    {
      uint64_t v17 = *(void *)(v2 + 32);
      uint64_t v18 = 4 * v16;
      *(float *)(v2 + 192) = *(float *)(*(void *)(v17 + 88) + v18) * (float)(*(_DWORD *)(v2 + 136) + 1);
      *(_DWORD *)(v2 + 196) = *(_DWORD *)(*(void *)(v17 + 112) + v18);
    }
    ++*v5;
  }
  return this;
}

uint64_t NDEHMMDetector::numKeywords(NDEHMMDetector *this)
{
  return *((unsigned int *)this + 10);
}

BOOL NDEHMMDetector::skipUntilProcessedFrame(NDEHMMDetector *this)
{
  int v1 = *((_DWORD *)this + 52);
  if (v1)
  {
    int v2 = v1 - 1;
  }
  else
  {
    int v3 = *((_DWORD *)this + 51);
    int v2 = *((_DWORD *)this + 34);
    if (v3) {
      *((_DWORD *)this + 51) = v2 + v3;
    }
  }
  *((_DWORD *)this + 52) = v2;
  return v1 != 0;
}

double NDEHMMDetector::maxScore(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 16);
  if (!v2) {
    return 0.0;
  }
  int v3 = *(_DWORD **)(a2 + 8);
  LODWORD(result) = *v3;
  if (v2 != 1)
  {
    uint64_t v5 = v2 - 1;
    int v6 = (float *)(v3 + 1);
    do
    {
      float v7 = *v6++;
      float v8 = v7;
      if (v7 > *(float *)&result) {
        *(float *)&double result = v8;
      }
      --v5;
    }
    while (v5);
  }
  return result;
}

float NDEHMMDetector::partialScore(NDEHMMDetector *this)
{
  return *((float *)this + 48);
}

uint64_t NDEHMMDetector::partialLength(NDEHMMDetector *this)
{
  if (*((_DWORD *)this + 33)) {
    return (*((_DWORD *)this + 51) - *((_DWORD *)this + 49));
  }
  else {
    return 0;
  }
}

float NDEHMMDetector::scorePhrase(NDEHMMDetector *this, unsigned int a2)
{
  if (*((_DWORD *)this + 10) <= a2) {
    return -3.4028e38;
  }
  uint64_t v2 = *((void *)this + 4) + 136 * a2;
  return *(float *)(*(void *)(v2 + 88) + 4 * *(unsigned int *)(v2 + 72))
       * (float)(*((_DWORD *)this + 34) + 1);
}

float NDEHMMDetector::phraseScoreOffset(NDEHMMDetector *this, unsigned int a2)
{
  float result = 0.0;
  if (*((_DWORD *)this + 10) > a2) {
    return *(float *)(*((void *)this + 4) + 136 * a2 + 128);
  }
  return result;
}

uint64_t NDEHMMDetector::bestLengthPhrase(NDEHMMDetector *this, unsigned int a2)
{
  if (*((_DWORD *)this + 10) <= a2) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 4) + 136 * a2;
  return (*((_DWORD *)this + 51) - *(_DWORD *)(*(void *)(v2 + 112) + 4 * *(unsigned int *)(v2 + 72)));
}

uint64_t NDEHMMDetector::frameLatency(NDEHMMDetector *this)
{
  int v1 = *((_DWORD *)this + 50) - *((_DWORD *)this + 51) + *((_DWORD *)this + 35);
  return v1 & ~(v1 >> 31);
}

uint64_t NArray<NGaussianMixture>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NGaussianMixture::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      unint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(result + 16));
    }
    unsigned int v10 = *(_DWORD *)(result + 40);
    int v11 = *(_DWORD *)(a2 + 40);
    if (v10 != v11)
    {
      uint64_t v12 = *(void *)(result + 32);
      if (v12)
      {
        MEMORY[0x21D46B220](v12, 0x1000C8052888210);
        int v11 = *(_DWORD *)(a2 + 40);
      }
      *(_DWORD *)(v2 + 40) = v11;
      operator new[]();
    }
    if (v10)
    {
      uint64_t v13 = 0;
      uint64_t v14 = *(void *)(a2 + 32);
      uint64_t v15 = *(void *)(result + 32);
      uint64_t v16 = v10;
      if (v10 < 8) {
        goto LABEL_19;
      }
      if ((unint64_t)(v15 - v14) < 0x20) {
        goto LABEL_19;
      }
      uint64_t v13 = v10 & 0xFFFFFFF8;
      uint64_t v17 = (_OWORD *)(v15 + 16);
      uint64_t v18 = (long long *)(v14 + 16);
      uint64_t v19 = v16 & 0xFFFFFFF8;
      do
      {
        long long v20 = *v18;
        *(v17 - 1) = *(v18 - 1);
        *uint64_t v17 = v20;
        v17 += 2;
        v18 += 2;
        v19 -= 8;
      }
      while (v19);
      if (v13 != v16)
      {
LABEL_19:
        uint64_t v21 = v16 - v13;
        uint64_t v22 = 4 * v13;
        uint64_t v23 = (_DWORD *)(v15 + v22);
        int v24 = (int *)(v14 + v22);
        do
        {
          int v25 = *v24++;
          *v23++ = v25;
          --v21;
        }
        while (v21);
      }
    }
  }
  return result;
}

uint64_t NArray<NGaussianMixture>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = 48 * v9;
        uint64_t v11 = v7 - 24;
        do
        {
          uint64_t v12 = v11 + v10;
          *(void *)(v11 + v10) = &unk_26C99C348;
          uint64_t v13 = *(void *)(v11 + v10 + 8);
          if (v13) {
            MEMORY[0x21D46B220](v13, 0x1000C8052888210);
          }
          *(void *)(v12 - 24) = &unk_26C99C3F0;
          uint64_t v14 = *(void *)(v12 - 16);
          if (v14) {
            MEMORY[0x21D46B220](v14, 0x1000C8052888210);
          }
          v10 -= 48;
        }
        while (v10);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x1090C806BD41B22);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    do
    {
      float result = NGaussianMixture::operator=(*(void *)(v4 + 8) + v15, a2 + v15);
      ++v16;
      v15 += 48;
    }
    while (v16 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NGaussianMixture>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 48 * v7;
          uint64_t v9 = v6 - 24;
          do
          {
            uint64_t v10 = v9 + v8;
            *(void *)(v9 + v8) = &unk_26C99C348;
            uint64_t v11 = *(void *)(v9 + v8 + 8);
            if (v11) {
              MEMORY[0x21D46B220](v11, 0x1000C8052888210);
            }
            *(void *)(v10 - 24) = &unk_26C99C3F0;
            uint64_t v12 = *(void *)(v10 - 16);
            if (v12) {
              MEMORY[0x21D46B220](v12, 0x1000C8052888210);
            }
            v8 -= 48;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x1090C806BD41B22);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      do
      {
        NGaussianMixture::operator=(*(void *)(a1 + 8) + v13, *(void *)(a2 + 8) + v13);
        ++v14;
        v13 += 48;
      }
      while (v14 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void NGaussianMixtureModels::~NGaussianMixtureModels(NGaussianMixtureModels *this)
{
  NGaussianMixtureModels::~NGaussianMixtureModels(this);

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  *(void *)this = &unk_26C99BAB8;
  *((void *)this + 7) = &unk_26C99C5B0;
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  *((void *)this + 3) = &unk_26C99C0E0;
  int v3 = *((void *)this + 4);
  if (v3)
  {
    int v4 = *(void *)(v3 - 8);
    if (v4)
    {
      int v5 = 56 * v4;
      uint64_t v6 = v3 - 56;
      do
      {
        uint64_t v7 = (void *)(v6 + v5);
        *(void *)(v6 + v5 + 24) = &unk_26C99C348;
        uint64_t v8 = *(void *)(v6 + v5 + 32);
        if (v8) {
          MEMORY[0x21D46B220](v8, 0x1000C8052888210);
        }
        *uint64_t v7 = &unk_26C99C348;
        uint64_t v9 = v7[1];
        if (v9) {
          MEMORY[0x21D46B220](v9, 0x1000C8052888210);
        }
        v5 -= 56;
      }
      while (v5);
    }
    MEMORY[0x21D46B220](v3 - 16, 0x1080C80D133DD60);
  }
  *(void *)this = &unk_26C99BFC8;
  uint64_t v10 = *((void *)this + 1);
  if (v10)
  {
    uint64_t v11 = *(void *)(v10 - 8);
    if (v11)
    {
      uint64_t v12 = 48 * v11;
      uint64_t v13 = v10 - 24;
      do
      {
        unint64_t v14 = v13 + v12;
        *(void *)(v13 + v12) = &unk_26C99C348;
        uint64_t v15 = *(void *)(v13 + v12 + 8);
        if (v15) {
          MEMORY[0x21D46B220](v15, 0x1000C8052888210);
        }
        *(void *)(v14 - 24) = &unk_26C99C3F0;
        unint64_t v16 = *(void *)(v14 - 16);
        if (v16) {
          MEMORY[0x21D46B220](v16, 0x1000C8052888210);
        }
        v12 -= 48;
      }
      while (v12);
    }
    MEMORY[0x21D46B220](v10 - 16, 0x1090C806BD41B22);
  }
}

void NArray<NGaussianMixture>::~NArray(void *a1)
{
  *a1 = &unk_26C99BFC8;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 48 * v2;
      uint64_t v4 = v1 - 24;
      do
      {
        uint64_t v5 = v4 + v3;
        *(void *)(v4 + v3) = &unk_26C99C348;
        uint64_t v6 = *(void *)(v4 + v3 + 8);
        if (v6) {
          MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        }
        *(void *)(v5 - 24) = &unk_26C99C3F0;
        uint64_t v7 = *(void *)(v5 - 16);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        v3 -= 48;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1090C806BD41B22);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NGaussianMixture>::~NArray(void *a1)
{
  *a1 = &unk_26C99BFC8;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 48 * v3;
      uint64_t v5 = v2 - 24;
      do
      {
        uint64_t v6 = v5 + v4;
        *(void *)(v5 + v4) = &unk_26C99C348;
        uint64_t v7 = *(void *)(v5 + v4 + 8);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        *(void *)(v6 - 24) = &unk_26C99C3F0;
        uint64_t v8 = *(void *)(v6 - 16);
        if (v8) {
          MEMORY[0x21D46B220](v8, 0x1000C8052888210);
        }
        v4 -= 48;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1090C806BD41B22);
  }
  return a1;
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  *a1 = &unk_26C99BFC8;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 48 * v3;
      uint64_t v5 = v2 - 24;
      do
      {
        uint64_t v6 = v5 + v4;
        *(void *)(v5 + v4) = &unk_26C99C348;
        uint64_t v7 = *(void *)(v5 + v4 + 8);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        *(void *)(v6 - 24) = &unk_26C99C3F0;
        uint64_t v8 = *(void *)(v6 - 16);
        if (v8) {
          MEMORY[0x21D46B220](v8, 0x1000C8052888210);
        }
        v4 -= 48;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1090C806BD41B22);
  }
  return a1;
}

uint64_t NArray<NGaussian>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NGaussian::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v3 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      uint64_t v10 = v4;
      if (v4 < 8) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFF8;
      uint64_t v11 = (_OWORD *)(v9 + 16);
      uint64_t v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFF8;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *uint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 8;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 4 * v7;
        uint64_t v17 = (_DWORD *)(v9 + v16);
        uint64_t v18 = (int *)(v8 + v16);
        do
        {
          int v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
    unsigned int v20 = *(_DWORD *)(result + 40);
    int v21 = *(_DWORD *)(a2 + 40);
    if (v20 != v21)
    {
      uint64_t v22 = *(void *)(result + 32);
      if (v22)
      {
        MEMORY[0x21D46B220](v22, 0x1000C8052888210);
        int v21 = *(_DWORD *)(a2 + 40);
      }
      *(_DWORD *)(v3 + 40) = v21;
      operator new[]();
    }
    if (v20)
    {
      uint64_t v23 = 0;
      uint64_t v24 = *(void *)(a2 + 32);
      uint64_t v25 = *(void *)(result + 32);
      uint64_t v26 = v20;
      if (v20 < 8) {
        goto LABEL_24;
      }
      if ((unint64_t)(v25 - v24) < 0x20) {
        goto LABEL_24;
      }
      uint64_t v23 = v20 & 0xFFFFFFF8;
      uint64_t v27 = (_OWORD *)(v25 + 16);
      unint64_t v28 = (long long *)(v24 + 16);
      uint64_t v29 = v26 & 0xFFFFFFF8;
      do
      {
        long long v30 = *v28;
        *(v27 - 1) = *(v28 - 1);
        *uint64_t v27 = v30;
        v27 += 2;
        v28 += 2;
        v29 -= 8;
      }
      while (v29);
      if (v23 != v26)
      {
LABEL_24:
        uint64_t v31 = v26 - v23;
        uint64_t v32 = 4 * v23;
        float v33 = (_DWORD *)(v25 + v32);
        int v34 = (int *)(v24 + v32);
        do
        {
          int v35 = *v34++;
          *v33++ = v35;
          --v31;
        }
        while (v31);
      }
    }
  }
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 48);
  return result;
}

uint64_t NArray<NGaussian>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = 56 * v9;
        uint64_t v11 = v7 - 56;
        do
        {
          uint64_t v12 = (void *)(v11 + v10);
          *(void *)(v11 + v10 + 24) = &unk_26C99C348;
          uint64_t v13 = *(void *)(v11 + v10 + 32);
          if (v13) {
            MEMORY[0x21D46B220](v13, 0x1000C8052888210);
          }
          void *v12 = &unk_26C99C348;
          uint64_t v14 = v12[1];
          if (v14) {
            MEMORY[0x21D46B220](v14, 0x1000C8052888210);
          }
          v10 -= 56;
        }
        while (v10);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x1080C80D133DD60);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    do
    {
      float result = NGaussian::operator=(*(void *)(v4 + 8) + v15, a2 + v15);
      ++v16;
      v15 += 56;
    }
    while (v16 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NGaussian>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 56 * v7;
          uint64_t v9 = v6 - 56;
          do
          {
            uint64_t v10 = (void *)(v9 + v8);
            *(void *)(v9 + v8 + 24) = &unk_26C99C348;
            uint64_t v11 = *(void *)(v9 + v8 + 32);
            if (v11) {
              MEMORY[0x21D46B220](v11, 0x1000C8052888210);
            }
            *uint64_t v10 = &unk_26C99C348;
            uint64_t v12 = v10[1];
            if (v12) {
              MEMORY[0x21D46B220](v12, 0x1000C8052888210);
            }
            v8 -= 56;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x1080C80D133DD60);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v13 = 0;
      unint64_t v14 = 0;
      do
      {
        NGaussian::operator=(*(void *)(a1 + 8) + v13, *(void *)(a2 + 8) + v13);
        ++v14;
        v13 += 56;
      }
      while (v14 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void NArray<NGaussian>::~NArray(void *a1)
{
  *a1 = &unk_26C99C0E0;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 56 * v2;
      uint64_t v4 = v1 - 56;
      do
      {
        int v5 = (void *)(v4 + v3);
        *(void *)(v4 + v3 + 24) = &unk_26C99C348;
        uint64_t v6 = *(void *)(v4 + v3 + 32);
        if (v6) {
          MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        }
        *int v5 = &unk_26C99C348;
        uint64_t v7 = v5[1];
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        v3 -= 56;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x1080C80D133DD60);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NGaussian>::~NArray(void *a1)
{
  *a1 = &unk_26C99C0E0;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 56 * v3;
      uint64_t v5 = v2 - 56;
      do
      {
        uint64_t v6 = (void *)(v5 + v4);
        *(void *)(v5 + v4 + 24) = &unk_26C99C348;
        uint64_t v7 = *(void *)(v5 + v4 + 32);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8052888210);
        }
        *uint64_t v6 = &unk_26C99C348;
        uint64_t v8 = v6[1];
        if (v8) {
          MEMORY[0x21D46B220](v8, 0x1000C8052888210);
        }
        v4 -= 56;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x1080C80D133DD60);
  }
  return a1;
}

float NGaussian::score(uint64_t a1, uint64_t a2)
{
  float v2 = *(float *)(a1 + 48);
  uint64_t v3 = *(unsigned int *)(a2 + 16);
  if (v3)
  {
    uint64_t v4 = *(float32x4_t **)(a2 + 8);
    uint64_t v5 = *(float32x4_t **)(a1 + 8);
    uint64_t v6 = *(float32x4_t **)(a1 + 32);
    if (v3 < 8)
    {
      uint64_t v7 = 0;
LABEL_7:
      uint64_t v16 = v3 - v7;
      uint64_t v17 = v7;
      uint64_t v18 = &v6->f32[v17];
      int v19 = &v5->f32[v17];
      unsigned int v20 = &v4->f32[v17];
      do
      {
        float v21 = *v20++;
        float v22 = v21;
        float v23 = *v19++;
        float v24 = (float)(v22 - v23) * (float)(v22 - v23);
        float v25 = *v18++;
        float v2 = v2 + (float)(v24 * v25);
        --v16;
      }
      while (v16);
      return v2 * -0.5;
    }
    uint64_t v7 = v3 & 0xFFFFFFF8;
    uint64_t v8 = v6 + 1;
    uint64_t v9 = v5 + 1;
    uint64_t v10 = v4 + 1;
    uint64_t v11 = v7;
    do
    {
      float32x4_t v12 = vsubq_f32(v10[-1], v9[-1]);
      float32x4_t v13 = vsubq_f32(*v10, *v9);
      float32x4_t v14 = vmulq_f32(vmulq_f32(v12, v12), v8[-1]);
      float32x4_t v15 = vmulq_f32(vmulq_f32(v13, v13), *v8);
      float v2 = (float)((float)((float)((float)((float)((float)((float)(v2 + v14.f32[0]) + v14.f32[1]) + v14.f32[2])
                                         + v14.f32[3])
                                 + v15.f32[0])
                         + v15.f32[1])
                 + v15.f32[2])
         + v15.f32[3];
      v8 += 2;
      v9 += 2;
      v10 += 2;
      v11 -= 8;
    }
    while (v11);
    if (v7 != v3) {
      goto LABEL_7;
    }
  }
  return v2 * -0.5;
}

void NGaussian::refreshOffset(NGaussian *this)
{
  uint64_t v1 = *((unsigned int *)this + 10);
  float v2 = (double)v1 * 1.83787707;
  *((float *)this + 12) = v2;
  if (v1)
  {
    uint64_t v4 = (float *)*((void *)this + 4);
    do
    {
      float v5 = *v4++;
      float v2 = v2 - logf(v5);
      *((float *)this + 12) = v2;
      --v1;
    }
    while (v1);
  }
}

void NGaussianMixtureModels::NGaussianMixtureModels(NGaussianMixtureModels *this)
{
  *((_DWORD *)this + 4) = 0;
  *(void *)this = &unk_26C99BAB8;
  *((void *)this + 1) = 0;
  *((void *)this + 3) = &unk_26C99C0E0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 7) = &unk_26C99C5B0;
  *((_DWORD *)this + 16) = 0;
  operator new[]();
}

{
  *((_DWORD *)this + 4) = 0;
  *(void *)this = &unk_26C99BAB8;
  *((void *)this + 1) = 0;
  *((void *)this + 3) = &unk_26C99C0E0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 7) = &unk_26C99C5B0;
  *((_DWORD *)this + 16) = 0;
  operator new[]();
}

void sub_2184B9414(_Unwind_Exception *a1)
{
  NArray<NGaussian>::~NArray(v2);
  NArray<NGaussianMixture>::~NArray(v1);
  _Unwind_Resume(a1);
}

void sub_2184B961C(_Unwind_Exception *exception_object)
{
  v1[3] = v2;
  uint64_t v4 = v1[4];
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 - 8);
    if (v5)
    {
      uint64_t v8 = 56 * v5;
      uint64_t v9 = v4 - 56;
      do
      {
        uint64_t v10 = (void *)(v9 + v8);
        *(void *)(v9 + v8 + 24) = &unk_26C99C348;
        uint64_t v11 = *(void *)(v9 + v8 + 32);
        if (v11) {
          MEMORY[0x21D46B220](v11, 0x1000C8052888210);
        }
        *uint64_t v10 = &unk_26C99C348;
        uint64_t v12 = v10[1];
        if (v12) {
          MEMORY[0x21D46B220](v12, 0x1000C8052888210);
        }
        v8 -= 56;
      }
      while (v8);
    }
    MEMORY[0x21D46B220](v4 - 16, 0x1080C80D133DD60);
  }
  *uint64_t v1 = &unk_26C99BFC8;
  uint64_t v6 = v1[1];
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 - 8);
    if (v7)
    {
      uint64_t v13 = 48 * v7;
      uint64_t v14 = v6 - 24;
      do
      {
        uint64_t v15 = v14 + v13;
        *(void *)(v14 + v13) = &unk_26C99C348;
        uint64_t v16 = *(void *)(v14 + v13 + 8);
        if (v16) {
          MEMORY[0x21D46B220](v16, 0x1000C8052888210);
        }
        *(void *)(v15 - 24) = &unk_26C99C3F0;
        uint64_t v17 = *(void *)(v15 - 16);
        if (v17) {
          MEMORY[0x21D46B220](v17, 0x1000C8052888210);
        }
        v13 -= 48;
      }
      while (v13);
    }
    MEMORY[0x21D46B220](v6 - 16, 0x1090C806BD41B22);
  }
  _Unwind_Resume(exception_object);
}

void NGaussianMixtureModels::read(NGaussianMixtureModels *this, const NString *a2)
{
  uint64_t v2 = (char *)&unk_26C99C5B0;
  LODWORD(v3) = 1;
  operator new[]();
}

void sub_2184BD508(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40)
{
  if (a40) {
    MEMORY[0x21D46B220](a40, 0x1000C8077774924);
  }
  *(void *)(v40 - 208) = a22;
  uint64_t v42 = *(void *)(v40 - 200);
  if (v42)
  {
    uint64_t v43 = *(void *)(v42 - 8);
    if (v43)
    {
      uint64_t v47 = 24 * v43;
      do
      {
        *(void *)(v42 + v47 - 24) = &unk_26C99C5B0;
        uint64_t v48 = *(void *)(v42 + v47 - 8);
        if (v48) {
          MEMORY[0x21D46B220](v48, 0x1000C8077774924);
        }
        v47 -= 24;
      }
      while (v47);
    }
    MEMORY[0x21D46B220](v42 - 16, 0x1091C800F2A5985);
  }
  *(void *)(v40 - 184) = a23;
  uint64_t v44 = *(void *)(v40 - 168);
  if (v44) {
    MEMORY[0x21D46B220](v44, 0x1000C8077774924);
  }
  *(void *)(v40 - 160) = &unk_26C99C5B0;
  uint64_t v45 = *(void *)(v40 - 144);
  if (v45) {
    MEMORY[0x21D46B220](v45, 0x1000C8077774924);
  }
  *(void *)(v40 - 136) = &unk_26C99AA78;
  uint64_t v46 = *(void *)(v40 - 128);
  if (v46) {
    (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
  }
  _Unwind_Resume(a1);
}

void NGaussianMixtureModels::validateVars()
{
}

void sub_2184BDE4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NGaussianMixtureModels::logWeights(void *a1@<X8>)
{
  *a1 = &unk_26C99C348;
  operator new[]();
}

void sub_2184BDF88(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[1];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NGaussianMixtureModels::invertVars(void *a1@<X8>)
{
  *a1 = &unk_26C99C348;
  operator new[]();
}

void sub_2184BE078(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[1];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NGaussianMixtureModels::invertSquareVars(void *a1@<X8>)
{
  *a1 = &unk_26C99C348;
  operator new[]();
}

void sub_2184BE168(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[1];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NGaussianMixtureModels::validateWeights(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 16);
  if (!v3)
  {
    double v7 = -1.0;
    goto LABEL_11;
  }
  uint64_t v4 = *(void *)(a2 + 8);
  if (v3 == 1)
  {
    uint64_t v5 = 0;
    float v6 = 0.0;
  }
  else
  {
    uint64_t v5 = v3 & 0xFFFFFFFE;
    uint64_t v8 = (float *)(v4 + 4);
    float v6 = 0.0;
    uint64_t v9 = v5;
    do
    {
      float v10 = *v8;
      float v11 = expf(*(v8 - 1));
      float v6 = (float)(v6 + v11) + expf(v10);
      v8 += 2;
      v9 -= 2;
    }
    while (v9);
    if (v5 == v3) {
      goto LABEL_10;
    }
  }
  uint64_t v12 = v3 - v5;
  uint64_t v13 = (float *)(v4 + 4 * v5);
  do
  {
    float v14 = *v13++;
    float v6 = v6 + expf(v14);
    --v12;
  }
  while (v12);
LABEL_10:
  double v7 = v6 + -1.0;
LABEL_11:
  if (fabs(v7) > 0.1) {
    Error::chuck((Error *)"NGaussianMixtureModels::validateWeights() - mixture weights do not sum to one (tol=+-0.1)", (const char *)a2);
  }
  return a2;
}

void NGaussianMixtureModels::refreshOffsets(NGaussianMixtureModels *this)
{
  uint64_t v1 = *((unsigned int *)this + 10);
  if (v1)
  {
    uint64_t v2 = 0;
    uint64_t v3 = *((void *)this + 4);
    do
    {
      uint64_t v4 = v3 + 56 * v2;
      uint64_t v5 = *(unsigned int *)(v4 + 40);
      float v6 = (double)v5 * 1.83787707;
      *(float *)(v4 + 48) = v6;
      double v7 = (float *)(v4 + 48);
      if (v5)
      {
        uint64_t v8 = *(float **)(v3 + 56 * v2 + 32);
        do
        {
          float v9 = *v8++;
          float v6 = v6 - logf(v9);
          *double v7 = v6;
          --v5;
        }
        while (v5);
      }
      ++v2;
    }
    while (v2 != v1);
  }
}

void NGaussianMixtureModels::write()
{
}

void sub_2184BFA9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  if (a33) {
    MEMORY[0x21D46B220](a33, 0x1000C8077774924);
  }
  if (a24) {
    MEMORY[0x21D46B220](a24, 0x1000C8077774924);
  }
  if (!a27) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(uint64_t))(*(void *)a27 + 8))(a27);
  _Unwind_Resume(exception_object);
}

void operator<<<float>()
{
  v0 = &unk_26C99C5B0;
  int v1 = 1;
  operator new[]();
}

void sub_2184C01EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NGaussianMixtureModels::expWeights(void *a1@<X8>)
{
  *a1 = &unk_26C99C348;
  operator new[]();
}

void sub_2184C043C(_Unwind_Exception *exception_object)
{
  *int v1 = v2;
  uint64_t v4 = v1[1];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NGaussianMixtureModels::invertSqrtVars(void *a1@<X8>)
{
  *a1 = &unk_26C99C348;
  operator new[]();
}

void sub_2184C052C(_Unwind_Exception *exception_object)
{
  *int v1 = v2;
  uint64_t v4 = v1[1];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NGaussianMixtureModels::writeBinary(NGaussianMixtureModels *this, const NString *a2)
{
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 1;
  operator new[]();
}

void sub_2184C0D1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  if (a17) {
    (*(void (**)(uint64_t))(*(void *)a17 + 8))(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NGaussianMixtureModels::dimen(NGaussianMixtureModels *this)
{
  return (uint64_t)this + 48;
}

uint64_t NGaussianMixtureModels::id(NGaussianMixtureModels *this)
{
  return (uint64_t)this + 56;
}

{
  return (uint64_t)this + 56;
}

uint64_t NGaussianMixtureModels::gaussians(NGaussianMixtureModels *this)
{
  return (uint64_t)this + 24;
}

uint64_t NGaussianMixtureModels::gaussian(NGaussianMixtureModels *this, const unsigned int *a2, const unsigned int *a3)
{
  return *((void *)this + 4)
       + 56 * *(unsigned int *)(*(void *)(*((void *)this + 1) + 48 * *a2 + 8) + 4 * *a3);
}

uint64_t NGaussianMixtureModels::weight(NGaussianMixtureModels *this, const unsigned int *a2, const unsigned int *a3)
{
  return *(void *)(*((void *)this + 1) + 48 * *a2 + 32) + 4 * *a3;
}

float NGaussianMixtureModels::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(unsigned int *)(v3 + 48 * *a2 + 16);
  if (v4)
  {
    uint64_t v5 = v3 + 48 * *a2;
    float v6 = *(float **)(v5 + 32);
    double v7 = *(unsigned int **)(v5 + 8);
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(unsigned int *)(a3 + 16);
    if (v9)
    {
      float v10 = *(float **)(a3 + 8);
      if (v9 >= 8)
      {
        uint64_t v29 = 0;
        long long v30 = (float32x4_t *)(v10 + 4);
        uint64_t v31 = (4 * v9) & 0x3FFFFFFE0;
        uint64_t v32 = (float *)((char *)v10 + v31);
        long double v12 = 0.0;
        do
        {
          uint64_t v33 = v8 + 56 * v7[v29];
          float v34 = *(float *)(v33 + 48);
          int v35 = *(float32x4_t **)(v33 + 8);
          unsigned int v36 = *(float32x4_t **)(v33 + 32);
          int v37 = v36 + 1;
          uint64_t v38 = v35 + 1;
          unint64_t v39 = v30;
          uint64_t v40 = v9 & 0xFFFFFFF8;
          do
          {
            float32x4_t v41 = vsubq_f32(v39[-1], v38[-1]);
            float32x4_t v42 = vsubq_f32(*v39, *v38);
            float32x4_t v43 = vmulq_f32(vmulq_f32(v41, v41), v37[-1]);
            float32x4_t v44 = vmulq_f32(vmulq_f32(v42, v42), *v37);
            float v34 = (float)((float)((float)((float)((float)((float)((float)(v34 + v43.f32[0]) + v43.f32[1]) + v43.f32[2])
                                                + v43.f32[3])
                                        + v44.f32[0])
                                + v44.f32[1])
                        + v44.f32[2])
                + v44.f32[3];
            v37 += 2;
            v38 += 2;
            v39 += 2;
            v40 -= 8;
          }
          while (v40);
          if (v9 != (v9 & 0xFFFFFFF8))
          {
            uint64_t v45 = (float *)((char *)v36->f32 + v31);
            uint64_t v46 = (float *)((char *)v35->f32 + v31);
            uint64_t v47 = v32;
            uint64_t v48 = v9 - (v9 & 0xFFFFFFF8);
            do
            {
              float v49 = *v47++;
              float v50 = v49;
              float v51 = *v46++;
              float v52 = (float)(v50 - v51) * (float)(v50 - v51);
              float v53 = *v45++;
              float v34 = v34 + (float)(v52 * v53);
              --v48;
            }
            while (v48);
          }
          long double v12 = v12 + exp((float)(v6[v29++] + (float)(v34 * -0.5)));
        }
        while (v29 != v4);
      }
      else
      {
        float v11 = *v10;
        long double v12 = 0.0;
        do
        {
          unsigned int v14 = *v7++;
          uint64_t v15 = v8 + 56 * v14;
          uint64_t v16 = *(float **)(v15 + 8);
          uint64_t v17 = *(float **)(v15 + 32);
          float v18 = *(float *)(v15 + 48) + (float)((float)((float)(v11 - *v16) * (float)(v11 - *v16)) * *v17);
          if (v9 != 1)
          {
            float v19 = v10[1] - v16[1];
            float v18 = v18 + (float)((float)(v19 * v19) * v17[1]);
            if (v9 != 2)
            {
              float v20 = v10[2] - v16[2];
              float v18 = v18 + (float)((float)(v20 * v20) * v17[2]);
              if (v9 != 3)
              {
                float v21 = v10[3] - v16[3];
                float v18 = v18 + (float)((float)(v21 * v21) * v17[3]);
                if (v9 != 4)
                {
                  float v22 = v10[4] - v16[4];
                  float v18 = v18 + (float)((float)(v22 * v22) * v17[4]);
                  if (v9 != 5)
                  {
                    float v23 = v10[5] - v16[5];
                    float v18 = v18 + (float)((float)(v23 * v23) * v17[5]);
                    if (v9 != 6)
                    {
                      float v24 = v10[6] - v16[6];
                      float v18 = v18 + (float)((float)(v24 * v24) * v17[6]);
                    }
                  }
                }
              }
            }
          }
          float v13 = *v6++;
          long double v12 = v12 + exp((float)(v13 + (float)(v18 * -0.5)));
          --v4;
        }
        while (v4);
      }
    }
    else
    {
      long double v12 = 0.0;
      do
      {
        float v25 = *v6++;
        float v26 = v25;
        unsigned int v27 = *v7++;
        long double v12 = v12 + exp((float)(v26 + (float)(*(float *)(v8 + 56 * v27 + 48) * -0.5)));
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    long double v12 = 0.0;
  }
  return log(v12);
}

void NGaussianMixtureModels::score2()
{
}

void NGaussianMixtureModels::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = v4 + 48 * *a2;
  uint64_t v6 = *(unsigned int *)(v5 + 16);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = *(void *)(v5 + 8);
    uint64_t v9 = *(void *)(a3 + 8);
    float v10 = (void *)(v4 + 48 * *a2 + 32);
    uint64_t v11 = *(void *)(a4 + 8);
    uint64_t v12 = 4 * v6;
    double v13 = 0.0;
    do
    {
      uint64_t v14 = *(unsigned int *)(v8 + v7);
      if (*(unsigned char *)(v9 + v14)) {
        double v13 = v13 + expf(*(float *)(*v10 + v7) + *(float *)(v11 + 4 * v14));
      }
      v7 += 4;
    }
    while (v12 != v7);
    if (v13 != 0.0) {
      log(v13);
    }
  }
}

void NGaussianMixtureModels::posteriorWeightedMean()
{
}

void sub_2184C1B48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17) {
    MEMORY[0x21D46B220](a17, 0x1000C8000313F17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NArray<double>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

double NArray<double>::fromArray(uint64_t a1, uint64_t a2, int *a3)
{
  unsigned int v4 = *(_DWORD *)(a1 + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C8000313F17);
      int v5 = *a3;
    }
    *(_DWORD *)(a1 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    uint64_t v9 = v4;
    if (v4 < 4 || (unint64_t)(v8 - a2) <= 0x1F)
    {
      uint64_t v11 = 0;
LABEL_14:
      uint64_t v17 = v9 - v11;
      uint64_t v18 = 8 * v11;
      float v19 = (void *)(v8 + v18);
      float v20 = (uint64_t *)(a2 + v18);
      do
      {
        uint64_t v21 = *v20++;
        *(void *)&long long v15 = v21;
        *v19++ = v21;
        --v17;
      }
      while (v17);
      return *(double *)&v15;
    }
    uint64_t v11 = v4 & 0xFFFFFFFC;
    uint64_t v12 = (_OWORD *)(v8 + 16);
    double v13 = (long long *)(a2 + 16);
    uint64_t v14 = v9 & 0xFFFFFFFC;
    do
    {
      long long v15 = *(v13 - 1);
      long long v16 = *v13;
      *(v12 - 1) = v15;
      _OWORD *v12 = v16;
      v12 += 2;
      v13 += 2;
      v14 -= 4;
    }
    while (v14);
    if (v11 != v9) {
      goto LABEL_14;
    }
  }
  return *(double *)&v15;
}

uint64_t NArray<double>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8000313F17);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      uint64_t v10 = v4;
      if (v4 < 4) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFFC;
      uint64_t v11 = (_OWORD *)(v9 + 16);
      uint64_t v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFFC;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *uint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 4;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 8 * v7;
        uint64_t v17 = (void *)(v9 + v16);
        uint64_t v18 = (uint64_t *)(v8 + v16);
        do
        {
          uint64_t v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  return result;
}

void NArray<double>::~NArray(void *a1)
{
  *a1 = &unk_26C99C310;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8000313F17);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<double>::~NArray(void *a1)
{
  *a1 = &unk_26C99C310;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8000313F17);
  }
  return a1;
}

void NGaussianMixtureModels::posteriors()
{
}

void sub_2184C2294(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8000313F17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AccelLoga::init(uint64_t this, const unsigned int *a2, float a3)
{
  *(_DWORD *)this = *a2;
  *(unsigned char *)(this + 4) = 1;
  *(float *)(this + 8) = a3;
  return this;
}

void AccelLoga::run(AccelLoga *this, float *__A)
{
  if (!*((unsigned char *)this + 4)) {
    Error::chuck((Error *)"AccelLoga::run - AccelLoga::init() has to be called before running", (const char *)__A);
  }
  vDSP_vsadd(__A, 1, (const float *)this + 2, __A, 1, *(unsigned int *)this);
  int v4 = *(_DWORD *)this;
  vvlogf(__A, __A, &v4);
}

float AccelLoga::getScalingFactor(AccelLoga *this)
{
  return *((float *)this + 3);
}

float AccelLoga::findMax(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(float **)(a2 + 8);
  float result = *v2;
  uint64_t v4 = *(unsigned int *)(a2 + 16);
  if (v4)
  {
    do
    {
      float v5 = *v2++;
      float v6 = v5;
      if (v5 > result) {
        float result = v6;
      }
      --v4;
    }
    while (v4);
  }
  if (result <= 0.0) {
    return 1.0;
  }
  return result;
}

uint64_t NArray<NPhoneHMM>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

void sub_2184C2F20(_Unwind_Exception *a1)
{
  *uint64_t v4 = off_26C99C118;
  uint64_t v6 = v4[1];
  if (v6) {
    MEMORY[0x21D46B220](v6 - 16, 0x1000C8000313F17);
  }
  if (v3 != v4)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v1 - 32 + v2));
      v2 -= 48;
    }
    while (v2);
  }
  MEMORY[0x21D46B220](v1, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

void NPhoneHMM::~NPhoneHMM(NPhoneHMM *this)
{
  *(void *)this = &unk_26C99C7A8;
  *((void *)this + 3) = &unk_26C99C5B0;
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  *(void *)this = off_26C99C118;
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    MEMORY[0x21D46B220](v3 - 16, 0x1000C8000313F17);
  }
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_26C99C7A8;
  *((void *)this + 3) = &unk_26C99C5B0;
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  *(void *)this = off_26C99C118;
  uint64_t v3 = *((void *)this + 1);
  if (v3) {
    MEMORY[0x21D46B220](v3 - 16, 0x1000C8000313F17);
  }

  JUMPOUT(0x21D46B240);
}

uint64_t NArray<NHMMState>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<NHMMState>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6 - 16, 0x1000C8000313F17);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    unint64_t v8 = 0;
    do
    {
      *(void *)(*(void *)(result + 8) + 8 * v8) = *(void *)(a2 + 8 * v8);
      ++v8;
    }
    while (v8 < *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t NArray<NHMMState>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6 - 16, 0x1000C8000313F17);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      unint64_t v7 = 0;
      do
      {
        *(void *)(*(void *)(result + 8) + 8 * v7) = *(void *)(*(void *)(a2 + 8) + 8 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(result + 16));
    }
  }
  return result;
}

void NArray<NHMMState>::~NArray(void *a1)
{
  *a1 = off_26C99C118;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1 - 16, 0x1000C8000313F17);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NHMMState>::~NArray(void *a1)
{
  *a1 = off_26C99C118;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2 - 16, 0x1000C8000313F17);
  }
  return a1;
}

uint64_t NArray<NPhoneHMM>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = 48 * v9;
        uint64_t v11 = v7 - 24;
        do
        {
          uint64_t v12 = (void *)(v11 + v10);
          *(v12 - 3) = &unk_26C99C7A8;
          void *v12 = &unk_26C99C5B0;
          uint64_t v13 = *(void *)(v11 + v10 + 16);
          if (v13) {
            MEMORY[0x21D46B220](v13, 0x1000C8077774924);
          }
          *(v12 - 3) = off_26C99C118;
          uint64_t v14 = *(v12 - 2);
          if (v14) {
            MEMORY[0x21D46B220](v14 - 16, 0x1000C8000313F17);
          }
          v10 -= 48;
        }
        while (v10);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x10B1C80FD921951);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    unint64_t v15 = 0;
    do
    {
      uint64_t v16 = *(void *)(v4 + 8);
      if (v16 != a2)
      {
        uint64_t v17 = a2 + 48 * v15;
        uint64_t v18 = v16 + 48 * v15;
        uint64_t v19 = *(unsigned int *)(v17 + 16);
        if (*(_DWORD *)(v18 + 16) != v19)
        {
          uint64_t v20 = *(void *)(v18 + 8);
          if (v20)
          {
            MEMORY[0x21D46B220](v20 - 16, 0x1000C8000313F17);
            LODWORD(v19) = *(_DWORD *)(v17 + 16);
          }
          *(_DWORD *)(v18 + 16) = v19;
          operator new[]();
        }
        if (*(_DWORD *)(v18 + 16))
        {
          unint64_t v21 = 0;
          do
          {
            *(void *)(*(void *)(v18 + 8) + 8 * v21) = *(void *)(*(void *)(v17 + 8) + 8 * v21);
            ++v21;
          }
          while (v21 < *(unsigned int *)(v18 + 16));
        }
        float result = (*(uint64_t (**)(void))(*(void *)(v16 + 48 * v15 + 24) + 64))();
      }
      ++v15;
    }
    while (v15 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

void sub_2184C37A8(_Unwind_Exception *a1)
{
  *uint64_t v4 = off_26C99C118;
  uint64_t v6 = v4[1];
  if (v6) {
    MEMORY[0x21D46B220](v6 - 16, 0x1000C8000313F17);
  }
  if (v3 != v4)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v1 - 32 + v2));
      v2 -= 48;
    }
    while (v2);
  }
  MEMORY[0x21D46B220](v1, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

uint64_t NArray<NPhoneHMM>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = 48 * v7;
          uint64_t v9 = v6 - 24;
          do
          {
            uint64_t v10 = (void *)(v9 + v8);
            *(v10 - 3) = &unk_26C99C7A8;
            *uint64_t v10 = &unk_26C99C5B0;
            uint64_t v11 = *(void *)(v9 + v8 + 16);
            if (v11) {
              MEMORY[0x21D46B220](v11, 0x1000C8077774924);
            }
            *(v10 - 3) = off_26C99C118;
            uint64_t v12 = *(v10 - 2);
            if (v12) {
              MEMORY[0x21D46B220](v12 - 16, 0x1000C8000313F17);
            }
            v8 -= 48;
          }
          while (v8);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x10B1C80FD921951);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      unint64_t v13 = 0;
      do
      {
        uint64_t v14 = *(void *)(a2 + 8);
        uint64_t v15 = *(void *)(a1 + 8);
        if (v15 != v14)
        {
          uint64_t v16 = v14 + 48 * v13;
          uint64_t v17 = v15 + 48 * v13;
          uint64_t v18 = *(unsigned int *)(v16 + 16);
          if (*(_DWORD *)(v17 + 16) != v18)
          {
            uint64_t v19 = *(void *)(v17 + 8);
            if (v19)
            {
              MEMORY[0x21D46B220](v19 - 16, 0x1000C8000313F17);
              LODWORD(v18) = *(_DWORD *)(v16 + 16);
            }
            *(_DWORD *)(v17 + 16) = v18;
            operator new[]();
          }
          if (*(_DWORD *)(v17 + 16))
          {
            unint64_t v20 = 0;
            do
            {
              *(void *)(*(void *)(v17 + 8) + 8 * v20) = *(void *)(*(void *)(v16 + 8) + 8 * v20);
              ++v20;
            }
            while (v20 < *(unsigned int *)(v17 + 16));
          }
          (*(void (**)(void))(*(void *)(v15 + 48 * v13 + 24) + 64))();
        }
        ++v13;
      }
      while (v13 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void sub_2184C3B44(_Unwind_Exception *a1)
{
  *int v4 = off_26C99C118;
  uint64_t v6 = v4[1];
  if (v6) {
    MEMORY[0x21D46B220](v6 - 16, 0x1000C8000313F17);
  }
  if (v3 != v4)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v1 - 32 + v2));
      v2 -= 48;
    }
    while (v2);
  }
  MEMORY[0x21D46B220](v1, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

void NPhoneHMMArray::~NPhoneHMMArray(NPhoneHMMArray *this)
{
  NPhoneHMMArray::~NPhoneHMMArray(this);

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;

  *(void *)this = &unk_26C99AB50;
  *((void *)this + 3) = &unk_26C99BD50;
  *((void *)this + 4) = &unk_26C99BF58;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      int v4 = v2 + 32 * v3;
      do
      {
        int v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A760;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  *(void *)this = &unk_26C99C150;
  uint64_t v7 = *((void *)this + 1);
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 - 8);
    if (v8)
    {
      uint64_t v9 = 48 * v8;
      uint64_t v10 = v7 - 24;
      do
      {
        uint64_t v11 = (void *)(v10 + v9);
        *(v11 - 3) = &unk_26C99C7A8;
        *uint64_t v11 = &unk_26C99C5B0;
        uint64_t v12 = *(void *)(v10 + v9 + 16);
        if (v12) {
          MEMORY[0x21D46B220](v12, 0x1000C8077774924);
        }
        *(v11 - 3) = off_26C99C118;
        unint64_t v13 = *(v11 - 2);
        if (v13) {
          MEMORY[0x21D46B220](v13 - 16, 0x1000C8000313F17);
        }
        v9 -= 48;
      }
      while (v9);
    }
    MEMORY[0x21D46B220](v7 - 16, 0x10B1C80FD921951);
  }
}

void NArray<NPhoneHMM>::~NArray(void *a1)
{
  *a1 = &unk_26C99C150;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 48 * v2;
      uint64_t v4 = v1 - 24;
      do
      {
        int v5 = (void *)(v4 + v3);
        *(v5 - 3) = &unk_26C99C7A8;
        *int v5 = &unk_26C99C5B0;
        uint64_t v6 = *(void *)(v4 + v3 + 16);
        if (v6) {
          MEMORY[0x21D46B220](v6, 0x1000C8077774924);
        }
        *(v5 - 3) = off_26C99C118;
        uint64_t v7 = *(v5 - 2);
        if (v7) {
          MEMORY[0x21D46B220](v7 - 16, 0x1000C8000313F17);
        }
        v3 -= 48;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10B1C80FD921951);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NPhoneHMM>::~NArray(void *a1)
{
  *a1 = &unk_26C99C150;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 48 * v3;
      uint64_t v5 = v2 - 24;
      do
      {
        uint64_t v6 = (void *)(v5 + v4);
        *(v6 - 3) = &unk_26C99C7A8;
        *uint64_t v6 = &unk_26C99C5B0;
        uint64_t v7 = *(void *)(v5 + v4 + 16);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8077774924);
        }
        *(v6 - 3) = off_26C99C118;
        uint64_t v8 = *(v6 - 2);
        if (v8) {
          MEMORY[0x21D46B220](v8 - 16, 0x1000C8000313F17);
        }
        v4 -= 48;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10B1C80FD921951);
  }
  return a1;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::deleteElement(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void NLinkedList<NMap<NString,unsigned int>::HashItem>::newElement()
{
}

void sub_2184C41C0(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x10B1C4036FAF639);
  _Unwind_Resume(a1);
}

void NLinkedList<NMap<NString,unsigned int>::HashItem>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C910;
  a1[2] = &unk_26C99C5B0;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NLinkedList<NMap<NString,unsigned int>::HashItem>::NElement::~NElement(void *a1)
{
  *a1 = &unk_26C99C910;
  a1[2] = &unk_26C99C5B0;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::reset(uint64_t result)
{
  uint64_t v1 = result;
  for (uint64_t i = *(void *)(result + 8); i; uint64_t i = *(void *)(v1 + 8))
  {
    *(void *)(v1 + 8) = *(void *)(i + 8);
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v1 + 72))(v1);
  }
  *(void *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  return result;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::insert(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)a2;
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v3 > v4) {
    Error::chuck((Error *)"NLinkedList::insert List index out of bounds (size = %d, [] = %d)", a2, *(unsigned int *)(a1 + 24), v3);
  }
  if (!v3)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 32);
    return v6();
  }
  if (v3 == v4)
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)a1 + 40);
    return v6();
  }
  uint64_t v8 = *(void *)(a1 + 8);
  for (int i = v3 - 1; i; --i)
    uint64_t v8 = *(void *)(v8 + 8);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 64))(a1, a3);
  *(void *)(result + 8) = *(void *)(v8 + 8);
  *(void *)(v8 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::append(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = (uint64_t *)(a1 + 16);
  if (*(void *)(a1 + 8))
  {
    unsigned int v4 = (uint64_t *)(*v3 + 8);
  }
  else
  {
    unsigned int v4 = (uint64_t *)(a1 + 16);
    uint64_t v3 = (uint64_t *)(a1 + 8);
  }
  *unsigned int v4 = result;
  *uint64_t v3 = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::prepend(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3) {
    *(void *)(result + 8) = v3;
  }
  else {
    *(void *)(a1 + 16) = result;
  }
  *(void *)(a1 + 8) = result;
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    for (uint64_t i = *(void *)(a2 + 8); i; uint64_t i = *(void *)(i + 8))
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 40))(a1, i + 16);
  }
  return a1;
}

void NLinkedList<NMap<NString,unsigned int>::HashItem>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A760;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;

  JUMPOUT(0x21D46B240);
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::~NLinkedList(uint64_t a1)
{
  *(void *)a1 = &unk_26C99A760;
  for (uint64_t i = *(void *)(a1 + 8); i; uint64_t i = *(void *)(a1 + 8))
  {
    *(void *)(a1 + 8) = *(void *)(i + 8);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t NLinkedList<NMap<NString,unsigned int>::HashItem>::removeElement(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    Error::chuck((Error *)"NLinkedList::removeElement Attempted to remove NULL pointer list element\n", 0);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v4 = (void *)(a1 + 8);
  if (v3 == v5)
  {
    *unsigned int v4 = 0;
    *(void *)(a1 + 16) = 0;
  }
  else if (v3 == a2)
  {
    *unsigned int v4 = *(void *)(a2 + 8);
  }
  else if (v5 == a2)
  {
    do
    {
      uint64_t v7 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v7 + 8) = 0;
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      uint64_t v6 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
    }
    while (v3 != a2);
    *(void *)(v6 + 8) = *(void *)(a2 + 8);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
  --*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 16);
  int v6 = *a3;
  if (v5 != *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v9 = *(void *)(v7 - 8);
      if (v9)
      {
        uint64_t v10 = v7 + 32 * v9;
        do
        {
          uint64_t v11 = v10 - 32;
          for (*(void *)(v10 - 32) = &unk_26C99A760;
                ;
                (*(void (**)(uint64_t))(*(void *)(v10 - 32) + 72))(v10 - 32))
          {
            uint64_t v12 = *(void *)(v10 - 24);
            if (!v12) {
              break;
            }
            *(void *)(v10 - 24) = *(void *)(v12 + 8);
          }
          *(void *)(v10 - 16) = 0;
          *(_DWORD *)(v10 - 8) = 0;
          v10 -= 32;
        }
        while (v11 != v7);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x10A1C80F4A7E088);
      int v6 = *a3;
    }
    *(_DWORD *)(v4 + 16) = v6;
    operator new[]();
  }
  if (v5)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(*(void *)(v4 + 8) + v13) + 24))(*(void *)(v4 + 8) + v13, a2 + v13);
      ++v14;
      v13 += 32;
    }
    while (v14 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

uint64_t NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    int v4 = *(_DWORD *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 - 8);
        if (v7)
        {
          uint64_t v8 = v6 + 32 * v7;
          do
          {
            uint64_t v9 = v8 - 32;
            for (*(void *)(v8 - 32) = &unk_26C99A760;
                  ;
                  (*(void (**)(uint64_t))(*(void *)(v8 - 32) + 72))(v8 - 32))
            {
              uint64_t v10 = *(void *)(v8 - 24);
              if (!v10) {
                break;
              }
              *(void *)(v8 - 24) = *(void *)(v10 + 8);
            }
            *(void *)(v8 - 16) = 0;
            *(_DWORD *)(v8 - 8) = 0;
            v8 -= 32;
          }
          while (v9 != v6);
        }
        MEMORY[0x21D46B220](v6 - 16, 0x10A1C80F4A7E088);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(a1 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      do
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)(*(void *)(a1 + 8) + v11) + 24))(*(void *)(a1 + 8) + v11, *(void *)(a2 + 8) + v11);
        ++v12;
        v11 += 32;
      }
      while (v12 < *(unsigned int *)(a1 + 16));
    }
  }
  return a1;
}

void NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::~NArray(void *a1)
{
  *a1 = &unk_26C99BF58;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A760;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::~NArray(void *a1)
{
  *a1 = &unk_26C99BF58;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A760;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NMap<NString,unsigned int>::~NMap(void *a1)
{
  *a1 = &unk_26C99BD50;
  a1[1] = &unk_26C99BF58;
  uint64_t v1 = a1[2];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A760;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NMap<NString,unsigned int>::~NMap(void *a1)
{
  *a1 = &unk_26C99BD50;
  a1[1] = &unk_26C99BF58;
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A760;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NPhoneHMMArray::NPhoneHMMArray(NPhoneHMMArray *this)
{
  *((_DWORD *)this + 4) = 0;
  *(void *)this = &unk_26C99AB50;
  *((void *)this + 1) = 0;
  *((void *)this + 4) = &unk_26C99BE78;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 3) = &unk_26C99A930;
}

{
  *((_DWORD *)this + 4) = 0;
  *(void *)this = &unk_26C99AB50;
  *((void *)this + 1) = 0;
  *((void *)this + 4) = &unk_26C99BE78;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 3) = &unk_26C99A930;
}

void NStringHash<unsigned int>::~NStringHash(void *a1)
{
  *a1 = &unk_26C99BD50;
  a1[1] = &unk_26C99BF58;
  uint64_t v1 = a1[2];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A760;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NStringHash<unsigned int>::~NStringHash(void *a1)
{
  *a1 = &unk_26C99BD50;
  a1[1] = &unk_26C99BF58;
  uint64_t v2 = a1[2];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A760;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NHash<NMap<NString,unsigned int>::HashItem>::~NHash(void *a1)
{
  *a1 = &unk_26C99BF58;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A760;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NHash<NMap<NString,unsigned int>::HashItem>::~NHash(void *a1)
{
  *a1 = &unk_26C99BF58;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A760;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NPhoneHMMArray::read(NPhoneHMMArray *this, const NString *a2, const unsigned int *a3)
{
}

void sub_2184C6110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41)
{
  NAutoArray<NPhoneHMM>::~NAutoArray(&a33);
  NArray<NString>::~NArray((void *)(v41 - 160));
  a40 = &unk_26C99AA78;
  if (a41) {
    (*(void (**)(uint64_t))(*(void *)a41 + 8))(a41);
  }
  _Unwind_Resume(a1);
}

void *NAutoArray<NPhoneHMM>::~NAutoArray(void *a1)
{
  *a1 = &unk_26C99C150;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = 48 * v3;
      uint64_t v5 = v2 - 24;
      do
      {
        uint64_t v6 = (void *)(v5 + v4);
        *(v6 - 3) = &unk_26C99C7A8;
        *uint64_t v6 = &unk_26C99C5B0;
        uint64_t v7 = *(void *)(v5 + v4 + 16);
        if (v7) {
          MEMORY[0x21D46B220](v7, 0x1000C8077774924);
        }
        *(v6 - 3) = off_26C99C118;
        uint64_t v8 = *(v6 - 2);
        if (v8) {
          MEMORY[0x21D46B220](v8 - 16, 0x1000C8000313F17);
        }
        v4 -= 48;
      }
      while (v4);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10B1C80FD921951);
  }
  return a1;
}

uint64_t NAutoArray<NPhoneHMM>::resize(uint64_t result, unsigned int *a2, unsigned int a3)
{
  uint64_t v4 = result;
  unsigned int v5 = *a2;
  if (*a2 <= a3) {
    unsigned int v6 = a3;
  }
  else {
    unsigned int v6 = *a2;
  }
  if (v6) {
    operator new[]();
  }
  unsigned int v7 = *(_DWORD *)(result + 16);
  if (v5 < v7)
  {
    *(_DWORD *)(result + 16) = v5;
    unsigned int v7 = v5;
  }
  if (v7)
  {
    unint64_t v8 = 0;
    do
    {
      uint64_t v9 = *(void *)(v4 + 8);
      if (v9)
      {
        uint64_t v10 = v9 + 48 * v8;
        uint64_t v11 = *(unsigned int *)(v10 + 16);
        if (*(_DWORD *)(48 * v8 + 0x10) != v11)
        {
          uint64_t v12 = *(void *)(48 * v8 + 8);
          if (v12)
          {
            MEMORY[0x21D46B220](v12 - 16, 0x1000C8000313F17);
            LODWORD(v11) = *(_DWORD *)(v10 + 16);
          }
          *(_DWORD *)(48 * v8 + 0x10) = v11;
          operator new[]();
        }
        if (*(_DWORD *)(48 * v8 + 0x10))
        {
          unint64_t v13 = 0;
          do
          {
            *(void *)(*(void *)(48 * v8 + 8) + 8 * v13) = *(void *)(*(void *)(v10 + 8) + 8 * v13);
            ++v13;
          }
          while (v13 < *(unsigned int *)(48 * v8 + 0x10));
        }
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(48 * v8 + 0x18) + 64))();
      }
      ++v8;
    }
    while (v8 < *(unsigned int *)(v4 + 16));
  }
  uint64_t v14 = *(void *)(v4 + 8);
  if (v14)
  {
    uint64_t v15 = *(void *)(v14 - 8);
    if (v15)
    {
      uint64_t v16 = 48 * v15;
      uint64_t v17 = v14 - 24;
      do
      {
        uint64_t v18 = (void *)(v17 + v16);
        *(v18 - 3) = &unk_26C99C7A8;
        *uint64_t v18 = &unk_26C99C5B0;
        uint64_t v19 = *(void *)(v17 + v16 + 16);
        if (v19) {
          MEMORY[0x21D46B220](v19, 0x1000C8077774924);
        }
        *(v18 - 3) = off_26C99C118;
        uint64_t v20 = *(v18 - 2);
        if (v20) {
          MEMORY[0x21D46B220](v20 - 16, 0x1000C8000313F17);
        }
        v16 -= 48;
      }
      while (v16);
    }
    uint64_t result = MEMORY[0x21D46B220](v14 - 16, 0x10B1C80FD921951);
  }
  *(void *)(v4 + 8) = 0;
  *(_DWORD *)(v4 + 16) = *a2;
  *(_DWORD *)(v4 + 20) = 0;
  return result;
}

void sub_2184C6720(_Unwind_Exception *a1)
{
  *uint64_t v4 = off_26C99C118;
  uint64_t v6 = v4[1];
  if (v6) {
    MEMORY[0x21D46B220](v6 - 16, 0x1000C8000313F17);
  }
  if (v3 != v4)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v1 - 32 + v2));
      v2 -= 48;
    }
    while (v2);
  }
  MEMORY[0x21D46B220](v1, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

uint64_t NAutoArray<NPhoneHMM>::operator=(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t NAutoArray<NPhoneHMM>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v4 = result;
  int v5 = *a3;
  if (*(_DWORD *)(result + 20) < *a3)
  {
    uint64_t v7 = *(void *)(result + 8);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 - 8);
      if (v8)
      {
        uint64_t v9 = 48 * v8;
        uint64_t v10 = v7 - 24;
        do
        {
          uint64_t v11 = (void *)(v10 + v9);
          *(v11 - 3) = &unk_26C99C7A8;
          *uint64_t v11 = &unk_26C99C5B0;
          uint64_t v12 = *(void *)(v10 + v9 + 16);
          if (v12) {
            MEMORY[0x21D46B220](v12, 0x1000C8077774924);
          }
          *(v11 - 3) = off_26C99C118;
          uint64_t v13 = *(v11 - 2);
          if (v13) {
            MEMORY[0x21D46B220](v13 - 16, 0x1000C8000313F17);
          }
          v9 -= 48;
        }
        while (v9);
      }
      MEMORY[0x21D46B220](v7 - 16, 0x10B1C80FD921951);
      int v5 = *a3;
    }
    *(_DWORD *)(v4 + 20) = v5;
    operator new[]();
  }
  *(_DWORD *)(result + 16) = v5;
  if (v5)
  {
    unint64_t v14 = 0;
    do
    {
      uint64_t v15 = *(void *)(v4 + 8);
      if (v15 != a2)
      {
        uint64_t v16 = a2 + 48 * v14;
        uint64_t v17 = v15 + 48 * v14;
        uint64_t v18 = *(unsigned int *)(v16 + 16);
        if (*(_DWORD *)(v17 + 16) != v18)
        {
          uint64_t v19 = *(void *)(v17 + 8);
          if (v19)
          {
            MEMORY[0x21D46B220](v19 - 16, 0x1000C8000313F17);
            LODWORD(v18) = *(_DWORD *)(v16 + 16);
          }
          *(_DWORD *)(v17 + 16) = v18;
          operator new[]();
        }
        if (*(_DWORD *)(v17 + 16))
        {
          unint64_t v20 = 0;
          do
          {
            *(void *)(*(void *)(v17 + 8) + 8 * v20) = *(void *)(*(void *)(v16 + 8) + 8 * v20);
            ++v20;
          }
          while (v20 < *(unsigned int *)(v17 + 16));
        }
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v15 + 48 * v14 + 24) + 64))();
      }
      ++v14;
    }
    while (v14 < *(unsigned int *)(v4 + 16));
  }
  return result;
}

void sub_2184C6AD8(_Unwind_Exception *a1)
{
  *uint64_t v4 = off_26C99C118;
  uint64_t v6 = v4[1];
  if (v6) {
    MEMORY[0x21D46B220](v6 - 16, 0x1000C8000313F17);
  }
  if (v3 != v4)
  {
    do
    {
      NPhoneHMM::~NPhoneHMM((NPhoneHMM *)(v1 - 32 + v2));
      v2 -= 48;
    }
    while (v2);
  }
  MEMORY[0x21D46B220](v1, 0x10B1C80FD921951);
  _Unwind_Resume(a1);
}

uint64_t NAutoArray<NPhoneHMM>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  uint64_t v4 = a2 + 16;
  unsigned int v5 = v6;
  unsigned int v7 = *(_DWORD *)(a1 + 20);
  BOOL v8 = v6 >= v7;
  if (v6 <= v7)
  {
    *(_DWORD *)(a1 + 16) = v5;
    if (!v8) {
      operator new[]();
    }
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 48))(a1, v4, (float)(*(float *)(a1 + 24) * (float)v5));
  }
  if (*(_DWORD *)(a1 + 16))
  {
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(a2 + 8);
      uint64_t v11 = *(void *)(a1 + 8);
      if (v11 != v10)
      {
        uint64_t v12 = v10 + 48 * v9;
        uint64_t v13 = v11 + 48 * v9;
        uint64_t v14 = *(unsigned int *)(v12 + 16);
        if (*(_DWORD *)(v13 + 16) != v14)
        {
          uint64_t v15 = *(void *)(v13 + 8);
          if (v15)
          {
            MEMORY[0x21D46B220](v15 - 16, 0x1000C8000313F17);
            LODWORD(v14) = *(_DWORD *)(v12 + 16);
          }
          *(_DWORD *)(v13 + 16) = v14;
          operator new[]();
        }
        if (*(_DWORD *)(v13 + 16))
        {
          unint64_t v16 = 0;
          do
          {
            *(void *)(*(void *)(v13 + 8) + 8 * v16) = *(void *)(*(void *)(v12 + 8) + 8 * v16);
            ++v16;
          }
          while (v16 < *(unsigned int *)(v13 + 16));
        }
        (*(void (**)(void))(*(void *)(v11 + 48 * v9 + 24) + 64))();
      }
      ++v9;
    }
    while (v9 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

void sub_2184C6EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  NPhoneHMM::~NPhoneHMM((NPhoneHMM *)va);
  _Unwind_Resume(a1);
}

void sub_2184C6F0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12 - 16, 0x1000C8000313F17);
  }
  _Unwind_Resume(exception_object);
}

void NAutoArray<NPhoneHMM>::~NAutoArray(void *a1)
{
  *a1 = &unk_26C99C150;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = 48 * v2;
      uint64_t v4 = v1 - 24;
      do
      {
        unsigned int v5 = (void *)(v4 + v3);
        *(v5 - 3) = &unk_26C99C7A8;
        *unsigned int v5 = &unk_26C99C5B0;
        uint64_t v6 = *(void *)(v4 + v3 + 16);
        if (v6) {
          MEMORY[0x21D46B220](v6, 0x1000C8077774924);
        }
        *(v5 - 3) = off_26C99C118;
        uint64_t v7 = *(v5 - 2);
        if (v7) {
          MEMORY[0x21D46B220](v7 - 16, 0x1000C8000313F17);
        }
        v3 -= 48;
      }
      while (v3);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10B1C80FD921951);
  }

  JUMPOUT(0x21D46B240);
}

void NPhoneHMMArray::write(NPhoneHMMArray *this, const NString *a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  *(void *)__str = &unk_26C99C5B0;
  int v3 = 1;
  operator new[]();
}

void sub_2184C7970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 8))(a14);
  }
  if (a17)
  {
    MEMORY[0x21D46B220](a17, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NPhoneHMMArray::initReverseLookup(uint64_t this)
{
  if (!*(_DWORD *)(this + 52))
  {
    uint64_t v1 = this;
    this = NHash<NMap<NString,unsigned int>::HashItem>::resize(this + 32, *(_DWORD *)(this + 16), 0);
    if (*(_DWORD *)(v1 + 16)) {
      NMap<NString,unsigned int>::operator[](v1 + 24, *(void *)(v1 + 8) + 24);
    }
  }
  return this;
}

uint64_t NHash<NMap<NString,unsigned int>::HashItem>::resize(uint64_t result, unsigned int a2, char a3)
{
  if (*(_DWORD *)(result + 20) != a2)
  {
    uint64_t v3 = result;
    int v32 = 0;
    long long v30 = &unk_26C99BE78;
    uint64_t v31 = 0;
    if (!a3 && a2 - 1 >= 2)
    {
      unsigned int v4 = a2 | 1;
      if ((a2 & 0xFFFFFFFE) >= 3)
      {
        while (v4 >= 9)
        {
          int v23 = 5;
          while (v4 % (v23 - 2))
          {
            unsigned int v24 = v23 * v23;
            v23 += 2;
            if (v24 > v4) {
              goto LABEL_5;
            }
          }
          a2 = v4 + 2;
          unsigned int v25 = v4 + 1;
          v4 += 2;
          if (v25 < 3) {
            goto LABEL_6;
          }
        }
      }
LABEL_5:
      a2 = v4;
    }
LABEL_6:
    LODWORD(v33) = a2;
    uint64_t result = NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::resize((uint64_t)&v30, &v33);
    HIDWORD(v33) = 0;
    float v26 = (uint64_t (**)(void **, uint64_t))&unk_26C99A760;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    int v29 = 0;
    unint64_t v6 = *(unsigned int *)(v3 + 20);
    if (v6)
    {
      for (unint64_t i = 0; i < v6; ++i)
      {
        uint64_t v8 = *(void *)(v3 + 8);
        if (!v8) {
          Error::chuck((Error *)"NLinkedList::NIterator::start List not set", v5);
        }
        uint64_t v9 = *(void *)(v8 + 32 * i + 8);
        if (v9)
        {
          do
          {
            uint64_t result = v26[8]((void **)&v26, v9 + 16);
            if (v27) {
              uint64_t v10 = (uint64_t *)(v28 + 8);
            }
            else {
              uint64_t v10 = &v28;
            }
            if (v27) {
              uint64_t v11 = 2;
            }
            else {
              uint64_t v11 = 1;
            }
            *uint64_t v10 = result;
            (&v26)[v11] = (uint64_t (**)(void **, uint64_t))result;
            ++v29;
            uint64_t v9 = *(void *)(v9 + 8);
          }
          while (v9);
          unint64_t v6 = *(unsigned int *)(v3 + 20);
        }
      }
      for (uint64_t j = v27; j; uint64_t j = *(void *)(j + 8))
      {
        if (!v33) {
          Error::chuck((Error *)"NHash::insert() - zero length hash table", v5);
        }
        uint64_t v13 = *(unsigned int *)(j + 24);
        if (v13)
        {
          unsigned int v14 = 0;
          uint64_t v15 = *(char **)(j + 32);
          do
          {
            int v16 = *v15++;
            unsigned int v14 = v16 + 65599 * v14;
            --v13;
          }
          while (v13);
        }
        else
        {
          unsigned int v14 = 0;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v31 + 32 * (v14 % v33)) + 32))(v31 + 32 * (v14 % v33), j + 16);
        ++HIDWORD(v33);
      }
    }
    if (&v30 != (void **)v3)
    {
      *(void *)(v3 + 20) = v33;
      uint64_t result = NArray<NLinkedList<NMap<NString,unsigned int>::HashItem>>::operator=(v3, (uint64_t)&v30);
    }
    float v26 = (uint64_t (**)(void **, uint64_t))&unk_26C99A760;
    for (uint64_t k = v27; v27; uint64_t k = v27)
    {
      uint64_t v27 = *(void *)(k + 8);
      uint64_t result = ((uint64_t (*)(uint64_t (***)(void **, uint64_t)))v26[9])(&v26);
    }
    long long v30 = &unk_26C99BF58;
    uint64_t v18 = v31;
    if (v31)
    {
      uint64_t v19 = *(void *)(v31 - 8);
      if (v19)
      {
        uint64_t v20 = v31 + 32 * v19;
        do
        {
          uint64_t v21 = v20 - 32;
          for (*(void *)(v20 - 32) = &unk_26C99A760;
                ;
                (*(void (**)(uint64_t))(*(void *)(v20 - 32) + 72))(v20 - 32))
          {
            uint64_t v22 = *(void *)(v20 - 24);
            if (!v22) {
              break;
            }
            *(void *)(v20 - 24) = *(void *)(v22 + 8);
          }
          *(void *)(v20 - 16) = 0;
          *(_DWORD *)(v20 - 8) = 0;
          v20 -= 32;
        }
        while (v21 != v18);
      }
      return MEMORY[0x21D46B220](v18 - 16, 0x10A1C80F4A7E088);
    }
  }
  return result;
}

void sub_2184C7EF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void NMap<NString,unsigned int>::operator[](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = &unk_26C99C5B0;
  LODWORD(__n) = *(_DWORD *)(a2 + 8);
  operator new[]();
}

void sub_2184C8248(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NPhoneHMMArray::endReverseLookup(uint64_t this)
{
  if (*(_DWORD *)(this + 52))
  {
    uint64_t v1 = this;
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    do
    {
      (*(void (**)(uint64_t))(*(void *)(*(void *)(v1 + 40) + v2) + 56))(*(void *)(v1 + 40) + v2);
      ++v3;
      v2 += 32;
    }
    while (v3 < *(unsigned int *)(v1 + 52));
    *(_DWORD *)(v1 + 56) = 0;
    return NHash<NMap<NString,unsigned int>::HashItem>::resize(v1 + 32, 0, 1);
  }
  return this;
}

void NPhoneHMMArray::operator()(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 52))
  {
    NHash<NMap<NString,unsigned int>::HashItem>::resize(a1 + 32, *(_DWORD *)(a1 + 16), 0);
    if (*(_DWORD *)(a1 + 16)) {
      NMap<NString,unsigned int>::operator[](a1 + 24, *(void *)(a1 + 8) + 24);
    }
  }
  operator new[]();
}

void sub_2184C8600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NPipeFile::getPosition(NPipeFile *this, const char *a2)
{
}

void NPipeFile::setPosition(NPipeFile *this, const char *a2)
{
}

void NPipeFile::write(NPipeFile *this, const NString *a2)
{
  if ((*(uint64_t (**)(NPipeFile *, const NString *))(*(void *)this + 32))(this, a2))
  {
    if (*((_DWORD *)this + 12) == 1) {
      Error::chuck((Error *)"NPipeFile::write() - Not available because compiled without support", v3);
    }
    Error::chuck((Error *)"NPipeFile::write() - pipe \"%s\" not opened in write mode", v3, *((void *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::write() - pipe \"%s\" is not open", v3, *((void *)this + 3));
}

void NPipeFile::readString(NPipeFile *this)
{
  if ((*(uint64_t (**)(NPipeFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 12)) {
      Error::chuck((Error *)"NPipeFile::readString() - Not available because compiled without support", v2);
    }
    Error::chuck((Error *)"NPipeFile::readString() - pipe \"%s\" not opened in read mode", v2, *((void *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::readString() - pipe \"%s\" is not open", v2, *((void *)this + 3));
}

void NPipeFile::readLine(NPipeFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  if ((*(uint64_t (**)(NPipeFile *, const char *))(*(void *)this + 32))(this, a2))
  {
    if (!*((_DWORD *)this + 12))
    {
      *(void *)a3 = &unk_26C99C5B0;
      *(_DWORD *)(a3 + 8) = 0;
      operator new[]();
    }
    Error::chuck((Error *)"NPipeFile::readLine() - pipe \"%s\" not opened in read mode", v5, *((void *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::readLine() - pipe \"%s\" is not open", v5, *((void *)this + 3));
}

void sub_2184C8870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  void *v12 = v13;
  uint64_t v15 = v12[2];
  if (v15) {
    MEMORY[0x21D46B220](v15, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NPipeFile::read(NPipeFile *this, const unsigned int *a2, NString *a3)
{
  if ((*(uint64_t (**)(NPipeFile *, const unsigned int *, NString *))(*(void *)this + 32))(this, a2, a3))
  {
    if (!*((_DWORD *)this + 12))
    {
      if (*a2 == -1) {
        Error::chuck((Error *)"NFile::read() - attempting impossibly long read in pipe \"%s\"", v5, *((void *)this + 3));
      }
      Error::chuck((Error *)"NPipeFile::read() - Not available because compiled without support", v5);
    }
    Error::chuck((Error *)"NPipeFile::read() - pipe \"%s\" not opened in read mode", v5, *((void *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::read() - pipe \"%s\" is not open", v5, *((void *)this + 3));
}

void NPipeFile::read(NPipeFile *this, const unsigned int *a2)
{
  if ((*(uint64_t (**)(NPipeFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 12))
    {
      if (*a2 == -1) {
        Error::chuck((Error *)"NFile::read() - attempting impossibly long read in pipe \"%s\"", v4, *((void *)this + 3));
      }
      operator new[]();
    }
    Error::chuck((Error *)"NPipeFile::read() - pipe \"%s\" not opened in read mode", v4, *((void *)this + 3));
  }
  Error::chuck((Error *)"NPipeFile::read() - pipe \"%s\" is not open", v4, *((void *)this + 3));
}

void sub_2184C8A50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NPipeFile::read(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 0;
  operator new[]();
}

void sub_2184C8BDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  *uint64_t v11 = v12;
  uint64_t v14 = v11[2];
  if (v14) {
    MEMORY[0x21D46B220](v14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NPipeFile::good(NPipeFile *this)
{
  if ((*(uint64_t (**)(NPipeFile *))(*(void *)this + 40))(this)) {
    return 0;
  }
  unint64_t v3 = *(uint64_t (**)(NPipeFile *))(*(void *)this + 32);

  return v3(this);
}

void NPipeFile::eof(NPipeFile *this, const char *a2)
{
}

uint64_t NPipeFile::isOpen(NPipeFile *this)
{
  return *((unsigned __int8 *)this + 52);
}

uint64_t NPipeFile::close(NPipeFile *this, const char *a2)
{
  if (*((unsigned char *)this + 52)) {
    Error::chuck((Error *)"NPipeFile::close() - Not available because compiled without support", a2);
  }
  int v4 = 0;
  uint64_t v2 = (char *)this + 8;
  uint64_t result = (*(uint64_t (**)(char *, const char *, int *))(*((void *)this + 1) + 64))((char *)this + 8, "", &v4);
  v2[44] = 0;
  return result;
}

void NPipeFile::open(NPipeFile *this, const NString *a2, const NString *a3)
{
  (*(void (**)(NPipeFile *))(*(void *)this + 24))(this);
  uint64_t v7 = (unsigned char *)*((void *)a3 + 2);
  if (*((_DWORD *)a3 + 2) == 1)
  {
    if (*v7 == 114)
    {
      int v8 = 0;
      goto LABEL_6;
    }
    uint64_t v7 = (unsigned char *)*((void *)a3 + 2);
    if (*v7 == 119)
    {
      int v8 = 1;
LABEL_6:
      *((_DWORD *)this + 12) = v8;
      *((void *)this + 5) = 0;
      Error::chuck((Error *)"NPipeFile::open() - Can't open pipe '\"%s\"' because compiled without support", v6, *((void *)a2 + 2));
    }
  }
  Error::chuck((Error *)"NPipeFile::open() - unrecognized file mode \"%s\"", v6, v7);
}

void NPipeFile::~NPipeFile(NPipeFile *this, const char *a2)
{
  *(void *)this = &unk_26C99C7E0;
  if (!*((unsigned char *)this + 52))
  {
    uint64_t v3 = *((void *)this + 1);
    int v5 = 0;
    (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 8, "", &v5);
    *((unsigned char *)this + 52) = 0;
    *(void *)this = &unk_26C99C718;
    *((void *)this + 1) = &unk_26C99C5B0;
    uint64_t v4 = *((void *)this + 3);
    if (v4) {
      MEMORY[0x21D46B220](v4, 0x1000C8077774924);
    }
    JUMPOUT(0x21D46B240);
  }
  Error::chuck((Error *)"NPipeFile::close() - Not available because compiled without support", a2);
}

{
  uint64_t v3;
  uint64_t v4;
  int v5;

  *(void *)this = &unk_26C99C7E0;
  if (*((unsigned char *)this + 52)) {
    Error::chuck((Error *)"NPipeFile::close() - Not available because compiled without support", a2);
  }
  uint64_t v3 = *((void *)this + 1);
  int v5 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 8, "", &v5);
  *((unsigned char *)this + 52) = 0;
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 3);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
}

{
  uint64_t v3;
  uint64_t v4;
  int v5;

  *(void *)this = &unk_26C99C7E0;
  if (*((unsigned char *)this + 52)) {
    Error::chuck((Error *)"NPipeFile::close() - Not available because compiled without support", a2);
  }
  uint64_t v3 = *((void *)this + 1);
  int v5 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 8, "", &v5);
  *((unsigned char *)this + 52) = 0;
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 3);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
}

void NPipeFile::NPipeFile(NPipeFile *this)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void NPipeFile::NPipeFile(NPipeFile *this, const NString *a2, const NString *a3)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void sub_2184C9250(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v5 = v1[3];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_2184C9344(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v5 = v1[3];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NDistribution::allocateStateP(NDistribution *this)
{
  return 0;
}

void NFloatDistribution::fixedPointScalesP(NFloatDistribution *this, const char *a2)
{
}

uint64_t NFloatDistribution::baseGMM(NFloatDistribution *this)
{
  return (uint64_t)this + 8;
}

void NFloatDistribution::posteriorWeightedMean()
{
}

uint64_t NFloatDistribution::firstComponentId(NFloatDistribution *this, const unsigned int *a2)
{
  return **(unsigned int **)(*((void *)this + 2) + 48 * *a2 + 8);
}

uint64_t NFloatDistribution::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 16) + 48 * *a2;
  uint64_t v4 = *(unsigned int *)(v3 + 16);
  if (v4)
  {
    uint64_t v5 = *(void *)(v3 + 8);
    uint64_t v6 = *(void *)(a3 + 8);
    if (v4 == 1)
    {
      uint64_t v7 = 0;
LABEL_7:
      uint64_t v11 = v4 - v7;
      uint64_t v12 = (unsigned int *)(v5 + 4 * v7);
      do
      {
        unsigned int v13 = *v12++;
        *(unsigned char *)(v6 + v13) = 1;
        --v11;
      }
      while (v11);
      return result;
    }
    uint64_t v7 = v4 & 0xFFFFFFFE;
    int v8 = (unsigned int *)(v5 + 4);
    uint64_t v9 = v7;
    do
    {
      uint64_t v10 = *v8;
      *(unsigned char *)(v6 + *(v8 - 1)) = 1;
      *(unsigned char *)(v6 + v10) = 1;
      v8 += 2;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4) {
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t NFloatDistribution::numComponents(NFloatDistribution *this)
{
  return (uint64_t)this + 48;
}

float NFloatDistribution::componentScore(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 40);
  float v4 = *(float *)(v3 + 56 * *a2 + 48);
  uint64_t v5 = *(unsigned int *)(a3 + 16);
  if (v5)
  {
    uint64_t v6 = *(float32x4_t **)(a3 + 8);
    uint64_t v7 = v3 + 56 * *a2;
    int v8 = *(float32x4_t **)(v7 + 8);
    uint64_t v9 = *(float32x4_t **)(v7 + 32);
    if (v5 < 8)
    {
      uint64_t v10 = 0;
LABEL_7:
      uint64_t v19 = v5 - v10;
      uint64_t v20 = v10;
      uint64_t v21 = &v9->f32[v20];
      uint64_t v22 = &v8->f32[v20];
      int v23 = &v6->f32[v20];
      do
      {
        float v24 = *v23++;
        float v25 = v24;
        float v26 = *v22++;
        float v27 = (float)(v25 - v26) * (float)(v25 - v26);
        float v28 = *v21++;
        float v4 = v4 + (float)(v27 * v28);
        --v19;
      }
      while (v19);
      return v4 * -0.5;
    }
    uint64_t v10 = v5 & 0xFFFFFFF8;
    uint64_t v11 = v9 + 1;
    uint64_t v12 = v8 + 1;
    unsigned int v13 = v6 + 1;
    uint64_t v14 = v10;
    do
    {
      float32x4_t v15 = vsubq_f32(v13[-1], v12[-1]);
      float32x4_t v16 = vsubq_f32(*v13, *v12);
      float32x4_t v17 = vmulq_f32(vmulq_f32(v15, v15), v11[-1]);
      float32x4_t v18 = vmulq_f32(vmulq_f32(v16, v16), *v11);
      float v4 = (float)((float)((float)((float)((float)((float)((float)(v4 + v17.f32[0]) + v17.f32[1]) + v17.f32[2])
                                         + v17.f32[3])
                                 + v18.f32[0])
                         + v18.f32[1])
                 + v18.f32[2])
         + v18.f32[3];
      v11 += 2;
      v12 += 2;
      v13 += 2;
      v14 -= 8;
    }
    while (v14);
    if (v10 != v5) {
      goto LABEL_7;
    }
  }
  return v4 * -0.5;
}

void NFloatDistribution::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = v4 + 48 * *a2;
  uint64_t v6 = *(unsigned int *)(v5 + 16);
  if (v6)
  {
    uint64_t v7 = 0;
    uint64_t v8 = *(void *)(v5 + 8);
    uint64_t v9 = *(void *)(a3 + 8);
    uint64_t v10 = (void *)(v4 + 48 * *a2 + 32);
    uint64_t v11 = *(void *)(a4 + 8);
    uint64_t v12 = 4 * v6;
    double v13 = 0.0;
    do
    {
      uint64_t v14 = *(unsigned int *)(v8 + v7);
      if (*(unsigned char *)(v9 + v14)) {
        double v13 = v13 + expf(*(float *)(*v10 + v7) + *(float *)(v11 + 4 * v14));
      }
      v7 += 4;
    }
    while (v12 != v7);
    if (v13 != 0.0) {
      log(v13);
    }
  }
}

uint64_t NDistribution::scoreAll(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v10 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (result)
  {
    do
    {
      float v7 = (*(float (**)(uint64_t, unsigned int *, uint64_t))(*(void *)a1 + 64))(a1, &v10, a2);
      unsigned int v8 = v10;
      *(float *)(*(void *)(a3 + 8) + 4 * v10) = v7;
      unsigned int v9 = v8 + 1;
      unsigned int v10 = v8 + 1;
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    }
    while (v9 < result);
  }
  return result;
}

float NFloatDistribution::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return NGaussianMixtureModels::score(a1 + 8, a2, a3);
}

void NFloatDistribution::read(NFloatDistribution *this, const NString *a2)
{
}

uint64_t NDistribution::scoreCacheTypes(NDistribution *this)
{
  return 7;
}

uint64_t NDistribution::frameSize(NDistribution *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 24))();
}

uint64_t NDistribution::numFrames(NDistribution *this)
{
  return 1;
}

uint64_t NFloatDistribution::dimen(NFloatDistribution *this)
{
  return (uint64_t)this + 56;
}

uint64_t NFloatDistribution::size(NFloatDistribution *this)
{
  return *((unsigned int *)this + 6);
}

void NFloatDistribution::~NFloatDistribution(NFloatDistribution *this)
{
  *(void *)this = &unk_26C99B048;
  NGaussianMixtureModels::~NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));

  JUMPOUT(0x21D46B240);
}

{
  *(void *)this = &unk_26C99B048;
  NGaussianMixtureModels::~NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));
}

{
  *(void *)this = &unk_26C99B048;
  NGaussianMixtureModels::~NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));
}

void NDistributionLoader::~NDistributionLoader(NDistributionLoader *this)
{
  *(void *)this = &unk_26C99B258;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99B258;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99B258;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

void NFloatDistribution::NFloatDistribution(NFloatDistribution *this)
{
  *(void *)this = &unk_26C99B048;
  NGaussianMixtureModels::NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));
}

{
  *(void *)this = &unk_26C99B048;
  NGaussianMixtureModels::NGaussianMixtureModels((NFloatDistribution *)((char *)this + 8));
}

void NDistributionLoader::NDistributionLoader(NDistributionLoader *this)
{
  *(void *)this = &unk_26C99B258;
  *((void *)this + 1) = 0;
}

{
  *(void *)this = &unk_26C99B258;
  *((void *)this + 1) = 0;
}

void NDistributionLoader::read(NDistributionLoader *this, const NString *a2, const NString *a3)
{
  uint64_t v4 = *((void *)this + 1);
  if (v4) {
    (*(void (**)(uint64_t, const NString *, const NString *))(*(void *)v4 + 8))(v4, a2, a3);
  }
  *((void *)this + 1) = 0;
  operator new[]();
}

void sub_2184CB6AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  v18[34] = v22;
  uint64_t v25 = v18[35];
  if (v25) {
    MEMORY[0x21D46B220](v25, 0x50C80EE9192B6);
  }
  v18[31] = v21;
  uint64_t v26 = v18[33];
  if (v26) {
    MEMORY[0x21D46B220](v26, 0x1000C8077774924);
  }
  NGaussianFixedPointScales::~NGaussianFixedPointScales(v20);
  v18[1] = v19;
  uint64_t v27 = v18[3];
  if (v27) {
    MEMORY[0x21D46B220](v27, 0x1000C8077774924);
  }
  MEMORY[0x21D46B240](v18, 0x10D1C4027B8FD50);
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)&a15);
  *(void *)(v23 - 144) = &unk_26C99C5B0;
  uint64_t v28 = *(void *)(v23 - 128);
  if (v28) {
    MEMORY[0x21D46B220](v28, 0x1000C8077774924);
  }
  *(void *)(v23 - 120) = &unk_26C99AA78;
  uint64_t v29 = *(void *)(v23 - 112);
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  }
  *(void *)(v23 - 104) = v17;
  uint64_t v30 = *(void *)(v23 - 88);
  if (v30) {
    MEMORY[0x21D46B220](v30, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t NFixedDummyDistribution::fixedPointScalesP(NFixedDummyDistribution *this)
{
  return (uint64_t)this + 16;
}

void NFixedDummyDistribution::baseGMM(NFixedDummyDistribution *this, const char *a2)
{
}

void NFixedDummyDistribution::notSupported(NFixedDummyDistribution *this, const char *a2)
{
}

void NFixedDummyDistribution::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

void NFixedDummyDistribution::firstComponentId(NFixedDummyDistribution *this, const char *a2)
{
}

void NFixedDummyDistribution::setComponentMask(uint64_t a1, const char *a2)
{
}

void NFixedDummyDistribution::numComponents(NFixedDummyDistribution *this, const char *a2)
{
}

void NFixedDummyDistribution::componentScore(uint64_t a1, const char *a2)
{
}

void NFixedDummyDistribution::scoreUsingCache(uint64_t a1, const char *a2)
{
}

float NFixedDummyDistribution::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return *(float *)(*(void *)(a3 + 8) + 4 * *a2);
}

void NFixedDummyDistribution::read(NFixedDummyDistribution *this, const NString *a2)
{
  *((void *)this + 1) = 0;
  operator new[]();
}

void sub_2184CC4C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  if (a28) {
    MEMORY[0x21D46B220](a28, 0x1000C8077774924);
  }
  *(void *)(v28 - 144) = &unk_26C99C5B0;
  uint64_t v30 = *(void *)(v28 - 128);
  if (v30) {
    MEMORY[0x21D46B220](v30, 0x1000C8077774924);
  }
  *(void *)(v28 - 120) = &unk_26C99AA78;
  uint64_t v31 = *(void *)(v28 - 112);
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NFixedDummyDistribution::dimen(NFixedDummyDistribution *this)
{
  return (uint64_t)this + 12;
}

uint64_t NFixedDummyDistribution::size(NFixedDummyDistribution *this)
{
  return *((unsigned int *)this + 2);
}

void NFixedDummyDistribution::~NFixedDummyDistribution(NFixedDummyDistribution *this)
{
  *(void *)this = &unk_26C99BB90;
  NFixedPointScales::~NFixedPointScales((NFixedDummyDistribution *)((char *)this + 16));

  JUMPOUT(0x21D46B240);
}

{
  *(void *)this = &unk_26C99BB90;
  NFixedPointScales::~NFixedPointScales((NFixedDummyDistribution *)((char *)this + 16));
}

void NDummyDistribution::fixedPointScalesP(NDummyDistribution *this, const char *a2)
{
}

void NDummyDistribution::baseGMM(NDummyDistribution *this, const char *a2)
{
}

void NDummyDistribution::notSupported(NDummyDistribution *this, const char *a2)
{
}

void NDummyDistribution::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

void NDummyDistribution::firstComponentId(NDummyDistribution *this, const char *a2)
{
}

void NDummyDistribution::setComponentMask(uint64_t a1, const char *a2)
{
}

void NDummyDistribution::numComponents(NDummyDistribution *this, const char *a2)
{
}

void NDummyDistribution::componentScore(uint64_t a1, const char *a2)
{
}

void NDummyDistribution::scoreUsingCache(uint64_t a1, const char *a2)
{
}

float NDummyDistribution::score(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  return *(float *)(*(void *)(a3 + 8) + 4 * *a2);
}

void NDummyDistribution::read(NDummyDistribution *this, const NString *a2)
{
  *((void *)this + 1) = 0;
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 1;
  operator new[]();
}

void sub_2184CD054(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a27) {
    MEMORY[0x21D46B220](a27, 0x1000C8077774924);
  }
  *(void *)(v27 - 136) = &unk_26C99C5B0;
  uint64_t v29 = *(void *)(v27 - 120);
  if (v29) {
    MEMORY[0x21D46B220](v29, 0x1000C8077774924);
  }
  *(void *)(v27 - 112) = &unk_26C99AA78;
  uint64_t v30 = *(void *)(v27 - 104);
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NDummyDistribution::dimen(NDummyDistribution *this)
{
  return (uint64_t)this + 12;
}

uint64_t NDummyDistribution::size(NDummyDistribution *this)
{
  return *((unsigned int *)this + 2);
}

void NDummyDistribution::~NDummyDistribution(NDummyDistribution *this)
{
}

uint64_t NArray<unsigned int const*>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<unsigned int const*>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x50C80EE9192B6);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 8 * *(unsigned int *)(result + 16);
    do
    {
      *(void *)(*(void *)(result + 8) + v8) = *(void *)(a2 + v8);
      v8 += 8;
    }
    while (v9 != v8);
  }
  return result;
}

uint64_t NArray<unsigned int const*>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x50C80EE9192B6);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * *(unsigned int *)(result + 16);
      do
      {
        *(void *)(*(void *)(result + 8) + v7) = *(void *)(*(void *)(a2 + 8) + v7);
        v7 += 8;
      }
      while (v8 != v7);
    }
  }
  return result;
}

void NArray<unsigned int const*>::~NArray(void *a1)
{
  *a1 = &unk_26C99C1C0;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x50C80EE9192B6);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<unsigned int const*>::~NArray(void *a1)
{
  *a1 = &unk_26C99C1C0;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  return a1;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::baseGMM(uint64_t a1, const char *a2)
{
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 280) + 8 * *a2) + 4);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int **)(*(void *)(result + 280) + 8 * *a2);
  uint64_t v4 = *v3;
  if (v4)
  {
    int v5 = v3 + 1;
    uint64_t v6 = *(void *)(a3 + 8);
    if (v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      int v12 = v4 - v7;
      do
      {
        unsigned int v13 = *v5;
        v5 += 2;
        *(unsigned char *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    uint64_t v7 = v4 & 0xFFFFFFFE;
    v5 += 2 * v7;
    uint64_t v8 = v3 + 3;
    uint64_t v9 = v7;
    do
    {
      uint64_t v10 = *(v8 - 2);
      unsigned int v11 = *v8;
      v8 += 4;
      *(unsigned char *)(v6 + v10) = 1;
      *(unsigned char *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4) {
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::componentScore(uint64_t a1)
{
}

void sub_2184CD8F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

float NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  int v5 = *(int **)(*(void *)(a1 + 280) + 8 * *a2);
  int v6 = *v5;
  if (*v5)
  {
    uint64_t v9 = v5 + 2;
    uint64_t v10 = 3221225473;
    do
    {
      uint64_t v12 = *(v9 - 1);
      if (*(unsigned char *)(*(void *)(a3 + 8) + v12))
      {
        int v13 = (uint64_t)rintf(*(float *)(*(void *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v13;
        }
        if (v13 >= (int)v10) {
          int v13 = v10;
        }
        if (v13 != -1073741823)
        {
          int v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500)) {
            uint64_t v11 = (*(_DWORD *)(*(void *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
          }
                               + v11);
        }
      }
      else
      {
        uint64_t v11 = v10;
      }
      v9 += 2;
      uint64_t v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::score(uint64_t a1)
{
}

void sub_2184CDD74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::read()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  *(void *)__str = &unk_26C99C5B0;
  LODWORD(v1) = 1;
  operator new[]();
}

void sub_2184CF6A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  if (a43) {
    MEMORY[0x21D46B220](a43, 0x1000C8077774924);
  }
  a44 = &unk_26C99C3F0;
  if (a45) {
    MEMORY[0x21D46B220](a45, 0x1000C8052888210);
  }
  if (!a26) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(uint64_t))(*(void *)a26 + 8))(a26);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedGaussians<signed char,int,unsigned short>::read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, unsigned char *a6)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  NGaussianFixedPointScales::operator=(a1 + 32, a4);
  int v13 = *a5;
  int v14 = 2 * *(_DWORD *)(a4 + 184) + ((-2 * *(_DWORD *)(a4 + 184)) & 2) + 8;
  *(_DWORD *)(a1 + 232) = v14;
  *(_DWORD *)(a1 + 236) = v13;
  unsigned int v18 = *a5 * v14;
  if (!*a6) {
    operator new[]();
  }
  uint64_t v15 = *(void *)(a3 + 8);
  if (!v15) {
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(void *)v15 + 72))(v15, &v18, a1);
  *(void *)(a1 + 24) = *(void *)(a1 + 16);
  if (result != v18) {
    Error::chuck((Error *)"NFastFixedGaussians::read() - not enough gaussian data in file %s (%d out of %d bytes)", v17, *(void *)(a2 + 16), result, v18);
  }
  return result;
}

void sub_2184D0A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  a39 = a15;
  if (!a41) {
    _Unwind_Resume(a1);
  }
  MEMORY[0x21D46B220](a41, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NAutoArray<unsigned int>::resize(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  unsigned int v5 = *a2;
  if (*a2 <= a3) {
    unsigned int v6 = a3;
  }
  else {
    unsigned int v6 = *a2;
  }
  if (v6) {
    operator new[]();
  }
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (v5 < v7)
  {
    *(_DWORD *)(a1 + 16) = v5;
    unsigned int v7 = v5;
  }
  uint64_t result = *(void *)(a1 + 8);
  if (v7)
  {
    uint64_t v9 = 0;
    uint64_t v10 = v7;
    if (v7 < 8) {
      goto LABEL_14;
    }
    if ((unint64_t)-result < 0x20) {
      goto LABEL_14;
    }
    uint64_t v9 = v7 & 0xFFFFFFF8;
    uint64_t v11 = 16;
    uint64_t v12 = (long long *)(result + 16);
    uint64_t v13 = v10 & 0xFFFFFFF8;
    do
    {
      long long v14 = *v12;
      *(_OWORD *)(v11 - 16) = *(v12 - 1);
      *(_OWORD *)uint64_t v11 = v14;
      v11 += 32;
      v12 += 2;
      v13 -= 8;
    }
    while (v13);
    if (v9 != v10)
    {
LABEL_14:
      uint64_t v15 = v10 - v9;
      float32x4_t v16 = (_DWORD *)(4 * v9);
      uint64_t v17 = (_DWORD *)((char *)v16 + result);
      do
      {
        int v18 = *v17++;
        *v16++ = v18;
        --v15;
      }
      while (v15);
    }
    goto LABEL_18;
  }
  if (result) {
LABEL_18:
  }
    uint64_t result = MEMORY[0x21D46B220]();
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = 0;
  return result;
}

uint64_t NAutoArray<unsigned int>::operator=(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t NAutoArray<unsigned int>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *a3;
  if (*(_DWORD *)(result + 20) < *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C8052888210);
      int v4 = *a3;
    }
    *(_DWORD *)(v3 + 20) = v4;
    operator new[]();
  }
  *(_DWORD *)(result + 16) = v4;
  if (v4)
  {
    unint64_t v7 = 0;
    uint64_t v8 = *(void *)(result + 8);
    do
    {
      *(_DWORD *)(v8 + 4 * v7) = *(_DWORD *)(a2 + 4 * v7);
      ++v7;
    }
    while (v7 < *(unsigned int *)(result + 16));
  }
  return result;
}

uint64_t NAutoArray<unsigned int>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  uint64_t v4 = a2 + 16;
  unint64_t v5 = v6;
  unsigned int v7 = *(_DWORD *)(a1 + 20);
  BOOL v8 = v6 >= v7;
  if (v6 <= v7)
  {
    *(_DWORD *)(a1 + 16) = v5;
    if (!v8)
    {
      uint64_t v9 = *(void *)(a1 + 8);
      do
        *(_DWORD *)(v9 + 4 * v5++) = 0;
      while (v5 < *(unsigned int *)(a1 + 20));
    }
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 48))(a1, v4, (float)(*(float *)(a1 + 24) * (float)v5));
  }
  if (*(_DWORD *)(a1 + 16))
  {
    unint64_t v10 = 0;
    uint64_t v11 = *(void *)(a2 + 8);
    uint64_t v12 = *(void *)(a1 + 8);
    do
    {
      *(_DWORD *)(v12 + 4 * v10) = *(_DWORD *)(v11 + 4 * v10);
      ++v10;
    }
    while (v10 < *(unsigned int *)(a1 + 16));
  }
  return a1;
}

void NAutoArray<unsigned int>::~NAutoArray(void *a1)
{
  *a1 = &unk_26C99C3F0;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8052888210);
  }

  JUMPOUT(0x21D46B240);
}

void *NAutoArray<unsigned int>::~NAutoArray(void *a1)
{
  *a1 = &unk_26C99C3F0;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8052888210);
  }
  return a1;
}

uint64_t NGaussianFixedPointScales::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (_DWORD *)result;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
  if (result == a2)
  {
    *(unsigned char *)(result + 120) = *(unsigned char *)(a2 + 120);
    uint64_t v71 = *(void *)(a2 + 124);
    *(_DWORD *)(result + 132) = *(_DWORD *)(a2 + 132);
    *(void *)(result + 124) = v71;
  }
  else
  {
    int v4 = *(_DWORD *)(result + 32);
    int v5 = *(_DWORD *)(a2 + 32);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 24);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8052888210);
        int v5 = *(_DWORD *)(a2 + 32);
      }
      BOOL v3[8] = v5;
      operator new[]();
    }
    if (v4)
    {
      unint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 24);
      uint64_t v9 = *(void *)(result + 24);
      do
      {
        *(_DWORD *)(v9 + 4 * v7) = *(_DWORD *)(v8 + 4 * v7);
        ++v7;
      }
      while (v7 < *(unsigned int *)(result + 32));
    }
    *(void *)(result + 40) = *(void *)(a2 + 40);
    unsigned int v10 = *(_DWORD *)(result + 64);
    int v11 = *(_DWORD *)(a2 + 64);
    if (v10 != v11)
    {
      uint64_t v12 = *(void *)(result + 56);
      if (v12)
      {
        MEMORY[0x21D46B220](v12, 0x1000C8052888210);
        int v11 = *(_DWORD *)(a2 + 64);
      }
      v3[16] = v11;
      operator new[]();
    }
    if (v10)
    {
      uint64_t v13 = 0;
      uint64_t v14 = *(void *)(a2 + 56);
      uint64_t v15 = *(void *)(result + 56);
      uint64_t v16 = v10;
      if (v10 < 8) {
        goto LABEL_19;
      }
      if ((unint64_t)(v15 - v14) < 0x20) {
        goto LABEL_19;
      }
      uint64_t v13 = v10 & 0xFFFFFFF8;
      uint64_t v17 = (_OWORD *)(v15 + 16);
      int v18 = (long long *)(v14 + 16);
      uint64_t v19 = v16 & 0xFFFFFFF8;
      do
      {
        long long v20 = *v18;
        *(v17 - 1) = *(v18 - 1);
        *uint64_t v17 = v20;
        v17 += 2;
        v18 += 2;
        v19 -= 8;
      }
      while (v19);
      if (v13 != v16)
      {
LABEL_19:
        uint64_t v21 = v16 - v13;
        uint64_t v22 = 4 * v13;
        uint64_t v23 = (_DWORD *)(v15 + v22);
        float v24 = (int *)(v14 + v22);
        do
        {
          int v25 = *v24++;
          *v23++ = v25;
          --v21;
        }
        while (v21);
      }
    }
    unsigned int v26 = *(_DWORD *)(result + 88);
    int v27 = *(_DWORD *)(a2 + 88);
    if (v26 != v27)
    {
      uint64_t v28 = *(void *)(result + 80);
      if (v28)
      {
        MEMORY[0x21D46B220](v28, 0x1000C8052888210);
        int v27 = *(_DWORD *)(a2 + 88);
      }
      v3[22] = v27;
      operator new[]();
    }
    if (v26)
    {
      uint64_t v29 = 0;
      uint64_t v30 = *(void *)(a2 + 80);
      uint64_t v31 = *(void *)(result + 80);
      uint64_t v32 = v26;
      if (v26 < 8) {
        goto LABEL_31;
      }
      if ((unint64_t)(v31 - v30) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v29 = v26 & 0xFFFFFFF8;
      uint64_t v33 = (_OWORD *)(v31 + 16);
      float v34 = (long long *)(v30 + 16);
      uint64_t v35 = v32 & 0xFFFFFFF8;
      do
      {
        long long v36 = *v34;
        *(v33 - 1) = *(v34 - 1);
        *uint64_t v33 = v36;
        v33 += 2;
        v34 += 2;
        v35 -= 8;
      }
      while (v35);
      if (v29 != v32)
      {
LABEL_31:
        uint64_t v37 = v32 - v29;
        uint64_t v38 = 4 * v29;
        unint64_t v39 = (_DWORD *)(v31 + v38);
        uint64_t v40 = (int *)(v30 + v38);
        do
        {
          int v41 = *v40++;
          *v39++ = v41;
          --v37;
        }
        while (v37);
      }
    }
    unsigned int v42 = *(_DWORD *)(result + 112);
    int v43 = *(_DWORD *)(a2 + 112);
    if (v42 != v43)
    {
      uint64_t v44 = *(void *)(result + 104);
      if (v44)
      {
        MEMORY[0x21D46B220](v44, 0x1000C8052888210);
        int v43 = *(_DWORD *)(a2 + 112);
      }
      v3[28] = v43;
      operator new[]();
    }
    if (v42)
    {
      uint64_t v45 = 0;
      uint64_t v46 = *(void *)(a2 + 104);
      uint64_t v47 = *(void *)(result + 104);
      uint64_t v48 = v42;
      if (v42 < 8) {
        goto LABEL_43;
      }
      if ((unint64_t)(v47 - v46) < 0x20) {
        goto LABEL_43;
      }
      uint64_t v45 = v42 & 0xFFFFFFF8;
      float v49 = (_OWORD *)(v47 + 16);
      float v50 = (long long *)(v46 + 16);
      uint64_t v51 = v48 & 0xFFFFFFF8;
      do
      {
        long long v52 = *v50;
        *(v49 - 1) = *(v50 - 1);
        *float v49 = v52;
        v49 += 2;
        v50 += 2;
        v51 -= 8;
      }
      while (v51);
      if (v45 != v48)
      {
LABEL_43:
        uint64_t v53 = v48 - v45;
        uint64_t v54 = 4 * v45;
        uint64_t v55 = (_DWORD *)(v47 + v54);
        unsigned int v56 = (int *)(v46 + v54);
        do
        {
          int v57 = *v56++;
          *v55++ = v57;
          --v53;
        }
        while (v53);
      }
    }
    *(unsigned char *)(result + 120) = *(unsigned char *)(a2 + 120);
    uint64_t v58 = *(void *)(a2 + 124);
    *(_DWORD *)(result + 132) = *(_DWORD *)(a2 + 132);
    *(void *)(result + 124) = v58;
    int v59 = *(_DWORD *)(result + 152);
    int v60 = *(_DWORD *)(a2 + 152);
    if (v59 != v60)
    {
      uint64_t v61 = *(void *)(result + 144);
      if (v61)
      {
        MEMORY[0x21D46B220](v61, 0x1000C8052888210);
        int v60 = *(_DWORD *)(a2 + 152);
      }
      v3[38] = v60;
      operator new[]();
    }
    if (v59)
    {
      unint64_t v62 = 0;
      uint64_t v63 = *(void *)(a2 + 144);
      uint64_t v64 = *(void *)(result + 144);
      do
      {
        *(_DWORD *)(v64 + 4 * v62) = *(_DWORD *)(v63 + 4 * v62);
        ++v62;
      }
      while (v62 < *(unsigned int *)(result + 152));
    }
    *(void *)(result + 160) = *(void *)(a2 + 160);
    int v65 = *(_DWORD *)(result + 184);
    int v66 = *(_DWORD *)(a2 + 184);
    if (v65 != v66)
    {
      uint64_t v67 = *(void *)(result + 176);
      if (v67)
      {
        MEMORY[0x21D46B220](v67, 0x1000C8052888210);
        int v66 = *(_DWORD *)(a2 + 184);
      }
      v3[46] = v66;
      operator new[]();
    }
    if (v65)
    {
      unint64_t v68 = 0;
      uint64_t v69 = *(void *)(a2 + 176);
      uint64_t v70 = *(void *)(result + 176);
      do
      {
        *(_DWORD *)(v70 + 4 * v68) = *(_DWORD *)(v69 + 4 * v68);
        ++v68;
      }
      while (v68 < *(unsigned int *)(result + 184));
    }
  }
  *(unsigned char *)(result + 192) = *(unsigned char *)(a2 + 192);
  return result;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B720;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1C0;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NFastFixedDistribution<signed char,int,unsigned int,unsigned short>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B720;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1C0;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NArray<unsigned short const*>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<unsigned short const*>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x50C80EE9192B6);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 8 * *(unsigned int *)(result + 16);
    do
    {
      *(void *)(*(void *)(result + 8) + v8) = *(void *)(a2 + v8);
      v8 += 8;
    }
    while (v9 != v8);
  }
  return result;
}

uint64_t NArray<unsigned short const*>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x50C80EE9192B6);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * *(unsigned int *)(result + 16);
      do
      {
        *(void *)(*(void *)(result + 8) + v7) = *(void *)(*(void *)(a2 + 8) + v7);
        v7 += 8;
      }
      while (v8 != v7);
    }
  }
  return result;
}

void NArray<unsigned short const*>::~NArray(void *a1)
{
  *a1 = &unk_26C99C1F8;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x50C80EE9192B6);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<unsigned short const*>::~NArray(void *a1)
{
  *a1 = &unk_26C99C1F8;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  return a1;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::baseGMM(uint64_t a1, const char *a2)
{
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 280) + 8 * *a2) + 2);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(_WORD **)(*(void *)(result + 280) + 8 * *a2);
  uint64_t v4 = (unsigned __int16)*v3;
  if (*v3)
  {
    int v5 = v3 + 1;
    uint64_t v6 = *(void *)(a3 + 8);
    if (v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      int v12 = v4 - v7;
      do
      {
        unsigned int v13 = *v5;
        v5 += 2;
        *(unsigned char *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    uint64_t v7 = (unsigned __int16)v4 & 0xFFFE;
    v5 += 2 * v7;
    uint64_t v8 = v3 + 3;
    uint64_t v9 = v7;
    do
    {
      uint64_t v10 = *(v8 - 2);
      unsigned int v11 = *v8;
      v8 += 4;
      *(unsigned char *)(v6 + v10) = 1;
      *(unsigned char *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4) {
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::componentScore(uint64_t a1)
{
}

void sub_2184D1E0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

float NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  int v5 = *(_WORD **)(*(void *)(a1 + 280) + 8 * *a2);
  int v6 = (unsigned __int16)*v5;
  if (*v5)
  {
    uint64_t v9 = v5 + 2;
    uint64_t v10 = 3221225473;
    do
    {
      uint64_t v12 = *(v9 - 1);
      if (*(unsigned char *)(*(void *)(a3 + 8) + v12))
      {
        int v13 = (uint64_t)rintf(*(float *)(*(void *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v13;
        }
        if (v13 >= (int)v10) {
          int v13 = v10;
        }
        if (v13 != -1073741823)
        {
          int v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500)) {
            uint64_t v11 = (*(_DWORD *)(*(void *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
          }
                               + v11);
        }
      }
      else
      {
        uint64_t v11 = v10;
      }
      v9 += 2;
      uint64_t v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::score(uint64_t a1)
{
}

void sub_2184D2290(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::read()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  *(void *)__str = &unk_26C99C5B0;
  LODWORD(v1) = 1;
  operator new[]();
}

void sub_2184D3BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  if (a43) {
    MEMORY[0x21D46B220](a43, 0x1000C8077774924);
  }
  a44 = &unk_26C99C460;
  if (a45) {
    MEMORY[0x21D46B220](a45, 0x1000C80BDFB0063);
  }
  if (!a26) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(uint64_t))(*(void *)a26 + 8))(a26);
  _Unwind_Resume(a1);
}

uint64_t NArray<unsigned short>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<unsigned short>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C80BDFB0063);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = *(void *)(result + 8);
    uint64_t v9 = v4;
    if (v4 < 0x10 || (unint64_t)(v8 - a2) <= 0x1F)
    {
      uint64_t v11 = 0;
LABEL_14:
      uint64_t v16 = v9 - v11;
      uint64_t v17 = 2 * v11;
      int v18 = (_WORD *)(v8 + v17);
      uint64_t v19 = (__int16 *)(a2 + v17);
      do
      {
        __int16 v20 = *v19++;
        *v18++ = v20;
        --v16;
      }
      while (v16);
      return result;
    }
    uint64_t v11 = v4 & 0xFFFFFFF0;
    uint64_t v12 = (_OWORD *)(v8 + 16);
    int v13 = (long long *)(a2 + 16);
    uint64_t v14 = v9 & 0xFFFFFFF0;
    do
    {
      long long v15 = *v13;
      *(v12 - 1) = *(v13 - 1);
      _OWORD *v12 = v15;
      v12 += 2;
      v13 += 2;
      v14 -= 16;
    }
    while (v14);
    if (v11 != v9) {
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t NArray<unsigned short>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C80BDFB0063);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      uint64_t v10 = v4;
      if (v4 < 0x10) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFF0;
      uint64_t v11 = (_OWORD *)(v9 + 16);
      uint64_t v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFF0;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *uint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 16;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 2 * v7;
        uint64_t v17 = (_WORD *)(v9 + v16);
        int v18 = (__int16 *)(v8 + v16);
        do
        {
          __int16 v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  return result;
}

void NArray<unsigned short>::~NArray(void *a1)
{
  *a1 = &unk_26C99C460;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C80BDFB0063);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<unsigned short>::~NArray(void *a1)
{
  *a1 = &unk_26C99C460;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C80BDFB0063);
  }
  return a1;
}

uint64_t NAutoArray<unsigned short>::resize(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  unsigned int v5 = *a2;
  if (*a2 <= a3) {
    unsigned int v6 = a3;
  }
  else {
    unsigned int v6 = *a2;
  }
  if (v6) {
    operator new[]();
  }
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (v5 < v7)
  {
    *(_DWORD *)(a1 + 16) = v5;
    unsigned int v7 = v5;
  }
  uint64_t result = *(void *)(a1 + 8);
  if (v7)
  {
    uint64_t v9 = 0;
    uint64_t v10 = v7;
    if (v7 < 0x10) {
      goto LABEL_14;
    }
    if ((unint64_t)-result < 0x20) {
      goto LABEL_14;
    }
    uint64_t v9 = v7 & 0xFFFFFFF0;
    uint64_t v11 = 16;
    uint64_t v12 = (long long *)(result + 16);
    uint64_t v13 = v10 & 0xFFFFFFF0;
    do
    {
      long long v14 = *v12;
      *(_OWORD *)(v11 - 16) = *(v12 - 1);
      *(_OWORD *)uint64_t v11 = v14;
      v11 += 32;
      v12 += 2;
      v13 -= 16;
    }
    while (v13);
    if (v9 != v10)
    {
LABEL_14:
      uint64_t v15 = v10 - v9;
      uint64_t v16 = (_WORD *)(2 * v9);
      uint64_t v17 = (_WORD *)((char *)v16 + result);
      do
      {
        __int16 v18 = *v17++;
        *v16++ = v18;
        --v15;
      }
      while (v15);
    }
    goto LABEL_18;
  }
  if (result) {
LABEL_18:
  }
    uint64_t result = MEMORY[0x21D46B220]();
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *a2;
  *(_DWORD *)(a1 + 20) = 0;
  return result;
}

uint64_t NAutoArray<unsigned short>::operator=(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 16))();
}

uint64_t NAutoArray<unsigned short>::fromArray(uint64_t result, uint64_t a2, unsigned int *a3)
{
  uint64_t v3 = result;
  unsigned int v4 = *a3;
  if (*(_DWORD *)(result + 20) < *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C80BDFB0063);
      unsigned int v4 = *a3;
    }
    *(_DWORD *)(v3 + 20) = v4;
    operator new[]();
  }
  *(_DWORD *)(result + 16) = v4;
  if (v4)
  {
    uint64_t v7 = *(void *)(result + 8);
    uint64_t v8 = v4;
    if (v4 < 0x10 || (unint64_t)(v7 - a2) <= 0x1F)
    {
      uint64_t v10 = 0;
LABEL_14:
      uint64_t v15 = v8 - v10;
      uint64_t v16 = 2 * v10;
      uint64_t v17 = (_WORD *)(v7 + v16);
      __int16 v18 = (__int16 *)(a2 + v16);
      do
      {
        __int16 v19 = *v18++;
        *v17++ = v19;
        --v15;
      }
      while (v15);
      return result;
    }
    uint64_t v10 = v4 & 0xFFFFFFF0;
    uint64_t v11 = (_OWORD *)(v7 + 16);
    uint64_t v12 = (long long *)(a2 + 16);
    uint64_t v13 = v8 & 0xFFFFFFF0;
    do
    {
      long long v14 = *v12;
      *(v11 - 1) = *(v12 - 1);
      *uint64_t v11 = v14;
      v11 += 2;
      v12 += 2;
      v13 -= 16;
    }
    while (v13);
    if (v10 != v8) {
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t NAutoArray<unsigned short>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v6 = *(_DWORD *)(a2 + 16);
  uint64_t v4 = a2 + 16;
  uint64_t v5 = v6;
  unsigned int v7 = *(_DWORD *)(a1 + 20);
  BOOL v8 = v6 >= v7;
  if (v6 <= v7)
  {
    *(_DWORD *)(a1 + 16) = v5;
    if (!v8) {
      bzero((void *)(*(void *)(a1 + 8) + 2 * v5), 2 * (v7 + ~v5) + 2);
    }
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 48))(a1, v4, (float)(*(float *)(a1 + 24) * (float)v5));
    LODWORD(v5) = *(_DWORD *)(a1 + 16);
  }
  if (v5)
  {
    uint64_t v9 = 0;
    uint64_t v10 = *(void *)(a2 + 8);
    uint64_t v11 = *(void *)(a1 + 8);
    if (v5 < 0x10) {
      goto LABEL_11;
    }
    if ((unint64_t)(v11 - v10) < 0x20) {
      goto LABEL_11;
    }
    uint64_t v9 = v5 & 0xFFFFFFF0;
    uint64_t v12 = (_OWORD *)(v11 + 16);
    uint64_t v13 = (long long *)(v10 + 16);
    uint64_t v14 = v9;
    do
    {
      long long v15 = *v13;
      *(v12 - 1) = *(v13 - 1);
      _OWORD *v12 = v15;
      v12 += 2;
      v13 += 2;
      v14 -= 16;
    }
    while (v14);
    if (v9 != v5)
    {
LABEL_11:
      uint64_t v16 = v5 - v9;
      uint64_t v17 = 2 * v9;
      __int16 v18 = (_WORD *)(v11 + v17);
      __int16 v19 = (__int16 *)(v10 + v17);
      do
      {
        __int16 v20 = *v19++;
        *v18++ = v20;
        --v16;
      }
      while (v16);
    }
  }
  return a1;
}

void NAutoArray<unsigned short>::~NAutoArray(void *a1)
{
  *a1 = &unk_26C99C460;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C80BDFB0063);
  }

  JUMPOUT(0x21D46B240);
}

void *NAutoArray<unsigned short>::~NAutoArray(void *a1)
{
  *a1 = &unk_26C99C460;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C80BDFB0063);
  }
  return a1;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B890;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1F8;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NFastFixedDistribution<signed char,int,unsigned short,unsigned short>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B890;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1F8;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

void NFastFixedDistribution<short,int,unsigned int,unsigned char>::baseGMM(uint64_t a1, const char *a2)
{
}

void NFastFixedDistribution<short,int,unsigned int,unsigned char>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 280) + 8 * *a2) + 4);
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int **)(*(void *)(result + 280) + 8 * *a2);
  uint64_t v4 = *v3;
  if (v4)
  {
    uint64_t v5 = v3 + 1;
    uint64_t v6 = *(void *)(a3 + 8);
    if (v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      int v12 = v4 - v7;
      do
      {
        unsigned int v13 = *v5;
        v5 += 2;
        *(unsigned char *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    uint64_t v7 = v4 & 0xFFFFFFFE;
    v5 += 2 * v7;
    BOOL v8 = v3 + 3;
    uint64_t v9 = v7;
    do
    {
      uint64_t v10 = *(v8 - 2);
      unsigned int v11 = *v8;
      v8 += 4;
      *(unsigned char *)(v6 + v10) = 1;
      *(unsigned char *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4) {
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

void NFastFixedDistribution<short,int,unsigned int,unsigned char>::componentScore(uint64_t a1)
{
}

void sub_2184D4FBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

float NFastFixedDistribution<short,int,unsigned int,unsigned char>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(int **)(*(void *)(a1 + 280) + 8 * *a2);
  int v6 = *v5;
  if (*v5)
  {
    uint64_t v9 = v5 + 2;
    uint64_t v10 = 3221225473;
    do
    {
      uint64_t v12 = *(v9 - 1);
      if (*(unsigned char *)(*(void *)(a3 + 8) + v12))
      {
        int v13 = (uint64_t)rintf(*(float *)(*(void *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v13;
        }
        if (v13 >= (int)v10) {
          int v13 = v10;
        }
        if (v13 != -1073741823)
        {
          int v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500)) {
            uint64_t v11 = (*(_DWORD *)(*(void *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
          }
                               + v11);
        }
      }
      else
      {
        uint64_t v11 = v10;
      }
      v9 += 2;
      uint64_t v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

void NFastFixedDistribution<short,int,unsigned int,unsigned char>::score(uint64_t a1)
{
}

void sub_2184D55A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NFastFixedDistribution<short,int,unsigned int,unsigned char>::read()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  *(void *)__str = &unk_26C99C5B0;
  LODWORD(v1) = 1;
  operator new[]();
}

void sub_2184D6ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  if (a43) {
    MEMORY[0x21D46B220](a43, 0x1000C8077774924);
  }
  a44 = &unk_26C99C3F0;
  if (a45) {
    MEMORY[0x21D46B220](a45, 0x1000C8052888210);
  }
  if (!a26) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(uint64_t))(*(void *)a26 + 8))(a26);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedGaussians<short,int,unsigned char>::read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, unsigned char *a6)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  NGaussianFixedPointScales::operator=(a1 + 32, a4);
  int v13 = *a5;
  int v14 = 4 * *(_DWORD *)(a4 + 184) + 8;
  *(_DWORD *)(a1 + 232) = v14;
  *(_DWORD *)(a1 + 236) = v13;
  unsigned int v18 = *a5 * v14;
  if (!*a6) {
    operator new[]();
  }
  uint64_t v15 = *(void *)(a3 + 8);
  if (!v15) {
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(void *)v15 + 72))(v15, &v18, a1);
  *(void *)(a1 + 24) = *(void *)(a1 + 16);
  if (result != v18) {
    Error::chuck((Error *)"NFastFixedGaussians::read() - not enough gaussian data in file %s (%d out of %d bytes)", v17, *(void *)(a2 + 16), result, v18);
  }
  return result;
}

void sub_2184D8278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43)
{
  a41 = a16;
  if (!a43) {
    _Unwind_Resume(a1);
  }
  MEMORY[0x21D46B220](a43, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<short,int,unsigned int,unsigned char>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

void NFastFixedDistribution<short,int,unsigned int,unsigned char>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B948;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1C0;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NFastFixedDistribution<short,int,unsigned int,unsigned char>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B948;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1C0;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

void NFastFixedDistribution<short,int,unsigned short,unsigned char>::baseGMM(uint64_t a1, const char *a2)
{
}

void NFastFixedDistribution<short,int,unsigned short,unsigned char>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 280) + 8 * *a2) + 2);
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(_WORD **)(*(void *)(result + 280) + 8 * *a2);
  uint64_t v4 = (unsigned __int16)*v3;
  if (*v3)
  {
    uint64_t v5 = v3 + 1;
    uint64_t v6 = *(void *)(a3 + 8);
    if (v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      int v12 = v4 - v7;
      do
      {
        unsigned int v13 = *v5;
        v5 += 2;
        *(unsigned char *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    uint64_t v7 = (unsigned __int16)v4 & 0xFFFE;
    v5 += 2 * v7;
    BOOL v8 = v3 + 3;
    uint64_t v9 = v7;
    do
    {
      uint64_t v10 = *(v8 - 2);
      unsigned int v11 = *v8;
      v8 += 4;
      *(unsigned char *)(v6 + v10) = 1;
      *(unsigned char *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4) {
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

void NFastFixedDistribution<short,int,unsigned short,unsigned char>::componentScore(uint64_t a1)
{
}

void sub_2184D8CA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

float NFastFixedDistribution<short,int,unsigned short,unsigned char>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(_WORD **)(*(void *)(a1 + 280) + 8 * *a2);
  int v6 = (unsigned __int16)*v5;
  if (*v5)
  {
    uint64_t v9 = v5 + 2;
    uint64_t v10 = 3221225473;
    do
    {
      uint64_t v12 = *(v9 - 1);
      if (*(unsigned char *)(*(void *)(a3 + 8) + v12))
      {
        int v13 = (uint64_t)rintf(*(float *)(*(void *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v13;
        }
        if (v13 >= (int)v10) {
          int v13 = v10;
        }
        if (v13 != -1073741823)
        {
          int v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500)) {
            uint64_t v11 = (*(_DWORD *)(*(void *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
          }
                               + v11);
        }
      }
      else
      {
        uint64_t v11 = v10;
      }
      v9 += 2;
      uint64_t v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

void NFastFixedDistribution<short,int,unsigned short,unsigned char>::score(uint64_t a1)
{
}

void sub_2184D9288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NFastFixedDistribution<short,int,unsigned short,unsigned char>::read()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  *(void *)__str = &unk_26C99C5B0;
  LODWORD(v1) = 1;
  operator new[]();
}

void sub_2184DABD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  if (a43) {
    MEMORY[0x21D46B220](a43, 0x1000C8077774924);
  }
  a44 = &unk_26C99C460;
  if (a45) {
    MEMORY[0x21D46B220](a45, 0x1000C80BDFB0063);
  }
  if (!a26) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(uint64_t))(*(void *)a26 + 8))(a26);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<short,int,unsigned short,unsigned char>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

void NFastFixedDistribution<short,int,unsigned short,unsigned char>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99BA00;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1F8;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NFastFixedDistribution<short,int,unsigned short,unsigned char>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99BA00;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1F8;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::baseGMM(uint64_t a1, const char *a2)
{
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 280) + 8 * *a2) + 4);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int **)(*(void *)(result + 280) + 8 * *a2);
  uint64_t v4 = *v3;
  if (v4)
  {
    uint64_t v5 = v3 + 1;
    uint64_t v6 = *(void *)(a3 + 8);
    if (v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      int v12 = v4 - v7;
      do
      {
        unsigned int v13 = *v5;
        v5 += 2;
        *(unsigned char *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    uint64_t v7 = v4 & 0xFFFFFFFE;
    v5 += 2 * v7;
    BOOL v8 = v3 + 3;
    uint64_t v9 = v7;
    do
    {
      uint64_t v10 = *(v8 - 2);
      unsigned int v11 = *v8;
      v8 += 4;
      *(unsigned char *)(v6 + v10) = 1;
      *(unsigned char *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4) {
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::componentScore(uint64_t a1)
{
}

void sub_2184DB654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

float NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(int **)(*(void *)(a1 + 280) + 8 * *a2);
  int v6 = *v5;
  if (*v5)
  {
    uint64_t v9 = v5 + 2;
    uint64_t v10 = 3221225473;
    do
    {
      uint64_t v12 = *(v9 - 1);
      if (*(unsigned char *)(*(void *)(a3 + 8) + v12))
      {
        int v13 = (uint64_t)rintf(*(float *)(*(void *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v13;
        }
        if (v13 >= (int)v10) {
          int v13 = v10;
        }
        if (v13 != -1073741823)
        {
          int v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500)) {
            uint64_t v11 = (*(_DWORD *)(*(void *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
          }
                               + v11);
        }
      }
      else
      {
        uint64_t v11 = v10;
      }
      v9 += 2;
      uint64_t v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::score(uint64_t a1)
{
}

void sub_2184DBAD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::read()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  *(void *)__str = &unk_26C99C5B0;
  LODWORD(v1) = 1;
  operator new[]();
}

void sub_2184DD40C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  if (a43) {
    MEMORY[0x21D46B220](a43, 0x1000C8077774924);
  }
  a44 = &unk_26C99C3F0;
  if (a45) {
    MEMORY[0x21D46B220](a45, 0x1000C8052888210);
  }
  if (!a26) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(uint64_t))(*(void *)a26 + 8))(a26);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedGaussians<signed char,int,unsigned char>::read(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, unsigned char *a6)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  NGaussianFixedPointScales::operator=(a1 + 32, a4);
  int v13 = *a5;
  int v14 = 2 * *(_DWORD *)(a4 + 184) + ((-2 * *(_DWORD *)(a4 + 184)) & 2) + 8;
  *(_DWORD *)(a1 + 232) = v14;
  *(_DWORD *)(a1 + 236) = v13;
  unsigned int v18 = *a5 * v14;
  if (!*a6) {
    operator new[]();
  }
  uint64_t v15 = *(void *)(a3 + 8);
  if (!v15) {
    Error::chuck((Error *)"NSmartPointer::checkptr() - pointer unset", v12);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(*(void *)v15 + 72))(v15, &v18, a1);
  *(void *)(a1 + 24) = *(void *)(a1 + 16);
  if (result != v18) {
    Error::chuck((Error *)"NFastFixedGaussians::read() - not enough gaussian data in file %s (%d out of %d bytes)", v17, *(void *)(a2 + 16), result, v18);
  }
  return result;
}

void sub_2184DE7B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  a39 = a15;
  if (!a41) {
    _Unwind_Resume(a1);
  }
  MEMORY[0x21D46B220](a41, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

void NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B668;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1C0;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NFastFixedDistribution<signed char,int,unsigned int,unsigned char>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B668;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1C0;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  return a1;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::fixedPointScalesP(uint64_t a1)
{
  return a1 + 336;
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::baseGMM(uint64_t a1, const char *a2)
{
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::firstComponentId(uint64_t a1, unsigned int *a2)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 280) + 8 * *a2) + 2);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::setComponentMask(uint64_t result, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = *(_WORD **)(*(void *)(result + 280) + 8 * *a2);
  uint64_t v4 = (unsigned __int16)*v3;
  if (*v3)
  {
    uint64_t v5 = v3 + 1;
    uint64_t v6 = *(void *)(a3 + 8);
    if (v4 == 1)
    {
      LODWORD(v7) = 0;
LABEL_7:
      int v12 = v4 - v7;
      do
      {
        unsigned int v13 = *v5;
        v5 += 2;
        *(unsigned char *)(v6 + v13) = 1;
        --v12;
      }
      while (v12);
      return result;
    }
    uint64_t v7 = (unsigned __int16)v4 & 0xFFFE;
    v5 += 2 * v7;
    BOOL v8 = v3 + 3;
    uint64_t v9 = v7;
    do
    {
      uint64_t v10 = *(v8 - 2);
      unsigned int v11 = *v8;
      v8 += 4;
      *(unsigned char *)(v6 + v10) = 1;
      *(unsigned char *)(v6 + v11) = 1;
      v9 -= 2;
    }
    while (v9);
    if (v7 != v4) {
      goto LABEL_7;
    }
  }
  return result;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::numComponents(uint64_t a1)
{
  return a1 + 536;
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::componentScore(uint64_t a1)
{
}

void sub_2184DF084(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x21D46B220](a10, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

float NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::scoreUsingCache(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(_WORD **)(*(void *)(a1 + 280) + 8 * *a2);
  int v6 = (unsigned __int16)*v5;
  if (*v5)
  {
    uint64_t v9 = v5 + 2;
    uint64_t v10 = 3221225473;
    do
    {
      uint64_t v12 = *(v9 - 1);
      if (*(unsigned char *)(*(void *)(a3 + 8) + v12))
      {
        int v13 = (uint64_t)rintf(*(float *)(*(void *)(a4 + 8) + 4 * v12)* *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 40))- *v9;
        if (v13 <= (int)v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v13;
        }
        if (v13 >= (int)v10) {
          int v13 = v10;
        }
        if (v13 != -1073741823)
        {
          int v14 = v11 - v13;
          if (v14 <= *(_DWORD *)(a1 + 500)) {
            uint64_t v11 = (*(_DWORD *)(*(void *)(a1 + 480) + 4 * (v14 >> *(_DWORD *)(a1 + 496)))
          }
                               + v11);
        }
      }
      else
      {
        uint64_t v11 = v10;
      }
      v9 += 2;
      uint64_t v10 = v11;
      --v6;
    }
    while (v6);
  }
  else
  {
    LODWORD(v11) = -1073741823;
  }
  return *(float *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 136))(a1) + 44) * (float)(int)v11;
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::score(uint64_t a1)
{
}

void sub_2184DF508(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::read()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  *(void *)__str = &unk_26C99C5B0;
  LODWORD(v1) = 1;
  operator new[]();
}

void sub_2184E0E54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45)
{
  if (a43) {
    MEMORY[0x21D46B220](a43, 0x1000C8077774924);
  }
  a44 = &unk_26C99C460;
  if (a45) {
    MEMORY[0x21D46B220](a45, 0x1000C80BDFB0063);
  }
  if (!a26) {
    _Unwind_Resume(a1);
  }
  (*(void (**)(uint64_t))(*(void *)a26 + 8))(a26);
  _Unwind_Resume(a1);
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::dimen(uint64_t a1)
{
  return a1 + 296;
}

uint64_t NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::size(uint64_t a1)
{
  return *(unsigned int *)(a1 + 540);
}

void NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B7D8;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1F8;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

void *NFastFixedDistribution<signed char,int,unsigned short,unsigned char>::~NFastFixedDistribution(void *a1)
{
  *a1 = &unk_26C99B7D8;
  NChunkGaussianMixtureModelsHeader::~NChunkGaussianMixtureModelsHeader((NChunkGaussianMixtureModelsHeader *)(a1 + 37));
  a1[34] = &unk_26C99C1F8;
  uint64_t v2 = a1[35];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x50C80EE9192B6);
  }
  a1[31] = &unk_26C99C5B0;
  uint64_t v3 = a1[33];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  a1[5] = &unk_26C99BC98;
  a1[26] = &unk_26C99C3B8;
  uint64_t v4 = a1[27];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  a1[22] = &unk_26C99C3B8;
  uint64_t v5 = a1[23];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NFixedPointScales::~NFixedPointScales((NFixedPointScales *)(a1 + 5));
  a1[1] = &unk_26C99C5B0;
  uint64_t v6 = a1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  return a1;
}

void read_gaussian_models(const NString *a1, const NString *a2)
{
  v2[0] = &unk_26C99B258;
  v2[1] = 0;
  NDistributionLoader::read((NDistributionLoader *)v2, a1, a2);
}

void sub_2184E1620(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_2184E2354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2184E2D28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3216(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3217(uint64_t a1)
{
}

id getCSUtilsClass()
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2050000000;
  v0 = (void *)getCSUtilsClass_softClass_3222;
  uint64_t v6 = getCSUtilsClass_softClass_3222;
  if (!getCSUtilsClass_softClass_3222)
  {
    if (!CoreSpeechFoundationLibraryCore_frameworkLibrary_3224)
    {
      uint64_t v7 = MEMORY[0x263EF8330];
      uint64_t v8 = 3221225472;
      uint64_t v9 = __CoreSpeechFoundationLibraryCore_block_invoke_3225;
      uint64_t v10 = &__block_descriptor_40_e5_v8__0l;
      uint64_t v11 = 0;
      long long v12 = xmmword_264325748;
      uint64_t v13 = 0;
      CoreSpeechFoundationLibraryCore_frameworkLibrary_3224 = _sl_dlopen();
    }
    v4[3] = (uint64_t)objc_getClass("CSUtils");
    getCSUtilsClass_softClass_3222 = v4[3];
    v0 = (void *)v4[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v3, 8);

  return v1;
}

void sub_2184E3168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getCSUtilsClass_block_invoke_3223(uint64_t a1)
{
  if (!CoreSpeechFoundationLibraryCore_frameworkLibrary_3224) {
    CoreSpeechFoundationLibraryCore_frameworkLibrary_3224 = _sl_dlopen();
  }
  Class result = objc_getClass("CSUtils");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getCSUtilsClass_softClass_3222 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __CoreSpeechFoundationLibraryCore_block_invoke_3225()
{
  uint64_t result = _sl_dlopen();
  CoreSpeechFoundationLibraryCore_frameworkLibrary_3224 = result;
  return result;
}

uint64_t VTInternalPreferencesSynchronize()
{
  return CFPreferencesAppSynchronize(@"com.apple.voicetrigger");
}

void _VTPreferencesSetValueForKey(CFPropertyListRef value, CFStringRef key)
{
}

uint64_t _VTNotBackedupPreferencesSynchronize()
{
  return CFPreferencesAppSynchronize(@"com.apple.voicetrigger.notbackedup");
}

void _VTNotBackedupPreferencesSetValueForKey(CFPropertyListRef value, CFStringRef key)
{
}

void _VTReloadVoiceTrigger()
{
  CFPreferencesAppSynchronize(@"com.apple.voicetrigger");
  dispatch_time_t v0 = dispatch_time(0, 50000000);
  id v1 = MEMORY[0x263EF83A0];

  dispatch_after(v0, v1, &__block_literal_global_99);
}

id _VTPreferencesValueForKey(const __CFString *a1)
{
  id v1 = (void *)CFPreferencesCopyAppValue(a1, @"com.apple.voicetrigger");

  return v1;
}

id _VTNotBackedupPreferencesValueForKey(const __CFString *a1)
{
  id v1 = (void *)CFPreferencesCopyAppValue(a1, @"com.apple.voicetrigger.notbackedup");

  return v1;
}

void NZFile::open(NZFile *this, const NString *a2, const NString *a3, const unsigned int *a4)
{
  (*(void (**)(NZFile *))(*(void *)this + 24))(this);
  uint64_t v9 = (unsigned char *)*((void *)a3 + 2);
  if (*((_DWORD *)a3 + 2) == 1)
  {
    if (*v9 == 114)
    {
      int v10 = 0;
      goto LABEL_6;
    }
    uint64_t v9 = (unsigned char *)*((void *)a3 + 2);
    if (*v9 == 119)
    {
      int v10 = 1;
LABEL_6:
      *((_DWORD *)this + 12) = v10;
      *((void *)this + 5) = 0;
      if (!*a4) {
        Error::chuck((Error *)"NZFile::open() - Can't open gz compressed file '%s' because compiled without zlib", v8, *((void *)a2 + 2));
      }
      Error::chuck((Error *)"NZFile::open() - offset open not supported", v8);
    }
  }
  Error::chuck((Error *)"NZFile::open() - unrecognized file mode %s", v8, v9);
}

void NZFile::getPosition(NZFile *this, const char *a2)
{
}

void NZFile::setPosition(NZFile *this, const char *a2)
{
}

void NZFile::write(NZFile *this, const NString *a2)
{
  if ((*(uint64_t (**)(NZFile *, const NString *))(*(void *)this + 32))(this, a2))
  {
    if (*((_DWORD *)this + 12) == 1) {
      Error::chuck((Error *)"NZFile::write() - Not available because compiled without zlib", v3);
    }
    Error::chuck((Error *)"NZFile::write() - file %s not opened in write mode", v3, *((void *)this + 3));
  }
  Error::chuck((Error *)"NZFile::write() - file %s is not open", v3, *((void *)this + 3));
}

void NZFile::readString(NZFile *this)
{
  if ((*(uint64_t (**)(NZFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 12)) {
      Error::chuck((Error *)"NZFile::readString() - Not available because compiled without zlib", v2);
    }
    Error::chuck((Error *)"NZFile::readString() - file %s not opened in read mode", v2, *((void *)this + 3));
  }
  Error::chuck((Error *)"NZFile::readString() - file %s is not open", v2, *((void *)this + 3));
}

void NZFile::readLine(NZFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  if ((*(uint64_t (**)(NZFile *, const char *))(*(void *)this + 32))(this, a2))
  {
    if (!*((_DWORD *)this + 12))
    {
      *(void *)a3 = &unk_26C99C5B0;
      *(_DWORD *)(a3 + 8) = 0;
      operator new[]();
    }
    Error::chuck((Error *)"NZFile::readLine() - file %s not opened in read mode", v5, *((void *)this + 3));
  }
  Error::chuck((Error *)"NZFile::readLine() - file %s is not open", v5, *((void *)this + 3));
}

void sub_2184E6554(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  void *v12 = v13;
  uint64_t v15 = v12[2];
  if (v15) {
    MEMORY[0x21D46B220](v15, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NZFile::read(NZFile *this, const unsigned int *a2, NString *a3)
{
  if ((*(uint64_t (**)(NZFile *, const unsigned int *, NString *))(*(void *)this + 32))(this, a2, a3))
  {
    if (!*((_DWORD *)this + 12))
    {
      if (*a2 == -1) {
        Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v5, *((void *)this + 3));
      }
      Error::chuck((Error *)"NZFile::read() - Not available because compiled without zlib", v5);
    }
    Error::chuck((Error *)"NZFile::read() - file %s not opened in read mode", v5, *((void *)this + 3));
  }
  Error::chuck((Error *)"NZFile::read() - file %s is not open", v5, *((void *)this + 3));
}

void NZFile::read(NZFile *this, const unsigned int *a2)
{
  if ((*(uint64_t (**)(NZFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 12))
    {
      if (*a2 == -1) {
        Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v4, *((void *)this + 3));
      }
      operator new[]();
    }
    Error::chuck((Error *)"NZFile::read() - file %s not opened in read mode", v4, *((void *)this + 3));
  }
  Error::chuck((Error *)"NZFile::read() - file %s is not open", v4, *((void *)this + 3));
}

void sub_2184E6734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NZFile::read(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 0;
  operator new[]();
}

void sub_2184E68C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  *uint64_t v11 = v12;
  uint64_t v14 = v11[2];
  if (v14) {
    MEMORY[0x21D46B220](v14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NZFile::good(NZFile *this)
{
  if ((*(uint64_t (**)(NZFile *))(*(void *)this + 40))(this)) {
    return 0;
  }
  uint64_t v3 = *(uint64_t (**)(NZFile *))(*(void *)this + 32);

  return v3(this);
}

void NZFile::eof(NZFile *this, const char *a2)
{
}

uint64_t NZFile::isOpen(NZFile *this)
{
  return *((unsigned __int8 *)this + 52);
}

uint64_t NZFile::close(NZFile *this, const char *a2)
{
  if (*((unsigned char *)this + 52)) {
    Error::chuck((Error *)"NZFile::close() - Not available because compiled without zlib", a2);
  }
  int v4 = 0;
  uint64_t v2 = (char *)this + 8;
  uint64_t result = (*(uint64_t (**)(char *, const char *, int *))(*((void *)this + 1) + 64))((char *)this + 8, "", &v4);
  v2[44] = 0;
  return result;
}

uint64_t NZFile::open(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)a1 + 128))(a1, a2, a3, &v4);
}

void NZFile::~NZFile(NZFile *this, const char *a2)
{
  *(void *)this = &unk_26C99C518;
  if (!*((unsigned char *)this + 52))
  {
    uint64_t v3 = *((void *)this + 1);
    int v5 = 0;
    (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 8, "", &v5);
    *((unsigned char *)this + 52) = 0;
    *(void *)this = &unk_26C99C718;
    *((void *)this + 1) = &unk_26C99C5B0;
    uint64_t v4 = *((void *)this + 3);
    if (v4) {
      MEMORY[0x21D46B220](v4, 0x1000C8077774924);
    }
    JUMPOUT(0x21D46B240);
  }
  Error::chuck((Error *)"NZFile::close() - Not available because compiled without zlib", a2);
}

{
  uint64_t v3;
  uint64_t v4;
  int v5;

  *(void *)this = &unk_26C99C518;
  if (*((unsigned char *)this + 52)) {
    Error::chuck((Error *)"NZFile::close() - Not available because compiled without zlib", a2);
  }
  uint64_t v3 = *((void *)this + 1);
  int v5 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 8, "", &v5);
  *((unsigned char *)this + 52) = 0;
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 3);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
}

{
  uint64_t v3;
  uint64_t v4;
  int v5;

  *(void *)this = &unk_26C99C518;
  if (*((unsigned char *)this + 52)) {
    Error::chuck((Error *)"NZFile::close() - Not available because compiled without zlib", a2);
  }
  uint64_t v3 = *((void *)this + 1);
  int v5 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 8, "", &v5);
  *((unsigned char *)this + 52) = 0;
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 3);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
}

void NZFile::NZFile(NZFile *this)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void NZFile::NZFile(NZFile *this, const NString *a2, const NString *a3, const unsigned int *a4)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void sub_2184E6ED8(_Unwind_Exception *exception_object)
{
  *id v1 = v2;
  v1[1] = v3;
  uint64_t v5 = v1[3];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_2184E6FD4(_Unwind_Exception *exception_object)
{
  *id v1 = v2;
  v1[1] = v3;
  uint64_t v5 = v1[3];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NZipFile::~NZipFile(NZipFile *this)
{
  *(void *)this = &unk_26C99C6F8;
  uint64_t v2 = (NZipFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((void *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      uint64_t v3 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    int v5 = 0;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "", &v5);
  }
  int v6 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 80) + 64))((char *)this + 640, "", &v6);
  *((_DWORD *)this + 167) = 0;
  *((unsigned char *)this + 688) = 0;
  *((void *)this + 80) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 82);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  NFile::~NFile(v2);

  JUMPOUT(0x21D46B240);
}

{
  NFile *v2;
  std::ios_base *v3;
  uint64_t v4;
  int v5;
  int v6;

  *(void *)this = &unk_26C99C6F8;
  uint64_t v2 = (NZipFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((void *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      uint64_t v3 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    int v5 = 0;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "", &v5);
  }
  int v6 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 80) + 64))((char *)this + 640, "", &v6);
  *((_DWORD *)this + 167) = 0;
  *((unsigned char *)this + 688) = 0;
  *((void *)this + 80) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 82);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  NFile::~NFile(v2);
}

{
  NFile *v2;
  std::ios_base *v3;
  uint64_t v4;
  int v5;
  int v6;

  *(void *)this = &unk_26C99C6F8;
  uint64_t v2 = (NZipFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((void *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      uint64_t v3 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    int v5 = 0;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "", &v5);
  }
  int v6 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 80) + 64))((char *)this + 640, "", &v6);
  *((_DWORD *)this + 167) = 0;
  *((unsigned char *)this + 688) = 0;
  *((void *)this + 80) = &unk_26C99C5B0;
  uint64_t v4 = *((void *)this + 82);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  NFile::~NFile(v2);
}

void NZipFile::NZipFile(NZipFile *this)
{
  *(void *)this = &unk_26C99C6F8;
  NFile::NFile((NZipFile *)((char *)this + 8));
}

{
  *(void *)this = &unk_26C99C6F8;
  NFile::NFile((NZipFile *)((char *)this + 8));
}

void sub_2184E7960(_Unwind_Exception *a1)
{
  NFile::~NFile(v1);
  _Unwind_Resume(a1);
}

void sub_2184E7A18(_Unwind_Exception *a1)
{
  NFile::~NFile(v1);
  _Unwind_Resume(a1);
}

void NZipFile::NZipFile(NZipFile *this, const NString *a2)
{
  *(void *)this = &unk_26C99C6F8;
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 1;
  operator new[]();
}

void sub_2184E7C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  *(void *)(v13 + 640) = v14;
  uint64_t v16 = *(void *)(v13 + 656);
  if (v16) {
    MEMORY[0x21D46B220](v16, 0x1000C8077774924);
  }
  NFile::~NFile(v12);
  _Unwind_Resume(a1);
}

void NZipFile::open(NZipFile *this, const NString *a2)
{
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 1;
  operator new[]();
}

void sub_2184E7DDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NZipFile::close(NZipFile *this)
{
  if ((*(unsigned int (**)(void))(*((void *)this + 1) + 32))())
  {
    if (!std::filebuf::close())
    {
      uint64_t v2 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 6) - 24) + 48);
      std::ios_base::clear(v2, v2->__rdstate_ | 4);
    }
    int v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "", &v4);
  }
  int v5 = 0;
  uint64_t result = (*(uint64_t (**)(char *, const char *, int *))(*((void *)this + 80) + 64))((char *)this + 640, "", &v5);
  *((_DWORD *)this + 167) = 0;
  *((unsigned char *)this + 688) = 0;
  return result;
}

void NZipFile::start(NZipFile *this)
{
  *((void *)this + 83) = 0;
  *((unsigned char *)this + 688) = 0;
  uint64_t v2 = (NZipFile *)((char *)this + 8);
  v4[0] = -1;
  NFile::setPosition((NZipFile *)((char *)this + 8), v4);
  if (NFile::getPosition(v2) > 0x15)
  {
    *(void *)int v4 = &unk_26C99C5B0;
    int v5 = 0;
    operator new[]();
  }
  Error::chuck((Error *)"NZipFile::start() - Problem reading \"%s\": %s", v3, *((void *)this + 4), "file not large enough to be a zipfile");
}

void sub_2184E83BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22)
{
  if (a22) {
    MEMORY[0x21D46B220](a22, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NZipFile::nextHeader(uint64_t this)
{
  *(unsigned char *)(this + 688) = 0;
  if (*(_DWORD *)(this + 668) < *(_DWORD *)(this + 664))
  {
    v1[0] = 46;
    NFile::read((NFile *)(this + 8), v1);
  }
  return this;
}

void sub_2184E86CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17) {
    MEMORY[0x21D46B220](a17, 0x1000C8077774924);
  }
  *(void *)(v17 - 56) = &unk_26C99C5B0;
  uint64_t v19 = *(void *)(v17 - 40);
  if (v19) {
    MEMORY[0x21D46B220](v19, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NZipFile::valid(NZipFile *this)
{
  return *((unsigned __int8 *)this + 688);
}

uint64_t NZipFile::operator++(uint64_t this)
{
  if (*(unsigned char *)(this + 688)) {
    return NZipFile::nextHeader(this);
  }
  return this;
}

uint64_t NZipFile::operator*(uint64_t a1)
{
  return a1 + 640;
}

void NZipFile::getCurrentSubFile(NZipFile *this, NFilePtr *a2)
{
  if (*((unsigned char *)this + 688))
  {
    uint64_t v3 = *((unsigned int *)this + 168);
    if (!v3)
    {
      v4[8] = NFile::getPosition((NZipFile *)((char *)this + 8));
      NFile::setPosition((NZipFile *)((char *)this + 8), (const unsigned int *)this + 170);
      v4[0] = 30;
      NFile::read((NZipFile *)((char *)this + 8), v4);
    }
    Error::chuck((Error *)"NZipFile::getCurrentSubFile() - compression method %d not currently supported in subfile %s in zipfile %s", (const char *)a2, v3, *((void *)this + 82), *((void *)this + 4));
  }
  Error::chuck((Error *)"NZipFile::getCurrentSubFile() - reading iterator in invalid state", (const char *)a2);
}

void sub_2184E8A54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a15) {
    MEMORY[0x21D46B220](a15, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NFilePtr::openOffsetZFile(NFilePtr *this, const NString *a2, const unsigned int *a3)
{
}

void sub_2184E8BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  void *v12 = v13;
  v12[1] = v14;
  uint64_t v16 = v12[3];
  if (v16) {
    MEMORY[0x21D46B220](v16, 0x1000C8077774924);
  }
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  MEMORY[0x21D46B240](v12, 0x1091C40807AD00ALL);
  _Unwind_Resume(a1);
}

void NFilePtr::openOffsetFile(NFilePtr *this, const NString *a2, const unsigned int *a3, const unsigned int *a4)
{
}

void sub_2184E8D84(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12)
  {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void NZipFile::getSubFile(NZipFile *this, const NString *a2, NFilePtr *a3)
{
}

void NFidFile::~NFidFile(NFidFile *this)
{
  *(void *)this = &unk_26C99C6B0;
  *((unsigned char *)this + 648) = 0;
  uint64_t v2 = (NFidFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((void *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      uint64_t v3 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    int v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "", &v4);
  }
  NFile::~NFile(v2);

  JUMPOUT(0x21D46B240);
}

{
  NFile *v2;
  std::ios_base *v3;
  int v4;

  *(void *)this = &unk_26C99C6B0;
  *((unsigned char *)this + 648) = 0;
  uint64_t v2 = (NFidFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((void *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      uint64_t v3 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    int v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "", &v4);
  }
  NFile::~NFile(v2);
}

{
  NFile *v2;
  std::ios_base *v3;
  int v4;

  *(void *)this = &unk_26C99C6B0;
  *((unsigned char *)this + 648) = 0;
  uint64_t v2 = (NFidFile *)((char *)this + 8);
  if ((*(unsigned int (**)(char *))(*((void *)this + 1) + 32))((char *)this + 8))
  {
    if (!std::filebuf::close())
    {
      uint64_t v3 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 6) - 24) + 48);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    int v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "", &v4);
  }
  NFile::~NFile(v2);
}

void NFidFile::NFidFile(NFidFile *this)
{
  *(void *)this = &unk_26C99C6B0;
  NFile::NFile((NFidFile *)((char *)this + 8));
}

{
  *(void *)this = &unk_26C99C6B0;
  NFile::NFile((NFidFile *)((char *)this + 8));
}

void NFidFile::NFidFile(NFidFile *this, const NString *a2)
{
  *(void *)this = &unk_26C99C6B0;
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 1;
  operator new[]();
}

void sub_2184E92BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  NFile::~NFile(v12);
  _Unwind_Resume(a1);
}

void NFidFile::readHeader(NFidFile *this)
{
  id v1 = &unk_26C99C3F0;
  operator new[]();
}

void sub_2184E9500(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void NFidFile::open(NFidFile *this, const NString *a2)
{
  *((unsigned char *)this + 648) = 0;
  uint64_t v2 = &unk_26C99C5B0;
  int v3 = 1;
  operator new[]();
}

void sub_2184E9648(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NFidFile::close(NFidFile *this)
{
  uint64_t v2 = *((void *)this + 1);
  *((unsigned char *)this + 648) = 0;
  uint64_t result = (*(uint64_t (**)(void))(v2 + 32))();
  if (result)
  {
    if (!std::filebuf::close())
    {
      int v4 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 6) - 24) + 48);
      std::ios_base::clear(v4, v4->__rdstate_ | 4);
    }
    int v5 = 0;
    return (*(uint64_t (**)(char *, const char *, int *))(*((void *)this + 2) + 64))((char *)this + 16, "", &v5);
  }
  return result;
}

void NFidFile::getSubFile(NFidFile *this, const NString *a2, NFilePtr *a3)
{
  if (*((unsigned char *)this + 648))
  {
    uint64_t v5 = *((unsigned int *)a2 + 2);
    if (v5)
    {
      unsigned int v6 = 0;
      uint64_t v7 = (char *)*((void *)a2 + 2);
      do
      {
        int v8 = *v7++;
        unsigned int v6 = v8 + 65599 * v6;
        --v5;
      }
      while (v5);
    }
    else
    {
      unsigned int v6 = 0;
    }
    v13[0] = *((_DWORD *)this + 161) + 4 * (v6 % *((_DWORD *)this + 160));
    if (NFile::setPosition((NFidFile *)((char *)this + 8), v13))
    {
      v12[0] = 4;
      NFile::read((NFidFile *)((char *)this + 8), v12);
    }
    uint64_t v9 = *((void *)a2 + 2);
    uint64_t v10 = *((void *)this + 4);
    uint64_t v11 = "could not reach hashblock slot";
  }
  else
  {
    uint64_t v9 = *((void *)a2 + 2);
    uint64_t v10 = *((void *)this + 4);
    uint64_t v11 = "fidfile is not open and ready";
  }
  Error::chuck((Error *)"NFidFile::getSubFile() - Problem reading subfile \"%s\" from \"%s\": %s", (const char *)a2, a3, v9, v10, v11);
}

void sub_2184E9C78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (a24) {
    MEMORY[0x21D46B220](a24, 0x1000C8052888210);
  }
  _Unwind_Resume(exception_object);
}

void *NAutoString::appendTo(NAutoString *this, const void *__src, const unsigned int *a3)
{
  if (!__src) {
    Error::chuck((Error *)"NAutoString::appendTo() - Null pointer passed to assign", 0, a3);
  }
  uint64_t v6 = *((unsigned int *)this + 2);
  size_t v7 = *a3;
  unsigned int v8 = v7 + v6;
  if ((v7 + v6) >= *((_DWORD *)this + 6))
  {
    unsigned int v11 = *((_DWORD *)this + 7) + v8;
    uint64_t v10 = (char *)(**(uint64_t (***)(NAutoString *, int *))this)(this, (int *)&v11);
    memcpy(v10, *((const void **)this + 2), *((unsigned int *)this + 2));
    memcpy(&v10[*((unsigned int *)this + 2)], __src, *a3);
    v10[v8] = 0;
    uint64_t result = (void *)(*(uint64_t (**)(NAutoString *, void))(*(void *)this + 8))(this, *((void *)this + 2));
    *((void *)this + 2) = v10;
    *((_DWORD *)this + 6) = v11;
  }
  else
  {
    uint64_t result = memcpy((void *)(*((void *)this + 2) + v6), __src, v7);
    *(unsigned char *)(*((void *)this + 2) + v8) = 0;
  }
  *((_DWORD *)this + 2) = v8;
  return result;
}

void *NAutoString::assignTo(NAutoString *this, const void *__src, const unsigned int *a3)
{
  if (!__src) {
    Error::chuck((Error *)"NAutoString::assignTo() - Null pointer passed to assign", 0, a3);
  }
  size_t v5 = *a3;
  if (v5 >= *((_DWORD *)this + 6))
  {
    int v8 = *((_DWORD *)this + 7) + v5;
    size_t v7 = (void *)(**(uint64_t (***)(NAutoString *, int *))this)(this, &v8);
    memcpy(v7, __src, v5);
    *((unsigned char *)v7 + v5) = 0;
    uint64_t result = (void *)(*(uint64_t (**)(NAutoString *, void))(*(void *)this + 8))(this, *((void *)this + 2));
    *((void *)this + 2) = v7;
    *((_DWORD *)this + 6) = v8;
  }
  else
  {
    uint64_t result = memcpy(*((void **)this + 2), __src, *a3);
    *(unsigned char *)(*((void *)this + 2) + v5) = 0;
  }
  *((_DWORD *)this + 2) = v5;
  return result;
}

uint64_t NAutoString::operator+=(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3)
  {
    uint64_t v4 = *(void *)(a2 + 16);
    int v6 = v3;
    (*(void (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 72))(a1, v4, &v6);
  }
  return a1;
}

uint64_t NAutoString::operator=(uint64_t a1, char *__s)
{
  int v5 = strlen(__s);
  (*(void (**)(uint64_t, char *, int *))(*(void *)a1 + 64))(a1, __s, &v5);
  return a1;
}

uint64_t NAutoString::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = *(void *)(a2 + 16);
    int v5 = *(_DWORD *)(a2 + 8);
    (*(void (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 64))(a1, v3, &v5);
  }
  return a1;
}

void NAutoString::~NAutoString(NAutoString *this)
{
  *(void *)this = &unk_26C99C5B0;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99C5B0;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99C5B0;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }
}

void NAutoString::NAutoString(NAutoString *this)
{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = 0;
  operator new[]();
}

void NAutoString::NAutoString(NAutoString *this, const unsigned int *a2, const unsigned int *a3)
{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = 0;
  operator new[]();
}

void sub_2184EA6CC(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[2];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_2184EA7FC(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[2];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NAutoString::NAutoString(NAutoString *this, const NAutoString *a2)
{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  operator new[]();
}

{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  operator new[]();
}

void NAutoString::NAutoString(NAutoString *this, const NString *a2)
{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  operator new[]();
}

{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  operator new[]();
}

void sub_2184EAD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3585(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3586(uint64_t a1)
{
}

void sub_2184EAF5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2184EB5FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_2184EB67C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
}

void sub_2184EB9AC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v4 - 104));
  _Unwind_Resume(a1);
}

uint64_t AccelStaticMFCC::init(AccelStaticMFCC *this, const char *a2, unsigned int *a3, const unsigned int *a4, const BOOL *a5, float *a6, const BOOL *a7, const BOOL *a8, double a9, const BOOL *a10, const unsigned int *a11, const float *a12, const float *a13, const unsigned int *a14, const unsigned int *a15, const float *a16, const float *a17, const float *a18, const float *a19)
{
  if (*a4 >> 30) {
    Error::chuck((Error *)"AccelStaticMFCC::init() - windowlen too large (%u >2^30)", a2, a3, *a4);
  }
  *((_DWORD *)this + 123) = *(_DWORD *)a2;
  *((_DWORD *)this + 124) = *a15;
  int v20 = *a4;
  *((_DWORD *)this + 122) = *a4;
  *((float *)this + 125) = *a6;
  if (*((_DWORD *)this + 12) != v20)
  {
    *((_DWORD *)this + 12) = v20;
    operator new[]();
  }
  if (*((_DWORD *)this + 18) != v20)
  {
    *((_DWORD *)this + 18) = v20;
    operator new[]();
  }
  int v21 = *((_DWORD *)this + 124);
  if (*((_DWORD *)this + 6) != v21)
  {
    *((_DWORD *)this + 6) = v21;
    operator new[]();
  }
  *((unsigned char *)this + 88) = 0;
  unsigned int v22 = *a3;
  *((_DWORD *)this + 105) = *a3;
  int v23 = *a4;
  *((_DWORD *)this + 106) = *a4;
  *((unsigned char *)this + 428) = *a5;
  int v24 = 1;
  do
  {
    int v25 = v24;
    v24 *= 2;
  }
  while (v25 < v23);
  *((_DWORD *)this + 108) = v25;
  *((_DWORD *)this + 109) = (v25 >> 1) + 1;
  *((unsigned char *)this + 440) = *a10;
  *((float *)this + 111) = *a16 * *a17;
  *((unsigned char *)this + 448) = *a7;
  int v26 = *a11;
  *((_DWORD *)this + 113) = *a11;
  *((_DWORD *)this + 114) = v22 >> 1;
  *((float *)this + 115) = *a12;
  *((float *)this + 116) = *a13;
  *((float *)this + 117) = *a18;
  *(float *)&a9 = *a19;
  *((float *)this + 118) = *a19;
  int v27 = *(unsigned __int8 *)a8;
  *((unsigned char *)this + 449) = v27;
  *((_DWORD *)this + 119) = *a14;
  if (v27) {
    int v28 = v26;
  }
  else {
    int v28 = *((_DWORD *)this + 124);
  }
  *((_DWORD *)this + 120) = v28;
  AccelWin2MFCC::initProc((AccelStaticMFCC *)((char *)this + 88), a9);
  uint64_t result = AccelWin2MFCC::initData((void **)this + 11);
  *((_DWORD *)this + 104) = 1065353216;
  *((unsigned char *)this + 88) = 1;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 126) = *((_DWORD *)this + 122) + 1;
  *((void *)this + 64) = 0;
  *((unsigned char *)this + 508) = 0;
  *(unsigned char *)this = 1;
  return result;
}

uint64_t AccelStaticMFCC::reset(uint64_t this)
{
  *(_DWORD *)(this + 80) = 0;
  *(_DWORD *)(this + 504) = *(_DWORD *)(this + 488) + 1;
  *(void *)(this + 512) = 0;
  *(unsigned char *)(this + 508) = 0;
  return this;
}

uint64_t AccelStaticMFCC::start(uint64_t result, const char *a2, int *a3, int *a4)
{
  if (!*(unsigned char *)result) {
    Error::chuck((Error *)"AccelStaticMFCC::start() - AccelStaticMFCC::init() has to be called before starting", a2);
  }
  if (*(void *)(result + 512)) {
    Error::chuck((Error *)"AccelStaticMFCC::start() - frames undrained from previous chunk - call isFrame() or reset()", a2);
  }
  int v4 = *a3;
  if (!a2 && v4) {
    Error::chuck((Error *)"AccelStaticMFCC::start() - pointer to chunk is NULL", 0);
  }
  int v5 = *a4;
  if (*a4 >= 2) {
    Error::chuck((Error *)"NAccelStaticMFCC::start() - unsupported sample type", a2);
  }
  *(void *)(result + 512) = a2;
  *(_DWORD *)(result + 520) = v4;
  *(_DWORD *)(result + 524) = v5;
  *(unsigned char *)(result + 508) = 0;
  return result;
}

uint64_t AccelStaticMFCC::isFrame(AccelStaticMFCC *this, const char *a2)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)this + 64);
  unsigned int v4 = *((_DWORD *)this + 130);
  if (!v3)
  {
    if (v4) {
      Error::chuck((Error *)"AccelStaticMFCC::isFrame() - AccelStaticMFCC::start() has tobe called before computing next frame", a2);
    }
    uint64_t v3 = 0;
  }
  int v5 = *((_DWORD *)this + 131);
  unsigned int v6 = *((_DWORD *)this + 126);
  if (v6 > v4 || *((unsigned char *)this + 508))
  {
    int v7 = *((_DWORD *)this + 122);
    if (v7 + 1 <= v6 || *((unsigned char *)this + 508))
    {
      unsigned int v8 = v6 + ~v7;
      vDSP_Length v9 = v4 - v8;
      if (v4 <= v8) {
        goto LABEL_29;
      }
      if (v8 < v6 && *((unsigned char *)this + 508) != 0) {
        goto LABEL_29;
      }
      unsigned int v11 = (float *)*((void *)this + 8);
      if (v5 == 1)
      {
        float __B = 32767.0;
        uint64_t v12 = (const float *)(v3 + 4 * v8);
LABEL_22:
        vDSP_vsmul(v12, 1, &__B, v11, 1, v9);
        float __C = 32767.0;
        float v54 = -32767.0;
        vDSP_vclip(v11, 1, &v54, &__C, v11, 1, v9);
LABEL_29:
        uint64_t result = 0;
        int v24 = *((_DWORD *)this + 126) - *((_DWORD *)this + 130);
        *((_DWORD *)this + 126) = v24;
        *((_DWORD *)this + 20) = *((_DWORD *)this + 122) - v24 + 1;
        *((void *)this + 64) = 0;
        *((unsigned char *)this + 508) = 0;
        return result;
      }
      uint64_t v12 = (const float *)(v3 + 2 * v8);
    }
    else
    {
      size_t v19 = 4 * (v7 + 1 - v6);
      memmove(*((void **)this + 8), (const void *)(*((void *)this + 8) + 4 * (*((_DWORD *)this + 20) - (v7 + 1 - v6))), v19);
      uint64_t v12 = (const float *)*((void *)this + 64);
      unsigned int v11 = (float *)(*((void *)this + 8) + v19);
      vDSP_Length v9 = *((unsigned int *)this + 130);
      if (v5 == 1)
      {
        float __B = 32767.0;
        goto LABEL_22;
      }
    }
    vDSP_vflt16((const __int16 *)v12, 1, v11, 1, v9);
    goto LABEL_29;
  }
  vDSP_Length v13 = *((unsigned int *)this + 122);
  uint64_t v14 = (float *)*((void *)this + 5);
  unsigned int v15 = v13 + 1 - v6;
  if ((int)v13 + 1 <= v6)
  {
    unsigned int v20 = v6 + ~v13;
    if (v5 == 1)
    {
      float __B = 32767.0;
      unsigned int v18 = (const float *)(v3 + 4 * v20);
LABEL_25:
      vDSP_vsmul(v18, 1, &__B, v14, 1, v13);
      float __C = 32767.0;
      float v54 = -32767.0;
      vDSP_vclip(v14, 1, &v54, &__C, v14, 1, v13);
      int v22 = *((_DWORD *)this + 126);
      if (!v22) {
        goto LABEL_31;
      }
LABEL_34:
      uint64_t v25 = (v22 - 1);
      if (v5 == 1)
      {
        float v26 = *(float *)(v3 + 4 * v25);
        BOOL v27 = v26 < -1.0 || v26 > 1.0;
        float v28 = -32767.0;
        if (v26 > 1.0 && v26 >= -1.0) {
          float v28 = 32767.0;
        }
        *(float *)v21.i32 = v26 * 32767.0;
        if (v27) {
          *(float *)v21.i32 = v28;
        }
      }
      else
      {
        v21.i16[0] = *(_WORD *)(v3 + 2 * v25);
        *(float *)v21.i32 = (float)vmovl_s16(v21).i32[0];
      }
      goto LABEL_44;
    }
    unsigned int v18 = (const float *)(v3 + 2 * v20);
  }
  else
  {
    uint64_t v16 = (const void *)(*((void *)this + 8) + 4 * (*((_DWORD *)this + 20) - v15));
    if (v15 >= v13)
    {
      memcpy(*((void **)this + 5), v16, 4 * v13);
      int v22 = *((_DWORD *)this + 126);
      if (v22) {
        goto LABEL_34;
      }
      goto LABEL_31;
    }
    size_t v17 = 4 * (v13 + 1 - v6);
    memcpy(*((void **)this + 5), v16, v17);
    vDSP_Length v13 = (*((_DWORD *)this + 126) - 1);
    unsigned int v18 = (const float *)*((void *)this + 64);
    uint64_t v14 = (float *)(*((void *)this + 5) + v17);
    if (v5 == 1)
    {
      float __B = 32767.0;
      goto LABEL_25;
    }
  }
  vDSP_vflt16((const __int16 *)v18, 1, v14, 1, v13);
  int v22 = *((_DWORD *)this + 126);
  if (v22) {
    goto LABEL_34;
  }
LABEL_31:
  v21.i32[0] = *(_DWORD *)(*((void *)this + 8) + 4 * (*((_DWORD *)this + 20) - 1));
LABEL_44:
  *((_DWORD *)this + 21) = v21.i32[0];
  float __B = 1.0;
  float v56 = -*((float *)this + 125);
  vDSP_conv(*((const float **)this + 5), 1, &v56, -1, *((float **)this + 5), 1, (*((_DWORD *)this + 122) - 1), 2uLL);
  uint64_t v29 = 4 * (*((_DWORD *)this + 122) - 1);
  *(float *)(*((void *)this + 5) + v29) = *((float *)this + 21)
                                          - (float)(*(float *)(*((void *)this + 5) + v29) * *((float *)this + 125));
  uint64_t v30 = AccelWin2MFCC::run((uint64_t)this + 88, (uint64_t)this + 32);
  if ((AccelStaticMFCC *)((char *)this + 8) != (AccelStaticMFCC *)v30)
  {
    uint64_t v31 = v30;
    unsigned int v32 = *((_DWORD *)this + 6);
    int v33 = *(_DWORD *)(v30 + 16);
    if (v32 != v33)
    {
      uint64_t v34 = *((void *)this + 2);
      if (v34)
      {
        MEMORY[0x21D46B220](v34, 0x1000C8052888210);
        int v33 = *(_DWORD *)(v31 + 16);
      }
      *((_DWORD *)this + 6) = v33;
      operator new[]();
    }
    if (v32)
    {
      uint64_t v35 = 0;
      uint64_t v36 = *(void *)(v30 + 8);
      uint64_t v37 = *((void *)this + 2);
      uint64_t v38 = v32;
      if (v32 < 8) {
        goto LABEL_55;
      }
      if ((unint64_t)(v37 - v36) < 0x20) {
        goto LABEL_55;
      }
      uint64_t v35 = v32 & 0xFFFFFFF8;
      unint64_t v39 = (_OWORD *)(v37 + 16);
      uint64_t v40 = (long long *)(v36 + 16);
      uint64_t v41 = v38 & 0xFFFFFFF8;
      do
      {
        long long v42 = *v40;
        *(v39 - 1) = *(v40 - 1);
        *unint64_t v39 = v42;
        v39 += 2;
        v40 += 2;
        v41 -= 8;
      }
      while (v41);
      if (v35 != v38)
      {
LABEL_55:
        uint64_t v43 = v38 - v35;
        uint64_t v44 = 4 * v35;
        uint64_t v45 = (_DWORD *)(v37 + v44);
        uint64_t v46 = (int *)(v36 + v44);
        do
        {
          int v47 = *v46++;
          *v45++ = v47;
          --v43;
        }
        while (v43);
      }
    }
  }
  int v48 = *((_DWORD *)this + 126);
  int v49 = *((_DWORD *)this + 123);
  BOOL v50 = __CFADD__(v49, v48);
  int v51 = v49 + v48;
  char v52 = v50;
  *((_DWORD *)this + 126) = v51;
  *((unsigned char *)this + 508) = v52;
  return 1;
}

float AccelStaticMFCC::preemph(AccelStaticMFCC *this)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  float v5 = -*((float *)this + 125);
  vDSP_conv(*((const float **)this + 5), 1, &v5, -1, *((float **)this + 5), 1, (*((_DWORD *)this + 122) - 1), 2uLL);
  uint64_t v2 = *((void *)this + 5);
  uint64_t v3 = 4 * (*((_DWORD *)this + 122) - 1);
  float result = *((float *)this + 21) - (float)(*(float *)(v2 + v3) * *((float *)this + 125));
  *(float *)(v2 + v3) = result;
  return result;
}

uint64_t AccelStaticMFCC::getFrame(AccelStaticMFCC *this)
{
  return (uint64_t)this + 8;
}

uint64_t AccelStaticMFCC::getWindow(AccelStaticMFCC *this)
{
  return (uint64_t)this + 32;
}

uint64_t AccelStaticMFCC::getScalingFactor(AccelStaticMFCC *this)
{
  return (uint64_t)this + 416;
}

void sub_2184ED190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_2184ED44C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getCSActivationEventNotifierClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v4[0] = 0;
  if (!CoreSpeechLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x263EF8330];
    unsigned int v4[2] = 3221225472;
    v4[3] = __CoreSpeechLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_264325838;
    uint64_t v6 = 0;
    CoreSpeechLibraryCore_frameworkLibrary = _sl_dlopen();
    uint64_t v2 = (void *)v4[0];
    if (!CoreSpeechLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("CSActivationEventNotifier");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    uint64_t v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getCSActivationEventNotifierClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

Class __getCSActivationEventClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v4[0] = 0;
  if (!CoreSpeechLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x263EF8330];
    unsigned int v4[2] = 3221225472;
    v4[3] = __CoreSpeechLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_264325838;
    uint64_t v6 = 0;
    CoreSpeechLibraryCore_frameworkLibrary = _sl_dlopen();
    uint64_t v2 = (void *)v4[0];
    if (!CoreSpeechLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("CSActivationEvent");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    uint64_t v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getCSActivationEventClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __CoreSpeechLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreSpeechLibraryCore_frameworkLibrary = result;
  return result;
}

id getCSVoiceTriggerXPCServiceClass()
{
  uint64_t v4 = 0;
  long long v5 = &v4;
  uint64_t v6 = 0x2050000000;
  dispatch_time_t v0 = (void *)getCSVoiceTriggerXPCServiceClass_softClass;
  uint64_t v7 = getCSVoiceTriggerXPCServiceClass_softClass;
  if (!getCSVoiceTriggerXPCServiceClass_softClass)
  {
    v3[0] = MEMORY[0x263EF8330];
    v3[1] = 3221225472;
    v3[2] = __getCSVoiceTriggerXPCServiceClass_block_invoke;
    v3[3] = &unk_264326190;
    v3[4] = &v4;
    __getCSVoiceTriggerXPCServiceClass_block_invoke((uint64_t)v3);
    dispatch_time_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_2184EE4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getCSVoiceTriggerXPCServiceClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v4[0] = 0;
  if (!CoreSpeechLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x263EF8330];
    unsigned int v4[2] = 3221225472;
    v4[3] = __CoreSpeechLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_264325838;
    uint64_t v6 = 0;
    CoreSpeechLibraryCore_frameworkLibrary = _sl_dlopen();
    uint64_t v2 = (void *)v4[0];
    if (!CoreSpeechLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("CSVoiceTriggerXPCService");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    uint64_t v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getCSVoiceTriggerXPCServiceClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void NFilePtr::open(NFilePtr *this, const NString *a2, const NString *a3)
{
  uint64_t v5 = *((unsigned int *)a2 + 2);
  if (v5 >= 7)
  {
    uint64_t v6 = (int *)*((void *)a2 + 2);
    int v7 = *v6;
    int v8 = *(int *)((char *)v6 + 3);
    if (v7 == 1684957549 && v8 == 980968804) {
      operator new();
    }
    int v10 = v5 - 6;
    if ((int)v5 - 6 >= 1)
    {
      unsigned int v11 = (void *)*((void *)a2 + 2);
      int v12 = v5 - 6;
      vDSP_Length v13 = v11;
      while (1)
      {
        uint64_t v14 = memchr(v13, 46, v12);
        if (!v14) {
          goto LABEL_29;
        }
        int v16 = v14 - v11;
        if (*v14 == 1684629038 && *(_DWORD *)((char *)v14 + 3) == 791624292) {
          break;
        }
        int v12 = v5 - v16 - 7;
        vDSP_Length v13 = (char *)v14 + 1;
        if (v12 <= 0) {
          goto LABEL_29;
        }
      }
      if ((v16 & 0x80000000) == 0)
      {
        uint64_t v18 = (v16 + 4);
        if (v18 <= v5)
        {
          if (v11) {
            operator new[]();
          }
          Error::chuck((Error *)"Null pointer passed to string constructor", v15);
        }
LABEL_54:
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v15, v18, v5);
      }
LABEL_29:
      if (v10 >= 1)
      {
        size_t v19 = (void *)*((void *)a2 + 2);
        int v20 = v5 - 6;
        int16x4_t v21 = v19;
        while (1)
        {
          int v22 = memchr(v21, 46, v20);
          if (!v22) {
            goto LABEL_42;
          }
          int v23 = v22 - v19;
          if (*v22 == 1885960750 && *(_DWORD *)((char *)v22 + 3) == 791624304) {
            break;
          }
          int v20 = v5 - v23 - 7;
          int16x4_t v21 = (char *)v22 + 1;
          if (v20 <= 0) {
            goto LABEL_42;
          }
        }
        if ((v23 & 0x80000000) == 0)
        {
          uint64_t v18 = (v23 + 4);
          if (v18 <= v5)
          {
            if (v19) {
              operator new[]();
            }
            Error::chuck((Error *)"Null pointer passed to string constructor", v15);
          }
          goto LABEL_54;
        }
LABEL_42:
        uint64_t v25 = (void *)*((void *)a2 + 2);
        float v26 = v25;
        while (1)
        {
          BOOL v27 = memchr(v26, 46, v10);
          if (!v27) {
            goto LABEL_2;
          }
          int v28 = v27 - v25;
          if (*v27 == 875979310 && *(_DWORD *)((char *)v27 + 3) == 791624244) {
            break;
          }
          int v10 = v5 - v28 - 7;
          float v26 = (char *)v27 + 1;
          if (v10 <= 0) {
            goto LABEL_2;
          }
        }
        if (v28 >= 1) {
          operator new();
        }
        if (!v28) {
          operator new();
        }
      }
    }
  }
LABEL_2:
  if (NString::endswith(a2, "|") && NString::operator==((uint64_t)a3, "r")) {
    operator new();
  }
  if (NString::startswith(a2, "|") && NString::operator==((uint64_t)a3, "w")) {
    operator new();
  }
  if (NString::endswith(a2, ".gz")) {
    operator new();
  }
  operator new();
}

void sub_2184EF378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (!a19) {
    _Unwind_Resume(exception_object);
  }
  MEMORY[0x21D46B220](a19, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

void sub_2184EF578(_Unwind_Exception *a1)
{
  *id v1 = v2;
  v1[1] = v3;
  uint64_t v5 = v1[3];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  MEMORY[0x21D46B240](v1, 0x1091C407359F4A8);
  _Unwind_Resume(a1);
}

void sub_2184EF5B4()
{
}

void sub_2184EF5D0()
{
}

void NBNNSIRDistribution::resetState(NBNNSIRDistribution *this, void *a2)
{
  if (a2)
  {
    uint64_t v3 = *((unsigned int *)this + 50);
    if (v3)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      uint64_t v7 = 4 * v3;
      do
      {
        size_t v8 = *(unsigned int *)(*((void *)this + 27) + v6);
        if (v8) {
          bzero(*(void **)(a2[1] + v5), v8);
        }
        v6 += 4;
        v5 += 16;
      }
      while (v7 != v6);
    }
  }
}

uint64_t NBNNSIRDistribution::deallocateState(uint64_t this, void *a2)
{
  if (a2)
  {
    uint64_t v3 = *(unsigned int *)(this + 200);
    if (v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 0;
      do
      {
        if (!*(_DWORD *)(*(void *)(this + 216) + v5)) {
          *(void *)(a2[1] + v4) = 0;
        }
        v5 += 4;
        v4 += 16;
      }
      while (4 * v3 != v5);
    }
    *(void *)(a2[1] + 16 * *(unsigned int *)(this + 172)) = 0;
    *(void *)(a2[1] + 16 * *(unsigned int *)(this + 176)) = 0;
    if (v3)
    {
      uint64_t v6 = 0;
      uint64_t v7 = a2[1];
      uint64_t v8 = 16 * v3;
      do
      {
        uint64_t v9 = *(void *)(v7 + v6);
        if (v9)
        {
          MEMORY[0x21D46B240](v9, 0x1000C4077774924);
          uint64_t v7 = a2[1];
        }
        *(void *)(v7 + v6) = 0;
        uint64_t v7 = a2[1];
        *(void *)(v7 + v6 + 8) = 0;
        v6 += 16;
      }
      while (v8 != v6);
    }
    int v10 = *(uint64_t (**)(void *))(*a2 + 8);
    return v10(a2);
  }
  return this;
}

uint64_t NBNNSIRDistribution::allocateStateP(NBNNSIRDistribution *this, const char *a2)
{
  if (!*((_DWORD *)this + 39)) {
    Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - BNNSIR not loaded", a2);
  }
  if (*((_DWORD *)this + 50) >= 3u) {
    operator new();
  }
  return 0;
}

void sub_2184EFE64(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x10A1C40DF6760FDLL);
  _Unwind_Resume(a1);
}

uint64_t NArray<bnns_graph_argument_t>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

__n128 NArray<bnns_graph_argument_t>::fromArray(uint64_t a1, uint64_t a2, int *a3)
{
  int v4 = *(_DWORD *)(a1 + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x10A2C808DAD38D9);
      int v5 = *a3;
    }
    *(_DWORD *)(a1 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      __n128 result = *(__n128 *)(a2 + v8);
      *(__n128 *)(*(void *)(a1 + 8) + v8) = result;
      ++v9;
      v8 += 16;
    }
    while (v9 < *(unsigned int *)(a1 + 16));
  }
  return result;
}

uint64_t NArray<bnns_graph_argument_t>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x10A2C808DAD38D9);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      unint64_t v8 = 0;
      do
      {
        *(_OWORD *)(*(void *)(result + 8) + v7) = *(_OWORD *)(*(void *)(a2 + 8) + v7);
        ++v8;
        v7 += 16;
      }
      while (v8 < *(unsigned int *)(result + 16));
    }
  }
  return result;
}

void NArray<bnns_graph_argument_t>::~NArray(void *a1)
{
  *a1 = &unk_26C9994B8;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x10A2C808DAD38D9);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<bnns_graph_argument_t>::~NArray(void *a1)
{
  *a1 = &unk_26C9994B8;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x10A2C808DAD38D9);
  }
  return a1;
}

void NBNNSIRDistribution::fixedPointScalesP(NBNNSIRDistribution *this, const char *a2)
{
}

void NBNNSIRDistribution::baseGMM(NBNNSIRDistribution *this, const char *a2)
{
}

void NBNNSIRDistribution::posteriorWeightedMean(uint64_t a1, const char *a2)
{
}

void NBNNSIRDistribution::firstComponentId(NBNNSIRDistribution *this, const char *a2)
{
}

void NBNNSIRDistribution::setComponentMask(uint64_t a1, const char *a2)
{
}

void NBNNSIRDistribution::numComponents(NBNNSIRDistribution *this, const char *a2)
{
}

void NBNNSIRDistribution::componentScore(uint64_t a1, const char *a2)
{
}

void NBNNSIRDistribution::scoreUsingCache(uint64_t a1, const char *a2)
{
}

void NBNNSIRDistribution::scoreAll(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(unsigned int *)(a1 + 156);
  if (v4)
  {
    if (*(_DWORD *)(a2 + 16) == v4)
    {
      uint64_t v6 = (*(_DWORD *)(a1 + 152) * *(_DWORD *)(a1 + 164));
      if (*(_DWORD *)(a3 + 16) == v6)
      {
        if (a4)
        {
          uint64_t v7 = *(char **)(a4 + 8);
        }
        else
        {
          if (*(_DWORD *)(a1 + 200) >= 3u) {
            Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - state uninitialized", (const char *)a2);
          }
          uint64_t v7 = &v11;
        }
        *(void *)&v7[16 * *(unsigned int *)(a1 + 172)] = *(void *)(a2 + 8);
        *(void *)&v7[16 * *(unsigned int *)(a1 + 172) + 8] = 4 * *(unsigned int *)(a2 + 16);
        *(void *)&v7[16 * *(unsigned int *)(a1 + 176)] = *(void *)(a3 + 8);
        *(void *)&v7[16 * *(unsigned int *)(a1 + 176) + 8] = 4 * *(unsigned int *)(a3 + 16);
        BNNSGraphContextMake();
        if (*(void *)(a1 + 96))
        {
          uint64_t v8 = BNNSGraphContextSetWeights();
          if (v8)
          {
            uint64_t v9 = v8;
            BNNSGraphContextDestroy_v2();
            Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - BNNSGraphContextSetWeights fails with error %d", v10, v9);
          }
        }
        operator new[]();
      }
      Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - output (dist) vector has wrong size (%d, should be %d)", (const char *)a2, *(unsigned int *)(a3 + 16), v6);
    }
    Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - input vector has wrong size (%d, should be %d)", (const char *)a2, *(unsigned int *)(a2 + 16), v4);
  }
  Error::chuck((Error *)"NBNNSIRDistribution::scoreAll() - BNNSIR not loaded", (const char *)a2);
}

void sub_2184F0598(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (!a15) {
    _Unwind_Resume(exception_object);
  }
  MEMORY[0x21D46B220](a15, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NBNNSIRDistribution::scoreAll(NArray<float> const&,NArray<float>&,void *)const::$_0::__invoke(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (result == 8 && a2 && a4)
  {
    __n128 result = *(void *)(a4 + 8);
    if (result) {
      return (*(uint64_t (**)(void))(*(void *)result + 40))();
    }
  }
  return result;
}

void NBNNSIRDistribution::score(uint64_t a1, const char *a2)
{
}

void NBNNSIRDistribution::read(NBNNSIRDistribution *this, const NString *a2)
{
  *((void *)this + 19) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 42) = 0;
  uint64_t v4 = (NBNNSIRDistribution *)((char *)this + 8);
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0;
  size_t v5 = *((unsigned int *)this + 16);
  if (v5) {
    munmap(*((void **)this + 9), v5);
  }
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = 0;
  LODWORD(v11[0]) = 0;
  (*(void (**)(char *, const char *, void *))(*((void *)this + 4) + 64))((char *)this + 32, "", v11);
  NLoadedMemory::load(v4, a2);
  uint64_t v6 = (const char *)*((unsigned int *)this + 4);
  if (v6 >= 4 && **((_DWORD **)this + 3) == -673472473)
  {
    v11[0] = *((void *)this + 3);
    v11[1] = v6;
    WorkspaceSize_uint64_t v2 = BNNSGraphGetWorkspaceSize_v2();
    if (WorkspaceSize_v2 == -1)
    {
      uint64_t v9 = *((void *)a2 + 2);
      int v10 = "Invalid BNNSIR";
    }
    else
    {
      if (WorkspaceSize_v2 < 0xFFFFFFFF80000000) {
        NBNNSIRDistribution::determineStateWiring(this, v11, 0, a2);
      }
      uint64_t v9 = *((void *)a2 + 2);
      int v10 = "BNNSIR Sizes >= 2^31";
    }
    Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v8, v10, v9);
  }
  Error::chuck((Error *)"NBNNSIRDistribution::read() - missing cookie in %s", v6, *((void *)a2 + 2));
}

void NBNNSIRDistribution::determineStateWiring(NBNNSIRDistribution *this, const void *a2, const char *a3, const NString *a4)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  unsigned int v32 = a2;
  unint64_t InputCount = BNNSGraphGetInputCount();
  if (InputCount != -1)
  {
    unsigned int v8 = InputCount;
    if (InputCount >= 0xFFFFFFFF80000000) {
      goto LABEL_27;
    }
    unint64_t OutputCount = BNNSGraphGetOutputCount();
    if (OutputCount != -1)
    {
      unsigned int v11 = OutputCount;
      if (OutputCount < 0xFFFFFFFF80000000)
      {
        uint64_t v29 = this;
        if (v8 && v8 == OutputCount)
        {
          MEMORY[0x270FA5388](v10);
          vDSP_Length v13 = (char *)v28 - ((v12 + 15) & 0xFFFFFFFF0);
          if (v12 >= 0x200) {
            size_t v14 = 512;
          }
          else {
            size_t v14 = v12;
          }
          bzero((char *)v28 - ((v12 + 15) & 0xFFFFFFFF0), v14);
          uint64_t v33 = v11;
          MEMORY[0x270FA5388](v15);
          if (v16 >= 0x200) {
            size_t v17 = 512;
          }
          else {
            size_t v17 = v16;
          }
          uint64_t v34 = (char *)v28 - ((v16 + 15) & 0xFFFFFFFF0);
          bzero(v34, v17);
          uint64_t v30 = v8;
          uint64_t v31 = v13;
          if (!BNNSGraphGetInputNames_v2())
          {
            if (!BNNSGraphGetOutputNames_v2())
            {
              int v20 = 2 * v8;
              int16x4_t v21 = v29;
              if (*((_DWORD *)v29 + 50) != 2 * v8)
              {
                *((_DWORD *)v29 + 50) = v20;
                operator new[]();
              }
              if (2 * v8)
              {
                unint64_t v22 = 0;
                uint64_t v23 = *((void *)v29 + 24);
                do
                  *(_DWORD *)(v23 + 4 * v22++) = -1;
                while (v22 < *((unsigned int *)v21 + 50));
              }
              if (*((_DWORD *)v21 + 56) != v20)
              {
                *((_DWORD *)v21 + 56) = v20;
                operator new[]();
              }
              if (v20)
              {
                unint64_t v24 = 0;
                uint64_t v25 = *((void *)v21 + 27);
                do
                  *(_DWORD *)(v25 + 4 * v24++) = 0;
                while (v24 < *((unsigned int *)v21 + 56));
              }
              v28[4] = &unk_26C99C2D8;
              uint64_t v35 = &unk_26C99C2D8;
              operator new[]();
            }
            Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v19, "BNNSGraphGetOutputNames failed", *((void *)a4 + 2));
          }
          Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v18, "BNNSGraphGetInputNames failed", *((void *)a4 + 2));
        }
        uint64_t v26 = *((void *)a4 + 2);
        BOOL v27 = "Currently only support numinputs=numoutputs";
LABEL_29:
        Error::chuck((Error *)"NBNNSIRDistribution::read() - %s %s", v7, v27, v26);
      }
LABEL_27:
      uint64_t v26 = *((void *)a4 + 2);
      BOOL v27 = "BNNSIR Sizes >= 2^31";
      goto LABEL_29;
    }
  }
  uint64_t v26 = *((void *)a4 + 2);
  BOOL v27 = "Invalid BNNSIR";
  goto LABEL_29;
}

void sub_2184F1740(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v1[16];
  v1[47] = &unk_26C99C5B0;
  uint64_t v5 = v1[49];
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8077774924);
  }
  v1[50] = v4;
  uint64_t v6 = v1[52];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  *(void *)(v2 - 120) = v1[4];
  uint64_t v7 = *(void *)(v2 - 112);
  if (!v7) {
    _Unwind_Resume(exception_object);
  }
  MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  _Unwind_Resume(exception_object);
}

uint64_t NArray<unsigned long>::resize(uint64_t result, _DWORD *a2)
{
  if (*(_DWORD *)(result + 16) != *a2)
  {
    *(_DWORD *)(result + 16) = *a2;
    operator new[]();
  }
  return result;
}

uint64_t NArray<unsigned long>::fromArray(uint64_t result, uint64_t a2, int *a3)
{
  uint64_t v3 = result;
  unsigned int v4 = *(_DWORD *)(result + 16);
  int v5 = *a3;
  if (v4 != *a3)
  {
    uint64_t v6 = *(void *)(result + 8);
    if (v6)
    {
      MEMORY[0x21D46B220](v6, 0x1000C8000313F17);
      int v5 = *a3;
    }
    *(_DWORD *)(v3 + 16) = v5;
    operator new[]();
  }
  if (v4)
  {
    uint64_t v8 = *(void *)(result + 8);
    uint64_t v9 = v4;
    if (v4 < 4 || (unint64_t)(v8 - a2) <= 0x1F)
    {
      uint64_t v11 = 0;
LABEL_14:
      uint64_t v16 = v9 - v11;
      uint64_t v17 = 8 * v11;
      uint64_t v18 = (void *)(v8 + v17);
      size_t v19 = (uint64_t *)(a2 + v17);
      do
      {
        uint64_t v20 = *v19++;
        *v18++ = v20;
        --v16;
      }
      while (v16);
      return result;
    }
    uint64_t v11 = v4 & 0xFFFFFFFC;
    unint64_t v12 = (_OWORD *)(v8 + 16);
    vDSP_Length v13 = (long long *)(a2 + 16);
    uint64_t v14 = v9 & 0xFFFFFFFC;
    do
    {
      long long v15 = *v13;
      *(v12 - 1) = *(v13 - 1);
      _OWORD *v12 = v15;
      v12 += 2;
      v13 += 2;
      v14 -= 4;
    }
    while (v14);
    if (v11 != v9) {
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t NArray<unsigned long>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (result != a2)
  {
    unsigned int v4 = *(_DWORD *)(result + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 != v5)
    {
      uint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        MEMORY[0x21D46B220](v6, 0x1000C8000313F17);
        int v5 = *(_DWORD *)(a2 + 16);
      }
      *(_DWORD *)(v2 + 16) = v5;
      operator new[]();
    }
    if (v4)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 8);
      uint64_t v9 = *(void *)(result + 8);
      uint64_t v10 = v4;
      if (v4 < 4) {
        goto LABEL_12;
      }
      if ((unint64_t)(v9 - v8) < 0x20) {
        goto LABEL_12;
      }
      uint64_t v7 = v4 & 0xFFFFFFFC;
      uint64_t v11 = (_OWORD *)(v9 + 16);
      unint64_t v12 = (long long *)(v8 + 16);
      uint64_t v13 = v10 & 0xFFFFFFFC;
      do
      {
        long long v14 = *v12;
        *(v11 - 1) = *(v12 - 1);
        *uint64_t v11 = v14;
        v11 += 2;
        v12 += 2;
        v13 -= 4;
      }
      while (v13);
      if (v7 != v10)
      {
LABEL_12:
        uint64_t v15 = v10 - v7;
        uint64_t v16 = 8 * v7;
        uint64_t v17 = (void *)(v9 + v16);
        uint64_t v18 = (uint64_t *)(v8 + v16);
        do
        {
          uint64_t v19 = *v18++;
          *v17++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  return result;
}

void NArray<unsigned long>::~NArray(void *a1)
{
  *a1 = &unk_26C9994F0;
  uint64_t v1 = a1[1];
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8000313F17);
  }

  JUMPOUT(0x21D46B240);
}

void *NArray<unsigned long>::~NArray(void *a1)
{
  *a1 = &unk_26C9994F0;
  uint64_t v2 = a1[1];
  if (v2) {
    MEMORY[0x21D46B220](v2, 0x1000C8000313F17);
  }
  return a1;
}

uint64_t NBNNSIRDistribution::scoreCacheTypes(NBNNSIRDistribution *this)
{
  return 4;
}

uint64_t NBNNSIRDistribution::frameSize(NBNNSIRDistribution *this)
{
  return (uint64_t)this + 168;
}

uint64_t NBNNSIRDistribution::numFrames(NBNNSIRDistribution *this)
{
  return *((unsigned int *)this + 40);
}

uint64_t NBNNSIRDistribution::dimen(NBNNSIRDistribution *this)
{
  return (uint64_t)this + 156;
}

uint64_t NBNNSIRDistribution::size(NBNNSIRDistribution *this)
{
  return (*((_DWORD *)this + 38) * *((_DWORD *)this + 41));
}

void NBNNSIRDistribution::~NBNNSIRDistribution(NBNNSIRDistribution *this)
{
  NBNNSIRDistribution::~NBNNSIRDistribution(this);

  JUMPOUT(0x21D46B240);
}

{
  size_t v2;
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;

  *(void *)this = &unk_26C99B150;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0;
  uint64_t v2 = *((unsigned int *)this + 16);
  if (v2) {
    munmap(*((void **)this + 9), v2);
  }
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = 0;
  uint64_t v6 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 4) + 64))((char *)this + 32, "", &v6);
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 12) = 0;
  uint64_t v3 = *((unsigned int *)this + 34);
  if (v3) {
    munmap(*((void **)this + 18), v3);
  }
  *((_DWORD *)this + 34) = 0;
  *((void *)this + 18) = 0;
  uint64_t v7 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 13) + 64))((char *)this + 104, "", &v7);
  *((void *)this + 19) = 0;
  *((_DWORD *)this + 40) = 0;
  *((_DWORD *)this + 42) = 0;
  *((void *)this + 26) = &unk_26C99C3F0;
  unsigned int v4 = *((void *)this + 27);
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8052888210);
  }
  *((void *)this + 23) = &unk_26C99C3F0;
  int v5 = *((void *)this + 24);
  if (v5) {
    MEMORY[0x21D46B220](v5, 0x1000C8052888210);
  }
  NLoadedMemory::~NLoadedMemory((NBNNSIRDistribution *)((char *)this + 80));
  NLoadedMemory::~NLoadedMemory((NBNNSIRDistribution *)((char *)this + 8));
}

void NBNNSIRDistribution::NBNNSIRDistribution(NBNNSIRDistribution *this)
{
  *(void *)this = &unk_26C99B150;
  *((void *)this + 1) = &unk_26C99AA30;
  *((_DWORD *)this + 4) = 0;
  uint64_t v2 = (char *)this + 32;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = &unk_26C99B388;
  *((_DWORD *)this + 14) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v3, 1, *((unsigned int *)this + 14));
  }
  unsigned int v4 = memptr;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 6) = v4;
  *((void *)this + 4) = &unk_26C99B388;
  *unsigned int v4 = 0;
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = &unk_26C99AA30;
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 13) = &unk_26C99B388;
  *((_DWORD *)this + 32) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v5, 1, *((unsigned int *)this + 32));
  }
  uint64_t v6 = memptr;
  *((_DWORD *)this + 28) = 0;
  *((void *)this + 15) = v6;
  *((void *)this + 13) = &unk_26C99B388;
  *uint64_t v6 = 0;
  *((_DWORD *)this + 34) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 44) = 0;
  *((void *)this + 23) = &unk_26C99C3F0;
  *((void *)this + 24) = 0;
  *((_DWORD *)this + 50) = 0;
  *((void *)this + 26) = &unk_26C99C3F0;
  *((void *)this + 27) = 0;
  *((_DWORD *)this + 56) = 0;
  int v7 = getpagesize();
  if (v7 <= 0) {
    Error::chuck((Error *)"NBNNSIRDistribution::NBNNSIRDistribution() - cannot determine page size for allocation", v8);
  }
  int v9 = v7;
  *((_DWORD *)this + 14) = v7;
  unint64_t v10 = v7;
  if (*((void *)this + 6) % (unint64_t)v7)
  {
    LODWORD(memptr) = *((_DWORD *)this + 10);
    (*(void (**)(char *))(*((void *)this + 4) + 64))(v2);
  }
  *((_DWORD *)this + 32) = v9;
  if (*((void *)this + 15) % v10)
  {
    LODWORD(memptr) = *((_DWORD *)this + 28);
    (*(void (**)(char *))(*((void *)this + 13) + 64))((char *)this + 104);
  }
}

void sub_2184F2158(_Unwind_Exception *a1)
{
  v2[26] = v5;
  uint64_t v7 = v2[27];
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8052888210);
  }
  v2[23] = v4;
  uint64_t v8 = v2[24];
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8052888210);
  }
  NLoadedMemory::~NLoadedMemory(v3);
  NLoadedMemory::~NLoadedMemory(v1);
  _Unwind_Resume(a1);
}

uint64_t NBNNSIRDistribution::reset(NBNNSIRDistribution *this)
{
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 3) = 0;
  size_t v2 = *((unsigned int *)this + 16);
  if (v2) {
    munmap(*((void **)this + 9), v2);
  }
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = 0;
  int v7 = 0;
  (*(void (**)(char *, const char *, int *))(*((void *)this + 4) + 64))((char *)this + 32, "", &v7);
  *((_DWORD *)this + 22) = 0;
  *((void *)this + 12) = 0;
  size_t v3 = *((unsigned int *)this + 34);
  if (v3) {
    munmap(*((void **)this + 18), v3);
  }
  *((_DWORD *)this + 34) = 0;
  *((void *)this + 18) = 0;
  int v8 = 0;
  uint64_t v5 = *((void *)this + 13);
  uint64_t v4 = (char *)this + 104;
  uint64_t result = (*(uint64_t (**)(char *, const char *, int *))(v5 + 64))(v4, "", &v8);
  *((void *)v4 + 6) = 0;
  *((_DWORD *)v4 + 14) = 0;
  *((_DWORD *)v4 + 16) = 0;
  return result;
}

uint64_t NBNNSIRDistribution::setWeightsFile(NBNNSIRDistribution *this, const NString *a2)
{
  if (*((_DWORD *)a2 + 2))
  {
    size_t v3 = (NBNNSIRDistribution *)((char *)this + 80);
    return NLoadedMemory::load(v3, a2);
  }
  else
  {
    *((_DWORD *)this + 22) = 0;
    *((void *)this + 12) = 0;
    size_t v5 = *((unsigned int *)this + 34);
    if (v5) {
      munmap(*((void **)this + 18), v5);
    }
    *((_DWORD *)this + 34) = 0;
    *((void *)this + 18) = 0;
    int v6 = 0;
    return (*(uint64_t (**)(char *, const char *, int *))(*((void *)this + 13) + 64))((char *)this + 104, "", &v6);
  }
}

uint64_t NBNNSIRDistribution::getDimensions(NBNNSIRDistribution *this, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  if (a2[2]) {
    return 0;
  }
  if (a2[3]) {
    return 0;
  }
  if (a2[4]) {
    return 0;
  }
  if (a2[5]) {
    return 0;
  }
  if (a2[6]) {
    return 0;
  }
  if (a2[7]) {
    return 0;
  }
  if (a2[1]) {
    unint64_t v5 = *a2++;
  }
  else {
    unint64_t v5 = 1;
  }
  *a3 = v5;
  *a4 = *a2;
  return 1;
}

uint64_t NBNNSIRDistribution::flipStateOutputsToInputs(uint64_t this, void *a2)
{
  if (a2)
  {
    uint64_t v2 = *(unsigned int *)(this + 200);
    if (v2)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = *(unsigned int *)(*(void *)(this + 192) + v4);
        if (v5 < v2)
        {
          uint64_t v6 = a2[1];
          uint64_t v7 = *(void *)(v6 + v3);
          uint64_t v8 = 16 * v5;
          *(void *)(v6 + v3) = *(void *)(v6 + v8);
          *(void *)(a2[1] + v8) = v7;
        }
        v4 += 4;
        v3 += 16;
      }
      while (4 * v2 != v4);
    }
  }
  return this;
}

void sub_2184F448C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_2184F4620(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184F4A70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184F4E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_2184F51B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_2184F53F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184F5448(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  __cxa_begin_catch(a1);
  int v9 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_21844F000, v9, OS_LOG_TYPE_DEFAULT, "recognizeWavData failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x2184F5438);
}

void sub_2184F5670(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  __cxa_begin_catch(a1);
  int v9 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_21844F000, v9, OS_LOG_TYPE_DEFAULT, "endAudio failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x2184F5660);
}

void sub_2184F57CC(void *a1)
{
  __cxa_begin_catch(a1);
  uint64_t v1 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v2 = 0;
    _os_log_impl(&dword_21844F000, v1, OS_LOG_TYPE_DEFAULT, "runRecognition failed", (uint8_t *)&v2, 2u);
  }
  __cxa_end_catch();
}

void sub_2184F5BB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184F5D40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t N16ByteAlignedString::allocate2(N16ByteAlignedString *this, const unsigned int *a2, const unsigned int *a3)
{
  if (*a3) {
    *((_DWORD *)this + 6) = *a3;
  }
  return (**(uint64_t (***)(N16ByteAlignedString *, const unsigned int *))this)(this, a2);
}

void N16ByteAlignedString::~N16ByteAlignedString(void **this)
{
  *this = &unk_26C99B388;
  free(this[2]);
  this[2] = 0;
  *this = &unk_26C99C5B0;

  JUMPOUT(0x21D46B240);
}

{
  *this = &unk_26C99B388;
  free(this[2]);
  this[2] = 0;
  *this = &unk_26C99C5B0;
}

{
  *this = &unk_26C99B388;
  free(this[2]);
  this[2] = 0;
  *this = &unk_26C99C5B0;
}

void N16ByteAlignedString::deallocate(N16ByteAlignedString *this, char *a2)
{
}

void *N16ByteAlignedString::allocate(N16ByteAlignedString *this, const unsigned int *a2)
{
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, *((unsigned int *)this + 6), *a2 + 1, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v4, *a2 + 1, *((unsigned int *)this + 6));
  }
  return memptr;
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this)
{
  *(void *)this = &unk_26C99B388;
  *((_DWORD *)this + 6) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 6));
  }
  uint64_t v3 = memptr;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = v3;
  *(void *)this = &unk_26C99B388;
  *uint64_t v3 = 0;
}

{
  const char *v2;
  unsigned char *v3;
  void *memptr;

  *(void *)this = &unk_26C99B388;
  *((_DWORD *)this + 6) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 6));
  }
  uint64_t v3 = memptr;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = v3;
  *(void *)this = &unk_26C99B388;
  *uint64_t v3 = 0;
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this, const N16ByteAlignedString *a2)
{
  *(void *)this = &unk_26C99B388;
  unsigned int v6 = *((_DWORD *)a2 + 2);
  int v4 = *((_DWORD *)a2 + 6);
  if (v4) {
    *((_DWORD *)this + 6) = v4;
  }
  uint64_t v5 = N16ByteAlignedString::allocate(this, &v6);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 2) = v5;
  *(void *)this = &unk_26C99B388;
  memcpy(v5, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

{
  int v4;
  void *v5;
  unsigned int v6;

  *(void *)this = &unk_26C99B388;
  unsigned int v6 = *((_DWORD *)a2 + 2);
  int v4 = *((_DWORD *)a2 + 6);
  if (v4) {
    *((_DWORD *)this + 6) = v4;
  }
  uint64_t v5 = N16ByteAlignedString::allocate(this, &v6);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 2) = v5;
  *(void *)this = &unk_26C99B388;
  memcpy(v5, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this, const NString *a2)
{
  *(void *)this = &unk_26C99B388;
  unsigned int v5 = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 6) = 16;
  int v4 = N16ByteAlignedString::allocate(this, &v5);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 2) = v4;
  *(void *)this = &unk_26C99B388;
  memcpy(v4, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

{
  void *v4;
  unsigned int v5;

  *(void *)this = &unk_26C99B388;
  unsigned int v5 = *((_DWORD *)a2 + 2);
  *((_DWORD *)this + 6) = 16;
  int v4 = N16ByteAlignedString::allocate(this, &v5);
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((void *)this + 2) = v4;
  *(void *)this = &unk_26C99B388;
  memcpy(v4, *((const void **)a2 + 2), (*((_DWORD *)a2 + 2) + 1));
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this, const char *__s)
{
  *((_DWORD *)this + 2) = 0;
  uint64_t v3 = (const unsigned int *)((char *)this + 8);
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C99B388;
  if (!__s) {
    Error::chuck((Error *)"Null pointer passed to string constructor", 0);
  }
  *((_DWORD *)this + 2) = strlen(__s);
  *((_DWORD *)this + 6) = 16;
  unsigned int v5 = N16ByteAlignedString::allocate(this, v3);
  *((void *)this + 2) = v5;
  memcpy(v5, __s, (*((_DWORD *)this + 2) + 1));
}

{
  const unsigned int *v3;
  void *v5;

  *((_DWORD *)this + 2) = 0;
  uint64_t v3 = (const unsigned int *)((char *)this + 8);
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C99B388;
  if (!__s) {
    Error::chuck((Error *)"Null pointer passed to string constructor", 0);
  }
  *((_DWORD *)this + 2) = strlen(__s);
  *((_DWORD *)this + 6) = 16;
  unsigned int v5 = N16ByteAlignedString::allocate(this, v3);
  *((void *)this + 2) = v5;
  memcpy(v5, __s, (*((_DWORD *)this + 2) + 1));
}

void sub_2184F6330(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_26C99C5B0;
  uint64_t v3 = v1[2];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_2184F6418(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_26C99C5B0;
  uint64_t v3 = v1[2];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void N16ByteAlignedString::N16ByteAlignedString(N16ByteAlignedString *this, const char *a2, const unsigned int *a3)
{
  *((_DWORD *)this + 2) = 0;
  unsigned int v5 = (char *)this + 8;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C99B388;
  if (!a2) {
    Error::chuck((Error *)"Null pointer passed to string constructor", v5, a3);
  }
  *((_DWORD *)this + 2) = *a3;
  *((_DWORD *)this + 6) = 16;
  uint64_t v7 = N16ByteAlignedString::allocate(this, (const unsigned int *)v5);
  *((void *)this + 2) = v7;
  memcpy(v7, a2, *a3);
  *(unsigned char *)(*((void *)this + 2) + *((unsigned int *)this + 2)) = 0;
}

{
  const char *v5;
  void *v7;

  *((_DWORD *)this + 2) = 0;
  unsigned int v5 = (char *)this + 8;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C99B388;
  if (!a2) {
    Error::chuck((Error *)"Null pointer passed to string constructor", v5, a3);
  }
  *((_DWORD *)this + 2) = *a3;
  *((_DWORD *)this + 6) = 16;
  uint64_t v7 = N16ByteAlignedString::allocate(this, (const unsigned int *)v5);
  *((void *)this + 2) = v7;
  memcpy(v7, a2, *a3);
  *(unsigned char *)(*((void *)this + 2) + *((unsigned int *)this + 2)) = 0;
}

{
  const char *v6;
  void *v7;
  size_t v8;
  void *memptr;

  *(void *)this = &unk_26C99B388;
  *((_DWORD *)this + 6) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, *a3 + 1, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v6, *a3 + 1, *((unsigned int *)this + 6));
  }
  uint64_t v7 = memptr;
  uint64_t v8 = *a3;
  *((_DWORD *)this + 2) = v8;
  *((void *)this + 2) = v7;
  *(void *)this = &unk_26C99B388;
  memset(v7, *(unsigned __int8 *)a2, v8);
  *(unsigned char *)(*((void *)this + 2) + *((unsigned int *)this + 2)) = 0;
}

{
  const char *v6;
  void *v7;
  size_t v8;
  void *memptr;

  *(void *)this = &unk_26C99B388;
  *((_DWORD *)this + 6) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, *a3 + 1, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v6, *a3 + 1, *((unsigned int *)this + 6));
  }
  uint64_t v7 = memptr;
  uint64_t v8 = *a3;
  *((_DWORD *)this + 2) = v8;
  *((void *)this + 2) = v7;
  *(void *)this = &unk_26C99B388;
  memset(v7, *(unsigned __int8 *)a2, v8);
  *(unsigned char *)(*((void *)this + 2) + *((unsigned int *)this + 2)) = 0;
}

void sub_2184F6504(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_26C99C5B0;
  uint64_t v3 = v1[2];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_2184F65F0(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = &unk_26C99C5B0;
  uint64_t v3 = v1[2];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t N16ByteAlignedString::setAlignment(uint64_t this, unsigned int *a2)
{
  unsigned int v2 = *a2;
  if (*a2) {
    *(_DWORD *)(this + 24) = v2;
  }
  else {
    unsigned int v2 = *(_DWORD *)(this + 24);
  }
  if (*(void *)(this + 16) % (unint64_t)v2)
  {
    int v3 = *(_DWORD *)(this + 8);
    return (*(uint64_t (**)(uint64_t))(*(void *)this + 64))(this);
  }
  return this;
}

void sub_2184F9B34(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 216), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4632(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4633(uint64_t a1)
{
}

void sub_2184FD310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_2184FEA50(_Unwind_Exception *a1)
{
  unsigned int v6 = v5;

  _Unwind_Resume(a1);
}

void sub_2184FEC38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184FED14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  if (a2 == 3)
  {
    unint64_t v10 = __cxa_begin_catch(exception_object);
    uint64_t v11 = (void *)VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(uint64_t (**)(void *))(*(void *)v10 + 16);
      uint64_t v17 = v11;
      uint64_t v18 = v16(v10);
      LODWORD(a9) = 136446210;
      *(void *)((char *)&a9 + 4) = v18;
      _os_log_error_impl(&dword_21844F000, v17, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&a9, 0xCu);
    }
  }
  else
  {
    unint64_t v12 = __cxa_begin_catch(exception_object);
    uint64_t v13 = VTLogContextFacilityVoiceTrigger;
    if (a2 == 2)
    {
      long long v14 = v12;
      uint64_t v15 = (id)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = v14[2];
        LODWORD(a9) = 136446210;
        *(void *)((char *)&a9 + 4) = v19;
        _os_log_error_impl(&dword_21844F000, v15, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&a9, 0xCu);
      }

      __cxa_end_catch();
LABEL_14:
      JUMPOUT(0x2184FECD8);
    }
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(a9) = 0;
      _os_log_error_impl(&dword_21844F000, v13, OS_LOG_TYPE_ERROR, "unknown reason", (uint8_t *)&a9, 2u);
    }
  }
  __cxa_end_catch();
  goto LABEL_14;
}

void sub_2184FEFB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184FF0D4(_Unwind_Exception *a1)
{
  int v3 = v2;

  _Unwind_Resume(a1);
}

void sub_2184FF1F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184FF32C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184FF574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184FF5F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184FF66C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2184FF770(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, long long buf)
{
  if (a2)
  {
    if (a2 == 3)
    {
      unint64_t v12 = __cxa_begin_catch(a1);
      uint64_t v13 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        long long v14 = *(uint64_t (**)(void *))(*(void *)v12 + 16);
        uint64_t v15 = v13;
        uint64_t v16 = v14(v12);
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v16;
        _os_log_error_impl(&dword_21844F000, v15, OS_LOG_TYPE_ERROR, "Could not get SAT vector count : %{public}s", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      uint64_t v17 = __cxa_begin_catch(a1);
      uint64_t v18 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        uint64_t v19 = v17;
        uint64_t v20 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          uint64_t v21 = v19[2];
          LODWORD(buf) = 136446210;
          *(void *)((char *)&buf + 4) = v21;
          _os_log_error_impl(&dword_21844F000, v20, OS_LOG_TYPE_ERROR, "Could not get SAT vector count : %{public}s", (uint8_t *)&buf, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        _os_log_error_impl(&dword_21844F000, v18, OS_LOG_TYPE_ERROR, "Could not get SAT vector count : unknown reason", (uint8_t *)&buf, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x2184FF720);
  }
  _Unwind_Resume(a1);
}

void sub_2184FF930(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9)
{
  if (a2)
  {
    if (a2 == 3)
    {
      unint64_t v10 = __cxa_begin_catch(a1);
      uint64_t v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        unint64_t v12 = *(uint64_t (**)(void *))(*(void *)v10 + 16);
        uint64_t v13 = v11;
        uint64_t v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(void *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_21844F000, v13, OS_LOG_TYPE_ERROR, "Could not delete SAT vector : %{public}s", (uint8_t *)&a9, 0xCu);
      }
    }
    else
    {
      uint64_t v15 = __cxa_begin_catch(a1);
      uint64_t v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        uint64_t v17 = v15;
        uint64_t v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(void *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_21844F000, v18, OS_LOG_TYPE_ERROR, "Could not delete SAT vector  : %{public}s", (uint8_t *)&a9, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_21844F000, v16, OS_LOG_TYPE_ERROR, "Could not delete SAT vector  : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x2184FF900);
  }
  _Unwind_Resume(a1);
}

void sub_2184FFAF0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9)
{
  if (a2)
  {
    if (a2 == 3)
    {
      unint64_t v10 = __cxa_begin_catch(a1);
      uint64_t v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        unint64_t v12 = *(uint64_t (**)(void *))(*(void *)v10 + 16);
        uint64_t v13 = v11;
        uint64_t v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(void *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_21844F000, v13, OS_LOG_TYPE_ERROR, "Could not get score of super vector : %{public}s", (uint8_t *)&a9, 0xCu);
      }
    }
    else
    {
      uint64_t v15 = __cxa_begin_catch(a1);
      uint64_t v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        uint64_t v17 = v15;
        uint64_t v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(void *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_21844F000, v18, OS_LOG_TYPE_ERROR, "Could not get score of super vector : %{public}s", (uint8_t *)&a9, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_21844F000, v16, OS_LOG_TYPE_ERROR, "Could not get score of super vector : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x2184FFAC0);
  }
  _Unwind_Resume(a1);
}

void sub_2184FFCAC(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9)
{
  if (a2)
  {
    if (a2 == 3)
    {
      unint64_t v10 = __cxa_begin_catch(a1);
      uint64_t v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        unint64_t v12 = *(uint64_t (**)(void *))(*(void *)v10 + 16);
        uint64_t v13 = v11;
        uint64_t v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(void *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_21844F000, v13, OS_LOG_TYPE_ERROR, "Could not update sat : %{public}s", (uint8_t *)&a9, 0xCu);
      }
    }
    else
    {
      uint64_t v15 = __cxa_begin_catch(a1);
      uint64_t v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        uint64_t v17 = v15;
        uint64_t v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(void *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_21844F000, v18, OS_LOG_TYPE_ERROR, "Could not update sat : %{public}s", (uint8_t *)&a9, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_21844F000, v16, OS_LOG_TYPE_ERROR, "Could not update sat : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x2184FFC7CLL);
  }
  _Unwind_Resume(a1);
}

void sub_2185000C4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9)
{
  if (a2)
  {
    if (a2 == 3)
    {
      unint64_t v10 = __cxa_begin_catch(a1);
      uint64_t v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        unint64_t v12 = *(uint64_t (**)(void *))(*(void *)v10 + 16);
        uint64_t v13 = v11;
        uint64_t v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(void *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_21844F000, v13, OS_LOG_TYPE_ERROR, "Could not get super vector : %{public}s", (uint8_t *)&a9, 0xCu);
      }
    }
    else
    {
      uint64_t v15 = __cxa_begin_catch(a1);
      uint64_t v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        uint64_t v17 = v15;
        uint64_t v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(void *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_21844F000, v18, OS_LOG_TYPE_ERROR, "Could not get super vector : %{public}s", (uint8_t *)&a9, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_21844F000, v16, OS_LOG_TYPE_ERROR, "Could not get super vector : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x218500094);
  }
  _Unwind_Resume(a1);
}

void sub_218500424(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_218500710(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9)
{
  if (a2)
  {
    if (a2 == 3)
    {
      unint64_t v10 = __cxa_begin_catch(a1);
      uint64_t v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        unint64_t v12 = *(uint64_t (**)(void *))(*(void *)v10 + 16);
        uint64_t v13 = v11;
        uint64_t v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(void *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_21844F000, v13, OS_LOG_TYPE_ERROR, "Could not analize wavdata : %{public}s", (uint8_t *)&a9, 0xCu);
      }
    }
    else
    {
      uint64_t v15 = __cxa_begin_catch(a1);
      uint64_t v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        uint64_t v17 = v15;
        uint64_t v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(void *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_21844F000, v18, OS_LOG_TYPE_ERROR, "Could not analize wavdata : %{public}s", (uint8_t *)&a9, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_21844F000, v16, OS_LOG_TYPE_ERROR, "Could not analize wavdata : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x2185006E0);
  }
  _Unwind_Resume(a1);
}

void sub_2185008D4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9)
{
  if (a2)
  {
    if (a2 == 3)
    {
      unint64_t v10 = __cxa_begin_catch(a1);
      uint64_t v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        unint64_t v12 = *(uint64_t (**)(void *))(*(void *)v10 + 16);
        uint64_t v13 = v11;
        uint64_t v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(void *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_21844F000, v13, OS_LOG_TYPE_ERROR, "Could not analyze wavdata : %{public}s", (uint8_t *)&a9, 0xCu);
      }
    }
    else
    {
      uint64_t v15 = __cxa_begin_catch(a1);
      uint64_t v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        uint64_t v17 = v15;
        uint64_t v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(void *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_21844F000, v18, OS_LOG_TYPE_ERROR, "Could not analyze wavdata : %{public}s", (uint8_t *)&a9, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_21844F000, v16, OS_LOG_TYPE_ERROR, "Could not analyze wavdata : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x2185008A4);
  }
  _Unwind_Resume(a1);
}

void sub_218500A8C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9)
{
  if (a2)
  {
    if (a2 == 3)
    {
      unint64_t v10 = __cxa_begin_catch(a1);
      uint64_t v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        unint64_t v12 = *(uint64_t (**)(void *))(*(void *)v10 + 16);
        uint64_t v13 = v11;
        uint64_t v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(void *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_21844F000, v13, OS_LOG_TYPE_ERROR, "Could not resetbest NDAPI : %{public}s", (uint8_t *)&a9, 0xCu);
      }
    }
    else
    {
      uint64_t v15 = __cxa_begin_catch(a1);
      uint64_t v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        uint64_t v17 = v15;
        uint64_t v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(void *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_21844F000, v18, OS_LOG_TYPE_ERROR, "Could not resetbest NDAPI : %{public}s", (uint8_t *)&a9, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_21844F000, v16, OS_LOG_TYPE_ERROR, "Could not resetbest NDAPI : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x218500A5CLL);
  }
  _Unwind_Resume(a1);
}

void sub_218500C44(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9)
{
  if (a2)
  {
    if (a2 == 3)
    {
      unint64_t v10 = __cxa_begin_catch(a1);
      uint64_t v11 = (void *)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        unint64_t v12 = *(uint64_t (**)(void *))(*(void *)v10 + 16);
        uint64_t v13 = v11;
        uint64_t v14 = v12(v10);
        LODWORD(a9) = 136446210;
        *(void *)((char *)&a9 + 4) = v14;
        _os_log_error_impl(&dword_21844F000, v13, OS_LOG_TYPE_ERROR, "Could not reset NDAPI : %{public}s", (uint8_t *)&a9, 0xCu);
      }
    }
    else
    {
      uint64_t v15 = __cxa_begin_catch(a1);
      uint64_t v16 = VTLogContextFacilityVoiceTrigger;
      if (a2 == 2)
      {
        uint64_t v17 = v15;
        uint64_t v18 = (id)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          uint64_t v19 = v17[2];
          LODWORD(a9) = 136446210;
          *(void *)((char *)&a9 + 4) = v19;
          _os_log_error_impl(&dword_21844F000, v18, OS_LOG_TYPE_ERROR, "Could not reset NDAPI : %{public}s", (uint8_t *)&a9, 0xCu);
        }
      }
      else if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
      {
        LOWORD(a9) = 0;
        _os_log_error_impl(&dword_21844F000, v16, OS_LOG_TYPE_ERROR, "Could not reset NDAPI : unknown reason", (uint8_t *)&a9, 2u);
      }
    }
    __cxa_end_catch();
    JUMPOUT(0x218500C14);
  }
  _Unwind_Resume(a1);
}

void sub_218500F5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void NConfigSection::NConfigSection(NConfigSection *this, const NString *a2)
{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  operator new[]();
}

{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  operator new[]();
}

void sub_21850156C(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[2];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_21850165C(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[2];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NConfigSection::sOpt(NConfigSection *this, const NString *a2)
{
}

void NMap<NString,NString>::contains()
{
}

void sub_218501938(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a18) {
    MEMORY[0x21D46B220](a18, 0x1000C8077774924);
  }
  if (a15) {
    MEMORY[0x21D46B220](a15, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_218501C08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (a15) {
    MEMORY[0x21D46B220](a15, 0x1000C8077774924);
  }
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NConfigSection::iOpt(NConfigSection *this, const NString *a2)
{
}

void NConfigSection::fOpt(NConfigSection *this, const NString *a2)
{
}

void NConfigSection::bOpt(NConfigSection *this, const NString *a2)
{
}

void NConfigSection::sOptDefault(NConfigSection *this, const NString *a2, const NString *a3)
{
}

void NConfigSection::hasOpt(NConfigSection *this, const NString *a2)
{
}

void NConfigSection::iOptDefault(NConfigSection *this, const NString *a2, const int *a3)
{
}

void NConfigSection::fOptDefault(NConfigSection *this, const NString *a2, const float *a3)
{
}

void NConfigSection::bOptDefault(NConfigSection *this, const NString *a2, const BOOL *a3)
{
}

void NConfigSection::setOpt(NConfigSection *this, const NString *a2, const NString *a3)
{
}

void NConfigSection::appendOpt(NConfigSection *this, const NString *a2, const NString *a3)
{
}

void NConfig::NConfig(NConfig *this, const BOOL *a2)
{
  *(void *)this = &unk_26C99BD10;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0xB00000000;
  *((void *)this + 1) = &unk_26C99BE08;
  NArray<NLinkedList<NMap<NString,NConfigSection>::HashItem>>::resize((uint64_t)this + 8, (_DWORD *)this + 7);
  *((_DWORD *)this + 8) = 0;
  *((unsigned char *)this + 40) = *a2;
  if (*a2) {
    operator new[]();
  }
}

void sub_21850264C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  NConfigSection::~NConfigSection((NConfigSection *)va);
  if (a7) {
    MEMORY[0x21D46B220](a7, 0x1000C8077774924);
  }
  NMap<NString,NConfigSection>::~NMap(v7);
  _Unwind_Resume(a1);
}

void NMap<NString,NConfigSection>::operator[]()
{
}

void sub_218502D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a25) {
    MEMORY[0x21D46B220](a25, 0x1000C8077774924);
  }
  if (a22) {
    MEMORY[0x21D46B220](a22, 0x1000C8077774924);
  }
  NConfigSection::~NConfigSection((NConfigSection *)&a12);
  if (a11)
  {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void *NMap<NString,NConfigSection>::HashItem::~HashItem(void *a1)
{
  a1[6] = &unk_26C99BD30;
  a1[7] = &unk_26C99BF20;
  uint64_t v2 = a1[8];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A700;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  a1[3] = &unk_26C99C5B0;
  uint64_t v7 = a1[5];
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  *a1 = &unk_26C99C5B0;
  uint64_t v8 = a1[2];
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8077774924);
  }
  return a1;
}

void NHash<NMap<NString,NConfigSection>::HashItem>::~NHash(void *a1)
{
  *a1 = &unk_26C99BEE8;
  uint64_t v1 = a1[1];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 - 8);
    if (v2)
    {
      uint64_t v3 = v1 + 32 * v2;
      do
      {
        uint64_t v4 = v3 - 32;
        for (*(void *)(v3 - 32) = &unk_26C99A6A0;
              ;
              (*(void (**)(uint64_t))(*(void *)(v3 - 32) + 72))(v3 - 32))
        {
          uint64_t v5 = *(void *)(v3 - 24);
          if (!v5) {
            break;
          }
          *(void *)(v3 - 24) = *(void *)(v5 + 8);
        }
        *(void *)(v3 - 16) = 0;
        *(_DWORD *)(v3 - 8) = 0;
        v3 -= 32;
      }
      while (v4 != v1);
    }
    MEMORY[0x21D46B220](v1 - 16, 0x10A1C80F4A7E088);
  }

  JUMPOUT(0x21D46B240);
}

void *NHash<NMap<NString,NConfigSection>::HashItem>::~NHash(void *a1)
{
  *a1 = &unk_26C99BEE8;
  uint64_t v2 = a1[1];
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 - 8);
    if (v3)
    {
      uint64_t v4 = v2 + 32 * v3;
      do
      {
        uint64_t v5 = v4 - 32;
        for (*(void *)(v4 - 32) = &unk_26C99A6A0;
              ;
              (*(void (**)(uint64_t))(*(void *)(v4 - 32) + 72))(v4 - 32))
        {
          uint64_t v6 = *(void *)(v4 - 24);
          if (!v6) {
            break;
          }
          *(void *)(v4 - 24) = *(void *)(v6 + 8);
        }
        *(void *)(v4 - 16) = 0;
        *(_DWORD *)(v4 - 8) = 0;
        v4 -= 32;
      }
      while (v5 != v2);
    }
    MEMORY[0x21D46B220](v2 - 16, 0x10A1C80F4A7E088);
  }
  return a1;
}

void NConfig::load(NConfig *this, const NString *a2, const NString *a3)
{
  uint64_t v3 = &unk_26C99C5B0;
  int v4 = 1;
  operator new[]();
}

void sub_218503378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 8))(a13);
  }
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NConfig::loadString(NConfig *this, const NString *a2, const NString *a3, const NString *a4)
{
}

void sub_218505810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (a47) {
    MEMORY[0x21D46B220](a47, 0x1000C8077774924);
  }
  if (a32) {
    MEMORY[0x21D46B220](a32, 0x1000C8077774924);
  }
  if (a53) {
    MEMORY[0x21D46B220](a53, 0x1000C8077774924);
  }
  if (a56) {
    MEMORY[0x21D46B220](a56, 0x1000C8077774924);
  }
  NArray<NString>::~NArray(&a57);
  a66 = a16;
  if (a68) {
    MEMORY[0x21D46B220](a68, 0x1000C8077774924);
  }
  a61 = a17;
  if (a63) {
    MEMORY[0x21D46B220](a63, 0x1000C8077774924);
  }
  *(void *)(v68 - 192) = a19;
  uint64_t v70 = *(void *)(v68 - 176);
  if (v70) {
    MEMORY[0x21D46B220](v70, 0x1000C8077774924);
  }
  *(void *)(v68 - 168) = a20;
  uint64_t v71 = *(void *)(v68 - 152);
  if (v71) {
    MEMORY[0x21D46B220](v71, 0x1000C8077774924);
  }
  *(void *)(v68 - 144) = a21;
  uint64_t v72 = *(void *)(v68 - 128);
  if (v72) {
    MEMORY[0x21D46B220](v72, 0x1000C8077774924);
  }
  *(void *)(v68 - 120) = a18;
  uint64_t v73 = *(void *)(v68 - 104);
  if (v73) {
    MEMORY[0x21D46B220](v73, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void *NStringSplitIterator::operator++(uint64_t *a1, const char *a2)
{
  uint64_t v2 = *a1;
  if (!*a1) {
    Error::chuck((Error *)"NStringSplitIterator::operator++() - input string unset", a2);
  }
  int v4 = (unsigned int *)a1 + 9;
  uint64_t v5 = *((unsigned int *)a1 + 9);
  uint64_t v6 = (void *)a1[3];
  size_t v7 = *((unsigned int *)a1 + 4);
  uint64_t v8 = *(unsigned int *)(v2 + 8);
  int v9 = *((unsigned __int8 *)a1 + 32);
  if (*((unsigned char *)a1 + 32)) {
    BOOL v10 = 1;
  }
  else {
    BOOL v10 = v5 >= v8;
  }
  if (v10)
  {
LABEL_7:
    unsigned int v26 = v5;
    if (v5 < v8)
    {
      uint64_t v5 = v5;
      uint64_t v11 = *(void *)(v2 + 16);
      do
      {
        if (memchr(v6, *(char *)(v11 + v5), v7)) {
          break;
        }
        *int v4 = ++v5;
      }
      while (v8 != v5);
      *((unsigned char *)a1 + 40) = 1;
LABEL_23:
      NString::slice((NString *)v2, &v26, v4, (uint64_t)v25);
    }
  }
  else
  {
    uint64_t v12 = *(void *)(v2 + 16);
    do
    {
      if (!memchr(v6, *(char *)(v12 + v5), v7)) {
        goto LABEL_7;
      }
      *int v4 = ++v5;
    }
    while (v8 != v5);
    unsigned int v26 = v8;
    LODWORD(v5) = v8;
  }
  if (v9) {
    BOOL v13 = v5 == v8;
  }
  else {
    BOOL v13 = 0;
  }
  char v14 = v13;
  *((unsigned char *)a1 + 40) = v14;
  if (v13) {
    goto LABEL_23;
  }
  LODWORD(v25[0]) = 0;
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t *, const char *, void *))(a1[6] + 64))(a1 + 6, "", v25);
  uint64_t v17 = *((unsigned int *)a1 + 9);
  if (*((unsigned char *)a1 + 33) && v17 < v8)
  {
    unsigned int v18 = *(_DWORD *)(*a1 + 8);
    if (v17 >= v18) {
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v16, *((unsigned int *)a1 + 9), v18 - 1, v25[0]);
    }
    uint64_t v19 = *(void *)(*a1 + 16);
    int v20 = *(unsigned __int8 *)(v19 + v17);
    uint64_t v21 = (v8 - 1);
    uint64_t v22 = v18 - 1;
    uint64_t v23 = v19 + 1;
    do
    {
      *int v4 = v17 + 1;
      if (v21 == v17) {
        break;
      }
      if (v22 == v17) {
        Error::chuck((Error *)"Index %d outside of range [0,%d]", v16, v17 + 1, v22, v25[0]);
      }
      int v24 = *(unsigned __int8 *)(v23 + v17);
      if (v24 == v20) {
        break;
      }
      uint64_t result = memchr(v6, (char)v24, v7);
      ++v17;
    }
    while (result);
  }
  else
  {
    *int v4 = v17 + 1;
  }
  return result;
}

void sub_218506120(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NMap<NString,NConfigSection>::contains()
{
}

void sub_218506624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  NMap<NString,NConfigSection>::HashItem::~HashItem((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_218506638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (a26) {
    MEMORY[0x21D46B220](a26, 0x1000C8077774924);
  }
  if (a23) {
    MEMORY[0x21D46B220](a23, 0x1000C8077774924);
  }
  NConfigSection::~NConfigSection((NConfigSection *)&a13);
  if (!a12) {
    _Unwind_Resume(a1);
  }
  MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  _Unwind_Resume(a1);
}

void NConfig::section(NConfig *this, const NString *a2)
{
}

void sub_218506BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (a26) {
    MEMORY[0x21D46B220](a26, 0x1000C8077774924);
  }
  if (a23) {
    MEMORY[0x21D46B220](a23, 0x1000C8077774924);
  }
  NConfigSection::~NConfigSection((NConfigSection *)&a13);
  if (a12)
  {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void AccelFFT::~AccelFFT(vDSP_DFT_SetupStruct **this)
{
  uint64_t v2 = *this;
  if (v2) {
    vDSP_DFT_DestroySetup(v2);
  }
  this[3] = (vDSP_DFT_SetupStruct *)&unk_26C99C348;
  uint64_t v3 = this[4];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
}

{
  vDSP_DFT_SetupStruct *v2;
  vDSP_DFT_SetupStruct *v3;

  uint64_t v2 = *this;
  if (v2) {
    vDSP_DFT_DestroySetup(v2);
  }
  this[3] = (vDSP_DFT_SetupStruct *)&unk_26C99C348;
  uint64_t v3 = this[4];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8052888210);
  }
}

vDSP_DFT_Setup AccelFFT::init(vDSP_DFT_SetupStruct **this, const char *a2, unsigned int *a3, const unsigned int *a4)
{
  uint64_t v4 = *(unsigned int *)a2;
  unsigned int v5 = *a3;
  uint64_t v6 = *a4;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7 || v6 == 0) {
    Error::chuck((Error *)"AccelFFT::init() - these lengths have to be strictly positive: a_iWindowLen (=%u), a_iDFTLen (=%u) and a_iNPoints (=%u)", a2, v4, *a3, v6);
  }
  uint64_t v12 = *this;
  if (v12)
  {
    vDSP_DFT_DestroySetup(v12);
    unsigned int v5 = *a3;
  }
  *((_DWORD *)this + 3) = v5;
  *((_DWORD *)this + 5) = *a4;
  *((_DWORD *)this + 4) = *(_DWORD *)a2;
  if (*((_DWORD *)this + 10) != v5)
  {
    *((_DWORD *)this + 10) = v5;
    operator new[]();
  }
  vDSP_DFT_Setup result = vDSP_DFT_zrop_CreateSetup(0, v5, vDSP_DFT_FORWARD);
  *this = result;
  *((unsigned char *)this + 8) = 1;
  return result;
}

void AccelFFT::zeroPadData(uint64_t a1, uint64_t a2)
{
  memcpy(*(void **)(a1 + 32), *(const void **)(a2 + 8), 4 * *(unsigned int *)(a1 + 16));
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = (void *)(*(void *)(a1 + 32) + 4 * v3);
  size_t v5 = 4 * (*(_DWORD *)(a1 + 12) - v3);

  bzero(v4, v5);
}

void AccelFFT::run(uint64_t a1, uint64_t a2, const DSPSplitComplex *a3)
{
  if (!*(unsigned char *)(a1 + 8)) {
    Error::chuck((Error *)"AccelFFT::run() - You need to call AccelFFT::init() before running the FFT", (const char *)a2);
  }
  uint64_t v4 = *(unsigned int *)(a2 + 16);
  if (v4 != *(_DWORD *)(a1 + 16)) {
    Error::chuck((Error *)"AccelFFT::run() - length of input array should be %d, not %d", (const char *)a2, *(unsigned int *)(a1 + 16), v4);
  }
  memcpy(*(void **)(a1 + 32), *(const void **)(a2 + 8), 4 * v4);
  bzero((void *)(*(void *)(a1 + 32) + 4 * *(unsigned int *)(a1 + 16)), 4 * (*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 16)));
  vDSP_ctoz(*(const DSPComplex **)(a1 + 32), 2, a3, 1, (unint64_t)*(unsigned int *)(a1 + 12) >> 1);
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)a1, a3->realp, a3->imagp, a3->realp, a3->imagp);
  float __B = 0.5;
  vDSP_vsmul(a3->realp, 1, &__B, a3->realp, 1, (unint64_t)*(unsigned int *)(a1 + 12) >> 1);
  vDSP_vsmul(a3->imagp, 1, &__B, a3->imagp, 1, (unint64_t)*(unsigned int *)(a1 + 12) >> 1);
}

void sub_2185075EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void Error::error(Error *this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v3 = (FILE **)MEMORY[0x263EF8348];
  fwrite("ERROR: ", 7uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  vfprintf(*v3, (const char *)this, va);
  fputc(10, *v3);
  exit(1);
}

uint64_t Error::warning(Error *this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v3 = (FILE **)MEMORY[0x263EF8348];
  fwrite("WARNING: ", 9uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  vfprintf(*v3, (const char *)this, va);
  return fputc(10, *v3);
}

void Error::chuck(Error *this, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v4 = *MEMORY[0x263EF8340];
  vsnprintf(__str, 0x3FFuLL, (const char *)this, va);
  exception = (NString *)__cxa_allocate_exception(0x18uLL);
  NString::NString(exception, __str);
}

void sub_218509244(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL sanity_check_model(uint64_t a1, unint64_t a2, unsigned int *a3)
{
  if (*(_DWORD *)a1 != 1330397763 || *(_DWORD *)(a1 + 4) != 171013698) {
    return 0;
  }
  uint64_t v3 = 0;
  if (!(a2 >> 30) && *(_DWORD *)(a1 + 8) == 2)
  {
    int v4 = *(_DWORD *)(a1 + 28);
    unint64_t v6 = *(unsigned int *)(a1 + 12);
    unint64_t v5 = *(unsigned int *)(a1 + 16);
    unint64_t v7 = *(unsigned int *)(a1 + 20);
    unsigned int v8 = *(_DWORD *)(a1 + 24);
    unsigned int v10 = *(_DWORD *)(a1 + 32);
    int v9 = *(_DWORD *)(a1 + 36);
    unsigned int v12 = *(_DWORD *)(a1 + 40);
    int v11 = *(_DWORD *)(a1 + 44);
    uint64_t v3 = (v5 | v6 | v7 | v8 | v4 | v10 | v9 | v12 | v11) >> 30;
    if (v3) {
      return 0;
    }
    if (v8 >= v7 && v6 + 44 <= v5 && v5 + 68 <= v7 && v10 >= v4 + v8)
    {
      unint64_t v13 = v9 + v10;
      if (v12 >= v13 && v11 + v12 <= a2)
      {
        int v14 = 0;
        int v15 = -2;
        int v16 = 0;
        if (v6 <= a2 && a2 >= 0x30 && v13 <= a2)
        {
          if (v6 >= 0x40 && *(_DWORD *)(a1 + 48) == 1919706177)
          {
            int v15 = 0;
            int v16 = *(_DWORD *)(a1 + 52);
            unint64_t v17 = 52;
            unsigned int v18 = 52;
LABEL_20:
            unsigned int v19 = 0;
            unsigned int v20 = 0;
            int v21 = 67;
            unint64_t v22 = 1;
            unsigned int v23 = 1;
            while (1)
            {
              v23 += v21;
              v20 += v23;
              if (v19 <= 0xFFE && v22 < v17)
              {
                ++v19;
              }
              else
              {
                v23 %= 0xFFF1u;
                v20 %= 0xFFF1u;
                if (v22 >= v17) {
                  goto LABEL_28;
                }
                unsigned int v19 = 0;
              }
              int v21 = *(unsigned __int8 *)(a1 + v22++);
            }
          }
          int v16 = 0;
          int v15 = -1;
          if (v13)
          {
            unint64_t v17 = v13;
            unsigned int v18 = v13;
            goto LABEL_20;
          }
          unsigned int v23 = 1;
          unsigned int v18 = 0;
          unsigned int v20 = 0;
LABEL_28:
          if (v18 >= v13)
          {
            int v14 = v23 | (v20 << 16);
          }
          else
          {
            unsigned int v24 = (v20 + 4 * v23) % 0xFFF1;
            uint64_t v25 = v18 + 4;
            unint64_t v26 = (v13 - v25);
            if (v26)
            {
              unsigned int v28 = 0;
              uint64_t v29 = 0;
              uint64_t v30 = a1 + v25;
              while (1)
              {
                while (1)
                {
                  v23 += *(unsigned __int8 *)(v30 + v29);
                  v24 += v23;
                  unint64_t v31 = v29 + 1;
                  if (v28 > 0xFFE || v31 >= v26) {
                    break;
                  }
                  ++v28;
                  ++v29;
                }
                v23 %= 0xFFF1u;
                v24 %= 0xFFF1u;
                if (v31 >= v26) {
                  break;
                }
                unsigned int v28 = 0;
                ++v29;
              }
            }
            int v14 = v23 | (v24 << 16);
          }
        }
        if (a3) {
          *a3 = v14;
        }
        if (v15 == -1 || !v15 && v14 == v16) {
          return NDeepnetDistribution::verifyMemoryImage((NDeepnetDistribution *)(a1 + *(unsigned int *)(a1 + 24)), (const char *)(a1 + 28), a3) == 0;
        }
        return 0;
      }
    }
  }
  return v3;
}

uint64_t _nde_create(unsigned char *a1, unint64_t a2)
{
  if (NMemPool::m_bLocked)
  {
    unsigned int v5 = 0;
    if (sanity_check_model((uint64_t)a1, a2, &v5)
      && (!a1[*((unsigned int *)a1 + 3) + 40]
       || (unint64_t)*((unsigned int *)a1 + 5) + 12 <= *((unsigned int *)a1 + 6)))
    {
      size_t v4 = *((unsigned int *)a1 + 11);
      if (!(v4 >> 30))
      {
        NMemPool::m_pData = (uint64_t)&a1[*((unsigned int *)a1 + 10)];
        NMemPool::m_iSize = v4;
        NMemPool::m_iAlignBytes = 16;
        NMemPool::m_bLocked = 0;
        NMemPool::m_iPos = 0;
        bzero((void *)NMemPool::m_pData, v4);
        operator new();
      }
      Error::chuck((Error *)"NMemPool::init - pool size too large", (const char *)v4);
    }
  }
  return 0;
}

void sub_218509960(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  *(unsigned char *)(v1 + 2728) = 1;
  JUMPOUT(0x21850992CLL);
}

void sub_218509974(_Unwind_Exception *a1)
{
  MEMORY[0x21D46B240](v1, 0x10F0C401ECB8852);
  _Unwind_Resume(a1);
}

uint64_t nde_create(unsigned char *a1, unint64_t a2)
{
  uint64_t result = 0;
  if (a2 >= 0x30 && a1 && ((gpNovDetect != 0) & ~gIsMultiInstance) == 0)
  {
    uint64_t result = _nde_create(a1, a2);
    if ((gIsMultiInstance & 1) == 0) {
      gHasValidModel = result != 0;
    }
  }
  return result;
}

uint64_t nde_process(uint64_t a1, const char *a2, signed int a3, char *a4, uint64_t a5)
{
  if (!a4) {
    return 0xFFFFFFFFLL;
  }
  if (!gHasValidModel)
  {
    uint64_t result = 0;
LABEL_18:
    char v10 = 0;
    goto LABEL_19;
  }
  BOOL v7 = a1 == 0;
  if ((gIsMultiInstance & 1) == 0)
  {
    if (a1) {
      BOOL v8 = gpNovDetect == a1;
    }
    else {
      BOOL v8 = 0;
    }
    BOOL v7 = !v8;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (!a5) {
    goto LABEL_18;
  }
  if (!a2) {
    goto LABEL_18;
  }
  if (a3 < 0) {
    goto LABEL_18;
  }
  if (v7) {
    goto LABEL_18;
  }
  __int16 v11 = 0;
  uint64_t result = IntNovDetectE::process(a1, a2, a3, (unsigned char *)&v11 + 1, &v11, a5);
  if (!v11) {
    goto LABEL_18;
  }
  char v10 = 1;
LABEL_19:
  *a4 = v10;
  return result;
}

uint64_t nde_process_v2(uint64_t a1, const char *a2, signed int a3, int *a4, uint64_t a5)
{
  uint64_t v5 = gHasValidModel;
  if (gHasValidModel)
  {
    BOOL v7 = a1 == 0;
    if ((gIsMultiInstance & 1) == 0)
    {
      if (a1) {
        BOOL v8 = gpNovDetect == a1;
      }
      else {
        BOOL v8 = 0;
      }
      BOOL v7 = !v8;
    }
    uint64_t v5 = 0xFFFFFFFFLL;
    if (a5)
    {
      if (a4)
      {
        if (a2)
        {
          if ((a3 & 0x80000000) == 0 && !v7)
          {
            __int16 v11 = 0;
            uint64_t v5 = IntNovDetectE::process(a1, a2, a3, (unsigned char *)&v11 + 1, &v11, a5);
            int v9 = HIBYTE(v11);
            *a4 = HIBYTE(v11);
            if ((_BYTE)v11) {
              *a4 = v9 | 2;
            }
          }
        }
      }
    }
  }
  return v5;
}

uint64_t nde_processframe(uint64_t a1, float32x4_t *a2, unsigned int a3, BOOL *a4, uint64_t a5)
{
  if (!a4) {
    return 0xFFFFFFFFLL;
  }
  char v12 = 0;
  uint64_t v6 = gHasValidModel;
  if (gHasValidModel)
  {
    BOOL v7 = a1 == 0;
    if ((gIsMultiInstance & 1) == 0)
    {
      if (a1) {
        BOOL v8 = gpNovDetect == a1;
      }
      else {
        BOOL v8 = 0;
      }
      BOOL v7 = !v8;
    }
    BOOL v9 = 0;
    uint64_t v6 = 0xFFFFFFFFLL;
    if (a5 && a2 && (a3 & 0x80000000) == 0 && !v7)
    {
      uint64_t v6 = IntNovDetectE::processframe(a1, a2, a3, &v12, &v11, a5);
      BOOL v9 = v12 != 0;
    }
  }
  else
  {
    BOOL v9 = 0;
  }
  *a4 = v9;
  return v6;
}

uint64_t nde_processframe_v2(uint64_t a1, float32x4_t *a2, unsigned int a3, int *a4, uint64_t a5)
{
  __int16 v11 = 0;
  uint64_t v5 = gHasValidModel;
  if (gHasValidModel)
  {
    BOOL v7 = a1 == 0;
    if ((gIsMultiInstance & 1) == 0)
    {
      if (a1) {
        BOOL v8 = gpNovDetect == a1;
      }
      else {
        BOOL v8 = 0;
      }
      BOOL v7 = !v8;
    }
    uint64_t v5 = 0xFFFFFFFFLL;
    if (a5)
    {
      if (a4)
      {
        if (a2)
        {
          if ((a3 & 0x80000000) == 0 && !v7)
          {
            uint64_t v5 = IntNovDetectE::processframe(a1, a2, a3, (unsigned char *)&v11 + 1, &v11, a5);
            int v9 = HIBYTE(v11);
            *a4 = HIBYTE(v11);
            if ((_BYTE)v11) {
              *a4 = v9 | 2;
            }
          }
        }
      }
    }
  }
  return v5;
}

uint64_t nde_getchecksum(uint64_t a1, _DWORD *a2)
{
  if (gIsMultiInstance)
  {
    if (!a1) {
      return 0xFFFFFFFFLL;
    }
LABEL_7:
    uint64_t result = 0;
    *a2 = *(_DWORD *)(a1 + 1096);
    return result;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && gpNovDetect == a1) {
    goto LABEL_7;
  }
  return result;
}

uint64_t nde_reset(IntNovDetectE *a1)
{
  uint64_t v1 = gHasValidModel;
  if (gHasValidModel)
  {
    if (gIsMultiInstance)
    {
      if (!a1) {
        return 0xFFFFFFFFLL;
      }
LABEL_7:
      IntNovDetectE::reset(a1);
      return 0;
    }
    uint64_t v1 = 0xFFFFFFFFLL;
    if (a1 && (IntNovDetectE *)gpNovDetect == a1) {
      goto LABEL_7;
    }
  }
  return v1;
}

uint64_t nde_destroy(IntNovDetectE *a1)
{
  uint64_t v1 = gHasValidModel;
  if (!gHasValidModel)
  {
    gHasValidModel = 1;
    return v1;
  }
  if (gIsMultiInstance)
  {
    if (!a1) {
      return 0xFFFFFFFFLL;
    }
LABEL_8:
    IntNovDetectE::~IntNovDetectE(a1);
    MEMORY[0x21D46B240]();
    uint64_t v1 = 0;
    gpNovDetect = 0;
    return v1;
  }
  uint64_t v1 = 0xFFFFFFFFLL;
  if (a1 && (IntNovDetectE *)gpNovDetect == a1) {
    goto LABEL_8;
  }
  return v1;
}

uint64_t nde_enable_multiinstance()
{
  gpNovDetect = 0;
  gHasValidModel = 1;
  gIsMultiInstance = 1;
  return 0;
}

uint64_t NDBlobBuildBlob(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v9[7] = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    if (a5)
    {
      v7[0] = 0;
      NConfig::NConfig((NConfig *)v9, v7);
      *(void *)BOOL v7 = &unk_26C99C5B0;
      int v8 = strlen(a1);
      operator new[]();
    }
  }
  return result;
}

void sub_21850A42C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, long long buf, uint64_t a20)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  N16ByteAlignedString::~N16ByteAlignedString((void **)&a12);
  *(void *)&buf = &unk_26C99BD10;
  *((void *)&buf + 1) = &unk_26C99BEE8;
  uint64_t v22 = a20;
  if (a20)
  {
    uint64_t v23 = *(void *)(a20 - 8);
    if (v23)
    {
      uint64_t v24 = a20 + 32 * v23;
      do
      {
        uint64_t v25 = v24 - 32;
        for (*(void *)(v24 - 32) = &unk_26C99A6A0;
              ;
              (*(void (**)(uint64_t))(*(void *)(v24 - 32) + 72))(v24 - 32))
        {
          uint64_t v26 = *(void *)(v24 - 24);
          if (!v26) {
            break;
          }
          *(void *)(v24 - 24) = *(void *)(v26 + 8);
        }
        *(void *)(v24 - 16) = 0;
        *(_DWORD *)(v24 - 8) = 0;
        v24 -= 32;
      }
      while (v25 != v22);
    }
    MEMORY[0x21D46B220](v22 - 16, 0x10A1C80F4A7E088);
  }
  if (a2 == 3)
  {
    BOOL v27 = __cxa_begin_catch(exception_object);
    unsigned int v28 = (void *)VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      uint64_t v33 = *(uint64_t (**)(void *))(*(void *)v27 + 16);
      uint64_t v34 = v28;
      uint64_t v35 = v33(v27);
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v35;
      _os_log_error_impl(&dword_21844F000, v34, OS_LOG_TYPE_ERROR, "CorealisRT Blob build failed: %{public}s", (uint8_t *)&buf, 0xCu);
    }
  }
  else
  {
    uint64_t v29 = __cxa_begin_catch(exception_object);
    uint64_t v30 = VTLogContextFacilityVoiceTrigger;
    if (a2 == 2)
    {
      unint64_t v31 = v29;
      unsigned int v32 = (id)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        uint64_t v36 = v31[2];
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v36;
        _os_log_error_impl(&dword_21844F000, v32, OS_LOG_TYPE_ERROR, "CorealisRT Blob build failed: %{public}s", (uint8_t *)&buf, 0xCu);
      }

      __cxa_end_catch();
LABEL_22:
      JUMPOUT(0x21850A3D8);
    }
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_21844F000, v30, OS_LOG_TYPE_ERROR, "CorealisRT Blob build failed: Unknown throw", (uint8_t *)&buf, 2u);
    }
  }
  __cxa_end_catch();
  goto LABEL_22;
}

uint64_t NDBlobGetBlobSize(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  v9[7] = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    if (a5)
    {
      *a5 = 0;
      v7[0] = 0;
      NConfig::NConfig((NConfig *)v9, v7);
      *(void *)BOOL v7 = &unk_26C99C5B0;
      int v8 = strlen(a1);
      operator new[]();
    }
  }
  return result;
}

void sub_21850AA5C(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, long long buf)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  N16ByteAlignedString::~N16ByteAlignedString(&a12);
  NConfig::~NConfig((NConfig *)&buf);
  if (a2 == 3)
  {
    int v21 = __cxa_begin_catch(a1);
    uint64_t v22 = (void *)VTLogContextFacilityVoiceTrigger;
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      BOOL v27 = *(uint64_t (**)(void *))(*(void *)v21 + 16);
      unsigned int v28 = v22;
      uint64_t v29 = v27(v21);
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = v29;
      _os_log_error_impl(&dword_21844F000, v28, OS_LOG_TYPE_ERROR, "Failed to get CorealisRT Blob size: %{public}s", (uint8_t *)&buf, 0xCu);
    }
  }
  else
  {
    uint64_t v23 = __cxa_begin_catch(a1);
    uint64_t v24 = VTLogContextFacilityVoiceTrigger;
    if (a2 == 2)
    {
      uint64_t v25 = v23;
      uint64_t v26 = (id)VTLogContextFacilityVoiceTrigger;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        uint64_t v30 = v25[2];
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = v30;
        _os_log_error_impl(&dword_21844F000, v26, OS_LOG_TYPE_ERROR, "Failed to get CorealisRT Blob size: %{public}s", (uint8_t *)&buf, 0xCu);
      }

      __cxa_end_catch();
LABEL_14:
      JUMPOUT(0x21850AA0CLL);
    }
    if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf) = 0;
      _os_log_error_impl(&dword_21844F000, v24, OS_LOG_TYPE_ERROR, "Faied to get CorealisRT Blob size: Unknown throw", (uint8_t *)&buf, 2u);
    }
  }
  __cxa_end_catch();
  goto LABEL_14;
}

uint64_t NDBlobGetDefaultBlobSize()
{
  return 0xFFFFFFFFLL;
}

uint64_t NDBlobBuildDefaultBlob()
{
  return 0xFFFFFFFFLL;
}

void NFile::readLine(NFile *this, const char *a2, NString *a3)
{
  if ((*(uint64_t (**)(NFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 156))
    {
      uint64_t v5 = &unk_26C99C5B0;
      int v6 = 0;
      operator new[]();
    }
    Error::chuck((Error *)"NFile::readLine() - cannot read, file %s not opened in read mode", v4, *((void *)this + 3));
  }
  Error::chuck((Error *)"NFile::readLine() - cannot read, file %s is not open", v4, *((void *)this + 3));
}

void sub_21850B0B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
  }
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NFile::getPosition(NFile *this)
{
  v5[17] = *MEMORY[0x263EF8340];
  if (((*(uint64_t (**)(NFile *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NFile::getPosition() - cannot get position, file %s is not open", v2, *((void *)this + 3));
  }
  if (*((_DWORD *)this + 156))
  {
    uint64_t v3 = (char *)this + *(void *)(*((void *)this + 7) - 24) + 56;
    if ((v3[32] & 5) != 0) {
      return -1;
    }
    (*(void (**)(void *__return_ptr))(**((void **)v3 + 5) + 32))(v5);
  }
  else
  {
    std::istream::tellg();
  }
  return v5[16];
}

uint64_t NFile::setPosition(NFile *this, const unsigned int *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (((*(uint64_t (**)(NFile *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NFile::setPosition() - cannot set position, file %s is not open", v4, *((void *)this + 3));
  }
  int v5 = *((_DWORD *)this + 156);
  if (*a2 == -1)
  {
    if (v5)
    {
      int v8 = (void *)((char *)this + 56);
      MEMORY[0x21D46B140](v12, (char *)this + 56);
      int v9 = (char *)v8 + *(void *)(*v8 - 24);
      if ((v9[32] & 5) == 0)
      {
        (*(void (**)(void *__return_ptr))(**((void **)v9 + 5) + 32))(v13);
        if (v14 == -1) {
          std::ios_base::clear((std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)), *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24) + 32) | 4);
        }
      }
      goto LABEL_11;
    }
  }
  else if (v5)
  {
    int v6 = (void *)((char *)this + 56);
    MEMORY[0x21D46B140](v12, (char *)this + 56);
    BOOL v7 = (char *)v6 + *(void *)(*v6 - 24);
    if ((v7[32] & 5) == 0)
    {
      (*(void (**)(void *__return_ptr))(**((void **)v7 + 5) + 32))(v13);
      if (v14 == -1) {
        std::ios_base::clear((std::ios_base *)((char *)v6 + *(void *)(*v6 - 24)), *(_DWORD *)((char *)v6 + *(void *)(*v6 - 24) + 32) | 4);
      }
    }
LABEL_11:
    MEMORY[0x21D46B150](v12);
    goto LABEL_13;
  }
  std::istream::seekg();
LABEL_13:
  if (*(_DWORD *)((char *)this + *(void *)(*((void *)this + 5) - 24) + 72)) {
    Error::chuck((Error *)"NFile::setPosition() - problem with stream, file %s", v10, *((void *)this + 3));
  }
  return 1;
}

void sub_21850B4A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  MEMORY[0x21D46B150](va);
  _Unwind_Resume(a1);
}

uint64_t NFile::write(NFile *this, const NString *a2)
{
  if (((*(uint64_t (**)(NFile *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NFile::write() cannot write, file %s is not open", v3, *((void *)this + 3));
  }
  if (!*((_DWORD *)this + 156)) {
    Error::chuck((Error *)"NFile::write() cannot write, file %s opened in read mode", v3, *((void *)this + 3));
  }

  return std::ostream::write();
}

void NFile::readString(NFile *this)
{
  if ((*(uint64_t (**)(NFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 156))
    {
      std::istream::read();
      if (*((void *)this + 6) == 4) {
        operator new[]();
      }
      Error::chuck((Error *)"NFile::readString() - failed to read length for embedded binary string in %s", v3, *((void *)this + 3));
    }
    Error::chuck((Error *)"NFile::readString() - cannot read, file %s not opened in read mode", v2, *((void *)this + 3));
  }
  Error::chuck((Error *)"NFile::readString() - cannot read, file %s is not open", v2, *((void *)this + 3));
}

void sub_21850B774(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NFile::readLine(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 0;
  operator new[]();
}

void sub_21850B844(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[2];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NFile::read(NFile *this, const unsigned int *a2, NString *a3)
{
  if (((*(uint64_t (**)(NFile *))(*(void *)this + 32))(this) & 1) == 0) {
    Error::chuck((Error *)"NFile::read() - cannot read, file %s is not open", v6, *((void *)this + 3));
  }
  if (*((_DWORD *)this + 156)) {
    Error::chuck((Error *)"NFile::read() - cannot read, file %s not opened in read mode", v6, *((void *)this + 3));
  }
  if (*a2 == -1) {
    Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v6, *((void *)this + 3));
  }
  (*(void (**)(NString *, const unsigned int *))(*(void *)a3 + 56))(a3, a2);
  std::istream::read();
  uint64_t v8 = *((void *)this + 6);
  if (*a2 > v8)
  {
    uint64_t v9 = *((unsigned int *)a3 + 2);
    if (v9 >= v8)
    {
      if (*((void *)a3 + 2)) {
        operator new[]();
      }
      Error::chuck((Error *)"Null pointer passed to string constructor", v7);
    }
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v7, *((void *)this + 6), v9);
  }
  return *((unsigned int *)a3 + 2);
}

void sub_21850BA50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NFile::read(NFile *this, const unsigned int *a2)
{
  if ((*(uint64_t (**)(NFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 156))
    {
      if (*a2 != -1) {
        operator new[]();
      }
      Error::chuck((Error *)"NFile::read() - attempting impossibly long read in file %s", v4, *((void *)this + 3));
    }
    Error::chuck((Error *)"NFile::read() - cannot read, file %s not opened in read mode", v4, *((void *)this + 3));
  }
  Error::chuck((Error *)"NFile::read() - cannot read, file %s is not open", v4, *((void *)this + 3));
}

void sub_21850BCBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NFile::read(NFile *this@<X0>, uint64_t a2@<X8>)
{
  if ((*(uint64_t (**)(NFile *))(*(void *)this + 32))(this))
  {
    if (!*((_DWORD *)this + 156))
    {
      *(void *)a2 = &unk_26C99C5B0;
      *(_DWORD *)(a2 + 8) = 0;
      operator new[]();
    }
    Error::chuck((Error *)"NFile::read() - cannot read, file %s not opened in read mode", v4, *((void *)this + 3));
  }
  Error::chuck((Error *)"NFile::read() - cannot read, file %s is not open", v4, *((void *)this + 3));
}

void sub_21850C1A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  if (a18) {
    MEMORY[0x21D46B220](a18, 0x1000C8077774924);
  }
  if (a21) {
    MEMORY[0x21D46B220](a21, 0x1000C8077774924);
  }
  *int v21 = a11;
  uint64_t v23 = v21[2];
  if (v23) {
    MEMORY[0x21D46B220](v23, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

BOOL NFile::good(NFile *this)
{
  return *(_DWORD *)((char *)this + *(void *)(*((void *)this + 5) - 24) + 72) == 0;
}

uint64_t NFile::eof(NFile *this)
{
  return (*((unsigned __int8 *)this + *(void *)(*((void *)this + 5) - 24) + 72) >> 1) & 1;
}

BOOL NFile::isOpen(NFile *this)
{
  return *((void *)this + 23) != 0;
}

uint64_t NFile::close(NFile *this)
{
  uint64_t result = (*(uint64_t (**)(NFile *))(*(void *)this + 32))(this);
  if (result)
  {
    if (!std::filebuf::close())
    {
      uint64_t v3 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 5) - 24) + 40);
      std::ios_base::clear(v3, v3->__rdstate_ | 4);
    }
    int v4 = 0;
    return (*(uint64_t (**)(char *, const char *, int *))(*((void *)this + 1) + 64))((char *)this + 8, "", &v4);
  }
  return result;
}

uint64_t NFile::open(NFile *this, const NString *a2, const NString *a3)
{
  (*(void (**)(NFile *))(*(void *)this + 24))(this);
  int v6 = (void *)((char *)this + 40);
  std::ios_base::clear((std::ios_base *)((char *)this + *(void *)(*((void *)this + 5) - 24) + 40), 0);
  uint64_t v8 = (unsigned char *)*((void *)a3 + 2);
  if (*((_DWORD *)a3 + 2) != 1) {
    goto LABEL_18;
  }
  int v9 = *v8;
  if (v9 == 114)
  {
    int v10 = 0;
    goto LABEL_8;
  }
  if (v9 == 119)
  {
    int v10 = 1;
    goto LABEL_8;
  }
  uint64_t v8 = (unsigned char *)*((void *)a3 + 2);
  if (*v8 != 97) {
LABEL_18:
  }
    Error::chuck((Error *)"NFile::open() - invalid mode %s", v7, v8);
  int v10 = 2;
LABEL_8:
  *((_DWORD *)this + 156) = v10;
  uint64_t v11 = std::filebuf::open();
  char v12 = (std::ios_base *)((char *)v6 + *(void *)(*((void *)this + 5) - 24));
  if (v11) {
    std::ios_base::iostate v13 = 0;
  }
  else {
    std::ios_base::iostate v13 = v12->__rdstate_ | 4;
  }
  std::ios_base::clear(v12, v13);
  if (!*((void *)this + 23)) {
    Error::chuck((Error *)"NFile::open() - file %s failed to open (mode %s)", v14, *((void *)a2 + 2), *((void *)a3 + 2));
  }
  if (*(_DWORD *)((char *)v6 + *(void *)(*v6 - 24) + 32)) {
    Error::chuck((Error *)"NFile::open() - file %s opens with error (mode %s)", v14, *((void *)a2 + 2), *((void *)a3 + 2));
  }
  uint64_t result = (uint64_t)this + 8;
  if ((NFile *)((char *)this + 8) != a2)
  {
    int v16 = *(uint64_t (**)(void))(*(void *)result + 64);
    return v16();
  }
  return result;
}

void NFile::~NFile(NFile *this)
{
  NFile::~NFile(this);

  JUMPOUT(0x21D46B240);
}

{
  std::ios_base *v2;
  uint64_t v3;
  int v4;

  *(void *)this = &unk_26C99BD70;
  if (*((void *)this + 23))
  {
    if (!std::filebuf::close())
    {
      uint64_t v2 = (std::ios_base *)((char *)this + *(void *)(*((void *)this + 5) - 24) + 40);
      std::ios_base::clear(v2, v2->__rdstate_ | 4);
    }
    int v4 = 0;
    (*(void (**)(char *, const char *, int *))(*((void *)this + 1) + 64))((char *)this + 8, "", &v4);
  }
  MEMORY[0x21D46B0D0]((char *)this + 64);
  std::iostream::~basic_iostream();
  MEMORY[0x21D46B200]((char *)this + 472);
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
}

void virtual thunk to'std::fstream::~fstream(void *a1)
{
  uint64_t v1 = (void (__cdecl ***)(std::fstream *__hidden))((char *)a1 + *(void *)(*a1 - 24));
  MEMORY[0x21D46B0D0](v1 + 3);
  std::iostream::~basic_iostream();
  MEMORY[0x21D46B200](v1 + 54);

  JUMPOUT(0x21D46B240);
}

{
  void (__cdecl ***v1)(std::fstream *__hidden);
  uint64_t vars8;

  uint64_t v1 = (void (__cdecl ***)(std::fstream *__hidden))((char *)a1 + *(void *)(*a1 - 24));
  MEMORY[0x21D46B0D0](v1 + 3);
  std::iostream::~basic_iostream();

  JUMPOUT(0x21D46B200);
}

void non-virtual thunk to'std::fstream::~fstream(void (__cdecl ***a1)(std::fstream *__hidden this))
{
  uint64_t v1 = a1 + 52;
  MEMORY[0x21D46B0D0](a1 + 1);
  std::iostream::~basic_iostream();
  MEMORY[0x21D46B200](v1);

  JUMPOUT(0x21D46B240);
}

{
  uint64_t vars8;

  MEMORY[0x21D46B0D0](a1 + 1);
  std::iostream::~basic_iostream();

  JUMPOUT(0x21D46B200);
}

void std::fstream::~fstream(void (__cdecl ***a1)(std::fstream *__hidden this))
{
  uint64_t v1 = a1 + 54;
  MEMORY[0x21D46B0D0](a1 + 3);
  std::iostream::~basic_iostream();
  MEMORY[0x21D46B200](v1);

  JUMPOUT(0x21D46B240);
}

void (__cdecl ***std::fstream::~fstream(void (__cdecl ***a1)(std::fstream *__hidden this)))(std::fstream *__hidden this)
{
  uint64_t v2 = a1 + 54;
  MEMORY[0x21D46B0D0](a1 + 3);
  std::iostream::~basic_iostream();
  MEMORY[0x21D46B200](v2);
  return a1;
}

void NFile::NFile(NFile *this)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void sub_21850CD08(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x21D46B200](v4);
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v6 = v1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

void NFile::NFile(NFile *this, const NString *a2, const NString *a3)
{
  *(void *)this = &unk_26C99C718;
  *((void *)this + 1) = &unk_26C99C5B0;
  *((_DWORD *)this + 4) = 0;
  operator new[]();
}

void sub_21850CF28(_Unwind_Exception *a1)
{
  std::fstream::~fstream(v4);
  *uint64_t v1 = v2;
  v1[1] = v3;
  uint64_t v6 = v1[3];
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t NFile::flush(NFile *this)
{
  return MEMORY[0x270F98748]((char *)this + 56);
}

void NDEFrameProc::NDEFrameProc(NDEFrameProc *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C99C498;
  *((unsigned char *)this + 24) = 0;
  *(void *)((char *)this + 28) = 0;
  *((unsigned char *)this + 36) = 0;
}

{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26C99C498;
  *((unsigned char *)this + 24) = 0;
  *(void *)((char *)this + 28) = 0;
  *((unsigned char *)this + 36) = 0;
}

float NDEFrameProc::init(NDEFrameProc *this, const unsigned int *a2, float *a3, float *a4, const BOOL *a5)
{
  if (*((_DWORD *)this + 4) != *a2)
  {
    *((_DWORD *)this + 4) = *a2;
    operator new[]();
  }
  *((float *)this + 7) = *a3;
  *((unsigned char *)this + 36) = *a5;
  float result = *a4;
  *((float *)this + 8) = *a4;
  *((unsigned char *)this + 24) = 1;
  return result;
}

NDEFrameProc *NDEFrameProc::apply(NDEFrameProc *this, float32x4_t *a2, const unsigned int *a3)
{
  if (!*((unsigned char *)this + 24)) {
    Error::chuck((Error *)"NDEFrameProc::doLog() - init() must be called first", (const char *)a2, a3);
  }
  uint64_t v4 = *a3;
  uint64_t v5 = *((unsigned int *)this + 4);
  if (v4 != v5) {
    Error::chuck((Error *)"NDEFrameProc::doLog() - input frame size mismatch (%d != %d)", (const char *)a2, *a3, v5);
  }
  if (!*((unsigned char *)this + 36))
  {
    if (!v4) {
      return this;
    }
    int v10 = (const float *)((char *)this + 28);
    uint64_t v11 = (float32x4_t *)*((void *)this + 1);
    if (v4 > 0xB)
    {
      uint64_t v12 = 0;
      unint64_t v31 = (unint64_t)v11->u64 + 4 * v4;
      BOOL v33 = v11 < (float32x4_t *)this + 2 && (unint64_t)v10 < v31;
      if ((v31 <= (unint64_t)a2 || v11 >= (float32x4_t *)&a2->f32[v4]) && !v33)
      {
        uint64_t v12 = v4 & 0xFFFFFFF8;
        float32x4_t v35 = vld1q_dup_f32(v10);
        uint64_t v36 = v11 + 1;
        uint64_t v37 = a2 + 1;
        uint64_t v38 = v12;
        do
        {
          float32x4_t v39 = vaddq_f32(*v37, v35);
          v36[-1] = vaddq_f32(v37[-1], v35);
          *uint64_t v36 = v39;
          v36 += 2;
          v37 += 2;
          v38 -= 8;
        }
        while (v38);
        if (v12 == v4) {
          return this;
        }
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v40 = v4 - v12;
    uint64_t v41 = v12;
    long long v42 = &v11->f32[v41];
    uint64_t v43 = &a2->f32[v41];
    do
    {
      float v44 = *v43++;
      *v42++ = v44 + *v10;
      --v40;
    }
    while (v40);
    return this;
  }
  if (!v4) {
    return this;
  }
  BOOL v7 = (const float *)((char *)this + 28);
  unint64_t v8 = *((void *)this + 1);
  if (v4 <= 7)
  {
    uint64_t v9 = 0;
LABEL_25:
    uint64_t v27 = v4 - v9;
    unsigned int v28 = (float *)(v8 + 4 * v9);
    uint64_t v29 = &a2->f32[v9];
    do
    {
      float v30 = *v29++;
      *v28++ = logf(v30 + *v7);
      --v27;
    }
    while (v27);
    return this;
  }
  uint64_t v9 = 0;
  unint64_t v13 = v8 + 4 * v4;
  BOOL v15 = v8 < (unint64_t)this + 32 && (unint64_t)v7 < v13;
  if (v13 > (unint64_t)a2 && v8 < (unint64_t)a2->u64 + 4 * v4) {
    goto LABEL_25;
  }
  if (v15) {
    goto LABEL_25;
  }
  uint64_t v9 = v4 & 0xFFFFFFFC;
  float32x4_t v17 = vld1q_dup_f32(v7);
  float32x4_t v46 = v17;
  unsigned int v18 = (const float *)a2;
  unsigned int v19 = (_OWORD *)*((void *)this + 1);
  uint64_t v20 = v9;
  do
  {
    float32x4_t v21 = *(float32x4_t *)v18;
    v18 += 4;
    float32x4_t v50 = vaddq_f32(v21, v46);
    float v47 = logf(v50.f32[1]);
    *(float *)&long long v22 = logf(v50.f32[0]);
    *((float *)&v22 + 1) = v47;
    long long v48 = v22;
    float v23 = logf(v50.f32[2]);
    long long v24 = v48;
    *((float *)&v24 + 2) = v23;
    long long v49 = v24;
    float v25 = logf(v50.f32[3]);
    long long v26 = v49;
    *((float *)&v26 + 3) = v25;
    *v19++ = v26;
    v20 -= 4;
  }
  while (v20);
  if (v9 != v4) {
    goto LABEL_25;
  }
  return this;
}

uint64_t NDEFrameProc::frameSize(NDEFrameProc *this)
{
  return *((unsigned int *)this + 4);
}

float NDEFrameProc::get_framerate(NDEFrameProc *this)
{
  return *((float *)this + 8);
}

void softLink_AnalyticsSendEventLazy(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v2 = (void (*)(__CFString *, id))getAnalyticsSendEventLazySymbolLoc_ptr;
  unint64_t v8 = getAnalyticsSendEventLazySymbolLoc_ptr;
  if (!getAnalyticsSendEventLazySymbolLoc_ptr)
  {
    v4[0] = MEMORY[0x263EF8330];
    v4[1] = 3221225472;
    unsigned int v4[2] = __getAnalyticsSendEventLazySymbolLoc_block_invoke;
    v4[3] = &unk_264326190;
    v4[4] = &v5;
    __getAnalyticsSendEventLazySymbolLoc_block_invoke((uint64_t)v4);
    uint64_t v2 = (void (*)(__CFString *, id))v6[3];
  }
  _Block_object_dispose(&v5, 8);
  if (!v2)
  {
    dlerror();
    uint64_t v3 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v5, 8);
    _Unwind_Resume(v3);
  }
  v2(@"com.apple.voicetrigger", v1);
}

void *__getAnalyticsSendEventLazySymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  v5[0] = 0;
  if (!CoreAnalyticsLibraryCore_frameworkLibrary)
  {
    v5[1] = MEMORY[0x263EF8330];
    v5[2] = 3221225472;
    v5[3] = __CoreAnalyticsLibraryCore_block_invoke;
    v5[4] = &__block_descriptor_40_e5_v8__0l;
    v5[5] = v5;
    long long v6 = xmmword_264325BC8;
    uint64_t v7 = 0;
    CoreAnalyticsLibraryCore_frameworkLibrary = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)CoreAnalyticsLibraryCore_frameworkLibrary;
    if (CoreAnalyticsLibraryCore_frameworkLibrary)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)CoreAnalyticsLibraryCore_frameworkLibrary;
LABEL_5:
  float result = dlsym(v2, "AnalyticsSendEventLazy");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getAnalyticsSendEventLazySymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __CoreAnalyticsLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreAnalyticsLibraryCore_frameworkLibrary = result;
  return result;
}

BOOL gIsPrime(unsigned int *a1)
{
  unsigned int v1 = *a1;
  if (*a1 - 1 < 3) {
    return 1;
  }
  if ((v1 & 1) == 0) {
    return 0;
  }
  if (v1 < 9) {
    return 1;
  }
  unsigned int v3 = 3;
  while (1)
  {
    BOOL result = v1 % v3 != 0;
    if (!(v1 % v3)) {
      break;
    }
    v3 += 2;
    if (v3 * v3 > v1) {
      return 1;
    }
  }
  return result;
}

uint64_t gNextPrime(const unsigned int *a1)
{
  uint64_t result = *a1;
  if ((result - 1) >= 2)
  {
    uint64_t v2 = result | 1;
    if ((result & 0xFFFFFFFE) >= 3)
    {
      while (v2 >= 9)
      {
        unsigned int v3 = 3;
        while (v2 % v3)
        {
          v3 += 2;
          if (v3 * v3 > v2) {
            return v2;
          }
        }
        uint64_t result = (v2 + 2);
        unsigned int v4 = v2 + 1;
        uint64_t v2 = result;
        if (v4 <= 2) {
          return result;
        }
      }
    }
    return v2;
  }
  return result;
}

uint64_t NOffsetFile::open(NOffsetFile *this, const NString *a2, const NString *a3, const unsigned int *a4, const unsigned int *a5)
{
  *((_DWORD *)this + 157) = *a4;
  unsigned int v8 = *a5 + *a4;
  *((_DWORD *)this + 158) = v8;
  *((_DWORD *)this + 159) = v8;
  NFile::open(this, a2, a3);
  uint64_t result = NFile::setPosition(this, a4);
  if ((result & 1) == 0) {
    Error::chuck((Error *)"NOffsetFile::open() - opened at invalid offset %d in %s\n", v10, *a4, *((void *)a2 + 2));
  }
  *((_DWORD *)this + 159) = *((_DWORD *)this + 157);
  return result;
}

void NOffsetFile::readLine(NOffsetFile *this, const char *a2, NString *a3)
{
}

void sub_2185112A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NOffsetFile::getPosition(NOffsetFile *this)
{
  return (*((_DWORD *)this + 159) - *((_DWORD *)this + 157));
}

uint64_t NOffsetFile::setPosition(NOffsetFile *this, const unsigned int *a2)
{
  if (*a2 + *((_DWORD *)this + 157) > *((_DWORD *)this + 158)) {
    return 0;
  }
  unsigned int v6 = *a2 + *((_DWORD *)this + 157);
  uint64_t result = NFile::setPosition(this, &v6);
  if (result) {
    unsigned int v5 = *a2 + *((_DWORD *)this + 157);
  }
  else {
    unsigned int v5 = *((_DWORD *)this + 158);
  }
  *((_DWORD *)this + 159) = v5;
  return result;
}

uint64_t NOffsetFile::readString@<X0>(NOffsetFile *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  if ((*((_DWORD *)this + 159) + 4) > *((_DWORD *)this + 158)) {
    goto LABEL_8;
  }
  int v9 = 4;
  (*(void (**)(void **__return_ptr, NOffsetFile *, int *))(*(void *)this + 64))(&v10, this, &v9);
  if (v11 != 4)
  {
    int v10 = &unk_26C99C5B0;
    if (v12) {
      MEMORY[0x21D46B220](v12, 0x1000C8077774924);
    }
LABEL_8:
    Error::chuck((Error *)"NOffsetFile::readString() - cannot read length for embedded binary string in %s", a2, *((void *)this + 3));
  }
  int v13 = *v12;
  int v5 = v13;
  int v10 = &unk_26C99C5B0;
  MEMORY[0x21D46B220]();
  if ((v5 + *((_DWORD *)this + 159)) > *((_DWORD *)this + 158)) {
    Error::chuck((Error *)"NOffsetFile::readString() - cannot read embedded binary string in %s", v6, *((void *)this + 3));
  }
  uint64_t result = (*(uint64_t (**)(NOffsetFile *, int *))(*(void *)this + 64))(this, &v13);
  if (*(_DWORD *)(a3 + 8) != v13) {
    Error::chuck((Error *)"NOffsetFile::readString() - failed to read embedded binary string in %s", v8, *((void *)this + 3));
  }
  return result;
}

void sub_2185114F0(_Unwind_Exception *exception_object)
{
  *unsigned int v1 = &unk_26C99C5B0;
  uint64_t v3 = v1[2];
  if (v3) {
    MEMORY[0x21D46B220](v3, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NOffsetFile::read(NOffsetFile *this, unsigned int *a2, NString *a3)
{
  int v3 = *((_DWORD *)this + 159);
  unsigned int v4 = *((_DWORD *)this + 158) - v3;
  if (*a2 < v4) {
    unsigned int v4 = *a2;
  }
  unsigned int v6 = v4;
  *((_DWORD *)this + 159) = v4 + v3;
  return NFile::read(this, &v6, a3);
}

void NOffsetFile::read(NOffsetFile *this, unsigned int *a2)
{
  int v2 = *((_DWORD *)this + 159);
  unsigned int v3 = *((_DWORD *)this + 158) - v2;
  if (*a2 < v3) {
    unsigned int v3 = *a2;
  }
  unsigned int v4 = v3;
  *((_DWORD *)this + 159) = v3 + v2;
  NFile::read(this, &v4);
}

void NOffsetFile::read(NOffsetFile *this@<X0>, uint64_t a2@<X8>)
{
  int v2 = *((_DWORD *)this + 158);
  if (v2 != -1)
  {
    unsigned int v3 = v2 - *((_DWORD *)this + 159);
    *((_DWORD *)this + 159) = v2;
    NFile::read(this, &v3);
  }
  *((_DWORD *)this + 159) = -1;

  NFile::read(this, a2);
}

BOOL NOffsetFile::good(NOffsetFile *this)
{
  return !*(_DWORD *)((char *)this + *(void *)(*((void *)this + 5) - 24) + 72)
      && *((_DWORD *)this + 159) < *((_DWORD *)this + 158);
}

BOOL NOffsetFile::eof(NOffsetFile *this)
{
  return (*((unsigned char *)this + *(void *)(*((void *)this + 5) - 24) + 72) & 2) != 0
      || *((_DWORD *)this + 159) >= *((_DWORD *)this + 158);
}

void NOffsetFile::~NOffsetFile(NOffsetFile *this)
{
  NFile::~NFile(this);

  JUMPOUT(0x21D46B240);
}

void NOffsetFile::NOffsetFile(NOffsetFile *this)
{
}

{
  NFile::NFile(this);
}

void NOffsetFile::NOffsetFile(NOffsetFile *this, const NString *a2, const NString *a3, const unsigned int *a4, const unsigned int *a5)
{
}

void sub_218511838(_Unwind_Exception *a1)
{
  NFile::~NFile(v1);
  _Unwind_Resume(a1);
}

void sub_218511CA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_218511DE4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  __cxa_begin_catch(a1);
  int v11 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
  {
    a9 = 0;
    _os_log_error_impl(&dword_21844F000, v11, OS_LOG_TYPE_ERROR, "processAudioBuffer failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x218511DB8);
}

void sub_218511E44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_218511EF0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  __cxa_begin_catch(a1);
  int v11 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
  {
    a9 = 0;
    _os_log_error_impl(&dword_21844F000, v11, OS_LOG_TYPE_ERROR, "processAudioBuffer failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x218511EC4);
}

void sub_218511F50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_21851200C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9)
{
  __cxa_begin_catch(a1);
  uint64_t v12 = *(NSObject **)(v10 + 1952);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    a9 = 0;
    _os_log_impl(&dword_21844F000, v12, OS_LOG_TYPE_DEFAULT, "endAudio failed", (uint8_t *)&a9, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x218511FE4);
}

void sub_218512358(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_2185126F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void sub_2185128D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void NScrambler::NScrambler(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  operator new[]();
}

{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  operator new[]();
}

uint64_t NScrambler::keystream(NScrambler *this)
{
  uint64_t v1 = *((unsigned __int8 *)this + 24);
  *((unsigned char *)this + 24) = *((unsigned char *)this + 25) + v1;
  return v1;
}

void NScrambler::convert(const NString *a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)a2 = &unk_26C99C5B0;
  *(_DWORD *)(a2 + 8) = *((_DWORD *)a1 + 2);
  operator new[]();
}

void NScrambler::scramble(NScrambler *this, const NString *a2)
{
  int v2 = &unk_26C99C5B0;
  int v3 = *((_DWORD *)a2 + 2);
  operator new[]();
}

void sub_218512C4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void base64_encode(const NString *a1, double a2)
{
  LODWORD(a2) = *((_DWORD *)a1 + 2);
  double v2 = (double)*(unint64_t *)&a2;
  v3[0] = (v2 * 1.6);
  unsigned int v5 = (v2 * 0.5);
  NAutoString::NAutoString((NAutoString *)&v4, v3, &v5);
}

void sub_218513194(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NScrambler::unscramble(NScrambler *this, const NString *a2)
{
  double v2 = &unk_26C99C5B0;
  int v3 = 0;
  operator new[]();
}

void sub_21851346C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  *uint64_t v14 = v15;
  uint64_t v17 = v14[2];
  if (v17) {
    MEMORY[0x21D46B220](v17, 0x1000C8077774924);
  }
  if (a14) {
    MEMORY[0x21D46B220](a14, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void base64_decode(const NString *a1)
{
  unsigned int v3 = *((_DWORD *)a1 + 2);
  unsigned int v1 = ((double)v3 * 0.5);
  NAutoString::NAutoString((NAutoString *)&v2, &v3, &v1);
}

void sub_218513A30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NString::stripComments(uint64_t this, unsigned __int8 a2)
{
  unsigned int v2 = *(_DWORD *)(this + 8);
  if (v2)
  {
    unsigned int v3 = *(unsigned char **)(this + 16);
    if (*v3 == a2)
    {
      *unsigned int v3 = 0;
      *(_DWORD *)(this + 8) = 0;
    }
    else if (v2 >= 2)
    {
      uint64_t v4 = 0;
      unsigned int v5 = v2 - 1;
      while (1)
      {
        unsigned int v6 = &v3[v4++];
        if (v6[1] == a2)
        {
          int v7 = *v6;
          if (v7 == 32 || v7 == 9) {
            break;
          }
        }
        if (v5 == v4) {
          return this;
        }
      }
      *(_DWORD *)(this + 8) = v4;
      v3[v4] = 0;
    }
  }
  return this;
}

void NString::creplace(NString *this, const NString *a2, const NString *a3)
{
  unsigned int v3 = &unk_26C99C5B0;
  int v4 = 0;
  operator new[]();
}

void sub_2185150A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  if (a19) {
    MEMORY[0x21D46B220](a19, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

NString *NString::replace(NString *this, const NString *a2, const NString *a3)
{
  (*(void (**)(void *__return_ptr))(*(void *)this + 112))(v5);
  (*(void (**)(NString *, void *))(*(void *)this + 32))(this, v5);
  v5[0] = &unk_26C99C5B0;
  if (v6) {
    MEMORY[0x21D46B220](v6, 0x1000C8077774924);
  }
  return this;
}

void sub_2185151D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NString::vprintf(NString *this, const char *a2, va_list a3)
{
  va_list v5 = a3;
  unsigned int v3 = &unk_26C99C5B0;
  int v4 = 0;
  operator new[]();
}

void sub_2185153E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13) {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

NString *NString::printf(NString *this, const char *a2, ...)
{
  va_start(va, a2);
  (*(void (**)(NString *, const char *, uint64_t *))(*(void *)this + 96))(this, a2, (uint64_t *)va);
  return this;
}

uint64_t NString::chomp(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 8);
  if (v1)
  {
    uint64_t v2 = (v1 - 1);
    if (!v2)
    {
      unsigned int v3 = *(unsigned char **)(this + 16);
      if (*v3 != 10) {
        return this;
      }
LABEL_7:
      *unsigned int v3 = 0;
      --*(_DWORD *)(this + 8);
      return this;
    }
    uint64_t v4 = *(void *)(this + 16);
    if (*(unsigned char *)(v4 + v2) == 10)
    {
      *(unsigned char *)(v4 + v2) = 0;
      int v5 = *(_DWORD *)(this + 8);
      *(_DWORD *)(this + 8) = v5 - 1;
      unsigned int v3 = (unsigned char *)(*(void *)(this + 16) + (v5 - 2));
      if (*v3 == 13) {
        goto LABEL_7;
      }
    }
  }
  return this;
}

uint64_t NString::appendTo(NString *this, const void *a2, const unsigned int *a3)
{
  if (!a2) {
    Error::chuck((Error *)"NString::appendTo() - Null pointer passed to assign", 0, a3);
  }
  unsigned int v8 = *a3 + *((_DWORD *)this + 2);
  uint64_t v6 = (char *)(**(uint64_t (***)(NString *, unsigned int *))this)(this, &v8);
  memcpy(v6, *((const void **)this + 2), *((unsigned int *)this + 2));
  memcpy(&v6[*((unsigned int *)this + 2)], a2, *a3);
  v6[v8] = 0;
  uint64_t result = (*(uint64_t (**)(NString *, void))(*(void *)this + 8))(this, *((void *)this + 2));
  *((_DWORD *)this + 2) = v8;
  *((void *)this + 2) = v6;
  return result;
}

uint64_t NString::assignTo(NString *this, const void *a2, const unsigned int *a3)
{
  if (!a2) {
    Error::chuck((Error *)"NString::assignTo() - Null pointer passed to assign", 0, a3);
  }
  LODWORD(__n) = *a3;
  int v5 = (void *)(**(uint64_t (***)(NString *, size_t *))this)(this, &__n);
  memcpy(v5, a2, __n);
  *((unsigned char *)v5 + __n) = 0;
  uint64_t result = (*(uint64_t (**)(NString *, void))(*(void *)this + 8))(this, *((void *)this + 2));
  *((_DWORD *)this + 2) = __n;
  *((void *)this + 2) = v5;
  return result;
}

uint64_t NString::newAllocation(NString *this, const unsigned int *a2)
{
  if (*a2 != *((_DWORD *)this + 2))
  {
    (*(void (**)(NString *, void))(*(void *)this + 8))(this, *((void *)this + 2));
    uint64_t v4 = (**(uint64_t (***)(NString *, const unsigned int *))this)(this, a2);
    *((void *)this + 2) = v4;
    *((_DWORD *)this + 2) = *a2;
    *(unsigned char *)(v4 + *a2) = 0;
  }
  return *((void *)this + 2);
}

uint64_t NString::operator+=(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 8);
  if (v3)
  {
    uint64_t v4 = *(void *)(a2 + 16);
    int v6 = v3;
    (*(void (**)(uint64_t, uint64_t, int *))(*(void *)a1 + 72))(a1, v4, &v6);
  }
  return a1;
}

uint64_t NString::operator=(uint64_t a1, char *__s)
{
  if (!__s) {
    Error::chuck((Error *)"NString::assignTo() - Null pointer passed to assign", 0);
  }
  int v5 = strlen(__s);
  (*(void (**)(uint64_t, char *, int *))(*(void *)a1 + 64))(a1, __s, &v5);
  return a1;
}

uint64_t NString::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2) {
    (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 64))(a1, *(void *)(a2 + 16), a2 + 8);
  }
  return a1;
}

void NString::~NString(NString *this)
{
  *(void *)this = &unk_26C99C5B0;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x21D46B240);
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99C5B0;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }
}

{
  uint64_t v1;

  *(void *)this = &unk_26C99C5B0;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    MEMORY[0x21D46B220](v1, 0x1000C8077774924);
  }
}

void NString::deallocate(NString *this, char *a2)
{
  if (a2) {
    JUMPOUT(0x21D46B220);
  }
}

void NString::allocate(NString *this, const unsigned int *a2)
{
}

void NString::NString(NString *this)
{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = 0;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = 0;
  operator new[]();
}

void NString::NString(NString *this, const NString *a2)
{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  operator new[]();
}

{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  operator new[]();
}

void NString::NString(NString *this, const char *__s)
{
  *(void *)this = &unk_26C99C5B0;
  if (__s)
  {
    *((_DWORD *)this + 2) = strlen(__s);
    operator new[]();
  }
  Error::chuck((Error *)"Null pointer passed to string constructor", 0);
}

{
  *(void *)this = &unk_26C99C5B0;
  if (__s)
  {
    *((_DWORD *)this + 2) = strlen(__s);
    operator new[]();
  }
  Error::chuck((Error *)"Null pointer passed to string constructor", 0);
}

void NString::NString(NString *this, const char *a2, const unsigned int *a3)
{
  *(void *)this = &unk_26C99C5B0;
  if (a2)
  {
    *((_DWORD *)this + 2) = *a3;
    operator new[]();
  }
  Error::chuck((Error *)"Null pointer passed to string constructor", 0, a3);
}

{
  *(void *)this = &unk_26C99C5B0;
  if (a2)
  {
    *((_DWORD *)this + 2) = *a3;
    operator new[]();
  }
  Error::chuck((Error *)"Null pointer passed to string constructor", 0, a3);
}

{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *a3;
  operator new[]();
}

{
  *(void *)this = &unk_26C99C5B0;
  *((_DWORD *)this + 2) = *a3;
  operator new[]();
}

void NString::NString(NString *this, const int *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26C99C5B0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F) {
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  }
  *((_DWORD *)this + 2) = strlen(__str);
  uint64_t v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((void *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

{
  const char *v3;
  void *v4;
  char __str[128];
  uint64_t v6;

  uint64_t v6 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26C99C5B0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F) {
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  }
  *((_DWORD *)this + 2) = strlen(__str);
  uint64_t v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((void *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

void NString::NString(NString *this, const unsigned int *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26C99C5B0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F) {
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  }
  *((_DWORD *)this + 2) = strlen(__str);
  uint64_t v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((void *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

{
  const char *v3;
  void *v4;
  char __str[128];
  uint64_t v6;

  uint64_t v6 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26C99C5B0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F) {
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  }
  *((_DWORD *)this + 2) = strlen(__str);
  uint64_t v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((void *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

void NString::NString(NString *this, const double *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26C99C5B0;
  if ((snprintf(__str, 0x200uLL, "%f", *a2) - 513) <= 0xFFFFFDFF) {
    Error::chuck((Error *)"NString::NString: cannot convert double to string", v3);
  }
  *((_DWORD *)this + 2) = strlen(__str);
  uint64_t v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((void *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

{
  const char *v3;
  void *v4;
  char __str[512];
  uint64_t v6;

  uint64_t v6 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26C99C5B0;
  if ((snprintf(__str, 0x200uLL, "%f", *a2) - 513) <= 0xFFFFFDFF) {
    Error::chuck((Error *)"NString::NString: cannot convert double to string", v3);
  }
  *((_DWORD *)this + 2) = strlen(__str);
  uint64_t v4 = (void *)(**(uint64_t (***)(NString *, char *))this)(this, (char *)this + 8);
  *((void *)this + 2) = v4;
  memcpy(v4, __str, (*((_DWORD *)this + 2) + 1));
}

uint64_t NString::pointer(NString *this)
{
  return *((void *)this + 2);
}

uint64_t NString::length(NString *this)
{
  return *((unsigned int *)this + 2);
}

void NString::operator+(uint64_t a1)
{
  uint64_t v1 = &unk_26C99C5B0;
  int v2 = *(_DWORD *)(a1 + 8);
  operator new[]();
}

void sub_2185165D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    MEMORY[0x21D46B220](a11, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

BOOL NString::operator==(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(unsigned int *)(a2 + 8);
  return v2 == *(_DWORD *)(a1 + 8) && memcmp(*(const void **)(a1 + 16), *(const void **)(a2 + 16), v2) == 0;
}

BOOL NString::operator==(uint64_t a1, char *__s)
{
  size_t v4 = strlen(__s);
  return v4 == *(_DWORD *)(a1 + 8) && memcmp(*(const void **)(a1 + 16), __s, v4) == 0;
}

BOOL NString::operator!=(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(unsigned int *)(a2 + 8);
  return v2 != *(_DWORD *)(a1 + 8) || memcmp(*(const void **)(a1 + 16), *(const void **)(a2 + 16), v2) != 0;
}

uint64_t NString::operator<(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) >> 31;
}

BOOL NString::operator<=(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) < 1;
}

BOOL NString::operator>(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) > 0;
}

BOOL NString::operator>=(uint64_t a1, uint64_t a2)
{
  return strcmp(*(const char **)(a1 + 16), *(const char **)(a2 + 16)) >= 0;
}

uint64_t NString::operator[](uint64_t a1, const char *a2)
{
  uint64_t v2 = *(unsigned int *)a2;
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v2 >= v3) {
    Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, *(unsigned int *)a2, v3 - 1);
  }
  return *(void *)(a1 + 16) + v2;
}

{
  uint64_t v2;
  unsigned int v3;

  uint64_t v2 = *(unsigned int *)a2;
  unsigned int v3 = *(_DWORD *)(a1 + 8);
  if (v2 >= v3) {
    Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, *(unsigned int *)a2, v3 - 1);
  }
  return *(void *)(a1 + 16) + v2;
}

void NString::slice(NString *this@<X0>, unsigned int *a2@<X1>, const unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int v5 = *a2;
  uint64_t v6 = *((unsigned int *)this + 2);
  if (*a2 <= v6)
  {
    uint64_t v7 = *a3;
    if (v7 <= v6)
    {
      if (v7 >= v5)
      {
        uint64_t v8 = *((void *)this + 2);
        *(void *)a4 = &unk_26C99C5B0;
        if (v8)
        {
          *(_DWORD *)(a4 + 8) = v7 - v5;
          operator new[]();
        }
        Error::chuck((Error *)"Null pointer passed to string constructor", (const char *)a2);
      }
      Error::chuck((Error *)"Start and end indices conflict, start [%d], end [%d]", (const char *)a2, *a2, v7);
    }
    Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, a3, *a3, v6);
  }
  Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, a3, *a2, v6);
}

void NString::head(NString *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *(_DWORD *)a2;
  uint64_t v5 = *((unsigned int *)this + 2);
  if (*(_DWORD *)a2 <= v5)
  {
    uint64_t v6 = *((void *)this + 2);
    *(void *)a3 = &unk_26C99C5B0;
    if (v6)
    {
      *(_DWORD *)(a3 + 8) = v4;
      operator new[]();
    }
    Error::chuck((Error *)"Null pointer passed to string constructor", a2);
  }
  Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, *(unsigned int *)a2, v5);
}

void NString::tail(NString *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  int v4 = *(_DWORD *)a2;
  uint64_t v5 = *((unsigned int *)this + 2);
  if (v5 >= *(_DWORD *)a2)
  {
    uint64_t v6 = *((void *)this + 2);
    *(void *)a3 = &unk_26C99C5B0;
    if (v6)
    {
      *(_DWORD *)(a3 + 8) = v5 - v4;
      operator new[]();
    }
    Error::chuck((Error *)"Null pointer passed to string constructor", a2);
  }
  Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, *(unsigned int *)a2, v5);
}

void NString::cuttail(NString *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((unsigned int *)this + 2);
  int v5 = v4 - *(_DWORD *)a2;
  if (v4 >= *(_DWORD *)a2)
  {
    uint64_t v6 = *((void *)this + 2);
    *(void *)a3 = &unk_26C99C5B0;
    if (v6)
    {
      *(_DWORD *)(a3 + 8) = v5;
      operator new[]();
    }
    Error::chuck((Error *)"Null pointer passed to string constructor", a2);
  }
  Error::chuck((Error *)"Index %d outside of range [0,%d]", a2, (v4 - *(_DWORD *)a2), v4);
}

void NString::uppercase(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 0;
  operator new[]();
}

void sub_218516C64(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[2];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NString::lowercase(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 0;
  operator new[]();
}

void sub_218516DC8(_Unwind_Exception *exception_object)
{
  *uint64_t v1 = v2;
  uint64_t v4 = v1[2];
  if (v4) {
    MEMORY[0x21D46B220](v4, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

float NString::tofloat(const char **this)
{
  return atof(this[2]);
}

uint64_t NString::toint(const char **this, const unsigned int *a2)
{
  return strtol(this[2], 0, *a2);
}

unint64_t NString::touint(const char **this, const unsigned int *a2)
{
  return strtoul(this[2], 0, *a2);
}

BOOL NString::checkFloat(NString *this)
{
  if (!*((_DWORD *)this + 2)) {
    return 0;
  }
  unsigned int v3 = 0;
  strtod(*((const char **)this + 2), &v3);
  return v3 == (char *)(*((void *)this + 2) + *((unsigned int *)this + 2));
}

BOOL NString::checkInt(NString *this, const unsigned int *a2)
{
  if (!*((_DWORD *)this + 2)) {
    return 0;
  }
  __endptr = 0;
  strtol(*((const char **)this + 2), &__endptr, *a2);
  return __endptr == (char *)(*((void *)this + 2) + *((unsigned int *)this + 2));
}

BOOL NString::checkUint(NString *this, const unsigned int *a2)
{
  if (!*((_DWORD *)this + 2)) {
    return 0;
  }
  __endptr = 0;
  strtoul(*((const char **)this + 2), &__endptr, *a2);
  return __endptr == (char *)(*((void *)this + 2) + *((unsigned int *)this + 2));
}

void NString::toBOOL(NString *this)
{
  NString::lowercase((uint64_t)&v1);
}

BOOL NString::startswith(NString *this, const char *__s)
{
  unsigned int v4 = strlen(__s);
  return *((_DWORD *)this + 2) >= v4 && memcmp(*((const void **)this + 2), __s, v4) == 0;
}

BOOL NString::startswith(NString *this, const void **a2)
{
  size_t v2 = *((unsigned int *)a2 + 2);
  return *((_DWORD *)this + 2) >= v2 && memcmp(*((const void **)this + 2), a2[2], v2) == 0;
}

BOOL NString::endswith(NString *this, const char *__s)
{
  unsigned int v4 = strlen(__s);
  unsigned int v5 = *((_DWORD *)this + 2);
  BOOL v6 = v5 >= v4;
  uint64_t v7 = v5 - v4;
  return v6 && memcmp((const void *)(*((void *)this + 2) + v7), __s, v4) == 0;
}

BOOL NString::endswith(NString *this, const void **a2)
{
  unsigned int v2 = *((_DWORD *)this + 2);
  size_t v3 = *((unsigned int *)a2 + 2);
  return v2 >= v3 && memcmp((const void *)(*((void *)this + 2) + v2 - v3), a2[2], v3) == 0;
}

uint64_t NString::contains(NString *this, const char *__s)
{
  unsigned int v4 = strlen(__s);
  unsigned int v5 = v4;
  int v6 = *((_DWORD *)this + 2);
  if (v6) {
    BOOL v7 = v4 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    int v8 = v6 - v4 + 1;
    if (v8 >= 1)
    {
      int v9 = *__s;
      uint64_t v10 = (void *)*((void *)this + 2);
      int v11 = v10;
      do
      {
        uint64_t v12 = (char *)memchr(v11, v9, v8);
        if (!v12) {
          break;
        }
        int v13 = v12;
        uint64_t v14 = (v12 - v10);
        if (!memcmp(v12, __s, v5)) {
          return v14;
        }
        int v8 = v6 - v5 - v14;
        int v11 = v13 + 1;
      }
      while (v8 > 0);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t NString::contains(NString *this, const NString *a2)
{
  int v2 = *((_DWORD *)this + 2);
  if (v2)
  {
    size_t v3 = *((unsigned int *)a2 + 2);
    if (v3)
    {
      int v4 = v2 - v3 + 1;
      if (v4 >= 1)
      {
        unsigned int v5 = (char *)*((void *)a2 + 2);
        int v6 = *v5;
        BOOL v7 = (void *)*((void *)this + 2);
        int v8 = v7;
        do
        {
          int v9 = (char *)memchr(v8, v6, v4);
          if (!v9) {
            break;
          }
          uint64_t v10 = v9;
          uint64_t v11 = (v9 - v7);
          if (!memcmp(v9, v5, v3)) {
            return v11;
          }
          int v4 = v2 - v3 - v11;
          int v8 = v10 + 1;
        }
        while (v4 > 0);
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t NString::contains(NString *this, const char *a2)
{
  size_t v2 = *((unsigned int *)this + 2);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  size_t v3 = (void *)*((void *)this + 2);
  int v4 = memchr(v3, *(unsigned __int8 *)a2, v2);
  if (v4) {
    return (v4 - v3);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t NString::containsafter(NString *this, const NString *a2, const unsigned int *a3)
{
  uint64_t v3 = *a3;
  unsigned int v4 = *((_DWORD *)this + 2);
  if (v3 >= v4) {
    Error::chuck((Error *)"Index %d outside of range [0,%d]", (const char *)a2, *a3, v4 - 1);
  }
  size_t v5 = *((unsigned int *)a2 + 2);
  if (v5)
  {
    int v6 = v4 - (v3 + v5) + 1;
    if (v6 >= 1)
    {
      BOOL v7 = (char *)*((void *)a2 + 2);
      int v8 = *v7;
      uint64_t v9 = *((void *)this + 2);
      uint64_t v10 = (void *)(v9 + v3);
      do
      {
        uint64_t v11 = (char *)memchr(v10, v8, v6);
        if (!v11) {
          break;
        }
        uint64_t v12 = v11;
        uint64_t v13 = (v11 - v9);
        if (!memcmp(v11, v7, v5)) {
          return v13;
        }
        int v6 = v4 - (v5 + v13);
        uint64_t v10 = v12 + 1;
      }
      while (v6 > 0);
    }
  }
  return 0xFFFFFFFFLL;
}

void *operator<<(void *a1, uint64_t a2)
{
  uint64_t v3 = *(const char **)(a2 + 16);
  size_t v4 = strlen(v3);

  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)v3, v4);
}

uint64_t operator<<(uint64_t a1)
{
  return a1;
}

void *NString::split@<X0>(NString *this@<X0>, const NString *a2@<X1>, unsigned int *a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 8) = 0;
  *(void *)(a4 + 16) = 0;
  *(void *)a4 = &unk_26C99A640;
  *(_DWORD *)(a4 + 24) = 0;
  return NString::split((uint64_t)this, a4, (uint64_t)a2, (int *)a3);
}

void sub_218517528(_Unwind_Exception *a1)
{
  NLinkedList<NString>::~NLinkedList(v1);
  _Unwind_Resume(a1);
}

void *NString::split(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  size_t v5 = *(const char **)(a1 + 16);
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
  uint64_t v16 = a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = 0;
    for (int i = *a4; ; int i = *a4)
    {
      uint64_t v10 = v8;
      uint64_t v11 = *(void **)(a3 + 16);
      size_t v12 = *(unsigned int *)(a3 + 8);
      uint64_t v8 = v7 <= (int)v8 + 1 ? (v8 + 1) : v7;
      uint64_t v13 = v5;
      while (1)
      {
        uint64_t result = memchr(v11, *v13, v12);
        if (!result) {
          break;
        }
        ++v13;
        uint64_t v10 = (v10 + 1);
        if (v8 == v10)
        {
          int v14 = 0;
LABEL_17:
          size_t v5 = v13;
          if (i) {
            goto LABEL_20;
          }
LABEL_18:
          strlen(v13);
          operator new[]();
        }
      }
      int v14 = v7 - v10;
      if (v7 <= v10)
      {
        int v14 = 0;
        uint64_t v8 = v10;
        goto LABEL_17;
      }
      uint64_t v15 = 0;
      do
      {
        uint64_t result = memchr(v11, v13[v15], v12);
        if (result)
        {
          size_t v5 = &v13[v15];
          int v14 = v15;
          uint64_t v8 = v10;
          if (i) {
            goto LABEL_20;
          }
          goto LABEL_18;
        }
        uint64_t v10 = (v10 + 1);
        ++v15;
      }
      while (v7 != v10);
      size_t v5 = &v13[v15];
      uint64_t v8 = v7;
      if (!i) {
        goto LABEL_18;
      }
LABEL_20:
      if (v14) {
        operator new[]();
      }
      uint64_t v7 = *(unsigned int *)(v16 + 8);
      if (v8 >= v7) {
        break;
      }
    }
  }
  return result;
}

void sub_21851780C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  if (a16) {
    MEMORY[0x21D46B220](a16, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void *NString::split(uint64_t a1, void *a2, uint64_t a3, unsigned int *a4)
{
  size_t v4 = *(char **)(a1 + 16);
  size_t v5 = *(void **)(a3 + 16);
  size_t v6 = *(unsigned int *)(a3 + 8);
  int v27 = 0;
  int v7 = *(_DWORD *)(a1 + 8);
  if (v7)
  {
    int v8 = 0;
    BOOL v9 = 1;
    do
    {
      BOOL v10 = v9;
      uint64_t v11 = memchr(v5, *v4, v6);
      BOOL v9 = v11 != 0;
      if (v10 && !v11) {
        int v27 = ++v8;
      }
      ++v4;
      --v7;
    }
    while (v7);
  }
  else
  {
    int v8 = 0;
  }
  if (v8 - 1 > *a4) {
    int v27 = *a4 + 1;
  }
  uint64_t result = (void *)(*(uint64_t (**)(void *, int *))(*a2 + 32))(a2, &v27);
  int v26 = 0;
  unsigned int v13 = *(_DWORD *)(a1 + 8);
  if (v13)
  {
    unsigned int v14 = 0;
    unsigned int v15 = 0;
    uint64_t v16 = *(char **)(a1 + 16);
    do
    {
      unsigned int v18 = *a4;
      if (v15 > *a4) {
        return result;
      }
      if (v14 < v13)
      {
        while (1)
        {
          uint64_t result = memchr(v5, *v16, v6);
          if (!result) {
            break;
          }
          ++v16;
          if (v13 == ++v14)
          {
            unsigned int v19 = 0;
            int v26 = 0;
            uint64_t v20 = v16;
            unsigned int v14 = v13;
            if (v15 == v18) {
              goto LABEL_12;
            }
            goto LABEL_30;
          }
        }
      }
      uint64_t v20 = v16;
      int v26 = 0;
      unsigned int v19 = v13 - v14;
      if (v13 <= v14)
      {
        unsigned int v19 = 0;
        if (v15 == v18) {
          goto LABEL_12;
        }
      }
      else
      {
        uint64_t v21 = 0;
        while (1)
        {
          uint64_t result = memchr(v5, v16[v21], v6);
          if (result) {
            break;
          }
          int v26 = ++v21;
          if (!(v14 - v13 + v21))
          {
            v16 += v21;
            unsigned int v14 = v13;
            goto LABEL_29;
          }
        }
        v16 += v21;
        v14 += v21;
        unsigned int v19 = v21;
LABEL_29:
        if (v15 == v18)
        {
LABEL_12:
          uint64_t v17 = a2[1] + 24 * v15;
          uint64_t result = (void *)(*(uint64_t (**)(uint64_t, char *))(*(void *)v17 + 40))(v17, v20);
          goto LABEL_13;
        }
      }
LABEL_30:
      if (!v19) {
        goto LABEL_14;
      }
      uint64_t v22 = a2[1] + 24 * v15;
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t, char *, int *))(*(void *)v22 + 64))(v22, v20, &v26);
LABEL_13:
      ++v15;
LABEL_14:
      unsigned int v13 = *(_DWORD *)(a1 + 8);
    }
    while (v14 < v13);
  }
  return result;
}

uint64_t NString::split(uint64_t a1, void *a2, unsigned __int8 a3)
{
  int v5 = a3;
  size_t v6 = *(unsigned __int8 **)(a1 + 16);
  int v21 = 0;
  int v7 = *(_DWORD *)(a1 + 8);
  if (v7)
  {
    int v8 = 0;
    BOOL v9 = 1;
    do
    {
      BOOL v10 = v9;
      BOOL v9 = *v6 == a3;
      if (v10 && *v6 != a3) {
        int v21 = ++v8;
      }
      ++v6;
      --v7;
    }
    while (v7);
  }
  uint64_t result = (*(uint64_t (**)(void *, int *))(*a2 + 32))(a2, &v21);
  unsigned int v12 = *(_DWORD *)(a1 + 8);
  if (v12)
  {
    unsigned int v13 = 0;
    unsigned int v14 = 0;
    unsigned int v15 = *(unsigned __int8 **)(a1 + 16);
    do
    {
      if (v12 <= v13 + 1) {
        unsigned int v16 = v13 + 1;
      }
      else {
        unsigned int v16 = v12;
      }
      for (int i = v15; *i == v5; ++i)
      {
        if (v16 == ++v13) {
          return result;
        }
      }
      unsigned int v18 = v12 - v13;
      if (v12 <= v13)
      {
        unsigned int v15 = i;
      }
      else
      {
        uint64_t v19 = 0;
        while (i[v19] != v5)
        {
          ++v13;
          ++v19;
          if (v12 == v13)
          {
            unsigned int v15 = &i[v19];
            unsigned int v13 = v12;
            if (!v18) {
              goto LABEL_25;
            }
            goto LABEL_24;
          }
        }
        unsigned int v15 = &i[v19];
        if (!v19) {
          continue;
        }
LABEL_24:
        uint64_t v20 = a2[1] + 24 * v14;
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v20 + 64))(v20);
        ++v14;
        unsigned int v12 = *(_DWORD *)(a1 + 8);
      }
LABEL_25:
      ;
    }
    while (v13 < v12);
  }
  return result;
}

void NString::hexcoded(NString *this@<X0>, uint64_t a2@<X8>)
{
  int v3 = *((_DWORD *)this + 2);
  *(void *)a2 = &unk_26C99C5B0;
  *(_DWORD *)(a2 + 8) = 2 * v3;
  operator new[]();
}

void NString::hexdecoded(NString *this@<X0>, const char *a2@<X1>, uint64_t a3@<X8>)
{
  if ((*((unsigned char *)this + 8) & 1) == 0)
  {
    *(void *)a3 = &unk_26C99C5B0;
    *(_DWORD *)(a3 + 8) = 0;
    operator new[]();
  }
  Error::chuck((Error *)"NString::hexdecoded() - string is odd number of chars", a2);
}

void sub_218517FC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  *uint64_t v20 = v21;
  uint64_t v23 = v20[2];
  if (v23) {
    MEMORY[0x21D46B220](v23, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void NString::strip(NString *this@<X0>, const NString *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5 = *((unsigned int *)this + 2);
  size_t v6 = (char *)*((void *)a2 + 2);
  if (v5)
  {
    uint64_t v7 = 0;
    uint64_t v8 = *((void *)this + 2);
    while (strchr(v6, *(char *)(v8 + v7)))
    {
      if (v5 == ++v7)
      {
        unint64_t v9 = v5;
        unint64_t v10 = v5;
        LODWORD(v7) = v5;
        goto LABEL_8;
      }
    }
    unint64_t v9 = v7;
    unint64_t v10 = v5;
  }
  else
  {
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    LODWORD(v7) = 0;
  }
LABEL_8:
  unsigned int v13 = v7;
  if (v7 < v5) {
    LODWORD(v5) = v7;
  }
  do
  {
    if (v10 <= v9) {
      goto LABEL_13;
    }
    uint64_t v11 = v10--;
  }
  while (strchr(v6, *(char *)(*((void *)this + 2) + v11 - 1)));
  LODWORD(v5) = v11;
LABEL_13:
  unsigned int v12 = v5;
  NString::slice(this, &v13, &v12, a3);
}

void NString::dirname(NString *this@<X0>, uint64_t a2@<X8>)
{
  size_t v4 = (char *)*((void *)this + 2);
  unint64_t v5 = strrchr(v4, 47);
  if (v5)
  {
    unsigned int v7 = v5 - v4;
    if (v5 != v4)
    {
      uint64_t v8 = *((unsigned int *)this + 2);
      if (v8 >= v7)
      {
        *(void *)a2 = &unk_26C99C5B0;
        if (v4)
        {
          *(_DWORD *)(a2 + 8) = v7;
          operator new[]();
        }
        Error::chuck((Error *)"Null pointer passed to string constructor", v6);
      }
      Error::chuck((Error *)"Index %d outside of range [0,%d]", v6, v5 - v4, v8);
    }
    *(void *)a2 = &unk_26C99C5B0;
    *(_DWORD *)(a2 + 8) = 1;
    operator new[]();
  }
  *(void *)a2 = &unk_26C99C5B0;
  *(_DWORD *)(a2 + 8) = 1;
  operator new[]();
}

void NString::prefixDirname(NString *this@<X0>, uint64_t a2@<X8>)
{
  size_t v4 = (char *)*((void *)this + 2);
  unint64_t v5 = strrchr(v4, 47);
  if (v5)
  {
    unsigned int v7 = v5 - v4 + 1;
    uint64_t v8 = *((unsigned int *)this + 2);
    if (v7 <= v8)
    {
      *(void *)a2 = &unk_26C99C5B0;
      if (v4)
      {
        *(_DWORD *)(a2 + 8) = v7;
        operator new[]();
      }
      Error::chuck((Error *)"Null pointer passed to string constructor", v6);
    }
    Error::chuck((Error *)"Index %d outside of range [0,%d]", v6, (v5 - v4 + 1), v8);
  }
  *(void *)a2 = &unk_26C99C5B0;
  *(_DWORD *)(a2 + 8) = 0;
  operator new[]();
}

void NString::basename(char **this@<X0>, uint64_t a2@<X8>)
{
  size_t v4 = strrchr(this[2], 47);
  if (v4)
  {
    *(void *)a2 = &unk_26C99C5B0;
    *(_DWORD *)(a2 + 8) = strlen(v4 + 1);
    operator new[]();
  }
  *(void *)a2 = &unk_26C99C5B0;
  *(_DWORD *)(a2 + 8) = *((_DWORD *)this + 2);
  operator new[]();
}

void NString::basename(char **this, const NString *a2)
{
  int v3 = strrchr(this[2], 47);
  if (v3)
  {
    size_t v4 = &unk_26C99C5B0;
    int v5 = strlen(v3 + 1);
    operator new[]();
  }
  size_t v4 = &unk_26C99C5B0;
  int v5 = *((_DWORD *)this + 2);
  operator new[]();
}

void sub_218518724(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    MEMORY[0x21D46B220](a12, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NString::hashValue(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 8);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = this;
  LODWORD(this) = 0;
  int v3 = *(char **)(v2 + 16);
  do
  {
    int v4 = *v3++;
    this = (v4 + 65599 * this);
    --v1;
  }
  while (v1);
  return this;
}

uint64_t operator<<(uint64_t a1, _DWORD *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v5 = (uint64_t (**)(void **, int *))&unk_26C99C5B0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F) {
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  }
  int v6 = strlen(__str);
  unsigned int v7 = (void *)(*v5)((void **)&v5, &v6);
  memcpy(v7, __str, (v6 + 1));
  (*(void (**)(uint64_t, uint64_t (***)(void **, int *)))(*(void *)a1 + 48))(a1, &v5);
  int v5 = (uint64_t (**)(void **, int *))&unk_26C99C5B0;
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  return a1;
}

{
  const char *v3;
  uint64_t (**v5)(void **, int *);
  int v6;
  void *v7;
  char __str[128];
  uint64_t v9;

  uint64_t v9 = *MEMORY[0x263EF8340];
  int v5 = (uint64_t (**)(void **, int *))&unk_26C99C5B0;
  if ((snprintf(__str, 0x80uLL, "%d", *a2) - 129) <= 0xFFFFFF7F) {
    Error::chuck((Error *)"NString::NString: cannot convert int to string", v3);
  }
  int v6 = strlen(__str);
  unsigned int v7 = (void *)(*v5)((void **)&v5, &v6);
  memcpy(v7, __str, (v6 + 1));
  (*(void (**)(uint64_t, uint64_t (***)(void **, int *)))(*(void *)a1 + 48))(a1, &v5);
  int v5 = (uint64_t (**)(void **, int *))&unk_26C99C5B0;
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  return a1;
}

void sub_218518900(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
  {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_218518A90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
  {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t operator<<(uint64_t a1, float *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  double v3 = *a2;
  int v6 = (uint64_t (**)(void **, int *))&unk_26C99C5B0;
  if ((snprintf(__str, 0x200uLL, "%f", v3) - 513) <= 0xFFFFFDFF) {
    Error::chuck((Error *)"NString::NString: cannot convert double to string", v4);
  }
  int v7 = strlen(__str);
  uint64_t v8 = (void *)(*v6)((void **)&v6, &v7);
  memcpy(v8, __str, (v7 + 1));
  (*(void (**)(uint64_t, uint64_t (***)(void **, int *)))(*(void *)a1 + 48))(a1, &v6);
  int v6 = (uint64_t (**)(void **, int *))&unk_26C99C5B0;
  if (v8) {
    MEMORY[0x21D46B220](v8, 0x1000C8077774924);
  }
  return a1;
}

void sub_218518C2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
  {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t operator<<(uint64_t a1, double *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v5 = (uint64_t (**)(void **, int *))&unk_26C99C5B0;
  if ((snprintf(__str, 0x200uLL, "%f", *a2) - 513) <= 0xFFFFFDFF) {
    Error::chuck((Error *)"NString::NString: cannot convert double to string", v3);
  }
  int v6 = strlen(__str);
  int v7 = (void *)(*v5)((void **)&v5, &v6);
  memcpy(v7, __str, (v6 + 1));
  (*(void (**)(uint64_t, uint64_t (***)(void **, int *)))(*(void *)a1 + 48))(a1, &v5);
  int v5 = (uint64_t (**)(void **, int *))&unk_26C99C5B0;
  if (v7) {
    MEMORY[0x21D46B220](v7, 0x1000C8077774924);
  }
  return a1;
}

void sub_218518DC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13)
  {
    MEMORY[0x21D46B220](a13, 0x1000C8077774924);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void NTimer::~NTimer(NTimer *this)
{
}

void NTimer::NTimer(NTimer *this)
{
  *(void *)this = &unk_26C99C4F8;
  *((_WORD *)this + 4) = 0;
}

{
  *(void *)this = &unk_26C99C4F8;
  *((_WORD *)this + 4) = 0;
}

uint64_t NTimer::running(NTimer *this)
{
  return (uint64_t)this + 8;
}

uint64_t NTimer::start(NTimer *this)
{
  times((tms *)((char *)this + 16));
  uint64_t result = gettimeofday((timeval *)this + 5, 0);
  *((_WORD *)this + 4) = 257;
  return result;
}

uint64_t NTimer::stop(uint64_t this)
{
  if (*(unsigned char *)(this + 8))
  {
    uint64_t v1 = this;
    times((tms *)(this + 48));
    this = gettimeofday((timeval *)(v1 + 96), 0);
    *(unsigned char *)(v1 + 8) = 0;
  }
  return this;
}

double NTimer::elapsed(uint64_t a1, const char *a2)
{
  if (!*(unsigned char *)(a1 + 9)) {
    Error::chuck((Error *)"NTimer::elapsed(): timer not started, cannot call elapsed", a2);
  }
  int v2 = (int)a2;
  if (*(unsigned char *)(a1 + 8))
  {
    times(&v14);
    gettimeofday(&v13, 0);
  }
  else
  {
    long long v4 = *(_OWORD *)(a1 + 64);
    *(_OWORD *)&v14.clock_t tms_utime = *(_OWORD *)(a1 + 48);
    *(_OWORD *)&v14.clock_t tms_cutime = v4;
    timeval v13 = *(timeval *)(a1 + 96);
  }
  uint64_t v5 = sysconf(3);
  switch(v2)
  {
    case 0:
      clock_t tms_utime = v14.tms_utime;
      uint64_t v7 = *(void *)(a1 + 16);
      goto LABEL_12;
    case 1:
      clock_t tms_utime = v14.tms_stime;
      uint64_t v7 = *(void *)(a1 + 24);
      goto LABEL_12;
    case 3:
      clock_t tms_stime = v14.tms_utime;
      clock_t tms_cutime = v14.tms_cutime;
      uint64_t v11 = *(void *)(a1 + 16);
      uint64_t v12 = *(void *)(a1 + 32);
      goto LABEL_11;
    case 4:
      clock_t tms_stime = v14.tms_stime;
      clock_t tms_cutime = v14.tms_cstime;
      uint64_t v11 = *(void *)(a1 + 24);
      uint64_t v12 = *(void *)(a1 + 40);
LABEL_11:
      clock_t tms_utime = tms_cutime + tms_stime;
      uint64_t v7 = v11 + v12;
LABEL_12:
      double result = (double)(tms_utime - v7) / (double)v5;
      break;
    default:
      double result = (double)(v13.tv_usec - *(_DWORD *)(a1 + 88)) / 1000000.0 + (double)(v13.tv_sec - *(void *)(a1 + 80));
      break;
  }
  return result;
}

void NVersion::release(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 20;
  operator new[]();
}

void NVersion::releaseDate(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 28;
  operator new[]();
}

void NVersion::buildType(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 7;
  operator new[]();
}

void NVersion::buildDate(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 24;
  operator new[]();
}

void NVersion::compilerVersion(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 61;
  operator new[]();
}

void NVersion::compileFlags(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 407;
  operator new[]();
}

void NVersion::buildMachine(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 8;
  operator new[]();
}

void NVersion::versionMessage(uint64_t a1@<X8>)
{
  *(void *)a1 = &unk_26C99C5B0;
  *(_DWORD *)(a1 + 8) = 61;
  operator new[]();
}

void sub_21851DF64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ndapilog_callback(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  int v2 = VTLogContextFacilityVoiceTrigger;
  if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_INFO))
  {
    int v3 = 136446210;
    uint64_t v4 = a1;
    _os_log_impl(&dword_21844F000, v2, OS_LOG_TYPE_INFO, "NDAPI: %{public}s", (uint8_t *)&v3, 0xCu);
  }
}

void sub_218524B4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose((const void *)(v29 - 144), 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6640(uint64_t a1, uint64_t a2)
{
  uint64_t result = MEMORY[0x21D46B9F0](*(void *)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__6641(uint64_t a1)
{
}

void sub_218525BF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t _PhraseSpotterEnabledDidChange(uint64_t a1, void *a2)
{
  return [a2 _phraseSpotterEnabledDidChange];
}

uint64_t _VoiceTriggerEnabledDidChange(uint64_t a1, void *a2)
{
  return [a2 _voiceTriggerEnabledDidChange];
}

id VTBuildVersion()
{
  dispatch_time_t v0 = (void *)MGCopyAnswer();

  return v0;
}

id _baseDir()
{
  CPSharedResourcesDirectory();
  dispatch_time_t v0 = (__CFString *)objc_claimAutoreleasedReturnValue();
  if ([(__CFString *)v0 rangeOfString:@"root"] != 0x7FFFFFFFFFFFFFFFLL)
  {

    dispatch_time_t v0 = @"/var/mobile";
  }
  uint64_t v1 = [(__CFString *)v0 stringByAppendingPathComponent:@"Library"];

  return v1;
}

void *VTLogDirectory()
{
  CPSharedResourcesDirectory();
  dispatch_time_t v0 = (__CFString *)objc_claimAutoreleasedReturnValue();
  if ([(__CFString *)v0 rangeOfString:@"root"] != 0x7FFFFFFFFFFFFFFFLL)
  {

    dispatch_time_t v0 = @"/var/mobile";
  }
  uint64_t v1 = [(__CFString *)v0 stringByAppendingPathComponent:@"Library"];

  int v2 = [v1 stringByAppendingPathComponent:@"Logs/CrashReporter/VoiceTrigger/"];

  return v2;
}

id VTAudioLogDirectory()
{
  if (VTAudioLogDirectory_onceToken != -1) {
    dispatch_once(&VTAudioLogDirectory_onceToken, &__block_literal_global_6700);
  }
  dispatch_time_t v0 = (void *)VTAudioLogDirectory_logPath;

  return v0;
}

void __VTAudioLogDirectory_block_invoke()
{
  CPSharedResourcesDirectory();
  dispatch_time_t v0 = (__CFString *)objc_claimAutoreleasedReturnValue();
  if ([(__CFString *)v0 rangeOfString:@"root"] != 0x7FFFFFFFFFFFFFFFLL)
  {

    dispatch_time_t v0 = @"/var/mobile";
  }
  id v3 = [(__CFString *)v0 stringByAppendingPathComponent:@"Library"];

  uint64_t v1 = [v3 stringByAppendingPathComponent:@"Logs/CrashReporter/VoiceTrigger/audio/"];
  int v2 = (void *)VTAudioLogDirectory_logPath;
  VTAudioLogDirectory_logPath = v1;
}

id VTMakeTimestampedAudioLogFilenameWithPrefixAndSuffix(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = +[VTPreferences sharedPreferences];
  int v6 = [v5 fileLoggingIsEnabled];

  if (v6)
  {
    uint64_t v7 = NSString;
    if (VTAudioLogDirectory_onceToken != -1) {
      dispatch_once(&VTAudioLogDirectory_onceToken, &__block_literal_global_6700);
    }
    objc_storeStrong((id *)&_VTGetOrCreateAudioLogDirectory_audioFileDir, (id)VTAudioLogDirectory_logPath);
    uint64_t v8 = [MEMORY[0x263F08850] defaultManager];
    char v9 = [v8 fileExistsAtPath:_VTGetOrCreateAudioLogDirectory_audioFileDir isDirectory:0];

    id v10 = 0;
    if ((v9 & 1) == 0)
    {
      uint64_t v11 = [MEMORY[0x263F08850] defaultManager];
      id v26 = 0;
      char v12 = [v11 createDirectoryAtPath:_VTGetOrCreateAudioLogDirectory_audioFileDir withIntermediateDirectories:1 attributes:0 error:&v26];
      id v10 = v26;

      if ((v12 & 1) == 0)
      {
        timeval v13 = (void *)VTLogContextFacilityVoiceTrigger;
        if (os_log_type_enabled((os_log_t)VTLogContextFacilityVoiceTrigger, OS_LOG_TYPE_ERROR))
        {
          uint64_t v23 = _VTGetOrCreateAudioLogDirectory_audioFileDir;
          long long v24 = v13;
          float v25 = [v10 localizedDescription];
          *(_DWORD *)buf = 138543618;
          uint64_t v28 = v23;
          __int16 v29 = 2114;
          float v30 = v25;
          _os_log_error_impl(&dword_21844F000, v24, OS_LOG_TYPE_ERROR, "Couldn't create voice trigger log directory at path %{public}@ %{public}@", buf, 0x16u);
        }
        tms v14 = (void *)_VTGetOrCreateAudioLogDirectory_audioFileDir;
        _VTGetOrCreateAudioLogDirectory_audioFileDir = @"/tmp";
      }
    }
    id v15 = (id)_VTGetOrCreateAudioLogDirectory_audioFileDir;

    unsigned int v16 = (void *)_dateFormatter;
    uint64_t v17 = [MEMORY[0x263EFF910] date];
    unsigned int v18 = [v16 stringFromDate:v17];

    uint64_t v19 = &stru_26C99F218;
    if (v18) {
      uint64_t v19 = v18;
    }
    uint64_t v20 = [v7 stringWithFormat:@"%@/%@%@%@", v15, v3, v19, v4];

    uint64_t v21 = [v20 stringByReplacingOccurrencesOfString:@" " withString:@"_"];
  }
  else
  {
    uint64_t v21 = 0;
  }

  return v21;
}

void VTLogInitIfNeeded()
{
  if (VTLogInitIfNeeded_once != -1) {
    dispatch_once(&VTLogInitIfNeeded_once, &__block_literal_global_30);
  }
}

void AccelWindow::init(AccelWindow *this, const char *a2, const BOOL *a3, const BOOL *a4, double a5)
{
  int v6 = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  *((unsigned char *)this + 5) = *a3;
  if (*((_DWORD *)this + 6) != v6)
  {
    *((_DWORD *)this + 6) = v6;
    operator new[]();
  }
  *((unsigned char *)this + 6) = *a4;
  *((_DWORD *)this + 8) = 1;
  if (!*(_DWORD *)a2)
  {
    *((unsigned char *)this + 4) = 0;
    Error::chuck((Error *)"NWindow::init() - window length cannot be zero", a2);
  }
  uint64_t v7 = *(unsigned int *)this;
  if (*((unsigned char *)this + 5))
  {
    if (!v7) {
      goto LABEL_14;
    }
    uint64_t v8 = *((void *)this + 2);
    if (v7 == 1)
    {
      uint64_t v9 = 0;
      float v10 = (float)1u + -1.0;
      do
      {
LABEL_13:
        float v18 = cosf((float)((float)v9 * 6.2832) / v10);
        float v10 = (float)v7 + -1.0;
        float v19 = v18 * -0.46 + 0.54;
        *(float *)(v8 + 4 * v9++) = v19;
      }
      while (v7 != v9);
      goto LABEL_14;
    }
    uint64_t v9 = v7 & 0xFFFFFFFE;
    *(float *)&a5 = (float)v7 + -1.0;
    float32x2_t v11 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0);
    int32x2_t v12 = (int32x2_t)0x100000000;
    float32x2_t v13 = (float32x2_t)vdup_n_s32(0x40C90FD0u);
    float64x2_t v20 = (float64x2_t)vdupq_n_s64(0x3FE147AE147AE148uLL);
    float64x2_t v21 = (float64x2_t)vdupq_n_s64(0xBFDD70A3D70A3D71);
    tms v14 = (float32x2_t *)*((void *)this + 2);
    uint64_t v15 = v9;
    do
    {
      float32x2_t v16 = vdiv_f32(vmul_f32(vcvt_f32_u32((uint32x2_t)v12), v13), v11);
      float v22 = v16.f32[0];
      float v23 = cosf(v16.f32[1]);
      v17.f32[0] = cosf(v22);
      v17.f32[1] = v23;
      *v14++ = vcvt_f32_f64(vmlaq_f64(v20, v21, vcvtq_f64_f32(v17)));
      int32x2_t v12 = vadd_s32(v12, (int32x2_t)0x200000002);
      v15 -= 2;
    }
    while (v15);
    float v10 = (float)v7 + -1.0;
    if (v9 != v7) {
      goto LABEL_13;
    }
  }
  else if (v7)
  {
    memset_pattern16(*((void **)this + 2), &unk_21852DED0, 4 * v7);
  }
LABEL_14:
  *((unsigned char *)this + 4) = 1;
}

void AccelWindow::initHamming(AccelWindow *this, double a2)
{
  uint64_t v2 = *(unsigned int *)this;
  if (*((unsigned char *)this + 5))
  {
    if (!v2) {
      return;
    }
    uint64_t v3 = *((void *)this + 2);
    if (v2 == 1)
    {
      uint64_t v4 = 0;
      float v5 = (float)1u + -1.0;
      do
      {
LABEL_12:
        float v14 = cosf((float)((float)v4 * 6.2832) / v5);
        float v5 = (float)v2 + -1.0;
        float v15 = v14 * -0.46 + 0.54;
        *(float *)(v3 + 4 * v4++) = v15;
      }
      while (v2 != v4);
      return;
    }
    uint64_t v4 = v2 & 0xFFFFFFFE;
    *(float *)&a2 = (float)v2 + -1.0;
    float32x2_t v7 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a2, 0);
    int32x2_t v8 = (int32x2_t)0x100000000;
    float32x2_t v9 = (float32x2_t)vdup_n_s32(0x40C90FD0u);
    float64x2_t v16 = (float64x2_t)vdupq_n_s64(0x3FE147AE147AE148uLL);
    float64x2_t v17 = (float64x2_t)vdupq_n_s64(0xBFDD70A3D70A3D71);
    float v10 = (float32x2_t *)*((void *)this + 2);
    uint64_t v11 = v4;
    do
    {
      float32x2_t v12 = vdiv_f32(vmul_f32(vcvt_f32_u32((uint32x2_t)v8), v9), v7);
      float v18 = v12.f32[0];
      float v19 = cosf(v12.f32[1]);
      v13.f32[0] = cosf(v18);
      v13.f32[1] = v19;
      *v10++ = vcvt_f32_f64(vmlaq_f64(v16, v17, vcvtq_f64_f32(v13)));
      int32x2_t v8 = vadd_s32(v8, (int32x2_t)0x200000002);
      v11 -= 2;
    }
    while (v11);
    float v5 = (float)v2 + -1.0;
    if (v4 != v2) {
      goto LABEL_12;
    }
  }
  else if (v2)
  {
    int v6 = (void *)*((void *)this + 2);
    memset_pattern16(v6, &unk_21852DED0, 4 * v2);
  }
}

void AccelWindow::apply(unsigned int *a1, uint64_t a2)
{
  if (!*((unsigned char *)a1 + 4)) {
    Error::chuck((Error *)"AccelWindow::apply() - AccelWindow::init() has to be called before running", (const char *)a2);
  }
  uint64_t v2 = *(unsigned int *)(a2 + 16);
  if (v2 != *a1) {
    Error::chuck((Error *)"AccelWindow::apply() - length of input array should be %d, not %d", (const char *)a2, *a1, v2);
  }

  AccelWindow::applyHamming(a1, a2);
}

void AccelWindow::applyHamming(unsigned int *a1, uint64_t a2)
{
  float __C = 0.0;
  vDSP_meanv(*(const float **)(a2 + 8), 1, &__C, *a1);
  float __B = -__C;
  if (*((unsigned char *)a1 + 6)) {
    vDSP_vsadd(*(const float **)(a2 + 8), 1, &__B, *(float **)(a2 + 8), 1, *a1);
  }
  vDSP_vmul(*(const float **)(a2 + 8), 1, *((const float **)a1 + 2), 1, *(float **)(a2 + 8), 1, *a1);
}

float AccelWindow::getOffset(unsigned int *a1, uint64_t a2)
{
  float __C = 0.0;
  vDSP_meanv(*(const float **)(a2 + 8), 1, &__C, *a1);
  return __C;
}

uint64_t AccelWindow::getHamming(AccelWindow *this)
{
  return (uint64_t)this + 8;
}

unsigned int *AccelWindow::rescale(unsigned int *result, uint64_t a2)
{
  uint64_t v2 = *result;
  if (v2)
  {
    uint64_t v3 = *(int **)(a2 + 8);
    float v4 = 0.0;
    float v5 = (float *)v3;
    uint64_t v6 = *result;
    do
    {
      float v7 = *v5;
      if (*v5 > v4 || v7 < (float)-v4)
      {
        if (v7 > 32766.0 || v7 < -32766.0) {
          goto LABEL_19;
        }
        if (v7 <= 0.0) {
          float v4 = -v7;
        }
        else {
          float v4 = *v5;
        }
      }
      ++v5;
      --v6;
    }
    while (v6);
    if (v4 >= 32766.0)
    {
LABEL_19:
      result[8] = 1;
      do
      {
        int v11 = 1191181312;
        if (*(float *)v3 > 32766.0 || (int v11 = -956302336, *(float *)v3 < -32766.0)) {
          *uint64_t v3 = v11;
        }
        ++v3;
        --v2;
      }
      while (v2);
    }
    else
    {
      if (v4 <= 0.0) {
        int v10 = 0x7FFF;
      }
      else {
        int v10 = (int)(float)(32767.0 / v4);
      }
      result[8] = v10;
      float32x2_t v12 = *(float32x4_t **)(a2 + 8);
      float v13 = (float)v10;
      if (v2 < 8)
      {
        uint64_t v14 = 0;
LABEL_32:
        uint64_t v18 = v2 - v14;
        float v19 = &v12->f32[v14];
        do
        {
          float *v19 = *v19 * v13;
          ++v19;
          --v18;
        }
        while (v18);
        return result;
      }
      uint64_t v14 = v2 & 0xFFFFFFF8;
      float v15 = v12 + 1;
      uint64_t v16 = v14;
      do
      {
        float32x4_t v17 = vmulq_n_f32(*v15, v13);
        v15[-1] = vmulq_n_f32(v15[-1], v13);
        *float v15 = v17;
        v15 += 2;
        v16 -= 8;
      }
      while (v16);
      if (v14 != v2) {
        goto LABEL_32;
      }
    }
  }
  else
  {
    result[8] = 0x7FFF;
  }
  return result;
}

uint64_t AccelWindow::getScalingFactor(AccelWindow *this)
{
  return *((unsigned int *)this + 8);
}

void NLoadedMemory::~NLoadedMemory(NLoadedMemory *this)
{
  *(void *)this = &unk_26C99AA30;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = 0;
  size_t v2 = *((unsigned int *)this + 14);
  if (v2) {
    munmap(*((void **)this + 8), v2);
  }
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
  uint64_t v3 = *((void *)this + 3);
  int v4 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 24, "", &v4);
  *((void *)this + 3) = &unk_26C99B388;
  free(*((void **)this + 5));
  *((void *)this + 5) = 0;
  *((void *)this + 3) = &unk_26C99C5B0;

  JUMPOUT(0x21D46B240);
}

{
  size_t v2;
  uint64_t v3;
  int v4;

  *(void *)this = &unk_26C99AA30;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = 0;
  size_t v2 = *((unsigned int *)this + 14);
  if (v2) {
    munmap(*((void **)this + 8), v2);
  }
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
  uint64_t v3 = *((void *)this + 3);
  int v4 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 24, "", &v4);
  *((void *)this + 3) = &unk_26C99B388;
  free(*((void **)this + 5));
  *((void *)this + 5) = 0;
  *((void *)this + 3) = &unk_26C99C5B0;
}

{
  size_t v2;
  uint64_t v3;
  int v4;

  *(void *)this = &unk_26C99AA30;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = 0;
  size_t v2 = *((unsigned int *)this + 14);
  if (v2) {
    munmap(*((void **)this + 8), v2);
  }
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
  uint64_t v3 = *((void *)this + 3);
  int v4 = 0;
  (*(void (**)(char *, const char *, int *))(v3 + 64))((char *)this + 24, "", &v4);
  *((void *)this + 3) = &unk_26C99B388;
  free(*((void **)this + 5));
  *((void *)this + 5) = 0;
  *((void *)this + 3) = &unk_26C99C5B0;
}

void NLoadedMemory::NLoadedMemory(NLoadedMemory *this)
{
  *(void *)this = &unk_26C99AA30;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = &unk_26C99B388;
  *((_DWORD *)this + 12) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 12));
  }
  uint64_t v3 = memptr;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = v3;
  *((void *)this + 3) = &unk_26C99B388;
  *uint64_t v3 = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
}

{
  const char *v2;
  unsigned char *v3;
  void *memptr;

  *(void *)this = &unk_26C99AA30;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = &unk_26C99B388;
  *((_DWORD *)this + 12) = 16;
  memptr = 0;
  if (malloc_type_posix_memalign(&memptr, 0x10uLL, 1uLL, 0xB72AFE98uLL)) {
    Error::chuck((Error *)"N16ByteAlignedString::allocate() - failed to allocate %d bytes %d-aligned", v2, 1, *((unsigned int *)this + 12));
  }
  uint64_t v3 = memptr;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 5) = v3;
  *((void *)this + 3) = &unk_26C99B388;
  *uint64_t v3 = 0;
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
}

uint64_t NLoadedMemory::reset(NLoadedMemory *this)
{
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = 0;
  size_t v2 = *((unsigned int *)this + 14);
  if (v2) {
    munmap(*((void **)this + 8), v2);
  }
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
  int v4 = 0;
  return (*(uint64_t (**)(char *, const char *, int *))(*((void *)this + 3) + 64))((char *)this + 24, "", &v4);
}

uint64_t NLoadedMemory::setAlignment(uint64_t this, unsigned int *a2)
{
  unsigned int v2 = *a2;
  if (*a2) {
    *(_DWORD *)(this + 48) = v2;
  }
  else {
    unsigned int v2 = *(_DWORD *)(this + 48);
  }
  if (*(void *)(this + 40) % (unint64_t)v2)
  {
    int v3 = *(_DWORD *)(this + 32);
    return (*(uint64_t (**)(uint64_t))(*(void *)(this + 24) + 64))(this + 24);
  }
  return this;
}

uint64_t NLoadedMemory::load(NLoadedMemory *this, const NString *a2)
{
  size_t v4 = *((unsigned int *)this + 14);
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = 0;
  if (v4) {
    munmap(*((void **)this + 8), v4);
  }
  *((_DWORD *)this + 14) = 0;
  *((void *)this + 8) = 0;
  uint64_t v5 = *((void *)this + 3);
  LODWORD(v17) = 0;
  (*(void (**)(char *, const char *, void **))(v5 + 64))((char *)this + 24, "", &v17);
  LODWORD(v19) = 0;
  unsigned int v8 = *((_DWORD *)a2 + 2);
  if (v8 < 7)
  {
    if (v8 < 4) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  float32x2_t v9 = (int *)*((void *)a2 + 2);
  int v10 = *v9;
  int v11 = *(int *)((char *)v9 + 3);
  if (v10 != 1684957549 || v11 != 980968804)
  {
LABEL_10:
    float v13 = (_DWORD *)*((void *)a2 + 2);
    if (*v13 == 980443501)
    {
      float32x4_t v17 = &unk_26C99C5B0;
      if (v13)
      {
        unsigned int v18 = v8 - 4;
        operator new[]();
      }
      Error::chuck((Error *)"Null pointer passed to string constructor", v6);
    }
LABEL_11:
    operator new[]();
  }
  float32x4_t v17 = 0;
  uint64_t result = NMemoryFile::getMemoryBlockParams(a2, (const NString *)&v17, (const void **)&v19, v7);
  if ((result & 1) == 0) {
    Error::chuck((Error *)"NLoadedMemory::read() - %s does not define a memory block", v15, *((void *)a2 + 2));
  }
  int v16 = (int)v19;
  *((void *)this + 2) = v17;
  *((_DWORD *)this + 2) = v16;
  return result;
}

void sub_218528770(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17) {
    MEMORY[0x21D46B220](a17, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t NLoadedMemory::mapFile(NLoadedMemory *this, const char **a2)
{
  int v4 = open(a2[2], 0);
  if (v4 == -1) {
    Error::chuck((Error *)"NLoadedMemory::mapFile() - cannot open %s", v5, a2[2]);
  }
  int v6 = v4;
  size_t v7 = lseek(v4, 0, 2);
  if (v7 >> 31)
  {
    close(v6);
    Error::chuck((Error *)"NLoadedMemory::mapFile() - cannot determine size of %s", v12, a2[2]);
  }
  int v8 = v7;
  float32x2_t v9 = mmap(0, v7, 1, 1, v6, 0);
  if (v9 == (void *)-1)
  {
    close(v6);
    Error::chuck((Error *)"NLoadedMemory::mapFile() - cannot map %s", v13, a2[2]);
  }
  *((void *)this + 8) = v9;
  *((_DWORD *)this + 14) = v8;
  uint64_t result = close(v6);
  if (result == -1) {
    Error::chuck((Error *)"NLoadedMemory::mapFile() - cannot close %s", v11, a2[2]);
  }
  return result;
}

void sub_218528FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getBKDeviceClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v4[0] = 0;
  if (!BiometricKitLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x263EF8330];
    unsigned int v4[2] = 3221225472;
    v4[3] = __BiometricKitLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    void v4[5] = v4;
    long long v5 = xmmword_2643261B0;
    uint64_t v6 = 0;
    BiometricKitLibraryCore_frameworkLibrary = _sl_dlopen();
    unsigned int v2 = (void *)v4[0];
    if (!BiometricKitLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("BKDevice");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    unsigned int v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getBKDeviceClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

Class __getBKDeviceManagerClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v4[0] = 0;
  if (!BiometricKitLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x263EF8330];
    unsigned int v4[2] = 3221225472;
    v4[3] = __BiometricKitLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    void v4[5] = v4;
    long long v5 = xmmword_2643261B0;
    uint64_t v6 = 0;
    BiometricKitLibraryCore_frameworkLibrary = _sl_dlopen();
    unsigned int v2 = (void *)v4[0];
    if (!BiometricKitLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("BKDeviceManager");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    unsigned int v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getBKDeviceManagerClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __BiometricKitLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  BiometricKitLibraryCore_frameworkLibrary = result;
  return result;
}

uint64_t AFPreferencesAssistantEnabled()
{
  return MEMORY[0x270F0EE98]();
}

uint64_t AFPreferencesMobileUserSessionLanguage()
{
  return MEMORY[0x270F0EEA0]();
}

uint64_t AFSiriActivationBuiltInMicVoiceTrigger()
{
  return MEMORY[0x270F0EF38]();
}

uint64_t AFSiriActivationBuiltInMicVoiceTriggerPrewarm()
{
  return MEMORY[0x270F0EF40]();
}

OSStatus AudioConverterConvertComplexBuffer(AudioConverterRef inAudioConverter, UInt32 inNumberPCMFrames, const AudioBufferList *inInputData, AudioBufferList *outOutputData)
{
  return MEMORY[0x270EE2088](inAudioConverter, *(void *)&inNumberPCMFrames, inInputData, outOutputData);
}

OSStatus AudioConverterNew(const AudioStreamBasicDescription *inSourceFormat, const AudioStreamBasicDescription *inDestinationFormat, AudioConverterRef *outAudioConverter)
{
  return MEMORY[0x270EE20B0](inSourceFormat, inDestinationFormat, outAudioConverter);
}

OSStatus AudioFileClose(AudioFileID inAudioFile)
{
  return MEMORY[0x270EE20D0](inAudioFile);
}

OSStatus AudioFileOpenURL(CFURLRef inFileRef, AudioFilePermissions inPermissions, AudioFileTypeID inFileTypeHint, AudioFileID *outAudioFile)
{
  return MEMORY[0x270EE2120](inFileRef, inPermissions, *(void *)&inFileTypeHint, outAudioFile);
}

int BNNSFilterApply(void *filter, const void *in, void *out)
{
  return MEMORY[0x270EDE038](filter, in, out);
}

void *__cdecl BNNSFilterCreateLayerFullyConnected(const BNNSLayerParametersFullyConnected *layer_params, const BNNSFilterParameters *filter_params)
{
  return (void *)MEMORY[0x270EDE088](layer_params, filter_params);
}

void BNNSFilterDestroy(void *filter)
{
}

uint64_t BNNSGraphContextDestroy_v2()
{
  return MEMORY[0x270EDE108]();
}

uint64_t BNNSGraphContextExecute_v2()
{
  return MEMORY[0x270EDE110]();
}

uint64_t BNNSGraphContextMake()
{
  return MEMORY[0x270EDE128]();
}

uint64_t BNNSGraphContextSetMessageLogCallback()
{
  return MEMORY[0x270EDE140]();
}

uint64_t BNNSGraphContextSetMessageLogMask()
{
  return MEMORY[0x270EDE148]();
}

uint64_t BNNSGraphContextSetWeights()
{
  return MEMORY[0x270EDE150]();
}

uint64_t BNNSGraphGetArgumentPosition()
{
  return MEMORY[0x270EDE168]();
}

uint64_t BNNSGraphGetInputCount()
{
  return MEMORY[0x270EDE170]();
}

uint64_t BNNSGraphGetInputNames_v2()
{
  return MEMORY[0x270EDE178]();
}

uint64_t BNNSGraphGetOutputCount()
{
  return MEMORY[0x270EDE180]();
}

uint64_t BNNSGraphGetOutputNames_v2()
{
  return MEMORY[0x270EDE188]();
}

uint64_t BNNSGraphGetTensorDescriptor_v2()
{
  return MEMORY[0x270EDE190]();
}

uint64_t BNNSGraphGetWorkspaceSize_v2()
{
  return MEMORY[0x270EDE198]();
}

size_t BNNSNDArrayGetDataSize(const BNNSNDArrayDescriptor *array)
{
  return MEMORY[0x270EDE1B0](array);
}

unsigned __int8 *__cdecl CC_MD5(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x270ED7AD0](data, *(void *)&len, md);
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x270EE4530](BOOLean);
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x270EE48F0](theDict, key);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x270EE4998](cf1, cf2);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x270EE4B88]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x270EE4BE8](allocator, theType, valuePtr);
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x270EE4C90](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x270EE4CA0](key, applicationID);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return (CFRunLoopRef)MEMORY[0x270EE4E68]();
}

uint64_t CPSharedResourcesDirectory()
{
  return MEMORY[0x270F0CDD8]();
}

OSStatus ExtAudioFileCreateWithURL(CFURLRef inURL, AudioFileTypeID inFileType, const AudioStreamBasicDescription *inStreamDesc, const AudioChannelLayout *inChannelLayout, UInt32 inFlags, ExtAudioFileRef *outExtAudioFile)
{
  return MEMORY[0x270EE2350](inURL, *(void *)&inFileType, inStreamDesc, inChannelLayout, *(void *)&inFlags, outExtAudioFile);
}

OSStatus ExtAudioFileDispose(ExtAudioFileRef inExtAudioFile)
{
  return MEMORY[0x270EE2360](inExtAudioFile);
}

OSStatus ExtAudioFileGetProperty(ExtAudioFileRef inExtAudioFile, ExtAudioFilePropertyID inPropertyID, UInt32 *ioPropertyDataSize, void *outPropertyData)
{
  return MEMORY[0x270EE2378](inExtAudioFile, *(void *)&inPropertyID, ioPropertyDataSize, outPropertyData);
}

OSStatus ExtAudioFileOpenURL(CFURLRef inURL, ExtAudioFileRef *outExtAudioFile)
{
  return MEMORY[0x270EE2388](inURL, outExtAudioFile);
}

OSStatus ExtAudioFileRead(ExtAudioFileRef inExtAudioFile, UInt32 *ioNumberFrames, AudioBufferList *ioData)
{
  return MEMORY[0x270EE23A0](inExtAudioFile, ioNumberFrames, ioData);
}

OSStatus ExtAudioFileSetProperty(ExtAudioFileRef inExtAudioFile, ExtAudioFilePropertyID inPropertyID, UInt32 inPropertyDataSize, const void *inPropertyData)
{
  return MEMORY[0x270EE23B0](inExtAudioFile, *(void *)&inPropertyID, *(void *)&inPropertyDataSize, inPropertyData);
}

OSStatus ExtAudioFileWrapAudioFileID(AudioFileID inFileID, Boolean inForWriting, ExtAudioFileRef *outExtAudioFile)
{
  return MEMORY[0x270EE23C0](inFileID, inForWriting, outExtAudioFile);
}

OSStatus ExtAudioFileWrite(ExtAudioFileRef inExtAudioFile, UInt32 inNumberFrames, const AudioBufferList *ioData)
{
  return MEMORY[0x270EE23D0](inExtAudioFile, *(void *)&inNumberFrames, ioData);
}

IOHIDManagerRef IOHIDManagerCreate(CFAllocatorRef allocator, IOOptionBits options)
{
  return (IOHIDManagerRef)MEMORY[0x270EF4538](allocator, *(void *)&options);
}

IOReturn IOHIDManagerOpen(IOHIDManagerRef manager, IOOptionBits options)
{
  return MEMORY[0x270EF4558](manager, *(void *)&options);
}

void IOHIDManagerRegisterDeviceMatchingCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
}

void IOHIDManagerRegisterDeviceRemovalCallback(IOHIDManagerRef manager, IOHIDDeviceCallback callback, void *context)
{
}

void IOHIDManagerRegisterInputReportCallback(IOHIDManagerRef manager, IOHIDReportCallback callback, void *context)
{
}

void IOHIDManagerScheduleWithRunLoop(IOHIDManagerRef manager, CFRunLoopRef runLoop, CFStringRef runLoopMode)
{
}

void IOHIDManagerSetDeviceMatching(IOHIDManagerRef manager, CFDictionaryRef matching)
{
}

uint64_t IOPSDrawingUnlimitedPower()
{
  return MEMORY[0x270EF4928]();
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x270F95F90]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x270F95FC0]();
}

uint64_t MKBDeviceUnlockedSinceBoot()
{
  return MEMORY[0x270F4AE18]();
}

uint64_t MKBGetDeviceLockState()
{
  return MEMORY[0x270F4AE48]();
}

void NSLog(NSString *format, ...)
{
}

uint64_t PLLogRegisteredEvent()
{
  return MEMORY[0x270F55150]();
}

uint64_t PLShouldLogRegisteredEvent()
{
  return MEMORY[0x270F55158]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _MACleanV1Repository()
{
  return MEMORY[0x270F4A950]();
}

uint64_t _MAMigrateAssets()
{
  return MEMORY[0x270F4A958]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x270F982E8](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x270F982F8](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x270F98638]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x270F98640]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x270F98650]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x270F98658]();
}

uint64_t std::istream::read()
{
  return MEMORY[0x270F98678]();
}

uint64_t std::istream::seekg()
{
  return MEMORY[0x270F98690]();
}

uint64_t std::istream::tellg()
{
  return MEMORY[0x270F98698]();
}

uint64_t std::istream::getline()
{
  return MEMORY[0x270F986B8]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x270F98750]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x270F98758]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x270F98760]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x270F98770]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x270F98778]();
}

{
  return MEMORY[0x270F987C0]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x270F98870]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x270F988A8]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x270F988B0]();
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x270F98DE8]();
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

double __exp10(double a1)
{
  MEMORY[0x270ED7DC8](a1);
  return result;
}

float __exp10f(float a1)
{
  MEMORY[0x270ED7DD0](a1);
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x270ED7E28](*(void *)&a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x270ED7F00](*(void *)&a1);
}

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t a1)
{
  return MEMORY[0x270ED7F08](*(void *)&a1);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x270ED8070]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x270F76310]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x270ED8458]();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x270ED85F8](*(void *)&__upper_bound);
}

double atof(const char *a1)
{
  MEMORY[0x270ED86E0](a1);
  return result;
}

void bzero(void *a1, size_t a2)
{
}

uint64_t cblas_sgemm_NEWLAPACK_ILP64()
{
  return MEMORY[0x270EDE448]();
}

uint64_t cblas_sgemv_NEWLAPACK_ILP64()
{
  return MEMORY[0x270EDE460]();
}

int close(int a1)
{
  return MEMORY[0x270ED8F18](*(void *)&a1);
}

float cosf(float a1)
{
  MEMORY[0x270ED9130](a1);
  return result;
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9458](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x270ED94B8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x270ED94C8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x270ED94D0](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x270ED9510](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x270ED95A8](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x270ED9620]();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x270ED9648](__handle, __symbol);
}

void exit(int a1)
{
}

long double exp(long double __x)
{
  MEMORY[0x270ED9858](__x);
  return result;
}

float expf(float a1)
{
  MEMORY[0x270ED9870](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x270ED98C8](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x270ED99F0](__filename, __mode);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x270ED9A18](*(void *)&a1, a2);
}

void free(void *a1)
{
}

float frexpf(float a1, int *a2)
{
  MEMORY[0x270ED9A70](a2, a1);
  return result;
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

int getpagesize(void)
{
  return MEMORY[0x270ED9CC8]();
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x270ED9D98](a1, a2);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x270ED9F50]();
}

long double ldexp(long double __x, int __e)
{
  MEMORY[0x270EDA028](*(void *)&__e, __x);
  return result;
}

long double log(long double __x)
{
  MEMORY[0x270EDA0A8](__x);
  return result;
}

long double log10(long double __x)
{
  MEMORY[0x270EDA0B0](__x);
  return result;
}

float log10f(float a1)
{
  MEMORY[0x270EDA0B8](a1);
  return result;
}

long double log2(long double __x)
{
  MEMORY[0x270EDA0D8](__x);
  return result;
}

float logf(float a1)
{
  MEMORY[0x270EDA0F8](a1);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x270EDA118](*(void *)&a1, a2, *(void *)&a3);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x270EDA138]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x270EDA158]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x270EDA288](info);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x270EDA398](memptr, alignment, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x270EDA458](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x270EDA598](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x270EDA5F8](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x270EDA738](*(void *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x270EDA748](*(void *)&token, state64);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x270EDA760](name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x270EDA768](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x270EDA770](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x270F9A568](a1);
}

{
  MEMORY[0x270F9A570](context);
}

{
  return (void *)MEMORY[0x270F9A588]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x270F9A658](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x270F9A678](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x270F9A688](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x270F9A6B0](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x270F9A700]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x270F9A728]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x270F9A898](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x270F9A9F8](location, obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x270F9AA38](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x270EDA828](a1, *(void *)&a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

uint64_t os_variant_is_darwinos()
{
  return MEMORY[0x270EDAB50]();
}

float powf(float a1, float a2)
{
  MEMORY[0x270EDAD00](a1, a2);
  return result;
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

float sinf(float a1)
{
  MEMORY[0x270EDB4F0](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x270EDB560](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x270EDB5A8](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x270EDB638](__s1, __s2, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x270EDB680](__s, *(void *)&__c);
}

double strtod(const char *a1, char **a2)
{
  MEMORY[0x270EDB6A8](a1, a2);
  return result;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB6D8](__str, __endptr, *(void *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB708](__str, __endptr, *(void *)&__base);
}

uint64_t sysconf(int a1)
{
  return MEMORY[0x270EDB7C8](*(void *)&a1);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x270EDB7D0](a1, *(void *)&a2, a3, a4, a5, a6);
}

clock_t times(tms *a1)
{
  return MEMORY[0x270EDB940](a1);
}

void vDSP_DFT_DestroySetup(vDSP_DFT_Setup __Setup)
{
}

void vDSP_DFT_Execute(const vDSP_DFT_SetupStruct *__Setup, const float *__Ir, const float *__Ii, float *__Or, float *__Oi)
{
}

vDSP_DFT_Setup vDSP_DFT_zrop_CreateSetup(vDSP_DFT_Setup __Previous, vDSP_Length __Length, vDSP_DFT_Direction __Direction)
{
  return (vDSP_DFT_Setup)MEMORY[0x270EDE950](__Previous, __Length, *(void *)&__Direction);
}

void vDSP_conv(const float *__A, vDSP_Stride __IA, const float *__F, vDSP_Stride __IF, float *__C, vDSP_Stride __IC, vDSP_Length __N, vDSP_Length __P)
{
}

FFTSetup vDSP_create_fftsetup(vDSP_Length __Log2n, FFTRadix __Radix)
{
  return (FFTSetup)MEMORY[0x270EDE9D0](__Log2n, *(void *)&__Radix);
}

void vDSP_ctoz(const DSPComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__Z, vDSP_Stride __IZ, vDSP_Length __N)
{
}

void vDSP_dotpr(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Length __N)
{
}

void vDSP_fft_zip(FFTSetup __Setup, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __Log2N, FFTDirection __Direction)
{
}

void vDSP_hamm_window(float *__C, vDSP_Length __N, int __Flag)
{
}

void vDSP_meanv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_sve(const float *__A, vDSP_Stride __I, float *__C, vDSP_Length __N)
{
}

void vDSP_svesq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_vadd(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vclip(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vfill(const float *__A, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vfix16(const float *__A, vDSP_Stride __IA, __int16 *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vflt16(const __int16 *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vneg(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsadd(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvmags(const DSPSplitComplex *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return MEMORY[0x270EDBA70](a1, a2, a3);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x270EDBB18](__str, __size, __format, a4);
}

void vvexpf(float *a1, const float *a2, const int *a3)
{
}

void vvlogf(float *a1, const float *a2, const int *a3)
{
}

void vvrecf(float *a1, const float *a2, const int *a3)
{
}

void vvsqrtf(float *a1, const float *a2, const int *a3)
{
}

void vvtanhf(float *a1, const float *a2, const int *a3)
{
}