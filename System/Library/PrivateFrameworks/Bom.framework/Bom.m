uint64_t BOMCFArrayMaxRange(const __CFArray *a1)
{
  CFArrayGetCount(a1);
  return 0;
}

CFStringRef BOMCFStringGetUTF8String(CFStringRef theString)
{
  CFStringRef v1 = theString;
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (theString)
  {
    CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
    if (!CStringPtr || (v3 = (char *)CStringPtr, !*CStringPtr))
    {
      if (!CFStringGetCString(v1, buffer, 1024, 0x8000100u)) {
        return 0;
      }
      size_t v8 = strlen(buffer) + 1;
      v5 = (__CFString *)BOM_malloc(v8);
      if (!v5) {
        return 0;
      }
      CFStringRef v1 = v5;
      v6 = buffer;
      size_t v7 = v8;
      goto LABEL_9;
    }
    size_t v4 = strlen(CStringPtr) + 1;
    v5 = (__CFString *)BOM_malloc(v4);
    CFStringRef v1 = v5;
    if (v5)
    {
      v6 = v3;
      size_t v7 = v4;
LABEL_9:
      memmove(v5, v6, v7);
    }
  }
  return v1;
}

CFPropertyListRef BOMCFPropertyListReadFromPath(uint64_t a1, CFOptionFlags a2)
{
  return BOMCFPropertyListReadFromPathWithSys(a1, a2, 0);
}

CFPropertyListRef BOMCFPropertyListReadFromPathWithSys(uint64_t a1, CFOptionFlags a2, void *a3)
{
  if (!a1) {
    return 0;
  }
  v3 = a3;
  if (!a3) {
    v3 = BomSys_default();
  }
  long long v18 = 0u;
  long long v19 = 0u;
  long long v17 = 0u;
  memset(v16, 0, sizeof(v16));
  if ((*((unsigned int (**)(void, uint64_t, _OWORD *))v3 + 10))(*((void *)v3 + 1), a1, v16)) {
    return 0;
  }
  CFIndex v6 = v17;
  size_t v7 = BOM_malloc(v17);
  if (!v7) {
    return 0;
  }
  size_t v8 = v7;
  uint64_t v9 = (*((uint64_t (**)(void, uint64_t, void, void))v3 + 2))(*((void *)v3 + 1), a1, 0, 0);
  if (v9 == -1
    || (uint64_t v10 = v9,
        uint64_t v11 = (*((uint64_t (**)(void, uint64_t, void *, CFIndex))v3 + 6))(*((void *)v3 + 1), v9, v8, v6),
        (*((void (**)(void, uint64_t))v3 + 4))(*((void *)v3 + 1), v10),
        v11 != v6)
    || (CFDataRef v12 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v8, v6, (CFAllocatorRef)*MEMORY[0x263EFFB18])) == 0)
  {
    free(v8);
    return 0;
  }
  CFDataRef v13 = v12;
  CFPropertyListRef v14 = CFPropertyListCreateWithData((CFAllocatorRef)*MEMORY[0x263EFFB08], v12, a2, 0, 0);
  CFRelease(v13);
  return v14;
}

BOOL BOMCFPropertyListWriteToPath(const void *a1, uint64_t a2)
{
  return BOMCFPropertyListWriteToPathWithSys(a1, a2, 0);
}

BOOL BOMCFPropertyListWriteToPathWithSys(CFPropertyListRef propertyList, uint64_t a2, uint64_t (**a3)(void, uint64_t, uint64_t, uint64_t))
{
  BOOL v3 = 1;
  if (propertyList)
  {
    if (a2)
    {
      CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x263EFFB08], propertyList, kCFPropertyListXMLFormat_v1_0, 0, 0);
      if (Data)
      {
        CFDataRef v7 = Data;
        if (!a3) {
          a3 = (uint64_t (**)(void, uint64_t, uint64_t, uint64_t))BomSys_default();
        }
        uint64_t v8 = a3[2](a3[1], a2, 513, 420);
        if (v8 != -1)
        {
          uint64_t v9 = v8;
          CFIndex Length = CFDataGetLength(v7);
          uint64_t v11 = (uint64_t (*)(void, uint64_t, const UInt8 *, CFIndex))a3[7];
          CFDataRef v12 = a3[1];
          BytePtr = CFDataGetBytePtr(v7);
          BOOL v3 = v11(v12, v9, BytePtr, Length) != Length;
          ((void (*)(uint64_t (*)(void, uint64_t, uint64_t, uint64_t), uint64_t))a3[4])(a3[1], v9);
        }
        CFRelease(v7);
      }
    }
  }
  return v3;
}

CFBooleanRef BOMCFGetBoolValue(const __CFBoolean *result)
{
  if (result)
  {
    CFBooleanRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFBooleanGetTypeID())
    {
      return (const __CFBoolean *)CFBooleanGetValue(v1);
    }
    else
    {
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFNumberGetTypeID())
      {
        int valuePtr = 0;
        CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
        return (const __CFBoolean *)(valuePtr != 0);
      }
      else
      {
        CFTypeID v4 = CFGetTypeID(v1);
        if (v4 == CFStringGetTypeID())
        {
          UTF8String = (const char *)BOMCFStringGetUTF8String((CFStringRef)v1);
          CFIndex v6 = (char *)UTF8String;
          do
          {
            char v7 = __tolower(*v6);
            *v6++ = v7;
          }
          while (v7);
          return (const __CFBoolean *)(strcmp(UTF8String, "yes") == 0);
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t BOMCFGetIntValue(const void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID TypeID = CFNumberGetTypeID();
  if (TypeID != CFGetTypeID(a1)) {
    return 0xFFFFFFFFLL;
  }
  unsigned int valuePtr = 0;
  if (CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr)) {
    return valuePtr;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void *BOM_malloc(size_t a1)
{
  CFBooleanRef v1 = malloc_type_malloc(a1, 0x5414152EuLL);
  if (!v1)
  {
    CFTypeID v2 = __error();
    CFTypeID v3 = strerror(*v2);
    CFTypeID v4 = BOMExceptionHandlerMessage("malloc: %s\n", v3);
    v5 = __error();
    _BOMExceptionHandlerCall((uint64_t)v4, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 27, *v5);
  }
  return v1;
}

void *BOM_malloczero(size_t size)
{
  CFTypeID v2 = malloc_type_calloc(1uLL, size, 0xA378B4FEuLL);
  CFTypeID v3 = v2;
  if (v2)
  {
    bzero(v2, size);
  }
  else
  {
    CFTypeID v4 = __error();
    v5 = strerror(*v4);
    CFIndex v6 = BOMExceptionHandlerMessage("calloc: %s\n", v5);
    char v7 = __error();
    _BOMExceptionHandlerCall((uint64_t)v6, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 38, *v7);
  }
  return v3;
}

void *BOM_calloc(size_t a1, size_t a2)
{
  CFTypeID v2 = malloc_type_calloc(a1, a2, 0xC024D4AuLL);
  if (!v2)
  {
    CFTypeID v3 = __error();
    CFTypeID v4 = strerror(*v3);
    v5 = BOMExceptionHandlerMessage("calloc: %s\n", v4);
    CFIndex v6 = __error();
    _BOMExceptionHandlerCall((uint64_t)v5, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 52, *v6);
  }
  return v2;
}

void *BOM_realloc(void *a1, size_t a2)
{
  CFTypeID v2 = reallocf(a1, a2);
  if (!v2)
  {
    CFTypeID v3 = __error();
    CFTypeID v4 = strerror(*v3);
    v5 = BOMExceptionHandlerMessage("reallocf: %s\n", v4);
    CFIndex v6 = __error();
    _BOMExceptionHandlerCall((uint64_t)v5, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 66, *v6);
  }
  return v2;
}

char *BOM_realloczero(void *a1, unint64_t a2, size_t __size)
{
  v5 = (char *)reallocf(a1, __size);
  CFIndex v6 = v5;
  if (v5)
  {
    if (__size > a2) {
      bzero(&v5[a2], __size - a2);
    }
  }
  else
  {
    char v7 = __error();
    uint64_t v8 = strerror(*v7);
    uint64_t v9 = BOMExceptionHandlerMessage("reallocf: %s\n", v8);
    uint64_t v10 = __error();
    _BOMExceptionHandlerCall((uint64_t)v9, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMSystemCmds.c", 80, *v10);
  }
  return v6;
}

uint64_t BOM_strrncmp(const char *a1, const char *a2, size_t a3)
{
  size_t v6 = strlen(a1);
  size_t v7 = strlen(a2);
  if (v6 >= v7) {
    size_t v8 = v7;
  }
  else {
    size_t v8 = v6;
  }
  if (v8 >= a3) {
    size_t v9 = a3;
  }
  else {
    size_t v9 = v8;
  }
  return strncmp(&a1[v6 - v8], &a2[v7 - v8], v9);
}

uint64_t pkzip_crypto_init(int *a1, char *__s)
{
  CFTypeID v2 = __s;
  *(void *)a1 = 0x2345678912345678;
  a1[2] = 878082192;
  uint64_t result = strlen(__s);
  if (result)
  {
    uint64_t v5 = result;
    do
    {
      unsigned int v6 = *v2++;
      uint64_t result = pkzip_crypto_update(a1, v6);
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t pkzip_crypto_update(int *a1, uint64_t a2)
{
  int v2 = PKZip_crctab[(*a1 ^ a2)] ^ (*a1 >> 8);
  unsigned int v3 = 134775813 * (a1[1] + v2) + 1;
  *a1 = v2;
  a1[1] = v3;
  a1[2] = PKZip_crctab[a1[2] ^ HIBYTE(v3)] ^ (a1[2] >> 8);
  return a2;
}

uint64_t pkzip_crypto_decrypt_buffer(int *a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    do
    {
      int v6 = *a2;
      unsigned int v7 = (a1[2] & 0xFFFD ^ 3) * (a1[2] | 2);
      int v8 = v6 ^ (v7 >> 8);
      pkzip_crypto_update(a1, (char)(v6 ^ BYTE1(v7)));
      *a2++ = v8;
      --v3;
    }
    while (v3);
  }
  return 0;
}

void **BOMStackNew()
{
  v0 = (void **)BOM_calloc(1uLL, 0x18uLL);
  CFBooleanRef v1 = v0;
  if (v0)
  {
    v0[1] = (void *)1024;
    int v2 = BOM_malloczero(0x2000uLL);
    *CFBooleanRef v1 = v2;
    if (!v2)
    {
      BOMStackFree(v1);
      return 0;
    }
  }
  return v1;
}

void BOMStackFree(void **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2) {
      free(v2);
    }
    free(a1);
  }
}

uint64_t *BOMStackPop(uint64_t *result)
{
  if (result)
  {
    uint64_t v1 = *result;
    if (*result && (uint64_t v2 = result[2]) != 0)
    {
      uint64_t v3 = v2 - 1;
      result[2] = v3;
      uint64_t result = *(uint64_t **)(v1 + 8 * v3);
      *(void *)(v1 + 8 * v3) = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *BOMStackPeek(void *result)
{
  if (result)
  {
    if (*result && (uint64_t v1 = result[2]) != 0) {
      return *(void **)(*result + 8 * v1 - 8);
    }
    else {
      return 0;
    }
  }
  return result;
}

void *BOMStackPoke(void *result, uint64_t a2)
{
  if (result && *result)
  {
    uint64_t v2 = result[2];
    if (v2) {
      *(void *)(*result + 8 * v2 - 8) = a2;
    }
  }
  return result;
}

char *BOMStackPush(char *result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = result;
    uint64_t result = *(char **)result;
    if (result)
    {
      unint64_t v5 = v2[1];
      uint64_t v4 = v2[2];
      uint64_t v6 = v4 + 1;
      if (v4 + 1 < v5)
      {
LABEL_9:
        v2[2] = v6;
        *(void *)&result[8 * v4] = a2;
        return result;
      }
      if (v5 != 0xFFFFFFF)
      {
        uint64_t v7 = 2 * v5;
        if (2 * v5 >= 0xFFFFFFF) {
          uint64_t v7 = 0xFFFFFFFLL;
        }
        v2[1] = v7;
        uint64_t result = BOM_realloczero(result, 8 * v5, 8 * v7);
        *uint64_t v2 = result;
        if (result)
        {
          uint64_t v4 = v2[2];
          uint64_t v6 = v4 + 1;
          goto LABEL_9;
        }
      }
    }
  }
  return result;
}

BOOL BOMStackIsEmpty(uint64_t a1)
{
  return !a1 || !*(void *)a1 || *(_DWORD *)(a1 + 16) < 1;
}

uint64_t BOMStackCount(uint64_t result)
{
  if (result)
  {
    if (*(void *)result) {
      return *(unsigned int *)(result + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

void *darc_format_entry_new(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0;
  }
  uint64_t result = platform_calloc(a1, 1uLL, 0x48uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 1853125241;
    result[1] = a1;
    *((_DWORD *)result + 16) = 2037544037;
  }
  return result;
}

void darc_format_entry_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1853125241 && *((_DWORD *)__b + 16) == 2037544037)
  {
    uint64_t v2 = (char *)__b[5];
    if (v2)
    {
      if (*((_DWORD *)__b + 8))
      {
        uint64_t v3 = 0;
        unint64_t v4 = 0;
        do
        {
          if (*(void *)&v2[v3])
          {
            platform_free(__b[1], *(void **)&v2[v3]);
            uint64_t v2 = (char *)__b[5];
            *(void *)&v2[v3] = 0;
          }
          *(void *)&v2[v3 + 8] = 0;
          if (*(void *)&v2[v3 + 16])
          {
            platform_free(__b[1], *(void **)&v2[v3 + 16]);
            uint64_t v2 = (char *)__b[5];
            *(void *)&v2[v3 + 16] = 0;
          }
          *(void *)&v2[v3 + 24] = 0;
          ++v4;
          v3 += 32;
        }
        while (v4 < *((unsigned int *)__b + 8));
      }
      platform_free(__b[1], v2);
    }
    uint64_t v5 = __b[1];
    platform_memset(v5, __b, 0, 0x48uLL);
    platform_free(v5, __b);
  }
}

uint64_t darc_format_entry_set_type(_DWORD *a1, int a2)
{
  if (!a1 || *a1 != 1853125241 || a1[16] != 2037544037) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  a1[4] = a2;
  return result;
}

_DWORD *darc_format_entry_get_type(_DWORD *result)
{
  if (result)
  {
    if (*result == 1853125241 && result[16] == 2037544037) {
      return (_DWORD *)result[4];
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t darc_format_entry_set_size(uint64_t a1, uint64_t a2)
{
  if (!a1 || *(_DWORD *)a1 != 1853125241 || *(_DWORD *)(a1 + 64) != 2037544037) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(void *)(a1 + 24) = a2;
  return result;
}

uint64_t darc_format_entry_set_attribute(uint64_t a1, char *__s, void *a3, size_t a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1853125241) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (__s)
  {
    if (*(_DWORD *)(a1 + 64) == 2037544037)
    {
      size_t v9 = strlen(__s);
      uint64_t result = 0xFFFFFFFFLL;
      if (a4)
      {
        if (a3 && v9)
        {
          unsigned int v10 = *(_DWORD *)(a1 + 32);
          if (v10)
          {
            uint64_t v11 = 0;
            uint64_t v12 = 0;
            LODWORD(v13) = 0;
            do
            {
              uint64_t v14 = *(void *)(a1 + 40);
              if (v9 == *(void *)(v14 + v11 + 8))
              {
                int v15 = platform_strncmp(*(void *)(a1 + 8), __s, *(char **)(v14 + v11), v9);
                BOOL v16 = v15 == 0;
                if (!v15) {
                  LODWORD(v13) = v12;
                }
                unsigned int v10 = *(_DWORD *)(a1 + 32);
              }
              else
              {
                BOOL v16 = 0;
              }
              if (++v12 >= (unint64_t)v10) {
                break;
              }
              v11 += 32;
            }
            while (!v16);
            if (v16)
            {
              long long v17 = *(void **)(*(void *)(a1 + 40) + 32 * v13 + 16);
              if (v17) {
                platform_free(*(void *)(a1 + 8), v17);
              }
              goto LABEL_24;
            }
          }
          unsigned int v18 = v10 + 1;
          long long v19 = platform_realloc(*(void *)(a1 + 8), *(void **)(a1 + 40), 32 * (v10 + 1));
          if (v19)
          {
            uint64_t v13 = *(unsigned int *)(a1 + 32);
            *(_DWORD *)(a1 + 32) = v18;
            *(void *)(a1 + 40) = v19;
            v20 = platform_strdup(*(void *)(a1 + 8), __s);
            if (v20)
            {
              v21 = (char **)(*(void *)(a1 + 40) + 32 * v13);
              *v21 = v20;
              v21[1] = (char *)v9;
LABEL_24:
              v22 = platform_malloc(*(void *)(a1 + 8), a4);
              if (v22)
              {
                v23 = v22;
                platform_memcpy(*(void *)(a1 + 8), v22, a3, a4);
                uint64_t result = 0;
                uint64_t v24 = *(void *)(a1 + 40) + 32 * v13;
                *(void *)(v24 + 16) = v23;
                *(void *)(v24 + 24) = a4;
                return result;
              }
              v27 = (FILE *)*MEMORY[0x263EF8348];
              v28 = __error();
              strerror(*v28);
              fprintf(v27, "Could not allocate %ld bytes for value: %s\n");
              return 0xFFFFFFFFLL;
            }
            v29 = (FILE *)*MEMORY[0x263EF8348];
            v30 = __error();
            strerror(*v30);
            fprintf(v29, "Could not duplicate key %s: %s\n");
          }
          else
          {
            v25 = (FILE *)*MEMORY[0x263EF8348];
            v26 = __error();
            strerror(*v26);
            fprintf(v25, "Could not re-allocate the entry list: %s\n");
          }
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return result;
}

uint64_t darc_format_entry_get_attribute(uint64_t a1, char *__s, void *a3)
{
  if (!a1 || *(_DWORD *)a1 != 1853125241) {
    return -1;
  }
  uint64_t v5 = -1;
  if (__s)
  {
    if (*(_DWORD *)(a1 + 64) == 2037544037)
    {
      size_t v7 = platform_strlen(*(void *)(a1 + 8), __s);
      if (v7)
      {
        if (*(_DWORD *)(a1 + 32))
        {
          size_t v8 = v7;
          uint64_t v9 = 0;
          unint64_t v10 = 0;
          do
          {
            uint64_t v11 = *(void *)(a1 + 40);
            if (v8 == *(void *)(v11 + v9 + 8)
              && !platform_strncmp(*(void *)(a1 + 8), __s, *(char **)(v11 + v9), v8))
            {
              uint64_t v12 = *(void *)(a1 + 40) + v9;
              uint64_t v5 = *(void *)(v12 + 24);
              if (a3) {
                platform_memcpy(*(void *)(a1 + 8), a3, *(void **)(v12 + 16), *(void *)(v12 + 24));
              }
            }
            ++v10;
            v9 += 32;
          }
          while (v10 < *(unsigned int *)(a1 + 32));
        }
      }
    }
  }
  return v5;
}

uint64_t darc_format_entry_set_range(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1 || *(_DWORD *)a1 != 1853125241 || *(_DWORD *)(a1 + 64) != 2037544037) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = a3;
  return result;
}

CFMutableArrayRef BOMPatternListNew()
{
  return CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
}

void BOMPatternListFree(const __CFArray *a1)
{
  if (a1)
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a1))
    {
      CFIndex Count = CFArrayGetCount(a1);
      if (Count >= 1)
      {
        CFIndex v4 = Count;
        for (CFIndex i = 0; i != v4; ++i)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(a1, i);
          if (ValueAtIndex)
          {
            size_t v7 = ValueAtIndex;
            MEMORY[0x21666D560]();
            free(v7);
          }
        }
      }
      CFRelease(a1);
    }
  }
}

void BOMPatternFree(void *a1)
{
  if (a1)
  {
    MEMORY[0x21666D560]();
    free(a1);
  }
}

regex_t *BOMPatternCompileString(const char *a1)
{
  uint64_t v2 = (regex_t *)BOM_malloc(0x20uLL);
  uint64_t v3 = v2;
  if (v2 && regcomp(v2, a1, 5))
  {
    CFIndex v4 = BOMExceptionHandlerMessage("**** WARNING **** Can't compile pattern: %s\n", a1);
    uint64_t v5 = __error();
    _BOMExceptionHandlerCall((uint64_t)v4, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMPatternList.c", 47, *v5);
    free(v3);
    return 0;
  }
  return v3;
}

BOOL BOMPatternMatch(regex_t *a1, const char *a2)
{
  BOOL result = 0;
  if (a1)
  {
    if (a2) {
      return regexec(a1, a2, 0, 0, 0) == 0;
    }
  }
  return result;
}

uint64_t BOMPatternListMatch(const __CFArray *a1, const char *a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(a1) && (CFIndex Count = CFArrayGetCount(a1), Count >= 1))
    {
      CFIndex v7 = Count;
      CFIndex v8 = 0;
      while (1)
      {
        ValueAtIndex = (const regex_t *)CFArrayGetValueAtIndex(a1, v8);
        if (ValueAtIndex)
        {
          if (!regexec(ValueAtIndex, a2, 0, 0, 0)) {
            break;
          }
        }
        if (v7 == ++v8) {
          return 0;
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

__CFArray *BOMPatternListFromStringList(const void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID != CFGetTypeID(a1)) {
    return 0;
  }
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
  if (Mutable)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      for (CFIndex i = 0; i != v5; ++i)
      {
        ValueAtIndex = (const char *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
        if (ValueAtIndex)
        {
          CFIndex v8 = BOMPatternCompileString(ValueAtIndex);
          if (v8) {
            CFArrayAppendValue(Mutable, v8);
          }
        }
      }
    }
  }
  return Mutable;
}

__CFArray *BOMPatternListExtractFromFile(const char *a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v2 = fopen(a1, "r");
  if (v2)
  {
    uint64_t v3 = v2;
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
    if (Mutable)
    {
      while (1)
      {
        do
        {
          if (!fgets(__s, 1025, v3)) {
            goto LABEL_11;
          }
          size_t v5 = strlen(__s);
        }
        while (!v5);
        size_t v6 = v5 - 1;
        if (__s[v5 - 1] == 10) {
          break;
        }
LABEL_7:
        size_t v7 = strlen(__s);
        if (v7)
        {
          size_t v6 = v7 - 1;
          if (__s[v7 - 1] == 47) {
            break;
          }
        }
        CFIndex v8 = BOMPatternCompileString(__s);
        if (v8) {
          CFArrayAppendValue(Mutable, v8);
        }
      }
      __s[v6] = 0;
      goto LABEL_7;
    }
LABEL_11:
    fclose(v3);
  }
  else
  {
    uint64_t v9 = __error();
    unint64_t v10 = strerror(*v9);
    uint64_t v11 = BOMExceptionHandlerMessage("can't open %s for reading: %s\n", a1, v10);
    uint64_t v12 = __error();
    _BOMExceptionHandlerCall((uint64_t)v11, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMPatternList.c", 130, *v12);
    return 0;
  }
  return Mutable;
}

__CFArray *BOMPatternListExtractFromStrings(int a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
  if (Mutable) {
    BOOL v5 = a1 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    uint64_t v6 = 0;
    while (1)
    {
      strncpy(__dst, *(const char **)(a2 + 8 * v6), 0x400uLL);
      size_t v7 = strlen(__dst);
      if (v7) {
        break;
      }
LABEL_13:
      if (++v6 == a1) {
        return Mutable;
      }
    }
    size_t v8 = v7 - 1;
    if (__dst[v7 - 1] != 10) {
      goto LABEL_9;
    }
    while (1)
    {
      __dst[v8] = 0;
LABEL_9:
      size_t v9 = strlen(__dst);
      if (v9)
      {
        size_t v8 = v9 - 1;
        if (__dst[v9 - 1] == 47) {
          continue;
        }
      }
      unint64_t v10 = BOMPatternCompileString(__dst);
      if (v10) {
        CFArrayAppendValue(Mutable, v10);
      }
      goto LABEL_13;
    }
  }
  return Mutable;
}

uint64_t BOMFileNewFromFD(void *a1, uint64_t a2, char a3, unsigned __int8 *a4)
{
  return BOMFileNewFromFDWithSys(a1, a2, a3, a4, 0);
}

uint64_t BOMFileNewFromFDWithSys(void *a1, uint64_t a2, char a3, unsigned __int8 *a4, void (**a5)(void, uint64_t, uint64_t, uint64_t))
{
  unint64_t v10 = BOM_malloczero(0x118uLL);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v10;
  if (a5)
  {
    if ((a3 & 0x10) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  a5 = (void (**)(void, uint64_t, uint64_t, uint64_t))BomSys_default();
  if ((a3 & 0x10) != 0) {
LABEL_4:
  }
    a5[5](a5[1], a2, 48, 1);
LABEL_5:
  *uint64_t v11 = *a4 == 119;
  v11[2] = a2;
  if (_BOMFileInit(v11, a3 & 0xF, a5))
  {
LABEL_6:
    uint64_t v12 = v11;
LABEL_7:
    _freeBOMFile(v12);
    return 0xFFFFFFFFLL;
  }
  if ((a3 & 0x20) != 0)
  {
    if (getenv("BOM_ASYNC_DEBUG"))
    {
      gBOMAsyncDebug = 1;
    }
    else if (gBOMAsyncDebug != 1)
    {
LABEL_17:
      uint64_t v14 = BOM_malloczero(0x118uLL);
      if (!v14) {
        goto LABEL_6;
      }
      uint64_t v15 = v14;
      if (*v11 == 1) {
        int v16 = 6;
      }
      else {
        int v16 = 5;
      }
      *(_DWORD *)uint64_t v14 = v16;
      v14[1] = v11;
      if (_BOMFileInit(v14, 0, a5))
      {
        uint64_t v12 = v15;
        goto LABEL_7;
      }
      uint64_t v11 = v15;
      goto LABEL_12;
    }
    fprintf((FILE *)*MEMORY[0x263EF8348], "async compression enabled for %d\n", a2);
    goto LABEL_17;
  }
LABEL_12:
  uint64_t result = 0;
  *a1 = v11;
  return result;
}

uint64_t _BOMFileInit(_DWORD *a1, int a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (!a3) {
    a3 = BomSys_default();
  }
  *((void *)a1 + 34) = a3;
  BOOL v5 = malloc_type_malloc(0x20000uLL, 0xEE4BF368uLL);
  *((void *)a1 + 11) = v5;
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  switch(a2)
  {
    case 8:
      int v6 = 4;
      goto LABEL_10;
    case 2:
      int v6 = 2;
      a1[8] = 2;
      goto LABEL_12;
    case 1:
      int v6 = 1;
LABEL_10:
      a1[8] = v6;
      a1[60] = -1;
      goto LABEL_12;
  }
  int v6 = 0;
  a1[8] = 0;
LABEL_12:
  switch(*a1)
  {
    case 0:
    case 3:
      if (((1 << v6) & 0x16) == 0) {
        goto LABEL_60;
      }
      *(_DWORD *)((char *)&v22.__sig + 7) = 0;
      v22.__sig = 0;
      size_t Raw = _BOMFileReadRaw((uint64_t)a1, (UInt8 *)&v22, 11);
      if (Raw == -1) {
        return 0xFFFFFFFFLL;
      }
      int v8 = a1[8];
      if (v8 == 1)
      {
        if (LOBYTE(v22.__sig) != 31) {
          goto LABEL_58;
        }
        goto LABEL_49;
      }
      if (v8 == 4 && LOBYTE(v22.__sig) == 31)
      {
LABEL_49:
        if (BYTE1(v22.__sig) == 139 && BYTE2(v22.__sig) == 8)
        {
          int v19 = 1;
          goto LABEL_59;
        }
        goto LABEL_58;
      }
      if ((v8 == 2 || v8 == 4) && LOBYTE(v22.__sig) == 66 && BYTE1(v22.__sig) == 90 && BYTE2(v22.__sig) == 104)
      {
        int v19 = 2;
        goto LABEL_59;
      }
LABEL_58:
      int v19 = 0;
LABEL_59:
      a1[8] = v19;
      *((void *)a1 + 9) = Raw;
      a1[20] = 1;
      memcpy(*((void **)a1 + 11), &v22, Raw);
      int v6 = a1[8];
LABEL_60:
      if (v6 == 2)
      {
        uint64_t result = _BOMFileSetupBzip2((uint64_t)a1, 0);
      }
      else if (v6 == 1)
      {
        uint64_t result = _BOMFileSetupGzip((uint64_t)a1, 0, 1);
      }
      else
      {
LABEL_63:
        uint64_t result = 0;
      }
      break;
    case 1:
    case 2:
      if (v6 == 1) {
        goto LABEL_22;
      }
      if (v6 == 2)
      {
        return _BOMFileSetupBzip2((uint64_t)a1, 1);
      }
      if (v6 != 4) {
        goto LABEL_63;
      }
      a1[8] = 1;
LABEL_22:
      *(_DWORD *)((char *)&v22.__sig + 7) = 196608;
      v22.__sig = 559903;
      if (!_BOMFileSetupGzip((uint64_t)a1, 1, 1))
      {
        if (_BOMFileWriteRaw((uint64_t)a1, (UInt8 *)&v22, 10) > 9) {
          goto LABEL_63;
        }
        deflateEnd(*((z_streamp *)a1 + 5));
      }
      return 0xFFFFFFFFLL;
    case 4:
      size_t v9 = BOM_malloczero(8uLL);
      if (!v9) {
        return 0xFFFFFFFFLL;
      }
      unint64_t v10 = v9;
      uint64_t result = 0;
      *unint64_t v10 = 0;
      *((void *)a1 + 1) = v10;
      return result;
    case 5:
      uint64_t result = pthread_once(&gBufferPoolOnce, (void (*)(void))_initBufferPool);
      if (result) {
        return result;
      }
      uint64_t v12 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v12) {
        return 0xFFFFFFFFLL;
      }
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v12);
      *((void *)a1 + 12) = BOMBufferFIFOCreate();
      *((void *)a1 + 13) = 0;
      *((void *)a1 + 29) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 42), 0) || pthread_cond_init((pthread_cond_t *)(a1 + 30), 0)) {
        return 1;
      }
      memset(&v22, 0, sizeof(v22));
      qos_class_t v13 = qos_class_self();
      int v14 = pthread_attr_init(&v22);
      if (!v14) {
        int v14 = pthread_attr_set_qos_class_np(&v22, v13, 0);
      }
      if (v14) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = &v22;
      }
      int v16 = (pthread_t *)(a1 + 28);
      long long v17 = (void *(__cdecl *)(void *))_asyncReadThread;
      return pthread_create(v16, v15, v17, a1) != 0;
    case 6:
      uint64_t result = pthread_once(&gBufferPoolOnce, (void (*)(void))_initBufferPool);
      if (result) {
        return result;
      }
      unsigned int v18 = BOMBufferAllocate(gBOMAsyncBufferSize);
      if (!v18) {
        return 0xFFFFFFFFLL;
      }
      BOMBufferPoolAddBuffer(gBufferPool, (uint64_t)v18);
      *((void *)a1 + 12) = BOMBufferFIFOCreate();
      *((void *)a1 + 13) = 0;
      *((void *)a1 + 29) = 0;
      if (pthread_mutex_init((pthread_mutex_t *)(a1 + 42), 0) || pthread_cond_init((pthread_cond_t *)(a1 + 30), 0)) {
        return 1;
      }
      memset(&v22, 0, sizeof(v22));
      qos_class_t v20 = qos_class_self();
      int v21 = pthread_attr_init(&v22);
      if (!v21) {
        int v21 = pthread_attr_set_qos_class_np(&v22, v20, 0);
      }
      if (v21) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = &v22;
      }
      int v16 = (pthread_t *)(a1 + 28);
      long long v17 = (void *(__cdecl *)(void *))_asyncWriteThread;
      return pthread_create(v16, v15, v17, a1) != 0;
    default:
      return 0xFFFFFFFFLL;
  }
  return result;
}

void _freeBOMFile(void *a1)
{
  if (*(_DWORD *)a1 == 4)
  {
    uint64_t v2 = (void *)a1[1];
    if (v2)
    {
      free(v2);
      a1[1] = 0;
    }
  }
  uint64_t v3 = (void *)a1[5];
  if (v3)
  {
    free(v3);
    a1[5] = 0;
  }
  CFIndex v4 = (void *)a1[6];
  if (v4)
  {
    free(v4);
    a1[6] = 0;
  }
  uint64_t v5 = a1[12];
  if (v5)
  {
    BOMBufferFIFODestroy(v5);
    a1[12] = 0;
  }
  int v6 = (void *)a1[11];
  if (v6) {
    free(v6);
  }
  free(a1);
}

uint64_t BOMFileNewFromCFWriteStream(void *a1, const void *a2, char a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID TypeID = CFWriteStreamGetTypeID();
  if (TypeID != CFGetTypeID(a2)) {
    return 0xFFFFFFFFLL;
  }
  size_t v7 = BOM_malloczero(0x118uLL);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  int v8 = v7;
  *(_DWORD *)size_t v7 = 2;
  v7[1] = a2;
  uint64_t result = _BOMFileInit(v7, a3 & 0xF, 0);
  if (result)
  {
    _freeBOMFile(v8);
    return 0xFFFFFFFFLL;
  }
  *a1 = v8;
  return result;
}

uint64_t BOMFileNewFromCFReadStream(void *a1, const void *a2, char a3)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  CFTypeID TypeID = CFReadStreamGetTypeID();
  if (TypeID != CFGetTypeID(a2)) {
    return 0xFFFFFFFFLL;
  }
  size_t v7 = BOM_malloczero(0x118uLL);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  int v8 = v7;
  *(_DWORD *)size_t v7 = 3;
  v7[1] = a2;
  uint64_t result = _BOMFileInit(v7, a3 & 0xF, 0);
  if (result)
  {
    _freeBOMFile(v8);
    return 0xFFFFFFFFLL;
  }
  *a1 = v8;
  return result;
}

uint64_t BOMFileNewMirror(void *a1)
{
  return BOMFileNewMirrorWithSys(a1, 0);
}

uint64_t BOMFileNewMirrorWithSys(void *a1, void *a2)
{
  CFIndex v4 = BOM_malloczero(0x118uLL);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v4;
  *CFIndex v4 = 4;
  uint64_t result = _BOMFileInit(v4, 0, a2);
  if (result)
  {
    _freeBOMFile(v5);
    return 0xFFFFFFFFLL;
  }
  *a1 = v5;
  return result;
}

uint64_t BOMFileOpen(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  return BOMFileOpenWithSys(a1, a2, a3, a4, a5, 0);
}

uint64_t BOMFileOpenWithSys(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, void (**a6)(void, uint64_t, uint64_t, uint64_t))
{
  int v6 = a6;
  uint64_t v51 = *MEMORY[0x263EF8340];
  if (!a6) {
    int v6 = (void (**)(void, uint64_t, uint64_t, uint64_t))BomSys_default();
  }
  int v21 = 25202;
  uint64_t result = ((uint64_t (*)(void, uint64_t, uint64_t, uint64_t))v6[2])(v6[1], a2, a3, a4);
  long long v19 = 0u;
  long long v20 = 0u;
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  if (result != -1)
  {
    uint64_t v13 = result;
    uint64_t result = ((uint64_t (*)(void (*)(void, uint64_t, uint64_t, uint64_t), uint64_t, _OWORD *))v6[11])(v6[1], result, v17);
    if (result != -1)
    {
      int v14 = WORD2(v17[0]) & 0xF000;
      if (v14 == 0x8000)
      {
        long long v49 = 0u;
        long long v50 = 0u;
        long long v47 = 0u;
        long long v48 = 0u;
        long long v45 = 0u;
        long long v46 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v39 = 0u;
        long long v40 = 0u;
        long long v37 = 0u;
        long long v38 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        long long v31 = 0u;
        long long v32 = 0u;
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v25 = 0u;
        long long v26 = 0u;
        long long v23 = 0u;
        long long v24 = 0u;
        memset(v22, 0, sizeof(v22));
        if (!((unsigned int (*)(void (*)(void, uint64_t, uint64_t, uint64_t), uint64_t, _OWORD *))v6[14])(v6[1], v13, v22)&& !(DWORD2(v23) ^ 0x73666361 | BYTE12(v23)))
        {
          v16[0] = 0u;
          DWORD1(v16[0]) = 3;
          v16[1] = (unint64_t)v18;
          v6[5](v6[1], v13, 42, (uint64_t)v16);
        }
      }
      else if (v14 == 0x4000)
      {
        *__error() = 21;
        return 0xFFFFFFFFLL;
      }
      if (a3)
      {
        BYTE2(v21) = 0;
        __int16 v15 = 25207;
      }
      else
      {
        if ((a3 & 2) == 0)
        {
LABEL_16:
          uint64_t result = BOMFileNewFromFDWithSys(a1, v13, a5, (unsigned __int8 *)&v21, v6);
          if (!result) {
            return result;
          }
          ((void (*)(void (*)(void, uint64_t, uint64_t, uint64_t), uint64_t))v6[4])(v6[1], v13);
          return 0xFFFFFFFFLL;
        }
        BYTE2(v21) = 0;
        __int16 v15 = 25185;
      }
      LOWORD(v21) = v15;
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t BOMFileOpenSTDIN(void *a1, char a2)
{
  return BOMFileNewFromFDWithSys(a1, 0, a2 & 0xF, "rb", 0);
}

uint64_t BOMFileOpenSTDOUT(void *a1, char a2)
{
  return BOMFileNewFromFDWithSys(a1, 1, a2 & 0xF, "wb", 0);
}

uint64_t BOMFileClose(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v2 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 - 1) <= 1)
  {
    int v3 = *(_DWORD *)(a1 + 32);
    if (v3 == 1)
    {
      if (_BOMFileFinishGzipCompression((void *)a1, 1)) {
        return 0xFFFFFFFFLL;
      }
    }
    else if (v3 == 2)
    {
      CFIndex v4 = *(bz_stream **)(a1 + 40);
      if (v4->avail_out) {
        goto LABEL_73;
      }
      BOOL v5 = 0;
      while (1)
      {
        CFIndex v21 = 0x20000 - v4->avail_out;
        pthread_attr_t v22 = *(UInt8 **)(a1 + 48);
        while (v21)
        {
          uint64_t v23 = _BOMFileWriteRaw(a1, v22, v21);
          v21 -= v23;
          v22 += v23;
          if (v23 == -1) {
            return 0xFFFFFFFFLL;
          }
        }
        v4->next_out = *(char **)(a1 + 48);
        v4->avail_out = 0x20000;
        if (v5) {
          break;
        }
LABEL_73:
        int v20 = BZ2_bzCompress(v4, 2);
        BOOL v5 = 1;
        if (v20 != 4)
        {
          BOOL v5 = 0;
          if (v20 != 3)
          {
            if (v20) {
              return 0xFFFFFFFFLL;
            }
            BOOL v5 = v4->avail_out != 0;
          }
        }
      }
      BZ2_bzCompressEnd(v4);
    }
    int v2 = *(_DWORD *)a1;
  }
  if (v2 == 3 || v2 == 0)
  {
    int v7 = *(_DWORD *)(a1 + 32);
    if (v7 == 2)
    {
      uint64_t v9 = *(void *)(a1 + 40);
      int v8 = *(void **)(a1 + 48);
      size_t v10 = *(unsigned int *)(v9 + 8);
      *(void *)(a1 + 72) = v10;
      *(_DWORD *)(a1 + 80) = 0;
      memmove(v8, *(const void **)v9, v10);
      if (BZ2_bzDecompressEnd(*(bz_stream **)(a1 + 40))) {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if (v7 != 1) {
        goto LABEL_20;
      }
      if (_BOMFileFinishGzipDecompression(a1)) {
        return 0xFFFFFFFFLL;
      }
    }
    int v2 = *(_DWORD *)a1;
  }
LABEL_20:
  if ((v2 - 5) > 1) {
    goto LABEL_60;
  }
  if (v2 != 5)
  {
    if (v2 != 6) {
      goto LABEL_60;
    }
    uint64_t v11 = *(void **)(a1 + 104);
    if (v11)
    {
      *(void *)(a1 + 104) = 0;
    }
    else
    {
      uint64_t v11 = BOMBufferPoolRequestBuffer(gBufferPool);
      v11[1] = 0;
      v11[2] = 0;
    }
    *((_DWORD *)v11 + 12) |= 1u;
    BOMBufferFIFOEnqueue(*(void *)(a1 + 96), (uint64_t)v11);
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))) {
      return 0xFFFFFFFFLL;
    }
    int v16 = *(_DWORD *)(a1 + 232);
    if (!v16)
    {
      int v16 = 1;
      *(_DWORD *)(a1 + 232) = 1;
    }
    if (gBOMAsyncDebug == 1)
    {
      fwrite("waiting for async write thread to finish...", 0x2BuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      int v16 = *(_DWORD *)(a1 + 232);
    }
    if (v16 != 2)
    {
      while (!pthread_cond_wait((pthread_cond_t *)(a1 + 120), (pthread_mutex_t *)(a1 + 168)))
      {
        if (*(_DWORD *)(a1 + 232) == 2) {
          goto LABEL_52;
        }
      }
      return 0xFFFFFFFFLL;
    }
LABEL_52:
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)) || pthread_join(*(pthread_t *)(a1 + 112), 0)) {
      return 0xFFFFFFFFLL;
    }
    if (gBOMAsyncDebug == 1) {
      fwrite("async write thread terminated. Draining FIFO...", 0x2FuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 96)))
    {
      uint64_t v17 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
      BOMBufferPoolReturnBuffer(gBufferPool, v17);
    }
    if ((gBOMAsyncDebug & 1) == 0) {
      goto LABEL_60;
    }
    goto LABEL_59;
  }
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v12 = *(void *)(a1 + 104);
  if (v12)
  {
    BOMBufferPoolReturnBuffer(gBufferPool, v12);
    *(void *)(a1 + 104) = 0;
  }
  while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 96)))
  {
    uint64_t v13 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
    BOMBufferPoolReturnBuffer(gBufferPool, v13);
  }
  int v14 = *(_DWORD *)(a1 + 232);
  if (!v14)
  {
    int v14 = 1;
    *(_DWORD *)(a1 + 232) = 1;
  }
  if (gBOMAsyncDebug == 1)
  {
    fwrite("waiting for async read thread to finish...", 0x2AuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    int v14 = *(_DWORD *)(a1 + 232);
  }
  if (v14 != 2)
  {
    while (!pthread_cond_wait((pthread_cond_t *)(a1 + 120), (pthread_mutex_t *)(a1 + 168)))
    {
      if (*(_DWORD *)(a1 + 232) == 2) {
        goto LABEL_37;
      }
    }
    return 0xFFFFFFFFLL;
  }
LABEL_37:
  if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)) || pthread_join(*(pthread_t *)(a1 + 112), 0)) {
    return 0xFFFFFFFFLL;
  }
  while (BOMBufferFIFOCount(*(uint64_t **)(a1 + 96)))
  {
    uint64_t v15 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
    BOMBufferPoolReturnBuffer(gBufferPool, v15);
  }
  if (gBOMAsyncDebug == 1) {
LABEL_59:
  }
    fwrite("done\n", 5uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
LABEL_60:
  if (*(_DWORD *)(a1 + 32) == 3)
  {
    if (!CloseStreamCompressor())
    {
      *(void *)(a1 + 40) = 0;
      goto LABEL_63;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_63:
  uint64_t v18 = 0;
  switch(*(_DWORD *)a1)
  {
    case 0:
    case 1:
      uint64_t v18 = (*(uint64_t (**)(void, void))(*(void *)(a1 + 272) + 32))(*(void *)(*(void *)(a1 + 272) + 8), *(unsigned int *)(a1 + 8));
      *(_DWORD *)(a1 + 8) = -1;
      break;
    case 2:
      CFWriteStreamClose(*(CFWriteStreamRef *)(a1 + 8));
      goto LABEL_68;
    case 3:
      CFReadStreamClose(*(CFReadStreamRef *)(a1 + 8));
LABEL_68:
      uint64_t v18 = 0;
      goto LABEL_69;
    case 5:
    case 6:
      uint64_t v18 = BOMFileClose(*(void *)(a1 + 8));
LABEL_69:
      *(void *)(a1 + 8) = 0;
      break;
    default:
      break;
  }
  _freeBOMFile((void *)a1);
  return v18;
}

unint64_t BOMFileRead(int *a1, char *a2, unint64_t a3)
{
  if (!a1) {
    return -1;
  }
  int v3 = *a1;
  if (!*a1) {
    return _BOMFileDirectRead((uint64_t)a1, a2, a3);
  }
  if (v3 != 5)
  {
    if (v3 == 3) {
      return _BOMFileDirectRead((uint64_t)a1, a2, a3);
    }
    return -1;
  }
  return _BOMFileAsyncRead((uint64_t)a1, a2, a3);
}

uint64_t _BOMFileDirectRead(uint64_t a1, char *__dst, unint64_t a3)
{
  if (a3)
  {
    if (!__dst) {
      return -1;
    }
    unint64_t v4 = a3;
    int v6 = *(_DWORD *)(a1 + 32);
    if (v6)
    {
      if (v6 == 2)
      {
        uint64_t v15 = *(bz_stream **)(a1 + 40);
        v15->next_out = __dst;
        v15->uint64_t avail_out = a3;
        do
        {
          if (!v15->avail_in && !*(unsigned char *)(a1 + 64))
          {
            uint64_t Raw = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 48), 0x20000);
            uint64_t v8 = Raw;
            if (Raw)
            {
              if (Raw == -1) {
                return v8;
              }
            }
            else
            {
              *(unsigned char *)(a1 + 64) = 1;
            }
            v15->avail_in = Raw;
            v15->next_in = *(char **)(a1 + 48);
          }
          int v17 = BZ2_bzDecompress(v15);
          if (v17)
          {
            if (v17 != 4) {
              return -1;
            }
            *(unsigned char *)(a1 + 64) = 1;
          }
          uint64_t avail_out = v15->avail_out;
        }
        while (avail_out && !*(unsigned char *)(a1 + 65) && !*(unsigned char *)(a1 + 64));
        goto LABEL_46;
      }
      if (v6 == 1)
      {
        int v7 = *(z_stream **)(a1 + 40);
        v7->next_out = (Bytef *)__dst;
        v7->uint64_t avail_out = a3;
        do
        {
          LODWORD(v8) = v7->avail_in;
          if (!v8)
          {
            if (*(unsigned char *)(a1 + 64))
            {
              LODWORD(v8) = 0;
            }
            else
            {
              uint64_t v9 = _BOMFileReadRaw(a1, *(UInt8 **)(a1 + 48), 0x20000);
              uint64_t v8 = v9;
              if (v9)
              {
                if (v9 == -1) {
                  return v8;
                }
              }
              else
              {
                *(unsigned char *)(a1 + 64) = 1;
              }
              *(_DWORD *)(a1 + 264) = v9;
              v7->avail_in = v9;
              v7->next_in = *(Bytef **)(a1 + 48);
            }
          }
          if (*(unsigned char *)(a1 + 256))
          {
            int v10 = *(_DWORD *)(a1 + 264);
            if (v10)
            {
              unsigned int v11 = *(_DWORD *)(a1 + 260);
              if (v8 >= v11) {
                int v12 = *(_DWORD *)(a1 + 260);
              }
              else {
                int v12 = v8;
              }
              *(_DWORD *)(a1 + 260) = v11 - v12;
              *(_DWORD *)(a1 + 264) = v10 - v12;
              decrypt_buffer((uint64_t)v7->next_in, v12, (int *)(a1 + 244));
            }
          }
          int v13 = inflate(v7, 0);
          if (v13)
          {
            if (v13 != 1) {
              return -1;
            }
            *(unsigned char *)(a1 + 64) = 1;
          }
          uint64_t avail_out = v7->avail_out;
        }
        while (avail_out && (avail_out == v4 || !*(unsigned char *)(a1 + 65)) && !*(unsigned char *)(a1 + 64));
LABEL_46:
        uint64_t v8 = v4 - avail_out;
        goto LABEL_47;
      }
      return -1;
    }
    if (*(unsigned char *)(a1 + 67) == 1)
    {
      uint64_t v8 = 0;
      *(_WORD *)(a1 + 66) = 0;
LABEL_47:
      *(void *)(a1 + 24) += v8;
      return v8;
    }
    uint64_t v8 = *(void *)(a1 + 72);
    if (v8)
    {
      uint64_t v19 = 88;
      if (!*(_DWORD *)(a1 + 80)) {
        uint64_t v19 = 48;
      }
      int v20 = *(char **)(a1 + v19);
      if (*(unsigned char *)(a1 + 66) == 1)
      {
        unint64_t v29 = 0;
        if (search_for_data_descriptor((uint64_t)v20, v8, &v29))
        {
          *(unsigned char *)(a1 + 67) = 1;
          unint64_t v4 = v29;
          if (!v29)
          {
            uint64_t v8 = 0;
            goto LABEL_47;
          }
        }
      }
      if (v4 < v8) {
        uint64_t v8 = v4;
      }
      if (v8 >= 1)
      {
        memcpy(__dst, v20, v8);
        uint64_t v21 = *(void *)(a1 + 72);
        v4 -= v8;
        *(_DWORD *)(a1 + 264) -= v8;
        pthread_attr_t v22 = (UInt8 *)&__dst[v8];
        *(void *)(a1 + 72) = v21 - v8;
        if (v21 != v8) {
          memmove(v20, &v20[v8], v21 - v8);
        }
        if (!v4) {
          goto LABEL_70;
        }
        goto LABEL_65;
      }
      uint64_t v8 = 0;
    }
    pthread_attr_t v22 = (UInt8 *)__dst;
LABEL_65:
    uint64_t v23 = _BOMFileReadRaw(a1, v22, v4);
    if (v23 == -1)
    {
      uint64_t v8 = -1;
      goto LABEL_47;
    }
    if (v23) {
      v8 += v23;
    }
    else {
      *(unsigned char *)(a1 + 64) = 1;
    }
LABEL_70:
    if (*(unsigned char *)(a1 + 66) != 1
      || (unint64_t v29 = 0, !search_for_data_descriptor((uint64_t)__dst, v8, &v29))
      || (*(unsigned char *)(a1 + 67) = 1, uint64_t v24 = v29, v25 = v8 - v29, v8 == v29))
    {
LABEL_73:
      if (*(unsigned char *)(a1 + 256) == 1) {
        decrypt_buffer((uint64_t)__dst, v8, (int *)(a1 + 244));
      }
      goto LABEL_47;
    }
    if (*(void *)(a1 + 72))
    {
      long long v26 = (FILE *)*MEMORY[0x263EF8348];
      long long v27 = "The extra buffer is not empty";
      size_t v28 = 29;
    }
    else
    {
      if (v25 <= 0x20000)
      {
        *(void *)(a1 + 72) = v25;
        *(_DWORD *)(a1 + 80) = 1;
        memcpy(*(void **)(a1 + 88), &v22[v24], v25);
        uint64_t v8 = v24;
        goto LABEL_73;
      }
      long long v26 = (FILE *)*MEMORY[0x263EF8348];
      long long v27 = "The extra buffer is not large enough";
      size_t v28 = 36;
    }
    fwrite(v27, v28, 1uLL, v26);
    uint64_t v8 = -1;
    goto LABEL_47;
  }
  return 0;
}

unint64_t _BOMFileAsyncRead(uint64_t a1, char *__dst, size_t a3)
{
  if (!a3)
  {
    unint64_t v6 = 0;
    goto LABEL_17;
  }
  size_t v4 = a3;
  unint64_t v6 = 0;
  while (1)
  {
    int v7 = *(void **)(a1 + 104);
    if (!v7)
    {
      int v7 = (void *)BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
      *(void *)(a1 + 104) = v7;
    }
    uint64_t v8 = v7[1];
    if (v4 >= v7[2] - v8) {
      size_t v9 = v7[2] - v8;
    }
    else {
      size_t v9 = v4;
    }
    memcpy(__dst, (const void *)(v7[3] + v8), v9);
    uint64_t v10 = v7[2];
    size_t v11 = v7[1] + v9;
    v7[1] = v11;
    v6 += v9;
    if (v10 != v11) {
      goto LABEL_14;
    }
    if (!v11)
    {
      if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))) {
        goto LABEL_17;
      }
      int v13 = *(_DWORD *)(a1 + 232);
      int v12 = *(_DWORD *)(a1 + 236);
      if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))) {
        goto LABEL_17;
      }
      if ((v13 - 1) <= 1) {
        break;
      }
    }
    BOMBufferPoolReturnBuffer(gBufferPool, (uint64_t)v7);
    *(void *)(a1 + 104) = 0;
LABEL_14:
    __dst += v9;
    v4 -= v9;
    if (!v4) {
      goto LABEL_17;
    }
  }
  if (v12)
  {
    *__error() = v12;
    return -1;
  }
LABEL_17:
  *(int64x2_t *)(a1 + 16) = vaddq_s64(*(int64x2_t *)(a1 + 16), vdupq_n_s64(v6));
  return v6;
}

CFIndex BOMFileWrite(uint64_t a1, UInt8 *a2, CFIndex a3)
{
  if (!a1) {
    return -1;
  }
  size_t v3 = a3;
  size_t v4 = a2;
  int v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 - 1) < 2)
  {
    return _BOMFileDirectWrite(a1, a2, a3);
  }
  if (v6 != 6)
  {
    if (v6 != 4) {
      return -1;
    }
    if (!**(void **)(a1 + 8)) {
      return v3;
    }
    uint64_t v7 = 8;
    while (BOMFileWrite() == v3)
    {
      uint64_t v8 = *(void *)(*(void *)(a1 + 8) + v7);
      v7 += 8;
      if (!v8) {
        return v3;
      }
    }
    return -1;
  }
  unint64_t v10 = 0;
  if (!a3) {
    goto LABEL_26;
  }
  while (1)
  {
    size_t v11 = *(void **)(a1 + 104);
    if (v11)
    {
      uint64_t v12 = v11[1];
    }
    else
    {
      size_t v11 = BOMBufferPoolRequestBuffer(gBufferPool);
      uint64_t v12 = 0;
      v11[1] = 0;
      v11[2] = 0;
      *(void *)(a1 + 104) = v11;
    }
    if (v3 >= *v11 - v12) {
      size_t v13 = *v11 - v12;
    }
    else {
      size_t v13 = v3;
    }
    memcpy((void *)(v11[3] + v12), v4, v13);
    int64x2_t v14 = vaddq_s64(*(int64x2_t *)(v11 + 1), vdupq_n_s64(v13));
    *(int64x2_t *)(v11 + 1) = v14;
    v10 += v13;
    if (*v11 != v14.i64[0]) {
      goto LABEL_25;
    }
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))) {
      goto LABEL_26;
    }
    int v16 = *(_DWORD *)(a1 + 232);
    int v15 = *(_DWORD *)(a1 + 236);
    if (pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))) {
      goto LABEL_26;
    }
    if ((v16 - 1) <= 1) {
      break;
    }
    BOMBufferFIFOEnqueue(*(void *)(a1 + 96), (uint64_t)v11);
    *(void *)(a1 + 104) = 0;
LABEL_25:
    v4 += v13;
    v3 -= v13;
    if (!v3) {
      goto LABEL_26;
    }
  }
  if (v15)
  {
    *__error() = v15;
    return -1;
  }
LABEL_26:
  *(int64x2_t *)(a1 + 16) = vaddq_s64(*(int64x2_t *)(a1 + 16), vdupq_n_s64(v10));
  return v10;
}

CFIndex _BOMFileDirectWrite(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  CFIndex v3 = bufferLength;
  if (bufferLength)
  {
    if (buffer)
    {
      switch(*(_DWORD *)(a1 + 32))
      {
        case 0:
          CFIndex v6 = 0;
          while (v3)
          {
            uint64_t v7 = _BOMFileWriteRaw(a1, buffer, v3);
            v6 += v7;
            v3 -= v7;
            if (v7 < 0) {
              return -1;
            }
          }
          goto LABEL_18;
        case 1:
          uint64_t v8 = *(z_stream **)(a1 + 40);
          v8->next_in = buffer;
          v8->avail_in = bufferLength;
          if (!bufferLength) {
            goto LABEL_27;
          }
          uInt avail_out = v8->avail_out;
          if (!avail_out) {
            goto LABEL_22;
          }
          while (!deflate(v8, 0))
          {
            uInt avail_out = v8->avail_out;
LABEL_22:
            CFIndex v13 = 0x20000 - avail_out;
            int64x2_t v14 = *(UInt8 **)(a1 + 48);
            while (v13)
            {
              uint64_t v15 = _BOMFileWriteRaw(a1, v14, v13);
              v14 += v15;
              v13 -= v15;
              if (v15 < 0) {
                return -1;
              }
            }
            v8->uInt avail_out = 0x20000;
            v8->next_out = *(Bytef **)(a1 + 48);
            if (!v8->avail_in)
            {
LABEL_27:
              *(void *)(a1 + 56) = crc32(*(void *)(a1 + 56), buffer, v3);
              goto LABEL_28;
            }
          }
          return -1;
        case 2:
          unint64_t v10 = *(bz_stream **)(a1 + 40);
          v10->next_in = (char *)buffer;
          v10->avail_in = bufferLength;
          if (!bufferLength) {
            goto LABEL_28;
          }
          unsigned int v11 = v10->avail_out;
          if (!v11) {
            goto LABEL_32;
          }
          while (BZ2_bzCompress(v10, 0) <= 1)
          {
            unsigned int v11 = v10->avail_out;
LABEL_32:
            CFIndex v17 = 0x20000 - v11;
            uint64_t v18 = *(UInt8 **)(a1 + 48);
            while (v17)
            {
              uint64_t v19 = _BOMFileWriteRaw(a1, v18, v17);
              v18 += v19;
              v17 -= v19;
              if (v19 < 0) {
                return -1;
              }
            }
            v10->uInt avail_out = 0x20000;
            v10->next_out = *(char **)(a1 + 48);
            if (!v10->avail_in) {
              goto LABEL_28;
            }
          }
          return -1;
        case 3:
          CFIndex v6 = 0;
          break;
        default:
          return -1;
      }
      while (v3)
      {
        uint64_t v12 = WriteToStreamCompressor();
        v6 += v12;
        v3 -= v12;
        if (v12 < 0) {
          return -1;
        }
      }
LABEL_18:
      CFIndex v3 = v6;
LABEL_28:
      *(void *)(a1 + 24) += v3;
    }
    else
    {
      return -1;
    }
  }
  return v3;
}

uint64_t BOMFileSeek()
{
  v0 = (int64x2_t *)MEMORY[0x270FA5388]();
  uint64_t v18 = *MEMORY[0x263EF8340];
  int64_t v3 = v1;
  uint64_t v4 = (uint64_t)v0;
  switch(v0->i32[0])
  {
    case 0:
      if (!v0[2].i32[0]) {
        goto LABEL_44;
      }
      goto LABEL_3;
    case 1:
      if (v0[2].i32[0]) {
        goto LABEL_14;
      }
LABEL_44:
      uint64_t result = (*(uint64_t (**)(void, void, int64_t, uint64_t))(v0[17].i64[0] + 64))(*(void *)(v0[17].i64[0] + 8), v0->u32[2], v1, v2);
      *(void *)(v4 + 16) = result;
      *(void *)(v4 + 24) = result;
      return result;
    case 2:
    case 6:
LABEL_14:
      if (v2 == 1) {
        goto LABEL_17;
      }
      if (v2) {
        return -1;
      }
      int64_t v3 = v1 - v0[1].i64[0];
LABEL_17:
      if (v3 < 1) {
        return -1;
      }
      bzero(__dst, 0x20000uLL);
      while (v3)
      {
        if (v3 >= 0x20000) {
          CFIndex v7 = 0x20000;
        }
        else {
          CFIndex v7 = v3;
        }
        CFIndex v8 = _BOMFileDirectWrite(v4, (UInt8 *)__dst, v7);
        v3 -= v8;
        if (v8 < 0) {
          return -1;
        }
      }
      return *(void *)(v4 + 16);
    case 3:
LABEL_3:
      if (v2 == 1) {
        goto LABEL_6;
      }
      if (v2) {
        return -1;
      }
      int64_t v3 = v1 - v0[1].i64[0];
LABEL_6:
      if (v3 < 1) {
        return -1;
      }
      do
      {
        if (v3 < 1) {
          return *(void *)(v4 + 16);
        }
        if (v3 >= 0x20000) {
          unint64_t v5 = 0x20000;
        }
        else {
          unint64_t v5 = v3;
        }
        uint64_t v6 = _BOMFileDirectRead(v4, __dst, v5);
        v3 -= v6;
      }
      while (v6 > 0);
      return -1;
    case 4:
      uint64_t result = -1;
      if (v1 < 0 || v2 != 1) {
        return result;
      }
      if (!**(void **)(v4 + 8)) {
        goto LABEL_31;
      }
      uint64_t v10 = 8;
      break;
    case 5:
      if (v2 == 1) {
        goto LABEL_35;
      }
      if (v2)
      {
        int64_t v3 = -1;
      }
      else
      {
        int64_t v3 = v1 - v0[1].i64[0];
LABEL_35:
        if ((v3 & 0x8000000000000000) == 0)
        {
          if (!v3) {
            return -1;
          }
          do
          {
            if (v3 < 1) {
              return *(void *)(v4 + 16);
            }
            if (v3 >= 0x20000) {
              size_t v12 = 0x20000;
            }
            else {
              size_t v12 = v3;
            }
            int64_t v13 = _BOMFileAsyncRead(v4, __dst, v12);
            v3 -= v13;
          }
          while (v13 > 0);
          return -1;
        }
      }
      uint64_t v14 = v0[6].i64[1];
      if (v14)
      {
        unint64_t v15 = *(void *)(v14 + 24);
        if (v15)
        {
          if (*(void *)(v14 + 8) + v3 != 0 && v15 + *(void *)(v14 + 8) + v3 >= v15)
          {
            *(void *)(v14 + 8) += v3;
            int64x2_t v16 = vaddq_s64(v0[1], vdupq_n_s64(v3));
            v0[1] = v16;
            return v16.i64[0];
          }
        }
      }
      return -1;
    default:
      return -1;
  }
  while (1)
  {
    uint64_t result = BOMFileSeek();
    if (result == -1) {
      break;
    }
    uint64_t v11 = *(void *)(*(void *)(v4 + 8) + v10);
    v10 += 8;
    if (!v11)
    {
LABEL_31:
      uint64_t result = *(void *)(v4 + 16) + v3;
      *(void *)(v4 + 16) = result;
      return result;
    }
  }
  return result;
}

uint64_t BOMFileOffset(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t BOMFileUncompressedOffset(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t BOMFileSetPartialRead(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 65) = a2;
  }
  return result;
}

uint64_t BOMFileSetDataDescriptor(uint64_t result, char a2)
{
  if (result)
  {
    *(unsigned char *)(result + 66) = a2;
    *(unsigned char *)(result + 67) = 0;
  }
  return result;
}

uint64_t BOMFileSetCompression(uint64_t result, int a2, int a3, int a4)
{
  if (result)
  {
    if (*(_DWORD *)(result + 32) == (a2 == 0))
    {
      *(_DWORD *)(result + 240) = a4;
      *(_DWORD *)(result + 32) = a2 != 0;
      if (a2)
      {
        if (_BOMFileSetupGzip(result, a3 == 0, 0)) {
          return 0xFFFFFFFFLL;
        }
        else {
          return 0;
        }
      }
      else if (a3)
      {
        return _BOMFileFinishGzipDecompression(result);
      }
      else
      {
        return _BOMFileFinishGzipCompression((void *)result, 0);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t _BOMFileSetupGzip(uint64_t a1, int a2, int a3)
{
  CFIndex v7 = (z_streamp *)(a1 + 40);
  uint64_t v6 = *(z_stream **)(a1 + 40);
  if (!v6)
  {
    uint64_t v6 = (z_stream *)BOM_malloc(0x70uLL);
    *CFIndex v7 = v6;
    if (!v6) {
      return 0xFFFFFFFFLL;
    }
  }
  CFIndex v8 = *(void **)(a1 + 48);
  if (!v8)
  {
    CFIndex v8 = BOM_malloc(0x20000uLL);
    *(void *)(a1 + 48) = v8;
    uint64_t v6 = *(z_stream **)(a1 + 40);
    if (!v8)
    {
      free(*(void **)(a1 + 40));
      goto LABEL_13;
    }
  }
  v6->zalloc = 0;
  (*v7)->zfree = 0;
  (*v7)->opaque = 0;
  size_t v9 = *v7;
  if (a2)
  {
    *size_t v9 = 0;
    *(void *)(*(void *)(a1 + 40) + 24) = v8;
    *(_DWORD *)(*(void *)(a1 + 40) + 8) = 0;
    *(_DWORD *)(*(void *)(a1 + 40) + 32) = 0x20000;
    if (deflateInit2_(*(z_streamp *)(a1 + 40), *(_DWORD *)(a1 + 240), 8, -15, 8, 0, "1.2.12", 112))
    {
LABEL_7:
      free(*(void **)(a1 + 40));
      free(*(void **)(a1 + 48));
      v7[1] = 0;
LABEL_13:
      *CFIndex v7 = 0;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    *size_t v9 = v8;
    size_t v10 = *(void *)(a1 + 72);
    if (v10)
    {
      uint64_t v11 = 88;
      if (!*(_DWORD *)(a1 + 80)) {
        uint64_t v11 = 48;
      }
      memcpy(**(void ***)(a1 + 40), *(const void **)(a1 + v11), v10);
      *(_DWORD *)(*(void *)(a1 + 40) + 8) = *(void *)(a1 + 72);
      *(void *)(a1 + 72) = 0;
    }
    else
    {
      (*v7)->avail_in = 0;
    }
    (*v7)->next_out = 0;
    (*v7)->uInt avail_out = 0;
    if (a3) {
      int v13 = 47;
    }
    else {
      int v13 = -15;
    }
    if (inflateInit2_(*v7, v13, "1.2.12", 112)) {
      goto LABEL_7;
    }
  }
  uLong v14 = crc32(0, 0, 0);
  uint64_t result = 0;
  *(void *)(a1 + 56) = v14;
  *(unsigned char *)(a1 + 64) = 0;
  return result;
}

uint64_t _BOMFileFinishGzipDecompression(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v2 = *(void **)(a1 + 48);
  size_t v4 = *(unsigned int *)(v3 + 8);
  *(void *)(a1 + 72) = v4;
  *(_DWORD *)(a1 + 80) = 0;
  memmove(v2, *(const void **)v3, v4);
  unint64_t v5 = *(z_stream **)(a1 + 40);
  return inflateEnd(v5);
}

uint64_t _BOMFileFinishGzipCompression(void *a1, int a2)
{
  size_t v4 = (z_stream *)a1[5];
  uInt avail_out = v4->avail_out;
  if (avail_out) {
    goto LABEL_3;
  }
  BOOL v6 = 0;
  while (1)
  {
    CFIndex v8 = 0x20000 - avail_out;
    size_t v9 = (UInt8 *)a1[6];
    while (v8)
    {
      uint64_t v10 = _BOMFileWriteRaw((uint64_t)a1, v9, v8);
      v8 -= v10;
      v9 += v10;
      if (v10 == -1) {
        return 0xFFFFFFFFLL;
      }
    }
    v4->next_out = (Bytef *)a1[6];
    v4->uInt avail_out = 0x20000;
    if (v6) {
      break;
    }
LABEL_3:
    int v7 = deflate(v4, 4);
    if (v7)
    {
      if (v7 != 1) {
        return 0xFFFFFFFFLL;
      }
      uInt avail_out = v4->avail_out;
      BOOL v6 = 1;
    }
    else
    {
      uInt avail_out = v4->avail_out;
      BOOL v6 = avail_out != 0;
    }
  }
  if (a2)
  {
    uint64_t v12 = 0;
    uint64_t v13 = a1[7];
    a1[7] = v13;
    *(_DWORD *)buffer = v13;
    while (v12 != 4)
    {
      uint64_t v14 = _BOMFileWriteRaw((uint64_t)a1, buffer, 4 - v12);
      v12 += v14;
      if (v14 < 0) {
        return 0xFFFFFFFFLL;
      }
    }
    uint64_t v15 = 0;
    uLong total_in = v4->total_in;
    v4->uLong total_in = total_in;
    *(_DWORD *)uint64_t v18 = total_in;
    while (v15 != 4)
    {
      uint64_t v17 = _BOMFileWriteRaw((uint64_t)a1, v18, 4 - v15);
      v15 += v17;
      if (v17 < 0) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  deflateEnd(v4);
  return 0;
}

BOOL BOMFileEndOfCompressionStream(BOOL result)
{
  if (result) {
    return *(unsigned char *)(result + 64) != 0;
  }
  return result;
}

uint64_t BOMFileSetAFSCCompression(uint64_t a1)
{
  if (*(_DWORD *)a1 != 1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 32)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t StreamCompressor = CreateStreamCompressor();
  if (!StreamCompressor) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = StreamCompressor;
  uint64_t result = 0;
  *(_DWORD *)(a1 + 32) = 3;
  *(void *)(a1 + 40) = v4;
  return result;
}

uint64_t BOMFileSetKeys(uint64_t a1, unsigned char *a2)
{
  uint64_t v2 = a1 + 244;
  *(unsigned char *)(a1 + 256) = a2 != 0;
  if (a2) {
    init_keys(a1 + 244, a2);
  }
  return v2;
}

uint64_t BOMFileSetEncryptedRemainder(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 260) = a2;
  }
  return result;
}

uint64_t BOMFileClearEncrypted(uint64_t result)
{
  if (result) {
    *(unsigned char *)(result + 256) = 0;
  }
  return result;
}

uint64_t BOMFileGetFileDescriptor(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t _BOMFileReadRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6 = 0;
  do
  {
    if (*(_DWORD *)a1 == 3)
    {
      CFIndex v7 = CFReadStreamRead(*(CFReadStreamRef *)(a1 + 8), buffer, bufferLength);
    }
    else if (*(_DWORD *)a1)
    {
      CFIndex v7 = -1;
    }
    else
    {
      CFIndex v7 = (*(uint64_t (**)(void, void, UInt8 *, CFIndex))(*(void *)(a1 + 272) + 48))(*(void *)(*(void *)(a1 + 272) + 8), *(unsigned int *)(a1 + 8), buffer, bufferLength);
    }
    uint64_t v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1) {
      break;
    }
    if (*(unsigned char *)(a1 + 65)) {
      break;
    }
    buffer += v8;
    bufferLength -= v8;
  }
  while (bufferLength);
  *(void *)(a1 + 16) += v6;
  if (v7 < 0) {
    return -1;
  }
  else {
    return v6;
  }
}

uint64_t _BOMFileSetupBzip2(uint64_t a1, int a2)
{
  unint64_t v5 = (bz_stream **)(a1 + 40);
  uint64_t v4 = *(bz_stream **)(a1 + 40);
  if (!v4)
  {
    uint64_t v4 = (bz_stream *)BOM_malloc(0x50uLL);
    z_stream *v5 = v4;
    if (!v4) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t v6 = *(char **)(a1 + 48);
  if (!v6)
  {
    uint64_t v6 = (char *)BOM_malloc(0x20000uLL);
    *(void *)(a1 + 48) = v6;
    uint64_t v4 = *(bz_stream **)(a1 + 40);
    if (!v6)
    {
      free(*(void **)(a1 + 40));
      goto LABEL_13;
    }
  }
  v4->bzalloc = 0;
  (*v5)->bzfree = 0;
  (*v5)->opaque = 0;
  CFIndex v7 = *v5;
  if (a2)
  {
    v7->next_in = 0;
    (*v5)->next_out = v6;
    (*v5)->avail_in = 0;
    (*v5)->uInt avail_out = 0x20000;
    if (BZ2_bzCompressInit(*v5, 9, 0, 0))
    {
LABEL_7:
      free(*(void **)(a1 + 40));
      free(*(void **)(a1 + 48));
      v5[1] = 0;
LABEL_13:
      z_stream *v5 = 0;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    v7->next_in = v6;
    size_t v8 = *(void *)(a1 + 72);
    if (v8)
    {
      uint64_t v9 = 88;
      if (!*(_DWORD *)(a1 + 80)) {
        uint64_t v9 = 48;
      }
      memcpy(**(void ***)(a1 + 40), *(const void **)(a1 + v9), v8);
      *(_DWORD *)(*(void *)(a1 + 40) + 8) = *(void *)(a1 + 72);
      *(void *)(a1 + 72) = 0;
    }
    else
    {
      (*v5)->avail_in = 0;
    }
    (*v5)->next_out = 0;
    (*v5)->uInt avail_out = 0;
    if (BZ2_bzDecompressInit(*v5, 0, 0)) {
      goto LABEL_7;
    }
  }
  uLong v11 = crc32(0, 0, 0);
  uint64_t result = 0;
  *(void *)(a1 + 56) = v11;
  *(unsigned char *)(a1 + 64) = 0;
  return result;
}

uint64_t _BOMFileWriteRaw(uint64_t a1, UInt8 *buffer, CFIndex bufferLength)
{
  uint64_t v6 = 0;
  do
  {
    if (*(_DWORD *)a1 == 2)
    {
      CFIndex v7 = CFWriteStreamWrite(*(CFWriteStreamRef *)(a1 + 8), buffer, bufferLength);
    }
    else if (*(_DWORD *)a1 == 1)
    {
      CFIndex v7 = (*(uint64_t (**)(void, void, UInt8 *, CFIndex))(*(void *)(a1 + 272) + 56))(*(void *)(*(void *)(a1 + 272) + 8), *(unsigned int *)(a1 + 8), buffer, bufferLength);
    }
    else
    {
      CFIndex v7 = -1;
    }
    uint64_t v8 = v7 & ~(v7 >> 63);
    v6 += v8;
    if (v7 < 1) {
      break;
    }
    buffer += v8;
    bufferLength -= v8;
  }
  while (bufferLength);
  *(void *)(a1 + 16) += v6;
  if (v7 < 0) {
    return -1;
  }
  else {
    return v6;
  }
}

void *_initBufferPool()
{
  uint64_t result = BOMBufferPoolAllocate(gBOMAsyncBufferSize, gBOMAsyncBufferCount);
  if (!result)
  {
    int64_t v1 = BOMExceptionHandlerMessage("Unable to allocate BOM buffer pool gBOMAsyncBufferSize=%lu gBOMAsyncBufferCount=%u!\n", gBOMAsyncBufferSize, gBOMAsyncBufferCount);
    uint64_t v2 = __error();
    _BOMFatalException((uint64_t)v1, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMFile.c", 2825, *v2);
  }
  gBufferPool = (uint64_t)result;
  return result;
}

uint64_t _asyncWriteThread(uint64_t a1)
{
  uint64_t v2 = (FILE **)MEMORY[0x263EF8348];
  if (gBOMAsyncDebug == 1) {
    fwrite("async write thread starting\n", 0x1CuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  int v3 = 0;
  do
  {
    uint64_t v4 = BOMBufferFIFODequeue(*(uint64_t **)(a1 + 96));
    CFIndex v5 = BOMFileWrite(*(void *)(a1 + 8), *(UInt8 **)(v4 + 24), *(void *)(v4 + 16));
    int v6 = *(_DWORD *)(v4 + 48);
    if ((v6 & 1) != 0 && gBOMAsyncDebug == 1) {
      fwrite("async write thread asked to finish\n", 0x23uLL, 1uLL, *v2);
    }
    if (v5 == -1)
    {
      if (gBOMAsyncDebug == 1)
      {
        uint64_t v8 = *v2;
        uint64_t v9 = __error();
        fprintf(v8, "async write thread finished file (errno=%d)\n", *v9);
      }
      int v3 = *__error();
      int v7 = 1;
    }
    else
    {
      int v7 = v6 & 1;
    }
    ++*(void *)(v4 + 40);
    BOMBufferPoolReturnBuffer(gBufferPool, v4);
  }
  while (!v7);
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
  {
    *(_DWORD *)(a1 + 232) = 2;
    *(_DWORD *)(a1 + 236) = v3;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 120))
      && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))
      && gBOMAsyncDebug == 1)
    {
      fwrite("async write thread terminating\n", 0x1FuLL, 1uLL, *v2);
    }
  }
  return 0;
}

uint64_t _asyncReadThread(uint64_t a1)
{
  if (gBOMAsyncDebug == 1) {
    fwrite("async read thread starting\n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  for (CFIndex i = BOMBufferPoolRequestBuffer(gBufferPool); ; CFIndex i = BOMBufferPoolRequestBuffer(gBufferPool))
  {
    if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 168))
      || (int v3 = *(_DWORD *)(a1 + 232), pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168))))
    {
      int v5 = 0;
      goto LABEL_20;
    }
    if (v3 == 1)
    {
      if (gBOMAsyncDebug == 1)
      {
        fwrite("async read thread asked to finish\n", 0x22uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
LABEL_13:
        if (gBOMAsyncDebug == 1) {
          fwrite("async read thread finished file\n", 0x20uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
        }
      }
      int v5 = 0;
      goto LABEL_19;
    }
    unint64_t v4 = BOMFileRead(*(int **)(a1 + 8), (char *)i[3], *i);
    if (v4 == -1) {
      break;
    }
    if (!v4) {
      goto LABEL_13;
    }
    i[1] = 0;
    i[2] = v4;
    ++i[5];
    BOMBufferFIFOEnqueue(*(void *)(a1 + 96), (uint64_t)i);
  }
  if (gBOMAsyncDebug == 1)
  {
    int v6 = (FILE *)*MEMORY[0x263EF8348];
    int v7 = __error();
    fprintf(v6, "async read thread finished file (errno=%d)\n", *v7);
  }
  int v5 = *__error();
LABEL_19:
  i[1] = 0;
  i[2] = 0;
  ++i[5];
LABEL_20:
  if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 168)))
  {
    *(_DWORD *)(a1 + 232) = 2;
    *(_DWORD *)(a1 + 236) = v5;
    if (!pthread_cond_signal((pthread_cond_t *)(a1 + 120)) && !pthread_mutex_unlock((pthread_mutex_t *)(a1 + 168)))
    {
      if (i) {
        BOMBufferFIFOEnqueue(*(void *)(a1 + 96), (uint64_t)i);
      }
      if (gBOMAsyncDebug == 1) {
        fwrite("async read thread terminating\n", 0x1EuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      }
    }
  }
  return 0;
}

uint64_t decrypt_buffer(uint64_t result, int a2, int *a3)
{
  if (a2)
  {
    int v4 = a2;
    int v5 = (unsigned __int8 *)result;
    do
    {
      --v4;
      unsigned __int8 v6 = *v5 ^ decrypt_byte((uint64_t)a3);
      *v5++ = v6;
      uint64_t result = update_keys(a3, v6);
    }
    while (v4);
  }
  return result;
}

uint64_t search_for_data_descriptor(uint64_t a1, unint64_t a2, void *a3)
{
  *a3 = 0;
  if (a2 <= 4) {
    return 0;
  }
  uint64_t v3 = 0;
  uint64_t v4 = a1 + 1;
  while (*(unsigned char *)(a1 + v3) != 80
       || *(unsigned char *)(v4 + v3) != 75
       || *(unsigned char *)(v4 + v3 + 1) != 7
       || *(unsigned char *)(v4 + v3 + 2) != 8)
  {
    if (a2 - 4 == ++v3) {
      return 0;
    }
  }
  *a3 = v3;
  return 1;
}

uint64_t BOMExceptionHandlerSet(uint64_t result)
{
  gHandler = result;
  return result;
}

void _BOMFatalException(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v4 = (uint64_t (*)(uint64_t))gHandler;
  if (!gHandler) {
    uint64_t v4 = _defaultHandler;
  }
  uint64_t v5 = gMessage;
  if (a1) {
    uint64_t v5 = a1;
  }
  v7[0] = v5;
  v7[1] = 1;
  if (a2) {
    unsigned __int8 v6 = a2;
  }
  else {
    unsigned __int8 v6 = "";
  }
  v7[2] = v6;
  int v8 = a3;
  int v9 = a4;
  v4((uint64_t)v7);
  abort();
}

uint64_t _defaultHandler(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 24);
  uint64_t v3 = (FILE *)*MEMORY[0x263EF8348];
  if (v2) {
    uint64_t result = fprintf(v3, "[%s:%u] %s\n");
  }
  else {
    uint64_t result = fprintf(v3, "%s\n");
  }
  if (*(unsigned char *)(a1 + 8)) {
    abort();
  }
  return result;
}

uint64_t _BOMExceptionHandlerCall(uint64_t a1, unsigned __int8 a2, const char *a3, int a4, int a5)
{
  uint64_t v5 = (uint64_t (*)(uint64_t))gHandler;
  if (!gHandler) {
    uint64_t v5 = _defaultHandler;
  }
  uint64_t v6 = gMessage;
  if (a1) {
    uint64_t v6 = a1;
  }
  v9[0] = v6;
  int v7 = "";
  v9[1] = a2;
  if (a3) {
    int v7 = a3;
  }
  v9[2] = v7;
  int v10 = a4;
  int v11 = a5;
  return v5((uint64_t)v9);
}

char *BOMExceptionHandlerMessage(char *__format, ...)
{
  va_start(va, __format);
  uint64_t result = (char *)gMessage;
  if (!gMessage)
  {
    uint64_t result = (char *)malloc_type_malloc(0x1000uLL, 0x100004077774924uLL);
    gMessage = (uint64_t)result;
    if (!result) {
      return result;
    }
    *uint64_t result = 0;
  }
  vsnprintf(result, 0x1000uLL, __format, va);
  return (char *)gMessage;
}

uint64_t BOMCRC32ForFile(const char *a1, _DWORD *a2, off_t *a3)
{
  uint64_t v3 = 1;
  if (a1 && a2)
  {
    memset(&v20, 0, sizeof(v20));
    if (stat(a1, &v20))
    {
      int v7 = __error();
      int v8 = strerror(*v7);
      int v9 = BOMExceptionHandlerMessage("stat: %s\n", v8);
      int v10 = *__error();
      uint64_t v11 = (uint64_t)v9;
      int v12 = 213;
LABEL_5:
      _BOMExceptionHandlerCall(v11, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMCRC32.c", v12, v10);
      return v3;
    }
    off_t st_size = v20.st_size;
    int v15 = open(a1, 0, 0);
    if (v15 == -1)
    {
      uint64_t v17 = __error();
      uint64_t v18 = strerror(*v17);
      uint64_t v19 = BOMExceptionHandlerMessage("open: %s\n", v18);
      int v10 = *__error();
      uint64_t v11 = (uint64_t)v19;
      int v12 = 220;
      goto LABEL_5;
    }
    int v16 = v15;
    uint64_t v3 = posix_checksum(v15, a2, st_size);
    close(v16);
    if (a3) {
      *a3 = st_size;
    }
  }
  return v3;
}

uint64_t posix_checksum(int a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v6 = malloc_type_malloc(0x20000uLL, 0x1D38C244uLL);
  if (v6)
  {
    int v7 = v6;
    CNCRCInit();
    if (a3)
    {
      uint64_t v8 = 0;
      do
      {
        if ((unint64_t)(a3 - v8) >= 0x20000) {
          size_t v9 = 0x20000;
        }
        else {
          size_t v9 = a3 - v8;
        }
        if (read(a1, v7, v9) != v9)
        {
          int v15 = (FILE *)*MEMORY[0x263EF8348];
          int v16 = __error();
          uint64_t v17 = strerror(*v16);
          fprintf(v15, "Could not read: %s", v17);
          free(v7);
          return 0xFFFFFFFFLL;
        }
        CNCRCUpdate();
        v8 += v9;
      }
      while (v8 != a3);
      do
      {
        CNCRCUpdate();
        BOOL v10 = (unint64_t)a3 > 0xFF;
        a3 >>= 8;
      }
      while (v10);
    }
    CNCRCFinal();
    *a2 = 0;
    free(v7);
    CNCRCRelease();
    return 0;
  }
  else
  {
    int v12 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v13 = __error();
    uint64_t v14 = strerror(*v13);
    fprintf(v12, "Could not allocate buffer: %s", v14);
    return 0xFFFFFFFFLL;
  }
}

uint64_t BOMCRC32ForFileDesc(int a1, _DWORD *a2, uint64_t a3)
{
  if ((a1 - 1) > 0xFFFFFFFD || a2 == 0) {
    return 1;
  }
  else {
    return posix_checksum(a1, a2, a3);
  }
}

uint64_t BOMCRC32ForBuffer(uint64_t a1, _DWORD *a2, unint64_t a3)
{
  if (CNCRCInit() || CNCRCUpdate()) {
    return 1;
  }
  if (!a3)
  {
LABEL_6:
    if (!CNCRCFinal())
    {
      CNCRCRelease();
      uint64_t v5 = 0;
      *a2 = 0;
      return v5;
    }
    return 1;
  }
  while (1)
  {
    uint64_t v5 = 1;
    if (CNCRCUpdate()) {
      return v5;
    }
    BOOL v6 = a3 >= 0x100;
    a3 >>= 8;
    if (!v6) {
      goto LABEL_6;
    }
  }
}

uint64_t BOMCRC32ForBufferSegment(unsigned __int8 *a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = 1;
  if (a1 && a2)
  {
    for (unsigned int i = *a2; a3; --a3)
    {
      int v5 = *a1++;
      unsigned int i = crctab[v5 ^ HIBYTE(i)] ^ (i << 8);
    }
    uint64_t v3 = 0;
    *a2 = i;
  }
  return v3;
}

uint64_t BOMCRC32ForBufferSegmentFinal(unsigned __int8 *a1, unsigned int *a2, uint64_t a3, unint64_t a4)
{
  if (a1) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = a3 == 0;
  }
  int v5 = v4;
  uint64_t v6 = 1;
  if (a2 && v5)
  {
    for (unsigned int i = *a2; a3; --a3)
    {
      int v8 = *a1++;
      unsigned int i = crctab[v8 ^ HIBYTE(i)] ^ (i << 8);
    }
    if (a4)
    {
      do
      {
        unsigned int i = crctab[a4 ^ (unint64_t)HIBYTE(i)] ^ (i << 8);
        BOOL v9 = a4 > 0xFF;
        a4 >>= 8;
      }
      while (v9);
    }
    uint64_t v6 = 0;
    *a2 = ~i;
  }
  return v6;
}

_DWORD *_BOMBomGetFSObjectWithBlockID(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = BOMStreamWithBlockID(*(void *)(a1 + 8), a2, 0, 0);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = BOMFSObjectUnarchive(v4);
    BOMStreamFree(v5);
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(void *)(a1 + 40);
  if (v7)
  {
    unsigned int v11 = bswap32(a2);
    uint64_t v10 = 0;
    if (BOMTreeGetValueSize(v7, &v11, 4uLL, &v10)) {
      BOOL v8 = 0;
    }
    else {
      BOOL v8 = v10 == 8;
    }
    if (v8 && BOMTreeGetValue(*(void *)(a1 + 40), &v11, 4uLL))
    {
      __memcpy_chk();
      BOMFSObjectSetSize((uint64_t)v6, bswap64(0));
    }
  }
  return v6;
}

uint64_t BOMBomPathsTree(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

char *BOMBomOpen(char *a1, int a2)
{
  return BOMBomOpenWithSys(a1, a2, 0);
}

char *BOMBomOpenWithSys(char *a1, int a2, void *a3)
{
  uint64_t v3 = a3;
  if (!a3) {
    uint64_t v3 = BomSys_default();
  }
  if (a1)
  {
    if (a2) {
      uint64_t v6 = 6;
    }
    else {
      uint64_t v6 = 4;
    }
    if (!(*((unsigned int (**)(void, char *, uint64_t))v3 + 23))(*((void *)v3 + 1), a1, v6))
    {
      uint64_t v8 = BOMStorageOpenWithSys(a1, a2, v3);
      if (v8)
      {
        BOOL v9 = (_DWORD *)v8;
        unsigned int NamedBlock = BOMStorageGetNamedBlock(v8, "BomInfo");
        if (NamedBlock)
        {
          unsigned int v11 = NamedBlock;
          a1 = (char *)BOM_malloczero(0x48uLL);
          if (!a1)
          {
            BOMStorageFree(v9);
            return a1;
          }
          uint64_t v12 = BOMStreamWithBlockID((uint64_t)v9, v11, 0, 0);
          if (!v12
            || (uint64_t v13 = v12,
                BOMStreamReadUInt32(v12),
                int UInt32 = BOMStreamReadUInt32(v13),
                int ArchInfo = _readArchInfo((uint64_t)a1, v13),
                int v16 = BOMStreamFree(v13),
                ArchInfo)
            || v16)
          {
            BOMStorageFree(v9);
            free(a1);
          }
          else
          {
            *(_DWORD *)a1 = UInt32;
            *((void *)a1 + 1) = v9;
            *((void *)a1 + 2) = BOMTreeOpenWithName((uint64_t)v9, "Paths", a2);
            *((void *)a1 + 3) = BOMBomHLIndexOpen((uint64_t)v9, a2);
            uint64_t v17 = BOMBomVIndexOpen((uint64_t)v9, a2);
            *((void *)a1 + 4) = v17;
            if (*((void *)a1 + 2))
            {
              if (*((void *)a1 + 3))
              {
                if (v17)
                {
                  uint64_t v18 = BOMTreeOpenWithName((uint64_t)v9, "Size64", a2);
                  *((void *)a1 + 5) = v18;
                  if (a2 != 1
                    || v18
                    || (uint64_t v19 = BOMTreeNewWithName((uint64_t)v9, "Size64"), (*((void *)a1 + 5) = v19) != 0))
                  {
                    a1[65] = a2;
                    return a1;
                  }
                }
              }
            }
            BOMBomFree((uint64_t)a1);
          }
        }
        else
        {
          fprintf((FILE *)*MEMORY[0x263EF8348], "file %s is not a bom file\n", a1);
        }
      }
    }
    return 0;
  }
  return a1;
}

uint64_t _readArchInfo(uint64_t a1, uint64_t a2)
{
  uint64_t result = BOMStreamReadUInt32(a2);
  *(_DWORD *)(a1 + 48) = result;
  if (result)
  {
    uint64_t v5 = BOM_malloczero(24 * result);
    *(void *)(a1 + 56) = v5;
    if (v5)
    {
      if (*(_DWORD *)(a1 + 48))
      {
        uint64_t v6 = 0;
        unint64_t v7 = 0;
        do
        {
          *(_DWORD *)(*(void *)(a1 + 56) + v6) = BOMStreamReadUInt32(a2);
          *(_DWORD *)(*(void *)(a1 + 56) + v6 + 4) = BOMStreamReadUInt32(a2);
          *(void *)(*(void *)(a1 + 56) + v6 + 8) = BOMStreamReadUInt32(a2);
          *(_DWORD *)(*(void *)(a1 + 56) + v6 + 16) = BOMStreamReadUInt32(a2);
          ++v7;
          v6 += 24;
        }
        while (v7 < *(unsigned int *)(a1 + 48));
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t BOMBomFree(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 64) && BOMBomCommit(a1)) {
    return 1;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    BOMTreeFree(v3);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    BOMBomHLIndexFree(v4);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v5 = *(unsigned char **)(a1 + 32);
  if (v5)
  {
    BOMBomVIndexFree(v5);
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6)
  {
    BOMTreeFree(v6);
    *(void *)(a1 + 40) = 0;
  }
  unint64_t v7 = *(_DWORD **)(a1 + 8);
  if (v7)
  {
    uint64_t result = BOMStorageFree(v7);
    if (result) {
      return result;
    }
    *(void *)(a1 + 8) = 0;
  }
  free(*(void **)(a1 + 56));
  free((void *)a1);
  return 0;
}

_DWORD *BOMBomOpenWithStorage(_DWORD *a1, int a2)
{
  unsigned int NamedBlock = BOMStorageGetNamedBlock(a1, "BomInfo");
  if (NamedBlock)
  {
    unsigned int v5 = NamedBlock;
    uint64_t v6 = BOM_malloczero(0x48uLL);
    if (!v6)
    {
      BOMStorageFree(a1);
      return v6;
    }
    uint64_t v7 = BOMStreamWithBlockID((uint64_t)a1, v5, 0, 0);
    if (!v7
      || (uint64_t v8 = v7,
          BOMStreamReadUInt32(v7),
          int UInt32 = BOMStreamReadUInt32(v8),
          int ArchInfo = _readArchInfo((uint64_t)v6, v8),
          int v11 = BOMStreamFree(v8),
          ArchInfo)
      || v11)
    {
      BOMStorageFree(a1);
      free(v6);
    }
    else
    {
      _DWORD *v6 = UInt32;
      *((void *)v6 + 1) = a1;
      *((void *)v6 + 2) = BOMTreeOpenWithName((uint64_t)a1, "Paths", a2);
      *((void *)v6 + 3) = BOMBomHLIndexOpen((uint64_t)a1, a2);
      uint64_t v13 = BOMBomVIndexOpen((uint64_t)a1, a2);
      *((void *)v6 + 4) = v13;
      if (*((void *)v6 + 2))
      {
        if (*((void *)v6 + 3))
        {
          if (v13)
          {
            uint64_t v14 = BOMTreeOpenWithName((uint64_t)a1, "Size64", a2);
            *((void *)v6 + 5) = v14;
            if (a2 != 1 || v14 || (int v15 = BOMTreeNewWithName((uint64_t)a1, "Size64"), (*((void *)v6 + 5) = v15) != 0))
            {
              *((unsigned char *)v6 + 65) = a2;
              return v6;
            }
          }
        }
      }
      BOMBomFree((uint64_t)v6);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "file %s is not a bom file\n", "<storage>");
  }
  return 0;
}

void *BOMBomNewWithStorage(_DWORD *a1)
{
  if (a1)
  {
    int64_t v1 = a1;
    int v2 = BOM_malloczero(0x48uLL);
    if (!v2) {
      return v2;
    }
  }
  else
  {
    uint64_t v3 = BOMStorageNewInRAM();
    if (!v3) {
      return 0;
    }
    int64_t v1 = (_DWORD *)v3;
    int v2 = BOM_malloczero(0x48uLL);
    if (!v2)
    {
      BOMStorageFree(v1);
      return v2;
    }
  }
  *(_DWORD *)int v2 = 1;
  v2[1] = v1;
  unsigned int v4 = BOMStorageNewNamedBlock((uint64_t)v1, "BomInfo");
  if (!v4) {
    goto LABEL_13;
  }
  uint64_t v5 = BOMStreamWithBlockID(v2[1], v4, (16 * *((unsigned int *)v2 + 12)) | 0xC, 1);
  if (!v5) {
    goto LABEL_13;
  }
  uint64_t v6 = v5;
  BOMStreamWriteUInt32(v5, 1u);
  BOMStreamWriteUInt32(v6, *(_DWORD *)v2);
  _writeArchInfo((uint64_t)v2, v6);
  BOMStreamFree(v6);
  v2[2] = BOMTreeNewWithName((uint64_t)v1, "Paths");
  v2[3] = BOMBomHLIndexNew((uint64_t)v1);
  uint64_t v7 = BOMBomVIndexNew((uint64_t)v1);
  v2[4] = v7;
  if (!v2[2] || !v2[3] || !v7 || (uint64_t v8 = BOMTreeNewWithName((uint64_t)v1, "Size64"), (v2[5] = v8) == 0))
  {
LABEL_13:
    BOMBomFree((uint64_t)v2);
    return 0;
  }
  *((_WORD *)v2 + 32) = 257;
  return v2;
}

uint64_t _writeArchInfo(uint64_t a1, uint64_t a2)
{
  uint64_t result = BOMStreamWriteUInt32(a2, *(_DWORD *)(a1 + 48));
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      BOMStreamWriteUInt32(a2, *(_DWORD *)(*(void *)(a1 + 56) + v5));
      BOMStreamWriteUInt32(a2, *(_DWORD *)(*(void *)(a1 + 56) + v5 + 4));
      BOMStreamWriteUInt32(a2, *(_DWORD *)(*(void *)(a1 + 56) + v5 + 8));
      uint64_t result = BOMStreamWriteUInt32(a2, *(_DWORD *)(*(void *)(a1 + 56) + v5 + 16));
      ++v6;
      v5 += 24;
    }
    while (v6 < *(unsigned int *)(a1 + 48));
  }
  return result;
}

void *BOMBomNew(const char *a1)
{
  return BOMBomNewWithSys(a1, 0);
}

void *BOMBomNewWithSys(const char *a1, unsigned int (**a2)(void, const char *, uint64_t))
{
  int v2 = a2;
  if (a2)
  {
    if (a1) {
      goto LABEL_3;
    }
LABEL_7:
    unsigned int v4 = 0;
    goto LABEL_8;
  }
  int v2 = (unsigned int (**)(void, const char *, uint64_t))BomSys_default();
  if (!a1) {
    goto LABEL_7;
  }
LABEL_3:
  if (!v2[23](v2[1], a1, 6)
    && ((unsigned int (*)(unsigned int (*)(void, const char *, uint64_t), const char *))v2[28])(v2[1], a1))
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "can't unlink %s\n", a1);
    return 0;
  }
  unsigned int v4 = (_DWORD *)BOMStorageNewWithSys(a1, (uint64_t (**)(void, const char *, uint64_t, uint64_t))v2);
  if (!v4) {
    return 0;
  }
LABEL_8:
  return BOMBomNewWithStorage(v4);
}

BOOL BOMBomFSObjectExistsAtPath(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a1)
  {
    if (a2) {
      return _valueAtPath(a1) != 0;
    }
  }
  return result;
}

unsigned int *_valueAtPath(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  size_t v9 = 0;
  __stringp = &v11;
  __strlcpy_chk();
  int v2 = strsep(&__stringp, "/");
  if (v2)
  {
    uint64_t v3 = v2;
    unsigned int v4 = 0;
    while (1)
    {
      uint64_t v5 = BOMNewPathKey(v4, v3, &v9);
      if (!v5) {
        break;
      }
      unint64_t v6 = v5;
      Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v5, v9);
      free(v6);
      if (Value)
      {
        unsigned int v4 = BOMPathIDFromPathKey(Value);
        uint64_t v3 = strsep(&__stringp, "/");
        if (v3) {
          continue;
        }
      }
      return Value;
    }
  }
  return 0;
}

uint64_t BOMBomNewFromBom(const char *a1, uint64_t a2)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  Sys = (unsigned int (**)(void, const char *, uint64_t))BOMStorageGetSys(*(void *)(a2 + 8));
  uint64_t v5 = BOMBomNewWithSys(a1, Sys);
  uint64_t v6 = (uint64_t)v5;
  if (!a2 || !v5) {
    goto LABEL_43;
  }
  BOMTreeSetDensePacking(v5[2], 1);
  uint64_t v7 = (const void **)BOMHardLinkTableNew();
  if (!v7) {
    goto LABEL_44;
  }
  uint64_t v8 = v7;
  *(_DWORD *)bytes = 0;
  uint64_t v38 = 0;
  size_t v9 = (char *)BOMTreeIteratorNew(*(void *)(a2 + 16), 0, 0, 0);
  if (!v9)
  {
    BOMHardLinkTableFree(v8);
    goto LABEL_44;
  }
  uint64_t v10 = v9;
  if (BOMTreeIteratorIsAtEnd((uint64_t)v9))
  {
    BOMHardLinkTableFree(v8);
    BOMTreeIteratorFree(v10);
    goto LABEL_37;
  }
  size_t v11 = 0;
  uint64_t v12 = 0;
  while (1)
  {
    uint64_t v13 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v10);
    unsigned int v14 = BOMBlockIDFromPathValue((uint64_t)v13);
    unsigned int v15 = BOMPathIDFromPathKey(v13);
    int v16 = BOMHardLinkTableGet((CFDictionaryRef *)v8, 0, v14);
    if (v16)
    {
      *(_DWORD *)bytes = *(_DWORD *)v16;
      goto LABEL_22;
    }
    size_t v17 = BOMStorageSizeOfBlock(*(void *)(a2 + 8), v14);
    if (v17 > v11)
    {
      if (v12) {
        free(v12);
      }
      uint64_t v12 = BOM_malloc(v17);
      size_t v11 = v17;
    }
    if (BOMStorageCopyFromBlock(*(void *)(a2 + 8), v14, v12))
    {
      long long v35 = BOMExceptionHandlerMessage("_copyFilesFromBomToBomInOrder failed while getting data (pid=%u bid=%u)", v15, v14);
      long long v36 = __error();
      _BOMFatalException((uint64_t)v35, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 985, *v36);
    }
    uint64_t v18 = BOMStorageNewBlock(*(void *)(v6 + 8));
    *(_DWORD *)bytes = v18;
    if (BOMStorageSetBlockData(*(void *)(v6 + 8), v18, v12, v17)) {
      break;
    }
    unsigned int v19 = BOMBomHLIndexCount(*(void *)(a2 + 24), v14);
    if (v19 >= 2)
    {
      unsigned int v20 = v19;
      size_t v37 = 0;
      BOMHardLinkTableSet((CFDictionaryRef *)v8, 0, v14, bytes, 4);
      unsigned int v21 = 0;
      while (1)
      {
        if (BOMBomHLIndexGet(*(void *)(a2 + 24), v14, v21, v40, &v37))
        {
          long long v27 = (FILE *)*MEMORY[0x263EF8348];
          size_t v28 = "can't get hardlink data\n";
          size_t v29 = 24;
          goto LABEL_33;
        }
        if (BOMBomHLIndexSet(*(void *)(v6 + 24), *(unsigned int *)bytes, v40, v37)) {
          break;
        }
        if (v20 == ++v21) {
          goto LABEL_22;
        }
      }
      long long v27 = (FILE *)*MEMORY[0x263EF8348];
      size_t v28 = "can't set hardlink index\n";
      goto LABEL_32;
    }
LABEL_22:
    pthread_attr_t v22 = BOMNewPathValue(v15, *(unsigned int *)bytes, &v38);
    uint64_t v23 = *(void **)(v6 + 16);
    uint64_t v24 = (const void *)BOMTreeIteratorKey((uint64_t)v10);
    size_t v25 = BOMTreeIteratorKeySize((uint64_t)v10);
    if (BOMTreeSetValue(v23, v24, v25, (uint64_t)v22, v38))
    {
      if (v22) {
        free(v22);
      }
      long long v27 = (FILE *)*MEMORY[0x263EF8348];
      size_t v28 = "can't set new path value\n";
LABEL_32:
      size_t v29 = 25;
      goto LABEL_33;
    }
    if (v22) {
      free(v22);
    }
    BOMTreeIteratorNext((uint64_t)v10);
    if (BOMTreeIteratorIsAtEnd((uint64_t)v10))
    {
      int v26 = 1;
      goto LABEL_34;
    }
  }
  long long v27 = (FILE *)*MEMORY[0x263EF8348];
  size_t v28 = "can't set file data\n";
  size_t v29 = 20;
LABEL_33:
  fwrite(v28, v29, 1uLL, v27);
  int v26 = 0;
LABEL_34:
  if (v12) {
    free(v12);
  }
  BOMHardLinkTableFree(v8);
  BOMTreeIteratorFree(v10);
  if (!v26)
  {
LABEL_43:
    if (!v6) {
      return v6;
    }
LABEL_44:
    BOMBomFree(v6);
    return 0;
  }
LABEL_37:
  BOMTreeSetDensePacking(*(void *)(v6 + 16), 0);
  if (BOMBomVIndexCopyFromVIndex(*(void *)(v6 + 32), *(void *)(a2 + 32))) {
    goto LABEL_44;
  }
  long long v30 = *(void **)(v6 + 56);
  if (v30) {
    free(v30);
  }
  uint64_t v31 = *(unsigned int *)(a2 + 48);
  *(_DWORD *)(v6 + 48) = v31;
  size_t v32 = 24 * v31;
  long long v33 = BOM_malloczero(24 * v31);
  *(void *)(v6 + 56) = v33;
  if (v33) {
    memmove(v33, *(const void **)(a2 + 56), v32);
  }
  *(_DWORD *)uint64_t v6 = *(_DWORD *)a2;
  return v6;
}

uint64_t BOMBomNewFromPath(char *a1, char *a2)
{
  return BOMBomNewFromPathWithSys(a1, a2, 0);
}

uint64_t BOMBomNewFromPathWithSys(char *__s1, char *__s2, void *a3)
{
  if (!__s2 || __s1 && !strcmp(__s1, __s2)) {
    return 0;
  }
  if (!a3) {
    a3 = BomSys_default();
  }
  memset(v14, 0, sizeof(v14));
  memset(v13, 0, sizeof(v13));
  if (!__s1) {
    goto LABEL_9;
  }
  if ((*((unsigned int (**)(void, char *, _OWORD *))a3 + 12))(*((void *)a3 + 1), __s1, v14))
  {
    if (*__error() == 2) {
      goto LABEL_9;
    }
    uint64_t v10 = (FILE *)*MEMORY[0x263EF8348];
    size_t v11 = __error();
    strerror(*v11);
    fprintf(v10, "can't stat %s: %s\n");
    return 0;
  }
  if ((*((unsigned int (**)(void, char *, _OWORD *))a3 + 12))(*((void *)a3 + 1), __s2, v13))
  {
    uint64_t v8 = (FILE *)*MEMORY[0x263EF8348];
    size_t v9 = __error();
    strerror(*v9);
    fprintf(v8, "can't stat %s: %s\n");
    return 0;
  }
  if (LODWORD(v14[0]) == LODWORD(v13[0]) && *((void *)&v14[0] + 1) == *((void *)&v13[0] + 1))
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%s and %s are identical.\n");
    return 0;
  }
LABEL_9:
  uint64_t v6 = BOMBomOpenWithSys(__s2, 0, a3);
  uint64_t v7 = BOMBomNewFromBom(__s1, (uint64_t)v6);
  if (v6) {
    BOMBomFree((uint64_t)v6);
  }
  return v7;
}

unsigned int *BOMBomNewFromBomWithStripping(const char *a1, uint64_t *a2, const char **a3, const char **a4)
{
  return BOMBomNewFromBomWithOptions(a1, a2, 3, a3, a4);
}

unsigned int *BOMBomNewFromBomWithOptions(const char *a1, uint64_t *a2, char a3, const char **a4, const char **a5)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  if (!a2) {
    return 0;
  }
  uint64_t Sys = BOMStorageGetSys(a2[1]);
  uint64_t v11 = Sys;
  if (a1
    && !(*(unsigned int (**)(void, const char *, uint64_t))(Sys + 184))(*(void *)(Sys + 8), a1, 6)
    && (*(unsigned int (**)(void, const char *))(v11 + 224))(*(void *)(v11 + 8), a1))
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "can't unlink %s\n", a1);
    return 0;
  }
  uint64_t v12 = (unsigned int *)BOMBomNewWithSys(a1, (unsigned int (**)(void, const char *, uint64_t))v11);
  if (v12)
  {
    __s[0] = 0;
    size_t v13 = strlen(__s);
    _copyFilesFromBomToBom(a2, v12, 0, __s, &__s[v13], 0, 0, 0, 1);
    _copyVariantsFromBomToBom((uint64_t)a2, (uint64_t)v12, v14, v15, v16, v17, v18, v19);
    if (a3)
    {
      unsigned int v20 = _patternListForArchAndLangs((uint64_t)a2, a4, a5, 1);
      CFArrayRef v21 = v20;
      if (v20)
      {
        if (CFArrayGetCount(v20))
        {
          RootFSObject = (unsigned int *)BOMBomGetRootFSObject((uint64_t)v12);
          uint64_t v23 = BOMBomEnumeratorNew((uint64_t)v12, RootFSObject);
          BOMFSObjectFree((uint64_t)RootFSObject);
          if (v23)
          {
            v78 = a5;
            char v79 = a3;
            CFIndex Count = CFArrayGetCount(v21);
            size_t v25 = BOMBomEnumeratorNext((uint64_t)v23);
            if (v25)
            {
              int v26 = v25;
              BOOL v27 = 0;
              while (1)
              {
                uint64_t v28 = BOMFSObjectPathName((uint64_t)v26);
                if (Count >= 1) {
                  break;
                }
LABEL_16:
                if (v27) {
                  goto LABEL_17;
                }
LABEL_18:
                BOMFSObjectFree((uint64_t)v26);
                int v26 = BOMBomEnumeratorNext((uint64_t)v23);
                if (!v26) {
                  goto LABEL_19;
                }
              }
              size_t v29 = (const char *)v28;
              CFIndex v30 = 0;
              while (1)
              {
                ValueAtIndex = (regex_t *)CFArrayGetValueAtIndex(v21, v30);
                if (ValueAtIndex)
                {
                  BOOL v27 = BOMPatternMatch(ValueAtIndex, v29);
                  if (v27) {
                    break;
                  }
                }
                if (Count == ++v30) {
                  goto LABEL_16;
                }
              }
LABEL_17:
              BOMBomRemoveFSObject((unint64_t)v12, v26);
              goto LABEL_18;
            }
LABEL_19:
            BOMBomEnumeratorFree(v23);
            a3 = v79;
            a5 = v78;
          }
        }
      }
      BOMPatternListFree(v21);
      __s[0] = 0;
      size_t v32 = _patternListForArchAndLangs((uint64_t)a2, a4, a5, 0);
      size_t v33 = strlen(__s);
      _copyFilesFromBomToBom(a2, v12, v32, __s, &__s[v33], 0, 0, 0, 1);
      BOMPatternListFree(v32);
    }
    if ((a3 & 2) != 0 && a4 && *a4)
    {
      uint64_t v34 = 0;
      while (a4[++v34])
        ;
      uint64_t v36 = v34;
      size_t v37 = BOM_malloczero(32 * v34);
      uint64_t v38 = (char *)v37;
      if (v34)
      {
        long long v39 = v37 + 2;
        while (1)
        {
          long long v40 = *a4;
          uint64_t v41 = BOMGetArchInfoFromName((char *)*a4);
          if (!v41) {
            break;
          }
          int v42 = *((_DWORD *)v41 + 3);
          long long v43 = BOMGetArchInfoFromCpuType(*((_DWORD *)v41 + 2), -1);
          if (!v43) {
            break;
          }
          int v45 = *((_DWORD *)v43 + 2);
          int v44 = *((_DWORD *)v43 + 3);
          int v46 = 16777228;
          BOOL v47 = v45 == 16777228 && v42 == 0;
          if (v47)
          {
            char v48 = 0;
          }
          else
          {
            int v46 = *((_DWORD *)v43 + 2);
            char v48 = 1;
          }
          if (v47) {
            int v49 = 0;
          }
          else {
            int v49 = -1;
          }
          if (v45 == 16777223 && v42 == 3)
          {
            int v46 = 16777223;
            char v48 = 0;
            int v49 = 3;
          }
          BOOL v51 = v42 == v44;
          if (v42 == v44) {
            int v52 = v46;
          }
          else {
            int v52 = *((_DWORD *)v43 + 2);
          }
          if (v51) {
            char v53 = v48;
          }
          else {
            char v53 = 0;
          }
          if (v51) {
            int v54 = v49;
          }
          else {
            int v54 = v42;
          }
          *(v39 - 2) = v52;
          *((unsigned char *)v39 - 4) = v53;
          *long long v39 = v54;
          v39 += 8;
          ++a4;
          if (!--v36) {
            goto LABEL_54;
          }
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "can't get arch info for '%s'", v40);
      }
      else
      {
LABEL_54:
        v55 = (unsigned int *)BOMBomGetRootFSObject((uint64_t)v12);
        v56 = BOMBomEnumeratorNew((uint64_t)v12, v55);
        BOMFSObjectFree((uint64_t)v55);
        if (v56)
        {
          v57 = BOMBomEnumeratorNext((uint64_t)v56);
          if (v57)
          {
            v58 = v57;
            do
            {
              if (BOMFSObjectType(v58) == 1 && BOMFSObjectIsBinaryObject((uint64_t)v58))
              {
                int v59 = BOMFSObjectArchCount((uint64_t)v58);
                if (v59)
                {
                  int v60 = v59;
                  unsigned int v61 = 0;
                  while (1)
                  {
                    int Arch = BOMFSObjectGetArch((uint64_t)v58, v61);
                    int ArchSubtype = BOMFSObjectGetArchSubtype((uint64_t)v58, v61);
                    if (v34) {
                      break;
                    }
LABEL_67:
                    if (++v61 == v60) {
                      goto LABEL_68;
                    }
                  }
                  uint64_t v64 = 0;
                  while (Arch != *(_DWORD *)&v38[v64]
                       || !v38[v64 + 4] && ((*(_DWORD *)&v38[v64 + 8] ^ ArchSubtype) & 0xFFFFFF) != 0)
                  {
                    v64 += 32;
                    if (32 * v34 == v64) {
                      goto LABEL_67;
                    }
                  }
                  if (!BOMFSObjectThinKeepingArchsAndSubArchs((uint64_t)v58, (uint64_t)v38, v34))
                  {
                    unsigned int v65 = BOMFSObjectBlockID((uint64_t)v58);
                    if (!_BOMBomSetFSObjectWithBlockID((uint64_t)v12, (uint64_t)v58, v65)) {
                      *((unsigned char *)v12 + 64) = 1;
                    }
                  }
                }
                else
                {
LABEL_68:
                  BOMBomRemoveFSObject((unint64_t)v12, v58);
                }
              }
              BOMFSObjectFree((uint64_t)v58);
              v58 = BOMBomEnumeratorNext((uint64_t)v56);
            }
            while (v58);
          }
          BOMBomEnumeratorFree(v56);
          if (*((unsigned char *)v12 + 64))
          {
            uint64_t v66 = v12[12];
            v67 = (void *)*((void *)v12 + 7);
            v68 = BOM_malloczero(24 * (v66 + 1));
            *((void *)v12 + 7) = v68;
            uint64_t v69 = v67[2];
            *(_OWORD *)v68 = *(_OWORD *)v67;
            v68[2] = v69;
            if (v66 < 2)
            {
              unsigned int v71 = 1;
            }
            else
            {
              uint64_t v70 = 1;
              unsigned int v71 = 1;
              do
              {
                if (v34)
                {
                  v72 = (char *)&v67[3 * v70];
                  uint64_t v73 = v34;
                  v74 = v38 + 8;
                  while (*(_DWORD *)v72 != *(v74 - 2)
                       || !*((unsigned char *)v74 - 4) && ((*v74 ^ *((_DWORD *)v72 + 1)) & 0xFFFFFF) != 0)
                  {
                    v74 += 8;
                    if (!--v73) {
                      goto LABEL_84;
                    }
                  }
                  uint64_t v75 = *((void *)v12 + 7) + 24 * v71++;
                  long long v76 = *(_OWORD *)v72;
                  *(void *)(v75 + 16) = *((void *)v72 + 2);
                  *(_OWORD *)uint64_t v75 = v76;
                }
LABEL_84:
                ++v70;
              }
              while (v70 != v66);
            }
            v12[12] = v71;
            free(v67);
          }
        }
      }
      free(v38);
    }
  }
  return v12;
}

uint64_t _copyFilesFromBomToBom(uint64_t *a1, unsigned int *a2, const __CFArray *a3, const char *a4, char *a5, unsigned int a6, unsigned int a7, CFDictionaryRef *a8, char a9)
{
  size_t v9 = a8;
  uint64_t v96 = *MEMORY[0x263EF8340];
  v85 = a8;
  if (!a8) {
    v85 = (CFDictionaryRef *)BOMHardLinkTableNew();
  }
  uint64_t v93 = 0;
  size_t v94 = 0;
  unsigned int v92 = 0;
  v91 = 0;
  uint64_t v17 = BOMNewPathKey(a6, "", &v94);
  if (!v17) {
    goto LABEL_9;
  }
  uint64_t v18 = v17;
  uint64_t v19 = (char *)BOMTreeIteratorNew(a1[2], v17, v94, 0);
  free(v18);
  if (!v19) {
    goto LABEL_9;
  }
  __dst = (char *)a4;
  if (a4 != a5)
  {
    *a5 = 47;
    __dst = a5 + 1;
  }
  if (BOMTreeIteratorIsAtEnd((uint64_t)v19))
  {
    BOMTreeIteratorFree(v19);
LABEL_9:
    unsigned int v20 = 0;
    unsigned __int8 v21 = 0;
    goto LABEL_10;
  }
  size_t v88 = 0;
  CFArrayRef theArray = a3;
  unsigned int v71 = a7;
  unsigned int v20 = 0;
  int v73 = 0;
  uint64_t __size = a4 - __dst + 1025;
  v87 = a4;
  v72 = v9;
  unsigned int v86 = a6;
  do
  {
    uint64_t v23 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v19);
    if (BOMPathIDFromPathKey(v23) != a6) {
      break;
    }
    uint64_t v24 = (uint64_t)a2;
    size_t v25 = (const char *)BOMShortNameFromPathKey((uint64_t)v23);
    int v26 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v19);
    unsigned int v27 = BOMBlockIDFromPathValue((uint64_t)v26);
    unsigned int v28 = BOMPathIDFromPathKey(v26);
    size_t v29 = BOMStorageSizeOfBlock(a1[1], v27);
    if (v29 > v88)
    {
      if (v20) {
        free(v20);
      }
      unsigned int v20 = BOM_malloc(v29);
      size_t v88 = v29;
    }
    if (BOMStorageCopyFromBlock(a1[1], v27, v20))
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "can't unarchive %s. skipping...\n");
LABEL_23:
      a2 = (unsigned int *)v24;
      goto LABEL_24;
    }
    unsigned int v80 = v28;
    unsigned int v84 = BOMFSObjectTypeFromRawData((unsigned __int8 *)v20);
    strlcpy(__dst, v25, __size);
    size_t v79 = strlen(v25);
    unsigned int v92 = 0;
    if (!a9)
    {
      char v78 = 0;
      int v81 = 0;
      LODWORD(v82) = 1;
      a2 = (unsigned int *)v24;
      goto LABEL_39;
    }
    a2 = (unsigned int *)v24;
    CFIndex v30 = _valueAtPath(v24);
    if (!v30)
    {
      char v78 = 0;
      int v81 = 0;
      LODWORD(v82) = 1;
      goto LABEL_39;
    }
    uint64_t v31 = (uint64_t)v30;
    size_t v32 = v9;
    size_t v33 = BOMPathIDFromPathKey(v30);
    unsigned int v92 = BOMBlockIDFromPathValue(v31);
    if (BOMStorageCopyFromBlockRange(*(void *)(v24 + 8), v92, 0, 1uLL, &v90))
    {
      uint64_t v34 = BOMExceptionHandlerMessage("BOMStorageCopyFromBlockRange(storage=%p, bid=%u, location=%u, length=%u, data=%p) failed!", *(const void **)(v24 + 8), v92, 0, 1, &v90);
      long long v35 = __error();
      _BOMExceptionHandlerCall((uint64_t)v34, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 743, *v35);
    }
    unsigned int v36 = BOMFSObjectTypeFromRawData(&v90);
    int v81 = v36;
    if (BOMBomHLIndexCount(*(void *)(v24 + 24), v92))
    {
      if (v36 == 1)
      {
        size_t v37 = v33;
        char v78 = 1;
        LODWORD(v82) = 0;
        HIDWORD(v82) = v92;
        int v81 = 1;
        size_t v9 = v32;
        a4 = v87;
      }
      else
      {
        LODWORD(v82) = 0;
        char v78 = 1;
        size_t v9 = v32;
        a4 = v87;
LABEL_39:
        HIDWORD(v82) = 0;
        size_t v37 = (unsigned int *)*a2;
        *a2 = v37 + 1;
      }
      if (v84 == 1 && BOMBomHLIndexCount(a1[3], v27))
      {
        v91 = 0;
        BOMHardLinkTableGetPathAndData(v85, 0, v27, __s, &v91);
        if (v91)
        {
          unsigned int v38 = *v91;
          BOOL v75 = 1;
        }
        else
        {
          unsigned int v38 = BOMStorageNewBlock(*((void *)a2 + 1));
          BOOL v75 = 0;
        }
        char v77 = 0;
        unsigned int v92 = v38;
      }
      else
      {
        BOOL v75 = 0;
        unsigned int v92 = BOMStorageNewBlock(*((void *)a2 + 1));
        char v77 = 1;
      }
      goto LABEL_50;
    }
    size_t v37 = v33;
    if (v84 == 1)
    {
      size_t v9 = v32;
      if (BOMBomHLIndexCount(a1[3], v27))
      {
        v91 = 0;
        BOMHardLinkTableGetPathAndData(v85, 0, v27, __s, &v91);
        uint64_t v82 = 0;
        BOOL v75 = v91 != 0;
        char v77 = 0;
        char v78 = 1;
      }
      else
      {
        uint64_t v82 = 0;
        BOOL v75 = 0;
        char v77 = 1;
        char v78 = 1;
      }
    }
    else
    {
      uint64_t v82 = 0;
      BOOL v75 = 0;
      char v77 = 1;
      char v78 = 1;
      size_t v9 = v32;
    }
    a4 = v87;
LABEL_50:
    if (!v92 || !v37) {
      goto LABEL_24;
    }
    if (theArray)
    {
      long long v39 = v37;
      CFIndex Count = CFArrayGetCount(theArray);
      if (Count < 1)
      {
        BOOL v45 = 0;
      }
      else
      {
        CFIndex v41 = Count;
        CFIndex v42 = 0;
        while (1)
        {
          ValueAtIndex = (regex_t *)CFArrayGetValueAtIndex(theArray, v42);
          if (ValueAtIndex)
          {
            BOOL v44 = BOMPatternMatch(ValueAtIndex, v87);
            if (v44) {
              break;
            }
          }
          if (v41 == ++v42)
          {
            BOOL v45 = 0;
            goto LABEL_63;
          }
        }
        BOOL v45 = v44;
LABEL_63:
        size_t v9 = v72;
      }
      size_t v37 = v39;
      if (v84 == 2)
      {
        if (v45) {
          CFArrayRef v46 = 0;
        }
        else {
          CFArrayRef v46 = theArray;
        }
        LOBYTE(v70) = v78;
        a4 = v87;
        int v47 = _copyFilesFromBomToBom(a1, v24, v46, v87, &__dst[v79], v80, v37, v85, v70);
      }
      else
      {
        int v47 = 0;
        a4 = v87;
      }
      int v48 = v47 | v45;
      a2 = (unsigned int *)v24;
      if (!v48) {
        goto LABEL_24;
      }
    }
    else if (v84 == 2)
    {
      LOBYTE(v70) = v78;
      _copyFilesFromBomToBom(a1, a2, 0, a4, &__dst[v79], v80, v37, v85, v70);
    }
    unsigned int v74 = v37;
    int v49 = v82;
    if (v81 == 2) {
      int v50 = v82;
    }
    else {
      int v50 = 1;
    }
    if (v50 == 1)
    {
      if ((v82 & 1) == 0)
      {
        if (HIDWORD(v82)) {
          unsigned int v51 = HIDWORD(v82);
        }
        else {
          unsigned int v51 = v92;
        }
        FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID((uint64_t)a2, v51);
        if (FSObjectWithBlockID)
        {
          uint64_t v53 = (uint64_t)FSObjectWithBlockID;
          _removeArchInfoForFSObject((unint64_t)a2, (uint64_t)FSObjectWithBlockID);
          BOMFSObjectFree(v53);
        }
        int v49 = v82;
        if (HIDWORD(v82))
        {
          size_t v54 = strlen(a4) + 1;
          int v49 = v82;
          BOMBomHLIndexRemove(*((void *)a2 + 3), HIDWORD(v82), a4, v54);
          if (!BOMBomHLIndexCount(*((void *)a2 + 3), HIDWORD(v82))) {
            BOMStorageFreeBlock(*((void *)a2 + 1), HIDWORD(v82));
          }
        }
      }
      if (BOMStorageSetBlockData(*((void *)a2 + 1), v92, v20, v29))
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], "can't archive %s. skipping...\n", a4);
        goto LABEL_24;
      }
      v55 = _BOMBomGetFSObjectWithBlockID((uint64_t)a2, v92);
      if (v55)
      {
        uint64_t v56 = (uint64_t)v55;
        _addArchInfoForFSObject((uint64_t)a2, (uint64_t)v55);
        BOMFSObjectFree(v56);
      }
    }
    if (HIDWORD(v82)) {
      int v57 = 1;
    }
    else {
      int v57 = v49;
    }
    if (v57 == 1)
    {
      uint64_t v58 = BOMTreeIteratorKey((uint64_t)v19);
      int v59 = (char *)BOMShortNameFromPathKey(v58);
      int v60 = BOMNewPathKey(v71, v59, &v94);
      unsigned int v61 = BOMNewPathValue(v74, v92, &v93);
      int v62 = BOMTreeSetValue(*((void **)a2 + 2), v60, v94, (uint64_t)v61, v93);
      free(v60);
      free(v61);
      if (v62)
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], "can't set path info for %s. skipping...\n");
        goto LABEL_23;
      }
      int v73 = 1;
      a2 = (unsigned int *)v24;
    }
    if ((v77 & 1) == 0)
    {
      if (v75)
      {
        uint64_t v63 = *((void *)a2 + 3);
        if (!__s[0])
        {
          size_t v69 = strlen(a4);
          BOMBomHLIndexSet(v63, v92, a4, v69 + 1);
          goto LABEL_24;
        }
        size_t v64 = strlen(__s);
        BOMBomHLIndexSet(v63, v92, __s, v64 + 1);
        size_t v65 = strlen(a4);
        BOMBomHLIndexSet(*((void *)a2 + 3), v92, a4, v65 + 1);
        uint64_t v66 = v27;
        v67 = v85;
        v68 = "";
      }
      else
      {
        uint64_t v66 = v27;
        v67 = v85;
        v68 = (char *)a4;
      }
      BOMHardLinkTableSetPathAndData(v67, 0, v66, v68, &v92, 4uLL);
    }
LABEL_24:
    BOMTreeIteratorNext((uint64_t)v19);
    a6 = v86;
  }
  while (!BOMTreeIteratorIsAtEnd((uint64_t)v19));
  BOMTreeIteratorFree(v19);
  unsigned __int8 v21 = v73;
  if (v73) {
    *((unsigned char *)a2 + 64) = 1;
  }
LABEL_10:
  if (!v9) {
    BOMHardLinkTableFree((const void **)v85);
  }
  if (v20) {
    free(v20);
  }
  return v21;
}

uint64_t _copyVariantsFromBomToBom(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  if (result)
  {
    uint64_t v9 = result;
    BOOL result = BOMBomVIndexCount(*(void *)(result + 32), 0, 0, 0, a5, a6, a7, a8);
    int v37 = result;
    if ((int)result >= 1)
    {
      unsigned int v11 = 0;
      unsigned int v38 = 0;
      do
      {
        BOMBomVIndexGet(*(void *)(v9 + 32), 0, 0, 0, v11, v42, 0x64uLL, v10);
        BOOL result = BOMBomVIndexCount(*(void *)(v9 + 32), v42, 0, 0, v12, v13, v14, v15);
        if ((int)result >= 1)
        {
          int v16 = result;
          for (unsigned int i = 0; i != v16; ++i)
          {
            BOMBomVIndexGet(*(void *)(v9 + 32), v42, 0, 0, i, v41, 0x64uLL, v10);
            BOOL result = BOMBomVIndexCount(*(void *)(v9 + 32), v42, (uint64_t)v41, 0, v18, v19, v20, v21);
            if ((int)result >= 1)
            {
              int v22 = result;
              for (unsigned int j = 0; j != v22; ++j)
              {
                BOMBomVIndexGet(*(void *)(v9 + 32), v42, (uint64_t)v41, 0, j, v40, 0x64uLL, v10);
                int v28 = BOMBomVIndexCount(*(void *)(v9 + 32), v42, (uint64_t)v41, (uint64_t)v40, v24, v25, v26, v27);
                if (v28 >= 1)
                {
                  int v32 = v28;
                  for (unsigned int k = 0; k != v32; ++k)
                  {
                    int v34 = BOMBomVIndexGet(*(void *)(v9 + 32), v42, (uint64_t)v41, (uint64_t)v40, k, v39, 0x64uLL, v31);
                    if (a2
                      && !v34
                      && !BOMBomVIndexSet(*(void *)(a2 + 32), v42, (uint64_t)v41, (uint64_t)v40, v39, v29, v30, v31))
                    {
                      *(unsigned char *)(a2 + 64) = 1;
                    }
                  }
                }
                BOOL result = BOMBomVIndexGetApproxDiskSpace(*(void *)(a2 + 32), v42, (uint64_t)v41, (uint64_t)v40, &v38, v29, v30, v31);
                if (!result) {
                  BOOL result = BOMBomVIndexSetApproxDiskSpace(*(void *)(a2 + 32), v42, (uint64_t)v41, (uint64_t)v40, v38, v35, v36, v10);
                }
              }
            }
          }
        }
        ++v11;
      }
      while (v11 != v37);
    }
  }
  return result;
}

__CFArray *_patternListForArchAndLangs(uint64_t a1, const char **a2, const char **a3, int a4)
{
  uint64_t v10 = BOMPatternListNew();
  if (!v10) {
    return v10;
  }
  if (!a2) {
    goto LABEL_5;
  }
  if (a4)
  {
    _addPathsToList(a1, "arch", v10, a2, 1, 1, v8, v9);
    _addPathsToList(a1, "arch", v10, a2, 0, 0, v11, v12);
LABEL_5:
    if (!a3) {
      goto LABEL_12;
    }
    if (a4)
    {
      _addPathsToList(a1, "lang", v10, a3, 1, 1, v8, v9);
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = 1;
    }
    goto LABEL_11;
  }
  uint64_t v13 = 1;
  _addPathsToList(a1, "arch", v10, a2, 1, 0, v8, v9);
  if (a3) {
LABEL_11:
  }
    _addPathsToList(a1, "lang", v10, a3, v13, 0, v8, v9);
LABEL_12:
  CFIndex Count = CFArrayGetCount(v10);
  if (Count >= 1)
  {
    CFIndex v15 = Count;
    for (CFIndex i = 0; i != v15; ++i)
    {
      ValueAtIndex = (char *)CFArrayGetValueAtIndex(v10, i);
      uint64_t v18 = BOMPatternCompileString(ValueAtIndex);
      CFArraySetValueAtIndex(v10, i, v18);
      free(ValueAtIndex);
    }
  }
  return v10;
}

char *BOMBomNewFromDirectory(char *a1, char *a2, uint64_t a3)
{
  return BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0);
}

char *BOMBomNewFromDirectoryWithSys(char *a1, char *a2, uint64_t a3, unsigned int (**a4)(void, char *, long long *))
{
  keys[1] = *(void **)MEMORY[0x263EF8340];
  uint64_t v8 = getenv("BOMBomNewFromDirectory_parallel");
  if (v8 && (uint64_t v9 = v8, strcmp(v8, "1")) && !strcmp(v9, "0"))
  {
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    long long v97 = 0u;
    long long v98 = 0u;
    long long v95 = 0u;
    long long v96 = 0u;
    blocunsigned int k = 0u;
    if (!a4) {
      a4 = (unsigned int (**)(void, char *, long long *))BomSys_default();
    }
    if (a4[10](a4[1], a2, &block))
    {
      uint64_t v10 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v13 = __error();
      v91 = a2;
      uint64_t v93 = strerror(*v13);
      uint64_t v12 = "can't stat %s (%s)\n";
      goto LABEL_14;
    }
    if ((WORD2(block) & 0xF000) != 0x4000) {
      goto LABEL_53;
    }
    a1 = (char *)BOMBomNewWithSys(a1, (unsigned int (**)(void, const char *, uint64_t))a4);
    if (a1)
    {
      v55 = (const void **)BOMHardLinkTableNew();
      if (v55)
      {
        uint64_t v56 = v55;
        a4[38](a4[1], (char *)&v114, (long long *)1025);
        if (!((unsigned int (*)(unsigned int (*)(void, char *, long long *), char *))a4[39])(a4[1], a2))
        {
          __strlcpy_chk();
          size_t v57 = strlen(__s);
          if (!_visitDir((unsigned int *)a1, __s, &__s[v57], 0, (CFDictionaryRef *)v56, a3))
          {
            BOMHardLinkTableFree(v56);
            ((void (*)(unsigned int (*)(void, char *, long long *), stat *))a4[39])(a4[1], &v114);
            return a1;
          }
        }
      }
      BOMBomFree((uint64_t)a1);
      return 0;
    }
  }
  else
  {
    if (a1)
    {
      if (!a2)
      {
        fwrite("directory_path is NULL\n", 0x17uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
        return 0;
      }
      memset(&v114, 0, sizeof(v114));
      if (stat(a2, &v114))
      {
        uint64_t v10 = (FILE *)*MEMORY[0x263EF8348];
        uint64_t v11 = __error();
        v91 = a2;
        uint64_t v93 = strerror(*v11);
        uint64_t v12 = "Could not stat %s: %s\n";
LABEL_14:
        uint64_t v14 = v10;
LABEL_54:
        fprintf(v14, v12, v91, v93, block, v95, v96, v97, v98, v99, v100, v101, v102);
        return 0;
      }
      if ((v114.st_mode & 0xF000) == 0x4000)
      {
        *(void *)__s = 0;
        v107 = __s;
        uint64_t v108 = 0x6000000000;
        long long v109 = 0u;
        long long v110 = 0u;
        long long v111 = 0u;
        long long v112 = 0u;
        uint64_t v113 = 0;
        values = (void *)*MEMORY[0x263EFFB40];
        keys[0] = @"disableLexicographicSort";
        CFDictionaryRef v15 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const void **)keys, (const void **)&values, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
        if (!v15
          || (CFDictionaryRef v16 = v15,
              uint64_t v17 = BOMCopierSourceNew(a2, v15, 0, 0),
              *((void *)v107 + 3) = v17,
              CFRelease(v16),
              !*((void *)v107 + 3)))
        {
          int v59 = (FILE *)*MEMORY[0x263EF8348];
          int v60 = "Could not create BOMCopierSource\n";
          size_t v61 = 33;
          goto LABEL_58;
        }
        dispatch_queue_global_t global_queue = dispatch_get_global_queue(0, 0);
        if (!global_queue)
        {
          int v59 = (FILE *)*MEMORY[0x263EF8348];
          int v60 = "Could not get the global queue\n";
          size_t v61 = 31;
          goto LABEL_58;
        }
        uint64_t v19 = global_queue;
        dispatch_group_t v20 = dispatch_group_create();
        *((void *)v107 + 6) = v20;
        if (!v20)
        {
          int v59 = (FILE *)*MEMORY[0x263EF8348];
          int v60 = "Could not create dispatch group\n";
          size_t v61 = 32;
          goto LABEL_58;
        }
        *((void *)v107 + 7) = BOMStackNew();
        uint64_t v21 = BOMHardLinkTableNew();
        *((void *)v107 + 9) = v21;
        if (v21)
        {
          int v22 = malloc_type_calloc(1uLL, 0x400uLL, 0x488F247BuLL);
          uint64_t v29 = v107;
          *((void *)v107 + 10) = v22;
          if (!v22)
          {
            int v59 = (FILE *)*MEMORY[0x263EF8348];
            int v60 = "Could not create empty hardlink path\n";
            size_t v61 = 37;
            goto LABEL_58;
          }
          v105 = 0;
          uint64_t v30 = BOMCopierSourceNext(*((void *)v29 + 3), &v105, v23, v24, v25, v26, v27, v28);
          if (v30)
          {
            uint64_t v31 = v30;
            int v32 = 1;
            while (1)
            {
              size_t v33 = malloc_type_calloc(1uLL, 0x50uLL, 0x1030040C9A1E1CFuLL);
              if (!v33)
              {
                int v59 = (FILE *)*MEMORY[0x263EF8348];
                int v60 = "Could not allocate entry node\n";
                size_t v61 = 30;
                goto LABEL_58;
              }
              int v34 = v33;
              *size_t v33 = v31;
              uint64_t v35 = v107;
              if (*((void *)v107 + 4))
              {
                uint64_t v36 = v107 + 40;
                *(void *)(*((void *)v107 + 5) + 72) = v33;
              }
              else
              {
                *((void *)v107 + 4) = v33;
                uint64_t v36 = v35 + 40;
              }
              *uint64_t v36 = v33;
              int Type = BOMCopierSourceEntryGetType((uint64_t)v31);
              BOOL v44 = v107;
              BOOL v45 = (_DWORD *)*((void *)v107 + 8);
              if (v45)
              {
                *((_DWORD *)v34 + 4) = *v45;
                if (Type == 13)
                {
                  free(v45);
                  BOOL v44 = v107;
                  *((void *)v107 + 8) = 0;
LABEL_32:
                  CFArrayRef v46 = BOMStackPop(*((uint64_t **)v44 + 7));
                  *((void *)v107 + 8) = v46;
                  goto LABEL_41;
                }
                *((_DWORD *)v34 + 5) = v32;
                int v47 = (_DWORD *)v34 + 5;
                ++v32;
                if (Type != 6) {
                  goto LABEL_40;
                }
                BOMStackPush(*((char **)v44 + 7), (uint64_t)v45);
                *((void *)v107 + 8) = 0;
              }
              else
              {
                if (Type == 13) {
                  goto LABEL_32;
                }
                *((_DWORD *)v34 + 5) = v32;
                int v47 = (_DWORD *)v34 + 5;
                ++v32;
                if (Type != 6)
                {
LABEL_40:
                  switch(Type)
                  {
                    case 4:
                    case 10:
                      goto LABEL_41;
                    case 6:
                      goto LABEL_38;
                    case 8:
                      if (BOMCopierSourceEntryGetHardlinkCount(*v34) < 2) {
                        goto LABEL_39;
                      }
                      int Device = BOMCopierSourceEntryGetDevice(*v34);
                      uint64_t Inode = BOMCopierSourceEntryGetInode(*v34);
                      *((_DWORD *)v34 + 8) = Device;
                      v34[5] = Inode;
                      v104 = 0;
                      if (BOMHardLinkTableGetPathAndData(*((CFDictionaryRef **)v107 + 9), Device, Inode, *((char **)v107 + 10), &v104))
                      {
                        Path = (char *)BOMCopierSourceEntryGetPath((uint64_t)v31);
                        int v103 = 1;
                        BOMHardLinkTableSetPathAndData(*((CFDictionaryRef **)v107 + 9), Device, Inode, Path, &v103, 4uLL);
                        *((unsigned char *)v34 + 24) = 1;
                        *((_DWORD *)v34 + 7) = v103;
                        goto LABEL_39;
                      }
                      *((unsigned char *)v34 + 25) = 1;
                      size_t v54 = (char *)BOMCopierSourceEntryGetPath((uint64_t)v31);
                      int v103 = 0;
                      int v103 = *v104 + 1;
                      BOMHardLinkTableSetPathAndData(*((CFDictionaryRef **)v107 + 9), Device, Inode, v54, &v103, 4uLL);
                      *((_DWORD *)v34 + 7) = v103;
                      break;
                    default:
                      goto LABEL_39;
                  }
                  goto LABEL_41;
                }
              }
              int v48 = malloc_type_malloc(4uLL, 0x100004052888210uLL);
              *((void *)v107 + 8) = v48;
              if (!v48)
              {
                v87 = (FILE *)*MEMORY[0x263EF8348];
                unsigned __int8 v90 = __error();
                unsigned int v92 = strerror(*v90);
                v89 = "Could not create parent element: %s\n";
                goto LABEL_112;
              }
              *int v48 = *v47;
LABEL_38:
              ActualPath = (const char *)BOMCopierSourceEntryGetActualPath((uint64_t)v31);
              if (access(ActualPath, 1))
              {
                v87 = (FILE *)*MEMORY[0x263EF8348];
                size_t v88 = __error();
                unsigned int v92 = (char *)ActualPath;
                uint64_t v93 = strerror(*v88);
                v89 = "Could not access %s: %s\n";
LABEL_112:
                fprintf(v87, v89, v92, v93);
                goto LABEL_59;
              }
LABEL_39:
              dispatch_group_enter(*((dispatch_group_t *)v107 + 6));
              int v50 = *((void *)v107 + 6);
              *(void *)&blocunsigned int k = MEMORY[0x263EF8330];
              *((void *)&block + 1) = 0x40000000;
              *(void *)&long long v95 = __BOMBomNewFromDirectory_parallel_block_invoke;
              *((void *)&v95 + 1) = &unk_264132718;
              LOWORD(v98) = a3;
              *(void *)&long long v97 = a4;
              *((void *)&v97 + 1) = v34;
              *(void *)&long long v96 = __s;
              *((void *)&v96 + 1) = v31;
              dispatch_group_async(v50, v19, &block);
LABEL_41:
              v105 = 0;
              uint64_t v31 = BOMCopierSourceNext(*((void *)v107 + 3), &v105, v38, v39, v40, v41, v42, v43);
              if (!v31) {
                goto LABEL_68;
              }
            }
          }
          int v32 = 1;
LABEL_68:
          if (v105)
          {
            int v62 = (FILE *)*MEMORY[0x263EF8348];
            Message = (const char *)BOMCopierErrorGetMessage((uint64_t)v105);
            fprintf(v62, "Could not get next entry: %s\n", Message);
            BOMCopierErrorFree(v105);
            goto LABEL_59;
          }
          dispatch_group_wait(*((dispatch_group_t *)v107 + 6), 0xFFFFFFFFFFFFFFFFLL);
          uint64_t v64 = *((void *)v107 + 4);
          while (v64)
          {
            uint64_t v65 = v64;
            uint64_t v64 = *(void *)(v64 + 72);
            if (!*(void *)(v65 + 8) && *(unsigned char *)(v65 + 52) && *(void *)(v65 + 56) && *(void *)(v65 + 64))
            {
              uint64_t v66 = BOMFSObjectNewFromPathWithSys(*(char **)(v65 + 56), a3, a4);
              if (!v66)
              {
                fprintf((FILE *)*MEMORY[0x263EF8348], "Could not make second attempt to create BOMFSObject for %s\n");
                goto LABEL_59;
              }
              v67 = v66;
              BOMFSObjectSetPathName((uint64_t)v66, *(char **)(v65 + 64), 1);
              *(void *)(v65 + 8) = v67;
              v68 = *(void **)(v65 + 64);
              if (v68)
              {
                free(v68);
                *(void *)(v65 + 64) = 0;
              }
              size_t v69 = *(void **)(v65 + 56);
              if (v69)
              {
                free(v69);
                *(void *)(v65 + 56) = 0;
              }
              *(unsigned char *)(v65 + 52) = 0;
            }
          }
          uint64_t v70 = BOMBomNewWithSys(a1, 0);
          unsigned int v71 = v107;
          *((void *)v107 + 11) = v70;
          if (!v70)
          {
            int v59 = (FILE *)*MEMORY[0x263EF8348];
            int v60 = "Could not create empty bom\n";
            size_t v61 = 27;
            goto LABEL_58;
          }
          uint64_t v72 = *((void *)v71 + 4);
          if (v72)
          {
            while (1)
            {
              int v73 = (void **)v72;
              uint64_t v72 = *(void *)(v72 + 72);
              if (v73[1] || *((unsigned char *)v73 + 25))
              {
                int v74 = BOMCopierSourceEntryGetType((uint64_t)*v73);
                if (v74 != 13)
                {
                  int v75 = v74;
                  long long v76 = (char *)BOMCopierSourceEntryGetPath((uint64_t)*v73);
                  int v103 = 0;
                  if (*((unsigned char *)v73 + 25))
                  {
                    v105 = 0;
                    if (BOMHardLinkTableGetPathAndData(*((CFDictionaryRef **)v107 + 9), *((_DWORD *)v73 + 8), (uint64_t)v73[5], *((char **)v107 + 10), &v105))
                    {
                      int v59 = (FILE *)*MEMORY[0x263EF8348];
                      int v60 = "Could not get entry for hardlink node\n";
                      goto LABEL_64;
                    }
                    int v103 = *(_DWORD *)v105;
                  }
                  else
                  {
                    unsigned int v77 = BOMStorageNewBlock(*(void *)(*((void *)v107 + 11) + 8));
                    int v103 = v77;
                    if (!v77)
                    {
                      int v59 = (FILE *)*MEMORY[0x263EF8348];
                      int v60 = "Could not get storage block for fso\n";
                      size_t v61 = 36;
                      goto LABEL_58;
                    }
                    *((_DWORD *)v73 + 12) = v77;
                    if (_BOMBomSetFSObjectWithBlockID(*((void *)v107 + 11), (uint64_t)v73[1], v77))
                    {
                      fprintf((FILE *)*MEMORY[0x263EF8348], "Could not archive fso for %s\n");
                      goto LABEL_59;
                    }
                    if ((v75 & 0xFFFFFFFE) == 8) {
                      _addArchInfoForFSObject(*((void *)v107 + 11), (uint64_t)v73[1]);
                    }
                    if (*((unsigned char *)v73 + 24))
                    {
                      v105 = 0;
                      if (BOMHardLinkTableGetPathAndData(*((CFDictionaryRef **)v107 + 9), *((_DWORD *)v73 + 8), (uint64_t)v73[5], *((char **)v107 + 10), &v105))
                      {
                        int v59 = (FILE *)*MEMORY[0x263EF8348];
                        int v60 = "Could not lookup count for hardlink origin\n";
                        size_t v61 = 43;
                        goto LABEL_58;
                      }
                      BOMHardLinkTableSetPathAndData(*((CFDictionaryRef **)v107 + 9), *((_DWORD *)v73 + 8), (uint64_t)v73[5], v76, &v103, 4uLL);
                    }
                  }
                  Name = BOMCopierSourceEntryGetName(*v73);
                  v105 = 0;
                  size_t v79 = BOMNewPathKey(*((_DWORD *)v73 + 4), Name, &v105);
                  if (!v79)
                  {
                    fprintf((FILE *)*MEMORY[0x263EF8348], "Could not create path key for %u %s\n");
                    goto LABEL_59;
                  }
                  unsigned int v80 = v79;
                  v104 = 0;
                  int v81 = BOMNewPathValue(*((_DWORD *)v73 + 5), v103, &v104);
                  if (!v81)
                  {
                    fprintf((FILE *)*MEMORY[0x263EF8348], "Could not create path value for %u %u\n", *((_DWORD *)v73 + 5), v103);
                    free(v80);
                    goto LABEL_59;
                  }
                  uint64_t v82 = v81;
                  int v83 = BOMTreeSetValue(*(void **)(*((void *)v107 + 11) + 16), v80, (size_t)v105, (uint64_t)v81, (uint64_t)v104);
                  free(v80);
                  free(v82);
                  if (v83)
                  {
                    fprintf((FILE *)*MEMORY[0x263EF8348], "Could not set path info for %s\n");
                    goto LABEL_59;
                  }
                  if (*((unsigned char *)v73 + 25))
                  {
                    if (*((_DWORD *)v73 + 7) == 2)
                    {
                      size_t v84 = strlen(*((const char **)v107 + 10));
                      BOMBomHLIndexSet(*(void *)(*((void *)v107 + 11) + 24), v103, *((const void **)v107 + 10), v84 + 1);
                    }
                    size_t v85 = strlen(v76);
                    BOMBomHLIndexSet(*(void *)(*((void *)v107 + 11) + 24), v103, v76, v85 + 1);
                  }
                }
              }
              if (!v72)
              {
                uint64_t v70 = (void *)*((void *)v107 + 11);
                break;
              }
            }
          }
          *(_DWORD *)uint64_t v70 = v32;
          uint64_t v86 = (uint64_t)(v107 + 24);
          a1 = (char *)*((void *)v107 + 11);
          *((void *)v107 + 11) = 0;
          release_discovery_state(v86);
        }
        else
        {
          int v59 = (FILE *)*MEMORY[0x263EF8348];
          int v60 = "Could not create empty hardlink table\n";
LABEL_64:
          size_t v61 = 38;
LABEL_58:
          fwrite(v60, v61, 1uLL, v59);
LABEL_59:
          release_discovery_state((uint64_t)(v107 + 24));
          a1 = 0;
        }
        _Block_object_dispose(__s, 8);
        return a1;
      }
LABEL_53:
      uint64_t v14 = (FILE *)*MEMORY[0x263EF8348];
      v91 = a2;
      uint64_t v12 = "%s is not a directory\n";
      goto LABEL_54;
    }
    fwrite("bom_path is NULL\n", 0x11uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return a1;
}

char *BOMBomNewFromDirectoryWithOptions(char *a1, char *a2, uint64_t a3, char a4)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  v13.rlim_cur = 0;
  v13.int rlim_max = 0;
  if (a4)
  {
    if (getrlimit(8, &v13)) {
      return 0;
    }
    *(void *)uint64_t v14 = 0x1D00000001;
    int rlim_max = 0;
    size_t v11 = 4;
    if (sysctl(v14, 2u, &rlim_max, &v11, 0, 0)) {
      return 0;
    }
    rlim_t rlim_max_low = rlim_max;
    if (v13.rlim_max < rlim_max)
    {
      int rlim_max = v13.rlim_max;
      rlim_t rlim_max_low = SLODWORD(v13.rlim_max);
    }
    if (v13.rlim_cur >= rlim_max_low) {
      goto LABEL_16;
    }
    rlimit v10 = v13;
    if (v13.rlim_cur + 2304 < rlim_max_low) {
      rlim_t rlim_max_low = v13.rlim_cur + 2304;
    }
    v10.rlim_cur = rlim_max_low;
    if (setrlimit(8, &v10)) {
      return BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0);
    }
LABEL_16:
    uint64_t v8 = BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0);
    setrlimit(8, &v13);
    return v8;
  }
  else
  {
    return BOMBomNewFromDirectoryWithSys(a1, a2, a3, 0);
  }
}

uint64_t _visitDir(unsigned int *a1, const char *a2, char *a3, unsigned int a4, CFDictionaryRef *a5, uint64_t a6)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  *(_OWORD *)uint64_t v53 = 0u;
  size_t v50 = 0;
  unsigned int v51 = 0;
  uint64_t v49 = 0;
  uint64_t v12 = *a1;
  *a1 = v12 + 1;
  uint64_t Sys = BOMStorageGetSys(*((void *)a1 + 1));
  if ((*(unsigned int (**)(void, const char *, int *))(Sys + 80))(*(void *)(Sys + 8), ".", v53)) {
    goto LABEL_49;
  }
  uint64_t v14 = BOMFSObjectNewFromPathWithSys(".", a6, (unsigned int (**)(void, char *, long long *))Sys);
  if (!v14)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "can't read %s. skipping...\n");
    return 0;
  }
  uint64_t v15 = (uint64_t)v14;
  unsigned int v16 = BOMStorageNewBlock(*((void *)a1 + 1));
  unsigned int v52 = v16;
  if (!v16) {
    return 1;
  }
  if (_BOMBomSetFSObjectWithBlockID((uint64_t)a1, v15, v16))
  {
LABEL_5:
    fprintf((FILE *)*MEMORY[0x263EF8348], "can't archive %s. skipping...\n", a2);
    return 1;
  }
  BOMFSObjectFree(v15);
  uint64_t v18 = a3;
  do
  {
    if (v18 <= a2) {
      break;
    }
    int v19 = *--v18;
  }
  while (v19 != 47);
  if (v18 <= a2) {
    dispatch_group_t v20 = v18;
  }
  else {
    dispatch_group_t v20 = v18 + 1;
  }
  uint64_t v21 = BOMNewPathKey(a4, v20, &v50);
  int v22 = BOMNewPathValue(v12, v52, &v49);
  int v23 = BOMTreeSetValue(*((void **)a1 + 2), v21, v50, (uint64_t)v22, v49);
  free(v21);
  free(v22);
  if (v23)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "can't set path info for %s. skipping...\n");
    return 0;
  }
  uint64_t v24 = (*(uint64_t (**)(void, const char *))(Sys + 272))(*(void *)(Sys + 8), ".");
  if (!v24)
  {
LABEL_49:
    perror(a2);
    return 1;
  }
  uint64_t v25 = v24;
  *a3 = 47;
  uint64_t v26 = a3 + 1;
  uint64_t v27 = (*(uint64_t (**)(void, uint64_t))(Sys + 288))(*(void *)(Sys + 8), v24);
  if (!v27)
  {
LABEL_51:
    (*(void (**)(void, uint64_t))(Sys + 280))(*(void *)(Sys + 8), v25);
    return 0;
  }
  uint64_t v28 = v27;
  uint64_t v48 = v25;
  while (1)
  {
    if (_ignore_readdir_entry(v28)) {
      goto LABEL_39;
    }
    uint64_t v29 = (char *)(v28 + 21);
    strlcpy(v26, (const char *)(v28 + 21), a2 - v26 + 1025);
    if ((*(unsigned int (**)(void, uint64_t, int *))(Sys + 96))(*(void *)(Sys + 8), v28 + 21, v53)) {
      goto LABEL_52;
    }
    int v30 = v53[1] & 0xF000;
    if (v30 == 0x4000) {
      break;
    }
    unsigned int v51 = 0;
    BOOL v31 = v30 == 0x8000 && HIWORD(v53[1]) >= 2u;
    if (v31 && (__s[0] = 0, BOMHardLinkTableGetPathAndData(a5, v53[0], *(uint64_t *)&v53[2], __s, &v51), v51))
    {
      int v47 = 0;
      unsigned int v52 = *v51;
    }
    else
    {
      int v32 = BOMFSObjectNewFromPathWithSys((char *)(v28 + 21), a6, (unsigned int (**)(void, char *, long long *))Sys);
      if (!v32) {
        goto LABEL_39;
      }
      uint64_t v33 = (uint64_t)v32;
      unsigned int v34 = BOMStorageNewBlock(*((void *)a1 + 1));
      unsigned int v52 = v34;
      if (!v34) {
        goto LABEL_53;
      }
      if (_BOMBomSetFSObjectWithBlockID((uint64_t)a1, v33, v34)) {
        goto LABEL_5;
      }
      _addArchInfoForFSObject((uint64_t)a1, v33);
      BOMFSObjectFree(v33);
      int v47 = 1;
    }
    unsigned int v35 = (*a1)++;
    uint64_t v36 = BOMNewPathKey(v12, v29, &v50);
    int v37 = BOMNewPathValue(v35, v52, &v49);
    int v38 = BOMTreeSetValue(*((void **)a1 + 2), v36, v50, (uint64_t)v37, v49);
    free(v36);
    free(v37);
    if (v38)
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "can't set path info for %s. skipping...\n", a2);
      uint64_t v25 = v48;
    }
    else
    {
      uint64_t v25 = v48;
      if ((v53[1] & 0xF000) != 0x8000 || HIWORD(v53[1]) < 2u) {
        goto LABEL_39;
      }
      if (v47)
      {
        int v39 = v53[0];
        uint64_t v40 = *(void *)&v53[2];
        uint64_t v41 = a5;
        uint64_t v42 = (char *)a2;
      }
      else
      {
        uint64_t v43 = *((void *)a1 + 3);
        if (!__s[0])
        {
          size_t v46 = strlen(a2);
          BOMBomHLIndexSet(v43, v52, a2, v46 + 1);
          goto LABEL_39;
        }
        size_t v44 = strlen(__s);
        BOMBomHLIndexSet(v43, v52, __s, v44 + 1);
        size_t v45 = strlen(a2) + 1;
        uint64_t v25 = v48;
        BOMBomHLIndexSet(*((void *)a1 + 3), v52, a2, v45);
        int v39 = v53[0];
        uint64_t v40 = *(void *)&v53[2];
        uint64_t v41 = a5;
        uint64_t v42 = "";
      }
      BOMHardLinkTableSetPathAndData(v41, v39, v40, v42, &v52, 4uLL);
    }
LABEL_39:
    uint64_t v28 = (*(uint64_t (**)(void, uint64_t))(Sys + 288))(*(void *)(Sys + 8), v25);
    if (!v28) {
      goto LABEL_51;
    }
  }
  if (!(*(unsigned int (**)(void, uint64_t))(Sys + 312))(*(void *)(Sys + 8), v28 + 21))
  {
    if (_visitDir(a1, a2, &v26[*(unsigned __int16 *)(v28 + 18)], v12, a5, a6)) {
      goto LABEL_53;
    }
    if (!(*(unsigned int (**)(void, const char *))(Sys + 312))(*(void *)(Sys + 8), "..")) {
      goto LABEL_39;
    }
  }
LABEL_52:
  perror(a2);
LABEL_53:
  (*(void (**)(void, uint64_t))(Sys + 280))(*(void *)(Sys + 8), v25);
  return 1;
}

uint64_t BOMBomCommit(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 65)) {
    return 0;
  }
  unsigned int NamedBlock = BOMStorageGetNamedBlock(*(void *)(a1 + 8), "BomInfo");
  if (!NamedBlock) {
    return 1;
  }
  uint64_t v3 = 1;
  uint64_t v4 = BOMStreamWithBlockID(*(void *)(a1 + 8), NamedBlock, (16 * *(unsigned int *)(a1 + 48)) | 0xC, 1);
  if (v4)
  {
    uint64_t v5 = v4;
    BOMStreamWriteUInt32(v4, 1u);
    BOMStreamWriteUInt32(v5, *(_DWORD *)a1);
    _writeArchInfo(a1, v5);
    if (!BOMStreamFree(v5))
    {
      uint64_t v6 = *(void *)(a1 + 16);
      if (v6) {
        BOMTreeCommit(v6);
      }
      uint64_t v7 = *(void *)(a1 + 24);
      if (v7) {
        BOMBomHLIndexCommit(v7);
      }
      uint64_t v8 = *(void *)(a1 + 32);
      if (v8) {
        BOMBomVIndexCommit(v8);
      }
      uint64_t v9 = *(void *)(a1 + 40);
      if (v9) {
        BOMTreeCommit(v9);
      }
      if (!BOMStorageCommit(*(void *)(a1 + 8)))
      {
        uint64_t v3 = 0;
        *(unsigned char *)(a1 + 64) = 0;
      }
    }
  }
  return v3;
}

void *BOMBomPathIDForKey(uint64_t a1, unsigned int a2, char *a3)
{
  return BOMBomPathIDAndArchsForKey(a1, a2, a3, 0);
}

void *BOMBomPathIDAndArchsForKey(uint64_t a1, unsigned int a2, char *__s, uint64_t a4)
{
  uint64_t v4 = 0;
  if (a1)
  {
    if (__s)
    {
      size_t v15 = 0;
      uint64_t v4 = BOMNewPathKey(a2, __s, &v15);
      if (v4)
      {
        Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v4, v15);
        free(v4);
        if (!Value) {
          return 0;
        }
        uint64_t v4 = BOMPathIDFromPathKey(Value);
        if (!a4) {
          return v4;
        }
        unsigned int v8 = BOMBlockIDFromPathValue((uint64_t)Value);
        FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v8);
        if (!FSObjectWithBlockID) {
          return 0;
        }
        uint64_t v10 = (uint64_t)FSObjectWithBlockID;
        if (BOMFSObjectType(FSObjectWithBlockID) == 1)
        {
          unsigned int v11 = BOMFSObjectArchCount(v10);
          if (v11)
          {
            uint64_t v12 = 0;
            uint64_t v13 = v11;
            do
            {
              *(_DWORD *)(a4 + 4 * v12) = BOMFSObjectGetArch(v10, v12);
              ++v12;
            }
            while (v13 != v12);
          }
          else
          {
            uint64_t v13 = 0;
          }
          *(_DWORD *)(a4 + 4 * v13) = 0;
        }
        BOMFSObjectFree(v10);
      }
    }
  }
  return v4;
}

uint64_t BOMBomFSObjectCount(uint64_t result)
{
  if (result) {
    return BOMTreeCount(*(void *)(result + 16));
  }
  return result;
}

char *BOMBomGetRootFSObject(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  size_t v14 = 0;
  int v2 = BOMNewPathKey(0, ".", &v14);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  unint64_t Value = BOMTreeGetValue(*(void *)(a1 + 16), v2, v14);
  unint64_t v5 = Value;
  if (Value)
  {
    uint64_t v6 = (unsigned int *)Value;
  }
  else
  {
    uint64_t v12 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), v3, v14, 0);
    free(v3);
    if (!v12) {
      return v12;
    }
    uint64_t v3 = (void *)BOMTreeIteratorKey((uint64_t)v12);
    size_t v14 = BOMTreeIteratorKeySize((uint64_t)v12);
    uint64_t v6 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v12);
    BOMTreeIteratorFree(v12);
    uint64_t v12 = 0;
    if (!v3 || !v14 || !v6) {
      return v12;
    }
  }
  unsigned int v7 = BOMBlockIDFromPathValue((uint64_t)v6);
  int v8 = BOMPathIDFromPathKey(v6);
  int v9 = BOMPathIDFromPathKey((unsigned int *)v3);
  uint64_t v10 = (char *)BOMShortNameFromPathKey((uint64_t)v3);
  FSObjectWithBlockID = (char *)_BOMBomGetFSObjectWithBlockID(a1, v7);
  uint64_t v12 = FSObjectWithBlockID;
  if (FSObjectWithBlockID)
  {
    BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, v10, 1);
    BOMFSObjectSetShortName((uint64_t)v12, v10, 1);
    BOMFSObjectSetPathID((uint64_t)v12, v8);
    BOMFSObjectSetParentPathID((uint64_t)v12, v9);
    BOMFSObjectSetBlockID((uint64_t)v12, v7);
  }
  if (v5) {
    free(v3);
  }
  return v12;
}

uint64_t BOMBomGetFSObjectAtPath(uint64_t a1, char *__s)
{
  uint64_t v2 = 0;
  size_t v18 = 0;
  if (a1 && __s)
  {
    size_t v5 = strlen(__s) + 1;
    uint64_t v6 = (char *)BOM_malloc(v5);
    __stringp = v6;
    if (v6)
    {
      unsigned int v7 = v6;
      memmove(v6, __s, v5);
      int v8 = strsep(&__stringp, "/");
      if (v8)
      {
        unsigned int v9 = 0;
        while (1)
        {
          int v10 = v9;
          unsigned int v11 = v8;
          uint64_t v12 = BOMNewPathKey(v9, v8, &v18);
          if (!v12) {
            break;
          }
          uint64_t v13 = v12;
          unint64_t Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v12, v18);
          free(v13);
          if (!Value) {
            break;
          }
          unsigned int v9 = BOMPathIDFromPathKey(Value);
          int v8 = strsep(&__stringp, "/");
          if (!v8)
          {
            unsigned int v15 = BOMBlockIDFromPathValue((uint64_t)Value);
            FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v15);
            uint64_t v2 = (uint64_t)FSObjectWithBlockID;
            if (FSObjectWithBlockID)
            {
              BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, __s, 1);
              BOMFSObjectSetShortName(v2, v11, 1);
              BOMFSObjectSetPathID(v2, v9);
              BOMFSObjectSetParentPathID(v2, v10);
              BOMFSObjectSetBlockID(v2, v15);
            }
            goto LABEL_12;
          }
        }
      }
      uint64_t v2 = 0;
LABEL_12:
      free(v7);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t BOMBomInsertFSObject(unint64_t a1, unsigned int *a2, int a3)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v28 = 0;
  size_t v29 = 0;
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    unsigned int v7 = (const char *)BOMFSObjectPathName((uint64_t)a2);
    __strlcpy_chk();
    int v8 = strrchr(__s, 47);
    if (v8)
    {
      *int v8 = 0;
      unsigned int v9 = _valueAtPath(a1);
      if (!v9)
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], "parent directory %s does not exist\n", __s);
        return 401;
      }
      unsigned int v10 = BOMPathIDFromPathKey(v9);
    }
    else
    {
      unsigned int v10 = 0;
    }
    unsigned int v11 = (char *)BOMFSObjectShortName((uint64_t)a2);
    uint64_t v12 = _valueAtPath(a1);
    if (v12)
    {
      if (!a3) {
        return 0;
      }
      uint64_t v13 = (uint64_t)v12;
      unsigned int v14 = BOMPathIDFromPathKey(v12);
      unsigned int v15 = BOMBlockIDFromPathValue(v13);
      if (BOMStorageCopyFromBlockRange(*(void *)(a1 + 8), v15, 0, 1uLL, &__dst))
      {
        uint64_t v25 = BOMExceptionHandlerMessage("BOMBomInsertFSObject failed while getting data for '%s' (parentPathID=%u pathID=%u bid=%u)", v11, v10, v14, v15);
        uint64_t v26 = __error();
        _BOMFatalException((uint64_t)v25, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3022, *v26);
      }
      unsigned int v16 = BOMFSObjectTypeFromRawData(&__dst);
      int v17 = BOMFSObjectType(a2);
      if (v17 == 2 && v16 != 2) {
        return 402;
      }
      if (v17 != 2 && v16 == 2) {
        return 403;
      }
      FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v15);
      if (FSObjectWithBlockID)
      {
        uint64_t v23 = (uint64_t)FSObjectWithBlockID;
        _removeArchInfoForFSObject(a1, (uint64_t)FSObjectWithBlockID);
        BOMFSObjectFree(v23);
      }
      if (!BOMBomHLIndexCount(*(void *)(a1 + 24), v15)
        || (size_t v24 = strlen(v7),
            BOMBomHLIndexRemove(*(void *)(a1 + 24), v15, v7, v24 + 1),
            !BOMBomHLIndexCount(*(void *)(a1 + 24), v15)))
      {
        int v18 = 0;
        goto LABEL_15;
      }
    }
    else
    {
      unsigned int v14 = (*(_DWORD *)a1)++;
    }
    unsigned int v15 = BOMStorageNewBlock(*(void *)(a1 + 8));
    int v18 = 1;
LABEL_15:
    if (_BOMBomSetFSObjectWithBlockID(a1, (uint64_t)a2, v15))
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "can't archive %s\n", v7);
      return 404;
    }
    _addArchInfoForFSObject(a1, (uint64_t)a2);
    if (v18)
    {
      int v19 = BOMNewPathKey(v10, v11, &v29);
      dispatch_group_t v20 = BOMNewPathValue(v14, v15, &v28);
      int v21 = BOMTreeSetValue(*(void **)(a1 + 16), v19, v29, (uint64_t)v20, v28);
      free(v19);
      free(v20);
      if (v21)
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], "can't set path info for %s.\n", v7);
        return 405;
      }
    }
    *(unsigned char *)(a1 + 64) = 1;
    BOMBomVIndexInvalidateDiskSpace(*(void *)(a1 + 32));
    return 0;
  }
  return result;
}

unint64_t _removeArchInfoForFSObject(unint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 48))
  {
    unint64_t v2 = result;
    if (*(void *)(result + 56))
    {
      if (BOMFSObjectIsBinaryObject(a2))
      {
        uint64_t result = BOMFSObjectArchCount(a2);
        if (result)
        {
          int v4 = result;
          for (unsigned int i = 0; i != v4; ++i)
          {
            int Arch = BOMFSObjectGetArch(a2, i);
            uint64_t result = BOMFSObjectGetArchSize(a2, i);
            uint64_t v7 = *(unsigned int *)(v2 + 48);
            if (v7 >= 2)
            {
              int v8 = (void *)(*(void *)(v2 + 56) + 32);
              uint64_t v9 = v7 - 1;
              while (*((_DWORD *)v8 - 2) != Arch)
              {
                v8 += 3;
                if (!--v9) {
                  goto LABEL_14;
                }
              }
              uint64_t v10 = *v8 - result;
              if (*v8 < (unint64_t)result) {
                uint64_t v10 = 0;
              }
              *int v8 = v10;
            }
LABEL_14:
            ;
          }
        }
      }
      else
      {
        uint64_t result = BOMFSObjectSize(a2);
        uint64_t v11 = *(void *)(v2 + 56);
        unint64_t v12 = *(void *)(v11 + 8);
        BOOL v13 = v12 >= result;
        unint64_t v14 = v12 - result;
        if (!v13) {
          unint64_t v14 = 0;
        }
        *(void *)(v11 + 8) = v14;
      }
    }
  }
  return result;
}

uint64_t _BOMBomSetFSObjectWithBlockID(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    uint64_t v7 = BOMStorageSizeOfBlock(*(void *)(a1 + 8), a3);
    int64_t v8 = BOMFSObjectArchiveLength(a2);
    if (v8 < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v9 = BOMStreamWithBlockID(*(void *)(a1 + 8), a3, v8, 1);
      uint64_t v10 = v9;
      if (v9 && !BOMFSObjectArchive(v9, a2)) {
        uint64_t v3 = 0;
      }
      BOMStreamFree(v10);
      if (*(void *)(a1 + 40))
      {
        unsigned int v14 = bswap32(a3);
        int64_t v11 = BOMFSObjectSize(a2);
        if (v11 < 0x100000000)
        {
          if (v7) {
            BOMTreeRemoveValue(*(void *)(a1 + 40), &v14, 4uLL);
          }
        }
        else
        {
          unint64_t v13 = bswap64(v11);
          BOMTreeSetValue(*(void **)(a1 + 40), &v14, 4uLL, (uint64_t)&v13, 8);
        }
      }
    }
  }
  return v3;
}

uint64_t _addArchInfoForFSObject(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a1 + 48) || !*(void *)(a1 + 56))
  {
    *(_DWORD *)(a1 + 48) = 1;
    uint64_t result = (uint64_t)BOM_malloczero(0x18uLL);
    *(void *)(a1 + 56) = result;
    if (!result) {
      return result;
    }
    *(_DWORD *)uint64_t result = 0;
  }
  if (BOMFSObjectIsBinaryObject(a2))
  {
    uint64_t result = BOMFSObjectArchCount(a2);
    if (result)
    {
      int v5 = result;
      for (unsigned int i = 0; i != v5; ++i)
      {
        int Arch = BOMFSObjectGetArch(a2, i);
        unsigned int ArchSize = BOMFSObjectGetArchSize(a2, i);
        uint64_t v9 = *(unsigned int *)(a1 + 48);
        uint64_t result = *(void *)(a1 + 56);
        if (v9 < 2)
        {
LABEL_12:
          uint64_t result = (uint64_t)BOM_realloczero((void *)result, 24 * v9, 24 * (v9 + 1));
          *(void *)(a1 + 56) = result;
          if (!result) {
            return result;
          }
          unsigned int v12 = *(_DWORD *)(a1 + 48);
          *(_DWORD *)(a1 + 48) = v12 + 1;
          unint64_t v13 = (_DWORD *)(result + 24 * v12);
          *unint64_t v13 = Arch;
          uint64_t v10 = v13 + 2;
        }
        else
        {
          uint64_t v10 = (void *)(result + 32);
          uint64_t v11 = v9 - 1;
          while (*((_DWORD *)v10 - 2) != Arch)
          {
            v10 += 3;
            if (!--v11) {
              goto LABEL_12;
            }
          }
        }
        *v10 += ArchSize;
      }
    }
  }
  else
  {
    uint64_t result = BOMFSObjectSize(a2);
    *(void *)(*(void *)(a1 + 56) + 8) += result;
  }
  return result;
}

uint64_t BOMBomRemoveFSObject(unint64_t a1, unsigned int *a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    size_t v16 = 0;
    int v4 = BOMBomEnumeratorNewWithOptions(a1, a2, 2);
    int v5 = BOMBomEnumeratorNext((uint64_t)v4);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = 1;
      while (1)
      {
        unsigned int v8 = BOMFSObjectBlockID((uint64_t)v6);
        if (!v8)
        {
          unsigned int v8 = _BOMBlockIDForFSObject(a1, (uint64_t)v6);
          if (!v8) {
            break;
          }
        }
        if (BOMFSObjectGetHardlinkCount(a1, (uint64_t)v6))
        {
          uint64_t v9 = (const char *)BOMFSObjectPathName((uint64_t)v6);
          size_t v10 = strlen(v9);
          BOMBomHLIndexRemove(*(void *)(a1 + 24), v8, v9, v10 + 1);
        }
        unsigned int v11 = BOMFSObjectParentPathID((uint64_t)v6);
        unsigned int v12 = (char *)BOMFSObjectShortName((uint64_t)v6);
        unint64_t v13 = BOMNewPathKey(v11, v12, &v16);
        if (!v13) {
          break;
        }
        unsigned int v14 = v13;
        if (BOMTreeRemoveValue(*(void *)(a1 + 16), v13, v16))
        {
          free(v14);
          break;
        }
        if (!BOMBomHLIndexCount(*(void *)(a1 + 24), v8)) {
          BOMStorageFreeBlock(*(void *)(a1 + 8), v8);
        }
        _removeArchInfoForFSObject(a1, (uint64_t)v6);
        *(unsigned char *)(a1 + 64) = 1;
        BOMBomVIndexInvalidateDiskSpace(*(void *)(a1 + 32));
        BOMFSObjectFree((uint64_t)v6);
        free(v14);
        uint64_t v6 = BOMBomEnumeratorNext((uint64_t)v4);
        uint64_t v7 = 0;
        uint64_t v2 = 0;
        if (!v6) {
          goto LABEL_18;
        }
      }
      uint64_t v2 = v7;
    }
    else
    {
      uint64_t v2 = 1;
    }
LABEL_18:
    BOMBomEnumeratorFree(v4);
  }
  return v2;
}

unsigned int *_BOMBlockIDForFSObject(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const char *)BOMFSObjectPathName(a2);
  if (!v3) {
    return 0;
  }
  int v4 = v3;
  size_t v5 = strlen(v3) + 1;
  uint64_t v6 = (char *)BOM_malloc(v5);
  __stringp = v6;
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  size_t v15 = 0;
  memmove(v6, v4, v5);
  unsigned int v8 = strsep(&__stringp, "/");
  if (v8)
  {
    uint64_t v9 = v8;
    unsigned int v10 = 0;
    while (1)
    {
      unsigned int v11 = BOMNewPathKey(v10, v9, &v15);
      if (!v11) {
        break;
      }
      unsigned int v12 = v11;
      unint64_t Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v11, v15);
      free(v12);
      if (Value)
      {
        unsigned int v10 = BOMPathIDFromPathKey(Value);
        unint64_t Value = (unsigned int *)BOMBlockIDFromPathValue((uint64_t)Value);
        uint64_t v9 = strsep(&__stringp, "/");
        if (v9) {
          continue;
        }
      }
      goto LABEL_11;
    }
  }
  unint64_t Value = 0;
LABEL_11:
  free(v7);
  return Value;
}

BOOL BOMFSObjectIsHardlink(uint64_t a1, uint64_t a2)
{
  return BOMFSObjectGetHardlinkCount(a1, a2) != 0;
}

uint64_t BOMBomMergeInto(uint64_t *a1, uint64_t a2)
{
  return BOMBomMergeIntoBomWithPatternList(a1, a2, 0);
}

uint64_t BOMBomMergeIntoBomWithPatternList(uint64_t *a1, uint64_t a2, const __CFArray *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  __s[0] = 0;
  uint64_t v3 = 1;
  if (a1 && a2)
  {
    if (a1 == (uint64_t *)a2)
    {
      uint64_t v3 = 1;
      fwrite("boms are identical.\n", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
    else
    {
      size_t v7 = strlen(__s);
      _copyFilesFromBomToBom(a1, (unsigned int *)a2, a3, __s, &__s[v7], 0, 0, 0, 1);
      _copyVariantsFromBomToBom((uint64_t)a1, a2, v8, v9, v10, v11, v12, v13);
      BOMBomVIndexInvalidateDiskSpace(*(void *)(a2 + 32));
      return 0;
    }
  }
  return v3;
}

uint64_t BOMBomMergeIntoBom(uint64_t *a1, uint64_t a2)
{
  return BOMBomMergeIntoBomWithPatternList(a1, a2, 0);
}

uint64_t BOMBomMaskWithBom(unint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  uint64_t result = 1;
  if (a1)
  {
    if (a2)
    {
      v5[0] = 0;
      v4[0] = 0;
      _maskWithBom(a1, v5, v5, 0, a2, v4, v4, 0);
      BOMBomVIndexInvalidateDiskSpace(*(void *)(a1 + 32));
      return 0;
    }
  }
  return result;
}

BOOL _maskWithBom(unint64_t a1, char *a2, char *a3, unsigned int a4, uint64_t a5, char *a6, char *a7, unsigned int a8)
{
  size_t v54 = 0;
  uint64_t v16 = BOMNewPathKey(a4, "", &v54);
  if (v16)
  {
    int v17 = v16;
    int v18 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), v16, v54, 0);
    free(v17);
    if (v18)
    {
      int v19 = BOMNewPathKey(a8, "", &v54);
      if (!v19
        || (dispatch_group_t v20 = v19, v50 = a5, v21 = (char *)BOMTreeIteratorNew(*(void *)(a5 + 16), v19, v54, 0), free(v20), !v21))
      {
        BOOL v25 = 0;
        int v21 = v18;
LABEL_39:
        BOMTreeIteratorFree(v21);
        return v25;
      }
      int v22 = a2;
      if (a2 != a3)
      {
        *a3 = 47;
        int v22 = a3 + 1;
      }
      unsigned __int8 __dst = v22;
      uint64_t v23 = a6;
      if (a6 != a7)
      {
        *a7 = 47;
        uint64_t v23 = a7 + 1;
      }
      if (BOMTreeIteratorIsAtEnd((uint64_t)v18))
      {
        int v24 = 0;
LABEL_38:
        BOOL v25 = v24 == 0;
        BOMTreeIteratorFree(v18);
        goto LABEL_39;
      }
      uint64_t v26 = v23;
      int v24 = 0;
      int v47 = 0;
      uint64_t v27 = a6;
      uint64_t v28 = 0;
      size_t v46 = v26;
      __s2 = v27;
      uint64_t v45 = v27 - v26 + 1025;
      while (2)
      {
        if (BOMTreeIteratorIsAtEnd((uint64_t)v21)
          || (size_t v29 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v18), BOMPathIDFromPathKey(v29) != a4))
        {
LABEL_36:
          if (v47) {
            *(unsigned char *)(a1 + 64) = 1;
          }
          goto LABEL_38;
        }
        int v52 = v24;
        int v30 = (const char *)BOMShortNameFromPathKey((uint64_t)v29);
        size_t v31 = strlen(v30);
        int v32 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v18);
        uint64_t v48 = BOMPathIDFromPathKey(v32);
        unsigned int v33 = BOMBlockIDFromPathValue((uint64_t)v32);
        if (BOMStorageCopyFromBlockRange(*(void *)(a1 + 8), v33, 0, 1uLL, &v53))
        {
          uint64_t v42 = BOMExceptionHandlerMessage("_maskWithBom failed while getting data for '%s' (parentPathID=%u pathID=%u bid=%u)", v30, a4, v48, v33);
          uint64_t v43 = __error();
          _BOMFatalException((uint64_t)v42, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3363, *v43);
        }
        unsigned int v51 = BOMFSObjectTypeFromRawData(&v53);
        while (1)
        {
          if (BOMTreeIteratorIsAtEnd((uint64_t)v21))
          {
            unsigned int v35 = 0;
            goto LABEL_23;
          }
          unsigned int v34 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v21);
          if (BOMPathIDFromPathKey(v34) != a8) {
            goto LABEL_35;
          }
          uint64_t v28 = (const char *)BOMShortNameFromPathKey((uint64_t)v34);
          if ((strcmp(v28, v30) & 0x80000000) == 0) {
            break;
          }
          BOMTreeIteratorNext((uint64_t)v21);
        }
        int v37 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v21);
        unsigned int v35 = BOMPathIDFromPathKey(v37);
LABEL_23:
        if (BOMTreeIteratorIsAtEnd((uint64_t)v21))
        {
LABEL_35:
          int v24 = v52 + 1;
          goto LABEL_36;
        }
        if (!v28 || strcmp(v28, v30)) {
          goto LABEL_26;
        }
        strlcpy(__dst, v30, a2 - __dst + 1025);
        strlcpy(v46, v28, v45);
        if (v51 == 2)
        {
          int v36 = _maskWithBom(a1, a2, &__dst[v31], v48, v50, __s2, &v46[v31], v35);
          __dst[v31] = 0;
          if (!v36) {
            goto LABEL_26;
          }
        }
        else if (strcmp(a2, __s2))
        {
LABEL_26:
          int v24 = v52 + 1;
          goto LABEL_27;
        }
        int v38 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v18);
        int v39 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v18);
        uint64_t v40 = (unsigned int *)_BOMGetFSObject(a1, v38, v39, a2);
        BOMBomRemoveFSObject(a1, v40);
        BOMFSObjectFree((uint64_t)v40);
        int v47 = 1;
        int v24 = v52;
LABEL_27:
        BOMTreeIteratorNext((uint64_t)v18);
        if (!BOMTreeIteratorIsAtEnd((uint64_t)v18)) {
          continue;
        }
        goto LABEL_36;
      }
    }
  }
  return 0;
}

CFIndex BOMBomMaskWithPatternList(unint64_t a1, CFArrayRef theArray)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  CFIndex result = 1;
  if (a1 && theArray)
  {
    CFIndex result = CFArrayGetCount(theArray);
    if (result)
    {
      v5[0] = 0;
      _maskWithPatternList(a1, theArray, v5, v5, 0);
      BOMBomVIndexInvalidateDiskSpace(*(void *)(a1 + 32));
      return 0;
    }
  }
  return result;
}

char *_maskWithPatternList(unint64_t a1, const __CFArray *a2, char *a3, char *a4, unsigned int a5)
{
  size_t v35 = 0;
  CFIndex result = BOMNewPathKey(a5, "", &v35);
  if (!result) {
    return result;
  }
  uint64_t v10 = result;
  uint64_t v11 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), result, v35, 0);
  free(v10);
  if (!v11) {
    return 0;
  }
  unsigned __int8 __dst = a3;
  if (a3 != a4)
  {
    *a4 = 47;
    unsigned __int8 __dst = a4 + 1;
  }
  if (BOMTreeIteratorIsAtEnd((uint64_t)v11))
  {
    BOMTreeIteratorFree(v11);
    int v12 = 0;
    unsigned int v13 = 0;
    goto LABEL_23;
  }
  int v12 = 0;
  int v31 = 0;
  do
  {
    unsigned int v14 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v11);
    if (BOMPathIDFromPathKey(v14) != a5) {
      break;
    }
    size_t v15 = (const char *)BOMShortNameFromPathKey((uint64_t)v14);
    uint64_t v16 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v11);
    int v17 = BOMPathIDFromPathKey(v16);
    unsigned int v18 = BOMBlockIDFromPathValue((uint64_t)v16);
    if (BOMStorageCopyFromBlockRange(*(void *)(a1 + 8), v18, 0, 1uLL, &v34))
    {
      size_t v29 = BOMExceptionHandlerMessage("_maskWithPatternList failed while getting data for '%s' (parentPathID=%u pathID=%u bid=%u)", v15, a5, v17, v18);
      int v30 = __error();
      _BOMFatalException((uint64_t)v29, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3252, *v30);
    }
    unsigned int v19 = BOMFSObjectTypeFromRawData(&v34);
    strlcpy(__dst, v15, a3 - __dst + 1025);
    size_t v20 = strlen(v15);
    CFIndex Count = CFArrayGetCount(a2);
    if (Count < 1)
    {
LABEL_16:
      if (v19 != 2 || !_maskWithPatternList(a1, a2, a3, &__dst[v20], v17))
      {
        int v28 = 1;
        goto LABEL_20;
      }
    }
    else
    {
      CFIndex v22 = Count;
      CFIndex v23 = 0;
      while (1)
      {
        ValueAtIndex = (regex_t *)CFArrayGetValueAtIndex(a2, v23);
        if (ValueAtIndex)
        {
          if (BOMPatternMatch(ValueAtIndex, a3)) {
            break;
          }
        }
        if (v22 == ++v23) {
          goto LABEL_16;
        }
      }
    }
    BOOL v25 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v11);
    uint64_t v26 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v11);
    uint64_t v27 = (unsigned int *)_BOMGetFSObject(a1, v25, v26, a3);
    BOMBomRemoveFSObject(a1, v27);
    BOMFSObjectFree((uint64_t)v27);
    int v28 = 0;
    int v31 = 1;
LABEL_20:
    v12 += v28;
    BOMTreeIteratorNext((uint64_t)v11);
  }
  while (!BOMTreeIteratorIsAtEnd((uint64_t)v11));
  BOMTreeIteratorFree(v11);
  unsigned int v13 = v31;
  if (v31)
  {
    unsigned int v13 = 1;
    *(unsigned char *)(a1 + 64) = 1;
  }
LABEL_23:
  if (v12) {
    return 0;
  }
  else {
    return (char *)v13;
  }
}

CFDictionaryRef *BOMBomApproximateBytesRepresentedWithBlockSize(CFDictionaryRef *a1, unsigned int a2)
{
  return BOMBomApproximateBytesRepresentedWithBlockSize64(a1, a2);
}

CFDictionaryRef *BOMBomApproximateBytesRepresentedWithBlockSize64(CFDictionaryRef *result, unsigned int a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v5 = 0;
  if (result)
  {
    uint64_t v3 = (uint64_t)result;
    CFIndex result = (CFDictionaryRef *)BOMHardLinkTableNew();
    if (result)
    {
      int v4 = (const void **)result;
      v6[0] = 0;
      _sizeBom(v3, result, v6, v6, 0, a2, &v5);
      BOMHardLinkTableFree(v4);
      return (CFDictionaryRef *)v5;
    }
  }
  return result;
}

void _sizeBom(uint64_t a1, CFDictionaryRef *a2, char *a3, char *a4, unsigned int a5, unsigned int a6, void *a7)
{
  size_t v31 = 0;
  *(_DWORD *)bytes = 0;
  unsigned int v14 = BOMNewPathKey(a5, "", &v31);
  if (v14)
  {
    size_t v15 = v14;
    uint64_t v16 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), v14, v31, 0);
    free(v15);
    if (v16)
    {
      unsigned int v27 = a6;
      int v28 = a7;
      unsigned __int8 __dst = a3;
      if (a3 != a4)
      {
        *a4 = 47;
        unsigned __int8 __dst = a4 + 1;
      }
      while (!BOMTreeIteratorIsAtEnd((uint64_t)v16))
      {
        int v17 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v16);
        if (BOMPathIDFromPathKey(v17) != a5) {
          break;
        }
        unsigned int v18 = (const char *)BOMShortNameFromPathKey((uint64_t)v17);
        size_t v19 = strlen(v18);
        size_t v20 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v16);
        int v21 = BOMPathIDFromPathKey(v20);
        *(_DWORD *)bytes = BOMBlockIDFromPathValue((uint64_t)v20);
        if (!BOMHardLinkTableGet(a2, 0, *(unsigned int *)bytes))
        {
          BOMHardLinkTableSet(a2, 0, *(unsigned int *)bytes, bytes, 4);
          FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, *(unsigned int *)bytes);
          int v23 = BOMFSObjectType(FSObjectWithBlockID);
          if (v23 != 4)
          {
            int v24 = v23;
            strlcpy(__dst, v18, a3 - __dst + 1025);
            if (v24 == 2) {
              _sizeBom(a1, a2, a3, &__dst[v19], v21, v27, v28);
            }
            uint64_t v25 = BOMFSObjectSize((uint64_t)FSObjectWithBlockID);
            if (v25 % v27) {
              uint64_t v26 = v27 - v25 % v27;
            }
            else {
              uint64_t v26 = 0;
            }
            *v28 += v25 + v26;
            BOMFSObjectFree((uint64_t)FSObjectWithBlockID);
          }
        }
        BOMTreeIteratorNext((uint64_t)v16);
      }
      BOMTreeIteratorFree(v16);
    }
  }
}

CFDictionaryRef *BOMBomApproximateBytesRepresented(CFDictionaryRef *a1)
{
  return BOMBomApproximateBytesRepresentedWithBlockSize64(a1, 0x200u);
}

CFDictionaryRef *BOMBomApproximateBytesRepresented64(CFDictionaryRef *a1)
{
  return BOMBomApproximateBytesRepresentedWithBlockSize64(a1, 0x200u);
}

uint64_t BOMFSObjectGetHardlinkCount(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  if (!a2) {
    return 0;
  }
  unsigned int v4 = BOMFSObjectBlockID(a2);
  if (!v4)
  {
    unsigned int v4 = _BOMBlockIDForFSObject(a1, a2);
    if (!v4) {
      return 0;
    }
  }
  uint64_t v5 = *(void *)(a1 + 24);
  return BOMBomHLIndexCount(v5, v4);
}

uint64_t BOMFSObjectGetHardlinkPath(uint64_t a1, uint64_t a2, unsigned int a3, char *a4)
{
  uint64_t result = 0;
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a1 && a4)
  {
    uint64_t v7 = *(void *)(a1 + 24);
    if (v7)
    {
      uint64_t result = BOMFSObjectBlockID(a2);
      if (!result) {
        return result;
      }
      unsigned int v9 = result;
      if (BOMBomHLIndexCount(v7, result) > a3)
      {
        size_t v10 = 0;
        if (!BOMBomHLIndexGet(v7, v9, a3, __source, &v10))
        {
          strlcpy(a4, __source, 0x400uLL);
          return 1;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t BOMBomLinkToPathFromPath(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(a1, a2);
  return BOMBomLinkToFSObjectFromPath(a1, FSObjectAtPath, a3);
}

uint64_t BOMBomLinkToFSObjectFromPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v3 = 1;
  if (!a2 || !a1 || !a3) {
    return v3;
  }
  uint64_t v5 = (unsigned int *)a2;
  uint64_t v24 = 0;
  size_t v25 = 0;
  unsigned int v6 = BOMFSObjectBlockID(a2);
  unsigned int v7 = v6;
  if (v6)
  {
    unsigned int v8 = v6;
LABEL_6:
    if (BOMFSObjectType(v5) != 1 || _valueAtPath(a1))
    {
      uint64_t FSObjectAtPath = 0;
      goto LABEL_9;
    }
    __strlcpy_chk();
    unsigned int v13 = strrchr(__s, 47);
    unsigned int v14 = v13;
    if (v13)
    {
      *unsigned int v13 = 0;
      uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(a1, __s);
      *v14++ = 47;
      if (!FSObjectAtPath)
      {
LABEL_9:
        uint64_t v3 = 1;
        if (v7) {
          goto LABEL_10;
        }
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(a1, __s);
      if (!FSObjectAtPath) {
        goto LABEL_9;
      }
    }
    unsigned int v16 = BOMFSObjectPathID(FSObjectAtPath);
    unsigned int v17 = (*(_DWORD *)a1)++;
    unsigned int v18 = BOMNewPathKey(v16, v14, &v25);
    size_t v19 = BOMNewPathValue(v17, v8, &v24);
    int v20 = BOMTreeSetValue(*(void **)(a1 + 16), v18, v25, (uint64_t)v19, v24);
    free(v18);
    free(v19);
    if (!v20)
    {
      size_t v21 = strlen(__s);
      BOMBomHLIndexSet(*(void *)(a1 + 24), v8, __s, v21 + 1);
      CFIndex v22 = (const char *)BOMFSObjectPathName((uint64_t)v5);
      size_t v23 = strlen(v22);
      BOMBomHLIndexSet(*(void *)(a1 + 24), v8, v22, v23 + 1);
      uint64_t v3 = 0;
      if (v7)
      {
LABEL_10:
        if (!FSObjectAtPath) {
          return v3;
        }
        goto LABEL_20;
      }
      goto LABEL_19;
    }
    goto LABEL_9;
  }
  size_t v10 = (char *)BOMFSObjectPathName((uint64_t)v5);
  uint64_t v11 = BOMBomGetFSObjectAtPath(a1, v10);
  if (!v11) {
    return v3;
  }
  uint64_t v5 = (unsigned int *)v11;
  unsigned int v12 = BOMFSObjectBlockID(v11);
  if (v12)
  {
    unsigned int v8 = v12;
    goto LABEL_6;
  }
  uint64_t FSObjectAtPath = 0;
LABEL_19:
  BOMFSObjectFree((uint64_t)v5);
  if (FSObjectAtPath) {
LABEL_20:
  }
    BOMFSObjectFree(FSObjectAtPath);
  return v3;
}

uint64_t BOMBomDumpLinks(uint64_t result)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (result)
  {
    uint64_t v1 = *(void *)(result + 24);
    if (v1)
    {
      uint64_t result = BOMBomHLIndexCount(*(void *)(result + 24), 0);
      if (result)
      {
        int v2 = result;
        unsigned int v3 = 0;
        size_t v7 = 0;
        do
        {
          uint64_t result = BOMBomHLIndexBlock(v1, v3);
          if (result)
          {
            unsigned int v4 = result;
            int v5 = BOMBomHLIndexCount(v1, result);
            uint64_t result = printf("hardlink group #%d: (%d links)\n", v4, v5);
            if (v5)
            {
              for (unsigned int i = 0; i != v5; ++i)
              {
                uint64_t result = BOMBomHLIndexGet(v1, v4, i, v8, &v7);
                if (!result) {
                  uint64_t result = printf("    %s\n", v8);
                }
              }
            }
          }
          ++v3;
        }
        while (v3 != v2);
      }
    }
  }
  return result;
}

uint64_t BOMBomVariantAdd(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1 && a2 && a3 && a4 && a5)
  {
    uint64_t result = BOMBomVIndexSet(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      *(unsigned char *)(a1 + 64) = 1;
    }
  }
  return result;
}

uint64_t BOMBomVariantGetList(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, CFMutableArrayRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 && a2 && a3 && a4) {
    return BOMBomVIndexGetList(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    return 1;
  }
}

uint64_t BOMBomVariantCount(uint64_t result, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result) {
    return BOMBomVIndexCount(*(void *)(result + 32), a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t BOMBomVariantGet(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, unsigned int a5, char *a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return BOMBomVIndexGet(*(void *)(a1 + 32), a2, a3, a4, a5, a6, 0x64uLL, a8);
  }
  else {
    return 1;
  }
}

uint64_t BOMBomVariantRemove(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return BOMBomVIndexRemove(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    return 1;
  }
}

uint64_t BOMBomApproximateBytesRepresentedByVariantWithBlockSize(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, unsigned int *a5, unsigned int a6)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!BOMBomVIndexDiskSpaceInfoIsValid(a1[4]))
  {
    value = 0;
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0, 0);
    if (Mutable)
    {
      CFDictionaryRef theDict = Mutable;
      uint64_t v70 = a2;
      int v17 = BOMBomVIndexCount(a1[4], 0, 0, 0, v16, v12, v13, v14);
      int v19 = v17;
      uint64_t v71 = a3;
      if (v17 < 101)
      {
        if (v17 < 1)
        {
LABEL_19:
          uint64_t v68 = a4;
          size_t v69 = a5;
          CFIndex Count = CFDictionaryGetCount(theDict);
          size_t v46 = (const void **)BOM_malloczero(8 * Count + 8);
          CFDictionaryGetKeysAndValues(theDict, v46, 0);
          int v47 = BOM_malloczero(8 * Count + 8);
          int v73 = BOMBomEnumeratorNew((uint64_t)a1, 0);
          uint64_t v48 = BOMBomEnumeratorNext((uint64_t)v73);
          if (v48)
          {
            uint64_t v49 = v48;
            uint64_t v50 = a6;
            do
            {
              unsigned int v51 = (const char *)BOMFSObjectPathName((uint64_t)v49);
              uint64_t v52 = BOMFSObjectSize((uint64_t)v49);
              if (v52 % v50) {
                uint64_t v53 = v50 - v52 % v50;
              }
              else {
                uint64_t v53 = 0;
              }
              uint64_t v54 = v53 + v52;
              if (Count < 1) {
                goto LABEL_33;
              }
              uint64_t v55 = 0;
              char v56 = 1;
              do
              {
                while (BOMPatternListMatch((const __CFArray *)v46[v55], v51))
                {
                  char v56 = 0;
                  v47[v55] += v54;
                  if (Count - 1 == v55++) {
                    goto LABEL_34;
                  }
                }
                ++v55;
              }
              while (Count != v55);
              if (v56) {
LABEL_33:
              }
                v47[Count] += v54;
LABEL_34:
              BOMFSObjectFree((uint64_t)v49);
              uint64_t v49 = BOMBomEnumeratorNext((uint64_t)v73);
            }
            while (v49);
          }
          BOMBomEnumeratorFree(v73);
          if (Count < 1)
          {
            BOMBomVIndexSetApproxDiskSpace(a1[4], 0, 0, 0, v47[Count], v58, v59, v60);
            free(v47);
            a4 = v68;
            a5 = v69;
            CFDictionaryRef v62 = theDict;
          }
          else
          {
            uint64_t v61 = 0;
            a4 = v68;
            a5 = v69;
            CFDictionaryRef v62 = theDict;
            do
            {
              value = (void *)CFDictionaryGetValue(theDict, v46[v61]);
              BOMBomVIndexSetApproxDiskSpaceWithKey(a1[4], (char *)value, v47[v61++]);
            }
            while (Count != v61);
            BOMBomVIndexSetApproxDiskSpace(a1[4], 0, 0, 0, v47[Count], v63, v64, v65);
            free(v47);
            do
            {
              value = (void *)CFDictionaryGetValue(theDict, *v46);
              free(value);
              uint64_t v66 = *v46++;
              CFRelease(v66);
              --Count;
            }
            while (Count);
          }
          CFDictionaryRef v67 = v62;
LABEL_44:
          CFRelease(v67);
          a2 = v70;
          a3 = v71;
          return BOMBomVIndexGetApproxDiskSpace(a1[4], a2, a3, a4, a5, v12, v13, v14);
        }
      }
      else
      {
        int v20 = BOMExceptionHandlerMessage("_computeVariantSizes(bom=%p, blockSize=%u): catcnt(%d) > catmax(%d)!", a1, a6, v17, 100);
        size_t v21 = __error();
        _BOMExceptionHandlerCall((uint64_t)v20, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", 3818, *v21);
      }
      unsigned int v23 = 0;
      int v72 = v19;
      while (1)
      {
        BOMBomVIndexGet(a1[4], 0, 0, 0, v23, v79, 0x64uLL, v18);
        int v28 = BOMBomVIndexCount(a1[4], v79, 0, 0, v24, v25, v26, v27);
        if (v28 >= 1) {
          break;
        }
LABEL_18:
        if (++v23 == v72) {
          goto LABEL_19;
        }
      }
      int v29 = v28;
      unsigned int v30 = 0;
      while (1)
      {
        BOMBomVIndexGet(a1[4], v79, 0, 0, v30, v78, 0x64uLL, v18);
        int v35 = BOMBomVIndexCount(a1[4], v79, (uint64_t)v78, 0, v31, v32, v33, v34);
        if (v35 >= 1) {
          break;
        }
LABEL_17:
        if (++v30 == v29) {
          goto LABEL_18;
        }
      }
      int v36 = v35;
      unsigned int v37 = 0;
      while (1)
      {
        CFTypeRef cf = 0;
        BOMBomVIndexGet(a1[4], v79, (uint64_t)v78, 0, v37, v77, 0x64uLL, v18);
        if (BOMBomVIndexDiskSpaceKey(a1[4], v79, (uint64_t)v78, (uint64_t)v77, &value, v38, v39, v40)) {
          break;
        }
        if (BOMBomVIndexGetList(a1[4], v79, (uint64_t)v78, (uint64_t)v77, (CFMutableArrayRef *)&cf, v41, v42, v43))break; {
        size_t v44 = BOMPatternListFromStringList(cf);
        }
        CFRelease(cf);
        if (!v44) {
          break;
        }
        CFDictionarySetValue(theDict, v44, value);
        if (v36 == ++v37) {
          goto LABEL_17;
        }
      }
      CFDictionaryRef v67 = theDict;
      goto LABEL_44;
    }
  }
  return BOMBomVIndexGetApproxDiskSpace(a1[4], a2, a3, a4, a5, v12, v13, v14);
}

uint64_t BOMBomApproximateBytesRepresentedByVariantWithBlockSize64(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, void *a5, unsigned int a6)
{
  unsigned int v8 = 0;
  uint64_t result = BOMBomApproximateBytesRepresentedByVariantWithBlockSize(a1, a2, a3, a4, &v8, a6);
  *a5 = v8;
  return result;
}

uint64_t BOMBomApproximateBytesRepresentedByVariant(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, unsigned int *a5)
{
  return BOMBomApproximateBytesRepresentedByVariantWithBlockSize(a1, a2, a3, a4, a5, 0x200u);
}

uint64_t BOMBomApproximateBytesRepresentedByVariant64(uint64_t *a1, char *a2, uint64_t a3, uint64_t a4, void *a5)
{
  unsigned int v7 = 0;
  uint64_t result = BOMBomApproximateBytesRepresentedByVariantWithBlockSize(a1, a2, a3, a4, &v7, 0x200u);
  if (!result) {
    *a5 = v7;
  }
  return result;
}

uint64_t BOMBomApproximateBytesRepresentedByVariantIsValid(uint64_t result)
{
  if (result) {
    return BOMBomVIndexDiskSpaceInfoIsValid(*(void *)(result + 32));
  }
  return result;
}

uint64_t BOMBomEInsertFSObject(unint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v4 = 1;
  if (!a1 || !a2) {
    return v4;
  }
  uint64_t v24 = 0;
  size_t v25 = 0;
  uint64_t v9 = (const char *)BOMFSObjectPathName(a2);
  size_t v10 = (char *)BOMFSObjectShortName(a2);
  uint64_t v11 = BOMNewPathKey(a3, v10, &v25);
  if (!v11) {
    return 1;
  }
  uint64_t v12 = v11;
  unint64_t Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 16), v11, v25);
  uint64_t v14 = (uint64_t)Value;
  if (Value)
  {
    unsigned int v23 = a4;
    size_t v15 = v9;
    unsigned int v16 = BOMPathIDFromPathKey(Value);
    unsigned int v17 = BOMBlockIDFromPathValue(v14);
    FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v17);
    if (FSObjectWithBlockID)
    {
      uint64_t v19 = (uint64_t)FSObjectWithBlockID;
      _removeArchInfoForFSObject(a1, (uint64_t)FSObjectWithBlockID);
      BOMFSObjectFree(v19);
    }
    unsigned int v20 = v16;
    uint64_t v9 = v15;
    a4 = v23;
  }
  else
  {
    unsigned int v20 = (*(_DWORD *)a1)++;
    unsigned int v17 = BOMStorageNewBlock(*(void *)(a1 + 8));
  }
  if (_BOMBomSetFSObjectWithBlockID(a1, a2, v17))
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "can't archive %s\n", v9);
    size_t v21 = 0;
    uint64_t v4 = 1;
LABEL_17:
    free(v12);
    goto LABEL_18;
  }
  _addArchInfoForFSObject(a1, a2);
  if (v14)
  {
    size_t v21 = 0;
    goto LABEL_14;
  }
  free(v12);
  uint64_t v12 = BOMNewPathKey(a3, v10, &v25);
  size_t v21 = BOMNewPathValue(v20, v17, &v24);
  if (!BOMTreeSetValue(*(void **)(a1 + 16), v12, v25, (uint64_t)v21, v24))
  {
LABEL_14:
    *(unsigned char *)(a1 + 64) = 1;
    uint64_t v4 = 0;
    if (a4) {
      *a4 = v20;
    }
    if (!v12) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  fprintf((FILE *)*MEMORY[0x263EF8348], "can't set path info for %s.\n", v9);
  uint64_t v4 = 1;
  if (v12) {
    goto LABEL_17;
  }
LABEL_18:
  if (v21) {
    free(v21);
  }
  return v4;
}

uint64_t BOMBomELinkFromPathToPath(uint64_t a1, const char *a2, char *a3, unsigned int a4)
{
  uint64_t v4 = 1;
  if (a2)
  {
    if (a1)
    {
      if (a3)
      {
        uint64_t v9 = _valueAtPath(a1);
        if (v9)
        {
          unsigned int v10 = BOMBlockIDFromPathValue((uint64_t)v9);
          if (v10)
          {
            unsigned int v11 = v10;
            uint64_t v24 = 0;
            size_t v25 = 0;
            uint64_t v12 = strrchr(a3, 47);
            if (v12) {
              uint64_t v13 = v12 + 1;
            }
            else {
              uint64_t v13 = a3;
            }
            uint64_t v14 = BOMNewPathKey(a4, v13, &v25);
            if (v14)
            {
              size_t v15 = v14;
              unint64_t Value = BOMTreeGetValue(*(void *)(a1 + 16), v14, v25);
              unint64_t v17 = Value;
              if (Value)
              {
                uint64_t v18 = 8;
                uint64_t v24 = 8;
                uint64_t v19 = (_DWORD *)Value;
              }
              else
              {
                unsigned int v20 = (*(_DWORD *)a1)++;
                uint64_t v19 = BOMNewPathValue(v20, v11, &v24);
                uint64_t v18 = v24;
              }
              if (BOMTreeSetValue(*(void **)(a1 + 16), v15, v25, (uint64_t)v19, v18))
              {
                uint64_t v4 = 1;
              }
              else
              {
                size_t v21 = strlen(a3);
                BOMBomHLIndexSet(*(void *)(a1 + 24), v11, a3, v21 + 1);
                size_t v22 = strlen(a2);
                BOMBomHLIndexSet(*(void *)(a1 + 24), v11, a2, v22 + 1);
                uint64_t v4 = 0;
              }
              free(v15);
              if (!v17) {
                free(v19);
              }
            }
            else
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return v4;
}

uint64_t BOMBomEInvalidateCachedData(uint64_t a1)
{
  return 0;
}

uint64_t _BOMBomPrintDiagnostics(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void *)result;
    int v2 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "Tree: %s\n", "Paths");
    _BOMTreePrintDiagnostics(v1[2]);
    _BOMBomHLIndexPrintDiagnostics(v1[3]);
    _BOMBomVIndexPrintDiagnostics(v1[4], v3, v4, v5, v6, v7, v8, v9);
    fwrite("Storage:\n", 9uLL, 1uLL, *v2);
    uint64_t v10 = v1[1];
    return _BOMStoragePrintDiagnostics(v10);
  }
  return result;
}

uint64_t BOMBomVerifyBom(uint64_t a1, unsigned __int8 a2)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4)
    {
      if (!BOMTreeVerifyLeaves(v4))
      {
        int v9 = *__error();
        uint64_t v10 = "BOMBomVerifyBom: leaves do not verify.\n";
        unsigned __int8 v11 = a2;
        int v12 = 4300;
        goto LABEL_12;
      }
      uint64_t v4 = *(void *)(a1 + 16);
    }
    int v5 = BOMTreeCount(v4);
    uint64_t v6 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 16), 0, 0, 0);
    int v7 = 0;
    while (!BOMTreeIteratorIsAtEnd((uint64_t)v6))
    {
      ++v7;
      BOMTreeIteratorNext((uint64_t)v6);
    }
    BOMTreeIteratorFree(v6);
    if (v7 == v5) {
      return 1;
    }
    int v9 = *__error();
    uint64_t v10 = "BOMBomVerifyBom: count is wrong.\n";
    unsigned __int8 v11 = a2;
    int v12 = 4316;
  }
  else
  {
    int v9 = *__error();
    uint64_t v10 = "BOMBomVerifyBom: bom is NULL.\n";
    unsigned __int8 v11 = a2;
    int v12 = 4293;
  }
LABEL_12:
  _BOMExceptionHandlerCall((uint64_t)v10, v11, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBom.c", v12, v9);
  return 0;
}

void _addPathsToList(uint64_t a1, char *a2, __CFArray *a3, const char **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a6;
  int v9 = a5;
  uint64_t v28 = *MEMORY[0x263EF8340];
  int v14 = BOMBomVIndexCount(*(void *)(a1 + 32), a2, 0, 0, a5, a6, a7, a8);
  if (v14)
  {
    int v16 = v14;
    unsigned int v17 = 0;
    uint64_t v18 = kBOMBomVariantExtra;
    CFTypeRef cf = 0;
    if (!v9) {
      uint64_t v18 = &kBOMBomVariantException;
    }
    uint64_t v19 = (uint64_t)*v18;
    do
    {
      if (!BOMBomVIndexGet(*(void *)(a1 + 32), a2, 0, 0, v17, __s2, 0x64uLL, v15))
      {
        if (a4)
        {
          size_t v22 = a4;
          while (1)
          {
            unsigned int v23 = *v22;
            if (!*v22) {
              break;
            }
            ++v22;
            if (!strcmp(v23, __s2))
            {
              if (v8) {
                goto LABEL_6;
              }
              goto LABEL_15;
            }
          }
        }
        if (v8)
        {
LABEL_15:
          CFTypeRef cf = 0;
          if (!BOMBomVIndexGetList(*(void *)(a1 + 32), a2, (uint64_t)__s2, v19, (CFMutableArrayRef *)&cf, v20, v21, v15))
          {
            CFArrayRef v24 = (const __CFArray *)cf;
            v29.location = BOMCFArrayMaxRange((const __CFArray *)cf);
            v29.length = v25;
            CFArrayAppendArray(a3, v24, v29);
            CFRelease(cf);
          }
        }
      }
LABEL_6:
      ++v17;
    }
    while (v17 != v16);
  }
}

void release_discovery_state(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(NSObject **)(a1 + 24);
    if (v2)
    {
      dispatch_group_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(*(dispatch_object_t *)(a1 + 24));
      *(void *)(a1 + 24) = 0;
    }
    uint64_t v3 = *(void **)(a1 + 56);
    if (v3)
    {
      free(v3);
      *(void *)(a1 + 56) = 0;
    }
    uint64_t v4 = *(const void ***)(a1 + 48);
    if (v4)
    {
      BOMHardLinkTableFree(v4);
      *(void *)(a1 + 48) = 0;
    }
    uint64_t v5 = *(void *)(a1 + 64);
    if (v5)
    {
      BOMBomFree(v5);
      *(void *)(a1 + 64) = 0;
    }
    uint64_t v6 = *(void **)(a1 + 40);
    if (v6)
    {
      free(v6);
      *(void *)(a1 + 40) = 0;
    }
    int v7 = *(uint64_t **)(a1 + 32);
    if (v7)
    {
      while (1)
      {
        int v8 = BOMStackPop(v7);
        if (!v8) {
          break;
        }
        free(v8);
        int v7 = *(uint64_t **)(a1 + 32);
      }
      BOMStackFree(*(void ***)(a1 + 32));
      *(void *)(a1 + 32) = 0;
    }
    uint64_t v9 = *(void *)(a1 + 8);
    if (v9)
    {
      do
      {
        uint64_t v10 = *(void *)(v9 + 72);
        uint64_t v11 = *(void *)(v9 + 8);
        if (v11)
        {
          BOMFSObjectFree(v11);
          *(void *)(v9 + 8) = 0;
        }
        BOMCopierSourceEntryFree(*(unsigned int **)v9);
        free((void *)v9);
        uint64_t v9 = v10;
      }
      while (v10);
    }
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    if (*(void *)a1)
    {
      BOMCopierSourceFree(*(void **)a1);
      *(void *)a1 = 0;
    }
  }
}

uint64_t _BOMGetFSObject(uint64_t a1, unsigned int *a2, unsigned int *a3, char *a4)
{
  unsigned int v8 = BOMBlockIDFromPathValue((uint64_t)a3);
  int v9 = BOMPathIDFromPathKey(a3);
  int v10 = BOMPathIDFromPathKey(a2);
  uint64_t v11 = (char *)BOMShortNameFromPathKey((uint64_t)a2);
  FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(a1, v8);
  uint64_t v13 = (uint64_t)FSObjectWithBlockID;
  if (FSObjectWithBlockID)
  {
    BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, a4, 1);
    BOMFSObjectSetShortName(v13, v11, 1);
    BOMFSObjectSetPathID(v13, v9);
    BOMFSObjectSetParentPathID(v13, v10);
    BOMFSObjectSetBlockID(v13, v8);
  }
  return v13;
}

void *BOMHardLinkTableNew()
{
  return BOM_malloczero(8uLL);
}

void BOMHardLinkTableFree(const void **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

void BOMHardLinkTableSet(CFDictionaryRef *a1, int a2, uint64_t a3, UInt8 *bytes, CFIndex length)
{
  if (a1)
  {
    if (bytes)
    {
      CFDataRef v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], bytes, length);
      if (v8)
      {
        CFDataRef v9 = v8;
        BOMHardLinkTableSetCFData(a1, a2, a3, v8);
        CFRelease(v9);
      }
      else
      {
        int v10 = (FILE *)*MEMORY[0x263EF8348];
        uint64_t v11 = __error();
        int v12 = strerror(*v11);
        fprintf(v10, "CFDataCreate: %s\n", v12);
      }
    }
    else
    {
      BOMHardLinkTableSetCFData(a1, a2, a3, 0);
    }
  }
}

void BOMHardLinkTableSetCFData(CFDictionaryRef *a1, int a2, uint64_t a3, const void *a4)
{
  int valuePtr = a2;
  uint64_t v18 = a3;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  if (!*a1)
  {
    CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    if (!Mutable) {
      goto LABEL_15;
    }
    *a1 = Mutable;
  }
  CFNumberRef v8 = CFNumberCreate(v6, kCFNumberSInt32Type, &valuePtr);
  if (!v8)
  {
LABEL_11:
    int v14 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v15 = __error();
    strerror(*v15);
    fprintf(v14, "CFNumberCreate: %s\n");
    return;
  }
  CFNumberRef v9 = v8;
  unint64_t Value = (void *)CFDictionaryGetValue(*a1, v8);
  if (!Value)
  {
    CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(v6, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    if (v11)
    {
      unint64_t Value = v11;
      CFDictionarySetValue(*a1, v9, v11);
      CFRelease(Value);
      goto LABEL_8;
    }
    CFRelease(v9);
LABEL_15:
    int v16 = (FILE *)*MEMORY[0x263EF8348];
    unsigned int v17 = __error();
    strerror(*v17);
    fprintf(v16, "CFDictionaryCreateMutable: %s\n");
    return;
  }
LABEL_8:
  CFRelease(v9);
  CFNumberRef v12 = CFNumberCreate(v6, kCFNumberSInt64Type, &v18);
  if (!v12) {
    goto LABEL_11;
  }
  CFNumberRef v13 = v12;
  if (a4) {
    CFDictionarySetValue((CFMutableDictionaryRef)Value, v12, a4);
  }
  else {
    CFDictionaryRemoveValue((CFMutableDictionaryRef)Value, v12);
  }
  CFRelease(v13);
}

const UInt8 *BOMHardLinkTableGet(CFDictionaryRef *a1, int a2, uint64_t a3)
{
  if (!a1) {
    return 0;
  }
  CFCFDataRef Data = (const __CFData *)BOMHardLinkTableGetCFData(a1, a2, a3);
  if (!CFData) {
    return 0;
  }
  return CFDataGetBytePtr(CFData);
}

const void *BOMHardLinkTableGetCFData(CFDictionaryRef *a1, int a2, uint64_t a3)
{
  int valuePtr = a2;
  uint64_t v12 = a3;
  if (!*a1) {
    return 0;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
  if (!v5) {
    return 0;
  }
  CFNumberRef v6 = v5;
  CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(*a1, v5);
  CFRelease(v6);
  if (!Value) {
    return 0;
  }
  CFNumberRef v8 = CFNumberCreate(v4, kCFNumberSInt64Type, &v12);
  if (!v8) {
    return 0;
  }
  CFNumberRef v9 = v8;
  int v10 = CFDictionaryGetValue(Value, v8);
  CFRelease(v9);
  return v10;
}

void BOMHardLinkTableSetPathAndData(CFDictionaryRef *a1, int a2, uint64_t a3, char *__s, const void *a5, size_t a6)
{
  if (a1)
  {
    if (__s && a5)
    {
      size_t v12 = strlen(__s) + 1;
      size_t v13 = v12 + a6;
      int v14 = (char *)BOM_malloc(v12 + a6);
      if (v14)
      {
        uint64_t v15 = (UInt8 *)v14;
        strlcpy(v14, __s, v13);
        memmove(&v15[v12], a5, a6);
        CFDataRef v16 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x263EFFB08], v15, v13, (CFAllocatorRef)*MEMORY[0x263EFFB18]);
        if (v16)
        {
          CFDataRef v17 = v16;
          BOMHardLinkTableSetCFData(a1, a2, a3, v16);
          CFRelease(v17);
        }
        else
        {
          free(v15);
          uint64_t v18 = (FILE *)*MEMORY[0x263EF8348];
          uint64_t v19 = __error();
          uint64_t v20 = strerror(*v19);
          fprintf(v18, "CFDataCreate: %s\n", v20);
        }
      }
    }
    else
    {
      BOMHardLinkTableSetCFData(a1, a2, a3, 0);
    }
  }
}

uint64_t BOMHardLinkTableGetPathAndData(CFDictionaryRef *a1, int a2, uint64_t a3, char *a4, void *a5)
{
  uint64_t result = 1;
  if (a1 && a4 && a5)
  {
    CFCFDataRef Data = (const __CFData *)BOMHardLinkTableGetCFData(a1, a2, a3);
    if (CFData)
    {
      CFDataRef v10 = CFData;
      BytePtr = (const char *)CFDataGetBytePtr(CFData);
      size_t Length = CFDataGetLength(v10);
      size_t v13 = strncpy(a4, BytePtr, Length);
      size_t v14 = strlen(v13);
      uint64_t result = 0;
      *a5 = &BytePtr[v14 + 1];
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void *BOMFSEnumeratorNew(uint64_t a1, __int16 a2, char a3)
{
  return BOMFSEnumeratorNewWithSys(a1, a2, a3, 0);
}

void *BOMFSEnumeratorNewWithSys(uint64_t a1, __int16 a2, char a3, void (**a4)(void, uint64_t, uint64_t))
{
  v15[2] = *(char **)MEMORY[0x263EF8340];
  if (!a1) {
    return 0;
  }
  CFNumberRef v8 = BOM_malloczero(0x420uLL);
  if (v8)
  {
    if (!a4) {
      a4 = (void (**)(void, uint64_t, uint64_t))BomSys_default();
    }
    v8[2] = a4;
    if (((unsigned int (*)(void (*)(void, uint64_t, uint64_t), uint64_t))a4[39])(a4[1], a1))
    {
      CFNumberRef v9 = __error();
      CFDataRef v10 = strerror(*v9);
      CFMutableDictionaryRef v11 = BOMExceptionHandlerMessage("chdir: %s\n", v10);
      size_t v12 = __error();
      _BOMExceptionHandlerCall((uint64_t)v11, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMFSEnumerator.c", 56, *v12);
    }
    else
    {
      *((_WORD *)v8 + 4) = a2;
      *((unsigned char *)v8 + 10) = a3;
      a4[38](a4[1], (uint64_t)(v8 + 3), 1025);
      v15[0] = ".";
      v15[1] = 0;
      size_t v14 = fts_open(v15, 92, (int (__cdecl *)(const FTSENT **, const FTSENT **))_sort);
      *CFNumberRef v8 = v14;
      if (v14) {
        return v8;
      }
    }
    free(v8);
    return 0;
  }
  return v8;
}

uint64_t _sort(uint64_t a1, uint64_t a2)
{
  return strcmp((const char *)(*(void *)a1 + 104), (const char *)(*(void *)a2 + 104));
}

FTSENT *BOMFSEnumeratorNext(FTSENT *result)
{
  if (result)
  {
    uint64_t v1 = result;
    memset(v12, 0, sizeof(v12));
    do
    {
      uint64_t result = fts_read((FTS *)v1->fts_cycle);
      if (!result) {
        return result;
      }
      int fts_info = result->fts_info;
    }
    while (fts_info == 6);
    int fts_errno = result->fts_errno;
    if (fts_errno)
    {
      *__error() = fts_errno;
      CFAllocatorRef v4 = __error();
      CFNumberRef v5 = strerror(*v4);
      CFNumberRef v6 = BOMExceptionHandlerMessage("fts_read: %s\n", v5);
      int v7 = __error();
      _BOMExceptionHandlerCall((uint64_t)v6, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMFSEnumerator.c", 94, *v7);
      return 0;
    }
    if (BYTE2(v1->fts_parent))
    {
      if (result->fts_info > 7u)
      {
        if (fts_info == 8)
        {
          __int16 v8 = 0x8000;
          goto LABEL_21;
        }
        if (fts_info == 12)
        {
          __int16 v8 = -24576;
          goto LABEL_21;
        }
      }
      else
      {
        if (fts_info == 1)
        {
          __int16 v8 = 0x4000;
          goto LABEL_21;
        }
        if (fts_info == 3)
        {
          __int16 v8 = 24576;
LABEL_21:
          WORD2(v12[0]) = v8;
          return (FTSENT *)BOMFSObjectNewFromPathDeferredWithSys((uint64_t)v12, result->fts_path, (__int16)v1->fts_parent, (const char *)&v1->fts_number, 0, v1->fts_link);
        }
      }
      __int16 v8 = 0;
      goto LABEL_21;
    }
    fts_path = result->fts_path;
    __int16 fts_parent = (__int16)v1->fts_parent;
    fts_linunsigned int k = v1->fts_link;
    return (FTSENT *)BOMFSObjectNewFromPathWithSys(fts_path, fts_parent, fts_link);
  }
  return result;
}

void BOMFSEnumeratorFree(FTS **a1)
{
  if (a1)
  {
    int v2 = *a1;
    if (v2) {
      fts_close(v2);
    }
    free(a1);
  }
}

_DWORD *BOMBomVIndexNew(uint64_t a1)
{
  int v2 = BOM_malloczero(0x30uLL);
  uint64_t v3 = v2;
  if (v2)
  {
    *int v2 = 1;
    int v4 = BOMStorageNewNamedBlock(a1, "VIndex");
    if (!v4) {
      goto LABEL_7;
    }
    *((void *)v3 + 2) = a1;
    v3[6] = v4;
    unsigned int v5 = BOMStorageNewBlock(a1);
    if (!v5) {
      goto LABEL_7;
    }
    unsigned int v6 = v5;
    int v7 = BOMTreeNewWithOptions(a1, v5, "VIndex", 0x80u, 0);
    if (!v7) {
      goto LABEL_7;
    }
    *((void *)v3 + 1) = v7;
    uint64_t v8 = BOMStreamWithBlockID(*((void *)v3 + 2), v3[6], 0xDuLL, 1);
    if (v8
      && (CFNumberRef v9 = (int *)v8,
          BOMStreamWriteUInt32(v8, *v3),
          BOMStreamWriteUInt32((uint64_t)v9, v6),
          BOMStreamWriteUInt32((uint64_t)v9, v3[7]),
          BOMStreamWriteUInt8((uint64_t)v9, *((unsigned char *)v3 + 33)),
          !BOMStreamFlush(v9)))
    {
      BOMStreamFree((uint64_t)v9);
    }
    else
    {
LABEL_7:
      BOMBomVIndexFree(v3);
      return 0;
    }
  }
  return v3;
}

uint64_t BOMBomVIndexFree(unsigned char *a1)
{
  if (!a1) {
    return 1;
  }
  if (a1[32] && BOMBomVIndexCommit((uint64_t)a1)) {
    return 1;
  }
  uint64_t v3 = *((void *)a1 + 1);
  if (v3) {
    BOMTreeFree(v3);
  }
  int v4 = (const void *)*((void *)a1 + 5);
  if (v4) {
    CFRelease(v4);
  }
  free(a1);
  return 0;
}

void *BOMBomVIndexOpen(uint64_t a1, char a2)
{
  int v4 = BOM_malloczero(0x30uLL);
  if (v4)
  {
    unsigned int NamedBlock = BOMStorageGetNamedBlock(a1, "VIndex");
    if (!NamedBlock) {
      goto LABEL_5;
    }
    v4[2] = a1;
    *((_DWORD *)v4 + 6) = NamedBlock;
    uint64_t v6 = BOMStreamWithBlockID(a1, NamedBlock, 0xDuLL, 0);
    if (!v6) {
      goto LABEL_5;
    }
    uint64_t v7 = v6;
    *(_DWORD *)int v4 = BOMStreamReadUInt32(v6);
    unsigned int UInt32 = BOMStreamReadUInt32(v7);
    *((_DWORD *)v4 + 7) = BOMStreamReadUInt32(v7);
    *((unsigned char *)v4 + 33) = BOMStreamReadUInt8(v7);
    BOMStreamFree(v7);
    uint64_t v9 = BOMTreeOpen(a1, UInt32, a2);
    v4[1] = v9;
    if (!v9)
    {
LABEL_5:
      BOMBomVIndexFree(v4);
      return 0;
    }
  }
  return v4;
}

uint64_t BOMBomVIndexCommit(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 32)) {
    return 0;
  }
  uint64_t result = BOMStorageIsOpenForWriting(*(void *)(a1 + 16));
  if (result)
  {
    BOMTreeCommit(*(void *)(a1 + 8));
    uint64_t v3 = BOMStreamWithBlockID(*(void *)(a1 + 16), *(_DWORD *)(a1 + 24), 0xDuLL, 2);
    if (v3
      && (int v4 = (int *)v3,
          BOMStreamReadUInt32(v3),
          BOMStreamReadUInt32((uint64_t)v4),
          BOMStreamWriteUInt32((uint64_t)v4, *(_DWORD *)(a1 + 28)),
          BOMStreamWriteUInt8((uint64_t)v4, *(unsigned char *)(a1 + 33)),
          !BOMStreamFlush(v4)))
    {
      BOMStreamFree((uint64_t)v4);
      uint64_t result = 0;
      *(unsigned char *)(a1 + 32) = 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t BOMBomVIndexCopyFromVIndex(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  if (a1 && a2)
  {
    if (BOMTreeCount(*(void *)(a1 + 8)) || BOMCKTreeBuildKey(__s, v4, v5, v6, v7, v8, v9, v10, "path"))
    {
      CFMutableDictionaryRef v11 = 0;
    }
    else
    {
      int v17 = strlen(__s);
      uint64_t v18 = *(void *)(a1 + 16);
      uint64_t v19 = *(void *)(a2 + 16);
      CFMutableDictionaryRef v11 = (char *)BOMTreeIteratorNew(*(void *)(a2 + 8), 0, 0, 0);
      if (v11)
      {
        BOMTreeSetDensePacking(*(void *)(a1 + 8), 1);
        while (!BOMTreeIteratorIsAtEnd((uint64_t)v11))
        {
          uint64_t v20 = (const void *)BOMTreeIteratorKey((uint64_t)v11);
          if (BOM_strrncmp((const char *)v20, __s, v17))
          {
            uint64_t v21 = *(void **)(a1 + 8);
            size_t v22 = BOMTreeIteratorKeySize((uint64_t)v11);
            uint64_t v23 = BOMTreeIteratorValue((uint64_t)v11);
            uint64_t v24 = BOMTreeIteratorValueSize((uint64_t)v11);
            if (BOMTreeSetValue(v21, v20, v22, v23, v24)) {
              goto LABEL_6;
            }
          }
          else
          {
            unsigned int v29 = 0;
            size_t v25 = strlen((const char *)v20) + 1;
            CFDictionaryRef Value = (unsigned int *)BOMTreeGetValue(*(void *)(a2 + 8), v20, v25);
            if (!Value)
            {
              uint64_t v13 = 0;
              uint64_t v12 = 0;
              goto LABEL_8;
            }
            uint64_t v12 = BOMTreeOpen(v19, bswap32(*Value), 0);
            if (!v12) {
              goto LABEL_7;
            }
            unsigned int v27 = BOMStorageNewBlock(v18);
            unsigned int v29 = v27;
            if (!v27) {
              goto LABEL_7;
            }
            uint64_t v28 = BOMTreeNewWithOptions(v18, v27, 0, 0x80u, 0);
            uint64_t v13 = (uint64_t)v28;
            if (!v28) {
              goto LABEL_8;
            }
            BOMTreeSetDensePacking((uint64_t)v28, 1);
            if (BOMTreeCopyToTree(v12, v13)) {
              goto LABEL_8;
            }
            BOMTreeFree(v12);
            BOMTreeFree(v13);
            unsigned int v29 = bswap32(v29);
            BOMTreeSetValue(*(void **)(a1 + 8), v20, v25, (uint64_t)&v29, 4);
          }
          BOMTreeIteratorNext((uint64_t)v11);
        }
        uint64_t v14 = 0;
        uint64_t v12 = 0;
        uint64_t v13 = 0;
        *(unsigned char *)(a1 + 33) = *(unsigned char *)(a2 + 33);
        *(unsigned char *)(a1 + 32) = 1;
        goto LABEL_11;
      }
    }
LABEL_6:
    uint64_t v12 = 0;
LABEL_7:
    uint64_t v13 = 0;
LABEL_8:
    uint64_t v14 = 1;
  }
  else
  {
    uint64_t v14 = 1;
    if (!a1) {
      return v14;
    }
    CFMutableDictionaryRef v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
  }
LABEL_11:
  uint64_t v15 = *(void *)(a1 + 8);
  if (v15) {
    BOMTreeSetDensePacking(v15, 0);
  }
  if (v12) {
    BOMTreeFree(v12);
  }
  if (v13) {
    BOMTreeFree(v13);
  }
  if (v11) {
    BOMTreeIteratorFree(v11);
  }
  return v14;
}

uint64_t BOMBomVIndexSet(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            uint64_t TreeFor = _v_findTreeFor(a1, 1, 1, a2, a3, a4, a7, a8);
            if (TreeFor)
            {
              uint64_t v12 = (void *)TreeFor;
              size_t v13 = strlen(a5);
              uint64_t v8 = BOMTreeSetValue(v12, a5, v13 + 1, 0, 0);
              BOMTreeFree((uint64_t)v12);
              if (!v8) {
                *(_WORD *)(a1 + 32) = 1;
              }
            }
          }
        }
      }
    }
  }
  return v8;
}

uint64_t _v_findTreeFor(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0;
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (a4)
  {
    if (a5)
    {
      if (a6)
      {
        int v9 = a3;
        char v10 = a2;
        uint64_t v12 = *(void *)(a1 + 16);
        uint64_t v8 = 0;
        if (!BOMCKTreeBuildKey(__s, a2, a3, (uint64_t)a4, a5, a6, a7, a8, a4))
        {
          size_t v13 = strlen(__s) + 1;
          CFDictionaryRef Value = (unsigned int *)BOMTreeGetValue(*(void *)(a1 + 8), __s, v13);
          if (Value)
          {
            return BOMTreeOpen(v12, bswap32(*Value), v10);
          }
          else if (v9 && (unsigned int v15 = BOMStorageNewBlock(v12)) != 0)
          {
            unsigned int v16 = v15;
            uint64_t v8 = BOMTreeNewWithOptions(v12, v15, 0, 0x80u, 0);
            if (v8)
            {
              unsigned int v18 = bswap32(v16);
              BOMTreeSetValue(*(void **)(a1 + 8), __s, v13, (uint64_t)&v18, 4);
            }
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return (uint64_t)v8;
}

uint64_t BOMBomVIndexCount(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 0;
  }
  uint64_t TreeFor = _v_findTreeFor(a1, 0, 0, a2, a3, a4, a7, a8);
  if (TreeFor)
  {
    uint64_t v18 = TreeFor;
    uint64_t v19 = BOMTreeCount(TreeFor);
    if (v18 != *(void *)(a1 + 8)) {
      BOMTreeFree(v18);
    }
    return v19;
  }
  return BOMCKTreeCount(*(void *)(a1 + 8), v11, v12, v13, v14, v15, v16, v17, a2);
}

uint64_t BOMBomVIndexGet(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, unsigned int a5, char *a6, size_t a7, uint64_t a8)
{
  uint64_t result = 1;
  if (a1 && a6)
  {
    *a6 = 0;
    uint64_t TreeFor = _v_findTreeFor(a1, 0, 0, a2, a3, a4, a7, a8);
    if (TreeFor)
    {
      uint64_t v21 = TreeFor;
      if (BOMTreeCount(TreeFor) <= a5) {
        return 1;
      }
      size_t v22 = (char *)BOMTreeIteratorNew(v21, 0, 0, 0);
      if (!v22) {
        return 1;
      }
      for (unsigned int i = v22; a5; --a5)
        BOMTreeIteratorNext((uint64_t)i);
      uint64_t v24 = (const char *)BOMTreeIteratorKey((uint64_t)i);
      strlcpy(a6, v24, a7);
      BOMTreeIteratorFree(i);
      BOMTreeFree(v21);
    }
    else
    {
      size_t v25 = BOMCKTreeGet(*(void *)(a1 + 8), a5, v15, v16, v17, v18, v19, v20, a2);
      strlcpy(a6, v25, a7);
    }
    return 0;
  }
  return result;
}

uint64_t BOMBomVIndexGetList(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, CFMutableArrayRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            if (*a5
              || (CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0), (*a5 = Mutable) != 0))
            {
              uint64_t TreeFor = _v_findTreeFor(a1, 0, 0, a2, a3, a4, a7, a8);
              uint64_t v23 = TreeFor;
              if (TreeFor)
              {
                uint64_t v24 = (char *)BOMTreeIteratorNew(TreeFor, 0, 0, 0);
                if (!v24) {
                  goto LABEL_27;
                }
                for (unsigned int i = v24; ; BOMTreeIteratorNext((uint64_t)i))
                {
                  if (BOMTreeIteratorIsAtEnd((uint64_t)i))
                  {
                    uint64_t v8 = 0;
                    goto LABEL_25;
                  }
                  uint64_t v26 = (const char *)BOMTreeIteratorKey((uint64_t)i);
                  if (!v26) {
                    break;
                  }
                  unsigned int v27 = v26;
                  size_t v28 = strlen(v26) + 1;
                  unsigned int v29 = (char *)BOM_malloc(v28);
                  if (!v29) {
                    break;
                  }
                  unsigned int v30 = v29;
                  strlcpy(v29, v27, v28);
                  CFArrayAppendValue(*a5, v30);
                }
                uint64_t v8 = 1;
LABEL_25:
                BOMTreeIteratorFree(i);
LABEL_26:
                if (v23) {
LABEL_27:
                }
                  BOMTreeFree(v23);
              }
              else
              {
                int v31 = BOMCKTreeCount(*(void *)(a1 + 8), v16, v17, v18, v19, v20, v21, v22, a2);
                if (v31 < 1)
                {
                  return 0;
                }
                else
                {
                  int v38 = v31;
                  int v39 = 0;
                  while (1)
                  {
                    uint64_t v40 = BOMCKTreeGet(*(void *)(a1 + 8), v39, v32, v33, v34, v35, v36, v37, a2);
                    if (!v40) {
                      return 1;
                    }
                    uint64_t v41 = v40;
                    size_t v42 = strlen(v40) + 1;
                    uint64_t v43 = (char *)BOM_malloc(v42);
                    if (!v43) {
                      return 1;
                    }
                    size_t v44 = v43;
                    strlcpy(v43, v41, v42);
                    CFArrayAppendValue(*a5, v44);
                    if (v38 == ++v39)
                    {
                      uint64_t v8 = 0;
                      uint64_t v23 = 0;
                      goto LABEL_26;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v8;
}

uint64_t BOMBomVIndexRemove(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v8 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          uint64_t TreeFor = _v_findTreeFor(a1, 1, 0, a2, a3, a4, a7, a8);
          if (TreeFor)
          {
            uint64_t v15 = TreeFor;
            while (a5)
            {
              size_t v16 = strlen(a5);
              uint64_t v17 = BOMTreeRemoveValue(v15, a5, v16 + 1);
              if (v17) {
                return v17;
              }
              int v18 = BOMTreeCount(v15);
              BOMTreeFree(v15);
              if (v18) {
                goto LABEL_16;
              }
              uint64_t v8 = 1;
              *(_WORD *)(a1 + 32) = 1;
              uint64_t v15 = _v_findTreeFor(a1, 1, 0, a2, a3, a4, v19, v20);
              a5 = 0;
              if (!v15) {
                return v8;
              }
            }
            BOMTreeRemoveAndFree(v15);
            if (BOMCKTreeBuildKey(__s, v21, v22, v23, v24, v25, v26, v27, a2)) {
              return 1;
            }
            int v28 = strlen(__s);
            uint64_t v8 = BOMTreeRemoveValue(*(void *)(a1 + 8), __s, (v28 + 1));
            if (!v8)
            {
LABEL_16:
              uint64_t v8 = 0;
              *(_WORD *)(a1 + 32) = 1;
            }
          }
        }
      }
    }
  }
  return v8;
}

uint64_t BOMBomVIndexGetApproxDiskSpace(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, unsigned int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!a2 && !a3 && !a4)
  {
    uint64_t result = 0;
    unsigned int v11 = *(_DWORD *)(a1 + 28);
LABEL_6:
    *a5 = v11;
    return result;
  }
  uint64_t result = 1;
  if (a4 && a2 && a3 && a5)
  {
    *a5 = 0;
    if (BOMCKTreeBuildKey(__s, (uint64_t)a2, a3, a4, (uint64_t)a5, a6, a7, a8, a2)) {
      return 1;
    }
    size_t v12 = strlen(__s) + 1;
    if (*(void *)(a1 + 40))
    {
      value = 0;
      CFDataRef v13 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const UInt8 *)__s, v12);
      if (!v13)
      {
        uint64_t v15 = (FILE *)*MEMORY[0x263EF8348];
        size_t v16 = __error();
        uint64_t v17 = strerror(*v16);
        fprintf(v15, "CFDataCreate: %s\n", v17);
        return 1;
      }
      CFDataRef v14 = v13;
      if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 40), v13, (const void **)&value))
      {
        *a5 = value;
        CFRelease(v14);
        return 0;
      }
      CFRelease(v14);
    }
    unint64_t v18 = BOMTreeGetValue(*(void *)(a1 + 8), __s, v12);
    if (v18)
    {
      uint64_t v19 = (unsigned int *)v18;
      uint64_t result = 0;
      unsigned int v11 = bswap32(*v19);
      goto LABEL_6;
    }
    return 1;
  }
  return result;
}

uint64_t BOMBomVIndexSetApproxDiskSpace(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  unsigned int v8 = a5;
  if (!a2 && !a3 && !a4)
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 28) = a5;
    *(_WORD *)(a1 + 32) = 257;
    return result;
  }
  uint64_t result = 1;
  if (a2 && a3 && a4)
  {
    if (!BOMCKTreeBuildKey(__s, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a2)) {
      return BOMBomVIndexSetApproxDiskSpaceWithKey(a1, __s, v8);
    }
    return 1;
  }
  return result;
}

uint64_t BOMBomVIndexSetApproxDiskSpaceWithKey(uint64_t a1, char *__s, unsigned int a3)
{
  uint64_t result = 1;
  if (a1 && __s)
  {
    size_t v7 = strlen(__s) + 1;
    if (BOMStorageIsOpenForWriting(*(void *)(a1 + 16)))
    {
      unsigned int v15 = bswap32(a3);
      uint64_t result = BOMTreeSetValue(*(void **)(a1 + 8), __s, v7, (uint64_t)&v15, 4);
      if (!result)
      {
        *(_WORD *)(a1 + 32) = 257;
        return result;
      }
    }
    else
    {
      CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      if (*(void *)(a1 + 40)
        || (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], 0),
            (*(void *)(a1 + 40) = Mutable) != 0))
      {
        CFDataRef v10 = CFDataCreate(v8, (const UInt8 *)__s, v7);
        if (v10)
        {
          CFDataRef v11 = v10;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v10, (const void *)a3);
          CFRelease(v11);
          uint64_t result = 0;
          *(unsigned char *)(a1 + 33) = 1;
          return result;
        }
        uint64_t v12 = (FILE *)*MEMORY[0x263EF8348];
        CFDataRef v13 = __error();
        CFDataRef v14 = strerror(*v13);
        fprintf(v12, "CFDataCreate: %s\n", v14);
      }
    }
    return 1;
  }
  return result;
}

uint64_t BOMBomVIndexDiskSpaceKey(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t result = 1;
  if (a1 && a2 && a3 && a4)
  {
    if (BOMCKTreeBuildKey(__s, (uint64_t)a2, a3, a4, (uint64_t)a5, a6, a7, a8, a2)) {
      return 1;
    }
    size_t v11 = strlen(__s) + 1;
    uint64_t v12 = BOM_malloc(v11);
    *a5 = v12;
    if (!v12)
    {
      return 1;
    }
    else
    {
      memmove(v12, __s, v11);
      return 0;
    }
  }
  return result;
}

uint64_t BOMBomVIndexDiskSpaceInfoIsValid(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 33);
  }
  return result;
}

uint64_t BOMBomVIndexInvalidateDiskSpace(uint64_t result)
{
  *(_WORD *)(result + 32) = 1;
  return result;
}

uint64_t _BOMBomVIndexPrintDiagnostics(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (result)
  {
    uint64_t v8 = result;
    uint64_t result = BOMCKTreeBuildKey(__s, a2, a3, a4, a5, a6, a7, a8, "path");
    if (!result)
    {
      int v9 = strlen(__s);
      CFDataRef v10 = (FILE **)MEMORY[0x263EF8348];
      fprintf((FILE *)*MEMORY[0x263EF8348], "Tree: %s\n", "VIndex");
      int v11 = BOMTreeCount(*(void *)(v8 + 8));
      uint64_t result = (uint64_t)BOMTreeIteratorNew(*(void *)(v8 + 8), 0, 0, 0);
      if (result)
      {
        uint64_t v12 = (char *)result;
        int v13 = 0;
        while (!BOMTreeIteratorIsAtEnd((uint64_t)v12))
        {
          uint64_t v14 = (const char *)BOMTreeIteratorKey((uint64_t)v12);
          if (!BOM_strrncmp(v14, __s, v9))
          {
            int v15 = strlen(v14);
            uint64_t result = BOMTreeGetValue(*(void *)(v8 + 8), v14, (v15 + 1));
            if (!result) {
              return result;
            }
            size_t v16 = (unsigned int *)result;
            uint64_t v17 = BOMTreeStorage(*(void *)(v8 + 8));
            uint64_t result = BOMTreeOpen(v17, bswap32(*v16), 0);
            if (!result) {
              return result;
            }
            uint64_t v18 = result;
            v13 += BOMTreeCount(result);
            BOMTreeFree(v18);
          }
          BOMTreeIteratorNext((uint64_t)v12);
        }
        BOMTreeIteratorFree(v12);
        fprintf(*v10, " i # records: %d\n", v11);
        fprintf(*v10, " i # pages  : %d (%d)\n", 0, 0);
        fprintf(*v10, "   i leaf   : %d (%d)\n", 0, 0);
        fprintf(*v10, "   i branch : %d (%d)\n", 0, 0);
        fprintf(*v10, " i key size : %zd\n", 0);
        fprintf(*v10, " i data size: %zd\n", 0);
        fprintf(*v10, "   # records: %d\n", v13);
        fprintf(*v10, "   # pages  : %d (%d)\n", 0, 0);
        fprintf(*v10, "     leaf   : %d (%d)\n", 0, 0);
        fprintf(*v10, "     branch : %d (%d)\n", 0, 0);
        fprintf(*v10, "   key size : %zd\n", 0);
        return fprintf(*v10, "   data size: %zd\n", 0);
      }
    }
  }
  return result;
}

double byte_stream_new(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v3 = platform_calloc(a1, 1uLL, 0x50uLL);
    if (v3)
    {
      *(_DWORD *)uint64_t v3 = 1651733613;
      v3[1] = a1;
      *(void *)&double result = 0x200000002;
      v3[2] = 0x200000002;
      *((_DWORD *)v3 + 18) = 1836348258;
    }
  }
  return result;
}

void byte_stream_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1651733613 && *((_DWORD *)__b + 18) == 1836348258)
  {
    int v2 = (void *)__b[7];
    if (v2) {
      platform_free(__b[1], v2);
    }
    uint64_t v3 = __b[1];
    platform_memset(v3, __b, 0, 0x50uLL);
    platform_free(v3, __b);
  }
}

uint64_t byte_stream_attach(uint64_t result, uint64_t a2, unint64_t a3)
{
  if (result && *(_DWORD *)result == 1651733613 && *(_DWORD *)(result + 72) == 1836348258)
  {
    if (a3 < 0xE8D4A51001)
    {
      *(unsigned char *)(result + 24) = 0;
      *(void *)(result + 40) = a3;
      *(void *)(result + 48) = 0;
      *(void *)(result + 32) = a2;
    }
    else
    {
      *(unsigned char *)(result + 24) = 1;
    }
  }
  return result;
}

BOOL byte_stream_exception(BOOL result)
{
  if (result) {
    return *(_DWORD *)result == 1651733613 && *(_DWORD *)(result + 72) == 1836348258 && *(unsigned char *)(result + 24) != 0;
  }
  return result;
}

_DWORD *byte_stream_set_byte_order(_DWORD *result, int a2)
{
  if (result && *result == 1651733613 && result[18] == 1836348258) {
    result[5] = a2;
  }
  return result;
}

uint64_t byte_stream_read_uint8(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1651733613 && *(_DWORD *)(a1 + 72) == 1836348258 && !*(unsigned char *)(a1 + 24))
  {
    uint64_t v1 = *(void *)(a1 + 48);
    uint64_t v2 = v1 + 1;
    if ((unint64_t)(v1 + 1) <= *(void *)(a1 + 40))
    {
      uint64_t v3 = *(unsigned __int8 *)(*(void *)(a1 + 32) + v1);
      *(void *)(a1 + 48) = v2;
      return v3;
    }
    *(unsigned char *)(a1 + 24) = 1;
  }
  return 255;
}

uint64_t byte_stream_read_uint16(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(unsigned char *)(a1 + 24)) {
      return (unsigned __int16)-1;
    }
    uint64_t v2 = *(void *)(a1 + 48);
    if ((unint64_t)(v2 + 2) > *(void *)(a1 + 40))
    {
      *(unsigned char *)(a1 + 24) = 1;
      return (unsigned __int16)-1;
    }
    unsigned __int16 __dst = 0;
    platform_memcpy(*(void *)(a1 + 8), &__dst, (void *)(*(void *)(a1 + 32) + v2), 2uLL);
    *(void *)(a1 + 48) += 2;
    unsigned int v5 = bswap32(__dst) >> 16;
    if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20)) {
      return __dst;
    }
    else {
      return (unsigned __int16)v5;
    }
  }
  else
  {
    return (unsigned __int16)-1;
  }
}

uint64_t byte_stream_read_uint32(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(unsigned char *)(a1 + 24)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  if ((unint64_t)(v2 + 4) > *(void *)(a1 + 40))
  {
    *(unsigned char *)(a1 + 24) = 1;
    return 0xFFFFFFFFLL;
  }
  unsigned int __dst = 0;
  platform_memcpy(*(void *)(a1 + 8), &__dst, (void *)(*(void *)(a1 + 32) + v2), 4uLL);
  *(void *)(a1 + 48) += 4;
  unsigned int v4 = bswap32(__dst);
  if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20)) {
    return __dst;
  }
  else {
    return v4;
  }
}

unint64_t byte_stream_read_uint64(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(unsigned char *)(a1 + 24)) {
    return -1;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  if ((unint64_t)(v2 + 8) > *(void *)(a1 + 40))
  {
    *(unsigned char *)(a1 + 24) = 1;
    return -1;
  }
  unint64_t __dst = 0;
  platform_memcpy(*(void *)(a1 + 8), &__dst, (void *)(*(void *)(a1 + 32) + v2), 8uLL);
  *(void *)(a1 + 48) += 8;
  unint64_t v4 = bswap64(__dst);
  if (*(_DWORD *)(a1 + 16) == *(_DWORD *)(a1 + 20)) {
    return __dst;
  }
  else {
    return v4;
  }
}

uint64_t *byte_stream_read_buffer(uint64_t *result, void *a2, size_t __n)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(_DWORD *)result == 1651733613 && *((_DWORD *)result + 18) == 1836348258 && !*((unsigned char *)result + 24))
    {
      if (!a2) {
        goto LABEL_8;
      }
      if (!__n) {
        return result;
      }
      uint64_t v5 = result[6];
      if (v5 + __n <= result[5])
      {
        double result = (uint64_t *)platform_memcpy(result[1], a2, (void *)(result[4] + v5), __n);
        v3[6] += __n;
      }
      else
      {
LABEL_8:
        *((unsigned char *)result + 24) = 1;
      }
    }
  }
  return result;
}

uint64_t byte_stream_read_string(uint64_t a1, size_t a2, uint64_t a3)
{
  if (!a1) {
    return -1;
  }
  if (*(_DWORD *)a1 != 1651733613 || *(_DWORD *)(a1 + 72) != 1836348258 || *(unsigned char *)(a1 + 24)) {
    return -1;
  }
  if (*(void *)(a1 + 48) + a2 > *(void *)(a1 + 40)) {
    goto LABEL_6;
  }
  size_t v7 = a2 + 1;
  size_t v8 = *(void *)(a1 + 64);
  if (v8 >= a2 + 1)
  {
    platform_memset(*(void *)(a1 + 8), *(void **)(a1 + 56), 0, v8);
    CFDataRef v10 = *(void **)(a1 + 56);
  }
  else
  {
    int v9 = *(void **)(a1 + 56);
    if (v9) {
      platform_free(*(void *)(a1 + 8), v9);
    }
    *(void *)(a1 + 64) = v7;
    CFDataRef v10 = platform_calloc(*(void *)(a1 + 8), a2 + 1, 1uLL);
    *(void *)(a1 + 56) = v10;
    if (!v10)
    {
      *(unsigned char *)(a1 + 24) = 1;
      return -1;
    }
  }
  byte_stream_read_buffer((uint64_t *)a1, v10, a2);
  if (*(unsigned char *)(a1 + 24)) {
    return -1;
  }
  __endptr = 0;
  uint64_t result = platform_strtoq(*(void *)(a1 + 8), *(char **)(a1 + 56), &__endptr, a3);
  if (!result)
  {
    if (!*__error()) {
      return 0;
    }
LABEL_6:
    *(unsigned char *)(a1 + 24) = 1;
    return -1;
  }
  return result;
}

uint64_t byte_stream_remaining(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1651733613 && *(_DWORD *)(a1 + 72) == 1836348258) {
    return *(void *)(a1 + 40) - *(void *)(a1 + 48);
  }
  else {
    return -1;
  }
}

uint64_t byte_stream_advance(uint64_t result, uint64_t a2)
{
  if (result && *(_DWORD *)result == 1651733613 && *(_DWORD *)(result + 72) == 1836348258 && !*(unsigned char *)(result + 24))
  {
    unint64_t v2 = *(void *)(result + 48) + a2;
    if (v2 <= *(void *)(result + 40)) {
      *(void *)(result + 48) = v2;
    }
    else {
      *(unsigned char *)(result + 24) = 1;
    }
  }
  return result;
}

void *data_archive_decoder_new(uint64_t a1, uint64_t a2)
{
  if (!a2)
  {
    uint64_t v5 = platform_calloc(a1, 1uLL, 0x60uLL);
    unint64_t v2 = v5;
    if (!v5) {
      return v2;
    }
    *(_DWORD *)uint64_t v5 = 1919315316;
    v5[1] = a1;
    byte_stream_new(a1, 0);
    v2[3] = v6;
    if (v6)
    {
      *((_DWORD *)v2 + 23) = 1953326706;
      return v2;
    }
    free(v2);
  }
  return 0;
}

void data_archive_decoder_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1919315316 && *((_DWORD *)__b + 23) == 1953326706)
  {
    unint64_t v2 = (void *)__b[5];
    if (v2) {
      platform_free(__b[1], v2);
    }
    uint64_t v3 = (void *)__b[3];
    if (v3) {
      byte_stream_free(v3);
    }
    uint64_t v4 = __b[1];
    platform_memset(v4, __b, 0, 0x60uLL);
    platform_free(v4, __b);
  }
}

uint64_t data_archive_decoder_set_stream(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1919315316) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && *(_DWORD *)(a1 + 92) == 1953326706)
  {
    *(void *)(a1 + 16) = a2;
    *(void *)(a1 + 32) = 0x20000;
    uint64_t v6 = platform_valloc(*(void *)(a1 + 8), 0x20000uLL);
    *(void *)(a1 + 40) = v6;
    if (!v6)
    {
      int v13 = __error();
      unsigned __int8 v14 = strerror(*v13);
      CFDataRef v10 = "Could not allocate read buffer: %s";
      char v23 = v14;
      int v11 = a3;
      int v12 = 409;
      goto LABEL_10;
    }
    *(void *)(a1 + 48) = v6;
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    if (populate_read_buffer(a1, *(void *)(a1 + 32), a3))
    {
      CFDataRef v10 = "Could not populate the read buffer";
      int v11 = a3;
      int v12 = 425;
LABEL_10:
      capture_error(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v12, (uint64_t)"data_archive_decoder_set_stream", v10, v7, v8, v9, v23);
      return 0xFFFFFFFFLL;
    }
    if (!*(void *)(a1 + 72)) {
      return 0;
    }
    uint64_t v15 = *(void *)(a1 + 48);
    unint64_t v16 = *(void *)(a1 + 64);
    if (v16 < 0x200)
    {
LABEL_15:
      if (!*(_DWORD *)(a1 + 84))
      {
        if (check_cpio_header(a1, v15, v16, a3))
        {
          CFDataRef v10 = "Could not check for a cpio header";
          int v11 = a3;
          int v12 = 461;
          goto LABEL_10;
        }
        if (!*(_DWORD *)(a1 + 84))
        {
          uint64_t result = is_pkzip_header(a1, v15, v16);
          if (result)
          {
            uint64_t result = 0;
            *(_DWORD *)(a1 + 84) = 9;
          }
          return result;
        }
      }
      return 0;
    }
    byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), *(void *)(a1 + 64));
    byte_stream_advance(*(void *)(a1 + 24), 257);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not advance to the magic offset";
      uint64_t v21 = a3;
      int v22 = 805;
    }
    else
    {
      byte_stream_read_buffer(*(uint64_t **)(a1 + 24), __s1, 6uLL);
      if (byte_stream_exception(*(void *)(a1 + 24)))
      {
        uint64_t v20 = "Could not read the potential magic value";
        uint64_t v21 = a3;
        int v22 = 815;
      }
      else
      {
        byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v24, 2uLL);
        if (!byte_stream_exception(*(void *)(a1 + 24)))
        {
          if (!platform_memcmp(*(void *)(a1 + 8), __s1, "ustar", 6uLL)
            && !platform_memcmp(*(void *)(a1 + 8), v24, "00", 2uLL))
          {
            *(_DWORD *)(a1 + 84) = 2;
          }
          goto LABEL_15;
        }
        uint64_t v20 = "Could not read the potential version value";
        uint64_t v21 = a3;
        int v22 = 825;
      }
    }
    capture_error(v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v22, (uint64_t)"check_tar_posix_header", v20, v17, v18, v19, v23);
    CFDataRef v10 = "Could not check for a tar POSIX header";
    int v11 = a3;
    int v12 = 445;
    goto LABEL_10;
  }
  return result;
}

uint64_t populate_read_buffer(uint64_t a1, size_t a2, void *a3)
{
  size_t v4 = *(void *)(a1 + 64);
  if (v4 >= a2) {
    return 0;
  }
  uint64_t v6 = *(void **)(a1 + 40);
  if (v4)
  {
    memmove(v6, *(const void **)(a1 + 48), v4);
    uint64_t v6 = *(void **)(a1 + 40);
    *(void *)(a1 + 48) = v6;
    uint64_t v7 = *(void *)(a1 + 64);
  }
  else
  {
    uint64_t v7 = 0;
    *(void *)(a1 + 48) = v6;
  }
  size_t v8 = *(void *)(a1 + 32) - v7;
  unint64_t v9 = data_stream_read(*(void *)(a1 + 16), (char *)v6 + v7, v8);
  if (v9 == -1)
  {
    int v12 = __error();
    strerror(*v12);
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 4061, (uint64_t)"populate_read_buffer", "Could not read additional %ld bytes onto read buffer: %s\n", v13, v14, v15, v8);
    return 0xFFFFFFFFLL;
  }
  else
  {
    int64x2_t v10 = vaddq_s64(*(int64x2_t *)(a1 + 64), vdupq_n_s64(v9));
    *(int64x2_t *)(a1 + 64) = v10;
    if (v10.i64[0]) {
      return 0;
    }
    uint64_t result = 0;
    *(unsigned char *)(a1 + 80) = 1;
  }
  return result;
}

uint64_t check_cpio_header(uint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  if (a3 < 2) {
    return 0;
  }
  byte_stream_attach(*(void *)(a1 + 24), a2, a3);
  int uint16 = byte_stream_read_uint16(*(void *)(a1 + 24));
  if (byte_stream_exception(*(void *)(a1 + 24)))
  {
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 867, (uint64_t)"check_cpio_header", "Could not read the potential binary magic value", v11, v12, v13, v4);
    return 0xFFFFFFFFLL;
  }
  if (uint16 == 51057)
  {
    uint64_t result = 0;
    int v14 = 8;
    goto LABEL_9;
  }
  if (uint16 == 29127)
  {
    uint64_t result = 0;
    int v14 = 7;
LABEL_9:
    *(_DWORD *)(a1 + 84) = v14;
    return result;
  }
  if (a3 < 6) {
    return 0;
  }
  byte_stream_attach(*(void *)(a1 + 24), a2, a3);
  uint64_t string = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
  if (byte_stream_exception(*(void *)(a1 + 24))) {
    return 0;
  }
  uint64_t result = 0;
  if (string > 29126)
  {
    if (string == 29143)
    {
      uint64_t result = 0;
      int v14 = 4;
      goto LABEL_9;
    }
    if (string == 29127)
    {
      uint64_t result = 0;
      int v14 = 3;
      goto LABEL_9;
    }
  }
  else
  {
    if (string == 29121)
    {
      uint64_t result = 0;
      int v14 = 6;
      goto LABEL_9;
    }
    if (string == 29122)
    {
      uint64_t result = 0;
      int v14 = 5;
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t is_pkzip_header(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 < 4) {
    return 0;
  }
  byte_stream_attach(*(void *)(a1 + 24), a2, a3);
  int uint32 = byte_stream_read_uint32(*(void *)(a1 + 24));
  uint64_t result = 1;
  if (uint32 <= 101075791)
  {
    BOOL v6 = uint32 == 67324752;
    int v7 = 101010256;
  }
  else
  {
    BOOL v6 = uint32 == 101075792 || uint32 == 134695760;
    int v7 = 808471376;
  }
  if (!v6 && uint32 != v7) {
    return 0;
  }
  return result;
}

uint64_t data_archive_decoder_get_type(_DWORD *a1)
{
  if (a1 && *a1 == 1919315316 && a1[23] == 1953326706) {
    return a1[21];
  }
  puts("Invalid decoder?");
  return 0;
}

void *data_archive_decoder_read_entry(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1919315316 || *(_DWORD *)(a1 + 92) != 1953326706)
  {
    int64x2_t v10 = "Invalid decoder";
    uint64_t v11 = a2;
    int v12 = 527;
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 89))
  {
    int64x2_t v10 = "End of archive";
    uint64_t v11 = a2;
    int v12 = 537;
LABEL_7:
    capture_error(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v12, (uint64_t)"data_archive_decoder_read_entry", v10, a6, a7, a8, v28);
    return 0;
  }
  if (!*(void *)(a1 + 64) && populate_read_buffer(a1, *(void *)(a1 + 32), a2))
  {
    int64x2_t v10 = "Could not populate the read buffer";
    uint64_t v11 = a2;
    int v12 = 550;
    goto LABEL_7;
  }
  uint64_t v15 = darc_format_entry_new(*(void *)(a1 + 8), 0);
  uint64_t v13 = v15;
  if (!v15)
  {
    capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 562, (uint64_t)"data_archive_decoder_read_entry", "Could not create empty data format entry", v18, v19, v20, v28);
    return v13;
  }
  if (*(unsigned char *)(a1 + 80))
  {
    if (!darc_format_entry_set_type(v15, 1))
    {
      *(unsigned char *)(a1 + 89) = 1;
      return v13;
    }
    uint64_t v24 = "Could not set EoA entry type";
    uint64_t v25 = a2;
    int v26 = 575;
    goto LABEL_15;
  }
  int v27 = *(_DWORD *)(a1 + 84);
  if (v27 == 9)
  {
    if (!parse_entry_pkzip(a1, v15, a2)) {
      return v13;
    }
    uint64_t v24 = "Could not parse PKZip entry";
    uint64_t v25 = a2;
    int v26 = 620;
    goto LABEL_15;
  }
  if (v27 == 3)
  {
    if (!parse_entry_cpio(a1, v15, a2, v16, v17, v18, v19, v20)) {
      return v13;
    }
    uint64_t v24 = "Could not parse CPIO ASCII entry";
    uint64_t v25 = a2;
    int v26 = 609;
    goto LABEL_15;
  }
  if (v27 != 2)
  {
    capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 628, (uint64_t)"data_archive_decoder_read_entry", "Unknown data format: %d", v18, v19, v20, *(_DWORD *)(a1 + 84));
    return v13;
  }
  if (parse_entry_posix_ustar(a1, v15, a2))
  {
    uint64_t v24 = "Could not parse POSIX ustar entry";
    uint64_t v25 = a2;
    int v26 = 598;
LABEL_15:
    capture_error(v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v26, (uint64_t)"data_archive_decoder_read_entry", v24, v21, v22, v23, v28);
    darc_format_entry_free(v13);
    return 0;
  }
  return v13;
}

uint64_t parse_entry_posix_ustar(uint64_t a1, _DWORD *a2, void *a3)
{
  uint64_t v75 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a1 + 56);
  if (require_minimum_amount(a1, 0x200uLL, (char)"POSIX ustar header", a3))
  {
    int64x2_t v10 = "Minimum amount necessary for POSIX ustar header is unavailable";
    uint64_t v11 = a3;
    int v12 = 1022;
LABEL_3:
    capture_error(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v12, (uint64_t)"parse_entry_posix_ustar", v10, v7, v8, v9, v53);
    return 0xFFFFFFFFLL;
  }
  int v14 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x28uLL);
  if (!v14)
  {
    uint64_t v23 = __error();
    strerror(*v23);
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1030, (uint64_t)"parse_entry_posix_ustar", "Could not allocate %ld bytes for POSIX ustar header: %s", v24, v25, v26, 40);
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = v14;
  uint64_t v16 = *(unsigned char **)(a1 + 48);
  if (*v16)
  {
LABEL_8:
    *int v14 = 2;
    byte_stream_attach(*(void *)(a1 + 24), (uint64_t)v16, 0x200uLL);
    memset(__s, 0, sizeof(__s));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), __s, 0x64uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar name field";
      uint64_t v21 = a3;
      int v22 = 1113;
      goto LABEL_101;
    }
    size_t v30 = strlen(__s);
    if (darc_format_entry_set_attribute((uint64_t)a2, "name", __s, v30 + 1))
    {
      uint64_t v20 = "Could not set name attribute";
      uint64_t v21 = a3;
      int v22 = 1123;
      goto LABEL_101;
    }
    __int16 string = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar mode field";
      uint64_t v21 = a3;
      int v22 = 1134;
      goto LABEL_101;
    }
    *((_WORD *)v15 + 2) = string | 0x8000;
    int v32 = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar uid field";
      uint64_t v21 = a3;
      int v22 = 1148;
      goto LABEL_101;
    }
    v15[2] = v32;
    int v33 = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar gid field";
      uint64_t v21 = a3;
      int v22 = 1161;
      goto LABEL_101;
    }
    v15[3] = v33;
    uint64_t v34 = byte_stream_read_string(*(void *)(a1 + 24), 0xCuLL, 8);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar size field";
      uint64_t v21 = a3;
      int v22 = 1174;
      goto LABEL_101;
    }
    *((void *)v15 + 2) = v34;
    uint64_t v35 = byte_stream_read_string(*(void *)(a1 + 24), 0xCuLL, 8);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar mtime field";
      uint64_t v21 = a3;
      int v22 = 1187;
      goto LABEL_101;
    }
    *((void *)v15 + 3) = v35;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v73, 8uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar checksum field";
      uint64_t v21 = a3;
      int v22 = 1202;
      goto LABEL_101;
    }
    char v58 = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), &v58, 1uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar type flag field";
      uint64_t v21 = a3;
      int v22 = 1215;
      goto LABEL_101;
    }
    if (v58 > 102)
    {
      if (v58 == 103)
      {
        int v36 = 0;
        int v37 = 1;
      }
      else
      {
        if (v58 != 120)
        {
LABEL_43:
          if ((v58 - 65) > 0x19)
          {
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1302, (uint64_t)"parse_entry_posix_ustar_header_decode", "Unrecognize tar type flag value: %c", v17, v18, v19, v58);
LABEL_102:
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1037, (uint64_t)"parse_entry_posix_ustar", "Could not decode POSIX ustar header", v42, v43, v44, v54);
            platform_free(*(void *)(a1 + 8), v15);
            return 0xFFFFFFFFLL;
          }
          *__error() = 45;
          uint64_t v20 = "Vendor specific extensions (POSIX.1-1988)";
          uint64_t v21 = a3;
          int v22 = 1298;
LABEL_101:
          capture_error(v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v22, (uint64_t)"parse_entry_posix_ustar_header_decode", v20, v17, v18, v19, v53);
          goto LABEL_102;
        }
        int v37 = 0;
        int v36 = 1;
      }
    }
    else
    {
      int v36 = 0;
      int v37 = 0;
      switch(v58)
      {
        case '0':
        case '1':
          break;
        case '2':
          int v36 = 0;
          int v37 = 0;
          __int16 v38 = *((_WORD *)v15 + 2) | 0xA000;
          goto LABEL_50;
        case '3':
          int v36 = 0;
          int v37 = 0;
          __int16 v38 = v15[1] & 0x5FFF | 0x2000;
          goto LABEL_50;
        case '4':
          int v36 = 0;
          int v37 = 0;
          __int16 v39 = v15[1] & 0x1FFF | 0x6000;
          goto LABEL_48;
        case '5':
          int v36 = 0;
          int v37 = 0;
          __int16 v39 = v15[1] & 0x3FFF | 0x4000;
LABEL_48:
          *((_WORD *)v15 + 2) = v39;
          break;
        case '6':
          int v36 = 0;
          int v37 = 0;
          __int16 v38 = v15[1] & 0x6FFF | 0x1000;
LABEL_50:
          *((_WORD *)v15 + 2) = v38;
          break;
        case '7':
          *__error() = 45;
          uint64_t v20 = "I do not support contiguous files";
          uint64_t v21 = a3;
          int v22 = 1277;
          goto LABEL_101;
        default:
          if (v58) {
            goto LABEL_43;
          }
          break;
      }
    }
    memset(v72, 0, sizeof(v72));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v72, 0x64uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar linkname field";
      uint64_t v21 = a3;
      int v22 = 1316;
      goto LABEL_101;
    }
    int v40 = v37;
    size_t v41 = strlen(v72);
    if (v41 && darc_format_entry_set_attribute((uint64_t)a2, "tar linkname", v72, v41 + 1))
    {
      uint64_t v20 = "Could not set linkname attribute";
      uint64_t v21 = a3;
      int v22 = 1328;
      goto LABEL_101;
    }
    __int16 v57 = 0;
    int __s1 = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), &__s1, 6uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar magic field";
      uint64_t v21 = a3;
      int v22 = 1342;
      goto LABEL_101;
    }
    if (platform_memcmp(*(void *)(a1 + 8), &__s1, "ustar", 6uLL))
    {
      uint64_t v20 = "Invalid magic for POSIX ustar archive";
      uint64_t v21 = a3;
      int v22 = 1348;
      goto LABEL_101;
    }
    __int16 v55 = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), &v55, 2uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the tar version field";
      uint64_t v21 = a3;
      int v22 = 1361;
      goto LABEL_101;
    }
    if (platform_memcmp(*(void *)(a1 + 8), &v55, "00", 2uLL))
    {
      uint64_t v20 = "Invalid version for POSIX ustar archive";
      uint64_t v21 = a3;
      int v22 = 1367;
      goto LABEL_101;
    }
    memset(v71, 0, sizeof(v71));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v71, 0x20uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar uname field";
      uint64_t v21 = a3;
      int v22 = 1380;
      goto LABEL_101;
    }
    size_t v45 = strlen((const char *)v71);
    if (v45 && darc_format_entry_set_attribute((uint64_t)a2, "POSIX ustar user name", v71, v45 + 1))
    {
      uint64_t v20 = "Could not set POSIX ustar user name attribute";
      uint64_t v21 = a3;
      int v22 = 1392;
      goto LABEL_101;
    }
    memset(v70, 0, sizeof(v70));
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v70, 0x20uLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar group name field";
      uint64_t v21 = a3;
      int v22 = 1406;
      goto LABEL_101;
    }
    size_t v46 = strlen((const char *)v70);
    if (v46 && darc_format_entry_set_attribute((uint64_t)a2, "POSIX ustar group name", v70, v46 + 1))
    {
      uint64_t v20 = "Could not set POSIX ustar group name attribute";
      uint64_t v21 = a3;
      int v22 = 1418;
      goto LABEL_101;
    }
    int v47 = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar devmajor field";
      uint64_t v21 = a3;
      int v22 = 1430;
      goto LABEL_101;
    }
    v15[8] = v47;
    int v48 = byte_stream_read_string(*(void *)(a1 + 24), 8uLL, 8);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar devminor field";
      uint64_t v21 = a3;
      int v22 = 1443;
      goto LABEL_101;
    }
    v15[9] = v48;
    long long v68 = 0u;
    memset(v69, 0, sizeof(v69));
    long long v66 = 0u;
    long long v67 = 0u;
    long long v64 = 0u;
    long long v65 = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    *(_OWORD *)uint64_t v61 = 0u;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v61, 0x9BuLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar prefix field";
      uint64_t v21 = a3;
      int v22 = 1458;
      goto LABEL_101;
    }
    size_t v49 = strlen(v61);
    if (v49)
    {
      size_t v50 = v49;
      bzero(__str, 0x400uLL);
      if (v61[v50] == 47) {
        snprintf(__str, 0x400uLL, "%s%s");
      }
      else {
        snprintf(__str, 0x400uLL, "%s/%s");
      }
      size_t v51 = strlen(__str);
      if (darc_format_entry_set_attribute((uint64_t)a2, "name", __str, v51 + 1))
      {
        uint64_t v20 = "Could not reset POSIX ustar name attribute";
        uint64_t v21 = a3;
        int v22 = 1482;
        goto LABEL_101;
      }
    }
    int v60 = 0;
    *(void *)__str = 0;
    byte_stream_read_buffer(*(uint64_t **)(a1 + 24), __str, 0xCuLL);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v20 = "Could not parse the POSIX ustar padding field";
      uint64_t v21 = a3;
      int v22 = 1496;
      goto LABEL_101;
    }
    *(void *)(a1 + 48) += 512;
    *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662800);
    if (v40)
    {
      *uint64_t v15 = 3;
      *__error() = 45;
      uint64_t v20 = "This entry has global extended metadata";
      uint64_t v21 = a3;
      int v22 = 1512;
      goto LABEL_101;
    }
    if (v36)
    {
      *uint64_t v15 = 4;
      if (parse_entry_posix_ustar_extended_metadata(a1, *((void *)v15 + 2), a3))
      {
        uint64_t v20 = "Could not parse the POSIX ustar extended metadata";
        uint64_t v21 = a3;
        int v22 = 1527;
        goto LABEL_101;
      }
    }
    else
    {
      uint64_t v52 = *((void *)v15 + 2);
      if (v52 >= 1 && darc_format_entry_set_size((uint64_t)a2, v52))
      {
        uint64_t v20 = "Could not set entry size";
        uint64_t v21 = a3;
        int v22 = 1543;
        goto LABEL_101;
      }
    }
    if (darc_format_entry_set_type(a2, 2))
    {
      uint64_t v20 = "Could not set entry type";
      uint64_t v21 = a3;
      int v22 = 1553;
      goto LABEL_101;
    }
  }
  else
  {
    uint64_t v27 = 1;
    while (v27 != 512)
    {
      if (v16[v27++])
      {
        if ((unint64_t)(v27 - 2) < 0x1FF) {
          goto LABEL_8;
        }
        break;
      }
    }
    darc_format_entry_set_type(a2, 3);
    *uint64_t v15 = 1;
    *(void *)(a1 + 48) += 512;
    *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662800);
  }
  int v29 = darc_format_entry_set_attribute((uint64_t)a2, "POSIX ustar header", v15, 0x28uLL);
  platform_free(*(void *)(a1 + 8), v15);
  if (v29)
  {
    int64x2_t v10 = "Could not set POSIX ustar header attribute";
    uint64_t v11 = a3;
    int v12 = 1052;
    goto LABEL_3;
  }
  uint64_t result = darc_format_entry_set_range((uint64_t)a2, v6, *(void *)(a1 + 56) - v6);
  if (result)
  {
    int64x2_t v10 = "Could not set entry range";
    uint64_t v11 = a3;
    int v12 = 1065;
    goto LABEL_3;
  }
  return result;
}

uint64_t parse_entry_cpio(uint64_t a1, _DWORD *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a1 + 56);
  if (!*(unsigned char *)(a1 + 88))
  {
    if (require_minimum_amount(a1, 0x4CuLL, (char)"cpio header", a3))
    {
      uint64_t v16 = "parse_entry_cpio_header";
      uint64_t v17 = "Minimum amount necessary for CPIO header is unavailable";
      uint64_t v18 = a3;
      int v19 = 1655;
LABEL_12:
      capture_error(v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v19, (uint64_t)v16, v17, a6, a7, a8, v51);
      return 0xFFFFFFFFLL;
    }
    uint64_t v21 = (uint64_t *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x48uLL);
    if (!v21)
    {
      int v29 = __error();
      strerror(*v29);
      capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1663, (uint64_t)"parse_entry_cpio_header", "Could not allocate %ld bytes for cpio_header: %s", v30, v31, v32, 72);
      return 0xFFFFFFFFLL;
    }
    int v22 = v21;
    byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x4CuLL);
    uint64_t *v22 = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
    *((_DWORD *)v22 + 2) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
    v22[2] = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
    *((_WORD *)v22 + 12) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
    *((_DWORD *)v22 + 7) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
    *((_DWORD *)v22 + 8) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
    *((_WORD *)v22 + 18) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
    *((_DWORD *)v22 + 10) = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
    v22[6] = byte_stream_read_string(*(void *)(a1 + 24), 0xBuLL, 8);
    v22[7] = byte_stream_read_string(*(void *)(a1 + 24), 6uLL, 8);
    v22[8] = byte_stream_read_string(*(void *)(a1 + 24), 0xBuLL, 8);
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v26 = "Could not parse the CPIO header";
      uint64_t v27 = a3;
      int v28 = 1743;
    }
    else if (*v22 == 29127)
    {
      *(void *)(a1 + 48) += 76;
      *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662810);
      uint64_t v33 = v22[8];
      if (v33 < 1 || !darc_format_entry_set_size((uint64_t)a2, v33))
      {
        size_t v37 = v22[7];
        if (v37)
        {
          if (require_minimum_amount(a1, v37, (char)"cpio entry name", a3))
          {
            uint64_t v26 = "Minimum amount necessary for CPIO name is unavailable";
            uint64_t v27 = a3;
            int v28 = 1785;
            goto LABEL_26;
          }
          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), v22[7]);
          __int16 v38 = platform_calloc(*(void *)(a1 + 8), v22[7], 1uLL);
          if (!v38)
          {
            uint64_t v43 = v22[7];
            uint64_t v44 = __error();
            strerror(*v44);
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1794, (uint64_t)"parse_entry_cpio_header_decode", "Could not allocate %ld bytes: %s", v45, v46, v47, v43);
            goto LABEL_27;
          }
          __int16 v39 = v38;
          byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v38, v22[7]);
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1802, (uint64_t)"parse_entry_cpio_header_decode", "Could not parse the CPIO name", v40, v41, v42, v51);
            free(v39);
            goto LABEL_27;
          }
          if (darc_format_entry_set_attribute((uint64_t)a2, "name", v39, v22[7]))
          {
            uint64_t v26 = "Could not set name attribute";
            uint64_t v27 = a3;
            int v28 = 1815;
            goto LABEL_26;
          }
          if (platform_strlen(*(void *)(a1 + 8), (char *)v39) == 10
            && !platform_strncmp(*(void *)(a1 + 8), (char *)v39, "TRAILER!!!", 0xAuLL))
          {
            *(unsigned char *)(a1 + 88) = 1;
          }
          platform_free(*(void *)(a1 + 8), v39);
          uint64_t v48 = v22[7];
          uint64_t v49 = *(void *)(a1 + 56) + v48;
          *(void *)(a1 + 48) += v48;
          *(void *)(a1 + 56) = v49;
          *(void *)(a1 + 64) -= v48;
        }
        int v50 = darc_format_entry_set_attribute((uint64_t)a2, "cpio header", v22, 0x48uLL);
        platform_free(*(void *)(a1 + 8), v22);
        if (v50)
        {
          uint64_t v16 = "parse_entry_cpio_header";
          uint64_t v17 = "Could not set cpio header attribute";
          uint64_t v18 = a3;
          int v19 = 1685;
        }
        else if (darc_format_entry_set_type(a2, 4))
        {
          uint64_t v16 = "parse_entry_cpio_header";
          uint64_t v17 = "Could not set entry type";
          uint64_t v18 = a3;
          int v19 = 1696;
        }
        else
        {
          uint64_t result = darc_format_entry_set_range((uint64_t)a2, v11, *(void *)(a1 + 56) - v11);
          if (!result) {
            return result;
          }
          uint64_t v16 = "parse_entry_cpio_header";
          uint64_t v17 = "Could not set entry range";
          uint64_t v18 = a3;
          int v19 = 1705;
        }
        goto LABEL_12;
      }
      uint64_t v26 = "Could not set entry size";
      uint64_t v27 = a3;
      int v28 = 1764;
    }
    else
    {
      uint64_t v26 = "Invalid CPIO magic: %lld";
      uint64_t v51 = *v22;
      uint64_t v27 = a3;
      int v28 = 1749;
    }
LABEL_26:
    capture_error(v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v28, (uint64_t)"parse_entry_cpio_header_decode", v26, v23, v24, v25, v51);
LABEL_27:
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1670, (uint64_t)"parse_entry_cpio_header", "Could not decode CPIO header", v34, v35, v36, v52);
    platform_free(*(void *)(a1 + 8), v22);
    return 0xFFFFFFFFLL;
  }
  while (!*(unsigned char *)(a1 + 80))
  {
    uint64_t v12 = *(void *)(a1 + 64);
    if (v12)
    {
      uint64_t v13 = v12 - 1;
      uint64_t v14 = *(void *)(a1 + 48) + 1;
      while (!*(unsigned char *)(v14 - 1))
      {
        uint64_t v15 = *(void *)(a1 + 56) + 1;
        *(void *)(a1 + 48) = v14;
        *(void *)(a1 + 56) = v15;
        *(void *)(a1 + 64) = v13--;
        ++v14;
        if (v13 == -1) {
          goto LABEL_7;
        }
      }
      uint64_t v16 = "parse_entry_cpio_padding";
      uint64_t v17 = "Could not populate the read buffer";
      uint64_t v18 = a3;
      int v19 = 1857;
      goto LABEL_12;
    }
LABEL_7:
    if (populate_read_buffer(a1, *(void *)(a1 + 32), a3))
    {
      uint64_t v16 = "parse_entry_cpio_padding";
      uint64_t v17 = "Could not populate the read buffer";
      uint64_t v18 = a3;
      int v19 = 1867;
      goto LABEL_12;
    }
  }
  if (darc_format_entry_set_type(a2, 5))
  {
    uint64_t v16 = "parse_entry_cpio_padding";
    uint64_t v17 = "Could not set entry type";
    uint64_t v18 = a3;
    int v19 = 1879;
    goto LABEL_12;
  }
  uint64_t result = darc_format_entry_set_range((uint64_t)a2, v11, *(void *)(a1 + 56) - v11);
  if (result)
  {
    uint64_t v16 = "parse_entry_cpio_padding";
    uint64_t v17 = "Could not set entry range";
    uint64_t v18 = a3;
    int v19 = 1888;
    goto LABEL_12;
  }
  return result;
}

uint64_t parse_entry_pkzip(uint64_t a1, _DWORD *a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  if (require_minimum_amount(a1, 4uLL, (char)"PKZip signature", a3)) {
    return 0xFFFFFFFFLL;
  }
  v104 = a2;
  v105 = a3;
  while (1)
  {
    byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 4uLL);
    int uint32 = byte_stream_read_uint32(*(void *)(a1 + 24));
    if (byte_stream_exception(*(void *)(a1 + 24)))
    {
      uint64_t v15 = "parse_entry_pkzip";
      uint64_t v16 = "Could not parse the PKZip entry";
      uint64_t v17 = a3;
      int v18 = 1936;
      goto LABEL_61;
    }
    if (uint32 > 101075791)
    {
      if (uint32 <= 134630223)
      {
        if (uint32 == 101075792)
        {
          uint64_t v31 = a3;
          if (require_minimum_amount(a1, 0x38uLL, (char)"PKZip ZIP64 end of central directory read", a3)) {
            return 0xFFFFFFFFLL;
          }
          uint64_t v30 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x40uLL);
          if (!v30)
          {
            uint64_t v48 = __error();
            strerror(*v48);
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3041, (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_record", "Could not allocate %ld bytes for PKZip ZIP64 central directory header: %s", v49, v50, v51, 64);
            return 0xFFFFFFFFLL;
          }
          int v22 = v30;
          byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x38uLL);
          *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
          v22[1] = byte_stream_read_uint64(*(void *)(a1 + 24));
          *((_WORD *)v22 + 8) = byte_stream_read_uint16(*(void *)(a1 + 24));
          *((_WORD *)v22 + 9) = byte_stream_read_uint16(*(void *)(a1 + 24));
          *((_DWORD *)v22 + 5) = byte_stream_read_uint32(*(void *)(a1 + 24));
          *((_DWORD *)v22 + 6) = byte_stream_read_uint32(*(void *)(a1 + 24));
          _OWORD v22[4] = byte_stream_read_uint64(*(void *)(a1 + 24));
          v22[5] = byte_stream_read_uint64(*(void *)(a1 + 24));
          v22[6] = byte_stream_read_uint64(*(void *)(a1 + 24));
          v22[7] = byte_stream_read_uint64(*(void *)(a1 + 24));
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
            uint64_t v24 = "Could not parse the PKZip ZIP64 end of central directory record";
            uint64_t v25 = a3;
            int v26 = 3062;
            goto LABEL_97;
          }
          if (*(_DWORD *)v22 != 101075792)
          {
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3069, (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_record", "Invalid PKZip ZIP64 end of central directory record signature: %04x", v9, v10, v11, *(_DWORD *)v22);
            goto LABEL_98;
          }
          uint64_t v61 = *(void *)(a1 + 48);
          uint64_t v62 = *(void *)(a1 + 56);
          *(void *)(a1 + 48) = v61 + 56;
          *(void *)(a1 + 56) = v62 + 56;
          uint64_t v63 = *(void *)(a1 + 64) - 56;
          *(void *)(a1 + 64) = v63;
          uint64_t v64 = v22[1];
          if (v64 - 56 >= 1)
          {
            *(void *)(a1 + 48) = v61 + v64;
            *(void *)(a1 + 56) = v64 + v62;
            *(void *)(a1 + 64) = v63 - (v64 - 56);
            uint64_t v15 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
            uint64_t v16 = "TODO: parse ZIP64 extensible data";
            uint64_t v17 = a3;
            int v18 = 3087;
            goto LABEL_61;
          }
          uint64_t v34 = (uint64_t)a2;
          if (!darc_format_entry_set_type(a2, 12))
          {
            if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip ZIP64 end of central directory record", v22, 0x40uLL))
            {
              uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
              uint64_t v24 = "Could not set PKZip ZIP64 end of central directory record attribute";
              uint64_t v25 = v105;
              int v26 = 3110;
              goto LABEL_97;
            }
            goto LABEL_124;
          }
          uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_record";
          uint64_t v24 = "Could not set entry type";
          uint64_t v25 = v105;
          int v26 = 3098;
          goto LABEL_97;
        }
        if (uint32 == 117853008)
        {
          uint64_t v31 = a3;
          if (require_minimum_amount(a1, 0x14uLL, (char)"PKZip ZIP64 end of central directory locator read", a3))return 0xFFFFFFFFLL; {
          uint64_t v33 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x18uLL);
          }
          if (!v33)
          {
            char v52 = __error();
            strerror(*v52);
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3155, (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_locator", "Could not allocate %ld bytes for PKZip ZIP64 central directory locator: %s", v53, v54, v55, 24);
            return 0xFFFFFFFFLL;
          }
          int v22 = v33;
          byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x14uLL);
          *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
          *((_DWORD *)v22 + 1) = byte_stream_read_uint32(*(void *)(a1 + 24));
          v22[1] = byte_stream_read_uint64(*(void *)(a1 + 24));
          *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(void *)(a1 + 24));
          uint64_t v34 = (uint64_t)a2;
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_locator";
            uint64_t v24 = "Could not parse the PKZip ZIP64 end of central directory locator";
            uint64_t v25 = v105;
            int v26 = 3170;
            goto LABEL_97;
          }
          if (*(_DWORD *)v22 != 117853008)
          {
            capture_error(v105, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3177, (uint64_t)"parse_entry_pkzip_zip64_end_of_central_directory_locator", "Invalid PKZip ZIP64 end of central directory record signature: %04x", v9, v10, v11, *(_DWORD *)v22);
            goto LABEL_98;
          }
          *(void *)(a1 + 48) += 20;
          *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662830);
          if (darc_format_entry_set_type(a2, 13))
          {
            uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_locator";
            uint64_t v24 = "Could not set entry type";
            uint64_t v25 = v105;
            int v26 = 3191;
          }
          else
          {
            if (!darc_format_entry_set_attribute((uint64_t)a2, "pkzip ZIP64 end of central directory locator", v22, 0x18uLL))goto LABEL_124; {
            uint64_t v23 = "parse_entry_pkzip_zip64_end_of_central_directory_locator";
            }
            uint64_t v24 = "Could not set PKZip ZIP64 end of central directory locator attribute";
            uint64_t v25 = v105;
            int v26 = 3203;
          }
          goto LABEL_97;
        }
      }
      else
      {
        if (uint32 == 134630224)
        {
          uint64_t v31 = a3;
          if (require_minimum_amount(a1, 8uLL, (char)"PKZip archive extra data", a3)) {
            return 0xFFFFFFFFLL;
          }
          byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 8uLL);
          int v19 = byte_stream_read_uint32(*(void *)(a1 + 24));
          unsigned int v20 = byte_stream_read_uint32(*(void *)(a1 + 24));
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            uint64_t v15 = "parse_entry_pkzip_archive_extra_data";
            uint64_t v16 = "Could not parse the PKZip data descriptor";
            uint64_t v17 = a3;
            int v18 = 2516;
            goto LABEL_61;
          }
          if (v19 == 134630224)
          {
            *(void *)(a1 + 48) += 8;
            *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662850);
            if (!v20)
            {
              uint64_t v34 = (uint64_t)a2;
              if (!darc_format_entry_set_type(a2, 9)) {
                goto LABEL_59;
              }
              uint64_t v15 = "parse_entry_pkzip_archive_extra_data";
              uint64_t v16 = "Could not set entry type";
              uint64_t v17 = v105;
              int v18 = 2554;
              goto LABEL_61;
            }
            if (!require_minimum_amount(a1, v20, (char)"PKZip extra data", a3))
            {
              uint64_t v38 = *(void *)(a1 + 56) + v20;
              *(void *)(a1 + 48) += v20;
              *(void *)(a1 + 56) = v38;
              *(void *)(a1 + 64) -= v20;
              uint64_t v15 = "parse_entry_pkzip_archive_extra_data";
              uint64_t v16 = "TODO: parse extra field";
              uint64_t v17 = a3;
              int v18 = 2543;
              goto LABEL_61;
            }
          }
          else
          {
            capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2522, (uint64_t)"parse_entry_pkzip_archive_extra_data", "Invalid PKZip archive extra signature: %04x", v9, v10, v11, v19);
          }
          return 0xFFFFFFFFLL;
        }
        if (uint32 == 134695760 || uint32 == 808471376) {
          goto LABEL_55;
        }
      }
      goto LABEL_21;
    }
    if (uint32 <= 84233039)
    {
      if (uint32 != 33639248)
      {
        if (uint32 != 67324752) {
          goto LABEL_21;
        }
        uint64_t v27 = a3;
        if (require_minimum_amount(a1, 0x1EuLL, (char)"PKZip local header", a3)) {
          return 0xFFFFFFFFLL;
        }
        int v29 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x20uLL);
        if (!v29)
        {
          uint64_t v44 = __error();
          strerror(*v44);
          capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2159, (uint64_t)"parse_entry_pkzip_local_header", "Could not allocate %ld bytes for PKZip local header: %s\n", v45, v46, v47, 32);
          return 0xFFFFFFFFLL;
        }
        int v22 = v29;
        byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x1EuLL);
        *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
        *((_WORD *)v22 + 2) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 3) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 4) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 5) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 6) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(void *)(a1 + 24));
        *((_DWORD *)v22 + 5) = byte_stream_read_uint32(*(void *)(a1 + 24));
        *((_DWORD *)v22 + 6) = byte_stream_read_uint32(*(void *)(a1 + 24));
        *((_WORD *)v22 + 14) = byte_stream_read_uint16(*(void *)(a1 + 24));
        *((_WORD *)v22 + 15) = byte_stream_read_uint16(*(void *)(a1 + 24));
        if (byte_stream_exception(*(void *)(a1 + 24)))
        {
          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not parse the PKZip local header";
          uint64_t v25 = a3;
          int v26 = 2179;
          goto LABEL_97;
        }
        if (*(_DWORD *)v22 != 67324752)
        {
          capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2186, (uint64_t)"parse_entry_pkzip_local_header", "Invalid PKZip local header signature: %04x", v9, v10, v11, *(_DWORD *)v22);
          goto LABEL_98;
        }
        *(void *)(a1 + 48) += 30;
        *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662860);
        if (darc_format_entry_set_attribute((uint64_t)v104, "pkzip local header", v22, 0x20uLL))
        {
          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not set PKZip local header attribute";
          uint64_t v25 = a3;
          int v26 = 2204;
          goto LABEL_97;
        }
        uint64_t v77 = *((unsigned int *)v22 + 5);
        if (v77 && darc_format_entry_set_size((uint64_t)v104, v77))
        {
          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not set entry size";
          uint64_t v25 = a3;
          int v26 = 2215;
          goto LABEL_97;
        }
        if (*((_WORD *)v22 + 14))
        {
          if (require_minimum_amount(a1, *((unsigned __int16 *)v22 + 14), (char)"PKZip file name", a3)) {
            goto LABEL_98;
          }
          byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), *((unsigned __int16 *)v22 + 14));
          size_t v78 = *((unsigned __int16 *)v22 + 14) + 1;
          size_t v79 = platform_calloc(*(void *)(a1 + 8), v78, 1uLL);
          if (!v79)
          {
            __int16 v85 = *((_WORD *)v22 + 14);
            uint64_t v86 = __error();
            strerror(*v86);
            capture_error(v105, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2247, (uint64_t)"parse_entry_pkzip_local_header", "Could not allocate %d bytes: %s", v87, v88, v89, v85);
            goto LABEL_98;
          }
          size_t v69 = v79;
          byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v79, *((unsigned __int16 *)v22 + 14));
          if (byte_stream_exception(*(void *)(a1 + 24)))
          {
            int v73 = "parse_entry_pkzip_local_header";
            int v74 = "Could not parse the PKZip file name";
            uint64_t v75 = a3;
            int v76 = 2256;
            goto LABEL_143;
          }
          if (darc_format_entry_set_attribute((uint64_t)v104, "name", v69, v78))
          {
            int v73 = "parse_entry_pkzip_local_header";
            int v74 = "Could not set entry name";
            uint64_t v75 = a3;
            int v76 = 2270;
            goto LABEL_143;
          }
          free(v69);
          uint64_t v99 = *((unsigned __int16 *)v22 + 14);
          uint64_t v100 = *(void *)(a1 + 56) + v99;
          *(void *)(a1 + 48) += v99;
          *(void *)(a1 + 56) = v100;
          *(void *)(a1 + 64) -= v99;
          uint64_t v27 = a3;
        }
        if (*((_WORD *)v22 + 15)
          && parse_entry_pkzip_extra_field((uint64_t *)a1, (uint64_t)v104, *((unsigned __int16 *)v22 + 15), 1, v27))
        {
          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not parse local header extra field";
          uint64_t v25 = v27;
          int v26 = 2290;
        }
        else
        {
          if ((*((_WORD *)v22 + 3) & 8) != 0)
          {
            if (darc_format_entry_get_attribute((uint64_t)v104, "pkzip extra field ZIP64", 0) < 1) {
              *(unsigned char *)(a1 + 90) = 1;
            }
            else {
              *(unsigned char *)(a1 + 91) = 1;
            }
          }
          else
          {
            *(_WORD *)(a1 + 90) = 0;
          }
          uint64_t v34 = (uint64_t)v104;
          if (!darc_format_entry_set_type(v104, 6))
          {
            free(v22);
            uint64_t v31 = v105;
            goto LABEL_59;
          }
          uint64_t v23 = "parse_entry_pkzip_local_header";
          uint64_t v24 = "Could not set entry type";
          uint64_t v25 = v105;
          int v26 = 2326;
        }
        goto LABEL_97;
      }
      uint64_t v31 = a3;
      if (require_minimum_amount(a1, 0x2EuLL, (char)"PKZip central directory header", a3)) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v21 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x30uLL);
      if (!v21)
      {
        uint64_t v40 = __error();
        strerror(*v40);
        capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2610, (uint64_t)"parse_entry_pkzip_central_directory_header", "Could not allocate %ld bytes for PKZip central directory header: %s", v41, v42, v43, 48);
        return 0xFFFFFFFFLL;
      }
      int v22 = v21;
      byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
      byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x2EuLL);
      *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_WORD *)v22 + 2) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 3) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 4) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 5) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 6) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 7) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 5) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 6) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_WORD *)v22 + 14) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 15) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 16) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 17) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 18) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 10) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 11) = byte_stream_read_uint32(*(void *)(a1 + 24));
      if (byte_stream_exception(*(void *)(a1 + 24)))
      {
        uint64_t v23 = "parse_entry_pkzip_central_directory_header";
        uint64_t v24 = "Could not parse the PKZip data descriptor";
        uint64_t v25 = a3;
        int v26 = 2638;
        goto LABEL_97;
      }
      if (*(_DWORD *)v22 != 33639248)
      {
        capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2645, (uint64_t)"parse_entry_pkzip_central_directory_header", "Invalid PKZip central directory header signature: %04x", v9, v10, v11, *(_DWORD *)v22);
        goto LABEL_98;
      }
      *(void *)(a1 + 48) += 46;
      *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662840);
      int v60 = a2;
      if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip central directory header", v22, 0x30uLL))
      {
        uint64_t v23 = "parse_entry_pkzip_central_directory_header";
        uint64_t v24 = "Could not set PKZip central directory header attribute";
        uint64_t v25 = v105;
        int v26 = 2663;
        goto LABEL_97;
      }
      if (*((_WORD *)v22 + 14))
      {
        if (require_minimum_amount(a1, *((unsigned __int16 *)v22 + 14), (char)"PKZip file name", v105)) {
          goto LABEL_98;
        }
        byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), *((unsigned __int16 *)v22 + 14));
        size_t v67 = *((unsigned __int16 *)v22 + 14) + 1;
        long long v68 = platform_calloc(*(void *)(a1 + 8), v67, 1uLL);
        if (!v68)
        {
          __int16 v80 = *((_WORD *)v22 + 14);
          int v81 = __error();
          strerror(*v81);
          capture_error(v105, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2694, (uint64_t)"parse_entry_pkzip_central_directory_header", "Could not allocate %d bytes: %s", v82, v83, v84, v80);
          goto LABEL_98;
        }
        size_t v69 = v68;
        byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v68, *((unsigned __int16 *)v22 + 14));
        if (byte_stream_exception(*(void *)(a1 + 24)))
        {
          int v73 = "parse_entry_pkzip_central_directory_header";
          int v74 = "Could not parse the PKZip file name";
          uint64_t v75 = v105;
          int v76 = 2703;
LABEL_143:
          capture_error(v75, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v76, (uint64_t)v73, v74, v70, v71, v72, v103);
          free(v69);
          goto LABEL_98;
        }
        if (darc_format_entry_set_attribute((uint64_t)a2, "name", v69, v67))
        {
          int v73 = "parse_entry_pkzip_central_directory_header";
          int v74 = "Could not set entry name";
          uint64_t v75 = v105;
          int v76 = 2717;
          goto LABEL_143;
        }
        free(v69);
        uint64_t v90 = *((unsigned __int16 *)v22 + 14);
        uint64_t v91 = *(void *)(a1 + 56) + v90;
        *(void *)(a1 + 48) += v90;
        *(void *)(a1 + 56) = v91;
        *(void *)(a1 + 64) -= v90;
        uint64_t v31 = v105;
        int v60 = a2;
      }
      if (*((_WORD *)v22 + 15)
        && parse_entry_pkzip_extra_field((uint64_t *)a1, (uint64_t)v60, *((unsigned __int16 *)v22 + 15), 0, v31))
      {
        uint64_t v23 = "parse_entry_pkzip_central_directory_header";
        uint64_t v24 = "Could not parse central directory header extra field";
        uint64_t v25 = v31;
        int v26 = 2737;
        goto LABEL_97;
      }
      if (*((_WORD *)v22 + 16))
      {
        if (require_minimum_amount(a1, *((unsigned __int16 *)v22 + 16), (char)"PKZip file comment", v31)) {
          goto LABEL_98;
        }
        byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), *((unsigned __int16 *)v22 + 16));
        size_t v92 = *((unsigned __int16 *)v22 + 16);
        uint64_t v93 = platform_calloc(*(void *)(a1 + 8), v92, 1uLL);
        if (!v93)
        {
          __int16 v94 = *((_WORD *)v22 + 16);
          long long v95 = __error();
          strerror(*v95);
          capture_error(v105, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2769, (uint64_t)"parse_entry_pkzip_central_directory_header", "Could not allocate %d bytes: %s", v96, v97, v98, v94);
          goto LABEL_98;
        }
        size_t v69 = v93;
        byte_stream_read_buffer(*(uint64_t **)(a1 + 24), v93, *((unsigned __int16 *)v22 + 16));
        if (byte_stream_exception(*(void *)(a1 + 24)))
        {
          int v73 = "parse_entry_pkzip_central_directory_header";
          int v74 = "Could not parse the PKZip file comment";
          uint64_t v75 = v105;
          int v76 = 2778;
          goto LABEL_143;
        }
        if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip central directory file comment", v69, v92))
        {
          int v73 = "parse_entry_pkzip_central_directory_header";
          int v74 = "Could not set entry file comment";
          uint64_t v75 = v105;
          int v76 = 2787;
          goto LABEL_143;
        }
        free(v69);
        uint64_t v101 = *((unsigned __int16 *)v22 + 16);
        uint64_t v102 = *(void *)(a1 + 56) + v101;
        *(void *)(a1 + 48) += v101;
        *(void *)(a1 + 56) = v102;
        *(void *)(a1 + 64) -= v101;
        uint64_t v31 = v105;
        int v60 = a2;
      }
      if (darc_format_entry_set_type(v60, 10))
      {
        uint64_t v23 = "parse_entry_pkzip_central_directory_header";
        uint64_t v24 = "Could not set entry type";
        uint64_t v25 = v31;
        int v26 = 2805;
        goto LABEL_97;
      }
      free(v22);
LABEL_58:
      uint64_t v34 = (uint64_t)a2;
      goto LABEL_59;
    }
    if (uint32 == 84233040) {
      break;
    }
    if (uint32 == 101010256)
    {
      uint64_t v31 = a3;
      if (require_minimum_amount(a1, 0x16uLL, (char)"PKZip end of central directory read", a3)) {
        return 0xFFFFFFFFLL;
      }
      size_t v37 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x18uLL);
      if (!v37)
      {
        char v56 = __error();
        strerror(*v56);
        capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2920, (uint64_t)"parse_entry_pkzip_end_of_central_directory_record", "Could not allocate %ld bytes for PKZip central directory header: %s", v57, v58, v59, 24);
        return 0xFFFFFFFFLL;
      }
      int v22 = v37;
      byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
      byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 0x16uLL);
      *(_DWORD *)int v22 = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_WORD *)v22 + 2) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 3) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 4) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_WORD *)v22 + 5) = byte_stream_read_uint16(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 3) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_DWORD *)v22 + 4) = byte_stream_read_uint32(*(void *)(a1 + 24));
      *((_WORD *)v22 + 10) = byte_stream_read_uint16(*(void *)(a1 + 24));
      if (byte_stream_exception(*(void *)(a1 + 24)))
      {
        uint64_t v23 = "parse_entry_pkzip_end_of_central_directory_record";
        uint64_t v24 = "Could not parse the PKZip data descriptor";
        uint64_t v25 = a3;
        int v26 = 2939;
        goto LABEL_97;
      }
      if (*(_DWORD *)v22 == 101010256)
      {
        *(void *)(a1 + 48) += 22;
        *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662820);
        if (*((_WORD *)v22 + 10))
        {
          if (!require_minimum_amount(a1, *((unsigned __int16 *)v22 + 10), (char)".ZIP file comment", a3))
          {
            uint64_t v65 = *((unsigned __int16 *)v22 + 10);
            uint64_t v66 = *(void *)(a1 + 56) + v65;
            *(void *)(a1 + 48) += v65;
            *(void *)(a1 + 56) = v66;
            *(void *)(a1 + 64) -= v65;
            uint64_t v15 = "parse_entry_pkzip_end_of_central_directory_record";
            uint64_t v16 = "TODO: parse .ZIP file comment";
            uint64_t v17 = a3;
            int v18 = 2969;
            goto LABEL_61;
          }
LABEL_98:
          free(v22);
          return 0xFFFFFFFFLL;
        }
        uint64_t v34 = (uint64_t)a2;
        if (darc_format_entry_set_type(a2, 14))
        {
          uint64_t v23 = "parse_entry_pkzip_end_of_central_directory_record";
          uint64_t v24 = "Could not set entry type";
          uint64_t v25 = v105;
          int v26 = 2980;
          goto LABEL_97;
        }
        if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip end of central directory record", v22, 0x18uLL))
        {
          uint64_t v23 = "parse_entry_pkzip_end_of_central_directory_record";
          uint64_t v24 = "Could not set PKZip end of central directory record attribute";
          uint64_t v25 = v105;
          int v26 = 2992;
          goto LABEL_97;
        }
LABEL_124:
        free(v22);
        goto LABEL_59;
      }
      uint64_t v23 = "parse_entry_pkzip_end_of_central_directory_record";
      uint64_t v24 = "Invalid PKZip end of central directory record signature: %04x";
      int v103 = *(_DWORD *)v22;
      uint64_t v25 = a3;
      int v26 = 2946;
LABEL_97:
      capture_error(v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v26, (uint64_t)v23, v24, v9, v10, v11, v103);
      goto LABEL_98;
    }
LABEL_21:
    if ((~uint32 & 0x3000000) != 0)
    {
      if (*(unsigned __int8 *)(a1 + 91) | *(unsigned __int8 *)(a1 + 90))
      {
        int uint32 = 0;
LABEL_55:
        uint64_t v34 = (uint64_t)a2;
        uint64_t v31 = v105;
        if (parse_entry_pkzip_data_descriptor(a1, a2, uint32, v105)) {
          return 0xFFFFFFFFLL;
        }
LABEL_59:
        uint64_t result = darc_format_entry_set_range(v34, v6, *(void *)(a1 + 56) - v6);
        if (!result) {
          return result;
        }
        uint64_t v15 = "parse_entry_pkzip";
        uint64_t v16 = "Could not set entry range\n";
        uint64_t v17 = v31;
        int v18 = 2109;
LABEL_61:
        capture_error(v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v18, (uint64_t)v15, v16, v9, v10, v11, v103);
        return 0xFFFFFFFFLL;
      }
      uint64_t v13 = *(void *)(a1 + 56) + 1;
      ++*(void *)(a1 + 48);
      *(void *)(a1 + 56) = v13;
      uint64_t v14 = *(void *)(a1 + 64) - 1;
      *(void *)(a1 + 64) = v14;
      if (!v14)
      {
        uint64_t v31 = a3;
        capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2080, (uint64_t)"parse_entry_pkzip", "Could not find a PKZip signature", v9, v10, v11, v103);
        *(unsigned char *)(a1 + 80) = 1;
        goto LABEL_58;
      }
    }
    else
    {
      *(void *)(a1 + 48) += 2;
      int64x2_t v12 = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662870);
      *(int64x2_t *)(a1 + 56) = v12;
      uint64_t v13 = v12.i64[0];
    }
    uint64_t v6 = v13;
    if (require_minimum_amount(a1, 4uLL, (char)"PKZip signature", a3)) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t v31 = a3;
  if (require_minimum_amount(a1, 6uLL, (char)"PKZip archive digital signature", a3)) {
    return 0xFFFFFFFFLL;
  }
  byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
  byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), 6uLL);
  int v35 = byte_stream_read_uint32(*(void *)(a1 + 24));
  unsigned int uint16 = byte_stream_read_uint16(*(void *)(a1 + 24));
  if (byte_stream_exception(*(void *)(a1 + 24)))
  {
    uint64_t v15 = "parse_entry_pkzip_digital_signature";
    uint64_t v16 = "Could not parse the PKZip digital signature";
    uint64_t v17 = a3;
    int v18 = 2858;
    goto LABEL_61;
  }
  if (v35 != 84233040)
  {
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2864, (uint64_t)"parse_entry_pkzip_digital_signature", "Invalid PKZip archive digital signature signature: %04x", v9, v10, v11, v35);
    return 0xFFFFFFFFLL;
  }
  if (!require_minimum_amount(a1, uint16, (char)"PKZip archive digital signature", a3))
  {
    uint64_t v39 = *(void *)(a1 + 56) + uint16;
    *(void *)(a1 + 48) += uint16;
    *(void *)(a1 + 56) = v39;
    *(void *)(a1 + 64) -= uint16;
    goto LABEL_58;
  }
  return 0xFFFFFFFFLL;
}

size_t data_archive_decoder_read_data(uint64_t a1, void *__dst, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1919315316 || *(_DWORD *)(a1 + 92) != 1953326706)
  {
    uint64_t v15 = "Invalid decoder";
    uint64_t v16 = a4;
    int v17 = 648;
    goto LABEL_13;
  }
  if (!__dst)
  {
    uint64_t v15 = "Invalid read buffer";
    uint64_t v16 = a4;
    int v17 = 654;
    goto LABEL_13;
  }
  if (!a3)
  {
    uint64_t v15 = "Invalid bytes to read";
    uint64_t v16 = a4;
    int v17 = 660;
    goto LABEL_13;
  }
  size_t v12 = *(void *)(a1 + 64);
  if (!v12)
  {
    if (!populate_read_buffer(a1, *(void *)(a1 + 32), a4))
    {
      size_t v12 = *(void *)(a1 + 64);
      goto LABEL_7;
    }
    uint64_t v15 = "Could not populate the read buffer";
    uint64_t v16 = a4;
    int v17 = 673;
LABEL_13:
    capture_error(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v17, (uint64_t)"data_archive_decoder_read_data", v15, a6, a7, a8, v19);
    return -1;
  }
LABEL_7:
  if (v12 >= a3) {
    size_t v13 = a3;
  }
  else {
    size_t v13 = v12;
  }
  if (v13)
  {
    platform_memcpy(*(void *)(a1 + 8), __dst, *(void **)(a1 + 48), v13);
    size_t v14 = *(void *)(a1 + 56) + v13;
    *(void *)(a1 + 48) += v13;
    *(void *)(a1 + 56) = v14;
    *(void *)(a1 + 64) -= v13;
  }
  return v13;
}

uint64_t data_archive_decoder_rewind_data(uint64_t a1, void *__s2, size_t __n, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1919315316 || *(_DWORD *)(a1 + 92) != 1953326706)
  {
    uint64_t v15 = "Invalid decoder";
    uint64_t v16 = a4;
    int v17 = 710;
    goto LABEL_9;
  }
  if (!__s2)
  {
    uint64_t v15 = "Invalid rewind buffer";
    uint64_t v16 = a4;
    int v17 = 716;
    goto LABEL_9;
  }
  if (!__n)
  {
    uint64_t v15 = "Invalid bytes to rewind";
    uint64_t v16 = a4;
    int v17 = 722;
    goto LABEL_9;
  }
  uint64_t v11 = *(void *)(a1 + 56);
  size_t v12 = (void *)(*(void *)(a1 + 48) - __n);
  uint64_t v13 = *(void *)(a1 + 64);
  uint64_t result = platform_memcmp(*(void *)(a1 + 8), v12, __s2, __n);
  if (result)
  {
    uint64_t v15 = "Bytes don't match";
    uint64_t v16 = a4;
    int v17 = 732;
LABEL_9:
    capture_error(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v17, (uint64_t)"data_archive_decoder_rewind_data", v15, a6, a7, a8, v18);
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 48) = v12;
  *(void *)(a1 + 56) = v11 - __n;
  *(void *)(a1 + 64) = v13 + __n;
  return result;
}

uint64_t require_minimum_amount(uint64_t a1, size_t a2, char a3, void *a4)
{
  if (populate_read_buffer(a1, a2, a4))
  {
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 4001, (uint64_t)"require_minimum_amount", "Could not populate read buffer for %s", v8, v9, v10, a3);
    return 0xFFFFFFFFLL;
  }
  size_t v11 = *(void *)(a1 + 64);
  if (v11 < a2)
  {
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 4007, (uint64_t)"require_minimum_amount", "Not enough data remaining (%ld) for %s (%ld)", v8, v9, v10, v11);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t parse_entry_posix_ustar_extended_metadata(uint64_t a1, uint64_t a2, void *a3)
{
  if (!require_minimum_amount(a1, 0x200uLL, (char)"POSIX ustar extended metadata", a3))
  {
    size_t v6 = platform_strnlen(*(void *)(a1 + 8), *(char **)(a1 + 48), 0x200uLL);
    if (v6 < 0x201)
    {
      if (v6 == a2)
      {
        printf("DALLAS: string_length = %lu\n", a2);
        uint64_t result = 0;
        *(void *)(a1 + 48) += 512;
        *(int64x2_t *)(a1 + 56) = vaddq_s64(*(int64x2_t *)(a1 + 56), (int64x2_t)xmmword_210662800);
        return result;
      }
      capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1607, (uint64_t)"parse_entry_posix_ustar_extended_metadata", "POSIX ustar extended metadata string length %lu does not match expected size %lu", v7, v8, v9, v6);
    }
    else
    {
      capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 1601, (uint64_t)"parse_entry_posix_ustar_extended_metadata", "POSIX ustar extended metadata string length %lu is larger than TAR record size %lu", v7, v8, v9, v6);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t parse_entry_pkzip_data_descriptor(uint64_t a1, _DWORD *a2, int a3, void *a4)
{
  BOOL v8 = a3 == 134695760 || a3 == 808471376;
  int v9 = *(unsigned __int8 *)(a1 + 91);
  uint64_t v10 = 4;
  if (v8) {
    uint64_t v10 = 8;
  }
  size_t v11 = v10 + 8;
  uint64_t v12 = v10 | 0x10;
  if (*(unsigned char *)(a1 + 91)) {
    size_t v13 = v12;
  }
  else {
    size_t v13 = v11;
  }
  if (require_minimum_amount(a1, v13, (char)"PKZip data descriptor", a4)) {
    return 0xFFFFFFFFLL;
  }
  size_t v14 = platform_calloc(*(void *)(a1 + 8), 1uLL, 0x18uLL);
  if (!v14)
  {
    char v18 = __error();
    strerror(*v18);
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 2409, (uint64_t)"parse_entry_pkzip_data_descriptor", "Could not allocate %ld bytes for PKZip data descriptor: %s", v19, v20, v21, 24);
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = v14;
  byte_stream_set_byte_order(*(_DWORD **)(a1 + 24), 2);
  byte_stream_attach(*(void *)(a1 + 24), *(void *)(a1 + 48), v13);
  *uint64_t v15 = 134695760;
  if (a3 == 808471376 || a3 == 134695760) {
    *uint64_t v15 = byte_stream_read_uint32(*(void *)(a1 + 24));
  }
  v15[1] = byte_stream_read_uint32(*(void *)(a1 + 24));
  uint64_t v16 = *(void *)(a1 + 24);
  if (v9)
  {
    *((void *)v15 + 1) = byte_stream_read_uint64(v16);
    unint64_t uint64 = byte_stream_read_uint64(*(void *)(a1 + 24));
  }
  else
  {
    *((void *)v15 + 1) = byte_stream_read_uint32(v16);
    unint64_t uint64 = byte_stream_read_uint32(*(void *)(a1 + 24));
  }
  *((void *)v15 + 2) = uint64;
  if (byte_stream_exception(*(void *)(a1 + 24)))
  {
    uint64_t v25 = "Could not parse the PKZip data descriptor";
    int v26 = a4;
    int v27 = 2438;
LABEL_24:
    capture_error(v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v27, (uint64_t)"parse_entry_pkzip_data_descriptor", v25, v22, v23, v24, v30);
    free(v15);
    return 0xFFFFFFFFLL;
  }
  if (*v15 != 134695760)
  {
    uint64_t v25 = "Invalid PKZip data descriptor signature: %04x";
    int v30 = *v15;
    int v26 = a4;
    int v27 = 2445;
    goto LABEL_24;
  }
  size_t v28 = *(void *)(a1 + 56) + v13;
  *(void *)(a1 + 48) += v13;
  *(void *)(a1 + 56) = v28;
  *(void *)(a1 + 64) -= v13;
  if (darc_format_entry_set_type(a2, 7))
  {
    uint64_t v25 = "Could not set entry type";
    int v26 = a4;
    int v27 = 2459;
    goto LABEL_24;
  }
  if (darc_format_entry_set_attribute((uint64_t)a2, "pkzip data descriptor", v15, 0x18uLL))
  {
    uint64_t v25 = "Could not set PKZip data descriptor attribute";
    int v26 = a4;
    int v27 = 2471;
    goto LABEL_24;
  }
  *(_WORD *)(a1 + 90) = 0;
  free(v15);
  return 0;
}

uint64_t parse_entry_pkzip_extra_field(uint64_t *a1, uint64_t a2, size_t a3, int a4, void *a5)
{
  uint64_t v5 = a5;
  if (require_minimum_amount((uint64_t)a1, a3, (char)"PKZip extra field", a5)) {
    return 0xFFFFFFFFLL;
  }
  byte_stream_attach(a1[3], a1[6], a3);
  if (!a3)
  {
LABEL_78:
    uint64_t result = byte_stream_remaining(a1[3]);
    if (result)
    {
      capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3394, (uint64_t)"parse_entry_pkzip_extra_field", "%ld bytes remaining after parsing %s extra field", v72, v73, v74, result);
      return 0xFFFFFFFFLL;
    }
    size_t v75 = a1[7] + a3;
    a1[6] += a3;
    a1[7] = v75;
    a1[8] -= a3;
    return result;
  }
  uint64_t v10 = 0;
  long long v95 = v5;
  while (1)
  {
    int uint16 = byte_stream_read_uint16(a1[3]);
    unsigned int v12 = byte_stream_read_uint16(a1[3]);
    if (byte_stream_exception(a1[3]))
    {
      int v76 = "Exceed byte stream when parsing extra field";
      uint64_t v77 = v5;
      int v78 = 3268;
      goto LABEL_106;
    }
    uint64_t v16 = v10 + 4;
    if (uint16 > 21588)
    {
      if (uint16 != 21589)
      {
        if (uint16 != 22613)
        {
          if (uint16 != 30837) {
            goto LABEL_83;
          }
          uint64_t v17 = a1[6];
          byte_stream_new(a1[1], 0);
          if (v18)
          {
            uint64_t v22 = (void *)v18;
            uint64_t v23 = v17 + v16;
            uint64_t v24 = v12;
            byte_stream_attach(v18, v23, v12);
            DWORD2(v96) = 0;
            *(void *)&long long v96 = 0;
            LOBYTE(v96) = byte_stream_read_uint8((uint64_t)v22);
            unsigned int uint8 = byte_stream_read_uint8((uint64_t)v22);
            uint64_t v29 = uint8;
            if (uint8 == 4)
            {
              DWORD1(v96) = byte_stream_read_uint32((uint64_t)v22);
            }
            else
            {
              capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3858, (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v3", "Unrecognized uid size: %d", v26, v27, v28, uint8);
              byte_stream_advance((uint64_t)v22, v29);
            }
            if (byte_stream_read_uint8((uint64_t)v22) == 4)
            {
              DWORD2(v96) = byte_stream_read_uint32((uint64_t)v22);
            }
            else
            {
              capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3869, (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v3", "Unrecognized uid size: %d", v64, v65, v66, v29);
              byte_stream_advance((uint64_t)v22, v29);
            }
            if (byte_stream_exception((BOOL)v22))
            {
              size_t v79 = "Could not parse the PKZip Info-ZIP UNIX v3";
              __int16 v80 = v5;
              int v81 = 3875;
            }
            else
            {
              if (!darc_format_entry_set_attribute(a2, "pkzip extra field InfoZIP UNIX v3", &v96, 0xCuLL)) {
                goto LABEL_72;
              }
              size_t v79 = "Could not set ctime";
              __int16 v80 = v5;
              int v81 = 3886;
            }
          }
          else
          {
            size_t v79 = "Could not create extra byte stream";
            __int16 v80 = v5;
            int v81 = 3801;
          }
          capture_error(v80, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v81, (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v3", v79, v19, v20, v21, v94);
          int v76 = "Could not parse extended timestamp";
          uint64_t v77 = v5;
          int v78 = 3349;
          goto LABEL_106;
        }
        uint64_t v49 = a1[6];
        byte_stream_new(a1[1], 0);
        if (v50)
        {
          uint64_t v22 = (void *)v50;
          uint64_t v54 = v49 + v16;
          uint64_t v24 = v12;
          byte_stream_attach(v50, v54, v12);
          long long v97 = 0uLL;
          *(void *)&long long v96 = byte_stream_read_uint32((uint64_t)v22);
          *((void *)&v96 + 1) = byte_stream_read_uint32((uint64_t)v22);
          if (v12 >= 0xA)
          {
            LOBYTE(v97) = 1;
            DWORD1(v97) = byte_stream_read_uint16((uint64_t)v22);
            if (v12 == 12)
            {
              BYTE8(v97) = 1;
              HIDWORD(v97) = byte_stream_read_uint16((uint64_t)v22);
            }
          }
          if (byte_stream_exception((BOOL)v22))
          {
            uint64_t v82 = "Could not parse the PKZip Info-ZIP extra block for UNIX";
            uint64_t v83 = v5;
            int v84 = 3769;
          }
          else
          {
            if (!darc_format_entry_set_attribute(a2, "pkzip extra field InfoZIP UNIX v1", &v96, 0x20uLL))
            {
LABEL_72:
              byte_stream_free(v22);
              goto LABEL_73;
            }
            uint64_t v82 = "Could not set ctime";
            uint64_t v83 = v5;
            int v84 = 3780;
          }
        }
        else
        {
          uint64_t v82 = "Could not create extra byte stream";
          uint64_t v83 = v5;
          int v84 = 3721;
        }
        capture_error(v83, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v84, (uint64_t)"parse_entry_pkzip_extra_field_infozip_unix_v1", v82, v51, v52, v53, v94);
        int v76 = "Could not parse extended timestamp";
        uint64_t v77 = v5;
        int v78 = 3329;
        goto LABEL_106;
      }
      uint64_t v40 = a1[6];
      byte_stream_new(a1[1], 0);
      if (!v41)
      {
        uint64_t v91 = "Could not create extra byte stream";
        size_t v92 = v5;
        int v93 = 3567;
        goto LABEL_103;
      }
      uint64_t v45 = (void *)v41;
      uint64_t v46 = v40 + v16;
      uint64_t v24 = v12;
      byte_stream_attach(v41, v46, v12);
      char v47 = byte_stream_read_uint8((uint64_t)v45);
      char v48 = v47;
      if (!a4)
      {
        long long v96 = 0uLL;
        unint64_t v67 = v12;
        *(void *)&long long v97 = 0;
        if (v12 >= 4)
        {
          unint64_t v67 = v12;
          if (v47)
          {
            *(void *)&long long v96 = byte_stream_read_uint32((uint64_t)v45);
            unint64_t v67 = v12 - 4;
          }
        }
        if ((v48 & 2) != 0)
        {
          unint64_t v68 = v67 - 4;
          if (v67 >= 4)
          {
            *((void *)&v96 + 1) = byte_stream_read_uint32((uint64_t)v45);
            unint64_t v67 = v68;
          }
        }
        if ((v48 & 4) != 0 && v67 >= 4) {
          *(void *)&long long v97 = byte_stream_read_uint32((uint64_t)v45);
        }
        if (byte_stream_exception((BOOL)v45))
        {
          uint64_t v91 = "Could not parse the PKZip extended-timestamp extra block";
          uint64_t v5 = v95;
          size_t v92 = v95;
          int v93 = 3688;
          goto LABEL_103;
        }
        if (darc_format_entry_set_attribute(a2, "pkzip extra field extended timestamp", &v96, 0x18uLL))
        {
          uint64_t v91 = "Could not set timestamp";
          uint64_t v5 = v95;
          size_t v92 = v95;
          int v93 = 3699;
          goto LABEL_103;
        }
LABEL_53:
        byte_stream_free(v45);
        uint64_t v5 = v95;
        goto LABEL_73;
      }
      long long v96 = 0uLL;
      *(void *)&long long v97 = 0;
      if (v47)
      {
        *(void *)&long long v96 = byte_stream_read_uint32((uint64_t)v45);
        if ((v48 & 2) == 0)
        {
LABEL_23:
          if ((v48 & 4) == 0) {
            goto LABEL_25;
          }
          goto LABEL_24;
        }
      }
      else if ((v47 & 2) == 0)
      {
        goto LABEL_23;
      }
      *((void *)&v96 + 1) = byte_stream_read_uint32((uint64_t)v45);
      if ((v48 & 4) == 0)
      {
LABEL_25:
        if (byte_stream_exception((BOOL)v45))
        {
          uint64_t v91 = "Could not parse the PKZip extended-timestamp extra block";
          uint64_t v5 = v95;
          size_t v92 = v95;
          int v93 = 3625;
          goto LABEL_103;
        }
        if (darc_format_entry_set_attribute(a2, "pkzip extra field extended timestamp", &v96, 0x18uLL))
        {
          uint64_t v91 = "Could not set extended timestamp";
          uint64_t v5 = v95;
          size_t v92 = v95;
          int v93 = 3636;
LABEL_103:
          capture_error(v92, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v93, (uint64_t)"parse_entry_pkzip_extra_field_extended_timestamp", v91, v42, v43, v44, v94);
          int v76 = "Could not parse extended timestamp";
          uint64_t v77 = v5;
          int v78 = 3309;
          goto LABEL_106;
        }
        goto LABEL_53;
      }
LABEL_24:
      *(void *)&long long v97 = byte_stream_read_uint32((uint64_t)v45);
      goto LABEL_25;
    }
    if (uint16 != 1) {
      break;
    }
    uint64_t v55 = a1[6];
    byte_stream_new(a1[1], 0);
    if (!v56)
    {
      uint64_t v88 = "Could not create extra byte stream";
      uint64_t v89 = v5;
      int v90 = 3416;
      goto LABEL_105;
    }
    int v60 = (void *)v56;
    uint64_t v61 = v55 + v16;
    uint64_t v24 = v12;
    byte_stream_attach(v56, v61, v12);
    if (a4)
    {
      uint64_t v62 = "pkzip local header";
      if (darc_format_entry_get_attribute(a2, "pkzip local header", 0) != 32)
      {
        uint64_t v88 = "Could not extract PKZip local header from entry";
        uint64_t v89 = v5;
        int v90 = 3465;
        goto LABEL_105;
      }
      long long v63 = 0uLL;
    }
    else
    {
      uint64_t v62 = "pkzip central directory header";
      if (darc_format_entry_get_attribute(a2, "pkzip central directory header", 0) != 48)
      {
        uint64_t v88 = "Could not extract PKZip central directory header from entry";
        uint64_t v89 = v5;
        int v90 = 3483;
        goto LABEL_105;
      }
      long long v63 = 0uLL;
      long long v98 = 0u;
    }
    long long v96 = v63;
    long long v97 = v63;
    darc_format_entry_get_attribute(a2, v62, &v96);
    int v70 = DWORD1(v97);
    int v69 = DWORD2(v97);
    *(void *)&long long v98 = 0;
    long long v96 = 0u;
    long long v97 = 0u;
    if (v69 == -1)
    {
      LOBYTE(v96) = 1;
      *((void *)&v96 + 1) = byte_stream_read_uint64((uint64_t)v60);
    }
    if (v70 == -1)
    {
      BYTE1(v96) = 1;
      *(void *)&long long v97 = byte_stream_read_uint64((uint64_t)v60);
    }
    if ((a4 & 1) == 0)
    {
      if ((unint64_t)byte_stream_remaining((uint64_t)v60) >= 8) {
        *((void *)&v97 + 1) = byte_stream_read_uint64((uint64_t)v60);
      }
      if ((unint64_t)byte_stream_remaining((uint64_t)v60) >= 4) {
        LODWORD(v98) = byte_stream_read_uint32((uint64_t)v60);
      }
    }
    if (byte_stream_exception((BOOL)v60))
    {
      uint64_t v88 = "Could not parse the PKZip ZIP64 extra block";
      uint64_t v89 = v5;
      int v90 = 3523;
      goto LABEL_105;
    }
    if (darc_format_entry_set_attribute(a2, "pkzip extra field ZIP64", &v96, 0x28uLL))
    {
      uint64_t v88 = "Could not set ZIP64";
      uint64_t v89 = v5;
      int v90 = 3534;
      goto LABEL_105;
    }
    byte_stream_free(v60);
    if (darc_format_entry_set_size(a2, *((uint64_t *)&v96 + 1)))
    {
      uint64_t v88 = "Could not reset pkzip entry size";
      uint64_t v89 = v5;
      int v90 = 3547;
LABEL_105:
      capture_error(v89, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v90, (uint64_t)"parse_entry_pkzip_extra_field_zip64", v88, v57, v58, v59, v94);
      int v76 = "Could not parse extended timestamp";
      uint64_t v77 = v5;
      int v78 = 3288;
      goto LABEL_106;
    }
LABEL_73:
    byte_stream_advance(a1[3], v24);
    uint64_t v10 = v16 + v24;
    if (v10 == a3) {
      goto LABEL_78;
    }
  }
  if (uint16 != 10)
  {
LABEL_83:
    capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3378, (uint64_t)"parse_entry_pkzip_extra_field", "Unrecognized extra field header ID: 0x%04x %d %d", v13, v14, v15, uint16);
    byte_stream_advance(a1[3], v12);
    return 0xFFFFFFFFLL;
  }
  uint64_t v30 = a1[6];
  byte_stream_new(a1[1], 0);
  if (!v31)
  {
    __int16 v85 = "Could not create extra byte stream";
    uint64_t v86 = v5;
    int v87 = 3907;
    goto LABEL_96;
  }
  uint64_t v22 = (void *)v31;
  uint64_t v35 = v30 + v16;
  uint64_t v24 = v12;
  byte_stream_attach(v31, v35, v12);
  LODWORD(v96) = byte_stream_read_uint32((uint64_t)v22);
  int v36 = byte_stream_read_uint16((uint64_t)v22);
  WORD2(v96) = v36;
  WORD3(v96) = byte_stream_read_uint16((uint64_t)v22);
  if (v36 != 1)
  {
    capture_error(v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", 3960, (uint64_t)"parse_entry_pkzip_extra_field_ntfs", "Unknown NTFS tag value: %u", v37, v38, v39, v36);
    goto LABEL_97;
  }
  *((void *)&v96 + 1) = byte_stream_read_uint64((uint64_t)v22);
  *(void *)&long long v97 = byte_stream_read_uint64((uint64_t)v22);
  *((void *)&v97 + 1) = byte_stream_read_uint64((uint64_t)v22);
  if (!byte_stream_exception((BOOL)v22))
  {
    if (darc_format_entry_set_attribute(a2, "pkzip extra field NTFS", &v96, 0x20uLL))
    {
      __int16 v85 = "Could not set NTFS extra field";
      uint64_t v86 = v5;
      int v87 = 3981;
      goto LABEL_96;
    }
    goto LABEL_72;
  }
  __int16 v85 = "Could not parse the PKZip NTFS extra field";
  uint64_t v86 = v5;
  int v87 = 3970;
LABEL_96:
  capture_error(v86, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v87, (uint64_t)"parse_entry_pkzip_extra_field_ntfs", v85, v32, v33, v34, v94);
LABEL_97:
  int v76 = "Could not parse NFTS extra field";
  uint64_t v77 = v5;
  int v78 = 3369;
LABEL_106:
  capture_error(v77, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_decoder.c", v78, (uint64_t)"parse_entry_pkzip_extra_field", v76, v13, v14, v15, v94);
  return 0xFFFFFFFFLL;
}

void *data_source_new(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0;
  }
  uint64_t result = platform_calloc(a1, 1uLL, 0x48uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 1936876321;
    result[1] = a1;
    *((_DWORD *)result + 4) = -1;
    *((_DWORD *)result + 16) = 560165491;
  }
  return result;
}

void data_source_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1936876321 && *((_DWORD *)__b + 16) == 560165491)
  {
    uint64_t v2 = __b[1];
    platform_memset(v2, __b, 0, 0x48uLL);
    platform_free(v2, __b);
  }
}

_DWORD *data_source_set_fd(_DWORD *result, int a2)
{
  if (result && *result == 1936876321 && result[16] == 560165491) {
    result[4] = a2;
  }
  return result;
}

uint64_t data_source_set_handler(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && *(_DWORD *)result == 1936876321 && *(_DWORD *)(result + 64) == 560165491)
  {
    *(void *)(result + 48) = a2;
    *(void *)(result + 56) = a3;
  }
  return result;
}

ssize_t data_source_read(uint64_t a1, void *a2, size_t a3)
{
  if (!a1 || *(_DWORD *)a1 != 1936876321 || *(_DWORD *)(a1 + 64) != 560165491) {
    return -1;
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, void *, size_t))(a1 + 56);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    return v5(v6, v7, a2, a3);
  }
  uint64_t v10 = *(void *)(a1 + 24);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 40);
    if (*(void *)(a1 + 32) - v11 >= a3) {
      size_t v9 = a3;
    }
    else {
      size_t v9 = *(void *)(a1 + 32) - v11;
    }
    if (v9)
    {
      platform_memcpy(*(void *)(a1 + 8), a2, (void *)(v10 + v11), v9);
      *(void *)(a1 + 40) += v9;
    }
    return v9;
  }
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *(unsigned int *)(a1 + 16);
  return platform_read(v12, v13, a2, a3);
}

_DWORD *data_archive_new(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  uint64_t result = platform_toolbox_new(a1);
  if (result)
  {
    uint64_t v2 = result;
    uint64_t result = platform_calloc((uint64_t)result, 1uLL, 0xD0uLL);
    if (result)
    {
      *uint64_t result = 1684107875;
      *((void *)result + 1) = v2;
      result[5] = -1;
      result[50] = 1668440420;
    }
    else
    {
      platform_toolbox_free(v2);
      return 0;
    }
  }
  return result;
}

void data_archive_free(unsigned int *__b)
{
  if (__b && *__b == 1684107875 && __b[50] == 1668440420)
  {
    uint64_t v2 = (void *)*((void *)__b + 20);
    if (v2) {
      platform_free(*((void *)__b + 1), v2);
    }
    uint64_t v3 = (z_stream *)*((void *)__b + 15);
    if (v3)
    {
      inflateEnd(v3);
      platform_free(*((void *)__b + 1), *((void **)__b + 15));
    }
    char v4 = (void *)*((void *)__b + 12);
    if (v4) {
      platform_free(*((void *)__b + 1), v4);
    }
    uint64_t v5 = (void *)*((void *)__b + 5);
    if (v5) {
      data_archive_decoder_free(v5);
    }
    uint64_t v6 = (void *)*((void *)__b + 4);
    if (v6) {
      data_read_stream_free(v6);
    }
    uint64_t v7 = (void *)*((void *)__b + 3);
    if (v7 && *((unsigned char *)__b + 16)) {
      data_source_free(v7);
    }
    uint64_t v8 = __b[5];
    if (v8 != -1 && *((unsigned char *)__b + 17)) {
      platform_close(*((void *)__b + 1), v8);
    }
    size_t v9 = (void *)*((void *)__b + 1);
    platform_memset((uint64_t)v9, __b, 0, 0xD0uLL);
    platform_free((uint64_t)v9, __b);
    platform_toolbox_free(v9);
  }
}

uint64_t data_archive_set_passphrase_callback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    size_t v9 = "Invalid data archive";
    uint64_t v10 = a4;
    int v11 = 264;
LABEL_7:
    capture_error(v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v11, (uint64_t)"data_archive_set_passphrase_callback", v9, a6, a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
  if (!a2)
  {
    size_t v9 = "Invalid passphrase callback";
    uint64_t v10 = a4;
    int v11 = 270;
    goto LABEL_7;
  }
  uint64_t v8 = 0;
  *(void *)(a1 + 128) = a2;
  *(void *)(a1 + 136) = a3;
  return v8;
}

uint64_t data_archive_open_source(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    uint64_t v16 = "Invalid data archive";
    uint64_t v17 = a3;
    int v18 = 292;
LABEL_9:
    capture_error(v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v18, (uint64_t)"data_archive_open_source", v16, a6, a7, a8, v27);
    return 0xFFFFFFFFLL;
  }
  if (!a2)
  {
    uint64_t v16 = "Invalid data source";
    uint64_t v17 = a3;
    int v18 = 298;
    goto LABEL_9;
  }
  *(void *)(a1 + 24) = a2;
  stream_new = data_read_stream_new(*(void *)(a1 + 8), 0);
  *(void *)(a1 + 32) = stream_new;
  if (!stream_new)
  {
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0;
    uint64_t v16 = "Could not create data read stream";
    uint64_t v17 = a3;
    int v18 = 310;
    goto LABEL_9;
  }
  int stream_set_source = data_read_stream_set_source((uint64_t)stream_new, *(void *)(a1 + 24));
  if (stream_set_source)
  {
    char v12 = stream_set_source;
    data_read_stream_free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0;
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0;
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 323, (uint64_t)"data_archive_open_source", "Could not set source for read stream: %d", v13, v14, v15, v12);
    return 0xFFFFFFFFLL;
  }
  uint64_t v20 = data_archive_decoder_new(*(void *)(a1 + 8), 0);
  *(void *)(a1 + 40) = v20;
  if (!v20)
  {
    data_read_stream_free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0;
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0;
    uint64_t v16 = "Could not create data decoder";
    uint64_t v17 = a3;
    int v18 = 336;
    goto LABEL_9;
  }
  int v21 = data_archive_decoder_set_stream((uint64_t)v20, *(void *)(a1 + 32), a3);
  uint64_t v22 = *(void **)(a1 + 40);
  if (v21)
  {
    data_archive_decoder_free(v22);
    *(void *)(a1 + 40) = 0;
    data_read_stream_free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0;
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0;
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 352, (uint64_t)"data_archive_open_source", "Could not set read stream for decoder: %d", v23, v24, v25, v21);
    return 0xFFFFFFFFLL;
  }
  int type = data_archive_decoder_get_type(v22);
  *(_DWORD *)(a1 + 48) = type;
  if (!type)
  {
    data_archive_decoder_free(*(void **)(a1 + 40));
    *(void *)(a1 + 40) = 0;
    data_read_stream_free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0;
    data_source_free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = 0;
    uint64_t v16 = "Unknown archive format";
    uint64_t v17 = a3;
    int v18 = 368;
    goto LABEL_9;
  }
  return 0;
}

uint64_t data_archive_open_fd(uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    uint64_t v19 = "Invalid data archive";
    uint64_t v20 = a3;
    int v21 = 387;
LABEL_10:
    capture_error(v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v21, (uint64_t)"data_archive_open_fd", v19, a6, a7, a8, v22);
    return 0xFFFFFFFFLL;
  }
  if (a2 == -1)
  {
    uint64_t v19 = "Invalid file descriptor";
    uint64_t v20 = a3;
    int v21 = 393;
    goto LABEL_10;
  }
  *(unsigned char *)(a1 + 16) = 1;
  int v11 = data_source_new(*(void *)(a1 + 8), 0);
  if (!v11)
  {
    uint64_t v19 = "Could not create data source";
    uint64_t v20 = a3;
    int v21 = 407;
    goto LABEL_10;
  }
  uint64_t v12 = (uint64_t)v11;
  data_source_set_fd(v11, a2);
  return data_archive_open_source(a1, v12, a3, v13, v14, v15, v16, v17);
}

uint64_t data_archive_open(uint64_t a1, char *__s, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    int v18 = "Invalid data archive";
    uint64_t v19 = a3;
    int v20 = 428;
LABEL_11:
    capture_error(v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v20, (uint64_t)"data_archive_open", v18, a6, a7, a8, v25);
    return 0xFFFFFFFFLL;
  }
  if (!__s)
  {
    int v18 = "Invalid path";
    uint64_t v19 = a3;
    int v20 = 434;
    goto LABEL_11;
  }
  if (platform_strlen(*(void *)(a1 + 8), __s) > 0x3FF) {
    return 0xFFFFFFFFLL;
  }
  int v11 = open(__s, 0);
  if (v11 == -1)
  {
    int v21 = __error();
    strerror(*v21);
    capture_error(a3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 447, (uint64_t)"data_archive_open", "Could not open %s: %s", v22, v23, v24, (char)__s);
    return 0xFFFFFFFFLL;
  }
  *(unsigned char *)(a1 + 17) = 1;
  return data_archive_open_fd(a1, v11, a3, v12, v13, v14, v15, v16);
}

uint64_t data_archive_open_custom(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    int v20 = "Invalid data archive";
    int v21 = a4;
    int v22 = 517;
LABEL_10:
    capture_error(v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v22, (uint64_t)"data_archive_open_custom", v20, a6, a7, a8, v23);
    return 0xFFFFFFFFLL;
  }
  if (!a3)
  {
    int v20 = "Invalid read handler";
    int v21 = a4;
    int v22 = 523;
    goto LABEL_10;
  }
  *(unsigned char *)(a1 + 16) = 1;
  uint64_t v12 = data_source_new(*(void *)(a1 + 8), 0);
  if (!v12)
  {
    int v20 = "Could not create data source";
    int v21 = a4;
    int v22 = 537;
    goto LABEL_10;
  }
  uint64_t v13 = (uint64_t)v12;
  data_source_set_handler((uint64_t)v12, a2, a3);
  return data_archive_open_source(a1, v13, a4, v14, v15, v16, v17, v18);
}

_DWORD *data_archive_read_entry(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    uint64_t v15 = "Invalid data archive";
    uint64_t v16 = a2;
    int v17 = 557;
LABEL_11:
    capture_error(v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v17, (uint64_t)"data_archive_read_entry", v15, a6, a7, a8, v45);
    return 0;
  }
  if (*(_DWORD *)(a1 + 48) == 2)
  {
    uint64_t v10 = *(void *)(a1 + 152);
    if (v10 >= 1)
    {
      int v11 = *(void **)(a1 + 160);
      if (!v11)
      {
        int v11 = platform_malloc(*(void *)(a1 + 8), 0x200uLL);
        *(void *)(a1 + 160) = v11;
        if (!v11)
        {
          uint64_t v40 = __error();
          char v41 = strerror(*v40);
          capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 943, (uint64_t)"consume_padding", "Could not allocate padding buffer: %s", v42, v43, v44, v41);
          goto LABEL_38;
        }
      }
      if ((unint64_t)v10 >= 0x201)
      {
        capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 950, (uint64_t)"consume_padding", "padding amount %lld is larger than buffer %lld", a6, a7, a8, v10);
LABEL_38:
        capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 574, (uint64_t)"data_archive_read_entry", "Could not consume padding %llu", v12, v13, v14, *(void *)(a1 + 152));
        return 0;
      }
      if (data_archive_decoder_read_data(*(void *)(a1 + 40), v11, v10, 0, a5, a6, a7, a8) == -1)
      {
        capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 957, (uint64_t)"consume_padding", "Could not consume %lld bytes of padding", a6, a7, a8, v10);
        goto LABEL_38;
      }
      *(void *)(a1 + 152) = 0;
    }
  }
  entry = data_archive_decoder_read_entry(*(void *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
  if (!entry)
  {
LABEL_31:
    uint64_t v15 = "Could not read next decoder entry";
    uint64_t v16 = a2;
    int v17 = 596;
    goto LABEL_11;
  }
  int v21 = entry;
  int v22 = (void *)(a1 + 52);
  while (2)
  {
    char v23 = *(unsigned int (**)(uint64_t, void *, void, void *))(a1 + 184);
    if (v23 && v23(a1, v21, *(void *)(a1 + 192), a2))
    {
      uint64_t v15 = "Format entry callback failed";
      uint64_t v16 = a2;
      int v17 = 605;
      goto LABEL_11;
    }
    uint64_t v24 = data_archive_entry_new(*(void *)(a1 + 8), 0);
    uint64_t v18 = v24;
    if (!v24)
    {
      capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 613, (uint64_t)"data_archive_read_entry", "Could not create empty archive entry", v25, v26, v27, v45);
      darc_format_entry_free(v21);
      return v18;
    }
    if (!data_archive_entry_set_format_entry((uint64_t)v24, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 144), v21, a2, v25, v26, v27))
    {
      *(_DWORD *)(a1 + 144) = darc_format_entry_get_type(v21);
      int v31 = *(_DWORD *)(a1 + 48);
      if (v31 == 2)
      {
        uint64_t v32 = data_archive_entry_size((uint64_t)v18);
        uint64_t v33 = 512 - v32;
        if (v32 >= 513) {
          uint64_t v33 = v32 & 0x1FF;
        }
        *(void *)(a1 + 152) = v33;
        int v31 = *(_DWORD *)(a1 + 48);
      }
      if (v31 == 9)
      {
        *(_DWORD *)(a1 + 148) = (data_archive_entry_crc32(v18) << 16) & 0xFF000000;
        *(unsigned char *)(a1 + 168) = 0;
      }
      darc_format_entry_free(v21);
      void *v22 = 0;
      *(void *)(a1 + 60) = 0;
      *(void *)(a1 + 73) = 0;
      *(void *)(a1 + 68) = 0;
      switch(data_archive_entry_get_type(v18))
      {
        case 0u:
          capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 698, (uint64_t)"data_archive_read_entry", "Unknown entry type", v37, v38, v39, v45);
          data_archive_entry_free(v18);
          return 0;
        case 1u:
        case 3u:
          *(_DWORD *)int v22 = 1;
          return v18;
        case 2u:
          *(_DWORD *)(a1 + 52) = data_archive_entry_get_data_type(v18);
          *(void *)(a1 + 56) = data_archive_entry_compressed_size((uint64_t)v18);
          *(void *)(a1 + 64) = data_archive_entry_size((uint64_t)v18);
          return v18;
        case 4u:
          *(_DWORD *)int v22 = 1;
          data_archive_entry_free(v18);
          goto LABEL_30;
        default:
LABEL_30:
          int v21 = data_archive_decoder_read_entry(*(void *)(a1 + 40), a2, v34, v35, v36, v37, v38, v39);
          if (!v21) {
            goto LABEL_31;
          }
          continue;
      }
    }
    break;
  }
  capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 627, (uint64_t)"data_archive_read_entry", "Could not set format entry", v28, v29, v30, v45);
  data_archive_entry_free(v18);
  darc_format_entry_free(v21);
  return 0;
}

size_t data_archive_read_data(uint64_t a1, void *a2, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684107875 || *(_DWORD *)(a1 + 200) != 1668440420)
  {
    uint64_t v13 = "data_archive_read_data";
    uint64_t v14 = "Invalid data archive";
    uint64_t v15 = a4;
    int v16 = 771;
    goto LABEL_11;
  }
  if (!a2)
  {
    uint64_t v13 = "data_archive_read_data";
    uint64_t v14 = "Invalid read buffer";
    uint64_t v15 = a4;
    int v16 = 777;
    goto LABEL_11;
  }
  if (!a3)
  {
    uint64_t v13 = "data_archive_read_data";
    uint64_t v14 = "Invalid read size";
    uint64_t v15 = a4;
    int v16 = 783;
LABEL_11:
    capture_error(v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v16, (uint64_t)v13, v14, a6, a7, a8, v103);
    return -1;
  }
  switch(*(_DWORD *)(a1 + 52))
  {
    case 1:
      return 0;
    case 2:
      return read_data_direct((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    case 3:
      if (*(unsigned char *)(a1 + 80)) {
        return 0;
      }
      if (*(void *)(a1 + 96)) {
        goto LABEL_20;
      }
      *(void *)(a1 + 88) = 0x20000;
      uint64_t v18 = platform_valloc(*(void *)(a1 + 8), 0x20000uLL);
      *(void *)(a1 + 96) = v18;
      if (!v18)
      {
        uint64_t v75 = *(void *)(a1 + 88);
        int v76 = __error();
        strerror(*v76);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1027, (uint64_t)"decompress_data", "Could not allocate %ld for read buffer: %s", v77, v78, v79, v75);
        return -1;
      }
      platform_memset(*(void *)(a1 + 8), v18, 0, *(void *)(a1 + 88));
      *(void *)(a1 + 104) = *(void *)(a1 + 96);
      *(void *)(a1 + 112) = 0;
LABEL_20:
      if (*(void *)(a1 + 120)) {
        goto LABEL_21;
      }
      int v31 = (z_stream *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x70uLL);
      *(void *)(a1 + 120) = v31;
      if (!v31)
      {
        __int16 v85 = __error();
        char v86 = strerror(*v85);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1043, (uint64_t)"decompress_data", "Could not allocate zlib stream: %s", v87, v88, v89, v86);
        return -1;
      }
      int v32 = inflateInit2_(v31, -15, "1.2.12", 112);
      if (v32)
      {
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1050, (uint64_t)"decompress_data", "Could not inflateInit2: %d", a6, a7, a8, v32);
        return -1;
      }
LABEL_21:
      size_t v19 = *(void *)(a1 + 112);
      if (v19)
      {
        int v20 = *(char **)(a1 + 104);
      }
      else
      {
        if (*(void *)(a1 + 88) >= *(void *)(a1 + 56) - *(void *)(a1 + 72)) {
          size_t v35 = *(void *)(a1 + 56) - *(void *)(a1 + 72);
        }
        else {
          size_t v35 = *(void *)(a1 + 88);
        }
        size_t data = data_archive_decoder_read_data(*(void *)(a1 + 40), *(void **)(a1 + 96), v35, 0, a5, a6, a7, a8);
        if (!data)
        {
          uint64_t v13 = "decompress_data";
          uint64_t v14 = "End of decoder";
          uint64_t v15 = a4;
          int v16 = 1082;
          goto LABEL_11;
        }
        size_t v19 = data;
        if (data == -1 && *__error() != 35)
        {
          capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1075, (uint64_t)"decompress_data", "Could not read %ld bytes from decoder", v37, v38, v39, v35);
          return -1;
        }
        int v20 = *(char **)(a1 + 96);
        *(void *)(a1 + 104) = v20;
        *(void *)(a1 + 112) = v19;
        *(void *)(a1 + 72) += v19;
      }
      uint64_t v40 = 0;
      char v41 = 0;
      uint64_t v42 = *(z_stream **)(a1 + 120);
      do
      {
        v42->next_in = (Bytef *)&v20[v40];
        v42->avail_in = v19 - v40;
        v42->next_out = (Bytef *)a2;
        v42->uInt avail_out = a3;
        int v43 = inflate(v42, 0);
        if (v43)
        {
          if (v43 != 1)
          {
            capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1134, (uint64_t)"decompress_data", "Could not inflate: %d", v45, v46, v47, v43);
            return -1;
          }
          char v41 = 1;
          *(unsigned char *)(a1 + 80) = 1;
        }
        uint64_t v48 = *(void *)(a1 + 112);
        uint64_t v42 = *(z_stream **)(a1 + 120);
        size_t v49 = v19 - v40 - v42->avail_in;
        int v20 = (char *)(*(void *)(a1 + 104) + v49);
        *(void *)(a1 + 104) = v20;
        *(void *)(a1 + 112) = v48 - v49;
        int64_t v17 = a3 - v42->avail_out;
        if (v41) {
          break;
        }
        v40 += v49;
      }
      while (!v17 && v19 != v40);
      if ((v41 & 1) == 0) {
        return v17;
      }
      if (v48 != v49)
      {
        int v51 = data_archive_decoder_rewind_data(*(void *)(a1 + 40), v20, v48 - v49, 0, v44, v45, v46, v47);
        if (v51)
        {
          capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1163, (uint64_t)"decompress_data", "Could not rewind remaining data: %d", v52, v53, v54, v51);
          return -1;
        }
        *(void *)(a1 + 104) = *(void *)(a1 + 96);
        *(void *)(a1 + 112) = 0;
        uint64_t v42 = *(z_stream **)(a1 + 120);
      }
      int v95 = inflateEnd(v42);
      if (!v95) {
        goto LABEL_111;
      }
      capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1178, (uint64_t)"decompress_data", "Could not inflateEnd: %d", v96, v97, v98, v95);
      return -1;
    case 4:
      if (!*(unsigned char *)(a1 + 168) && init_pkzip_cipher(a1, a4, a3, (uint64_t)a4, a5, a6, a7, a8))
      {
        uint64_t v13 = "decrypt_data";
        uint64_t v14 = "Could not initialize the PKZip cipher";
        uint64_t v15 = a4;
        int v16 = 1206;
        goto LABEL_11;
      }
      if (*(void *)(a1 + 64) == *(void *)(a1 + 72))
      {
        int64_t v17 = 0;
        goto LABEL_37;
      }
      int64_t data_direct = read_data_direct((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
      if (data_direct <= 0)
      {
        uint64_t v26 = __error();
        char v27 = strerror(*v26);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1222, (uint64_t)"decrypt_data", "Could not read ciphertext: %s", v28, v29, v30, v27);
        return -1;
      }
      int64_t v17 = data_direct;
      pkzip_crypto_decrypt_buffer((int *)(a1 + 172), (unsigned __int8 *)a2, data_direct);
      if (*(void *)(a1 + 64) != *(void *)(a1 + 72)) {
        return v17;
      }
      goto LABEL_37;
    case 5:
      return read_streamed_data(a1, (char *)a2, a3, a4, a5, a6, a7, a8);
    case 6:
      if (*(unsigned char *)(a1 + 80)) {
        return 0;
      }
      if (*(void *)(a1 + 96)) {
        goto LABEL_43;
      }
      *(void *)(a1 + 88) = 0x20000;
      char v23 = platform_valloc(*(void *)(a1 + 8), 0x20000uLL);
      *(void *)(a1 + 96) = v23;
      if (!v23)
      {
        uint64_t v80 = *(void *)(a1 + 88);
        int v81 = __error();
        strerror(*v81);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1378, (uint64_t)"decompress_streamed_data", "Could not allocate %ld for read buffer: %s", v82, v83, v84, v80);
        return -1;
      }
      platform_memset(*(void *)(a1 + 8), v23, 0, *(void *)(a1 + 88));
      *(void *)(a1 + 104) = *(void *)(a1 + 96);
      *(void *)(a1 + 112) = 0;
LABEL_43:
      if (*(void *)(a1 + 120)) {
        goto LABEL_44;
      }
      uint64_t v33 = (z_stream *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x70uLL);
      *(void *)(a1 + 120) = v33;
      if (!v33)
      {
        int v90 = __error();
        char v91 = strerror(*v90);
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1394, (uint64_t)"decompress_streamed_data", "Could not allocate zlib stream: %s", v92, v93, v94, v91);
        return -1;
      }
      int v34 = inflateInit2_(v33, -15, "1.2.12", 112);
      if (v34)
      {
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1401, (uint64_t)"decompress_streamed_data", "Could not inflateInit2: %d", a6, a7, a8, v34);
        return -1;
      }
LABEL_44:
      size_t v24 = *(void *)(a1 + 112);
      if (v24)
      {
        uint64_t v25 = *(char **)(a1 + 104);
      }
      else
      {
        size_t v55 = *(void *)(a1 + 88);
        size_t v56 = data_archive_decoder_read_data(*(void *)(a1 + 40), *(void **)(a1 + 96), v55, 0, a5, a6, a7, a8);
        if (!v56)
        {
          uint64_t v13 = "decompress_streamed_data";
          uint64_t v14 = "End of decoder";
          uint64_t v15 = a4;
          int v16 = 1427;
          goto LABEL_11;
        }
        size_t v24 = v56;
        if (v56 == -1 && *__error() != 35)
        {
          capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1420, (uint64_t)"decompress_streamed_data", "Could not read %ld bytes from decoder", v57, v58, v59, v55);
          return -1;
        }
        uint64_t v25 = *(char **)(a1 + 96);
        *(void *)(a1 + 104) = v25;
        *(void *)(a1 + 112) = v24;
      }
      uint64_t v60 = 0;
      char v61 = 0;
      uint64_t v62 = *(z_stream **)(a1 + 120);
      do
      {
        v62->next_in = (Bytef *)&v25[v60];
        v62->avail_in = v24 - v60;
        v62->next_out = (Bytef *)a2;
        v62->uInt avail_out = a3;
        int v63 = inflate(v62, 0);
        if (v63)
        {
          if (v63 != 1)
          {
            capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1476, (uint64_t)"decompress_streamed_data", "Could not inflate: %d", v65, v66, v67, v63);
            return -1;
          }
          char v61 = 1;
          *(unsigned char *)(a1 + 80) = 1;
        }
        uint64_t v68 = *(void *)(a1 + 112);
        uint64_t v62 = *(z_stream **)(a1 + 120);
        size_t v69 = v24 - v60 - v62->avail_in;
        uint64_t v25 = (char *)(*(void *)(a1 + 104) + v69);
        *(void *)(a1 + 104) = v25;
        *(void *)(a1 + 112) = v68 - v69;
        int64_t v17 = a3 - v62->avail_out;
        if (v61) {
          break;
        }
        v60 += v69;
      }
      while (!v17 && v24 != v60);
      if ((v61 & 1) == 0) {
        return v17;
      }
      if (v68 != v69)
      {
        int v71 = data_archive_decoder_rewind_data(*(void *)(a1 + 40), v25, v68 - v69, 0, v64, v65, v66, v67);
        if (v71)
        {
          capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1505, (uint64_t)"decompress_streamed_data", "Could not rewind remaining data: %d", v72, v73, v74, v71);
          return -1;
        }
        *(void *)(a1 + 104) = *(void *)(a1 + 96);
        *(void *)(a1 + 112) = 0;
        uint64_t v62 = *(z_stream **)(a1 + 120);
      }
      int v99 = inflateEnd(v62);
      if (v99)
      {
        capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1520, (uint64_t)"decompress_streamed_data", "Could not inflateEnd: %d", v100, v101, v102, v99);
        return -1;
      }
LABEL_111:
      platform_free(*(void *)(a1 + 8), *(void **)(a1 + 120));
      *(void *)(a1 + 120) = 0;
      return v17;
    case 7:
      if (!*(unsigned char *)(a1 + 168) && init_pkzip_cipher(a1, a4, a3, (uint64_t)a4, a5, a6, a7, a8))
      {
        uint64_t v13 = "decrypt_streamed_data";
        uint64_t v14 = "Could not initialize the PKZip cipher";
        uint64_t v15 = a4;
        int v16 = 1548;
        goto LABEL_11;
      }
      uint64_t streamed_data = read_streamed_data(a1, (char *)a2, a3, a4, a5, a6, a7, a8);
      if (streamed_data < 0)
      {
        uint64_t v13 = "decrypt_streamed_data";
        uint64_t v14 = "Could not read encrypted data";
        uint64_t v15 = a4;
        int v16 = 1561;
        goto LABEL_11;
      }
      int64_t v17 = streamed_data;
      if (streamed_data) {
        pkzip_crypto_decrypt_buffer((int *)(a1 + 172), (unsigned __int8 *)a2, streamed_data);
      }
      else {
LABEL_37:
      }
        *(unsigned char *)(a1 + 168) = 0;
      break;
    default:
      return -1;
  }
  return v17;
}

size_t read_data_direct(uint64_t *a1, void *a2, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[8] - a1[9] >= a3) {
    size_t v10 = a3;
  }
  else {
    size_t v10 = a1[8] - a1[9];
  }
  size_t data = data_archive_decoder_read_data(a1[5], a2, v10, 0, a5, a6, a7, a8);
  size_t v15 = data;
  if (data == -1) {
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 983, (uint64_t)"read_data_direct", "Could not read %ld from data decoder", v12, v13, v14, v10);
  }
  else {
    a1[9] += data;
  }
  return v15;
}

uint64_t read_streamed_data(uint64_t a1, char *a2, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 80)) {
    return 0;
  }
  char v10 = a3;
  size_t data = data_archive_decoder_read_data(*(void *)(a1 + 40), a2, a3, a4, a5, a6, a7, a8);
  if (!data)
  {
    int v22 = "End of decoder";
    char v23 = a4;
    int v24 = 1276;
LABEL_18:
    capture_error(v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v24, (uint64_t)"read_streamed_data", v22, v14, v15, v16, v34);
    return -1;
  }
  unint64_t v8 = data;
  if (data == -1 && *__error() != 35)
  {
    capture_error(a4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1269, (uint64_t)"read_streamed_data", "Could not read %ld bytes from decoder", v17, v18, v19, v10);
    return -1;
  }
  byte_stream_new(*(void *)(a1 + 8), 0);
  if (!v20)
  {
    int v22 = "Could not create byte stream";
    char v23 = a4;
    int v24 = 1292;
    goto LABEL_18;
  }
  int v21 = v20;
  if (v8 < 5)
  {
    byte_stream_free(v20);
    return v8;
  }
  uint64_t v25 = 0;
  unint64_t v26 = v8;
  do
  {
    byte_stream_attach((uint64_t)v21, (uint64_t)&a2[v25], v26);
    int uint32 = byte_stream_read_uint32((uint64_t)v21);
    v26 -= uint32 != 134695760;
    if (uint32 == 134695760) {
      break;
    }
    ++v25;
  }
  while (v26 > 4);
  byte_stream_free(v21);
  if (uint32 == 134695760)
  {
    *(unsigned char *)(a1 + 80) = 1;
    int v32 = data_archive_decoder_rewind_data(*(void *)(a1 + 40), &a2[v25], v26, a4, v28, v29, v30, v31);
    if (!v32)
    {
      v8 -= v26;
      return v8;
    }
    int v22 = "Could not rewind remaining data: %d";
    char v34 = v32;
    char v23 = a4;
    int v24 = 1334;
    goto LABEL_18;
  }
  return v8;
}

uint64_t init_pkzip_cipher(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 176) = 0;
  size_t v9 = (int *)(a1 + 172);
  *(_DWORD *)(a1 + 180) = 0;
  char v10 = *(uint64_t (**)(uint64_t, void, void *))(a1 + 128);
  if (v10)
  {
    uint64_t v12 = (char *)v10(a1, *(void *)(a1 + 136), a2);
    if (v12)
    {
      pkzip_crypto_init(v9, v12);
      uint64_t v14 = 0;
      uint64_t v15 = __dst;
      do
      {
        int64_t data = data_archive_decoder_read_data(*(void *)(a1 + 40), v15, 12 - v14, a2, v13, a6, a7, a8);
        if (data <= 0)
        {
          int v22 = __error();
          char v23 = strerror(*v22);
          capture_error(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", 1626, (uint64_t)"init_pkzip_cipher", "Could not read initial ciphertext: %s", v24, v25, v26, v23);
          return 0xFFFFFFFFLL;
        }
        int64_t v17 = data;
        pkzip_crypto_decrypt_buffer(v9, v15, data);
        v15 += v17;
        v14 += v17;
      }
      while (v14 != 12);
      if (*(unsigned __int8 *)(a1 + 151) == __dst[11])
      {
        uint64_t result = 0;
        *(unsigned char *)(a1 + 168) = 1;
        return result;
      }
      uint64_t v19 = "Decryption passphrase appears to be incorrect";
      int v20 = a2;
      int v21 = 1641;
    }
    else
    {
      uint64_t v19 = "Client did not provide passphrase";
      int v20 = a2;
      int v21 = 1606;
    }
  }
  else
  {
    uint64_t v19 = "No passphrase callback";
    int v20 = a2;
    int v21 = 1596;
  }
  capture_error(v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive.c", v21, (uint64_t)"init_pkzip_cipher", v19, a6, a7, a8, v27);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceNew(char *a1, const __CFDictionary *a2, uint64_t a3, void *a4)
{
  v180[2] = *(char **)MEMORY[0x263EF8340];
  if (!((unint64_t)a1 | (unint64_t)a2))
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 577, (uint64_t)"BOMCopierSourceNew", "path and options are NULL");
    return 0;
  }
  unint64_t v8 = malloc_type_calloc(1uLL, 0x180uLL, 0x10B00405CB9951FuLL);
  uint64_t v9 = (uint64_t)v8;
  if (!v8)
  {
    long long v110 = __error();
    BOMCopierErrorCapture(a4, *v110, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 590, (uint64_t)"BOMCopierSourceNew", "Could not allocate empty BOMCopierSource");
    return v9;
  }
  v8[3] = a3;
  *((_DWORD *)v8 + 8) = geteuid();
  gid_t v10 = getegid();
  *(_DWORD *)(v9 + 36) = v10;
  *(_DWORD *)(v9 + 40) = -1;
  *(_DWORD *)(v9 + 100) = 0;
  *(unsigned char *)(v9 + 64) = 1;
  *(void *)(v9 + 232) = 0x4000000;
  *(unsigned char *)(v9 + 160) = 1;
  int v11 = *(NSObject **)(v9 + 24);
  if (v11)
  {
    gid_t v12 = v10;
    if (os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
    {
      int32_t v13 = *(_DWORD *)(v9 + 32);
      buf.f_bsize = 67109376;
      buf.f_iosize = v13;
      LOWORD(buf.f_blocks) = 1024;
      *(_DWORD *)((char *)&buf.f_blocks + 2) = v12;
      _os_log_impl(&dword_2105F8000, v11, OS_LOG_TYPE_DEFAULT, "euid: %u egid: %u", (uint8_t *)&buf, 0xEu);
    }
  }
  if (a2)
  {
    CFTypeID TypeID = CFBooleanGetTypeID();
    CFDictionaryRef Value = CFDictionaryGetValue(a2, @"useFilesystemCache");
    if (Value)
    {
      uint64_t v16 = Value;
      if (TypeID != CFGetTypeID(Value))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1536, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionUseFilesystemCacheKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      *(unsigned char *)(v9 + 64) = CFEqual(v16, (CFTypeRef)*MEMORY[0x263EFFB40]) != 0;
    }
    int64_t v17 = CFDictionaryGetValue(a2, @"useEnumerationBom");
    if (v17)
    {
      uint64_t v18 = v17;
      if (TypeID != CFGetTypeID(v17))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1548, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionUseEnumerationBomKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      *(unsigned char *)(v9 + 65) = CFEqual(v18, (CFTypeRef)*MEMORY[0x263EFFB40]) != 0;
    }
    uint64_t v19 = CFDictionaryGetValue(a2, @"applyBomOwnership");
    if (v19)
    {
      int v20 = v19;
      if (TypeID != CFGetTypeID(v19))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1560, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionApplyBomOwnershipKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      *(unsigned char *)(v9 + 208) = CFEqual(v20, (CFTypeRef)*MEMORY[0x263EFFB40]) != 0;
    }
    int v21 = CFDictionaryGetValue(a2, @"allowAccessFailures");
    if (v21)
    {
      int v22 = v21;
      if (TypeID != CFGetTypeID(v21))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1572, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceAllowAccessFailuresKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      if (CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v22) == 1) {
        *(unsigned char *)(v9 + 209) = 1;
      }
    }
    char v23 = CFDictionaryGetValue(a2, @"crossDevices");
    if (v23)
    {
      uint64_t v24 = v23;
      if (TypeID != CFGetTypeID(v23))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1587, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionCrossDevicesKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      *(unsigned char *)(v9 + 160) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v24) != 0;
    }
    uint64_t v25 = CFDictionaryGetValue(a2, @"extractLibarchive");
    if (v25)
    {
      uint64_t v26 = v25;
      if (TypeID != CFGetTypeID(v25))
      {
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1599, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractLibarchiveKey must be a CFBooleanRef");
        goto LABEL_313;
      }
      if (CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v26) == 1) {
        *(_DWORD *)(v9 + 100) = 2;
      }
    }
    char v27 = CFDictionaryGetValue(a2, @"extractDataArchive");
    if (!v27)
    {
LABEL_33:
      uint64_t v29 = CFDictionaryGetValue(a2, @"enforceArchiveEntryPermissions");
      if (v29)
      {
        uint64_t v30 = v29;
        if (TypeID != CFGetTypeID(v29))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1629, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionEnforceArchiveEntryPermissionsKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 264) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v30) != 0;
      }
      uint64_t v31 = CFDictionaryGetValue(a2, @"extractAppleArchive");
      if (v31)
      {
        int v32 = v31;
        if (TypeID != CFGetTypeID(v31))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1641, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        if (CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v32) == 1) {
          *(_DWORD *)(v9 + 100) = 4;
        }
      }
      CFTypeID v33 = CFNumberGetTypeID();
      CFNumberRef v34 = (const __CFNumber *)CFDictionaryGetValue(a2, @"inputFD");
      if (v34)
      {
        CFNumberRef v35 = v34;
        if (v33 != CFGetTypeID(v34))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1658, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFNumberRef");
          goto LABEL_313;
        }
        buf.f_bsize = -1;
        if (!CFNumberGetValue(v35, kCFNumberSInt32Type, &buf))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1666, (uint64_t)"parse_copier_source_options", "Could not convert the input file descriptor number to kCFNumberSInt32Type");
          goto LABEL_313;
        }
        *(_DWORD *)(v9 + 40) = buf.f_bsize;
      }
      CFTypeID v36 = CFReadStreamGetTypeID();
      uint64_t v37 = (__CFReadStream *)CFDictionaryGetValue(a2, @"inputStream");
      if (v37)
      {
        uint64_t v38 = v37;
        if (v36 != CFGetTypeID(v37))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1680, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFReadStreamRef");
          goto LABEL_313;
        }
        if (CFReadStreamGetStatus(v38) != kCFStreamStatusOpen)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1687, (uint64_t)"parse_copier_source_options", "CFReadStream is not open");
          goto LABEL_313;
        }
        *(void *)(v9 + 48) = v38;
      }
      uint64_t v39 = CFDictionaryGetValue(a2, @"synthesizeResourceForks");
      if (v39)
      {
        uint64_t v40 = v39;
        if (TypeID != CFGetTypeID(v39))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1699, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionSynthesizeResourceForksKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 66) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v40) != 0;
      }
      char v41 = CFDictionaryGetValue(a2, @"synthesizeAppleDoubles");
      if (v41)
      {
        uint64_t v42 = v41;
        if (TypeID != CFGetTypeID(v41))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1711, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractAppleArchiveKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 67) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v42) != 0;
      }
      int v43 = CFDictionaryGetValue(a2, @"appleDoublesCaptureResourceAttributes");
      if (v43)
      {
        uint64_t v44 = v43;
        if (TypeID != CFGetTypeID(v43))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1725, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionAppleDoubleCaptureResourceAttributesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 68) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v44) != 0;
      }
      uint64_t v45 = CFDictionaryGetValue(a2, @"appleDoublesCaptureExtendedAttributes");
      if (v45)
      {
        uint64_t v46 = v45;
        if (TypeID != CFGetTypeID(v45))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1737, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionAppleDoubleCaptureExtendedAttributesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 69) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v46) != 0;
      }
      uint64_t v47 = CFDictionaryGetValue(a2, @"appleDoublesCaptureACLs");
      if (v47)
      {
        uint64_t v48 = v47;
        if (TypeID != CFGetTypeID(v47))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1749, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionAppleDoubleCaptureACLsKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 70) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v48) != 0;
      }
      size_t v49 = CFDictionaryGetValue(a2, @"deferAppleDoubles");
      if (v49)
      {
        uint64_t v50 = v49;
        if (TypeID != CFGetTypeID(v49))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1761, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDeferAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 71) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v50) != 0;
      }
      int v51 = CFDictionaryGetValue(a2, @"replayAppleDoubles");
      if (v51)
      {
        uint64_t v52 = v51;
        if (TypeID != CFGetTypeID(v51))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1773, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplayAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 72) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v52) != 0;
      }
      uint64_t v53 = CFDictionaryGetValue(a2, @"replaySymlinks");
      if (v53)
      {
        uint64_t v54 = v53;
        if (TypeID != CFGetTypeID(v53))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1785, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplaySymlinksKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 91) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v54) != 0;
      }
      size_t v55 = CFDictionaryGetValue(a2, @"replayDirectories");
      if (v55)
      {
        size_t v56 = v55;
        if (TypeID != CFGetTypeID(v55))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1797, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplayDirectoriesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 92) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v56) != 0;
      }
      uint64_t v57 = CFDictionaryGetValue(a2, @"excludeRootDirectory");
      if (v57)
      {
        uint64_t v58 = v57;
        if (TypeID != CFGetTypeID(v57))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1809, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExcludeRootDirectoryKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 93) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v58) != 0;
      }
      uint64_t v59 = CFDictionaryGetValue(a2, @"skipRootDirectory");
      if (v59)
      {
        uint64_t v60 = v59;
        if (TypeID != CFGetTypeID(v59))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1821, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionSkipRootDirectoryKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 94) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v60) != 0;
      }
      char v61 = CFDictionaryGetValue(a2, @"sequesterAppleDoubles");
      if (v61)
      {
        uint64_t v62 = v61;
        if (TypeID != CFGetTypeID(v61))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1833, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionSequesterAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 95) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v62) != 0;
      }
      int v63 = CFDictionaryGetValue(a2, @"unsequesterAppleDoubles");
      if (v63)
      {
        uint64_t v64 = v63;
        if (TypeID != CFGetTypeID(v63))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1845, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionUnsequesterAppleDoublesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 96) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v64) != 0;
      }
      CFNumberRef v65 = (const __CFNumber *)CFDictionaryGetValue(a2, @"libarchiveReadBlockSize");
      if (v65)
      {
        CFNumberRef v66 = v65;
        if (v33 != CFGetTypeID(v65))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1857, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionLibarchiveReadBlockSize must be a CFNumberRef");
          goto LABEL_313;
        }
        *(void *)&buf.f_bsize = 0;
        if (!CFNumberGetValue(v66, kCFNumberSInt64Type, &buf))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1865, (uint64_t)"parse_copier_source_options", "Could not convert the read block size number to kCFNumberSInt64Type");
          goto LABEL_313;
        }
        *(void *)(v9 + 232) = *(void *)&buf.f_bsize;
      }
      uint64_t v67 = CFDictionaryGetValue(a2, @"discoverBinaries");
      if (v67)
      {
        uint64_t v68 = v67;
        if (TypeID != CFGetTypeID(v67))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1877, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverBinaries must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 360) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v68) != 0;
      }
      size_t v69 = CFDictionaryGetValue(a2, @"discoverResourceAttribute");
      if (v69)
      {
        int v70 = v69;
        if (TypeID != CFGetTypeID(v69))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1889, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverResourceAttribute must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 361) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v70) != 0;
      }
      int v71 = CFDictionaryGetValue(a2, @"discoverExtendedAttributes");
      if (v71)
      {
        uint64_t v72 = v71;
        if (TypeID != CFGetTypeID(v71))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1901, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverExtendedAttributes must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 362) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v72) != 0;
      }
      uint64_t v73 = CFDictionaryGetValue(a2, @"discoverCompressionAttributes");
      if (v73)
      {
        uint64_t v74 = v73;
        if (TypeID != CFGetTypeID(v73))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1913, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverCompressionAttributes must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 363) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v74) != 0;
      }
      uint64_t v75 = CFDictionaryGetValue(a2, @"discoverACLs");
      if (v75)
      {
        int v76 = v75;
        if (TypeID != CFGetTypeID(v75))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1925, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverACLs must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 364) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v76) != 0;
      }
      uint64_t v77 = CFDictionaryGetValue(a2, @"discoverQuarantine");
      if (v77)
      {
        uint64_t v78 = v77;
        if (TypeID != CFGetTypeID(v77))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1937, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverQuarantine must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 365) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v78) != 0;
      }
      CFTypeID v79 = CFStringGetTypeID();
      CFStringRef v80 = (const __CFString *)CFDictionaryGetValue(a2, @"replayQuarantineFromPath");
      if (v80)
      {
        CFStringRef v81 = v80;
        if (v79 != CFGetTypeID(v80))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1951, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplayQuarantineFromPath must be a CFBooleanRef");
          goto LABEL_313;
        }
        CFIndex v82 = CFStringGetLength(v81) + 1;
        uint64_t v83 = (char *)malloc_type_calloc(1uLL, v82, 0x7DB4F0CAuLL);
        *(void *)(v9 + 368) = v83;
        if (!v83)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1963, (uint64_t)"parse_copier_source_options", "Could not allocate %ld bytes for path_size");
          goto LABEL_313;
        }
        if (!CFStringGetCString(v81, v83, v82, 0x8000100u))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1970, (uint64_t)"parse_copier_source_options", "Could not convert quarantine source path string to C string");
          goto LABEL_313;
        }
      }
      uint64_t v84 = CFDictionaryGetValue(a2, @"keepParent");
      if (v84)
      {
        __int16 v85 = v84;
        if (TypeID != CFGetTypeID(v84))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1980, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionKeepParent must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 376) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v85) != 0;
      }
      CFStringRef v86 = (const __CFString *)CFDictionaryGetValue(a2, @"passphrase");
      if (v86)
      {
        CFStringRef v87 = v86;
        if (v79 != CFGetTypeID(v86))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1992, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionPassphraseKey must be a CFStringRef");
          goto LABEL_313;
        }
        CFIndex v88 = CFStringGetLength(v87) + 1;
        uint64_t v89 = (char *)malloc_type_calloc(1uLL, v88, 0x8F28313BuLL);
        *(void *)(v9 + 240) = v89;
        if (!v89)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2002, (uint64_t)"parse_copier_source_options", "Could not allocate %ld bytes for passphrase_size");
          goto LABEL_313;
        }
        if (!CFStringGetCString(v87, v89, v88, 0x8000100u))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2009, (uint64_t)"parse_copier_source_options", "Could not convert passphrase string to C string");
          goto LABEL_313;
        }
      }
      int v90 = CFDictionaryGetValue(a2, @"discoverSegmentedFiles");
      if (v90)
      {
        char v91 = v90;
        if (TypeID != CFGetTypeID(v90))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2019, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDiscoverSegmentedFilesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 265) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v91) != 0;
      }
      uint64_t v92 = CFDictionaryGetValue(a2, @"ignoreAppleDoubles");
      if (v92)
      {
        uint64_t v93 = v92;
        if (TypeID != CFGetTypeID(v92))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2031, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionIgnoreAppleDoubles must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 88) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v93) != 0;
      }
      CFStringRef v94 = (const __CFString *)CFDictionaryGetValue(a2, @"appleDoubleSuffix");
      if (v94)
      {
        CFStringRef v95 = v94;
        if (v79 != CFGetTypeID(v94))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2043, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionAppleDoubleSuffix must be a CFStringRef");
          goto LABEL_313;
        }
        CFIndex v96 = CFStringGetLength(v95) + 1;
        uint64_t v97 = (char *)malloc_type_calloc(1uLL, v96, 0x97E3DC56uLL);
        *(void *)(v9 + 80) = v97;
        if (!v97)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2053, (uint64_t)"parse_copier_source_options", "Could not allocate %ld bytes for suffix_size");
          goto LABEL_313;
        }
        if (!CFStringGetCString(v95, v97, v96, 0x8000100u))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2060, (uint64_t)"parse_copier_source_options", "Could not convert AppleDouble suffix string to C string");
          goto LABEL_313;
        }
      }
      uint64_t v98 = CFDictionaryGetValue(a2, @"reorderExtraEntries");
      if (v98)
      {
        int v99 = v98;
        if (TypeID != CFGetTypeID(v98))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2070, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReorderExtraEntriesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 89) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v99) != 0;
      }
      uint64_t v100 = CFDictionaryGetValue(a2, @"replayExtraAppleDoubles");
      if (v100)
      {
        uint64_t v101 = v100;
        if (TypeID != CFGetTypeID(v100))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2082, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionReplayExtraAppleDoubleEntriesKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 90) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v101) != 0;
      }
      uint64_t v102 = CFDictionaryGetValue(a2, @"disableLexicographicSort");
      if (v102)
      {
        char v103 = v102;
        if (TypeID != CFGetTypeID(v102))
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2094, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionDisableLexicographicSortKey must be a CFBooleanRef");
          goto LABEL_313;
        }
        *(unsigned char *)(v9 + 97) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v103) != 0;
      }
      goto LABEL_139;
    }
    uint64_t v28 = v27;
    if (TypeID == CFGetTypeID(v27))
    {
      if (CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v28) == 1) {
        *(_DWORD *)(v9 + 100) = 3;
      }
      goto LABEL_33;
    }
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1614, (uint64_t)"parse_copier_source_options", "kBOMCopierSourceOptionExtractDataArchiveKey must be a CFBooleanRef");
LABEL_313:
    BOMCopierSourceFree((void *)v9);
    return 0;
  }
LABEL_139:
  int v104 = *(_DWORD *)(v9 + 100);
  if ((v104 - 2) >= 3 && *(unsigned char *)(v9 + 65))
  {
    *(_DWORD *)(v9 + 100) = 1;
    v105 = *(NSObject **)(v9 + 24);
    if (!v105 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
    {
LABEL_157:
      long long v111 = realpath_DARWIN_EXTSN(a1, 0);
      *(void *)(v9 + 176) = v111;
      if (v111)
      {
        long long v112 = *(NSObject **)(v9 + 24);
        if (v112)
        {
          uint64_t v113 = v111;
          if (os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
          {
            buf.f_bsize = 136315138;
            *(void *)&buf.f_iosize = v113;
            stat v114 = "Source path: %s";
            goto LABEL_161;
          }
        }
        return v9;
      }
      int v131 = *__error();
      v132 = __error();
      strerror(*v132);
      BOMCopierErrorCapture(a4, v131, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 803, (uint64_t)"BOMCopierSourceNew", "Could not resolve the path: %s");
      goto LABEL_313;
    }
    LOWORD(buf.f_bsize) = 0;
    _os_log_impl(&dword_2105F8000, v105, OS_LOG_TYPE_DEFAULT, "Using an enumeration bom", (uint8_t *)&buf, 2u);
    int v104 = *(_DWORD *)(v9 + 100);
  }
  switch(v104)
  {
    case 0:
      v106 = realpath_DARWIN_EXTSN(a1, 0);
      *(void *)(v9 + 128) = v106;
      if (!v106)
      {
        int v133 = *__error();
        v134 = __error();
        strerror(*v134);
        BOMCopierErrorCapture(a4, v133, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 716, (uint64_t)"BOMCopierSourceNew", "Could not resolve %s: %s");
        goto LABEL_313;
      }
      v107 = v106;
      if (!*(unsigned char *)(v9 + 376)) {
        goto LABEL_149;
      }
      if (!basename_r(v106, (char *)&buf))
      {
        int v151 = *__error();
        v152 = __error();
        strerror(*v152);
        BOMCopierErrorCapture(a4, v151, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 727, (uint64_t)"BOMCopierSourceNew", "Could not basename_r %s: %s");
        goto LABEL_313;
      }
      *(void *)(v9 + 136) = strlen((const char *)&buf) + 1;
      v107 = *(const char **)(v9 + 128);
LABEL_149:
      *(void *)(v9 + 144) = strlen(v107);
      v180[0] = (char *)v107;
      v180[1] = 0;
      if (*(unsigned char *)(v9 + 160)) {
        int v108 = 21;
      }
      else {
        int v108 = 85;
      }
      if (*(unsigned char *)(v9 + 97)) {
        long long v109 = 0;
      }
      else {
        long long v109 = (int (__cdecl *)(const FTSENT **, const FTSENT **))fts_compare;
      }
      v146 = fts_open(v180, v108, v109);
      *(void *)(v9 + 152) = v146;
      if (!v146)
      {
        int v149 = *__error();
        v150 = __error();
        strerror(*v150);
        BOMCopierErrorCapture(a4, v149, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 758, (uint64_t)"BOMCopierSourceNew", "Could not open the FTS handle for %s: %s");
        goto LABEL_313;
      }
      memset(&v176, 0, sizeof(v176));
      if (stat(*(const char **)(v9 + 128), &v176))
      {
        int v147 = *__error();
        v148 = __error();
        strerror(*v148);
        BOMCopierErrorCapture(a4, v147, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 771, (uint64_t)"BOMCopierSourceNew", "Could not stat %s: %s");
        goto LABEL_313;
      }
      *(_DWORD *)(v9 + 164) = v176.st_dev;
      bzero(&buf, 0x878uLL);
      if (statfs(*(const char **)(v9 + 128), &buf))
      {
        int v157 = *__error();
        v158 = __error();
        strerror(*v158);
        BOMCopierErrorCapture(a4, v157, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 782, (uint64_t)"BOMCopierSourceNew", "Could not statfs %s: %s");
        goto LABEL_313;
      }
      *(unsigned char *)(v9 + 168) = (buf.f_flags & 8) == 0;
      long long v112 = *(NSObject **)(v9 + 24);
      if (!v112 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
        return v9;
      }
      uint64_t v160 = *(void *)(v9 + 128);
      int v177 = 136315138;
      uint64_t v178 = v160;
      stat v114 = "Opened FTS from %s";
      p_statfs buf = (statfs *)&v177;
      goto LABEL_162;
    case 1:
      goto LABEL_157;
    case 2:
      uint64_t v118 = archive_read_new();
      *(void *)(v9 + 224) = v118;
      if (!v118)
      {
        int v135 = *__error();
        BOMCopierErrorCapture(a4, v135, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 823, (uint64_t)"BOMCopierSourceNew", "Could not create archive object");
        goto LABEL_313;
      }
      int support_filter_all = archive_read_support_filter_all();
      if (support_filter_all)
      {
        BOMCopierErrorCapture(a4, support_filter_all, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 832, (uint64_t)"BOMCopierSourceNew", "Could not enable read support for all filter types");
LABEL_234:
        archive_read_free();
        *(void *)(v9 + 224) = 0;
        goto LABEL_313;
      }
      int support_format_all = archive_read_support_format_all();
      if (support_format_all)
      {
        BOMCopierErrorCapture(a4, support_format_all, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 842, (uint64_t)"BOMCopierSourceNew", "Could not enable read support for all format types");
        goto LABEL_234;
      }
      int set_options = archive_read_set_options();
      if (set_options)
      {
        BOMCopierErrorCapture(a4, set_options, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 852, (uint64_t)"BOMCopierSourceNew", "Could not disable __MACOSX support\n");
        goto LABEL_234;
      }
      set_passphrase_callbacunsigned int k = archive_read_set_passphrase_callback();
      if (set_passphrase_callback)
      {
        BOMCopierErrorCapture(a4, set_passphrase_callback, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 866, (uint64_t)"BOMCopierSourceNew", "Could not set the passphrase callback\n");
        goto LABEL_234;
      }
      if (*(void *)(v9 + 240))
      {
        int add_passphrase = archive_read_add_passphrase();
        if (add_passphrase)
        {
          int v164 = add_passphrase;
          int v165 = archive_errno();
          strerror(v165);
          BOMCopierErrorCapture(a4, v164, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 878, (uint64_t)"BOMCopierSourceNew", "Could not add passphrase: %s\n");
          goto LABEL_234;
        }
      }
      if (prepare_archive_source(a1, v9, a4))
      {
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 894, (uint64_t)"BOMCopierSourceNew", "Could not prepare archive source");
        goto LABEL_234;
      }
      if (a1)
      {
        if (archive_read_open_filename())
        {
          archive_error_string();
          BOMCopierErrorCapture(a4, 3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 969, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %s for reading: %s");
          goto LABEL_234;
        }
        long long v112 = *(NSObject **)(v9 + 24);
        if (v112 && os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
        {
          buf.f_bsize = 136315138;
          *(void *)&buf.f_iosize = a1;
          stat v114 = "Opened archive from %s";
LABEL_161:
          p_statfs buf = &buf;
LABEL_162:
          v116 = v112;
          uint32_t v117 = 12;
          goto LABEL_163;
        }
        return v9;
      }
      if (*(void *)(v9 + 48))
      {
        v169 = malloc_type_valloc(*(void *)(v9 + 232), 0x138B50F5uLL);
        *(void *)(v9 + 56) = v169;
        if (!v169)
        {
          v174 = __error();
          strerror(*v174);
          BOMCopierErrorCapture(a4, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 920, (uint64_t)"BOMCopierSourceNew", "Could not allocate libarchive buffer: %s");
          goto LABEL_234;
        }
        int open = archive_read_open();
        if (open)
        {
          int v171 = open;
          archive_error_string();
          BOMCopierErrorCapture(a4, v171, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 935, (uint64_t)"BOMCopierSourceNew", "Could not open the archive_read_open2 for reading: %s");
          goto LABEL_234;
        }
        v168 = *(NSObject **)(v9 + 24);
        if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
          return v9;
        }
        LOWORD(buf.f_bsize) = 0;
        stat v114 = "Opened archive from CFReadStream";
LABEL_263:
        p_statfs buf = &buf;
        v116 = v168;
        uint32_t v117 = 2;
LABEL_163:
        _os_log_impl(&dword_2105F8000, v116, OS_LOG_TYPE_DEFAULT, v114, (uint8_t *)p_buf, v117);
        return v9;
      }
      if (*(_DWORD *)(v9 + 40) != -1)
      {
        int open_fd = archive_read_open_fd();
        if (open_fd)
        {
          int v173 = open_fd;
          archive_error_string();
          BOMCopierErrorCapture(a4, v173, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 954, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %d for reading: %s");
          goto LABEL_234;
        }
        v168 = *(NSObject **)(v9 + 24);
        if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
          return v9;
        }
        LOWORD(buf.f_bsize) = 0;
        stat v114 = "Opened archive from file descriptor";
        goto LABEL_263;
      }
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 947, (uint64_t)"BOMCopierSourceNew", "No input file descriptor\n");
      return 0;
    case 3:
      v120 = data_archive_new(0);
      *(void *)(v9 + 280) = v120;
      if (!v120)
      {
        int v136 = *__error();
        BOMCopierErrorCapture(a4, v136, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 986, (uint64_t)"BOMCopierSourceNew", "Could not create data_archive object");
        goto LABEL_313;
      }
      *(void *)&v176.st_dev = 0;
      int v125 = data_archive_set_passphrase_callback((uint64_t)v120, (uint64_t)data_archive_passphrase_callback_handler, v9, &v176, v121, v122, v123, v124);
      if (v125)
      {
        BOMCopierErrorCapture(a4, v125, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 999, (uint64_t)"BOMCopierSourceNew", "Could not set the passphrase callback: %s");
        goto LABEL_172;
      }
      int v140 = prepare_archive_source(a1, v9, a4);
      if (v140)
      {
        BOMCopierErrorCapture(a4, v140, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1013, (uint64_t)"BOMCopierSourceNew", "Could not prepare archive source");
        goto LABEL_313;
      }
      if (!a1)
      {
        if (*(void *)(v9 + 48))
        {
          int v162 = data_archive_open_custom(*(void *)(v9 + 280), v9, (uint64_t)data_source_read_callback, &v176, v142, v143, v144, v145);
          if (!v162)
          {
            v168 = *(NSObject **)(v9 + 24);
            if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
              return v9;
            }
            LOWORD(buf.f_bsize) = 0;
            stat v114 = "Opened data archive from CFReadStream";
            goto LABEL_263;
          }
          BOMCopierErrorCapture(a4, v162, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1030, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %d for custom reading: %s");
        }
        else
        {
          int v166 = *(_DWORD *)(v9 + 40);
          if (v166 == -1)
          {
            BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1041, (uint64_t)"BOMCopierSourceNew", "No input file descriptor\n");
            goto LABEL_313;
          }
          int v167 = data_archive_open_fd(*(void *)(v9 + 280), v166, &v176, v141, v142, v143, v144, v145);
          if (!v167)
          {
            v168 = *(NSObject **)(v9 + 24);
            if (!v168 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
              return v9;
            }
            LOWORD(buf.f_bsize) = 0;
            stat v114 = "Opened data archive from file descriptor";
            goto LABEL_263;
          }
          BOMCopierErrorCapture(a4, v167, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1049, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %d for reading: %s");
        }
LABEL_172:
        release_error(*(void **)&v176.st_dev);
        goto LABEL_313;
      }
      if (data_archive_open(*(void *)(v9 + 280), a1, &v176, v141, v142, v143, v144, v145))
      {
        BOMCopierErrorCapture(a4, 3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1063, (uint64_t)"BOMCopierSourceNew", "Could not open the archive %s for reading: %s");
        goto LABEL_172;
      }
      long long v112 = *(NSObject **)(v9 + 24);
      if (v112 && os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
      {
        buf.f_bsize = 136315138;
        *(void *)&buf.f_iosize = a1;
        stat v114 = "Opened data archive from %s";
        goto LABEL_161;
      }
      return v9;
    case 4:
      if (a1)
      {
        AAByteStream v126 = AAFileStreamOpenWithPath(a1, 0, 0);
        *(void *)(v9 + 288) = v126;
        if (!v126)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1116, (uint64_t)"BOMCopierSourceNew", "Could not open AppleArchive byte stream at %s");
          goto LABEL_313;
        }
        v127 = *(NSObject **)(v9 + 24);
        if (v127 && os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT))
        {
          buf.f_bsize = 136315138;
          *(void *)&buf.f_iosize = a1;
          v128 = "Opened AppleArchive from %s";
          v129 = v127;
          uint32_t v130 = 12;
LABEL_209:
          _os_log_impl(&dword_2105F8000, v129, OS_LOG_TYPE_DEFAULT, v128, (uint8_t *)&buf, v130);
        }
LABEL_210:
        v155 = AADecompressionInputStreamOpen(*(AAByteStream *)(v9 + 288), 0, 0);
        *(void *)(v9 + 296) = v155;
        if (v155)
        {
          AAArchiveStream v156 = AADecodeArchiveInputStreamOpen(v155, 0, 0, 0, 0);
          *(void *)(v9 + 304) = v156;
          if (v156) {
            return v9;
          }
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1135, (uint64_t)"BOMCopierSourceNew", "Could not create AppleArchive decoder");
        }
        else
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1127, (uint64_t)"BOMCopierSourceNew", "Could not open AppleArchive decompression stream at %s");
        }
        goto LABEL_313;
      }
      if (*(void *)(v9 + 48))
      {
        v137 = AACustomByteStreamOpen();
        *(void *)(v9 + 288) = v137;
        if (!v137)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1082, (uint64_t)"BOMCopierSourceNew", "Could not create custom AppleArchive byte stream at %s\n");
          goto LABEL_313;
        }
        AACustomByteStreamSetData(v137, (void *)v9);
        AACustomByteStreamSetCloseProc(*(AAByteStream *)(v9 + 288), (AAByteStreamCloseProc)apple_archive_close_callback);
        AACustomByteStreamSetReadProc(*(AAByteStream *)(v9 + 288), (AAByteStreamReadProc)apple_archive_read_callback);
        v138 = *(NSObject **)(v9 + 24);
        if (!v138 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_210;
        }
        LOWORD(buf.f_bsize) = 0;
        v128 = "Opened AppleArchive from CFReadStream";
      }
      else
      {
        int v153 = *(_DWORD *)(v9 + 40);
        if (v153 == -1)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1096, (uint64_t)"BOMCopierSourceNew", "No input file descriptor\n");
          goto LABEL_313;
        }
        AAByteStream v154 = AAFileStreamOpenWithFD(v153, 0);
        *(void *)(v9 + 288) = v154;
        if (!v154)
        {
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1104, (uint64_t)"BOMCopierSourceNew", "Could not open AppleArchive byte stream from file descriptor");
          goto LABEL_313;
        }
        v138 = *(NSObject **)(v9 + 24);
        if (!v138 || !os_log_type_enabled(*(os_log_t *)(v9 + 24), OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_210;
        }
        LOWORD(buf.f_bsize) = 0;
        v128 = "Opened AppleArchive from file descriptor";
      }
      v129 = v138;
      uint32_t v130 = 2;
      goto LABEL_209;
    default:
      return v9;
  }
}

void BOMCopierSourceFree(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)*((void *)a1 + 7);
    if (v2) {
      free(v2);
    }
    uint64_t v3 = (void *)*((void *)a1 + 34);
    if (v3) {
      free(v3);
    }
    char v4 = (void *)*((void *)a1 + 46);
    if (v4) {
      free(v4);
    }
    uint64_t v5 = *((void *)a1 + 43);
    if (v5) {
      path_tree_node_release(v5);
    }
    uint64_t v6 = *((void *)a1 + 44);
    if (v6)
    {
      while (!BOMStackIsEmpty(v6))
      {
        uint64_t v7 = BOMStackPop(*((uint64_t **)a1 + 44));
        BOMCopierSourceEntryFree((unsigned int *)v7);
        uint64_t v6 = *((void *)a1 + 44);
      }
      BOMStackFree(*((void ***)a1 + 44));
    }
    uint64_t v8 = *((void *)a1 + 42);
    if (v8)
    {
      while (!BOMStackIsEmpty(v8))
      {
        uint64_t v9 = BOMStackPop(*((uint64_t **)a1 + 42));
        BOMCopierSourceEntryFree((unsigned int *)v9);
        uint64_t v8 = *((void *)a1 + 42);
      }
      BOMStackFree(*((void ***)a1 + 42));
    }
    uint64_t v10 = *((void *)a1 + 41);
    if (v10)
    {
      while (!BOMStackIsEmpty(v10))
      {
        int v11 = BOMStackPop(*((uint64_t **)a1 + 41));
        BOMCopierSourceEntryFree((unsigned int *)v11);
        uint64_t v10 = *((void *)a1 + 41);
      }
      BOMStackFree(*((void ***)a1 + 41));
    }
    uint64_t v12 = *((void *)a1 + 40);
    if (v12)
    {
      while (!BOMStackIsEmpty(v12))
      {
        int32_t v13 = BOMStackPop(*((uint64_t **)a1 + 40));
        BOMCopierSourceEntryFree((unsigned int *)v13);
        uint64_t v12 = *((void *)a1 + 40);
      }
      BOMStackFree(*((void ***)a1 + 40));
    }
    uint64_t v14 = *((void *)a1 + 39);
    if (v14)
    {
      while (!BOMStackIsEmpty(v14))
      {
        uint64_t v15 = BOMStackPop(*((uint64_t **)a1 + 39));
        BOMCopierSourceEntryFree((unsigned int *)v15);
        uint64_t v14 = *((void *)a1 + 39);
      }
      BOMStackFree(*((void ***)a1 + 39));
    }
    uint64_t v16 = (void *)*((void *)a1 + 30);
    if (v16) {
      free(v16);
    }
    int64_t v17 = (AAArchiveStream_impl *)*((void *)a1 + 38);
    if (v17 && AAArchiveStreamClose(v17))
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "Could not close AppleArchive decoder: %d\n");
    }
    else
    {
      uint64_t v18 = (AAByteStream_impl *)*((void *)a1 + 37);
      if (v18 && AAByteStreamClose(v18))
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], "Could not close AppleArchive decompression stream: %d\n");
      }
      else
      {
        uint64_t v19 = (AAByteStream_impl *)*((void *)a1 + 36);
        if (v19 && AAByteStreamClose(v19))
        {
          fprintf((FILE *)*MEMORY[0x263EF8348], "Could not close AppleArchive byte stream: %d\n");
        }
        else
        {
          int v20 = (unsigned int *)*((void *)a1 + 35);
          if (v20) {
            data_archive_free(v20);
          }
          if (*((void *)a1 + 28)) {
            archive_read_free();
          }
          int v21 = (void *)*((void *)a1 + 25);
          if (v21) {
            BOMBomEnumeratorFree(v21);
          }
          uint64_t v22 = *((void *)a1 + 24);
          if (v22) {
            BOMFSObjectFree(v22);
          }
          char v23 = (void *)*((void *)a1 + 22);
          if (v23) {
            free(v23);
          }
          uint64_t v24 = (FTS *)*((void *)a1 + 19);
          if (v24) {
            fts_close(v24);
          }
          uint64_t v25 = (void *)*((void *)a1 + 16);
          if (v25) {
            free(v25);
          }
          uint64_t v26 = (void *)*((void *)a1 + 10);
          if (v26) {
            free(v26);
          }
          free(a1);
        }
      }
    }
  }
}

uint64_t fts_compare(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int16 *)(*(void *)a2 + 66) <= *(unsigned __int16 *)(*(void *)a1 + 66)) {
    size_t v2 = *(unsigned __int16 *)(*(void *)a1 + 66);
  }
  else {
    size_t v2 = *(unsigned __int16 *)(*(void *)a2 + 66);
  }
  return strncmp((const char *)(*(void *)a1 + 104), (const char *)(*(void *)a2 + 104), v2);
}

uint64_t libarchive_passphrase_callback_handler(uint64_t a1, void *a2)
{
  uint64_t result = a2[30];
  if (!result)
  {
    uint64_t v3 = (uint64_t (*)(void *, void, uint64_t *))a2[31];
    if (v3)
    {
      uint64_t v4 = 0;
      return v3(a2, a2[32], &v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t prepare_archive_source(const char *a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    memset(&v7, 0, sizeof(v7));
    if (stat(a1, &v7))
    {
      int v4 = *__error();
      uint64_t v5 = __error();
      strerror(*v5);
      BOMCopierErrorCapture(a3, v4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2131, (uint64_t)"prepare_archive_source", "Could not stat the archive %s: %s");
      return 1;
    }
    if (!v7.st_size)
    {
      BOMCopierErrorCapture(a3, 3, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2137, (uint64_t)"prepare_archive_source", "%s is empty: Unrecognized archive format");
      return 1;
    }
  }
  else if (!*(void *)(a2 + 48) && *(_DWORD *)(a2 + 40) == -1)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2117, (uint64_t)"prepare_archive_source", "No input file descriptor\n");
    return 1;
  }
  return 0;
}

uint64_t libarchive_open_callback()
{
  return 0;
}

uint64_t libarchive_read_callback(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a2) {
    return -1;
  }
  *a3 = *(void *)(a2 + 56);
  while (1)
  {
    CFIndex v4 = CFReadStreamRead(*(CFReadStreamRef *)(a2 + 48), *(UInt8 **)(a2 + 56), *(void *)(a2 + 232));
    if ((v4 & 0x8000000000000000) == 0) {
      break;
    }
    if (*__error() != 4)
    {
      __error();
      archive_set_error();
      return v4;
    }
  }
  return v4;
}

uint64_t libarchive_close_callback()
{
  return 0;
}

uint64_t data_archive_passphrase_callback_handler(uint64_t a1, void *a2)
{
  uint64_t result = a2[30];
  if (!result)
  {
    uint64_t v3 = (uint64_t (*)(void *, void, uint64_t *))a2[31];
    if (v3)
    {
      uint64_t v4 = 0;
      return v3(a2, a2[32], &v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFIndex data_source_read_callback(uint64_t a1, int a2, UInt8 *buffer, CFIndex bufferLength)
{
  if (a1) {
    return CFReadStreamRead(*(CFReadStreamRef *)(a1 + 48), buffer, bufferLength);
  }
  else {
    return -1;
  }
}

uint64_t apple_archive_close_callback()
{
  return 0;
}

CFIndex apple_archive_read_callback(uint64_t a1, UInt8 *a2, CFIndex a3)
{
  if (a1) {
    return CFReadStreamRead(*(CFReadStreamRef *)(a1 + 48), a2, a3);
  }
  else {
    return -1;
  }
}

void path_tree_node_release(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 8))
  {
    unint64_t v2 = 0;
    do
      path_tree_node_release(*(void *)(*(void *)(a1 + 16) + 8 * v2++));
    while (v2 < *(unsigned int *)(a1 + 8));
  }
  uint64_t v3 = *(void **)(a1 + 16);
  if (v3) {
    free(v3);
  }
  if (*(void *)a1) {
    free(*(void **)a1);
  }
  free((void *)a1);
}

uint64_t BOMCopierSourceSetErrorHandler(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0;
    *a1 = a2;
    a1[1] = a3;
  }
  else
  {
    uint64_t v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1329, (uint64_t)"BOMCopierSourceSetErrorHandler", "copier_source is NULL");
  }
  return v4;
}

uint64_t BOMCopierSourceSetEnumerationBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a1)
  {
    uint64_t v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1348, (uint64_t)"BOMCopierSourceSetEnumerationBom", "copier_source is NULL");
    return v7;
  }
  if (!a2)
  {
    uint64_t v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1354, (uint64_t)"BOMCopierSourceSetEnumerationBom", "enumeration_bom is NULL");
    return v7;
  }
  if (*(_DWORD *)(a1 + 100) != 1)
  {
    uint64_t v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1360, (uint64_t)"BOMCopierSourceSetEnumerationBom", "The copier source is not BOMCopierSourceIndexBom");
    return v7;
  }
  if (!*(unsigned char *)(a1 + 65))
  {
    uint64_t v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1366, (uint64_t)"BOMCopierSourceSetEnumerationBom", "The copier source is not configured to use an enumeration bom");
    return v7;
  }
  *(void *)(a1 + 184) = a2;
  RootFSObject = (unsigned int *)BOMBomGetRootFSObject(a2);
  *(void *)(a1 + 192) = RootFSObject;
  if (!RootFSObject)
  {
    uint64_t v7 = 1;
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1375, (uint64_t)"BOMCopierSourceSetEnumerationBom", "Could not get the root fso for the enumeration bom");
LABEL_15:
    BOMCopierSourceFree((void *)a1);
    return v7;
  }
  uint64_t v6 = BOMBomEnumeratorNew(*(void *)(a1 + 184), RootFSObject);
  *(void *)(a1 + 200) = v6;
  if (!v6)
  {
    uint64_t v7 = 1;
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1390, (uint64_t)"BOMCopierSourceSetEnumerationBom", "Could not create enumerator for the enumeration bom");
    goto LABEL_15;
  }
  return 0;
}

uint64_t BOMCopierSourceSetAllowBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    uint64_t v3 = 0;
    *(void *)(a1 + 216) = a2;
  }
  else
  {
    uint64_t v3 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1410, (uint64_t)"BOMCopierSourceSetAllowBom", "copier_source is NULL");
  }
  return v3;
}

uint64_t BOMCopierSourceSetRedirectCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0;
    *(void *)(a1 + 112) = a2;
    *(void *)(a1 + 120) = a3;
  }
  else
  {
    uint64_t v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1433, (uint64_t)"BOMCopierSourceSetRedirectCallback", "copier_source is NULL");
  }
  return v4;
}

uint64_t BOMCopierSourceSetPassphraseCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0;
    *(void *)(a1 + 248) = a2;
    *(void *)(a1 + 256) = a3;
  }
  else
  {
    uint64_t v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1453, (uint64_t)"BOMCopierSourceSetPassphraseCallback", "copier_source is NULL");
  }
  return v4;
}

uint64_t *BOMCopierSourceNext(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a2;
  uint64_t v148 = *MEMORY[0x263EF8340];
  if (a1)
  {
    uint64_t v10 = (unsigned char *)(a1 + 104);
    uint64_t v133 = a1 + 112;
    int v11 = &dword_2105F8000;
    while (1)
    {
      v134 = 0;
      uint64_t v12 = *(uint64_t **)(a1 + 312);
      if (v12)
      {
        int32_t v13 = *(NSObject **)(a1 + 24);
        if (v13 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v11, v13, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the pre-empt stack", buf, 2u);
          uint64_t v12 = *(uint64_t **)(a1 + 312);
        }
        filesystem_entry = (unsigned int *)BOMStackPop(v12);
        int v136 = 0;
        if (filesystem_entry) {
          break;
        }
      }
      else
      {
        int v136 = 0;
      }
      if (*v10)
      {
LABEL_11:
        filesystem_entry = 0;
      }
      else
      {
        uint64_t v16 = *(NSObject **)(a1 + 24);
        if (v16 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v11, v16, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the source", buf, 2u);
        }
        switch(*(_DWORD *)(a1 + 100))
        {
          case 0:
            v139[0] = 0;
            if (*(void *)v133)
            {
              (*(void (**)(uint64_t, char **, void))v133)(a1, v139, *(void *)(a1 + 120));
              *(void *)uint64_t v133 = 0;
              *(void *)(v133 + 8) = 0;
              int64_t v17 = *(NSObject **)(a1 + 24);
              if (v17)
              {
                if (os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)statfs buf = 136315138;
                  *(char **)&buf[4] = v139[0];
                  _os_log_impl(v11, v17, OS_LOG_TYPE_DEFAULT, "Redirected to %s", buf, 0xCu);
                }
              }
            }
            filesystem_entry = (unsigned int *)next_filesystem_entry(a1, v139[0], v10, (uint64_t *)&v136);
            if (v139[0]) {
              free(v139[0]);
            }
            break;
          case 1:
            uint64_t v48 = *(void *)(a1 + 200);
            if (!v48)
            {
              BOMCopierErrorCapture(&v136, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2837, (uint64_t)"next_enumeration_bom_entry", "The BOMCopierSource does not have an index bom enumerator", v129);
              goto LABEL_11;
            }
            size_t v49 = BOMBomEnumeratorNext(v48);
            if (v49)
            {
              uint64_t v50 = (uint64_t)v49;
              __int16 v51 = *(unsigned char *)(a1 + 64) == 0;
              if (*(unsigned char *)(a1 + 360)) {
                v51 |= 2u;
              }
              if (*(unsigned char *)(a1 + 361)) {
                v51 |= 8u;
              }
              if (*(unsigned char *)(a1 + 362)) {
                v51 |= 4u;
              }
              if (*(unsigned char *)(a1 + 363)) {
                v51 |= 0x10u;
              }
              if (*(unsigned char *)(a1 + 364)) {
                v51 |= 0x20u;
              }
              if (*(unsigned char *)(a1 + 365)) {
                v51 |= 0x40u;
              }
              if (*(unsigned char *)(a1 + 209)) {
                v51 |= 0x100u;
              }
              if (*(unsigned char *)(a1 + 208)) {
                __int16 v52 = v51 | 0x80;
              }
              else {
                __int16 v52 = v51;
              }
              filesystem_entry = (unsigned int *)BOMCopierSourceEntryNewFromFSObject(*(const char **)(a1 + 176), (uint64_t)v49, v52, &v136);
              if (filesystem_entry)
              {
                int v53 = BOMFSObjectParentPathID(v50);
                int v54 = BOMFSObjectPathID(v50);
                if (!v53 && v54 == 1) {
                  BOMCopierSourceEntrySetRoot((uint64_t)filesystem_entry, 1);
                }
                BOMFSObjectFree(v50);
                if (synthesize_filesystem_stuff())
                {
                  BOMCopierErrorCapture(&v136, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2918, (uint64_t)"next_enumeration_bom_entry", "Could not synthesize filesystem stuff");
                  BOMCopierSourceEntryFree(filesystem_entry);
                  goto LABEL_11;
                }
              }
              else
              {
                BOMCopierErrorCapture(&v136, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2900, (uint64_t)"next_enumeration_bom_entry", "Could not synthesize filesystem stuff");
                BOMFSObjectFree(v50);
              }
            }
            else
            {
              filesystem_entry = 0;
              *uint64_t v10 = 1;
            }
            break;
          case 2:
            if (!*(void *)(a1 + 224))
            {
              BOMCopierErrorCapture(&v136, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2942, (uint64_t)"next_libarchive_entry", "copier_source->archive is NULL", v129);
              goto LABEL_11;
            }
            if (*(unsigned char *)(a1 + 360)) {
              __int16 v55 = (*(unsigned __int8 *)(a1 + 264) << 9) | 2;
            }
            else {
              __int16 v55 = *(unsigned __int8 *)(a1 + 264) << 9;
            }
            *(void *)statfs buf = 0;
            int next_header = archive_read_next_header();
            if (archive_read_has_encrypted_entries() == 1
              && !*(void *)(a1 + 240)
              && !*(void *)(a1 + 248))
            {
              BOMCopierErrorCapture(&v136, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2973, (uint64_t)"next_libarchive_entry", "archive has encrypted entries");
              goto LABEL_11;
            }
            if (next_header == -30)
            {
              CFStringRef v81 = (const char *)archive_error_string();
              if (!v81 || strcmp(v81, "Invalid central directory signature"))
              {
                BOMCopierErrorCapture(&v136, -30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3010, (uint64_t)"next_libarchive_entry", "Could not read archive header: ARCHIVE_FATAL: %s");
                goto LABEL_11;
              }
              goto LABEL_186;
            }
            if (next_header == 1) {
              goto LABEL_186;
            }
            if (next_header)
            {
              archive_error_string();
              BOMCopierErrorCapture(&v136, next_header, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3018, (uint64_t)"next_libarchive_entry", "Could not read archive header: %d: %s");
              goto LABEL_11;
            }
            uint64_t v57 = BOMCopierSourceEntryNewFromLibarchive(*(void *)(a1 + 224), *(uint64_t *)buf, v55, &v136);
LABEL_122:
            filesystem_entry = (unsigned int *)v57;
            break;
          case 3:
            uint64_t v57 = next_data_archive_entry(a1, v10, &v136, a4, a5, a6, a7, a8);
            goto LABEL_122;
          case 4:
            uint64_t v58 = *(AAArchiveStream_impl **)(a1 + 304);
            if (!v58)
            {
              BOMCopierErrorCapture(&v136, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3114, (uint64_t)"next_apple_archive_entry", "copier_source->aa_decoder is NULL", v129);
              goto LABEL_11;
            }
            if (*(unsigned char *)(a1 + 360)) {
              char v59 = 2;
            }
            else {
              char v59 = 0;
            }
            if (*(unsigned char *)(a1 + 362)) {
              v59 |= 4u;
            }
            if (*(unsigned char *)(a1 + 364)) {
              unsigned __int8 v60 = v59 | 0x20;
            }
            else {
              unsigned __int8 v60 = v59;
            }
            *(void *)statfs buf = 0;
            int Header = AAArchiveStreamReadHeader(v58, (AAHeader *)buf);
            if (Header < 0)
            {
              int v62 = 3146;
              goto LABEL_155;
            }
            if (Header == 1)
            {
              filesystem_entry = (unsigned int *)BOMCopierSourceEntryNewFromAppleArchive(*(void *)(a1 + 304), *(AAHeader *)buf, v60, &v136);
              AAHeaderDestroy(*(AAHeader *)buf);
            }
            else
            {
              if (Header)
              {
                int v62 = 3154;
LABEL_155:
                BOMCopierErrorCapture(&v136, Header, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", v62, (uint64_t)"next_apple_archive_entry", "Could not read AppleArchive header: %d");
                goto LABEL_11;
              }
LABEL_186:
              filesystem_entry = 0;
              *uint64_t v10 = 1;
            }
            break;
          default:
            goto LABEL_11;
        }
      }
      if (v136)
      {
        if (*(_DWORD *)(a1 + 16) == 1)
        {
          BOMCopierErrorFree(v136);
          *(_DWORD *)(a1 + 16) = 1;
          uint64_t v15 = *(NSObject **)(a1 + 24);
          if (v15 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)statfs buf = 0;
            _os_log_impl(v11, v15, OS_LOG_TYPE_DEFAULT, "Swallowing error", buf, 2u);
          }
        }
        else
        {
          v134 = v136;
          BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2354, (uint64_t)"next_source_entry", "Could not get the next source entry");
        }
        goto LABEL_318;
      }
      if (filesystem_entry) {
        break;
      }
LABEL_283:
      if (!*v10) {
        goto LABEL_318;
      }
      if (*(void *)(a1 + 344))
      {
        if (!*(void *)(a1 + 352))
        {
          uint64_t v121 = (char *)BOMStackNew();
          *(void *)(a1 + 352) = v121;
          if (!v121)
          {
            BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4823, (uint64_t)"populate_sequester_stack", "Could not create empty sequester stack");
            goto LABEL_317;
          }
          uint64_t v122 = *(void *)(a1 + 344);
          if (*(unsigned char *)(a1 + 93))
          {
            if (path_tree_node_push(*(void *)(a1 + 344), 0, v121, &v134))
            {
              BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4844, (uint64_t)"populate_sequester_stack", "Could not push root node %s onto the stack\n");
LABEL_317:
              BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2400, (uint64_t)"next_source_entry", "Could not populate sequester stack");
              goto LABEL_318;
            }
          }
          else if (*(_DWORD *)(v122 + 8))
          {
            uint64_t v123 = 0;
            while (!path_tree_node_push(*(void *)(*(void *)(v122 + 16) + 8 * v123), ".", *(char **)(a1 + 352), &v134))
            {
              if (++v123 >= (unint64_t)*(unsigned int *)(v122 + 8)) {
                goto LABEL_286;
              }
            }
            BOMCopierErrorCapture(&v134, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4860, (uint64_t)"populate_sequester_stack", "Could not push child %s of %s onto the stack\n");
            goto LABEL_317;
          }
        }
LABEL_286:
        int v108 = *(NSObject **)(a1 + 24);
        if (v108 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v11, v108, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the sequester stack", buf, 2u);
        }
        char v91 = BOMStackPop(*(uint64_t **)(a1 + 352));
        if (v91) {
          goto LABEL_302;
        }
      }
      long long v109 = *(uint64_t **)(a1 + 320);
      if (v109 || *(void *)(a1 + 328) || *(void *)(a1 + 336))
      {
        long long v110 = *(NSObject **)(a1 + 24);
        if (v110 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v11, v110, OS_LOG_TYPE_DEFAULT, "Retrieving entry from the replay stacks", buf, 2u);
          long long v109 = *(uint64_t **)(a1 + 320);
        }
        if (v109)
        {
          char v91 = BOMStackPop(v109);
          if (v91) {
            goto LABEL_302;
          }
        }
        long long v111 = *(uint64_t **)(a1 + 328);
        if (v111)
        {
          char v91 = BOMStackPop(v111);
          if (v91) {
            goto LABEL_302;
          }
        }
        long long v112 = *(uint64_t **)(a1 + 336);
        if (v112)
        {
          char v91 = BOMStackPop(v112);
          if (v91) {
            goto LABEL_302;
          }
        }
      }
LABEL_318:
      v107 = v134;
      if (v134)
      {
LABEL_352:
        char v91 = 0;
        if (v8) {
          *uint64_t v8 = v107;
        }
        return v91;
      }
      if (*v10) {
        return 0;
      }
    }
    int v135 = 0;
    if ((*(_DWORD *)(a1 + 100) - 2) <= 2 && *(void *)(a1 + 216))
    {
      Path = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      if (!Path)
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3181, (uint64_t)"filter_next_source_entry", "Could not get entry path for source entry", v129);
LABEL_49:
        char v23 = filesystem_entry;
LABEL_50:
        BOMCopierSourceEntryFree(v23);
        goto LABEL_282;
      }
      *(void *)statfs buf = 0;
      if (*Path == 46)
      {
        uint64_t v19 = (uint64_t)Path;
      }
      else if (asprintf((char **)buf, "./%s", Path) == -1 || (uint64_t v19 = *(void *)buf) == 0)
      {
        int v63 = *__error();
        BOMCopierErrorCapture(&v135, v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3194, (uint64_t)"filter_next_source_entry", "Could not construct lookup path for skip bom from %s");
        goto LABEL_49;
      }
      BOOL v20 = BOMBomFSObjectExistsAtPath(*(void *)(a1 + 216), v19);
      if (*(void *)buf) {
        free(*(void **)buf);
      }
      if (!v20)
      {
        if (consume_source_entry(filesystem_entry, &v135))
        {
          int v22 = 3216;
          goto LABEL_48;
        }
LABEL_282:
        v107 = v135;
        if (v135) {
          goto LABEL_352;
        }
        goto LABEL_283;
      }
    }
    if ((*(unsigned char *)(a1 + 93) || *(unsigned char *)(a1 + 94)) && BOMCopierSourceEntryIsRoot((uint64_t)filesystem_entry))
    {
      int v21 = *(NSObject **)(a1 + 24);
      if (v21 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v11, v21, OS_LOG_TYPE_DEFAULT, "Consuming root entry", buf, 2u);
      }
      if (consume_source_entry(filesystem_entry, &v135))
      {
        int v22 = 3240;
LABEL_48:
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", v22, (uint64_t)"filter_next_source_entry", "Could not consume the source entry", v129);
        goto LABEL_49;
      }
      goto LABEL_282;
    }
    uint64_t v24 = v11;
    int Type = BOMCopierSourceEntryGetType((uint64_t)filesystem_entry);
    if (*(unsigned char *)(a1 + 96))
    {
      unsigned int v26 = BOMCopierSourceEntryGetType((uint64_t)filesystem_entry);
      if (v26 <= 0xE && ((1 << v26) & 0x6040) != 0)
      {
        char v27 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
        if (v27)
        {
          uint64_t v28 = v27;
          size_t v29 = strlen(v27);
          int v30 = *(unsigned __int8 *)v28;
          size_t v31 = v30 == 46 ? 10 : 8;
          if (v29 >= v31)
          {
            int v32 = v30 == 46 ? "./__MACOSX" : "__MACOSX";
            if (!strncmp(v28, v32, v31))
            {
              CFNumberRef v66 = *(NSObject **)(a1 + 24);
              int v11 = v24;
              if (v66 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)statfs buf = 0;
                _os_log_impl(v24, v66, OS_LOG_TYPE_DEFAULT, "Consuming __MACOSX directory entry", buf, 2u);
              }
              if (consume_source_entry(filesystem_entry, &v135))
              {
                int v22 = 3268;
                goto LABEL_48;
              }
              goto LABEL_282;
            }
          }
        }
      }
    }
    if (!is_apple_double(filesystem_entry)) {
      goto LABEL_203;
    }
    if (*(unsigned char *)(a1 + 95))
    {
      CFTypeID v33 = *(NSObject **)(a1 + 24);
      if (v33 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v24, v33, OS_LOG_TYPE_DEFAULT, "Sequestering __MACOSX entry", buf, 2u);
      }
      uint64_t v34 = BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      if (v34)
      {
        CFNumberRef v35 = (const char *)v34;
        CFTypeID v36 = *(NSObject **)(a1 + 24);
        if (v36 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 136315138;
          *(void *)&buf[4] = v35;
          _os_log_impl(v24, v36, OS_LOG_TYPE_DEFAULT, "Sequestering AppleDouble from %s", buf, 0xCu);
        }
        uint64_t v37 = "./__MACOSX";
        if (*(unsigned char *)(a1 + 93)) {
          uint64_t v37 = "__MACOSX";
        }
        uint64_t v38 = &v35[2 * (*v35 == 46)];
        v137 = 0;
        if (asprintf(&v137, "%s/%s", v37, v38) != -1 && v137)
        {
          if (BOMCopierSourceEntrySetPath(filesystem_entry, v137))
          {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4393, (uint64_t)"sequester_apple_double", "Could not create set sequester path entry for %s", v35);
LABEL_269:
            BOMCopierSourceEntryFree(filesystem_entry);
            goto LABEL_270;
          }
          free(v137);
          uint64_t v67 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
          uint64_t v68 = v67;
          v139[0] = 0;
          v139[1] = (char *)v139;
          v139[2] = (char *)0x2000000000;
          v139[3] = 0;
          v138[0] = 0;
          v138[1] = v138;
          v138[2] = 0x2000000000;
          v138[3] = 0;
          *(void *)statfs buf = MEMORY[0x263EF8330];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = __add_sequester_entry_block_invoke;
          uint64_t v142 = &unk_264132760;
          uint64_t v145 = a1;
          v146 = &v135;
          uint64_t v143 = v139;
          uint64_t v144 = v138;
          int v147 = filesystem_entry;
          if (v67)
          {
            size_t v69 = strlen(v67);
            __s = 0;
            if (v69 == asprintf(&__s, "%s", v68))
            {
              int v70 = __s;
              if (__s)
              {
                int v131 = v68;
                v132 = v8;
                int v71 = strchr(__s, 47);
                uint64_t v72 = v70;
                uint64_t v73 = v70;
                if (v71)
                {
                  while (1)
                  {
                    *int v71 = 0;
                    int v74 = (*(uint64_t (**)(unsigned char *, char *, void))&buf[16])(buf, v72, 0);
                    if (v74) {
                      break;
                    }
                    *int v71 = 47;
                    uint64_t v72 = v71 + 1;
                    uint64_t v73 = __s;
                    if (v71 + 1 - __s < v69)
                    {
                      int v71 = strchr(v71 + 1, 47);
                      if (v71) {
                        continue;
                      }
                    }
                    goto LABEL_163;
                  }
                  int v75 = v74;
                  uint64_t v73 = __s;
                }
                else
                {
LABEL_163:
                  if (v72 == &v70[v69]
                    || (int v75 = (*(uint64_t (**)(unsigned char *, char *, uint64_t))&buf[16])(buf, v72, 1),
                        uint64_t v73 = __s,
                        !v75))
                  {
                    free(v73);
                    uint64_t v8 = v132;
LABEL_267:
                    _Block_object_dispose(v138, 8);
                    _Block_object_dispose(v139, 8);
                    goto LABEL_281;
                  }
                }
                free(v73);
                BOOL v106 = v75 == -1;
                uint64_t v68 = v131;
                uint64_t v8 = v132;
                if (!v106) {
                  goto LABEL_267;
                }
              }
            }
          }
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4806, (uint64_t)"add_sequester_entry", "Could not add sequester entry for %s", v68);
          _Block_object_dispose(v138, 8);
          _Block_object_dispose(v139, 8);
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4408, (uint64_t)"sequester_apple_double", "Could not create set sequester path entry for %s", v35);
          goto LABEL_269;
        }
        int v64 = *__error();
        CFNumberRef v65 = __error();
        strerror(*v65);
        BOMCopierErrorCapture(&v135, v64, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4385, (uint64_t)"sequester_apple_double", "Could not create sequester path for %s: %s");
      }
      else
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4359, (uint64_t)"sequester_apple_double", "Could not retrieve entry path for AppleDouble entry");
      }
LABEL_270:
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3300, (uint64_t)"filter_next_source_entry", "Could not sequester AppleDouble entry", v130);
      goto LABEL_281;
    }
    uint64_t v39 = v8;
    if (*(unsigned char *)(a1 + 96))
    {
      uint64_t v40 = *(NSObject **)(a1 + 24);
      if (v40 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v24, v40, OS_LOG_TYPE_DEFAULT, "Unsequestering __MACOSX entry", buf, 2u);
      }
      char v41 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      if (v41)
      {
        uint64_t v42 = v41;
        size_t v43 = strlen(v41);
        if (*v42 == 46)
        {
          uint64_t v44 = 0;
          size_t v45 = 10;
          uint64_t v46 = "./__MACOSX";
          uint64_t v47 = ".";
        }
        else
        {
          size_t v45 = 8;
          uint64_t v46 = "__MACOSX";
          uint64_t v47 = "";
          uint64_t v44 = 1;
        }
        if (v43 < v45 || strncmp(v42, v46, v45)) {
          goto LABEL_169;
        }
        *(void *)statfs buf = 0;
        if (asprintf((char **)buf, "%s%s", v47, &v42[v45 + v44]) == -1 || !*(void *)buf)
        {
          int v99 = *__error();
          uint64_t v100 = __error();
          uint64_t v101 = strerror(*v100);
          BOMCopierErrorCapture(&v135, v99, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4466, (uint64_t)"unsequester_apple_double", "Could not created adjusted path for %s: %s", v42, v101);
          uint64_t v8 = v39;
        }
        else
        {
          BOOL v82 = BOMCopierSourceEntrySetPath(filesystem_entry, *(char **)buf);
          free(*(void **)buf);
          if (!v82) {
            goto LABEL_169;
          }
          uint64_t v8 = v39;
          uint64_t v83 = __error();
          strerror(*v83);
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4476, (uint64_t)"unsequester_apple_double", "Could not set adjusted path %s: %s");
        }
      }
      else
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4429, (uint64_t)"unsequester_apple_double", "Could not retrieve entry path for AppleDouble entry");
      }
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3317, (uint64_t)"filter_next_source_entry", "Could not unsequester AppleDouble file");
LABEL_151:
      BOMCopierSourceEntryFree(filesystem_entry);
      goto LABEL_281;
    }
LABEL_169:
    uint64_t v8 = v39;
    if (*(unsigned char *)(a1 + 71))
    {
      int v76 = *(NSObject **)(a1 + 24);
      int v11 = v24;
      if (v76 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v24, v76, OS_LOG_TYPE_DEFAULT, "Deferring AppleDouble entry", buf, 2u);
      }
      if (push_replay_stack((void *)a1, (uint64_t)filesystem_entry, 2, &v135))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3331, (uint64_t)"filter_next_source_entry", "Could not push AppleDouble onto the replay stack", v129);
        goto LABEL_49;
      }
      goto LABEL_282;
    }
    if (*(void *)(a1 + 80))
    {
      uint64_t v77 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      v139[0] = 0;
      asprintf(v139, "%s%s", v77, *(const char **)(a1 + 80));
      uint64_t v78 = v139[0];
      if (!v139[0])
      {
        uint64_t v84 = __error();
        strerror(*v84);
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3353, (uint64_t)"filter_next_source_entry", "Could not constructed adjusted AppleDouble path: %s");
        goto LABEL_281;
      }
      CFTypeID v79 = *(NSObject **)(a1 + 24);
      if (v79 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v80 = *(void *)(a1 + 80);
        *(_DWORD *)statfs buf = 136315394;
        *(void *)&buf[4] = v80;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = v77;
        _os_log_impl(v24, v79, OS_LOG_TYPE_DEFAULT, "Appending suffix %s to %s", buf, 0x16u);
        uint64_t v78 = v139[0];
      }
      if (BOMCopierSourceEntrySetPath(filesystem_entry, v78))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3362, (uint64_t)"filter_next_source_entry", "Could not set appended entry path for AppleDouble file", v129);
        goto LABEL_281;
      }
      free(v139[0]);
    }
    if (Type == 8)
    {
      if (*(unsigned char *)(a1 + 72))
      {
        __int16 v85 = *(NSObject **)(a1 + 24);
        if (v85 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          _os_log_impl(v24, v85, OS_LOG_TYPE_DEFAULT, "Synthesizing AppleDouble replay entry", buf, 2u);
        }
        if (synthesize_replay_apple_double(a1, filesystem_entry, &v135))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3382, (uint64_t)"filter_next_source_entry", "Could not replay AppleDouble file");
          goto LABEL_151;
        }
      }
      goto LABEL_219;
    }
LABEL_203:
    if (*(unsigned char *)(a1 + 91) && Type == 9)
    {
      CFStringRef v86 = *(NSObject **)(a1 + 24);
      if (v86 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(v24, v86, OS_LOG_TYPE_DEFAULT, "Synthesizing replay symlink entry", buf, 2u);
      }
      CFStringRef v87 = (char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
      SymlinkTarget = (char *)BOMCopierSourceEntryGetSymlinkTarget((uint64_t)filesystem_entry);
      size_t v89 = strlen(SymlinkTarget);
      int v90 = (uint64_t *)BOMCopierSourceEntryNew(8, &v135);
      if (v90)
      {
        char v91 = v90;
        if (BOMCopierSourceEntrySetPath(v90, v87))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4115, (uint64_t)"synthesize_replay_symlink", "Could not set the path for the regular file entry");
LABEL_279:
          CFIndex v96 = (unsigned int *)v91;
          goto LABEL_280;
        }
        if (BOMCopierSourceEntrySetData((uint64_t)v91, SymlinkTarget, v89))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4123, (uint64_t)"synthesize_replay_symlink", "Could not set the data for the regular file entry");
          goto LABEL_279;
        }
        if (copy_entry_metadata((uint64_t)filesystem_entry, (uint64_t)v91, &v135))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4131, (uint64_t)"synthesize_replay_symlink", "Could not copy metadata from the symlink entry to its regular file doppleganger");
          goto LABEL_279;
        }
        if (BOMCopierSourceEntrySetMode((uint64_t)v91, 33188))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4139, (uint64_t)"synthesize_replay_symlink", "Could not set the mode for the regular file entry");
          goto LABEL_279;
        }
        uint64_t v102 = BOMCopierSourceEntryNew(18, &v135);
        if (!v102)
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4155, (uint64_t)"synthesize_replay_symlink", "Could create a post order symlink entry");
          goto LABEL_279;
        }
        uint64_t v103 = (uint64_t)v102;
        if (BOMCopierSourceEntrySetPath(v102, v87))
        {
          int v104 = 4163;
LABEL_258:
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", v104, (uint64_t)"synthesize_replay_symlink", "Could not set the path for the post order symlink entry");
          goto LABEL_279;
        }
        if (copy_entry_metadata((uint64_t)filesystem_entry, v103, &v135))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4171, (uint64_t)"synthesize_replay_symlink", "Could not copy metadata from the symlink entry to its replay symlink");
          goto LABEL_279;
        }
        if (BOMCopierSourceEntrySetSymlinkTarget(v103, SymlinkTarget))
        {
          int v104 = 4179;
          goto LABEL_258;
        }
        if (push_replay_stack((void *)a1, v103, 1, &v135))
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4187, (uint64_t)"synthesize_replay_symlink", "Could not push the synthetic post-order symlink");
          goto LABEL_279;
        }
        AAByteStream v126 = *(NSObject **)(a1 + 24);
        if (v126 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 136315138;
          *(void *)&buf[4] = v87;
          _os_log_impl(v24, v126, OS_LOG_TYPE_DEFAULT, "Synthesizing replay symlink from %s", buf, 0xCu);
        }
        if (!consume_source_entry(filesystem_entry, &v135)) {
          goto LABEL_220;
        }
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4202, (uint64_t)"synthesize_replay_symlink", "Could not consume the symlink entry");
        CFIndex v96 = filesystem_entry;
      }
      else
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4107, (uint64_t)"synthesize_replay_symlink", "Could create a regular file entry");
        CFIndex v96 = 0;
      }
LABEL_280:
      BOMCopierSourceEntryFree(v96);
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3411, (uint64_t)"filter_next_source_entry", "Could not synthesize replay symlink", v129);
      goto LABEL_281;
    }
    if (!*(unsigned char *)(a1 + 92) || Type != 6)
    {
LABEL_219:
      char v91 = (uint64_t *)filesystem_entry;
LABEL_220:
      if (!*(unsigned char *)(a1 + 89)
        || (int v95 = BOMCopierSourceEntryGetType((uint64_t)v91), v95 != 14)
        && v95 != 16
        && (v95 != 15 || !is_apple_double(v91)))
      {
LABEL_246:
        int v11 = v24;
LABEL_302:
        if (!*(unsigned char *)(a1 + 265)) {
          return v91;
        }
        uint64_t v113 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v91);
        stat v114 = v113;
        v115 = *(void **)(a1 + 272);
        if (v115)
        {
          if (!strcmp(v113, *(const char **)(a1 + 272)))
          {
            v116 = *(NSObject **)(a1 + 24);
            if (v116 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)statfs buf = 0;
              _os_log_impl(v11, v116, OS_LOG_TYPE_DEFAULT, "Marking segmented file entry", buf, 2u);
            }
            BOMCopierSourceEntrySetSegmentedFile((uint64_t)v91, 1);
            v115 = *(void **)(a1 + 272);
          }
          free(v115);
        }
        uint32_t v117 = strdup(v114);
        *(void *)(a1 + 272) = v117;
        if (v117) {
          return v91;
        }
        int v118 = *__error();
        v119 = __error();
        v120 = strerror(*v119);
        BOMCopierErrorCapture(&v134, v118, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2493, (uint64_t)"next_source_entry", "Could not duplicate entry path: %s", v120);
        BOMCopierSourceEntryFree((unsigned int *)v91);
        goto LABEL_318;
      }
      switch(Type)
      {
        case 16:
          int v11 = v24;
          if (push_replay_stack((void *)a1, (uint64_t)v91, 1, &v135)) {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3486, (uint64_t)"filter_next_source_entry", "Could not push the extra symlink entry onto the replay stack");
          }
          goto LABEL_282;
        case 15:
          if (!*(unsigned char *)(a1 + 90)) {
            goto LABEL_246;
          }
          uint64_t v98 = *(NSObject **)(a1 + 24);
          int v11 = v24;
          if (v98 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)statfs buf = 0;
            _os_log_impl(v24, v98, OS_LOG_TYPE_DEFAULT, "Synthesizing AppleDouble replay entry from extra AppleDouble entry", buf, 2u);
          }
          if (synthesize_replay_apple_double(a1, v91, &v135))
          {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3503, (uint64_t)"filter_next_source_entry", "Could not replay AppleDouble file");
          }
          else
          {
            v105 = *(NSObject **)(a1 + 24);
            if (v105 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)statfs buf = 0;
              _os_log_impl(v24, v105, OS_LOG_TYPE_DEFAULT, "Consuming extra AppleDouble entry", buf, 2u);
            }
            if (!consume_source_entry((unsigned int *)v91, &v135)) {
              goto LABEL_282;
            }
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3513, (uint64_t)"filter_next_source_entry", "Could not consume the source entry");
          }
          char v23 = (unsigned int *)v91;
          goto LABEL_50;
        case 14:
          int v11 = v24;
          if (push_replay_stack((void *)a1, (uint64_t)v91, 3, &v135)) {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3473, (uint64_t)"filter_next_source_entry", "Could not push the extra directory entry onto the replay stack");
          }
          goto LABEL_282;
      }
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3525, (uint64_t)"filter_next_source_entry", "Cannot convert %u to replay entry");
LABEL_281:
      int v11 = v24;
      goto LABEL_282;
    }
    uint64_t v92 = *(NSObject **)(a1 + 24);
    if (v92 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(v24, v92, OS_LOG_TYPE_DEFAULT, "Synthesizing replay directory entry", buf, 2u);
    }
    uint64_t v93 = (char *)BOMCopierSourceEntryGetPath((uint64_t)filesystem_entry);
    CFStringRef v94 = (uint64_t *)BOMCopierSourceEntryNew(6, &v135);
    if (v94)
    {
      char v91 = v94;
      if (BOMCopierSourceEntrySetPath(v94, v93))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4239, (uint64_t)"synthesize_replay_directory", "Could not set the path for the directory entry");
      }
      else if (copy_entry_metadata((uint64_t)filesystem_entry, (uint64_t)v91, &v135))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4248, (uint64_t)"synthesize_replay_directory", "Could not copy metadata from the source entry to its directory doppleganger");
      }
      else if (BOMCopierSourceEntrySetMode((uint64_t)v91, 16877))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4257, (uint64_t)"synthesize_replay_directory", "Could not set the mode for the directory entry");
      }
      else if (BOMCopierSourceEntrySetUserID((uint64_t)v91, *(_DWORD *)(a1 + 32)))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4266, (uint64_t)"synthesize_replay_directory", "Could not set the user ID for the directory entry");
      }
      else if (BOMCopierSourceEntrySetGroupID((uint64_t)v91, *(_DWORD *)(a1 + 36)))
      {
        BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4275, (uint64_t)"synthesize_replay_directory", "Could not set the group ID for the directory entry");
      }
      else
      {
        uint64_t v124 = BOMCopierSourceEntryNew(19, &v135);
        if (v124)
        {
          int v125 = v124;
          if (BOMCopierSourceEntrySetPath(v124, v93))
          {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4300, (uint64_t)"synthesize_replay_directory", "Could not copy entry path from the source entry to its replay directory");
          }
          else if (copy_entry_metadata((uint64_t)filesystem_entry, (uint64_t)v125, &v135))
          {
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4310, (uint64_t)"synthesize_replay_directory", "Could not copy metadata from the source entry to its replay directory");
          }
          else
          {
            if (!push_replay_stack((void *)a1, (uint64_t)v125, 3, &v135))
            {
              v127 = *(NSObject **)(a1 + 24);
              if (v127 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)statfs buf = 136315138;
                *(void *)&buf[4] = v93;
                _os_log_impl(v24, v127, OS_LOG_TYPE_DEFAULT, "Synthesized replay directory from %s", buf, 0xCu);
              }
              if (!consume_source_entry(filesystem_entry, &v135)) {
                goto LABEL_220;
              }
              BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4337, (uint64_t)"synthesize_replay_directory", "Could not consume the source entry");
LABEL_275:
              BOMCopierSourceEntryFree(filesystem_entry);
              BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3440, (uint64_t)"filter_next_source_entry", "Could not synthesize replay directory", v129);
              goto LABEL_281;
            }
            BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4320, (uint64_t)"synthesize_replay_directory", "Could not push the synthetic replay directory onto the replay stack");
          }
          BOMCopierSourceEntryFree(v125);
        }
        else
        {
          BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4291, (uint64_t)"synthesize_replay_directory", "Could not create BOMCopierSourceEntry for replay directory");
        }
      }
      uint64_t v97 = (unsigned int *)v91;
    }
    else
    {
      BOMCopierErrorCapture(&v135, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4230, (uint64_t)"synthesize_replay_directory", "Could create a directory entry");
      uint64_t v97 = 0;
    }
    BOMCopierSourceEntryFree(v97);
    goto LABEL_275;
  }
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 1471, (uint64_t)"BOMCopierSourceNext", "copier_source is NULL");
  return 0;
}

uint64_t next_filesystem_entry(uint64_t a1, char *a2, unsigned char *a3, uint64_t *a4)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(FTS **)(a1 + 152);
  if (!v6)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2519, (uint64_t)"next_filesystem_entry", "The BOMCopierSource does not have an open FTS handle");
    return 0;
  }
  char v8 = *(unsigned char *)(a1 + 64) == 0;
  if (*(unsigned char *)(a1 + 360)) {
    v8 |= 2u;
  }
  if (*(unsigned char *)(a1 + 361)) {
    v8 |= 8u;
  }
  if (*(unsigned char *)(a1 + 362)) {
    v8 |= 4u;
  }
  if (*(unsigned char *)(a1 + 363)) {
    v8 |= 0x10u;
  }
  if (*(unsigned char *)(a1 + 364)) {
    v8 |= 0x20u;
  }
  if (*(unsigned char *)(a1 + 365)) {
    char v9 = v8 | 0x40;
  }
  else {
    char v9 = v8;
  }
  if (a2)
  {
    uint64_t v10 = (unsigned int *)BOMCopierSourceEntryNewFromPath(a2, v9, a4);
    if (!v10)
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2574, (uint64_t)"next_filesystem_entry", "Could not create BOMCopierSourceEntry from redirect path %s", a2);
      return (uint64_t)v10;
    }
    if (synthesize_filesystem_stuff())
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2582, (uint64_t)"next_filesystem_entry", "Could not synthesize filesystem stuff");
LABEL_19:
      int v11 = v10;
LABEL_20:
      BOMCopierSourceEntryFree(v11);
      return 0;
    }
    uint64_t v18 = *(NSObject **)(a1 + 24);
    if (v18 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
    {
      v35.f_bsize = 136315138;
      *(void *)&v35.f_iosize = a2;
      _os_log_impl(&dword_2105F8000, v18, OS_LOG_TYPE_DEFAULT, "Entry created from redirect path %s", (uint8_t *)&v35, 0xCu);
    }
  }
  else
  {
    uint64_t v14 = fts_read(v6);
    if (v14)
    {
      uint64_t v15 = (uint64_t)v14;
      if (v14->fts_statp->st_dev != *(_DWORD *)(a1 + 164))
      {
        bzero(&v35, 0x878uLL);
        if (statfs(*(const char **)(v15 + 48), &v35))
        {
          int v16 = *__error();
          int64_t v17 = __error();
          strerror(*v17);
          BOMCopierErrorCapture(a4, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2627, (uint64_t)"next_filesystem_entry", "Could not statfs %s: %s");
          return 0;
        }
        *(unsigned char *)(a1 + 168) = (v35.f_flags & 8) == 0;
        *(_DWORD *)(a1 + 164) = **(_DWORD **)(v15 + 96);
      }
      BOOL v20 = *(NSObject **)(a1 + 24);
      if (v20 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v35.f_bsize) = 0;
        _os_log_impl(&dword_2105F8000, v20, OS_LOG_TYPE_DEFAULT, "Creating source entry from FTS entry", (uint8_t *)&v35, 2u);
      }
      uint64_t v21 = BOMCopierSourceEntryNewFromFTSENT(v15, v9, a4);
      if (!v21)
      {
        if (*(void *)a1)
        {
          uint64_t v22 = *(void *)(v15 + 48);
          *(void *)&v35.f_bsize = 0;
          v35.f_blocks = v22;
          v35.f_bfree = 0;
          LODWORD(v35.f_bfree) = *__error();
          if (a4)
          {
            uint64_t v23 = *a4;
            *(void *)&v35.f_bsize = v23;
            if (v23) {
              LODWORD(v35.f_bfree) = BOMCopierErrorGetCode(v23);
            }
          }
          uint64_t v24 = *(NSObject **)(a1 + 24);
          if (v24 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)statfs buf = 0;
            _os_log_impl(&dword_2105F8000, v24, OS_LOG_TYPE_DEFAULT, "Could not create FTS entry. Calling error handler", buf, 2u);
          }
          *(_DWORD *)(a1 + 16) = (*(uint64_t (**)(uint64_t, void, statfs *))a1)(a1, *(void *)(a1 + 8), &v35);
        }
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2676, (uint64_t)"next_filesystem_entry", "Could not create BOMCopierSourceEntry from FTS entry");
        return 0;
      }
      uint64_t v10 = (unsigned int *)v21;
      BOMCopierSourceEntrySetHonorsSetuid(v21, *(unsigned char *)(a1 + 168));
      if (*(_WORD *)(v15 + 86))
      {
        if (adjust_filesystem_entry_path(a1, v15, v10, a4))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2780, (uint64_t)"next_filesystem_entry", "Could not adjust entry path");
          goto LABEL_19;
        }
        if (!*(unsigned char *)(a1 + 88) || !is_apple_double(v10))
        {
          if (!synthesize_filesystem_stuff()) {
            return (uint64_t)v10;
          }
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2812, (uint64_t)"next_filesystem_entry", "Could not synthesize filesystem stuff");
          goto LABEL_19;
        }
        uint64_t v28 = *(NSObject **)(a1 + 24);
        if (v28 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v35.f_bsize) = 0;
          _os_log_impl(&dword_2105F8000, v28, OS_LOG_TYPE_DEFAULT, "Consuming AppleDouble entry", (uint8_t *)&v35, 2u);
        }
        if (consume_source_entry(v10, a4))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2796, (uint64_t)"next_filesystem_entry", "Could not consume the source entry");
          goto LABEL_19;
        }
        CFTypeID v33 = *(NSObject **)(a1 + 24);
        if (v33 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v35.f_bsize) = 0;
          _os_log_impl(&dword_2105F8000, v33, OS_LOG_TYPE_DEFAULT, "Ignored AppleDouble", (uint8_t *)&v35, 2u);
        }
        return next_filesystem_entry(a1, 0, a3, a4);
      }
      else
      {
        if (*(unsigned char *)(a1 + 376))
        {
          uint64_t v25 = *(NSObject **)(a1 + 24);
          if (v25 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v35.f_bsize) = 0;
            _os_log_impl(&dword_2105F8000, v25, OS_LOG_TYPE_DEFAULT, "Synthesizing parent entry from FTS root entry", (uint8_t *)&v35, 2u);
          }
          unsigned int v26 = (unsigned int *)BOMCopierSourceEntryNewFromFTSENT(v15, v9, a4);
          if (!v26)
          {
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2702, (uint64_t)"next_filesystem_entry", "Could not create parent from FTS entry");
            goto LABEL_19;
          }
          char v27 = v26;
          if (adjust_filesystem_entry_path(a1, v15, v26, a4))
          {
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2711, (uint64_t)"next_filesystem_entry", "Could not adjust entry path");
            int v11 = v27;
            goto LABEL_20;
          }
        }
        else
        {
          char v27 = 0;
        }
        int v29 = *(unsigned __int16 *)(v15 + 88);
        if (v29 == 6 || v29 == 1)
        {
          int v30 = ".";
        }
        else
        {
          memset(&v35, 0, 255);
          basename_r(*(const char **)(v15 + 48), (char *)&v35);
          int v30 = (char *)&v35;
        }
        BOMCopierSourceEntrySetPath(v10, v30);
        BOMCopierSourceEntrySetRoot((uint64_t)v10, 1);
        if (v27)
        {
          int v31 = *(unsigned __int16 *)(v15 + 88);
          int v32 = *(NSObject **)(a1 + 24);
          if (v31 == 1)
          {
            if (v32 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v35.f_bsize) = 0;
              _os_log_impl(&dword_2105F8000, v32, OS_LOG_TYPE_DEFAULT, "Pushing entry onto the pre-empt stack", (uint8_t *)&v35, 2u);
            }
            if (!push_preempt_stack(a1, (uint64_t)v27, a4)) {
              return (uint64_t)v10;
            }
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2751, (uint64_t)"next_filesystem_entry", "Could not push parent entry onto the preempty stack");
          }
          else
          {
            if (v32 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v35.f_bsize) = 0;
              _os_log_impl(&dword_2105F8000, v32, OS_LOG_TYPE_DEFAULT, "Pushing root entry onto the pre-empt stack", (uint8_t *)&v35, 2u);
            }
            if (!push_preempt_stack(a1, (uint64_t)v10, a4)) {
              return (uint64_t)v27;
            }
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 2764, (uint64_t)"next_filesystem_entry", "Could not push parent entry onto the preempty stack");
          }
          BOMCopierSourceEntryFree(v27);
          goto LABEL_19;
        }
      }
    }
    else
    {
      fts_close(*(FTS **)(a1 + 152));
      *(void *)(a1 + 152) = 0;
      free(*(void **)(a1 + 128));
      *(void *)(a1 + 128) = 0;
      uint64_t v19 = *(NSObject **)(a1 + 24);
      if (v19 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v35.f_bsize) = 0;
        _os_log_impl(&dword_2105F8000, v19, OS_LOG_TYPE_DEFAULT, "FTS exhausted", (uint8_t *)&v35, 2u);
      }
      uint64_t v10 = 0;
      *a3 = 1;
    }
  }
  return (uint64_t)v10;
}

uint64_t next_data_archive_entry(uint64_t a1, unsigned char *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)(a1 + 280);
  if (!v10)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3042, (uint64_t)"next_data_archive_entry", "copier_source->data_archive is NULL");
    return 0;
  }
  if (*(unsigned char *)(a1 + 360)) {
    __int16 v12 = (*(unsigned __int8 *)(a1 + 264) << 9) | 2;
  }
  else {
    __int16 v12 = *(unsigned __int8 *)(a1 + 264) << 9;
  }
  uint64_t v21 = 0;
  int32_t v13 = data_archive_read_entry(v10, &v21, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (!v13)
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3064, (uint64_t)"next_data_archive_entry", "Could not read next data_archive entry: %s", *((const char **)v21 + 4));
    release_error(v21);
    return 0;
  }
  uint64_t v14 = v13;
  unsigned int type = data_archive_entry_get_type(v13);
  int v16 = *(NSObject **)(a1 + 24);
  if (v16 && os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = data_archive_entry_path((uint64_t)v14);
    if (type > 4) {
      uint64_t v18 = "?";
    }
    else {
      uint64_t v18 = off_264132780[type];
    }
    *(_DWORD *)statfs buf = 136315394;
    uint64_t v23 = v17;
    __int16 v24 = 2080;
    uint64_t v25 = v18;
    _os_log_impl(&dword_2105F8000, v16, OS_LOG_TYPE_DEFAULT, "%s [%s]", buf, 0x16u);
  }
  if (type == 1)
  {
    *a2 = 1;
    data_archive_entry_free(v14);
    return 0;
  }
  if (type == 4)
  {
    data_archive_entry_free(v14);
    return next_data_archive_entry(a1, a2, a3);
  }
  else
  {
    uint64_t v19 = BOMCopierSourceEntryNewFromDataArchive(*(void *)(a1 + 280), v14, v12, a3);
    data_archive_entry_free(v14);
  }
  return v19;
}

uint64_t synthesize_filesystem_stuff()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v3 = v2;
  uint64_t v4 = v1;
  uint64_t v5 = v0;
  uint64_t v53 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(v0 + 67) || BOMCopierSourceEntryGetType(v1) == 13) {
    goto LABEL_28;
  }
  uint64_t v6 = *(NSObject **)(v5 + 24);
  if (v6 && os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)statfs buf = 0;
    _os_log_impl(&dword_2105F8000, v6, OS_LOG_TYPE_DEFAULT, "Synthesizing AppleDouble entry", buf, 2u);
  }
  int v7 = *(unsigned char *)(v5 + 68) || *(unsigned char *)(v5 + 69) ? 4980740 : 4980736;
  copyfile_flags_t v8 = v7 | *(unsigned __int8 *)(v5 + 70);
  ActualPath = (const char *)BOMCopierSourceEntryGetActualPath(v4);
  if ((copyfile(ActualPath, 0, 0, v8 | 0x10000) & v8) == 0) {
    goto LABEL_28;
  }
  memcpy(buf, "/tmp/.BC.T_XXXXXX", sizeof(buf));
  if (!mktemp(buf))
  {
    int v12 = *__error();
    int32_t v13 = __error();
    strerror(*v13);
    BOMCopierErrorCapture(v3, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3789, (uint64_t)"synthesize_apple_double", "Could not mktemp %s: %s");
    goto LABEL_14;
  }
  if (!copyfile(ActualPath, buf, 0, v8))
  {
    uint64_t v14 = BOMCopierSourceEntryNewFromPath(buf, 0, v3);
    if (!v14)
    {
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3808, (uint64_t)"synthesize_apple_double", "Could not create BOMCopierSourceEntry from %s", buf);
      unlink(buf);
      goto LABEL_14;
    }
    uint64_t v15 = (unsigned int *)v14;
    Path = (const char *)BOMCopierSourceEntryGetPath(v4);
    bzero(__s, 0x400uLL);
    bzero(v47, 0x400uLL);
    dirname_r(Path, __s);
    basename_r(Path, (char *)v47);
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s/%s%s", __s, "._", (const char *)v47);
    if (BOMCopierSourceEntrySetPath(v15, __str))
    {
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3828, (uint64_t)"synthesize_apple_double", "Could not create set path entry for %s");
LABEL_24:
      BOMCopierSourceEntryFree(v15);
      goto LABEL_14;
    }
    if (BOMCopierSourceEntrySetOption((uint64_t)v15, @"DeleteOnFree", (const void *)*MEMORY[0x263EFFB40]))
    {
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3836, (uint64_t)"synthesize_apple_double", "Could not set kBOMCopierSourceEntryDeleteOnFree option", v30);
      goto LABEL_24;
    }
    if (push_preempt_stack(v5, (uint64_t)v15, v3))
    {
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3844, (uint64_t)"synthesize_apple_double", "Could not push synthetic AppleDouble entry", v30);
      goto LABEL_24;
    }
    uint64_t v17 = *(NSObject **)(v5 + 24);
    if (v17 && os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
    {
      v52.st_dev = 136315138;
      *(void *)&v52.st_mode = ActualPath;
      _os_log_impl(&dword_2105F8000, v17, OS_LOG_TYPE_DEFAULT, "Synthesized AppleDouble from %s", (uint8_t *)&v52, 0xCu);
    }
LABEL_28:
    if (!*(unsigned char *)(v5 + 66) || BOMCopierSourceEntryGetType(v4) == 13) {
      return 0;
    }
    uint64_t v19 = *(NSObject **)(v5 + 24);
    if (v19 && os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_2105F8000, v19, OS_LOG_TYPE_DEFAULT, "Synthesizing resource fork entry", buf, 2u);
    }
    BOOL v20 = (const char *)BOMCopierSourceEntryGetActualPath(v4);
    int v31 = 0;
    if (asprintf(&v31, "%s%s", v20, "/..namedfork/rsrc") < 0)
    {
      int v24 = *__error();
      uint64_t v25 = __error();
      strerror(*v25);
      BOMCopierErrorCapture(v3, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3653, (uint64_t)"synthesize_resource_fork", "Could not asprintf resource path for %s: %s");
      goto LABEL_39;
    }
    memset(&v52, 0, sizeof(v52));
    int v21 = lstat(v31, &v52);
    free(v31);
    if (v21)
    {
      if (*__error() != 2)
      {
        int v22 = *__error();
        uint64_t v23 = __error();
        strerror(*v23);
        BOMCopierErrorCapture(v3, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3666, (uint64_t)"synthesize_resource_fork", "Could not lstat resource path for %s: %s");
        goto LABEL_39;
      }
    }
    else if (v52.st_size)
    {
      uint64_t v26 = BOMCopierSourceEntryNewFromResourceFork(v20, v3);
      if (v26)
      {
        char v27 = v26;
        uint64_t v28 = (const char *)BOMCopierSourceEntryGetPath(v4);
        bzero(buf, 0x400uLL);
        memset(v47, 0, 255);
        dirname_r(v28, buf);
        basename_r(v28, (char *)v47);
        long long v45 = 0u;
        memset(v46, 0, sizeof(v46));
        long long v43 = 0u;
        long long v44 = 0u;
        long long v41 = 0u;
        long long v42 = 0u;
        long long v40 = 0u;
        long long v38 = 0u;
        long long v39 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        long long v34 = 0u;
        long long v35 = 0u;
        *(_OWORD *)__str = 0u;
        long long v33 = 0u;
        snprintf(__str, 0xFFuLL, "%s%s", (const char *)v47, "/..namedfork/rsrc");
        bzero(__s, 0x400uLL);
        snprintf(__s, 0x400uLL, "%s/%s", buf, __str);
        if (BOMCopierSourceEntrySetPath(v27, __s))
        {
          BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3709, (uint64_t)"synthesize_resource_fork", "Could not create set path entry for %s");
        }
        else if (BOMCopierSourceEntrySetParent((uint64_t)v27, buf))
        {
          BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3717, (uint64_t)"synthesize_resource_fork", "Could not create set entry parent for %s");
        }
        else if (BOMCopierSourceEntrySetName((uint64_t)v27, __str))
        {
          BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3725, (uint64_t)"synthesize_resource_fork", "Could not create set entry name for %s");
        }
        else
        {
          if (!push_preempt_stack(v5, (uint64_t)v27, v3))
          {
            int v29 = *(NSObject **)(v5 + 24);
            if (v29)
            {
              if (os_log_type_enabled(*(os_log_t *)(v5 + 24), OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)uint64_t v48 = 136315138;
                size_t v49 = v20;
                _os_log_impl(&dword_2105F8000, v29, OS_LOG_TYPE_DEFAULT, "Synthesized resource fork from %s", v48, 0xCu);
              }
            }
            return 0;
          }
          BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3733, (uint64_t)"synthesize_resource_fork", "Could not push synthetic resource fork entry");
        }
        BOMCopierSourceEntryFree(v27);
      }
      else
      {
        *(stat *)statfs buf = v52;
        BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3688, (uint64_t)"synthesize_resource_fork", "Could not create BOMCopierSourceEntry from %s");
      }
LABEL_39:
      BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3627, (uint64_t)"synthesize_filesystem_stuff", "Could not discover resource fork");
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  int v10 = *__error();
  int v11 = __error();
  strerror(*v11);
  BOMCopierErrorCapture(v3, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3796, (uint64_t)"synthesize_apple_double", "Could not copyfile %s to %s: %s", ActualPath);
LABEL_14:
  BOMCopierErrorCapture(v3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3605, (uint64_t)"synthesize_filesystem_stuff", "Could not synthesize the AppleDouble file");
  return 0xFFFFFFFFLL;
}

uint64_t adjust_filesystem_entry_path(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v6 = "";
  if (!*(unsigned char *)(a1 + 93)) {
    uint64_t v6 = ".";
  }
  int v7 = (const char *)(*(void *)(a2 + 48)
                    + *(void *)(a1 + 144)
                    - *(void *)(a1 + 136)
                    + *(unsigned __int8 *)(a1 + 93));
  __s = 0;
  int v8 = asprintf(&__s, "%s%s", v6, v7);
  if (!__s || v8 < 0)
  {
    int v10 = *__error();
    int v11 = __error();
    int v12 = strerror(*v11);
    BOMCopierErrorCapture(a4, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3558, (uint64_t)"adjust_filesystem_entry_path", "Could not asprintf the entry_path: %s", v12);
    return 1;
  }
  else if (BOMCopierSourceEntrySetPath(a3, __s))
  {
    uint64_t v9 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3571, (uint64_t)"adjust_filesystem_entry_path", "Could not set the entry path");
    free(__s);
  }
  else
  {
    free(__s);
    return 0;
  }
  return v9;
}

uint64_t push_preempt_stack(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(char **)(a1 + 312);
  if (v5 || (uint64_t v5 = (char *)BOMStackNew(), (*(void *)(a1 + 312) = v5) != 0))
  {
    BOMStackPush(v5, a2);
    return 0;
  }
  else
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4589, (uint64_t)"push_preempt_stack", "Could not create empty preempt stack");
    return 0xFFFFFFFFLL;
  }
}

char *is_apple_double(void *a1)
{
  int Type = BOMCopierSourceEntryGetType((uint64_t)a1);
  if (Type != 15 && Type != 8) {
    return 0;
  }
  uint64_t result = BOMCopierSourceEntryGetName(a1);
  if (result) {
    return (char *)(strncmp(result, "._", 2uLL) == 0);
  }
  return result;
}

uint64_t consume_source_entry(unsigned int *a1, void *a2)
{
  uint64_t v4 = BOMCopierSourceEntrySkip((uint64_t)a1, 0, 0, a2);
  if (v4) {
    BOMCopierErrorCapture(a2, v4, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 3864, (uint64_t)"consume_source_entry", "Could not skip source entry");
  }
  else {
    BOMCopierSourceEntryFree(a1);
  }
  return v4;
}

uint64_t push_replay_stack(void *a1, uint64_t a2, int a3, void *a4)
{
  switch(a3)
  {
    case 3:
      int v7 = (char *)a1[42];
      if (!v7)
      {
        int v7 = (char *)BOMStackNew();
        a1[42] = v7;
        if (!v7)
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4646, (uint64_t)"push_replay_stack", "Could not create empty replay directory stack");
          return 0xFFFFFFFFLL;
        }
      }
      break;
    case 2:
      int v7 = (char *)a1[41];
      if (!v7)
      {
        int v7 = (char *)BOMStackNew();
        a1[41] = v7;
        if (!v7)
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4631, (uint64_t)"push_replay_stack", "Could not create empty replay AppleDouble stack");
          return 0xFFFFFFFFLL;
        }
      }
      break;
    case 1:
      int v7 = (char *)a1[40];
      if (!v7)
      {
        int v7 = (char *)BOMStackNew();
        a1[40] = v7;
        if (!v7)
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4616, (uint64_t)"push_replay_stack", "Could not create empty replay symlink stack");
          return 0xFFFFFFFFLL;
        }
      }
      break;
    default:
      uint64_t v8 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4656, (uint64_t)"push_replay_stack", "Unknown replay type: %u", a3);
      return v8;
  }
  BOMStackPush(v7, a2);
  return 0;
}

uint64_t synthesize_replay_apple_double(uint64_t a1, void *a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v6 = BOMCopierSourceEntryNew(17, a3);
  if (v6)
  {
    int v7 = v6;
    uint64_t v8 = BOMCopierSourceEntryGetName(a2) + 2;
    uint64_t v9 = strdup(v8);
    if (v9)
    {
      int v10 = v9;
      int v11 = *(const char **)(a1 + 80);
      if (v11)
      {
        size_t v12 = strlen(v11);
        v10[strlen(v10) - v12] = 0;
      }
      if (BOMCopierSourceEntrySetAppleDoubleTarget((uint64_t)v7, v10))
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4039, (uint64_t)"synthesize_replay_apple_double", "Could not create set AppleDouble target for replay AppleDouble file");
        free(v10);
      }
      else
      {
        Path = (char *)BOMCopierSourceEntryGetPath((uint64_t)a2);
        uint64_t v15 = *(NSObject **)(a1 + 24);
        if (v15)
        {
          if (os_log_type_enabled(*(os_log_t *)(a1 + 24), OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)statfs buf = 136315394;
            uint64_t v18 = Path;
            __int16 v19 = 2080;
            BOOL v20 = v10;
            _os_log_impl(&dword_2105F8000, v15, OS_LOG_TYPE_DEFAULT, "Synthesizing replay AppleDouble from %s to %s", buf, 0x16u);
          }
        }
        free(v10);
        if (BOMCopierSourceEntrySetPath(v7, Path))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4054, (uint64_t)"synthesize_replay_apple_double", "Could not set entry path for replay AppleDouble file");
        }
        else if (copy_entry_metadata((uint64_t)a2, (uint64_t)v7, a3))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4062, (uint64_t)"synthesize_replay_apple_double", "Could not copy metadata from the source entry to its replay apple double");
        }
        else
        {
          uint64_t result = push_replay_stack((void *)a1, (uint64_t)v7, 2, a3);
          if (!result) {
            return result;
          }
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4070, (uint64_t)"synthesize_replay_apple_double", "Could not push the synthetic replay AppleDouble");
        }
      }
    }
    else
    {
      int32_t v13 = __error();
      strerror(*v13);
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4022, (uint64_t)"synthesize_replay_apple_double", "Could not duplicate %s: %s");
    }
    BOMCopierSourceEntryFree(v7);
  }
  else
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4006, (uint64_t)"synthesize_replay_apple_double", "Could not create BOMCopierSourceEntry for replay AppleDouble file");
  }
  return 0xFFFFFFFFLL;
}

uint64_t __add_sequester_entry_block_invoke(uint64_t a1, const char *a2, int a3)
{
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(void *)(v5 + 24))
  {
    size_t v18 = strlen(a2);
    uint64_t v19 = *(void *)(a1 + 48);
    if (*(unsigned char *)(v19 + 93)) {
      BOOL v20 = "__MACOSX";
    }
    else {
      BOOL v20 = ".";
    }
    if (!strncmp(a2, v20, v18))
    {
      uint64_t v21 = *(void *)(v19 + 344);
      if (v21)
      {
        uint64_t result = 0;
        *(void *)(v5 + 24) = v21;
        return result;
      }
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = path_tree_node_create(a2, *(void **)(a1 + 56));
      uint64_t v23 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (v23)
      {
        uint64_t result = 0;
        *(void *)(*(void *)(a1 + 48) + 344) = v23;
        return result;
      }
      BOMCopierErrorCapture(*(void **)(a1 + 56), 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4751, (uint64_t)"add_sequester_entry_block_invoke", "Could not create root path tree node");
    }
    else
    {
      BOMCopierErrorCapture(*(void **)(a1 + 56), 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4741, (uint64_t)"add_sequester_entry_block_invoke", "I was expecting %s not %s");
    }
    return 0xFFFFFFFFLL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(*(void *)(v7 + 8) + 24);
  if (*(_DWORD *)(v8 + 8))
  {
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 40) + 8);
      if (*(void *)(v10 + 24)) {
        break;
      }
      int v11 = *(const char ***)(*(void *)(v8 + 16) + 8 * v9);
      if (!strncmp(a2, *v11, 0xFFuLL))
      {
        *(void *)(v10 + 24) = v11;
        uint64_t v7 = *(void *)(a1 + 32);
      }
      ++v9;
      uint64_t v8 = *(void *)(*(void *)(v7 + 8) + 24);
    }
    while (v9 < *(unsigned int *)(v8 + 8));
  }
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(*(void *)(v12 + 8) + 24);
  if (v13) {
    goto LABEL_27;
  }
  uint64_t v14 = *(void **)(a1 + 56);
  if (a2)
  {
    uint64_t v15 = path_tree_node_create(a2, *(void **)(a1 + 56));
    if (!v15)
    {
      BOMCopierErrorCapture(v14, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5055, (uint64_t)"path_tree_node_add_child", "Could not create child node for %s\n", a2);
      goto LABEL_26;
    }
    uint64_t v16 = *(unsigned int *)(v8 + 8);
    uint64_t v17 = malloc_type_realloc(*(void **)(v8 + 16), 8 * (v16 + 1), 0x240466AuLL);
    if (v17)
    {
      v17[v16] = v15;
      *(_DWORD *)(v8 + 8) = v16 + 1;
      *(void *)(v8 + 16) = v17;
      goto LABEL_26;
    }
    int v24 = __error();
    BOMCopierErrorCapture(v14, *v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5067, (uint64_t)"path_tree_node_add_child", "Could not reallocate new children list\n");
    path_tree_node_release((uint64_t)v15);
  }
  else
  {
    BOMCopierErrorCapture(*(void **)(a1 + 56), 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5047, (uint64_t)"path_tree_node_add_child", "child_name is NULL");
  }
  uint64_t v15 = 0;
LABEL_26:
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v15;
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(void *)(*(void *)(v12 + 8) + 24);
  if (!v13)
  {
    BOMCopierErrorCapture(*(void **)(a1 + 56), 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4786, (uint64_t)"add_sequester_entry_block_invoke", "Could not add child %s to %s");
    return 0xFFFFFFFFLL;
  }
LABEL_27:
  if (a3)
  {
    *(void *)(v13 + 24) = *(void *)(a1 + 64);
    uint64_t v12 = *(void *)(a1 + 40);
  }
  uint64_t result = 0;
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(*(void *)(v12 + 8) + 24);
  return result;
}

void *path_tree_node_create(const char *a1, void *a2)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4985, (uint64_t)"path_tree_node_create", "name is NULL");
    return 0;
  }
  uint64_t v4 = malloc_type_calloc(1uLL, 0x20uLL, 0x10B0040ECAA58F3uLL);
  if (!v4)
  {
    unint64_t v9 = __error();
    BOMCopierErrorCapture(a2, *v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4992, (uint64_t)"path_tree_node_create", "Could not allocate node");
    return v4;
  }
  uint64_t v5 = strdup(a1);
  *uint64_t v4 = v5;
  if (!v5)
  {
    int v6 = *__error();
    uint64_t v7 = __error();
    uint64_t v8 = strerror(*v7);
    BOMCopierErrorCapture(a2, v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4999, (uint64_t)"path_tree_node_create", "Could not strdup %s: %s", a1, v8);
    free(v4);
    return 0;
  }
  return v4;
}

uint64_t copy_entry_metadata(uint64_t a1, uint64_t a2, void *a3)
{
  BOMCopierSourceEntryGetPath(a1);
  BOMCopierSourceEntryGetPath(a2);
  __int16 Mode = BOMCopierSourceEntryGetMode(a1);
  if (BOMCopierSourceEntrySetMode(a2, Mode))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4504, (uint64_t)"copy_entry_metadata", "Could not set mode for entry %s");
  }
  else
  {
    int UserID = BOMCopierSourceEntryGetUserID(a1);
    if (BOMCopierSourceEntrySetUserID(a2, UserID))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4513, (uint64_t)"copy_entry_metadata", "Could not set uid for entry %s");
    }
    else
    {
      int GroupID = BOMCopierSourceEntryGetGroupID(a1);
      if (BOMCopierSourceEntrySetGroupID(a2, GroupID))
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4522, (uint64_t)"copy_entry_metadata", "Could not set gid for entry %s");
      }
      else
      {
        long long v12 = 0uLL;
        if (BOMCopierSourceEntryGetAccessTime(a1, &v12))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4531, (uint64_t)"copy_entry_metadata", "Could not get access time for entry %s");
        }
        else if (BOMCopierSourceEntrySetAccessTime(a2, v12, *((uint64_t *)&v12 + 1)))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4538, (uint64_t)"copy_entry_metadata", "Could not set access time for entry %s");
        }
        else
        {
          long long v11 = 0uLL;
          if (BOMCopierSourceEntryGetModificationTime(a1, &v11))
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4547, (uint64_t)"copy_entry_metadata", "Could not get modification time for entry %s");
          }
          else if (BOMCopierSourceEntrySetModificationTime(a2, v11, *((uint64_t *)&v11 + 1)))
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4554, (uint64_t)"copy_entry_metadata", "Could not set modification time for entry %s");
          }
          else
          {
            long long v10 = 0uLL;
            if (BOMCopierSourceEntryGetStatusTime(a1, &v10))
            {
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4563, (uint64_t)"copy_entry_metadata", "Could not get status time for entry %s");
            }
            else
            {
              uint64_t result = BOMCopierSourceEntrySetStatusTime(a2, v10, *((uint64_t *)&v10 + 1));
              if (!result) {
                return result;
              }
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 4570, (uint64_t)"copy_entry_metadata", "Could not set status time for entry %s");
            }
          }
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t path_tree_node_push(uint64_t a1, const char *a2, char *a3, void *a4)
{
  __s = 0;
  if (a2) {
    asprintf(&__s, "%s/%s");
  }
  else {
    asprintf(&__s, "%s");
  }
  if (__s)
  {
    if (*(_DWORD *)(a1 + 8))
    {
      uint64_t v8 = 0;
      while (!path_tree_node_push(*(void *)(*(void *)(a1 + 16) + 8 * v8), __s, a3, a4))
      {
        if (++v8 >= (unint64_t)*(unsigned int *)(a1 + 8)) {
          goto LABEL_9;
        }
      }
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5114, (uint64_t)"path_tree_node_push", "Could not push child %s of %s onto the stack\n");
      goto LABEL_21;
    }
LABEL_9:
    unint64_t v9 = *(unsigned int **)(a1 + 24);
    if (v9)
    {
LABEL_10:
      BOMStackPush(a3, (uint64_t)v9);
      free(__s);
      return 0;
    }
    long long v12 = BOMCopierSourceEntryNew(6, a4);
    if (v12)
    {
      unint64_t v9 = v12;
      if (BOMCopierSourceEntrySetPath(v12, __s))
      {
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5135, (uint64_t)"path_tree_node_push", "Could not path for source entry of %s\n");
      }
      else
      {
        if (!BOMCopierSourceEntrySetMode((uint64_t)v9, 16893)) {
          goto LABEL_10;
        }
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5144, (uint64_t)"path_tree_node_push", "Could not mode for source entry of %s\n");
      }
      BOMCopierSourceEntryFree(v9);
    }
    else
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5127, (uint64_t)"path_tree_node_push", "Could not create source entry for %s\n");
    }
LABEL_21:
    free(__s);
    return 0xFFFFFFFFLL;
  }
  long long v11 = __error();
  BOMCopierErrorCapture(a4, *v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSource.c", 5104, (uint64_t)"path_tree_node_push", "Could not create node path for %s and %s\n", a2, *(const char **)a1);
  return 0xFFFFFFFFLL;
}

char *BOMNewPathKey(unsigned int a1, char *__s, void *a3)
{
  uint64_t v3 = 0;
  if (__s && a3)
  {
    size_t v7 = strlen(__s);
    uint64_t v8 = (char *)BOM_malloc(v7 + 5);
    uint64_t v3 = v8;
    if (v8)
    {
      *a3 = v7 + 5;
      *(_DWORD *)uint64_t v8 = bswap32(a1);
      strlcpy(v8 + 4, __s, v7 + 1);
    }
    else
    {
      unint64_t v9 = (FILE *)*MEMORY[0x263EF8348];
      long long v10 = __error();
      long long v11 = strerror(*v10);
      fprintf(v9, "malloc: %s\n", v11);
    }
  }
  return v3;
}

_DWORD *BOMNewPathValue(unsigned int a1, unsigned int a2, void *a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t result = BOM_malloc(8uLL);
  if (result)
  {
    *a3 = 8;
    *uint64_t result = bswap32(a1);
    result[1] = bswap32(a2);
  }
  else
  {
    size_t v7 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v8 = __error();
    unint64_t v9 = strerror(*v8);
    fprintf(v7, "malloc: %s\n", v9);
    return 0;
  }
  return result;
}

unsigned int *BOMPathIDFromPathKey(unsigned int *result)
{
  if (result) {
    return (unsigned int *)bswap32(*result);
  }
  return result;
}

uint64_t BOMShortNameFromPathKey(uint64_t a1)
{
  return a1 + 4;
}

uint64_t BOMBlockIDFromPathValue(uint64_t result)
{
  if (result) {
    return bswap32(*(_DWORD *)(result + 4));
  }
  return result;
}

char *BOMCopierDestinationNew(char *__s, const __CFDictionary *a2, void *a3)
{
  uint64_t v175 = *MEMORY[0x263EF8340];
  if (!((unint64_t)__s | (unint64_t)a2))
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 621, (uint64_t)"BOMCopierDestinationNew", "path and options are NULL");
    return 0;
  }
  if (__s && strlen(__s) >= 0x400)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 630, (uint64_t)"BOMCopierDestinationNew", "maximum path length exceeded: %ld");
    return 0;
  }
  int v6 = (char *)malloc_type_calloc(1uLL, 0x170uLL, 0x10B004067826777uLL);
  if (!v6)
  {
    int v24 = __error();
    BOMCopierErrorCapture(a3, *v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 644, (uint64_t)"BOMCopierDestinationNew", "Could not allocate empty BOMCopierDestination");
    return v6;
  }
  *((_DWORD *)v6 + 2) = geteuid();
  *(void *)(v6 + 124) = 0x10000;
  *((_DWORD *)v6 + 36) = -1;
  *((_DWORD *)v6 + 29) = 0;
  v6[297] = 1;
  *((_DWORD *)v6 + 82) = -1;
  size_t v7 = BOMHardLinkTableNew();
  *((void *)v6 + 9) = v7;
  if (!v7)
  {
    int v25 = *__error();
    BOMCopierErrorCapture(a3, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 662, (uint64_t)"BOMCopierDestinationNew", "Could not create BOMHardLinkTable");
    goto LABEL_319;
  }
  *((_DWORD *)v6 + 4) = -1;
  if (!geteuid()) {
    v6[302] = 1;
  }
  if (a2)
  {
    CFTypeID TypeID = CFBooleanGetTypeID();
    CFDictionaryRef Value = CFDictionaryGetValue(a2, @"useFilesystemCache");
    if (Value)
    {
      long long v10 = Value;
      if (TypeID != CFGetTypeID(Value))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2767, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionUseFilesystemCacheKey must be a CFBooleanRef");
        goto LABEL_319;
      }
      if (CFEqual(v10, (CFTypeRef)*MEMORY[0x263EFFB38]) == 1) {
        v6[40] = 1;
      }
    }
    long long v11 = CFDictionaryGetValue(a2, @"applySourcePermissions");
    if (v11)
    {
      long long v12 = v11;
      if (TypeID != CFGetTypeID(v11))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2782, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionApplySourcePermissionsKey must be a CFBooleanRef");
        goto LABEL_319;
      }
      v6[43] = CFEqual(v12, (CFTypeRef)*MEMORY[0x263EFFB40]) != 0;
    }
    uint64_t v13 = CFDictionaryGetValue(a2, @"createArchive");
    if (v13)
    {
      if (TypeID != CFGetTypeID(v13))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2794, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionCreateArchiveKey must be a CFBooleanRef");
        goto LABEL_319;
      }
      *((_DWORD *)v6 + 11) = 1;
    }
    CFTypeID v14 = CFNumberGetTypeID();
    CFNumberRef v15 = (const __CFNumber *)CFDictionaryGetValue(a2, @"libarchiveFormat");
    if (v15)
    {
      CFNumberRef v16 = v15;
      if (v14 != CFGetTypeID(v15))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2808, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionLibarchiveFormatKey must be a CFNumberRef");
        goto LABEL_319;
      }
      valuePtr[0].st_dev = -1;
      if (!CFNumberGetValue(v16, kCFNumberSInt32Type, valuePtr))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2816, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
        goto LABEL_319;
      }
      *((_DWORD *)v6 + 31) = valuePtr[0].st_dev;
    }
    CFNumberRef v17 = (const __CFNumber *)CFDictionaryGetValue(a2, @"libarchiveFilter");
    if (v17)
    {
      CFNumberRef v18 = v17;
      if (v14 != CFGetTypeID(v17))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2828, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionLibarchiveFilterKey must be a CFNumberRef");
        goto LABEL_319;
      }
      valuePtr[0].st_dev = -1;
      if (!CFNumberGetValue(v18, kCFNumberSInt32Type, valuePtr))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2836, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
        goto LABEL_319;
      }
      *((_DWORD *)v6 + 32) = valuePtr[0].st_dev;
    }
    uint64_t v19 = CFDictionaryGetValue(a2, @"createAppleArchive");
    if (v19)
    {
      if (TypeID != CFGetTypeID(v19))
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2848, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionCreateAppleArchiveKey must be a CFBooleanRef");
        goto LABEL_319;
      }
      *((_DWORD *)v6 + 11) = 2;
    }
    CFTypeID v20 = CFStringGetTypeID();
    uint64_t v21 = CFDictionaryGetValue(a2, @"compressAppleArchive");
    if (!v21) {
      goto LABEL_59;
    }
    int v22 = v21;
    if (v20 == CFGetTypeID(v21))
    {
      if (CFEqual(v22, @"none") == 1)
      {
        int v23 = 0;
      }
      else if (CFEqual(v22, @"lz4") == 1)
      {
        int v23 = 256;
      }
      else if (CFEqual(v22, @"zlib") == 1)
      {
        int v23 = 1285;
      }
      else if (CFEqual(v22, @"lzma") == 1)
      {
        int v23 = 774;
      }
      else if (CFEqual(v22, @"lzfse") == 1)
      {
        int v23 = 2049;
      }
      else
      {
        if (CFEqual(v22, @"lzbitmap") != 1)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2896, (uint64_t)"parse_copier_destination_options", "Unsupported AppleArchive compression algorithm");
          goto LABEL_319;
        }
        int v23 = 1794;
      }
      *((_DWORD *)v6 + 41) = v23;
LABEL_59:
      CFNumberRef v26 = (const __CFNumber *)CFDictionaryGetValue(a2, @"outputFD");
      if (v26)
      {
        CFNumberRef v27 = v26;
        if (v14 != CFGetTypeID(v26))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2906, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionOutputFileDescriptorKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v27, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2914, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 12) = valuePtr[0].st_dev;
      }
      CFTypeID v28 = CFWriteStreamGetTypeID();
      int v29 = (__CFWriteStream *)CFDictionaryGetValue(a2, @"outputStream");
      if (v29)
      {
        uint64_t v30 = v29;
        if (v28 != CFGetTypeID(v29))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2928, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionOutputCFWriteStreamKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        if (CFWriteStreamGetStatus(v30) != kCFStreamStatusOpen)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2935, (uint64_t)"parse_copier_destination_options", "CFWriteStream is not open");
          goto LABEL_319;
        }
        *((void *)v6 + 7) = v30;
      }
      int v31 = CFDictionaryGetValue(a2, @"output2Nowhere");
      if (v31)
      {
        int v32 = v31;
        if (TypeID != CFGetTypeID(v31))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2947, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionOutputToNowhereKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        if (CFEqual(v32, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1) {
          *((_DWORD *)v6 + 11) = 3;
        }
      }
      if (CFDictionaryContainsKey(a2, @"archs") == 1)
      {
        memset(valuePtr, 0, 48);
        if (BOMCopierPrepareMatchContext(a2, (uint64_t)valuePtr, a3))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2964, (uint64_t)"parse_copier_destination_options", "Could not prepare binary matching context");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 48) = valuePtr[0].st_dev;
        *((void *)v6 + 25) = valuePtr[0].st_ino;
      }
      long long v33 = CFDictionaryGetValue(a2, @"enableAtomicCopies");
      if (v33)
      {
        long long v34 = v33;
        if (TypeID != CFGetTypeID(v33))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2977, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionPerformAtomicCopies must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[297] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v34) != 0;
      }
      long long v35 = CFDictionaryGetValue(a2, @"useDefaultDirectoryPermissions");
      if (v35)
      {
        long long v36 = v35;
        if (TypeID != CFGetTypeID(v35))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2989, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionUseDefaultDirectoryPermissions must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[296] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v36) != 0;
      }
      long long v37 = CFDictionaryGetValue(a2, @"useAppleFSCompression");
      if (v37)
      {
        long long v38 = v37;
        if (TypeID != CFGetTypeID(v37))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3001, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionUseAppleFSCompression must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[112] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v38) != 0;
      }
      long long v39 = CFDictionaryGetValue(a2, @"preserveAppleFSCompression");
      if (v39)
      {
        long long v40 = v39;
        if (TypeID != CFGetTypeID(v39))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3013, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionPreserveAppleFSCompression must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[113] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v40) != 0;
      }
      CFNumberRef v41 = (const __CFNumber *)CFDictionaryGetValue(a2, @"AppleFSCompressionType");
      if (v41)
      {
        CFNumberRef v42 = v41;
        if (v14 != CFGetTypeID(v41))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3026, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionAppleFSCompressionType must be a CFNumberRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v42, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3034, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 29) = valuePtr[0].st_dev;
      }
      CFNumberRef v43 = (const __CFNumber *)CFDictionaryGetValue(a2, @"AppleFSCompressionFlags");
      if (v43)
      {
        CFNumberRef v44 = v43;
        if (v14 != CFGetTypeID(v43))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3046, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionAppleFSCompressionFlags must be a CFNumberRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v44, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3054, (uint64_t)"parse_copier_destination_options", "Could not convert the format number to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 30) = valuePtr[0].st_dev;
      }
      long long v45 = CFDictionaryGetValue(a2, @"enforceDestinationEncapsulation");
      if (v45)
      {
        uint64_t v46 = v45;
        if (TypeID != CFGetTypeID(v45))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3066, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionEnforceDestinationEncapsulationKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[298] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v46) != 0;
      }
      uint64_t v47 = CFDictionaryGetValue(a2, @"enforceDestinationLocation");
      if (v47)
      {
        uint64_t v48 = v47;
        if (TypeID != CFGetTypeID(v47))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3078, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionEnforceDestinationLocationKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[299] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v48) != 0;
      }
      size_t v49 = CFDictionaryGetValue(a2, @"keepBinaries");
      if (v49)
      {
        uint64_t v50 = v49;
        if (TypeID != CFGetTypeID(v49))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3090, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeepBinariesKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[307] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v50) != 0;
      }
      CFStringRef v51 = (const __CFString *)CFDictionaryGetValue(a2, @"keptFileList");
      if (v51)
      {
        CFStringRef v52 = v51;
        if (v20 != CFGetTypeID(v51))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3102, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeptFileListKey must be a CFStringRef");
          goto LABEL_319;
        }
        CFIndex v53 = CFStringGetLength(v52) + 1;
        int v54 = (char *)malloc_type_calloc(1uLL, v53, 0x3C5E005DuLL);
        *((void *)v6 + 40) = v54;
        if (!v54)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3112, (uint64_t)"parse_copier_destination_options", "Could not allocate %ld bytes for path");
          goto LABEL_319;
        }
        if (!CFStringGetCString(v52, v54, v53, 0x8000100u))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3119, (uint64_t)"parse_copier_destination_options", "Could not convert enumeration_bom_path string to C string");
          goto LABEL_319;
        }
      }
      CFStringRef v55 = (const __CFString *)CFDictionaryGetValue(a2, @"keepFilePattern");
      if (v55)
      {
        CFStringRef v56 = v55;
        if (v20 != CFGetTypeID(v55))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3129, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeepFilePatternKey must be a CFStringRef");
          goto LABEL_319;
        }
        CFIndex v57 = CFStringGetLength(v56) + 1;
        buffer = (char *)malloc_type_calloc(1uLL, v57, 0xE8E4CC65uLL);
        if (!buffer)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3139, (uint64_t)"parse_copier_destination_options", "Could not allocate %ld bytes for pattern");
          goto LABEL_319;
        }
        if (CFStringGetCString(v56, buffer, v57, 0x8000100u))
        {
          uint64_t v58 = (regex_t *)malloc_type_malloc(0x20uLL, 0x10700404B019E81uLL);
          *((void *)v6 + 42) = v58;
          if (v58)
          {
            if (regcomp(v58, buffer, 5))
            {
              int v59 = *__error();
              unsigned __int8 v60 = __error();
              char v61 = strerror(*v60);
              BOMCopierErrorCapture(a3, v59, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3162, (uint64_t)"parse_copier_destination_options", "Could not compile regular expression from %s: %s", buffer, v61);
              int v62 = buffer;
LABEL_140:
              free(v62);
              goto LABEL_319;
            }
            free(buffer);
            goto LABEL_142;
          }
          int v63 = *__error();
          BOMCopierErrorCapture(a3, v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3154, (uint64_t)"parse_copier_destination_options", "Could not allocate regular expression");
        }
        else
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3146, (uint64_t)"parse_copier_destination_options", "Could not convert enumeration_bom_path string to C string");
        }
        int v62 = buffer;
        goto LABEL_140;
      }
LABEL_142:
      CFStringRef v64 = (const __CFString *)CFDictionaryGetValue(a2, @"keptFileDirectory");
      if (v64)
      {
        CFStringRef v65 = v64;
        if (v20 != CFGetTypeID(v64))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3175, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeptFileDirectoryKey must be a CFStringRef");
          goto LABEL_319;
        }
        CFIndex v66 = CFStringGetLength(v65) + 1;
        uint64_t v67 = (char *)malloc_type_calloc(1uLL, v66, 0xB5EA7FB2uLL);
        *((void *)v6 + 43) = v67;
        if (!v67)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3185, (uint64_t)"parse_copier_destination_options", "Could not allocate %ld bytes for kept file directory");
          goto LABEL_319;
        }
        if (!CFStringGetCString(v65, v67, v66, 0x8000100u))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3192, (uint64_t)"parse_copier_destination_options", "Could not convert kept_file_directory string to C string");
          goto LABEL_319;
        }
      }
      uint64_t v68 = CFDictionaryGetValue(a2, @"balanceKeptFiles");
      if (v68)
      {
        size_t v69 = v68;
        if (TypeID != CFGetTypeID(v68))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3202, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationBalanceKeptFilesKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        int v70 = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v69);
        v6[352] = v70 != 0;
        if (v70) {
          *((_DWORD *)v6 + 89) = 100;
        }
      }
      CFNumberRef v71 = (const __CFNumber *)CFDictionaryGetValue(a2, @"keptFileBalanceLimit");
      if (v71)
      {
        CFNumberRef v72 = v71;
        if (v14 != CFGetTypeID(v71))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3219, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationKeptFileBalanceLimitKey must be a CFNumberRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v72, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3227, (uint64_t)"parse_copier_destination_options", "Could not convert the kept file balance limit to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        if (valuePtr[0].st_dev <= 0)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3233, (uint64_t)"parse_copier_destination_options", "%d is out of range for kept file balance limit");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 89) = valuePtr[0].st_dev;
      }
      CFNumberRef v73 = (const __CFNumber *)CFDictionaryGetValue(a2, @"zlibCompressionLevel");
      if (v73)
      {
        CFNumberRef v74 = v73;
        if (v14 != CFGetTypeID(v73))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3246, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionZlibCompressionLevel must be a CFNumberRef");
          goto LABEL_319;
        }
        valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v74, kCFNumberSInt32Type, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3254, (uint64_t)"parse_copier_destination_options", "Could not convert the zlib compression level to kCFNumberSInt32Type");
          goto LABEL_319;
        }
        if ((valuePtr[0].st_dev - 10) <= 0xFFFFFFF4)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3260, (uint64_t)"parse_copier_destination_options", "%d is out of range for Zlib compression");
          goto LABEL_319;
        }
        *((_DWORD *)v6 + 36) = valuePtr[0].st_dev;
      }
      int v75 = CFDictionaryGetValue(a2, @"symlinkTreatment");
      if (v75)
      {
        int v76 = v75;
        if (CFGetTypeID(v75) != v20)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3276, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSymlinkTreatmentKey is not a CFStringRef");
          goto LABEL_319;
        }
        if (CFEqual(v76, @"unlink"))
        {
          int v77 = 1;
        }
        else if (CFEqual(v76, @"follow"))
        {
          int v77 = 2;
        }
        else
        {
          if (!CFEqual(v76, @"error"))
          {
            BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3291, (uint64_t)"parse_copier_destination_options", "Unknown value for kBOMCopierOptionSymlinkTreatmentKey");
            goto LABEL_319;
          }
          int v77 = 0;
        }
        *((_DWORD *)v6 + 70) = v77;
      }
      uint64_t v78 = CFDictionaryGetValue(a2, @"persistRestrictedFlags");
      if (v78)
      {
        CFTypeID v79 = v78;
        if (TypeID != CFGetTypeID(v78))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3301, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationPersistRestrictedFlags must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[303] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v79) != 0;
      }
      uint64_t v80 = CFDictionaryGetValue(a2, @"preserveRestrictedFlags");
      if (v80)
      {
        CFStringRef v81 = v80;
        if (TypeID != CFGetTypeID(v80))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3313, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationPreserveRestrictedFlags must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[302] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v81) != 0;
      }
      BOOL v82 = CFDictionaryGetValue(a2, @"persistRootless");
      if (v82)
      {
        uint64_t v83 = v82;
        if (TypeID != CFGetTypeID(v82))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3325, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionPersistRootlessExtendedAttribute must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[301] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v83) != 0;
      }
      CFNumberRef v84 = (const __CFNumber *)CFDictionaryGetValue(a2, @"initialInode");
      if (v84)
      {
        CFNumberRef v85 = v84;
        if (v14 != CFGetTypeID(v84))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3337, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionInitialInodeKey must be a CFNumberRef");
          goto LABEL_319;
        }
        *(void *)&valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v85, kCFNumberLongLongType, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3345, (uint64_t)"parse_copier_destination_options", "Could not convert kBOMCopierDestinationOptionInitialInodeKey to kCFNumberLongLongType");
          goto LABEL_319;
        }
        *((void *)v6 + 8) = *(void *)&valuePtr[0].st_dev;
      }
      CFStringRef v86 = CFDictionaryGetValue(a2, @"skipTerminator");
      if (v86)
      {
        CFStringRef v87 = v86;
        if (TypeID != CFGetTypeID(v86))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3357, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSkipCPIOTerminatorKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[148] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v87) != 0;
      }
      CFNumberRef v88 = (const __CFNumber *)CFDictionaryGetValue(a2, @"segmentFileSize");
      if (v88)
      {
        CFNumberRef v89 = v88;
        if (v14 != CFGetTypeID(v88))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3369, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSegmentFileSizeKey must be a CFNumberRef");
          goto LABEL_319;
        }
        *(void *)&valuePtr[0].st_dev = -1;
        if (!CFNumberGetValue(v89, kCFNumberLongLongType, valuePtr))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3377, (uint64_t)"parse_copier_destination_options", "Could not convert kBOMCopierDestinationOptionSegmentFileSizeKey to kCFNumberLongLongType");
          goto LABEL_319;
        }
        *((void *)v6 + 19) = *(void *)&valuePtr[0].st_dev;
      }
      int v90 = CFDictionaryGetValue(a2, @"appleDoubleMergeACLs");
      if (v90)
      {
        char v91 = v90;
        if (TypeID != CFGetTypeID(v90))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3389, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionAppleDoubleMergeACLsKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[160] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v91) != 0;
      }
      uint64_t v92 = CFDictionaryGetValue(a2, @"cloneFiles");
      if (v92)
      {
        uint64_t v93 = v92;
        if (TypeID != CFGetTypeID(v92))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3401, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionCloneFilesKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[304] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v93) != 0;
      }
      CFStringRef v94 = CFDictionaryGetValue(a2, @"removeSetuidPermissions");
      if (v94)
      {
        int v95 = v94;
        if (TypeID != CFGetTypeID(v94))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3413, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionRemoveSetuidPermissionsKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[305] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v95) != 0;
      }
      CFIndex v96 = CFDictionaryGetValue(a2, @"removeExecutablePermissions");
      if (v96)
      {
        uint64_t v97 = v96;
        if (TypeID != CFGetTypeID(v96))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3425, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionRemoveExecutablePermissionsKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[306] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v97) != 0;
      }
      uint64_t v98 = CFDictionaryGetValue(a2, @"setStaticContent");
      if (v98)
      {
        int v99 = v98;
        if (TypeID != CFGetTypeID(v98))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3437, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSetStaticContentKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[41] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v99) != 0;
      }
      uint64_t v100 = CFDictionaryGetValue(a2, @"setSingleWriter");
      if (v100)
      {
        uint64_t v101 = v100;
        if (TypeID != CFGetTypeID(v100))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3449, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSetSingleWriterKey must be a CFBooleanRef");
          goto LABEL_319;
        }
        v6[42] = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v101) != 0;
      }
      uint64_t v102 = CFDictionaryGetValue(a2, @"setDataProtectionClass");
      if (v102)
      {
        uint64_t v103 = v102;
        if (v20 != CFGetTypeID(v102))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3461, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionSetDataProtectionClassKey must be a CFStringRef");
          goto LABEL_319;
        }
        int v104 = CFEqual(v103, @"A");
        int v105 = 1;
        if (v104 != 1)
        {
          if (CFEqual(v103, @"B") == 1)
          {
            int v105 = 2;
          }
          else if (CFEqual(v103, @"C") == 1)
          {
            int v105 = 3;
          }
          else
          {
            if (CFEqual(v103, @"D") != 1)
            {
              BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3479, (uint64_t)"parse_copier_destination_options", "Unsupported data protection class");
              goto LABEL_319;
            }
            int v105 = 4;
          }
        }
        *((_DWORD *)v6 + 4) = v105;
        v6[12] = 1;
      }
      CFTypeID v106 = CFDataGetTypeID();
      CFDataRef v107 = (const __CFData *)CFDictionaryGetValue(a2, @"applyProvenance");
      if (v107)
      {
        CFDataRef v108 = v107;
        if (v106 != CFGetTypeID(v107))
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3493, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionApplyProvenanceKey must be a CFDataRef");
          goto LABEL_319;
        }
        size_t Length = CFDataGetLength(v108);
        if (!Length)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3501, (uint64_t)"parse_copier_destination_options", "kBOMCopierOptionApplyProvenanceKey has an invalid size");
          goto LABEL_319;
        }
        size_t v110 = Length;
        long long v111 = malloc_type_malloc(Length, 0xA5D9A754uLL);
        if (!v111)
        {
          int v167 = *__error();
          BOMCopierErrorCapture(a3, v167, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3508, (uint64_t)"parse_copier_destination_options", "Could not allocate provenance data buffer");
          goto LABEL_319;
        }
        long long v112 = v111;
        BytePtr = CFDataGetBytePtr(v108);
        memcpy(v112, BytePtr, v110);
        *((void *)v6 + 3) = v112;
        *((void *)v6 + 4) = v110;
      }
      goto LABEL_249;
    }
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2862, (uint64_t)"parse_copier_destination_options", "kBOMCopierDestinationOptionCompressAppleArchiveKey must be a CFStringRef");
LABEL_319:
    BOMCopierDestinationFree((unsigned int *)v6);
    return 0;
  }
LABEL_249:
  switch(*((_DWORD *)v6 + 11))
  {
    case 0:
      memset(&v172, 0, sizeof(v172));
      int v114 = stat(__s, &v172);
      if (v114)
      {
        int v115 = v114;
        if (*__error() != 2)
        {
          int v124 = *__error();
          int v125 = __error();
          strerror(*v125);
          BOMCopierErrorCapture(a3, v124, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 711, (uint64_t)"BOMCopierDestinationNew", "Could not stat %s: %s");
          goto LABEL_319;
        }
        v6[284] = 0;
        if (dirname_r(__s, (char *)valuePtr) != (char *)valuePtr)
        {
          v116 = __error();
          strerror(*v116);
          BOMCopierErrorCapture(a3, v115, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 767, (uint64_t)"BOMCopierDestinationNew", "Could not dirname %s: %s");
          goto LABEL_319;
        }
        if (basename_r(__s, v173) != v173)
        {
          v132 = __error();
          strerror(*v132);
          BOMCopierErrorCapture(a3, v115, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 777, (uint64_t)"BOMCopierDestinationNew", "Could not basename %s: %s");
          goto LABEL_319;
        }
        if (make_path(0, (char *)valuePtr, a3))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 785, (uint64_t)"BOMCopierDestinationNew", "Could not make the parent_path %s");
          goto LABEL_319;
        }
        v155 = realpath_DARWIN_EXTSN((const char *)valuePtr, 0);
        if (!v155)
        {
          v161 = __error();
          strerror(*v161);
          BOMCopierErrorCapture(a3, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 793, (uint64_t)"BOMCopierDestinationNew", "Could not realpath %s: %s");
          goto LABEL_319;
        }
        AAArchiveStream v156 = v155;
        char v171 = 0;
        __int16 v170 = 0;
        if (get_volume_state(v155, (BOOL *)&v170, a3))
        {
          int v157 = __error();
          strerror(*v157);
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 814, (uint64_t)"BOMCopierDestinationNew", "Could not get volume state for %s: %s");
          goto LABEL_319;
        }
        if (v6[12]) {
          v6[12] = v170;
        }
        v6[20] = HIBYTE(v170);
        v6[300] = v171;
        asprintf((char **)v6 + 36, "%s/%s", v156, v173);
        free(v156);
        if (!*((void *)v6 + 36))
        {
          v163 = __error();
          strerror(*v163);
          BOMCopierErrorCapture(a3, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 839, (uint64_t)"BOMCopierDestinationNew", "Could not construct resolve path from %s and %s: %s", v156);
          goto LABEL_319;
        }
      }
      else
      {
        v6[285] = (v172.st_mode & 0xF000) == 0x4000;
        if (v6[299])
        {
          memset(valuePtr, 0, 144);
          if (lstat(__s, valuePtr))
          {
            int v122 = *__error();
            uint64_t v123 = __error();
            strerror(*v123);
            BOMCopierErrorCapture(a3, v122, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 733, (uint64_t)"BOMCopierDestinationNew", "Could not stat %s: %s");
            goto LABEL_319;
          }
          if ((valuePtr[0].st_mode & 0xF000) == 0xA000 && valuePtr[0].st_dev != v172.st_dev)
          {
            int v150 = *__error();
            int v151 = __error();
            strerror(*v151);
            BOMCopierErrorCapture(a3, v150, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 742, (uint64_t)"BOMCopierDestinationNew", "%s exists on a different device from its target");
            goto LABEL_319;
          }
        }
        v6[284] = 1;
        uint64_t v133 = realpath_DARWIN_EXTSN(__s, 0);
        if (!v133)
        {
          int v140 = __error();
          strerror(*v140);
          BOMCopierErrorCapture(a3, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 849, (uint64_t)"BOMCopierDestinationNew", "Could not realpath %s: %s");
          goto LABEL_319;
        }
        *((void *)v6 + 36) = v133;
        BYTE2(valuePtr[0].st_dev) = 0;
        LOWORD(valuePtr[0].st_dev) = 0;
        int volume_state = get_volume_state(v133, (BOOL *)valuePtr, a3);
        if (volume_state)
        {
          int v135 = volume_state;
          int v136 = __error();
          strerror(*v136);
          BOMCopierErrorCapture(a3, v135, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 872, (uint64_t)"BOMCopierDestinationNew", "Could not get volume state for %s: %s");
          goto LABEL_319;
        }
        if (v6[12]) {
          v6[12] = valuePtr[0].st_dev;
        }
        v6[20] = BYTE1(valuePtr[0].st_dev);
        v6[300] = BYTE2(valuePtr[0].st_dev);
      }
      break;
    case 1:
      uint64_t v118 = archive_write_new();
      *((void *)v6 + 17) = v118;
      if (!v118)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 902, (uint64_t)"BOMCopierDestinationNew", "Could not create archive");
        goto LABEL_319;
      }
      int v119 = archive_write_set_format();
      if (v119)
      {
        int v120 = archive_errno();
        strerror(v120);
        BOMCopierErrorCapture(a3, v119, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 910, (uint64_t)"BOMCopierDestinationNew", "Could not set archive format: %s");
        goto LABEL_319;
      }
      int v126 = archive_write_add_filter();
      if (v126)
      {
        int v127 = v126;
        int v128 = archive_errno();
        strerror(v128);
        BOMCopierErrorCapture(a3, v127, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 918, (uint64_t)"BOMCopierDestinationNew", "Could not set archive filter: %s");
        goto LABEL_319;
      }
      if (*((_DWORD *)v6 + 32) == 1 && *((_DWORD *)v6 + 36) != -1)
      {
        snprintf((char *)valuePtr, 0xFFuLL, "%d", *((_DWORD *)v6 + 36));
        int v137 = archive_write_set_filter_option();
        if (v137)
        {
          int v138 = v137;
          int v139 = archive_errno();
          strerror(v139);
          BOMCopierErrorCapture(a3, v138, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 937, (uint64_t)"BOMCopierDestinationNew", "Could not set zlib compression level %s: %s");
          goto LABEL_319;
        }
      }
      if (*((_DWORD *)v6 + 31) == 327680 && *((_DWORD *)v6 + 36) != -1)
      {
        snprintf((char *)valuePtr, 0xFFuLL, "%d", *((_DWORD *)v6 + 36));
        int v141 = archive_write_set_format_option();
        if (v141)
        {
          int v142 = v141;
          int v143 = archive_errno();
          strerror(v143);
          BOMCopierErrorCapture(a3, v142, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 954, (uint64_t)"BOMCopierDestinationNew", "Could not set PKZip compression level %s: %s (%d)", valuePtr);
          goto LABEL_319;
        }
      }
      if (*((void *)v6 + 8))
      {
        snprintf((char *)valuePtr, 0xFFuLL, "%lld", *((void *)v6 + 8));
        int v144 = archive_write_set_format_option();
        if (v144)
        {
          int v145 = v144;
          int v146 = archive_errno();
          strerror(v146);
          BOMCopierErrorCapture(a3, v145, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 971, (uint64_t)"BOMCopierDestinationNew", "Could not set cpio starting inode %s: %s");
          goto LABEL_319;
        }
      }
      if (v6[148])
      {
        int v147 = archive_write_set_format_option();
        if (v147)
        {
          int v148 = v147;
          int v149 = archive_errno();
          strerror(v149);
          BOMCopierErrorCapture(a3, v148, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 984, (uint64_t)"BOMCopierDestinationNew", "Could not enable cpio skip trailer %s");
          goto LABEL_319;
        }
      }
      if (__s)
      {
        int v152 = archive_write_open_filename();
        if (v152)
        {
          int v153 = v152;
          int v154 = archive_errno();
          strerror(v154);
          BOMCopierErrorCapture(a3, v153, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 999, (uint64_t)"BOMCopierDestinationNew", "Could not archive_write_open_filename %s: %s\n");
          goto LABEL_319;
        }
      }
      else if (*((void *)v6 + 7))
      {
        int v158 = archive_write_open2();
        if (v158)
        {
          int v159 = v158;
          int v160 = archive_errno();
          strerror(v160);
          BOMCopierErrorCapture(a3, v159, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1028, (uint64_t)"BOMCopierDestinationNew", "Could not archive_write_open2 %s: %s\n");
          goto LABEL_319;
        }
      }
      else
      {
        if (*((_DWORD *)v6 + 12) == -1)
        {
          BOMCopierErrorCapture(a3, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1036, (uint64_t)"BOMCopierDestinationNew", "No output file descriptor\n", v168);
          goto LABEL_319;
        }
        int v164 = archive_write_open_fd();
        if (v164)
        {
          int v165 = v164;
          int v166 = archive_errno();
          strerror(v166);
          BOMCopierErrorCapture(a3, v165, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1044, (uint64_t)"BOMCopierDestinationNew", "Could not archive_write_open_fd %s: %s\n");
          goto LABEL_319;
        }
      }
      break;
    case 2:
      if (__s)
      {
        uint32_t v117 = AAFileStreamOpenWithPath(__s, 1537, 0x1A4u);
        *((void *)v6 + 21) = v117;
        if (!v117)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1063, (uint64_t)"BOMCopierDestinationNew", "Could not create AppleArchive byte stream at %s\n");
          goto LABEL_319;
        }
      }
      else if (*((void *)v6 + 7))
      {
        uint64_t v121 = AACustomByteStreamOpen();
        *((void *)v6 + 21) = v121;
        if (!v121)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1079, (uint64_t)"BOMCopierDestinationNew", "Could not create custom AppleArchive byte stream at %s\n");
          goto LABEL_319;
        }
        AACustomByteStreamSetData(v121, v6);
        AACustomByteStreamSetCloseProc(*((AAByteStream *)v6 + 21), (AAByteStreamCloseProc)apple_archive_close_callback_0);
        AACustomByteStreamSetWriteProc(*((AAByteStream *)v6 + 21), (AAByteStreamWriteProc)apple_archive_write_callback);
        uint32_t v117 = (AAByteStream_impl *)*((void *)v6 + 21);
      }
      else
      {
        int v129 = *((_DWORD *)v6 + 12);
        if (v129 == -1)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1091, (uint64_t)"BOMCopierDestinationNew", "No output file descriptor\n");
          goto LABEL_319;
        }
        uint32_t v117 = AAFileStreamOpenWithFD(v129, 0);
        *((void *)v6 + 21) = v117;
        if (!v117)
        {
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1099, (uint64_t)"BOMCopierDestinationNew", "Could not create AppleArchive byte stream from file descriptor\n");
          goto LABEL_319;
        }
      }
      uint64_t v130 = AACompressionOutputStreamOpen(v117, *((_DWORD *)v6 + 41), 0x100000uLL, 0, 0);
      *((void *)v6 + 22) = v130;
      if (!v130)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1118, (uint64_t)"BOMCopierDestinationNew", "Could not create AppleArchive compression stream\n");
        goto LABEL_319;
      }
      AAArchiveStream v131 = AAEncodeArchiveOutputStreamOpen(v130, 0, 0, 0, 0);
      *((void *)v6 + 23) = v131;
      if (!v131)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1132, (uint64_t)"BOMCopierDestinationNew", "Could not create AppleArchive encoder\n");
        goto LABEL_319;
      }
      break;
    case 3:
      if (__s)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1143, (uint64_t)"BOMCopierDestinationNew", "I expect path to be NULL for nowhere destinations");
        goto LABEL_319;
      }
      break;
    default:
      return v6;
  }
  return v6;
}

void BOMCopierDestinationFree(unsigned int *a1)
{
  if (a1)
  {
    unint64_t v2 = (void *)*((void *)a1 + 3);
    if (v2) {
      free(v2);
    }
    uint64_t v3 = (void *)*((void *)a1 + 45);
    if (v3) {
      free(v3);
    }
    uint64_t v4 = (void *)*((void *)a1 + 43);
    if (v4) {
      free(v4);
    }
    if (*((void *)a1 + 42))
    {
      MEMORY[0x21666D560]();
      free(*((void **)a1 + 42));
    }
    int v5 = a1[82];
    if (v5 != -1) {
      close(v5);
    }
    int v6 = (void *)*((void *)a1 + 40);
    if (v6) {
      free(v6);
    }
    size_t v7 = (void *)*((void *)a1 + 36);
    if (v7) {
      free(v7);
    }
    uint64_t v8 = (void *)*((void *)a1 + 25);
    if (v8)
    {
      unint64_t v9 = a1[48];
      if (v9)
      {
        unint64_t v10 = 0;
        uint64_t v11 = 16;
        do
        {
          long long v12 = *(void **)(*((void *)a1 + 25) + v11);
          if (v12)
          {
            free(v12);
            unint64_t v9 = a1[48];
          }
          ++v10;
          v11 += 32;
        }
        while (v10 < v9);
        uint64_t v8 = (void *)*((void *)a1 + 25);
      }
      free(v8);
    }
    uint64_t v13 = (AAArchiveStream_impl *)*((void *)a1 + 23);
    if (v13)
    {
      CFTypeID v14 = (char *)AAArchiveStreamClose(v13);
      if (v14)
      {
        CFNumberRef v15 = (FILE *)*MEMORY[0x263EF8348];
        CFTypeID v28 = v14;
        CFNumberRef v16 = "Could not close AppleArchive encoder: %d\n";
LABEL_36:
        int v22 = v15;
LABEL_37:
        fprintf(v22, v16, v28);
        return;
      }
    }
    CFNumberRef v17 = (AAByteStream_impl *)*((void *)a1 + 22);
    if (v17)
    {
      CFNumberRef v18 = (char *)AAByteStreamClose(v17);
      if (v18)
      {
        CFNumberRef v15 = (FILE *)*MEMORY[0x263EF8348];
        CFTypeID v28 = v18;
        CFNumberRef v16 = "Could not close AppleArchive compression stream: %d\n";
        goto LABEL_36;
      }
    }
    CFTypeID v20 = (AAByteStream_impl *)*((void *)a1 + 21);
    if (v20)
    {
      uint64_t v21 = (char *)AAByteStreamClose(v20);
      if (v21)
      {
        CFNumberRef v15 = (FILE *)*MEMORY[0x263EF8348];
        CFTypeID v28 = v21;
        CFNumberRef v16 = "Could not close AppleArchive byte stream: %d\n";
        goto LABEL_36;
      }
    }
    if (*((void *)a1 + 17))
    {
      if (archive_write_close())
      {
        int v23 = (FILE *)*MEMORY[0x263EF8348];
        int v24 = archive_errno();
        CFTypeID v28 = strerror(v24);
        CFNumberRef v16 = "Could not close archive %s\n";
LABEL_43:
        int v22 = v23;
        goto LABEL_37;
      }
      if (archive_write_free())
      {
        int v23 = (FILE *)*MEMORY[0x263EF8348];
        int v25 = archive_errno();
        CFTypeID v28 = strerror(v25);
        CFNumberRef v16 = "Could not free archive: %s\n";
        goto LABEL_43;
      }
    }
    CFNumberRef v26 = (void *)*((void *)a1 + 13);
    if (v26)
    {
      BOMCopierDataAnalyzerFree(v26);
      *((void *)a1 + 13) = 0;
    }
    CFNumberRef v27 = (const void **)*((void *)a1 + 9);
    if (v27) {
      BOMHardLinkTableFree(v27);
    }
    free(a1);
  }
  else
  {
    uint64_t v19 = (FILE *)*MEMORY[0x263EF8348];
    fwrite("copier_destination is NULL", 0x1AuLL, 1uLL, v19);
  }
}

uint64_t make_path(NSObject *a1, char *__s1, void *a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  int v6 = strdup(__s1);
  if (!v6)
  {
    int v15 = *__error();
    CFNumberRef v16 = __error();
    CFNumberRef v17 = strerror(*v16);
    BOMCopierErrorCapture(a3, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3538, (uint64_t)"make_path", "Could not duplicate %s: %s", __s1, v17);
    return 1;
  }
  size_t v7 = v6;
  int v8 = *v6;
  BOOL v9 = v8 == 47;
  if (v8 == 47) {
    ++v6;
  }
  unint64_t v10 = strchr(v6, 47);
  if (!v10)
  {
LABEL_13:
    if (mkdir(v7, 0x1EDu))
    {
      if (*__error() != 17)
      {
        int v13 = *__error();
        CFTypeID v14 = __error();
        strerror(*v14);
        BOMCopierErrorCapture(a3, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3599, (uint64_t)"make_path", "Could not mkdir %s: %s");
        goto LABEL_22;
      }
    }
    else if (a1)
    {
      if (os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)statfs buf = 136315138;
        int v22 = v7;
        _os_log_impl(&dword_2105F8000, a1, OS_LOG_TYPE_DEFAULT, "Created directory %s", buf, 0xCu);
      }
    }
    free(v7);
    return 0;
  }
  uint64_t v11 = v10;
  long long v12 = &v7[v9 + 1];
  while (1)
  {
    *uint64_t v11 = 0;
    if (!mkdir(v7, 0x1EDu))
    {
      if (a1 && os_log_type_enabled(a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)statfs buf = 136315138;
        int v22 = v7;
        _os_log_impl(&dword_2105F8000, a1, OS_LOG_TYPE_DEFAULT, "Created directory %s", buf, 0xCu);
      }
      goto LABEL_8;
    }
    if (*__error() != 17) {
      break;
    }
LABEL_8:
    *uint64_t v11 = 47;
    uint64_t v11 = strchr(v12++, 47);
    if (!v11) {
      goto LABEL_13;
    }
  }
  int v19 = *__error();
  CFTypeID v20 = __error();
  strerror(*v20);
  BOMCopierErrorCapture(a3, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3562, (uint64_t)"make_path", "Could not mkdir %s: %s");
LABEL_22:
  free(v7);
  return 1;
}

uint64_t get_volume_state(const char *a1, BOOL *a2, void *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  memset(&v16, 0, 512);
  if (!statfs(a1, &v16))
  {
    char f_flags = v16.f_flags;
    *a2 = (v16.f_flags & 0x80) != 0;
    a2[1] = (f_flags & 8) == 0;
    long long v14 = xmmword_210662CE8;
    int v15 = 0;
    long long v12 = xmmword_210662CFC;
    uint64_t v13 = 0;
    if (getattrlist(a1, &v12, &v14, 0x14uLL, 0))
    {
      if (*__error() != 22)
      {
        int v10 = *__error();
        uint64_t v11 = __error();
        strerror(*v11);
        BOMCopierErrorCapture(a3, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8658, (uint64_t)"get_volume_state", "Could not getattrlist %s: %s\n");
        return 1;
      }
      if (*(_DWORD *)v16.f_fstypename == 7562856) {
        a2[2] = 1;
      }
      if (*(_DWORD *)v16.f_fstypename ^ 0x73667061 | v16.f_fstypename[4]) {
        return 0;
      }
    }
    else if ((BYTE6(v14) & 1) == 0)
    {
      return 0;
    }
    uint64_t result = 0;
    a2[2] = 1;
    return result;
  }
  int v6 = *__error();
  size_t v7 = __error();
  strerror(*v7);
  BOMCopierErrorCapture(a3, v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8629, (uint64_t)"get_volume_state", "Could not statfs %s: %s");
  return 1;
}

uint64_t libarchive_open_callback_0()
{
  return 0;
}

CFIndex libarchive_write_callback(int a1, uint64_t a2, UInt8 *buffer, CFIndex bufferLength)
{
  if (a2) {
    return CFWriteStreamWrite(*(CFWriteStreamRef *)(a2 + 56), buffer, bufferLength);
  }
  else {
    return -1;
  }
}

uint64_t libarchive_close_callback_0()
{
  return 0;
}

uint64_t libarchive_free_callback()
{
  return 0;
}

uint64_t apple_archive_close_callback_0()
{
  return 0;
}

CFIndex apple_archive_write_callback(uint64_t a1, const UInt8 *a2, CFIndex a3)
{
  if (a1) {
    return CFWriteStreamWrite(*(CFWriteStreamRef *)(a1 + 56), a2, a3);
  }
  else {
    return -1;
  }
}

void *BOMCopierDestinationSetLog(void *result, uint64_t a2)
{
  if (result)
  {
    if (a2) {
      *uint64_t result = a2;
    }
  }
  return result;
}

uint64_t BOMCopierDestinationSetAllowBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    uint64_t v3 = 0;
    *(void *)(a1 + 80) = a2;
  }
  else
  {
    uint64_t v3 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1304, (uint64_t)"BOMCopierDestinationSetAllowBom", "copier_destination is NULL");
  }
  return v3;
}

uint64_t BOMCopierDestinationSetDenyBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    uint64_t v3 = 0;
    *(void *)(a1 + 88) = a2;
  }
  else
  {
    uint64_t v3 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1326, (uint64_t)"BOMCopierDestinationSetDenyBom", "copier_destination is NULL");
  }
  return v3;
}

uint64_t BOMCopierDestinationSetChecksumBom(uint64_t a1, uint64_t a2, void *a3)
{
  if (a1)
  {
    *(void *)(a1 + 96) = a2;
    if (!a2) {
      return 0;
    }
    if (*(void *)(a1 + 104)) {
      return 0;
    }
    int v5 = BOMCopierDataAnalyzerNew(2, a3);
    *(void *)(a1 + 104) = v5;
    if (v5)
    {
      return 0;
    }
    else
    {
      uint64_t v6 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1365, (uint64_t)"BOMCopierDestinationSetChecksumBom", "Could not create BOMCopierDataAnalyzer");
    }
  }
  else
  {
    uint64_t v6 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1348, (uint64_t)"BOMCopierDestinationSetChecksumBom", "copier_destination is NULL");
  }
  return v6;
}

uint64_t BOMCopierDestinationSetRedirectCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0;
    *(void *)(a1 + 208) = a2;
    *(void *)(a1 + 216) = a3;
  }
  else
  {
    uint64_t v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1387, (uint64_t)"BOMCopierDestinationSetRedirectCallback", "copier_destination is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationSetConflictResolver(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0;
    *(void *)(a1 + 224) = a2;
    *(void *)(a1 + 232) = a3;
  }
  else
  {
    uint64_t v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1410, (uint64_t)"BOMCopierDestinationSetConflictResolver", "copier_destination is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationSetFinalizationCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0;
    *(void *)(a1 + 264) = a2;
    *(void *)(a1 + 272) = a3;
  }
  else
  {
    uint64_t v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1433, (uint64_t)"BOMCopierDestinationSetFinalizationCallback", "copier_destination is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationGetCopyOperation(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 240);
  }
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1453, (uint64_t)"BOMCopierDestinationGetCopyOperation", "copier_destination is NULL");
  return 2;
}

uint64_t BOMCopierDestinationGetCopyResult(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 244);
  }
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1470, (uint64_t)"BOMCopierDestinationGetCopyResult", "copier_destination is NULL");
  return 1;
}

uint64_t BOMCopierDestinationSetDataWrittenCallback(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    uint64_t v4 = 0;
    *(void *)(a1 + 248) = a2;
    *(void *)(a1 + 256) = a3;
  }
  else
  {
    uint64_t v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1490, (uint64_t)"BOMCopierDestinationSetDataWrittenCallback", "copier_destination is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationCreateEntry(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1513, (uint64_t)"BOMCopierDestinationCreateEntry", "copier_destination is NULL");
    return 0;
  }
  if (!a2)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1519, (uint64_t)"BOMCopierDestinationCreateEntry", "source_entry is NULL");
    return 0;
  }
  if (*(void *)(a1 + 80) && !BOMCopierSourceEntryIsRoot(a2))
  {
    uint64_t Path = BOMCopierSourceEntryGetPath(a2);
    BOOL v8 = !BOMBomFSObjectExistsAtPath(*(void *)(a1 + 80), Path);
  }
  else
  {
    BOOL v8 = 0;
  }
  if (*(void *)(a1 + 88))
  {
    if (!BOMCopierSourceEntryIsRoot(a2))
    {
      uint64_t v10 = BOMCopierSourceEntryGetPath(a2);
      if (BOMBomFSObjectExistsAtPath(*(void *)(a1 + 88), v10)) {
        BOOL v8 = 1;
      }
    }
  }
  uint64_t v11 = malloc_type_calloc(1uLL, 0x178uLL, 0x10300404E91E69FuLL);
  if (!v11)
  {
    int v13 = *__error();
    long long v14 = __error();
    strerror(*v14);
    BOMCopierErrorCapture(a4, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1584, (uint64_t)"BOMCopierDestinationCreateEntry", "Could not allocate empty destination entry: %s");
    return 0;
  }
  uint64_t v12 = (uint64_t)v11;
  v11[8] = -1;
  *(_DWORD *)uint64_t v11 = *(_DWORD *)(a1 + 44);
  v11[1] = a2;
  if (!v8)
  {
    BOMCopierDataAnalyzerReset(*(uint64_t **)(a1 + 104));
    *(void *)(v12 + 24) = *(void *)(a1 + 104);
    *(_DWORD *)(v12 + 32) = 1;
    if (BOMCopierSourceEntryGetType(a2) == 8)
    {
      *(void *)(v12 + 56) = BOMCopierSourceEntryGetSize(a2);
      if (BOMCopierSourceEntryGetBinaryType(a2))
      {
        long long v19 = 0u;
        long long v20 = 0u;
        long long v18 = 0u;
        LODWORD(v18) = *(_DWORD *)(a1 + 192);
        *((void *)&v18 + 1) = *(void *)(a1 + 200);
        if (BOMCopierMatchBinary(a2, (unsigned int *)&v18, a4))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3647, (uint64_t)"match_binary", "Could not match the binary");
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1639, (uint64_t)"BOMCopierDestinationCreateEntry", "Could not match the source binary");
LABEL_33:
          BOMCopierDestinationEntryFree((void *)v12);
          return 0;
        }
        *(_OWORD *)(v12 + 32) = v19;
        *(_DWORD *)(v12 + 48) = v20;
        *(void *)(v12 + 56) = *((void *)&v20 + 1);
      }
    }
    if (*(_DWORD *)(v12 + 32) == 2) {
      return v12;
    }
    int v16 = *(_DWORD *)(a1 + 44);
    if (v16 == 2)
    {
      int entry_apple_archive = create_entry_apple_archive(a1, a2, v12, a4);
    }
    else if (v16 == 1)
    {
      int entry_apple_archive = create_entry_libarchive(a1, a2, (void *)v12, a4);
    }
    else
    {
      if (v16) {
        return v12;
      }
      int entry_apple_archive = create_entry_filesystem(a1, a2, v12, a3, a4);
    }
    if (!entry_apple_archive) {
      return v12;
    }
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1679, (uint64_t)"BOMCopierDestinationCreateEntry", "Could not create the entry");
    goto LABEL_33;
  }
  *((unsigned char *)v11 + 16) = 1;
  return v12;
}

void BOMCopierDestinationEntryFree(void *a1)
{
  if (a1)
  {
    unint64_t v2 = (void *)a1[45];
    if (v2) {
      free(v2);
    }
    uint64_t v3 = (void *)a1[43];
    if (v3) {
      free(v3);
    }
    if (a1[10]) {
      archive_entry_free();
    }
    uint64_t v4 = (void *)a1[40];
    if (v4) {
      free(v4);
    }
    if (a1[20])
    {
      if (ParallelCompressionAFSCStreamClose())
      {
        int v5 = (FILE *)*MEMORY[0x263EF8348];
        uint64_t v6 = __error();
        size_t v7 = strerror(*v6);
        fprintf(v5, "Could not close compressor stream: %s", v7);
      }
      a1[20] = 0;
    }
    int v8 = *((_DWORD *)a1 + 17);
    if (v8 != *((_DWORD *)a1 + 16))
    {
      close(v8);
      int v8 = *((_DWORD *)a1 + 16);
    }
    if (v8 != -1) {
      close(v8);
    }
    BOOL v9 = (void *)a1[18];
    if (v9) {
      free(v9);
    }
    uint64_t v10 = (void *)a1[17];
    if (v10) {
      free(v10);
    }
    uint64_t v11 = (void *)a1[16];
    if (v11) {
      free(v11);
    }
    uint64_t v12 = (void *)a1[15];
    if (v12) {
      free(v12);
    }
    int v13 = (void *)a1[5];
    if (v13) {
      free(v13);
    }
    free(a1);
  }
}

uint64_t create_entry_filesystem(uint64_t a1, uint64_t a2, uint64_t a3, char a4, void *a5)
{
  uint64_t v185 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 240) = 0;
  unsigned int Type = BOMCopierSourceEntryGetType(a2);
  uint64_t Path = (const char *)BOMCopierSourceEntryGetPath(a2);
  uint64_t v12 = *(NSObject **)a1;
  if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)statfs buf = 136315394;
    *(void *)&uint8_t buf[4] = string_for_entry_type(Type);
    __int16 v181 = 2080;
    v182 = Path;
    _os_log_impl(&dword_2105F8000, v12, OS_LOG_TYPE_DEFAULT, "entry_path: [%s] %s", buf, 0x16u);
  }
  size_t v13 = strlen(Path);
  if (!v13)
  {
    BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7822, (uint64_t)"construct_filesystem_destination", "The entry path is empty");
LABEL_87:
    uint64_t v65 = 1;
    BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3690, (uint64_t)"create_entry_filesystem", "Could not construct filesystem destinations");
    return v65;
  }
  unint64_t v14 = v13;
  if (!strncmp(Path, ".", v13))
  {
    ++Path;
  }
  else if (v14 >= 3)
  {
    int v15 = *(unsigned __int8 *)Path;
    if (v15 != 46) {
      goto LABEL_12;
    }
    Path += 2 * (Path[1] == 47);
  }
  int v15 = *(unsigned __int8 *)Path;
LABEL_12:
  if (BOMCopierSourceEntryIsRoot(a2))
  {
    if (Type == 6 || !*(unsigned char *)(a1 + 284) || !*(unsigned char *)(a1 + 285))
    {
LABEL_16:
      int v16 = strdup(*(const char **)(a1 + 288));
      *(void *)(a3 + 120) = v16;
      if (!v16)
      {
        int v17 = *__error();
        long long v18 = __error();
        strerror(*v18);
        BOMCopierErrorCapture(a5, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7939, (uint64_t)"construct_filesystem_destination", "Could not construct destination path from %s: %s");
        goto LABEL_87;
      }
      goto LABEL_21;
    }
  }
  else if (!v15)
  {
    goto LABEL_16;
  }
  if (asprintf((char **)(a3 + 120), "%s/%s", *(const char **)(a1 + 288), Path) < 0 || !*(void *)(a3 + 120))
  {
    int v30 = *__error();
    uint64_t v31 = *(void *)(a1 + 288);
    int v32 = __error();
    strerror(*v32);
    BOMCopierErrorCapture(a5, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7947, (uint64_t)"construct_filesystem_destination", "Could not construct destination path from %s and %s: %s", v31);
    goto LABEL_87;
  }
LABEL_21:
  long long v19 = *(void (**)(uint64_t, unsigned char *, void))(a1 + 208);
  if (v19)
  {
    *(void *)statfs buf = 0;
    v19(a1, buf, *(void *)(a1 + 216));
    if (*(void *)buf)
    {
      free(*(void **)(a3 + 120));
      *(void *)(a3 + 120) = *(void *)buf;
    }
    *(void *)(a1 + 208) = 0;
    *(void *)(a1 + 216) = 0;
  }
  long long v20 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x27BBF7F0uLL);
  *(void *)(a3 + 128) = v20;
  if (!v20)
  {
    int v33 = *__error();
    long long v34 = __error();
    strerror(*v34);
    BOMCopierErrorCapture(a5, v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7975, (uint64_t)"construct_filesystem_destination", "Could not allocate destination name: %s");
    goto LABEL_87;
  }
  uint64_t v21 = (const char **)(a3 + 120);
  basename_r(*(const char **)(a3 + 120), v20);
  int v22 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x5F1B39BFuLL);
  *(void *)(a3 + 136) = v22;
  if (!v22)
  {
    int v35 = *__error();
    long long v36 = __error();
    strerror(*v36);
    BOMCopierErrorCapture(a5, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7985, (uint64_t)"construct_filesystem_destination", "Could not allocate destination parent: %s");
    goto LABEL_87;
  }
  dirname_r(*v21, v22);
  uint64_t v23 = *(NSObject **)a1;
  if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = *v21;
    *(_DWORD *)statfs buf = 136315138;
    *(void *)&uint8_t buf[4] = v24;
    _os_log_impl(&dword_2105F8000, v23, OS_LOG_TYPE_DEFAULT, "destination_path: %s", buf, 0xCu);
  }
  if (*(unsigned char *)(a1 + 297) && (Type - 7 < 4 || Type == 5) && !BOMCopierSourceEntryIsSegmentedFile(a2))
  {
    *(void *)statfs buf = 0;
    if (asprintf((char **)buf, "%s/%s", *(const char **)(a3 + 136), ".BCD.T_XXXXXX") < 0 || !*(void *)buf)
    {
      int v62 = *__error();
      uint64_t v63 = *(void *)(a3 + 136);
      CFStringRef v64 = __error();
      strerror(*v64);
      BOMCopierErrorCapture(a5, v62, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8030, (uint64_t)"construct_filesystem_destination", "Could not construct atomic template path from %s and %s: %s", v63);
      goto LABEL_87;
    }
    int v25 = mktemp(*(char **)buf);
    if (v25 != *(char **)buf)
    {
      int v26 = *__error();
      CFNumberRef v27 = *(const char **)buf;
      CFTypeID v28 = __error();
      int v29 = strerror(*v28);
      BOMCopierErrorCapture(a5, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8040, (uint64_t)"construct_filesystem_destination", "Could not mktemp %s and %s: %s", v27, v29, v174);
      free(*(void **)buf);
      goto LABEL_87;
    }
    long long v37 = v25;
    *(void *)(a3 + 144) = v25;
    *(unsigned char *)(a3 + 152) = 1;
  }
  else
  {
    long long v37 = strdup(*(const char **)(a3 + 120));
    *(void *)(a3 + 144) = v37;
    if (!v37)
    {
      int v60 = *__error();
      char v61 = __error();
      strerror(*v61);
      BOMCopierErrorCapture(a5, v60, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8064, (uint64_t)"construct_filesystem_destination", "Could not duplicate %s: %s");
      goto LABEL_87;
    }
  }
  long long v38 = *(NSObject **)a1;
  if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)statfs buf = 136315138;
    *(void *)&uint8_t buf[4] = v37;
    _os_log_impl(&dword_2105F8000, v38, OS_LOG_TYPE_DEFAULT, "destination_staging_path: %s", buf, 0xCu);
  }
  char v39 = 0;
  while (1)
  {
    char v40 = v39;
    *(unsigned char *)(a3 + 153) = 1;
    if (lstat(*(const char **)(a3 + 120), (stat *)(a3 + 168)))
    {
      if (*__error() != 2)
      {
        int v79 = *__error();
        uint64_t v80 = __error();
        strerror(*v80);
        BOMCopierErrorCapture(a5, v79, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8097, (uint64_t)"resolve_filesystem_conflict", "Could not lstat %s: %s");
        goto LABEL_119;
      }
      *(unsigned char *)(a3 + 153) = 0;
      goto LABEL_95;
    }
    unsigned int v41 = BOMCopierSourceEntryGetType(a2);
    os_log_t v42 = *(os_log_t *)a1;
    int v43 = *(_WORD *)(a3 + 172) & 0xF000;
    switch(v41)
    {
      case 0u:
        BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8353, (uint64_t)"check_filesystem_conflict", "The source entry is unknown");
        goto LABEL_118;
      case 1u:
        BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8359, (uint64_t)"check_filesystem_conflict", "The source entry is a circular directory");
        goto LABEL_118;
      case 2u:
        BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8365, (uint64_t)"check_filesystem_conflict", "The source entry is an unreadable directory");
LABEL_118:
        BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8122, (uint64_t)"resolve_filesystem_conflict", "Could not check for a destination conflict for %s");
        goto LABEL_119;
      case 3u:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        goto LABEL_95;
      case 6u:
        if (v43 == 0x4000) {
          goto LABEL_95;
        }
        if (!v42 || !os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_57;
        }
        *(_WORD *)statfs buf = 0;
        CFNumberRef v44 = v42;
        long long v45 = "Filesystem Conflict: The source entry is a Directory but the destination entry is not.";
        break;
      default:
        if (v43 != 0x4000) {
          goto LABEL_95;
        }
        if (!v42 || !os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_57;
        }
        *(_WORD *)statfs buf = 0;
        CFNumberRef v44 = v42;
        long long v45 = "Filesystem Conflict: The source entry is not a Directory but the destination entry is.";
        break;
    }
    _os_log_impl(&dword_2105F8000, v44, OS_LOG_TYPE_DEFAULT, v45, buf, 2u);
LABEL_57:
    uint64_t v46 = *(NSObject **)a1;
    if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v47 = *(void *)(a3 + 120);
      uint64_t v48 = *(const char **)(a3 + 144);
      *(_DWORD *)statfs buf = 136315394;
      *(void *)&uint8_t buf[4] = v47;
      __int16 v181 = 2080;
      v182 = v48;
      _os_log_impl(&dword_2105F8000, v46, OS_LOG_TYPE_DEFAULT, "%s conflicts with %s", buf, 0x16u);
    }
    if (v41 == 6)
    {
      __int16 v49 = *(_WORD *)(a3 + 172);
      if ((v49 & 0xF000) == 0xA000) {
        break;
      }
    }
    uint64_t v58 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void *))(a1 + 224);
    if (!v58)
    {
      string_for_mode(*(_WORD *)(a3 + 172));
      string_for_entry_type(v41);
      BOMCopierErrorCapture(a5, 21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8322, (uint64_t)"resolve_filesystem_conflict", "%s: conflict replacing %s with %s", *(void *)(a3 + 120));
      goto LABEL_119;
    }
LABEL_80:
    *(_DWORD *)(a1 + 240) = 0;
    int v59 = v58(a1, a2, a3, *(void *)(a1 + 232), a5);
    if (v59 != 3)
    {
      if (v59 == 2)
      {
        *(_DWORD *)(a1 + 240) = 2;
        return 1;
      }
      if (v59 == 1)
      {
        *(void *)(a1 + 240) = 0x100000001;
        return 1;
      }
LABEL_95:
      if (*(_DWORD *)(a1 + 240)) {
        return 1;
      }
      unsigned int v67 = BOMCopierSourceEntryGetType(a2);
      BOOL IsSegmentedFile = BOMCopierSourceEntryIsSegmentedFile(a2);
      BOOL v69 = IsSegmentedFile;
      if (*(unsigned char *)(a1 + 297))
      {
LABEL_97:
        if (*(unsigned char *)(a3 + 153))
        {
          if (v67 == 8) {
            goto LABEL_99;
          }
          goto LABEL_132;
        }
LABEL_110:
        if (make_path(*(NSObject **)a1, *(char **)(a3 + 136), a5))
        {
          int v77 = *__error();
          uint64_t v78 = __error();
          strerror(*v78);
          BOMCopierErrorCapture(a5, v77, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3787, (uint64_t)"create_entry_filesystem", "Could not make_path %s: %s");
          return 1;
        }
        goto LABEL_132;
      }
      if (!*(unsigned char *)(a3 + 153)) {
        goto LABEL_110;
      }
      if (v67 <= 0xA)
      {
        if (((1 << v67) & 0x6B0) != 0)
        {
          if (unlink(*v21))
          {
            int v75 = *__error();
            int v76 = __error();
            strerror(*v76);
            BOMCopierErrorCapture(a5, v75, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3746, (uint64_t)"create_entry_filesystem", "Could not unlink %s: %s");
            return 1;
          }
          uint64_t v83 = *(NSObject **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            CFNumberRef v84 = *v21;
            *(_DWORD *)statfs buf = 136315138;
            *(void *)&uint8_t buf[4] = v84;
            _os_log_impl(&dword_2105F8000, v83, OS_LOG_TYPE_DEFAULT, "Unlinked %s", buf, 0xCu);
          }
          goto LABEL_97;
        }
        if (v67 == 8)
        {
          if (!IsSegmentedFile)
          {
            if (unlink(*v21))
            {
              int v86 = *__error();
              CFStringRef v87 = __error();
              strerror(*v87);
              BOMCopierErrorCapture(a5, v86, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3764, (uint64_t)"create_entry_filesystem", "Could not unlink %s: %s");
              return 1;
            }
            goto LABEL_97;
          }
LABEL_99:
          if (*(unsigned char *)(a1 + 301))
          {
            ssize_t v70 = getxattr(*v21, "com.apple.rootless", 0, 0, 0, 1);
            if (v70 == -1)
            {
              if (*__error() != 93)
              {
                CFNumberRef v85 = __error();
                strerror(*v85);
                uint64_t v65 = 1;
                BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3804, (uint64_t)"create_entry_filesystem", "Could not get size for rootless attribute %s: %s");
                return v65;
              }
            }
            else
            {
              size_t v71 = v70;
              if (v70 >= 1)
              {
                CFNumberRef v72 = malloc_type_malloc(v70, 0x4350292CuLL);
                if (!v72)
                {
                  int v114 = *__error();
                  BOMCopierErrorCapture(a5, v114, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3814, (uint64_t)"create_entry_filesystem", "Could not allocate attribute buffer: %s");
                  return 1;
                }
                CFNumberRef v73 = v72;
                ssize_t v74 = getxattr(*v21, "com.apple.rootless", v72, v71, 0, 1);
                if (v74 == -1)
                {
                  v116 = *v21;
                  uint32_t v117 = __error();
                  uint64_t v118 = strerror(*v117);
                  uint64_t v65 = 1;
                  BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3821, (uint64_t)"create_entry_filesystem", "Could not get rootless attribute for xattr %s: %s", v116, v118);
                  free(v73);
                  return v65;
                }
                *(void *)(a3 + 312) = v74;
                *(void *)(a3 + 320) = v73;
              }
            }
          }
        }
      }
LABEL_132:
      if (*(unsigned char *)(a1 + 298))
      {
        size_t v88 = strlen(*(const char **)(a1 + 288));
        CFNumberRef v89 = realpath_DARWIN_EXTSN(*(const char **)(a3 + 136), 0);
        if (!v89)
        {
          int v96 = *__error();
          uint64_t v97 = __error();
          strerror(*v97);
          BOMCopierErrorCapture(a5, v96, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3848, (uint64_t)"create_entry_filesystem", "Could not realpath parent %s: %s");
          return 1;
        }
        int v90 = v89;
        int v91 = strncmp(*(const char **)(a1 + 288), v89, v88);
        free(v90);
        if (v91)
        {
          uint64_t v65 = 1;
          BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3858, (uint64_t)"create_entry_filesystem", "%s resolves outside of %s");
          return v65;
        }
      }
      uint64_t v65 = 0;
      switch(v67)
      {
        case 6u:
          if (*(unsigned char *)(a3 + 153)) {
            return 0;
          }
          __int16 Mode = BOMCopierSourceEntryGetMode(a2);
          mode_t v93 = *(unsigned char *)(a1 + 296) ? 493 : Mode;
          if (!mkdir(*v21, v93)) {
            return 0;
          }
          int v94 = *__error();
          int v95 = __error();
          strerror(*v95);
          BOMCopierErrorCapture(a5, v94, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3882, (uint64_t)"create_entry_filesystem", "Could not create directory at %s: %s");
          return 1;
        case 8u:
          if (BOMCopierSourceEntryGetHardlinkCount(a2) < 2) {
            goto LABEL_176;
          }
          int Device = BOMCopierSourceEntryGetDevice(a2);
          uint64_t Inode = BOMCopierSourceEntryGetInode(a2);
          uint64_t v175 = 0;
          uint64_t Size = BOMCopierSourceEntryGetSize(a2);
          if (BOMHardLinkTableGetPathAndData(*(CFDictionaryRef **)(a1 + 72), Device, Inode, buf, &v175))
          {
            BOMHardLinkTableSetPathAndData(*(CFDictionaryRef **)(a1 + 72), Device, Inode, (char *)*v21, &Size, 8uLL);
          }
          else if (*v175 == Size)
          {
            if (*(unsigned char *)(a3 + 153) && unlink(*v21))
            {
              int v124 = *__error();
              int v125 = __error();
              strerror(*v125);
              BOMCopierErrorCapture(a5, v124, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3956, (uint64_t)"create_entry_filesystem", "Could not unlink %s: %s");
              return 1;
            }
            if (link(buf, *v21))
            {
              if (*__error() != 18)
              {
                int v126 = *__error();
                int v127 = *v21;
                int v128 = __error();
                strerror(*v128);
                BOMCopierErrorCapture(a5, v126, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3968, (uint64_t)"create_entry_filesystem", "Could not create hardlink %s to %s: %s", v127);
                return 1;
              }
            }
            else
            {
              *(_DWORD *)(a1 + 244) = 2;
              *(unsigned char *)(a3 + 154) = 1;
              *(unsigned char *)(a3 + 152) = 0;
              int v129 = *(NSObject **)a1;
              if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v130 = *v21;
                *(_DWORD *)int v177 = 136315394;
                *(void *)&v177[4] = v130;
                __int16 v178 = 2080;
                v179 = buf;
                _os_log_impl(&dword_2105F8000, v129, OS_LOG_TYPE_DEFAULT, "Hardlinked %s to %s", v177, 0x16u);
              }
            }
          }
LABEL_176:
          if (!*(unsigned char *)(a1 + 304)) {
            goto LABEL_181;
          }
          buf[0] = 0;
          if (BOMCopierSourceEntryClone(a2, *(char **)(a3 + 144), buf, a5))
          {
            int v131 = *__error();
            v132 = __error();
            strerror(*v132);
            BOMCopierErrorCapture(a5, v131, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4003, (uint64_t)"create_entry_filesystem", "Could not clone source entry to %s: %s");
            return 1;
          }
          if (buf[0]) {
            *(unsigned char *)(a3 + 154) = 1;
          }
LABEL_181:
          if (*(unsigned char *)(a3 + 154)) {
            return 0;
          }
          if (v69)
          {
            int v133 = open(*(const char **)(a3 + 144), 1, 420);
            if (v133 == -1)
            {
              int v139 = *__error();
              int v140 = __error();
              strerror(*v140);
              BOMCopierErrorCapture(a5, v139, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4087, (uint64_t)"create_entry_filesystem", "Could not open regular file at %s: %s");
              return 1;
            }
            int v134 = v133;
            if (lseek(v133, 0, 2) == -1)
            {
              int v153 = *__error();
              int v154 = __error();
              strerror(*v154);
              BOMCopierErrorCapture(a5, v153, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4096, (uint64_t)"create_entry_filesystem", "Could not seek to the end of %s: %s");
              return 1;
            }
            int v135 = *(NSObject **)a1;
            if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v136 = *(void *)(a3 + 144);
              *(_DWORD *)statfs buf = 136315138;
              *(void *)&uint8_t buf[4] = v136;
              _os_log_impl(&dword_2105F8000, v135, OS_LOG_TYPE_DEFAULT, "Opened segmented file at %s", buf, 0xCu);
            }
            goto LABEL_198;
          }
          int v137 = *(const char **)(a3 + 144);
          if (*(unsigned char *)(a1 + 12)) {
            int v138 = open_dprotected_np(v137, 1537, *(_DWORD *)(a1 + 16), 0, 420);
          }
          else {
            int v138 = open(v137, 513, 420);
          }
          int v134 = v138;
          if (v138 == -1)
          {
            int v149 = *__error();
            int v150 = __error();
            strerror(*v150);
            BOMCopierErrorCapture(a5, v149, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4042, (uint64_t)"create_entry_filesystem", "Could not create regular file at %s: %s");
            return 1;
          }
          int v141 = *(NSObject **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v142 = *(void *)(a3 + 144);
            *(_DWORD *)statfs buf = 136315138;
            *(void *)&uint8_t buf[4] = v142;
            _os_log_impl(&dword_2105F8000, v141, OS_LOG_TYPE_DEFAULT, "Created file at %s", buf, 0xCu);
          }
          if ((a4 & 2) == 0)
          {
LABEL_198:
            int v143 = v134;
            goto LABEL_199;
          }
          *(void *)int v177 = 0;
          asprintf((char **)v177, "%s%s", *(const char **)(a3 + 144), "/..namedfork/rsrc");
          if (!*(void *)v177)
          {
            int v166 = *__error();
            int v167 = __error();
            strerror(*v167);
            BOMCopierErrorCapture(a5, v166, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4060, (uint64_t)"create_entry_filesystem", "Could not create rsrc path for %s: %s");
            return 1;
          }
          int v151 = open(*(const char **)v177, 513, 420);
          if (v151 == -1)
          {
            int v168 = *__error();
            v169 = __error();
            strerror(*v169);
            BOMCopierErrorCapture(a5, v168, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4067, (uint64_t)"create_entry_filesystem", "Could not create resource fork at %s: %s");
            return 1;
          }
          int v143 = v151;
          int v152 = *(NSObject **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)statfs buf = 136315138;
            *(void *)&uint8_t buf[4] = *(void *)v177;
            _os_log_impl(&dword_2105F8000, v152, OS_LOG_TYPE_DEFAULT, "Open resource fork at %s", buf, 0xCu);
          }
          free(*(void **)v177);
LABEL_199:
          int v144 = *(unsigned __int8 *)(a1 + 41);
          if (*(unsigned char *)(a1 + 41) && fcntl(v134, 68, 1))
          {
            int v145 = *__error();
            int v146 = __error();
            strerror(*v146);
            BOMCopierErrorCapture(a5, v145, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4116, (uint64_t)"create_entry_filesystem", "Could not set F_SETSTATICCONTENT for %s: %s");
            return 1;
          }
          if (*(unsigned char *)(a1 + 42))
          {
            if (fcntl(v134, 76, 1))
            {
              int v147 = *__error();
              int v148 = __error();
              strerror(*v148);
              BOMCopierErrorCapture(a5, v147, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4128, (uint64_t)"create_entry_filesystem", "Could not set F_SINGLE_WRITER for %s: %s");
              return 1;
            }
            if (*(unsigned char *)(a1 + 40))
            {
LABEL_217:
              if (fcntl(v134, 48, 1))
              {
                int v155 = *__error();
                AAArchiveStream v156 = __error();
                strerror(*v156);
                BOMCopierErrorCapture(a5, v155, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4140, (uint64_t)"create_entry_filesystem", "Could not F_NOCACHE %s: %s\n");
                return 1;
              }
            }
          }
          else
          {
            if (*(unsigned char *)(a1 + 40)) {
              goto LABEL_217;
            }
            if (!v144)
            {
LABEL_230:
              *(_DWORD *)(a3 + 64) = v134;
              *(_DWORD *)(a3 + 68) = v143;
              if (BOMCopierSourceEntryGetSize(a2) <= 0x4000) {
                return 0;
              }
              uint64_t v65 = 0;
              BOOL v162 = (a4 & 1) == 0 && *(unsigned char *)(a1 + 112) == 0;
              if (v162 || !*(unsigned char *)(a1 + 300)) {
                return v65;
              }
              uint64_t v163 = ParallelCompressionAFSCStreamOpen();
              if (v163)
              {
                *(void *)(a3 + 160) = v163;
                os_log_t v164 = *(os_log_t *)a1;
                if (!*(void *)a1) {
                  return 0;
                }
                uint64_t v65 = 0;
                if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v165 = *(void *)(a3 + 144);
                  *(_DWORD *)statfs buf = 136315138;
                  *(void *)&uint8_t buf[4] = v165;
                  uint64_t v121 = "Enabled filesystem compression for %s";
                  int v122 = v164;
                  uint32_t v123 = 12;
                  goto LABEL_165;
                }
                return v65;
              }
              int v170 = *__error();
              char v171 = __error();
              strerror(*v171);
              BOMCopierErrorCapture(a5, v170, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4193, (uint64_t)"create_entry_filesystem", "Could not create ParallelCompression AFSC stream for %s: %s");
              return 1;
            }
          }
          int v157 = *(NSObject **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            int v158 = "F_SETSTATICCONTENT ";
            if (!*(unsigned char *)(a1 + 41)) {
              int v158 = "";
            }
            if (*(unsigned char *)(a1 + 42)) {
              int v159 = "F_SINGLE_WRITER ";
            }
            else {
              int v159 = "";
            }
            int v160 = *(unsigned __int8 *)(a1 + 40);
            *(_DWORD *)statfs buf = 136315650;
            *(void *)&uint8_t buf[4] = v158;
            __int16 v181 = 2080;
            v182 = v159;
            if (v160) {
              v161 = "F_NOCACHE ";
            }
            else {
              v161 = "";
            }
            __int16 v183 = 2080;
            v184 = v161;
            _os_log_impl(&dword_2105F8000, v157, OS_LOG_TYPE_DEFAULT, "Set %s%s%s", buf, 0x20u);
          }
          goto LABEL_230;
        case 9u:
          SymlinkTarget = (const char *)BOMCopierSourceEntryGetSymlinkTarget(a2);
          if (symlink(SymlinkTarget, *(const char **)(a3 + 144)))
          {
            int v112 = *__error();
            uint64_t v113 = __error();
            strerror(*v113);
            BOMCopierErrorCapture(a5, v112, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4211, (uint64_t)"create_entry_filesystem", "Could not create symlink at %s: %s");
            return 1;
          }
          os_log_t v119 = *(os_log_t *)a1;
          if (!*(void *)a1) {
            return 0;
          }
          uint64_t v65 = 0;
          if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v120 = *(void *)(a3 + 144);
            *(_DWORD *)statfs buf = 136315394;
            *(void *)&uint8_t buf[4] = v120;
            __int16 v181 = 2080;
            v182 = SymlinkTarget;
            uint64_t v121 = "Created symlink %s -> %s";
            int v122 = v119;
            uint32_t v123 = 22;
LABEL_165:
            _os_log_impl(&dword_2105F8000, v122, OS_LOG_TYPE_DEFAULT, v121, buf, v123);
            return 0;
          }
          return v65;
        case 0xDu:
        case 0xEu:
        case 0xFu:
        case 0x10u:
        case 0x11u:
        case 0x12u:
        case 0x13u:
          return v65;
        default:
          BOMCopierSourceEntryTypeString(v67);
          BOMCopierErrorCapture(a5, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4259, (uint64_t)"create_entry_filesystem", "Unsupported BOMCopierSourceEntryType: %s");
          return 1;
      }
    }
LABEL_81:
    char v39 = 1;
    if (v40) {
      goto LABEL_95;
    }
  }
  int v50 = *(_DWORD *)(a1 + 280);
  if (!v50)
  {
    uint64_t v58 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void *))(a1 + 224);
    if (!v58)
    {
      string_for_mode(v49);
      BOMCopierErrorCapture(a5, 20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8189, (uint64_t)"resolve_filesystem_conflict", "%s: conflict replacing %s with %s", *v21);
      goto LABEL_119;
    }
    goto LABEL_80;
  }
  if (v50 != 2)
  {
    if (v50 == 1)
    {
      if (unlink(*v21))
      {
        int v81 = *__error();
        BOOL v82 = __error();
        strerror(*v82);
        BOMCopierErrorCapture(a5, v81, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8199, (uint64_t)"resolve_filesystem_conflict", "Could not unlink %s: %s");
        goto LABEL_119;
      }
      *(unsigned char *)(a3 + 153) = 0;
      int v115 = *(NSObject **)a1;
      if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)statfs buf = 0;
        _os_log_impl(&dword_2105F8000, v115, OS_LOG_TYPE_DEFAULT, "Conflicting symlink unlinked", buf, 2u);
      }
    }
    goto LABEL_95;
  }
  if (stat(*v21, (stat *)(a3 + 168)))
  {
    int v98 = *__error();
    int v99 = __error();
    strerror(*v99);
    BOMCopierErrorCapture(a5, v98, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8213, (uint64_t)"resolve_filesystem_conflict", "Could not stat %s: %s");
    goto LABEL_119;
  }
  if ((*(_WORD *)(a3 + 172) & 0xF000) != 0x4000)
  {
    BOMCopierErrorCapture(a5, 20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8219, (uint64_t)"resolve_filesystem_conflict", "%s: Not a directory");
    goto LABEL_119;
  }
  if (!basename_r(*v21, buf))
  {
    int v100 = *__error();
    uint64_t v101 = __error();
    strerror(*v101);
    BOMCopierErrorCapture(a5, v100, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8231, (uint64_t)"resolve_filesystem_conflict", "Could not basename %s: %s");
    goto LABEL_119;
  }
  CFStringRef v51 = realpath_DARWIN_EXTSN(*v21, 0);
  if (!v51)
  {
    int v102 = *__error();
    uint64_t v103 = __error();
    strerror(*v103);
    BOMCopierErrorCapture(a5, v102, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8238, (uint64_t)"resolve_filesystem_conflict", "Could not resolve %s: %s");
    goto LABEL_119;
  }
  CFStringRef v52 = v51;
  free((void *)*v21);
  *uint64_t v21 = 0;
  asprintf((char **)(a3 + 120), "%s/%s", v52, buf);
  if (!*v21)
  {
    int v104 = *__error();
    int v105 = __error();
    CFTypeID v106 = strerror(*v105);
    BOMCopierErrorCapture(a5, v104, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8248, (uint64_t)"resolve_filesystem_conflict", "Could not reconstruct destination path: %s", v106);
    free(v52);
    goto LABEL_119;
  }
  CFIndex v53 = *(void **)(a3 + 136);
  if (v53) {
    free(v53);
  }
  *(void *)(a3 + 136) = v52;
  int v54 = *(void **)(a3 + 144);
  if (v54) {
    free(v54);
  }
  CFStringRef v55 = strdup(*(const char **)(a3 + 120));
  *(void *)(a3 + 144) = v55;
  if (v55)
  {
    CFStringRef v56 = *(NSObject **)a1;
    if (*(void *)a1)
    {
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
        || (*(_WORD *)int v177 = 0,
            _os_log_impl(&dword_2105F8000, v56, OS_LOG_TYPE_DEFAULT, "Conflicting symlink followed", v177, 2u),
            (CFStringRef v56 = *(NSObject **)a1) != 0))
      {
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex v57 = *v21;
          *(_DWORD *)int v177 = 136315138;
          *(void *)&v177[4] = v57;
          _os_log_impl(&dword_2105F8000, v56, OS_LOG_TYPE_DEFAULT, "destination_path: %s", v177, 0xCu);
        }
      }
    }
    goto LABEL_81;
  }
  int v107 = *__error();
  CFDataRef v108 = __error();
  strerror(*v108);
  BOMCopierErrorCapture(a5, v107, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 8268, (uint64_t)"resolve_filesystem_conflict", "Could not duplicate %s: %s");
LABEL_119:
  uint64_t v65 = 1;
  BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 3705, (uint64_t)"create_entry_filesystem", "Could not resolve filesystem conflict", v172, v173);
  return v65;
}

uint64_t create_entry_libarchive(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = archive_entry_new();
  if (v8)
  {
    uint64_t v9 = v8;
    uint64_t Path = (const char *)BOMCopierSourceEntryGetPath(a2);
    archive_entry_set_pathname();
    uint64_t v11 = strdup(Path);
    a3[15] = v11;
    if (!v11)
    {
      int v17 = __error();
      strerror(*v17);
      uint64_t v16 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4293, (uint64_t)"create_entry_libarchive", "Could not duplicate entry path %s: %s");
      return v16;
    }
    int Device = BOMCopierSourceEntryGetDevice(a2);
    uint64_t Inode = BOMCopierSourceEntryGetInode(a2);
    HardlinkCFIndex Count = BOMCopierSourceEntryGetHardlinkCount(a2);
    int Type = BOMCopierSourceEntryGetType(a2);
    if (Type == 8 && HardlinkCount >= 2)
    {
      int v15 = BOMHardLinkTableGet(*(CFDictionaryRef **)(a1 + 72), Device, Inode);
      if (v15)
      {
        *(void *)bytes = *(void *)v15;
      }
      else
      {
        long long v18 = *(CFDictionaryRef **)(a1 + 72);
        *(void *)bytes = *(void *)(a1 + 64);
        BOMHardLinkTableSet(v18, Device, Inode, bytes, 8);
        ++*(void *)(a1 + 64);
      }
    }
    else
    {
      *(void *)bytes = *(void *)(a1 + 64);
      *(void *)(a1 + 64) = *(void *)bytes + 1;
    }
    BOMCopierSourceEntryGetMode(a2);
    BOMCopierSourceEntryGetUserID(a2);
    BOMCopierSourceEntryGetGroupID(a2);
    long long v24 = 0uLL;
    if (BOMCopierSourceEntryGetAccessTime(a2, &v24))
    {
      uint64_t v16 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4362, (uint64_t)"create_entry_libarchive", "Could not get source entry access time");
    }
    else
    {
      long long v23 = 0uLL;
      if (BOMCopierSourceEntryGetModificationTime(a2, &v23))
      {
        uint64_t v16 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4372, (uint64_t)"create_entry_libarchive", "Could not get source entry modification time");
      }
      else
      {
        long long v22 = 0uLL;
        if (BOMCopierSourceEntryGetStatusTime(a2, &v22))
        {
          uint64_t v16 = 1;
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4382, (uint64_t)"create_entry_libarchive", "Could not get source entry status time");
        }
        else
        {
          archive_entry_set_dev();
          archive_entry_set_nlink();
          archive_entry_set_ino64();
          archive_entry_set_perm();
          archive_entry_set_mode();
          archive_entry_set_uid();
          archive_entry_set_gid();
          archive_entry_set_size();
          archive_entry_set_atime();
          archive_entry_set_mtime();
          archive_entry_set_ctime();
          switch(Type)
          {
            case 4:
            case 6:
            case 10:
              archive_entry_set_filetype();
              break;
            case 8:
              archive_entry_set_filetype();
              a3[9] = *(void *)(a1 + 136);
              uint64_t v19 = *(void *)(a1 + 152);
              if (v19 >= 1 && a3[7] >> 33)
              {
                a3[11] = v19;
                a3[12] = v19;
                archive_entry_set_size();
              }
              break;
            case 9:
              BOMCopierSourceEntryGetSymlinkTarget(a2);
              archive_entry_set_filetype();
              archive_entry_set_symlink();
              break;
            case 13:
            case 17:
            case 18:
            case 19:
              break;
            default:
              uint64_t v16 = 1;
              BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4473, (uint64_t)"create_entry_libarchive", "Unknown source entry type: %d");
              goto LABEL_27;
          }
          if (!archive_write_header())
          {
            uint64_t v16 = 0;
            a3[10] = v9;
            return v16;
          }
          archive_error_string();
          uint64_t v16 = 1;
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4483, (uint64_t)"create_entry_libarchive", "Could not write archive entry: %s (%d)");
        }
      }
    }
LABEL_27:
    archive_entry_free();
  }
  else
  {
    uint64_t v16 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4283, (uint64_t)"create_entry_libarchive", "Could not create empty archive entry");
  }
  return v16;
}

uint64_t create_entry_apple_archive(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  AAHeader v8 = AAHeaderCreate();
  if (!v8)
  {
    uint64_t v12 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4511, (uint64_t)"create_entry_apple_archive", "Could not create AppleArchive header");
    return v12;
  }
  uint64_t v9 = v8;
  int Type = BOMCopierSourceEntryGetType(a2);
  if ((Type - 4) > 7) {
    uint64_t v11 = 63;
  }
  else {
    uint64_t v11 = qword_210662D18[Type - 4];
  }
  v13.ikey = 5265748;
  int v14 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v13, v11);
  if (v14)
  {
    BOMCopierErrorCapture(a4, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4553, (uint64_t)"populate_aa_header", "Could not set AppleArchive type");
LABEL_11:
    uint64_t v12 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4518, (uint64_t)"create_entry_apple_archive", "Could not populate AppleArchive header");
    AAHeaderDestroy(v9);
    return v12;
  }
  uint64_t Path = (const char *)BOMCopierSourceEntryGetPath(a2);
  size_t v16 = strlen(Path);
  v17.ikey = 5521744;
  int v18 = AAHeaderSetFieldString(v9, 0xFFFFFFFF, v17, Path, v16);
  if (v18)
  {
    BOMCopierErrorCapture(a4, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4561, (uint64_t)"populate_aa_header", "Could not set AppleArchive path");
    goto LABEL_11;
  }
  long long v20 = strdup(Path);
  *(void *)(a3 + 120) = v20;
  if (!v20)
  {
    int v26 = __error();
    strerror(*v26);
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4568, (uint64_t)"populate_aa_header", "Could not duplicate entry path %s: %s");
    goto LABEL_11;
  }
  if (Type == 9)
  {
    SymlinkTarget = (const char *)BOMCopierSourceEntryGetSymlinkTarget(a2);
    if (!SymlinkTarget)
    {
      BOMCopierErrorCapture(a4, 0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4577, (uint64_t)"populate_aa_header", "Could not set AppleArchive size");
      goto LABEL_11;
    }
    long long v22 = SymlinkTarget;
    size_t v23 = strlen(SymlinkTarget);
    v24.ikey = 4935244;
    int v25 = AAHeaderSetFieldString(v9, 0xFFFFFFFF, v24, v22, v23);
    if (v25)
    {
      BOMCopierErrorCapture(a4, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4587, (uint64_t)"populate_aa_header", "Could not set AppleArchive symlink path");
      goto LABEL_11;
    }
  }
  else if ((Type & 0xFFFFFFFD) == 5)
  {
    int Device = BOMCopierSourceEntryGetDevice(a2);
    v28.ikey = 5653828;
    AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v28, Device);
  }
  unsigned int UserID = BOMCopierSourceEntryGetUserID(a2);
  v30.ikey = 4475221;
  int v31 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v30, UserID);
  if (v31)
  {
    BOMCopierErrorCapture(a4, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4608, (uint64_t)"populate_aa_header", "Could not set AppleArchive uid");
    goto LABEL_11;
  }
  unsigned int GroupID = BOMCopierSourceEntryGetGroupID(a2);
  v33.ikey = 4475207;
  int v34 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v33, GroupID);
  if (v34)
  {
    BOMCopierErrorCapture(a4, v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4616, (uint64_t)"populate_aa_header", "Could not set AppleArchive gid");
    goto LABEL_11;
  }
  __int16 Mode = BOMCopierSourceEntryGetMode(a2);
  v36.ikey = 4476749;
  int v37 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v36, Mode & 0xFFF);
  if (v37)
  {
    BOMCopierErrorCapture(a4, v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4624, (uint64_t)"populate_aa_header", "Could not set AppleArchive mode");
    goto LABEL_11;
  }
  unsigned int v38 = BOMCopierSourceEntryGetMode(a2);
  v39.ikey = 4672582;
  int v40 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v39, v38);
  if (v40)
  {
    BOMCopierErrorCapture(a4, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4632, (uint64_t)"populate_aa_header", "Could not set AppleArchive mode");
    goto LABEL_11;
  }
  value.tv_sec = 0;
  value.tv_nsec = 0;
  int ModificationTime = BOMCopierSourceEntryGetModificationTime(a2, &value);
  if (ModificationTime)
  {
    BOMCopierErrorCapture(a4, ModificationTime, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4640, (uint64_t)"populate_aa_header", "Could not retrieve modification time");
    goto LABEL_11;
  }
  v42.ikey = 5067853;
  int v43 = AAHeaderSetFieldTimespec(v9, 0xFFFFFFFF, v42, &value);
  if (v43)
  {
    BOMCopierErrorCapture(a4, v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4647, (uint64_t)"populate_aa_header", "Could not set AppleArchive modification time");
    goto LABEL_11;
  }
  uint64_t Inode = BOMCopierSourceEntryGetInode(a2);
  v45.ikey = 5197385;
  AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v45, Inode);
  HardlinkCFIndex Count = BOMCopierSourceEntryGetHardlinkCount(a2);
  v47.ikey = 4934734;
  AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v47, HardlinkCount);
  if (Type == 8)
  {
    int64_t v48 = *(void *)(a3 + 56);
    v49.ikey = 5917011;
    int v50 = AAHeaderSetFieldUInt(v9, 0xFFFFFFFF, v49, v48);
    if (v50)
    {
      BOMCopierErrorCapture(a4, v50, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4689, (uint64_t)"populate_aa_header", "Could not set AppleArchive size");
      goto LABEL_11;
    }
    if (v48 >= 1)
    {
      v51.ikey = 5521732;
      int v52 = AAHeaderSetFieldBlob(v9, 0xFFFFFFFF, v51, v48);
      if (v52)
      {
        BOMCopierErrorCapture(a4, v52, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4698, (uint64_t)"populate_aa_header", "Could not append AA_FIELD_DAT to AppleArchive header: %d");
        goto LABEL_11;
      }
    }
  }
  uint64_t v55 = 0;
  if (BOMCopierSourceEntryGetACL(a2, &v55, a4))
  {
    int v53 = populate_aa_header_acl(a2, a3, v9, a4);
    if (v53)
    {
      BOMCopierErrorCapture(a4, v53, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4711, (uint64_t)"populate_aa_header", "Could not encode ACL");
      goto LABEL_11;
    }
  }
  if (BOMCopierSourceEntryGetExtendedAttributeCount(a2, a4))
  {
    int v54 = populate_aa_header_xattr(a2, a3, v9, a4);
    if (v54)
    {
      BOMCopierErrorCapture(a4, v54, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4722, (uint64_t)"populate_aa_header", "Could not encode extended attributes");
      goto LABEL_11;
    }
  }
  uint64_t v12 = AAArchiveStreamWriteHeader(*(AAArchiveStream *)(a1 + 184), v9);
  AAHeaderDestroy(v9);
  if (v12)
  {
    uint64_t v12 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4529, (uint64_t)"create_entry_apple_archive", "Could not write AppleArchive header");
  }
  else
  {
    *(_DWORD *)(a3 + 328) = 5521732;
    *(void *)(a3 + 336) = *(void *)(a1 + 184);
  }
  return v12;
}

uint64_t BOMCopierDestinationFinalizeEntry(void *a1, void *a2, void *a3)
{
  if (!a1)
  {
    uint64_t v11 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1786, (uint64_t)"BOMCopierDestinationFinalizeEntry", "copier_destination is NULL");
    return v11;
  }
  if (!a2)
  {
    uint64_t v11 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1792, (uint64_t)"BOMCopierDestinationFinalizeEntry", "destination_entry is NULL");
    return v11;
  }
  uint64_t v5 = (uint64_t)a1;
  if (!*((unsigned char *)a2 + 16))
  {
    uint64_t v13 = a1[12];
    uint64_t v14 = a2[3];
    int Type = BOMCopierSourceEntryGetType(a2[1]);
    if (Type == 8 && v14 != 0 && v13 != 0)
    {
      if (BOMCopierDataAnalyzerFinalize((uint64_t *)a2[3], a3))
      {
        uint64_t v11 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1842, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not finalize data analyzer");
        return v11;
      }
      int v25 = 0;
      if (BOMCopierDataAnalyzerGetDigest(a2[3], 2, (uint64_t)&v25, a3))
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1851, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not retrieve CRC32 from data analyzer");
        return 1;
      }
      BOMCopierDataAnalyzerReset((uint64_t *)a2[3]);
      uint64_t Path = (char *)BOMCopierSourceEntryGetPath(a2[1]);
      uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(*(void *)(v5 + 96), Path);
      if (!FSObjectAtPath)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1866, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not lookup %s in checksum bom");
        return 1;
      }
      uint64_t v23 = FSObjectAtPath;
      int v24 = BOMFSObjectChecksum(FSObjectAtPath);
      BOMFSObjectFree(v23);
      if (v24 != v25)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1876, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Checksum mismatch for %s: %d vs %d", Path);
        return 1;
      }
    }
    if (*((_DWORD *)a2 + 8) != 2)
    {
      int v18 = *(_DWORD *)(v5 + 44);
      if (v18 == 2)
      {
        if (finalize_entry_apple_archive((uint64_t)a2, a3))
        {
          uint64_t v11 = 1;
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1908, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not finalize AppleArchive entry");
          return v11;
        }
      }
      else if (!v18)
      {
        finalize_entry_filesystem(v5, (uint64_t)a2, a3);
        if (v19)
        {
          uint64_t v11 = 1;
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1898, (uint64_t)"BOMCopierDestinationFinalizeEntry", "Could not finalize filesystem entry");
          return v11;
        }
      }
    }
    if (Type == 17) {
      goto LABEL_7;
    }
    uint64_t v6 = *(void (**)(void *, uint64_t, void *, uint64_t, uint64_t))(v5 + 264);
    if (!v6) {
      goto LABEL_7;
    }
    uint64_t v10 = *(unsigned int *)(v5 + 244);
    uint64_t v7 = a2[1];
    uint64_t v8 = *(void *)(v5 + 272);
    a1 = (void *)v5;
    uint64_t v9 = a2;
    goto LABEL_6;
  }
  uint64_t v6 = (void (*)(void *, uint64_t, void *, uint64_t, uint64_t))a1[33];
  if (v6)
  {
    uint64_t v7 = a2[1];
    uint64_t v8 = a1[34];
    uint64_t v9 = a2;
    uint64_t v10 = 1;
LABEL_6:
    v6(a1, v7, v9, v10, v8);
  }
LABEL_7:
  BOMCopierDestinationEntryFree(a2);
  return 0;
}

void finalize_entry_filesystem(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v199 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a2 + 154))
  {
    apply_retention_policy(a1, a2, a3);
    return;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  unsigned int Type = BOMCopierSourceEntryGetType(v6);
  switch(Type)
  {
    case 8u:
      int v8 = *(_DWORD *)(a2 + 64);
      if (v8 == -1) {
        goto LABEL_53;
      }
      if (!*(void *)(a2 + 160)) {
        goto LABEL_50;
      }
      if (!ParallelCompressionAFSCStreamClose())
      {
        *(void *)(a2 + 160) = 0;
        int v8 = *(_DWORD *)(a2 + 64);
LABEL_50:
        if (*(_DWORD *)(a2 + 68) != v8)
        {
          close(*(_DWORD *)(a2 + 68));
          int v8 = *(_DWORD *)(a2 + 64);
        }
        *(_DWORD *)(a2 + 68) = -1;
        close(v8);
        *(_DWORD *)(a2 + 64) = -1;
        goto LABEL_53;
      }
      int v9 = *__error();
      uint64_t v10 = __error();
      strerror(*v10);
      BOMCopierErrorCapture(a3, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5164, (uint64_t)"finalize_entry_filesystem", "Could not close AFSC stream for %s: %s");
      return;
    case 0x10u:
      memset(&v192, 0, sizeof(v192));
      if (lstat(*(const char **)(a2 + 120), &v192))
      {
        int v14 = *__error();
        BOMCopierErrorCapture(a3, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5192, (uint64_t)"finalize_entry_filesystem", "Missing symlink target for %s");
        return;
      }
      if ((v192.st_mode & 0xF000) != 0x8000)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5198, (uint64_t)"finalize_entry_filesystem", "%s is not a regular file");
        return;
      }
      if (v192.st_size >= 1025)
      {
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5204, (uint64_t)"finalize_entry_filesystem", "%s is too large (%luu) to hold a symlink target");
        return;
      }
      ssize_t v74 = malloc_type_calloc(1uLL, v192.st_size + 1, 0x9542858DuLL);
      if (!v74)
      {
        int v130 = *__error();
        int v131 = __error();
        strerror(*v131);
        BOMCopierErrorCapture(a3, v130, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5213, (uint64_t)"finalize_entry_filesystem", "Could not allocate target buffer %lu: %s");
        return;
      }
      CFStringRef v56 = v74;
      unsigned int v75 = Type;
      int v76 = open(*(const char **)(a2 + 120), 0);
      if (v76 == -1)
      {
        int v134 = *__error();
        int v135 = __error();
        strerror(*v135);
        BOMCopierErrorCapture(a3, v134, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5220, (uint64_t)"finalize_entry_filesystem", "Could not open %s: %s");
        goto LABEL_70;
      }
      int v77 = v76;
      ssize_t v78 = read(v76, v56, v192.st_size);
      if (v78 != v192.st_size)
      {
        int v136 = *__error();
        int v137 = *(const char **)(a2 + 120);
        off_t st_size = v192.st_size;
        int v139 = __error();
        int v140 = strerror(*v139);
        BOMCopierErrorCapture(a3, v136, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5228, (uint64_t)"finalize_entry_filesystem", "Could not read %s %lu: %s", v137, st_size, v140);
        close(v77);
        goto LABEL_70;
      }
      close(v77);
      if (unlink(*(const char **)(a2 + 120)))
      {
        int v79 = *__error();
        uint64_t v80 = __error();
        strerror(*v80);
        BOMCopierErrorCapture(a3, v79, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5239, (uint64_t)"finalize_entry_filesystem", "Could not unlink %s: %s");
        goto LABEL_70;
      }
      if (symlink((const char *)v56, *(const char **)(a2 + 120)))
      {
        int v153 = *__error();
        uint64_t v154 = *(void *)(a2 + 120);
        int v155 = __error();
        strerror(*v155);
        BOMCopierErrorCapture(a3, v153, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5247, (uint64_t)"finalize_entry_filesystem", "Could not symlink %s to %s: %s", v154);
        goto LABEL_70;
      }
      uint64_t v172 = *(NSObject **)a1;
      if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v173 = *(void *)(a2 + 120);
        *(_DWORD *)__bp = 136315394;
        *(void *)&__bp[4] = v173;
        *(_WORD *)&__bp[12] = 2080;
        *(void *)&__bp[14] = v56;
        _os_log_impl(&dword_2105F8000, v172, OS_LOG_TYPE_DEFAULT, "Transmogrified symlink: %s to %s", (uint8_t *)__bp, 0x16u);
      }
      free(v56);
      unsigned int Type = v75;
      goto LABEL_53;
    case 0x11u:
      AppleDoubleTarget = (const char *)BOMCopierSourceEntryGetAppleDoubleTarget(v6);
      to = 0;
      asprintf(&to, "%s/%s", *(const char **)(a2 + 136), AppleDoubleTarget);
      if (!to)
      {
        int v26 = *__error();
        uint64_t v27 = *(void *)(a2 + 136);
        AAFieldKey v28 = __error();
        strerror(*v28);
        BOMCopierErrorCapture(a3, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5298, (uint64_t)"finalize_entry_filesystem", "Could not construct target path for %s and %s: %s", v27);
        return;
      }
      memset(&v192, 0, sizeof(v192));
      if (lstat(to, &v192))
      {
        int v12 = *__error();
        uint64_t v13 = __error();
        strerror(*v13);
        BOMCopierErrorCapture(a3, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5306, (uint64_t)"finalize_entry_filesystem", "Could not lstat %s: %s");
        return;
      }
      if (*(unsigned char *)(a1 + 160)) {
        copyfile_flags_t v35 = 9175045;
      }
      else {
        copyfile_flags_t v35 = 9175044;
      }
      if (copyfile(*(const char **)(a2 + 120), to, 0, v35) < 0)
      {
        if (*__error() != 45)
        {
          int v125 = *__error();
          uint64_t v126 = *(void *)(a2 + 120);
          int v127 = __error();
          strerror(*v127);
          BOMCopierErrorCapture(a3, v125, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5387, (uint64_t)"finalize_entry_filesystem", "Could not merge %s to %s: %s", v126);
          goto LABEL_181;
        }
        free(to);
        int v81 = *(NSObject **)a1;
        if (v81 && os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v82 = *(void *)(a2 + 120);
          *(_DWORD *)__bp = 136315138;
          *(void *)&__bp[4] = v82;
          _os_log_impl(&dword_2105F8000, v81, OS_LOG_TYPE_DEFAULT, "AppleDouble merge not supported on this filesystem. Unlinking %s", (uint8_t *)__bp, 0xCu);
        }
        if (unlink(*(const char **)(a2 + 120)))
        {
          int v83 = *__error();
          CFNumberRef v84 = __error();
          strerror(*v84);
          BOMCopierErrorCapture(a3, v83, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5380, (uint64_t)"finalize_entry_filesystem", "Could not unlink %s: %s");
        }
      }
      else
      {
        AAFieldKey v36 = *(NSObject **)a1;
        if (v36 && os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v37 = *(void *)(a2 + 120);
          *(_DWORD *)__bp = 136315394;
          *(void *)&__bp[4] = v37;
          *(_WORD *)&__bp[12] = 2080;
          *(void *)&__bp[14] = to;
          _os_log_impl(&dword_2105F8000, v36, OS_LOG_TYPE_DEFAULT, "Merged AppleDouble %s to %s", (uint8_t *)__bp, 0x16u);
        }
        if (unlink(*(const char **)(a2 + 120)))
        {
          int v38 = *__error();
          AAFieldKey v39 = __error();
          strerror(*v39);
          BOMCopierErrorCapture(a3, v38, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5398, (uint64_t)"finalize_entry_filesystem", "Could not unlink %s: %s");
LABEL_181:
          int v59 = to;
          goto LABEL_182;
        }
        acl_t file = acl_get_file(to, ACL_TYPE_EXTENDED);
        if (file)
        {
          CFStringRef v87 = file;
          size_t v88 = acl_init(0);
          if (!v88)
          {
            int v145 = *__error();
            int v146 = __error();
            strerror(*v146);
            BOMCopierErrorCapture(a3, v145, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5427, (uint64_t)"finalize_entry_filesystem", "Could not create empty ACL for %s: %s");
            goto LABEL_181;
          }
          CFNumberRef v89 = v88;
          int v90 = acl_set_file(to, ACL_TYPE_EXTENDED, v88);
          free(v89);
          if (v90)
          {
            int v91 = *__error();
            uint64_t v92 = __error();
            strerror(*v92);
            BOMCopierErrorCapture(a3, v91, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5438, (uint64_t)"finalize_entry_filesystem", "Could not remove saved ACL from %s: %s");
            goto LABEL_181;
          }
          int v147 = acl_set_file(to, ACL_TYPE_EXTENDED, v87);
          acl_free(v87);
          if (v147)
          {
            int v148 = *__error();
            int v149 = __error();
            strerror(*v149);
            BOMCopierErrorCapture(a3, v148, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5478, (uint64_t)"finalize_entry_filesystem", "Could not re-apply saved ACL to %s: %s");
            goto LABEL_181;
          }
        }
        *(void *)&uint8_t buf[16] = 0;
        *(_OWORD *)statfs buf = xmmword_210662CD0;
        *(timespec *)__bp = v192.st_mtimespec;
        *(timespec *)&__bp[16] = v192.st_atimespec;
        if (setattrlist(to, buf, __bp, 0x20uLL, 1u) && *__error() != 13)
        {
          int v150 = *__error();
          int v151 = __error();
          strerror(*v151);
          BOMCopierErrorCapture(a3, v150, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5514, (uint64_t)"finalize_entry_filesystem", "Could not setattrlist timestamps for %s: %s");
        }
        else
        {
          free(to);
        }
      }
      return;
    case 0x12u:
      uint64_t SymlinkTarget = BOMCopierSourceEntryGetSymlinkTarget(*(void *)(a2 + 8));
      if (!SymlinkTarget)
      {
        int v29 = *__error();
        BOMCopierErrorCapture(a3, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5266, (uint64_t)"finalize_entry_filesystem", "Missing symlink target for %s");
        return;
      }
      size_t v16 = (const char *)SymlinkTarget;
      if (unlink(*(const char **)(a2 + 120)))
      {
        int v17 = *__error();
        int v18 = __error();
        strerror(*v18);
        BOMCopierErrorCapture(a3, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5273, (uint64_t)"finalize_entry_filesystem", "Could not unlink placeholder at %s: %s");
        return;
      }
      if (symlink(v16, *(const char **)(a2 + 120)))
      {
        int v40 = *__error();
        uint64_t v41 = *(void *)(a2 + 120);
        AAFieldKey v42 = __error();
        strerror(*v42);
        BOMCopierErrorCapture(a3, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5280, (uint64_t)"finalize_entry_filesystem", "Could not symlink %s to %s: %s", v41);
        return;
      }
LABEL_53:
      unsigned int v174 = Type;
      ExtendedAttributeCFIndex Count = BOMCopierSourceEntryGetExtendedAttributeCount(v6, a3);
      if (!ExtendedAttributeCount) {
        goto LABEL_67;
      }
      int v44 = ExtendedAttributeCount;
      for (unsigned int i = 0; i != v44; ++i)
      {
        ExtendedAttributeName = (const char *)BOMCopierSourceEntryGetExtendedAttributeName(v6, i, a3);
        if (!ExtendedAttributeName)
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5654, (uint64_t)"finalize_entry_filesystem", "Could not get xattr name for index %d");
          return;
        }
        AAFieldKey v47 = ExtendedAttributeName;
        if (strcmp(ExtendedAttributeName, "com.apple.ResourceFork") || !*(unsigned char *)(a2 + 155))
        {
          ExtendedAttributeuint64_t Size = BOMCopierSourceEntryGetExtendedAttributeSize(v6, i, a3);
          if (!ExtendedAttributeSize)
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5681, (uint64_t)"finalize_entry_filesystem", "Could not get xattr size for index %d: %s");
            return;
          }
          size_t v49 = ExtendedAttributeSize;
          int v50 = malloc_type_malloc(ExtendedAttributeSize, 0x314A8908uLL);
          if (!v50)
          {
            BOOL v69 = __error();
            strerror(*v69);
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5688, (uint64_t)"finalize_entry_filesystem", "Could not allocate buffer for value: %s\n");
            return;
          }
          AAFieldKey v51 = v50;
          if (BOMCopierSourceEntryCopyExtendedAttribute(v6, i, v50, v49, 0, a3) != v49)
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5695, (uint64_t)"finalize_entry_filesystem", "Could not copy attribute value for index %d: %s\n");
            return;
          }
          if (setxattr(*(const char **)(a2 + 144), v47, v51, v49, 0, 1))
          {
            int v70 = *__error();
            size_t v71 = __error();
            strerror(*v71);
            BOMCopierErrorCapture(a3, v70, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5702, (uint64_t)"finalize_entry_filesystem", "Could not set xattr %s on %s: %s", v47);
            return;
          }
          int v52 = *(NSObject **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            __darwin_ino64_t v53 = *(void *)(a2 + 120);
            v192.st_dev = 136315394;
            *(void *)&v192.st_mode = v47;
            WORD2(v192.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v192.st_ino + 6) = v53;
            _os_log_impl(&dword_2105F8000, v52, OS_LOG_TYPE_DEFAULT, "Applied xattr %s to %s", (uint8_t *)&v192, 0x16u);
          }
          free(v51);
        }
      }
LABEL_67:
      size_t v54 = *(void *)(a2 + 312);
      unsigned int v55 = v174;
      if (!v54) {
        goto LABEL_75;
      }
      CFStringRef v56 = *(void **)(a2 + 320);
      if (!setxattr(*(const char **)(a2 + 144), "com.apple.rootless", v56, v54, 0, 1))
      {
        int v60 = *(NSObject **)a1;
        if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v61 = *(void *)(a2 + 120);
          v192.st_dev = 136315138;
          *(void *)&v192.st_mode = v61;
          _os_log_impl(&dword_2105F8000, v60, OS_LOG_TYPE_DEFAULT, "Applied xattr com.apple.rootless to %s", (uint8_t *)&v192, 0xCu);
        }
LABEL_75:
        to = 0;
        ACL = (const char *)BOMCopierSourceEntryGetACL(v6, &to, a3);
        if (ACL && to)
        {
          acl_t v63 = acl_from_text(ACL);
          if (!v63)
          {
            int v72 = *__error();
            CFNumberRef v73 = __error();
            strerror(*v73);
            BOMCopierErrorCapture(a3, v72, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5755, (uint64_t)"finalize_entry_filesystem", "Could not create ACL from text [%s]: %s");
            return;
          }
          CFStringRef v64 = v63;
          uint64_t v65 = *(const char **)(a2 + 144);
          if (v174 == 9)
          {
            int v66 = open(v65, 0x200000);
            if (v66 == -1)
            {
              int v132 = *__error();
              int v133 = __error();
              strerror(*v133);
              BOMCopierErrorCapture(a3, v132, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5768, (uint64_t)"finalize_entry_filesystem", "Unable to open the symlink %s: %s\n");
              return;
            }
            int v67 = v66;
            int v68 = acl_set_fd_np(v66, v64, ACL_TYPE_EXTENDED);
            close(v67);
            unsigned int v55 = v174;
          }
          else
          {
            int v68 = acl_set_file(v65, ACL_TYPE_EXTENDED, v64);
          }
          acl_free(v64);
          if (v68)
          {
            CFNumberRef v85 = __error();
            strerror(*v85);
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5783, (uint64_t)"finalize_entry_filesystem", "Could not set ACL on %s: %s");
            return;
          }
          mode_t v93 = *(NSObject **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v94 = *(void *)(a2 + 144);
            v192.st_dev = 136315138;
            *(void *)&v192.st_mode = v94;
            _os_log_impl(&dword_2105F8000, v93, OS_LOG_TYPE_DEFAULT, "Applied ACL to %s", (uint8_t *)&v192, 0xCu);
          }
        }
        if (v55 == 8)
        {
          int v95 = *(const void **)(a1 + 24);
          if (v95)
          {
            if (setxattr(*(const char **)(a2 + 144), "com.apple.provenance", v95, *(void *)(a1 + 32), 0, 1))
            {
              int v96 = *__error();
              uint64_t v97 = __error();
              strerror(*v97);
              BOMCopierErrorCapture(a3, v96, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5808, (uint64_t)"finalize_entry_filesystem", "Could not set provenance xattr %s: %s");
              return;
            }
            int v128 = *(NSObject **)a1;
            if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v129 = *(void *)(a2 + 120);
              v192.st_dev = 136315138;
              *(void *)&v192.st_mode = v129;
              _os_log_impl(&dword_2105F8000, v128, OS_LOG_TYPE_DEFAULT, "Applied xattr com.apple.provenance to %s", (uint8_t *)&v192, 0xCu);
            }
          }
        }
        else if (v55 != 6)
        {
          goto LABEL_143;
        }
        unsigned int Flags = BOMCopierSourceEntryGetFlags(v6);
        if ((Flags & 0x80000) != 0 && *(unsigned char *)(a1 + 302) == 0) {
          unsigned int v100 = Flags & 0xFFF7FFFF;
        }
        else {
          unsigned int v100 = Flags;
        }
        if (*(unsigned char *)(a2 + 153) && *(unsigned char *)(a1 + 303)) {
          v100 |= *(_DWORD *)(a2 + 284) & 0x80000;
        }
        memset(&v192, 0, sizeof(v192));
        if (lstat(*(const char **)(a2 + 144), &v192))
        {
          int v101 = *__error();
          int v102 = __error();
          strerror(*v102);
          BOMCopierErrorCapture(a3, v101, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5863, (uint64_t)"finalize_entry_filesystem", "Could not lstat %s: %s\n");
          return;
        }
        if (BOMCopierSourceEntryIsCompressed(v6) && !*(unsigned char *)(a1 + 113)) {
          v100 &= ~0x20u;
        }
        if (*(unsigned char *)(a1 + 112) && (v192.st_flags & 0x40000020) == 0x20) {
          v100 |= 0x20u;
        }
        uid_t v103 = geteuid();
        unsigned int v104 = v100 & 0xC000FFFF;
        if (!v103) {
          unsigned int v104 = v100;
        }
        if ((~v104 & 0x40000020) != 0) {
          __uint32_t v105 = v104;
        }
        else {
          __uint32_t v105 = v104 & 0xBFFFFFDF;
        }
        if (v105)
        {
          if (change_flags(*(const char **)(a2 + 144), v192.st_flags, v105) && *__error() != 45)
          {
            int v141 = *__error();
            uint64_t v142 = *(void *)(a2 + 144);
            uint64_t st_flags = v192.st_flags;
            int v144 = __error();
            strerror(*v144);
            BOMCopierErrorCapture(a3, v141, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5926, (uint64_t)"finalize_entry_filesystem", "Could not change file flags on %s from %u to %u: %s. Calling error handler", v142, st_flags);
            return;
          }
          CFTypeID v106 = *(NSObject **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v107 = *(void *)(a2 + 120);
            *(_DWORD *)__bp = 136315650;
            *(void *)&__bp[4] = v107;
            *(_WORD *)&__bp[12] = 1024;
            *(_DWORD *)&__bp[14] = v192.st_flags;
            *(_WORD *)&__bp[18] = 1024;
            *(_DWORD *)&__bp[20] = v105;
            _os_log_impl(&dword_2105F8000, v106, OS_LOG_TYPE_DEFAULT, "Changed file flags on %s from %u to %u", (uint8_t *)__bp, 0x18u);
          }
        }
LABEL_143:
        apply_retention_policy(a1, a2, a3);
        if (v108)
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5944, (uint64_t)"finalize_entry_filesystem", "Could not apply retention policy");
          return;
        }
        int v109 = *(_DWORD *)(a1 + 8);
        uint64_t UserID = BOMCopierSourceEntryGetUserID(v6);
        gid_t GroupID = BOMCopierSourceEntryGetGroupID(v6);
        int Mode = BOMCopierSourceEntryGetMode(v6);
        if (*(_DWORD *)(a1 + 8) || *(unsigned char *)(a1 + 305))
        {
          BOOL v114 = v174 == 8 && *(unsigned char *)(a1 + 306) != 0;
        }
        else
        {
          if (*(unsigned char *)(a1 + 20)) {
            int v152 = BOMCopierSourceEntryGetHonorsSetuid(v6) ^ 1;
          }
          else {
            int v152 = 0;
          }
          BOOL v114 = v174 == 8 && *(unsigned char *)(a1 + 306) != 0;
          if ((v152 & 1) == 0 && !v114)
          {
LABEL_162:
            os_log_t v119 = "symlink";
            uint64_t v120 = "post-order directory";
            switch(v174)
            {
              case 6u:
                uint64_t v120 = "directory";
                goto LABEL_194;
              case 8u:
              case 0xFu:
                if (v174 == 15) {
                  uint64_t v121 = "extra regular file";
                }
                else {
                  uint64_t v121 = "regular file";
                }
                if (v109 || !chown(*(const char **)(a2 + 120), UserID, GroupID))
                {
                  if (!chmod(*(const char **)(a2 + 120), Mode)) {
                    goto LABEL_205;
                  }
                  long long v197 = 0u;
                  memset(v198, 0, sizeof(v198));
                  long long v195 = 0u;
                  long long v196 = 0u;
                  long long v193 = 0u;
                  long long v194 = 0u;
                  memset(&v192, 0, sizeof(v192));
                  strmode((unsigned __int16)Mode, (char *)&v192);
                  int v122 = *__error();
                  uint64_t v123 = *(void *)(a2 + 120);
                  int v124 = __error();
                  strerror(*v124);
                  BOMCopierErrorCapture(a3, v122, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6132, (uint64_t)"finalize_entry_filesystem", "Could not chmod %s %s to %s: %s", v121, v123);
                }
                else
                {
                  int v168 = *__error();
                  uint64_t v169 = *(void *)(a2 + 120);
                  int v170 = __error();
                  strerror(*v170);
                  BOMCopierErrorCapture(a3, v168, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6120, (uint64_t)"finalize_entry_filesystem", "Could not chown %s to %d:%d: %s", v169, UserID);
                }
                return;
              case 9u:
              case 0x10u:
                goto LABEL_202;
              case 0xDu:
                goto LABEL_194;
              case 0xEu:
                uint64_t v120 = "extra directory";
LABEL_194:
                if (!v109 && chown(*(const char **)(a2 + 120), UserID, GroupID))
                {
                  int v159 = *__error();
                  uint64_t v160 = *(void *)(a2 + 120);
                  v161 = __error();
                  strerror(*v161);
                  BOMCopierErrorCapture(a3, v159, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6068, (uint64_t)"finalize_entry_filesystem", "Could not chown %s to %d:%d: %s", v160, UserID);
                  return;
                }
                if ((!*(unsigned char *)(a2 + 153) || *(unsigned char *)(a1 + 43)) && chmod(*(const char **)(a2 + 120), Mode))
                {
                  long long v197 = 0u;
                  memset(v198, 0, sizeof(v198));
                  long long v195 = 0u;
                  long long v196 = 0u;
                  long long v193 = 0u;
                  long long v194 = 0u;
                  memset(&v192, 0, sizeof(v192));
                  strmode((unsigned __int16)Mode, (char *)&v192);
                  int v156 = *__error();
                  uint64_t v157 = *(void *)(a2 + 120);
                  int v158 = __error();
                  strerror(*v158);
                  BOMCopierErrorCapture(a3, v156, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6098, (uint64_t)"finalize_entry_filesystem", "Could not chmod %s %s to %s: %s", v120, v157);
                  return;
                }
                goto LABEL_205;
              case 0x12u:
                os_log_t v119 = "replay symlink";
LABEL_202:
                if (v109 || !lchown(*(const char **)(a2 + 120), UserID, GroupID))
                {
                  if (lchmod(*(const char **)(a2 + 120), Mode))
                  {
                    long long v197 = 0u;
                    memset(v198, 0, sizeof(v198));
                    long long v195 = 0u;
                    long long v196 = 0u;
                    long long v193 = 0u;
                    long long v194 = 0u;
                    memset(&v192, 0, sizeof(v192));
                    strmode((unsigned __int16)Mode, (char *)&v192);
                    int v162 = *__error();
                    uint64_t v163 = *(void *)(a2 + 120);
                    os_log_t v164 = __error();
                    strerror(*v164);
                    BOMCopierErrorCapture(a3, v162, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6169, (uint64_t)"finalize_entry_filesystem", "Could not lchmod %s %s to %s: %s", v119, v163);
                  }
                  else
                  {
LABEL_205:
                    if (set_timestamps(v6, a2, *(NSObject **)a1, a3)) {
                      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6192, (uint64_t)"finalize_entry_filesystem", "Could not set timestamps on destination entry");
                    }
                  }
                }
                else
                {
                  int v165 = *__error();
                  uint64_t v166 = *(void *)(a2 + 120);
                  int v167 = __error();
                  strerror(*v167);
                  BOMCopierErrorCapture(a3, v165, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6157, (uint64_t)"finalize_entry_filesystem", "Could not lchown %s to %d:%d: %s", v166, UserID);
                }
                break;
              default:
                BOMCopierSourceEntryTypeString(v174);
                BOMCopierErrorCapture(a3, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6176, (uint64_t)"finalize_entry_filesystem", "Unsupported BOMCopierSourceEntryType: %s");
                return;
            }
            return;
          }
          unsigned __int16 v115 = Mode;
          if (!v152)
          {
LABEL_154:
            if (v114) {
              unsigned __int16 v116 = v115 & 0xFFB6;
            }
            else {
              unsigned __int16 v116 = v115;
            }
            if (Mode != v116)
            {
              long long v197 = 0u;
              memset(v198, 0, sizeof(v198));
              long long v195 = 0u;
              long long v196 = 0u;
              long long v193 = 0u;
              long long v194 = 0u;
              memset(&v192, 0, sizeof(v192));
              strmode(Mode, (char *)&v192);
              long long v190 = 0u;
              memset(v191, 0, sizeof(v191));
              long long v188 = 0u;
              long long v189 = 0u;
              long long v186 = 0u;
              long long v187 = 0u;
              long long v184 = 0u;
              long long v185 = 0u;
              long long v183 = 0u;
              long long v181 = 0u;
              long long v182 = 0u;
              long long v179 = 0u;
              long long v180 = 0u;
              memset(__bp, 0, sizeof(__bp));
              strmode(v116, __bp);
              uint32_t v117 = *(NSObject **)a1;
              if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v118 = *(void *)(a2 + 120);
                *(_DWORD *)statfs buf = 136315650;
                *(void *)&uint8_t buf[4] = v118;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = &v192;
                *(_WORD *)&buf[22] = 2080;
                int v177 = __bp;
                _os_log_impl(&dword_2105F8000, v117, OS_LOG_TYPE_DEFAULT, "Filtering the mode for %s from %s to %s", buf, 0x20u);
              }
              LOWORD(Mode) = v116;
            }
            goto LABEL_162;
          }
        }
        unsigned __int16 v115 = Mode & 0xF1FF;
        goto LABEL_154;
      }
      int v57 = *__error();
      uint64_t v58 = __error();
      strerror(*v58);
      BOMCopierErrorCapture(a3, v57, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5724, (uint64_t)"finalize_entry_filesystem", "Could not set rootless xattr %s: %s");
LABEL_70:
      int v59 = (char *)v56;
LABEL_182:
      free(v59);
      return;
    case 0x13u:
      if (*(_DWORD *)(a1 + 8)
        || (uint64_t v30 = BOMCopierSourceEntryGetUserID(v6),
            gid_t v31 = BOMCopierSourceEntryGetGroupID(v6),
            !chown(*(const char **)(a2 + 120), v30, v31)))
      {
        int v19 = BOMCopierSourceEntryGetMode(v6);
        if ((*(_DWORD *)(a1 + 8)
           || *(unsigned char *)(a1 + 305)
           || *(unsigned char *)(a1 + 20) && (BOMCopierSourceEntryGetHonorsSetuid(v6) & 1) == 0)
          && (v19 & 0xE00) != 0)
        {
          __int16 v20 = v19 & 0xF1FF;
          long long v197 = 0u;
          memset(v198, 0, sizeof(v198));
          long long v195 = 0u;
          long long v196 = 0u;
          long long v193 = 0u;
          long long v194 = 0u;
          memset(&v192, 0, sizeof(v192));
          strmode(v19, (char *)&v192);
          long long v190 = 0u;
          memset(v191, 0, sizeof(v191));
          long long v188 = 0u;
          long long v189 = 0u;
          long long v186 = 0u;
          long long v187 = 0u;
          long long v184 = 0u;
          long long v185 = 0u;
          long long v183 = 0u;
          long long v181 = 0u;
          long long v182 = 0u;
          long long v179 = 0u;
          long long v180 = 0u;
          memset(__bp, 0, sizeof(__bp));
          strmode(v19 & 0xF1FF, __bp);
          uint64_t v21 = *(NSObject **)a1;
          if (*(void *)a1 && os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v22 = *(void *)(a2 + 120);
            *(_DWORD *)statfs buf = 136315650;
            *(void *)&uint8_t buf[4] = v22;
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = &v192;
            *(_WORD *)&buf[22] = 2080;
            int v177 = __bp;
            _os_log_impl(&dword_2105F8000, v21, OS_LOG_TYPE_DEFAULT, "Filtering the mode for %s from %s to %s", buf, 0x20u);
          }
          LOWORD(v19) = v20;
        }
        if (chmod(*(const char **)(a2 + 120), v19))
        {
          long long v197 = 0u;
          memset(v198, 0, sizeof(v198));
          long long v195 = 0u;
          long long v196 = 0u;
          long long v193 = 0u;
          long long v194 = 0u;
          memset(&v192, 0, sizeof(v192));
          strmode((unsigned __int16)v19, (char *)&v192);
          int v23 = *__error();
          uint64_t v24 = *(void *)(a2 + 120);
          int v25 = __error();
          strerror(*v25);
          BOMCopierErrorCapture(a3, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5613, (uint64_t)"finalize_entry_filesystem", "Could not chmod relay directory %s to %s: %s", v24);
        }
        else if (set_timestamps(v6, a2, *(NSObject **)a1, a3))
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5628, (uint64_t)"finalize_entry_filesystem", "Could not set timestamps on destination entry");
        }
      }
      else
      {
        int v32 = *__error();
        uint64_t v33 = *(void *)(a2 + 120);
        int v34 = __error();
        strerror(*v34);
        BOMCopierErrorCapture(a3, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 5546, (uint64_t)"finalize_entry_filesystem", "Could not chown %s to %d:%d: %s", v33, v30);
      }
      return;
    default:
      goto LABEL_53;
  }
}

uint64_t finalize_entry_apple_archive(uint64_t a1, void *a2)
{
  uint64_t v4 = *(char **)(a1 + 344);
  if (v4
    && (*(_DWORD *)(a1 + 328) = 4997953,
        BOMCopierDestinationEntryWrite(a1, v4, *(void *)(a1 + 352), a2) != *(void *)(a1 + 352)))
  {
    int v7 = *__error();
    BOMCopierErrorCapture(a2, v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6221, (uint64_t)"finalize_entry_apple_archive", "Could not write encoded AppleArchive ACL buffer to the destination");
  }
  else
  {
    uint64_t v5 = *(char **)(a1 + 360);
    if (!v5) {
      return 0;
    }
    *(_DWORD *)(a1 + 328) = 5521752;
    if (BOMCopierDestinationEntryWrite(a1, v5, *(void *)(a1 + 368), a2) == *(void *)(a1 + 368)) {
      return 0;
    }
    int v8 = *__error();
    BOMCopierErrorCapture(a2, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6241, (uint64_t)"finalize_entry_apple_archive", "Could not write encoded AppleArchive XAT buffer to the destination");
  }
  return 1;
}

uint64_t BOMCopierDestinationEntryGetMatchType(uint64_t a1, void *a2)
{
  if (a1) {
    return *(unsigned int *)(a1 + 32);
  }
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1943, (uint64_t)"BOMCopierDestinationEntryGetMatchType", "destination_entry is NULL");
  return 0;
}

uint64_t BOMCopierDestinationEntryGetMatchRecordCount(uint64_t a1, void *a2)
{
  if (a1) {
    return *(unsigned int *)(a1 + 36);
  }
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1961, (uint64_t)"BOMCopierDestinationEntryGetMatchRecordCount", "destination_entry is NULL");
  return 0;
}

uint64_t BOMCopierDestinationEntryGetMatchRecord(uint64_t a1, unsigned int a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 36) <= a2)
    {
      BOMCopierErrorCapture(a4, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1987, (uint64_t)"BOMCopierDestinationEntryGetMatchRecord", "index %d is out of range", a2);
      return 22;
    }
    else if (a3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = *(void *)(a1 + 40) + 40 * a2;
      long long v6 = *(_OWORD *)v5;
      long long v7 = *(_OWORD *)(v5 + 16);
      *(void *)(a3 + 32) = *(void *)(v5 + 32);
      *(_OWORD *)a3 = v6;
      *(_OWORD *)(a3 + 16) = v7;
    }
    else
    {
      uint64_t v4 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1993, (uint64_t)"BOMCopierDestinationEntryGetMatchRecord", "match_record is NULL");
    }
  }
  else
  {
    uint64_t v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 1981, (uint64_t)"BOMCopierDestinationEntryGetMatchRecord", "destination_entry is NULL");
  }
  return v4;
}

uint64_t BOMCopierDestinationEntryWriteFatHeader(uint64_t a1, size_t *a2, void *a3)
{
  if (a1)
  {
    if (a2)
    {
      Binaryunsigned int Type = BOMCopierSourceEntryGetBinaryType(*(void *)(a1 + 8));
      if ((BinaryType - 5) > 0xFFFFFFFD)
      {
        int v9 = BinaryType;
        unsigned int v10 = 20;
        if (BinaryType == 4) {
          unsigned int v10 = 32;
        }
        size_t v11 = v10 * (unint64_t)*(unsigned int *)(a1 + 48) + 8;
        int v12 = (char *)malloc_type_malloc(v11, 0x4AB16E04uLL);
        if (v12)
        {
          uint64_t v13 = v12;
          if (v9 == 4) {
            int v14 = -889275713;
          }
          else {
            int v14 = -889275714;
          }
          int8x8_t v27 = (int8x8_t)__PAIR64__(*(_DWORD *)(a1 + 48), v14);
          BOMSwapFatHeader(&v27, 2);
          *(int8x8_t *)uint64_t v13 = v27;
          if (*(_DWORD *)(a1 + 36))
          {
            uint64_t v15 = 0;
            unint64_t v16 = 0;
            int v17 = v13 + 8;
            do
            {
              uint64_t v18 = *(void *)(a1 + 40);
              if (*(unsigned char *)(v18 + v15))
              {
                uint64_t v19 = v18 + v15;
                if (v9 == 4)
                {
                  memset(v26, 0, sizeof(v26));
                  *(void *)&v26[0] = *(void *)(v19 + 4);
                  *(_OWORD *)((char *)v26 + 8) = *(_OWORD *)(v19 + 16);
                  DWORD2(v26[1]) = *(void *)(v19 + 32);
                  BOMSwapFatArch64((uint64_t)v26, 1u, 2);
                  long long v20 = v26[1];
                  *int v17 = v26[0];
                  v17[1] = v20;
                  v17 += 2;
                }
                else
                {
                  memset(v26, 0, 20);
                  *(void *)&v26[0] = *(void *)(v19 + 4);
                  *((int32x2_t *)&v26[0] + 1) = vmovn_s64(*(int64x2_t *)(v19 + 16));
                  LODWORD(v26[1]) = *(void *)(v19 + 32);
                  BOMSwapFatArch((uint64_t)v26, 1u, 2);
                  int v21 = v26[1];
                  *int v17 = v26[0];
                  *((_DWORD *)v17 + 4) = v21;
                  int v17 = (_OWORD *)((char *)v17 + 20);
                }
              }
              ++v16;
              v15 += 40;
            }
            while (v16 < *(unsigned int *)(a1 + 36));
          }
          uint64_t v22 = BOMCopierDestinationEntryWrite(a1, v13, v11, a3);
          free(v13);
          if (v22 == v11)
          {
            uint64_t v7 = 0;
            *a2 = v11;
          }
          else
          {
            uint64_t v7 = 1;
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2132, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "Could not write the fat header to the destination entry");
          }
        }
        else
        {
          int v23 = *__error();
          uint64_t v24 = __error();
          int v25 = strerror(*v24);
          BOMCopierErrorCapture(a3, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2059, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "Could not allocate %ld bytes: %s", v11, v25);
          return 1;
        }
      }
      else
      {
        uint64_t v7 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2027, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "source entry is not a fat file");
      }
    }
    else
    {
      uint64_t v7 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2020, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "fat_header_size is NULL");
    }
  }
  else
  {
    uint64_t v7 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2014, (uint64_t)"BOMCopierDestinationEntryWriteFatHeader", "destination_entry is NULL");
  }
  return v7;
}

uint64_t BOMCopierDestinationEntryWrite(uint64_t a1, char *__buf, size_t nbyte, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2159, (uint64_t)"BOMCopierDestinationEntryWrite", "destination_entry is NULL");
    return -1;
  }
  if (!__buf)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2165, (uint64_t)"BOMCopierDestinationEntryWrite", "buffer is NULL");
    return -1;
  }
  if (!nbyte)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2171, (uint64_t)"BOMCopierDestinationEntryWrite", "num_bytes is 0");
    return -1;
  }
  switch(*(_DWORD *)a1)
  {
    case 0:
      uint64_t v8 = 0;
      int v9 = __buf;
      break;
    case 1:
      if (*(void *)(a1 + 72))
      {
        uint64_t v8 = write_data_libarchive((void *)a1, (uint64_t)__buf, nbyte, a4);
        goto LABEL_27;
      }
      uint64_t v8 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2192, (uint64_t)"BOMCopierDestinationEntryWrite", "destination_entry->archive is NULL");
      return v8;
    case 2:
      AAFieldKey v13 = *(AAFieldKey *)(a1 + 328);
      if (!AAArchiveStreamWriteBlob(*(AAArchiveStream *)(a1 + 336), v13, __buf, nbyte)) {
        goto LABEL_26;
      }
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6930, (uint64_t)"write_data_apple_archive", "Could not write to AppleArchive: %u");
      return -1;
    case 3:
LABEL_26:
      *(void *)(a1 + 112) += nbyte;
      uint64_t v8 = nbyte;
LABEL_27:
      int v14 = *(uint64_t **)(a1 + 24);
      if (!v14 || v8 < 1 || !BOMCopierDataAnalyzerUpdate(v14, __buf, v8, a4)) {
        return v8;
      }
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2221, (uint64_t)"BOMCopierDestinationEntryWrite", "Could not update data analyzer");
      return -1;
    default:
      return 0;
  }
  while (1)
  {
    size_t v10 = nbyte - v8 >= 0x7FFFFFFF ? 0x7FFFFFFFLL : nbyte - v8;
    if (*(void *)(a1 + 160)) {
      break;
    }
    ssize_t v11 = write(*(_DWORD *)(a1 + 68), v9, v10);
    if (v11 == -1)
    {
      uint64_t v15 = __error();
      strerror(*v15);
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6748, (uint64_t)"write_data_filesystem", "Could not write %ld bytes: %s\n");
      return -1;
    }
LABEL_13:
    v9 += v11;
    v8 += v11;
    if (v11) {
      BOOL v12 = v8 == nbyte;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12)
    {
      *(void *)(a1 + 112) += v8;
      goto LABEL_27;
    }
  }
  ssize_t v11 = ParallelCompressionAFSCStreamWrite();
  if (v11 != -1) {
    goto LABEL_13;
  }
  uint64_t v8 = -1;
  BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6740, (uint64_t)"write_data_filesystem", "Could not AFSC compress %ld bytes: %ld\n");
  return v8;
}

uint64_t write_data_libarchive(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = 0;
  while (1)
  {
    if ((unint64_t)(a3 - v8) >= 0x7FFFFFFF) {
      uint64_t v9 = 0x7FFFFFFFLL;
    }
    else {
      uint64_t v9 = a3 - v8;
    }
    if ((uint64_t)a1[11] >= 1)
    {
      unint64_t v11 = a1[12];
      uint64_t v10 = a1[13];
      unint64_t v12 = v10 + v9;
      uint64_t v13 = v11 - v10;
      if (v12 > v11) {
        uint64_t v9 = v13;
      }
    }
    uint64_t v14 = archive_write_data();
    if (!v14)
    {
LABEL_18:
      a1[14] += v8;
      return v8;
    }
    uint64_t v15 = v14;
    if (v14 == -1)
    {
      int v21 = (const char *)archive_error_string();
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6843, (uint64_t)"write_data_libarchive", "Could not archive file data (%ld bytes): %s\n", v9, v21);
      return -1;
    }
    v8 += v14;
    uint64_t v16 = a1[11];
    if (v16 >= 1)
    {
      uint64_t v17 = a1[12];
      uint64_t v18 = a1[13] + v14;
      a1[13] = v18;
      if (v17 == v18)
      {
        uint64_t v19 = a1[7];
        uint64_t v20 = v19 - a1[14] - v8 >= v16 ? v16 : v19 - a1[14] - v8;
        a1[12] = v20;
        a1[13] = 0;
        if (v20 >= 1)
        {
          archive_entry_set_size();
          if (archive_write_header()) {
            break;
          }
        }
      }
    }
    a2 += v15;
    if (v8 == a3) {
      goto LABEL_18;
    }
  }
  int v23 = (const char *)archive_error_string();
  uint64_t v8 = 1;
  BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6903, (uint64_t)"write_data_libarchive", "Could not write next segment archive entry: %s\n", v23);
  return v8;
}

uint64_t BOMCopierDestinationEntrySeek(int *a1, void *data, unint64_t a3, off_t len, void *a5)
{
  if (!a1)
  {
    uint64_t v15 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2243, (uint64_t)"BOMCopierDestinationEntrySeek", "destination_entry is NULL");
    return v15;
  }
  int v10 = *a1;
  if (*a1 != 2)
  {
    if (v10 != 1)
    {
      if (!v10 && lseek(a1[17], len, 1) == -1)
      {
        int v11 = *__error();
        int v12 = a1[17];
        uint64_t v13 = __error();
        uint64_t v14 = strerror(*v13);
        BOMCopierErrorCapture(a5, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6950, (uint64_t)"seek_filesystem", "Could not lseek in the destination %d:%lu: %s", v12, len, v14);
        return 1;
      }
      goto LABEL_26;
    }
    if (!data)
    {
      uint64_t v15 = 22;
      BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2268, (uint64_t)"BOMCopierDestinationEntrySeek", "seek_buffer is NULL");
      return v15;
    }
    if (!a3)
    {
      uint64_t v15 = 22;
      BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2274, (uint64_t)"BOMCopierDestinationEntrySeek", "seek_buffer is NULL");
      return v15;
    }
    if (!*((void *)a1 + 9))
    {
      uint64_t v15 = 22;
      BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2280, (uint64_t)"BOMCopierDestinationEntrySeek", "destination_entry->archive is NULL");
      return v15;
    }
    if (len)
    {
      uint64_t v19 = 0;
      while (1)
      {
        uint64_t v20 = len - v19 >= a3 ? a3 : len - v19;
        if (write_data_libarchive(a1, (uint64_t)data, v20, a5) != v20) {
          break;
        }
        v19 += v20;
        if (v19 == len) {
          goto LABEL_26;
        }
      }
      uint64_t v15 = 1;
      BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6979, (uint64_t)"seek_libarchive", "Could not write zeroes to the archive for seeking");
      return v15;
    }
LABEL_26:
    int v21 = (uint64_t *)*((void *)a1 + 3);
    if (!v21 || !BOMCopierDataAnalyzerUpdate(v21, data, len, a5)) {
      return 0;
    }
    uint64_t v15 = 1;
    BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2307, (uint64_t)"BOMCopierDestinationEntrySeek", "Could not update data analyzer");
    return v15;
  }
  if (!len) {
    goto LABEL_26;
  }
  uint64_t v16 = 0;
  while (1)
  {
    size_t v17 = len - v16 >= a3 ? a3 : len - v16;
    v18.ikey = 5521732;
    if (AAArchiveStreamWriteBlob(*((AAArchiveStream *)a1 + 42), v18, data, v17)) {
      break;
    }
    v16 += v17;
    if (v16 == len) {
      goto LABEL_26;
    }
  }
  uint64_t v15 = 1;
  BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7011, (uint64_t)"seek_apple_archive", "Could not write zeroes to AppleArchive: %u");
  return v15;
}

uint64_t BOMCopierDestinationEntryGetType(uint64_t a1, void *a2)
{
  if (a1)
  {
    uint64_t v2 = *(unsigned __int16 *)(a1 + 172);
    return BOMCopierSourceEntryModeToType(v2);
  }
  else
  {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2326, (uint64_t)"BOMCopierDestinationEntryGetType", "destination_entry is NULL");
    return 0;
  }
}

uint64_t BOMCopierDestinationEntryGetPath(uint64_t a1, void *a2)
{
  if (a1) {
    return *(void *)(a1 + 120);
  }
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2344, (uint64_t)"BOMCopierDestinationEntryGetPath", "destination_entry is NULL");
  return 0;
}

uint64_t BOMCopierDestinationEntryGetTotalWritten(uint64_t a1, void *a2)
{
  if (a1) {
    return *(void *)(a1 + 112);
  }
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2362, (uint64_t)"BOMCopierDestinationEntryGetTotalWritten", "destination_entry is NULL");
  return 0;
}

BOOL BOMCopierDestinationEntrySkipped(uint64_t a1, void *a2)
{
  if (a1) {
    return *(unsigned char *)(a1 + 16) != 0;
  }
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2380, (uint64_t)"BOMCopierDestinationEntrySkipped", "destination_entry is NULL");
  return 0;
}

uint64_t BOMCopierDestinationSetInit(void *a1, size_t a2, size_t a3, uint64_t a4, void *a5)
{
  if (!a1)
  {
    uint64_t v13 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2401, (uint64_t)"BOMCopierDestinationSetInit", "destination_set is NULL");
    return v13;
  }
  if (!a2)
  {
    uint64_t v13 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2407, (uint64_t)"BOMCopierDestinationSetInit", "io_buffer_size is 0");
    return v13;
  }
  if (!a3)
  {
    uint64_t v13 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2413, (uint64_t)"BOMCopierDestinationSetInit", "zero_buffer_size is 0");
    return v13;
  }
  if (!a4)
  {
    uint64_t v13 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2419, (uint64_t)"BOMCopierDestinationSetInit", "copier_destination is NULL");
    return v13;
  }
  bzero(a1, 0x430uLL);
  *(_DWORD *)a1 = 1;
  int v10 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  a1[1] = v10;
  if (!v10)
  {
    int v15 = *__error();
    uint64_t v16 = __error();
    strerror(*v16);
    BOMCopierErrorCapture(a5, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2435, (uint64_t)"BOMCopierDestinationSetInit", "Could not allocate destination list: %s");
    return 1;
  }
  *int v10 = a4;
  int v11 = malloc_type_valloc(a2, 0x4AB463F2uLL);
  a1[2] = v11;
  if (!v11)
  {
    int v17 = *__error();
    AAFieldKey v18 = __error();
    strerror(*v18);
    BOMCopierErrorCapture(a5, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2448, (uint64_t)"BOMCopierDestinationSetInit", "Could not allocate I/O buffer: %s");
    return 1;
  }
  a1[3] = a2;
  int v12 = malloc_type_valloc(a3, 0x59638F12uLL);
  a1[4] = v12;
  if (!v12)
  {
    int v19 = *__error();
    uint64_t v20 = __error();
    strerror(*v20);
    BOMCopierErrorCapture(a5, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2457, (uint64_t)"BOMCopierDestinationSetInit", "Could not allocate zero buffer: %s");
    return 1;
  }
  bzero(v12, a3);
  uint64_t v13 = 0;
  a1[5] = a3;
  return v13;
}

void BOMCopierDestinationSetRelease(void *a1)
{
  if (a1)
  {
    uint64_t v3 = (void *)a1[4];
    if (v3) {
      free(v3);
    }
    uint64_t v4 = (void *)a1[2];
    if (v4) {
      free(v4);
    }
    uint64_t v5 = (void *)a1[1];
    if (v5) {
      free(v5);
    }
    bzero(a1, 0x430uLL);
  }
  else
  {
    BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2478, (uint64_t)"BOMCopierDestinationSetRelease", "destination_set is NULL");
  }
}

uint64_t BOMCopierCopySourceEntryToDestinationSet(uint64_t a1, unsigned int *a2, void *a3)
{
  uint64_t v132 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v25 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2512, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "source_entry is NULL");
    return v25;
  }
  if (!a2)
  {
    uint64_t v25 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2518, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "destination_set is NULL");
    return v25;
  }
  if (!*((void *)a2 + 4))
  {
    uint64_t v25 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2524, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "zero_buffer is NULL");
    return v25;
  }
  if (!*((void *)a2 + 5))
  {
    uint64_t v25 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2530, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "zero_buffer_size is 0");
    return v25;
  }
  size_t v6 = *a2;
  uint64_t v7 = (unsigned int *)malloc_type_calloc(1uLL, 0x48uLL, 0x1030040A1FD43D8uLL);
  if (!v7)
  {
    int v27 = *__error();
    AAFieldKey v28 = __error();
    int v29 = strerror(*v28);
    BOMCopierErrorCapture(a3, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2559, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "Could not allocate copy state: %s", v29);
    return 1;
  }
  uint64_t v8 = v7;
  *uint64_t v7 = *a2;
  *((void *)v7 + 1) = *((void *)a2 + 2);
  *((_OWORD *)v7 + 1) = *(_OWORD *)(a2 + 6);
  *((void *)v7 + 4) = *((void *)a2 + 5);
  *((void *)v7 + 5) = ***((void ***)a2 + 1);
  *((void *)v7 + 6) = a2 + 12;
  uint64_t v9 = (char *)malloc_type_calloc(v6, 0x20uLL, 0x92671938uLL);
  if (!v9)
  {
    int v30 = *__error();
    gid_t v31 = __error();
    int v32 = strerror(*v31);
    BOMCopierErrorCapture(a3, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2577, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "Could not allocate copy target list: %s", v32);
    release_copy_state(v8);
    return 1;
  }
  uint64_t v126 = v8;
  if (v6)
  {
    uint64_t v10 = 0;
    int v11 = (uint64_t *)*((void *)a2 + 1);
    do
    {
      uint64_t v12 = *v11++;
      *(void *)&v9[v10] = v12;
      v10 += 32;
    }
    while (32 * v6 != v10);
    *((void *)v8 + 7) = v9;
    int v127 = v8 + 14;
    BOOL IsCompressed = BOMCopierSourceEntryIsCompressed(a1);
    *((unsigned char *)v8 + 64) = 0;
    uint64_t v14 = v8 + 16;
    if (IsCompressed)
    {
      int v15 = 0;
      uint64_t v16 = *((void *)a2 + 1);
      size_t v17 = v6;
      do
      {
        if (*(unsigned char *)(*(void *)v16 + 113)) {
          v15 += *(unsigned __int8 *)(*(void *)v16 + 300);
        }
        v16 += 8;
        --v17;
      }
      while (v17);
      if (v15 && v15 == v6) {
        *uint64_t v14 = 1;
      }
    }
    uint64_t v18 = 0;
    for (uint64_t i = 0; i != v6; ++i)
    {
      uint64_t v20 = *(void *)(*((void *)a2 + 1) + 8 * i);
      if (IsCompressed && *(unsigned char *)(v20 + 113))
      {
        if (*v14) {
          char v21 = 2;
        }
        else {
          char v21 = 1;
        }
      }
      else
      {
        char v21 = 0;
      }
      if ((*(_DWORD *)(v20 + 44) - 1) > 1
        || !BOMCopierSourceEntryIsRoot(a1) && BOMCopierSourceEntryGetType(a1) != 13)
      {
        uint64_t Entry = BOMCopierDestinationCreateEntry(v20, a1, v21, a3);
        if (!Entry)
        {
          uint64_t v25 = 1;
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 2715, (uint64_t)"BOMCopierCopySourceEntryToDestinationSet", "Could not create destination entry");
          uint64_t v46 = v126;
          goto LABEL_208;
        }
        int v23 = *(_DWORD *)(Entry + 32);
        uint64_t v24 = *v127 + v18;
        *(void *)uint64_t v24 = v20;
        *(void *)(v24 + 8) = Entry;
        *(_DWORD *)(v24 + 16) = v23;
        if ((v23 - 3) <= 1) {
          *uint64_t v14 = 0;
        }
      }
      v18 += 32;
    }
    uint64_t v8 = v126;
  }
  else
  {
    *((void *)v8 + 7) = v9;
    int v127 = v8 + 14;
    BOMCopierSourceEntryIsCompressed(a1);
    *((unsigned char *)v8 + 64) = 0;
    uint64_t v14 = v8 + 16;
  }
  uint64_t v33 = *((void *)v8 + 5);
  if (BOMCopierSourceEntryGetType(a1) != 8)
  {
LABEL_81:
    uint64_t v54 = BOMCopierSourceEntrySkip(a1, *((void **)v8 + 1), *((void *)v8 + 2), a3);
    if (v54)
    {
      uint64_t v25 = v54;
      BOMCopierErrorCapture(a3, v54, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7334, (uint64_t)"copy_entry_to_destinations", "Could not skip remaning source entry data\n", v116);
      goto LABEL_207;
    }
    unint64_t v55 = *v8;
    if (!v55)
    {
LABEL_89:
      uint64_t v25 = 0;
      goto LABEL_207;
    }
    uint64_t v56 = 0;
    unint64_t v57 = 0;
    uint64_t v58 = *v127;
    while (1)
    {
      uint64_t v59 = *(void *)(v58 + v56 + 8);
      if (v59)
      {
        int v60 = *(void **)(v58 + v56);
        snprintf(*((char **)v8 + 6), 0x400uLL, "%s", *(const char **)(v59 + 120));
        uint64_t v61 = BOMCopierDestinationFinalizeEntry(v60, (void *)v59, a3);
        if (v61)
        {
          uint64_t v25 = v61;
          BOMCopierErrorCapture(a3, v61, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7354, (uint64_t)"copy_entry_to_destinations", "Could not finalize destination entry\n", v117);
          goto LABEL_207;
        }
        uint64_t v58 = *((void *)v8 + 7);
        *(void *)(v58 + v56 + 8) = 0;
        unint64_t v55 = *v8;
      }
      ++v57;
      v56 += 32;
      if (v57 >= v55) {
        goto LABEL_89;
      }
    }
  }
  uint64_t Size = BOMCopierSourceEntryGetSize(a1);
  BOOL v35 = BOMCopierSourceEntryIsCompressed(a1);
  AAFieldKey v36 = 0;
  uint64_t v37 = Size;
  if (Size < 1) {
    goto LABEL_63;
  }
  uint64_t v38 = a1;
  if (v35)
  {
    if (*v14)
    {
      ExtendedAttributeCFIndex Count = BOMCopierSourceEntryGetExtendedAttributeCount(a1, a3);
      if (ExtendedAttributeCount)
      {
        int v40 = ExtendedAttributeCount;
        unsigned int v41 = 0;
        char v42 = 0;
        do
        {
          ExtendedAttributeName = (const char *)BOMCopierSourceEntryGetExtendedAttributeName(a1, v41, a3);
          if (!ExtendedAttributeName)
          {
            uint64_t v25 = 1;
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7184, (uint64_t)"copy_entry_to_destinations", "Could not retrieve extended attribute name for index %u", v41);
            uint64_t v8 = v126;
            goto LABEL_207;
          }
          int v44 = ExtendedAttributeName;
          if (!strcmp(ExtendedAttributeName, "com.apple.ResourceFork"))
          {
            Actualuint64_t Path = (const char *)BOMCopierSourceEntryGetActualPath(a1);
            uint64_t v8 = v126;
            if (!ActualPath)
            {
              uint64_t v25 = 1;
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7206, (uint64_t)"copy_entry_to_destinations", "Could not retrieve actual path for source entry");
              goto LABEL_207;
            }
            int v112 = BOMCopierSourceEntryNewFromResourceFork(ActualPath, a3);
            if (!v112)
            {
              uint64_t v25 = 1;
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7213, (uint64_t)"copy_entry_to_destinations", "Could not create resource fork entry for %s");
              goto LABEL_207;
            }
            AAFieldKey v36 = v112;
            uint64_t v113 = *v126;
            uint64_t v37 = 1;
            if (v113)
            {
              uint64_t v114 = *v127 + 8;
              do
              {
                if (*(void *)v114) {
                  *(unsigned char *)(*(void *)v114 + 155) = 1;
                }
                v114 += 32;
                --v113;
              }
              while (v113);
            }
            uint64_t v38 = (uint64_t)v112;
            goto LABEL_64;
          }
          v42 |= strcmp(v44, "com.apple.decmpfs") == 0;
          ++v41;
        }
        while (v40 != v41);
        BOMCopierSourceEntrySetSize(a1, 0);
        uint64_t v8 = v126;
        if ((v42 & 1) == 0) {
          goto LABEL_58;
        }
        if (v33 && os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          AAFieldKey v45 = "Skipping copying com.apple.decmpfs until finalization";
          goto LABEL_61;
        }
      }
      else
      {
        BOMCopierSourceEntrySetSize(a1, 0);
LABEL_58:
        if (v33 && os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)statfs buf = 0;
          AAFieldKey v45 = "Source entry claims to be compressed but there is no com.apple.decmpfs extended attribute. Assuming zero-length file.";
LABEL_61:
          _os_log_impl(&dword_2105F8000, v33, OS_LOG_TYPE_DEFAULT, v45, buf, 2u);
        }
      }
      AAFieldKey v36 = 0;
      uint64_t v37 = 0;
    }
    else
    {
      AAFieldKey v36 = 0;
      uint64_t v37 = 1;
    }
LABEL_63:
    uint64_t v38 = a1;
  }
LABEL_64:
  uint64_t v122 = v37;
  uint64_t v123 = v36;
  uint64_t v124 = Size;
  uint64_t v125 = v38;
  if (!BOMCopierSourceEntryGetBinaryType(v38) || !*v8) {
    goto LABEL_71;
  }
  int v47 = 0;
  int64_t v48 = (int *)(*v127 + 16);
  uint64_t v49 = *v8;
  do
  {
    int v50 = *v48;
    v48 += 8;
    if (v50 == 1) {
      ++v47;
    }
    --v49;
  }
  while (v49);
  if (v47 == *v8)
  {
LABEL_71:
    uint64_t v51 = BOMCopierSourceEntryGetSize(v38);
    BOOL IsStreamed = BOMCopierSourceEntryIsStreamed(v38);
    if (v51) {
      BOOL v53 = 0;
    }
    else {
      BOOL v53 = IsStreamed;
    }
    if (!v51 && !IsStreamed) {
      goto LABEL_76;
    }
    uint64_t v62 = 0;
    uint64_t v120 = v51;
    while (1)
    {
      unint64_t v63 = v51 - v62;
      while (1)
      {
        uint64_t v64 = v63 >= *((void *)v8 + 2) ? *((void *)v8 + 2) : v63;
        size_t v65 = v53 ? *((void *)v8 + 2) : v64;
        size_t v66 = BOMCopierSourceEntryRead(v38, *((char **)v8 + 1), v65, a3);
        size_t v67 = v66;
        if (v53) {
          break;
        }
        if ((v66 & 0x8000000000000000) != 0)
        {
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7469, (uint64_t)"copy_file_entry_to_destinations", "Could not read %lu bytes from source");
LABEL_124:
          uint64_t v25 = 1;
          BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7292, (uint64_t)"copy_entry_to_destinations", "Could not copy file entry to destination entry list", v118);
          goto LABEL_207;
        }
        if (v66) {
          goto LABEL_104;
        }
      }
      if ((v66 & 0x8000000000000000) != 0)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7458, (uint64_t)"copy_file_entry_to_destinations", "Could not read %lu bytes from non-deterministic source");
        goto LABEL_124;
      }
      if (!v66) {
        break;
      }
LABEL_104:
      if (*v8)
      {
        uint64_t v68 = 0;
        unint64_t v69 = 0;
        do
        {
          uint64_t v70 = *(void *)(*v127 + v68 + 8);
          if (v70)
          {
            snprintf(*((char **)v126 + 6), 0x400uLL, "%s", *(const char **)(v70 + 120));
            if (!*(unsigned char *)(v70 + 16) && !*(unsigned char *)(v70 + 154))
            {
              size_t v71 = *((void *)v126 + 5);
              if (v71 && os_log_type_enabled(*((os_log_t *)v126 + 5), OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v72 = *(void *)(v70 + 120);
                *(_DWORD *)statfs buf = 134218242;
                *(void *)&uint8_t buf[4] = v67;
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = v72;
                _os_log_impl(&dword_2105F8000, v71, OS_LOG_TYPE_DEFAULT, "Copying %lu bytes to %s", buf, 0x16u);
              }
              if (BOMCopierDestinationEntryWrite(v70, *((char **)v126 + 1), v67, a3) != v67)
              {
                BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7499, (uint64_t)"copy_file_entry_to_destinations", "Could not write %ld bytes to destination", v67);
                uint64_t v8 = v126;
                goto LABEL_124;
              }
              uint64_t v73 = *(void *)(*v127 + v68);
              ssize_t v74 = *(void (**)(uint64_t, uint64_t, uint64_t, void))(v73 + 248);
              if (v74) {
                v74(v73, v125, v70, *(void *)(v73 + 256));
              }
            }
          }
          ++v69;
          uint64_t v8 = v126;
          v68 += 32;
        }
        while (v69 < *v126);
      }
      v62 += v67;
      uint64_t v51 = v120;
      char v75 = v62 != v120 || v53;
      uint64_t v38 = v125;
      if ((v75 & 1) == 0)
      {
        int v76 = *((void *)v8 + 5);
        if (v76 && os_log_type_enabled(*((os_log_t *)v8 + 5), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 134217984;
          *(void *)&uint8_t buf[4] = v120;
          int v77 = "Read %llu total bytes from the source.";
          ssize_t v78 = v76;
          uint32_t v79 = 12;
          goto LABEL_200;
        }
        goto LABEL_76;
      }
    }
    unsigned __int16 v115 = *((void *)v8 + 5);
    if (v115 && os_log_type_enabled(*((os_log_t *)v8 + 5), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      int v77 = "Read 0 bytes from non-deterministic source.";
      ssize_t v78 = v115;
      uint32_t v79 = 2;
LABEL_200:
      _os_log_impl(&dword_2105F8000, v78, OS_LOG_TYPE_DEFAULT, v77, buf, v79);
    }
LABEL_76:
    if (v123) {
      BOMCopierSourceEntryFree(v123);
    }
    if (v124 >= 1 && !v122) {
      BOMCopierSourceEntrySetSize(a1, v124);
    }
    goto LABEL_81;
  }
  uint64_t v80 = 0;
  unint64_t v81 = 0;
  do
  {
    uint64_t v82 = *v127 + v80;
    uint64_t v83 = *(void *)(v82 + 8);
    if (v83)
    {
      int v84 = *(_DWORD *)(v82 + 16);
      snprintf(*((char **)v8 + 6), 0x400uLL, "%s", *(const char **)(v83 + 120));
      if (v84 == 4 || v84 == 1 && BOMCopierSourceEntryGetBinaryType(v125) - 3 <= 1)
      {
        *(void *)statfs buf = 0;
        if (!*(unsigned char *)(v83 + 16) && !*(unsigned char *)(v83 + 154))
        {
          if (BOMCopierDestinationEntryWriteFatHeader(v83, (size_t *)buf, a3))
          {
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7580, (uint64_t)"copy_binary_entry_to_destinations", "Could not write fat header\n", v116);
            goto LABEL_206;
          }
          *(void *)(*v127 + v80 + 24) += *(void *)buf;
        }
      }
    }
    ++v81;
    v80 += 32;
  }
  while (v81 < *v8);
  uint64_t v85 = v125;
  ArchCFIndex Count = BOMCopierSourceEntryGetArchCount(v125);
  if (!ArchCount) {
    goto LABEL_76;
  }
  unsigned int v87 = 0;
  uint64_t v88 = 0;
  long long v89 = 0uLL;
  int v119 = ArchCount;
  while (1)
  {
    long long v128 = v89;
    long long v129 = v89;
    if (BOMCopierSourceEntryGetArchRecord(v85, v87, &v128, a3))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7608, (uint64_t)"copy_binary_entry_to_destinations", "Could not get arch record at index %d\n");
      goto LABEL_206;
    }
    unsigned int v121 = v87;
    unint64_t v90 = *((void *)&v128 + 1) - v88;
    if (*((void *)&v128 + 1) != v88)
    {
      uint64_t v88 = *((void *)&v128 + 1);
      if (BOMCopierSourceEntrySeek(v85, v90, *((void **)v8 + 1), *((void *)v8 + 2), a3))
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7624, (uint64_t)"copy_binary_entry_to_destinations", "Could not seek to beginning of matching slice\n");
        goto LABEL_206;
      }
    }
    uint64_t v91 = v88;
    unint64_t v92 = *v8;
    long long v89 = 0uLL;
    if (v92)
    {
      uint64_t v93 = 0;
      for (unint64_t j = 0; j < v92; ++j)
      {
        uint64_t v95 = *(void *)(*v127 + v93 + 8);
        if (v95)
        {
          snprintf(*((char **)v8 + 6), 0x400uLL, "%s", *(const char **)(v95 + 120));
          long long v89 = 0uLL;
          uint64_t v131 = 0;
          memset(buf, 0, sizeof(buf));
          if (!*(unsigned char *)(v95 + 16))
          {
            if (BOMCopierDestinationEntryGetMatchRecord(v95, v87, (uint64_t)buf, a3))
            {
              BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7659, (uint64_t)"copy_binary_entry_to_destinations", "Could not get match record at index %d\n");
              goto LABEL_206;
            }
            long long v89 = 0uLL;
            if (buf[0])
            {
              if (*(void *)&buf[16] == -1)
              {
                BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7673, (uint64_t)"copy_binary_entry_to_destinations", "dude offset is wack", v116);
                goto LABEL_206;
              }
              uint64_t v96 = *(void *)(*v127 + v93 + 24);
              uint64_t v97 = *(void *)&buf[16] - v96;
              if (*(void *)&buf[16] != v96)
              {
                if (BOMCopierDestinationEntrySeek((int *)v95, *((void **)v8 + 3), *((void *)v8 + 4), *(void *)&buf[16] - v96, a3))
                {
                  BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7685, (uint64_t)"copy_binary_entry_to_destinations", "Could not seek %ld bytes to beginning of new slice");
                  goto LABEL_206;
                }
                *(void *)(*v127 + v93 + 24) += v97;
                long long v89 = 0uLL;
              }
            }
          }
          unint64_t v92 = *v8;
        }
        v93 += 32;
      }
    }
    uint64_t v98 = v129;
    if ((void)v129) {
      break;
    }
    uint64_t v85 = v125;
    uint64_t v88 = v91;
LABEL_176:
    if (++v87 == v119) {
      goto LABEL_76;
    }
  }
  uint64_t v99 = 0;
  uint64_t v85 = v125;
  uint64_t v88 = v91;
  while (1)
  {
    size_t v100 = v98 - v99;
    int v101 = (char *)*((void *)v8 + 1);
    int v102 = v8;
    if (v100 >= *((void *)v8 + 2)) {
      size_t v103 = *((void *)v8 + 2);
    }
    else {
      size_t v103 = v100;
    }
    if (BOMCopierSourceEntryRead(v85, v101, v103, a3) != v103)
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7711, (uint64_t)"copy_binary_entry_to_destinations", "Could not read %ld bytes from source", v103);
      uint64_t v8 = v102;
      goto LABEL_206;
    }
    unint64_t v104 = *v102;
    unsigned int v87 = v121;
    long long v89 = 0uLL;
    if (v104) {
      break;
    }
LABEL_173:
    v88 += v103;
    v99 += v103;
    uint64_t v98 = v129;
    uint64_t v85 = v125;
    uint64_t v8 = v126;
    if (v99 == (void)v129) {
      goto LABEL_176;
    }
  }
  uint64_t v105 = 0;
  unint64_t v106 = 0;
  while (1)
  {
    uint64_t v107 = *(void *)(*v127 + v105 + 8);
    if (v107) {
      break;
    }
LABEL_164:
    ++v106;
    v105 += 32;
    if (v106 >= v104) {
      goto LABEL_173;
    }
  }
  snprintf(*((char **)v126 + 6), 0x400uLL, "%s", *(const char **)(v107 + 120));
  long long v89 = 0uLL;
  uint64_t v131 = 0;
  memset(buf, 0, sizeof(buf));
  if (*(unsigned char *)(v107 + 16)) {
    goto LABEL_163;
  }
  if (BOMCopierDestinationEntryGetMatchRecord(v107, v121, (uint64_t)buf, a3))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7741, (uint64_t)"copy_binary_entry_to_destinations", "Could not get match record at index %d\n");
    goto LABEL_189;
  }
  long long v89 = 0uLL;
  if (!buf[0] || *(unsigned char *)(v107 + 16) || *(unsigned char *)(v107 + 154))
  {
LABEL_163:
    unint64_t v104 = *v126;
    goto LABEL_164;
  }
  if (BOMCopierDestinationEntryWrite(v107, *((char **)v126 + 1), v103, a3) == v103)
  {
    int v108 = (void *)(*v127 + v105);
    v108[3] += v103;
    uint64_t v109 = *v108;
    size_t v110 = *(void (**)(uint64_t, uint64_t, uint64_t, void, __n128))(*v108 + 248);
    long long v89 = 0uLL;
    if (v110)
    {
      v110(v109, v125, v107, *(void *)(v109 + 256), (__n128)0);
      long long v89 = 0uLL;
    }
    goto LABEL_163;
  }
  BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7755, (uint64_t)"copy_binary_entry_to_destinations", "Could not write %ld bytes to destination: %s\n");
LABEL_189:
  uint64_t v8 = v126;
LABEL_206:
  uint64_t v25 = 1;
  BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 7300, (uint64_t)"copy_entry_to_destinations", "Could not copy file entry to destination entry list");
LABEL_207:
  uint64_t v46 = v8;
LABEL_208:
  release_copy_state(v46);
  return v25;
}

void release_copy_state(void *a1)
{
  uint64_t v2 = (char *)a1[7];
  if (v2)
  {
    unint64_t v3 = *(unsigned int *)a1;
    if (v3)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        if (*(void *)&v2[v5])
        {
          BOMCopierDestinationEntryFree(*(void **)&v2[v5]);
          uint64_t v2 = (char *)a1[7];
          *(void *)&v2[v5] = 0;
          unint64_t v3 = *(unsigned int *)a1;
        }
        ++v4;
        v5 += 32;
      }
      while (v4 < v3);
    }
    free(v2);
  }
  a1[8] = 0;
  *((_OWORD *)a1 + 2) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  free(a1);
}

const char *string_for_entry_type(unsigned int a1)
{
  if (a1 > 0x13) {
    return "?";
  }
  else {
    return off_2641327A8[a1];
  }
}

const char *string_for_mode(__int16 a1)
{
  unsigned int v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 13 > 6) {
    return "?";
  }
  else {
    return off_264132848[v1 >> 12];
  }
}

uint64_t populate_aa_header_acl(uint64_t a1, uint64_t a2, AAHeader_impl *a3, void *a4)
{
  path_p = 0;
  pid_t v8 = getpid();
  asprintf(&path_p, "/tmp/.BCDE.%u.T_XXXXXX", v8);
  if (path_p)
  {
    int v9 = mkstemp(path_p);
    if (v9 == -1)
    {
      uint64_t v20 = __error();
      strerror(*v20);
      uint64_t v19 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4871, (uint64_t)"populate_aa_header_acl", "Could not mkstemp %s: %s\n");
    }
    else
    {
      close(v9);
      uint64_t v36 = 0;
      ACL = (const char *)BOMCopierSourceEntryGetACL(a1, &v36, a4);
      if (ACL)
      {
        int v11 = acl_from_text(ACL);
        if (!v11)
        {
          int v21 = *__error();
          uint64_t v22 = __error();
          int v23 = strerror(*v22);
          BOMCopierErrorCapture(a4, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4890, (uint64_t)"populate_aa_header_acl", "Could not convert ACL text: %s", v23);
          goto LABEL_12;
        }
        uint64_t v12 = v11;
        if (acl_set_file(path_p, ACL_TYPE_EXTENDED, v11))
        {
          int v13 = *__error();
          uint64_t v14 = path_p;
          int v15 = __error();
          uint64_t v16 = strerror(*v15);
          BOMCopierErrorCapture(a4, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4898, (uint64_t)"populate_aa_header_acl", "Could not set ACL on %s: %s", v14, v16);
          acl_free(v12);
LABEL_12:
          uint64_t v24 = path_p;
          goto LABEL_13;
        }
        acl_free(v12);
        int v26 = AAEntryACLBlobCreateWithPath(path_p, "", 0);
        if (v26)
        {
          unlink(path_p);
          free(path_p);
          Encodeduint64_t Size = AAEntryACLBlobGetEncodedSize(v26);
          EncodedCFDataRef Data = AAEntryACLBlobGetEncodedData(v26);
          int v29 = (char *)malloc_type_malloc(EncodedSize, 0xE2C7DE7CuLL);
          if (!v29)
          {
            int v33 = *__error();
            int v34 = __error();
            BOOL v35 = strerror(*v34);
            BOMCopierErrorCapture(a4, v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4927, (uint64_t)"populate_aa_header_acl", "Could not allocate encoded buffer: %s", v35);
            AAEntryACLBlobDestroy(v26);
            return 1;
          }
          int v30 = v29;
          memcpy(v29, EncodedData, EncodedSize);
          AAEntryACLBlobDestroy(v26);
          v31.ikey = 4997953;
          int v32 = AAHeaderSetFieldBlob(a3, 0xFFFFFFFF, v31, EncodedSize);
          if (!v32)
          {
            uint64_t v19 = 0;
            *(void *)(a2 + 344) = v30;
            *(void *)(a2 + 352) = EncodedSize;
            return v19;
          }
          BOMCopierErrorCapture(a4, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4943, (uint64_t)"populate_aa_header_acl", "Could not append AA_FIELD_ACL to AppleArchive header: %d", v32);
          uint64_t v24 = v30;
LABEL_13:
          free(v24);
          return 1;
        }
        uint64_t v19 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4909, (uint64_t)"populate_aa_header_acl", "Could create AppleArchive ACL blob from %s: %s");
      }
      else
      {
        uint64_t v19 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4882, (uint64_t)"populate_aa_header_acl", "Could not get ACL from source entry");
      }
    }
    free(path_p);
  }
  else
  {
    size_t v17 = __error();
    uint64_t v18 = strerror(*v17);
    uint64_t v19 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4864, (uint64_t)"populate_aa_header_acl", "Could not create ACL file path: %s\n", v18);
  }
  return v19;
}

uint64_t populate_aa_header_xattr(uint64_t a1, uint64_t a2, AAHeader_impl *a3, void *a4)
{
  AAEntryXATBlob v8 = AAEntryXATBlobCreate();
  if (!v8)
  {
    uint64_t v26 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4750, (uint64_t)"populate_aa_header_xattr", "Could not create AppleArchive XAT blob");
    return v26;
  }
  int v9 = v8;
  ExtendedAttributeCFIndex Count = BOMCopierSourceEntryGetExtendedAttributeCount(a1, a4);
  if (ExtendedAttributeCount)
  {
    int v11 = ExtendedAttributeCount;
    uint64_t v32 = a2;
    unsigned int v12 = 0;
    int v13 = 0;
    size_t v14 = 0;
    do
    {
      uint64_t ExtendedAttributeName = BOMCopierSourceEntryGetExtendedAttributeName(a1, v12, a4);
      if (!ExtendedAttributeName)
      {
        uint64_t v26 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4764, (uint64_t)"populate_aa_header_xattr", "Could not get name for xattr %u");
        return v26;
      }
      uint64_t v16 = (const char *)ExtendedAttributeName;
      ExtendedAttributeuint64_t Size = BOMCopierSourceEntryGetExtendedAttributeSize(a1, v12, a4);
      if (!ExtendedAttributeSize)
      {
        uint64_t v26 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4771, (uint64_t)"populate_aa_header_xattr", "Could not get size for xattr %u");
        return v26;
      }
      size_t v18 = ExtendedAttributeSize;
      if (v14 < ExtendedAttributeSize)
      {
        int v13 = malloc_type_realloc(v13, ExtendedAttributeSize, 0xADE94BC4uLL);
        size_t v14 = v18;
        if (!v13)
        {
          int v29 = *__error();
          int v30 = __error();
          strerror(*v30);
          BOMCopierErrorCapture(a4, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4781, (uint64_t)"populate_aa_header_xattr", "Could not allocate buffer %u: %s");
          return 1;
        }
      }
      if (BOMCopierSourceEntryCopyExtendedAttribute(a1, v12, v13, v18, 0, a4) != v18)
      {
        uint64_t v26 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4789, (uint64_t)"populate_aa_header_xattr", "Could not copy xattr %u");
        return v26;
      }
      int appended = AAEntryXATBlobAppendEntry(v9, v16, (const uint8_t *)v13, v18);
      if (appended)
      {
        BOMCopierErrorCapture(a4, appended, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4796, (uint64_t)"populate_aa_header_xattr", "Could not append %u entry to AppleArchive XAT blob: %d");
        return 1;
      }
      ++v12;
    }
    while (v11 != v12);
    a2 = v32;
    if (v13) {
      free(v13);
    }
  }
  Encodeduint64_t Size = AAEntryXATBlobGetEncodedSize(v9);
  EncodedCFDataRef Data = AAEntryXATBlobGetEncodedData(v9);
  uint64_t v22 = malloc_type_malloc(EncodedSize, 0x8C0427uLL);
  if (!v22)
  {
    int v27 = *__error();
    AAFieldKey v28 = __error();
    strerror(*v28);
    BOMCopierErrorCapture(a4, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4816, (uint64_t)"populate_aa_header_xattr", "Could not allocate encoded buffer: %s");
    return 1;
  }
  int v23 = v22;
  memcpy(v22, EncodedData, EncodedSize);
  AAEntryXATBlobDestroy(v9);
  v24.ikey = 5521752;
  int v25 = AAHeaderSetFieldBlob(a3, 0xFFFFFFFF, v24, EncodedSize);
  if (v25)
  {
    BOMCopierErrorCapture(a4, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 4831, (uint64_t)"populate_aa_header_xattr", "Could not append AA_FIELD_XAT to AppleArchive header: %d", v25);
    free(v23);
    return 1;
  }
  uint64_t v26 = 0;
  *(void *)(a2 + 360) = v23;
  *(void *)(a2 + 368) = EncodedSize;
  return v26;
}

void apply_retention_policy(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a2 + 8);
  if (BOMCopierSourceEntryGetType(v6) == 8)
  {
    if (*(unsigned char *)(a1 + 307))
    {
      Binaryunsigned int Type = BOMCopierSourceEntryGetBinaryType(v6);
      BOOL v9 = BinaryType != 0;
      if (!*(void *)(a1 + 336))
      {
        if (!BinaryType) {
          goto LABEL_40;
        }
LABEL_11:
        __to = 0;
        unsigned int v12 = *(char **)(a1 + 344);
        if (v12)
        {
          if (make_path(*(NSObject **)a1, v12, a3))
          {
            int v13 = __error();
            strerror(*v13);
            BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6457, (uint64_t)"apply_retention_policy", "Could not make the kept file directory %s: %s");
            return;
          }
          if (*(unsigned char *)(a1 + 352))
          {
            if (!*(void *)(a1 + 360))
            {
              int v23 = malloc_type_calloc(1uLL, 0x400uLL, 0xFEEEF0C2uLL);
              *(void *)(a1 + 360) = v23;
              if (!v23)
              {
                int v40 = *__error();
                unsigned int v41 = __error();
                strerror(*v41);
                BOMCopierErrorCapture(a3, v40, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6476, (uint64_t)"apply_retention_policy", "Could not allocate kept file subdirectory path: %s");
                return;
              }
            }
            unint64_t v24 = *(void *)(a1 + 312);
            if (!v24 || !(v24 % *(unsigned int *)(a1 + 356)))
            {
              memset(out, 0, sizeof(out));
              uuid_generate_random(out);
              *(_OWORD *)statfs buf = 0u;
              memset(v48, 0, sizeof(v48));
              uuid_unparse(out, (char *)buf);
              snprintf(*(char **)(a1 + 360), 0x400uLL, "%s/%c%c/%c%c/%c%c/%s", *(const char **)(a1 + 344), (char)buf[0], (char)buf[1], (char)buf[2], (char)buf[3], (char)buf[4], (char)buf[5], (const char *)buf);
              if (make_path(*(NSObject **)a1, *(char **)(a1 + 360), a3))
              {
                int v25 = __error();
                strerror(*v25);
                BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6503, (uint64_t)"apply_retention_policy", "Could not make the kept file subdirectory %s: %s");
                return;
              }
            }
            asprintf((char **)&__to, "%s/%lu");
          }
          else
          {
            getpid();
            asprintf((char **)&__to, "%s/%s.dittoKeptBinary.%d.%lu");
          }
        }
        else
        {
          getpid();
          asprintf((char **)&__to, "%s.dittoKeptBinary.%d.%lu");
        }
        size_t v17 = __to;
        if (!__to)
        {
          int v26 = *__error();
          int v27 = __error();
          strerror(*v27);
          BOMCopierErrorCapture(a3, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6523, (uint64_t)"apply_retention_policy", "Could not asprintf kept path: %s\n");
          return;
        }
        ++*(void *)(a1 + 312);
        size_t v18 = *(const std::__fs::filesystem::path **)(a2 + 120);
        uint64_t v19 = *(NSObject **)a1;
        if (*(void *)a1)
        {
          if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
            || (*(_DWORD *)statfs buf = 136315138,
                *(void *)&uint8_t buf[4] = v18,
                _os_log_impl(&dword_2105F8000, v19, OS_LOG_TYPE_DEFAULT, "kept old: %s", buf, 0xCu),
                (uint64_t v19 = *(NSObject **)a1) != 0))
          {
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)statfs buf = 136315138;
              *(void *)&uint8_t buf[4] = v17;
              _os_log_impl(&dword_2105F8000, v19, OS_LOG_TYPE_DEFAULT, "kept new: %s", buf, 0xCu);
            }
          }
        }
        rename(v18, v17, v16);
        if (v20)
        {
          int v21 = *__error();
          uint64_t v22 = __error();
          strerror(*v22);
          BOMCopierErrorCapture(a3, v21, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6538, (uint64_t)"apply_retention_policy", "Could not rename kept %s to %s: %s", v18);
LABEL_24:
          free(__to);
          return;
        }
        AAFieldKey v28 = *(const char **)(a1 + 320);
        if (v28)
        {
          int v29 = *(_DWORD *)(a1 + 328);
          if (v29 == -1)
          {
            int v30 = open(v28, 1545, 420);
            if (v30 == -1)
            {
              int v44 = *__error();
              AAFieldKey v45 = __error();
              strerror(*v45);
              BOMCopierErrorCapture(a3, v44, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6561, (uint64_t)"apply_retention_policy", "Could not open %s: %s");
              goto LABEL_24;
            }
            int v29 = v30;
            *(_DWORD *)(a1 + 328) = v30;
          }
          size_t v31 = strlen((const char *)__to);
          if (write(v29, __to, v31) != v31)
          {
            int v38 = *__error();
            AAFieldKey v39 = __error();
            strerror(*v39);
            BOMCopierErrorCapture(a3, v38, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6577, (uint64_t)"apply_retention_policy", "Could not write to %s: %s");
            goto LABEL_24;
          }
          if (write(v29, "\n", 1uLL) != 1)
          {
            int v42 = *__error();
            int v43 = __error();
            strerror(*v43);
            BOMCopierErrorCapture(a3, v42, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6586, (uint64_t)"apply_retention_policy", "Could not write to %s: %s");
            goto LABEL_24;
          }
        }
        free(__to);
        goto LABEL_40;
      }
    }
    else
    {
      if (!*(void *)(a1 + 336)) {
        goto LABEL_40;
      }
      BOOL v9 = 0;
    }
    uint64_t Path = (const char *)BOMCopierSourceEntryGetPath(v6);
    int v11 = regexec(*(const regex_t **)(a1 + 336), Path, 0, 0, 0);
    if (v11)
    {
      if (v11 != 1)
      {
        int v14 = *__error();
        int v15 = __error();
        strerror(*v15);
        BOMCopierErrorCapture(a3, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6427, (uint64_t)"apply_retention_policy", "Could not regexec %s: %s\n");
        return;
      }
      if (!v9) {
        goto LABEL_40;
      }
    }
    goto LABEL_11;
  }
LABEL_40:
  if (*(unsigned char *)(a2 + 152))
  {
    uint64_t v32 = *(const std::__fs::filesystem::path **)(a2 + 144);
    int v33 = *(const std::__fs::filesystem::path **)(a2 + 120);
    int v34 = *(NSObject **)a1;
    if (*(void *)a1)
    {
      if (!os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_DEFAULT)
        || (*(_DWORD *)statfs buf = 136315138,
            *(void *)&uint8_t buf[4] = v32,
            _os_log_impl(&dword_2105F8000, v34, OS_LOG_TYPE_DEFAULT, "rename old: %s", buf, 0xCu),
            (int v34 = *(NSObject **)a1) != 0))
      {
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)statfs buf = 136315138;
          *(void *)&uint8_t buf[4] = v33;
          _os_log_impl(&dword_2105F8000, v34, OS_LOG_TYPE_DEFAULT, "rename new: %s", buf, 0xCu);
        }
      }
    }
    rename(v32, v33, v7);
    if (v35)
    {
      int v36 = *__error();
      uint64_t v37 = __error();
      strerror(*v37);
      BOMCopierErrorCapture(a3, v36, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6607, (uint64_t)"apply_retention_policy", "Could not rename staged %s to %s: %s", v32);
    }
  }
}

uint64_t set_timestamps(uint64_t a1, uint64_t a2, NSObject *a3, void *a4)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  long long v23 = 0uLL;
  if (BOMCopierSourceEntryGetModificationTime(a1, &v23))
  {
    uint64_t v8 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6638, (uint64_t)"set_timestamps", "Could not retrieve the entry modification time");
  }
  else
  {
    long long v22 = 0uLL;
    if (BOMCopierSourceEntryGetAccessTime(a1, &v22))
    {
      uint64_t v8 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6647, (uint64_t)"set_timestamps", "Could not retrieve the entry access time");
    }
    else
    {
      uint64_t v21 = 0;
      long long v20 = xmmword_210662CD0;
      uint64_t v11 = *((void *)&v23 + 1);
      uint64_t v10 = v23;
      long long v17 = v23;
      if (v22 != 0)
      {
        uint64_t v11 = *((void *)&v22 + 1);
        uint64_t v10 = v22;
      }
      uint64_t v18 = v10;
      uint64_t v19 = v11;
      if (!setattrlist(*(const char **)(a2 + 120), &v20, &v17, 0x20uLL, 1u))
      {
        if (a3)
        {
          uint64_t v8 = 0;
          if (!os_log_type_enabled(a3, OS_LOG_TYPE_DEFAULT)) {
            return v8;
          }
          uint64_t v16 = *(void *)(a2 + 120);
          *(_DWORD *)statfs buf = 134219010;
          uint64_t v25 = v17;
          __int16 v26 = 2048;
          uint64_t v27 = *((void *)&v17 + 1);
          __int16 v28 = 2048;
          uint64_t v29 = v18;
          __int16 v30 = 2048;
          uint64_t v31 = v19;
          __int16 v32 = 2080;
          uint64_t v33 = v16;
          _os_log_impl(&dword_2105F8000, a3, OS_LOG_TYPE_DEFAULT, "Set mtime [%ld.%ld] and atime [%ld.%ld] on %s", buf, 0x34u);
        }
        return 0;
      }
      int v12 = *__error();
      int v13 = *(const char **)(a2 + 120);
      int v14 = __error();
      int v15 = strerror(*v14);
      BOMCopierErrorCapture(a4, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDestination.c", 6677, (uint64_t)"set_timestamps", "Could not setattrlist timestamps for %s: %s", v13, v15);
      return 1;
    }
  }
  return v8;
}

uint64_t change_flags(const char *a1, int a2, __uint32_t a3)
{
  v6[0] = a2;
  v6[1] = a3;
  v6[2] = -1;
  uint64_t result = fsctl(a1, 0xC00C4114uLL, v6, 0);
  if (result)
  {
    if (*__error() == 25 || *__error() == 45)
    {
      uint64_t result = chflags(a1, a3);
      if (result) {
        return *__error() != 45;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void *data_read_stream_new(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0;
  }
  uint64_t result = platform_calloc(a1, 1uLL, 0x68uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 1919246692;
    result[1] = a1;
    *((_DWORD *)result + 25) = 1684104557;
  }
  return result;
}

void data_read_stream_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1919246692 && *((_DWORD *)__b + 25) == 1684104557)
  {
    uint64_t v2 = (bz_stream *)*((void *)__b + 11);
    if (v2)
    {
      BZ2_bzDecompressEnd(v2);
      platform_free(*((void *)__b + 1), *((void **)__b + 11));
    }
    unint64_t v3 = (z_stream *)*((void *)__b + 10);
    if (v3)
    {
      inflateEnd(v3);
      platform_free(*((void *)__b + 1), *((void **)__b + 10));
    }
    unint64_t v4 = (void *)*((void *)__b + 8);
    if (v4) {
      platform_free(*((void *)__b + 1), v4);
    }
    uint64_t v5 = (void *)*((void *)__b + 4);
    if (v5) {
      platform_free(*((void *)__b + 1), v5);
    }
    uint64_t v6 = *((void *)__b + 1);
    platform_memset(v6, __b, 0, 0x68uLL);
    platform_free(v6, __b);
  }
}

uint64_t data_read_stream_set_source(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1919246692) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && *(_DWORD *)(a1 + 100) == 1684104557)
  {
    *(void *)(a1 + 16) = a2;
    unsigned int v4 = getpagesize();
    if (v4 <= 0xE) {
      int v5 = 14;
    }
    else {
      int v5 = v4;
    }
    *(void *)(a1 + 24) = v5;
    uint64_t v6 = platform_valloc(*(void *)(a1 + 8), v5);
    *(void *)(a1 + 32) = v6;
    if (v6)
    {
      unint64_t v7 = resilient_source_read(*(void *)(a1 + 16), v6, 0xEuLL);
      if (v7 != -1)
      {
        *(void *)(a1 + 40) = v7;
        if ((uint64_t)v7 < 1) {
          goto LABEL_42;
        }
        uint64_t v8 = *(unsigned __int8 **)(a1 + 32);
        if (v7 < 0xA)
        {
          if (v7 < 7) {
            goto LABEL_42;
          }
          int v9 = *v8;
LABEL_36:
          if (v9 == 24 && v8[1] == 77 && v8[2] == 34 && v8[3] == 4)
          {
            int v14 = 3;
            goto LABEL_41;
          }
LABEL_42:
          if (*(_DWORD *)(a1 + 72))
          {
            *(void *)(a1 + 56) = 0x20000;
            uint64_t v19 = platform_valloc(*(void *)(a1 + 8), 0x20000uLL);
            *(void *)(a1 + 64) = v19;
            if (!v19)
            {
              unint64_t v24 = (FILE *)*MEMORY[0x263EF8348];
              uint64_t v25 = __error();
              __int16 v30 = strerror(*v25);
              long long v23 = "Could not allocate read buffer: %s\n";
              goto LABEL_51;
            }
            int v20 = *(_DWORD *)(a1 + 72);
            if (v20 == 2)
            {
              uint64_t v27 = (bz_stream *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x50uLL);
              *(void *)(a1 + 88) = v27;
              if (v27)
              {
                uint64_t result = BZ2_bzDecompressInit(v27, 0, 0);
                if (!result) {
                  return result;
                }
                long long v22 = (FILE *)*MEMORY[0x263EF8348];
                __int16 v30 = (char *)result;
                long long v23 = "Could not BZ2_bzDecompressInit: %d\n";
                goto LABEL_55;
              }
              unint64_t v24 = (FILE *)*MEMORY[0x263EF8348];
              uint64_t v29 = __error();
              __int16 v30 = strerror(*v29);
              long long v23 = "Could not allocate bzip2 stream: %s\n";
LABEL_51:
              __int16 v26 = v24;
LABEL_56:
              fprintf(v26, v23, v30);
              fwrite("Could not initialize decompression\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
              return 0xFFFFFFFFLL;
            }
            if (v20 == 1)
            {
              uint64_t v21 = (z_stream *)platform_calloc(*(void *)(a1 + 8), 1uLL, 0x70uLL);
              *(void *)(a1 + 80) = v21;
              if (v21)
              {
                uint64_t result = inflateInit2_(v21, 31, "1.2.12", 112);
                if (!result) {
                  return result;
                }
                long long v22 = (FILE *)*MEMORY[0x263EF8348];
                __int16 v30 = (char *)result;
                long long v23 = "Could not inflateInit2: %d\n";
LABEL_55:
                __int16 v26 = v22;
                goto LABEL_56;
              }
              unint64_t v24 = (FILE *)*MEMORY[0x263EF8348];
              __int16 v28 = __error();
              __int16 v30 = strerror(*v28);
              long long v23 = "Could not allocate zlib stream: %s\n";
              goto LABEL_51;
            }
          }
          return 0;
        }
        int v9 = *v8;
        if (v9 == 31 && v8[1] == 139 && v8[2] == 8)
        {
          int v14 = 1;
        }
        else
        {
          if (v7 < 0xE || v9 != 66) {
            goto LABEL_36;
          }
          if (v8[1] != 90 || v8[2] != 104 || v8[3] - 49 > 8) {
            goto LABEL_42;
          }
          if (*((_DWORD *)v8 + 1) != 643383601 || *((_WORD *)v8 + 4) != 22867)
          {
            int v16 = *((_DWORD *)v8 + 1);
            int v17 = *((unsigned __int16 *)v8 + 4);
            if (v16 != 944075287 || v17 != 36944) {
              goto LABEL_42;
            }
          }
          int v14 = 2;
        }
LABEL_41:
        *(_DWORD *)(a1 + 72) = v14;
        goto LABEL_42;
      }
      int v12 = (FILE *)*MEMORY[0x263EF8348];
      int v13 = __error();
      strerror(*v13);
      fprintf(v12, "Could not read minimal data for auto-detection: %s\n");
    }
    else
    {
      uint64_t v10 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v11 = __error();
      strerror(*v11);
      fprintf(v10, "Could not allocate discovery buffer: %s\n");
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

ssize_t resilient_source_read(uint64_t a1, void *a2, size_t a3)
{
  do
    ssize_t v6 = data_source_read(a1, a2, a3);
  while (v6 == -1 && *__error() == 35);
  return v6;
}

uint64_t data_stream_read(uint64_t a1, char *__dst, size_t a3)
{
  if (!a1 || *(_DWORD *)a1 != 1919246692) {
    return -1;
  }
  uint64_t result = -1;
  if (__dst && *(_DWORD *)(a1 + 100) == 1684104557)
  {
    if (a3)
    {
      if (*(_DWORD *)(a1 + 72))
      {
        while (1)
        {
          uint64_t result = read_from_source((uint64_t *)a1, *(char **)(a1 + 64), *(void *)(a1 + 56), a3);
          if (result == -1) {
            break;
          }
          uint64_t v7 = result;
          int v8 = *(_DWORD *)(a1 + 72);
          if (v8 == 2)
          {
            int v12 = *(bz_stream **)(a1 + 88);
            v12->next_in = *(char **)(a1 + 64);
            v12->avail_in = v7;
            v12->next_uuid_t out = __dst;
            v12->uInt avail_out = a3;
            int v13 = BZ2_bzDecompress(v12);
            if (v13)
            {
              if (v13 != 4)
              {
                fprintf((FILE *)*MEMORY[0x263EF8348], "Could not BZ2_bzDecompress: %d\n");
                return -1;
              }
              *(unsigned char *)(a1 + 96) = 1;
            }
            uint64_t v11 = *(void *)(a1 + 88);
          }
          else
          {
            if (v8 != 1) {
              return -1;
            }
            int v9 = *(z_stream **)(a1 + 80);
            v9->next_in = *(Bytef **)(a1 + 64);
            v9->avail_in = v7;
            v9->next_uuid_t out = (Bytef *)__dst;
            v9->uInt avail_out = a3;
            int v10 = inflate(v9, 0);
            if (v10)
            {
              if (v10 != 1)
              {
                fprintf((FILE *)*MEMORY[0x263EF8348], "Could not inflate: %d\n");
                return -1;
              }
              *(unsigned char *)(a1 + 96) = 1;
            }
            uint64_t v11 = *(void *)(a1 + 80);
          }
          uint64_t v14 = *(unsigned int *)(v11 + 32);
          uint64_t result = a3 - v14;
          if (v7 >= 1 && a3 == v14)
          {
            uint64_t result = 0;
            if (!*(unsigned char *)(a1 + 96)) {
              continue;
            }
          }
          return result;
        }
      }
      else
      {
        return read_from_source((uint64_t *)a1, __dst, a3, a3);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

size_t read_from_source(uint64_t *a1, char *__dst, size_t a3, size_t a4)
{
  unsigned int v4 = __dst;
  if (a4 >= a3) {
    size_t v6 = a3;
  }
  else {
    size_t v6 = a4;
  }
  unint64_t v8 = a1[5];
  unint64_t v7 = a1[6];
  BOOL v9 = v8 > v7;
  size_t v10 = v8 - v7;
  if (v9)
  {
    if (v6 >= v10) {
      size_t v11 = v10;
    }
    else {
      size_t v11 = v6;
    }
    memcpy(__dst, (const void *)(a1[4] + v7), v11);
    a1[6] += v11;
    v4 += v11;
    v6 -= v11;
    if (v6) {
      goto LABEL_12;
    }
  }
  else
  {
    size_t v11 = 0;
    if (v6)
    {
LABEL_12:
      uint64_t v12 = 0;
      do
      {
        ssize_t v13 = resilient_source_read(a1[2], v4, v6 - v12);
        if (v13 == -1)
        {
          if (*__error() != 35)
          {
            uint64_t v14 = (FILE *)*MEMORY[0x263EF8348];
            int v15 = __error();
            int v16 = strerror(*v15);
            fprintf(v14, "Could not read %ld bytes from source: %s\n", v6 - v12, v16);
            return -1;
          }
        }
        else
        {
          if (!v13) {
            return v11;
          }
          v4 += v13;
          v12 += v13;
          v11 += v13;
        }
      }
      while (v12 != v6);
    }
  }
  return v11;
}

uint64_t BOMBomHLIndexNew(uint64_t a1)
{
  uint64_t v2 = BOM_malloczero(0x20uLL);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    *uint64_t v2 = a1;
    unsigned int v4 = BOMTreeNewWithName(a1, "HLIndex");
    *(void *)(v3 + 8) = v4;
    if (!v4
      || (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], 0),
          (*(void *)(v3 + 16) = Mutable) == 0))
    {
      BOMBomHLIndexFree(v3);
      return 0;
    }
  }
  return v3;
}

uint64_t BOMBomHLIndexFree(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 24) && BOMBomHLIndexCommit(a1)) {
    return 1;
  }
  CFDictionaryRef v2 = *(const __CFDictionary **)(a1 + 16);
  if (v2)
  {
    LODWORD(v3) = CFDictionaryGetCount(v2);
    size_t v4 = 8 * v3;
    int v5 = (const void **)BOM_malloc(v4);
    if (v5)
    {
      size_t v6 = v5;
      unint64_t v7 = (const void **)BOM_malloc(v4);
      if (v7)
      {
        unint64_t v8 = (uint64_t *)v7;
        CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v6, v7);
        uint64_t v3 = v3;
        if (v3)
        {
          BOOL v9 = v8;
          do
          {
            uint64_t v10 = *v9++;
            BOMTreeFree(v10);
            --v3;
          }
          while (v3);
        }
        free(v6);
        free(v8);
        CFRelease(*(CFTypeRef *)(a1 + 16));
        goto LABEL_10;
      }
    }
    return 1;
  }
LABEL_10:
  uint64_t v11 = *(void *)(a1 + 8);
  if (v11) {
    BOMTreeFree(v11);
  }
  free((void *)a1);
  return 0;
}

uint64_t BOMBomHLIndexOpen(uint64_t a1, int a2)
{
  size_t v4 = BOM_malloczero(0x20uLL);
  uint64_t v5 = (uint64_t)v4;
  if (v4)
  {
    *size_t v4 = a1;
    uint64_t v6 = BOMTreeOpenWithName(a1, "HLIndex", a2);
    *(void *)(v5 + 8) = v6;
    if (!v6
      || a2
      && (CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], 0),
          (*(void *)(v5 + 16) = Mutable) == 0))
    {
      BOMBomHLIndexFree(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t BOMBomHLIndexCommit(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    return 0;
  }
  CFDictionaryRef v2 = *(const __CFDictionary **)(a1 + 16);
  if (!v2) {
    goto LABEL_10;
  }
  unsigned int Count = CFDictionaryGetCount(v2);
  size_t v4 = 8 * Count;
  uint64_t v5 = (const void **)BOM_malloc(v4);
  if (v5)
  {
    uint64_t v6 = v5;
    unint64_t v7 = (const void **)BOM_malloc(v4);
    if (v7)
    {
      unint64_t v8 = v7;
      CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 16), v6, v7);
      uint64_t v9 = Count;
      if (Count)
      {
        unint64_t v10 = 0;
        uint64_t v11 = 8 * v9;
        while (!BOMTreeCommit((uint64_t)v8[v10 / 8]))
        {
          v10 += 8;
          if (v11 == v10) {
            goto LABEL_9;
          }
        }
        free(v6);
        free(v8);
        return 1;
      }
LABEL_9:
      free(v6);
      free(v8);
LABEL_10:
      uint64_t result = BOMTreeCommit(*(void *)(a1 + 8));
      if (!result)
      {
        *(unsigned char *)(a1 + 24) = 0;
        return result;
      }
    }
  }
  return 1;
}

uint64_t BOMBomHLIndexCount(uint64_t a1, unsigned int a2)
{
  char v5 = 0;
  if (!a1) {
    return 0;
  }
  if (a2)
  {
    uint64_t TreeFor = _hl_findTreeFor(a1, a2, &v5);
    if (TreeFor) {
      goto LABEL_4;
    }
    return 0;
  }
  uint64_t TreeFor = *(const void **)(a1 + 8);
  if (!TreeFor) {
    return 0;
  }
LABEL_4:
  uint64_t v3 = BOMTreeCount((uint64_t)TreeFor);
  if (v5) {
    BOMTreeFree((uint64_t)TreeFor);
  }
  return v3;
}

const void *_hl_findTreeFor(uint64_t a1, unsigned int a2, char *a3)
{
  unsigned int v4 = a2;
  unsigned int valuePtr = a2;
  int IsOpenForWriting = BOMStorageIsOpenForWriting(*(void *)a1);
  if (*(void *)(a1 + 16))
  {
    CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
    if (!v7) {
      return 0;
    }
    CFNumberRef v8 = v7;
    CFDictionaryRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), v7);
    CFRelease(v8);
    if (Value) {
      return Value;
    }
    unsigned int v4 = valuePtr;
  }
  unsigned int valuePtr = bswap32(v4);
  uint64_t v10 = *(void *)a1;
  uint64_t v11 = *(void **)(a1 + 8);
  uint64_t v12 = (unsigned int *)BOMTreeGetValue((uint64_t)v11, &valuePtr, 4uLL);
  if (v12)
  {
    unsigned int v13 = *v12;
    unsigned int v14 = bswap32(*v12);
    unsigned int v21 = v14;
    if (!v13) {
      return 0;
    }
    CFDictionaryRef Value = (const void *)BOMTreeOpen(v10, v14, IsOpenForWriting);
    if (!Value)
    {
LABEL_18:
      if (a3)
      {
        char v19 = 1;
        goto LABEL_20;
      }
      return Value;
    }
  }
  else
  {
    if (!IsOpenForWriting) {
      return 0;
    }
    unsigned int v15 = BOMStorageNewBlock(v10);
    if (!v15) {
      return 0;
    }
    unsigned int v16 = v15;
    CFDictionaryRef Value = BOMTreeNewWithOptions(v10, v15, 0, 0x40u, 0);
    if (!Value) {
      goto LABEL_18;
    }
    unsigned int v21 = bswap32(v16);
    BOMTreeSetValue(v11, &valuePtr, 4uLL, (uint64_t)&v21, 4);
  }
  if (!*(void *)(a1 + 16)) {
    goto LABEL_18;
  }
  unsigned int valuePtr = bswap32(valuePtr);
  CFNumberRef v17 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
  if (!v17) {
    return 0;
  }
  CFNumberRef v18 = v17;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), v17, Value);
  CFRelease(v18);
  if (a3)
  {
    char v19 = 0;
LABEL_20:
    *a3 = v19;
  }
  return Value;
}

uint64_t BOMBomHLIndexBlock(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 0;
  }
  unsigned int v2 = a2;
  if (BOMTreeCount(*(void *)(a1 + 8)) <= a2) {
    return 0;
  }
  unsigned int v4 = (char *)BOMTreeIteratorNew(*(void *)(a1 + 8), 0, 0, 0);
  if (!v4) {
    return 0;
  }
  for (uint64_t i = v4; v2; --v2)
    BOMTreeIteratorNext((uint64_t)i);
  uint64_t v6 = (unsigned int *)BOMTreeIteratorKey((uint64_t)i);
  if (v6) {
    uint64_t v7 = bswap32(*v6);
  }
  else {
    uint64_t v7 = 0;
  }
  BOMTreeIteratorFree(i);
  return v7;
}

uint64_t BOMBomHLIndexGet(uint64_t a1, unsigned int a2, unsigned int a3, void *a4, size_t *a5)
{
  uint64_t v5 = 0;
  char v15 = 0;
  uint64_t v6 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a5)
      {
        uint64_t TreeFor = _hl_findTreeFor(a1, a2, &v15);
        uint64_t v5 = (uint64_t)TreeFor;
        if (TreeFor)
        {
          if (BOMTreeCount((uint64_t)TreeFor) > a3)
          {
            uint64_t v11 = (char *)BOMTreeIteratorNew(v5, 0, 0, 0);
            if (v11)
            {
              for (uint64_t i = v11; a3; --a3)
                BOMTreeIteratorNext((uint64_t)i);
              *a5 = BOMTreeIteratorKeySize((uint64_t)i);
              unsigned int v13 = (const void *)BOMTreeIteratorKey((uint64_t)i);
              memmove(a4, v13, *a5);
              BOMTreeIteratorFree(i);
              uint64_t v6 = 0;
            }
          }
        }
      }
    }
  }
  if (v15) {
    BOMTreeFree(v5);
  }
  return v6;
}

uint64_t BOMBomHLIndexSet(uint64_t a1, unsigned int a2, const void *a3, size_t a4)
{
  uint64_t v4 = 0;
  char v12 = 0;
  uint64_t v5 = 1;
  if (a1)
  {
    if (a2)
    {
      if (a4)
      {
        uint64_t TreeFor = _hl_findTreeFor(a1, a2, &v12);
        uint64_t v4 = (uint64_t)TreeFor;
        if (TreeFor)
        {
          uint64_t v10 = BOMTreeSetValue(TreeFor, a3, a4, 0, 0);
          *(unsigned char *)(a1 + 24) = 1;
          uint64_t v5 = v10;
        }
      }
    }
  }
  if (v12) {
    BOMTreeFree(v4);
  }
  return v5;
}

uint64_t BOMBomHLIndexRemove(uint64_t a1, unsigned int a2, const void *a3, size_t a4)
{
  unsigned int valuePtr = a2;
  char v14 = 0;
  uint64_t v4 = 1;
  if (!a1 || !a2) {
    return v4;
  }
  uint64_t TreeFor = _hl_findTreeFor(a1, a2, &v14);
  uint64_t v9 = (uint64_t)TreeFor;
  if (TreeFor)
  {
    if (a3)
    {
      uint64_t v4 = BOMTreeRemoveValue((uint64_t)TreeFor, a3, a4);
    }
    else
    {
      CFNumberRef v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
      if (!v10) {
        goto LABEL_11;
      }
      CFNumberRef v11 = v10;
      char v12 = *(__CFDictionary **)(a1 + 16);
      if (v12) {
        CFDictionaryRemoveValue(v12, v11);
      }
      CFRelease(v11);
      BOMTreeRemoveAndFree(v9);
      uint64_t v4 = 0;
    }
    *(unsigned char *)(a1 + 24) = 1;
  }
LABEL_11:
  if (v14) {
    BOMTreeFree(v9);
  }
  return v4;
}

uint64_t _BOMBomHLIndexPrintDiagnostics(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 8);
    unsigned int v2 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "Tree: %s\n", "HLIndex");
    uint64_t result = (uint64_t)BOMTreeIteratorNew(v1, 0, 0, 0);
    if (result)
    {
      uint64_t v3 = result;
      int v4 = 0;
      if (BOMTreeIteratorIsAtEnd(result))
      {
LABEL_4:
        fprintf(*v2, "   # records: %d\n", v4);
        fprintf(*v2, "   # pages  : %d (%d)\n", 0, 0);
        fprintf(*v2, "     leaf   : %d (%d)\n", 0, 0);
        fprintf(*v2, "     branch : %d (%d)\n", 0, 0);
        fprintf(*v2, "   key size : %zd\n", 0);
        return fprintf(*v2, "   data size: %zd\n", 0);
      }
      else
      {
        while (1)
        {
          uint64_t result = BOMTreeIteratorValue(v3);
          if (!result) {
            break;
          }
          if (!*(_DWORD *)result) {
            break;
          }
          unsigned int v5 = bswap32(*(_DWORD *)result);
          uint64_t v6 = BOMTreeStorage(v1);
          uint64_t result = BOMTreeOpen(v6, v5, 0);
          if (!result) {
            break;
          }
          uint64_t v7 = result;
          v4 += BOMTreeCount(result);
          BOMTreeFree(v7);
          BOMTreeIteratorNext(v3);
          if (BOMTreeIteratorIsAtEnd(v3)) {
            goto LABEL_4;
          }
        }
      }
    }
  }
  return result;
}

uint64_t _BOMBomPrint(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  RootFSObject = (unsigned int *)BOMBomGetRootFSObject(a1);
  uint64_t v3 = BOMBomEnumeratorNew(a1, RootFSObject);
  BOMFSObjectFree((uint64_t)RootFSObject);
  if (!v3) {
    return 1;
  }
  int v4 = BOMBomEnumeratorNext((uint64_t)v3);
  if (v4)
  {
    unsigned int v5 = v4;
    uint64_t v6 = (FILE **)MEMORY[0x263EF8348];
    do
    {
      uint64_t v7 = (const char *)BOMFSObjectPathName((uint64_t)v5);
      int v8 = BOMFSObjectPathID((uint64_t)v5);
      int v9 = BOMFSObjectParentPathID((uint64_t)v5);
      fprintf(*v6, "%d\t%d\t%s\n", v9, v8, v7);
      BOMFSObjectFree((uint64_t)v5);
      unsigned int v5 = BOMBomEnumeratorNext((uint64_t)v3);
    }
    while (v5);
  }
  BOMBomEnumeratorFree(v3);
  return 0;
}

uint64_t _BOMBomPathTreePrint(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t v1 = BOMBomPathsTree(a1);
  if (!v1) {
    return 1;
  }
  uint64_t v2 = v1;
  size_t v15 = 0;
  uint64_t v3 = BOMNewPathKey(0, "", &v15);
  if (!v3) {
    return 1;
  }
  int v4 = v3;
  unsigned int v5 = (char *)BOMTreeIteratorNew(v2, v3, v15, 0);
  free(v4);
  if (!v5) {
    return 1;
  }
  if (!BOMTreeIteratorIsAtEnd((uint64_t)v5))
  {
    uint64_t v6 = (FILE **)MEMORY[0x263EF8348];
    do
    {
      uint64_t v7 = (unsigned int *)BOMTreeIteratorKey((uint64_t)v5);
      int v8 = (unsigned int *)BOMTreeIteratorValue((uint64_t)v5);
      int v9 = *v6;
      unsigned int v10 = BOMPathIDFromPathKey(v7);
      CFNumberRef v11 = (const char *)BOMShortNameFromPathKey((uint64_t)v7);
      unsigned int v12 = BOMPathIDFromPathKey(v8);
      int v13 = BOMBlockIDFromPathValue((uint64_t)v8);
      fprintf(v9, "%d\t%s -> %d\t%d\n", v10, v11, v12, v13);
      BOMTreeIteratorNext((uint64_t)v5);
    }
    while (!BOMTreeIteratorIsAtEnd((uint64_t)v5));
  }
  BOMTreeIteratorFree(v5);
  return 0;
}

uint64_t _BOMCFArrayPrint(const __CFArray *a1)
{
  if (!a1) {
    return 1;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(a1))
  {
    int Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      CFIndex v4 = 0;
      uint64_t v5 = Count;
      uint64_t v6 = (FILE **)MEMORY[0x263EF8348];
      do
      {
        uint64_t v7 = *v6;
        ValueAtIndex = (const char *)CFArrayGetValueAtIndex(a1, v4);
        fprintf(v7, "%d\t%s\n", v4++, ValueAtIndex);
      }
      while (v5 != v4);
    }
    return 0;
  }
  else
  {
    uint64_t v9 = 1;
    fwrite("[not an array]\n", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v9;
}

uint64_t BOMCopierNew()
{
  return BOMCopierNewWithSys(0);
}

uint64_t BOMCopierNewWithSys(void *a1)
{
  uint64_t v2 = BOM_malloczero(0x3308uLL);
  uint64_t v3 = (uint64_t)v2;
  if (v2)
  {
    *((_DWORD *)v2 + 4) = 0x20000;
    if (vm_allocate(*MEMORY[0x263EF8960], (vm_address_t *)v2 + 1, 0x20000uLL, 1))
    {
      BOMCopierFree(v3);
      return 0;
    }
    else
    {
      *(void *)(v3 + 24) = 4096;
      uint64_t v5 = malloc_type_calloc(1uLL, 0x1000uLL, 0x18A1ECF8uLL);
      *(void *)(v3 + 32) = v5;
      if (v5)
      {
        *(_DWORD *)(v3 + 10568) = getpid();
        *(unsigned char *)(v3 + 2304) = 0;
        *(unsigned char *)(v3 + 6400) = 0;
        *(_DWORD *)(v3 + 12792) = -1;
        uint64_t v6 = BOMHardLinkTableNew();
        *(void *)uint64_t v3 = v6;
        if (v6)
        {
          uint64_t v7 = BOMStackNew();
          *(void *)(v3 + 40) = v7;
          if (v7)
          {
            if (!a1) {
              a1 = BomSys_default();
            }
            *(void *)(v3 + 12832) = a1;
          }
        }
      }
    }
  }
  return v3;
}

void BOMCopierFree(uint64_t a1)
{
  if (a1)
  {
    _resetCopier(a1);
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      MEMORY[0x21666D800](*MEMORY[0x263EF8960], v2, *(int *)(a1 + 16));
      *(void *)(a1 + 8) = 0;
    }
    uint64_t v3 = *(void **)(a1 + 32);
    if (v3)
    {
      free(v3);
      *(void *)(a1 + 32) = 0;
    }
    if (*(void *)a1)
    {
      BOMHardLinkTableFree(*(const void ***)a1);
      *(void *)a1 = 0;
    }
    uint64_t v4 = *(void *)(a1 + 40);
    if (v4)
    {
      while (!BOMStackIsEmpty(v4))
      {
        uint64_t v5 = (void **)BOMStackPop(*(uint64_t **)(a1 + 40));
        free(*v5);
        free(v5[1]);
        free(v5[2]);
        free(v5);
        uint64_t v4 = *(void *)(a1 + 40);
      }
      BOMStackFree(*(void ***)(a1 + 40));
    }
    free((void *)a1);
  }
}

void _resetCopier(uint64_t a1)
{
  if (a1)
  {
    uint64_t v3 = (void *)(a1 + 216);
    uint64_t v2 = *(void **)(a1 + 216);
    if (v2)
    {
      free(v2);
      void *v3 = 0;
      v3[1] = 0;
    }
    uint64_t v4 = *(void **)(a1 + 12928);
    if (v4)
    {
      free(v4);
      *(void *)(a1 + 12928) = 0;
    }
    uint64_t v5 = *(void **)(a1 + 12920);
    if (v5)
    {
      free(v5);
      *(void *)(a1 + 12920) = 0;
    }
    uint64_t v6 = *(void **)(a1 + 12936);
    if (v6)
    {
      free(v6);
      *(void *)(a1 + 12936) = 0;
    }
    uint64_t v7 = *(void **)(a1 + 10584);
    if (v7)
    {
      free(v7);
      *(void *)(a1 + 10584) = 0;
    }
    int v8 = *(void **)(a1 + 12912);
    if (v8)
    {
      free(v8);
      *(void *)(a1 + 12912) = 0;
    }
    uint64_t v9 = *(void **)(a1 + 12904);
    if (v9)
    {
      free(v9);
      *(void *)(a1 + 12904) = 0;
    }
    unsigned int v10 = *(void **)(a1 + 12896);
    if (v10)
    {
      free(v10);
      *(void *)(a1 + 12896) = 0;
    }
    uint64_t v11 = *(void *)(a1 + 152);
    if (v11)
    {
      BOMBomFree(v11);
      *(void *)(a1 + 152) = 0;
    }
    uint64_t v12 = *(void *)(a1 + 160);
    if (v12)
    {
      BOMBomFree(v12);
      *(void *)(a1 + 160) = 0;
    }
    char v14 = (void *)(a1 + 176);
    uint64_t v13 = *(void *)(a1 + 176);
    if (v13)
    {
      BOMFileClose(v13);
      *char v14 = 0;
    }
    size_t v15 = *(void **)(a1 + 184);
    if (v15)
    {
      BOMPatternFree(v15);
      *(void *)(a1 + 184) = 0;
    }
    unsigned int v16 = *(uint64_t **)(a1 + 12736);
    if (v16)
    {
      BOMCPIOFree(v16);
      *(void *)(a1 + 12736) = 0;
    }
    CFNumberRef v17 = *(void **)(a1 + 12760);
    if (v17)
    {
      BOMPKZipFree(v17);
      *(void *)(a1 + 12760) = 0;
    }
    if (*(void *)(a1 + 12840)) {
      BOMCopierSandbox_unbox(a1);
    }
    CFNumberRef v18 = *(void **)(a1 + 136);
    if (v18)
    {
      unint64_t v19 = *(unsigned int *)(a1 + 144);
      if (v19)
      {
        unint64_t v20 = 0;
        uint64_t v21 = 16;
        do
        {
          long long v22 = *(void **)(*(void *)(a1 + 136) + v21);
          if (v22)
          {
            free(v22);
            unint64_t v19 = *(unsigned int *)(a1 + 144);
          }
          ++v20;
          v21 += 32;
        }
        while (v20 < v19);
        CFNumberRef v18 = *(void **)(a1 + 136);
      }
      free(v18);
      *(void *)(a1 + 136) = 0;
    }
    uint64_t v23 = *(void *)(a1 + 152);
    if (v23)
    {
      BOMBomFree(v23);
      *(void *)(a1 + 152) = 0;
    }
    uint64_t v24 = *(void *)(a1 + 160);
    if (v24)
    {
      BOMBomFree(v24);
      *(void *)(a1 + 160) = 0;
    }
    uint64_t v25 = *(void **)(a1 + 184);
    if (v25)
    {
      BOMPatternFree(v25);
      *(void *)(a1 + 184) = 0;
    }
    __int16 v26 = *(void **)(a1 + 12800);
    if (v26)
    {
      free(v26);
      *(void *)(a1 + 12800) = 0;
    }
    *(_DWORD *)(a1 + 10564) = 0;
    uint64_t v27 = *(const void **)(a1 + 12856);
    if (v27)
    {
      CFRelease(v27);
      *(void *)(a1 + 12856) = 0;
    }
    bzero((void *)(a1 + 248), 0x400uLL);
    bzero((void *)(a1 + 1272), 0x400uLL);
    *(void *)(a1 + 2296) = 0;
    bzero((void *)(a1 + 2304), 0x400uLL);
    bzero((void *)(a1 + 3328), 0x400uLL);
    bzero((void *)(a1 + 4352), 0x400uLL);
    bzero((void *)(a1 + 5376), 0x400uLL);
    bzero((void *)(a1 + 6400), 0x400uLL);
    bzero((void *)(a1 + 7424), 0x400uLL);
    bzero((void *)(a1 + 8448), 0x400uLL);
    *(_DWORD *)(a1 + 144) = 0;
    *(_DWORD *)(a1 + 168) = 0;
    *(_WORD *)(a1 + 172) = 0;
    *(void *)(a1 + 12712) = 0x300000000;
    *(unsigned char *)(a1 + 12720) = 0;
    *(_WORD *)(a1 + 12768) = 256;
    *char v14 = 0;
    *(void *)(a1 + 184) = 0;
    *(_WORD *)(a1 + 192) = 1;
    *(_DWORD *)(a1 + 232) = 0;
    *(_WORD *)(a1 + 12813) = 257;
    *(_WORD *)(a1 + 12744) = 0;
    *(unsigned char *)(a1 + 12746) = 0;
    *(_DWORD *)(a1 + 12816) = 2;
    *(_WORD *)(a1 + 12822) = 0;
    *(unsigned char *)(a1 + 12824) = 0;
    *(void *)(a1 + 12960) = 0;
    *(void *)(a1 + 12976) = 0;
    *(void *)(a1 + 12984) = -1;
    *(_DWORD *)(a1 + 212) = -1;
    __int16 v28 = *(unsigned int **)(a1 + 13032);
    if (v28)
    {
      BOMCopierDestinationFree(v28);
      *(void *)(a1 + 13032) = 0;
    }
    uint64_t v29 = *(const void **)(a1 + 13008);
    if (v29)
    {
      CFRelease(v29);
      *(void *)(a1 + 13008) = 0;
    }
    __int16 v30 = *(void **)(a1 + 13016);
    if (v30)
    {
      BOMCopierSourceFree(v30);
      *(void *)(a1 + 13016) = 0;
      uint64_t v31 = *(const void **)(a1 + 13008);
      if (v31)
      {
        CFRelease(v31);
        *(void *)(a1 + 13008) = 0;
      }
    }
  }
}

uint64_t BOMCopierCopy(uint64_t a1, char *a2, char *a3)
{
  return BOMCopierCopyWithOptions(a1, a2, a3, 0);
}

uint64_t BOMCopierCopyWithOptions(uint64_t a1, char *a2, char *a3, const void *a4)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    uint64_t v22 = 1;
    fwrite("Invalid BOMCopier\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    return v22;
  }
  _resetCopier(a1);
  *__error() = 0;
  int v8 = getenv("DITTO2");
  if (v8)
  {
    if (strcmp(v8, "1"))
    {
      if (!a4) {
        goto LABEL_17;
      }
      goto LABEL_5;
    }
  }
  else
  {
    if (!a4) {
      goto LABEL_17;
    }
    CFTypeID TypeID = CFDictionaryGetTypeID();
    if (TypeID != CFGetTypeID(a4)) {
      goto LABEL_20;
    }
    CFDictionaryRef Value = CFDictionaryGetValue((CFDictionaryRef)a4, @"DITTO2");
    if (!Value
      || (uint64_t v25 = Value, v26 = CFBooleanGetTypeID(), v26 != CFGetTypeID(v25))
      || !CFEqual(v25, (CFTypeRef)*MEMORY[0x263EFFB40]))
    {
LABEL_5:
      CFTypeID v14 = CFDictionaryGetTypeID();
      if (v14 == CFGetTypeID(a4))
      {
        if (_parseCopierOptions(a1, (const __CFDictionary *)a4))
        {
          BOMCopierNotifyFatalError(a1, "Could not parse the options dictionary", v21, v9, v10, v11, v12, v13, v56);
LABEL_19:
          _resetCopier(a1);
          return 1;
        }
LABEL_17:
        if (_verifyCopierOptions(a1, (uint64_t)a2, (uint64_t)a3, v9, v10, v11, v12, v13)
          || _prepareCopierState(a1))
        {
          goto LABEL_19;
        }
        int v34 = *(_DWORD *)(a1 + 12712);
        if (v34)
        {
          int v35 = *(_DWORD *)(a1 + 12964);
          *(_DWORD *)(a1 + 12992) = v35;
          if (!*(unsigned char *)(a1 + 12813))
          {
            v35 |= 0x10u;
            *(_DWORD *)(a1 + 12992) = v35;
          }
          if (v34 == 1)
          {
            int v36 = getenv("BOM_ASYNC");
            if (!v36 || strcmp("0", v36))
            {
              v35 |= 0x20u;
              *(_DWORD *)(a1 + 12992) = v35;
            }
          }
          if (a2)
          {
            int v37 = strcmp("-", a2);
            int v38 = (void *)(a1 + 12976);
            if (v37)
            {
              if (!BOMFileOpenWithSys(v38, (uint64_t)a2, 0, 0, v35, *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))goto LABEL_51; {
              goto LABEL_43;
              }
            }
            if (BOMFileOpenSTDIN(v38, v35))
            {
LABEL_43:
              AAFieldKey v45 = __error();
              unsigned int v41 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
              if (!v41) {
                goto LABEL_19;
              }
              uint64_t v42 = *v45;
              uint64_t v43 = a1;
              int v44 = a2;
              goto LABEL_45;
            }
          }
          else
          {
            uint64_t v39 = *(unsigned int *)(a1 + 12984);
            if (v39 == -1)
            {
              uint64_t v46 = *(const void **)(a1 + 12944);
              if (v46 && BOMFileNewFromCFReadStream((void *)(a1 + 12976), v46, v35))
              {
                int v47 = __error();
                unsigned int v41 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
                if (!v41) {
                  goto LABEL_19;
                }
                uint64_t v42 = *v47;
                int v44 = "CFReadStream";
                uint64_t v43 = a1;
                goto LABEL_45;
              }
            }
            else if (BOMFileNewFromFDWithSys((void *)(a1 + 12976), v39, v35, "rb", *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
            {
              int v40 = __error();
              unsigned int v41 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
              if (!v41) {
                goto LABEL_19;
              }
              uint64_t v42 = *v40;
              uint64_t v43 = a1;
              int v44 = 0;
LABEL_45:
              v41(v43, v44, v42);
              goto LABEL_19;
            }
          }
        }
        else
        {
          if (!a2)
          {
            BOMCopierNotifyFatalError(a1, "If the source is a filesystem, the fromObj argument cannot be nil", v28, v29, v30, v31, v32, v33, v56);
            _resetCopier(a1);
            goto LABEL_19;
          }
          if (*(unsigned char *)(a1 + 12968))
          {
            uint64_t v28 = *(void *)(a1 + 152);
            if (v28) {
              BOMCopierSandbox_boxup(a1, a2, v28);
            }
          }
        }
LABEL_51:
        if (*(_DWORD *)(a1 + 12712)
          || (unsigned char *)(*(uint64_t (**)(void, char *, unsigned char *))(*(void *)(a1 + 12832) + 160))(*(void *)(*(void *)(a1 + 12832) + 8), a2, v57) == v57)
        {
          if (!_prepareCopierDestination(a1, a3, v28, v29, v30, v31, v32, v33))
          {
            uint64_t v22 = 1;
            switch(*(_DWORD *)(a1 + 12712))
            {
              case 0:
                uint64_t v55 = _BOMCopierCopyFromFilesystem(a1, a2, a3);
                goto LABEL_59;
              case 1:
                uint64_t v55 = _BOMCopierCopyFromCPIO(a1, *(void *)(a1 + 12976), a3, v50, v51, v52, v53, v54);
                goto LABEL_59;
              case 2:
                uint64_t v55 = _BOMCopierCopyFromPKZip(a1, *(void *)(a1 + 12976), a3, v50, v51, v52, v53, v54);
LABEL_59:
                uint64_t v22 = v55;
                if (!v55) {
                  goto LABEL_60;
                }
                goto LABEL_61;
              case 3:
                goto LABEL_61;
              default:
LABEL_60:
                uint64_t v22 = _finalizeCopierDestination(a1, v48, v49, v50, v51, v52, v53, v54);
LABEL_61:
                _resetCopier(a1);
                break;
            }
            return v22;
          }
        }
        else
        {
          BOMCopierNotifyFatalError(a1, "Cannot get the real path for source '%s'", v28, v29, v30, v31, v32, v33, (char)a2);
        }
        goto LABEL_19;
      }
LABEL_20:
      BOMCopierNotifyFatalError(a1, "The options dictionary is not a CFDictionary", v15, v16, v17, v18, v19, v20, v56);
      return 1;
    }
  }
  return BOMCopierCopyWithOptions2(a1, a2, a3, a4);
}

void BOMCopierNotifyFatalError(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a1 && *(void *)(a1 + 56))
  {
    CFTypeID v14 = 0;
    if (vasprintf(&v14, a2, &a9) == -1)
    {
      uint64_t v10 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v11 = __error();
      strerror(*v11);
      fprintf(v10, "Could not create fatal message: %s\n");
    }
    else if (v14)
    {
      (*(void (**)(uint64_t))(a1 + 56))(a1);
      free(v14);
    }
    else
    {
      uint64_t v12 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v13 = __error();
      strerror(*v13);
      fprintf(v12, "Could not allocate fatal message: %s\n");
    }
  }
}

uint64_t _parseCopierOptions(uint64_t a1, const __CFDictionary *a2)
{
  CFTypeID TypeID = CFArrayGetTypeID();
  CFTypeID v5 = CFDictionaryGetTypeID();
  CFTypeID v6 = CFStringGetTypeID();
  CFTypeID v7 = CFBooleanGetTypeID();
  CFTypeID v8 = CFNumberGetTypeID();
  CFTypeID v9 = CFDataGetTypeID();
  CFDictionaryRef Value = CFDictionaryGetValue(a2, @"archs");
  *(void *)(a1 + 12880) = Value;
  if (Value && CFGetTypeID(Value) != TypeID)
  {
    size_t v66 = "kBOMCopierOptionArchitectureArrayKey is not a CFArrayRef";
    goto LABEL_269;
  }
  uint64_t v17 = CFDictionaryGetValue(a2, @"fallbackForSubtype");
  *(void *)(a1 + 12888) = v17;
  if (v17 && CFGetTypeID(v17) != v5)
  {
    size_t v66 = "kBOMCopierOptionArchitectureFallbackKey is not a CFDictionaryRef";
    goto LABEL_269;
  }
  CFStringRef v18 = (const __CFString *)CFDictionaryGetValue(a2, @"indexbom");
  if (v18)
  {
    CFStringRef v19 = v18;
    if (CFGetTypeID(v18) != v6)
    {
      size_t v66 = "kBOMCopierOptionIndexBomKey is not a CFStringRef";
      goto LABEL_269;
    }
    CFStringRef UTF8String = BOMCFStringGetUTF8String(v19);
    *(void *)(a1 + 12896) = UTF8String;
    if (!UTF8String)
    {
      size_t v66 = "Cannot convert indexbom from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  CFBooleanRef v21 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"verifyFileDataPerIndexBom");
  if (v21)
  {
    CFBooleanRef v22 = v21;
    if (CFGetTypeID(v21) != v7)
    {
      size_t v66 = "kBOMCopierOptionVerifyFileDataPerIndexBomKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 197) = BOMCFGetBoolValue(v22);
  }
  CFStringRef v23 = (const __CFString *)CFDictionaryGetValue(a2, @"skipbom");
  if (v23)
  {
    CFStringRef v24 = v23;
    if (CFGetTypeID(v23) != v6)
    {
      size_t v66 = "kBOMCopierOptionSkipBomKey is not a CFStringRef";
      goto LABEL_269;
    }
    CFStringRef v25 = BOMCFStringGetUTF8String(v24);
    *(void *)(a1 + 12904) = v25;
    if (!v25)
    {
      size_t v66 = "Cannot convert skipbom from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  CFBooleanRef v26 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"sourceIsAppSandboxed");
  if (v26)
  {
    CFBooleanRef v27 = v26;
    if (CFGetTypeID(v26) != v7)
    {
      size_t v66 = "kBOMCopierOptionSourceIsAppSandboxed is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12968) = BOMCFGetBoolValue(v27);
  }
  CFBooleanRef v28 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"useHFSPlusCompression");
  if (v28)
  {
    CFBooleanRef v29 = v28;
    if (CFGetTypeID(v28) != v7)
    {
      size_t v66 = "kBOMCopierOptionUseHFSPlusCompressionKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12848) = BOMCFGetBoolValue(v29);
  }
  CFBooleanRef v30 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"preserveHFSPlusCompression");
  if (v30)
  {
    CFBooleanRef v31 = v30;
    if (CFGetTypeID(v30) != v7)
    {
      size_t v66 = "kBOMCopierOptionPreserveHFSPlusCompressionKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 195) = BOMCFGetBoolValue(v31);
  }
  uint64_t v32 = CFDictionaryGetValue(a2, @"hfsPlusCompressionOptions");
  if (v32)
  {
    uint64_t v33 = v32;
    if (CFGetTypeID(v32) != v5)
    {
      size_t v66 = "kBOMCopierOptionHFSPlusCompressionOptionsDictionaryKey is not a CFDictionaryRef";
      goto LABEL_269;
    }
    *(void *)(a1 + 12856) = v33;
    CFRetain(v33);
  }
  CFBooleanRef v34 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"copyResources");
  if (v34)
  {
    CFBooleanRef v35 = v34;
    if (CFGetTypeID(v34) != v7)
    {
      size_t v66 = "kBOMCopierOptionCopyResourcesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 169) = BOMCFGetBoolValue(v35);
  }
  CFBooleanRef v36 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"copyExtendedAttributes");
  if (v36)
  {
    CFBooleanRef v37 = v36;
    if (CFGetTypeID(v36) != v7)
    {
      size_t v66 = "kBOMCopierOptionCopyExtendedAttributesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 170) = BOMCFGetBoolValue(v37);
  }
  CFBooleanRef v38 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"copyACLs");
  if (v38)
  {
    CFBooleanRef v39 = v38;
    if (CFGetTypeID(v38) != v7)
    {
      size_t v66 = "kBOMCopierOptionCopyACLsKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 171) = BOMCFGetBoolValue(v39);
  }
  CFBooleanRef v40 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"applySourcePermissions");
  if (v40)
  {
    CFBooleanRef v41 = v40;
    if (CFGetTypeID(v40) != v7)
    {
      size_t v66 = "kBOMCopierOptionApplySourcePermissionsKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12822) = BOMCFGetBoolValue(v41);
  }
  CFBooleanRef v42 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"nonatomicCopy");
  if (v42)
  {
    CFBooleanRef v43 = v42;
    if (CFGetTypeID(v42) != v7)
    {
      size_t v66 = "kBOMCopierOptionNonAtomicCopyKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12823) = BOMCFGetBoolValue(v43);
  }
  CFBooleanRef v44 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"segmentLargeFiles");
  if (v44)
  {
    CFBooleanRef v45 = v44;
    if (CFGetTypeID(v44) != v7)
    {
      size_t v66 = "kBOMCopierOptionSegmentLargeFilesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12824) = BOMCFGetBoolValue(v45);
  }
  CFBooleanRef v46 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"keepBinaries");
  if (v46)
  {
    CFBooleanRef v47 = v46;
    if (CFGetTypeID(v46) != v7)
    {
      size_t v66 = "kBOMCopierOptionKeepBinariesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 173) = BOMCFGetBoolValue(v47);
  }
  CFStringRef v48 = (const __CFString *)CFDictionaryGetValue(a2, @"keepBinariesList");
  if (v48)
  {
    CFStringRef v49 = v48;
    if (CFGetTypeID(v48) != v6)
    {
      size_t v66 = "kBOMCopierOptionKeepBinariesListKey is not a CFStringRef";
      goto LABEL_269;
    }
    CFStringRef v50 = BOMCFStringGetUTF8String(v49);
    *(void *)(a1 + 12920) = v50;
    if (!v50)
    {
      size_t v66 = "Cannot convert kBOMCopierOptionKeepBinariesListKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  CFStringRef v51 = (const __CFString *)CFDictionaryGetValue(a2, @"keepBinariesPattern");
  if (v51)
  {
    CFStringRef v52 = v51;
    if (CFGetTypeID(v51) != v6)
    {
      size_t v66 = "kBOMCopierOptionKeepBinariesPatternKey is not a CFStringRef";
      goto LABEL_269;
    }
    CFStringRef v53 = BOMCFStringGetUTF8String(v52);
    *(void *)(a1 + 12928) = v53;
    if (!v53)
    {
      size_t v66 = "Cannot convert kBOMCopierOptionKeepBinariesPatternKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  CFStringRef v54 = (const __CFString *)CFDictionaryGetValue(a2, @"keepBinariesDir");
  if (v54)
  {
    CFStringRef v55 = v54;
    if (CFGetTypeID(v54) != v6)
    {
      size_t v66 = "kBOMCopierOptionKeepBinariesDirKey is not a CFStringRef";
      goto LABEL_269;
    }
    CFStringRef v56 = BOMCFStringGetUTF8String(v55);
    *(void *)(a1 + 12936) = v56;
    if (!v56)
    {
      size_t v66 = "Cannot convert kBOMCopierOptionKeepBinariesDirKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  CFBooleanRef v57 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"crossDevices");
  if (v57)
  {
    CFBooleanRef v58 = v57;
    if (CFGetTypeID(v57) != v7)
    {
      size_t v66 = "kBOMCopierOptionCrossDevicesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 192) = BOMCFGetBoolValue(v58);
  }
  uint64_t v59 = CFDictionaryGetValue(a2, @"createCPIO");
  if (v59)
  {
    int v60 = v59;
    if (CFGetTypeID(v59) != v7)
    {
      size_t v66 = "kBOMCopierOptionCreateCPIOKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v60, (CFTypeRef)*MEMORY[0x263EFFB40])) {
      *(_DWORD *)(a1 + 12716) = 4;
    }
  }
  uint64_t v61 = CFDictionaryGetValue(a2, @"extractCPIO");
  if (v61)
  {
    uint64_t v62 = v61;
    if (CFGetTypeID(v61) != v7)
    {
      size_t v66 = "kBOMCopierOptionExtractCPIOKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v62, (CFTypeRef)*MEMORY[0x263EFFB40])) {
      *(_DWORD *)(a1 + 12712) = 1;
    }
  }
  unint64_t v63 = CFDictionaryGetValue(a2, @"compressCPIO");
  if (v63 || (unint64_t v63 = CFDictionaryGetValue(a2, @"compress")) != 0)
  {
    CFTypeRef cf1 = v63;
    if (CFGetTypeID(v63) == v6)
    {
      if (!CFEqual(cf1, @"auto"))
      {
        if (CFEqual(cf1, @"none"))
        {
          char v64 = 0;
          int v65 = 0;
LABEL_103:
          *(unsigned char *)(a1 + 12720) = v64;
          *(_DWORD *)(a1 + 12964) = v65;
          goto LABEL_104;
        }
        if (CFEqual(cf1, @"gzip"))
        {
          char v64 = 1;
          int v65 = 1;
          goto LABEL_103;
        }
        if (!CFEqual(cf1, @"bzip2"))
        {
          size_t v66 = "Unknown compression type";
          goto LABEL_269;
        }
        int v65 = 2;
LABEL_102:
        char v64 = 1;
        goto LABEL_103;
      }
    }
    else if (!CFEqual(cf1, (CFTypeRef)*MEMORY[0x263EFFB40]))
    {
      goto LABEL_104;
    }
    int v65 = 8;
    goto LABEL_102;
  }
LABEL_104:
  CFBooleanRef v67 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"applyIndexBomOwnership");
  if (v67)
  {
    CFBooleanRef v68 = v67;
    if (CFGetTypeID(v67) != v7)
    {
      size_t v66 = "kBOMCopierOptionApplyIndexBomOwnershipKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12746) = BOMCFGetBoolValue(v68);
  }
  unint64_t v69 = CFDictionaryGetValue(a2, @"createPKZip");
  if (v69)
  {
    uint64_t v70 = v69;
    if (CFGetTypeID(v69) != v7)
    {
      size_t v66 = "kBOMCopierOptionCreatePKZipKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v70, (CFTypeRef)*MEMORY[0x263EFFB40])) {
      *(_DWORD *)(a1 + 12716) = 5;
    }
  }
  size_t v71 = CFDictionaryGetValue(a2, @"extractPKZip");
  if (v71)
  {
    uint64_t v72 = v71;
    if (CFGetTypeID(v71) != v7)
    {
      size_t v66 = "kBOMCopierOptionExtractPKZipKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v72, (CFTypeRef)*MEMORY[0x263EFFB40]))
    {
      *(_DWORD *)(a1 + 12712) = 2;
      *(unsigned char *)(a1 + 12768) = *(unsigned char *)(a1 + 169);
    }
  }
  uint64_t v73 = CFDictionaryGetValue(a2, @"extractAppleArchive");
  if (v73)
  {
    ssize_t v74 = v73;
    if (CFGetTypeID(v73) != v7)
    {
      size_t v66 = "kBOMCopierOptionExtractAppleArchiveKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v74, (CFTypeRef)*MEMORY[0x263EFFB40])) {
      *(_DWORD *)(a1 + 12712) = 3;
    }
  }
  char v75 = CFDictionaryGetValue(a2, @"createAppleArchive");
  if (v75)
  {
    int v76 = v75;
    if (CFGetTypeID(v75) != v7)
    {
      size_t v66 = "kBOMCopierOptionCreateAppleArchiveKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    if (CFEqual(v76, (CFTypeRef)*MEMORY[0x263EFFB40])) {
      *(_DWORD *)(a1 + 12716) = 6;
    }
  }
  CFNumberRef v77 = (const __CFNumber *)CFDictionaryGetValue(a2, @"zlibCompressionLevel");
  if (v77)
  {
    CFNumberRef v78 = v77;
    if (CFGetTypeID(v77) != v8)
    {
      size_t v66 = "kBOMCopierOptionZlibCompressionLevel is not a CFNumberRef";
      goto LABEL_269;
    }
    CFNumberGetValue(v78, kCFNumberSInt32Type, (void *)(a1 + 12792));
  }
  CFBooleanRef v79 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"sequesterResources");
  if (v79)
  {
    CFBooleanRef v80 = v79;
    if (CFGetTypeID(v79) != v7)
    {
      size_t v66 = "kBOMCopierOptionSequesterResourcesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    unsigned __int8 v81 = BOMCFGetBoolValue(v80);
    *(unsigned char *)(a1 + 12768) = v81;
    *(unsigned char *)(a1 + 169) = v81;
  }
  CFBooleanRef v82 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"skipCPIOTerminator");
  if (v82)
  {
    CFBooleanRef v83 = v82;
    if (CFGetTypeID(v82) != v7)
    {
      size_t v66 = "kBOMCopierOptionSkipCPIOTerminatorKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12744) = BOMCFGetBoolValue(v83);
  }
  CFBooleanRef v84 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"skipCPIORoot");
  if (v84)
  {
    CFBooleanRef v85 = v84;
    if (CFGetTypeID(v84) != v7)
    {
      size_t v66 = "kBOMCopierOptionSkipCPIORootKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12745) = BOMCFGetBoolValue(v85);
  }
  CFNumberRef v86 = (const __CFNumber *)CFDictionaryGetValue(a2, @"initialCPIOInode");
  if (v86)
  {
    CFNumberRef v87 = v86;
    if (CFGetTypeID(v86) != v8)
    {
      size_t v66 = "kBOMCopierOptionInitialCPIOInodeRootKey is not a CFNumberRef";
      goto LABEL_269;
    }
    CFNumberGetValue(v87, kCFNumberSInt32Type, (void *)(a1 + 12960));
  }
  CFBooleanRef v88 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"keepParent");
  if (v88)
  {
    CFBooleanRef v89 = v88;
    if (CFGetTypeID(v88) != v7)
    {
      size_t v66 = "kBOMCopierOptionKeepParentKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 193) = BOMCFGetBoolValue(v89);
  }
  CFBooleanRef v90 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"useFilesystemCache");
  if (v90)
  {
    CFBooleanRef v91 = v90;
    if (CFGetTypeID(v90) != v7) {
      goto LABEL_186;
    }
    unsigned __int8 v92 = BOMCFGetBoolValue(v91);
    *(unsigned char *)(a1 + 12813) = v92;
    *(unsigned char *)(a1 + 12814) = v92;
  }
  CFDictionaryRef v93 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"sourceOptions");
  if (v93)
  {
    CFDictionaryRef v94 = v93;
    if (CFGetTypeID(v93) != v5)
    {
      size_t v66 = "kBOMCopierOptionSourceOptionsDictionaryKey is not a CFDictionaryRef";
      goto LABEL_269;
    }
    CFBooleanRef v95 = (const __CFBoolean *)CFDictionaryGetValue(v94, @"useFilesystemCache");
    if (v95)
    {
      CFBooleanRef v96 = v95;
      if (CFGetTypeID(v95) != v7) {
        goto LABEL_186;
      }
      *(unsigned char *)(a1 + 12813) = BOMCFGetBoolValue(v96);
    }
  }
  CFDictionaryRef v97 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"destinationOptions");
  if (!v97) {
    goto LABEL_154;
  }
  CFDictionaryRef v98 = v97;
  if (CFGetTypeID(v97) != v5)
  {
    size_t v66 = "kBOMCopierOptionDestinationOptionsDictionaryKey is not a CFDictionaryRef";
    goto LABEL_269;
  }
  CFBooleanRef v99 = (const __CFBoolean *)CFDictionaryGetValue(v98, @"useFilesystemCache");
  if (!v99) {
    goto LABEL_154;
  }
  CFBooleanRef v100 = v99;
  if (CFGetTypeID(v99) != v7)
  {
LABEL_186:
    size_t v66 = "kBOMCopierOptionUseFilesystemCacheKey is not a CFBooleanRef";
    goto LABEL_269;
  }
  *(unsigned char *)(a1 + 12814) = BOMCFGetBoolValue(v100);
LABEL_154:
  int v101 = CFDictionaryGetValue(a2, @"inputFD");
  if (v101)
  {
    int v102 = v101;
    if (CFGetTypeID(v101) != v8)
    {
      size_t v66 = "kBOMCopierOptionInputFileDescriptorKey is not a CFNumberRef";
      goto LABEL_269;
    }
    *(_DWORD *)(a1 + 12984) = BOMCFGetIntValue(v102);
  }
  size_t v103 = CFDictionaryGetValue(a2, @"outputFD");
  if (v103)
  {
    unint64_t v104 = v103;
    if (CFGetTypeID(v103) != v8)
    {
      size_t v66 = "kBOMCopierOptionOutputFileDescriptorKey is not a CFNumberRef";
      goto LABEL_269;
    }
    *(_DWORD *)(a1 + 12988) = BOMCFGetIntValue(v104);
  }
  uint64_t v105 = CFDictionaryGetValue(a2, @"inputStream");
  if (v105)
  {
    unint64_t v106 = v105;
    CFTypeID v107 = CFGetTypeID(v105);
    if (v107 != CFReadStreamGetTypeID())
    {
      size_t v66 = "kBOMCopierOptionInputCFReadStreamKey is not a CFReadStreamRef";
      goto LABEL_269;
    }
    *(void *)(a1 + 12944) = v106;
  }
  int v108 = CFDictionaryGetValue(a2, @"outputStream");
  if (v108)
  {
    uint64_t v109 = v108;
    CFTypeID v110 = CFGetTypeID(v108);
    if (v110 != CFWriteStreamGetTypeID())
    {
      size_t v66 = "kBOMCopierOptionOutputCFWriteStreamKey is not a CFWriteStreamRef";
      goto LABEL_269;
    }
    *(void *)(a1 + 12952) = v109;
  }
  long long v111 = CFDictionaryGetValue(a2, @"symlinkTreatment");
  if (v111)
  {
    int v112 = v111;
    if (CFGetTypeID(v111) != v6)
    {
      size_t v66 = "kBOMCopierOptionSymlinkTreatmentKey is not a CFStringRef";
      goto LABEL_269;
    }
    if (CFEqual(v112, @"unlink"))
    {
      int v113 = 0;
    }
    else if (CFEqual(v112, @"follow"))
    {
      int v113 = 1;
    }
    else
    {
      if (!CFEqual(v112, @"error"))
      {
        size_t v66 = "Unknown value for kBOMCopierOptionSymlinkTreatmentKey";
        goto LABEL_269;
      }
      int v113 = 2;
    }
    *(_DWORD *)(a1 + 12816) = v113;
  }
  CFBooleanRef v114 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"enforceDestinationEncapsulation");
  if (v114)
  {
    CFBooleanRef v115 = v114;
    if (CFGetTypeID(v114) != v7)
    {
      size_t v66 = "kBOMCopierOptionEnforceDestinationEncapsulationKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12820) = BOMCFGetBoolValue(v115);
  }
  CFBooleanRef v116 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"enforceDestinationLocation");
  if (v116)
  {
    CFBooleanRef v117 = v116;
    if (CFGetTypeID(v116) != v7)
    {
      size_t v66 = "kBOMCopierOptionEnforceDestinationLocationKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12821) = BOMCFGetBoolValue(v117);
  }
  CFStringRef v118 = (const __CFString *)CFDictionaryGetValue(a2, @"zipFileEncryptionKey");
  if (v118)
  {
    CFStringRef v119 = v118;
    if (CFGetTypeID(v118) != v6)
    {
      size_t v66 = "kBOMCopierOptionEncryptionKey is not a CFStringRef";
      goto LABEL_269;
    }
    CFStringRef v120 = BOMCFStringGetUTF8String(v119);
    *(void *)(a1 + 12800) = v120;
    if (!v120)
    {
      size_t v66 = "Cannot convert kBOMCopierOptionEncryptionKey from options dictionary into UTF8 encoded C string";
      goto LABEL_269;
    }
  }
  CFBooleanRef v121 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"persistRestrictedFlags");
  if (v121)
  {
    CFBooleanRef v122 = v121;
    if (CFGetTypeID(v121) != v7)
    {
      size_t v66 = "kBOMCopierOptionPersistRestrictedFlagsKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12872) = BOMCFGetBoolValue(v122);
  }
  CFBooleanRef v123 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"preserveRestrictedFlags");
  if (v123)
  {
    CFBooleanRef v124 = v123;
    if (CFGetTypeID(v123) != v7)
    {
      size_t v66 = "kBOMCopierOptionPreserveRestrictedFlagsKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12873) = BOMCFGetBoolValue(v124);
  }
  CFBooleanRef v125 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"persistRootlessEAs");
  if (v125)
  {
    CFBooleanRef v126 = v125;
    if (CFGetTypeID(v125) != v7)
    {
      size_t v66 = "kBOMCopierOptionPersistRootlessExtendedAttributesKey is not a CFBooleanRef";
      goto LABEL_269;
    }
    *(unsigned char *)(a1 + 12874) = BOMCFGetBoolValue(v126);
  }
  if (getenv("PRESERVECOMPRESSION")) {
    *(unsigned char *)(a1 + 195) = 1;
  }
  if (CFDictionaryContainsKey(a2, @"output2Nowhere") == 1)
  {
    size_t v66 = "The legacy engine does not support the nowhere destination";
  }
  else
  {
    CFBooleanRef v127 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"cloneFiles");
    if (v127)
    {
      CFBooleanRef v128 = v127;
      if (CFGetTypeID(v127) != v7)
      {
        size_t v66 = "kBOMCopierOptionCloneFilesKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(unsigned char *)(a1 + 204) = BOMCFGetBoolValue(v128);
    }
    CFBooleanRef v129 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"removeSetuidPermissions");
    if (v129)
    {
      CFBooleanRef v130 = v129;
      if (CFGetTypeID(v129) != v7)
      {
        size_t v66 = "kBOMCopierOptionRemoveSetuidPermissionsKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(unsigned char *)(a1 + 205) = BOMCFGetBoolValue(v130);
    }
    CFBooleanRef v131 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"removeExecutablePermissions");
    if (v131)
    {
      CFBooleanRef v132 = v131;
      if (CFGetTypeID(v131) != v7)
      {
        size_t v66 = "kBOMCopierOptionRemoveExecutablePermissionsKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(unsigned char *)(a1 + 206) = BOMCFGetBoolValue(v132);
    }
    CFBooleanRef v133 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"setStaticContent");
    if (v133)
    {
      CFBooleanRef v134 = v133;
      if (CFGetTypeID(v133) != v7)
      {
        size_t v66 = "kBOMCopierOptionSetStaticContentKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(unsigned char *)(a1 + 207) = BOMCFGetBoolValue(v134);
    }
    CFBooleanRef v135 = (const __CFBoolean *)CFDictionaryGetValue(a2, @"setSingleWriter");
    if (v135)
    {
      CFBooleanRef v136 = v135;
      if (CFGetTypeID(v135) != v7)
      {
        size_t v66 = "kBOMCopierOptionSetSingleWriterKey is not a CFBooleanRef";
        goto LABEL_269;
      }
      *(unsigned char *)(a1 + 208) = BOMCFGetBoolValue(v136);
    }
    int v137 = CFDictionaryGetValue(a2, @"setDataProtectionClass");
    if (v137)
    {
      int v138 = v137;
      if (CFGetTypeID(v137) != v6)
      {
        size_t v66 = "kBOMCopierOptionSetDataProtectionClassKey must be a CFStringRef";
        goto LABEL_269;
      }
      int v139 = CFEqual(v138, @"A");
      int v140 = 1;
      if (v139 != 1)
      {
        if (CFEqual(v138, @"B") == 1)
        {
          int v140 = 2;
        }
        else if (CFEqual(v138, @"C") == 1)
        {
          int v140 = 3;
        }
        else
        {
          if (CFEqual(v138, @"D") != 1)
          {
            size_t v66 = "Unsupported data protection class";
            goto LABEL_269;
          }
          int v140 = 4;
        }
      }
      *(_DWORD *)(a1 + 212) = v140;
      *(unsigned char *)(a1 + 211) = 1;
    }
    uint64_t result = (uint64_t)CFDictionaryGetValue(a2, @"applyProvenance");
    if (!result) {
      return result;
    }
    CFDataRef v142 = (const __CFData *)result;
    if (CFGetTypeID((CFTypeRef)result) == v9)
    {
      size_t Length = CFDataGetLength(v142);
      if (Length)
      {
        size_t v144 = Length;
        int v145 = malloc_type_malloc(Length, 0xC3F1F04EuLL);
        if (v145)
        {
          int v146 = v145;
          BytePtr = CFDataGetBytePtr(v142);
          memcpy(v146, BytePtr, v144);
          uint64_t result = 0;
          *(void *)(a1 + 216) = v146;
          *(void *)(a1 + 224) = v144;
          return result;
        }
        size_t v66 = "Could not allocate provenance data buffer";
      }
      else
      {
        size_t v66 = "kBOMCopierOptionApplyProvenanceKey has an invalid size";
      }
    }
    else
    {
      size_t v66 = "kBOMCopierOptionApplyProvenanceKey must be a CFDataRef";
    }
  }
LABEL_269:
  BOMCopierNotifyFatalError(a1, v66, v11, v12, v13, v14, v15, v16, v148);
  return 1;
}

uint64_t _verifyCopierOptions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 12720) && *(_DWORD *)(a1 + 12712) != 1 && *(_DWORD *)(a1 + 12716) != 4)
  {
    uint64_t v11 = "Compression is only used for CPIO archives";
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 12744) && *(_DWORD *)(a1 + 12716) != 4)
  {
    uint64_t v11 = "SkipTerminator is only used for CPIO archives";
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 12745) && *(_DWORD *)(a1 + 12716) != 4)
  {
    uint64_t v11 = "SkipRoot is only used for CPIO archives";
    goto LABEL_23;
  }
  int v10 = *(_DWORD *)(a1 + 12712);
  if (v10 == 2 && *(_DWORD *)(a1 + 12716) != 3)
  {
    uint64_t v11 = "PKZip archives can only be extracted to filesystem destinations";
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 12768) && v10 != 2 && *(_DWORD *)(a1 + 12716) != 5)
  {
    uint64_t v11 = "sequesterResources is only for PKZip archives";
LABEL_23:
    BOMCopierNotifyFatalError(a1, v11, a3, a4, a5, a6, a7, a8, v21);
    return 1;
  }
  if ((*(_DWORD *)(a1 + 12792) - 10) <= 0xFFFFFFF4)
  {
    BOMCopierNotifyFatalError(a1, "%d is out of range for Zlib compression", a3, a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 12792));
    return 1;
  }
  if (v10 == 3 || (int v12 = *(_DWORD *)(a1 + 12716), v12 == 6))
  {
    uint64_t v11 = "The legacy engine does not support AppleArchive";
    goto LABEL_23;
  }
  if (v12 == 3 && *(unsigned char *)(a1 + 193))
  {
    uint64_t v11 = "keepParent is only for archives";
    goto LABEL_23;
  }
  int v14 = *(_DWORD *)(a1 + 12984);
  if (a2 && v14 != -1)
  {
    uint64_t v11 = "Cannot specify a fromObj with kBOMCopierOptionInputFileDescriptorKey";
    goto LABEL_23;
  }
  if (a3 && *(_DWORD *)(a1 + 12988) != -1)
  {
    uint64_t v11 = "Cannot specify a toObj with kBOMCopierOptionOutputFileDescriptorKey";
    goto LABEL_23;
  }
  uint64_t v15 = *(__CFReadStream **)(a1 + 12944);
  if (v15)
  {
    if (!a2 && v14 == -1)
    {
      for (int i = 30; ; --i)
      {
        CFStreamStatus Status = CFReadStreamGetStatus(v15);
        if (Status != kCFStreamStatusOpening) {
          break;
        }
        if (!i)
        {
          uint64_t v11 = "Timed out waiting for the read stream to open";
          goto LABEL_23;
        }
        timespec __rqtp = (timespec)xmmword_210662D70;
        nanosleep(&__rqtp, 0);
        uint64_t v15 = *(__CFReadStream **)(a1 + 12944);
      }
      if (Status == kCFStreamStatusOpen) {
        goto LABEL_43;
      }
      BOMCopierNotifyFatalError(a1, "CFReadStream is not open: %u", a3, a4, a5, a6, a7, a8, Status);
      return 1;
    }
    uint64_t v11 = "Cannot specify fromObj or kBOMCopierOptionInputFileDescriptorKey with kBOMCopierOptionInputCFReadStreamKey";
    goto LABEL_23;
  }
LABEL_43:
  CFStringRef v18 = *(__CFWriteStream **)(a1 + 12952);
  if (v18)
  {
    if (!a3 && *(_DWORD *)(a1 + 12988) == -1)
    {
      for (int j = 30; ; --j)
      {
        CFStreamStatus v20 = CFWriteStreamGetStatus(v18);
        if (v20 != kCFStreamStatusOpening) {
          break;
        }
        if (!j)
        {
          uint64_t v11 = "Timed out waiting for the write stream to open";
          goto LABEL_23;
        }
        timespec __rqtp = (timespec)xmmword_210662D70;
        nanosleep(&__rqtp, 0);
        CFStringRef v18 = *(__CFWriteStream **)(a1 + 12952);
      }
      if (v20 == kCFStreamStatusOpen) {
        goto LABEL_54;
      }
      BOMCopierNotifyFatalError(a1, "CFWriteStream is not open: %u", a3, a4, a5, a6, a7, a8, v20);
      return 1;
    }
    uint64_t v11 = "Cannot specify toObj or kBOMCopierOptionOutputFileDescriptorKey with kBOMCopierOptionOutputCFWriteStreamKey";
    goto LABEL_23;
  }
LABEL_54:
  if (*(unsigned char *)(a1 + 204) == 1)
  {
    if (*(_DWORD *)(a1 + 12712))
    {
      uint64_t v11 = "kBOMCopierOptionCloneFiles requires the source to be a filesystem";
      goto LABEL_23;
    }
    if (*(_DWORD *)(a1 + 12716) != 3)
    {
      uint64_t v11 = "kBOMCopierOptionCloneFiles requires the destination to be a filesystem";
      goto LABEL_23;
    }
  }
  if (*(unsigned char *)(a1 + 207) == 1 && *(_DWORD *)(a1 + 12716) != 3)
  {
    uint64_t v11 = "setStaticContent is only for filesystem destinations";
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 208) == 1 && *(_DWORD *)(a1 + 12716) != 3)
  {
    uint64_t v11 = "setSingleWriter is only for filesystem destinations";
    goto LABEL_23;
  }
  if (*(void *)(a1 + 216))
  {
    if (!*(_DWORD *)(a1 + 12712))
    {
      uint64_t v11 = "applyProvenance is only for extracting from archives";
      goto LABEL_23;
    }
    if (*(_DWORD *)(a1 + 12716) != 3)
    {
      uint64_t v11 = "applyProvenance is only applicable when extracting from archives";
      goto LABEL_23;
    }
  }
  return 0;
}

uint64_t _prepareCopierState(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 12896);
  if (v2)
  {
    uint64_t v3 = BOMBomOpenWithSys(v2, 0, *(void **)(a1 + 12832));
    *(void *)(a1 + 152) = v3;
    if (!v3)
    {
      uint64_t v33 = *(void *)(a1 + 12896);
LABEL_27:
      char v54 = v33;
      int v12 = "Cannot open BOM at '%s'";
      goto LABEL_28;
    }
  }
  CFStringRef v56 = 0;
  CFArrayRef v10 = *(const __CFArray **)(a1 + 12880);
  if (v10)
  {
    uint64_t v11 = _parse_arch_list(a1, v10, *(const __CFDictionary **)(a1 + 12888), (_DWORD *)(a1 + 144), &v56);
    *(void *)(a1 + 136) = v11;
    if (!v11)
    {
      int v12 = "Could not parse the Mach-O architectures to copy";
LABEL_28:
      BOMCopierNotifyFatalError(a1, v12, v4, v5, v6, v7, v8, v9, v54);
      return 1;
    }
  }
  else if (!*(void *)(a1 + 136))
  {
    goto LABEL_10;
  }
  uint64_t v13 = *(uint64_t **)(a1 + 152);
  if (v13)
  {
    int v14 = BOMBomNewFromBomWithOptions(0, v13, 1, (const char **)v56, 0);
    if (!v14)
    {
      BOMCopierNotifyFatalError(a1, "Cannot thin the index bom", v15, v16, v17, v18, v19, v20, v54);
      if (v56)
      {
        CFBooleanRef v34 = *(void **)v56;
        if (*(void *)v56)
        {
          uint64_t v35 = 8;
          do
          {
            free(v34);
            CFBooleanRef v34 = *(void **)((char *)v56 + v35);
            v35 += 8;
          }
          while (v34);
        }
      }
      return 1;
    }
    char v21 = v14;
    BOMBomFree(*(void *)(a1 + 152));
    *(void *)(a1 + 152) = v21;
  }
LABEL_10:
  CFBooleanRef v22 = v56;
  if (v56)
  {
    CFStringRef v23 = *(void **)v56;
    if (*(void *)v56)
    {
      uint64_t v24 = 0;
      do
      {
        free(v23);
        *(void *)((char *)v56 + v24) = 0;
        CFBooleanRef v22 = v56;
        CFStringRef v23 = *(void **)((char *)v56 + v24 + 8);
        v24 += 8;
      }
      while (v23);
    }
    free(v22);
  }
  CFStringRef v25 = *(char **)(a1 + 12904);
  if (v25)
  {
    CFBooleanRef v26 = BOMBomOpenWithSys(v25, 0, *(void **)(a1 + 12832));
    *(void *)(a1 + 160) = v26;
    if (!v26)
    {
      uint64_t v33 = *(void *)(a1 + 12904);
      goto LABEL_27;
    }
  }
  if (*(void *)(a1 + 12920))
  {
    if (_mkdirs_parent(a1))
    {
      BOMCopierNotifyFatalError(a1, "Cannot create parent directory for %s", v27, v28, v29, v30, v31, v32, *(void *)(a1 + 12920));
      return 1;
    }
    uint64_t v55 = 0;
    if (BOMFileOpenWithSys(&v55, *(void *)(a1 + 12920), 1545, 420, 0, *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
    {
      uint64_t v37 = *(void *)(a1 + 12920);
      CFBooleanRef v38 = __error();
      strerror(*v38);
      BOMCopierNotifyFatalError(a1, "Cannot open file %s for writing: %s", v39, v40, v41, v42, v43, v44, v37);
      return 1;
    }
    *(void *)(a1 + 176) = v55;
  }
  CFBooleanRef v45 = *(const char **)(a1 + 12928);
  if (v45)
  {
    CFBooleanRef v46 = BOMPatternCompileString(v45);
    *(void *)(a1 + 184) = v46;
    if (!v46)
    {
      BOMCopierNotifyFatalError(a1, "Cannot compile \"%s\" as a regular expression pattern", v47, v48, v49, v50, v51, v52, *(void *)(a1 + 12928));
      return 1;
    }
  }
  uid_t v53 = geteuid();
  *(_DWORD *)(a1 + 10496) = v53;
  if (v53 && _initGroupList(a1)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 195) && (*(_DWORD *)(a1 + 12716) != 3 || !*(unsigned char *)(a1 + 170) && !*(unsigned char *)(a1 + 169))) {
    *(unsigned char *)(a1 + 195) = 0;
  }
  while (!BOMStackIsEmpty(*(void *)(a1 + 40)))
    BOMStackPop(*(uint64_t **)(a1 + 40));
  return 0;
}

uint64_t _prepareCopierDestination(uint64_t a1, char *__s1, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = *(_DWORD *)(a1 + 12716);
  if (v10 != 3)
  {
    uint64_t v45 = 0;
    int v19 = *(_DWORD *)(a1 + 12964);
    *(_DWORD *)(a1 + 12992) = v19;
    if (!*(unsigned char *)(a1 + 12814))
    {
      v19 |= 0x10u;
      *(_DWORD *)(a1 + 12992) = v19;
    }
    if (v10 == 4)
    {
      uint64_t v20 = getenv("BOM_ASYNC");
      if (v20)
      {
        if (strcmp("0", v20))
        {
          v19 |= 0x20u;
          *(_DWORD *)(a1 + 12992) = v19;
        }
      }
    }
    if (__s1)
    {
      if (!strcmp(__s1, "-"))
      {
        if (BOMFileOpenSTDOUT(&v45, v19))
        {
          CFBooleanRef v26 = __error();
          CFStringRef v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
          if (!v23) {
            return 1;
          }
          uint64_t v24 = *v26;
          uint64_t v27 = a1;
          CFStringRef v25 = 0;
LABEL_34:
          v23(v27, v25, v24);
          return 1;
        }
      }
      else
      {
        if (_mkdirs_parent(a1))
        {
          LOBYTE(v44) = (_BYTE)__s1;
LABEL_16:
          BOMCopierNotifyFatalError(a1, "Cannot create parent directory for %s", v13, v14, v15, v16, v17, v18, v44);
          return 1;
        }
        if (BOMFileOpenWithSys(&v45, (uint64_t)__s1, 1537, 420, *(_DWORD *)(a1 + 12992), *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
        {
          uint64_t v28 = __error();
          CFStringRef v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
          if (!v23) {
            return 1;
          }
          uint64_t v24 = *v28;
          uint64_t v27 = a1;
          CFStringRef v25 = __s1;
          goto LABEL_34;
        }
      }
LABEL_37:
      if (*(_DWORD *)(a1 + 12716) == 4)
      {
        if (!BOMCPIONew((uint64_t **)(a1 + 12736), v45, 1, *(_DWORD *)(a1 + 12960))) {
          return 0;
        }
        BOMFileClose(v45);
        BOMCopierNotifyFatalError(a1, "Cannot create CPIO file at %s", v31, v32, v33, v34, v35, v36, v45);
      }
      else
      {
        if (!BOMPKZipNew((void *)(a1 + 12760), v45, 1)) {
          return 0;
        }
        BOMFileClose(v45);
        BOMCopierNotifyFatalError(a1, "Cannot create PKZip file at %s", v37, v38, v39, v40, v41, v42, v45);
      }
      return 1;
    }
    uint64_t v21 = *(unsigned int *)(a1 + 12988);
    if (v21 == -1)
    {
      uint64_t v29 = *(const void **)(a1 + 12952);
      if (!v29 || !BOMFileNewFromCFWriteStream(&v45, v29, v19)) {
        goto LABEL_37;
      }
      uint64_t v30 = __error();
      CFStringRef v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (!v23) {
        return 1;
      }
      uint64_t v24 = *v30;
      CFStringRef v25 = "wstream";
    }
    else
    {
      if (!BOMFileNewFromFDWithSys(&v45, v21, v19, "wb", *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))goto LABEL_37; {
      CFBooleanRef v22 = __error();
      }
      CFStringRef v23 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (!v23) {
        return 1;
      }
      uint64_t v24 = *v22;
      CFStringRef v25 = "fdesc";
    }
    uint64_t v27 = a1;
    goto LABEL_34;
  }
  if (__s1)
  {
    uint64_t v11 = *(void *)(a1 + 12936);
    if (v11)
    {
      uint64_t result = _mkdirs(a1, v11);
      if (!result) {
        return result;
      }
      uint64_t v44 = *(void *)(a1 + 12936);
      goto LABEL_16;
    }
    return 0;
  }
  BOMCopierNotifyFatalError(a1, "If the destination is a filesystem, the toObj argument cannot be nil", a3, a4, a5, a6, a7, a8, v43);
  _resetCopier(a1);
  return 1;
}

uint64_t _BOMCopierCopyFromFilesystem(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v83 = *MEMORY[0x263EF8340];
  long long v63 = 0uLL;
  long long v62 = 0uLL;
  char v61 = 0;
  if (!a2 || !*a2 || *(_DWORD *)(a1 + 12716) == 3 && (!a3 || !*a3)) {
    return 1;
  }
  *(unsigned char *)(a1 + 168) = 0;
  *(unsigned char *)(a1 + 11616) = 0;
  *(unsigned char *)(a1 + 12641) = 0;
  uint64_t v6 = *(void *)(a1 + 152);
  if (v6)
  {
    unsigned int v13 = BOMBomPathIDForKey(v6, 0, ".");
    if (!v13)
    {
      uint64_t v14 = "Can't find . in bom file";
LABEL_12:
      BOMCopierNotifyFatalError(a1, v14, v7, v8, v9, v10, v11, v12, v60);
      return 1;
    }
  }
  else
  {
    unsigned int v13 = 0;
  }
  if (strlen(a2) >= 0x3FF)
  {
    char v60 = (char)a2;
    uint64_t v14 = "source path ('%s') too long [%lu >= %lu]!";
    goto LABEL_12;
  }
  long long v79 = 0u;
  long long v80 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v74 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  memset(v73, 0, sizeof(v73));
  __strlcpy_chk();
  if ((*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 160))(*(void *)(*(void *)(a1 + 12832) + 8), __s, a1 + 248) != a1 + 248)goto LABEL_14; {
  if ((*(unsigned int (**)(void, uint64_t, void *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 248, v73))
  }
  {
LABEL_18:
    uint64_t v20 = __error();
    uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
    if (!v16) {
      return 1;
    }
    uint64_t v17 = *v20;
    uint64_t v19 = a1;
    uint64_t v18 = (char *)(a1 + 248);
LABEL_20:
    v16(v19, v18, v17);
    return 1;
  }
  int v22 = WORD2(v73[0]) & 0xF000;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  if (*(_DWORD *)(a1 + 12716) == 3)
  {
    if (strlen(a3) >= 0x3FF)
    {
      BOMCopierNotifyFatalError(a1, "destination path ('%s') too long [%lu >= %lu]!", v23, v24, v25, v26, v27, v28, (char)a3);
      return 1;
    }
    __strlcpy_chk();
    int v31 = (*(uint64_t (**)(void, char *, long long *))(*(void *)(a1 + 12832) + 80))(*(void *)(*(void *)(a1 + 12832) + 8), __s, &v64);
    int v30 = *__error();
    if (v31 && v30 != 2 && v30 != 63) {
      goto LABEL_14;
    }
    if (v31) {
      BOOL v32 = v22 == 0x4000;
    }
    else {
      BOOL v32 = (WORD2(v64) & 0xF000) == 0x4000;
    }
    if (!v31 && v22 != 0x4000 && v32)
    {
      strrchr((char *)(a1 + 248), 47);
      __strlcat_chk();
      __strlcat_chk();
      int v31 = (*(uint64_t (**)(void, char *, long long *))(*(void *)(a1 + 12832) + 80))(*(void *)(*(void *)(a1 + 12832) + 8), __s, &v64);
      if (v31) {
        BOOL v32 = v22 == 0x4000;
      }
      else {
        BOOL v32 = (WORD2(v64) & 0xF000) == 0x4000;
      }
    }
    if (v22 == 0x4000 && !v31 && !v32)
    {
      BOMCopierNotifyFatalError(a1, "Can't copy directory %s into a file %s.", v37, v38, v39, v40, v41, v42, a1 - 8);
      return 1;
    }
    if (!v31 && v73[1] == *((void *)&v64 + 1) && LODWORD(v73[0]) == v64)
    {
      BOMCopierNotifyFatalError(a1, "%s and %s are identical (not copied).", v37, v38, v39, v40, v41, v42, a1 - 8);
      return 1;
    }
    __strlcpy_chk();
  }
  else
  {
    uint64_t v29 = "<unknown>";
    if (a3) {
      uint64_t v29 = a3;
    }
    snprintf((char *)(a1 + 3328), 0x400uLL, "%s:", v29);
    int v30 = 0;
    int v31 = -1;
    BOOL v32 = 1;
  }
  if (v22 == 0x4000)
  {
    *(unsigned char *)(a1 + 2304) = 0;
    *(unsigned char *)(a1 + 6400) = 0;
  }
  else
  {
    _extractFileAndPath((char *)(a1 + 248), (char *)(a1 + 2304));
    if ((*(unsigned int (**)(void, uint64_t, void *))(*(void *)(a1 + 12832) + 80))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 248, v73))
    {
      goto LABEL_18;
    }
    if (v32)
    {
      __strlcpy_chk();
    }
    else
    {
      _extractFileAndPath((char *)(a1 + 3328), (char *)(a1 + 6400));
      int v31 = (*(uint64_t (**)(void, uint64_t, long long *))(*(void *)(a1 + 12832) + 80))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 3328, &v64);
      int v30 = *__error();
    }
  }
  if (!*(unsigned char *)(a1 + 193))
  {
    size_t v43 = strlen((const char *)(a1 + 248));
    if (v43 != 1 || strcmp("/", (const char *)(a1 + 248)))
    {
      __strlcat_chk();
      uint64_t v36 = v43 + 1;
      goto LABEL_66;
    }
    __strlcat_chk();
LABEL_65:
    uint64_t v36 = 1;
    goto LABEL_66;
  }
  __strlcpy_chk();
  uint64_t v33 = strrchr(__s, 47);
  if (!v33) {
    goto LABEL_67;
  }
  uint64_t v34 = v33;
  if (v33 == __s)
  {
    __strlcpy_chk();
    goto LABEL_65;
  }
  *uint64_t v33 = 0;
  size_t v35 = strlen(__s);
  snprintf((char *)(a1 + 248), 0x400uLL, "%s/./%s", __s, v34 + 1);
  uint64_t v36 = v35 + 1;
LABEL_66:
  *(void *)(a1 + 2296) = a1 + v36 + 248;
LABEL_67:
  *(_DWORD *)(a1 + 232) = v73[0];
  memset(&v81, 0, 512);
  if (statfs((const char *)(a1 + 248), &v81)) {
    goto LABEL_18;
  }
  *(unsigned char *)(a1 + 210) = (v81.f_flags & 8) == 0;
  int v44 = *(_DWORD *)(a1 + 12716);
  switch(v44)
  {
    case 5:
      if (!BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), ".", (uint64_t)v73, 0, 0)
        && (v22 != 0x4000
         || !*(unsigned char *)(a1 + 193)
         || !BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), *(char **)(a1 + 2296), (uint64_t)v73, 0, 0)))
      {
LABEL_84:
        int v45 = 0;
        uint64_t v46 = 0;
        goto LABEL_86;
      }
LABEL_112:
      CFBooleanRef v58 = __error();
      uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
      if (!v16) {
        return 1;
      }
      uint64_t v17 = *v58;
      uint64_t v18 = (char *)(a1 + 3328);
LABEL_16:
      uint64_t v19 = a1;
      goto LABEL_20;
    case 4:
      if (*(unsigned char *)(a1 + 12745)) {
        goto LABEL_84;
      }
      if (*(unsigned char *)(a1 + 12746)) {
        _applyIndexBomOwnershipForTargetArchive(a1, ".", (uint64_t)v73);
      }
      if (!BOMCPIOWriteDirectory(*(void *)(a1 + 12736), ".", (uint64_t)v73)
        && (v22 != 0x4000
         || !*(unsigned char *)(a1 + 193)
         || !BOMCPIOWriteDirectory(*(void *)(a1 + 12736), *(char **)(a1 + 2296), (uint64_t)v73)))
      {
        goto LABEL_84;
      }
      goto LABEL_112;
    case 3:
      *(_DWORD *)(a1 + 236) = v64;
      *(void *)(a1 + 240) = *((void *)&v64 + 1);
      __strlcpy_chk();
      if (v31)
      {
        *__error() = v30;
        if (*__error() != 2 && *__error() != 63) {
          goto LABEL_14;
        }
        int v45 = 0;
      }
      else
      {
        if ((WORD2(v64) & 0xF000) != 0x4000)
        {
          uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
          if (!v16) {
            return 1;
          }
          uint64_t v18 = __s;
          uint64_t v19 = a1;
          uint64_t v17 = 20;
          goto LABEL_20;
        }
        int v45 = 1;
        if (!*(unsigned char *)(a1 + 12822))
        {
          uint64_t v46 = 0;
          goto LABEL_105;
        }
      }
      if (_makeDestDir(a1, __s, 1, (uint64_t)v73, &v61)) {
        goto LABEL_14;
      }
      uint64_t v46 = WORD2(v73[0]);
      if ((*(unsigned int (**)(void, char *, long long *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), __s, &v64))
      {
        goto LABEL_14;
      }
      long long v62 = v75;
      long long v63 = v74;
LABEL_105:
      if ((*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 160))(*(void *)(*(void *)(a1 + 12832) + 8), __s, a1 + 3328) == a1 + 3328)
      {
        _initializeAFSCData(a1);
        if (statfs((const char *)(a1 + 3328), &v81))
        {
          CFBooleanRef v57 = __error();
          uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
          if (!v16) {
            return 1;
          }
          uint64_t v17 = *v57;
          uint64_t v19 = a1;
          uint64_t v18 = (char *)(a1 + 3328);
          goto LABEL_20;
        }
        *(unsigned char *)(a1 + 209) = (v81.f_flags & 8) == 0;
        if (*(unsigned char *)(a1 + 211) == 1) {
          *(unsigned char *)(a1 + 211) = volume_has_data_protection((const char *)(a1 + 3328));
        }
        goto LABEL_86;
      }
LABEL_14:
      uint64_t v15 = __error();
      uint64_t v16 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 64);
      if (!v16) {
        return 1;
      }
      uint64_t v17 = *v15;
      uint64_t v18 = __s;
      goto LABEL_16;
  }
  uint64_t v46 = 0;
  int v45 = 1;
LABEL_86:
  size_t v47 = strlen((const char *)(a1 + 248));
  size_t v48 = strlen((const char *)(a1 + 3328));
  uint64_t v49 = (unsigned char *)(a1 + 3328 + v48);
  uint64_t v50 = 1024 - v47;
  uint64_t v51 = 1024 - v48;
  uint64_t v52 = (unsigned char *)(a1 + 248 + v47);
  if (v22 == 0x4000) {
    uint64_t result = _copyFromDirToDir(a1, v73, v52, v50, v49, v51, v13);
  }
  else {
    uint64_t result = _copyFromFileToDir(a1, (uint64_t)v73, v52, v50, v49, v51, v13, v45);
  }
  if (!result)
  {
    if (v45 || *(_DWORD *)(a1 + 12716) != 3) {
      return 0;
    }
    if (!*(unsigned char *)(a1 + 170) && !*(unsigned char *)(a1 + 169)
      || (v53 = _copyExtendedAttributes(a1, a1 + 248, (uint64_t)v73, 0, 0), uint64_t result = 0, !v53))
    {
      if (!*(unsigned char *)(a1 + 171) || (v54 = _copyACLs(a1, (char *)(a1 + 248), 0, 0, 0), uint64_t result = 0, !v54))
      {
        if (v61
          && (*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 200))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 3328, v46))
        {
LABEL_99:
          uint64_t v55 = __error();
          CFStringRef v56 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
          if (v56) {
            v56(a1, a1 + 3328, *v55);
          }
          return 0;
        }
        uint64_t result = set_timestamps_0((const char *)(a1 + 3328), &v63, &v62);
        if (result)
        {
          if (*__error() == 13 || *__error() == 1)
          {
            uint64_t v59 = __error();
            uint64_t result = 0;
            *uint64_t v59 = 0;
            return result;
          }
          goto LABEL_99;
        }
      }
    }
  }
  return result;
}

uint64_t _BOMCopierCopyFromCPIO(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = 0;
  uint64_t v10 = (unsigned char *)(a1 + 12721);
  long long v31 = 0u;
  memset(v32, 0, sizeof(v32));
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  if (*(_DWORD *)(a1 + 12716) == 3)
  {
    if (!a3)
    {
      BOMCopierNotifyFatalError(a1, "dstPath is NULL", 0, a4, a5, a6, a7, a8, v23);
      goto LABEL_17;
    }
    if (*(unsigned char *)(a1 + 12821) && _enforceDestinationLocation(a1, a3))
    {
      BOMFileClose(a2);
LABEL_17:
      uint64_t v20 = 1;
      goto LABEL_18;
    }
    if (v10[99])
    {
      if (_resolveDestinationPath(a1, a3, (char *)(a1 + 3328))) {
        goto LABEL_17;
      }
    }
    else
    {
      __strlcpy_chk();
    }
    if ((*(unsigned int (**)(void, uint64_t, long long *))(*(void *)(a1 + 12832) + 80))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 3328, &v23))
    {
      if (*__error() != 2 && *__error() != 63
        || _mkdirs(a1, a1 + 3328)
        || (*(unsigned int (**)(void, uint64_t, long long *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 3328, &v23))
      {
        int v22 = __error();
        uint64_t v16 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
        if (!v16) {
          goto LABEL_17;
        }
        uint64_t v17 = *v22;
        uint64_t v19 = a1;
        uint64_t v18 = a3;
        goto LABEL_10;
      }
      int v12 = 0;
    }
    else
    {
      int v12 = 1;
    }
    _initializeAFSCData(a1);
  }
  else
  {
    __strlcpy_chk();
    int v12 = 0;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
  }
  size_t v13 = strlen((const char *)(a1 + 3328));
  uint64_t v14 = (unsigned char *)(a1 + 3328 + (int)v13);
  *uint64_t v14 = 47;
  if (BOMCPIONew(&v33, a2, 1, 0))
  {
    BOMFileClose(a2);
    uint64_t v15 = __error();
    uint64_t v16 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
    if (!v16) {
      goto LABEL_17;
    }
    uint64_t v17 = *v15;
    uint64_t v18 = "";
    uint64_t v19 = a1;
LABEL_10:
    v16(v19, v18, v17);
    goto LABEL_17;
  }
  *(unsigned char *)(a1 + 248) = 0;
  *(void *)(a1 + 2296) = a1 + 248;
  *(void *)(a1 + 12728) = v33;
  *uint64_t v10 = 1;
  uint64_t v20 = _copyFromCPIO(a1, (uint64_t)v32, (uint64_t)&v23, v14 + 1, ((uint64_t)(0x40000000000 - (v13 << 32)) >> 32) - 1, v12);
  if (!v20) {
    uint64_t v20 = _restoreSymlinks(a1, 0);
  }
LABEL_18:
  if (v10[102]) {
    _restoreSymlinks(a1, 1);
  }
  if (v33) {
    BOMCPIOFree(v33);
  }
  return v20;
}

uint64_t _BOMCopierCopyFromPKZip(uint64_t a1, uint64_t a2, char *__s, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  uint64_t v109 = 0;
  uint64_t v108 = 0;
  memset(v107, 0, sizeof(v107));
  memset(v106, 0, sizeof(v106));
  if (*(_DWORD *)(a1 + 12716) != 3)
  {
    uint64_t v17 = 0xFFFFFFFFLL;
    goto LABEL_8;
  }
  if (!__s)
  {
    BOMCopierNotifyFatalError(a1, "dstPath is NULL", 0, a4, a5, a6, a7, a8, v99);
    goto LABEL_7;
  }
  if (strlen(__s) >= 0x3FF)
  {
    BOMCopierNotifyFatalError(a1, "Filename('%s') too long [%lu >= %lu]!", v11, v12, v13, v14, v15, v16, (char)__s);
LABEL_7:
    uint64_t v17 = 1;
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 12821) && _enforceDestinationLocation(a1, __s))
  {
    BOMFileClose(a2);
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 12820))
  {
    if (_resolveDestinationPath(a1, __s, (char *)(a1 + 3328))) {
      goto LABEL_7;
    }
  }
  else
  {
    __strlcpy_chk();
  }
  if ((*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 80))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 3328, v106)&& (*__error() != 2 && *__error() != 63 || _mkdirs(a1, a1 + 3328)))
  {
    uint64_t v19 = __error();
    uint64_t v20 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
    if (!v20) {
      goto LABEL_7;
    }
    uint64_t v21 = *v19;
    uint64_t v22 = a1;
    long long v23 = __s;
LABEL_28:
    v20(v22, v23, v21);
    goto LABEL_7;
  }
  _initializeAFSCData(a1);
  int v24 = strlen((const char *)(a1 + 3328));
  long long v25 = (unsigned char *)(a1 + 3328 + v24);
  unsigned char *v25 = 47;
  long long v26 = v25 + 1;
  if (BOMPKZipNew(&v109, a2, 1))
  {
    BOMFileClose(a2);
    long long v27 = __error();
    uint64_t v20 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
    if (!v20) {
      goto LABEL_7;
    }
    uint64_t v21 = *v27;
    long long v23 = "Could not create a BOMPKZip object";
    goto LABEL_27;
  }
  *(unsigned char *)(a1 + 248) = 0;
  *(void *)(a1 + 2296) = a1 + 248;
  long long v28 = v109;
  *(void *)(a1 + 12752) = v109;
  *(unsigned char *)(a1 + 12721) = 1;
  if (*(_DWORD *)(a1 + 12716) == 3 && *(unsigned char *)(a1 + 12768))
  {
    int v29 = strlen((const char *)(a1 + 3328));
    *(_DWORD *)(a1 + 12780) = v29 + 8;
    long long v30 = (char *)BOM_malloc((v29 + 9));
    *(void *)(a1 + 12784) = v30;
    if (!v30)
    {
      uint64_t v73 = __error();
      uint64_t v20 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (!v20) {
        goto LABEL_7;
      }
      uint64_t v21 = *v73;
      long long v23 = "";
LABEL_27:
      uint64_t v22 = a1;
      goto LABEL_28;
    }
    snprintf(v30, (*(_DWORD *)(a1 + 12780) + 1), "%s%s", (const char *)(a1 + 3328), "__MACOSX");
    long long v28 = v109;
  }
  BOMPKZipLoadCentralDirectory((uint64_t)v28);
  uint64_t v17 = _copyFromPKZip(a1, (uint64_t)v107, (uint64_t)v106, v26, 1024 - v24 - 1);
  long long v31 = *(void **)(a1 + 12784);
  if (v31)
  {
    free(v31);
    *(void *)(a1 + 12784) = 0;
    *(_DWORD *)(a1 + 12780) = 0;
  }
  if (!v17)
  {
    int NumLocalHeaders = BOMPKZipGetNumLocalHeaders(*(void *)(a1 + 12752));
    if (NumLocalHeaders)
    {
      int v39 = NumLocalHeaders;
      uint64_t v40 = (const char *)(a1 + 249);
      uint64_t v41 = (const char *)(a1 + 250);
      do
      {
        if (*(_DWORD *)(a1 + 12772) != 2)
        {
          long long v72 = "Not a central directory signature";
          goto LABEL_109;
        }
        if (BOMPKZipReadCentralHeader(*(int ***)(a1 + 12752), (char *)(a1 + 248), (uint64_t)v107, &v108))
        {
          long long v72 = "Couldn't read pkzip central header";
          goto LABEL_109;
        }
        int v42 = *(char *)(a1 + 248);
        if (v42 == 46)
        {
          if (*v40 == 47) {
            size_t v43 = v41;
          }
          else {
            size_t v43 = (const char *)(a1 + 248);
          }
        }
        else
        {
          size_t v43 = (const char *)(a1 + 248);
          if (v42 == 47) {
            size_t v43 = v40;
          }
        }
        snprintf((char *)(a1 + 7424), 0x400uLL, "%s/%s", __s, v43);
        __int16 v44 = WORD2(v107[0]);
        if ((WORD2(v107[0]) & 0x1FF) == 0)
        {
          if ((WORD2(v107[0]) & 0xF000) == 0x4000)
          {
            __int16 v45 = 493;
          }
          else
          {
            if ((WORD2(v107[0]) & 0xF000) != 0x8000) {
              goto LABEL_52;
            }
            __int16 v45 = 420;
          }
          __int16 v44 = WORD2(v107[0]) | v45;
          WORD2(v107[0]) |= v45;
        }
LABEL_52:
        int v46 = v44 & 0xF000;
        if (v46 != 0x4000)
        {
          if (v46 == 40960)
          {
            uint64_t v105 = 0;
            long long v103 = 0u;
            memset(v104, 0, sizeof(v104));
            long long v101 = 0u;
            long long v102 = 0u;
            memset(v100, 0, sizeof(v100));
            if ((*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424, v100))
            {
              long long v79 = __error();
              strerror(*v79);
              BOMCopierNotifyFatalError(a1, "Could not lstat %s: %s", v80, v81, v82, v83, v84, v85, a1);
              goto LABEL_110;
            }
            if ((uint64_t)v101 >= 1024)
            {
              BOMCopierNotifyFatalError(a1, "%s is too large: %ld", v47, v48, v49, v50, v51, v52, a1);
              goto LABEL_110;
            }
            if (BOMFileOpenWithSys(&v105, a1 + 7424, 0, 0, 16, *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
            {
              BOMCopierNotifyFatalError(a1, "Could not open symlink %s", v53, v54, v55, v56, v57, v58, a1);
              goto LABEL_110;
            }
            uint64_t v59 = v41;
            unint64_t v60 = BOMFileRead(v105, (char *)(a1 + 3328), v101);
            if (v60 != (void)v101)
            {
              BOMCopierNotifyFatalError(a1, "Could not read %s", v61, v62, v63, v64, v65, v66, a1);
              goto LABEL_110;
            }
            *(unsigned char *)(a1 + v60 + 3328) = 0;
            BOMFileClose((uint64_t)v105);
            _parentPath((char *)(a1 + 7424), v110, 0x400uLL);
            int v67 = (*(uint64_t (**)(void, unsigned char *, uint64_t))(*(void *)(a1 + 12832) + 184))(*(void *)(*(void *)(a1 + 12832) + 8), v110, 2);
            if (v67)
            {
              if ((*(unsigned int (**)(void, unsigned char *, _OWORD *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), v110, v104))
              {
                goto LABEL_110;
              }
              if ((*(unsigned int (**)(void, unsigned char *, void))(*(void *)(a1 + 12832) + 200))(*(void *)(*(void *)(a1 + 12832) + 8), v110, WORD2(v104[0]) | 0x1C0u))
              {
LABEL_89:
                long long v74 = __error();
                long long v75 = *(void (**)(uint64_t, unsigned char *, uint64_t))(a1 + 64);
                if (!v75) {
                  goto LABEL_110;
                }
                uint64_t v76 = *v74;
                long long v77 = v110;
                uint64_t v78 = a1;
LABEL_97:
                v75(v78, v77, v76);
                goto LABEL_110;
              }
            }
            if ((*(unsigned int (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424))
            {
              long long v68 = __error();
              long long v69 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
              if (v69) {
                v69(a1, a1 + 7424, *v68);
              }
            }
            if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 248))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 3328, a1 + 7424) == -1)
            {
              CFNumberRef v86 = __error();
              long long v75 = *(void (**)(uint64_t, unsigned char *, uint64_t))(a1 + 64);
              if (!v75) {
                goto LABEL_110;
              }
              uint64_t v76 = *v86;
              uint64_t v78 = a1;
              long long v77 = (unsigned char *)(a1 + 7424);
              goto LABEL_97;
            }
            if (v67
              && (*(unsigned int (**)(void, unsigned char *, void))(*(void *)(a1 + 12832) + 200))(*(void *)(*(void *)(a1 + 12832) + 8), v110, WORD2(v104[0]) & 0xFFF))
            {
              goto LABEL_89;
            }
            uint64_t v41 = v59;
            uint64_t v40 = (const char *)(a1 + 249);
            goto LABEL_73;
          }
          if (v46 != 0x8000) {
            goto LABEL_73;
          }
        }
        if (_chPerms(a1, (char *)(a1 + 7424), (uint64_t)v107, 0, 0) == -1)
        {
          if (*__error() != 2 && *__error() != 63)
          {
            unsigned __int8 v92 = __error();
            strerror(*v92);
            BOMCopierNotifyFatalError(a1, "Could not chmod %s: %s", v93, v94, v95, v96, v97, v98, a1);
            goto LABEL_110;
          }
          *__error() = 0;
        }
LABEL_73:
        if (BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772))) {
          goto LABEL_88;
        }
        --v39;
      }
      while (v39);
    }
    long long v70 = (int *)(a1 + 12772);
    int v71 = *(_DWORD *)(a1 + 12772);
    if (v71 == 3)
    {
      if (BOMPKZipSkipDigitalSignature(*(int ***)(a1 + 12752)))
      {
        long long v72 = "Could not skip the digital signature.";
LABEL_109:
        BOMCopierNotifyFatalError(a1, v72, v33, v34, v35, v36, v37, v38, v99);
        goto LABEL_110;
      }
      if (BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772)))
      {
LABEL_88:
        long long v72 = "Could not read next signature";
        goto LABEL_109;
      }
      int v71 = *v70;
    }
    if (v71 == 4)
    {
      if (BOMPKZipSkipZIP64CentralDirectoryRecord(*(int ***)(a1 + 12752)))
      {
        long long v72 = "Could not skip the ZIP64 central dir record.";
        goto LABEL_109;
      }
      if (BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772))) {
        goto LABEL_88;
      }
      int v71 = *v70;
    }
    if (v71 == 5)
    {
      if (BOMPKZipSkipZIP64CentralDirectoryLocation(*(int ***)(a1 + 12752)))
      {
        long long v72 = "Could not skip the ZIP64 central dir locator.";
        goto LABEL_109;
      }
      if (BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772)))
      {
        long long v72 = "Couldn't read next signature";
        goto LABEL_109;
      }
      int v71 = *v70;
    }
    if (v71 != 6)
    {
      long long v72 = "I'm expecting the end of central directory record.";
      goto LABEL_109;
    }
    if (BOMPKZipSkipEndOfCentralDirectoryRecord(*(int ***)(a1 + 12752)))
    {
      long long v72 = "Could not skip the end of the central directory record.";
      goto LABEL_109;
    }
    if (*(unsigned char *)(a1 + 12768))
    {
      int v87 = BOMPKZipQuarantinePathCount((uint64_t)v109);
      if (v87 - 1 >= 0)
      {
        int v88 = v87;
        CFBooleanRef v89 = (unsigned __int8 *)(a1 + 7424);
        while (!BOMPKZipCopyQuarantinePath((uint64_t)v109, --v88, (void *)(a1 + 7424)))
        {
          int v90 = *v89;
          if (v90 == 46 && *(unsigned char *)(a1 + 7425) == 47) {
            uint64_t v91 = 2;
          }
          else {
            uint64_t v91 = v90 == 47;
          }
          snprintf((char *)(a1 + 3328), 0x400uLL, "%s/%s", __s, (const char *)&v89[v91]);
          (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 232))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 3328);
          uint64_t v17 = 0;
          if (v88 <= 0) {
            goto LABEL_8;
          }
        }
        long long v72 = "Could not copy quarantined directory path.";
        goto LABEL_109;
      }
    }
LABEL_110:
    uint64_t v17 = 0;
  }
LABEL_8:
  if (v109) {
    BOMPKZipFree(v109);
  }
  return v17;
}

uint64_t _finalizeCopierDestination(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(*(_DWORD *)(a1 + 12716))
  {
    case 3:
      uint64_t v9 = *(const void **)(a1 + 12856);
      if (v9)
      {
        CFRelease(v9);
        *(void *)(a1 + 12856) = 0;
      }
      if (!*(void *)(a1 + 12864)) {
        goto LABEL_8;
      }
      int v10 = FinishStreamCompressorQueue();
      if (v10)
      {
        BOMCopierNotifyFatalError(a1, "Could not finish the HFS FinishStreamCompressorQueue error (%d)", v11, v12, v13, v14, v15, v16, v10);
        goto LABEL_14;
      }
      uint64_t v17 = 0;
      *(void *)(a1 + 12864) = 0;
      break;
    case 4:
      if (*(unsigned char *)(a1 + 12744)) {
        goto LABEL_8;
      }
      uint64_t v17 = BOMCPIOWriteTerminator(*(uint64_t **)(a1 + 12736));
      if (v17) {
        BOMCopierNotifyFatalError(a1, "Cannot write the terminator for the CPIO archive", v26, v27, v28, v29, v30, v31, v33);
      }
      break;
    case 5:
      uint64_t v17 = BOMPKZipWriteCentralDirectory(*(void *)(a1 + 12760));
      if (v17)
      {
        int NumLocalHeaders = BOMPKZipGetNumLocalHeaders(*(void *)(a1 + 12760));
        long long v25 = "Could not write the central directory for";
        if (!NumLocalHeaders) {
          long long v25 = "No files for";
        }
        BOMCopierNotifyFatalError(a1, "%s PKZip archive", v19, v20, v21, v22, v23, v24, (char)v25);
      }
      break;
    case 6:
      BOMCopierNotifyFatalError(a1, "The legacy engine does not support AppleArchive", a3, a4, a5, a6, a7, a8, v33);
LABEL_14:
      uint64_t v17 = 1;
      break;
    default:
LABEL_8:
      uint64_t v17 = 0;
      break;
  }
  return v17;
}

uint64_t BOMCopierRedirectPath(uint64_t a1, int a2, char *__s)
{
  if (!__s) {
    return 1;
  }
  size_t v5 = strlen(__s);
  uint64_t v6 = 1;
  if (v5 <= 0x3FF)
  {
    memmove((void *)(a1 + 10592), __s, v5 + 1);
    *(unsigned char *)(a1 + 11616) = 1;
    return 0;
  }
  return v6;
}

uint64_t BOMCopierRedirectSourcePath(uint64_t a1, int a2, char *__s)
{
  if (!__s) {
    return 1;
  }
  size_t v5 = strlen(__s);
  uint64_t v6 = 1;
  if (v5 <= 0x3FF)
  {
    memmove((void *)(a1 + 11617), __s, v5 + 1);
    *(unsigned char *)(a1 + 12641) = 1;
    return 0;
  }
  return v6;
}

uint64_t BOMCopierCancelCopy(uint64_t result)
{
  if (result) {
    *(unsigned char *)(result + 168) = 1;
  }
  return result;
}

uint64_t BOMCopierCountFilesInArchive(uint64_t a1, char *__s, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  keys[1] = *(void **)MEMORY[0x263EF8340];
  if (!__s)
  {
    BOMCopierNotifyFatalError(a1, "BOMCopierCountFilesInArchive: missing path", (uint64_t)a3, a4, a5, a6, a7, a8, v72);
    return 22;
  }
  size_t v12 = strlen(__s);
  if (v12 >= 0x400)
  {
    BOMCopierNotifyFatalError(a1, "BOMCopierCountFilesInArchive: maximum path length exceeded: %ld", v13, v14, v15, v16, v17, v18, v12);
    return 22;
  }
  values = (void *)*MEMORY[0x263EFFB40];
  keys[0] = @"extractLibarchive";
  CFDictionaryRef v20 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], (const void **)keys, (const void **)&values, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (!v20)
  {
    BOMCopierNotifyFatalError(a1, "Could not create empty BOMCopierSource options", v21, v22, v23, v24, v25, v26, v72);
    _resetCopier(a1);
    return 1;
  }
  CFDictionaryRef v27 = v20;
  long long v74 = 0;
  uint64_t v28 = BOMCopierSourceNew(__s, v20, 0, &v74);
  if (!v28)
  {
    uint64_t Code = BOMCopierErrorGetCode((uint64_t)v74);
    BOMCopierErrorGetMessage((uint64_t)v74);
    BOMCopierNotifyFatalError(a1, "Could not create BOMCopierSource from %s: %s", v59, v60, v61, v62, v63, v64, (char)__s);
    CFRelease(v27);
    BOMCopierErrorFree(v74);
    return Code;
  }
  uint64_t v29 = (void *)v28;
  uint64_t v73 = (void *)a4;
  CFRelease(v27);
  uint64_t v36 = BOMCopierSourceNext((uint64_t)v29, &v74, v30, v31, v32, v33, v34, v35);
  if (v36)
  {
    uint64_t v37 = v36;
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    while (1)
    {
      int Type = BOMCopierSourceEntryGetType((uint64_t)v37);
      if (Type == 9)
      {
        uint64_t SymlinkTarget = (const char *)BOMCopierSourceEntryGetSymlinkTarget((uint64_t)v37);
        if (!SymlinkTarget) {
          goto LABEL_16;
        }
        size_t Size = strlen(SymlinkTarget);
      }
      else
      {
        if (!Type)
        {
          BOMCopierNotifyFatalError(a1, "Unknown BOMCopierSourceEntry", v41, v42, v43, v44, v45, v46, v72);
          BOMCopierSourceEntryFree((unsigned int *)v37);
          BOMCopierSourceFree(v29);
          return 1;
        }
        size_t Size = BOMCopierSourceEntryGetSize((uint64_t)v37);
      }
      v39 += Size;
LABEL_16:
      if (a1 && *(void *)(a1 + 88))
      {
        uint64_t Path = BOMCopierSourceEntryGetPath((uint64_t)v37);
        __int16 Mode = BOMCopierSourceEntryGetMode((uint64_t)v37);
        uint64_t v51 = BOMCopierSourceEntryGetSize((uint64_t)v37);
        uint64_t v52 = BOMFSObjectTypeForMode(Mode);
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88))(a1, Path, v52, v51);
      }
      BOMCopierSourceEntryFree((unsigned int *)v37);
      uint64_t v37 = BOMCopierSourceNext((uint64_t)v29, &v74, v53, v54, v55, v56, v57, v58);
      ++v38;
      if (!v37) {
        goto LABEL_24;
      }
    }
  }
  uint64_t v39 = 0;
  uint64_t v38 = 0;
LABEL_24:
  BOMCopierSourceFree(v29);
  if (v74)
  {
    BOMCopierErrorGetMessage((uint64_t)v74);
    BOMCopierNotifyFatalError(a1, "Could not enumerate %s: %s", v65, v66, v67, v68, v69, v70, (char)__s);
    BOMCopierErrorFree(v74);
    return 1;
  }
  if (a3) {
    *a3 = v38;
  }
  uint64_t Code = 0;
  if (v73) {
    *uint64_t v73 = v39;
  }
  return Code;
}

uint64_t BOMCopierCountFilesInDirectory(uint64_t a1, char *__s, const __CFDictionary *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 1;
  }
  if (!__s)
  {
    BOMCopierNotifyFatalError(a1, "missing path parameter", (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v86);
    return 1;
  }
  size_t v13 = strlen(__s);
  if (v13 >= 0x400)
  {
    BOMCopierNotifyFatalError(a1, "maximum path length exceeded: %ld", v14, v15, v16, v17, v18, v19, v13);
    return 1;
  }
  if (a3)
  {
    if (_parseCopierOptions(a1, a3))
    {
      uint64_t v26 = "Could not parse the options dictionary";
LABEL_49:
      BOMCopierNotifyFatalError(a1, v26, v20, v21, v22, v23, v24, v25, v86);
      goto LABEL_50;
    }
    if (_verifyCopierOptions(a1, 0, 0, v21, v22, v23, v24, v25))
    {
      uint64_t v26 = "Could not verify the copier options";
      goto LABEL_49;
    }
    if (_prepareCopierState(a1))
    {
LABEL_50:
      _resetCopier(a1);
      return 1;
    }
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (!Mutable)
  {
    uint64_t v26 = "Could not create empty BOMCopierSource options";
    goto LABEL_49;
  }
  uint64_t v28 = Mutable;
  uint64_t v29 = (const void **)MEMORY[0x263EFFB40];
  if (*(unsigned char *)(a1 + 169) == 1) {
    CFDictionarySetValue(Mutable, @"synthesizeResourceForks", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (*(unsigned char *)(a1 + 192) == 1) {
    CFDictionarySetValue(v28, @"crossDevices", *v29);
  }
  *(_OWORD *)int v90 = 0u;
  long long v91 = 0u;
  long long v89 = 0u;
  int v88 = 0;
  if (*(void *)(a1 + 136)
    && (CFDictionarySetValue(v28, @"discoverBinaries", *v29),
        BOMCopierPrepareMatchContext(a3, (uint64_t)&v89, &v88))
    || (uint64_t v30 = BOMCopierSourceNew(__s, v28, 0, &v88)) == 0)
  {
    BOMCopierErrorGetMessage((uint64_t)v88);
    BOMCopierNotifyFatalError(a1, "Could not create BOMCopierSource from %s: %s", v63, v64, v65, v66, v67, v68, (char)__s);
    CFRelease(v28);
    BOMCopierErrorFree(v88);
    return 1;
  }
  uint64_t v31 = (void *)v30;
  CFRelease(v28);
  if (*(void *)(a1 + 120))
  {
    *(void *)(a1 + 12680) = 1;
    *(_DWORD *)(a1 + 12688) = 0;
    v87.__darwin_time_t tv_sec = 0;
    *(void *)&v87.__darwin_suseconds_t tv_usec = 0;
    gettimeofday(&v87, 0);
    __darwin_time_t v38 = *(void *)(a1 + 12680) + v87.tv_sec;
    *(void *)(a1 + 12696) = v38;
    int v39 = *(_DWORD *)(a1 + 12688) + v87.tv_usec;
    *(_DWORD *)(a1 + 12704) = v39;
    if (v39 > 999999)
    {
      *(void *)(a1 + 12696) = v38 + 1;
      *(_DWORD *)(a1 + 12704) = v39 - 1000000;
    }
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  uint64_t v40 = BOMCopierSourceNext((uint64_t)v31, 0, v32, v33, v34, v35, v36, v37);
  if (v40)
  {
    uint64_t v41 = v40;
    uint64_t v42 = 0;
    uint64_t v43 = 0;
    while (1)
    {
      switch(BOMCopierSourceEntryGetType((uint64_t)v41))
      {
        case 0u:
          BOMCopierNotifyFatalError(a1, "Unknown BOMCopierSourceEntry", v44, v45, v46, v47, v48, v49, v86);
          BOMCopierSourceEntryFree((unsigned int *)v41);
          BOMCopierSourceFree(v31);
          return 1;
        case 4u:
        case 5u:
        case 6u:
        case 7u:
        case 9u:
        case 0xBu:
          ++v43;
          goto LABEL_31;
        case 8u:
          if (BOMCopierSourceEntryGetBinaryType((uint64_t)v41))
          {
            uint64_t matched = BOMCopierMatchBinary((uint64_t)v41, (unsigned int *)&v89, &v88);
            if (matched)
            {
              uint64_t v69 = matched;
              Message = (const char *)BOMCopierErrorGetMessage((uint64_t)v88);
              BOMCopierNotifyFatalError(a1, Message, v80, v81, v82, v83, v84, v85, v86);
              BOMCopierErrorFree(v88);
              BOMCopierSourceEntryFree((unsigned int *)v41);
              BOMCopierSourceFree(v31);
              return v69;
            }
            uint64_t Size = *((void *)&v91 + 1);
            if (v90[1]) {
              free(v90[1]);
            }
          }
          else
          {
            uint64_t Size = BOMCopierSourceEntryGetSize((uint64_t)v41);
          }
          v42 += Size;
          v43 += !BOMCopierSourceEntryIsResourceFork(v41);
LABEL_31:
          BOMCopierSourceEntryFree((unsigned int *)v41);
          if (!*(void *)(a1 + 120)) {
            goto LABEL_39;
          }
          v87.__darwin_time_t tv_sec = 0;
          *(void *)&v87.__darwin_suseconds_t tv_usec = 0;
          gettimeofday(&v87, 0);
          __darwin_time_t tv_sec = v87.tv_sec;
          __darwin_time_t v57 = *(void *)(a1 + 12696);
          if (v87.tv_sec == v57)
          {
            __darwin_suseconds_t tv_usec = v87.tv_usec;
            if (v87.tv_usec >= *(_DWORD *)(a1 + 12704)) {
              goto LABEL_37;
            }
          }
          else if (v87.tv_sec >= v57)
          {
            __darwin_suseconds_t tv_usec = v87.tv_usec;
LABEL_37:
            (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 120))(a1, v43, v42);
            __darwin_time_t v59 = *(void *)(a1 + 12680) + tv_sec;
            *(void *)(a1 + 12696) = v59;
            int v60 = *(_DWORD *)(a1 + 12688) + tv_usec;
            *(_DWORD *)(a1 + 12704) = v60;
            if (v60 > 999999)
            {
              *(void *)(a1 + 12696) = v59 + 1;
              *(_DWORD *)(a1 + 12704) = v60 - 1000000;
            }
          }
LABEL_39:
          uint64_t v41 = BOMCopierSourceNext((uint64_t)v31, 0, v50, v51, v52, v53, v54, v55);
          if (!v41) {
            goto LABEL_54;
          }
          break;
        default:
          goto LABEL_31;
      }
    }
  }
  uint64_t v43 = 0;
  uint64_t v42 = 0;
LABEL_54:
  BOMCopierSourceFree(v31);
  uint64_t v71 = BOMCopierReleaseMatchContext((unsigned int *)&v89, &v88);
  if (v71)
  {
    uint64_t v69 = v71;
    char v72 = (const char *)BOMCopierErrorGetMessage((uint64_t)v88);
    BOMCopierNotifyFatalError(a1, v72, v73, v74, v75, v76, v77, v78, v86);
    BOMCopierErrorFree(v88);
  }
  else
  {
    if (a4) {
      *a4 = v43;
    }
    uint64_t v69 = 0;
    if (a5) {
      *a5 = v42;
    }
  }
  return v69;
}

uint64_t BOMCopierSetUserData(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 48) = a2;
  }
  return result;
}

uint64_t BOMCopierUserData(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

uint64_t BOMCopierSetFatalErrorHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 56) = a2;
  }
  return result;
}

uint64_t BOMCopierSetFatalFileErrorHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 64) = a2;
  }
  return result;
}

uint64_t BOMCopierSetFileErrorHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 72) = a2;
  }
  return result;
}

uint64_t BOMCopierSetFileConflictErrorHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 80) = a2;
  }
  return result;
}

uint64_t BOMCopierSetCopyFileStartedHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 88) = a2;
  }
  return result;
}

uint64_t BOMCopierSetCopyFileFinishedHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 96) = a2;
  }
  return result;
}

uint64_t BOMCopierSetCopyFileUpdateHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 104) = a2;
  }
  return result;
}

uint64_t BOMCopierSetCountFilesUpdateHandler(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 120) = a2;
  }
  return result;
}

uint64_t BOMCopierSetPKZipPasswordRequester(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 128) = a2;
  }
  return result;
}

uint64_t BOMCopierGetArchiveFileDescriptor(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  int v1 = *(_DWORD *)(a1 + 12712);
  if (v1 == 2)
  {
    uint64_t v4 = *(void *)(a1 + 12752);
    if (v4)
    {
      uint64_t File = BOMPKZipGetFile(v4);
      goto LABEL_8;
    }
    return 0xFFFFFFFFLL;
  }
  if (v1 != 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *(void *)(a1 + 12728);
  if (!v2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t File = BOMCPIOGetFile(v2);
LABEL_8:
  return BOMFileGetFileDescriptor(File);
}

size_t _extractFileAndPath(char *a1, char *a2)
{
  uint64_t v4 = strrchr(a1, 47);
  if (v4)
  {
    *uint64_t v4 = 0;
    size_t result = strlcpy(a2, v4 + 1, 0x400uLL);
    if (*a1) {
      return result;
    }
    __int16 v6 = 47;
  }
  else
  {
    size_t result = strlcpy(a2, a1, 0x400uLL);
    __int16 v6 = 46;
  }
  *(_WORD *)a1 = v6;
  return result;
}

uint64_t _initializeAFSCData(uint64_t a1)
{
  uint64_t result = __strlcpy_chk();
  if (!*(unsigned char *)(a1 + 195)) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 12712) || (uint64_t result = VolumeSupportsCompression(), (result & 1) == 0))
  {
    *(unsigned char *)(a1 + 195) = 0;
    goto LABEL_7;
  }
  if (!*(unsigned char *)(a1 + 195))
  {
LABEL_7:
    if (!*(unsigned char *)(a1 + 12848)) {
      return result;
    }
  }
  if (*(_DWORD *)(a1 + 12716) == 3 && (uint64_t result = VolumeSupportsCompression(), result))
  {
    if (*(unsigned char *)(a1 + 12848))
    {
      if (!*(void *)(a1 + 12864))
      {
        uint64_t result = CreateStreamCompressorQueueWithOptions();
        *(void *)(a1 + 12864) = result;
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 195) = 0;
    *(unsigned char *)(a1 + 12848) = 0;
  }
  return result;
}

void _applyIndexBomOwnershipForTargetArchive(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 152);
  if (v3)
  {
    uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(v3, a2);
    if (FSObjectAtPath)
    {
      uint64_t v6 = FSObjectAtPath;
      *(_DWORD *)(a3 + 16) = BOMFSObjectUserID(FSObjectAtPath);
      *(_DWORD *)(a3 + 20) = BOMFSObjectGroupID(v6);
      BOMFSObjectFree(v6);
    }
  }
}

uint64_t _copyFromDirToDir(uint64_t a1, _DWORD *a2, unsigned char *a3, uint64_t a4, unsigned char *a5, uint64_t a6, unsigned int a7)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  unsigned __int8 v74 = 0;
  uint64_t v72 = 0;
  memset(v76, 0, 512);
  memset(v71, 0, sizeof(v71));
  memset(&v70[2], 0, 112);
  *a3 = 47;
  *a5 = 47;
  a3[1] = 0;
  size_t v13 = a3 + 1;
  memset(v70, 0, 32);
  a5[1] = 0;
  uint64_t v14 = a5 + 1;
  if (*(unsigned char *)(a1 + 192) == 1)
  {
    if (*(_DWORD *)(a1 + 232) == *a2) {
      goto LABEL_11;
    }
    memset(&v75, 0, 512);
    if (!statfs((const char *)(a1 + 248), &v75))
    {
      *(unsigned char *)(a1 + 210) = (v75.f_flags & 8) == 0;
      goto LABEL_11;
    }
    uint64_t v15 = __error();
    uint64_t v16 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
    if (v16) {
      v16(a1, a1 + 248, *v15);
    }
    return 0;
  }
  if (!*(unsigned char *)(a1 + 192) && *(_DWORD *)(a1 + 232) != *a2) {
    return 0;
  }
LABEL_11:
  uint64_t v18 = (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 272))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 248);
  if (!v18)
  {
    *a5 = 0;
    *a3 = 0;
    __error();
    return _checkCopyFileError(a1);
  }
  uint64_t v19 = v18;
  unsigned int v68 = a7;
  uint64_t v63 = a5;
  uint64_t v64 = a3;
  unint64_t v20 = a6 - 1;
  size_t v21 = a4 - 1;
  unsigned int v73 = 0;
  size_t __size = a6 - 1;
  if (a6 - 1 >= (unint64_t)(a4 - 1)) {
    unint64_t v20 = a4 - 1;
  }
  unint64_t v65 = v20;
  int v22 = (*(uint64_t (**)(void, uint64_t, _OWORD *, uint64_t *))(*(void *)(a1 + 12832) + 296))(*(void *)(*(void *)(a1 + 12832) + 8), v18, v76, &v72);
  uint64_t v23 = 0;
  uint64_t v17 = 0;
  BOOL v24 = v22 == 0;
  uint64_t v69 = 0;
  if (v22 || (uint64_t v25 = v72) == 0)
  {
LABEL_80:
    (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 280))(*(void *)(*(void *)(a1 + 12832) + 8), v19);
    if (v24)
    {
      if (!v17)
      {
        if (v69 && v23)
        {
          uint64_t v54 = v69;
          for (uint64_t i = v23; i; --i)
          {
            unsigned int v73 = 0;
            if (*v54)
            {
              if (*(unsigned char *)(a1 + 168)) {
                goto LABEL_94;
              }
              if ((unint64_t)v54[1] + 1 > v65
                || (strlcpy(v14, (const char *)*v54, __size),
                    strncpy(v13, (const char *)*v54, v21),
                    (*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 248, v71)))
              {
                __error();
                if (_checkCopyFileError(a1)) {
                  goto LABEL_94;
                }
              }
              else if (_checkForDestinationConflict(a1, (char *)(a1 + 3328), (uint64_t)v71, (uint64_t)v70, &v74, &v73) != 1&& _copyFile(a1, (uint64_t)v71, (uint64_t)v70, v74, *(_DWORD **)(a1 + 136), &v73, 0) == 2)
              {
LABEL_94:
                uint64_t v19 = 0;
                goto LABEL_95;
              }
            }
            v54 += 2;
          }
        }
        uint64_t v19 = 0;
        uint64_t v17 = 0;
        *uint64_t v63 = 0;
        *uint64_t v64 = 0;
LABEL_101:
        uint64_t v56 = v69;
        if (v69) {
          goto LABEL_102;
        }
        goto LABEL_106;
      }
    }
    else
    {
      uint64_t v17 = _checkCopyFileError(a1);
    }
    uint64_t v19 = 0;
    goto LABEL_101;
  }
  uint64_t v23 = 0;
  uint64_t v69 = 0;
  uint64_t v17 = 0;
  unsigned int v67 = 0;
  uint64_t v62 = 0;
  while (1)
  {
    unsigned int v73 = 0;
    if (_ignore_readdir_entry(v25)) {
      goto LABEL_43;
    }
    if (*(unsigned char *)(a1 + 168)) {
      goto LABEL_99;
    }
    if (strlcpy(v13, (const char *)(v72 + 21), v21) >= v21) {
      goto LABEL_40;
    }
    uint64_t v26 = *(void *)(a1 + 152);
    if (v26)
    {
      unsigned int v67 = BOMBomPathIDForKey(v26, v68, (char *)(v72 + 21));
      if (!v67)
      {
        unsigned int v67 = 0;
        goto LABEL_43;
      }
    }
    uint64_t v27 = *(void *)(a1 + 160);
    if (v27) {
      BOOL v28 = BOMBomFSObjectExistsAtPath(v27, *(void *)(a1 + 2296));
    }
    else {
      BOOL v28 = 0;
    }
    if ((*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 248, v71))
    {
      __error();
      uint64_t v29 = a1;
      goto LABEL_41;
    }
    if (*(unsigned char *)(a1 + 12746) && *(_DWORD *)(a1 + 12716) == 4) {
      _applyIndexBomOwnershipForTargetArchive(a1, *(char **)(a1 + 2296), (uint64_t)v71);
    }
    if (*(unsigned __int16 *)(v72 + 18) > 0xF9u)
    {
      BOOL v61 = v28;
      v75.f_bfree = 0;
      *(_OWORD *)&v75.f_bsize = xmmword_210662D80;
      uint64_t v31 = (unsigned int *)BOM_malloczero(0x30CuLL);
      if ((*(unsigned int (**)(void, uint64_t, statfs *, unsigned int *, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 120))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 248, &v75, v31, 780, 1))
      {
        free(v31);
        __error();
        uint64_t v17 = _checkCopyFileError(a1);
        if (v17 > 1) {
          goto LABEL_99;
        }
        goto LABEL_43;
      }
      unint64_t v32 = v31[2];
      if (v65 < v32)
      {
        free(v31);
LABEL_40:
        uint64_t v29 = a1;
LABEL_41:
        if (_checkCopyFileError(v29)) {
          goto LABEL_99;
        }
        uint64_t v17 = 0;
        goto LABEL_43;
      }
      __source = (char *)v31 + (int)v31[1] + 4;
      strlcpy(v14, __source, __size);
      strlcpy(v13, __source, v21);
      free(v31);
      uint64_t v30 = v32 - 1;
      BOOL v28 = v61;
    }
    else
    {
      if (strlcpy(v14, (const char *)(v72 + 21), __size) >= __size)
      {
        uint64_t v29 = a1;
        goto LABEL_41;
      }
      uint64_t v30 = *(unsigned __int16 *)(v72 + 18);
    }
    uint64_t v34 = _checkForDestinationConflict(a1, (char *)(a1 + 3328), (uint64_t)v71, (uint64_t)v70, &v74, &v73);
    if (v73 != 1) {
      break;
    }
    if (v34 == 1)
    {
      uint64_t v17 = v34;
    }
    else if (v34)
    {
LABEL_99:
      uint64_t v17 = 2;
      goto LABEL_101;
    }
LABEL_43:
    BOOL v24 = (*(unsigned int (**)(void, uint64_t, _OWORD *, uint64_t *))(*(void *)(a1 + 12832) + 296))(*(void *)(*(void *)(a1 + 12832) + 8), v19, v76, &v72) == 0;
    uint64_t v25 = v72;
    if (!v24 || v72 == 0) {
      goto LABEL_80;
    }
  }
  int v35 = WORD2(v71[0]) & 0xF000;
  if (v28)
  {
    if (v35 != 0x4000) {
      goto LABEL_43;
    }
    goto LABEL_66;
  }
  if (v35 != 0x8000)
  {
LABEL_66:
    HIDWORD(v43) = v35;
    LODWORD(v43) = v35 - 0x2000;
    switch((v43 >> 13))
    {
      case 0u:
      case 2u:
        uint64_t v44 = _copyDevice(a1, (uint64_t)v71);
        break;
      case 1u:
        uint64_t v44 = _copyDir(a1, (uint64_t)v71, (uint64_t)v70, v30, v74, (uint64_t)v13, v21, v14, __size, v67, v28);
        break;
      case 3u:
        uint64_t v44 = _copyFile(a1, (uint64_t)v71, (uint64_t)v70, v74, *(_DWORD **)(a1 + 136), &v73, 0);
        break;
      case 4u:
        uint64_t v44 = _copyLink(a1, (uint64_t)v71, (uint64_t)v70, v74);
        break;
      default:
        goto LABEL_43;
    }
    if (v44 == 1)
    {
      uint64_t v17 = 1;
    }
    else if (v44 == 2)
    {
      uint64_t v17 = v44;
      goto LABEL_101;
    }
    goto LABEL_43;
  }
  if (*(_DWORD *)(a1 + 12716) != 3)
  {
    int v35 = 0x8000;
    goto LABEL_66;
  }
  if (!BOMAppleDoubleIsADFile((const char *)(a1 + 248)))
  {
    int v35 = WORD2(v71[0]) & 0xF000;
    goto LABEL_66;
  }
  if (v62)
  {
    if (v62 == v23)
    {
      uint64_t v62 = 2 * v23;
      uint64_t v42 = (void **)BOM_realloc(v69, 32 * v23);
    }
    else
    {
      uint64_t v42 = v69;
    }
  }
  else
  {
    uint64_t v42 = (void **)BOM_malloc(0x40uLL);
    uint64_t v62 = 4;
  }
  uint64_t v69 = v42;
  if (!v42)
  {
    BOMCopierNotifyFatalError(a1, "Could not allocate space for Apple Double files.", v36, v37, v38, v39, v40, v41, v59);
    uint64_t v17 = 2;
    goto LABEL_107;
  }
  uint64_t v45 = (char *)BOM_malloc(v30 + 1);
  if (v45)
  {
    uint64_t v52 = v45;
    strlcpy(v45, v13, v30 + 1);
    uint64_t v53 = (char **)&v69[2 * v23];
    *uint64_t v53 = v52;
    v53[1] = (char *)v30;
    ++v23;
    goto LABEL_43;
  }
  BOMCopierNotifyFatalError(a1, "Could not allocate space for Apple Double filename.", v46, v47, v48, v49, v50, v51, v59);
LABEL_95:
  uint64_t v17 = 2;
  uint64_t v56 = v69;
LABEL_102:
  if (v23)
  {
    __darwin_time_t v57 = v56;
    do
    {
      free(*v57);
      int *v57 = 0;
      v57 += 2;
      --v23;
    }
    while (v23);
  }
  free(v56);
LABEL_106:
  if (v19) {
LABEL_107:
  }
    (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 280))(*(void *)(*(void *)(a1 + 12832) + 8), v19);
  return v17;
}

uint64_t _copyFromFileToDir(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4, unsigned char *a5, uint64_t a6, unsigned int a7, int a8)
{
  v26[0] = 0;
  *a3 = 47;
  unsigned int v25 = 0;
  *a5 = 47;
  uint64_t v15 = a5 + 1;
  uint64_t v16 = (unsigned char *)(a1 + 2304);
  if (strlcpy(a3 + 1, (const char *)(a1 + 2304), a4 - 1) >= a4 - 1) {
    return 1;
  }
  uint64_t v17 = *(void *)(a1 + 152);
  if (v17)
  {
    if (!BOMBomPathIDForKey(v17, a7, (char *)(a1 + 2304))) {
      return 1;
    }
  }
  uint64_t v18 = *(void *)(a1 + 160);
  if (v18)
  {
    if (BOMBomFSObjectExistsAtPath(v18, *(void *)(a1 + 2296))) {
      return 1;
    }
  }
  memset(v24, 0, sizeof(v24));
  memset(v23, 0, sizeof(v23));
  if ((*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 248, v24))
  {
LABEL_7:
    __error();
    return _checkCopyFileError(a1);
  }
  size_t v20 = a6 - 1;
  if (*(unsigned char *)(a1 + 12746) && *(_DWORD *)(a1 + 12716) == 4) {
    _applyIndexBomOwnershipForTargetArchive(a1, *(char **)(a1 + 2296), (uint64_t)v24);
  }
  size_t v21 = (const char *)(*(unsigned char *)(a1 + 6400) ? a1 + 6400 : a1 + 2304);
  if (strlcpy(v15, v21, v20) >= v20) {
    return 1;
  }
  if (a8)
  {
    uint64_t result = _checkForDestinationConflict(a1, (char *)(a1 + 3328), (uint64_t)v24, (uint64_t)v23, v26, &v25);
    if (v25 == 1) {
      return result;
    }
  }
  else
  {
    v26[0] = 0;
    uint64_t result = 1;
  }
  HIDWORD(v22) = WORD2(v24[0]) & 0xF000;
  LODWORD(v22) = HIDWORD(v22) - 0x2000;
  switch((v22 >> 13))
  {
    case 0u:
    case 2u:
      uint64_t result = _copyDevice(a1, (uint64_t)v24);
      break;
    case 3u:
      uint64_t result = _copyFile(a1, (uint64_t)v24, (uint64_t)v23, v26[0], *(_DWORD **)(a1 + 136), &v25, 0);
      break;
    case 4u:
      uint64_t result = _copyLink(a1, (uint64_t)v24, (uint64_t)v23, v26[0]);
      break;
    default:
      break;
  }
  if (!result)
  {
    *a5 = 0;
    *a3 = 0;
    *uint64_t v16 = 0;
    if (!a8)
    {
      if (*(_DWORD *)(a1 + 12716) == 3)
      {
        uint64_t result = set_timestamps_0((const char *)(a1 + 3328), (long long *)(a2 + 32), (_OWORD *)(a2 + 48));
        if (result) {
          goto LABEL_7;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _copyExtendedAttributes(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5)
{
  int v10 = *(_DWORD *)(a1 + 12716);
  if (v10 != 3)
  {
    uint64_t v11 = (char *)(a1 + 7424);
    if (*(unsigned char *)(a1 + 11616)) {
      size_t v12 = (const char *)(a1 + 10592);
    }
    else {
      size_t v12 = *(const char **)(a1 + 2296);
    }
    strncpy(v11, v12, 0x400uLL);
  }
  if (a5)
  {
    if (v10 == 3 && *a5 == 2) {
      return 0;
    }
  }
  if ((*(_DWORD *)(a3 + 116) & 0x40000020) == 0x20 && *(unsigned char *)(a1 + 195))
  {
    if (*(unsigned char *)(a1 + 196)) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = 33;
    }
  }
  else
  {
    uint64_t v14 = 1;
  }
  size_t v15 = (*(uint64_t (**)(void, uint64_t, void, void, uint64_t))(*(void *)(a1 + 12832) + 144))(*(void *)(*(void *)(a1 + 12832) + 8), a2, 0, 0, v14);
  if (v15 == -1) {
    goto LABEL_48;
  }
  size_t v16 = v15;
  if (!v15)
  {
    if (a5)
    {
      uint64_t v17 = 0;
      *a5 = 1;
      return v17;
    }
    return 0;
  }
  uint64_t v19 = (char *)BOM_malloc(v15);
  if (!v19
    || (size_t v20 = v19,
        uint64_t v21 = (*(uint64_t (**)(void, uint64_t, char *, size_t, uint64_t))(*(void *)(a1 + 12832) + 144))(*(void *)(*(void *)(a1 + 12832) + 8), a2, v19, v16, v14), v21 == -1))
  {
LABEL_48:
    __error();
    return _checkCopyFileError(a1);
  }
  if (v21 < 1)
  {
    unint64_t v22 = 0;
LABEL_52:
    uint64_t v17 = 0;
    if (a5)
    {
      *a5 = 0;
      if (!v22) {
        goto LABEL_58;
      }
    }
    else
    {
LABEL_56:
      if (!v22) {
        goto LABEL_58;
      }
    }
LABEL_57:
    free(v22);
    goto LABEL_58;
  }
  unint64_t v22 = 0;
  uint64_t v23 = &v20[v21];
  uint64_t v24 = 3328;
  if (a4) {
    uint64_t v24 = 7424;
  }
  uint64_t v34 = v20;
  uint64_t v35 = a1 + v24;
  unsigned int v25 = v20;
  uint64_t v33 = &v20[v21];
  while (1)
  {
    if (!strcmp(v25, "com.apple.FinderInfo") || !strcmp(v25, "com.apple.ResourceFork"))
    {
      if (!*(unsigned char *)(a1 + 169)) {
        goto LABEL_46;
      }
    }
    else if (!*(unsigned char *)(a1 + 170))
    {
      goto LABEL_46;
    }
    uint64_t v26 = (*(uint64_t (**)(void, uint64_t, const char *, void, void, void, uint64_t))(*(void *)(a1 + 12832) + 128))(*(void *)(*(void *)(a1 + 12832) + 8), a2, v25, 0, 0, 0, v14);
    if (v26 == -1) {
      break;
    }
    uint64_t v27 = v26;
    if (!v22)
    {
      unint64_t v22 = BOM_malloc(0x800000uLL);
      if (!v22)
      {
        __error();
        uint64_t v17 = _checkCopyFileError(a1);
        goto LABEL_58;
      }
    }
    if (v27)
    {
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      while (1)
      {
        uint64_t v30 = (unint64_t)(v27 - v29) >= 0x800000 ? 0x800000 : v27 - v29;
        uint64_t v31 = (*(uint64_t (**)(void, uint64_t, const char *, void *, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 128))(*(void *)(*(void *)(a1 + 12832) + 8), a2, v25, v22, v30, v28, v14);
        if (v31 == -1) {
          break;
        }
        uint64_t v32 = v31;
        if ((*(unsigned int (**)(void, uint64_t, const char *, void *, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 136))(*(void *)(*(void *)(a1 + 12832) + 8), v35, v25, v22, v31, v28, 1) == -1)break; {
        v29 += v32;
        }
        uint64_t v28 = (v28 + v32);
        if (v29 == v27)
        {
          uint64_t v23 = v33;
          size_t v20 = v34;
          goto LABEL_46;
        }
      }
      __error();
      uint64_t v17 = _checkCopyFileError(a1);
      size_t v20 = v34;
      goto LABEL_56;
    }
LABEL_46:
    v25 += strlen(v25) + 1;
    if (v25 >= v23) {
      goto LABEL_52;
    }
  }
  __error();
  uint64_t v17 = _checkCopyFileError(a1);
  if (v22) {
    goto LABEL_57;
  }
LABEL_58:
  free(v20);
  return v17;
}

uint64_t _copyACLs(uint64_t a1, char *path_p, int a3, int a4, _DWORD *a5)
{
  acl_entry_t v21 = 0;
  acl_entry_t entry_p = 0;
  acl_t acl_p = 0;
  if (*(_DWORD *)(a1 + 12716) != 3) {
    return 0;
  }
  acl_flagset_t flagset_d = 0;
  if (a4)
  {
    acl_t link_np = acl_get_link_np(path_p, ACL_TYPE_EXTENDED);
    if (link_np)
    {
      int v10 = link_np;
      uint64_t v11 = acl_get_link_np((const char *)(a1 + 3328), ACL_TYPE_EXTENDED);
      goto LABEL_8;
    }
LABEL_26:
    if (*__error() == 2)
    {
      uint64_t v12 = 0;
      if (a5) {
        *a5 = 0;
      }
    }
    else
    {
      __error();
      uint64_t v12 = _checkCopyFileError(a1);
    }
    goto LABEL_36;
  }
  acl_t file = acl_get_file(path_p, ACL_TYPE_EXTENDED);
  if (!file) {
    goto LABEL_26;
  }
  int v10 = file;
  uint64_t v11 = acl_get_file((const char *)(a1 + 3328), ACL_TYPE_EXTENDED);
LABEL_8:
  acl_t acl_p = v11;
  if (!v11)
  {
    if (*__error() != 2 && *__error() != 63) {
      goto LABEL_34;
    }
    acl_t acl_p = acl_init(4);
  }
  uint64_t v14 = v10;
  int v15 = 0;
  while (!acl_get_entry(v14, v15, &entry_p))
  {
    acl_get_flagset_np(entry_p, &flagset_d);
    if (!acl_get_flag_np(flagset_d, ACL_ENTRY_INHERITED)
      && (acl_create_entry(&acl_p, &v21) == -1 || acl_copy_entry(v21, entry_p) == -1))
    {
      goto LABEL_34;
    }
    if (entry_p) {
      int v15 = -1;
    }
    else {
      int v15 = 0;
    }
    uint64_t v14 = v10;
  }
  if (a3) {
    size_t v16 = (const char *)(a1 + 7424);
  }
  else {
    size_t v16 = (const char *)(a1 + 3328);
  }
  if (a4) {
    int v17 = acl_set_link_np(v16, ACL_TYPE_EXTENDED, acl_p);
  }
  else {
    int v17 = acl_set_file(v16, ACL_TYPE_EXTENDED, acl_p);
  }
  if (v17 != -1)
  {
    uint64_t v12 = 0;
    if (a5) {
      *a5 = 0;
    }
    goto LABEL_35;
  }
LABEL_34:
  __error();
  uint64_t v12 = _checkCopyFileError(a1);
LABEL_35:
  acl_free(v10);
LABEL_36:
  if (acl_p) {
    acl_free(acl_p);
  }
  return v12;
}

uint64_t _checkForDestinationConflict(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, unsigned char *a5, _DWORD *a6)
{
  *a5 = 0;
  *a6 = 0;
  if (*(unsigned char *)(a1 + 12820))
  {
    uint64_t v12 = dirname_r(a2, (char *)(a1 + 9472));
    if (!v12
      || !(*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 160))(*(void *)(*(void *)(a1 + 12832) + 8), v12, a1 + 8448)&& *__error() != 2)
    {
      goto LABEL_31;
    }
    size_t v13 = strlen((const char *)(a1 + 4352));
    if (strncmp((const char *)(a1 + 4352), (const char *)(a1 + 8448), v13))
    {
      *a6 = 1;
      uint64_t v14 = a1;
LABEL_33:
      return _checkCopyFileError(v14);
    }
  }
  if ((*(unsigned int (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a2, a4))
  {
LABEL_8:
    if (*__error() == 2 || *__error() == 63) {
      goto LABEL_10;
    }
    goto LABEL_31;
  }
  char v16 = 1;
  while (1)
  {
    __int16 v17 = *(_WORD *)(a4 + 4);
    int v18 = v17 & 0xF000;
    if ((*(_WORD *)(a3 + 4) & 0xF000) != 0x4000)
    {
      if (v18 != 0x4000) {
        goto LABEL_37;
      }
LABEL_21:
      if ((v16 & 1) == 0
        || (BOMFSObjectTypeForMode(v17),
            BOMFSObjectTypeForMode(*(_WORD *)(a3 + 4)),
            _checkCopyFileConflictError(a1) != 3))
      {
        *a6 = 1;
        goto LABEL_32;
      }
      goto LABEL_23;
    }
    if (v18 == 0x4000) {
      goto LABEL_37;
    }
    if (v18 != 40960) {
      goto LABEL_21;
    }
    int v19 = *(_DWORD *)(a1 + 12816);
    if (v19 != 2) {
      break;
    }
    if ((v16 & 1) == 0) {
      goto LABEL_38;
    }
    BOMFSObjectTypeForMode(v17);
    BOMFSObjectTypeForMode(*(_WORD *)(a3 + 4));
    if (_checkCopyFileConflictError(a1) != 3) {
      goto LABEL_38;
    }
LABEL_23:
    int v20 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a2, a4);
    char v16 = 0;
    if (v20) {
      goto LABEL_8;
    }
  }
  if (v19 == 1)
  {
    if ((*(unsigned int (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 80))(*(void *)(*(void *)(a1 + 12832) + 8), a2, a4))
    {
      goto LABEL_31;
    }
    if ((*(_WORD *)(a4 + 4) & 0xF000) == 0x4000)
    {
LABEL_37:
      *a5 = 1;
      return 0;
    }
LABEL_38:
    *a6 = 1;
    uint64_t v14 = a1;
    goto LABEL_33;
  }
  if (v19) {
    return 0;
  }
  if ((*(unsigned int (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 3328))
  {
LABEL_31:
    *a6 = 1;
    __error();
LABEL_32:
    uint64_t v14 = a1;
    goto LABEL_33;
  }
LABEL_10:
  *a5 = 0;
  return 0;
}

uint64_t _copyFile(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int8 a4, _DWORD *a5, unsigned int *a6, int a7)
{
  v73[0] = a4;
  unsigned int v72 = 0;
  char v71 = 0;
  uint64_t v70 = 0;
  uint64_t v11 = (unsigned char *)(a1 + 11616);
  long long v69 = 0uLL;
  long long v68 = 0uLL;
  if (*(_DWORD *)(a1 + 12712))
  {
LABEL_2:
    int v12 = 0;
    int v13 = 0;
    uint64_t v14 = (int *)(a2 + 116);
    BOOL v60 = (*(_DWORD *)(a2 + 116) & 0x40000020) == 32;
    uint64_t v15 = *(void *)(a2 + 96);
    goto LABEL_3;
  }
  if (BOMAppleDoubleIsADFile((const char *)(a1 + 248)))
  {
    if (*(unsigned char *)(a1 + 169)) {
      goto LABEL_21;
    }
    goto LABEL_2;
  }
  uint64_t v14 = (int *)(a2 + 116);
  int v29 = *(_DWORD *)(a2 + 116) & 0x40000020;
  BOOL v30 = v29 == 32;
  if (v29 == 32)
  {
    if (*(unsigned char *)(a1 + 195)) {
      uint64_t v32 = 33;
    }
    else {
      uint64_t v32 = 1;
    }
  }
  else
  {
    uint64_t v32 = 1;
  }
  uint64_t v33 = *(void *)(a2 + 96);
  uint64_t v34 = (*(uint64_t (**)(void, uint64_t, const char *, void, void, void, uint64_t))(*(void *)(a1 + 12832)
                                                                                                  + 128))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 248, "com.apple.ResourceFork", 0, 0, 0, v32);
  BOOL v60 = v30;
  if (v34 == -1)
  {
    if (*__error() != 2 && *__error() != 93 && *__error() != 45)
    {
      uint64_t v38 = __error();
      uint64_t v34 = 0;
      int v13 = *v38;
      goto LABEL_45;
    }
    uint64_t v34 = 0;
  }
  int v13 = 0;
LABEL_45:
  uint64_t v15 = v34 + v33;
  int v12 = 1;
LABEL_3:
  if (*(_DWORD *)(a1 + 12712)) {
    uint64_t v16 = a1 + 248;
  }
  else {
    uint64_t v16 = *(void *)(a1 + 2296);
  }
  uint64_t v17 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  *uint64_t v11 = 0;
  v11[1025] = 0;
  int v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88);
  uint64_t v62 = v16;
  unsigned int v61 = v17;
  if (v18)
  {
    uint64_t v19 = v16;
    uint64_t v20 = v15;
    unsigned int v21 = v18(a1, v19, v17, v15);
  }
  else
  {
    uint64_t v20 = v15;
    unsigned int v21 = 0;
  }
  if (*(unsigned char *)(a1 + 168)) {
    uint64_t v22 = 2;
  }
  else {
    uint64_t v22 = v21;
  }
  if (v22 == 1)
  {
LABEL_21:
    *a6 = 1;
    int v25 = *(_DWORD *)(a1 + 12712);
    if (v25 == 2)
    {
      uint64_t File = BOMPKZipGetFile(*(void *)(a1 + 12752));
      uint64_t v28 = File;
      if (v11[1153] && BOMFileSetCompression(File, 1, 1, *(_DWORD *)(a1 + 12792)))
      {
        __error();
        _checkCopyFileError(a1);
        uint64_t v22 = 2;
        goto LABEL_144;
      }
      if (*(_DWORD *)(a1 + 12776)) {
        BOMFileSetPartialRead(v28, 1);
      }
      int v26 = _skipPKZipFile();
    }
    else
    {
      if (v25 != 1) {
        goto LABEL_143;
      }
      int v26 = _skipCPIOFile(a1);
    }
    uint64_t v22 = 2 * (v26 != 0);
    goto LABEL_144;
  }
  if (v22 != 2)
  {
    if (v13)
    {
      uint64_t v23 = a1;
LABEL_19:
      uint64_t v24 = _checkCopyFileError(v23);
LABEL_20:
      uint64_t v22 = v24;
      goto LABEL_144;
    }
    if (*v11)
    {
      LODWORD(v65[0]) = 0;
      uint64_t v31 = (char *)(a1 + 10592);
      uint64_t v24 = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, a3, v73, v65);
      if (LODWORD(v65[0]) == 1) {
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v31 = (char *)(a1 + 3328);
    }
    char v59 = v31;
    if (v11[1025] && !*(_DWORD *)(a1 + 12712))
    {
      uint64_t v35 = (char *)(a1 + 11617);
      if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 11617, a2) == -1)
      {
LABEL_90:
        __error();
        uint64_t v23 = a1;
        goto LABEL_19;
      }
      if ((*(_WORD *)(a2 + 4) & 0xF000) != 0x8000)
      {
        uint64_t v23 = a1;
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v35 = (char *)(a1 + 248);
    }
    if (*(_DWORD *)(a1 + 12716) == 3) {
      unsigned int v58 = *v14;
    }
    else {
      unsigned int v58 = 0;
    }
    *(unsigned char *)(a1 + 196) = 1;
    uint64_t v36 = _copyDataFork(a1, v35, a2, a3, v73[0], a5, a6, a7);
    if (v36)
    {
      uint64_t v22 = v36;
      if (*(_DWORD *)(a1 + 12716) != 3) {
        goto LABEL_144;
      }
LABEL_55:
      (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424);
      goto LABEL_144;
    }
    if (*a6)
    {
      unsigned int v72 = *a6;
    }
    else
    {
      if (*(_DWORD *)(a1 + 12716) == 3)
      {
        if (v11[1232] || (unsigned int v37 = *(unsigned __int8 *)(a1 + 195), *(unsigned char *)(a1 + 195)))
        {
          uint64_t v70 = AFSCLockFilePath();
          if (!v70)
          {
LABEL_94:
            __error();
            (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424);
LABEL_95:
            uint64_t v23 = a1;
            goto LABEL_19;
          }
          unsigned int v37 = *a6;
        }
      }
      else
      {
        unsigned int v37 = 0;
      }
      unsigned int v72 = v37;
      if (v37) {
        int v39 = 0;
      }
      else {
        int v39 = v12;
      }
      if (v39 == 1)
      {
        if (*(_DWORD *)(a1 + 12716) == 3)
        {
          if (*(unsigned char *)(a1 + 170) || *(unsigned char *)(a1 + 169)) {
            unsigned int v40 = _copyExtendedAttributes(a1, (uint64_t)v35, a2, 1, &v72);
          }
          else {
            unsigned int v40 = 0;
          }
          if (v40) {
            BOOL v41 = 1;
          }
          else {
            BOOL v41 = *(unsigned char *)(a1 + 172) == 0;
          }
          if (v41) {
            uint64_t v22 = v40;
          }
          else {
            uint64_t v22 = 0;
          }
          if (*(unsigned char *)(a1 + 171) && !v22) {
            uint64_t v22 = _copyACLs(a1, v35, 1, 0, &v72);
          }
          if (v22) {
            goto LABEL_55;
          }
        }
        else
        {
          uint64_t v22 = _copyAppleDoubleToArchive(a1, (uint64_t)v35, a2, &v72);
          if (v22) {
            goto LABEL_144;
          }
        }
      }
    }
    uint64_t v42 = *(const void **)(a1 + 216);
    if (v42 && setxattr((const char *)(a1 + 7424), "com.apple.provenance", v42, *(void *)(a1 + 224), 0, 1)) {
      goto LABEL_90;
    }
    unint64_t v43 = a6;
    uint64_t v44 = v20;
    uint64_t v45 = v62;
    if (!*a6 && *(_DWORD *)(a1 + 12716) == 3)
    {
      if (_chPerms(a1, (char *)(a1 + 7424), a2, &v71, 1)) {
        goto LABEL_94;
      }
      long long v46 = *(_OWORD *)(a2 + 32);
      long long v68 = *(_OWORD *)(a2 + 48);
      long long v69 = v46;
      if (set_timestamps_0((const char *)(a1 + 7424), &v69, &v68))
      {
        if (*__error() != 13 && *__error() != 1) {
          goto LABEL_94;
        }
        *__error() = 0;
      }
      if (*(_DWORD *)(a1 + 12712)
        && *(_DWORD *)(a1 + 12716) == 3
        && *(unsigned char *)(a1 + 169)
        && BOMAppleDoubleIsADFile(v59))
      {
        __strlcpy_chk();
        __strlcat_chk();
        if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 264))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424, a1 + 8448))
        {
          goto LABEL_94;
        }
        unint64_t v43 = a6;
        uint64_t v45 = v62;
        if (v62 == a1 + 248) {
          __strlcat_chk();
        }
      }
      else if (!v11[1207] {
             && (a7 & 1) == 0
      }
             && (*(unsigned int (**)(void, uint64_t, char *))(*(void *)(a1 + 12832) + 264))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424, v59))
      {
        goto LABEL_94;
      }
      if (v58)
      {
        if (*(_DWORD *)(a1 + 10496)) {
          uint64_t v47 = v58 & 0xC000FFFF;
        }
        else {
          uint64_t v47 = v58;
        }
        if (v60 && (!*(unsigned char *)(a1 + 195) || *(unsigned char *)(a1 + 196))) {
          uint64_t v47 = v47 & 0xFFFFFFDF;
        }
        if (v47)
        {
          uint64_t v48 = v45;
          uint64_t v49 = v44;
          int v50 = *v14;
          long long v66 = 0u;
          long long v67 = 0u;
          memset(v65, 0, sizeof(v65));
          if (!(*(unsigned int (**)(void, char *, _OWORD *))(*(void *)(a1 + 12832) + 80))(*(void *)(*(void *)(a1 + 12832) + 8), v59, v65))
          {
            int v50 = DWORD1(v66);
            if ((DWORD1(v66) & 0x40000020) == 0x20) {
              unsigned int v51 = v47 | 0x20;
            }
            else {
              unsigned int v51 = v47;
            }
            if (v11[1232]) {
              unsigned int v52 = v51;
            }
            else {
              unsigned int v52 = v47;
            }
            if ((~v52 & 0x40000020) != 0) {
              uint64_t v47 = v52;
            }
            else {
              uint64_t v47 = v52 & 0xBFFFFFDF;
            }
          }
          if (change_flags_0(a1, v59, v50, v47) || set_timestamps_0(v59, &v69, &v68))
          {
            __error();
            goto LABEL_95;
          }
          uint64_t v44 = v49;
          uint64_t v45 = v48;
        }
      }
      if (*(unsigned char *)(a1 + 197))
      {
        uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(*(void *)(a1 + 152), *(char **)(a1 + 2296));
        uint64_t v54 = v44;
        int v55 = BOMFSObjectChecksum(FSObjectAtPath);
        BOMFSObjectFree(FSObjectAtPath);
        BOOL v41 = v55 == *(_DWORD *)(a1 + 200);
        uint64_t v44 = v54;
        if (!v41)
        {
          if (*(void *)(a1 + 56)) {
            goto LABEL_95;
          }
        }
      }
    }
    if (*(_DWORD *)(a1 + 12712) == 2 && *(_DWORD *)(a1 + 12776)) {
      uint64_t v44 = *(void *)(a2 + 96);
    }
    uint64_t v56 = *(void (**)(uint64_t, uint64_t, void, uint64_t, void))(a1 + 96);
    if (v56) {
      v56(a1, v45, v61, v44, *v43);
    }
LABEL_143:
    uint64_t v22 = 0;
  }
LABEL_144:
  _unlockAFSCFileLock(&v70);
  return v22;
}

uint64_t _copyDir(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6, uint64_t a7, char *a8, size_t a9, unsigned int a10, unsigned __int8 a11)
{
  int v16 = a11;
  v68[0] = a5;
  unsigned __int8 v67 = 0;
  long long v66 = 0uLL;
  long long v65 = 0uLL;
  if (!*(_DWORD *)(a1 + 12712)
    && *(_DWORD *)a2 == *(_DWORD *)(a1 + 236)
    && *(void *)(a2 + 8) == *(void *)(a1 + 240))
  {
    return 0;
  }
  uint64_t v17 = (unsigned char *)(a1 + 11616);
  uint64_t v18 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  uint64_t v19 = *(void *)(a1 + 2296);
  *uint64_t v17 = 0;
  *(unsigned char *)(a1 + 12641) = 0;
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 88);
  int v21 = v20 ? v20(a1, v19, v18, 0) : 0;
  int v22 = *(unsigned char *)(a1 + 168) ? 2 : v21;
  if (v22 == 1) {
    return 0;
  }
  if (v22 == 2) {
    return 2;
  }
  uint64_t v58 = a7;
  if (*v17)
  {
    LODWORD(v64) = 0;
    uint64_t v24 = (char *)(a1 + 10592);
    uint64_t v23 = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, a3, v68, &v64);
    if (v64 == 1) {
      return v23;
    }
  }
  else
  {
    uint64_t v23 = 0;
    uint64_t v24 = (char *)(a1 + 3328);
  }
  unsigned int v55 = v18;
  if (!*(unsigned char *)(a1 + 12641) || *(_DWORD *)(a1 + 12712))
  {
    size_t v57 = a9;
    int v25 = v24;
    int v26 = (char *)(a1 + 248);
    goto LABEL_20;
  }
  int v26 = (char *)(a1 + 11617);
  if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 11617, a2) == -1)
  {
    __error();
    uint64_t v31 = a1;
  }
  else
  {
    if ((*(_WORD *)(a2 + 4) & 0xF000) == 0x4000)
    {
      size_t v57 = a9;
      int v25 = v24;
LABEL_20:
      if (*(_DWORD *)(a1 + 12712) || *(_DWORD *)(a1 + 12716) != 3 || (*(unsigned char *)(a2 + 118) & 1) == 0)
      {
LABEL_25:
        uint64_t v56 = a8;
        int v28 = *(_DWORD *)(a1 + 12716);
        path_p = v26;
        if (v28 == 3)
        {
          if (v68[0])
          {
            int v29 = v16;
            if (v16 || !*(unsigned char *)(a1 + 12822)) {
              goto LABEL_45;
            }
          }
          else
          {
            int v29 = v16;
            if (v16) {
              goto LABEL_45;
            }
          }
          if (!_makeDestDir(a1, v25, 1, a2, &v67))
          {
LABEL_45:
            int v32 = v67;
            BOOL v33 = v67 != 0;
            if (v67)
            {
              unsigned int v52 = *(unsigned __int16 *)(a2 + 4);
              uint64_t v34 = strdup(v25);
            }
            else
            {
              unsigned int v52 = 0;
              uint64_t v34 = v25;
            }
            int v53 = v68[0];
            int v35 = v68[0] | v29;
            if (v35)
            {
              int v36 = v33;
            }
            else
            {
              long long v37 = *(_OWORD *)(a2 + 48);
              long long v66 = *(_OWORD *)(a2 + 32);
              long long v65 = v37;
              if (!v32)
              {
                uint64_t v38 = strdup(v34);
                int v36 = 1;
LABEL_53:
                int v39 = *(_DWORD *)(a1 + 12712);
                if (v39 != 2) {
                  goto LABEL_81;
                }
                if (*(_DWORD *)(a1 + 12776))
                {
                  if (*(unsigned char *)(a1 + 12769))
                  {
                    uint64_t File = BOMPKZipGetFile(*(void *)(a1 + 12752));
                    BOMFileSetPartialRead(File, 1);
                    uint64_t v41 = BOMPKZipGetFile(*(void *)(a1 + 12752));
                    if (BOMFileSetCompression(v41, 1, 1, *(_DWORD *)(a1 + 12792))) {
                      goto LABEL_97;
                    }
                    int v51 = v36;
                    uint64_t v42 = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
                    while (BOMFileRead(v42, _copyDir_waste, 0x40uLL) != -1
                         && !BOMFileEndOfCompressionStream((BOOL)v42))
                      ;
                    uint64_t v43 = BOMPKZipGetFile(*(void *)(a1 + 12752));
                    if (BOMFileSetCompression(v43, 0, 1, *(_DWORD *)(a1 + 12792)))
                    {
                      __error();
                      uint64_t v23 = _checkCopyFileError(a1);
                      if ((v51 & 1) == 0) {
                        return v23;
                      }
LABEL_102:
                      free(v38);
                      return v23;
                    }
                    uint64_t v46 = BOMPKZipGetFile(*(void *)(a1 + 12752));
                    BOMFileSetPartialRead(v46, 0);
                    int v36 = v51;
                  }
                  int v63 = 0;
                  uint64_t v47 = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
                  if (BOMFileRead(v47, (char *)&v63, 4uLL) == 4 && v63 == 134695760)
                  {
                    int v62 = 0;
                    unint64_t v64 = 0;
                    unint64_t v61 = 0;
                    if (!BOMPKZipReadDataDescriptor(*(int ***)(a1 + 12752), *(unsigned __int8 *)(a1 + 12812), &v62, &v64, &v61))
                    {
                      int v39 = *(_DWORD *)(a1 + 12712);
LABEL_81:
                      switch(v39)
                      {
                        case 0:
                          uint64_t v48 = _copyFromDirToDir(a1, a2, a6 + a4, v58 - a4, &v56[a4], v57 - a4, a10);
                          goto LABEL_85;
                        case 1:
                          uint64_t v48 = _copyFromCPIO(a1, a2, a3, v56, v57, v53);
                          goto LABEL_85;
                        case 2:
                          goto LABEL_83;
                        case 3:
                          uint64_t v23 = 2;
                          if (v36) {
                            goto LABEL_102;
                          }
                          break;
                        default:
                          goto LABEL_86;
                      }
                      return v23;
                    }
                  }
                  goto LABEL_97;
                }
LABEL_83:
                uint64_t v48 = _copyFromPKZip(a1, a2, a3, v56, v57);
LABEL_85:
                uint64_t v23 = v48;
LABEL_86:
                if (v23)
                {
LABEL_87:
                  if (!v36) {
                    return v23;
                  }
                  goto LABEL_102;
                }
                if (!v35 && !*(_DWORD *)(a1 + 12712))
                {
                  if (*(_DWORD *)(a1 + 12716) == 3)
                  {
                    if (*(unsigned char *)(a1 + 170) || *(unsigned char *)(a1 + 169))
                    {
                      uint64_t v23 = _copyExtendedAttributes(a1, (uint64_t)path_p, a2, 0, 0);
                      if (v23) {
                        goto LABEL_87;
                      }
                    }
                    if (!*(unsigned char *)(a1 + 171)) {
                      goto LABEL_91;
                    }
                    uint64_t v50 = _copyACLs(a1, path_p, 0, 0, 0);
                  }
                  else
                  {
                    uint64_t v50 = _copyAppleDoubleToArchive(a1, (uint64_t)path_p, a2, 0);
                  }
                  uint64_t v23 = v50;
                  if (v50) {
                    goto LABEL_87;
                  }
                }
LABEL_91:
                if (v67)
                {
                  if ((*(unsigned int (**)(void, char *, void))(*(void *)(a1 + 12832) + 200))(*(void *)(*(void *)(a1 + 12832) + 8), v38, v52) == -1)goto LABEL_97; {
                  int v53 = v68[0];
                  }
                }
                if (*(_DWORD *)(a1 + 12716) == 3 && !(v53 | v29) && set_timestamps_0(v38, &v66, &v65))
                {
LABEL_97:
                  __error();
                  uint64_t v23 = _checkCopyFileError(a1);
                  if ((v36 & 1) == 0) {
                    return v23;
                  }
                  goto LABEL_102;
                }
                if (!*(_DWORD *)(a1 + 12712))
                {
                  uint64_t v49 = *(void (**)(uint64_t, void, void, void, void))(a1 + 96);
                  if (v49)
                  {
                    v49(a1, *(void *)(a1 + 2296), v55, 0, 0);
                    uint64_t v23 = 0;
                    if ((v36 & 1) == 0) {
                      return v23;
                    }
                    goto LABEL_102;
                  }
                }
                uint64_t v23 = 0;
                goto LABEL_87;
              }
              int v36 = 1;
            }
            uint64_t v38 = v34;
            goto LABEL_53;
          }
        }
        else
        {
          int v29 = v16;
          BOOL v30 = v25;
          if (!*v17) {
            BOOL v30 = *(const char **)(a1 + 2296);
          }
          strncpy((char *)(a1 + 7424), v30, 0x400uLL);
          if (v16) {
            goto LABEL_45;
          }
          if (v28 == 4)
          {
            if (!BOMCPIOWriteDirectory(*(void *)(a1 + 12736), (char *)(a1 + 7424), a2)) {
              goto LABEL_45;
            }
          }
          else if (!BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), (char *)(a1 + 7424), a2, 0, 0))
          {
            goto LABEL_45;
          }
        }
LABEL_44:
        __error();
        return _checkCopyFileError(a1);
      }
      uint64_t v27 = BOM_malloc(0x400uLL);
      unint64_t v64 = 0;
      if (BOMHardLinkTableGetPathAndData(*(CFDictionaryRef **)a1, *(_DWORD *)a2, *(void *)(a2 + 8), (char *)v27, &v64))
      {
        BOMHardLinkTableSetPathAndData(*(CFDictionaryRef **)a1, *(_DWORD *)a2, *(void *)(a2 + 8), v25, (const void *)(a2 + 96), 8uLL);
        free(v27);
        goto LABEL_25;
      }
      if (v68[0]
        && (*(unsigned int (**)(void, char *))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), v25))
      {
        free(v27);
        goto LABEL_44;
      }
      int v45 = (*(uint64_t (**)(void, void *, char *))(*(void *)(a1 + 12832) + 240))(*(void *)(*(void *)(a1 + 12832) + 8), v27, v25);
      free(v27);
      if (v45)
      {
        int v16 = a11;
        if (*__error() != 18) {
          goto LABEL_44;
        }
        goto LABEL_25;
      }
      return 0;
    }
    uint64_t v31 = a1;
  }
  return _checkCopyFileError(v31);
}

uint64_t _copyLink(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7 = (unsigned char *)(a1 + 11616);
  char v44 = a4;
  char v43 = 0;
  uint64_t v8 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  if (*(_DWORD *)(a1 + 12712)) {
    uint64_t v9 = (const char *)(a1 + 248);
  }
  else {
    uint64_t v9 = *(const char **)(a1 + 2296);
  }
  *uint64_t v7 = 0;
  v7[1025] = 0;
  int v10 = *(uint64_t (**)(uint64_t, const char *, uint64_t, void))(a1 + 88);
  if (v10) {
    unsigned int v11 = v10(a1, v9, v8, 0);
  }
  else {
    unsigned int v11 = 0;
  }
  if (*(unsigned char *)(a1 + 168)) {
    uint64_t v12 = 2;
  }
  else {
    uint64_t v12 = v11;
  }
  if (v12 == 1)
  {
    uint64_t v12 = 0;
LABEL_16:
    if (*(_DWORD *)(a1 + 12712) == 1)
    {
      if (_skipCPIOFile(a1)) {
        return 2;
      }
      else {
        return v12;
      }
    }
    return v12;
  }
  if (v12 == 2) {
    return v12;
  }
  if (*v7)
  {
    int v42 = 0;
    int v13 = (char *)(a1 + 10592);
    uint64_t v14 = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, a3, &v44, &v42);
    if (v42 == 1)
    {
LABEL_14:
      uint64_t v12 = v14;
      goto LABEL_16;
    }
  }
  else
  {
    int v13 = (char *)(a1 + 3328);
  }
  if (!v7[1025] || *(_DWORD *)(a1 + 12712))
  {
    int v16 = (char *)(a1 + 248);
    goto LABEL_25;
  }
  int v16 = (char *)(a1 + 11617);
  if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 11617, a2) == -1)
  {
LABEL_64:
    __error();
    uint64_t v18 = a1;
    goto LABEL_65;
  }
  if ((*(_WORD *)(a2 + 4) & 0xF000) == 0xA000)
  {
LABEL_25:
    uint64_t v12 = 2;
    switch(*(_DWORD *)(a1 + 12712))
    {
      case 0:
        uint64_t v17 = (*(uint64_t (**)(void, char *, void, void))(*(void *)(a1 + 12832) + 256))(*(void *)(*(void *)(a1 + 12832) + 8), v16, *(void *)(a1 + 8), *(int *)(a1 + 16));
        if (v17 == -1) {
          goto LABEL_64;
        }
        goto LABEL_39;
      case 1:
        uint64_t v17 = *(void *)(a2 + 96);
        if (v17 >= 1025)
        {
          uint64_t v14 = _checkCopyFileError(a1);
          goto LABEL_14;
        }
        unint64_t v19 = BOMCPIORead(*(int ***)(a1 + 12728), *(char **)(a1 + 8), *(void *)(a2 + 96));
        goto LABEL_38;
      case 2:
        uint64_t v17 = *(void *)(a2 + 96);
        if (v17 >= 1025)
        {
          uint64_t v18 = a1;
          goto LABEL_65;
        }
        uint64_t File = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
        unint64_t v19 = BOMFileRead(File, *(char **)(a1 + 8), v17);
LABEL_38:
        if (v19 != v17) {
          goto LABEL_64;
        }
LABEL_39:
        *(unsigned char *)(*(void *)(a1 + 8) + v17) = 0;
        int v21 = *(_DWORD *)(a1 + 12716);
        if (v21 == 5)
        {
          unsigned int v29 = crc32(0, 0, 0);
          if (*v7) {
            BOOL v30 = v13;
          }
          else {
            BOOL v30 = v9;
          }
          strncpy((char *)(a1 + 7424), v30, 0x400uLL);
          int v31 = crc32(v29, *(const Bytef **)(a1 + 8), v17);
          if (!BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), (char *)(a1 + 7424), a2, v31, v17))
          {
            uint64_t v32 = BOMPKZipGetFile(*(void *)(a1 + 12760));
            if (BOMFileWrite(v32, *(UInt8 **)(a1 + 8), v17) == v17) {
              goto LABEL_72;
            }
          }
        }
        else if (v21 == 4)
        {
          if (*v7) {
            BOOL v33 = v13;
          }
          else {
            BOOL v33 = v9;
          }
          strncpy((char *)(a1 + 7424), v33, 0x400uLL);
          if (!BOMCPIOWriteSymlink(*(void *)(a1 + 12736), (char *)(a1 + 7424), a2, *(char **)(a1 + 8))) {
            goto LABEL_72;
          }
        }
        else
        {
          char v22 = 0;
          if (v21 != 3) {
            goto LABEL_73;
          }
          if (*(unsigned char *)(a1 + 173) && v44 && (*(_WORD *)(a3 + 4) & 0xF000) == 0xA000)
          {
            uint64_t v23 = (*(uint64_t (**)(void, char *, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 256))(*(void *)(*(void *)(a1 + 12832) + 8), v13, a1 + 8448, 1024);
            if (v23 == -1) {
              goto LABEL_64;
            }
            *(unsigned char *)(a1 + v23 + 8448) = 0;
            if (v17 == v23 && !strcmp(*(const char **)(a1 + 8), (const char *)(a1 + 8448))) {
              goto LABEL_72;
            }
          }
          _parentPath(v13, (void *)(a1 + 7424), 0x400uLL);
          __strlcat_chk();
          if ((*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 336))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424)&& !(*(unsigned int (**)(void, void, uint64_t))(*(void *)(a1 + 12832) + 248))(*(void *)(*(void *)(a1 + 12832) + 8), *(void *)(a1 + 8), a1 + 7424))
          {
            if (*(_DWORD *)(a1 + 12712) == 1)
            {
              int v24 = _chPerms(a1, (char *)(a1 + 7424), a2, &v43, 1);
              uint64_t v25 = *(void *)(a1 + 12832);
              int v26 = *(unsigned int (**)(uint64_t, uint64_t))(v25 + 224);
              uint64_t v27 = *(void *)(v25 + 8);
              if (v24)
              {
                v26(v27, a1 + 7424);
                __error();
                uint64_t v28 = a1;
                return _checkCopyFileError(v28);
              }
              if (!v26(v27, (uint64_t)v13) || *__error() == 2 || *__error() == 63)
              {
                int v36 = (void **)BOM_malloc(0x18uLL);
                if (!v36) {
                  goto LABEL_96;
                }
                long long v37 = v36;
                size_t __n = strlen(v13) + 1;
                size_t v38 = strlen((const char *)(a1 + 7424)) + 1;
                size_t v39 = strlen(v9) + 1;
                *long long v37 = BOM_malloc(__n);
                v37[1] = BOM_malloc(v38);
                unsigned int v40 = BOM_malloc(v39);
                v37[2] = v40;
                if (!*v37 || !v37[1] || !v40)
                {
LABEL_96:
                  uint64_t v28 = a1;
                  return _checkCopyFileError(v28);
                }
                memcpy(*v37, v13, __n);
                memcpy(v37[1], (const void *)(a1 + 7424), v38);
                memcpy(v37[2], v9, v39);
                BOMStackPush(*(char **)(a1 + 40), (uint64_t)v37);
                char v22 = 1;
LABEL_73:
                if (*(_DWORD *)(a1 + 12712)) {
                  goto LABEL_74;
                }
                if (*(_DWORD *)(a1 + 12716) == 3)
                {
                  if (*(unsigned char *)(a1 + 170) || *(unsigned char *)(a1 + 169))
                  {
                    uint64_t v12 = _copyExtendedAttributes(a1, (uint64_t)v16, a2, 0, 0);
                    if (v12) {
                      goto LABEL_16;
                    }
                  }
                  if (!*(unsigned char *)(a1 + 171))
                  {
LABEL_74:
                    if ((v22 & 1) == 0)
                    {
                      uint64_t v34 = *(void (**)(uint64_t, const char *, uint64_t, void, void))(a1 + 96);
                      if (v34) {
                        v34(a1, v9, v8, 0, 0);
                      }
                    }
                    return 0;
                  }
                  uint64_t v35 = _copyACLs(a1, v16, 0, 1, 0);
                }
                else
                {
                  uint64_t v35 = _copyAppleDoubleToArchive(a1, (uint64_t)v16, a2, 0);
                }
                uint64_t v12 = v35;
                if (v35) {
                  goto LABEL_16;
                }
                goto LABEL_74;
              }
LABEL_71:
              __error();
              uint64_t v28 = a1;
              return _checkCopyFileError(v28);
            }
            if ((*(unsigned int (**)(void, uint64_t, char *))(*(void *)(a1 + 12832) + 264))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424, v13))
            {
              goto LABEL_64;
            }
            if (_chPerms(a1, v13, a2, &v43, 1))
            {
              (*(void (**)(void, char *))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), v13);
              goto LABEL_71;
            }
LABEL_72:
            char v22 = 0;
            goto LABEL_73;
          }
        }
        break;
      case 3:
        return v12;
      default:
        uint64_t v17 = 0;
        goto LABEL_39;
    }
    goto LABEL_64;
  }
  uint64_t v18 = a1;
LABEL_65:
  return _checkCopyFileError(v18);
}

uint64_t _copyDevice(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (unsigned char *)(a1 + 11616);
  uint64_t v5 = BOMFSObjectTypeForMode(*(_WORD *)(a2 + 4));
  if (*(_DWORD *)(a1 + 12712)) {
    uint64_t v6 = a1 + 248;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 2296);
  }
  *uint64_t v4 = 0;
  char v4[1025] = 0;
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 88);
  if (v7) {
    int v8 = v7(a1, v6, v5, 0);
  }
  else {
    int v8 = 0;
  }
  if (*(unsigned char *)(a1 + 168)) {
    int v9 = 2;
  }
  else {
    int v9 = v8;
  }
  if (v9 == 1) {
    return 0;
  }
  if (v9 == 2) {
    return 2;
  }
  memset(v17, 0, sizeof(v17));
  if (!*v4)
  {
    unsigned int v11 = (char *)(a1 + 3328);
    goto LABEL_17;
  }
  int v15 = 0;
  unsigned int v11 = (char *)(a1 + 10592);
  uint64_t result = _checkForDestinationConflict(a1, (char *)(a1 + 10592), a2, (uint64_t)v17, &v16, &v15);
  if (v15 != 1)
  {
LABEL_17:
    if (v4[1025] && !*(_DWORD *)(a1 + 12712))
    {
      if ((*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 11617, a2) == -1)goto LABEL_30; {
      if ((*(_WORD *)(a2 + 4) & 0xB000 | 0x4000) != 0x6000)
      }
      {
        uint64_t v13 = a1;
        return _checkCopyFileError(v13);
      }
    }
    int v12 = *(_DWORD *)(a1 + 12716);
    if (v12 != 4)
    {
      if (v12 == 3)
      {
        _parentPath(v11, (void *)(a1 + 7424), 0x400uLL);
        __strlcat_chk();
        if (!(*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 336))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424)|| (*(unsigned int (**)(void, uint64_t, void, void))(*(void *)(a1 + 12832) + 176))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424, *(unsigned __int16 *)(a2 + 4), *(unsigned int *)(a2 + 24))|| (*(unsigned int (**)(void, uint64_t, void, void))(*(void *)(a1 + 12832) + 192))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424, *(unsigned int *)(a2 + 16), *(unsigned int *)(a2 + 20))|| set_timestamps_0((const char *)(a1 + 7424), (long long *)(a2 + 32), (_OWORD *)(a2 + 48))|| (*(unsigned int (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 12832) + 264))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424, a1 + 3328))
        {
          goto LABEL_30;
        }
      }
      goto LABEL_31;
    }
    __strlcpy_chk();
    if (!BOMCPIOWriteDevice(*(void *)(a1 + 12736), (char *)(a1 + 7424), a2))
    {
LABEL_31:
      uint64_t v14 = *(void (**)(uint64_t, uint64_t, uint64_t, void, void))(a1 + 96);
      if (v14) {
        v14(a1, v6, v5, 0, 0);
      }
      return 0;
    }
LABEL_30:
    __error();
    uint64_t v13 = a1;
    return _checkCopyFileError(v13);
  }
  return result;
}

void *_unlockAFSCFileLock(void *result)
{
  if (result)
  {
    uint64_t result = (void *)*result;
    if (result)
    {
      uint64_t result = (void *)AFSCUnlockFile();
      if (result) {
        return (void *)fprintf((FILE *)*MEMORY[0x263EF8348], "Could not unlock AFSC file: %d\n", result);
      }
    }
  }
  return result;
}

uint64_t _skipCPIOFile(uint64_t a1)
{
  if (BOMCPIOSeek() != -1) {
    return 0;
  }
  uint64_t v3 = __error();
  char v4 = strerror(*v3);
  BOMCopierNotifyFatalError(a1, "cpio seek error: %s", v5, v6, v7, v8, v9, v10, v4);
  return 2;
}

uint64_t _skipPKZipFile()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  uint64_t v43 = *MEMORY[0x263EF8340];
  char v4 = (unsigned char *)(v0 + 12769);
  uint64_t File = BOMPKZipGetFile(*(void *)(v0 + 12752));
  uint64_t v6 = (int *)File;
  if (!*(_DWORD *)(v3 + 12776)) {
    goto LABEL_22;
  }
  BOMFileSetPartialRead(File, 1);
  if (*v4 && BOMFileSetCompression((uint64_t)v6, 1, 1, *(_DWORD *)(v3 + 12792)))
  {
    uint64_t v7 = __error();
    char v36 = strerror(*v7);
    uint64_t v14 = "pkzip set compression (1,1) error: %s";
LABEL_11:
    BOMCopierNotifyFatalError(v3, v14, v8, v9, v10, v11, v12, v13, v36);
    return 2;
  }
  while (!BOMFileEndOfCompressionStream((BOOL)v6))
  {
    if ((BOMFileRead(v6, v42, 0x20000uLL) & 0x8000000000000000) != 0)
    {
      char v16 = __error();
      char v36 = strerror(*v16);
      uint64_t v14 = "pkzip read seek error: %s";
      goto LABEL_11;
    }
  }
  if (*v4 && BOMFileSetCompression((uint64_t)v6, 0, 1, *(_DWORD *)(v3 + 12792)))
  {
    int v15 = __error();
    char v36 = strerror(*v15);
    uint64_t v14 = "pkzip set compression (0,1) error: %s";
    goto LABEL_11;
  }
  BOMFileSetPartialRead((uint64_t)v6, 0);
  int v41 = 0;
  if (BOMFileRead(v6, (char *)&v41, 4uLL) != 4)
  {
    unint64_t v19 = "pkzip read span error: %s";
LABEL_20:
    uint64_t v20 = __error();
    char v37 = strerror(*v20);
    BOMCopierNotifyFatalError(v3, v19, v21, v22, v23, v24, v25, v26, v37);
    return 2;
  }
  if (v41 != 134695760)
  {
    unint64_t v19 = "pkzip spanning doesn't match: %s";
    goto LABEL_20;
  }
  int v40 = 0;
  unint64_t v38 = 0;
  unint64_t v39 = 0;
  if (BOMPKZipReadDataDescriptor(*(int ***)(v3 + 12752), v4[43], &v40, &v39, &v38))
  {
    uint64_t v18 = __error();
    char v36 = strerror(*v18);
    uint64_t v14 = "Could not read pkzip data descriptor: %s";
    goto LABEL_11;
  }
  *(void *)(v2 + 96) = v38;
  uint64_t v27 = BOMPKZipGetFile(*(void *)(v3 + 12752));
  BOMFileSetPartialRead(v27, 1);
LABEL_22:
  if (*v4)
  {
    uint64_t v28 = BOMPKZipGetFile(*(void *)(v3 + 12752));
    if (BOMFileSetCompression(v28, 0, 1, *(_DWORD *)(v3 + 12792))) {
      return 2;
    }
  }
  if (*(_DWORD *)(v3 + 12776)) {
    return 0;
  }
  uint64_t v29 = *(void *)(v3 + 12752);
  int NumLocalHeaders = BOMPKZipGetNumLocalHeaders(v29);
  uint64_t result = BOMPKZipGetFileCompressedSize(v29, NumLocalHeaders - 1);
  if (result)
  {
    unint64_t v31 = result;
    while (1)
    {
      unint64_t v32 = v31 >= 0x20000 ? 0x20000 : v31;
      unint64_t v33 = BOMFileRead(v6, v42, v32);
      if ((v33 & 0x8000000000000000) != 0) {
        break;
      }
      unint64_t v34 = v33;
      uint64_t result = 0;
      v31 -= v34;
      if (!v31) {
        return result;
      }
    }
    uint64_t v35 = __error();
    char v36 = strerror(*v35);
    uint64_t v14 = "pkzip seek error: %s";
    goto LABEL_11;
  }
  return result;
}

uint64_t _copyDataFork(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, int a5, _DWORD *a6, _DWORD *a7, int a8)
{
  uint64_t v9 = a6;
  uint64_t v226 = *MEMORY[0x263EF8340];
  uint64_t v223 = 0;
  v224 = 0;
  v221 = 0;
  uint64_t v222 = 0;
  v219 = 0;
  uint64_t v220 = 0;
  int v209 = *(_DWORD *)(a1 + 12716);
  int v13 = *(unsigned __int8 *)(a1 + 197);
  if (a6) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = *(unsigned char *)(a1 + 173) != 0;
  }
  if (v209 == 5) {
    HIDWORD(v220) = crc32(0, 0, 0);
  }
  v215 = (unsigned char *)(a1 + 11616);
  if (*(_DWORD *)(a1 + 12712)) {
    int v15 = (const char *)(a1 + 248);
  }
  else {
    int v15 = *(const char **)(a1 + 2296);
  }
  v212 = v15;
  uint64_t v213 = a3;
  int v208 = v13;
  if (*(_DWORD *)(a1 + 12716) != 3)
  {
    if (*v215) {
      uint64_t v17 = (const char *)(a1 + 10592);
    }
    else {
      uint64_t v17 = v15;
    }
    strncpy((char *)(a1 + 7424), v17, 0x400uLL);
    goto LABEL_37;
  }
  if (*(unsigned char *)(a1 + 12823) || (a8 & 1) != 0)
  {
    if (*v215) {
      uint64_t v18 = (const char *)(a1 + 10592);
    }
    else {
      uint64_t v18 = (const char *)(a1 + 3328);
    }
    strncpy((char *)(a1 + 7424), v18, 0x400uLL);
    goto LABEL_26;
  }
  if (*v215) {
    char v16 = (char *)(a1 + 10592);
  }
  else {
    char v16 = (char *)(a1 + 3328);
  }
  _parentPath(v16, (void *)(a1 + 7424), 0x400uLL);
  __strlcat_chk();
  if ((*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 336))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424))
  {
    if (*(_DWORD *)(a1 + 12716) != 3) {
      goto LABEL_37;
    }
LABEL_26:
    if (*(unsigned __int16 *)(a3 + 6) < 2u) {
      goto LABEL_37;
    }
    v218 = 0;
    if (BOMHardLinkTableGetPathAndData(*(CFDictionaryRef **)a1, *(_DWORD *)a3, *(void *)(a3 + 8), (char *)&v225, &v218))
    {
      BOMHardLinkTableSetPathAndData(*(CFDictionaryRef **)a1, *(_DWORD *)a3, *(void *)(a3 + 8), (char *)(a1 + 3328), (const void *)(a3 + 96), 8uLL);
      goto LABEL_37;
    }
    if (*v218 == *(void *)(a3 + 96))
    {
      if (!a5
        || !(*(unsigned int (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 3328))
      {
        if (!(*(unsigned int (**)(void, stat *, uint64_t))(*(void *)(a1 + 12832) + 240))(*(void *)(*(void *)(a1 + 12832) + 8), &v225, a1 + 3328))
        {
          uint64_t v43 = 0;
          *a7 = 2;
          goto LABEL_128;
        }
        if (*__error() == 18) {
          goto LABEL_37;
        }
      }
      __error();
      uint64_t v43 = _checkCopyFileError(a1);
LABEL_128:
      LOBYTE(a2) = 0;
      uint64_t v44 = 0;
      uint64_t v202 = 0;
      v203 = 0;
      int64_t v45 = 0;
      uint64_t v46 = 0;
      int v204 = 0;
      uint64_t v205 = 0;
      __src = 0;
      v207 = 0;
      int v200 = 0;
      goto LABEL_159;
    }
LABEL_37:
    if (*(unsigned char *)(a1 + 204) == 1)
    {
      uint64_t v20 = strdup((const char *)(a1 + 3328));
      if (!v20)
      {
        uint64_t v29 = __error();
        strerror(*v29);
        BOMCopierNotifyFatalError(a1, "Could not duplicate %s: %s", v30, v31, v32, v33, v34, v35, a1);
        goto LABEL_45;
      }
      uint64_t v21 = v20;
      if (!dirname_r((const char *)(a1 + 3328), v20))
      {
        char v36 = __error();
        strerror(*v36);
        BOMCopierNotifyFatalError(a1, "Could not dirname %s: %s", v37, v38, v39, v40, v41, v42, a1);
        goto LABEL_44;
      }
      memset(&v225, 0, sizeof(v225));
      if (stat(v21, &v225))
      {
        uint64_t v22 = __error();
        strerror(*v22);
        BOMCopierNotifyFatalError(a1, "Could not stat %s: %s", v23, v24, v25, v26, v27, v28, (char)v21);
LABEL_44:
        free(v21);
        goto LABEL_45;
      }
      free(v21);
      if (*(_DWORD *)a3 == v225.st_dev)
      {
        if (!copyfile(a2, (const char *)(a1 + 3328), 0, 0x200000Fu))
        {
          LOBYTE(a2) = 0;
          uint64_t v44 = 0;
          uint64_t v202 = 0;
          v203 = 0;
          int64_t v45 = 0;
          uint64_t v46 = 0;
          int v204 = 0;
          uint64_t v205 = 0;
          __src = 0;
          v207 = 0;
          int v200 = 0;
          uint64_t v43 = 0;
          *a7 = 2;
          goto LABEL_159;
        }
        if (*__error() != 45)
        {
          uint64_t v93 = __error();
          strerror(*v93);
          BOMCopierNotifyFatalError(a1, "Could not clone %s to %s: %s", v94, v95, v96, v97, v98, v99, (char)a2);
LABEL_45:
          __error();
          uint64_t v43 = _checkCopyFileError(a1);
LABEL_46:
          LOBYTE(a2) = 0;
          uint64_t v44 = 0;
          uint64_t v202 = 0;
          v203 = 0;
          int64_t v45 = 0;
          uint64_t v46 = 0;
          int v204 = 0;
          uint64_t v205 = 0;
          __src = 0;
          v207 = 0;
          int v200 = 0;
          goto LABEL_170;
        }
      }
    }
    uint64_t v198 = (uint64_t)a2;
    LOBYTE(a2) = 0;
    uint64_t v44 = 0;
    uint64_t v202 = 0;
    v203 = 0;
    int64_t v45 = 0;
    uint64_t v46 = 0;
    uint64_t v205 = 0;
    __src = 0;
    v207 = 0;
    int v200 = 0;
    int v204 = 0;
    uint64_t v43 = 0;
    switch(*(_DWORD *)(a1 + 12712))
    {
      case 0:
        if (BOMFileOpenWithSys(&v224, v198, 0, 0, 16 * (*(unsigned char *)(a1 + 12813) == 0), *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))goto LABEL_45; {
        uint64_t v43 = 0;
        }
        goto LABEL_55;
      case 1:
        uint64_t v43 = 0;
        v224 = (int *)BOMCPIOGetFile(*(void *)(a1 + 12728));
        goto LABEL_55;
      case 2:
        uint64_t File = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
        v224 = File;
        if (*(unsigned char *)(a1 + 12796))
        {
          if (*(void *)(a1 + 12800))
          {
            v211 = v9;
            uint64_t v43 = 0;
          }
          else
          {
            long long v89 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 128);
            if (!v89)
            {
              BOMCopierNotifyFatalError(a1, "No password was provided and the client did not provide a callback for retrieving the PKZip encryption key", v51, v52, v53, v54, v55, v56, v197);
              uint64_t v43 = 2;
              goto LABEL_46;
            }
            uint64_t v43 = v89(a1, a1 + 248, a1 + 12800);
            if (v43 == 2) {
              goto LABEL_46;
            }
            v211 = v9;
            uint64_t File = v224;
          }
          if (BOMFileRead(File, (char *)&v225, 0xCuLL) != 12) {
            goto LABEL_45;
          }
          while (1)
          {
            size_t v57 = (int *)BOMFileSetKeys((uint64_t)v224, *(unsigned char **)(a1 + 12800));
            for (uint64_t i = 0; i != 12; ++i)
            {
              int v59 = *((unsigned __int8 *)&v225.st_dev + i);
              uint64_t v60 = decrypt_byte((uint64_t)v57) ^ v59;
              update_keys(v57, v60);
            }
            if (*(unsigned __int8 *)(a1 + 12811) == v60) {
              break;
            }
            free(*(void **)(a1 + 12800));
            *(void *)(a1 + 12800) = 0;
            unsigned __int8 v67 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 128);
            if (!v67)
            {
              BOMCopierNotifyFatalError(a1, "The password appears to be invalid and the client did not provide a callback for retrieving a new PKZip encryption key", v61, v62, v63, v64, v65, v66, v197);
LABEL_126:
              BOMCopierNotifyFatalError(a1, "The password provided for the encrypted PKZip archive appears to be invalid", v68, v69, v70, v71, v72, v73, v197);
              uint64_t v43 = 2;
              a3 = v213;
              goto LABEL_46;
            }
            uint64_t v43 = v67(a1, a1 + 248, a1 + 12800);
            if (v43 == 2) {
              goto LABEL_126;
            }
          }
          uint64_t v105 = v224;
          uint64_t v106 = *(void *)(a1 + 12752);
          int NumLocalHeaders = BOMPKZipGetNumLocalHeaders(v106);
          FileCompresseduint64_t Size = BOMPKZipGetFileCompressedSize(v106, NumLocalHeaders - 1);
          BOMFileSetEncryptedRemainder((uint64_t)v105, FileCompressedSize - 12);
          a3 = v213;
          uint64_t v9 = v211;
        }
        else
        {
          uint64_t v43 = 0;
        }
        if (*(unsigned char *)(a1 + 12769))
        {
          if (BOMFileSetCompression((uint64_t)v224, 1, 1, *(_DWORD *)(a1 + 12792))) {
            goto LABEL_45;
          }
          *(void *)(a3 + 96) = -1;
        }
        if (*(_DWORD *)(a1 + 12776))
        {
          BOMFileSetPartialRead((uint64_t)v224, 1);
          if (!*(unsigned char *)(a1 + 12769))
          {
            uint64_t v90 = *(void *)(a1 + 12752);
            int v91 = BOMPKZipGetNumLocalHeaders(v90);
            FileUncompresseduint64_t Size = BOMPKZipGetFileUncompressedSize(v90, v91 - 1);
            *(void *)(a3 + 96) = FileUncompressedSize;
            if (!FileUncompressedSize)
            {
              BOMFileSetDataDescriptor((uint64_t)v224, 1);
              *(void *)(a3 + 96) = -1;
            }
          }
        }
LABEL_55:
        uint64_t v44 = *(void *)(a3 + 96);
        if (v14)
        {
          uint64_t v47 = v9;
          uint64_t v48 = *(int *)(a1 + 16);
          uint64_t v210 = *(void *)(a3 + 96);
          if (v44 == -1)
          {
            uint64_t v74 = 0;
            int64_t v45 = 0;
            do
            {
              unint64_t v75 = BOMFileRead(v224, (char *)(*(void *)(a1 + 8) + v74), v48 - v74);
              if ((v75 & 0x8000000000000000) != 0)
              {
                __error();
                uint64_t v43 = _checkCopyFileError(a1);
                LOBYTE(a2) = 0;
                uint64_t v202 = 0;
                v203 = 0;
                uint64_t v46 = 0;
                int v204 = 0;
                uint64_t v205 = 0;
                __src = 0;
                v207 = 0;
                int v200 = 0;
                uint64_t v44 = -1;
                goto LABEL_170;
              }
              v74 += v75;
              v45 += v75;
            }
            while (v74 < v48 && !BOMFileEndOfCompressionStream((BOOL)v224));
          }
          else
          {
            if (v44 >= v48) {
              unint64_t v49 = *(int *)(a1 + 16);
            }
            else {
              unint64_t v49 = *(void *)(a3 + 96);
            }
            int64_t v45 = BOMFileRead(v224, *(char **)(a1 + 8), v49);
            if (v45 < 0)
            {
              __error();
              uint64_t v43 = _checkCopyFileError(a1);
              LOBYTE(a2) = 0;
              uint64_t v202 = 0;
              v203 = 0;
              int64_t v45 = 0;
              uint64_t v46 = 0;
              int v204 = 0;
              uint64_t v205 = 0;
              __src = 0;
              v207 = 0;
              int v200 = 0;
              LOBYTE(v14) = 1;
              goto LABEL_261;
            }
          }
          int v76 = BOMArchFlagForHeader(*(int **)(a1 + 8), v45);
          if (v76 == 1)
          {
            uint64_t v85 = *(void *)(a1 + 8);
            char v86 = (char *)BOM_malloc(0x1CuLL);
            if (!v86)
            {
              LOBYTE(a2) = 0;
              uint64_t v202 = 0;
              v203 = 0;
              uint64_t v46 = 0;
              int v204 = 0;
              uint64_t v205 = 0;
              __src = 0;
              v207 = 0;
              int v200 = 0;
              goto LABEL_261;
            }
            *(void *)char v86 = 0x1CAFEBABELL;
            uint64_t v84 = (uint64_t)(v86 + 8);
            int8x8_t v87 = 0;
            int v88 = *(_DWORD *)v85;
            if (*(int *)v85 > -17958195)
            {
              if (v88 == -17958193 || v88 == -17958194) {
                int8x8_t v87 = *(int8x8_t *)(v85 + 4);
              }
            }
            else if (v88 == -822415874 || v88 == -805638658)
            {
              int8x8_t v87 = vrev32_s8(*(int8x8_t *)(v85 + 4));
            }
            *((int8x8_t *)v86 + 1) = v87;
            unsigned int v78 = 1;
            int v200 = 1;
            *((_DWORD *)v86 + 4) = 0;
            v203 = (unsigned int *)v86;
            *(void *)(v86 + 20) = v210;
            uint64_t v44 = v210;
          }
          else
          {
            if (v76 == 2)
            {
              uint64_t v77 = *(unsigned int **)(a1 + 8);
              unsigned int v78 = bswap32(v77[1]);
              size_t v79 = (int)(20 * v78 + 8);
              uint64_t v80 = (unsigned int *)BOM_malloc(v79);
              if (!v80)
              {
                LOBYTE(a2) = 0;
                uint64_t v202 = 0;
                v203 = 0;
                uint64_t v46 = 0;
                int v204 = 0;
                uint64_t v205 = 0;
                __src = 0;
                v207 = 0;
                int v200 = 0;
                goto LABEL_260;
              }
              uint64_t v81 = v80;
              uint64_t v82 = v77;
              uint64_t v83 = (char *)(v80 + 2);
              memmove(v80, v82, v79);
              v203 = v81;
              _fat_header_big_to_host(v81, v79);
              uint64_t v84 = (uint64_t)v83;
              int v200 = 1;
            }
            else
            {
              unsigned int v78 = 0;
              uint64_t v84 = 0;
              v203 = 0;
              int v200 = 0;
            }
            uint64_t v44 = v210;
          }
          if (_determine_thin_type_and_archs(v84, v78, v47, &v221, &v222, (_DWORD *)&v222 + 1, 0))
          {
            LOBYTE(a2) = 0;
            uint64_t v202 = 0;
            uint64_t v46 = 0;
            int v204 = 0;
            uint64_t v205 = 0;
            __src = 0;
            v207 = 0;
            uint64_t v43 = 0;
            *a7 = 1;
            a3 = v213;
            goto LABEL_159;
          }
          a3 = v213;
          if (HIDWORD(v222))
          {
            int v100 = 20 * v222 + 8;
            long long v101 = BOM_malloc(v100);
            int v204 = v100;
            if (v101)
            {
              uint64_t v102 = (uint64_t)(v101 + 2);
              *long long v101 = -889275714;
              int v103 = v222;
              __src = v101;
              v101[1] = v222;
              _sortFatArchsByOffset(v221, v103);
              if (HIDWORD(v222) == 1) {
                int v104 = 0;
              }
              else {
                int v104 = v100;
              }
              _createNewFatArchArray((uint64_t *)v221, v222, v102, v104);
              LODWORD(a2) = 0;
              uint64_t v202 = 0;
              v207 = 0;
              uint64_t v205 = v102;
              uint64_t v46 = (*(_DWORD *)(v102 + 20 * (int)v222 - 8) + *(_DWORD *)(v102 + 20 * (int)v222 - 12));
              goto LABEL_130;
            }
            LOBYTE(a2) = 0;
            uint64_t v202 = 0;
            uint64_t v46 = 0;
            uint64_t v205 = 0;
            __src = 0;
            v207 = 0;
            while (1)
            {
              while (1)
              {
LABEL_170:
                if (v223 && *(_DWORD *)(a1 + 12716) == 3)
                {
                  if (BOMFileClose(v223) && !v43)
                  {
                    __error();
                    uint64_t v43 = _checkCopyFileError(a1);
                  }
                  uint64_t v223 = 0;
                }
                if (v43 != 0 || (a2 & 1) == 0 || v44 <= v45)
                {
                  BOMFileSetDataDescriptor((uint64_t)v224, 0);
                  if (v224)
                  {
                    CFBooleanRef v123 = v203;
                    CFBooleanRef v124 = __src;
                    CFBooleanRef v125 = v207;
                    if (!*(_DWORD *)(a1 + 12712))
                    {
                      int v126 = BOMFileClose((uint64_t)v224);
                      if (!v43 && v126)
                      {
                        __error();
                        uint64_t v43 = _checkCopyFileError(a1);
                      }
                      v224 = 0;
                    }
                  }
                  else
                  {
                    CFBooleanRef v123 = v203;
                    CFBooleanRef v124 = __src;
                    CFBooleanRef v125 = v207;
                  }
                  if (v123) {
                    free(v123);
                  }
                  if (v221) {
                    free(v221);
                  }
                  if (v124) {
                    free(v124);
                  }
                  if (v125) {
                    free(v125);
                  }
                  return v43;
                }
                uint64_t v43 = 0;
                if (v14) {
                  LOBYTE(v14) = 0;
                }
                if (v46 >= v44 - v45) {
                  uint64_t v46 = v44 - v45;
                }
                LODWORD(a2) = 1;
                a8 = 1;
LABEL_130:
                int v109 = *(_DWORD *)(a1 + 12716);
                if (v109 != 3)
                {
                  if (v46 == -1) {
                    uint64_t v114 = 0;
                  }
                  else {
                    uint64_t v114 = v46;
                  }
                  *(void *)(a3 + 96) = v114;
                  CFBooleanRef v115 = (char *)(a1 + 7424);
                  if (v109 == 4)
                  {
                    if (BOMCPIOWriteHeader(*(void *)(a1 + 12736), v115, a3)) {
                      goto LABEL_169;
                    }
                    uint64_t v223 = BOMCPIOGetFile(*(void *)(a1 + 12736));
                  }
                  else
                  {
                    if (BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), v115, a3, 0, 0)) {
                      goto LABEL_169;
                    }
                    uint64_t v122 = BOMPKZipGetFile(*(void *)(a1 + 12760));
                    uint64_t v223 = v122;
                    if (v46 >= 1)
                    {
                      if (BOMFileSetCompression(v122, 1, 0, *(_DWORD *)(a1 + 12792))) {
                        goto LABEL_169;
                      }
                      uint64_t v202 = BOMFileOffset(v223);
                    }
                  }
                  goto LABEL_205;
                }
                uint64_t v110 = v44;
                char v111 = 16 * (*(unsigned char *)(a1 + 12814) == 0);
                BOOL v112 = !a5 || *(unsigned char *)(a1 + 12823) == 0;
                char v113 = v112 ? 1 : a8;
                if ((v113 & 1) != 0
                  || !(*(unsigned int (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424))
                {
                  break;
                }
                __error();
                uint64_t v43 = _checkCopyFileError(a1);
LABEL_158:
                uint64_t v44 = v110;
LABEL_159:
                int v118 = *(_DWORD *)(a1 + 12712);
                switch(v118)
                {
                  case 3:
                    uint64_t v43 = 2;
                    break;
                  case 2:
                    *(void *)(a3 + 96) = 0;
                    int v119 = _skipPKZipFile();
                    goto LABEL_165;
                  case 1:
                    *(void *)(a3 + 96) -= v45;
                    int v119 = _skipCPIOFile(a1);
LABEL_165:
                    if (v119) {
                      uint64_t v43 = 2;
                    }
                    else {
                      uint64_t v43 = v43;
                    }
                    break;
                }
              }
              if (a8) {
                uint64_t v116 = 521;
              }
              else {
                uint64_t v116 = 2561;
              }
              if (BOMFileOpenWithSys(&v223, a1 + 7424, v116, 384, v111, *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))
              {
                if (*__error() != 2
                  || !*(_DWORD *)(a1 + 12712)
                  || _mkdirs_parent(a1)
                  || (!a8 ? (uint64_t v117 = 1537) : (uint64_t v117 = 521),
                      BOMFileOpenWithSys(&v223, a1 + 7424, v117, 384, v111, *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832))))
                {
                  __error();
                  uint64_t v43 = _checkCopyFileError(a1);
                  a3 = v213;
                  goto LABEL_158;
                }
              }
              if (*(unsigned char *)(a1 + 207) == 1 || *(unsigned char *)(a1 + 208) == 1 || *(unsigned char *)(a1 + 211) == 1)
              {
                int FileDescriptor = BOMFileGetFileDescriptor(v223);
                a3 = v213;
                if (FileDescriptor != -1)
                {
                  int v121 = FileDescriptor;
                  uint64_t v44 = v110;
                  if (*(unsigned char *)(a1 + 211) == 1 && fcntl(FileDescriptor, 64, *(unsigned int *)(a1 + 212))
                    || *(unsigned char *)(a1 + 207) == 1 && fcntl(v121, 68, 1)
                    || *(unsigned char *)(a1 + 208) == 1 && fcntl(v121, 76, 1))
                  {
                    __error();
                    uint64_t v43 = _checkCopyFileError(a1);
                    goto LABEL_159;
                  }
                  goto LABEL_205;
                }
              }
              else
              {
                a3 = v213;
              }
              uint64_t v44 = v110;
LABEL_205:
              if (HIDWORD(v222))
              {
                CFBooleanRef v127 = BOM_calloc(168 * (int)v222 + 168, 1uLL);
                if (v127)
                {
                  uint64_t v128 = (uint64_t)v127;
                  int v129 = 0;
                  uint64_t v130 = v44;
                  uint64_t v131 = 0;
                  void *v127 = a1;
                  uint64_t v132 = v223;
                  v127[1] = v224;
                  v127[2] = v132;
                  v127[3] = v212;
                  v127[4] = v130;
                  uint64_t v210 = v130;
                  v127[5] = v46;
                  CFBooleanRef v133 = v127 + 7;
                  if (HIDWORD(v222) != 2) {
                    goto LABEL_210;
                  }
                  uint64_t v131 = v204;
                  CFBooleanRef v134 = (unsigned int *)BOM_malloc(v204);
                  if (v134)
                  {
                    CFBooleanRef v135 = v134;
                    memmove(v134, __src, v204);
                    _fat_header_host_to_big(v135, v204);
                    int v129 = 1;
                    *(_DWORD *)(v128 + 56) = 1;
                    *(void *)(v128 + 64) = v204;
                    *(_DWORD *)(v128 + 72) = 1;
                    *(void *)(v128 + 80) = 0;
                    *(void *)(v128 + 88) = v135;
                    v207 = v135;
                    *(void *)(v128 + 96) = 0;
                    *(void *)(v128 + 104) = 0;
                    a3 = v213;
LABEL_210:
                    if ((int)v222 >= 1)
                    {
                      uint64_t v136 = 0;
                      int v137 = (unsigned int *)(v205 + 8);
                      while (1)
                      {
                        uint64_t v138 = *((void *)v221 + v136);
                        unsigned int v140 = *v137;
                        v137 += 5;
                        uint64_t v139 = v140;
                        uint64_t v141 = v140 - v131;
                        if (v140 <= v131)
                        {
                          uint64_t v139 = v131;
                        }
                        else
                        {
                          CFDataRef v142 = &v133[7 * v129];
                          *(_DWORD *)CFDataRef v142 = 0;
                          v142[1] = v141;
                          *((_DWORD *)v142 + 4) = 1;
                          v142[3] = 0;
                          v142[4] = 0;
                          v142[5] = v131;
                          v142[6] = 0;
                          ++v129;
                        }
                        uint64_t v143 = *(unsigned int *)(v138 + 8);
                        uint64_t v144 = *(unsigned int *)(v138 + 12);
                        uint64_t v145 = v45 - v143;
                        if (v45 <= v143) {
                          break;
                        }
                        int64_t v146 = (v144 + v143);
                        BOOL v147 = v146 <= v45;
                        int64_t v148 = v146 - v45;
                        if (v147)
                        {
                          int v151 = &v133[7 * v129];
                          *(_DWORD *)int v151 = 1;
                          v151[1] = v144;
                          *((_DWORD *)v151 + 4) = 1;
                          v151[3] = 0;
                          v151[4] = *(void *)(a1 + 8) + v143;
                          goto LABEL_220;
                        }
                        int v149 = &v133[7 * v129];
                        *(_DWORD *)int v149 = 1;
                        v149[1] = v145;
                        *((_DWORD *)v149 + 4) = 1;
                        v149[3] = 0;
                        v149[4] = *(void *)(a1 + 8) + v143;
                        v149[5] = v139;
                        v149[6] = 0;
                        uint64_t v150 = v145 + v139;
                        ++v129;
                        *((_DWORD *)v149 + 14) = 2;
                        v149[8] = v148;
                        *((_DWORD *)v149 + 18) = 1;
                        v149[10] = v45;
                        v149[11] = 0;
                        v149[12] = v150;
                        v149[13] = 0;
                        uint64_t v131 = v148 + v150;
LABEL_221:
                        ++v129;
                        if (++v136 >= (int)v222) {
                          goto LABEL_222;
                        }
                      }
                      int v151 = &v133[7 * v129];
                      *(_DWORD *)int v151 = 2;
                      v151[1] = v144;
                      *((_DWORD *)v151 + 4) = 1;
                      v151[3] = v143;
                      v151[4] = 0;
LABEL_220:
                      v151[5] = v139;
                      v151[6] = 0;
                      uint64_t v131 = v139 + v144;
                      goto LABEL_221;
                    }
LABEL_222:
                    int v152 = &v133[7 * v129];
                    *(_DWORD *)int v152 = 4;
                    v152[1] = 0;
                    *((_DWORD *)v152 + 4) = 1;
                    unsigned int v153 = v129 + 1;
                    uint64_t v44 = v210;
                    v152[3] = v210;
                    v152[4] = 0;
                    v152[5] = 0;
                    v152[6] = 0;
                    goto LABEL_223;
                  }
                  v207 = 0;
LABEL_260:
                  a3 = v213;
LABEL_261:
                  uint64_t v44 = v210;
                }
              }
              else
              {
                uint64_t v157 = BOM_calloc(0xA8uLL, 1uLL);
                if (v157)
                {
                  uint64_t v128 = (uint64_t)v157;
                  *uint64_t v157 = a1;
                  uint64_t v158 = v223;
                  v157[1] = v224;
                  v157[2] = v158;
                  v157[3] = v212;
                  v157[4] = v44;
                  v157[5] = v46;
                  if (v14)
                  {
                    unsigned int v153 = 1;
                    *((_DWORD *)v157 + 14) = 1;
                    v157[8] = v45;
                    *((_DWORD *)v157 + 18) = 1;
                    v157[10] = 0;
                    v157[11] = *(void *)(a1 + 8);
                    v157[12] = 0;
                    v157[13] = 0;
                    int64_t v159 = v45;
                    if (a2)
                    {
                      *((_DWORD *)v157 + 28) = 2;
                      v157[15] = v46 - v45;
                      *((_DWORD *)v157 + 32) = 1;
                      v157[17] = v45;
                      v157[18] = 0;
                      v157[19] = v45;
                      v157[20] = 0;
                      int64_t v45 = v46;
                      unsigned int v153 = 2;
                      goto LABEL_223;
                    }
                  }
                  else
                  {
                    int64_t v159 = 0;
                    unsigned int v153 = 0;
                    if (a2)
                    {
                      *((_DWORD *)v157 + 14) = 2;
                      v157[8] = v46;
                      unsigned int v153 = 1;
                      *((_DWORD *)v157 + 18) = 1;
                      v157[10] = v45;
                      v157[11] = 0;
                      v157[12] = v45;
                      v157[13] = 0;
                      v45 += v46;
                      goto LABEL_223;
                    }
                  }
                  if (v46 == -1 || v46 > v45)
                  {
                    uint64_t v160 = (uint64_t)&v157[7 * v153 + 7];
                    *(_DWORD *)uint64_t v160 = 3;
                    *(void *)(v160 + 8) = 0;
                    *(_DWORD *)(v160 + 16) = 1;
                    *(void *)(v160 + 24) = v45;
                    *(void *)(v160 + 32) = 0;
                    *(void *)(v160 + 40) = v159;
                    *(void *)(v160 + 48) = 0;
                    ++v153;
                  }
LABEL_223:
                  *(_DWORD *)(v128 + 48) = v153;
                  uint64_t v154 = v44;
                  _normalizeBomCopySpecification(v128, 0x1000u, *(_DWORD *)(a1 + 16), (size_t *)&v219);
                  if ((*(_DWORD *)(a3 + 116) & 0x40000020) == 0x20
                    && *(unsigned char *)(a1 + 195)
                    && *((void *)v219 + 4) == *((void *)v219 + 5))
                  {
                    *(unsigned char *)(a1 + 196) = 0;
                    if (!v208) {
                      goto LABEL_236;
                    }
                  }
                  else
                  {
                    BOMFileSetAFSCCompression(v223);
                    if (v209 == 5) {
                      int v155 = (unsigned int *)&v220 + 1;
                    }
                    else {
                      int v155 = 0;
                    }
                    if (v208) {
                      int v156 = &v220;
                    }
                    else {
                      int v156 = 0;
                    }
                    uint64_t v43 = _executeBomCopySpecification((int *)v219, 0x1000u, *(_DWORD *)(a1 + 16), v155, (uint64_t)v156, v45);
                    if (!v208) {
                      goto LABEL_236;
                    }
                  }
                  *(_DWORD *)(a1 + 200) = v220;
LABEL_236:
                  free((void *)v128);
                  free(v219);
                  v219 = 0;
                  if (v43) {
                    goto LABEL_237;
                  }
                  if (a5
                    && *(unsigned char *)(a1 + 173)
                    && *(_DWORD *)(a1 + 12716) == 3
                    && !*a7
                    && (v200
                     || (int v162 = *(regex_t **)(a1 + 184)) != 0 && BOMPatternMatch(v162, *(const char **)(a1 + 2296))))
                  {
                    if (!*(void *)(a1 + 12936))
                    {
                      ++*(void *)(a1 + 10576);
                      snprintf((char *)(a1 + 8448), 0x400uLL, "%s.dittoKeptBinary.%d.%lu");
                      goto LABEL_288;
                    }
                    uint64_t v161 = *(void *)(a1 + 10576);
                    if (__ROR8__(0x8F5C28F5C28F5C29 * v161, 1) <= 0x51EB851EB851EB8uLL)
                    {
                      long long v184 = *(void **)(a1 + 10584);
                      if (v184) {
                        free(v184);
                      }
                      *(void *)&v225.st_dev = 0;
                      v225.st_ino = 0;
                      uuid_generate_random((unsigned __int8 *)&v225);
                      long long v185 = (char *)malloc_type_malloc(0x25uLL, 0x12A6DCF8uLL);
                      uuid_unparse((const unsigned __int8 *)&v225, v185);
                      long long v186 = (char *)malloc_type_malloc(0x400uLL, 0x66ADC323uLL);
                      *(void *)(a1 + 10584) = v186;
                      snprintf(v186, 0x400uLL, "%s/%.2s/%.2s/%.2s/%s", *(const char **)(a1 + 12936), v185, v185 + 2, v185 + 4, v185);
                      free(v185);
                      if (!_mkdirs(a1, *(void *)(a1 + 10584)))
                      {
                        uint64_t v161 = *(void *)(a1 + 10576);
                        goto LABEL_275;
                      }
                      uint64_t v187 = *(void *)(a1 + 10584);
                      long long v188 = __error();
                      long long v189 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
                      if (v189) {
                        v189(a1, v187, *v188);
                      }
LABEL_304:
                      uint64_t v43 = 0;
                    }
                    else
                    {
LABEL_275:
                      *(void *)(a1 + 10576) = v161 + 1;
                      snprintf((char *)(a1 + 8448), 0x400uLL, "%s/%lu");
LABEL_288:
                      uint64_t v169 = *(void *)(a1 + 12832);
                      uint64_t v170 = *(void *)(v169 + 8);
                      uint64_t v171 = a1 + 3328;
                      if ((*(_WORD *)(a4 + 4) & 0xF000) == 0x8000) {
                        int v172 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v169 + 240))(v170, v171, a1 + 8448);
                      }
                      else {
                        int v172 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v169 + 264))(v170, v171, a1 + 8448);
                      }
                      if (v172)
                      {
                        uint64_t v173 = __error();
                        int v165 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
                        uint64_t v43 = 2;
                        if (v165)
                        {
                          uint64_t v166 = *v173;
                          uint64_t v168 = a1;
                          uint64_t v167 = a1 + 8448;
LABEL_294:
                          v165(v168, v167, v166);
                        }
                      }
                      else
                      {
                        uint64_t v174 = *(void *)(a1 + 176);
                        if (!v174) {
                          goto LABEL_246;
                        }
                        size_t v175 = strlen((const char *)(a1 + 8448));
                        if (BOMFileWrite(v174, (UInt8 *)(a1 + 8448), v175) == v175)
                        {
                          a3 = v213;
                          if (BOMFileWrite(*(void *)(a1 + 176), (UInt8 *)"\n", 1) == 1) {
                            goto LABEL_246;
                          }
                          stat v176 = __error();
                          char v177 = strerror(*v176);
                          BOMCopierNotifyFatalError(a1, "can't write to keepBinariesList: %s", v178, v179, v180, v181, v182, v183, v177);
                          uint64_t v43 = 2;
                        }
                        else
                        {
                          long long v190 = __error();
                          strerror(*v190);
                          BOMCopierNotifyFatalError(a1, "can't write %s to keepBinariesList: %s", v191, v192, v193, v194, v195, v196, a1);
                          uint64_t v43 = 2;
                          a3 = v213;
                        }
LABEL_237:
                        uint64_t v44 = v154;
                      }
                    }
                  }
                  else
                  {
LABEL_246:
                    uint64_t v44 = v154;
                    if (*(_DWORD *)(a1 + 12712) != 2) {
                      goto LABEL_280;
                    }
                    if (*(unsigned char *)(a1 + 12769)
                      && BOMFileSetCompression((uint64_t)v224, 0, 1, *(_DWORD *)(a1 + 12792)))
                    {
LABEL_169:
                      __error();
                      uint64_t v43 = _checkCopyFileError(a1);
                    }
                    else
                    {
                      BOMFileClearEncrypted((uint64_t)v224);
                      if (*(_DWORD *)(a1 + 12776))
                      {
                        BOMFileSetPartialRead((uint64_t)v224, 0);
                        BOMFileSetDataDescriptor((uint64_t)v224, 0);
                        int v217 = 0;
                        if (BOMFileRead(v224, (char *)&v217, 4uLL) != 4) {
                          goto LABEL_169;
                        }
                        if (v217 != 134695760) {
                          goto LABEL_169;
                        }
                        int v216 = 0;
                        *(void *)&v225.st_dev = 0;
                        v218 = 0;
                        if (BOMPKZipReadDataDescriptor(*(int ***)(a1 + 12752), *(unsigned __int8 *)(a1 + 12812), &v216, (unint64_t *)&v225, (unint64_t *)&v218))goto LABEL_169; {
                        *(void *)(a3 + 96) = v218;
                        }
                      }
LABEL_280:
                      if (*(_DWORD *)(a1 + 12716) != 5 || !*(void *)(a3 + 96)) {
                        goto LABEL_304;
                      }
                      if (BOMFileSetCompression(v223, 0, 0, *(_DWORD *)(a1 + 12792))) {
                        goto LABEL_169;
                      }
                      uint64_t v163 = BOMFileOffset(v223) - v202;
                      v225.st_dev = 134695760;
                      uint64_t v202 = v163;
                      if (BOMFileWrite(v223, (UInt8 *)&v225, 4) != 4) {
                        goto LABEL_169;
                      }
                      uint64_t v43 = 0;
                      if (BOMPKZipWriteDataDescriptor(*(void *)(a1 + 12760), HIDWORD(v220), v163, *(_DWORD *)(a3 + 96)))
                      {
                        os_log_t v164 = __error();
                        int v165 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
                        uint64_t v43 = 2;
                        if (v165)
                        {
                          uint64_t v166 = *v164;
                          uint64_t v167 = a1 + 8448;
                          uint64_t v168 = a1;
                          goto LABEL_294;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else
        {
          int v200 = 0;
          v203 = 0;
          int64_t v45 = 0;
          HIDWORD(v222) = 0;
        }
        if ((unint64_t)v44 >> 33 && *(unsigned char *)(a1 + 12824))
        {
          uint64_t v202 = 0;
          int v204 = 0;
          uint64_t v205 = 0;
          __src = 0;
          v207 = 0;
          LODWORD(a2) = 1;
          uint64_t v46 = 0x40000000;
        }
        else
        {
          LODWORD(a2) = 0;
          uint64_t v202 = 0;
          int v204 = 0;
          uint64_t v205 = 0;
          __src = 0;
          v207 = 0;
          uint64_t v46 = v44;
        }
        goto LABEL_130;
      case 3:
        goto LABEL_170;
      default:
        uint64_t v43 = 0;
        goto LABEL_55;
    }
  }
  __error();
  return _checkCopyFileError(a1);
}

uint64_t _copyAppleDoubleToArchive(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(a1 + 12716) == 3) {
    goto LABEL_21;
  }
  uint64_t v8 = a1 + 11616;
  uint64_t v9 = *(void *)(a1 + 2296);
  uint64_t v10 = a1 + 7424;
  uint64_t v11 = *(unsigned char *)(a1 + 11616) ? (const char *)(a1 + 10592) : *(const char **)(a1 + 2296);
  uint64_t v12 = strncpy((char *)(a1 + 7424), v11, 0x400uLL);
  BOMAppleDoublePathToADPath(v12, (char *)(a1 + 5376));
  if (*(unsigned char *)(a1 + 170) || *(unsigned char *)(a1 + 169)) {
    int v13 = 4980740;
  }
  else {
    int v13 = 4980736;
  }
  uint64_t v14 = v13 | (*(unsigned char *)(a1 + 171) != 0);
  if (((*(unsigned int (**)(void, uint64_t, void, void, void))(*(void *)(a1 + 12832) + 344))(*(void *)(*(void *)(a1 + 12832) + 8), a2, 0, 0, v14 | 0x10000) & v14) == 0)
  {
LABEL_21:
    uint64_t v17 = 0;
    if (a4) {
      *a4 = 1;
    }
    return v17;
  }
  if (!issetugid()) {
    getenv("TMPDIR");
  }
  if ((unint64_t)__strlcpy_chk() < 0x400 && (unint64_t)__strlcat_chk() < 0x400)
  {
    if (!(*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 12832) + 336))(*(void *)(*(void *)(a1 + 12832) + 8), v10))goto LABEL_25; {
    if ((*(unsigned int (**)(void, uint64_t, uint64_t, void, uint64_t))(*(void *)(a1 + 12832) + 344))(*(void *)(*(void *)(a1 + 12832) + 8), a2, v10, 0, v14))
    }
    {
      if (*__error() == 1 && *(void *)(a1 + 12840)) {
        goto LABEL_21;
      }
LABEL_25:
      __error();
      uint64_t v15 = a1;
      goto LABEL_14;
    }
    long long v34 = 0u;
    long long v35 = 0u;
    long long v33 = 0u;
    memset(v32, 0, sizeof(v32));
    if ((*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), v10, v32)|| (unint64_t v18 = v33, v19 = *(unsigned char *)(v8 + 1197) == 0, v31 = 0, BOMFileOpenWithSys(&v31, v10, 0, 0, 16 * v19, *(void (***)(void, uint64_t, uint64_t, uint64_t))(a1 + 12832)))&& *__error() != 2)
    {
      __error();
      uint64_t v17 = _checkCopyFileError(a1);
      (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), v10);
      return v17;
    }
    (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), v10);
    *(void *)(a3 + 96) = v18;
    *(_WORD *)(a3 + 4) = *(_WORD *)(a3 + 4) & 0x1B6 | 0x8000;
    int v20 = *(_DWORD *)(a1 + 12716);
    if (v20 == 5)
    {
      if (*(unsigned char *)(v8 + 1152))
      {
        snprintf((char *)__str, 0x400uLL, "./%s/%s", "__MACOSX", (const char *)(a1 + 5378));
        _parentPath((char *)__str, v36, 0x400uLL);
        if (_insertQuarantinePath(*(void *)(a1 + 12760), v36, 1)) {
          goto LABEL_64;
        }
        __strlcpy_chk();
      }
      if (BOMPKZipWriteLocalHeader(*(void *)(a1 + 12760), (char *)(a1 + 5376), a3, 0, 0)) {
        goto LABEL_64;
      }
      uint64_t File = BOMPKZipGetFile(*(void *)(a1 + 12760));
      if (BOMFileSetCompression(File, 1, 0, *(_DWORD *)(a1 + 12792))) {
        goto LABEL_64;
      }
      int v30 = BOMFileOffset(File);
      if (v18)
      {
LABEL_39:
        unint64_t v23 = 0;
        unsigned int v24 = 0;
        while (!*(unsigned char *)(a1 + 168))
        {
          if (v18 - v23 >= 0x20000) {
            uint64_t v25 = 0x20000;
          }
          else {
            uint64_t v25 = v18 - v23;
          }
          if (BOMFileRead(v31, *(char **)(a1 + 8), v25) != v25 || BOMFileWrite(File, *(UInt8 **)(a1 + 8), v25) != v25) {
            goto LABEL_64;
          }
          v23 += v25;
          if (a4)
          {
            uint64_t v26 = *(void (**)(uint64_t, uint64_t, unint64_t))(a1 + 104);
            if (v26) {
              v26(a1, v9, *(void *)(a3 + 96) + v23);
            }
          }
          if (*(_DWORD *)(a1 + 12716) == 5) {
            unsigned int v24 = crc32(v24, *(const Bytef **)(a1 + 8), v25);
          }
          if (v23 >= v18) {
            goto LABEL_58;
          }
        }
        BOMFileClose((uint64_t)v31);
        return 2;
      }
    }
    else
    {
      if (v20 != 4)
      {
        BOMFileClose((uint64_t)v31);
        uint64_t v21 = a1;
        return _checkCopyFileError(v21);
      }
      if (BOMCPIOWriteHeader(*(void *)(a1 + 12736), (char *)(a1 + 5376), a3)) {
        goto LABEL_64;
      }
      uint64_t File = BOMCPIOGetFile(*(void *)(a1 + 12736));
      int v30 = 0;
      if (v18) {
        goto LABEL_39;
      }
    }
    unsigned int v24 = 0;
LABEL_58:
    if (*(_DWORD *)(a1 + 12716) != 5) {
      goto LABEL_66;
    }
    if (!BOMFileSetCompression(File, 0, 0, *(_DWORD *)(a1 + 12792)))
    {
      int v27 = BOMFileOffset(File);
      *(_DWORD *)__str = 134695760;
      if (BOMFileWrite(File, __str, 4) == 4)
      {
        if (BOMPKZipWriteDataDescriptor(*(void *)(a1 + 12760), v24, v27 - v30, *(_DWORD *)(a3 + 96)))
        {
          BOMFileClose((uint64_t)v31);
          uint64_t v28 = __error();
          uint64_t v29 = *(void (**)(uint64_t, uint64_t, void))(a1 + 64);
          if (v29) {
            v29(a1, a1 + 8448, *v28);
          }
          return 2;
        }
LABEL_66:
        BOMFileClose((uint64_t)v31);
        uint64_t v17 = 0;
        if (a4) {
          *a4 = 0;
        }
        return v17;
      }
    }
LABEL_64:
    BOMFileClose((uint64_t)v31);
    __error();
    uint64_t v21 = a1;
    return _checkCopyFileError(v21);
  }
  uint64_t v15 = a1;
LABEL_14:
  return _checkCopyFileError(v15);
}

uint64_t change_flags_0(uint64_t a1, char *a2, int a3, uint64_t a4)
{
  v9[0] = a3;
  v9[1] = a4;
  int v10 = -1;
  if (fsctl(a2, 0xC00C4114uLL, v9, 0))
  {
    if (*__error() != 25 && *__error() != 45) {
      return 1;
    }
    uint64_t result = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 208))(*(void *)(*(void *)(a1 + 12832) + 8), a2, a4);
    if (!result) {
      return result;
    }
    BOOL v8 = *__error() == 45;
  }
  else
  {
    BOOL v8 = v9[0] == v10;
  }
  return !v8;
}

void *_parentPath(char *a1, void *a2, size_t a3)
{
  uint64_t v6 = strrchr(a1, 47);
  if (v6)
  {
    int64_t v7 = v6 - a1;
    uint64_t result = memcpy(a2, a1, v6 - a1);
    *((unsigned char *)a2 + v7) = 0;
  }
  else
  {
    return (void *)strlcpy((char *)a2, ".", a3);
  }
  return result;
}

uint64_t _insertQuarantinePath(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  char v16 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  if (BOMPKZipLookupQuarantinePath(a1, a2, &v16)) {
    return 0xFFFFFFFFLL;
  }
  if (v16) {
    return 0;
  }
  _parentPath(a2, v17, 0x401uLL);
  if (v17[0] != 46 && _insertQuarantinePath(a1, v17, a3)) {
    return 0xFFFFFFFFLL;
  }
  if (a3)
  {
    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    long long v8 = 0u;
    long long v9 = 0u;
    long long v7 = 0u;
    WORD2(v7) = 16893;
    LODWORD(v8) = geteuid();
    DWORD1(v8) = getegid();
    *(void *)&long long v9 = time(0);
    *(void *)&long long v10 = time(0);
    *(void *)&long long v11 = time(0);
    *(void *)&long long v13 = 748;
    if (BOMPKZipWriteLocalHeader(a1, a2, (uint64_t)&v7, 0, 0)) {
      return 0xFFFFFFFFLL;
    }
  }
  if (BOMPKZipStoreQuarantinePath(a1, a2)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t _copyFromCPIO(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, size_t a5, int a6)
{
  __int16 v83 = 0;
  long long v9 = (unsigned char *)(a1 + 248);
  unsigned int v10 = strlen((const char *)(a1 + 248));
  long long v11 = (char *)BOM_malloc(v10 + 2);
  if (!v11) {
    return 2;
  }
  long long v12 = v11;
  memmove(v11, v9, v10);
  __s2 = v12;
  if (v10)
  {
    unsigned int v13 = v10 + 1;
    v12[v10] = 47;
    v12[v10 + 1] = 0;
  }
  else
  {
    unsigned int v13 = 0;
  }
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  unint64_t v15 = 0;
  int v16 = 0;
  int __s1 = (char *)(a1 + 7424);
  __source = 0;
  int v76 = (char *)(a1 + 3328);
  size_t v17 = v13;
  size_t v77 = v13;
  while (1)
  {
    unsigned int v84 = 0;
    if (*(unsigned char *)(a1 + 12721) == 1)
    {
      *__error() = 0;
      __strlcpy_chk();
      int v18 = BOMCPIOReadHeader(*(void *)(a1 + 12728), v9, a2);
      if (v18) {
        break;
      }
    }
    uint64_t v25 = v9;
    if (*v9 == 46)
    {
      if (*(unsigned char *)(a1 + 249) == 47) {
        uint64_t v25 = (const char *)(a1 + 249);
      }
      else {
        uint64_t v25 = v9;
      }
    }
    if (strlcpy(a4, v25, a5) >= a5)
    {
      uint64_t v54 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (v54) {
        v54(a1, v25, 63);
      }
      goto LABEL_110;
    }
    if ((!a6 || *(unsigned char *)(a1 + 12822)) && *v25 == 46 && (!v25[1] || v25[1] == 47 && !v25[2]))
    {
      if (_chPerms(a1, v76, a2, &v83, 1))
      {
        uint64_t v26 = __error();
        int v27 = *(void (**)(uint64_t, char *, void))(a1 + 64);
        if (v27) {
          v27(a1, v76, *v26);
        }
      }
      LOWORD(v72) = *(_WORD *)(a2 + 4);
    }
    if (strncmp(v9, __s2, v17))
    {
      *(unsigned char *)(a1 + 12721) = 0;
      uint64_t v52 = __s2;
      __s2[(v17 - 1)] = 0;
      uint64_t v53 = *(void (**)(uint64_t, char *, uint64_t, void, void))(a1 + 96);
      uint64_t v51 = __source;
      if (v53) {
LABEL_84:
      }
        v53(a1, v52, 2, 0, 0);
LABEL_85:
      if (v51) {
        goto LABEL_86;
      }
      goto LABEL_102;
    }
    BOOL v34 = 1;
    *(unsigned char *)(a1 + 12721) = 1;
    if (*(unsigned char *)(a1 + 169) && *(_DWORD *)(a1 + 12716) == 3 && (*(_WORD *)(a2 + 4) & 0xF000) == 0x8000) {
      BOOL v34 = BOMAppleDoubleIsADFile(v9) == 0;
    }
    if (!*(unsigned char *)(a1 + 12824) || (*(_WORD *)(a2 + 4) & 0xF000) != 0x8000) {
      goto LABEL_37;
    }
    if (!v16 && *(void *)(a2 + 96) == 0x40000000)
    {
      int v35 = 0;
      int v16 = 1;
      goto LABEL_38;
    }
    if ((v16 == 2 || v16 == 1) && !strcmp(__s1, v9))
    {
      int v16 = 2;
      int v35 = 1;
    }
    else
    {
LABEL_37:
      int v35 = 0;
      int v16 = 0;
    }
LABEL_38:
    if (*(_DWORD *)(a1 + 12716) == 3
      && (unsigned int v36 = _checkForDestinationConflict(a1, v76, a2, a3, (unsigned char *)&v83 + 1, &v84), v84 == 1))
    {
      unsigned int v44 = v36;
      if (v36 > 1 || _skipCPIOFile(a1)) {
        goto LABEL_110;
      }
      int v45 = HIDWORD(v72);
      if (v44 == 1) {
        int v45 = 1;
      }
      HIDWORD(v72) = v45;
      size_t v17 = v77;
    }
    else
    {
      uint64_t v37 = *(void *)(a1 + 152);
      if (v37)
      {
        uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(v37, v9);
        if (!FSObjectAtPath) {
          goto LABEL_46;
        }
        BOMFSObjectFree(FSObjectAtPath);
      }
      uint64_t v39 = *(void *)(a1 + 160);
      if (v39)
      {
        BOOL v40 = BOMBomFSObjectExistsAtPath(v39, *(void *)(a1 + 2296));
        __int16 v41 = *(_WORD *)(a2 + 4);
        if (!v40 || (v41 & 0xF000) == 0x4000) {
          goto LABEL_50;
        }
LABEL_46:
        if (_skipCPIOFile(a1)) {
          goto LABEL_110;
        }
        unsigned int v84 = 1;
        size_t v17 = v77;
      }
      else
      {
        __int16 v41 = *(_WORD *)(a2 + 4);
LABEL_50:
        HIDWORD(v42) = v41 & 0xF000;
        LODWORD(v42) = HIDWORD(v42) - 0x2000;
        switch((v42 >> 13))
        {
          case 0u:
          case 2u:
            int v43 = _copyDevice(a1, a2);
            goto LABEL_60;
          case 1u:
            char v69 = a5;
            int v43 = _copyDir(a1, a2, a3, 0, HIBYTE(v83), 0, 0, a4);
            goto LABEL_60;
          case 3u:
            int v43 = _copyFile(a1, a2, a3, HIBYTE(v83), *(_DWORD **)(a1 + 136), &v84, v35);
            goto LABEL_60;
          case 4u:
            int v43 = _copyLink(a1, a2, a3, SHIBYTE(v83));
LABEL_60:
            if (v43 == 1)
            {
              HIDWORD(v72) = 1;
            }
            else if (v43 == 2)
            {
              goto LABEL_110;
            }
LABEL_64:
            size_t v17 = v77;
            if (v34 || (v84 & 0xFFFFFFFD) != 0) {
              continue;
            }
            uint64_t v46 = v71;
            if (v71)
            {
              if (v71 == v15)
              {
                uint64_t v47 = (char *)BOM_realloc(__source, 32 * v71);
                uint64_t v46 = 2 * v71;
              }
              else
              {
                uint64_t v47 = __source;
              }
            }
            else
            {
              uint64_t v47 = (char *)BOM_malloc(0x40uLL);
              uint64_t v46 = 4;
            }
            if (!v47)
            {
              BOMCopierNotifyFatalError(a1, "Could not allocate space for Apple Double files.", v28, v29, v30, v31, v32, v33, v69);
              uint64_t v52 = __s2;
              goto LABEL_106;
            }
            uint64_t v71 = v46;
            if (*(unsigned char *)(a1 + 11616)) {
              uint64_t v48 = (const char *)(a1 + 10592);
            }
            else {
              uint64_t v48 = (const char *)(a1 + 3328);
            }
            __sourcea = (char *)v48;
            size_t v70 = strlen(v48);
            unint64_t v49 = (char *)malloc_type_malloc(v70 + 1, 0x37DCBF42uLL);
            size_t v17 = v77;
            strlcpy(v49, __sourcea, v70 + 1);
            __source = v47;
            uint64_t v50 = (char **)&v47[16 * v15];
            *uint64_t v50 = v49;
            v50[1] = (char *)v70;
            ++v15;
            break;
          default:
            goto LABEL_64;
        }
      }
    }
  }
  if (v18 == 3)
  {
    uint64_t v65 = "bad file format";
LABEL_109:
    BOMCopierNotifyFatalError(a1, "cpio read error: %s", v19, v20, v21, v22, v23, v24, (char)v65);
LABEL_110:
    if (__source)
    {
      if (v15)
      {
        unsigned __int8 v67 = (void **)__source;
        do
        {
          free(*v67);
          char *v67 = 0;
          v67 += 2;
          --v15;
        }
        while (v15);
      }
      free(__source);
    }
    uint64_t v14 = 2;
    uint64_t v52 = __s2;
    goto LABEL_116;
  }
  if (v18 != 4)
  {
    uint64_t v66 = __error();
    LOBYTE(v65) = strerror(*v66);
    goto LABEL_109;
  }
  uint64_t v51 = __source;
  if (v17 >= 2)
  {
    uint64_t v52 = __s2;
    __s2[(v17 - 1)] = 0;
    uint64_t v53 = *(void (**)(uint64_t, char *, uint64_t, void, void))(a1 + 96);
    if (v53) {
      goto LABEL_84;
    }
    goto LABEL_85;
  }
  uint64_t v52 = __s2;
  if (__source)
  {
LABEL_86:
    int v82 = 0;
    if (v15)
    {
      uint64_t v55 = 0;
      uint64_t v56 = v51 + 16;
      do
      {
        size_t v57 = &v51[16 * v55];
        if (*(void *)v57)
        {
          __strlcpy_chk();
          __strlcat_chk();
          BOMAppleDoubleADPathToPath(*(char **)v57, __s1);
          HIDWORD(v72) = _mergeAppleDouble(a1, &v82);
          if (!v82) {
            (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 1272);
          }
          uint64_t v58 = v55 + 1;
          if (v55 + 1 < v15)
          {
            int v59 = &__source[16 * v55 + 8];
            uint64_t v60 = &v56[16 * v55];
            uint64_t v61 = v55 + 1;
            do
            {
              uint64_t v62 = *(char **)v60;
              if (*(void *)v60
                && *(void *)v59 == *((void *)v60 + 1)
                && !strcmp(*(const char **)v57, *(const char **)v60))
              {
                free(v62);
                *(void *)uint64_t v60 = 0;
                *((void *)v60 + 1) = 0;
              }
              ++v61;
              v60 += 16;
            }
            while (v15 != v61);
          }
          free(*(void **)v57);
          *(void *)size_t v57 = 0;
          *((void *)v57 + 1) = 0;
          uint64_t v51 = __source;
        }
        else
        {
          uint64_t v58 = v55 + 1;
        }
        uint64_t v55 = v58;
      }
      while (v58 != v15);
    }
    free(v51);
    uint64_t v52 = __s2;
  }
LABEL_102:
  *a4 = 0;
  if ((_BYTE)v83)
  {
    if ((*(unsigned int (**)(void, char *, void))(*(void *)(a1 + 12832) + 200))(*(void *)(*(void *)(a1 + 12832) + 8), v76, (unsigned __int16)v72))
    {
      uint64_t v63 = __error();
      uint64_t v64 = *(void (**)(uint64_t, char *, void))(a1 + 64);
      if (v64) {
        v64(a1, v76, *v63);
      }
    }
  }
LABEL_106:
  uint64_t v14 = HIDWORD(v72);
LABEL_116:
  free(v52);
  return v14;
}

uint64_t _copyFromPKZip(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, size_t a5)
{
  int64_t v99 = 0;
  int v98 = 0;
  unsigned __int8 v97 = 0;
  unsigned int v10 = (unsigned char *)(a1 + 248);
  unsigned int v11 = strlen((const char *)(a1 + 248));
  long long v12 = (char *)BOM_malloc(v11 + 2);
  if (!v12) {
    return 2;
  }
  unsigned int v13 = v12;
  uint64_t v14 = v11;
  memmove(v12, v10, v11);
  if (v11)
  {
    ++v11;
    v13[v14] = 47;
    v13[v11] = 0;
  }
  unint64_t v15 = (_DWORD *)(a1 + 12772);
  if (BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772)))
  {
    uint64_t v22 = "Couldn't read PKZip signature";
LABEL_6:
    BOMCopierNotifyFatalError(a1, v22, v16, v17, v18, v19, v20, v21, v84);
    uint64_t v23 = 2;
    goto LABEL_7;
  }
  uint64_t v25 = (unsigned char *)(a1 + 12721);
  if (*v15 == 2)
  {
    uint64_t v23 = 0;
    unsigned char *v25 = 0;
    goto LABEL_7;
  }
  if (*v15 != 1)
  {
    uint64_t v22 = "Incorrect pkzip signature";
    goto LABEL_6;
  }
  uint64_t v91 = a3;
  uint64_t v93 = 0;
  unint64_t __dst = a4;
  uint64_t v87 = 0;
  unint64_t v26 = 0;
  unsigned int v27 = v11;
  uint64_t v23 = 0;
  uint64_t v95 = (int *)(a1 + 12776);
  unsigned int v86 = v27;
  size_t __n = v27;
  int v88 = (void *)(a1 + 7424);
  long long v89 = (unsigned char *)(a1 + 249);
  __s = (char *)(a1 + 3328);
  while (1)
  {
    v100[0] = 0;
    if (!*v25) {
      goto LABEL_19;
    }
    if (BOMPKZipReadLocalHeader(*(void *)(a1 + 12752), v10, a2, (unint64_t *)&v99, &v98, (unsigned char *)(a1 + 12796), v95, (unsigned int *)(a1 + 12808), (unsigned char *)(a1 + 12812)))
    {
      char v69 = "Couldn't read pkzip local header";
      goto LABEL_113;
    }
    char v34 = v98;
    if (v98)
    {
      if (v98 == 8)
      {
        char v34 = 1;
        goto LABEL_18;
      }
      char v69 = "Unknown compression type";
LABEL_113:
      BOMCopierNotifyFatalError(a1, v69, v28, v29, v30, v31, v32, v33, v84);
      goto LABEL_114;
    }
LABEL_18:
    v25[48] = v34;
    if (!*v95 && !*(void *)(a2 + 96))
    {
      uint64_t v44 = v99;
      if (v99 >= 1)
      {
        uint64_t v45 = 0;
        while (1)
        {
          uint64_t v46 = v44 - v45;
          unint64_t v47 = v46 >= 1024 ? 1024 : v46;
          uint64_t File = (int *)BOMPKZipGetFile(*(void *)(a1 + 12752));
          if (BOMFileRead(File, _copyFromPKZip_junk, v47) != v47) {
            break;
          }
          v45 += v47;
          uint64_t v44 = v99;
          if (v45 == v99)
          {
            int64_t v99 = 0;
            uint64_t v25 = (unsigned char *)(a1 + 12721);
            *(unsigned char *)(a1 + 12769) = 0;
            goto LABEL_19;
          }
        }
        char v69 = "Couldn't extract junk data";
        goto LABEL_113;
      }
    }
LABEL_19:
    int v35 = v10;
    if (*v10 == 46)
    {
      if (*v89 == 47) {
        int v35 = (const char *)(a1 + 249);
      }
      else {
        int v35 = v10;
      }
    }
    if (strlcpy(__dst, v35, a5) >= a5)
    {
      size_t v70 = *(void (**)(uint64_t, const char *, uint64_t))(a1 + 64);
      if (v70) {
        v70(a1, v35, 63);
      }
LABEL_114:
      uint64_t v23 = 2;
LABEL_115:
      if (!v93) {
        goto LABEL_7;
      }
      if (v26)
      {
        __int16 v83 = v93;
        do
        {
          free(*(void **)v83);
          *(void *)__int16 v83 = 0;
          *((void *)v83 + 1) = 0;
          v83 += 16;
          --v26;
        }
        while (v26);
      }
      uint64_t v73 = v93;
LABEL_120:
      free(v73);
      goto LABEL_7;
    }
    if (strncmp(v10, v13, __n)) {
      break;
    }
    unsigned char *v25 = 1;
    if ((*(_WORD *)(a2 + 4) & 0xF000) == 0x8000 && BOMAppleDoubleIsADFile(v10) && *(unsigned char *)(a1 + 169))
    {
      if (*(_DWORD *)(a1 + 12716) != 3) {
        goto LABEL_59;
      }
      if (v25[47])
      {
        int v42 = *v10;
        if (v42 == 46 && *v89 == 47) {
          uint64_t v43 = 2;
        }
        else {
          uint64_t v43 = v42 == 47;
        }
        if (!strncmp("__MACOSX", &v10[v43], 8uLL))
        {
          _parentPath(v10, v88, 0x400uLL);
          if (_insertQuarantinePath(*(void *)(a1 + 12752), (char *)v88, 0))
          {
            __error();
            _checkCopyFileError(a1);
            goto LABEL_114;
          }
        }
      }
      uint64_t v49 = v87;
      if (v87)
      {
        if (v87 == v26)
        {
          uint64_t v50 = (char *)BOM_realloc(v93, 32 * v87);
          uint64_t v49 = 2 * v87;
        }
        else
        {
          uint64_t v50 = v93;
        }
      }
      else
      {
        uint64_t v50 = (char *)BOM_malloc(0x40uLL);
        uint64_t v49 = 4;
      }
      if (!v50)
      {
        BOMCopierNotifyFatalError(a1, "Could not allocate space for Apple Double files.", v36, v37, v38, v39, v40, v41, v84);
        goto LABEL_7;
      }
      uint64_t v87 = v49;
      uint64_t v93 = v50;
      size_t v85 = strlen(__s);
      uint64_t v51 = (char *)malloc_type_malloc(v85 + 1, 0x90DF671CuLL);
      strlcpy(v51, __s, v85 + 1);
      uint64_t v52 = (char **)&v93[16 * v26];
      *uint64_t v52 = v51;
      uint64_t v25 = (unsigned char *)(a1 + 12721);
      v52[1] = (char *)v85;
      ++v26;
    }
    if (*(_DWORD *)(a1 + 12716) == 3)
    {
      unsigned int v53 = _checkForDestinationConflict(a1, __s, a2, v91, &v97, v100);
      if (v100[0] == 1)
      {
        unsigned int v54 = v53;
        if (v53 > 1 || _skipPKZipFile()) {
          goto LABEL_114;
        }
        if (v54 == 1) {
          uint64_t v23 = 1;
        }
        else {
          uint64_t v23 = v23;
        }
        goto LABEL_78;
      }
    }
LABEL_59:
    uint64_t v55 = *(void *)(a1 + 152);
    if (v55)
    {
      uint64_t FSObjectAtPath = BOMBomGetFSObjectAtPath(v55, v10);
      if (!FSObjectAtPath) {
        goto LABEL_65;
      }
      BOMFSObjectFree(FSObjectAtPath);
    }
    uint64_t v57 = *(void *)(a1 + 160);
    if (v57)
    {
      BOOL v58 = BOMBomFSObjectExistsAtPath(v57, *(void *)(a1 + 2296));
      __int16 v59 = *(_WORD *)(a2 + 4);
      if (v58 && (v59 & 0xF000) != 0x4000)
      {
LABEL_65:
        if (_skipPKZipFile()) {
          goto LABEL_114;
        }
        goto LABEL_78;
      }
    }
    else
    {
      __int16 v59 = *(_WORD *)(a2 + 4);
    }
    HIDWORD(v61) = v59 & 0xF000;
    LODWORD(v61) = HIDWORD(v61) - 0x2000;
    int v60 = v61 >> 13;
    if (v60 == 1)
    {
      char v84 = a5;
      uint64_t v62 = _copyDir(a1, a2, v91, 0, v97, 0, 0, __dst);
    }
    else
    {
      if (v60 != 3) {
        goto LABEL_76;
      }
      uint64_t v62 = _copyFile(a1, a2, v91, v97, *(_DWORD **)(a1 + 136), v100, 0);
    }
    if (v62 == 1)
    {
      uint64_t v23 = 1;
    }
    else if (v62 == 2)
    {
      uint64_t v23 = v62;
      goto LABEL_115;
    }
LABEL_76:
    if (*v25 && BOMPKZipReadNextSignature(*(void *)(a1 + 12752), (int *)(a1 + 12772)))
    {
      BOMCopierNotifyFatalError(a1, "Couldn't read pkzip signature.", v63, v64, v65, v66, v67, v68, v84);
      goto LABEL_115;
    }
LABEL_78:
    if (*v15 != 1) {
      goto LABEL_87;
    }
  }
  unsigned char *v25 = 0;
  v13[v86 - 1] = 0;
  uint64_t v71 = *(void (**)(uint64_t, char *, uint64_t, void, void))(a1 + 96);
  if (v71) {
    v71(a1, v13, 2, 0, 0);
  }
LABEL_87:
  char *__dst = 0;
  unsigned char *v25 = 0;
  if (v86 >= 2)
  {
    v13[v86 - 1] = 0;
    uint64_t v72 = *(void (**)(uint64_t, char *, uint64_t, void, void))(a1 + 96);
    if (v72) {
      v72(a1, v13, 2, 0, 0);
    }
  }
  uint64_t v73 = v93;
  if (v93)
  {
    if (v26)
    {
      uint64_t v74 = 0;
      unint64_t v75 = (void *)(a1 + 8448);
      do
      {
        int v76 = &v73[16 * v74];
        if (*(void *)v76)
        {
          __strlcpy_chk();
          __strlcat_chk();
          BOMAppleDoubleADPathToPath(*(char **)v76, v75);
          if (*(unsigned char *)(a1 + 12768)
            && (unsigned int v77 = *(_DWORD *)(a1 + 12780), !strncmp(*(const char **)(a1 + 12784), (const char *)v75, v77)))
          {
            __strlcpy_chk();
            strlcpy((char *)v88 + v77 - 8, (const char *)v75 + v77 + 1, 1024 - (v77 - 8));
          }
          else
          {
            __strlcpy_chk();
          }
          int v96 = 0;
          uint64_t v23 = _mergeAppleDouble(a1, &v96);
          if (!v96) {
            (*(void (**)(void, uint64_t))(*(void *)(a1 + 12832) + 224))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 1272);
          }
          uint64_t v78 = v74 + 1;
          if (v74 + 1 < v26)
          {
            size_t v79 = &v93[16 * v74 + 8];
            uint64_t v80 = v26 - 1 - v74;
            uint64_t v81 = (uint64_t)&v93[16 * v74 + 16];
            do
            {
              int v82 = *(char **)v81;
              if (*(void *)v81
                && *(void *)v79 == *(void *)(v81 + 8)
                && !strcmp(*(const char **)v76, *(const char **)v81))
              {
                free(v82);
                *(void *)uint64_t v81 = 0;
                *(void *)(v81 + 8) = 0;
              }
              v81 += 16;
              --v80;
            }
            while (v80);
          }
          free(*(void **)v76);
          *(void *)int v76 = 0;
          *((void *)v76 + 1) = 0;
          uint64_t v74 = v78;
          uint64_t v73 = v93;
          unint64_t v75 = (void *)(a1 + 8448);
        }
        else
        {
          ++v74;
        }
      }
      while (v74 != v26);
    }
    goto LABEL_120;
  }
LABEL_7:
  free(v13);
  return v23;
}

uint64_t _mergeAppleDouble(uint64_t a1, _DWORD *a2)
{
  if (*(unsigned char *)(a1 + 169) || *(unsigned char *)(a1 + 170) || *(unsigned char *)(a1 + 171))
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v22 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    memset(v17, 0, sizeof(v17));
    if ((*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 1272, v17))
    {
      __error();
      return _checkCopyFileError(a1);
    }
    if ((*(unsigned int (**)(void, uint64_t, _OWORD *))(*(void *)(a1 + 12832) + 96))(*(void *)(*(void *)(a1 + 12832) + 8), a1 + 7424, v17))
    {
      *__error() = 0;
      uint64_t v4 = 0;
      if (a2) {
        *a2 = 0;
      }
      return v4;
    }
    long long v15 = v19;
    long long v16 = v18;
    uint64_t v14 = 0;
    if (!*(unsigned char *)(a1 + 12848) && !*(unsigned char *)(a1 + 195) || (uint64_t v14 = AFSCLockFilePath()) != 0)
    {
      if (*(unsigned char *)(a1 + 170) || *(unsigned char *)(a1 + 169)) {
        int v6 = 9175044;
      }
      else {
        int v6 = 9175040;
      }
      if (copyfile((const char *)(a1 + 1272), (const char *)(a1 + 7424), 0, v6 | (*(unsigned char *)(a1 + 171) != 0)) < 0)
      {
        if (*__error() == 45) {
          *a2 = 0;
        }
        goto LABEL_26;
      }
      acl_t file = acl_get_file((const char *)(a1 + 7424), ACL_TYPE_EXTENDED);
      if (file)
      {
        long long v8 = file;
        long long v9 = acl_init(0);
        if (!v9
          || (v10 = v9, int v11 = acl_set_file((const char *)(a1 + 7424), ACL_TYPE_EXTENDED, v9), free(v10), v11)
          || (int v12 = acl_set_file((const char *)(a1 + 7424), ACL_TYPE_EXTENDED, v8), acl_free(v8), v12))
        {
LABEL_26:
          __error();
          uint64_t v13 = a1;
LABEL_32:
          uint64_t v4 = _checkCopyFileError(v13);
LABEL_33:
          _unlockAFSCFileLock(&v14);
          return v4;
        }
      }
      if (!set_timestamps_0((const char *)(a1 + 7424), &v16, &v15) || *__error() == 13)
      {
        uint64_t v4 = 0;
        if (a2) {
          *a2 = 0;
        }
        goto LABEL_33;
      }
    }
    __error();
    uint64_t v13 = a1;
    goto LABEL_32;
  }
  uint64_t v4 = 0;
  if (a2) {
    *a2 = 1;
  }
  return v4;
}

uint64_t _enforceDestinationLocation(uint64_t a1, char *a2)
{
  memset(&v14, 0, sizeof(v14));
  if (lstat(a2, &v14))
  {
    if (*__error() == 2) {
      return 0;
    }
    goto LABEL_6;
  }
  if ((v14.st_mode & 0xF000) == 0xA000)
  {
    memset(&v13, 0, sizeof(v13));
    if (stat(a2, &v13))
    {
LABEL_6:
      unsigned int v10 = __error();
      int v11 = *(void (**)(uint64_t, char *, void))(a1 + 64);
      if (v11) {
        v11(a1, a2, *v10);
      }
      return 0xFFFFFFFFLL;
    }
    if (v14.st_dev != v13.st_dev)
    {
      BOMCopierNotifyFatalError(a1, "%s exists on a different device from its target", v4, v5, v6, v7, v8, v9, (char)a2);
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

uint64_t _resolveDestinationPath(uint64_t a1, char *a2, char *a3)
{
  bzero(a3, 0x400uLL);
  if (*a2 != 47 && !getcwd(a3, 0x400uLL))
  {
    uint64_t v39 = __error();
    char v49 = strerror(*v39);
    uint64_t v38 = "Could not get current working directory: %s\n";
    goto LABEL_18;
  }
  uint64_t v6 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x100004077774924uLL);
  if (!v6)
  {
    uint64_t v38 = "Could not allocate unresolved prefix\n";
LABEL_18:
    BOMCopierNotifyFatalError(a1, v38, v7, v8, v9, v10, v11, v12, v49);
    return 0xFFFFFFFFLL;
  }
  stat v13 = v6;
  stat v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x100004077774924uLL);
  if (v14)
  {
    long long v21 = v14;
    while (1)
    {
      long long v22 = strchr(a2, 47);
      uint64_t v29 = v22;
      if (v22)
      {
        int64_t v30 = v22 - a2;
        if ((unint64_t)(v22 - a2) >= 0x400)
        {
          BOMCopierNotifyFatalError(a1, "Unresolved path component too large: %ld\n", v23, v24, v25, v26, v27, v28, (_BYTE)v22 - (_BYTE)a2);
          goto LABEL_28;
        }
        strncpy(v13, a2, 0x400uLL);
        v13[v30] = 0;
        if (snprintf(v21, 0x400uLL, "%s/%s", a3, v13) >= 0x400) {
          goto LABEL_27;
        }
        a2 = v29 + 1;
      }
      else
      {
        if (snprintf(v21, 0x400uLL, "%s/%s", a3, a2) >= 0x400)
        {
LABEL_27:
          BOMCopierNotifyFatalError(a1, "Could not construct path to resolve: %s %s %ld\n", v31, v32, v33, v34, v35, v36, (char)a3);
          goto LABEL_28;
        }
        a2 = 0;
      }
      if (!(*(uint64_t (**)(void, char *, char *))(*(void *)(a1 + 12832) + 160))(*(void *)(*(void *)(a1 + 12832) + 8), v21, a3))break; {
      if (!v29)
      }
        goto LABEL_14;
    }
    if (*__error() == 2)
    {
      if (!a2)
      {
LABEL_14:
        free(v21);
        free(v13);
        return 0;
      }
      size_t v40 = strlen(a3);
      if (v40 + strlen(a2) + 2 <= 0x3FF)
      {
        *(_WORD *)&a3[strlen(a3)] = 47;
        strncat(a3, a2, 0x400uLL);
        goto LABEL_14;
      }
      BOMCopierNotifyFatalError(a1, "Concatenated path too large: %s %s %ld\n", v41, v42, v43, v44, v45, v46, (char)a3);
    }
    else
    {
      unint64_t v47 = __error();
      uint64_t v48 = *(void (**)(uint64_t, char *, void))(a1 + 64);
      if (v48) {
        v48(a1, v21, *v47);
      }
    }
LABEL_28:
    free(v21);
  }
  else
  {
    BOMCopierNotifyFatalError(a1, "Could not allocate path to resolve\n", v15, v16, v17, v18, v19, v20, v49);
  }
  free(v13);
  return 0xFFFFFFFFLL;
}

uint64_t _restoreSymlinks(uint64_t a1, int a2)
{
  uint64_t v4 = 0;
  while (!BOMStackIsEmpty(*(void *)(a1 + 40)))
  {
    uint64_t v5 = (void **)BOMStackPop(*(uint64_t **)(a1 + 40));
    if ((*(unsigned int (**)(void, void *, void *))(*(void *)(a1 + 12832) + 264))(*(void *)(*(void *)(a1 + 12832) + 8), v5[1], *v5))
    {
      uint64_t v6 = *v5;
      uint64_t v7 = __error();
      uint64_t v8 = *(void (**)(uint64_t, void *, void))(a1 + 64);
      if (v8) {
        v8(a1, v6, *v7);
      }
      if (!a2)
      {
        free(*v5);
        free(v5[1]);
        free(v5[2]);
        free(v5);
        return 1;
      }
      uint64_t v4 = 1;
    }
    else
    {
      uint64_t v9 = *(void (**)(uint64_t, void *, uint64_t, void, void))(a1 + 96);
      if (v9) {
        v9(a1, v5[2], 3, 0, 0);
      }
    }
    free(*v5);
    free(v5[1]);
    free(v5[2]);
    free(v5);
  }
  return v4;
}

uint64_t BOMCopierPrepareMatchContext(const __CFDictionary *a1, uint64_t a2, void *a3)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    uint64_t v40 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 42, (uint64_t)"BOMCopierPrepareMatchContext", "match_context is NULL");
    return v40;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (!a1) {
    goto LABEL_46;
  }
  CFTypeID v7 = TypeID;
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1, @"archs");
  CFArrayRef v9 = Value;
  if (Value && CFGetTypeID(Value) != v7)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 61, (uint64_t)"BOMCopierPrepareMatchContext", "kBOMCopierOptionArchitectureArrayKey is not a CFArrayRef");
    return 1;
  }
  CFTypeID v10 = CFDictionaryGetTypeID();
  CFDictionaryRef v11 = (const __CFDictionary *)CFDictionaryGetValue(a1, @"fallbackForSubtype");
  CFDictionaryRef v12 = v11;
  if (v11 && CFGetTypeID(v11) != v10)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 75, (uint64_t)"BOMCopierPrepareMatchContext", "kBOMCopierOptionArchitectureFallbackKey is not a CFDictionaryRef");
    return 1;
  }
  if (!v9)
  {
LABEL_46:
    LODWORD(Count) = 0;
    uint64_t v15 = 0;
LABEL_47:
    uint64_t v40 = 0;
    *(_DWORD *)a2 = Count;
    *(void *)(a2 + 8) = v15;
    return v40;
  }
  int64_t Count = CFArrayGetCount(v9);
  stat v14 = malloc_type_calloc(Count, 0x20uLL, 0x101004001FB615FuLL);
  if (!v14)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 92, (uint64_t)"BOMCopierPrepareMatchContext", "Could not allocate bom_cpu_type_list");
    return 1;
  }
  uint64_t v15 = v14;
  CFTypeID v44 = v7;
  CFTypeID v46 = CFStringGetTypeID();
  if (Count < 1) {
    goto LABEL_47;
  }
  CFIndex v16 = 0;
  CFDictionaryRef theDict = v12;
  while (1)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, v16);
    if (!ValueAtIndex)
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 105, (uint64_t)"BOMCopierPrepareMatchContext", "Could not retrieve item %d from architecture list");
LABEL_63:
      uint64_t v42 = v15;
      goto LABEL_64;
    }
    CFStringRef v18 = ValueAtIndex;
    if (v46 != CFGetTypeID(ValueAtIndex))
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 112, (uint64_t)"BOMCopierPrepareMatchContext", "Item %d from architecture list is not a CFString");
      goto LABEL_63;
    }
    if (!CFStringGetCString(v18, buffer, 255, 0x8000100u))
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 120, (uint64_t)"BOMCopierPrepareMatchContext", "Item %d from architecture list could not converted to a UTF8 string");
      goto LABEL_63;
    }
    uint64_t v19 = BOMGetArchInfoFromName(buffer);
    if (!v19)
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 128, (uint64_t)"BOMCopierPrepareMatchContext", "Could not resolve architecture info for %s");
      goto LABEL_63;
    }
    uint64_t v20 = v19;
    long long v21 = BOMGetArchInfoFromCpuType(*((_DWORD *)v19 + 2), -1);
    if (!v21)
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 136, (uint64_t)"BOMCopierPrepareMatchContext", "Could not resolve family architecture info for %s");
      goto LABEL_63;
    }
    int v22 = *((_DWORD *)v20 + 3);
    int v23 = *((_DWORD *)v21 + 2);
    BOOL v26 = v22 == 3 && v23 == 16777223 || v22 != *((_DWORD *)v21 + 3);
    if (v22) {
      BOOL v27 = 0;
    }
    else {
      BOOL v27 = v23 == 16777228;
    }
    if (v27) {
      BOOL v26 = 1;
    }
    if (!v26) {
      int v22 = -1;
    }
    CFIndex v28 = (CFIndex)v15 + 32 * v16;
    *(_DWORD *)CFIndex v28 = v23;
    *(unsigned char *)(v28 + 4) = !v26;
    *(_DWORD *)(v28 + 8) = v22;
    *(void *)(v28 + 16) = 0;
    uint64_t v29 = (void *)(v28 + 16);
    *(_DWORD *)(v28 + 24) = 0;
    int64_t v30 = (_DWORD *)(v28 + 24);
    if (!theDict) {
      goto LABEL_43;
    }
    CFArrayRef v31 = (const __CFArray *)CFDictionaryGetValue(theDict, v18);
    if (!v31) {
      goto LABEL_43;
    }
    CFArrayRef v32 = v31;
    if (v44 != CFGetTypeID(v31))
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 172, (uint64_t)"BOMCopierPrepareMatchContext", "Corresponding fallback entry for item %d from architecture list is not a CFArray");
      goto LABEL_63;
    }
    uint64_t v43 = v15;
    int64_t v33 = CFArrayGetCount(v32);
    if (v33 >= 1) {
      break;
    }
LABEL_42:
    uint64_t v15 = v43;
LABEL_43:
    if (++v16 == Count) {
      goto LABEL_47;
    }
  }
  int64_t v34 = v33;
  uint64_t v35 = malloc_type_calloc(v33, 4uLL, 0x100004052888210uLL);
  CFIndex v36 = 0;
  void *v29 = v35;
  uint64_t v37 = v35;
  _DWORD *v30 = v34;
  while (1)
  {
    CFStringRef v38 = (const __CFString *)CFArrayGetValueAtIndex(v32, v36);
    if (!v38)
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 193, (uint64_t)"BOMCopierPrepareMatchContext", "Could not retrieve item %d from fallback list");
      goto LABEL_56;
    }
    CFStringRef v39 = v38;
    if (v46 != CFGetTypeID(v38))
    {
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 201, (uint64_t)"BOMCopierPrepareMatchContext", "Item %d from fallback list is not a CFString");
      goto LABEL_56;
    }
    if (!CFStringGetCString(v39, __s2, 255, 0x8000100u)) {
      break;
    }
    v37[v36++] = *((_DWORD *)BOMGetArchInfoFromName(__s2) + 3);
    if (v34 == v36) {
      goto LABEL_42;
    }
  }
  BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 210, (uint64_t)"BOMCopierPrepareMatchContext", "Item %d from fallback list could not converted to a UTF8 string");
LABEL_56:
  free(v37);
  uint64_t v42 = v43;
LABEL_64:
  free(v42);
  return 1;
}

uint64_t BOMCopierReleaseMatchContext(unsigned int *a1, void *a2)
{
  if (a1)
  {
    uint64_t v3 = *a1;
    uint64_t v4 = (void **)*((void *)a1 + 1);
    if (v3)
    {
      uint64_t v5 = v4 + 2;
      do
      {
        if (*v5) {
          free(*v5);
        }
        v5 += 4;
        --v3;
      }
      while (v3);
    }
    else if (!v4)
    {
LABEL_11:
      uint64_t v6 = 0;
      *a1 = 0;
      *((void *)a1 + 1) = 0;
      return v6;
    }
    free(v4);
    goto LABEL_11;
  }
  uint64_t v6 = 22;
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 250, (uint64_t)"BOMCopierReleaseMatchContext", "match_context is NULL");
  return v6;
}

uint64_t BOMCopierMatchBinary(uint64_t a1, unsigned int *a2, void *a3)
{
  if (a1)
  {
    if (a2)
    {
      unint64_t v6 = *a2;
      uint64_t v7 = *((void *)a2 + 1);
      a2[4] = 2;
      *((void *)a2 + 5) = 0;
      *(void *)(a2 + 7) = 0;
      *(void *)(a2 + 5) = 0;
      Archint64_t Count = BOMCopierSourceEntryGetArchCount(a1);
      uint64_t v9 = ArchCount;
      uint64_t v48 = (char *)malloc_type_calloc(ArchCount, 0x28uLL, 0x1000040DFF313CCuLL);
      if (!v48)
      {
        int v32 = *__error();
        int64_t v33 = __error();
        int64_t v34 = strerror(*v33);
        BOMCopierErrorCapture(a3, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 323, (uint64_t)"BOMCopierMatchBinary", "Could not allocate empty match record list: %s", v34);
        return 1;
      }
      uint64_t Size = BOMCopierSourceEntryGetSize(a1);
      int v10 = *a2;
      if (*a2) {
        unsigned int v11 = 0;
      }
      else {
        unsigned int v11 = ArchCount;
      }
      if (v10) {
        int v12 = 2;
      }
      else {
        int v12 = 1;
      }
      int v45 = v12;
      unsigned int v47 = ArchCount;
      if (ArchCount)
      {
        uint64_t v13 = 0;
        BOOL v14 = v10 == 0;
        if (v6) {
          BOOL v15 = v10 == 0;
        }
        else {
          BOOL v15 = 1;
        }
        while (1)
        {
          memset(v49, 0, sizeof(v49));
          if (BOMCopierSourceEntryGetArchRecord(a1, v13, v49, a3)) {
            break;
          }
          CFIndex v16 = (BOOL *)&v48[40 * v13];
          *CFIndex v16 = v14;
          int v17 = v49[0];
          *((_DWORD *)v16 + 1) = v49[0];
          int v18 = DWORD1(v49[0]);
          *((_DWORD *)v16 + 2) = DWORD1(v49[0]);
          *((_OWORD *)v16 + 1) = *(_OWORD *)((char *)v49 + 8);
          *((void *)v16 + 4) = *((void *)&v49[1] + 1);
          if (!v15)
          {
            unint64_t v19 = 0;
            uint64_t v20 = (_DWORD *)(v7 + 8);
            do
            {
              if (v17 == *(v20 - 2) && (*((unsigned char *)v20 - 4) || ((*v20 ^ v18) & 0xFFFFFF) == 0))
              {
                *CFIndex v16 = 1;
                ++v11;
                goto LABEL_37;
              }
              v20 += 8;
              ++v19;
            }
            while (v19 < v6);
            if (!v15)
            {
              unint64_t v22 = 0;
              do
              {
                int v23 = (int *)(v7 + 32 * v22);
                if (*((unsigned char *)v23 + 4) || (uint64_t v25 = v23[6], !v25))
                {
                  char v24 = 0;
                }
                else
                {
                  uint64_t v26 = 0;
                  char v24 = 0;
                  int v27 = *v23;
                  uint64_t v28 = 4 * v25;
                  do
                  {
                    if (v17 == v27 && v18 == *(_DWORD *)(*(void *)(v7 + 32 * v22 + 16) + v26))
                    {
                      char v24 = 1;
                      *CFIndex v16 = 1;
                      ++v11;
                    }
                    v26 += 4;
                  }
                  while (v28 != v26);
                }
                if (v24) {
                  break;
                }
                ++v22;
              }
              while (v22 < v6);
            }
          }
LABEL_37:
          if (++v13 == v9) {
            goto LABEL_38;
          }
        }
        uint64_t v37 = __error();
        BOMCopierErrorCapture(a3, *v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 347, (uint64_t)"BOMCopierMatchBinary", "Could not get arch record for index %d", MEMORY[0x263EF8900]);
        free(v48);
        return 1;
      }
LABEL_38:
      if (v11 == v47)
      {
        int v29 = 1;
        unint64_t v30 = Size;
      }
      else if (v11)
      {
        if (v11 == 1)
        {
          unint64_t v30 = Size;
          if (!v47)
          {
            int v29 = 3;
LABEL_67:
            uint64_t v31 = 0;
            a2[4] = v29;
            a2[5] = v47;
            *((void *)a2 + 3) = v48;
            a2[8] = v11;
            *((void *)a2 + 5) = v30;
            return v31;
          }
          uint64_t v35 = (unint64_t *)(v48 + 24);
          uint64_t v36 = v9;
          do
          {
            if (*((unsigned char *)v35 - 24))
            {
              *(v35 - 1) = 0;
              unint64_t v30 = *v35;
            }
            v35 += 5;
            --v36;
          }
          while (v36);
          int v29 = 3;
        }
        else
        {
          unint64_t v30 = Size;
          int v29 = v45;
          if (v11 < v47)
          {
            Binaryint Type = BOMCopierSourceEntryGetBinaryType(a1);
            unsigned int v39 = 20;
            if (BinaryType == 4) {
              unsigned int v39 = 32;
            }
            unint64_t v30 = v39 * (unint64_t)v11 + 8;
            uint64_t v40 = v48 + 32;
            uint64_t v41 = v9;
            do
            {
              if (*((unsigned char *)v40 - 32))
              {
                uint64_t v42 = (v30 + (1 << *v40) - 1) & -(uint64_t)(1 << *v40);
                *((void *)v40 - 2) = v42;
                unint64_t v30 = v42 + *((void *)v40 - 1);
              }
              v40 += 10;
              --v41;
            }
            while (v41);
            int v29 = 4;
          }
        }
      }
      else
      {
        unint64_t v30 = 0;
        int v29 = 2;
      }
      if (v47)
      {
        uint64_t v43 = v48 + 16;
        do
        {
          if (!*((unsigned char *)v43 - 16)) {
            *uint64_t v43 = -1;
          }
          v43 += 5;
          --v9;
        }
        while (v9);
      }
      goto LABEL_67;
    }
    uint64_t v31 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 294, (uint64_t)"BOMCopierMatchBinary", "match_context is NULL");
  }
  else
  {
    uint64_t v31 = 22;
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierMatchRecord.c", 288, (uint64_t)"BOMCopierMatchBinary", "source_entry is NULL");
  }
  return v31;
}

uint64_t BOMFSOArchInfoInitialize()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v35 = *MEMORY[0x263EF8340];
  if (*(uint64_t *)(v1 + 96) >= 4096) {
    unint64_t v2 = 4096;
  }
  else {
    unint64_t v2 = *(void *)(v1 + 96);
  }
  if (*(_DWORD *)v0 != 1) {
    return 0;
  }
  uint64_t v3 = v0;
  uint64_t v4 = *(unsigned char **)(v0 + 24);
  if (v4)
  {
    unint64_t v2 = *(unsigned int *)(v0 + 32);
    goto LABEL_7;
  }
  uint64_t v26 = *(unsigned int *)(v0 + 16);
  if (v26 != -1)
  {
    if (*(void *)(v0 + 144))
    {
      snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(v0 + 144), *(const char **)(v0 + 72));
      uint64_t v26 = *(unsigned int *)(v3 + 16);
    }
    if ((*(uint64_t (**)(void, uint64_t, void, void))(*(void *)(v3 + 160) + 64))(*(void *)(*(void *)(v3 + 160) + 8), v26, 0, 0) < 0)return 0; {
    uint64_t v4 = v34;
    }
    if ((*(uint64_t (**)(void, void, unsigned char *, unint64_t))(*(void *)(v3 + 160) + 48))(*(void *)(*(void *)(v3 + 160) + 8), *(unsigned int *)(v3 + 16), v34, v2) == v2)
    {
LABEL_7:
      if (v2 < 8) {
        return 0;
      }
      uint64_t v5 = *(unsigned int *)(v3 + 16);
      if (BOMArchFlagForHeader((int *)v4, v2) == 2)
      {
        int v6 = bswap32(*((_DWORD *)v4 + 1));
        uint64_t v7 = 20 * v6 + 8;
        if (v7 <= (uint64_t)v2
          || v5 != -1
          && (*(uint64_t (**)(void, uint64_t, unsigned char *))(*(void *)(v3 + 160) + 48))(*(void *)(*(void *)(v3 + 160) + 8), v5, &v4[v2]) == v7 - v2)
        {
          *(_WORD *)(v3 + 40) |= 2 << B_ARCHOFFT;
          *(_DWORD *)(v3 + 104) = v6;
          *(void *)(v3 + 112) = BOM_malloc(24 * v6);
          if (v6 >= 1)
          {
            unsigned int v32 = v5;
            uint64_t v8 = 0;
            uint64_t v9 = (unsigned int *)(v4 + 20);
            uint64_t v10 = 24 * v6;
            while (1)
            {
              unsigned int v11 = *(v9 - 3);
              if (*(_DWORD *)v4 == -889275714)
              {
                uint64_t v12 = *(void *)(v3 + 112) + v8;
                *(_DWORD *)uint64_t v12 = v11;
                unsigned int v13 = *(v9 - 2);
                *(_DWORD *)(v12 + 4) = v13;
                unint64_t v14 = *v9;
                *(void *)(v12 + 8) = v14;
                unsigned int v15 = *(v9 - 1);
              }
              else
              {
                uint64_t v16 = *(void *)(v3 + 112) + v8;
                *(_DWORD *)uint64_t v16 = bswap32(v11);
                unsigned int v13 = *(v9 - 2);
                *(_DWORD *)(v16 + 4) = bswap32(v13);
                unint64_t v14 = bswap32(*v9);
                *(void *)(v16 + 8) = v14;
                unsigned int v15 = bswap32(*(v9 - 1));
              }
              if ((*(_WORD *)(v3 + 40) & (unsigned __int16)B_CKSUMS) == 0) {
                goto LABEL_28;
              }
              uint64_t v17 = v15;
              unint64_t v18 = v14 + v15;
              if (v18 > *(void *)(v3 + 64))
              {
                unint64_t v19 = *(const char **)(v3 + 72);
                uint64_t v20 = BOMGetArchInfoFromCpuType(v11, v13);
                if (v20)
                {
                  long long v21 = *v20;
                }
                else
                {
                  unsigned int v31 = v11;
                  long long v21 = _cpuNameForType_generic;
                  snprintf(_cpuNameForType_generic, 0x50uLL, "<cputype %d, subtype %d>", v31, v13);
                }
                char v24 = BOMExceptionHandlerMessage("file %s is corrupt: slice for %s extends beyond length of file. (%lu > %lld)\n", v19, v21, v18, *(void *)(v3 + 64));
                uint64_t v25 = __error();
                _BOMExceptionHandlerCall((uint64_t)v24, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOArchInfo.c", 470, *v25);
                goto LABEL_28;
              }
              *(_DWORD *)__str = 0;
              uint64_t v22 = *(void *)(v3 + 24);
              if (v22)
              {
                if (BOMCRC32ForBuffer(v22 + v17, __str, v14)) {
                  goto LABEL_23;
                }
              }
              else
              {
                if ((*(uint64_t (**)(void, void))(*(void *)(v3 + 160) + 64))(*(void *)(*(void *)(v3 + 160) + 8), v32) == -1)
                {
                  int v23 = 0;
                  goto LABEL_25;
                }
                if (BOMCRC32ForFileDesc(v32, __str, v14)) {
LABEL_23:
                }
                  *(_DWORD *)__str = 0;
              }
              int v23 = *(_DWORD *)__str;
LABEL_25:
              *(_DWORD *)(*(void *)(v3 + 112) + v8 + 16) = v23;
LABEL_28:
              v8 += 24;
              v9 += 5;
              if (v10 == v8) {
                return 1;
              }
            }
          }
          return 1;
        }
      }
      if (v2 < 0x1C) {
        return 0;
      }
      int v28 = *(_DWORD *)v4;
      if (*(_DWORD *)v4 != -17958194)
      {
        if (v28 == -822415874)
        {
LABEL_44:
          int v29 = bswap32(*((_DWORD *)v4 + 1));
          int v30 = bswap32(*((_DWORD *)v4 + 2));
LABEL_50:
          _handleMachO_common(v3, v29, v30);
          return 1;
        }
        if (v2 < 0x20) {
          return 0;
        }
        if (v28 != -17958193)
        {
          if (v28 != -805638658) {
            return 0;
          }
          goto LABEL_44;
        }
      }
      int v29 = *((_DWORD *)v4 + 1);
      int v30 = *((_DWORD *)v4 + 2);
      goto LABEL_50;
    }
  }
  return 1;
}

void BOMFSOArchInfoRelease(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 112);
  if (v2) {
    free(v2);
  }
  *(void *)(a1 + 112) = 0;
}

uint64_t BOMFSOArchInfoCopy(uint64_t a1, uint64_t a2)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    *(_DWORD *)(a2 + 104) = *(_DWORD *)(a1 + 104);
    uint64_t v5 = BOM_malloc(24 * *(int *)(a1 + 104));
    *(void *)(a2 + 112) = v5;
    if (v5)
    {
      if (*(_DWORD *)(a2 + 104))
      {
        uint64_t v6 = 0;
        unint64_t v7 = 0;
        do
        {
          uint64_t v8 = *(void *)(a2 + 112) + v6;
          uint64_t v9 = (long long *)(*(void *)(a1 + 112) + v6);
          long long v10 = *v9;
          *(void *)(v8 + 16) = *((void *)v9 + 2);
          *(_OWORD *)uint64_t v8 = v10;
          ++v7;
          v6 += 24;
        }
        while (v7 < *(unsigned int *)(a2 + 104));
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t BOMFSOArchInfoContainsArchitecture(uint64_t a1, int a2)
{
  if (((unsigned __int16)B_ARCH & *(_WORD *)(a1 + 40)) == 0) {
    return 0;
  }
  if (!((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a1 + 40)) >> B_ARCHOFFT)) {
    return 0;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 104);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(int **)(a1 + 112);
  while (1)
  {
    int v4 = *v3;
    v3 += 6;
    if (v4 == a2) {
      break;
    }
    if (!--v2) {
      return 0;
    }
  }
  return 1;
}

uint64_t BOMFSOArchInfoArchCount(_DWORD *a1)
{
  if (*a1 == 1) {
    return a1[26];
  }
  else {
    return 0;
  }
}

uint64_t BOMFSOArchInfoGetArch(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 104) <= a2) {
    return 0;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 112) + 24 * a2);
  }
}

uint64_t BOMFSOArchInfoGetArchSubtype(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 104) <= a2) {
    return 0;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 112) + 24 * a2 + 4);
  }
}

uint64_t BOMFSOArchInfoGetArchSize(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 104) <= a2) {
    return 0;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 112) + 24 * a2 + 8);
  }
}

uint64_t BOMFSOArchInfoThinKeepingArchs(uint64_t a1, int *a2, unsigned int a3)
{
  if (((unsigned __int16)B_ARCH & *(_WORD *)(a1 + 40)) == 0) {
    return 1;
  }
  if ((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a1 + 40)) >> B_ARCHOFFT != 2) {
    return 0;
  }
  uint64_t v6 = (char *)BOM_malloc(24 * *(int *)(a1 + 104));
  if (!v6) {
    return 1;
  }
  unint64_t v7 = v6;
  unint64_t v8 = *(unsigned int *)(a1 + 104);
  if (v8)
  {
    unint64_t v9 = 0;
    int v10 = 0;
    do
    {
      if (a3)
      {
        uint64_t v11 = *(void *)(a1 + 112) + 24 * v9;
        uint64_t v12 = a3;
        unsigned int v13 = a2;
        while (1)
        {
          int v14 = *v13++;
          if (*(_DWORD *)v11 == v14) {
            break;
          }
          if (!--v12) {
            goto LABEL_12;
          }
        }
        unsigned int v15 = &v6[24 * v10];
        long long v16 = *(_OWORD *)v11;
        *((void *)v15 + 2) = *(void *)(v11 + 16);
        *(_OWORD *)unsigned int v15 = v16;
        ++v10;
        unint64_t v8 = *(unsigned int *)(a1 + 104);
      }
LABEL_12:
      ++v9;
    }
    while (v9 < v8);
  }
  else
  {
    int v10 = 0;
  }
  unint64_t v18 = *(void **)(a1 + 112);
  if (v18) {
    free(v18);
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 104) = v10;
  *(_DWORD *)(a1 + 108) = 0;
  *(void *)(a1 + 112) = v7;
  if (v10 == 1)
  {
    uint64_t result = 0;
    *(void *)(a1 + 64) = *((void *)v7 + 1);
    *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 4);
  }
  return result;
}

uint64_t BOMFSOArchInfoThinKeepingArchsAndSubArchs(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (((unsigned __int16)B_ARCH & *(_WORD *)(a1 + 40)) == 0) {
    return 1;
  }
  if ((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a1 + 40)) >> B_ARCHOFFT != 2) {
    return 0;
  }
  uint64_t v6 = (char *)BOM_malloc(24 * *(int *)(a1 + 104));
  if (!v6) {
    return 1;
  }
  unint64_t v7 = v6;
  unint64_t v8 = *(unsigned int *)(a1 + 104);
  if (v8)
  {
    unint64_t v9 = 0;
    int v10 = 0;
    do
    {
      if (a3)
      {
        uint64_t v11 = *(void *)(a1 + 112) + 24 * v9;
        uint64_t v12 = a3;
        unsigned int v13 = (_DWORD *)(a2 + 8);
        while (*(_DWORD *)v11 != *(v13 - 2) || !*((unsigned char *)v13 - 4) && ((*v13 ^ *(_DWORD *)(v11 + 4)) & 0xFFFFFF) != 0)
        {
          v13 += 8;
          if (!--v12) {
            goto LABEL_14;
          }
        }
        int v14 = &v6[24 * v10];
        long long v15 = *(_OWORD *)v11;
        *((void *)v14 + 2) = *(void *)(v11 + 16);
        *(_OWORD *)int v14 = v15;
        ++v10;
        unint64_t v8 = *(unsigned int *)(a1 + 104);
      }
LABEL_14:
      ++v9;
    }
    while (v9 < v8);
  }
  else
  {
    int v10 = 0;
  }
  uint64_t v17 = *(void **)(a1 + 112);
  if (v17) {
    free(v17);
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 104) = v10;
  *(_DWORD *)(a1 + 108) = 0;
  *(void *)(a1 + 112) = v7;
  if (v10 == 1)
  {
    uint64_t result = 0;
    *(void *)(a1 + 64) = *((void *)v7 + 1);
    *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 4);
  }
  return result;
}

void BOMFSOArchInfoSet(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v6 = *(void **)(a1 + 112);
    if (v6)
    {
      free(v6);
      *(_DWORD *)(a1 + 104) = 0;
      *(void *)(a1 + 112) = 0;
      *(_WORD *)(a1 + 40) &= ~B_ARCH;
    }
    if (a2)
    {
      *(_DWORD *)(a1 + 104) = a2;
      unint64_t v7 = BOM_malloc(24 * (int)a2);
      uint64_t v8 = 0;
      *(void *)(a1 + 112) = v7;
      do
      {
        uint64_t v9 = *(void *)(a1 + 112) + v8;
        long long v10 = *(_OWORD *)(a3 + v8);
        *(void *)(v9 + 16) = *(void *)(a3 + v8 + 16);
        *(_OWORD *)uint64_t v9 = v10;
        v8 += 24;
      }
      while (24 * a2 != v8);
      if (a2 == 1) {
        __int16 v11 = 1;
      }
      else {
        __int16 v11 = 2;
      }
      *(_WORD *)(a1 + 40) |= B_ARCH | (unsigned __int16)(v11 << B_ARCHOFFT);
    }
  }
}

uint64_t _handleMachO_common(uint64_t a1, int a2, int a3)
{
  *(_WORD *)(a1 + 40) |= 1 << B_ARCHOFFT;
  *(_DWORD *)(a1 + 104) = 1;
  uint64_t v6 = BOM_malloc(0x18uLL);
  *(void *)(a1 + 112) = v6;
  v6[1] = *(void *)(a1 + 64);
  *(_DWORD *)uint64_t v6 = a2;
  *((_DWORD *)v6 + 1) = a3;
  uint64_t result = BOMFSObjectChecksum(a1);
  *(_DWORD *)(*(void *)(a1 + 112) + 16) = result;
  return result;
}

uint64_t BOMFSObjectArchiveLength(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  unsigned __int16 v2 = *(_WORD *)(a1 + 40);
  if (((unsigned __int16)B_STAT & v2) != 0)
  {
    uint64_t v3 = BOMFSOTypeInfoArchiveLength(a1);
    if (v3 < 0) {
      return -1;
    }
    uint64_t v4 = v3 + 30;
    unsigned __int16 v2 = *(_WORD *)(a1 + 40);
  }
  else
  {
    uint64_t v4 = 4;
  }
  if (((unsigned __int16)B_ARCH & v2) == 0) {
    goto LABEL_9;
  }
  uint64_t v5 = BOMFSOArchInfoArchiveLength(a1);
  if (v5 < 0) {
    return -1;
  }
  v4 += v5;
  unsigned __int16 v2 = *(_WORD *)(a1 + 40);
LABEL_9:
  if (((unsigned __int16)B_OPAQUEDATA & v2) != 0) {
    v4 += *(void *)(a1 + 128) + 4;
  }
  return v4;
}

uint64_t BOMFSObjectArchive(uint64_t a1, uint64_t a2)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    BOMStreamWriteUInt8(a1, *(unsigned char *)a2);
    BOMStreamWriteUInt8(a1, 1);
    BOMStreamWriteUInt16(a1, *(_WORD *)(a2 + 40));
    unsigned __int16 v5 = *(_WORD *)(a2 + 40);
    if (((unsigned __int16)B_STAT & v5) != 0)
    {
      BOMStreamWriteUInt16(a1, *(_WORD *)(a2 + 42));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 44));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 48));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 56));
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 64));
      BOMFSOTypeInfoArchive(a1, a2);
      unsigned __int16 v5 = *(_WORD *)(a2 + 40);
    }
    if (((unsigned __int16)B_ARCH & v5) != 0)
    {
      BOMFSOArchInfoArchive(a1, a2);
      unsigned __int16 v5 = *(_WORD *)(a2 + 40);
    }
    if (((unsigned __int16)B_OPAQUEDATA & v5) != 0)
    {
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 128));
      BOMStreamWriteBuffer(a1, *(const void **)(a2 + 120), *(void *)(a2 + 128));
    }
    return 0;
  }
  return result;
}

_DWORD *BOMFSObjectUnarchive(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  int UInt8 = BOMStreamReadUInt8(a1);
  int v3 = BOMStreamReadUInt8(a1);
  if ((UInt8 - 6) <= 0xFFFFFFFA)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "filesystem object has an invalid type: 0x%X\nCannot dearchive.\n");
    return 0;
  }
  if (v3 != 1)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "filesystem object has an invalid version: 0x%X\nCannot dearchive.\n");
    return 0;
  }
  uint64_t Sys = (void *)BOMStreamGetSys(a1);
  unsigned __int16 v5 = BOMFSObjectNewWithSys(UInt8, Sys);
  if (v5)
  {
    unsigned __int16 UInt16 = BOMStreamReadUInt16(a1);
    *((_WORD *)v5 + 20) = UInt16;
    if (((unsigned __int16)B_STAT & UInt16) != 0)
    {
      *((_WORD *)v5 + 21) = BOMStreamReadUInt16(a1);
      v5[11] = BOMStreamReadUInt32(a1);
      v5[12] = BOMStreamReadUInt32(a1);
      *((void *)v5 + 7) = BOMStreamReadUInt32(a1);
      *((void *)v5 + 8) = BOMStreamReadUInt32(a1);
      unsigned __int16 UInt16 = *((_WORD *)v5 + 20);
      if (((unsigned __int16)B_STAT & UInt16) != 0)
      {
        if (BOMFSOTypeInfoUnarchive(a1, (uint64_t)v5)) {
          goto LABEL_19;
        }
        unsigned __int16 UInt16 = *((_WORD *)v5 + 20);
      }
    }
    if (((unsigned __int16)B_ARCH & UInt16) != 0)
    {
      if (BOMFSOArchInfoUnarchive(a1, (uint64_t)v5)) {
        goto LABEL_19;
      }
      unsigned __int16 UInt16 = *((_WORD *)v5 + 20);
    }
    if (((unsigned __int16)B_OPAQUEDATA & UInt16) != 0)
    {
      unsigned int UInt32 = BOMStreamReadUInt32(a1);
      *((void *)v5 + 16) = UInt32;
      uint64_t v8 = BOM_malloc(UInt32);
      *((void *)v5 + 15) = v8;
      if (v8)
      {
        BOMStreamReadBuffer(a1, v8, *((void *)v5 + 16));
        return v5;
      }
LABEL_19:
      BOMFSObjectFree((uint64_t)v5);
      return 0;
    }
  }
  return v5;
}

uint64_t BOMFSObjectTypeForMode(__int16 a1)
{
  unsigned int v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 14 > 2) {
    return 0;
  }
  else {
    return dword_210662DF0[v1 >> 12];
  }
}

char *BOMNameForFSObjectType(int a1)
{
  if ((a1 - 6) >= 0xFFFFFFFB) {
    int v1 = a1;
  }
  else {
    int v1 = 0;
  }
  return &gTypeStrings[10 * v1];
}

void *BOMFSObjectNew(int a1)
{
  unsigned __int16 v2 = BOM_malloczero(0xA8uLL);
  int v3 = v2;
  if (v2)
  {
    *(_DWORD *)unsigned __int16 v2 = a1;
    v2[20] = BomSys_default();
  }
  return v3;
}

_DWORD *BOMFSObjectNewWithSys(int a1, void *a2)
{
  uint64_t v4 = BOM_malloczero(0xA8uLL);
  unsigned __int16 v5 = v4;
  if (v4)
  {
    *uint64_t v4 = a1;
    if (!a2) {
      a2 = BomSys_default();
    }
    *((void *)v5 + 20) = a2;
  }
  return v5;
}

_DWORD *BOMFSObjectNewFromPath(char *a1, __int16 a2)
{
  return BOMFSObjectNewFromPathWithSys(a1, a2, 0);
}

_DWORD *BOMFSObjectNewFromPathWithSys(char *a1, __int16 a2, unsigned int (**a3)(void, char *, long long *))
{
  int v3 = a3;
  if (!a3) {
    int v3 = (unsigned int (**)(void, char *, long long *))BomSys_default();
  }
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  if (v3[12](v3[1], a1, &v30)) {
    return 0;
  }
  int v8 = BOMFSObjectTypeForMode(SWORD2(v30));
  if (v8 == 5) {
    return 0;
  }
  if (!v8)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "file '%s' is an unknown file type\n", a1);
    return 0;
  }
  uint64_t v6 = BOMFSObjectNewWithSys(v8, v3);
  if (!v6) {
    return v6;
  }
  size_t v9 = strlen(a1) + 1;
  long long v10 = BOM_malloc(v9);
  *((void *)v6 + 9) = v10;
  if (!v10)
  {
LABEL_24:
    uint64_t v20 = (void *)*((void *)v6 + 10);
    if (v20) {
      free(v20);
    }
    free(v6);
    return 0;
  }
  memmove(v10, a1, v9);
  __int16 v11 = strrchr(a1, 47);
  uint64_t v12 = a1;
  if (v11)
  {
    if (v11[1]) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11;
    }
  }
  size_t v13 = strlen(v12) + 1;
  int v14 = BOM_malloc(v13);
  *((void *)v6 + 10) = v14;
  if (!v14)
  {
    unint64_t v19 = (void *)*((void *)v6 + 9);
    if (v19) {
      free(v19);
    }
    goto LABEL_24;
  }
  memmove(v14, v12, v13);
  *((_WORD *)v6 + 20) = a2;
  int v15 = a2 & 1;
  if (a2)
  {
    *((_WORD *)v6 + 21) = WORD2(v30);
    *(void *)(v6 + 11) = v31;
    *((void *)v6 + 7) = v33;
    *((void *)v6 + 8) = v36;
  }
  if ((a2 & 0xFFF) != 0 && *v6 == 1)
  {
    unsigned int v16 = v3[23](v3[1], a1, (long long *)4);
    uint64_t v17 = v3[1];
    if (v16 == -1)
    {
      v3[25](v17, a1, (long long *)(WORD2(v30) & 0xFFF | 0x124u));
      int v18 = ((uint64_t (*)(unsigned int (*)(void, char *, long long *), char *, void, void))v3[2])(v3[1], a1, 0, 0);
      v3[25](v3[1], a1, (long long *)(WORD2(v30) & 0xFFF));
    }
    else
    {
      int v18 = ((uint64_t (*)(unsigned int (*)(void, char *, long long *), char *, void, void))v3[2])(v17, a1, 0, 0);
    }
    if (v18 == -1)
    {
      BOMFSObjectFree((uint64_t)v6);
      return 0;
    }
    v6[4] = v18;
    *((void *)v6 + 3) = 0;
    *((void *)v6 + 4) = 0;
    a2 = *((_WORD *)v6 + 20);
    int v15 = a2 & 1;
  }
  if (v15)
  {
    long long v27 = v36;
    long long v28 = v37;
    long long v29 = v38;
    long long v23 = v32;
    long long v24 = v33;
    long long v25 = v34;
    long long v26 = v35;
    long long v21 = v30;
    long long v22 = v31;
    BOMFSOTypeInfoInitialize((uint64_t)v6, (uint64_t)&v21);
    a2 = *((_WORD *)v6 + 20);
  }
  if ((a2 & 4) != 0)
  {
    long long v27 = v36;
    long long v28 = v37;
    long long v29 = v38;
    long long v23 = v32;
    long long v24 = v33;
    long long v25 = v34;
    long long v26 = v35;
    long long v21 = v30;
    long long v22 = v31;
    BOMFSOArchInfoInitialize();
  }
  if (*v6 == 1 && (v6[10] & 0xFFF) != 0)
  {
    ((void (*)(unsigned int (*)(void, char *, long long *), void))v3[4])(v3[1], v6[4]);
    *((void *)v6 + 3) = 0;
    *((void *)v6 + 4) = 0;
  }
  return v6;
}

void BOMFSObjectFree(uint64_t a1)
{
  if (a1)
  {
    unsigned __int16 v2 = *(void **)(a1 + 72);
    if (v2) {
      free(v2);
    }
    int v3 = *(void **)(a1 + 80);
    if (v3) {
      free(v3);
    }
    BOMFSOTypeInfoRelease(a1);
    BOMFSOArchInfoRelease(a1);
    uint64_t v4 = *(void **)(a1 + 120);
    if (v4) {
      free(v4);
    }
    unsigned __int16 v5 = *(void **)(a1 + 144);
    if (v5 && *(unsigned char *)(a1 + 152)) {
      free(v5);
    }
    free((void *)a1);
  }
}

uint64_t BOMFSObjectENewFromPath(char *a1, long long *a2, int a3, __int16 a4)
{
  return BOMFSObjectENewFromPathWithSys(a1, a2, a3, a4, 0);
}

uint64_t BOMFSObjectENewFromPathWithSys(char *a1, long long *a2, int a3, __int16 a4, void *a5)
{
  int v10 = BOMFSObjectTypeForMode(*((_WORD *)a2 + 2));
  if (!v10) {
    return 0;
  }
  int v11 = v10;
  if (!a5) {
    a5 = BomSys_default();
  }
  uint64_t v12 = BOMFSObjectNewWithSys(v11, a5);
  uint64_t v13 = (uint64_t)v12;
  if (v12)
  {
    v12[4] = -1;
    size_t v14 = strlen(a1) + 1;
    int v15 = BOM_malloc(v14);
    *(void *)(v13 + 72) = v15;
    if (!v15) {
      goto LABEL_18;
    }
    memmove(v15, a1, v14);
    unsigned int v16 = strrchr(a1, 47);
    uint64_t v17 = a1;
    if (v16)
    {
      if (v16[1]) {
        uint64_t v17 = v16 + 1;
      }
      else {
        uint64_t v17 = v16;
      }
    }
    size_t v18 = strlen(v17) + 1;
    unint64_t v19 = BOM_malloc(v18);
    *(void *)(v13 + 80) = v19;
    if (v19)
    {
      memmove(v19, v17, v18);
      *(_WORD *)(v13 + 40) = a4;
      int v20 = a4 & 1;
      if (a4)
      {
        *(_WORD *)(v13 + 42) = *((_WORD *)a2 + 2);
        *(void *)(v13 + 44) = *((void *)a2 + 2);
        *(void *)(v13 + 56) = *((void *)a2 + 6);
        *(void *)(v13 + 64) = *((void *)a2 + 12);
      }
      if ((a4 & 0xFFF) == 0 || *(_DWORD *)v13 != 1) {
        goto LABEL_29;
      }
      if (a3 != -1)
      {
        *(_DWORD *)(v13 + 16) = a3;
LABEL_28:
        *(void *)(v13 + 24) = 0;
        *(void *)(v13 + 32) = 0;
LABEL_29:
        if (v20)
        {
          long long v25 = a2[7];
          long long v39 = a2[6];
          long long v40 = v25;
          long long v41 = a2[8];
          long long v26 = a2[3];
          long long v35 = a2[2];
          long long v36 = v26;
          long long v27 = a2[5];
          long long v37 = a2[4];
          long long v38 = v27;
          long long v28 = a2[1];
          long long v33 = *a2;
          long long v34 = v28;
          BOMFSOTypeInfoInitialize(v13, (uint64_t)&v33);
          a4 = *(_WORD *)(v13 + 40);
        }
        if ((a4 & 4) != 0)
        {
          long long v29 = a2[7];
          long long v39 = a2[6];
          long long v40 = v29;
          long long v41 = a2[8];
          long long v30 = a2[3];
          long long v35 = a2[2];
          long long v36 = v30;
          long long v31 = a2[5];
          long long v37 = a2[4];
          long long v38 = v31;
          long long v32 = a2[1];
          long long v33 = *a2;
          long long v34 = v32;
          BOMFSOArchInfoInitialize();
        }
        if (*(_DWORD *)v13 == 1 && (*(_WORD *)(v13 + 40) & 0xFFF) != 0)
        {
          *(void *)(v13 + 24) = 0;
          *(void *)(v13 + 32) = 0;
          if (a3 == -1)
          {
            (*((void (**)(void, void))a5 + 4))(*((void *)a5 + 1), *(unsigned int *)(v13 + 16));
            *(_DWORD *)(v13 + 16) = -1;
          }
        }
        return v13;
      }
      int v22 = (*((uint64_t (**)(void, char *, uint64_t))a5 + 23))(*((void *)a5 + 1), a1, 4);
      uint64_t v23 = *((void *)a5 + 1);
      if (v22 == -1)
      {
        (*((void (**)(uint64_t, char *, void))a5 + 25))(v23, a1, *((_WORD *)a2 + 2) & 0xFFF | 0x124u);
        *(_DWORD *)(v13 + 16) = (*((uint64_t (**)(void, char *, void, void))a5 + 2))(*((void *)a5 + 1), a1, 0, 0);
        (*((void (**)(void, char *, void))a5 + 25))(*((void *)a5 + 1), a1, *((_WORD *)a2 + 2) & 0xFFF);
        int v24 = *(_DWORD *)(v13 + 16);
      }
      else
      {
        int v24 = (*((uint64_t (**)(uint64_t, char *, void, void))a5 + 2))(v23, a1, 0, 0);
        *(_DWORD *)(v13 + 16) = v24;
      }
      if (v24 != -1)
      {
        a4 = *(_WORD *)(v13 + 40);
        int v20 = a4 & 1;
        goto LABEL_28;
      }
    }
    else
    {
LABEL_18:
      if (a3 == -1 && *(_DWORD *)(v13 + 16) != -1) {
        (*((void (**)(void))a5 + 4))(*((void *)a5 + 1));
      }
    }
    BOMFSObjectFree(v13);
    return 0;
  }
  return v13;
}

void *BOMFSObjectCopy(uint64_t a1)
{
  unsigned __int16 v2 = BOMFSObjectNewWithSys(*(_DWORD *)a1, *(void **)(a1 + 160));
  int v3 = v2;
  if (!v2) {
    return v3;
  }
  long long v4 = *(_OWORD *)(a1 + 32);
  long long v5 = *(_OWORD *)a1;
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 16);
  *((_OWORD *)v2 + 2) = v4;
  *(_OWORD *)unsigned __int16 v2 = v5;
  long long v6 = *(_OWORD *)(a1 + 48);
  long long v7 = *(_OWORD *)(a1 + 64);
  long long v8 = *(_OWORD *)(a1 + 96);
  *((_OWORD *)v2 + 5) = *(_OWORD *)(a1 + 80);
  *((_OWORD *)v2 + 6) = v8;
  *((_OWORD *)v2 + 3) = v6;
  *((_OWORD *)v2 + 4) = v7;
  long long v9 = *(_OWORD *)(a1 + 112);
  long long v10 = *(_OWORD *)(a1 + 128);
  long long v11 = *(_OWORD *)(a1 + 144);
  *((void *)v2 + 20) = *(void *)(a1 + 160);
  *((_OWORD *)v2 + 8) = v10;
  *((_OWORD *)v2 + 9) = v11;
  *((_OWORD *)v2 + 7) = v9;
  v2[4] = 0;
  *((void *)v2 + 3) = 0;
  *((void *)v2 + 4) = 0;
  uint64_t v12 = *(const char **)(a1 + 72);
  if (v12)
  {
    size_t v13 = strlen(v12) + 1;
    size_t v14 = (char *)BOM_malloc(v13);
    v3[9] = v14;
    if (!v14) {
      goto LABEL_16;
    }
    strlcpy(v14, *(const char **)(a1 + 72), v13);
  }
  int v15 = *(const char **)(a1 + 80);
  if (v15)
  {
    size_t v16 = strlen(v15) + 1;
    uint64_t v17 = (char *)BOM_malloc(v16);
    v3[10] = v17;
    if (!v17) {
      goto LABEL_16;
    }
    strlcpy(v17, *(const char **)(a1 + 80), v16);
  }
  if (BOMFSOArchInfoCopy(a1, (uint64_t)v3) || BOMFSOTypeInfoCopy(a1, (uint64_t)v3)) {
    return 0;
  }
  if (*(void *)(a1 + 120))
  {
    size_t v18 = BOM_malloc(*(void *)(a1 + 128));
    v3[15] = v18;
    if (v18)
    {
      memmove(v18, *(const void **)(a1 + 120), *(void *)(a1 + 128));
      goto LABEL_13;
    }
LABEL_16:
    int v22 = (void *)v3[9];
    if (v22) {
      free(v22);
    }
    uint64_t v23 = (void *)v3[10];
    if (v23) {
      free(v23);
    }
    int v24 = (void *)v3[15];
    if (v24) {
      free(v24);
    }
    long long v25 = (void *)v3[18];
    if (v25) {
      free(v25);
    }
    free(v3);
    return 0;
  }
LABEL_13:
  unint64_t v19 = *(const char **)(a1 + 144);
  if (v19)
  {
    size_t v20 = strlen(v19) + 1;
    long long v21 = (char *)BOM_malloc(v20);
    v3[18] = v21;
    if (v21)
    {
      strlcpy(v21, *(const char **)(a1 + 144), v20);
      *(unsigned char *)(a1 + 152) = 1;
      return v3;
    }
    goto LABEL_16;
  }
  return v3;
}

_DWORD *BOMFSObjectNewFromPathDeferred(uint64_t a1, char *a2, __int16 a3, const char *a4, int a5)
{
  return BOMFSObjectNewFromPathDeferredWithSys(a1, a2, a3, a4, a5, 0);
}

_DWORD *BOMFSObjectNewFromPathDeferredWithSys(uint64_t a1, char *a2, __int16 a3, const char *a4, int a5, void *a6)
{
  int v12 = BOMFSObjectTypeForMode(*(_WORD *)(a1 + 4));
  size_t v13 = BOMFSObjectNewWithSys(v12, a6);
  if (v13)
  {
    size_t v14 = strlen(a2) + 1;
    int v15 = BOM_malloc(v14);
    *((void *)v13 + 9) = v15;
    if (v15)
    {
      memmove(v15, a2, v14);
      size_t v16 = strrchr(a2, 47);
      uint64_t v17 = a2;
      if (v16)
      {
        if (v16[1]) {
          uint64_t v17 = v16 + 1;
        }
        else {
          uint64_t v17 = v16;
        }
      }
      size_t v18 = strlen(v17) + 1;
      unint64_t v19 = BOM_malloc(v18);
      *((void *)v13 + 10) = v19;
      if (v19)
      {
        memmove(v19, v17, v18);
        *((_WORD *)v13 + 20) = a3;
        if (a5)
        {
          size_t v20 = strlen(a4) + 1;
          long long v21 = BOM_malloc(v20);
          *((void *)v13 + 18) = v21;
          memmove(v21, a4, v20);
          *((unsigned char *)v13 + 152) = 1;
          if ((a3 & 1) == 0)
          {
LABEL_10:
            *((_WORD *)v13 + 68) = 0;
            return v13;
          }
        }
        else
        {
          *((void *)v13 + 18) = a4;
          if ((a3 & 1) == 0) {
            goto LABEL_10;
          }
        }
        *((_WORD *)v13 + 21) = *(_WORD *)(a1 + 4);
        *(void *)(v13 + 11) = *(void *)(a1 + 16);
        uint64_t v24 = *(void *)(a1 + 96);
        *((void *)v13 + 7) = *(void *)(a1 + 48);
        *((void *)v13 + 8) = v24;
        BOMFSOTypeInfoInitializeDeferred((uint64_t)v13, a1, (uint64_t)a2, 1u);
        *((_WORD *)v13 + 68) = 1;
        return v13;
      }
      int v22 = (void *)*((void *)v13 + 9);
      if (v22) {
        free(v22);
      }
    }
    uint64_t v23 = (void *)*((void *)v13 + 10);
    if (v23) {
      free(v23);
    }
    free(v13);
    return 0;
  }
  return v13;
}

_DWORD *BOMFSObjectNewFromPathString(const __CFString *a1, __int16 a2)
{
  return BOMFSObjectNewFromPathStringWithSys(a1, a2, 0);
}

_DWORD *BOMFSObjectNewFromPathStringWithSys(const __CFString *a1, __int16 a2, unsigned int (**a3)(void, char *, long long *))
{
  CStringPtr = (char *)CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    long long v7 = 0;
LABEL_5:
    long long v9 = BOMFSObjectNewFromPathWithSys(CStringPtr, a2, a3);
    goto LABEL_6;
  }
  long long v7 = (char *)BOM_malloc(0x2800uLL);
  int CString = CFStringGetCString(a1, v7, 10240, 0x8000100u);
  long long v9 = 0;
  if (v7)
  {
    int v10 = CString;
    CStringPtr = v7;
    if (v10) {
      goto LABEL_5;
    }
  }
LABEL_6:
  if (v7) {
    free(v7);
  }
  return v9;
}

uint64_t BOMFSObjectType(unsigned int *a1)
{
  return *a1;
}

uint64_t BOMFSObjectPathName(uint64_t result)
{
  if (result) {
    return *(void *)(result + 72);
  }
  return result;
}

uint64_t BOMFSObjectShortName(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

CFStringRef BOMFSObjectPathNameString(CFStringRef result)
{
  if (result) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], (const char *)result[2].info, 0x8000100u);
  }
  return result;
}

CFStringRef BOMFSObjectShortNameString(CFStringRef result)
{
  if (result) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], result[2].data, 0x8000100u);
  }
  return result;
}

uint64_t BOMFSObjectMode(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }
    return *(unsigned __int16 *)(v1 + 42);
  }
  return result;
}

uint64_t _loadStatInfo(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (*(_WORD *)(a1 + 136)) {
    return 0;
  }
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  long long v4 = 0u;
  snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(a1 + 144), *(const char **)(a1 + 72));
  if ((*(unsigned int (**)(void, char *, long long *))(*(void *)(a1 + 160) + 96))(*(void *)(*(void *)(a1 + 160) + 8), __str, &v4))
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "stat error for '%s'\n", __str);
    return 1;
  }
  else
  {
    *(_WORD *)(a1 + 42) = WORD2(v4);
    *(void *)(a1 + 44) = v5;
    uint64_t v3 = v10;
    *(void *)(a1 + 56) = v7;
    *(void *)(a1 + 64) = v3;
    BOMFSOTypeInfoInitializeDeferred(a1, (uint64_t)&v4, (uint64_t)__str, 1u);
    uint64_t result = 0;
    *(_WORD *)(a1 + 136) |= 1u;
  }
  return result;
}

uint64_t BOMFSObjectUserID(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }
    return *(unsigned int *)(v1 + 44);
  }
  return result;
}

uint64_t BOMFSObjectGroupID(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }
    return *(unsigned int *)(v1 + 48);
  }
  return result;
}

uint64_t BOMFSObjectModTime(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }
    return *(void *)(v1 + 56);
  }
  return result;
}

uint64_t BOMFSObjectSize(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144))
    {
      if ((*(_WORD *)(result + 136) & 1) == 0) {
        _loadStatInfo(result);
      }
    }
    return *(void *)(v1 + 64);
  }
  return result;
}

uint64_t BOMFSObjectPathID(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 4);
  }
  return result;
}

uint64_t BOMFSObjectSetPathID(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 4) = a2;
  }
  return result;
}

uint64_t BOMFSObjectParentPathID(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 8);
  }
  return result;
}

uint64_t BOMFSObjectSetParentPathID(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 8) = a2;
  }
  return result;
}

void BOMFSObjectSetPathName(uint64_t a1, char *__s, int a3)
{
  if (a1)
  {
    long long v6 = *(void **)(a1 + 72);
    if (v6) {
      free(v6);
    }
    if (__s && a3)
    {
      size_t v7 = strlen(__s) + 1;
      long long v8 = BOM_malloc(v7);
      *(void *)(a1 + 72) = v8;
      memmove(v8, __s, v7);
    }
    else
    {
      *(void *)(a1 + 72) = __s;
    }
  }
}

void BOMFSObjectSetShortName(uint64_t a1, char *__s, int a3)
{
  if (a1)
  {
    long long v6 = *(void **)(a1 + 80);
    if (v6) {
      free(v6);
    }
    if (__s && a3)
    {
      size_t v7 = strlen(__s) + 1;
      long long v8 = BOM_malloc(v7);
      *(void *)(a1 + 80) = v8;
      memmove(v8, __s, v7);
    }
    else
    {
      *(void *)(a1 + 80) = __s;
    }
  }
}

uint64_t BOMFSObjectSetFlags(uint64_t result, __int16 a2)
{
  if (result) {
    *(_WORD *)(result + 40) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetMode(uint64_t result, __int16 a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_WORD *)(result + 42) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetUserID(uint64_t result, int a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_DWORD *)(result + 44) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetGroupID(uint64_t result, int a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(_DWORD *)(result + 48) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetModTime(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(void *)(result + 56) = a2;
  }
  return result;
}

uint64_t BOMFSObjectSetSize(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(_WORD *)(result + 40) |= 1u;
    *(void *)(result + 64) = a2;
  }
  return result;
}

uint64_t BOMFSObjectVisitOrder(uint64_t a1)
{
  return *(unsigned int *)(a1 + 156);
}

uint64_t BOMFSObjectOpaqueData(uint64_t result)
{
  if (result) {
    return *(void *)(result + 120);
  }
  return result;
}

uint64_t BOMFSObjectOpaqueDataSize(uint64_t result)
{
  if (result) {
    return *(void *)(result + 128);
  }
  return result;
}

uint64_t BOMFSObjectSetOpaqueData(uint64_t a1, const void *a2, size_t a3, int a4)
{
  if (!a1) {
    return 1;
  }
  long long v9 = (void *)(a1 + 120);
  long long v8 = *(void **)(a1 + 120);
  if (v8) {
    free(v8);
  }
  __int16 v10 = *(_WORD *)(a1 + 40);
  if (a2 && a3)
  {
    *(_WORD *)(a1 + 40) = v10 | 0x10;
    *(void *)(a1 + 128) = a3;
    if (a4)
    {
      long long v11 = BOM_malloc(a3);
      *long long v9 = v11;
      if (v11)
      {
        memmove(v11, a2, a3);
        return 0;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      uint64_t result = 0;
      *long long v9 = a2;
    }
  }
  else
  {
    uint64_t result = 0;
    *(_WORD *)(a1 + 40) = v10 & 0xFFEF;
    *long long v9 = 0;
    v9[1] = 0;
  }
  return result;
}

uint64_t BOMFSObjectBlockID(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 12);
  }
  return result;
}

uint64_t BOMFSObjectSetBlockID(uint64_t result, int a2)
{
  if (result)
  {
    if (a2) {
      *(_DWORD *)(result + 12) = a2;
    }
  }
  return result;
}

uint64_t BOMFSObjectSetVisitOrder(uint64_t result, int a2)
{
  if (result) {
    *(_DWORD *)(result + 156) = a2;
  }
  return result;
}

uint64_t BOMFSObjectChecksum(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (_DWORD *)result;
    if (*(void *)(result + 144) && (*(_WORD *)(result + 136) & 2) == 0) {
      _loadCksumInfo(result);
    }
    return BOMFSOTypeInfoChecksum(v1);
  }
  return result;
}

uint64_t _loadCksumInfo(uint64_t result)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if ((*(_WORD *)(result + 136) & 2) != 0) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t result = _loadStatInfo(result);
  if (result) {
    return result;
  }
  if (*(_DWORD *)v1 != 1 || (*(_WORD *)(v1 + 40) & 2) == 0) {
    goto LABEL_10;
  }
  snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(v1 + 144), *(const char **)(v1 + 72));
  int v2 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(v1 + 160) + 184))(*(void *)(*(void *)(v1 + 160) + 8), __str, 4);
  uint64_t v3 = *(void *)(v1 + 160);
  uint64_t v4 = *(void *)(v3 + 8);
  if (v2 == -1)
  {
    (*(void (**)(uint64_t, char *, void))(v3 + 200))(v4, __str, *(_WORD *)(v1 + 42) & 0xFFF | 0x124u);
    int v5 = (*(uint64_t (**)(void, char *, void, void))(*(void *)(v1 + 160) + 16))(*(void *)(*(void *)(v1 + 160) + 8), __str, 0, 0);
    uint64_t result = (*(uint64_t (**)(void, char *, void))(*(void *)(v1 + 160) + 200))(*(void *)(*(void *)(v1 + 160) + 8), __str, *(_WORD *)(v1 + 42) & 0xFFF);
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, char *, void, void))(v3 + 16))(v4, __str, 0, 0);
    int v5 = result;
  }
  if (v5 != -1)
  {
    *(_DWORD *)(v1 + 16) = v5;
    *(void *)(v1 + 24) = 0;
    *(void *)(v1 + 32) = 0;
LABEL_10:
    uint64_t result = BOMFSOTypeInfoInitializeDeferred(v1, 0, (uint64_t)__str, 2u);
    *(_WORD *)(v1 + 136) |= 2u;
    if (*(_DWORD *)v1 == 1 && (*(_WORD *)(v1 + 40) & 2) != 0)
    {
      uint64_t result = (*(uint64_t (**)(void, void))(*(void *)(v1 + 160) + 32))(*(void *)(*(void *)(v1 + 160) + 8), *(unsigned int *)(v1 + 16));
      *(_DWORD *)(v1 + 16) = 0;
      *(void *)(v1 + 24) = 0;
      *(void *)(v1 + 32) = 0;
    }
  }
  return result;
}

uint64_t BOMFSObjectSymlinkTarget(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144) && (*(_WORD *)(result + 136) & 1) == 0) {
      _loadStatInfo(result);
    }
    return BOMFSOTypeInfoSymlinkTarget(v1);
  }
  return result;
}

CFStringRef BOMFSObjectSymlinkTargetString(CFStringRef result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    if (result[4].data && (result[4].info & 1) == 0) {
      _loadStatInfo((uint64_t)result);
    }
    return BOMFSOTypeInfoSymlinkTargetString(v1);
  }
  return result;
}

_DWORD *BOMFSObjectSetSymlinkTarget(_DWORD *result, char *__s, int a3)
{
  if (result)
  {
    *((_WORD *)result + 20) |= 1u;
    return BOMFSOTypeInfoSetSymlinkTarget(result, __s, a3);
  }
  return result;
}

uint64_t BOMFSObjectDeviceID(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(void *)(a1 + 144) && (*(_WORD *)(a1 + 136) & 1) == 0) {
    _loadStatInfo(a1);
  }
  return BOMFSOTypeInfoDeviceID((_DWORD *)a1);
}

_DWORD *BOMFSObjectSetChecksum(_DWORD *result, int a2)
{
  if (result) {
    return BOMFSOTypeInfoSetChecksum(result, a2);
  }
  return result;
}

_DWORD *BOMFSObjectSetDeviceID(_DWORD *result, int a2)
{
  if (result)
  {
    *((_WORD *)result + 20) |= 1u;
    return BOMFSOTypeInfoSetDeviceID(result, a2);
  }
  return result;
}

const char *BOMFSObjectSummary(const char *result, int a2, int a3, int a4)
{
  if (result)
  {
    uint64_t v7 = (uint64_t)result;
    if (*((void *)result + 18))
    {
      _loadCksumInfo((uint64_t)result);
      _loadArchInfo(v7);
    }
    return BOMFSOTypeInfoSummary(v7, a2, a3, a4);
  }
  return result;
}

uint64_t _loadArchInfo(uint64_t result)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if ((*(_WORD *)(result + 136) & 4) != 0) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t result = _loadStatInfo(result);
  if (result) {
    return result;
  }
  snprintf(__str, 0x401uLL, "%s/%s", *(const char **)(v1 + 144), *(const char **)(v1 + 72));
  if (*(_DWORD *)v1 == 1 && (*(_WORD *)(v1 + 40) & 4) != 0)
  {
    int v2 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(v1 + 160) + 184))(*(void *)(*(void *)(v1 + 160) + 8), __str, 4);
    uint64_t v3 = *(void *)(v1 + 160);
    uint64_t v4 = *(void *)(v3 + 8);
    if (v2 == -1)
    {
      (*(void (**)(uint64_t, char *, void))(v3 + 200))(v4, __str, *(_WORD *)(v1 + 42) & 0xFFF | 0x124u);
      int v5 = (*(uint64_t (**)(void, char *, void, void))(*(void *)(v1 + 160) + 16))(*(void *)(*(void *)(v1 + 160) + 8), __str, 0, 0);
      uint64_t result = (*(uint64_t (**)(void, char *, void))(*(void *)(v1 + 160) + 200))(*(void *)(*(void *)(v1 + 160) + 8), __str, *(_WORD *)(v1 + 42) & 0xFFF);
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, void, void))(v3 + 16))(v4, __str, 0, 0);
      int v5 = result;
    }
    if (v5 == -1) {
      return result;
    }
    *(_DWORD *)(v1 + 16) = v5;
    *(void *)(v1 + 24) = 0;
    *(void *)(v1 + 32) = 0;
  }
  uint64_t result = BOMFSOArchInfoInitialize();
  if (*(_DWORD *)v1 == 1 && (*(_WORD *)(v1 + 40) & 4) != 0)
  {
    uint64_t result = (*(uint64_t (**)(void, void))(*(void *)(v1 + 160) + 32))(*(void *)(*(void *)(v1 + 160) + 8), *(unsigned int *)(v1 + 16));
    *(_DWORD *)(v1 + 16) = 0;
    *(void *)(v1 + 24) = 0;
    *(void *)(v1 + 32) = 0;
  }
  *(_WORD *)(v1 + 136) |= 4u;
  return result;
}

uint64_t BOMFSObjectSummaryWithFormat(uint64_t a1, char *a2, int a3)
{
  if (!a1 || !a2) {
    return 0;
  }
  if (*(void *)(a1 + 144))
  {
    _loadCksumInfo(a1);
    _loadArchInfo(a1);
  }
  return BOMFSOTypeInfoSummaryWithFormat(a1, a2, a3);
}

const char *BOMFSObjectParseSummary(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    int v2 = BomSys_default();
    return (const char *)BOMFSOTypeInfoParseSummaryWithSys(v1, v2);
  }
  return result;
}

const char *BOMFSObjectParseSummaryWithSys(const char *result, void *a2)
{
  if (result)
  {
    int v2 = result;
    if (!a2) {
      a2 = BomSys_default();
    }
    return (const char *)BOMFSOTypeInfoParseSummaryWithSys(v2, a2);
  }
  return result;
}

uint64_t BOMFSObjectIsBinaryObject(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(void *)(result + 144) && (*(_WORD *)(result + 136) & 4) == 0) {
      _loadArchInfo(result);
    }
    if (*(_DWORD *)v1 == 1)
    {
      unsigned int v2 = *(unsigned __int16 *)(v1 + 40);
      if (v2 > 0xFFF) {
        return (v2 >> 2) & 1;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BOMFSObjectContainsArchitecture(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 144) && (*(_WORD *)(a1 + 136) & 4) == 0) {
    _loadArchInfo(a1);
  }
  return BOMFSOArchInfoContainsArchitecture(a1, a2);
}

uint64_t BOMFSObjectArchCount(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (_DWORD *)result;
    if (*(void *)(result + 144) && (*(_WORD *)(result + 136) & 4) == 0) {
      _loadArchInfo(result);
    }
    return BOMFSOArchInfoArchCount(v1);
  }
  return result;
}

uint64_t BOMFSObjectGetArch(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(void *)(result + 144) && (*(_WORD *)(result + 136) & 4) == 0) {
      _loadArchInfo(result);
    }
    return BOMFSOArchInfoGetArch(v3, a2);
  }
  return result;
}

uint64_t BOMFSObjectGetArchSubtype(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(void *)(result + 144) && (*(_WORD *)(result + 136) & 4) == 0) {
      _loadArchInfo(result);
    }
    return BOMFSOArchInfoGetArchSubtype(v3, a2);
  }
  return result;
}

uint64_t BOMFSObjectGetArchSize(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(void *)(result + 144) && (*(_WORD *)(result + 136) & 4) == 0) {
      _loadArchInfo(result);
    }
    return BOMFSOArchInfoGetArchSize(v3, a2);
  }
  return result;
}

uint64_t BOMFSObjectThinKeepingArchs(uint64_t a1, int *a2, unsigned int a3)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    if (a3)
    {
      if (*(void *)(a1 + 144) && (*(_WORD *)(a1 + 136) & 4) == 0) {
        _loadArchInfo(a1);
      }
      return BOMFSOArchInfoThinKeepingArchs(a1, a2, a3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BOMFSObjectThinKeepingArchsAndSubArchs(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    if (a3)
    {
      if (*(void *)(a1 + 144) && (*(_WORD *)(a1 + 136) & 4) == 0) {
        _loadArchInfo(a1);
      }
      return BOMFSOArchInfoThinKeepingArchsAndSubArchs(a1, a2, a3);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void BOMFSObjectSetArchInfo(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a1) {
    BOMFSOArchInfoSet(a1, a2, a3);
  }
}

unsigned __int8 *BOMFSObjectTypeFromRawData(unsigned __int8 *result)
{
  if (result) {
    return (unsigned __int8 *)*result;
  }
  return result;
}

void capture_error(void *a1, uint64_t a2, int a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v23 = 0;
  if (a1 && !*a1)
  {
    uint64_t v24 = 0;
    uint64_t v14 = malloc_type_calloc(1uLL, 0x30uLL, 0x105004057D267B0uLL);
    if (v14)
    {
      int v15 = v14;
      uint64_t v24 = &a9;
      if (vasprintf(&v23, a5, &a9) < 0)
      {
        size_t v20 = (FILE *)*MEMORY[0x263EF8348];
        long long v21 = __error();
        int v22 = strerror(*v21);
        fprintf(v20, "Could not create error message: %s\n", v22);
      }
      else
      {
        size_t v16 = v23;
        if (v23)
        {
          *(void *)int v15 = a2;
          v15[2] = a3;
          *((void *)v15 + 2) = "Nov 10 2024";
          *((void *)v15 + 3) = a4;
          *((void *)v15 + 4) = v16;
          v15[10] = *__error();
          *a1 = v15;
          return;
        }
        fwrite("Error message is NULL\n", 0x16uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      }
      free(v15);
    }
    else
    {
      uint64_t v17 = (FILE *)*MEMORY[0x263EF8348];
      size_t v18 = __error();
      unint64_t v19 = strerror(*v18);
      fprintf(v17, "Could not allocate error state: %s\n", v19);
    }
  }
}

void release_error(void *a1)
{
  if (a1)
  {
    unsigned int v2 = (void *)a1[4];
    if (v2) {
      free(v2);
    }
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *(_OWORD *)a1 = 0u;
    free(a1);
  }
}

char *BOMCopierSourceEntryTypeString(unsigned int a1)
{
  if (a1 > 0x13) {
    return 0;
  }
  else {
    return off_2641328D8[a1];
  }
}

_DWORD *BOMCopierSourceEntryNew(int a1, void *a2)
{
  uint64_t v4 = malloc_type_calloc(1uLL, 0x150uLL, 0x1030040944BAE5BuLL);
  int v5 = v4;
  if (v4)
  {
    v4[1] = a1;
    if (once != -1) {
      dispatch_once(&once, &__block_literal_global);
    }
    int v6 = global_groupID;
    v5[21] = global_userID;
    v5[22] = v6;
    *((_WORD *)v5 + 46) = -32348;
    v13.__darwin_time_t tv_sec = 0;
    *(void *)&v13.__darwin_suseconds_t tv_usec = 0;
    gettimeofday(&v13, 0);
    __darwin_time_t tv_sec = v13.tv_sec;
    uint64_t v8 = 1000 * v13.tv_usec;
    *((void *)v5 + 13) = v13.tv_sec;
    *((void *)v5 + 14) = v8;
    *((void *)v5 + 15) = tv_sec;
    *((void *)v5 + 16) = v8;
    *((void *)v5 + 17) = tv_sec;
    *((void *)v5 + 18) = v8;
    v5[81] = -1;
  }
  else
  {
    int v9 = *__error();
    __int16 v10 = __error();
    long long v11 = strerror(*v10);
    BOMCopierErrorCapture(a2, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 514, (uint64_t)"BOMCopierSourceEntryNew", "Could not allocate %ld bytes for BOMCopierSourceEntry: %s", 336, v11);
  }
  return v5;
}

uint64_t __BOMCopierSourceEntryNew_block_invoke()
{
  global_userID = geteuid();
  uint64_t result = getegid();
  global_groupID = result;
  return result;
}

uint64_t BOMCopierSourceEntryNewFromPath(char *a1, char a2, void *a3)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 557, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Invalid path");
    return 0;
  }
  memset(&v24, 0, sizeof(v24));
  if (lstat(a1, &v24))
  {
    int v6 = *__error();
    uint64_t v7 = __error();
    strerror(*v7);
    BOMCopierErrorCapture(a3, v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 572, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not stat %s: %s");
    return 0;
  }
  int v10 = mode_to_source_entry_type(v24.st_mode);
  long long v11 = BOMCopierSourceEntryNew(v10, a3);
  uint64_t v8 = (uint64_t)v11;
  if (!v11)
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 581, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not create BOMCopierSourceEntry for type %d", v10);
    return v8;
  }
  *long long v11 = 1;
  long long v12 = resolve_path(a1, v10 == 9, a3);
  *(void *)(v8 + 16) = v12;
  if (!v12)
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 593, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not resolve %s");
    goto LABEL_29;
  }
  timeval v13 = v12;
  uint64_t v14 = strdup(a1);
  *(void *)(v8 + 24) = v14;
  if (!v14)
  {
    int v19 = *__error();
    size_t v20 = __error();
    strerror(*v20);
    BOMCopierErrorCapture(a3, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 602, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not duplicate path %s: %s");
    goto LABEL_29;
  }
  if (v10 == 9)
  {
    bzero(__s1, 0x400uLL);
    ssize_t v15 = readlink(v13, __s1, 0x400uLL);
    if (v15 == -1)
    {
      if (*__error() != 13)
      {
        int v22 = *__error();
        uint64_t v23 = __error();
        strerror(*v23);
        BOMCopierErrorCapture(a3, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 620, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not readlink %s: %s\n");
        goto LABEL_29;
      }
    }
    else if (v15 >= 1)
    {
      __s1[v15] = 0;
      size_t v16 = strdup(__s1);
      *(void *)(v8 + 48) = v16;
      if (!v16)
      {
        int v17 = *__error();
        size_t v18 = __error();
        strerror(*v18);
        BOMCopierErrorCapture(a3, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 633, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not duplicate %s: %s\n");
LABEL_29:
        BOMCopierSourceEntryFree((unsigned int *)v8);
        return 0;
      }
    }
  }
  *(void *)(v8 + 84) = *(void *)&v24.st_uid;
  timespec st_mtimespec = v24.st_mtimespec;
  *(timespec *)(v8 + 104) = v24.st_atimespec;
  *(_DWORD *)(v8 + 64) = v24.st_dev;
  *(void *)(v8 + 72) = v24.st_ino;
  *(_WORD *)(v8 + 80) = v24.st_nlink;
  *(_WORD *)(v8 + 92) = v24.st_mode;
  *(void *)(v8 + 96) = v24.st_size;
  *(timespec *)(v8 + 120) = st_mtimespec;
  *(timespec *)(v8 + 136) = v24.st_ctimespec;
  *(_DWORD *)(v8 + 152) = v24.st_flags;
  if ((a2 & 2) != 0 && v10 == 8 && parse_regular_file(v8, a3))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 672, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not parse the regular file");
    goto LABEL_29;
  }
  if (capture_extended_attributes(v8, a2, a3))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 686, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not capture extended attributes");
    goto LABEL_29;
  }
  if ((a2 & 0x20) != 0 && capture_acl(v8, a3))
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 700, (uint64_t)"BOMCopierSourceEntryNewFromPath", "Could not capture access control list");
    goto LABEL_29;
  }
  return v8;
}

uint64_t mode_to_source_entry_type(__int16 a1)
{
  unsigned int v1 = (a1 & 0xF000) - 4096;
  if (v1 >> 13 > 6) {
    return 0;
  }
  else {
    return dword_210662E20[v1 >> 12];
  }
}

char *resolve_path(char *a1, char a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if ((a2 & 1) == 0)
  {
    uint64_t result = realpath_DARWIN_EXTSN(a1, 0);
    if (result) {
      return result;
    }
    int v8 = *__error();
    int v9 = __error();
    strerror(*v9);
    BOMCopierErrorCapture(a3, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5332, (uint64_t)"resolve_path", "Could not realpath %s: %s\n");
    return 0;
  }
  if (dirname_r(a1, v22) != v22)
  {
    int v5 = *__error();
    int v6 = __error();
    strerror(*v6);
    BOMCopierErrorCapture(a3, v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5346, (uint64_t)"resolve_path", "Could not dirname %s: %s\n");
    return 0;
  }
  int v10 = realpath_DARWIN_EXTSN(v22, 0);
  if (!v10)
  {
    int v15 = *__error();
    __error();
    size_t v16 = __error();
    strerror(*v16);
    BOMCopierErrorCapture(a3, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5353, (uint64_t)"resolve_path", "Could not realpath %s %d: %s\n", v22);
    return 0;
  }
  long long v11 = v10;
  if (basename_r(a1, v21) != v21)
  {
    int v12 = *__error();
    timeval v13 = __error();
    uint64_t v14 = strerror(*v13);
    BOMCopierErrorCapture(a3, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5360, (uint64_t)"resolve_path", "Could not basename %s: %s\n", a1, v14);
    free(v11);
    return 0;
  }
  size_t v20 = 0;
  int v17 = asprintf(&v20, "%s/%s", v11, v21);
  free(v11);
  if (v17 < 0 || (uint64_t result = v20) == 0)
  {
    int v18 = *__error();
    int v19 = __error();
    strerror(*v19);
    BOMCopierErrorCapture(a3, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5373, (uint64_t)"resolve_path", "Could not construct resolved path from %s + %s: %s\n", v22);
    return 0;
  }
  return result;
}

uint64_t BOMCopierSourceEntryFree(unsigned int *a1)
{
  if (!a1)
  {
    BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1739, (uint64_t)"BOMCopierSourceEntryFree", "Invalid source_entry");
    return 1;
  }
  int v2 = a1[81];
  if (v2 != -1) {
    close(v2);
  }
  if (*((unsigned char *)a1 + 320))
  {
    if (!*((void *)a1 + 2))
    {
      uint64_t v6 = 1;
      fwrite("Could not get actual path", 0x19uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      return v6;
    }
    unsigned int v3 = a1[1];
    if (v3 - 8 >= 3)
    {
      if (v3 == 6 && rmdir(*((const char **)a1 + 2)))
      {
        uint64_t v7 = (FILE *)*MEMORY[0x263EF8348];
        int v8 = __error();
        strerror(*v8);
        fprintf(v7, "Could not rmdir %s: %s");
        return 1;
      }
    }
    else if (unlink(*((const char **)a1 + 2)))
    {
      uint64_t v4 = (FILE *)*MEMORY[0x263EF8348];
      int v5 = __error();
      strerror(*v5);
      fprintf(v4, "Could not unlink %s: %s");
      return 1;
    }
  }
  int v9 = (void *)*((void *)a1 + 5);
  if (v9) {
    free(v9);
  }
  int v10 = (void *)*((void *)a1 + 4);
  if (v10) {
    free(v10);
  }
  long long v11 = (void *)*((void *)a1 + 3);
  if (v11) {
    free(v11);
  }
  int v12 = (void *)*((void *)a1 + 2);
  if (v12) {
    free(v12);
  }
  timeval v13 = (void *)*((void *)a1 + 6);
  if (v13) {
    free(v13);
  }
  uint64_t v14 = (void *)*((void *)a1 + 7);
  if (v14) {
    free(v14);
  }
  int v15 = (void *)*((void *)a1 + 25);
  if (v15) {
    free(v15);
  }
  size_t v16 = (void *)*((void *)a1 + 21);
  if (v16) {
    free(v16);
  }
  int v17 = (void *)*((void *)a1 + 30);
  if (v17) {
    free(v17);
  }
  if (a1[52])
  {
    uint64_t v18 = 0;
    unint64_t v19 = 0;
    do
    {
      free(*(void **)(*((void *)a1 + 27) + v18));
      size_t v20 = *(void **)(*((void *)a1 + 27) + v18 + 16);
      if (v20) {
        free(v20);
      }
      ++v19;
      v18 += 24;
    }
    while (v19 < a1[52]);
  }
  long long v21 = (void *)*((void *)a1 + 27);
  if (v21) {
    free(v21);
  }
  int v22 = (void *)*((void *)a1 + 28);
  if (v22) {
    free(v22);
  }
  uint64_t v23 = (void *)*((void *)a1 + 39);
  if (v23) {
    free(v23);
  }
  *((_OWORD *)a1 + 19) = 0u;
  *((_OWORD *)a1 + 20) = 0u;
  *((_OWORD *)a1 + 17) = 0u;
  *((_OWORD *)a1 + 18) = 0u;
  *((_OWORD *)a1 + 15) = 0u;
  *((_OWORD *)a1 + 16) = 0u;
  *((_OWORD *)a1 + 13) = 0u;
  *((_OWORD *)a1 + 14) = 0u;
  *((_OWORD *)a1 + 11) = 0u;
  *((_OWORD *)a1 + 12) = 0u;
  *((_OWORD *)a1 + 9) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 7) = 0u;
  *((_OWORD *)a1 + 8) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 6) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *(_OWORD *)a1 = 0u;
  free(a1);
  return 0;
}

uint64_t parse_regular_file(uint64_t a1, void *a2)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 156))
    {
      int v4 = 1;
      size_t v5 = 4096;
      goto LABEL_10;
    }
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  unint64_t Size = BOMCopierSourceEntryGetSize(a1);
  if (Size >= 0x1000) {
    size_t v5 = 4096;
  }
  else {
    size_t v5 = Size;
  }
  if (!Size) {
    return 0;
  }
  int v4 = 0;
LABEL_10:
  uint64_t v7 = (char *)malloc_type_malloc(0x1000uLL, 0x1FAA4AF7uLL);
  if (!v7)
  {
    int v12 = *__error();
    timeval v13 = __error();
    uint64_t v14 = strerror(*v13);
    BOMCopierErrorCapture(a2, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4004, (uint64_t)"parse_regular_file", "Could not allocate %lld bytes for parse buffer: %s", 4096, v14);
    return 1;
  }
  int v8 = v7;
  size_t v9 = BOMCopierSourceEntryRead(a1, v7, v5, a2);
  unint64_t v10 = v9;
  if (v4)
  {
    if (!v9)
    {
      free(v8);
      return 0;
    }
    if (v9 == -1)
    {
      BOMCopierSourceEntryGetPath(a1);
      uint64_t v11 = 1;
      BOMCopierErrorCapture(a2, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4019, (uint64_t)"parse_regular_file", "Could not read %lu bytes from %s");
LABEL_24:
      free(v8);
      return v11;
    }
  }
  else if (v9 != v5)
  {
    BOMCopierSourceEntryGetPath(a1);
    uint64_t v11 = 1;
    BOMCopierErrorCapture(a2, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4035, (uint64_t)"parse_regular_file", "Could not read %lu bytes from %s");
    goto LABEL_24;
  }
  *(void *)(a1 + 160) = 4096;
  *(void *)(a1 + 168) = v8;
  *(void *)(a1 + 176) = v9;
  if (v9 < 0x1C) {
    return 0;
  }
  uint64_t v11 = 0;
  int v15 = *(_DWORD *)v8;
  if (*(int *)v8 <= -822415875)
  {
    int v16 = 3;
    if (v15 > -889275715)
    {
      if (v15 != -889275714)
      {
        int v17 = -889275713;
        goto LABEL_33;
      }
    }
    else if (v15 != -1095041334)
    {
      int v17 = -1078264118;
LABEL_33:
      if (v15 != v17) {
        return v11;
      }
      int v16 = 4;
    }
    unint64_t v21 = *(void *)v8;
    size_t count = *(void *)v8;
    if ((v15 & 0xFEFFFFFF) == 0xBEBAFECA)
    {
      int v22 = BOMHostByteOrder();
      BOMSwapFatHeader((int8x8_t *)&count, v22);
      LODWORD(v23) = HIDWORD(count);
    }
    else
    {
      unint64_t v23 = HIDWORD(v21);
    }
    uint64_t v27 = v23;
    long long v28 = malloc_type_calloc(v23, 0x20uLL, 0x1000040E0EAB150uLL);
    if (!v28)
    {
      int v31 = *__error();
      long long v32 = __error();
      long long v33 = strerror(*v32);
      BOMCopierErrorCapture(a2, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4235, (uint64_t)"parse_regular_file", "Could not allocate BOMCopierArchRecord: %s", v33);
      uint64_t v11 = 1;
      goto LABEL_24;
    }
    long long v25 = v28;
    if (v15 == -1078264118 || v15 == -889275713) {
      uint64_t v30 = 32;
    }
    else {
      uint64_t v30 = 20;
    }
    if (v10 < v30 * (unint64_t)(v23 + 1) + 8)
    {
      uint64_t v11 = 0;
      int v8 = (char *)v28;
      goto LABEL_24;
    }
    int v46 = v16;
    if (v23)
    {
      long long v34 = v8 + 8;
      long long v35 = v28;
      do
      {
        if (v15 == -889275714 || v15 == -1095041334)
        {
          memset(v48, 0, 20);
          __memcpy_chk();
          if (v15 == -1095041334)
          {
            int v37 = BOMHostByteOrder();
            BOMSwapFatArch((uint64_t)v48, 1u, v37);
          }
          *long long v35 = v48[0].i64[0];
          *(void *)&long long v38 = v48[0].u32[2];
          *((void *)&v38 + 1) = v48[0].u32[3];
          *(_OWORD *)(v35 + 1) = v38;
          uint64_t v39 = v48[1].u32[0];
        }
        else
        {
          memset(v48, 0, sizeof(v48));
          __memcpy_chk();
          if (v15 == -1078264118)
          {
            int v40 = BOMHostByteOrder();
            BOMSwapFatArch64((uint64_t)v48, 1u, v40);
          }
          *long long v35 = v48[0].i64[0];
          *(int8x16_t *)(v35 + 1) = *(int8x16_t *)((char *)v48 + 8);
          uint64_t v39 = v48[1].u32[2];
        }
        v35[3] = v39;
        long long v34 = (_DWORD *)((char *)v34 + v30);
        v35 += 4;
        --v27;
      }
      while (v27);
    }
    int v19 = v46;
LABEL_77:
    uint64_t v11 = 0;
    *(_DWORD *)(a1 + 192) = v19;
    *(_DWORD *)(a1 + 196) = v23;
    *(void *)(a1 + 200) = v25;
    return v11;
  }
  int v19 = 1;
  if (v15 > -17958195)
  {
    if (v15 != -17958194)
    {
      int v20 = -17958193;
LABEL_39:
      if (v15 != v20) {
        return v11;
      }
      if (v9 >= 0x20)
      {
        int v19 = 2;
        goto LABEL_42;
      }
      return 0;
    }
  }
  else if (v15 != -822415874)
  {
    int v20 = -805638658;
    goto LABEL_39;
  }
LABEL_42:
  stat v24 = malloc_type_calloc(1uLL, 0x20uLL, 0x1000040E0EAB150uLL);
  if (v24)
  {
    long long v25 = v24;
    if (v15 == -17958194 || v15 == -822415874)
    {
      v48[0] = *(int8x16_t *)v8;
      *(int8x16_t *)((char *)v48 + 12) = *(int8x16_t *)(v8 + 12);
      if (v15 == -822415874)
      {
        int v26 = BOMHostByteOrder();
        BOMSwapMachHeader((uint64_t)v48, v26);
      }
    }
    else
    {
      int8x16_t v44 = *((int8x16_t *)v8 + 1);
      v48[0] = *(int8x16_t *)v8;
      v48[1] = v44;
      if (v15 == -805638658)
      {
        int v45 = BOMHostByteOrder();
        BOMSwapMachHeader64(v48, v45);
      }
    }
    void *v25 = *(uint64_t *)((char *)v48[0].i64 + 4);
    v25[1] = 0;
    v25[2] = *(void *)(a1 + 96);
    v25[3] = 0;
    LODWORD(v23) = 1;
    goto LABEL_77;
  }
  int v41 = *__error();
  uint64_t v42 = __error();
  uint64_t v43 = strerror(*v42);
  BOMCopierErrorCapture(a2, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4149, (uint64_t)"parse_regular_file", "Could not allocate BOMCopierArchRecord: %s", v43);
  free(v8);
  return 1;
}

ssize_t capture_extended_attributes(uint64_t a1, char a2, void *a3)
{
  if ((a2 & 0x1C) == 0) {
    return 0;
  }
  if (a1)
  {
    uint64_t v6 = *(const char **)(a1 + 16);
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    uint64_t v6 = 0;
  }
  if ((a2 & 0x10) != 0) {
    int v8 = 33;
  }
  else {
    int v8 = 1;
  }
  ssize_t result = listxattr(v6, 0, 0, v8);
  if (result)
  {
    size_t v9 = result;
    if (result == -1)
    {
      if (*__error() == 1 || *__error() == 45 || *__error() == 13) {
        return 0;
      }
      int v10 = *__error();
      uint64_t v11 = __error();
      strerror(*v11);
      BOMCopierErrorCapture(a3, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4409, (uint64_t)"capture_extended_attributes", "Could not listxattr %s: %s");
      return 1;
    }
    int v12 = (char *)malloc_type_malloc(result, 0xD6988167uLL);
    if (v12)
    {
      timeval v13 = v12;
      if (listxattr(v6, v12, v9, v8) == v9)
      {
        LODWORD(v14) = 0;
        unint64_t v15 = (unint64_t)&v13[v9];
        int v16 = v13;
        do
        {
          size_t v14 = (v14 + 1);
          v16 += strlen(v16) + 1;
        }
        while ((unint64_t)v16 < v15);
        int v17 = malloc_type_calloc(v14, 0x18uLL, 0x10100406AB5462FuLL);
        if (v17)
        {
          uint64_t v18 = v17;
          unsigned int v19 = 0;
          int v20 = v13;
          unsigned int v21 = 0;
          long long v38 = a3;
          uint64_t v39 = (char *)v20;
          while (1)
          {
            if ((a2 & 4) != 0)
            {
              if ((a2 & 8) != 0) {
                goto LABEL_30;
              }
              if (string_compare(v20, "com.apple.FinderInfo"))
              {
                BOOL v22 = string_compare(v20, "com.apple.ResourceFork") != 0;
                if ((a2 & 0x10) == 0) {
                  goto LABEL_38;
                }
                goto LABEL_31;
              }
            }
            else if ((a2 & 8) != 0)
            {
              if (string_compare(v20, "com.apple.FinderInfo"))
              {
                BOOL v22 = string_compare(v20, "com.apple.ResourceFork") == 0;
                if ((a2 & 0x10) == 0) {
                  goto LABEL_38;
                }
                goto LABEL_31;
              }
LABEL_30:
              BOOL v22 = 1;
              if ((a2 & 0x10) == 0) {
                goto LABEL_38;
              }
              goto LABEL_31;
            }
            BOOL v22 = 0;
            if ((a2 & 0x10) == 0)
            {
LABEL_38:
              if (v22) {
                goto LABEL_39;
              }
              goto LABEL_41;
            }
LABEL_31:
            if (!string_compare(v20, "com.apple.decmpfs")
              || (!string_compare(v20, "com.apple.ResourceFork") ? (char v23 = 1) : (char v23 = v22), (v23 & 1) != 0))
            {
LABEL_39:
              stat v24 = strdup(v20);
              v18[3 * v21] = v24;
              if (!v24)
              {
                int v34 = *__error();
                long long v35 = __error();
                strerror(*v35);
                BOMCopierErrorCapture(v38, v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4549, (uint64_t)"capture_extended_attributes", "Could not duplicate %s: %s");
LABEL_57:
                free(v18);
                long long v33 = v39;
                goto LABEL_58;
              }
              ++v19;
              ++v21;
            }
LABEL_41:
            v20 += strlen(v20) + 1;
            if ((unint64_t)v20 >= v15)
            {
              if (v19)
              {
                uint64_t v25 = 0;
                size_t v26 = v19;
                while (1)
                {
                  ssize_t v27 = getxattr(v6, (const char *)v18[v25], 0, 0, 0, v8);
                  if (v27 == -1) {
                    break;
                  }
                  v18[v25 + 1] = v27;
                  v25 += 3;
                  if (3 * v19 == v25) {
                    goto LABEL_54;
                  }
                }
                int v36 = *__error();
                int v37 = __error();
                strerror(*v37);
                BOMCopierErrorCapture(v38, v36, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4582, (uint64_t)"capture_extended_attributes", "Could not getxattr size for %s: %s");
                goto LABEL_57;
              }
              size_t v26 = 0;
LABEL_54:
              qsort(v18, v26, 0x18uLL, (int (__cdecl *)(const void *, const void *))xattr_compare);
              *(_DWORD *)(a1 + 208) = v19;
              *(void *)(a1 + 216) = v18;
              free(v39);
              return 0;
            }
          }
        }
        int v31 = *__error();
        long long v32 = __error();
        strerror(*v32);
        BOMCopierErrorCapture(a3, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4468, (uint64_t)"capture_extended_attributes", "Could not allocate extended attribute list: %s");
      }
      else
      {
        int v30 = *__error();
        BOMCopierErrorCapture(a3, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4434, (uint64_t)"capture_extended_attributes", "%ld does not match %ld\n");
      }
      long long v33 = v13;
LABEL_58:
      free(v33);
    }
    else
    {
      int v28 = *__error();
      long long v29 = __error();
      strerror(*v29);
      BOMCopierErrorCapture(a3, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4427, (uint64_t)"capture_extended_attributes", "Could not allocate %ld bytes for name buffer: %s\n");
    }
    return 1;
  }
  return result;
}

uint64_t capture_acl(uint64_t a1, void *a2)
{
  if (a1)
  {
    int v4 = *(const char **)(a1 + 16);
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    int v4 = 0;
  }
  if (*(_DWORD *)(a1 + 4) == 9) {
    acl_t link_np = acl_get_link_np(v4, ACL_TYPE_EXTENDED);
  }
  else {
    acl_t link_np = acl_get_file(v4, ACL_TYPE_EXTENDED);
  }
  uint64_t v6 = link_np;
  if (link_np)
  {
    ssize_t len_p = 0;
    uint64_t v7 = acl_to_text(link_np, &len_p);
    if (v7)
    {
      int v8 = v7;
      acl_free(v6);
      uint64_t result = 0;
      ssize_t v10 = len_p;
      *(void *)(a1 + 224) = v8;
      *(void *)(a1 + 232) = v10;
      return result;
    }
    int v11 = *__error();
    int v12 = __error();
    strerror(*v12);
    BOMCopierErrorCapture(a2, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4682, (uint64_t)"capture_acl", "Could not convert ACL to text for %s: %s");
  }
  else
  {
    if (*__error() == 2) {
      return 0;
    }
    int v13 = *__error();
    size_t v14 = __error();
    strerror(*v14);
    BOMCopierErrorCapture(a2, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4666, (uint64_t)"capture_acl", "Could not retrieve ACL for %s: %s");
  }
  return 1;
}

_DWORD *BOMCopierSourceEntryNewFromResourceFork(const char *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (a1)
  {
    int v4 = realpath_DARWIN_EXTSN(a1, 0);
    if (v4)
    {
      size_t v5 = v4;
      int v30 = 0;
      if (asprintf(&v30, "%s%s", v4, "/..namedfork/rsrc") < 0)
      {
        int v12 = *__error();
        int v13 = __error();
        size_t v14 = strerror(*v13);
        BOMCopierErrorCapture(a2, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 753, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not constructed resolved rsrc path: %s", v14);
        free(v5);
      }
      else
      {
        free(v5);
        memset(&v29, 0, sizeof(v29));
        if (lstat(v30, &v29))
        {
          int v6 = *__error();
          uint64_t v7 = __error();
          strerror(*v7);
          BOMCopierErrorCapture(a2, v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 764, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not stat %s: %s");
        }
        else
        {
          unint64_t v15 = BOMCopierSourceEntryNew(8, a2);
          ssize_t v10 = v15;
          if (!v15)
          {
            BOMCopierErrorCapture(a2, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 771, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not create BOMCopierSourceEntry for regular file");
            return v10;
          }
          *unint64_t v15 = 2;
          *((void *)v15 + 2) = v30;
          int v16 = v15 + 6;
          if (asprintf((char **)v15 + 3, "%s%s", a1, "/..namedfork/rsrc") == -1 || !*v16)
          {
            int v19 = *__error();
            int v20 = __error();
            strerror(*v20);
            BOMCopierErrorCapture(a2, v19, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 785, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not constructed entry rsrc path: %s");
          }
          else if (__s1 == dirname_r(a1, __s1))
          {
            unsigned int v21 = strdup(__s1);
            *((void *)v10 + 4) = v21;
            if (v21)
            {
              if (v31 == basename_r(a1, v31))
              {
                if (asprintf((char **)v10 + 5, "%s%s", v31, "/..namedfork/rsrc") != -1 && *((void *)v10 + 5))
                {
                  *(void *)(v10 + 21) = *(void *)&v29.st_uid;
                  timespec st_mtimespec = v29.st_mtimespec;
                  *(timespec *)(v10 + 26) = v29.st_atimespec;
                  v10[16] = v29.st_dev;
                  *((void *)v10 + 9) = v29.st_ino;
                  *((_WORD *)v10 + 40) = v29.st_nlink;
                  *((_WORD *)v10 + 46) = v29.st_mode;
                  *((void *)v10 + 12) = v29.st_size;
                  *(timespec *)(v10 + 30) = st_mtimespec;
                  *(timespec *)(v10 + 34) = v29.st_ctimespec;
                  v10[38] = v29.st_flags;
                  return v10;
                }
                int v27 = *__error();
                int v28 = __error();
                strerror(*v28);
                BOMCopierErrorCapture(a2, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 813, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not constructed entry rsrc name: %s");
              }
              else
              {
                int v22 = *__error();
                char v23 = __error();
                strerror(*v23);
                BOMCopierErrorCapture(a2, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 806, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not basename_r %s: %s");
              }
            }
            else
            {
              int v24 = *__error();
              uint64_t v25 = __error();
              strerror(*v25);
              BOMCopierErrorCapture(a2, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 799, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not duplicate %s: %s");
            }
          }
          else
          {
            int v17 = *__error();
            uint64_t v18 = __error();
            strerror(*v18);
            BOMCopierErrorCapture(a2, v17, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 792, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not dirname_r %s: %s");
          }
        }
      }
    }
    else
    {
      int v8 = *__error();
      __error();
      size_t v9 = __error();
      strerror(*v9);
      BOMCopierErrorCapture(a2, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 745, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Could not realpath %s %d: %s\n", a1);
    }
  }
  else
  {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 732, (uint64_t)"BOMCopierSourceEntryNewFromResourceFork", "Invalid path");
  }
  return 0;
}

uint64_t BOMCopierSourceEntryNewFromFTSENT(uint64_t a1, char a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 850, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Invalid filesystem_entry");
    return 0;
  }
  int v6 = 6;
  switch(*(_WORD *)(a1 + 88))
  {
    case 1:
      break;
    case 2:
      int v6 = 1;
      break;
    case 3:
      int v6 = mode_to_source_entry_type(*(_WORD *)(*(void *)(a1 + 96) + 4));
      break;
    case 4:
      int v6 = 2;
      break;
    case 5:
      int v6 = 3;
      break;
    case 6:
      int v6 = 13;
      break;
    case 8:
      int v6 = 8;
      break;
    case 0xC:
      int v6 = 9;
      break;
    case 0xE:
      int v6 = 11;
      break;
    default:
      int v6 = 0;
      break;
  }
  uint64_t v7 = BOMCopierSourceEntryNew(v6, a3);
  uint64_t v8 = (uint64_t)v7;
  if (v7)
  {
    *uint64_t v7 = 3;
    size_t v9 = copy_string(*(const void **)(a1 + 48), *(unsigned __int16 *)(a1 + 64));
    *(void *)(v8 + 16) = v9;
    if (!v9)
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 877, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not duplicate %s");
      goto LABEL_36;
    }
    ssize_t v10 = copy_string(*(const void **)(a1 + 48), *(unsigned __int16 *)(a1 + 64));
    *(void *)(v8 + 24) = v10;
    if (!v10)
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 886, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not duplicate %s");
      goto LABEL_36;
    }
    if (v6 == 9)
    {
      bzero(v19, 0x400uLL);
      ssize_t v11 = readlink(*(const char **)(a1 + 40), v19, 0x400uLL);
      if (v11 == -1)
      {
        int v14 = *__error();
        unint64_t v15 = __error();
        strerror(*v15);
        BOMCopierErrorCapture(a3, v14, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 899, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not readlink %s: %s\n");
        goto LABEL_36;
      }
      v19[v11] = 0;
      int v12 = copy_string(v19, v11);
      *(void *)(v8 + 48) = v12;
      if (!v12)
      {
        int v17 = __error();
        strerror(*v17);
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 909, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not duplicate %s: %s\n");
        goto LABEL_36;
      }
    }
    uint64_t v13 = *(void *)(a1 + 96);
    *(_DWORD *)(v8 + 64) = *(_DWORD *)v13;
    *(void *)(v8 + 72) = *(void *)(v13 + 8);
    *(_WORD *)(v8 + 80) = *(_WORD *)(v13 + 6);
    *(_WORD *)(v8 + 92) = *(_WORD *)(v13 + 4);
    *(void *)(v8 + 84) = *(void *)(v13 + 16);
    *(void *)(v8 + 96) = *(void *)(v13 + 96);
    *(_OWORD *)(v8 + 104) = *(_OWORD *)(v13 + 32);
    *(_OWORD *)(v8 + 120) = *(_OWORD *)(v13 + 48);
    *(_OWORD *)(v8 + 136) = *(_OWORD *)(v13 + 64);
    *(_DWORD *)(v8 + 152) = *(_DWORD *)(v13 + 116);
    if ((a2 & 1) != 0 && v6 == 8) {
      *(unsigned char *)(v8 + 321) = 1;
    }
    if ((a2 & 2) != 0 && v6 == 8 && parse_regular_file(v8, a3))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 961, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not parse the regular file");
LABEL_36:
      BOMCopierSourceEntryFree((unsigned int *)v8);
      return 0;
    }
    if (capture_extended_attributes(v8, a2, a3))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 975, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not capture extended attributes");
      goto LABEL_36;
    }
    if ((a2 & 0x20) != 0)
    {
      int v16 = capture_acl(v8, a3);
      if (v16)
      {
        BOMCopierErrorCapture(a3, v16, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 989, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not capture access control list");
        goto LABEL_36;
      }
    }
  }
  else
  {
    BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 865, (uint64_t)"BOMCopierSourceEntryNewFromFTSENT", "Could not create BOMCopierSourceEntry from %d", v6);
  }
  return v8;
}

unsigned char *copy_string(const void *a1, size_t a2)
{
  size_t v4 = a2 + 1;
  size_t v5 = malloc_type_malloc(a2 + 1, 0xF6B84704uLL);
  int v6 = v5;
  if (v5)
  {
    memcpy(v5, a1, a2);
    v6[a2] = 0;
  }
  else
  {
    uint64_t v7 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v8 = __error();
    size_t v9 = strerror(*v8);
    fprintf(v7, "Could not allocate copy buffer of %ld bytes: %s\n", v4, v9);
  }
  return v6;
}

uint64_t BOMCopierSourceEntryNewFromFSObject(const char *a1, uint64_t a2, __int16 a3, void *a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1023, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Invalid source_path");
    return 0;
  }
  if (!a2)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1029, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Invalid fso");
    return 0;
  }
  __int16 v8 = BOMFSObjectMode(a2);
  uint64_t v9 = BOMFSObjectPathName(a2);
  if (!v9)
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1047, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not retrieve path from fso\n");
    return 0;
  }
  ssize_t v10 = (const char *)v9;
  int v11 = mode_to_source_entry_type(v8);
  int v12 = strcmp(v10, ".");
  if (v12) {
    int v13 = 0;
  }
  else {
    int v13 = 6;
  }
  if (v11) {
    int v14 = v11;
  }
  else {
    int v14 = v13;
  }
  unint64_t v15 = BOMCopierSourceEntryNew(v14, a4);
  uint64_t v16 = (uint64_t)v15;
  if (!v15)
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1063, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not create BOMCopierSourceEntry from %d", v14);
    return v16;
  }
  *unint64_t v15 = 4;
  int v17 = strdup(v10);
  *(void *)(v16 + 24) = v17;
  if (!v17)
  {
    unsigned int v21 = __error();
    strerror(*v21);
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1076, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate fso_path %s: %s\n");
    goto LABEL_23;
  }
  uint64_t v55 = 0;
  if (v12)
  {
    if (asprintf(&v55, "%s/%s", a1, v10 + 2) == -1 || (uint64_t v18 = v55) == 0)
    {
      int v19 = __error();
      strerror(*v19);
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1097, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not construct path from %s and %s: %s\n", a1);
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v18 = strdup(a1);
    uint64_t v55 = v18;
    if (!v18)
    {
      int v30 = __error();
      strerror(*v30);
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1087, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate %s: %s\n");
      goto LABEL_23;
    }
  }
  memset(&v54, 0, sizeof(v54));
  int v22 = lstat(v18, &v54);
  if (v22)
  {
    if (*__error() != 13 && *__error() != 1)
    {
      int v34 = *__error();
      long long v35 = __error();
      strerror(*v35);
      BOMCopierErrorCapture(a4, v34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1121, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not lstat %s: %s\n");
      goto LABEL_23;
    }
    if ((a3 & 0x100) == 0)
    {
      int v23 = *__error();
      int v24 = __error();
      strerror(*v24);
      BOMCopierErrorCapture(a4, v23, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1113, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not lstat %s: %s\n");
      goto LABEL_23;
    }
  }
  unsigned int v53 = 0;
  uint64_t v25 = resolve_path(v55, v14 == 9, &v53);
  *(void *)(v16 + 16) = v25;
  if (!v25)
  {
    int Code = BOMCopierErrorGetCode((uint64_t)v53);
    if (Code != 13 && Code != 1)
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1147, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not resolve %s", v55);
      BOMCopierSourceEntryFree((unsigned int *)v16);
      free(v55);
      return 0;
    }
    if ((a3 & 0x100) == 0)
    {
      int v32 = *__error();
      uint64_t v33 = __error();
      strerror(*v33);
      BOMCopierErrorCapture(a4, v32, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1137, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not resolve path for %s: %s\n");
      goto LABEL_23;
    }
    BOMCopierErrorFree(v53);
    goto LABEL_49;
  }
  if (v22)
  {
LABEL_49:
    int v36 = v55;
    int v37 = strdup(v55);
    *(void *)(v16 + 16) = v37;
    if (v37)
    {
      free(v36);
      if (v14 == 9)
      {
        long long v38 = (const char *)BOMFSObjectSymlinkTarget(a2);
        if (!v38)
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1183, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not get symlink target from fso\n", v51, v52);
          goto LABEL_23;
        }
        uint64_t v39 = strdup(v38);
        *(void *)(v16 + 48) = v39;
        if (!v39)
        {
          uint64_t v48 = __error();
          strerror(*v48);
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1191, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate %s: %s\n");
          goto LABEL_23;
        }
      }
      *(_WORD *)(v16 + 92) = BOMFSObjectMode(a2);
      *(_DWORD *)(v16 + 84) = BOMFSObjectUserID(a2);
      *(_DWORD *)(v16 + 88) = BOMFSObjectGroupID(a2);
      uint64_t v40 = BOMFSObjectSize(a2);
      *(void *)(v16 + 104) = 0;
      *(void *)(v16 + 112) = 0;
      *(void *)(v16 + 96) = v40;
      *(void *)(v16 + 120) = BOMFSObjectModTime(a2);
      *(void *)(v16 + 128) = 0;
      *(void *)(v16 + 136) = 0;
      *(void *)(v16 + 144) = 0;
      *(_DWORD *)(v16 + 152) = 0;
      return v16;
    }
    int v41 = *__error();
    uint64_t v42 = v55;
    uint64_t v43 = __error();
    int8x16_t v44 = strerror(*v43);
    BOMCopierErrorCapture(a4, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1165, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate %s: %s", v42, v44);
    free(v55);
LABEL_23:
    BOMCopierSourceEntryFree((unsigned int *)v16);
    return 0;
  }
  free(v55);
  if (v14 == 9)
  {
    bzero(__s1, 0x400uLL);
    ssize_t v26 = readlink(*(const char **)(v16 + 16), __s1, 0x400uLL);
    if (v26 == -1)
    {
      int v46 = *__error();
      unsigned int v47 = __error();
      strerror(*v47);
      BOMCopierErrorCapture(a4, v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1226, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not readlink %s: %s\n");
      goto LABEL_23;
    }
    __s1[v26] = 0;
    int v27 = strdup(__s1);
    *(void *)(v16 + 48) = v27;
    if (!v27)
    {
      int v49 = *__error();
      uint64_t v50 = __error();
      strerror(*v50);
      BOMCopierErrorCapture(a4, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1236, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not duplicate %s: %s\n");
      goto LABEL_23;
    }
  }
  *(void *)(v16 + 84) = *(void *)&v54.st_uid;
  timespec st_mtimespec = v54.st_mtimespec;
  *(timespec *)(v16 + 104) = v54.st_atimespec;
  *(_DWORD *)(v16 + 64) = v54.st_dev;
  *(void *)(v16 + 72) = v54.st_ino;
  *(_WORD *)(v16 + 80) = v54.st_nlink;
  *(_WORD *)(v16 + 92) = v54.st_mode;
  *(void *)(v16 + 96) = v54.st_size;
  *(timespec *)(v16 + 120) = st_mtimespec;
  *(timespec *)(v16 + 136) = v54.st_ctimespec;
  *(_DWORD *)(v16 + 152) = v54.st_flags;
  if ((a3 & 0x80) != 0) {
    *(_DWORD *)(v16 + 84) = BOMFSObjectUserID(a2);
  }
  if ((a3 & 2) != 0 && v14 == 8)
  {
    int v29 = parse_regular_file(v16, a4);
    if (v29)
    {
      BOMCopierErrorCapture(a4, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1280, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not parse the regular file", v51, v52);
      goto LABEL_23;
    }
  }
  int v45 = capture_extended_attributes(v16, a3, a4);
  if (v45)
  {
    BOMCopierErrorCapture(a4, v45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1294, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not capture extended attributes", v51, v52);
    goto LABEL_23;
  }
  if ((a3 & 0x20) != 0 && capture_acl(v16, a4))
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1308, (uint64_t)"BOMCopierSourceEntryNewFromFSObject", "Could not capture access control list", v51, v52);
    goto LABEL_23;
  }
  return v16;
}

uint64_t BOMCopierSourceEntryNewFromLibarchive(uint64_t a1, uint64_t a2, __int16 a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1343, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Invalid archive");
    return 0;
  }
  if (!a2)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1349, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Invalid archive_entry");
    return 0;
  }
  __int16 v8 = archive_entry_mode();
  int v9 = mode_to_source_entry_type(v8);
  ssize_t v10 = BOMCopierSourceEntryNew(v9, 0);
  uint64_t v11 = (uint64_t)v10;
  if (!v10)
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1364, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not create BOMCopierSourceEntry from %d", v9);
    return v11;
  }
  *ssize_t v10 = 5;
  int v12 = (const char *)archive_entry_pathname();
  size_t v13 = strlen(v12) - 1;
  if (v12[v13] == 47)
  {
    int v14 = strdup(v12);
    if (!v14)
    {
      int v24 = *__error();
      uint64_t v25 = __error();
      strerror(*v25);
      BOMCopierErrorCapture(a4, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1386, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not duplicate %s: %s");
      goto LABEL_22;
    }
    unint64_t v15 = v14;
    v14[v13] = 0;
    int v12 = v14;
  }
  else
  {
    unint64_t v15 = 0;
  }
  uint64_t v16 = strdup(v12);
  *(void *)(v11 + 24) = v16;
  if (!v16)
  {
    int v20 = *__error();
    unsigned int v21 = __error();
    strerror(*v21);
    BOMCopierErrorCapture(a4, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1398, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not duplicate %s: %s");
LABEL_22:
    BOMCopierSourceEntryFree((unsigned int *)v11);
    return 0;
  }
  int v17 = strdup(v12);
  *(void *)(v11 + 16) = v17;
  if (!v17)
  {
    int v22 = *__error();
    int v23 = __error();
    strerror(*v23);
    BOMCopierErrorCapture(a4, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1406, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not duplicate %s: %s");
    goto LABEL_22;
  }
  if (v15) {
    free(v15);
  }
  *(void *)(v11 + 256) = a1;
  *(void *)(v11 + 264) = a2;
  *(_DWORD *)(v11 + 64) = archive_entry_dev();
  *(void *)(v11 + 72) = archive_entry_ino();
  *(_WORD *)(v11 + 80) = archive_entry_nlink();
  *(_WORD *)(v11 + 92) = archive_entry_mode();
  *(_DWORD *)(v11 + 84) = archive_entry_uid();
  *(_DWORD *)(v11 + 88) = archive_entry_gid();
  *(void *)(v11 + 96) = archive_entry_size();
  *(void *)(v11 + 104) = archive_entry_atime();
  *(void *)(v11 + 112) = archive_entry_atime_nsec();
  *(void *)(v11 + 120) = archive_entry_mtime();
  *(void *)(v11 + 128) = archive_entry_mtime_nsec();
  *(void *)(v11 + 136) = archive_entry_ctime();
  *(void *)(v11 + 144) = archive_entry_ctime_nsec();
  if ((a3 & 0x200) != 0)
  {
    __int16 v18 = *(_WORD *)(v11 + 92);
    if ((v18 & 0xF000) == 0x4000)
    {
      __int16 v19 = v18 | 0x1ED;
    }
    else if ((*(_WORD *)(v11 + 92) & 0xE00) != 0)
    {
      __int16 v19 = -32348;
    }
    else
    {
      __int16 v19 = v18 | 0x1A4;
    }
    *(_WORD *)(v11 + 92) = v19;
  }
  if (v9 != 8)
  {
    if (v9 != 9) {
      return v11;
    }
    int v27 = (const char *)archive_entry_symlink();
    if (v27)
    {
      int v28 = strdup(v27);
      *(void *)(v11 + 48) = v28;
      if (v28)
      {
        *(void *)(v11 + 96) = strlen(v28);
        return v11;
      }
      int v29 = *__error();
      int v30 = __error();
      strerror(*v30);
      BOMCopierErrorCapture(a4, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1461, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not duplicate %s: %s\n");
    }
    else
    {
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1453, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not get symlink target from Libarchive entry\n");
    }
    goto LABEL_22;
  }
  if ((a3 & 2) != 0 && parse_regular_file(v11, a4))
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1480, (uint64_t)"BOMCopierSourceEntryNewFromLibarchive", "Could not parse the regular file");
    goto LABEL_22;
  }
  return v11;
}

uint64_t BOMCopierSourceEntryNewFromDataArchive(uint64_t a1, _DWORD *a2, __int16 a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1500, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Invalid data_archive");
    return 0;
  }
  if (!a2)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1506, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Invalid data_archive_entry");
    return 0;
  }
  unsigned int type = data_archive_entry_get_type(a2);
  __int16 v9 = data_archive_entry_mode((uint64_t)a2);
  int v10 = mode_to_source_entry_type(v9);
  int v11 = v10;
  if (type == 3)
  {
    switch(v10)
    {
      case 6:
        int v11 = 14;
        break;
      case 9:
        int v11 = 16;
        break;
      case 8:
        int v11 = 15;
        break;
      default:
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1533, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Unexpected post order entry type: %u");
        return 0;
    }
  }
  int v12 = BOMCopierSourceEntryNew(v11, a4);
  uint64_t v13 = (uint64_t)v12;
  if (!v12)
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1541, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not create BOMCopierSourceEntry from %d", v11);
    return v13;
  }
  *int v12 = 6;
  int v14 = (const char *)data_archive_entry_path((uint64_t)a2);
  size_t v15 = strlen(v14) - 1;
  if (v14[v15] == 47)
  {
    uint64_t v16 = strdup(v14);
    if (!v16)
    {
      int v28 = *__error();
      int v29 = __error();
      strerror(*v29);
      BOMCopierErrorCapture(a4, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1563, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not duplicate %s: %s");
      goto LABEL_41;
    }
    int v17 = v16;
    v16[v15] = 0;
    int v14 = v16;
  }
  else
  {
    int v17 = 0;
  }
  __int16 v18 = strdup(v14);
  *(void *)(v13 + 24) = v18;
  if (!v18)
  {
    int v24 = *__error();
    uint64_t v25 = __error();
    strerror(*v25);
    BOMCopierErrorCapture(a4, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1575, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not duplicate %s: %s");
LABEL_41:
    BOMCopierSourceEntryFree((unsigned int *)v13);
    return 0;
  }
  __int16 v19 = strdup(v14);
  *(void *)(v13 + 16) = v19;
  if (!v19)
  {
    int v26 = *__error();
    int v27 = __error();
    strerror(*v27);
    BOMCopierErrorCapture(a4, v26, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1583, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not duplicate %s: %s");
    goto LABEL_41;
  }
  if (v17) {
    free(v17);
  }
  *(void *)(v13 + 272) = a1;
  *(void *)(v13 + 280) = a2;
  *(_DWORD *)(v13 + 64) = data_archive_entry_dev(a2);
  *(void *)(v13 + 72) = data_archive_entry_inode((uint64_t)a2);
  *(_WORD *)(v13 + 80) = data_archive_entry_nlink((uint64_t)a2);
  *(_WORD *)(v13 + 92) = data_archive_entry_mode((uint64_t)a2);
  *(_DWORD *)(v13 + 84) = data_archive_entry_uid(a2);
  *(_DWORD *)(v13 + 88) = data_archive_entry_gid(a2);
  uint64_t v20 = data_archive_entry_size((uint64_t)a2);
  if ((v11 - 15) >= 2) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = 0;
  }
  *(void *)(v13 + 96) = v21;
  *(void *)(v13 + 104) = data_archive_entry_atime((uint64_t)a2);
  *(void *)(v13 + 112) = data_archive_entry_atime_nsec(a2);
  *(void *)(v13 + 120) = data_archive_entry_mtime((uint64_t)a2);
  *(void *)(v13 + 128) = data_archive_entry_atime_nsec(a2);
  *(void *)(v13 + 136) = data_archive_entry_ctime((uint64_t)a2);
  *(void *)(v13 + 144) = data_archive_entry_atime_nsec(a2);
  *(unsigned char *)(v13 + 156) = data_archive_entry_is_streamed((BOOL)a2);
  if ((a3 & 0x200) != 0)
  {
    __int16 v22 = *(_WORD *)(v13 + 92);
    if ((v22 & 0xF000) == 0x4000)
    {
      __int16 v23 = v22 | 0x1ED;
    }
    else if ((*(_WORD *)(v13 + 92) & 0xE00) != 0)
    {
      __int16 v23 = -32348;
    }
    else
    {
      __int16 v23 = v22 | 0x1A4;
    }
    *(_WORD *)(v13 + 92) = v23;
  }
  if ((a3 & 2) != 0 && v11 == 8 && parse_regular_file(v13, a4))
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1649, (uint64_t)"BOMCopierSourceEntryNewFromDataArchive", "Could not parse the regular file");
    goto LABEL_41;
  }
  return v13;
}

uint64_t BOMCopierSourceEntryNewFromAppleArchive(uint64_t a1, AAHeader header, unsigned __int8 a3, void *a4)
{
  value[128] = *MEMORY[0x263EF8340];
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1669, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Invalid aa_decoder");
    return 0;
  }
  if (!header)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1675, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Invalid header");
    return 0;
  }
  value[0] = 0;
  v9.ikey = 5265748;
  uint32_t KeyIndex = AAHeaderGetKeyIndex(header, v9);
  if ((KeyIndex & 0x80000000) != 0
    || ((FieldUInt = AAHeaderGetFieldUInt(header, KeyIndex, value), FieldUInt <= 1) ? (int v12 = 1) : (int v12 = FieldUInt),
        v12 < 1))
  {
LABEL_15:
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1686, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Unknown source entry type");
    return 0;
  }
  uint64_t v13 = 0;
  int v14 = 8;
  switch(LODWORD(value[0]))
  {
    case 'B':
      int v14 = 7;
      goto LABEL_23;
    case 'C':
      int v14 = 5;
      goto LABEL_23;
    case 'D':
      int v14 = 6;
      goto LABEL_23;
    case 'E':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'M':
    case 'N':
    case 'O':
      goto LABEL_15;
    case 'F':
      goto LABEL_24;
    case 'L':
      int v14 = 9;
      goto LABEL_23;
    case 'P':
      int v14 = 4;
      goto LABEL_23;
    default:
      if (LODWORD(value[0]) == 83)
      {
        int v14 = 10;
      }
      else
      {
        if (LODWORD(value[0]) != 87) {
          goto LABEL_15;
        }
        int v14 = 11;
      }
LABEL_23:
      uint64_t v13 = 1;
LABEL_24:
      int v17 = BOMCopierSourceEntryNew(v14, 0);
      uint64_t v15 = (uint64_t)v17;
      if (!v17)
      {
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1693, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Could not create BOMCopierSourceEntry from %d", v14);
        return v15;
      }
      *int v17 = 7;
      *((void *)v17 + 36) = a1;
      *((void *)v17 + 37) = header;
      v17[76] = 5521732;
      Fieldint64_t Count = AAHeaderGetFieldCount(header);
      if (!FieldCount) {
        goto LABEL_42;
      }
      uint32_t v19 = FieldCount;
      uint32_t v20 = 0;
      break;
  }
  do
  {
    Fieldint Type = AAHeaderGetFieldType(header, v20);
    unsigned int v22 = FieldType;
    if (FieldType < 0)
    {
      BOMCopierErrorCapture(a4, FieldType, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5501, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get field type from AppleArchive header index %u: %d");
      goto LABEL_149;
    }
    AAFieldKey FieldKey = AAHeaderGetFieldKey(header, v20);
    if (!FieldKey.ikey)
    {
      BOMCopierErrorCapture(a4, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5508, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get field key from AppleArchive header index %u: %u");
      goto LABEL_149;
    }
    if (v22 >= 5)
    {
      if (v22 != 5)
      {
        BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5593, (uint64_t)"populate_source_entry_from_apple_archive", "Unknown AppleArchive field type: %u");
        goto LABEL_149;
      }
      AAFieldKey v24 = FieldKey;
      if (FieldKey.ikey != 5521732)
      {
        value[0] = 0;
        offset.__darwin_time_t tv_sec = 0;
        int FieldBlob = AAHeaderGetFieldBlob(header, v20, value, (uint64_t *)&offset);
        if (FieldBlob < 0)
        {
          BOMCopierErrorCapture(a4, FieldBlob, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5553, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive blob: %d");
          goto LABEL_149;
        }
        uint64_t v26 = v13;
        uint64_t v27 = *(unsigned int *)(v15 + 308);
        int v28 = (char *)malloc_type_realloc(*(void **)(v15 + 312), 32 * (v27 + 1), 0xD1FD997DuLL);
        if (!v28)
        {
          int v66 = *__error();
          uint64_t v67 = __error();
          strerror(*v67);
          BOMCopierErrorCapture(a4, v66, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5564, (uint64_t)"populate_source_entry_from_apple_archive", "Could not allocate blob list: %s");
          goto LABEL_149;
        }
        int v29 = &v28[32 * v27];
        *(AAFieldKey *)int v29 = v24;
        *((void *)v29 + 2) = value[0];
        *((void *)v29 + 1) = offset.tv_sec;
        char v30 = a3 >> 5;
        if (v24.ikey == 4997953 || (char v30 = a3 >> 2, v24.ikey == 5521752)) {
          v29[24] = v30 & 1;
        }
        *(_DWORD *)(v15 + 308) = v27 + 1;
        *(void *)(v15 + 312) = v28;
        uint64_t v13 = v26;
      }
    }
    ++v20;
  }
  while (v19 != v20);
LABEL_42:
  bzero(value, 0x400uLL);
  size_t length = 0;
  v31.ikey = 5521744;
  uint32_t v32 = AAHeaderGetKeyIndex(header, v31);
  if ((v32 & 0x80000000) != 0)
  {
    int v35 = 0;
LABEL_89:
    BOMCopierErrorCapture(a4, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5614, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get path from AppleArchive: %d");
    goto LABEL_149;
  }
  uint64_t v33 = (const char *)value;
  unsigned int FieldString = AAHeaderGetFieldString(header, v32, 0x400uLL, (char *)value, &length);
  if (FieldString <= 1) {
    int v35 = 1;
  }
  else {
    int v35 = FieldString;
  }
  if (v35 <= 0) {
    goto LABEL_89;
  }
  if (!length) {
    uint64_t v33 = ".";
  }
  int v36 = strdup(v33);
  *(void *)(v15 + 24) = v36;
  if (!v36)
  {
    int v61 = *__error();
    uint64_t v62 = __error();
    strerror(*v62);
    BOMCopierErrorCapture(a4, v61, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5631, (uint64_t)"populate_source_entry_from_apple_archive", "Could not duplicate %s: %s");
    goto LABEL_149;
  }
  int v37 = strdup((const char *)value);
  *(void *)(v15 + 16) = v37;
  if (!v37)
  {
    int v63 = *__error();
    uint64_t v64 = __error();
    strerror(*v64);
    BOMCopierErrorCapture(a4, v63, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5638, (uint64_t)"populate_source_entry_from_apple_archive", "Could not duplicate %s: %s");
    goto LABEL_149;
  }
  if (*(_DWORD *)(v15 + 4) == 9)
  {
    bzero(&offset, 0x400uLL);
    size_t v93 = 0;
    v38.ikey = 4935244;
    uint32_t v39 = AAHeaderGetKeyIndex(header, v38);
    if ((v39 & 0x80000000) != 0
      || ((unsigned int v40 = AAHeaderGetFieldString(header, v39, 0x400uLL, (char *)&offset, &v93), v40 <= 1)
        ? (int v41 = 1)
        : (int v41 = v40),
          v41 <= 0))
    {
      int v65 = *__error();
      BOMCopierErrorCapture(a4, v65, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5654, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get symlink target path: %d");
      goto LABEL_149;
    }
    uint64_t v42 = strdup((const char *)&offset);
    *(void *)(v15 + 48) = v42;
    if (!v42)
    {
      int v68 = *__error();
      char v69 = __error();
      strerror(*v69);
      BOMCopierErrorCapture(a4, v68, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5661, (uint64_t)"populate_source_entry_from_apple_archive", "Could not duplicate %s: %s\n");
      goto LABEL_149;
    }
  }
  size_t v93 = 0;
  v43.ikey = 5653828;
  uint32_t v44 = AAHeaderGetKeyIndex(header, v43);
  if ((v44 & 0x80000000) == 0)
  {
    unsigned int v45 = AAHeaderGetFieldUInt(header, v44, &v93);
    if (v45 <= 1) {
      int v46 = 1;
    }
    else {
      int v46 = v45;
    }
    if (v46 < 0)
    {
      BOMCopierErrorCapture(a4, v46, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5674, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive device: %d");
LABEL_149:
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1706, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Could not populate source entry from AppleArchive");
      goto LABEL_150;
    }
    if (v45 <= 1) {
      *(_DWORD *)(v15 + 64) = v93;
    }
  }
  v47.ikey = 5197385;
  uint32_t v48 = AAHeaderGetKeyIndex(header, v47);
  if ((v48 & 0x80000000) != 0) {
    goto LABEL_72;
  }
  unsigned int v49 = AAHeaderGetFieldUInt(header, v48, &v93);
  if (v49 <= 1) {
    int v50 = 1;
  }
  else {
    int v50 = v49;
  }
  if (v50 < 0)
  {
    BOMCopierErrorCapture(a4, v50, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5686, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive inode: %d");
    goto LABEL_149;
  }
  if (v49 <= 1) {
    *(void *)(v15 + 72) = v93;
  }
LABEL_72:
  v51.ikey = 4934734;
  uint32_t v52 = AAHeaderGetKeyIndex(header, v51);
  if ((v52 & 0x80000000) != 0) {
    goto LABEL_79;
  }
  unsigned int v53 = AAHeaderGetFieldUInt(header, v52, &v93);
  if (v53 <= 1) {
    int v54 = 1;
  }
  else {
    int v54 = v53;
  }
  if (v54 < 0)
  {
    BOMCopierErrorCapture(a4, v54, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5698, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive nlink: %d");
    goto LABEL_149;
  }
  if (v53 <= 1) {
    *(_WORD *)(v15 + 80) = v93;
  }
LABEL_79:
  v55.ikey = 4476749;
  uint32_t v56 = AAHeaderGetKeyIndex(header, v55);
  if ((v56 & 0x80000000) != 0) {
    goto LABEL_103;
  }
  unsigned int v57 = AAHeaderGetFieldUInt(header, v56, &v93);
  if (v57 <= 1) {
    int v58 = 1;
  }
  else {
    int v58 = v57;
  }
  if (v58 < 0)
  {
    BOMCopierErrorCapture(a4, v58, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5710, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive mode: %d");
    goto LABEL_149;
  }
  if (v57 <= 1)
  {
    __int16 v59 = v93;
    *(_WORD *)(v15 + 92) = v93;
    int v60 = *(_DWORD *)(v15 + 4) - 4;
    if (v60 >= 8 || ((0xF7u >> v60) & 1) == 0)
    {
      BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5757, (uint64_t)"populate_source_entry_from_apple_archive", "Unsupported entry type: %u");
      goto LABEL_149;
    }
    *(_WORD *)(v15 + 92) = word_210662E60[v60] | v59;
  }
LABEL_103:
  v70.ikey = 4475221;
  uint32_t v71 = AAHeaderGetKeyIndex(header, v70);
  if ((v71 & 0x80000000) != 0) {
    goto LABEL_110;
  }
  unsigned int v72 = AAHeaderGetFieldUInt(header, v71, &v93);
  if (v72 <= 1) {
    int v73 = 1;
  }
  else {
    int v73 = v72;
  }
  if (v73 < 0)
  {
    BOMCopierErrorCapture(a4, v73, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5766, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive uid: %d");
    goto LABEL_149;
  }
  if (v72 <= 1) {
    *(_DWORD *)(v15 + 84) = v93;
  }
LABEL_110:
  v74.ikey = 4475207;
  uint32_t v75 = AAHeaderGetKeyIndex(header, v74);
  if ((v75 & 0x80000000) != 0) {
    goto LABEL_117;
  }
  unsigned int v76 = AAHeaderGetFieldUInt(header, v75, &v93);
  if (v76 <= 1) {
    int v77 = 1;
  }
  else {
    int v77 = v76;
  }
  if (v77 < 0)
  {
    BOMCopierErrorCapture(a4, v77, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5778, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive gid: %d");
    goto LABEL_149;
  }
  if (v76 <= 1) {
    *(_DWORD *)(v15 + 88) = v93;
  }
LABEL_117:
  uint64_t v91 = 0;
  uint64_t size = 0;
  v78.ikey = 5521732;
  uint32_t v79 = AAHeaderGetKeyIndex(header, v78);
  if ((v79 & 0x80000000) != 0) {
    goto LABEL_124;
  }
  unsigned int v80 = AAHeaderGetFieldBlob(header, v79, &size, &v91);
  if (v80 <= 1) {
    int v81 = 1;
  }
  else {
    int v81 = v80;
  }
  if (v81 < 0)
  {
    BOMCopierErrorCapture(a4, v81, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5792, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive data size: %d");
    goto LABEL_149;
  }
  if (v80 <= 1) {
    *(void *)(v15 + 96) = size;
  }
LABEL_124:
  v82.ikey = 5917011;
  uint32_t v83 = AAHeaderGetKeyIndex(header, v82);
  if ((v83 & 0x80000000) != 0) {
    goto LABEL_131;
  }
  unsigned int v84 = AAHeaderGetFieldUInt(header, v83, &v93);
  if (v84 <= 1) {
    int v85 = 1;
  }
  else {
    int v85 = v84;
  }
  if (v85 < 0)
  {
    BOMCopierErrorCapture(a4, v85, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5804, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive size: %d");
    goto LABEL_149;
  }
  if (v84 <= 1) {
    *(void *)(v15 + 96) = v93;
  }
LABEL_131:
  offset.__darwin_time_t tv_sec = 0;
  offset.tv_nsec = 0;
  v86.ikey = 5067853;
  uint32_t v87 = AAHeaderGetKeyIndex(header, v86);
  if ((v87 & 0x80000000) != 0) {
    goto LABEL_138;
  }
  unsigned int FieldTimespec = AAHeaderGetFieldTimespec(header, v87, &offset);
  if (FieldTimespec <= 1) {
    int v89 = 1;
  }
  else {
    int v89 = FieldTimespec;
  }
  if (v89 < 0)
  {
    BOMCopierErrorCapture(a4, v89, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5817, (uint64_t)"populate_source_entry_from_apple_archive", "Could not get AppleArchive modification timespec: %d");
    goto LABEL_149;
  }
  if (FieldTimespec <= 1) {
    *(timespec *)(v15 + 120) = offset;
  }
LABEL_138:
  *(void *)(v15 + 104) = 0;
  *(void *)(v15 + 112) = 0;
  *(void *)(v15 + 136) = 0;
  *(void *)(v15 + 144) = 0;
  if ((a3 & 2) != 0) {
    char v90 = v13;
  }
  else {
    char v90 = 1;
  }
  if ((v90 & 1) == 0 && parse_regular_file(v15, a4))
  {
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 1722, (uint64_t)"BOMCopierSourceEntryNewFromAppleArchive", "Could not parse the regular file");
LABEL_150:
    BOMCopierSourceEntryFree((unsigned int *)v15);
    return 0;
  }
  return v15;
}

uint64_t BOMCopierSourceEntryGetActualPath(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 16);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetType(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 4);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetPath(uint64_t a1)
{
  if (a1)
  {
    uint64_t result = *(void *)(a1 + 24);
    if (!result) {
      return *(void *)(a1 + 16);
    }
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    return 0;
  }
  return result;
}

char *BOMCopierSourceEntryGetParent(void *a1)
{
  if (!a1)
  {
    size_t v4 = (FILE *)*MEMORY[0x263EF8348];
    size_t v5 = "Invalid source_entry";
    size_t v6 = 20;
LABEL_10:
    fwrite(v5, v6, 1uLL, v4);
    return 0;
  }
  int v2 = (char *)a1[4];
  if (v2) {
    return v2;
  }
  unsigned int v3 = (const char *)a1[3];
  if (!v3)
  {
    unsigned int v3 = (const char *)a1[2];
    if (!v3)
    {
      size_t v4 = (FILE *)*MEMORY[0x263EF8348];
      size_t v5 = "Missing entry_path";
      size_t v6 = 18;
      goto LABEL_10;
    }
  }
  if (!strcmp(v3, "."))
  {
    int v2 = strdup(".");
    goto LABEL_14;
  }
  int v2 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x8C400F89uLL);
  if (v2)
  {
    if (v2 != dirname_r(v3, v2))
    {
      free(v2);
      return 0;
    }
LABEL_14:
    a1[4] = v2;
  }
  return v2;
}

char *BOMCopierSourceEntryGetName(void *a1)
{
  if (!a1)
  {
    size_t v4 = (FILE *)*MEMORY[0x263EF8348];
    size_t v5 = "Invalid source_entry";
    size_t v6 = 20;
LABEL_10:
    fwrite(v5, v6, 1uLL, v4);
    return 0;
  }
  int v2 = (char *)a1[5];
  if (v2) {
    return v2;
  }
  unsigned int v3 = (const char *)a1[3];
  if (!v3)
  {
    unsigned int v3 = (const char *)a1[2];
    if (!v3)
    {
      size_t v4 = (FILE *)*MEMORY[0x263EF8348];
      size_t v5 = "Missing entry_path";
      size_t v6 = 18;
      goto LABEL_10;
    }
  }
  if (!strcmp(v3, "."))
  {
    int v2 = strdup(".");
    goto LABEL_14;
  }
  int v2 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x24089911uLL);
  if (v2)
  {
    if (v2 != basename_r(v3, v2))
    {
      free(v2);
      return 0;
    }
LABEL_14:
    a1[5] = v2;
  }
  return v2;
}

uint64_t BOMCopierSourceEntryGetDevice(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 64);
  }
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2026, (uint64_t)"BOMCopierSourceEntryGetDevice", "Invalid source_entry");
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetInode(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 72);
  }
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2040, (uint64_t)"BOMCopierSourceEntryGetInode", "Invalid source_entry");
  return -1;
}

uint64_t BOMCopierSourceEntryGetHardlinkCount(uint64_t a1)
{
  if (a1) {
    return *(unsigned __int16 *)(a1 + 80);
  }
  BOMCopierErrorCapture(0, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2054, (uint64_t)"BOMCopierSourceEntryGetHardlinkCount", "Invalid source_entry");
  return 0xFFFFLL;
}

uint64_t BOMCopierSourceEntryGetSize(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)a1) {
      return *(void *)(a1 + 96);
    }
    else {
      return *(void *)(a1 + 248);
    }
  }
  else
  {
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    return 0;
  }
}

uint64_t BOMCopierSourceEntryGetMode(uint64_t a1)
{
  if (a1) {
    return *(unsigned __int16 *)(a1 + 92);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetUserID(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 84);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetGroupID(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 88);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetFlags(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 152);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0xFFFFFFFFLL;
}

uint64_t BOMCopierSourceEntryGetAccessTime(uint64_t a1, _OWORD *a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = 0;
      *a2 = *(_OWORD *)(a1 + 104);
    }
    else
    {
      uint64_t v2 = 1;
      fwrite("Invalid access_time", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
  }
  else
  {
    uint64_t v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntryGetModificationTime(uint64_t a1, _OWORD *a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = 0;
      *a2 = *(_OWORD *)(a1 + 120);
    }
    else
    {
      uint64_t v2 = 1;
      fwrite("Invalid modification_time", 0x19uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
  }
  else
  {
    uint64_t v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntryGetStatusTime(uint64_t a1, _OWORD *a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = 0;
      *a2 = *(_OWORD *)(a1 + 136);
    }
    else
    {
      uint64_t v2 = 1;
      fwrite("Invalid status_time", 0x13uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    }
  }
  else
  {
    uint64_t v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntryGetSymlinkTarget(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 48);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetAppleDoubleTarget(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 56);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

BOOL BOMCopierSourceEntryIsCompressed(BOOL result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 152);
    return (v1 & 0x20) != 0 && (v1 & 0x40000000) == 0;
  }
  return result;
}

uint64_t BOMCopierSourceEntryIsRestricted(uint64_t result)
{
  if (result) {
    return (*(unsigned __int8 *)(result + 154) >> 3) & 1;
  }
  return result;
}

uint64_t BOMCopierSourceEntryGetBinaryType(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 192);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetArchCount(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 196);
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

uint64_t BOMCopierSourceEntryGetArchRecord(uint64_t a1, unsigned int a2, _OWORD *a3, void *a4)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 196) <= a2)
    {
      BOMCopierErrorCapture(a4, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2344, (uint64_t)"BOMCopierSourceEntryGetArchRecord", "index is out of range");
    }
    else
    {
      if (a3)
      {
        uint64_t result = 0;
        size_t v6 = (_OWORD *)(*(void *)(a1 + 200) + 32 * a2);
        long long v7 = v6[1];
        *a3 = *v6;
        a3[1] = v7;
        return result;
      }
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2350, (uint64_t)"BOMCopierSourceEntryGetArchRecord", "Invalid arch_record");
    }
  }
  else
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2338, (uint64_t)"BOMCopierSourceEntryGetArchRecord", "Invalid source_entry");
  }
  return 1;
}

uint64_t BOMCopierSourceEntryGetExtendedAttributeCount(uint64_t a1, void *a2)
{
  if (a1) {
    return *(unsigned int *)(a1 + 208);
  }
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2370, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeCount", "source_entry is NULL");
  return 0;
}

uint64_t BOMCopierSourceEntryGetExtendedAttributeName(uint64_t a1, unsigned int a2, void *a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 208) > a2) {
      return *(void *)(*(void *)(a1 + 216) + 24 * a2);
    }
    BOMCopierErrorCapture(a3, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2395, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeName", "index is out of range");
  }
  else
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2389, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeName", "source_entry is NULL");
  }
  return 0;
}

uint64_t BOMCopierSourceEntryGetExtendedAttributeSize(uint64_t a1, unsigned int a2, void *a3)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 208) > a2) {
      return *(void *)(*(void *)(a1 + 216) + 24 * a2 + 8);
    }
    BOMCopierErrorCapture(a3, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2420, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeSize", "index is out of range");
  }
  else
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2414, (uint64_t)"BOMCopierSourceEntryGetExtendedAttributeSize", "source_entry is NULL");
  }
  return 0;
}

ssize_t BOMCopierSourceEntryCopyExtendedAttribute(uint64_t a1, unsigned int a2, void *__dst, size_t __n, u_int32_t a5, void *a6)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a6, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2442, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "source_entry is NULL");
    return -1;
  }
  if (*(_DWORD *)(a1 + 208) <= a2)
  {
    BOMCopierErrorCapture(a6, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2448, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "index is out of range");
    return -1;
  }
  if (!__dst)
  {
    BOMCopierErrorCapture(a6, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2454, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "value is NULL");
    return -1;
  }
  size_t v8 = __n;
  if (!__n)
  {
    BOMCopierErrorCapture(a6, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2460, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "size is 0");
    return -1;
  }
  uint64_t v10 = *(void *)(a1 + 216);
  uint64_t v11 = v10 + 24 * a2;
  if (__n + a5 > *(void *)(v11 + 8))
  {
    BOMCopierErrorCapture(a6, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2473, (uint64_t)"BOMCopierSourceEntryCopyExtendedAttribute", "size + position are out of range");
    return -1;
  }
  uint64_t v13 = *(void *)(v10 + 24 * a2 + 16);
  if (v13)
  {
    memcpy(__dst, (const void *)(v13 + a5), __n);
    return v8;
  }
  int v14 = *(const char **)v11;
  int v15 = string_compare(*(const char **)v11, "com.apple.decmpfs");
  if (string_compare(v14, "com.apple.ResourceFork")) {
    BOOL v16 = v15 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  if (v16) {
    int v17 = 33;
  }
  else {
    int v17 = 1;
  }
  __int16 v18 = *(const char **)(a1 + 16);
  return getxattr(v18, v14, __dst, v8, a5, v17);
}

uint64_t string_compare(const char *a1, const char *a2)
{
  size_t v4 = strlen(a1);
  size_t v5 = strlen(a2);
  if (v5 <= v4) {
    size_t v6 = v4;
  }
  else {
    size_t v6 = v5;
  }
  return strncmp(a1, a2, v6);
}

uint64_t BOMCopierSourceEntryGetACL(uint64_t a1, void *a2, void *a3)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v4 = a1 + 224;
      uint64_t result = *(void *)(a1 + 224);
      *a2 = *(void *)(v4 + 8);
      return result;
    }
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2516, (uint64_t)"BOMCopierSourceEntryGetACL", "acl_text_size is NULL");
  }
  else
  {
    BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2510, (uint64_t)"BOMCopierSourceEntryGetACL", "source_entry is NULL");
  }
  return 0;
}

uint64_t BOMCopierSourceEntryGetQuarantine(uint64_t a1, void *a2)
{
  if (!a1) {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2536, (uint64_t)"BOMCopierSourceEntryGetQuarantine", "source_entry is NULL");
  }
  return 0;
}

uint64_t BOMCopierSourceEntryCheckAccess(uint64_t a1, void *a2)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2555, (uint64_t)"BOMCopierSourceEntryCheckAccess", "Invalid source_entry");
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)a1 - 1) > 3) {
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 4);
  if (v3 == 6) {
    int v4 = 5;
  }
  else {
    int v4 = 4;
  }
  if (v3 == 9) {
    int v5 = 48;
  }
  else {
    int v5 = 16;
  }
  uint64_t result = faccessat(-2, *(const char **)(a1 + 16), v4, v5);
  if (result)
  {
    int v7 = *__error();
    size_t v8 = __error();
    strerror(*v8);
    BOMCopierErrorCapture(a2, v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2595, (uint64_t)"BOMCopierSourceEntryCheckAccess", "Could not faccess %s: %s");
    return 0xFFFFFFFFLL;
  }
  return result;
}

size_t BOMCopierSourceEntryRead(uint64_t a1, char *__dst, size_t a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2613, (uint64_t)"BOMCopierSourceEntryRead", "Invalid source_entry");
    return -1;
  }
  int v5 = __dst;
  if (!__dst)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2619, (uint64_t)"BOMCopierSourceEntryRead", "Invalid buffer");
    return -1;
  }
  size_t v6 = a3;
  if (!a3)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2625, (uint64_t)"BOMCopierSourceEntryRead", "Invalid num_bytes");
    return -1;
  }
  AAFieldKey v9 = (void *)(a1 + 168);
  uint64_t v8 = *(void *)(a1 + 168);
  if (!v8)
  {
    size_t v12 = 0;
    goto LABEL_16;
  }
  uint64_t v11 = *(void *)(a1 + 176);
  uint64_t v10 = *(void *)(a1 + 184);
  if (v11 - v10 >= a3) {
    size_t v12 = a3;
  }
  else {
    size_t v12 = v11 - v10;
  }
  memcpy(__dst, (const void *)(v8 + v10), v12);
  v5 += v12;
  v6 -= v12;
  uint64_t v13 = *(void *)(a1 + 176);
  size_t v14 = *(void *)(a1 + 184) + v12;
  *(void *)(a1 + 184) = v14;
  if (v14 == v13)
  {
    *(void *)(a1 + 160) = 0;
    free(*(void **)(a1 + 168));
    *AAFieldKey v9 = 0;
    v9[1] = 0;
    _DWORD v9[2] = 0;
  }
  if (v6)
  {
LABEL_16:
    int v15 = open_origin(a1, a4);
    if (v15)
    {
      BOMCopierErrorCapture(a4, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2672, (uint64_t)"BOMCopierSourceEntryRead", "Could not open the underlying origin");
    }
    else
    {
      uint64_t v21 = read_from_origin(a1, v5, v6, a4, v16, v17, v18, v19);
      if (v21 != -1)
      {
        if (v21 >= 1) {
          *(void *)(a1 + 328) += v21;
        }
        v12 += v21;
        return v12;
      }
      BOMCopierErrorCapture(a4, -1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2684, (uint64_t)"BOMCopierSourceEntryRead", "Could not read from the underlying origin");
    }
    return -1;
  }
  return v12;
}

uint64_t open_origin(uint64_t a1, void *a2)
{
  if ((*(_DWORD *)a1 - 1) > 3 || *(_DWORD *)(a1 + 324) != -1) {
    return 0;
  }
  int v5 = *(const char **)(a1 + 16);
  if (!v5)
  {
    BOMCopierErrorCapture(a2, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4757, (uint64_t)"open_origin", "source entry has no actual path");
    return 0xFFFFFFFFLL;
  }
  int v6 = open(*(const char **)(a1 + 16), 0);
  if (v6 == -1)
  {
    int v11 = *__error();
    size_t v12 = __error();
    strerror(*v12);
    BOMCopierErrorCapture(a2, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4764, (uint64_t)"open_origin", "Could not open %s: %s");
    return 0xFFFFFFFFLL;
  }
  int v7 = v6;
  if (*(unsigned char *)(a1 + 321) && fcntl(v6, 48, 1))
  {
    int v8 = *__error();
    AAFieldKey v9 = __error();
    uint64_t v10 = strerror(*v9);
    BOMCopierErrorCapture(a2, v8, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4773, (uint64_t)"open_origin", "Could not F_NOCACHE %s: %s", v5, v10);
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 324) = v7;
  }
  return result;
}

uint64_t read_from_origin(uint64_t a1, void *a2, size_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(*(_DWORD *)a1)
  {
    case 0:
      uint64_t v14 = *(void *)(a1 + 240);
      if (!v14) {
        return 0;
      }
      unint64_t v15 = *(void *)(a1 + 248);
      unint64_t v16 = *(void *)(a1 + 328);
      BOOL v17 = v15 > v16;
      size_t v18 = v15 - v16;
      if (!v17) {
        return 0;
      }
      if (v18 >= a3) {
        size_t v11 = a3;
      }
      else {
        size_t v11 = v18;
      }
      memcpy(a2, (const void *)(v14 + v16), v11);
      return v11;
    case 1:
    case 2:
    case 3:
    case 4:
      size_t v11 = read(*(_DWORD *)(a1 + 324), a2, a3);
      if (v11 != -1) {
        return v11;
      }
      int v12 = *__error();
      uint64_t v13 = __error();
      strerror(*v13);
      BOMCopierErrorCapture(a4, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4847, (uint64_t)"read_from_origin", "Could not read %ld bytes from file descriptor: %s");
      return -1;
    case 5:
      uint64_t v19 = *(void *)(a1 + 256);
      return MEMORY[0x270F97E80](v19, a2, a3);
    case 6:
      AAFieldKey v24 = 0;
      size_t v11 = data_archive_read_data(*(void *)(a1 + 272), a2, a3, &v24, a5, a6, a7, a8);
      if (v11 == -1)
      {
        uint32_t v20 = __error();
        BOMCopierErrorCapture(a4, *v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4864, (uint64_t)"read_from_origin", "Could not read %ld bytes from data_archive: %s", a3, *((const char **)v24 + 4));
        release_error(v24);
      }
      return v11;
    case 7:
      AAFieldKey v21 = *(AAFieldKey *)(a1 + 304);
      int Blob = AAArchiveStreamReadBlob(*(AAArchiveStream *)(a1 + 288), v21, a2, a3);
      if (!Blob) {
        return a3;
      }
      BOMCopierErrorCapture(a4, Blob, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4876, (uint64_t)"read_from_origin", "Could not read %lu bytes from data_archive: %u");
      return -1;
    default:
      return -1;
  }
}

uint64_t BOMCopierSourceEntrySeek(uint64_t a1, unint64_t a2, void *a3, unint64_t a4, void *a5)
{
  if (a1)
  {
    if ((a2 & 0x8000000000000000) == 0)
    {
      size_t v11 = (void *)(a1 + 168);
      uint64_t v10 = *(void **)(a1 + 168);
      if (v10)
      {
        uint64_t v12 = *(void *)(a1 + 176);
        uint64_t v13 = *(void *)(a1 + 184);
        if (v12 - v13 >= a2) {
          unint64_t v14 = a2;
        }
        else {
          unint64_t v14 = v12 - v13;
        }
        uint64_t v15 = v14 + v13;
        *(void *)(a1 + 184) = v15;
        if (v15 == v12)
        {
          *(void *)(a1 + 160) = 0;
          free(v10);
          *size_t v11 = 0;
          v11[1] = 0;
          v11[2] = 0;
        }
      }
      else
      {
        unint64_t v14 = 0;
      }
      off_t v17 = a2 - v14;
      if (!v17) {
        return 0;
      }
      uint64_t v18 = open_origin(a1, a5);
      if (v18)
      {
        uint64_t v16 = v18;
        BOMCopierErrorCapture(a5, v18, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2764, (uint64_t)"BOMCopierSourceEntrySeek", "Could not open the origin");
        return v16;
      }
      off_t v23 = *(void *)(a1 + 328);
      unint64_t v24 = v23 + v17;
      int v25 = *(_DWORD *)a1;
      if ((*(_DWORD *)a1 - 1) < 4)
      {
        off_t v23 = lseek(*(_DWORD *)(a1 + 324), v17, 1);
        if (v23 != -1)
        {
LABEL_29:
          *(void *)(a1 + 328) = v23;
          goto LABEL_39;
        }
        int v28 = *__error();
        int v29 = __error();
        strerror(*v29);
        BOMCopierErrorCapture(a5, v28, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4969, (uint64_t)"seek_from_origin", "Could not lseek: %s");
      }
      else if ((v25 - 5) >= 3)
      {
        if (v25 || !*(void *)(a1 + 240))
        {
LABEL_39:
          if (v24 != v23)
          {
            uint64_t v16 = 1;
            BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2776, (uint64_t)"BOMCopierSourceEntrySeek", "Could not seek forward in the origin");
            return v16;
          }
          goto LABEL_40;
        }
        if (v24 <= *(void *)(a1 + 248))
        {
LABEL_40:
          uint64_t v16 = 0;
          *(void *)(a1 + 328) = v24;
          return v16;
        }
        BOMCopierErrorCapture(a5, 34, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 4938, (uint64_t)"seek_from_origin", "Cannot seek beyond the end of entry data");
      }
      else
      {
        if (*(_DWORD *)(a1 + 4) != 8) {
          goto LABEL_39;
        }
        if (a3)
        {
          if (a4)
          {
            uint64_t v26 = 0;
            while (1)
            {
              size_t v27 = v17 - v26 >= a4 ? a4 : v17 - v26;
              if (read_from_origin(a1, a3, v27, a5, v19, v20, v21, v22) != v27) {
                break;
              }
              v26 += v27;
              if (v26 == v17)
              {
                off_t v23 = *(void *)(a1 + 328) + v17;
                goto LABEL_29;
              }
            }
            int v30 = *__error();
            BOMCopierErrorCapture(a5, v30, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5063, (uint64_t)"seek_from_origin", "Could not read %lld bytes from archive for seeking");
          }
          else
          {
            BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5041, (uint64_t)"seek_from_origin", "seek_buffer_size is 0");
          }
        }
        else
        {
          BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5035, (uint64_t)"seek_from_origin", "seek_buffer is NULL");
        }
      }
      off_t v23 = -1;
      goto LABEL_39;
    }
    uint64_t v16 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2719, (uint64_t)"BOMCopierSourceEntrySeek", "Invalid seek_amount");
  }
  else
  {
    uint64_t v16 = 22;
    BOMCopierErrorCapture(a5, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2713, (uint64_t)"BOMCopierSourceEntrySeek", "source_entry is NULL");
  }
  return v16;
}

uint64_t BOMCopierSourceEntrySkip(uint64_t a1, void *a2, size_t a3, void *a4)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2796, (uint64_t)"BOMCopierSourceEntrySkip", "Invalid source_entry");
    return 1;
  }
  if (a3) {
    size_t v7 = a3;
  }
  else {
    size_t v7 = 0x4000000;
  }
  int v8 = a2;
  if (!a2)
  {
    int v8 = malloc_type_malloc(v7, 0x37F4229AuLL);
    if (!v8)
    {
      int v11 = *__error();
      uint64_t v12 = __error();
      strerror(*v12);
      BOMCopierErrorCapture(a4, v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2818, (uint64_t)"BOMCopierSourceEntrySkip", "Could not allocate %ld bytes for skip buffer: %s\n");
      return 1;
    }
  }
  if (*(_DWORD *)a1 != 7)
  {
    if (*(_DWORD *)a1 == 5 && skip_remaining_file_data(a1, v8, v7))
    {
      uint64_t v9 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2834, (uint64_t)"BOMCopierSourceEntrySkip", "Could not skip remaining libarchive file data");
LABEL_11:
      if (v8 != a2) {
        free(v8);
      }
      return v9;
    }
    goto LABEL_29;
  }
  int v10 = skip_remaining_file_data(a1, v8, v7);
  if (v10)
  {
    BOMCopierErrorCapture(a4, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2855, (uint64_t)"BOMCopierSourceEntrySkip", "Could not skip remaining AppleArchive file data");
    if (v8 != a2) {
      free(v8);
    }
    return 1;
  }
  if (*(_DWORD *)(a1 + 308))
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    while (1)
    {
      uint64_t v15 = *(void *)(a1 + 312) + v13;
      *(_DWORD *)(a1 + 304) = *(_DWORD *)v15;
      size_t v16 = *(void *)(v15 + 16);
      if (BOMCopierSourceEntryRead(a1, (char *)v8, v16, a4) != v16)
      {
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5866, (uint64_t)"parse_apple_archive_blobs", "Could not read AppleArchive blob data");
        goto LABEL_36;
      }
      if (*(unsigned char *)(*(void *)(a1 + 312) + v13 + 24))
      {
        int v17 = *(_DWORD *)(a1 + 304);
        if (v17 == 4997953)
        {
          if (parse_apple_archive_acl_blob(a1, (uint8_t *)v8, v16, a4))
          {
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5881, (uint64_t)"parse_apple_archive_blobs", "Could not parse AppleArchive ACL blob: %d");
            goto LABEL_36;
          }
          int v17 = *(_DWORD *)(a1 + 304);
        }
        if (v17 == 5521752 && parse_apple_archive_xat_blob(a1, (uint8_t *)v8, v16, a4)) {
          break;
        }
      }
      ++v14;
      v13 += 32;
      if (v14 >= *(unsigned int *)(a1 + 308)) {
        goto LABEL_29;
      }
    }
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5891, (uint64_t)"parse_apple_archive_blobs", "Could not read parse AppleArchive XAT blob: %d");
LABEL_36:
    uint64_t v9 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2873, (uint64_t)"BOMCopierSourceEntrySkip", "Could not parse AppleArchive payload blobs");
    goto LABEL_11;
  }
LABEL_29:
  if (v8 != a2) {
    free(v8);
  }
  return 0;
}

uint64_t skip_remaining_file_data(uint64_t a1, void *a2, unint64_t a3)
{
  if (*(_DWORD *)(a1 + 4) != 8) {
    return 0;
  }
  uint64_t Size = BOMCopierSourceEntryGetSize(a1);
  if (!Size || !BOMCopierSourceEntrySeek(a1, Size - *(void *)(a1 + 328), a2, a3, 0)) {
    return 0;
  }
  uint64_t v7 = 1;
  fwrite("Could not seek to the end of the source entry\n", 0x2EuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return v7;
}

uint64_t BOMCopierSourceEntryClone(uint64_t a1, char *__s1, unsigned char *a3, void *a4)
{
  if (a1)
  {
    if (__s1)
    {
      if (a3)
      {
        *a3 = 0;
        if ((*(_DWORD *)a1 | 2) == 3)
        {
          if (*(_DWORD *)(a1 + 4) == 8)
          {
            int v8 = strdup(__s1);
            if (v8)
            {
              uint64_t v9 = v8;
              if (!dirname_r(__s1, v8))
              {
                unint64_t v14 = __error();
                strerror(*v14);
                uint64_t v11 = 1;
                BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2971, (uint64_t)"BOMCopierSourceEntryClone", "Could not dirname %s: %s");
                goto LABEL_18;
              }
              memset(&v19, 0, sizeof(v19));
              if (stat(v9, &v19))
              {
                int v10 = __error();
                strerror(*v10);
                uint64_t v11 = 1;
                BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2981, (uint64_t)"BOMCopierSourceEntryClone", "Could not stat %s: %s");
LABEL_18:
                free(v9);
                return v11;
              }
              free(v9);
              if (*(_DWORD *)(a1 + 64) == v19.st_dev)
              {
                if (!copyfile(*(const char **)(a1 + 16), __s1, 0, 0x200000Fu))
                {
                  uint64_t v11 = 0;
                  *a3 = 1;
                  return v11;
                }
                if (*__error() != 45)
                {
                  int v15 = *__error();
                  size_t v16 = *(const char **)(a1 + 16);
                  int v17 = __error();
                  uint64_t v18 = strerror(*v17);
                  BOMCopierErrorCapture(a4, v15, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2998, (uint64_t)"BOMCopierSourceEntryClone", "Could not clone %s to %s: %s", v16, __s1, v18);
                  return 1;
                }
              }
              return 0;
            }
            else
            {
              uint64_t v12 = __error();
              strerror(*v12);
              uint64_t v11 = 1;
              BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2964, (uint64_t)"BOMCopierSourceEntryClone", "Could not duplicate %s: %s");
            }
          }
          else
          {
            uint64_t v11 = 1;
            BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2957, (uint64_t)"BOMCopierSourceEntryClone", "Entry is not a regular file");
          }
        }
        else
        {
          uint64_t v11 = 1;
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2951, (uint64_t)"BOMCopierSourceEntryClone", "Origin %u does not support filesystem cloning");
        }
      }
      else
      {
        uint64_t v11 = 22;
        BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2923, (uint64_t)"BOMCopierSourceEntryClone", "Invalid cloned");
      }
    }
    else
    {
      uint64_t v11 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2917, (uint64_t)"BOMCopierSourceEntryClone", "Invalid path");
    }
  }
  else
  {
    uint64_t v11 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 2911, (uint64_t)"BOMCopierSourceEntryClone", "Invalid source_entry");
  }
  return v11;
}

uint64_t BOMCopierSourceEntrySetRoot(uint64_t a1, char a2)
{
  if (a1)
  {
    uint64_t v2 = 0;
    *(unsigned char *)(a1 + 157) = a2;
  }
  else
  {
    uint64_t v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v2;
}

BOOL BOMCopierSourceEntryIsRoot(uint64_t a1)
{
  if (a1) {
    return *(unsigned char *)(a1 + 157) != 0;
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

BOOL BOMCopierSourceEntryIsResourceFork(_DWORD *a1)
{
  if (a1) {
    return *a1 == 2;
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

BOOL BOMCopierSourceEntrySetPath(void *a1, char *__s)
{
  if (a1)
  {
    if (!__s)
    {
      int v5 = (FILE *)*MEMORY[0x263EF8348];
      int v6 = "Invalid entry_path";
      uint64_t v7 = 1;
      size_t v8 = 18;
      goto LABEL_7;
    }
    size_t v4 = strlen(__s);
    if (v4 >= 0x400)
    {
      int v5 = (FILE *)*MEMORY[0x263EF8348];
      int v6 = "entry_path is too long";
      uint64_t v7 = 1;
      size_t v8 = 22;
LABEL_7:
      fwrite(v6, v8, 1uLL, v5);
      return v7;
    }
    size_t v9 = v4;
    int v10 = (void *)a1[3];
    if (v10)
    {
      free(v10);
      a1[3] = 0;
    }
    uint64_t v11 = (void *)a1[4];
    if (v11)
    {
      free(v11);
      a1[4] = 0;
    }
    uint64_t v12 = (void *)a1[5];
    if (v12)
    {
      free(v12);
      a1[5] = 0;
    }
    uint64_t v13 = copy_string(__s, v9);
    a1[3] = v13;
    return v13 == 0;
  }
  else
  {
    uint64_t v7 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v7;
}

BOOL BOMCopierSourceEntrySetParent(uint64_t a1, char *__s)
{
  if (a1)
  {
    if (!__s)
    {
      int v5 = (FILE *)*MEMORY[0x263EF8348];
      int v6 = "Invalid entry_parent";
      uint64_t v7 = 1;
      size_t v8 = 20;
      goto LABEL_7;
    }
    size_t v4 = strlen(__s);
    if (v4 >= 0x400)
    {
      int v5 = (FILE *)*MEMORY[0x263EF8348];
      int v6 = "entry_path is too long";
      uint64_t v7 = 1;
      size_t v8 = 22;
LABEL_7:
      fwrite(v6, v8, 1uLL, v5);
      return v7;
    }
    if (!*(void *)(a1 + 32)) {
      *(void *)(a1 + 32) = 0;
    }
    size_t v9 = copy_string(__s, v4);
    *(void *)(a1 + 32) = v9;
    return v9 == 0;
  }
  else
  {
    uint64_t v7 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v7;
}

BOOL BOMCopierSourceEntrySetName(uint64_t a1, char *__s)
{
  if (a1)
  {
    if (!__s)
    {
      int v5 = (FILE *)*MEMORY[0x263EF8348];
      int v6 = "Invalid entry_name";
      uint64_t v7 = 1;
      size_t v8 = 18;
      goto LABEL_7;
    }
    size_t v4 = strlen(__s);
    if (v4 >= 0xFF)
    {
      int v5 = (FILE *)*MEMORY[0x263EF8348];
      int v6 = "entry_name is too long";
      uint64_t v7 = 1;
      size_t v8 = 22;
LABEL_7:
      fwrite(v6, v8, 1uLL, v5);
      return v7;
    }
    if (!*(void *)(a1 + 40)) {
      *(void *)(a1 + 40) = 0;
    }
    size_t v9 = copy_string(__s, v4);
    *(void *)(a1 + 40) = v9;
    return v9 == 0;
  }
  else
  {
    uint64_t v7 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v7;
}

uint64_t BOMCopierSourceEntrySetData(uint64_t a1, const void *a2, size_t size)
{
  if (!a1)
  {
    uint64_t v9 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    return v9;
  }
  if (!a2)
  {
    int v10 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v11 = "Invalid data";
    uint64_t v9 = 1;
    size_t v12 = 12;
LABEL_11:
    fwrite(v11, v12, 1uLL, v10);
    return v9;
  }
  if (!size)
  {
    int v10 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v11 = "Invalid data size";
    uint64_t v9 = 1;
    size_t v12 = 17;
    goto LABEL_11;
  }
  int v6 = *(void **)(a1 + 240);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 248) = 0;
  }
  uint64_t v7 = malloc_type_malloc(size, 0xF9D3B54FuLL);
  if (!v7) {
    return 1;
  }
  size_t v8 = v7;
  memcpy(v7, a2, size);
  uint64_t v9 = 0;
  *(void *)(a1 + 240) = v8;
  *(void *)(a1 + 248) = size;
  return v9;
}

uint64_t BOMCopierSourceEntrySetMode(uint64_t a1, __int16 a2)
{
  if (a1)
  {
    uint64_t v2 = 0;
    *(_WORD *)(a1 + 92) = a2;
  }
  else
  {
    uint64_t v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetSize(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = 0;
    *(void *)(a1 + 96) = a2;
  }
  else
  {
    uint64_t v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetUserID(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v2 = 0;
    *(_DWORD *)(a1 + 84) = a2;
  }
  else
  {
    uint64_t v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetGroupID(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v2 = 0;
    *(_DWORD *)(a1 + 88) = a2;
  }
  else
  {
    uint64_t v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetAccessTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = 0;
    *(void *)(a1 + 104) = a2;
    *(void *)(a1 + 112) = a3;
  }
  else
  {
    uint64_t v3 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v3;
}

uint64_t BOMCopierSourceEntrySetModificationTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = 0;
    *(void *)(a1 + 120) = a2;
    *(void *)(a1 + 128) = a3;
  }
  else
  {
    uint64_t v3 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v3;
}

uint64_t BOMCopierSourceEntrySetStatusTime(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v3 = 0;
    *(void *)(a1 + 136) = a2;
    *(void *)(a1 + 144) = a3;
  }
  else
  {
    uint64_t v3 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v3;
}

BOOL BOMCopierSourceEntrySetSymlinkTarget(uint64_t a1, char *__s1)
{
  if (a1)
  {
    int v3 = *(_DWORD *)(a1 + 4);
    if (v3 == 18 || v3 == 9)
    {
      int v6 = *(void **)(a1 + 48);
      if (v6) {
        free(v6);
      }
      uint64_t v7 = strdup(__s1);
      *(void *)(a1 + 48) = v7;
      return v7 == 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    uint64_t v8 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v8;
}

BOOL BOMCopierSourceEntrySetAppleDoubleTarget(uint64_t a1, char *__s1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 4) == 17)
    {
      size_t v4 = *(void **)(a1 + 56);
      if (v4) {
        free(v4);
      }
      int v5 = strdup(__s1);
      *(void *)(a1 + 56) = v5;
      return v5 == 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    uint64_t v6 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v6;
}

uint64_t BOMCopierSourceEntrySetQuarantine()
{
  return 0;
}

uint64_t BOMCopierSourceEntrySetSegmentedFile(uint64_t a1, char a2)
{
  if (a1)
  {
    uint64_t v2 = 0;
    *(unsigned char *)(a1 + 158) = a2;
  }
  else
  {
    uint64_t v2 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  return v2;
}

uint64_t BOMCopierSourceEntrySetHonorsSetuid(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 8) = a2;
  return 0;
}

BOOL BOMCopierSourceEntryIsSegmentedFile(uint64_t a1)
{
  if (a1) {
    return *(unsigned char *)(a1 + 158) != 0;
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

BOOL BOMCopierSourceEntryIsStreamed(uint64_t a1)
{
  if (a1) {
    return *(unsigned char *)(a1 + 156) != 0;
  }
  fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return 0;
}

uint64_t BOMCopierSourceEntrySetOption(uint64_t a1, CFTypeRef cf1, const void *a3)
{
  if (!a1)
  {
    uint64_t v6 = 1;
    fwrite("Invalid source_entry", 0x14uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    return v6;
  }
  if (!cf1)
  {
    uint64_t v7 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v8 = "Invalid key";
    uint64_t v6 = 1;
    size_t v9 = 11;
LABEL_9:
    fwrite(v8, v9, 1uLL, v7);
    return v6;
  }
  if (!a3)
  {
    uint64_t v7 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v8 = "Invalid value";
    uint64_t v6 = 1;
    size_t v9 = 13;
    goto LABEL_9;
  }
  if (CFEqual(cf1, @"DeleteOnFree") != 1) {
    return 1;
  }
  int v5 = CFEqual(a3, (CFTypeRef)*MEMORY[0x263EFFB40]);
  uint64_t v6 = 0;
  *(unsigned char *)(a1 + 320) = v5 != 0;
  return v6;
}

uint64_t BOMCopierSourceEntryCompare(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    size_t v9 = (FILE *)*MEMORY[0x263EF8348];
    int v10 = "Invalid source_entry";
    size_t v11 = 20;
LABEL_9:
    fwrite(v10, v11, 1uLL, v9);
    return 0;
  }
  if (!a2)
  {
    size_t v9 = (FILE *)*MEMORY[0x263EF8348];
    int v10 = "Invalid other_entry";
    size_t v11 = 19;
    goto LABEL_9;
  }
  if (!a4)
  {
    size_t v9 = (FILE *)*MEMORY[0x263EF8348];
    int v10 = "Invalid compare_handler";
    size_t v11 = 23;
    goto LABEL_9;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, void, const char *))(a4 + 16))(a4, a1, a2, 0, "");
  if (*(_DWORD *)a1 == *(_DWORD *)a2)
  {
    uint64_t v8 = 1;
  }
  else
  {
    snprintf(__str, 0x400uLL, "entry_origin: %d vs %d", *(_DWORD *)a1, *(_DWORD *)a2);
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_origin", __str);
  }
  unsigned int v13 = *(_DWORD *)(a1 + 4);
  unsigned int v14 = *(_DWORD *)(a2 + 4);
  if (v13 != v14)
  {
    int v15 = BOMCopierSourceEntryTypeString(v13);
    size_t v16 = BOMCopierSourceEntryTypeString(v14);
    snprintf(__str, 0x400uLL, "entry_type: %s vs %s", v15, v16);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_type", __str) & v8;
  }
  if ((compare_strings((int)"entry_resolved_path", *(char **)(a1 + 16), *(char **)(a2 + 16), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_resolved_path", __str) & v8;
  }
  if ((compare_strings((int)"entry_path", *(char **)(a1 + 24), *(char **)(a2 + 24), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_path", __str) & v8;
  }
  BOMCopierSourceEntryGetParent((void *)a1);
  BOMCopierSourceEntryGetParent((void *)a2);
  if ((compare_strings((int)"entry_parent", *(char **)(a1 + 32), *(char **)(a2 + 32), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_parent", __str) & v8;
  }
  BOMCopierSourceEntryGetName((void *)a1);
  BOMCopierSourceEntryGetName((void *)a2);
  if ((compare_strings((int)"entry_name", *(char **)(a1 + 40), *(char **)(a2 + 40), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_name", __str) & v8;
  }
  if ((compare_strings((int)"entry_symlink_target", *(char **)(a1 + 48), *(char **)(a2 + 48), __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_symlink_target", __str) & v8;
  }
  int v17 = *(_DWORD *)(a2 + 84);
  if (*(_DWORD *)(a1 + 84) != v17)
  {
    snprintf(__str, 0x400uLL, "entry_uid: %d vs %d", *(_DWORD *)(a1 + 84), v17);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_uid", __str) & v8;
  }
  int v18 = *(_DWORD *)(a2 + 88);
  if (*(_DWORD *)(a1 + 88) != v18)
  {
    snprintf(__str, 0x400uLL, "entry_gid: %d vs %d", *(_DWORD *)(a1 + 88), v18);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_gid", __str) & v8;
  }
  int v19 = *(unsigned __int16 *)(a1 + 92);
  if (v19 != *(unsigned __int16 *)(a2 + 92))
  {
    strmode(v19, __bp);
    strmode(*(unsigned __int16 *)(a2 + 92), v23);
    snprintf(__str, 0x400uLL, "entry_mode: %s vs %s", __bp, v23);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_mode", __str) & v8;
  }
  uint64_t v20 = *(void *)(a2 + 96);
  if (*(void *)(a1 + 96) != v20)
  {
    snprintf(__str, 0x400uLL, "entry_size: %lld vs %lld", *(void *)(a1 + 96), v20);
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_size", __str) & v8;
  }
  if ((compare_times("entry_access_time", (void *)(a1 + 104), (void *)(a2 + 104), a3, __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_access_time", __str) & v8;
  }
  if ((compare_times("entry_modification_time", (void *)(a1 + 120), (void *)(a2 + 120), a3, __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_modification_time", __str) & v8;
  }
  if ((compare_times("entry_status_time", (void *)(a1 + 136), (void *)(a2 + 136), a3, __str) & 1) == 0) {
    uint64_t v8 = (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "entry_status_time", __str) & v8;
  }
  if (*(unsigned __int8 *)(a1 + 157) != *(unsigned __int8 *)(a2 + 157))
  {
    if (*(unsigned char *)(a1 + 157)) {
      uint64_t v21 = "yes";
    }
    else {
      uint64_t v21 = "no";
    }
    if (*(unsigned char *)(a2 + 157)) {
      uint64_t v22 = "yes";
    }
    else {
      uint64_t v22 = "no";
    }
    snprintf(__str, 0x400uLL, "is_root: %s vs %s", v21, v22);
    return (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, const char *, char *))(a4 + 16))(a4, a1, a2, "is_root", __str) & v8;
  }
  return v8;
}

uint64_t compare_strings(int a1, char *__s1, char *__s2, char *__str)
{
  if (__s1 && !__s2 || !__s1 && __s2)
  {
    snprintf(__str, 0x400uLL, "%s is missing %s");
    return 0;
  }
  uint64_t result = 1;
  if (__s1 && __s2)
  {
    if (!strcmp(__s1, __s2)) {
      return 1;
    }
    snprintf(__str, 0x400uLL, "%s: %s vs %s");
    return 0;
  }
  return result;
}

uint64_t compare_times(const char *a1, void *a2, void *a3, unint64_t a4, char *__str)
{
  if (*a2 != *a3) {
    snprintf(__str, 0x400uLL, "%s.tv_sec: %ld vs %ld", a1, *a2, *a3);
  }
  uint64_t v10 = a2[1];
  uint64_t v11 = a3[1];
  uint64_t v12 = v10 - v11;
  if (v10 == v11) {
    return 1;
  }
  if (v12 < 0) {
    uint64_t v12 = v11 - v10;
  }
  if (v12 < a4) {
    return 1;
  }
  snprintf(__str, 0x400uLL, "%s.tv_nsec: %ld vs %ld (%ld margin)", a1, v10, a3[1], a4);
  return 0;
}

uint64_t BOMCopierSourceEntryGetHonorsSetuid(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 8);
}

uint64_t parse_apple_archive_acl_blob(uint64_t a1, uint8_t *data, size_t data_size, void *a4)
{
  AAEntryACLBlob v6 = AAEntryACLBlobCreateWithEncodedData(data, data_size);
  if (v6)
  {
    uint64_t v7 = v6;
    dir = 0;
    pid_t v8 = getpid();
    asprintf(&dir, "/tmp/.BCSE.%u.T_XXXXXX", v8);
    if (dir)
    {
      int v9 = mkstemp(dir);
      if (v9 == -1)
      {
        unsigned int v14 = dir;
        int v15 = __error();
        size_t v16 = strerror(*v15);
        uint64_t v26 = v14;
        uint64_t v11 = 1;
        BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5932, (uint64_t)"parse_apple_archive_acl_blob", "Could not mkstemp %s: %s\n", v26, v16);
        free(dir);
      }
      else
      {
        close(v9);
        int v10 = AAEntryACLBlobApplyToPath(v7, dir, "", 0);
        if (v10)
        {
          BOMCopierErrorCapture(a4, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5942, (uint64_t)"parse_apple_archive_acl_blob", "Could not apply AppleArchive ACL blob to %s: %d\n");
        }
        else
        {
          acl_t file = acl_get_file(dir, ACL_TYPE_EXTENDED);
          if (file)
          {
            int v18 = file;
            ssize_t len_p = 0;
            int v19 = acl_to_text(file, &len_p);
            acl_free(v18);
            if (v19)
            {
              ssize_t v21 = len_p;
              uint64_t v20 = dir;
              *(void *)(a1 + 224) = v19;
              *(void *)(a1 + 232) = v21;
              unlink(v20);
              free(dir);
              AAEntryACLBlobClear(v7);
              AAEntryACLBlobDestroy(v7);
              return 0;
            }
            int v24 = *__error();
            int v25 = __error();
            strerror(*v25);
            BOMCopierErrorCapture(a4, v24, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5962, (uint64_t)"parse_apple_archive_acl_blob", "Could not convert ACL to text for %s: %s");
          }
          else
          {
            int v22 = *__error();
            off_t v23 = __error();
            strerror(*v23);
            BOMCopierErrorCapture(a4, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5950, (uint64_t)"parse_apple_archive_acl_blob", "Could not get ACL for %s: %s\n");
          }
        }
        free(dir);
        return 1;
      }
    }
    else
    {
      uint64_t v12 = __error();
      strerror(*v12);
      uint64_t v11 = 1;
      BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5925, (uint64_t)"parse_apple_archive_acl_blob", "Could not create ACL file path: %s\n");
    }
  }
  else
  {
    uint64_t v11 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5917, (uint64_t)"parse_apple_archive_acl_blob", "Could not decode AppleArchive ACL data blob");
  }
  return v11;
}

uint64_t parse_apple_archive_xat_blob(uint64_t a1, uint8_t *data, size_t data_size, void *a4)
{
  AAEntryACLBlob v6 = AAEntryXATBlobCreateWithEncodedData(data, data_size);
  if (v6)
  {
    uint64_t v7 = v6;
    Entryint64_t Count = AAEntryXATBlobGetEntryCount(v6);
    if (EntryCount)
    {
      uint32_t v9 = EntryCount;
      uint32_t v10 = 0;
      while (1)
      {
        size_t data_sizea = 0;
        key_size_t length = 0;
        if (AAEntryXATBlobGetEntry(v7, v10, 0, 0, &key_length, 0, 0, &data_sizea))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6021, (uint64_t)"parse_apple_archive_xat_blob", "Could not retrieve AppleArchive XAT entry sizes: %d");
          return 1;
        }
        size_t v11 = key_length + 1;
        uint64_t v12 = (char *)malloc_type_malloc(key_length + 1, 0xE48D7884uLL);
        if (!v12)
        {
          int v20 = *__error();
          ssize_t v21 = __error();
          strerror(*v21);
          BOMCopierErrorCapture(a4, v20, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6029, (uint64_t)"parse_apple_archive_xat_blob", "Could not allocate xattr name: %s");
          return 1;
        }
        unsigned int v13 = v12;
        unsigned int v14 = (uint8_t *)malloc_type_malloc(data_sizea, 0xA70B6835uLL);
        if (!v14)
        {
          int v22 = *__error();
          off_t v23 = __error();
          int v24 = strerror(*v23);
          BOMCopierErrorCapture(a4, v22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6036, (uint64_t)"parse_apple_archive_xat_blob", "Could not allocate xattr value: %s", v24);
          goto LABEL_19;
        }
        int v15 = v14;
        if (AAEntryXATBlobGetEntry(v7, v10, v11, v13, &key_length, data_sizea, v14, &data_sizea))
        {
          BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6044, (uint64_t)"parse_apple_archive_xat_blob", "Could not retrieve AppleArchive XAT entry: %d");
          goto LABEL_18;
        }
        int v16 = *(_DWORD *)(a1 + 208);
        int v17 = (char *)malloc_type_realloc(*(void **)(a1 + 216), 24 * (v16 + 1), 0x1471290EuLL);
        if (!v17) {
          break;
        }
        int v18 = (char **)&v17[24 * v16];
        *int v18 = v13;
        v18[1] = (char *)data_sizea;
        v18[2] = (char *)v15;
        *(_DWORD *)(a1 + 208) = v16 + 1;
        *(void *)(a1 + 216) = v17;
        if (v9 == ++v10) {
          goto LABEL_10;
        }
      }
      int v25 = *__error();
      uint64_t v26 = __error();
      strerror(*v26);
      BOMCopierErrorCapture(a4, v25, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 6062, (uint64_t)"parse_apple_archive_xat_blob", "Could not allocate new_extended_attribute_list: %s");
LABEL_18:
      free(v15);
LABEL_19:
      free(v13);
      return 1;
    }
    else
    {
LABEL_10:
      AAEntryXATBlobClear(v7);
      AAEntryXATBlobDestroy(v7);
      return 0;
    }
  }
  else
  {
    uint64_t v19 = 1;
    BOMCopierErrorCapture(a4, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierSourceEntry.c", 5998, (uint64_t)"parse_apple_archive_xat_blob", "Could not decode AppleArchive XAT data blob");
  }
  return v19;
}

uint64_t xattr_compare(const char **a1, const char **a2)
{
  return string_compare(*a1, *a2);
}

uint64_t BOMFSOTypeInfoArchiveLength(uint64_t a1)
{
  int v1 = *(_DWORD *)a1 - 1;
  uint64_t result = 1;
  switch(v1)
  {
    case 0:
      if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0) {
        uint64_t result = 5;
      }
      else {
        uint64_t result = 1;
      }
      break;
    case 1:
      return result;
    case 2:
      BOOL v4 = (unsigned __int16)(B_CKSUMS & *(_WORD *)(a1 + 40)) == 0;
      uint64_t v5 = *(void *)(a1 + 64);
      if (v4) {
        uint64_t v6 = v5 + 1;
      }
      else {
        uint64_t v6 = v5 + 5;
      }
      uint64_t result = v6 + 5;
      break;
    case 3:
      uint64_t result = 5;
      break;
    default:
      uint64_t result = -1;
      break;
  }
  return result;
}

uint64_t BOMFSOTypeInfoArchive(uint64_t a1, uint64_t a2)
{
  switch(*(_DWORD *)a2)
  {
    case 1:
      BOMStreamWriteUInt8(a1, 1);
      if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0) {
        goto LABEL_10;
      }
      goto LABEL_11;
    case 2:
      BOMStreamWriteUInt8(a1, 1);
      goto LABEL_11;
    case 3:
      BOMStreamWriteUInt8(a1, 1);
      if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0) {
        BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 88));
      }
      signed int v5 = *(_DWORD *)(a2 + 64) + 1;
      BOMStreamWriteUInt32(a1, v5);
      BOMStreamWriteBuffer(a1, *(const void **)(a2 + 96), v5);
      goto LABEL_11;
    case 4:
      BOMStreamWriteUInt8(a1, 1);
LABEL_10:
      BOMStreamWriteUInt32(a1, *(_DWORD *)(a2 + 88));
LABEL_11:
      uint64_t result = 0;
      break;
    default:
      uint64_t result = 1;
      break;
  }
  return result;
}

uint64_t BOMFSOTypeInfoUnarchive(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 1;
  if (a1 && a2)
  {
    switch(*(_DWORD *)a2)
    {
      case 1:
        if (BOMStreamReadUInt8(a1) != 1)
        {
          fprintf((FILE *)*MEMORY[0x263EF8348], "File object has an invalid version: 0x%X\nCannot dearchive.\n");
          return 1;
        }
        if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0) {
          goto LABEL_16;
        }
        goto LABEL_24;
      case 2:
        if (BOMStreamReadUInt8(a1) == 1) {
          goto LABEL_24;
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "Directory object has an invalid version: 0x%X\nCannot dearchive.\n");
        return 1;
      case 3:
        if (BOMStreamReadUInt8(a1) != 1)
        {
          fprintf((FILE *)*MEMORY[0x263EF8348], "Symlink object has an invalid version: 0x%X\nCannot dearchive.\n");
          return 1;
        }
        if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0) {
          *(_DWORD *)(a2 + 88) = BOMStreamReadUInt32(a1);
        }
        int UInt32 = BOMStreamReadUInt32(a1);
        if (UInt32)
        {
          size_t v6 = UInt32;
          uint64_t v7 = (char *)BOM_malloc(UInt32);
          if (!v7) {
            return 1;
          }
          pid_t v8 = v7;
          BOMStreamReadBuffer(a1, v7, v6);
        }
        else
        {
          uint64_t v2 = 1;
          uint32_t v9 = (char *)BOM_malloc(1uLL);
          if (!v9) {
            return v2;
          }
          pid_t v8 = v9;
          *uint32_t v9 = 0;
        }
        BOMFSObjectSetSymlinkTarget((_DWORD *)a2, v8, 0);
LABEL_24:
        uint64_t v2 = 0;
        break;
      case 4:
        if (BOMStreamReadUInt8(a1) == 1)
        {
LABEL_16:
          uint64_t v2 = 0;
          *(_DWORD *)(a2 + 88) = BOMStreamReadUInt32(a1);
        }
        else
        {
          fprintf((FILE *)*MEMORY[0x263EF8348], "Device object has an invalid version: 0x%X\nCannot dearchive.\n");
          return 1;
        }
        return v2;
      default:
        return 1;
    }
  }
  return v2;
}

uint64_t BOMFSOTypeInfoInitialize(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  int v4 = BOMFSObjectType((unsigned int *)a1);
  if (v4 == 4)
  {
    *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 24);
  }
  else if (v4 == 3)
  {
    uint64_t v7 = (*(uint64_t (**)(void, void, char *, uint64_t))(*(void *)(a1 + 160) + 256))(*(void *)(*(void *)(a1 + 160) + 8), *(void *)(a1 + 72), __s, 1024);
    if (v7 < 0 || v7 == 1024)
    {
      pid_t v8 = BOMExceptionHandlerMessage("can't access symlink for %s", *(const char **)(a1 + 72));
      uint32_t v9 = __error();
      _BOMExceptionHandlerCall((uint64_t)v8, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c", 95, *v9);
      uint64_t v7 = 0;
    }
    __s[v7] = 0;
    size_t v10 = strlen(__s) + 1;
    size_t v11 = BOM_malloc(v10);
    memmove(v11, __s, v10);
    BOMFSOTypeInfoSetSymlinkTarget((_DWORD *)a1, (char *)v11, 0);
  }
  else if (v4 == 1 && ((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0 && _getFileChecksum(a1))
  {
    signed int v5 = BOMExceptionHandlerMessage("can't compute checksum for %s", *(const char **)(a1 + 72));
    size_t v6 = __error();
    _BOMExceptionHandlerCall((uint64_t)v5, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c", 88, *v6);
  }
  return 0;
}

uint64_t _getFileChecksum(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 64);
  if (!v2)
  {
    int v3 = &v6;
    return BOMCRC32ForBuffer((uint64_t)v3, (_DWORD *)(a1 + 88), v2);
  }
  int v3 = *(char **)(a1 + 24);
  if (v3) {
    return BOMCRC32ForBuffer((uint64_t)v3, (_DWORD *)(a1 + 88), v2);
  }
  if ((*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 160) + 64))(*(void *)(*(void *)(a1 + 160) + 8), *(unsigned int *)(a1 + 16), 0, 0) < 0)return 0; {
  int v4 = *(_DWORD *)(a1 + 16);
  }
  return BOMCRC32ForFileDesc(v4, (_DWORD *)(a1 + 88), v2);
}

_DWORD *BOMFSOTypeInfoSetSymlinkTarget(_DWORD *result, char *__s, int a3)
{
  if (__s)
  {
    int v3 = result;
    if (*result == 3)
    {
      signed int v5 = __s;
      uint64_t result = (_DWORD *)strlen(__s);
      size_t v6 = (size_t)result;
      if (a3)
      {
        uint64_t v7 = BOM_malloc((size_t)result + 1);
        uint64_t result = memmove(v7, v5, v6);
        *((unsigned char *)v7 + v6) = 0;
        signed int v5 = (char *)v7;
      }
      v3[22] = 0;
      *((void *)v3 + 12) = v5;
      if (((unsigned __int16)B_CKSUMS & (_WORD)v3[10]) != 0)
      {
        size_t v8 = strlen(v5);
        uint64_t result = (_DWORD *)BOMCRC32ForBuffer((uint64_t)v5, v3 + 22, v8);
      }
      *((void *)v3 + 8) = v6;
    }
  }
  return result;
}

uint64_t BOMFSOTypeInfoInitializeDeferred(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  int v8 = BOMFSObjectType((unsigned int *)a1);
  switch(v8)
  {
    case 4:
      if (((unsigned __int16)B_STAT & a4) != 0) {
        *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 + 24);
      }
      break;
    case 3:
      if (((unsigned __int16)B_STAT & a4) != 0)
      {
        uint64_t v12 = (*(uint64_t (**)(void, uint64_t, char *, uint64_t))(*(void *)(a1 + 160) + 256))(*(void *)(*(void *)(a1 + 160) + 8), a3, __s, 1024);
        if (v12 < 0 || v12 == 1024)
        {
          unsigned int v13 = BOMExceptionHandlerMessage("can't access symlink for %s", *(const char **)(a1 + 72));
          uint64_t v14 = __error();
          _BOMExceptionHandlerCall((uint64_t)v13, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c", 136, *v14);
          uint64_t v12 = 0;
        }
        __s[v12] = 0;
        size_t v15 = strlen(__s) + 1;
        int v16 = BOM_malloc(v15);
        memmove(v16, __s, v15);
        int v17 = *(void **)(a1 + 96);
        if (v17) {
          free(v17);
        }
        *(void *)(a1 + 96) = v16;
      }
      if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0 && (unsigned __int16)(B_CKSUMS & a4) != 0)
      {
        uint64_t v19 = (_DWORD *)(a1 + 88);
        int v20 = *(const char **)(a1 + 96);
        size_t v21 = strlen(v20);
        BOMCRC32ForBuffer((uint64_t)v20, v19, v21);
      }
      break;
    case 1:
      BOOL v9 = ((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) == 0 || (unsigned __int16)(B_CKSUMS & a4) == 0;
      if (!v9 && _getFileChecksum(a1))
      {
        size_t v10 = BOMExceptionHandlerMessage("can't compute checksum for %s", *(const char **)(a1 + 72));
        size_t v11 = __error();
        _BOMExceptionHandlerCall((uint64_t)v10, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/FSObject/BOMFSOTypeInfo.c", 127, *v11);
      }
      break;
  }
  return 0;
}

void BOMFSOTypeInfoRelease(uint64_t a1)
{
  if (*(_DWORD *)a1 == 3)
  {
    int v1 = *(void **)(a1 + 96);
    if (v1) {
      free(v1);
    }
  }
}

uint64_t BOMFSOTypeInfoCopy(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != 3) {
    return 0;
  }
  size_t v4 = strlen(*(const char **)(a1 + 96)) + 1;
  signed int v5 = (char *)BOM_malloc(v4);
  *(void *)(a2 + 96) = v5;
  if (v5)
  {
    strlcpy(v5, *(const char **)(a1 + 96), v4);
    return 0;
  }
  return 1;
}

uint64_t BOMFSOTypeInfoChecksum(_DWORD *a1)
{
  if ((*a1 | 2) == 3) {
    return a1[22];
  }
  else {
    return 0;
  }
}

uint64_t BOMFSOTypeInfoSymlinkTarget(uint64_t a1)
{
  if (*(_DWORD *)a1 == 3) {
    return *(void *)(a1 + 96);
  }
  else {
    return 0;
  }
}

CFStringRef BOMFSOTypeInfoSymlinkTargetString(uint64_t a1)
{
  if (*(_DWORD *)a1 == 3) {
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], *(const char **)(a1 + 96), 0x8000100u);
  }
  else {
    return 0;
  }
}

uint64_t BOMFSOTypeInfoDeviceID(_DWORD *a1)
{
  if (*a1 == 4) {
    return a1[22];
  }
  else {
    return 0;
  }
}

_DWORD *BOMFSOTypeInfoSetChecksum(_DWORD *result, int a2)
{
  if ((*result | 2) == 3) {
    result[22] = a2;
  }
  return result;
}

_DWORD *BOMFSOTypeInfoSetDeviceID(_DWORD *result, int a2)
{
  if (*result == 4) {
    result[22] = a2;
  }
  return result;
}

const char *BOMFSOTypeInfoSummary(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  int v8 = (char *)printBuffer;
  if (!printBuffer)
  {
    int v8 = (char *)BOM_malloc(0x1000uLL);
    printBuffer = (uint64_t)v8;
  }
  if ((unsigned __int16)(B_INFOMASK & *(_WORD *)(a1 + 40)) == (unsigned __int16)B_PATHONLY)
  {
    snprintf(v8, 0x1000uLL, "%s\n");
  }
  else
  {
    switch(*(_DWORD *)a1)
    {
      case 1:
        *(_OWORD *)unsigned int v13 = 0u;
        long long v14 = 0u;
        if (a4 == -1) {
          goto LABEL_25;
        }
        uint64_t v10 = *(unsigned int *)(a1 + 104);
        if (!v10) {
          goto LABEL_13;
        }
        uint64_t v11 = *(void *)(a1 + 112) + 8;
        break;
      case 2:
        if (!a3) {
          goto LABEL_23;
        }
        snprintf(v8, 0x1000uLL, "%s\t%d/%d\n");
        return (const char *)printBuffer;
      case 3:
        uint64_t v12 = *(void *)(a1 + 72);
        if (a3) {
          snprintf(v8, 0x1000uLL, "%s\t%d/%d\t%lld\t%05u\t%s\n", v12);
        }
        else {
          snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\t%lld\t%05u\t%s\n", v12, *(unsigned __int16 *)(a1 + 42));
        }
        return (const char *)printBuffer;
      case 4:
        if (a3) {
LABEL_23:
        }
          snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\n");
        else {
          snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\t%d\n");
        }
        return (const char *)printBuffer;
      default:
        return "";
    }
    while (*(_DWORD *)(v11 - 8) != a4)
    {
      v11 += 24;
      if (!--v10)
      {
LABEL_13:
        if (!a2) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }
    }
LABEL_25:
    if (!a2) {
      goto LABEL_27;
    }
LABEL_26:
    ctime_r((const time_t *)(a1 + 56), v13);
    int v8 = (char *)printBuffer;
LABEL_27:
    snprintf(v8, 0x1000uLL, "%s\t%o\t%d/%d\t%llu\t%u%s%s%s", *(void *)(a1 + 72), *(unsigned __int16 *)(a1 + 42), *(unsigned int *)(a1 + 44), *(unsigned int *)(a1 + 48));
  }
  return (const char *)printBuffer;
}

uint64_t BOMFSOTypeInfoSummaryWithFormat(uint64_t a1, char *a2, int a3)
{
  uint64_t v83 = *MEMORY[0x263EF8340];
  size_t v6 = (char *)printBuffer;
  if (!printBuffer)
  {
    size_t v6 = (char *)BOM_malloc(0x1000uLL);
    printBuffer = (uint64_t)v6;
  }
  time_t v78 = 0;
  int v7 = BOMFSObjectType((unsigned int *)a1);
  char v8 = *a2;
  if (!*a2) {
    goto LABEL_131;
  }
  int v9 = v7;
  int v10 = 0;
  int v76 = 0;
  unsigned int v11 = v7 & 0xFFFFFFFD;
  int v77 = v7;
  unint64_t v12 = 0x26774F000uLL;
  while (2)
  {
    if (v8 > 98)
    {
      switch(v8)
      {
        case 'c':
          if ((v10 & 0x1000) != 0) {
            goto LABEL_128;
          }
          v10 |= 0x1000u;
          if (v11 != 1) {
            goto LABEL_72;
          }
          if (a3 == -1)
          {
            size_t v55 = printBuffer - (void)v6 + 4096;
          }
          else
          {
            uint64_t v15 = *(unsigned int *)(a1 + 104);
            if (!v15) {
              goto LABEL_128;
            }
            uint64_t v16 = *(void *)(a1 + 112) + 16;
            while (*(_DWORD *)(v16 - 16) != a3)
            {
              v16 += 24;
              if (!--v15) {
                goto LABEL_128;
              }
            }
            size_t v55 = printBuffer - (void)v6 + 4096;
          }
          int v14 = snprintf(v6, v55, "%u\t");
          goto LABEL_127;
        case 'f':
          if (v10) {
            goto LABEL_128;
          }
          v10 |= 1u;
          uint64_t v37 = printBuffer - (void)v6 + 4096;
          BOMFSObjectPathName(a1);
          goto LABEL_63;
        case 'g':
          if ((v10 & 0x10) != 0) {
            goto LABEL_128;
          }
          v10 |= 0x10u;
          uint64_t v38 = printBuffer - (void)v6 + 4096;
          BOMFSObjectGroupID(a1);
          uint32_t v39 = v6;
          size_t v40 = v38;
          goto LABEL_75;
        case 'l':
          if ((v10 & 2) != 0) {
            goto LABEL_128;
          }
          v10 |= 2u;
          if (v9 != B_SymlinkType) {
            goto LABEL_72;
          }
          uint64_t v37 = printBuffer - (void)v6 + 4096;
          BOMFSObjectSymlinkTarget(a1);
LABEL_63:
          uint64_t v33 = v6;
          size_t v28 = v37;
LABEL_64:
          int v14 = snprintf(v33, v28, "%s\t");
          goto LABEL_127;
        case 'm':
LABEL_33:
          if ((v10 & 4) != 0) {
            goto LABEL_128;
          }
LABEL_34:
          v10 |= 4u;
          size_t v26 = printBuffer - (void)v6 + 4096;
          BOMFSObjectMode(a1);
          int v14 = snprintf(v6, v26, "%o\t");
          goto LABEL_127;
        case 's':
          if ((v10 & 0x400) != 0) {
            goto LABEL_128;
          }
          v10 |= 0x400u;
          if (BOMFSObjectType((unsigned int *)a1) == B_DirectoryType)
          {
            int v14 = snprintf(v6, printBuffer - (void)v6 + 4096, "\t", v74, v75);
            goto LABEL_127;
          }
          if (a3 == -1)
          {
            int v14 = snprintf(v6, printBuffer - (void)v6 + 4096, "%llu\t");
            goto LABEL_127;
          }
          uint64_t v47 = *(unsigned int *)(a1 + 104);
          if (!v47) {
            goto LABEL_128;
          }
          uint64_t v48 = *(void *)(a1 + 112) + 8;
          while (*(_DWORD *)(v48 - 8) != a3)
          {
            v48 += 24;
            if (!--v47) {
              goto LABEL_128;
            }
          }
          size_t v43 = printBuffer - (void)v6 + 4096;
          uint64_t v42 = v6;
          goto LABEL_71;
        case 't':
          if ((v10 & 0x100) != 0) {
            goto LABEL_128;
          }
          v10 |= 0x100u;
          if (v11 == 1)
          {
            uint64_t v41 = printBuffer - (void)v6 + 4096;
            BOMFSObjectModTime(a1);
            uint64_t v42 = v6;
            size_t v43 = v41;
            unint64_t v12 = 0x26774F000;
LABEL_71:
            int v14 = snprintf(v42, v43, "%lu\t");
LABEL_127:
            v6 += v14;
          }
          else
          {
LABEL_72:
            *v6++ = 9;
          }
          goto LABEL_128;
        case 'u':
          if ((v10 & 0x40) != 0) {
            goto LABEL_128;
          }
          v10 |= 0x40u;
          uint64_t v44 = printBuffer - (void)v6 + 4096;
          BOMFSObjectUserID(a1);
          uint32_t v39 = v6;
          size_t v40 = v44;
          unint64_t v12 = 0x26774F000;
LABEL_75:
          int v14 = snprintf(v39, v40, "%d\t");
          goto LABEL_127;
        default:
          goto LABEL_128;
      }
    }
    switch(v8)
    {
      case 'F':
        if ((v10 & 1) == 0)
        {
          v10 |= 1u;
          size_t v13 = printBuffer - (void)v6 + 4096;
          BOMFSObjectPathName(a1);
          int v14 = snprintf(v6, v13, "\"%s\"\t");
          goto LABEL_127;
        }
        goto LABEL_128;
      case 'G':
        if ((v10 & 0x20) == 0)
        {
          if (!*(void *)(v12 + 1280)) {
            *(void *)(v12 + 1280) = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x263EFFF90]);
          }
          v10 |= 0x20u;
          size_t v21 = (const void *)(int)BOMFSObjectGroupID(a1);
          if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(v12 + 1280), v21)) {
            goto LABEL_114;
          }
          CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v12 + 1280), v21);
          CFStringRef UTF8String = (char *)BOMCFStringGetUTF8String(Value);
          v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", UTF8String);
          free(UTF8String);
        }
        goto LABEL_128;
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
        goto LABEL_128;
      case 'L':
        if ((v10 & 2) == 0)
        {
          v10 |= 2u;
          if (v9 == B_SymlinkType)
          {
            size_t v24 = printBuffer - (void)v6 + 4096;
            int v25 = (const char *)BOMFSObjectSymlinkTarget(a1);
            v6 += snprintf(v6, v24, "\"%s\"\t", v25);
            goto LABEL_33;
          }
          *v6++ = 9;
          if ((v10 & 4) == 0) {
            goto LABEL_34;
          }
        }
        goto LABEL_128;
      case 'M':
        if ((v10 & 8) == 0)
        {
          v10 |= 8u;
          int v27 = BOMFSObjectMode(a1);
          strmode(v27, __bp);
          size_t v28 = printBuffer - (void)v6 + 4096;
          goto LABEL_50;
        }
        goto LABEL_128;
      case 'S':
        if ((v10 & 0x800) != 0) {
          goto LABEL_128;
        }
        v10 |= 0x800u;
        if (v11 != 1)
        {
          char *v6 = 0;
          goto LABEL_128;
        }
        if (a3 == -1)
        {
          int v31 = snprintf(&__str, 0xCuLL, "%lld");
          goto LABEL_123;
        }
        uint64_t v29 = *(unsigned int *)(a1 + 104);
        if (!v29)
        {
          int v31 = v76;
          if (!v76) {
            goto LABEL_124;
          }
          goto LABEL_45;
        }
        uint64_t v30 = *(void *)(a1 + 112) + 8;
        int v31 = v76;
        do
        {
          if (*(_DWORD *)(v30 - 8) == a3)
          {
            int v31 = snprintf(&__str, 0xCuLL, "%lu");
LABEL_123:
            if (!v31) {
              goto LABEL_124;
            }
LABEL_45:
            if (__str == 45)
            {
              --v31;
              *v6++ = __str;
              p_str = v80;
            }
            else
            {
              p_str = &__str;
            }
            uint64_t v56 = (v31 - 1);
            if (v31 < 1)
            {
              int v76 = v31;
              goto LABEL_128;
            }
            uint64_t v57 = 0;
            unsigned int v58 = v31 - 1;
            __int16 v59 = v6;
            while (1)
            {
              *v59++ = p_str[v57];
              if (v56 != v57 && v56 - 3 * (v58 / 3) == v57) {
                break;
              }
              if (v56 == v57)
              {
                char v60 = 9;
                goto LABEL_102;
              }
LABEL_103:
              ++v57;
              --v58;
              size_t v6 = v59;
              if (v56 + 1 == v57)
              {
                int v76 = 0;
                size_t v6 = v59;
                goto LABEL_128;
              }
            }
            char v60 = 44;
LABEL_102:
            __int16 v59 = v6 + 2;
            v6[1] = v60;
            goto LABEL_103;
          }
          v30 += 24;
          --v29;
        }
        while (v29);
        if (v76) {
          goto LABEL_45;
        }
LABEL_124:
        int v76 = 0;
LABEL_128:
        int v71 = *++a2;
        char v8 = v71;
        if (v71) {
          continue;
        }
LABEL_131:
        uint64_t v72 = printBuffer;
        if ((unint64_t)v6 > printBuffer)
        {
          *--size_t v6 = 0;
          uint64_t v72 = printBuffer;
        }
        snprintf(v6, v72 - (void)v6 + 4096, "\n");
        return printBuffer;
      case 'T':
        if ((v10 & 0x200) == 0)
        {
          v10 |= 0x200u;
          if (v11 != 1) {
            goto LABEL_72;
          }
          time_t v78 = BOMFSObjectModTime(a1);
          ctime_r(&v78, __s);
          __s[strlen(__s) - 1] = 0;
          size_t v28 = printBuffer - (void)v6 + 4096;
LABEL_50:
          uint64_t v33 = v6;
          goto LABEL_64;
        }
        goto LABEL_128;
      case 'U':
        if ((v10 & 0x80) == 0)
        {
          if (!BOMFSOTypeInfoSummaryWithFormat_userNameHash) {
            BOMFSOTypeInfoSummaryWithFormat_userNameHash = (uint64_t)CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x263EFFF90]);
          }
          v10 |= 0x80u;
          int v34 = (const void *)(int)BOMFSObjectUserID(a1);
          if (CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v34))
          {
            CFStringRef v35 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v34);
            int v36 = (char *)BOMCFStringGetUTF8String(v35);
            v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", v36);
            free(v36);
          }
          else
          {
            uid_t v49 = BOMFSObjectUserID(a1);
            int v50 = getpwuid(v49);
            if (v50) {
              pw_name = v50->pw_name;
            }
            else {
              pw_name = "<unknown>";
            }
            CFStringRef v61 = CFStringCreateWithCString(0, pw_name, 0x8000100u);
            v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", pw_name);
            CFDictionarySetValue((CFMutableDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v34, v61);
            CFRelease(v61);
            int v9 = v77;
          }
          unint64_t v12 = 0x26774F000;
        }
        goto LABEL_128;
      default:
        if (v8 == 47)
        {
          if ((v10 & 0x2000) == 0)
          {
            v10 |= 0x2000u;
            uint64_t v45 = printBuffer - (void)v6 + 4096;
            BOMFSObjectUserID(a1);
            BOMFSObjectGroupID(a1);
            size_t v46 = v45;
            unint64_t v12 = 0x26774F000;
            int v14 = snprintf(v6, v46, "%d/%d\t");
            goto LABEL_127;
          }
        }
        else if (v8 == 63 && (v10 & 0x4000) == 0)
        {
          if (!BOMFSOTypeInfoSummaryWithFormat_userNameHash) {
            BOMFSOTypeInfoSummaryWithFormat_userNameHash = (uint64_t)CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x263EFFF90]);
          }
          int v17 = (const void *)(int)BOMFSObjectUserID(a1);
          if (CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v17))
          {
            CFStringRef v18 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v17);
            uint64_t v19 = (char *)BOMCFStringGetUTF8String(v18);
            int v20 = snprintf(v6, printBuffer - (void)v6 + 4096, "%s/", v19);
            free(v19);
          }
          else
          {
            uid_t v52 = BOMFSObjectUserID(a1);
            unsigned int v53 = getpwuid(v52);
            if (v53) {
              int v54 = v53->pw_name;
            }
            else {
              int v54 = "<unknown>";
            }
            CFStringRef v62 = CFStringCreateWithCString(0, v54, 0x8000100u);
            int v20 = snprintf(v6, printBuffer - (void)v6 + 4096, "%s/", v54);
            CFDictionarySetValue((CFMutableDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_userNameHash, v17, v62);
            CFRelease(v62);
          }
          if (!BOMFSOTypeInfoSummaryWithFormat_groupNameHash) {
            BOMFSOTypeInfoSummaryWithFormat_groupNameHash = (uint64_t)CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x263EFFF90]);
          }
          v10 |= 0x4000u;
          v6 += v20;
          size_t v21 = (const void *)(int)BOMFSObjectGroupID(a1);
          if (CFDictionaryContainsKey((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash, v21))
          {
            CFStringRef v63 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash, v21);
            uint64_t v64 = (const char *)BOMCFStringGetUTF8String(v63);
            v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", v64);
            int v65 = (char *)v64;
            unint64_t v12 = 0x26774F000;
            free(v65);
          }
          else
          {
LABEL_114:
            gid_t v66 = BOMFSObjectGroupID(a1);
            uint64_t v67 = getgrgid(v66);
            if (v67) {
              gr_name = v67->gr_name;
            }
            else {
              gr_name = "<unknown>";
            }
            CFStringRef v69 = CFStringCreateWithCString(0, gr_name, 0x8000100u);
            v6 += snprintf(v6, printBuffer - (void)v6 + 4096, "%s\t", gr_name);
            CFDictionarySetValue((CFMutableDictionaryRef)BOMFSOTypeInfoSummaryWithFormat_groupNameHash, v21, v69);
            CFStringRef v70 = v69;
            unint64_t v12 = 0x26774F000uLL;
            CFRelease(v70);
          }
          int v9 = v77;
        }
        goto LABEL_128;
    }
  }
}

_DWORD *BOMFSOTypeInfoParseSummaryWithSys(const char *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  long long v25 = 0u;
  long long v26 = 0u;
  *(_OWORD *)char __str = 0u;
  *(_OWORD *)size_t v24 = 0u;
  *(_OWORD *)__s = 0u;
  int v3 = strdup(a1);
  uint64_t v4 = 0;
  __endptr = 0;
  __stringp = v3;
  uint64_t v19 = 0;
  while (1)
  {
    signed int v5 = strsep(&__stringp, "\t");
    __s[v4] = v5;
    if (!v5) {
      break;
    }
    if (++v4 == 10) {
      goto LABEL_42;
    }
  }
  if (v4)
  {
    if (v4 != 10)
    {
      for (uint64_t i = 0; i != v4; ++i)
      {
        if (!*__s[i])
        {
          warnx("Empty field in summary");
          goto LABEL_45;
        }
      }
      if (v4 <= 1) {
        goto LABEL_43;
      }
      int v7 = __s[0];
      char v8 = strrchr(__s[0], 47);
      if (v8) {
        int v9 = v8 + 1;
      }
      else {
        int v9 = v7;
      }
      __int16 v10 = strtol(__s[1], &__endptr, 8);
      if (*__endptr)
      {
LABEL_17:
        size_t v13 = 0;
      }
      else
      {
        __int16 v11 = v10;
        int v12 = BOMFSObjectTypeForMode(v10);
        switch(v12)
        {
          case 1:
            if (v4 != 5) {
              goto LABEL_17;
            }
            break;
          case 2:
            if (v4 != 3) {
              goto LABEL_17;
            }
            break;
          case 3:
            if (v4 != 6) {
              goto LABEL_17;
            }
            break;
          case 4:
            if (v4 != 4) {
              goto LABEL_17;
            }
            break;
          default:
            goto LABEL_17;
        }
        if (!a2) {
          a2 = BomSys_default();
        }
        int v14 = BOMFSObjectNewWithSys(v12, a2);
        size_t v13 = v14;
        if (!v14)
        {
          warnx("Can't create FSO for %s");
LABEL_40:
          if (v3) {
            goto LABEL_46;
          }
          goto LABEL_47;
        }
        BOMFSObjectSetFlags((uint64_t)v14, B_CKSUMS | B_STAT);
        BOMFSObjectSetPathName((uint64_t)v13, v7, 1);
        BOMFSObjectSetShortName((uint64_t)v13, v9, 1);
        BOMFSObjectSetMode((uint64_t)v13, v11);
        if (sscanf(__str[0], "%d/%d", (char *)&v19 + 4, &v19) == 2)
        {
          BOMFSObjectSetUserID((uint64_t)v13, SHIDWORD(v19));
          BOMFSObjectSetGroupID((uint64_t)v13, v19);
          switch(v12)
          {
            case 1:
LABEL_30:
              uint64_t v15 = strtoll(__str[1], &__endptr, 10);
              if (!*__endptr)
              {
                BOMFSObjectSetSize((uint64_t)v13, v15);
                int v16 = strtoul(v24[0], &__endptr, 10);
                if (!*__endptr)
                {
                  BOMFSObjectSetChecksum(v13, v16);
                  if (v12 == 3) {
                    BOMFSObjectSetSymlinkTarget(v13, v24[1], 1);
                  }
                  goto LABEL_34;
                }
              }
              break;
            case 4:
              int v17 = strtoul(__str[1], &__endptr, 10);
              if (!*__endptr)
              {
                BOMFSObjectSetDeviceID(v13, v17);
                if (!v3) {
                  return v13;
                }
                goto LABEL_38;
              }
              break;
            case 3:
              goto LABEL_30;
            default:
LABEL_34:
              if (!v3) {
                return v13;
              }
LABEL_38:
              free(v3);
              return v13;
          }
        }
      }
      warnx("Improperly formatted field");
      goto LABEL_40;
    }
LABEL_42:
    warnx("Improperly formatted input, too many fields");
  }
  else
  {
LABEL_43:
    warnx("Not enough fields");
  }
LABEL_45:
  size_t v13 = 0;
  if (v3) {
LABEL_46:
  }
    free(v3);
LABEL_47:
  if (v13)
  {
    BOMFSObjectFree((uint64_t)v13);
    return 0;
  }
  return v13;
}

uint64_t BOMFSOArchInfoArchiveLength(uint64_t a1)
{
  if (*(_DWORD *)a1 != 1 || !((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a1 + 40)) >> B_ARCHOFFT)) {
    return 0;
  }
  uint64_t v1 = *(int *)(a1 + 104);
  uint64_t v2 = 4 * v1;
  uint64_t v3 = 12 * v1;
  if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a1 + 40)) != 0) {
    uint64_t v4 = v2;
  }
  else {
    uint64_t v4 = 0;
  }
  return v3 + v4 + 5;
}

uint64_t BOMFSOArchInfoArchive(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a2 == 1)
  {
    if ((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a2 + 40)) >> B_ARCHOFFT)
    {
      uint64_t v4 = *(unsigned int *)(a2 + 104);
      BOMStreamWriteUInt8(a1, 1);
      BOMStreamWriteUInt32(a1, v4);
      if ((int)v4 >= 1)
      {
        uint64_t v5 = 0;
        uint64_t v6 = 24 * v4;
        do
        {
          BOMStreamWriteUInt32(a1, *(_DWORD *)(*(void *)(a2 + 112) + v5));
          BOMStreamWriteUInt32(a1, *(_DWORD *)(*(void *)(a2 + 112) + v5 + 4));
          BOMStreamWriteUInt32(a1, *(_DWORD *)(*(void *)(a2 + 112) + v5 + 8));
          if (((unsigned __int16)B_CKSUMS & *(_WORD *)(a2 + 40)) != 0) {
            BOMStreamWriteUInt32(a1, *(_DWORD *)(*(void *)(a2 + 112) + v5 + 16));
          }
          v5 += 24;
        }
        while (v6 != v5);
      }
    }
  }
  return 0;
}

uint64_t BOMFSOArchInfoUnarchive(uint64_t a1, uint64_t a2)
{
  uint64_t result = 1;
  if (!a1 || !a2) {
    return result;
  }
  if (*(_DWORD *)a2 != 1 || !((unsigned __int16)(B_ARCHMASK & *(_WORD *)(a2 + 40)) >> B_ARCHOFFT)) {
    return 0;
  }
  int UInt8 = BOMStreamReadUInt8(a1);
  if (UInt8 != 1)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "Architecture info has an invalid version: 0x%X\nCannot dearchive.\n", UInt8);
    return 1;
  }
  int UInt32 = BOMStreamReadUInt32(a1);
  *(_DWORD *)(a2 + 104) = UInt32;
  int v7 = BOM_malloc(24 * UInt32);
  *(void *)(a2 + 112) = v7;
  if (!v7) {
    return 1;
  }
  if (UInt32 < 1) {
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 24 * UInt32;
  do
  {
    *(_DWORD *)(*(void *)(a2 + 112) + v8) = BOMStreamReadUInt32(a1);
    *(_DWORD *)(*(void *)(a2 + 112) + v8 + 4) = BOMStreamReadUInt32(a1);
    *(void *)(*(void *)(a2 + 112) + v8 + 8) = BOMStreamReadUInt32(a1);
    if ((*(_WORD *)(a2 + 40) & (unsigned __int16)B_CKSUMS) != 0) {
      *(_DWORD *)(*(void *)(a2 + 112) + v8 + 16) = BOMStreamReadUInt32(a1);
    }
    uint64_t result = 0;
    v8 += 24;
  }
  while (v9 != v8);
  return result;
}

uint64_t BOMStorageNew(const char *a1, uint64_t a2)
{
  return BOMStorageNewWithOptionsAndSys(a1, a2, 0);
}

uint64_t BOMStorageNewWithOptionsAndSys(const char *a1, uint64_t a2, uint64_t (**a3)(void, const char *, uint64_t, uint64_t))
{
  uint64_t v3 = a3;
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (!a3) {
    uint64_t v3 = (uint64_t (**)(void, const char *, uint64_t, uint64_t))BomSys_default();
  }
  uint64_t v5 = v3[2](v3[1], a1, 1538, 420);
  if (v5 == -1)
  {
    uint64_t v8 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v9 = __error();
    __int16 v10 = strerror(*v9);
    fprintf(v8, "can't open %s: %s\n", a1, v10);
  }
  else
  {
    uint64_t v6 = v5;
    bzero(v11, 0x460uLL);
    int v12 = v6;
    size_t v13 = v3;
    if (!_WriteRootPage((uint64_t)v11))
    {
      ((void (*)(uint64_t (*)(void, const char *, uint64_t, uint64_t), uint64_t))v3[4])(v3[1], v6);
      return BOMStorageOpenWithSys(a1, 1, v3);
    }
  }
  return 0;
}

uint64_t BOMStorageNewWithSys(const char *a1, uint64_t (**a2)(void, const char *, uint64_t, uint64_t))
{
  return BOMStorageNewWithOptionsAndSys(a1, (uint64_t)a2, a2);
}

uint64_t BOMStorageNewWithOptions(const char *a1, uint64_t a2)
{
  return BOMStorageNewWithOptionsAndSys(a1, a2, 0);
}

uint64_t _WriteRootPage(uint64_t a1)
{
  if (a1) {
    uint64_t v2 = *(void *)(a1 + 1120);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t v3 = 1;
  uint64_t v4 = BOMStreamWithFileAndSys(*(_DWORD *)(a1 + 1028), 0, 0x200uLL, 1, 0, (void *)v2);
  if (v4)
  {
    uint64_t v5 = v4;
    BOMStreamWriteUInt32(v4, 0x424F4D53u);
    BOMStreamWriteUInt32(v5, 0x746F7265u);
    BOMStreamWriteUInt32(v5, 1u);
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1056));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1060));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1064));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1096));
    BOMStreamWriteUInt32(v5, *(_DWORD *)(a1 + 1100));
    uint64_t v3 = BOMStreamFree(v5);
    if ((*(unsigned int (**)(void, void))(v2 + 72))(*(void *)(v2 + 8), *(unsigned int *)(a1 + 1028)))
    {
      uint64_t v6 = (FILE *)*MEMORY[0x263EF8348];
      int v7 = __error();
      uint64_t v8 = strerror(*v7);
      fprintf(v6, "fsync: %s\n", v8);
      return 1;
    }
  }
  return v3;
}

uint64_t BOMStorageOpenWithSys(const char *a1, int a2, void *a3)
{
  uint64_t v3 = a3;
  if (!a3) {
    uint64_t v3 = BomSys_default();
  }
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v52 = 0u;
  long long v53 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  long long v49 = 0u;
  uint64_t v6 = (*((uint64_t (**)(void, const char *, void, uint64_t))v3 + 2))(*((void *)v3 + 1), a1, 2 * (a2 != 0), 420);
  if (v6 != -1)
  {
    uint64_t v7 = v6;
    if ((*((unsigned int (**)(void, uint64_t, long long *))v3 + 11))(*((void *)v3 + 1), v6, &v49) == -1)
    {
      size_t v21 = (FILE *)*MEMORY[0x263EF8348];
      int v22 = __error();
      uint64_t v47 = strerror(*v22);
      off_t v23 = "fstat: %s\n";
LABEL_15:
      size_t v24 = v21;
LABEL_19:
      fprintf(v24, v23, v47, v48, v49, v50, v51, v52, v53, v54);
      goto LABEL_20;
    }
    uint64_t v8 = BOMStreamWithFileAndSys(v7, 0, 0x200uLL, 0, 0, v3);
    if (!v8)
    {
      size_t v24 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v47 = (char *)a1;
      off_t v23 = "can't read from %s\n";
      goto LABEL_19;
    }
    uint64_t v9 = v8;
    if (BOMStreamReadUInt32(v8) == 1112493395 && BOMStreamReadUInt32(v9) == 1953460837)
    {
      int UInt32 = BOMStreamReadUInt32(v9);
      if (UInt32 == 1)
      {
        __int16 v11 = BOM_malloc(0x468uLL);
        uint64_t v12 = (uint64_t)v11;
        if (!v11)
        {
          size_t v28 = (FILE *)*MEMORY[0x263EF8348];
          uint64_t v29 = __error();
          uint64_t v30 = strerror(*v29);
          fprintf(v28, "malloc: %s\n", v30);
          BOMStreamFree(v9);
          (*((void (**)(void, uint64_t))v3 + 4))(*((void *)v3 + 1), v7);
          return v12;
        }
        bzero(v11, 0x468uLL);
        *(void *)(v12 + 1120) = v3;
        *(_DWORD *)(v12 + 1028) = v7;
        int v13 = v55;
        *(_DWORD *)(v12 + 1032) = v55;
        *(_DWORD *)(v12 + 1036) = v13;
        *(unsigned char *)(v12 + 1052) = a2;
        *(unsigned char *)(v12 + 1053) = 0;
        *(_DWORD *)(v12 + 1056) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1060) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1064) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1096) = BOMStreamReadUInt32(v9);
        *(_DWORD *)(v12 + 1100) = BOMStreamReadUInt32(v9);
        BOMStreamFree(v9);
        int v14 = *(_DWORD *)(v12 + 1060);
        int v15 = *(_DWORD *)(v12 + 1064);
        BOOL v16 = __CFADD__(v15, v14);
        unsigned int v17 = v15 + v14;
        if (!v16)
        {
          unsigned int v31 = *(_DWORD *)(v12 + 1032);
          if (v17 > v31)
          {
            fprintf((FILE *)*MEMORY[0x263EF8348], "%s: stream invalid; admin range is outside file\n");
            goto LABEL_20;
          }
          int v32 = *(_DWORD *)(v12 + 1096);
          int v33 = *(_DWORD *)(v12 + 1100);
          BOOL v16 = __CFADD__(v33, v32);
          unsigned int v34 = v33 + v32;
          if (v16)
          {
            fprintf((FILE *)*MEMORY[0x263EF8348], "%s: stream invalid; overflow of toc offset+size\n");
            goto LABEL_20;
          }
          if (v34 > v31)
          {
            fprintf((FILE *)*MEMORY[0x263EF8348], "%s: stream invalid; toc range is outside file\n");
            goto LABEL_20;
          }
          if (a2)
          {
            if (v31 <= 0x4000) {
              unsigned int v35 = 0x4000;
            }
            else {
              unsigned int v35 = *(_DWORD *)(v12 + 1032);
            }
            *(_DWORD *)(v12 + 1048) = v35;
            _CreateMapAddress(v12, v35);
            uint64_t v36 = *(void *)(v12 + 1040);
            if (!v36) {
              goto LABEL_20;
            }
            *(unsigned char *)(v12 + 1053) = 1;
            uint64_t v37 = *(unsigned int *)(v12 + 1096);
            if (v37)
            {
              uint64_t v38 = BOMStreamWithFileAndSys(*(_DWORD *)(v12 + 1028), v37, *(unsigned int *)(v12 + 1100), 0, (char *)(v36 + v37), v3);
              if (!v38) {
                goto LABEL_20;
              }
              BOMStreamFree(v38);
            }
            _CreateBlockTable(v12);
            uint64_t v39 = *(unsigned int *)(v12 + 1060);
            if (v39)
            {
              uint64_t v40 = BOMStreamWithFileAndSys(v7, v39, *(unsigned int *)(v12 + 1064), 0, 0, v3);
LABEL_45:
              uint64_t v43 = v40;
              if (!v40)
              {
                uint64_t v45 = (FILE *)*MEMORY[0x263EF8348];
                size_t v46 = __error();
                strerror(*v46);
                fprintf(v45, "can't read from %s: %s\n");
                goto LABEL_20;
              }
              if (_ReadBlockTable(v12, v40) || _ReadFreeList(v12, v43)) {
                goto LABEL_20;
              }
              BOMStreamFree(v43);
LABEL_50:
              __strlcpy_chk();
              return v12;
            }
            goto LABEL_49;
          }
          uint64_t v41 = (*((uint64_t (**)(void, void))v3 + 40))(*((void *)v3 + 1), 0);
          if (v41 != -1)
          {
            *(_DWORD *)(v12 + 1048) = *(_DWORD *)(v12 + 1032);
            *(void *)(v12 + 1040) = v41;
            *(unsigned char *)(v12 + 1053) = 1;
            _CreateBlockTable(v12);
            uint64_t v42 = *(unsigned int *)(v12 + 1060);
            if (v42)
            {
              uint64_t v40 = (uint64_t)BOMStreamWithAddress(*(void *)(v12 + 1040) + v42, *(unsigned int *)(v12 + 1064), 0);
              goto LABEL_45;
            }
LABEL_49:
            *(void *)(v12 + 1088) = _NewFreeList();
            goto LABEL_50;
          }
          size_t v21 = (FILE *)*MEMORY[0x263EF8348];
          uint64_t v44 = __error();
          uint64_t v47 = strerror(*v44);
          off_t v23 = "mmap: %s\n";
          goto LABEL_15;
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "%s: stream invalid; overflow of admin offset+size\n");
LABEL_20:
        (*((void (**)(void, uint64_t))v3 + 4))(*((void *)v3 + 1), v7);
        return 0;
      }
      fprintf((FILE *)*MEMORY[0x263EF8348], "%s has an unknown version: 0x%X\n", a1, UInt32);
    }
    else
    {
      long long v25 = BOMExceptionHandlerMessage("%s is not a BOMStorage file\n", a1);
      long long v26 = __error();
      _BOMExceptionHandlerCall((uint64_t)v25, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 323, *v26);
    }
    BOMStreamFree(v9);
    goto LABEL_20;
  }
  CFStringRef v18 = (FILE *)*MEMORY[0x263EF8348];
  uint64_t v19 = __error();
  int v20 = strerror(*v19);
  fprintf(v18, "can't open %s: %s\n", a1, v20);
  return 0;
}

uint64_t BOMStorageNewInRAM()
{
  uint64_t v0 = (char *)BOM_malloczero(0x468uLL);
  uint64_t v1 = (uint64_t)v0;
  if (v0)
  {
    *(void *)(v0 + 1028) = 0x200FFFFFFFFLL;
    *((_DWORD *)v0 + 259) = 512;
    *((_WORD *)v0 + 526) = 1;
    *((void *)v0 + 140) = BomSys_default();
    if (*(_DWORD *)(v1 + 1032) <= 0x4000u) {
      unsigned int v2 = 0x4000;
    }
    else {
      unsigned int v2 = *(_DWORD *)(v1 + 1032);
    }
    *(_DWORD *)(v1 + 1048) = v2;
    _CreateMapAddress(v1, v2);
    if (*(void *)(v1 + 1040))
    {
      *(unsigned char *)(v1 + 1053) = 1;
      _CreateBlockTable(v1);
      __strlcpy_chk();
      *(void *)(v1 + 1088) = _NewFreeList();
    }
    else
    {
      free((void *)v1);
      return 0;
    }
  }
  return v1;
}

uint64_t _CreateMapAddress(uint64_t a1, unsigned int a2)
{
  unint64_t v3 = (unint64_t)a2 % *MEMORY[0x263EF8AF8];
  if (v3) {
    int v4 = *MEMORY[0x263EF8AF8] - v3;
  }
  else {
    int v4 = 0;
  }
  uint64_t v5 = v4 + a2;
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 1120)
                                                                                                 + 320))(*(void *)(*(void *)(a1 + 1120) + 8), 0, v5, 3, 4098, 0xFFFFFFFFLL, 0);
  if (result == -1) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = result;
  }
  *(void *)(a1 + 1040) = v7;
  *(_DWORD *)(a1 + 1048) = v5;
  return result;
}

uint64_t _CreateBlockTable(uint64_t a1)
{
  unint64_t v2 = 0x4000uLL % *MEMORY[0x263EF8AF8];
  if (v2) {
    vm_size_t v3 = *MEMORY[0x263EF8AF8] - v2 + 0x4000;
  }
  else {
    vm_size_t v3 = 0x4000;
  }
  uint64_t result = vm_allocate(*MEMORY[0x263EF8960], (vm_address_t *)(a1 + 1072), v3, 1);
  if (result) {
    *(void *)(a1 + 1072) = 0;
  }
  *(_DWORD *)(a1 + 1080) = v3;
  return result;
}

_DWORD *_NewFreeList()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  unint64_t v2 = getenv("BOMFREELISTIMPLEMENTATION");
  if (v2)
  {
    CFStringRef v3 = CFStringCreateWithCString(v0, v2, 0x8000100u);
    CFDictionaryAddValue(Mutable, @"Implementation", v3);
    CFRelease(v3);
  }
  int v4 = _BOMFreeListAllocate(Mutable);
  CFRelease(Mutable);
  return v4;
}

uint64_t BOMStorageOpen(const char *a1, int a2)
{
  return BOMStorageOpenWithSys(a1, a2, 0);
}

uint64_t _ReadBlockTable(uint64_t a1, uint64_t a2)
{
  unsigned int UInt32 = BOMStreamReadUInt32(a2);
  if (!UInt32) {
    return 0;
  }
  unsigned int v5 = UInt32;
  if (!(UInt32 >> 29) && *(unsigned int *)(a1 + 1064) >= 8 * (unint64_t)UInt32)
  {
    _ExpandBlockTable(a1, 12 * UInt32);
    if (!*(void *)(a1 + 1072))
    {
      uint64_t v12 = (FILE *)*MEMORY[0x263EF8348];
      int v13 = __error();
      int v14 = strerror(*v13);
      fprintf(v12, "realloc: %s\n", v14);
      return 1;
    }
    uint64_t v7 = 0;
    *(_DWORD *)(a1 + 1068) = v5;
    uint64_t v8 = 12 * v5;
    do
    {
      *(_DWORD *)(*(void *)(a1 + 1072) + v7) = BOMStreamReadUInt32(a2);
      int v9 = BOMStreamReadUInt32(a2);
      uint64_t v10 = *(void *)(a1 + 1072) + v7;
      *(_DWORD *)(v10 + 4) = v9;
      *(unsigned char *)(v10 + 8) = (*(_DWORD *)v10 & v9) == -1;
      *(unsigned char *)(v10 + 9) = 0;
      v7 += 12;
    }
    while (v8 != v7);
    return 0;
  }
  uint64_t v6 = 1;
  fwrite("bad value for block table count\n", 0x20uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return v6;
}

uint64_t _ReadFreeList(uint64_t a1, uint64_t a2)
{
  int UInt32 = BOMStreamReadUInt32(a2);
  *(void *)(a1 + 1088) = _NewFreeList();
  if (!UInt32) {
    return 0;
  }
  int v5 = 8 * UInt32;
  size_t v6 = 8 * UInt32;
  uint64_t v7 = BOM_malloc(v5);
  if (v7)
  {
    uint64_t v8 = v7;
    BOMStreamReadBuffer(a2, v7, v6);
    uint64_t v9 = *(void *)(a1 + 1088);
    uint64_t v10 = *(void (**)(uint64_t, void *, size_t, BOOL))(v9 + 16);
    BOOL v11 = BOMStreamGetByteOrder(a2) == 1;
    v10(v9, v8, v6, v11);
    free(v8);
    return 0;
  }
  return 1;
}

uint64_t BOMStorageOpenInRAM(uint64_t a1, unint64_t a2, char a3)
{
  if (a2 <= 0x1FF)
  {
    fwrite("stream invalid; root page is outside of address range\n", 0x36uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    return 0;
  }
  int v4 = a2;
  size_t v6 = BOMStreamWithAddress(a1, 0x200uLL, 0);
  if (!v6)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "can't read from %s\n");
    return 0;
  }
  uint64_t v7 = (uint64_t)v6;
  if (BOMStreamReadUInt32((uint64_t)v6) != 1112493395
    || BOMStreamReadUInt32(v7) != 1953460837)
  {
    int v14 = BOMExceptionHandlerMessage("%s is not a BOMStorage file\n", "<memory>");
    int v15 = __error();
    _BOMExceptionHandlerCall((uint64_t)v14, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 490, *v15);
LABEL_12:
    BOMStreamFree(v7);
    return 0;
  }
  if (BOMStreamReadUInt32(v7) != 1)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%s has an unknown version: 0x%X\n");
    goto LABEL_12;
  }
  uint64_t v8 = BOM_malloc(0x468uLL);
  if (!v8)
  {
    unsigned int v17 = (FILE *)*MEMORY[0x263EF8348];
    CFStringRef v18 = __error();
    strerror(*v18);
    fprintf(v17, "malloc: %s\n");
    goto LABEL_12;
  }
  uint64_t v9 = (uint64_t)v8;
  bzero(v8, 0x468uLL);
  *(void *)(v9 + 1120) = BomSys_default();
  *(_DWORD *)(v9 + 1028) = -1;
  *(_DWORD *)(v9 + 1032) = v4;
  *(_DWORD *)(v9 + 1036) = v4;
  *(unsigned char *)(v9 + 1052) = a3;
  *(unsigned char *)(v9 + 1053) = 0;
  *(_DWORD *)(v9 + 1056) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1060) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1064) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1096) = BOMStreamReadUInt32(v7);
  *(_DWORD *)(v9 + 1100) = BOMStreamReadUInt32(v7);
  BOMStreamFree(v7);
  int v10 = *(_DWORD *)(v9 + 1060);
  int v11 = *(_DWORD *)(v9 + 1064);
  BOOL v12 = __CFADD__(v11, v10);
  unsigned int v13 = v11 + v10;
  if (v12)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "%s: stream invalid; overflow of admin offset+size\n");
  }
  else
  {
    unsigned int v19 = *(_DWORD *)(v9 + 1032);
    if (v13 <= v19)
    {
      int v20 = *(_DWORD *)(v9 + 1096);
      int v21 = *(_DWORD *)(v9 + 1100);
      BOOL v12 = __CFADD__(v21, v20);
      unsigned int v22 = v21 + v20;
      if (v12)
      {
        fprintf((FILE *)*MEMORY[0x263EF8348], "%s: stream invalid; overflow of toc offset+size\n");
      }
      else
      {
        if (v22 <= v19)
        {
          *(_DWORD *)(v9 + 1048) = v19;
          *(void *)(v9 + 1040) = a1;
          _CreateBlockTable(v9);
          uint64_t v23 = *(unsigned int *)(v9 + 1060);
          if (v23)
          {
            size_t v24 = BOMStreamWithAddress(*(void *)(v9 + 1040) + v23, *(unsigned int *)(v9 + 1064), 0);
            if (!v24)
            {
              long long v26 = (FILE *)*MEMORY[0x263EF8348];
              uint64_t v27 = __error();
              strerror(*v27);
              fprintf(v26, "can't read from %s: %s\n");
              return 0;
            }
            uint64_t v25 = (uint64_t)v24;
            if (_ReadBlockTable(v9, (uint64_t)v24) || _ReadFreeList(v9, v25)) {
              return 0;
            }
            BOMStreamFree(v25);
          }
          else
          {
            *(void *)(v9 + 1088) = _NewFreeList();
          }
          __strlcpy_chk();
          return v9;
        }
        fprintf((FILE *)*MEMORY[0x263EF8348], "%s: stream invalid; toc range is outside file\n");
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "%s: stream invalid; admin range is outside file\n");
    }
  }
  return 0;
}

BOOL BOMStorageIsStorageFile(const char *a1)
{
  return BOMStorageIsStorageFileWithSys(a1, 0);
}

BOOL BOMStorageIsStorageFileWithSys(const char *a1, void *a2)
{
  unint64_t v2 = a2;
  if (!a2) {
    unint64_t v2 = BomSys_default();
  }
  uint64_t v4 = (*((uint64_t (**)(void, const char *, void, uint64_t))v2 + 2))(*((void *)v2 + 1), a1, 0, 420);
  if (v4 == -1)
  {
    uint64_t v9 = (FILE *)*MEMORY[0x263EF8348];
    int v10 = __error();
    int v11 = strerror(*v10);
    fprintf(v9, "can't open %s: %s\n", a1, v11);
    return 0;
  }
  else
  {
    uint64_t v5 = v4;
    uint64_t v6 = BOMStreamWithFileAndSys(v4, 0, 0x200uLL, 0, 0, v2);
    if (v6)
    {
      uint64_t v7 = v6;
      BOOL v8 = BOMStreamReadUInt32(v6) == 1112493395 && BOMStreamReadUInt32(v7) == 1953460837;
      BOMStreamFree(v7);
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "can't read from %s\n", a1);
      BOOL v8 = 0;
    }
    (*((void (**)(void, uint64_t))v2 + 4))(*((void *)v2 + 1), v5);
  }
  return v8;
}

uint64_t BOMStorageFree(_DWORD *a1)
{
  if (!a1) {
    return 1;
  }
  if (a1[279] && BOMStorageCommit((uint64_t)a1)) {
    return 1;
  }
  uint64_t v3 = *((void *)a1 + 134);
  if (v3 && MEMORY[0x21666D800](*MEMORY[0x263EF8960], v3, a1[270]))
  {
    uint64_t v4 = __error();
    _BOMExceptionHandlerCall((uint64_t)"vm_deallocate failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1550, *v4);
  }
  uint64_t v5 = (void (**)(void))*((void *)a1 + 136);
  if (v5)
  {
    v5[4](*((void *)a1 + 136));
    free(v5);
  }
  if (*((void *)a1 + 130))
  {
    if (*((unsigned char *)a1 + 1053))
    {
      int v6 = *((unsigned __int8 *)a1 + 1052);
      int v7 = (*(uint64_t (**)(void))(*((void *)a1 + 140) + 328))(*(void *)(*((void *)a1 + 140) + 8));
      if (v6)
      {
        if (v7 == -1)
        {
          BOOL v8 = __error();
          _BOMExceptionHandlerCall((uint64_t)"munmap failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1417, *v8);
        }
      }
    }
  }
  if (a1[257] != -1) {
    (*(void (**)(void))(*((void *)a1 + 140) + 32))(*(void *)(*((void *)a1 + 140) + 8));
  }
  free(a1);
  return 0;
}

uint64_t BOMStorageCommit(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  if (!*(_DWORD *)(a1 + 1116)) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 1028) == -1)
  {
    BOOL v2 = 0;
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    goto LABEL_8;
  }
  _FlushWriteCache(a1);
  if (_AdjustFileSize(a1, 0, 0)) {
    return 1;
  }
  uint64_t v4 = *(void *)(a1 + 1088);
  int v5 = 8 * (*(_DWORD *)(a1 + 1068) + *(_DWORD *)(v4 + 8));
  unint64_t v6 = (v5 + 24);
  if (v5 == -24)
  {
    unsigned int v7 = 0;
  }
  else
  {
    unsigned int v7 = (*(uint64_t (**)(uint64_t, unint64_t))(v4 + 48))(v4, v6);
    if (!v7) {
      unsigned int v7 = *(_DWORD *)(a1 + 1032);
    }
  }
  int v8 = *(_DWORD *)(a1 + 1060);
  int v9 = *(_DWORD *)(a1 + 1064);
  *(_DWORD *)(a1 + 1060) = v7;
  *(_DWORD *)(a1 + 1064) = v6;
  if (v8 && v9) {
    (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
  }
  uint64_t v10 = v7;
  BOOL v2 = 1;
  uint64_t v11 = BOMStreamWithFile(*(_DWORD *)(a1 + 1028), v10, v6, 1, 0);
  if (v11)
  {
    uint64_t v12 = v11;
    uint64_t v13 = *(unsigned int *)(a1 + 1068);
    BOMStreamWriteUInt32(v11, *(_DWORD *)(a1 + 1068));
    if (v13)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 12 * v13;
      do
      {
        BOMStreamWriteUInt32(v12, *(_DWORD *)(*(void *)(a1 + 1072) + v14));
        BOMStreamWriteUInt32(v12, *(_DWORD *)(*(void *)(a1 + 1072) + v14 + 4));
        v14 += 12;
      }
      while (v15 != v14);
    }
    BOMStreamWriteUInt32(v12, *(_DWORD *)(*(void *)(a1 + 1088) + 8));
    size_t __len = 0;
    uint64_t v16 = *(void *)(a1 + 1088);
    unsigned int v17 = *(uint64_t (**)(uint64_t, BOOL, size_t *))(v16 + 24);
    BOOL v18 = BOMStreamGetByteOrder(v12) == 1;
    unsigned int v19 = (void *)v17(v16, v18, &__len);
    BOMStreamWriteBuffer(v12, v19, __len);
    free(v19);
    int v20 = BOMStreamFree(v12);
    if (_AdjustFileSize(a1, 0, 0)) {
      return 1;
    }
    *(_DWORD *)(a1 + 1036) = *(_DWORD *)(a1 + 1032);
    BOOL v2 = (_WriteRootPage(a1) | v20) != 0;
LABEL_8:
    *(_DWORD *)(a1 + 1116) = 0;
  }
  return v2;
}

uint64_t BOMStorageGetSys(uint64_t result)
{
  if (result) {
    return *(void *)(result + 1120);
  }
  return result;
}

uint64_t BOMStorageIsOpenForWriting(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 1052);
  }
  return result;
}

uint64_t BOMStorageNewBlock(uint64_t a1)
{
  if (!a1 || !*(unsigned char *)(a1 + 1052)) {
    return 0;
  }
  uint64_t v2 = (*(_DWORD *)(a1 + 1056) + 1);
  *(_DWORD *)(a1 + 1056) = v2;
  if (v2 >= *(_DWORD *)(a1 + 1068))
  {
    unsigned int v3 = *(_DWORD *)(a1 + 1080);
    if (v3 >= 0x100000) {
      unsigned int v4 = v3 + 0x100000;
    }
    else {
      unsigned int v4 = 2 * v3;
    }
    _ExpandBlockTable(a1, v4);
    *(_DWORD *)(a1 + 1068) = *(_DWORD *)(a1 + 1080) / 0xCu;
  }
  *(unsigned char *)(*(void *)(a1 + 1072) + 12 * v2 + 8) = 0;
  return v2;
}

uint64_t _ExpandBlockTable(uint64_t result, unsigned int a2)
{
  uint64_t v2 = result;
  vm_size_t v3 = *(unsigned int *)(result + 1080);
  if (v3 >= a2)
  {
    if (*(void *)(result + 1072)) {
      return result;
    }
    goto LABEL_14;
  }
  vm_address_t address = 0;
  unint64_t v4 = (unint64_t)a2 % *MEMORY[0x263EF8AF8];
  if (v4) {
    int v5 = *MEMORY[0x263EF8AF8] - v4;
  }
  else {
    int v5 = 0;
  }
  vm_size_t v6 = v5 + a2;
  unsigned int v7 = (vm_map_t *)MEMORY[0x263EF8960];
  if (vm_allocate(*MEMORY[0x263EF8960], &address, v6, 1))
  {
    int v8 = __error();
    _BOMExceptionHandlerCall((uint64_t)"vm_allocate failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1570, *v8);
  }
  if (vm_copy(*v7, *(void *)(v2 + 1072), v3, address))
  {
    int v9 = __error();
    _BOMExceptionHandlerCall((uint64_t)"vm_copy failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1572, *v9);
  }
  uint64_t result = MEMORY[0x21666D800](*v7, *(void *)(v2 + 1072), v3);
  if (result)
  {
    uint64_t v10 = __error();
    uint64_t result = _BOMExceptionHandlerCall((uint64_t)"vm_deallocate failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1575, *v10);
  }
  vm_address_t v11 = address;
  *(void *)(v2 + 1072) = address;
  *(_DWORD *)(v2 + 1080) = v6;
  if (!v11)
  {
LABEL_14:
    uint64_t v12 = __error();
    return _BOMExceptionHandlerCall((uint64_t)"Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1591, *v12);
  }
  return result;
}

uint64_t BOMStorageNewNamedBlock(uint64_t a1, const char *a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (!*(unsigned char *)(a1 + 1052)) {
    return 0;
  }
  if (_tocGet(a1, a2))
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "name %s already exists!\n", a2);
    return 0;
  }
  uint64_t v4 = BOMStorageNewBlock(a1);
  unsigned int v6 = strlen(a2);
  if ((v6 & 0xFFFFFF00) != 0)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "name '%s' is > %d\n", a2, 255);
  }
  else
  {
    unsigned int v7 = v6;
    if (*(_DWORD *)(a1 + 1096)) {
      int v8 = *(_DWORD *)(a1 + 1100);
    }
    else {
      int v8 = 4;
    }
    unsigned int v9 = v6 + v8;
    unsigned int v10 = v9 + 5;
    if (v9 == -5)
    {
      unsigned int v11 = 0;
    }
    else
    {
      unsigned int v11 = (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 48))();
      if (!v11) {
        unsigned int v11 = *(_DWORD *)(a1 + 1032);
      }
    }
    _ExpandMapAddress(a1, v11 + v10);
    uint64_t v12 = *(unsigned int *)(a1 + 1096);
    if (v12)
    {
      uint64_t v13 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v12, *(unsigned int *)(a1 + 1100), 0);
      if (!v13) {
        return v4;
      }
      uint64_t v14 = (uint64_t)v13;
      int UInt32 = BOMStreamReadUInt32((uint64_t)v13);
    }
    else
    {
      int UInt32 = 0;
      uint64_t v14 = 0;
    }
    uint64_t v16 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v11, v10, 1);
    if (v16)
    {
      uint64_t v17 = (uint64_t)v16;
      size_t v18 = v7;
      BOMStreamWriteUInt32((uint64_t)v16, UInt32 + 1);
      if (v14)
      {
        unsigned int v23 = v11;
        for (unsigned int i = v10; UInt32; --UInt32)
        {
          unsigned int v19 = BOMStreamReadUInt32(v14);
          unsigned int UInt8 = BOMStreamReadUInt8(v14);
          char v21 = UInt8;
          size_t v22 = UInt8;
          BOMStreamReadBuffer(v14, __dst, UInt8);
          BOMStreamWriteUInt32(v17, v19);
          BOMStreamWriteUInt8(v17, v21);
          BOMStreamWriteBuffer(v17, __dst, v22);
        }
        BOMStreamFree(v14);
        if (*(_DWORD *)(a1 + 1096) && *(_DWORD *)(a1 + 1100)) {
          (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
        }
        unsigned int v10 = i;
        unsigned int v11 = v23;
        size_t v18 = v7;
      }
      BOMStreamWriteUInt32(v17, v4);
      BOMStreamWriteUInt8(v17, v7);
      BOMStreamWriteBuffer(v17, a2, v18);
      BOMStreamFree(v17);
      *(_DWORD *)(a1 + 1096) = v11;
      *(_DWORD *)(a1 + 1100) = v10;
      _AdjustFileSize(a1, v11, v10);
      if (*(_DWORD *)(a1 + 1028) != -1) {
        _AddToWriteCache(a1, v11, v10);
      }
      *(_DWORD *)(a1 + 1116) = 1;
    }
  }
  return v4;
}

uint64_t _tocGet(uint64_t a1, const char *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(unsigned int *)(a1 + 1096);
  if (!v2) {
    return 0;
  }
  unint64_t v4 = *(unsigned int *)(a1 + 1100);
  if (!v4) {
    return 0;
  }
  int v5 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v2, v4, 0);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = (uint64_t)v5;
  int UInt32 = BOMStreamReadUInt32((uint64_t)v5);
  if (UInt32)
  {
    int v8 = UInt32;
    while (1)
    {
      uint64_t v9 = BOMStreamReadUInt32(v6);
      unsigned int UInt8 = BOMStreamReadUInt8(v6);
      BOMStreamReadBuffer(v6, __s2, UInt8);
      __s2[UInt8] = 0;
      if (!strcmp(a2, __s2)) {
        break;
      }
      if (!--v8) {
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    uint64_t v9 = 0;
  }
  BOMStreamFree(v6);
  return v9;
}

uint64_t BOMStorageSizeOfBlock(uint64_t a1, unsigned int a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 1056) < a2) {
      return 0;
    }
    if (*(_DWORD *)(a1 + 1068) <= a2) {
      return 0;
    }
    uint64_t v4 = *(void *)(a1 + 1072);
    if (*(unsigned char *)(v4 + 12 * a2 + 8) == 1) {
      return 0;
    }
    else {
      return *(unsigned int *)(v4 + 12 * a2 + 4);
    }
  }
  return result;
}

double BOMStorageFreeBlock(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    if (a2)
    {
      if (*(_DWORD *)(a1 + 1056) >= a2)
      {
        uint64_t v3 = *(void *)(a1 + 1072);
        if (!*(unsigned char *)(v3 + 12 * a2 + 8))
        {
          int v5 = (_DWORD *)(v3 + 12 * a2);
          if (*v5) {
            BOOL v6 = v5[1] == 0;
          }
          else {
            BOOL v6 = 1;
          }
          if (!v6)
          {
            (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
            uint64_t v3 = *(void *)(a1 + 1072);
          }
          uint64_t v7 = v3 + 12 * a2;
          double result = NAN;
          *(void *)uint64_t v7 = -1;
          *(unsigned char *)(v7 + 8) = 1;
        }
      }
    }
  }
  return result;
}

void BOMStorageFreeNamedBlock(uint64_t a1, const char *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      unsigned int v4 = _tocGet(a1, a2);
      if (v4)
      {
        BOMStorageFreeBlock(a1, v4);
        if (*(_DWORD *)(a1 + 1096))
        {
          int v5 = strlen(a2);
          int v6 = *(_DWORD *)(a1 + 1100);
          if (v6)
          {
            unsigned int v7 = (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 48))();
            if (!v7) {
              unsigned int v7 = *(_DWORD *)(a1 + 1032);
            }
          }
          else
          {
            unsigned int v7 = 0;
          }
          unint64_t v8 = (v6 - v5 - 5);
          _ExpandMapAddress(a1, v7 + v8);
          uint64_t v9 = BOMStreamWithAddress(*(void *)(a1 + 1040) + *(unsigned int *)(a1 + 1096), *(unsigned int *)(a1 + 1100), 0);
          if (v9)
          {
            uint64_t v10 = (uint64_t)v9;
            unsigned int v11 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v7, v8, 1);
            if (v11)
            {
              uint64_t v12 = (uint64_t)v11;
              int UInt32 = BOMStreamReadUInt32(v10);
              BOMStreamWriteUInt32(v12, UInt32 - 1);
              for (; UInt32; --UInt32)
              {
                unsigned int v14 = BOMStreamReadUInt32(v10);
                size_t UInt8 = BOMStreamReadUInt8(v10);
                BOMStreamReadBuffer(v10, __s1, UInt8);
                __s1[UInt8] = 0;
                if (strcmp(__s1, a2))
                {
                  BOMStreamWriteUInt32(v12, v14);
                  BOMStreamWriteUInt8(v12, UInt8);
                  BOMStreamWriteBuffer(v12, __s1, UInt8);
                }
              }
              BOMStreamFree(v10);
              BOMStreamFree(v12);
              if (*(_DWORD *)(a1 + 1096) && *(_DWORD *)(a1 + 1100)) {
                (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
              }
              *(_DWORD *)(a1 + 1096) = v7;
              *(_DWORD *)(a1 + 1100) = v8;
              _AdjustFileSize(a1, v7, v8);
              if (*(_DWORD *)(a1 + 1028) != -1) {
                _AddToWriteCache(a1, v7, v8);
              }
              *(_DWORD *)(a1 + 1116) = 1;
            }
          }
        }
      }
    }
  }
}

uint64_t BOMStorageCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 1056);
  }
  return result;
}

uint64_t BOMStorageCopyToBlock(uint64_t a1, unsigned int a2, const void *a3, size_t a4)
{
  if (a1 && a2 && *(_DWORD *)(a1 + 1056) >= a2 && *(unsigned char *)(a1 + 1052)) {
    return BOMStorageCopyToBlockRange(a1, a2, a3, a4, 0, *(unsigned int *)(*(void *)(a1 + 1072) + 12 * a2 + 4));
  }
  else {
    return 1;
  }
}

uint64_t BOMStorageCopyToBlockRange(uint64_t a1, unsigned int a2, const void *a3, size_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t result = 1;
  if (!a1 || !a2 || *(_DWORD *)(a1 + 1056) < a2 || !*(unsigned char *)(a1 + 1052)) {
    return result;
  }
  uint64_t v10 = (unsigned int *)(*(void *)(a1 + 1072) + 12 * a2);
  unint64_t v11 = v10[1];
  int v12 = a6 + a5;
  if (a6 + a5 > v11)
  {
    int v13 = *__error();
    unsigned int v14 = "BOMStorageCopyToBlockRange: length extends beyond block size";
    int v15 = 893;
LABEL_7:
    _BOMExceptionHandlerCall((uint64_t)v14, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v15, v13);
    return 1;
  }
  uint64_t v18 = *v10;
  if (v11 <= a5) {
    unsigned int v19 = a5;
  }
  else {
    unsigned int v19 = v10[1];
  }
  unsigned int v20 = a4 - a6 + v19;
  if (v11 == v20 && v18 >= *(_DWORD *)(a1 + 1036))
  {
    unsigned int v22 = v18;
  }
  else
  {
    if (v18) {
      BOOL v21 = v11 == 0;
    }
    else {
      BOOL v21 = 1;
    }
    if (!v21) {
      (*(void (**)(void))(*(void *)(a1 + 1088) + 40))();
    }
    if (v20)
    {
      unsigned int v22 = (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 48))();
      if (!v22) {
        unsigned int v22 = *(_DWORD *)(a1 + 1032);
      }
    }
    else
    {
      unsigned int v22 = 0;
    }
    unsigned int v23 = (unsigned int *)(*(void *)(a1 + 1072) + 12 * a2);
    unsigned int *v23 = v22;
    v23[1] = v20;
  }
  if (v20) {
    BOOL v24 = v22 == 0;
  }
  else {
    BOOL v24 = 1;
  }
  if (v24) {
    return 0;
  }
  unsigned int v36 = v22 + v20;
  _ExpandMapAddress(a1, v22 + v20);
  if (a5)
  {
    memmove((void *)(*(void *)(a1 + 1040) + v22), (const void *)(*(void *)(a1 + 1040) + v18), a5);
    unsigned int v25 = a5;
  }
  else
  {
    unsigned int v25 = 0;
  }
  if (v11 <= a5 || v22 < v18 || v22 >= (int)v11 + (int)v18)
  {
    if (a4)
    {
      size_t v28 = a3;
      unsigned int v29 = v25;
      memmove((void *)(*(void *)(a1 + 1040) + v22 + v25), v28, a4);
      unsigned int v25 = v29 + a4;
    }
    if (v20 > v25)
    {
      memmove((void *)(*(void *)(a1 + 1040) + v22 + v25), (const void *)(*(void *)(a1 + 1040) + a5 + a6 + v18), v20 - v25);
      *(unsigned char *)(*(void *)(a1 + 1072) + 12 * a2 + 9) = 1;
      goto LABEL_51;
    }
  }
  else
  {
    size_t v30 = (v11 - v12);
    if (v30)
    {
      uint64_t v31 = *(void *)(a1 + 1040);
      int v32 = (const void *)(v31 + a5 + a6 + v18);
      unsigned int v33 = v25;
      memmove((void *)(v31 + v22 + a5 + a4), v32, v30);
      unsigned int v25 = v33;
    }
    if (a4)
    {
      unsigned int v34 = v25;
      memmove((void *)(*(void *)(a1 + 1040) + v22 + v25), a3, a4);
      unsigned int v25 = v34 + a4;
    }
    v25 += v30;
  }
  *(unsigned char *)(*(void *)(a1 + 1072) + 12 * a2 + 9) = 1;
  if (v25 != v20)
  {
    int v13 = *__error();
    unsigned int v14 = "BOMStorageCopyToBlockRange: internal consistency error";
    int v15 = 997;
    goto LABEL_7;
  }
LABEL_51:
  if (*(_DWORD *)(a1 + 1028) == -1)
  {
    if (v36 > *(_DWORD *)(a1 + 1032)) {
      *(_DWORD *)(a1 + 1032) = v36;
    }
  }
  else
  {
    _AddToWriteCache(a1, v22, v20);
  }
  int v35 = _AdjustFileSize(a1, v22, v20);
  uint64_t result = 1;
  if (!v35)
  {
    *(_DWORD *)(a1 + 1116) = 1;
    return 0;
  }
  return result;
}

uint64_t _ExpandMapAddress(uint64_t result, unsigned int a2)
{
  uint64_t v2 = result;
  unsigned int v3 = *(_DWORD *)(result + 1048);
  if (v3 >= a2)
  {
    if (*(void *)(result + 1040)) {
      return result;
    }
  }
  else
  {
    if (v3 >= 0x100000) {
      LODWORD(v4) = v3 + 0x100000;
    }
    else {
      LODWORD(v4) = 2 * v3;
    }
    if (v4 <= a2) {
      unint64_t v4 = a2;
    }
    else {
      unint64_t v4 = v4;
    }
    unint64_t v5 = v4 % *MEMORY[0x263EF8AF8];
    int v6 = *MEMORY[0x263EF8AF8] - v5;
    if (!v5) {
      int v6 = 0;
    }
    uint64_t v7 = (v6 + v4);
    vm_address_t v8 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)(result + 1120)
                                                                                               + 320))(*(void *)(*(void *)(result + 1120) + 8), 0, v7, 3, 4098, 0xFFFFFFFFLL, 0);
    if (v8 == -1)
    {
      int v11 = *__error();
      int v12 = "mmap failed";
      int v13 = 1443;
      goto LABEL_20;
    }
    vm_address_t v9 = v8;
    if (vm_copy(*MEMORY[0x263EF8960], *(void *)(v2 + 1040), *(unsigned int *)(v2 + 1048), v8))
    {
      uint64_t v10 = __error();
      _BOMExceptionHandlerCall((uint64_t)"vm_copy failed", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1447, *v10);
    }
    uint64_t result = (*(uint64_t (**)(void, void, void))(*(void *)(v2 + 1120) + 328))(*(void *)(*(void *)(v2 + 1120) + 8), *(void *)(v2 + 1040), *(unsigned int *)(v2 + 1048));
    if (result == -1)
    {
      int v11 = *__error();
      int v12 = "munmap failed";
      int v13 = 1449;
      goto LABEL_20;
    }
    *(void *)(v2 + 1040) = v9;
    *(_DWORD *)(v2 + 1048) = v7;
    if (v9) {
      return result;
    }
  }
  int v11 = *__error();
  int v12 = "Out of memory.";
  int v13 = 1460;
LABEL_20:
  return _BOMExceptionHandlerCall((uint64_t)v12, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v13, v11);
}

void _AddToWriteCache(uint64_t a1, unsigned int a2, int a3)
{
  if (!a2 || !a3) {
    return;
  }
  unint64_t v5 = *(_DWORD **)(a1 + 1104);
  if (!v5)
  {
    *(void *)(a1 + 1104) = _newFreeListEntry(a2, a3);
    int v11 = 1;
LABEL_23:
    *(_DWORD *)(a1 + 1112) = v11;
LABEL_24:
    if (*(_DWORD *)(a1 + 1112) < 0x10u)
    {
      unsigned int v14 = *(_DWORD **)(a1 + 1104);
      if (v14)
      {
        int v15 = 0;
        do
        {
          unsigned int v16 = v14[3];
          if (v16 < 0xFFFF)
          {
            uint64_t v17 = *(_DWORD **)v14;
            int v15 = v14;
          }
          else
          {
            uint64_t v17 = *(_DWORD **)v14;
            if (v15)
            {
              *int v15 = v17;
              uint64_t v17 = *(_DWORD **)v14;
            }
            else
            {
              *(void *)(a1 + 1104) = v17;
            }
            _WriteAddress(a1, v14[2], v16);
            free(v14);
            --*(_DWORD *)(a1 + 1112);
          }
          unsigned int v14 = v17;
        }
        while (v17);
      }
    }
    else
    {
      _FlushWriteCache(a1);
    }
    return;
  }
  unsigned int v6 = v5[2];
  if (v6 <= a2)
  {
    while (1)
    {
      uint64_t v7 = v5;
      unint64_t v5 = *(_DWORD **)v5;
      if (!v5) {
        break;
      }
      unsigned int v8 = v5[2];
      if (v8 >= a2)
      {
        int v10 = v7[3];
        if (v10 + v7[2] != a2) {
          goto LABEL_6;
        }
        void v7[3] = v10 + a3;
        if (a3 + a2 == v5[2])
        {
          void v7[3] = v5[3] + v10 + a3;
          *(void *)uint64_t v7 = *(void *)v5;
          free(v5);
          int v11 = *(_DWORD *)(a1 + 1112) - 1;
          goto LABEL_23;
        }
        goto LABEL_24;
      }
    }
    int v13 = v7[3];
    if (v13 + v7[2] == a2)
    {
      void v7[3] = v13 + a3;
      goto LABEL_24;
    }
    int v12 = _newFreeListEntry(a2, a3);
    if (v12)
    {
      *(void *)int v12 = 0;
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v7 = 0;
    unsigned int v8 = v5[2];
LABEL_6:
    if (a3 + a2 == v8)
    {
      int v9 = v5[3] + a3;
      v5[2] = a2;
      v5[3] = v9;
      goto LABEL_24;
    }
    int v12 = _newFreeListEntry(a2, a3);
    if (v12)
    {
      *(void *)int v12 = v5;
      if (v6 <= a2) {
LABEL_21:
      }
        *(void *)uint64_t v7 = v12;
      else {
        *(void *)(a1 + 1104) = v12;
      }
      int v11 = *(_DWORD *)(a1 + 1112) + 1;
      goto LABEL_23;
    }
  }
  int v18 = *__error();
  _BOMExceptionHandlerCall((uint64_t)"Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 2068, v18);
}

uint64_t _AdjustFileSize(uint64_t a1, int a2, int a3)
{
  if (a2)
  {
    if ((a3 + a2) <= *(_DWORD *)(a1 + 1032))
    {
      return 0;
    }
    else
    {
      uint64_t result = 0;
      *(_DWORD *)(a1 + 1032) = a3 + a2;
    }
  }
  else
  {
    uint64_t v5 = (*(uint64_t (**)(void, void, void, uint64_t))(*(void *)(a1 + 1120) + 64))(*(void *)(*(void *)(a1 + 1120) + 8), *(unsigned int *)(a1 + 1028), 0, 2);
    if (v5 == -1)
    {
      uint64_t v7 = (FILE *)*MEMORY[0x263EF8348];
      unsigned int v8 = __error();
      int v9 = strerror(*v8);
      fprintf(v7, "lseek: %s\n", v9);
      return 1;
    }
    else
    {
      int v6 = v5;
      uint64_t result = 0;
      *(_DWORD *)(a1 + 1032) = v6;
    }
  }
  return result;
}

uint64_t BOMStorageCopyFromBlock(uint64_t a1, unsigned int a2, void *a3)
{
  if (!a1 || !a2)
  {
    if (a1)
    {
      if (!a2) {
        goto LABEL_12;
      }
    }
    else
    {
      int v9 = __error();
      _BOMExceptionHandlerCall((uint64_t)"BOMStorageCopyFromBlock: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1035, *v9);
      if (!a2)
      {
LABEL_12:
        int v4 = *__error();
        uint64_t v5 = "BOMStorageCopyFromBlock: !bid";
        int v6 = 1039;
        goto LABEL_13;
      }
    }
    return 1;
  }
  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    int v4 = *__error();
    uint64_t v5 = "BOMStorageCopyFromBlock: bid > storage->blocks";
    int v6 = 1047;
LABEL_13:
    _BOMExceptionHandlerCall((uint64_t)v5, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v6, v4);
    return 1;
  }
  size_t v7 = *(unsigned int *)(*(void *)(a1 + 1072) + 12 * a2 + 4);
  return BOMStorageCopyFromBlockRange(a1, a2, 0, v7, a3);
}

uint64_t BOMStorageCopyFromBlockRange(uint64_t a1, unsigned int a2, uint64_t a3, size_t __len, void *__dst)
{
  if (!a1 || !a2 || !__dst)
  {
    if (a1)
    {
      if (a2) {
        goto LABEL_8;
      }
    }
    else
    {
      int v12 = __error();
      _BOMExceptionHandlerCall((uint64_t)"BOMStorageCopyFromBlockRange: !storage", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1066, *v12);
      if (a2)
      {
LABEL_8:
        if (!__dst) {
          goto LABEL_14;
        }
        return 1;
      }
    }
    int v13 = __error();
    _BOMExceptionHandlerCall((uint64_t)"BOMStorageCopyFromBlockRange: !bid", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1070, *v13);
    if (!__dst)
    {
LABEL_14:
      int v8 = *__error();
      int v9 = "BOMStorageCopyFromBlockRange: !data";
      int v10 = 1074;
      goto LABEL_15;
    }
    return 1;
  }
  if (*(_DWORD *)(a1 + 1056) < a2)
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: bad block (bid > storage->blocks)";
    int v10 = 1081;
LABEL_15:
    _BOMExceptionHandlerCall((uint64_t)v9, 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", v10, v8);
    return 1;
  }
  uint64_t v11 = *(void *)(a1 + 1072);
  if (*(unsigned char *)(v11 + 12 * a2 + 8))
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: reading from free block";
    int v10 = 1087;
    goto LABEL_15;
  }
  uint64_t v17 = (unsigned int *)(v11 + 12 * a2);
  uint64_t v19 = *v17;
  unint64_t v18 = v17[1];
  if ((v18 + v19) >> 32)
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: 32-bit overflow with block address+size";
    int v10 = 1098;
    goto LABEL_15;
  }
  if (v18 + v19 > *(unsigned int *)(a1 + 1032))
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: block extends past end of storage";
    int v10 = 1103;
    goto LABEL_15;
  }
  if (__len + a3 > v18)
  {
    int v8 = *__error();
    int v9 = "BOMStorageCopyRangeFromBlockRange: length extends beyond block size";
    int v10 = 1110;
    goto LABEL_15;
  }
  if (v18)
  {
    if (!v19)
    {
      int v8 = *__error();
      int v9 = "BOMStorageCopyRangeFromBlockRange: bad block address";
      int v10 = 1123;
      goto LABEL_15;
    }
    if (!*(unsigned char *)(v11 + 12 * a2 + 9))
    {
      if (*(unsigned char *)(a1 + 1052))
      {
        int v21 = *(_DWORD *)(a1 + 1028);
        if (v21 != -1)
        {
          uint64_t v22 = BOMStreamWithFile(v21, v19, v18, 0, (char *)(*(void *)(a1 + 1040) + v19));
          if (!v22)
          {
            int v8 = *__error();
            int v9 = "BOMStorageCopyRangeFromBlockRange: !stream";
            int v10 = 1147;
            goto LABEL_15;
          }
          BOMStreamFree(v22);
          *(unsigned char *)(*(void *)(a1 + 1072) + 12 * a2 + 9) = 1;
        }
      }
    }
    memmove(__dst, (const void *)(*(void *)(a1 + 1040) + a3 + v19), __len);
  }
  return 0;
}

void _FlushWriteCache(uint64_t a1)
{
  for (unsigned int i = *(_DWORD **)(a1 + 1104); i; unsigned int i = *(_DWORD **)(a1 + 1104))
  {
    *(void *)(a1 + 1104) = *(void *)i;
    _WriteAddress(a1, i[2], i[3]);
    free(i);
  }
  *(_DWORD *)(a1 + 1112) = 0;
}

uint64_t BOMStorageCompact(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (!a1 || !*(unsigned char *)(a1 + 1052) || *(_DWORD *)(a1 + 1028) == -1) {
    return 1;
  }
  uint64_t v2 = *(void *)(a1 + 1120);
  BOMStorageCommit(a1);
  __strlcpy_chk();
  __strlcpy_chk();
  unsigned int v3 = strrchr(__s, 47);
  if (v3) {
    char *v3 = 0;
  }
  else {
    __strlcpy_chk();
  }
  __strlcat_chk();
  if (!(*(uint64_t (**)(void, char *))(v2 + 336))(*(void *)(v2 + 8), __s))
  {
    uint64_t v13 = 1;
    fwrite("can't get temp file.\n", 0x15uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    return v13;
  }
  uint64_t v5 = BOMStorageNewWithOptionsAndSys(__s, v4, (uint64_t (**)(void, const char *, uint64_t, uint64_t))v2);
  if (!v5) {
    return 1;
  }
  uint64_t v6 = v5;
  if (*(_DWORD *)(a1 + 1056))
  {
    unsigned int v7 = 1;
    while (v7 == BOMStorageNewBlock(v6))
    {
      uint64_t v8 = *(void *)(a1 + 1072);
      if (*(unsigned char *)(v8 + 12 * v7 + 8))
      {
        BOMStorageFreeBlock(v6, v7);
      }
      else
      {
        int v9 = BOM_malloc(*(unsigned int *)(v8 + 12 * v7 + 4));
        BOMStorageCopyFromBlock(a1, v7, v9);
        BOMStorageCopyToBlock(v6, v7, v9, *(unsigned int *)(*(void *)(a1 + 1072) + 12 * v7 + 4));
        free(v9);
      }
      if (++v7 > *(_DWORD *)(a1 + 1056)) {
        goto LABEL_16;
      }
    }
    fprintf((FILE *)*MEMORY[0x263EF8348], "unable to reserve block %d.\n");
    return 1;
  }
LABEL_16:
  if (*(_DWORD *)(a1 + 1096))
  {
    size_t v10 = *(unsigned int *)(a1 + 1100);
    *(_DWORD *)(v6 + 1100) = v10;
    if (v10)
    {
      unsigned int v11 = (*(uint64_t (**)(void))(*(void *)(v6 + 1088) + 48))();
      size_t v12 = v10;
      if (!v11)
      {
        unsigned int v11 = *(_DWORD *)(v6 + 1032);
        size_t v12 = v10;
      }
    }
    else
    {
      size_t v12 = 0;
      unsigned int v11 = 0;
    }
    *(_DWORD *)(v6 + 1096) = v11;
    _ExpandMapAddress(v6, v11 + v10);
    memmove((void *)(*(void *)(v6 + 1040) + *(unsigned int *)(v6 + 1096)), (const void *)(*(void *)(a1 + 1040) + *(unsigned int *)(a1 + 1096)), v12);
    _AdjustFileSize(v6, v11, v10);
    if (*(_DWORD *)(v6 + 1028) != -1) {
      _AddToWriteCache(v6, v11, v10);
    }
    *(_DWORD *)(v6 + 1116) = 1;
  }
  BOMStorageCommit(v6);
  unsigned int v14 = BOM_malloc(0x468uLL);
  if (!v14)
  {
    BOMStorageFree((_DWORD *)v6);
    unsigned int v20 = (FILE *)*MEMORY[0x263EF8348];
    int v21 = __error();
    strerror(*v21);
    fprintf(v20, "malloc: %s\n");
    return 1;
  }
  int v15 = v14;
  memcpy(v14, (const void *)a1, 0x468uLL);
  BOMStorageFree(v15);
  if ((*(unsigned int (**)(void, char *, char *))(v2 + 264))(*(void *)(v2 + 8), __s, v24))
  {
    unsigned int v16 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v17 = __error();
    unint64_t v18 = strerror(*v17);
    fprintf(v16, "rename: %s\n", v18);
    BOMStorageFree((_DWORD *)v6);
    uint64_t v13 = 1;
    uint64_t v19 = (void *)BOMStorageOpenWithSys(v24, 1, (void *)v2);
    memcpy((void *)a1, v19, 0x468uLL);
    free(v19);
  }
  else
  {
    memcpy((void *)a1, (const void *)v6, 0x468uLL);
    free((void *)v6);
    return 0;
  }
  return v13;
}

uint64_t BOMStorageDumpFreeList(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 1088) + 64))();
}

void BOMStorageFindActualFreeSpace(uint64_t a1)
{
  int v9 = _newFreeListEntry(0, *(_DWORD *)(a1 + 1032));
  unsigned int v2 = *(_DWORD *)(a1 + 1056);
  if (v2)
  {
    unsigned int v3 = 1;
    do
    {
      uint64_t v4 = *(void *)(a1 + 1072);
      unsigned int v5 = v3;
      if (!*(unsigned char *)(v4 + 12 * v3 + 8))
      {
        _ClearAddress(&v9, *(_DWORD *)(v4 + 12 * v3), *(_DWORD *)(v4 + 12 * v3 + 4));
        unsigned int v2 = *(_DWORD *)(a1 + 1056);
      }
      unsigned int v3 = v5 + 1;
    }
    while (v5 + 1 <= v2);
  }
  _ClearAddress(&v9, *(_DWORD *)(a1 + 1060), *(_DWORD *)(a1 + 1064));
  _ClearAddress(&v9, *(_DWORD *)(a1 + 1096), *(_DWORD *)(a1 + 1100));
  uint64_t v6 = v9;
  if (v9)
  {
    int v7 = 0;
    int v8 = 1;
    do
    {
      printf("Node %u:\n", v8);
      printf("\taddr = %u\n\tuint64_t size = %u\n", v6[2], v6[3]);
      v7 += v6[3];
      uint64_t v6 = *(_DWORD **)v6;
      ++v8;
    }
    while (v6);
    if (v7) {
      printf("======\nTotal free bytes: %u\n", v7);
    }
  }
}

_DWORD *_newFreeListEntry(int a1, int a2)
{
  uint64_t v4 = BOM_malloc(0x10uLL);
  unsigned int v5 = v4;
  if (v4)
  {
    *(void *)uint64_t v4 = 0;
    v4[2] = a1;
    v4[3] = a2;
  }
  else
  {
    uint64_t v6 = (FILE *)*MEMORY[0x263EF8348];
    int v7 = __error();
    int v8 = strerror(*v7);
    fprintf(v6, "malloc: %s\n", v8);
  }
  return v5;
}

void _ClearAddress(void *a1, unsigned int a2, int a3)
{
  if (a2)
  {
    if (a3)
    {
      unsigned int v3 = (_DWORD *)*a1;
      if (*a1)
      {
        unsigned int v5 = 0;
        while (1)
        {
          uint64_t v6 = v3;
          unsigned int v7 = v3[2];
          if (v7 <= a2)
          {
            int v8 = v3[3];
            int v9 = v8 + v7;
            if (v8 + v7 > a2) {
              break;
            }
          }
          unsigned int v3 = *(_DWORD **)v6;
          unsigned int v5 = v6;
          if (!*(void *)v6) {
            return;
          }
        }
        if (v7 == a2)
        {
          int v10 = v8 - a3;
          if (v10)
          {
            v6[2] = a2 + a3;
            _DWORD v6[3] = v10;
          }
          else
          {
            if (!v5) {
              unsigned int v5 = a1;
            }
            void *v5 = *(void *)v6;
            free(v6);
          }
        }
        else
        {
          int v11 = a3 + a2;
          int v12 = v9 - (a3 + a2);
          if (v9 == v11)
          {
            _DWORD v6[3] = v8 - a3;
          }
          else
          {
            uint64_t v13 = _newFreeListEntry(v11, v12);
            if (v13)
            {
              *(void *)uint64_t v13 = *(void *)v6;
              _DWORD v6[3] = a2 - v6[2];
              *(void *)uint64_t v6 = v13;
            }
            else
            {
              int v14 = *__error();
              _BOMExceptionHandlerCall((uint64_t)"Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 1750, v14);
            }
          }
        }
      }
    }
  }
}

uint64_t _BOMStoragePrintDiagnostics(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = (FILE **)MEMORY[0x263EF8348];
    fprintf((FILE *)*MEMORY[0x263EF8348], "   # blocks : %d\n", *(_DWORD *)(result + 1056));
    fprintf(*v2, "   adm size : %d\n", *(_DWORD *)(v1 + 1064));
    fprintf(*v2, "   bt size  : %d\n", (8 * *(_DWORD *)(v1 + 1068)) | 4);
    fprintf(*v2, "   fl size  : %d\n", *(_DWORD *)(*(void *)(v1 + 1088) + 8));
    return fprintf(*v2, "   toc size : %d\n", *(_DWORD *)(v1 + 1100));
  }
  return result;
}

uint64_t BOMStorageDump(uint64_t a1, int a2)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 1096);
  if (!v3) {
    return 1;
  }
  unint64_t v5 = *(unsigned int *)(a1 + 1100);
  if (!v5) {
    return 1;
  }
  uint64_t v6 = BOMStreamWithAddress(*(void *)(a1 + 1040) + v3, v5, 0);
  if (!v6) {
    return 2;
  }
  uint64_t v7 = (uint64_t)v6;
  int UInt32 = BOMStreamReadUInt32((uint64_t)v6);
  if (*(unsigned char *)(a1 + 1052))
  {
    if (*(_DWORD *)(a1 + 1116)) {
      int v9 = "read/write [dirty]";
    }
    else {
      int v9 = "read/write";
    }
  }
  else
  {
    int v9 = "readonly";
  }
  int v12 = (FILE **)MEMORY[0x263EF8358];
  fprintf((FILE *)*MEMORY[0x263EF8358], "Storage: open %s (%u blocks)\n", v9, *(_DWORD *)(a1 + 1056));
  fprintf(*v12, "    ToC: %u entries (%u bytes)\n", UInt32, *(_DWORD *)(a1 + 1100));
  if (!UInt32)
  {
    uint64_t v10 = 0;
    goto LABEL_67;
  }
  int v26 = 0;
  do
  {
    BOMStreamReadUInt32(v7);
    unsigned int UInt8 = BOMStreamReadUInt8(v7);
    BOMStreamReadBuffer(v7, &__dst, UInt8);
    *((unsigned char *)&__dst + UInt8) = 0;
    int v14 = *v12;
    if (a2) {
      fprintf(v14, "    Bid: 0x%08x (%u) '%s' (%lu bytes)");
    }
    else {
      fprintf(v14, "    Bid: '%s' (%lu bytes)");
    }
    if ((void)__dst == 0x6F666E496D6F42
      || (__dst == 1752457552 ? (BOOL v15 = WORD2(__dst) == 115) : (BOOL v15 = 0),
          v15
       || (void)__dst == 0x7865646E494C48
       || (__dst == 1684949334 ? (BOOL v16 = *(_DWORD *)((char *)&__dst + 3) == 7890276) : (BOOL v16 = 0),
           v16 || (__dst == 1702521171 ? (BOOL v17 = *(_DWORD *)((char *)&__dst + 3) == 3421797) : (BOOL v17 = 0), v17))))
    {
      fwrite(" [BOM]\n", 7uLL, 1uLL, *v12);
      goto LABEL_54;
    }
    if ((void)__dst == 0x547463656A6F7250 && *((void *)&__dst + 1) == 0x656C6261546761)
    {
      fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
      v26 |= 0x10u;
      uint64_t v23 = a1;
      p_dst = "ProjectTagTable";
    }
    else if ((void)__dst == 0x546567616B636150 && *((void *)&__dst + 1) == 0x656C6261546761)
    {
      fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
      v26 |= 0x20u;
      uint64_t v23 = a1;
      p_dst = "PackageTagTable";
    }
    else
    {
      if ((void)__dst != 0x5467615468746150 || *(void *)((char *)&__dst + 5) != 0x656C6261546761)
      {
        if ((void)__dst == 0x547463656A6F7250 && *((void *)&__dst + 1) == 0x657254687461506FLL && v28 == 101)
        {
          fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
          v26 |= 0x80u;
          uint64_t v23 = a1;
          p_dst = "ProjectToPathTree";
          unsigned int v25 = a2 | 0x1310000;
        }
        else
        {
          if ((v26 & 0x20) == 0)
          {
            fputc(10, *v12);
            goto LABEL_54;
          }
          fwrite(" [Package]\n", 0xBuLL, 1uLL, *v12);
          p_dst = (const char *)&__dst;
          uint64_t v23 = a1;
          unsigned int v25 = a2 | 0x230000;
        }
        goto LABEL_60;
      }
      fwrite(" [Metabom]\n", 0xBuLL, 1uLL, *v12);
      v26 |= 0x40u;
      uint64_t v23 = a1;
      p_dst = "PathTagTable";
    }
    unsigned int v25 = a2 | 0x210000;
LABEL_60:
    BOMStorageDumpTree(v23, p_dst, v25);
LABEL_54:
    --UInt32;
  }
  while (UInt32);
  uint64_t v10 = 0;
  if ((v26 & 0xF0) != 0 && (v26 & 0xF0) != 0xF0)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "WARNING: file appears to be a corrupt Metabom! (found %04x expected %04x or %04x)\n", v26 & 0xF0, 240, 0);
    uint64_t v10 = 3;
  }
LABEL_67:
  BOMStreamFree(v7);
  return v10;
}

uint64_t _WriteAddress(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = (int *)BOMStreamWithFile(*(_DWORD *)(a1 + 1028), a2, a3, 1, (char *)(*(void *)(a1 + 1040) + a2));
  if (v3)
  {
    uint64_t v4 = (uint64_t)v3;
    BOMStreamFlush(v3);
    return BOMStreamFree(v4);
  }
  else
  {
    int v6 = *__error();
    return _BOMExceptionHandlerCall((uint64_t)"Unable to create write stream.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStorage.c", 2141, v6);
  }
}

BOOL BOMCKTreeBuildKey(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9)
{
  return _buildKey(a1, &a9) != 0;
}

uint64_t _buildKey(char *a1, char **a2)
{
  *a1 = 0;
  int v9 = a2 + 1;
  unsigned int v2 = *a2;
  if (!*a2) {
    return 0;
  }
  unsigned int v4 = 0;
  char v5 = 1;
  while (1)
  {
    if ((v5 & 1) == 0)
    {
      if (v4 >= 0x3FF) {
        break;
      }
      *(_WORD *)&a1[v4++] = 47;
    }
    if (strchr(v2, 47))
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "invalid key segment: '%s'\n", v2);
      return 1;
    }
    v4 += strlen(v2);
    if (v4 >= 0x400) {
      break;
    }
    strlcat(a1, v2, 0x400uLL);
    char v5 = 0;
    int v6 = v9++;
    unsigned int v2 = *v6;
    if (!*v6)
    {
      if (v4 < 0x3FF) {
        return 0;
      }
      break;
    }
  }
  uint64_t v7 = 1;
  fwrite("key too long\n", 0xDuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return v7;
}

uint64_t BOMCKTreeCount(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  BOOL v21 = 0;
  uint64_t v22 = &a9;
  uint64_t v10 = 0;
  if (!_buildKey(__s, &a9))
  {
    LODWORD(v11) = strlen(__s);
    size_t v12 = (v11 + 1);
    uint64_t v13 = (char *)BOMTreeIteratorNew(a1, __s, v12, &v21);
    if (v13)
    {
      int v14 = v13;
      if (!v21)
      {
        if (!BOMTreeIteratorKey((uint64_t)v13) || (__strlcpy_chk(), strlen(__s1) == v11))
        {
          uint64_t v10 = 0;
          goto LABEL_9;
        }
        if (v11)
        {
          if ((unint64_t)__strlcat_chk() >= 0x400) {
            size_t v11 = v11;
          }
          else {
            size_t v11 = v12;
          }
        }
        else
        {
          size_t v11 = 0;
        }
        BOOL v16 = strchr(&__s1[v11], 47);
        if (v16) {
          v16[1] = 0;
        }
        unsigned int v17 = strlen(__s1);
        BOMTreeIteratorNext((uint64_t)v14);
        if (!BOMTreeIteratorIsAtEnd((uint64_t)v14))
        {
          size_t v18 = v17;
          uint64_t v10 = 1;
          do
          {
            uint64_t v19 = (const char *)BOMTreeIteratorKey((uint64_t)v14);
            if (strncmp(__s, v19, v11)) {
              break;
            }
            if (strncmp(__s1, v19, v18))
            {
              __strlcpy_chk();
              unsigned int v20 = strchr(&__s1[v11], 47);
              if (v20) {
                v20[1] = 0;
              }
              size_t v18 = strlen(__s1);
              uint64_t v10 = (v10 + 1);
            }
            BOMTreeIteratorNext((uint64_t)v14);
          }
          while (!BOMTreeIteratorIsAtEnd((uint64_t)v14));
          goto LABEL_9;
        }
      }
      uint64_t v10 = 1;
LABEL_9:
      BOMTreeIteratorFree(v14);
      return v10;
    }
    return 0;
  }
  return v10;
}

char *BOMCKTreeGet(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  BOOL v23 = 0;
  BOOL v24 = &a9;
  size_t v11 = 0;
  if (!_buildKey(__s, &a9))
  {
    int v12 = strlen(__s);
    size_t v13 = (v12 + 1);
    int v14 = (char *)BOMTreeIteratorNew(a1, __s, v13, &v23);
    if (v14)
    {
      BOOL v15 = v14;
      if (v23)
      {
        size_t v11 = (char *)BOMTreeIteratorValue((uint64_t)v14);
      }
      else
      {
        if (BOMTreeIteratorKey((uint64_t)v14))
        {
          __strlcpy_chk();
          if (v12) {
            __strlcat_chk();
          }
          else {
            size_t v13 = 0;
          }
          size_t v11 = &BOMCKTreeGet_next[v13];
          BOOL v16 = strchr(&BOMCKTreeGet_next[v13], 47);
          if (v16) {
            v16[1] = 0;
          }
          if (!a2)
          {
LABEL_21:
            BOOL v21 = strchr(&BOMCKTreeGet_next[v13], 47);
            if (v21) {
              *BOOL v21 = 0;
            }
            goto LABEL_24;
          }
          int v17 = 0;
          size_t v18 = strlen(BOMCKTreeGet_next);
          while (!BOMTreeIteratorIsAtEnd((uint64_t)v15))
          {
            uint64_t v19 = (const char *)BOMTreeIteratorKey((uint64_t)v15);
            if (strncmp(__s, v19, v13)) {
              break;
            }
            if (strncmp(BOMCKTreeGet_next, v19, v18))
            {
              __strlcpy_chk();
              unsigned int v20 = strchr(&BOMCKTreeGet_next[v13], 47);
              if (v20) {
                v20[1] = 0;
              }
              size_t v18 = strlen(BOMCKTreeGet_next);
              ++v17;
            }
            BOMTreeIteratorNext((uint64_t)v15);
            if (v17 == a2) {
              goto LABEL_21;
            }
          }
        }
        size_t v11 = 0;
      }
LABEL_24:
      BOMTreeIteratorFree(v15);
      return v11;
    }
    return 0;
  }
  return v11;
}

_DWORD *platform_toolbox_new(uint64_t a1)
{
  if (a1) {
    return 0;
  }
  uint64_t result = malloc_type_calloc(1uLL, 0xD0uLL, 0x1080040013202F3uLL);
  if (result)
  {
    *uint64_t result = 1885499256;
    result[50] = 2020565616;
  }
  return result;
}

void platform_toolbox_free(void *a1)
{
  if (a1 && *(_DWORD *)a1 == 1885499256 && *((_DWORD *)a1 + 50) == 2020565616)
  {
    *((_OWORD *)a1 + 11) = 0u;
    *((_OWORD *)a1 + 12) = 0u;
    *((_OWORD *)a1 + 9) = 0u;
    *((_OWORD *)a1 + 10) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *(_OWORD *)a1 = 0u;
    free(a1);
  }
}

void *platform_malloc(uint64_t a1, size_t size)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 4);
  if (!v4) {
    goto LABEL_7;
  }
  int v5 = *(_DWORD *)(a1 + 8);
  if (!v5)
  {
    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
    return 0;
  }
  *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
  int v6 = *(uint64_t (**)(uint64_t, uint64_t, size_t))(a1 + 24);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    return (void *)v6(a1, v7, size);
  }
LABEL_11:
  return malloc_type_malloc(size, 0x7F3F82F6uLL);
}

void platform_free(uint64_t a1, void *a2)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return;
  }
  int v4 = *(_DWORD *)(a1 + 4);
  if (v4)
  {
    int v5 = *(_DWORD *)(a1 + 8);
    if (!v5)
    {
      *__error() = v4;
      *(_DWORD *)(a1 + 4) = 0;
      return;
    }
    *(_DWORD *)(a1 + 8) = v5 - 1;
  }
  int v6 = *(void (**)(uint64_t, uint64_t, void *))(a1 + 32);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    v6(a1, v7, a2);
  }
  else
  {
LABEL_11:
    free(a2);
  }
}

void *platform_calloc(uint64_t a1, size_t count, size_t size)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0;
  }
  int v6 = *(_DWORD *)(a1 + 4);
  if (!v6) {
    goto LABEL_7;
  }
  int v7 = *(_DWORD *)(a1 + 8);
  if (!v7)
  {
    *__error() = v6;
    *(_DWORD *)(a1 + 4) = 0;
    return 0;
  }
  *(_DWORD *)(a1 + 8) = v7 - 1;
LABEL_7:
  int v8 = *(uint64_t (**)(uint64_t, uint64_t, size_t, size_t))(a1 + 40);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 16);
    return (void *)v8(a1, v9, count, size);
  }
LABEL_11:
  return malloc_type_calloc(count, size, 0x384D96BCuLL);
}

void *platform_valloc(uint64_t a1, size_t size)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 4);
  if (!v4) {
    goto LABEL_7;
  }
  int v5 = *(_DWORD *)(a1 + 8);
  if (!v5)
  {
    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
    return 0;
  }
  *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
  int v6 = *(uint64_t (**)(uint64_t, uint64_t, size_t))(a1 + 48);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    return (void *)v6(a1, v7, size);
  }
LABEL_11:
  return malloc_type_valloc(size, 0x13EF63B8uLL);
}

void *platform_realloc(uint64_t a1, void *ptr, size_t size)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0;
  }
  int v6 = *(_DWORD *)(a1 + 4);
  if (!v6) {
    goto LABEL_7;
  }
  int v7 = *(_DWORD *)(a1 + 8);
  if (!v7)
  {
    *__error() = v6;
    *(_DWORD *)(a1 + 4) = 0;
    return 0;
  }
  *(_DWORD *)(a1 + 8) = v7 - 1;
LABEL_7:
  int v8 = *(uint64_t (**)(uint64_t, uint64_t, void *, size_t))(a1 + 56);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 16);
    return (void *)v8(a1, v9, ptr, size);
  }
LABEL_11:
  return malloc_type_realloc(ptr, size, 0xF43CA519uLL);
}

void *platform_memset(uint64_t a1, void *__b, uint64_t __c, size_t __len)
{
  int v4 = __b;
  if (!a1) {
    goto LABEL_12;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0;
  }
  int v6 = *(_DWORD *)(a1 + 4);
  if (v6)
  {
    int v7 = *(_DWORD *)(a1 + 8);
    if (!v7)
    {
      int v4 = 0;
      *__error() = v6;
      *(_DWORD *)(a1 + 4) = 0;
      return v4;
    }
    *(_DWORD *)(a1 + 8) = v7 - 1;
  }
  int v8 = *(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t, size_t))(a1 + 64);
  if (!v8)
  {
LABEL_12:
    memset(__b, __c, __len);
    return v4;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  return (void *)v8(a1, v9, v4, __c, __len);
}

void *platform_memcpy(uint64_t a1, void *__dst, void *__src, size_t __n)
{
  int v4 = __dst;
  if (!a1) {
    goto LABEL_12;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0;
  }
  int v6 = *(_DWORD *)(a1 + 4);
  if (v6)
  {
    int v7 = *(_DWORD *)(a1 + 8);
    if (!v7)
    {
      int v4 = 0;
      *__error() = v6;
      *(_DWORD *)(a1 + 4) = 0;
      return v4;
    }
    *(_DWORD *)(a1 + 8) = v7 - 1;
  }
  int v8 = *(uint64_t (**)(uint64_t, uint64_t, void *, void *, size_t))(a1 + 72);
  if (!v8)
  {
LABEL_12:
    memcpy(__dst, __src, __n);
    return v4;
  }
  uint64_t v9 = *(void *)(a1 + 16);
  return (void *)v8(a1, v9, v4, __src, __n);
}

uint64_t platform_memcmp(uint64_t a1, void *__s1, void *__s2, size_t __n)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0xFFFFFFFFLL;
  }
  int v8 = *(_DWORD *)(a1 + 4);
  if (!v8) {
    goto LABEL_7;
  }
  int v9 = *(_DWORD *)(a1 + 8);
  if (!v9)
  {
    *__error() = v8;
    *(_DWORD *)(a1 + 4) = 0;
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v9 - 1;
LABEL_7:
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, void *, void *, size_t))(a1 + 80);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    return v10(a1, v11, __s1, __s2, __n);
  }
LABEL_11:
  return memcmp(__s1, __s2, __n);
}

size_t platform_strlen(uint64_t a1, char *__s)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return -1;
  }
  int v4 = *(_DWORD *)(a1 + 4);
  if (!v4) {
    goto LABEL_7;
  }
  int v5 = *(_DWORD *)(a1 + 8);
  if (!v5)
  {
    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
    return -1;
  }
  *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
  int v6 = *(uint64_t (**)(uint64_t, uint64_t, char *))(a1 + 88);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    return v6(a1, v7, __s);
  }
LABEL_11:
  return strlen(__s);
}

size_t platform_strnlen(uint64_t a1, char *__s1, size_t __n)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return -1;
  }
  int v6 = *(_DWORD *)(a1 + 4);
  if (!v6) {
    goto LABEL_7;
  }
  int v7 = *(_DWORD *)(a1 + 8);
  if (!v7)
  {
    *__error() = v6;
    *(_DWORD *)(a1 + 4) = 0;
    return -1;
  }
  *(_DWORD *)(a1 + 8) = v7 - 1;
LABEL_7:
  int v8 = *(uint64_t (**)(uint64_t, uint64_t, char *, size_t))(a1 + 96);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 16);
    return v8(a1, v9, __s1, __n);
  }
LABEL_11:
  return strnlen(__s1, __n);
}

uint64_t platform_strncmp(uint64_t a1, char *__s1, char *__s2, size_t __n)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0xFFFFFFFFLL;
  }
  int v8 = *(_DWORD *)(a1 + 4);
  if (!v8) {
    goto LABEL_7;
  }
  int v9 = *(_DWORD *)(a1 + 8);
  if (!v9)
  {
    *__error() = v8;
    *(_DWORD *)(a1 + 4) = 0;
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v9 - 1;
LABEL_7:
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, char *, char *, size_t))(a1 + 104);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    return v10(a1, v11, __s1, __s2, __n);
  }
LABEL_11:
  return strncmp(__s1, __s2, __n);
}

char *platform_strdup(uint64_t a1, char *__s1)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0;
  }
  int v4 = *(_DWORD *)(a1 + 4);
  if (!v4) {
    goto LABEL_7;
  }
  int v5 = *(_DWORD *)(a1 + 8);
  if (!v5)
  {
    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
    return 0;
  }
  *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
  int v6 = *(uint64_t (**)(uint64_t, uint64_t, char *))(a1 + 120);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    return (char *)v6(a1, v7, __s1);
  }
LABEL_11:
  return strdup(__s1);
}

uint64_t platform_strtoq(uint64_t a1, char *__str, char **__endptr, uint64_t __base)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return -1;
  }
  int v8 = *(_DWORD *)(a1 + 4);
  if (!v8) {
    goto LABEL_7;
  }
  int v9 = *(_DWORD *)(a1 + 8);
  if (!v9)
  {
    *__error() = v8;
    *(_DWORD *)(a1 + 4) = 0;
    return -1;
  }
  *(_DWORD *)(a1 + 8) = v9 - 1;
LABEL_7:
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, char *, char **, uint64_t))(a1 + 136);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    return v10(a1, v11, __str, __endptr, __base);
  }
LABEL_11:
  return strtoq(__str, __endptr, __base);
}

ssize_t platform_read(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return -1;
  }
  int v8 = *(_DWORD *)(a1 + 4);
  if (!v8) {
    goto LABEL_7;
  }
  int v9 = *(_DWORD *)(a1 + 8);
  if (!v9)
  {
    *__error() = v8;
    *(_DWORD *)(a1 + 4) = 0;
    return -1;
  }
  *(_DWORD *)(a1 + 8) = v9 - 1;
LABEL_7:
  uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *, size_t))(a1 + 168);
  if (v10)
  {
    uint64_t v11 = *(void *)(a1 + 16);
    return v10(a1, v11, a2, a3, a4);
  }
LABEL_11:
  return read(a2, a3, a4);
}

uint64_t platform_close(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return 0xFFFFFFFFLL;
  }
  int v4 = *(_DWORD *)(a1 + 4);
  if (!v4) {
    goto LABEL_7;
  }
  int v5 = *(_DWORD *)(a1 + 8);
  if (!v5)
  {
    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
  int v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 176);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    return v6(a1, v7, a2);
  }
LABEL_11:
  return close(a2);
}

time_t platform_mktime(uint64_t a1, tm *a2)
{
  if (!a1) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a1 != 1885499256 || *(_DWORD *)(a1 + 200) != 2020565616) {
    return -1;
  }
  int v4 = *(_DWORD *)(a1 + 4);
  if (!v4) {
    goto LABEL_7;
  }
  int v5 = *(_DWORD *)(a1 + 8);
  if (!v5)
  {
    *__error() = v4;
    *(_DWORD *)(a1 + 4) = 0;
    return -1;
  }
  *(_DWORD *)(a1 + 8) = v5 - 1;
LABEL_7:
  int v6 = *(uint64_t (**)(uint64_t, uint64_t, tm *))(a1 + 184);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    return v6(a1, v7, a2);
  }
LABEL_11:
  return mktime(a2);
}

void *BOMTreeNew(uint64_t a1, unsigned int a2)
{
  if (a1 && a2) {
    return _BOMTreeNew(a1, 0, a2, 0, 0);
  }
  else {
    return 0;
  }
}

void *_BOMTreeNew(uint64_t a1, const char *a2, unsigned int a3, int a4, char a5)
{
  uint64_t result = _newBOMTree(a1, a2);
  if (result)
  {
    uint64_t v11 = (uint64_t)result;
    *((_DWORD *)result + 4) = a3;
    if (a4) {
      int v12 = a4;
    }
    else {
      int v12 = 4096;
    }
    *((_DWORD *)result + 78) = v12;
    unsigned int v13 = v12 - 16;
    *((_DWORD *)result + 79) = v13 >> 3;
    *((_DWORD *)result + 80) = (v13 >> 3) + 1;
    *((_DWORD *)result + 81) = v13 >> 4;
    *((unsigned char *)result + 294) = a5;
    int v14 = _NewPage((uint64_t)result, 0);
    *(void *)(v11 + 24) = v14;
    *((_WORD *)v14 + 2) |= 1u;
    *(unsigned char *)(v11 + 292) = 1;
    BOMTreeFree(v11);
    return (void *)_BOMTreeOpen(a1, a2, a3, 1);
  }
  return result;
}

void *BOMTreeNewWithName(uint64_t a1, const char *a2)
{
  if (!a1) {
    return 0;
  }
  if (!a2) {
    return 0;
  }
  unsigned int v4 = BOMStorageNewNamedBlock(a1, a2);
  if (!v4) {
    return 0;
  }
  return _BOMTreeNew(a1, a2, v4, 0, 0);
}

void *BOMTreeNewWithOptions(uint64_t a1, unsigned int a2, const char *a3, unsigned int a4, char a5)
{
  if (!a1) {
    return 0;
  }
  int v6 = a4;
  unsigned int v8 = a2;
  if (!a2 && !a3) {
    return 0;
  }
  if (a4)
  {
    if (a4 < 0x30) {
      return 0;
    }
    if (!a2)
    {
LABEL_9:
      unsigned int v8 = BOMStorageNewNamedBlock(a1, a3);
      if (v8) {
        goto LABEL_10;
      }
      return 0;
    }
  }
  else
  {
    int v6 = 4096;
    if (!a2) {
      goto LABEL_9;
    }
  }
LABEL_10:
  return _BOMTreeNew(a1, a3, v8, v6, a5);
}

uint64_t BOMTreeOpen(uint64_t a1, unsigned int a2, char a3)
{
  if (a1 && a2) {
    return _BOMTreeOpen(a1, 0, a2, a3);
  }
  else {
    return 0;
  }
}

uint64_t _BOMTreeOpen(uint64_t a1, const char *a2, unsigned int a3, char a4)
{
  uint64_t v7 = a1;
  uint64_t v17 = *MEMORY[0x263EF8340];
  unsigned int v8 = _newBOMTree(a1, a2);
  uint64_t v9 = (uint64_t)v8;
  if (v8)
  {
    *unsigned int v8 = v7;
    *((_DWORD *)v8 + 4) = a3;
    if (!a2)
    {
      snprintf(__str, 0x100uLL, "<Tree %d>", a3);
      uint64_t v7 = *(void *)v9;
      a3 = *(_DWORD *)(v9 + 16);
    }
    uint64_t v10 = BOMStreamWithBlockID(v7, a3, 0, 0);
    if (!v10) {
      goto LABEL_13;
    }
    uint64_t v11 = v10;
    if (BOMStreamReadUInt32(v10) == 1953654117)
    {
      if (BOMStreamReadUInt32(v11) == 1)
      {
        int UInt32 = BOMStreamReadUInt32(v11);
        *(_DWORD *)(v9 + 312) = BOMStreamReadUInt32(v11);
        *(_DWORD *)(v9 + 20) = BOMStreamReadUInt32(v11);
        *(unsigned char *)(v9 + 294) = BOMStreamReadUInt8(v11);
        BOMStreamFree(v11);
        unsigned int v13 = *(_DWORD *)(v9 + 312) - 16;
        *(_DWORD *)(v9 + 316) = v13 >> 3;
        *(_DWORD *)(v9 + 320) = (v13 >> 3) + 1;
        *(_DWORD *)(v9 + 324) = v13 >> 4;
        int v14 = _NewPage(v9, UInt32);
        *(void *)(v9 + 24) = v14;
        if (v14 && !_ReadPage(v9, (uint64_t)v14))
        {
          *(unsigned char *)(v9 + 293) = a4;
          return v9;
        }
LABEL_13:
        BOMTreeFree(v9);
        return 0;
      }
      fprintf((FILE *)*MEMORY[0x263EF8348], "Tree '%s' has an unknown version: 0x%X\n");
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "%s is not a Tree\n");
    }
    BOMStreamFree(v11);
    goto LABEL_13;
  }
  return v9;
}

uint64_t BOMTreeOpenWithName(uint64_t a1, const char *a2, char a3)
{
  if (!a1) {
    return 0;
  }
  if (!a2) {
    return 0;
  }
  unsigned int NamedBlock = BOMStorageGetNamedBlock(a1, a2);
  if (!NamedBlock) {
    return 0;
  }
  return _BOMTreeOpen(a1, a2, NamedBlock, a3);
}

uint64_t BOMTreeFree(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 292) && BOMTreeCommit(result))
    {
      return 1;
    }
    else
    {
      for (uint64_t i = 32; i != 288; i += 8)
      {
        uint64_t v3 = *(_WORD **)(v1 + i);
        if (v3)
        {
          if ((v3[2] & 2) != 0) {
            _WritePage(v1, *(void *)(v1 + i));
          }
          _FreePage(v3);
          *(void *)(v1 + i) = 0;
        }
      }
      _FreePage(*(void **)(v1 + 24));
      *(void *)(v1 + 24) = 0;
      unsigned int v4 = *(void **)(v1 + 8);
      if (v4)
      {
        free(v4);
        *(void *)(v1 + 8) = 0;
      }
      int v5 = *(const void **)(v1 + 304);
      if (v5)
      {
        CFRelease(v5);
        *(void *)(v1 + 304) = 0;
      }
      int v6 = *(void **)(v1 + 344);
      if (v6)
      {
        free(v6);
        *(void *)(v1 + 344) = 0;
      }
      uint64_t v7 = *(void **)(v1 + 328);
      if (v7) {
        free(v7);
      }
      free((void *)v1);
      return 0;
    }
  }
  return result;
}

uint64_t BOMTreeCommit(uint64_t a1)
{
  if (!a1 || !*(unsigned char *)(a1 + 292)) {
    return 0;
  }
  _SyncCache(a1);
  _WritePage(a1, *(void *)(a1 + 24));
  uint64_t v2 = 1;
  uint64_t v3 = BOMStreamWithBlockID(*(void *)a1, *(_DWORD *)(a1 + 16), 0x15uLL, 1);
  if (v3)
  {
    uint64_t v4 = v3;
    BOMStreamWriteUInt32(v3, 0x74726565u);
    BOMStreamWriteUInt32(v4, 1u);
    BOMStreamWriteUInt32(v4, **(_DWORD **)(a1 + 24));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a1 + 312));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a1 + 20));
    BOMStreamWriteUInt8(v4, *(unsigned char *)(a1 + 294));
    if (!BOMStreamFree(v4))
    {
      uint64_t v2 = 0;
      *(unsigned char *)(a1 + 292) = 0;
    }
  }
  return v2;
}

void _FreePage(void *a1)
{
  if (a1)
  {
    *(_DWORD *)a1 = -1;
    *((void *)a1 + 1) = -1;
    free(*((void **)a1 + 3));
    *((void *)a1 + 3) = 0;
    free(*((void **)a1 + 4));
    free(a1);
  }
}

uint64_t BOMTreeRemoveAndFree(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)result;
    uint64_t v3 = (char *)BOMTreeIteratorNew(result, 0, 0, 0);
    if (v3)
    {
      for (uint64_t i = v3; !BOMTreeIteratorIsAtEnd((uint64_t)i); BOMTreeIteratorNext((uint64_t)i))
      {
        int v5 = (const void *)BOMTreeIteratorKey((uint64_t)i);
        size_t v6 = BOMTreeIteratorKeySize((uint64_t)i);
        BOMTreeRemoveValue(v1, v5, v6);
      }
      BOMTreeIteratorFree(i);
      BOMStorageFreeBlock(v2, **(_DWORD **)(v1 + 24));
      _FreePage(*(void **)(v1 + 24));
      *(void *)(v1 + 24) = 0;
      uint64_t v7 = *(const char **)(v1 + 8);
      if (v7) {
        BOMStorageFreeNamedBlock(v2, v7);
      }
      else {
        BOMStorageFreeBlock(v2, *(_DWORD *)(v1 + 16));
      }
      unsigned int v8 = *(void **)(v1 + 8);
      if (v8)
      {
        free(v8);
        *(void *)(v1 + 8) = 0;
      }
      uint64_t v9 = *(const void **)(v1 + 304);
      if (v9) {
        CFRelease(v9);
      }
      free((void *)v1);
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void *BOMTreeIteratorNew(uint64_t a1, const void *a2, size_t a3, BOOL *a4)
{
  unsigned int v8 = BOM_malloczero(0x48uLL);
  uint64_t v9 = v8;
  if (v8)
  {
    *unsigned int v8 = a1;
    BOMTreeIteratorSet((uint64_t)v8, a2, a3, a4);
    CFArrayRef v10 = *(const __CFArray **)(a1 + 304);
    if (v10)
    {
      CFIndex v11 = BOMCFArrayMaxRange(v10);
      CFIndex v13 = v12;
      v17.location = v11;
      v17.size_t length = v13;
      if (CFArrayContainsValue(*(CFArrayRef *)(a1 + 304), v17, v9))
      {
LABEL_8:
        void v9[3] = BOM_malloc(v9[4]);
        v9[6] = BOM_malloc(v9[7]);
        return v9;
      }
      CFMutableDictionaryRef Mutable = *(__CFArray **)(a1 + 304);
    }
    else
    {
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, 0);
      *(void *)(a1 + 304) = Mutable;
      if (!Mutable)
      {
        BOOL v15 = __error();
        _BOMExceptionHandlerCall((uint64_t)"Out of memory.", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 2460, *v15);
        goto LABEL_8;
      }
    }
    CFArrayAppendValue(Mutable, v9);
    goto LABEL_8;
  }
  return v9;
}

uint64_t BOMTreeIteratorIsAtEnd(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 67)) {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 65))
  {
    uint64_t v3 = *(_DWORD **)(a1 + 8);
    if (v3)
    {
      if (*v3 == *(_DWORD *)(a1 + 16)) {
        return 0;
      }
    }
  }
  if (_revalidateIterator(a1)) {
    return *(unsigned __int8 *)(a1 + 67);
  }
  uint64_t result = 1;
  *(unsigned char *)(a1 + 67) = 1;
  return result;
}

uint64_t BOMTreeIteratorKey(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 67)) {
      return 0;
    }
    if ((*(unsigned char *)(result + 65) || (uint64_t v2 = *(_DWORD **)(result + 8)) == 0 || *v2 != *(_DWORD *)(result + 16))
      && !_revalidateIterator(result))
    {
      uint64_t result = 0;
      *(unsigned char *)(v1 + 67) = 1;
      return result;
    }
    if (*(unsigned char *)(*(void *)v1 + 294)) {
      return *(unsigned int *)(*(void *)(*(void *)(v1 + 8) + 24) + 4 * *(unsigned int *)(v1 + 20));
    }
    if (!*(unsigned char *)(v1 + 40))
    {
      unint64_t v3 = BOMStorageSizeOfBlock(**(void **)v1, *(_DWORD *)(*(void *)(*(void *)(v1 + 8) + 24) + 4 * *(unsigned int *)(v1 + 20)));
      uint64_t v4 = *(void **)(v1 + 24);
      unint64_t v5 = *(void *)(v1 + 32);
      if (v3 > v5)
      {
        unint64_t v6 = v3;
        if (v4)
        {
          free(*(void **)(v1 + 24));
          *(void *)(v1 + 24) = 0;
          unint64_t v5 = *(void *)(v1 + 32);
        }
        if (v6 <= 2 * v5) {
          size_t v7 = 2 * v5;
        }
        else {
          size_t v7 = v6;
        }
        *(void *)(v1 + 32) = v7;
        uint64_t v4 = BOM_malloc(v7);
        *(void *)(v1 + 24) = v4;
      }
      if (BOMStorageCopyFromBlock(**(void **)v1, *(_DWORD *)(*(void *)(*(void *)(v1 + 8) + 24) + 4 * *(unsigned int *)(v1 + 20)), v4))return 0; {
      *(unsigned char *)(v1 + 40) = 1;
      }
    }
    return *(void *)(v1 + 24);
  }
  return result;
}

uint64_t BOMTreeIteratorKeySize(uint64_t a1)
{
  if (!a1 || *(unsigned char *)(a1 + 67)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 65) || (unint64_t v3 = *(_DWORD **)(a1 + 8)) == 0 || *v3 != *(_DWORD *)(a1 + 16))
    && !_revalidateIterator(a1))
  {
    *(unsigned char *)(a1 + 67) = 1;
    return 0;
  }
  if (*(unsigned char *)(*(void *)a1 + 294)) {
    return 0;
  }
  uint64_t v4 = **(void **)a1;
  unsigned int v5 = *(_DWORD *)(*(void *)(*(void *)(a1 + 8) + 24) + 4 * *(unsigned int *)(a1 + 20));
  return BOMStorageSizeOfBlock(v4, v5);
}

uint64_t BOMTreeRemoveValue(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v3 = 1;
  if (a1 && a2)
  {
    if (a3 || *(unsigned char *)(a1 + 294))
    {
      if (*(unsigned char *)(a1 + 293))
      {
        uint64_t v6 = *(void *)(a1 + 24);
        uint64_t v3 = _findRemove(a1, &v6, 0, 0, 0, 0, a2, a3, 0);
        if (!v3)
        {
          --*(_DWORD *)(a1 + 20);
          *(unsigned char *)(a1 + 292) = 1;
        }
      }
      else
      {
        uint64_t v3 = 1;
        fwrite("tree is read-only\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
      }
    }
    else
    {
      return 1;
    }
  }
  return v3;
}

uint64_t BOMTreeIteratorNext(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!*(unsigned char *)(result + 67))
    {
      if (!*(unsigned char *)(result + 65) && (unsigned int v5 = *(_DWORD **)(result + 8)) != 0 && *v5 == *(_DWORD *)(result + 16)
        || (uint64_t result = _revalidateIterator(result), result))
      {
        if (*(unsigned char *)(v1 + 66))
        {
          unsigned int v2 = *(_DWORD *)(v1 + 20) + 1;
          *(_DWORD *)(v1 + 20) = v2;
          uint64_t v3 = *(void *)(v1 + 8);
          if (v2 >= *(unsigned __int16 *)(v3 + 16))
          {
            *(_DWORD *)(v1 + 20) = 0;
            int v4 = *(_DWORD *)(v3 + 8);
            if (!v4
              || (*(_DWORD *)(v1 + 16) = v4,
                  uint64_t result = (uint64_t)_findPage(*(void *)v1, v4),
                  (*(void *)(v1 + 8) = result) == 0))
            {
              *(unsigned char *)(v1 + 67) = 1;
            }
          }
        }
        else
        {
          *(unsigned char *)(v1 + 66) = 1;
        }
        *(unsigned char *)(v1 + 40) = 0;
        *(unsigned char *)(v1 + 64) = 0;
      }
      else
      {
        *(unsigned char *)(v1 + 67) = 1;
      }
    }
  }
  return result;
}

void BOMTreeIteratorFree(char *a1)
{
  if (a1)
  {
    *(_WORD *)(a1 + 65) = 1;
    a1[67] = 1;
    unsigned int v2 = (void *)*((void *)a1 + 3);
    if (v2)
    {
      free(v2);
      *((void *)a1 + 3) = 0;
    }
    a1[40] = 0;
    uint64_t v3 = (void *)*((void *)a1 + 6);
    if (v3)
    {
      free(v3);
      *((void *)a1 + 6) = 0;
    }
    a1[64] = 0;
    *((_DWORD *)a1 + 4) = -1;
    *((void *)a1 + 1) = 0;
    uint64_t v4 = *(void *)a1;
    CFArrayRef v5 = *(const __CFArray **)(*(void *)a1 + 304);
    if (v5)
    {
      CFIndex v6 = BOMCFArrayMaxRange(v5);
      CFIndex v8 = v7;
      v11.location = v6;
      v11.size_t length = v8;
      FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(v4 + 304), v11, a1);
      if (FirstIndexOfValue != -1)
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v4 + 304), FirstIndexOfValue);
        if (!CFArrayGetCount(*(CFArrayRef *)(v4 + 304)))
        {
          CFRelease(*(CFTypeRef *)(v4 + 304));
          *(void *)(v4 + 304) = 0;
        }
      }
    }
    free(a1);
  }
}

uint64_t _SyncCache(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    for (uint64_t i = 32; i != 288; i += 8)
    {
      uint64_t v3 = *(void *)(v1 + i);
      if (v3)
      {
        if ((*(_WORD *)(v3 + 4) & 2) != 0) {
          uint64_t result = _WritePage(v1, v3);
        }
      }
    }
  }
  return result;
}

uint64_t _WritePage(uint64_t a1, uint64_t a2)
{
  uint64_t result = BOMStreamWithBlockID(*(void *)a1, *(_DWORD *)a2, *(unsigned int *)(a1 + 312), 1);
  if (result)
  {
    uint64_t v4 = result;
    BOMStreamWriteUInt16(result, *(_WORD *)(a2 + 4) & 1);
    BOMStreamWriteUInt16(v4, *(_WORD *)(a2 + 16));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a2 + 8));
    BOMStreamWriteUInt32(v4, *(_DWORD *)(a2 + 12));
    if (*(_WORD *)(a2 + 16))
    {
      unint64_t v5 = 0;
      do
      {
        BOMStreamWriteUInt32(v4, *(_DWORD *)(*(void *)(a2 + 32) + 4 * v5));
        BOMStreamWriteUInt32(v4, *(_DWORD *)(*(void *)(a2 + 24) + 4 * v5++));
        unint64_t v6 = *(unsigned __int16 *)(a2 + 16);
      }
      while (v5 < v6);
    }
    else
    {
      unint64_t v6 = 0;
    }
    BOMStreamWriteUInt32(v4, *(_DWORD *)(*(void *)(a2 + 32) + 4 * v6));
    uint64_t result = BOMStreamFree(v4);
    *(_WORD *)(a2 + 4) &= ~2u;
  }
  return result;
}

uint64_t BOMTreeStorage(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t BOMTreeSetCompareFunc(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 296) = a2;
  }
  return result;
}

uint64_t BOMTreeCount(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 20);
  }
  return result;
}

uint64_t BOMTreeSetValue(void *a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v22 = 0;
  uint64_t v5 = 1;
  if (!a1 || !a2) {
    return v5;
  }
  if (!a3 && !*((unsigned char *)a1 + 294)) {
    return 1;
  }
  if (!*((unsigned char *)a1 + 293))
  {
    uint64_t v5 = 1;
    fwrite("tree is read-only\n", 0x12uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
    return v5;
  }
  PagesForKey = _FindPagesForKey((uint64_t)a1, a2, a3);
  if (!PagesForKey) {
    return 1;
  }
  CFIndex v12 = (uint64_t *)PagesForKey;
  if (*((unsigned char *)a1 + 294))
  {
    int v13 = (int)a2;
    goto LABEL_9;
  }
  BOOL v15 = BOMStackPeek(PagesForKey);
  if (!v15) {
    goto LABEL_23;
  }
  BOOL v16 = v15;
  unsigned int IndexForKey = _findIndexForKey((uint64_t)a1, (uint64_t)v15, a2, a3, &v22);
  if (!v22)
  {
    uint64_t v19 = BOMStorageNewBlock(*a1);
    if (!v19) {
      goto LABEL_23;
    }
    int v13 = v19;
    if (BOMStorageSetBlockData(*a1, v19, a2, a3)) {
      goto LABEL_23;
    }
LABEL_9:
    uint64_t v14 = BOMStorageNewBlock(*a1);
    if (!v14) {
      goto LABEL_23;
    }
    goto LABEL_10;
  }
  uint64_t v18 = v16[4];
  int v13 = *(_DWORD *)(v16[3] + 4 * IndexForKey);
  uint64_t v14 = *(unsigned int *)(v18 + 4 * IndexForKey);
  if (!v14) {
    goto LABEL_9;
  }
LABEL_10:
  if (!BOMStorageSetBlockData(*a1, v14, a4, a5)
    && !_PageSetValue((uint64_t)a1, v12, a2, a3, v13, v14))
  {
    if (!v22) {
      ++*((_DWORD *)a1 + 5);
    }
    uint64_t v5 = 0;
    *((unsigned char *)a1 + 292) = 1;
    goto LABEL_25;
  }
LABEL_23:
  uint64_t v5 = 1;
LABEL_25:
  while (!BOMStackIsEmpty((uint64_t)v12))
  {
    unsigned int v20 = BOMStackPop(v12);
    *((_WORD *)v20 + 2) &= ~8u;
  }
  BOMStackFree((void **)v12);
  return v5;
}

void **_FindPagesForKey(uint64_t a1, const void *a2, size_t a3)
{
  unint64_t v6 = BOMStackNew();
  if (!_findPagesForKey(a1, (char *)v6, a2, a3))
  {
    BOMStackFree(v6);
    return 0;
  }
  return v6;
}

uint64_t _findIndexForKey(uint64_t a1, uint64_t a2, const void *a3, size_t a4, BOOL *a5)
{
  if (*(_WORD *)(a2 + 16))
  {
    int v9 = 0;
    int v10 = *(unsigned __int16 *)(a2 + 16) - 1;
    while (1)
    {
      uint64_t v11 = v9 + ((v10 - v9) >> 1);
      CFIndex v12 = (void *)*(unsigned int *)(*(void *)(a2 + 24) + 4 * v11);
      if (!v12) {
        break;
      }
      if (*(unsigned char *)(a1 + 294)) {
        goto LABEL_13;
      }
      unint64_t v13 = BOMStorageSizeOfBlock(*(void *)a1, v12);
      size_t v14 = v13;
      unint64_t v15 = *(unsigned int *)(a1 + 352);
      CFIndex v12 = *(void **)(a1 + 344);
      if (v13 > v15)
      {
        unint64_t v16 = (2 * v15);
        if (v13 > v16) {
          LODWORD(v16) = v13;
        }
        *(_DWORD *)(a1 + 352) = v16;
        if (v12)
        {
          free(v12);
          *(void *)(a1 + 344) = 0;
          LODWORD(v16) = *(_DWORD *)(a1 + 352);
        }
        CFIndex v12 = BOM_malloc(v16);
        *(void *)(a1 + 344) = v12;
      }
      BOMStorageCopyFromBlock(*(void *)a1, *(_DWORD *)(*(void *)(a2 + 24) + 4 * v11), v12);
LABEL_14:
      CFRange v17 = *(uint64_t (**)(const void *, size_t, void *, size_t))(a1 + 296);
      if (v17)
      {
        int v18 = v17(a3, a4, v12, v14);
      }
      else
      {
        if (*(unsigned char *)(a1 + 294))
        {
          if (v12 <= a3) {
            int v19 = 0;
          }
          else {
            int v19 = -1;
          }
          if (v12 < a3) {
            int v18 = 1;
          }
          else {
            int v18 = v19;
          }
          goto LABEL_23;
        }
        if (v12 == a3)
        {
          if (!a5) {
            return v11;
          }
          int v18 = 0;
          BOOL v20 = 1;
          goto LABEL_25;
        }
        if (a3)
        {
          if (!v12)
          {
            int v18 = 1;
            goto LABEL_23;
          }
          if (a4 >= v14) {
            size_t v21 = v14;
          }
          else {
            size_t v21 = a4;
          }
          int v18 = memcmp(a3, v12, v21);
          if (v18) {
            goto LABEL_23;
          }
          if (v14 <= a4)
          {
            int v18 = v14 < a4;
            goto LABEL_23;
          }
        }
        int v18 = -1;
      }
LABEL_23:
      if (!a5) {
        goto LABEL_26;
      }
      BOOL v20 = v18 == 0;
LABEL_25:
      *a5 = v20;
LABEL_26:
      if (v10 == v9)
      {
        if (v18 <= 0) {
          return v11;
        }
        else {
          return (v11 + 1);
        }
      }
      if (v18 >= 1)
      {
        if (v11 == v10) {
          v9 += (v10 - v9) >> 1;
        }
        else {
          int v9 = v11 + 1;
        }
      }
      else
      {
        if ((v18 & 0x80000000) == 0) {
          return v11;
        }
        int v10 = v11 - ((v10 - v9) > 1);
      }
    }
    CFIndex v12 = 0;
LABEL_13:
    size_t v14 = 0;
    goto LABEL_14;
  }
  uint64_t v11 = 0;
  if (a5) {
    *a5 = 0;
  }
  return v11;
}

uint64_t _PageSetValue(uint64_t a1, uint64_t *a2, const void *a3, size_t a4, int a5, int a6)
{
  BOOL v47 = 0;
  uint64_t v6 = 1;
  if (a5)
  {
    if (a6)
    {
      unint64_t v13 = BOMStackPop(a2);
      if (v13)
      {
        uint64_t v14 = (uint64_t)v13;
        BOOL v15 = (*((_WORD *)v13 + 2) & 1) == 0;
        _invalidateIteratorsForPageID(a1, *(_DWORD *)v13);
        unsigned int IndexForKey = _findIndexForKey(a1, v14, a3, a4, &v47);
        if (v47)
        {
          unsigned __int16 v17 = *(_WORD *)(v14 + 16);
        }
        else
        {
          uint64_t v18 = *(void *)(v14 + 24);
          if (*(_DWORD *)(v18 + 4 * IndexForKey))
          {
            if (*(unsigned char *)(a1 + 295)) {
              *(unsigned char *)(a1 + 295) = 0;
            }
            int v19 = *(unsigned __int16 *)(v14 + 16);
            LODWORD(v20) = v19 - IndexForKey;
            if (v19 != IndexForKey)
            {
              uint64_t v21 = *(void *)(v14 + 32);
              if (v20 <= 1) {
                uint64_t v20 = 1;
              }
              else {
                uint64_t v20 = v20;
              }
              unsigned int v22 = v15 + v19;
              unsigned int v23 = *(unsigned __int16 *)(v14 + 16);
              do
              {
                *(_DWORD *)(v18 + 4 * v23) = *(_DWORD *)(v18 + 4 * (v23 - 1));
                *(_DWORD *)(v21 + 4 * v22) = *(_DWORD *)(v21 + 4 * (v22 - 1));
                --v23;
                --v22;
                --v20;
              }
              while (v20);
            }
          }
          else
          {
            LOWORD(v19) = *(_WORD *)(v14 + 16);
          }
          *(_DWORD *)(v18 + 4 * IndexForKey) = a5;
          unsigned __int16 v17 = v19 + 1;
          *(_WORD *)(v14 + 16) = v19 + 1;
        }
        *(_DWORD *)(*(void *)(v14 + 32) + 4 * (IndexForKey + v15)) = a6;
        *(_WORD *)(v14 + 4) |= 2u;
        if (*(_DWORD *)(a1 + 316) >= v17)
        {
          uint64_t v6 = 0;
        }
        else
        {
          BOOL v24 = _NewPage(a1, 0);
          if (v24)
          {
            uint64_t v25 = (unsigned int *)v24;
            *((_WORD *)v24 + 2) = *((_WORD *)v24 + 2) & 0xFFFC | *(_WORD *)(v14 + 4) & 1 | 2;
            if ((*(_WORD *)(v14 + 4) & 1) == 0
              || (int v26 = *(_DWORD *)v24,
                  int v27 = *(_DWORD *)v14,
                  *((_DWORD *)v24 + 2) = *(_DWORD *)(v14 + 8),
                  *(_DWORD *)(v14 + 8) = v26,
                  *((_DWORD *)v24 + 3) = v27,
                  (int v28 = *((_DWORD *)v24 + 2)) == 0))
            {
LABEL_25:
              if (*(unsigned char *)(a1 + 295))
              {
                LODWORD(v30) = *(_DWORD *)(a1 + 316) - 1;
                unsigned int v31 = *(unsigned __int16 *)(v14 + 16);
              }
              else
              {
                unsigned int v31 = *(unsigned __int16 *)(v14 + 16);
                LODWORD(v30) = v31 >> 1;
              }
              if ((int)v30 + 1 >= (int)v31)
              {
                uint64_t v34 = *((void *)v25 + 4);
                unsigned __int16 v37 = *((_WORD *)v25 + 8);
                uint64_t v30 = (int)v30;
                uint64_t v38 = v31;
                uint64_t v32 = *(void *)(v14 + 24);
                uint64_t v33 = *(void *)(v14 + 32);
              }
              else
              {
                uint64_t v32 = *(void *)(v14 + 24);
                uint64_t v33 = *(void *)(v14 + 32);
                uint64_t v35 = *((void *)v25 + 3);
                uint64_t v34 = *((void *)v25 + 4);
                uint64_t v30 = (int)v30;
                uint64_t v36 = (int)v30 + 1;
                unsigned __int16 v37 = *((_WORD *)v25 + 8);
                do
                {
                  *(_DWORD *)(v35 + 4 * v37) = *(_DWORD *)(v32 + 4 * v36);
                  *(_DWORD *)(v34 + 4 * v37++) = *(_DWORD *)(v33 + 4 * v36);
                  *(_DWORD *)(v32 + 4 * v36) = 0;
                  *((_WORD *)v25 + 8) = v37;
                  *(_DWORD *)(v33 + 4 * v36++) = 0;
                  uint64_t v38 = *(unsigned __int16 *)(v14 + 16);
                }
                while (v36 < v38);
                LOWORD(v31) = *(_WORD *)(v14 + 16);
              }
              *(_DWORD *)(v34 + 4 * v37) = *(_DWORD *)(v33 + 4 * v38);
              *(_DWORD *)(v33 + 4 * v38) = 0;
              *(_WORD *)(v14 + 16) = v31 - v37;
              uint64_t v39 = *(unsigned int *)(v32 + 4 * v30);
              if ((*(unsigned char *)(v14 + 4) & 1) == 0)
              {
                *(_DWORD *)(v32 + 4 * v30) = 0;
                *(_WORD *)(v14 + 16) = v31 - v37 - 1;
              }
              _addPageToCache(a1, (uint64_t)v25);
              if (BOMStackIsEmpty((uint64_t)a2))
              {
                uint64_t v40 = _NewPage(a1, 0);
                uint64_t v6 = 1;
                if (v40)
                {
                  uint64_t v41 = v40;
                  uint64_t v42 = (_DWORD *)v40[4];
                  *(_DWORD *)v40[3] = v39;
                  *uint64_t v42 = *(_DWORD *)v14;
                  v42[1] = *v25;
                  *((_WORD *)v40 + 8) = 1;
                  *((_WORD *)v40 + 2) |= 2u;
                  _addPageToCache(a1, v14);
                  uint64_t v6 = 0;
                  *(void *)(a1 + 24) = v41;
                }
              }
              else
              {
                uint64_t v6 = _PageSetValue(a1, a2, a3, a4, v39, *v25);
              }
              goto LABEL_44;
            }
            Page = _findPage(a1, v28);
            if (Page)
            {
              if (*((_DWORD *)Page + 3) == *(_DWORD *)v14)
              {
                *((_DWORD *)Page + 3) = *v25;
                *((_WORD *)Page + 2) |= 2u;
                goto LABEL_25;
              }
              int v43 = *__error();
              uint64_t v44 = "internal btree error";
              uint64_t v6 = 1;
              int v45 = 1998;
            }
            else
            {
              int v43 = *__error();
              uint64_t v44 = "missing tree page";
              uint64_t v6 = 1;
              int v45 = 1994;
            }
            _BOMExceptionHandlerCall((uint64_t)v44, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", v45, v43);
          }
          else
          {
            uint64_t v6 = 1;
          }
        }
LABEL_44:
        *(_WORD *)(v14 + 4) &= ~8u;
      }
    }
  }
  return v6;
}

uint64_t BOMTreeGetValueSize(uint64_t a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t result = 1;
  if (a1 && a2 && a4 && (a3 || *(unsigned char *)(a1 + 294)))
  {
    uint64_t PagesForKey = _findPagesForKey(a1, 0, a2, a3);
    if (PagesForKey && (uint64_t v10 = PagesForKey, v13 = 0, IndexForKey = _findIndexForKey(a1, PagesForKey, a2, a3, &v13), v13))
    {
      uint64_t v12 = BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)(*(void *)(v10 + 32) + 4 * IndexForKey));
      uint64_t result = 0;
      *a4 = v12;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

unint64_t BOMTreeGetValue(uint64_t a1, const void *a2, size_t a3)
{
  unint64_t result = 0;
  BOOL v13 = 0;
  if (a1 && a2)
  {
    if (!a3 && !*(unsigned char *)(a1 + 294)) {
      return 0;
    }
    unint64_t result = _findPagesForKey(a1, 0, a2, a3);
    if (!result) {
      return result;
    }
    unint64_t v7 = result;
    unsigned int IndexForKey = _findIndexForKey(a1, result, a2, a3, &v13);
    if (!v13) {
      return 0;
    }
    unsigned int v9 = IndexForKey;
    unint64_t result = BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)(*(void *)(v7 + 32) + 4 * IndexForKey));
    if (!result) {
      return result;
    }
    unint64_t v10 = result;
    uint64_t v11 = *(void **)(a1 + 328);
    if (v11)
    {
      if (result <= *(unsigned int *)(a1 + 336)) {
        goto LABEL_16;
      }
      free(*(void **)(a1 + 328));
      *(void *)(a1 + 328) = 0;
      unint64_t v12 = (2 * *(_DWORD *)(a1 + 336));
      if (v10 <= v12) {
        unint64_t result = v12;
      }
      else {
        unint64_t result = v10;
      }
      *(_DWORD *)(a1 + 336) = result;
    }
    else
    {
      *(_DWORD *)(a1 + 336) = result;
      unint64_t result = result;
    }
    uint64_t v11 = BOM_malloc(result);
    *(void *)(a1 + 328) = v11;
LABEL_16:
    if (!BOMStorageCopyFromBlock(*(void *)a1, *(_DWORD *)(*(void *)(v7 + 32) + 4 * v9), v11)) {
      return *(void *)(a1 + 328);
    }
    return 0;
  }
  return result;
}

uint64_t _findRemove(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, size_t a8, char *a9)
{
  uint64_t v14 = a2;
  uint64_t v15 = a1;
  unint64_t v16 = a9;
  BOOL v81 = 0;
  uint64_t v17 = *a2;
  unsigned int v80 = 0;
  char v79 = 0;
  if (!a9) {
    unint64_t v16 = &v79;
  }
  time_t v78 = v16;
  unsigned int IndexForKey = _findIndexForKey(a1, v17, a7, a8, &v81);
  unsigned int v19 = IndexForKey;
  *(_DWORD *)(v17 + 20) = IndexForKey;
  if (*(unsigned char *)(v17 + 4))
  {
    BOOL v23 = v81;
    uint64_t result = 1;
    if (!v81) {
      return result;
    }
LABEL_42:
    if (v23)
    {
      _invalidateIteratorsForPageID(v15, *(_DWORD *)v17);
LABEL_45:
      unsigned int v34 = *(unsigned __int16 *)(v17 + 16);
      uint64_t v35 = *(void *)(v17 + 24);
      LODWORD(v36) = v34 - v19;
      if (v34 == v19)
      {
        unsigned int v37 = 0;
        unsigned int v38 = 0;
        *(_DWORD *)(v35 + 4 * (v19 - 1)) = 0;
        uint64_t v39 = *(void *)(v17 + 32);
      }
      else
      {
        unsigned int v37 = *(_DWORD *)(v35 + 4 * v19);
        uint64_t v39 = *(void *)(v17 + 32);
        unsigned int v38 = *(_DWORD *)(v39 + 4 * v19);
        if (v36 <= 1) {
          uint64_t v36 = 1;
        }
        else {
          uint64_t v36 = v36;
        }
        unsigned int v40 = v19;
        do
        {
          *(_DWORD *)(v35 + 4 * v40) = *(_DWORD *)(v35 + 4 * (v40 + 1));
          *(_DWORD *)(v39 + 4 * v40) = *(_DWORD *)(v39 + 4 * (v40 + 1));
          ++v40;
          --v36;
        }
        while (v36);
      }
      *(_DWORD *)(v39 + 4 * v34) = 0;
      *(_WORD *)(v17 + 16) = v34 - 1;
      if (*(_WORD *)(v17 + 4))
      {
        if (*(unsigned char *)(v15 + 294)) {
          BOOL v41 = 1;
        }
        else {
          BOOL v41 = v37 == 0;
        }
        if (!v41) {
          BOMStorageFreeBlock(*(void *)v15, v37);
        }
        if (v38) {
          BOMStorageFreeBlock(*(void *)v15, v38);
        }
      }
      __int16 v42 = *(_WORD *)(v17 + 4);
      *(_WORD *)(v17 + 4) = v42 | 2;
      unsigned int v43 = *(unsigned __int16 *)(v17 + 16);
      if ((v42 & 1) != 0 && a6 && v19 == v43)
      {
        *(_DWORD *)(*(void *)(a6 + 24) + 4 * *(unsigned int *)(a6 + 20)) = *(_DWORD *)(*(void *)(v17 + 24)
                                                                                         + 4 * (v19 - 1));
        *(_WORD *)(a6 + 4) |= 2u;
        unsigned int v43 = *(unsigned __int16 *)(v17 + 16);
      }
      unsigned int v44 = *(_DWORD *)(v15 + 324);
      if (v44 <= v43)
      {
        uint64_t result = 0;
        *time_t v78 = 0;
        return result;
      }
      if (v17 == *(void *)(v15 + 24))
      {
        if (!(*(_WORD *)(v17 + 4) & 1 | v43))
        {
          int v51 = **(_DWORD **)(v17 + 32);
          if (v51)
          {
            Page = _findPage(v15, v51);
            Page[2] &= ~8u;
            _removePageFromCache(v15, Page);
            *(void *)(v15 + 24) = Page;
            BOMStorageFreeBlock(*(void *)v15, *(_DWORD *)v17);
            _FreePage((void *)v17);
          }
        }
      }
      else if (a3 | a4)
      {
        uint64_t v73 = a3;
        uint64_t v75 = v14;
        int v45 = (_WORD *)*v14;
        if (a3) {
          uint64_t v46 = a3;
        }
        else {
          uint64_t v46 = a4;
        }
        uint64_t v47 = a5;
        if (!a3) {
          uint64_t v47 = a6;
        }
        if (a4) {
          BOOL v48 = a3 != 0;
        }
        else {
          BOOL v48 = 0;
        }
        BOOL v70 = v48;
        if (v48)
        {
          unsigned int v49 = *(unsigned __int16 *)(a3 + 16);
          unsigned int v50 = *(unsigned __int16 *)(a4 + 16);
          if (v49 >= v50)
          {
            if (v49 <= v50)
            {
              int v53 = *(_DWORD *)(*(void *)(a6 + 32) + 4 * *(unsigned int *)(a6 + 20));
              if (*(_DWORD *)v45 == v53) {
                uint64_t v46 = a4;
              }
              else {
                uint64_t v46 = a3;
              }
              if (*(_DWORD *)v45 != v53) {
                a6 = a5;
              }
            }
            else
            {
              uint64_t v46 = a3;
              a6 = a5;
            }
          }
          else
          {
            uint64_t v46 = a4;
          }
        }
        else
        {
          a6 = v47;
        }
        unsigned int v54 = *(unsigned __int16 *)(v46 + 16);
        uint64_t v55 = a4;
        BOOL v41 = v46 == a4;
        BOOL v56 = v46 == a4;
        if (v41) {
          long long v57 = v45;
        }
        else {
          long long v57 = (_WORD *)v46;
        }
        if (v45[2]) {
          _invalidateIteratorsForPageID(v15, *(_DWORD *)v46);
        }
        int v58 = *(_DWORD *)(a6 + 20) - (v46 != v55);
        if ((v57[2] & 1) == 0)
        {
          uint64_t v59 = (unsigned __int16)v57[8];
          *(_DWORD *)(*((void *)v57 + 3) + 4 * v59) = *(_DWORD *)(*(void *)(a6 + 24) + 4 * v58);
          v57[8] = v59 + 1;
          v57[2] |= 2u;
        }
        if (v44 < v54)
        {
          _shiftKeysAndValues(v15, (uint64_t)v45, v46, v56);
          int v60 = *(_DWORD *)(*((void *)v57 + 3) + 4 * (unsigned __int16)v57[8] - 4);
          uint64_t v61 = *(void *)(a6 + 24);
          if (*(_DWORD *)(v61 + 4 * v58) != v60)
          {
            *(_DWORD *)(v61 + 4 * v58) = v60;
            *(_WORD *)(a6 + 4) |= 2u;
          }
          CFStringRef v62 = v75;
          char v63 = 0;
          if ((v57[2] & 1) == 0)
          {
            unsigned __int16 v64 = v57[8] - 1;
            v57[8] = v64;
            *(_DWORD *)(*((void *)v57 + 3) + 4 * v64) = 0;
            v57[2] |= 2u;
          }
          goto LABEL_112;
        }
        uint64_t v65 = v55;
        _shiftKeysAndValues(v15, v46, (uint64_t)v45, v46 != v55);
        if (v70)
        {
          CFStringRef v62 = v75;
          *(_DWORD *)(v73 + 8) = *(_DWORD *)v65;
          *(_DWORD *)(v65 + 12) = *(_DWORD *)v73;
          *(_WORD *)(v73 + 4) |= 2u;
        }
        else if (v73)
        {
          *(_DWORD *)(v73 + 8) = 0;
          uint64_t v65 = v73;
          CFStringRef v62 = v75;
        }
        else
        {
          CFStringRef v62 = v75;
          if (!v65)
          {
LABEL_111:
            v45[2] &= ~8u;
            _removePageFromCache(v15, v45);
            BOMStorageFreeBlock(*(void *)v15, *(_DWORD *)v45);
            _FreePage(v45);
            int v45 = 0;
            char v63 = 1;
LABEL_112:
            uint64_t result = 0;
            *time_t v78 = v63;
            *CFStringRef v62 = (uint64_t)v45;
            return result;
          }
          *(_DWORD *)(v65 + 12) = 0;
        }
        *(_WORD *)(v65 + 4) |= 2u;
        goto LABEL_111;
      }
      return 0;
    }
LABEL_44:
    if (!*v78) {
      return 0;
    }
    goto LABEL_45;
  }
  uint64_t v72 = a3;
  uint64_t v76 = a6;
  if (IndexForKey)
  {
    uint64_t v20 = v15;
    uint64_t v21 = _findPage(v15, *(_DWORD *)(*(void *)(v17 + 32) + 4 * (IndexForKey - 1)));
    __int16 v22 = *((_WORD *)v21 + 2);
    if ((v22 & 8) == 0)
    {
      uint64_t v68 = v17;
LABEL_12:
      char v25 = 0;
      *((_WORD *)v21 + 2) = v22 | 8;
      goto LABEL_16;
    }
    char v25 = 1;
    uint64_t v68 = v17;
  }
  else if (a3)
  {
    uint64_t v20 = v15;
    uint64_t v21 = _findPage(v15, *(_DWORD *)(*(void *)(a3 + 32) + 4 * *(unsigned __int16 *)(a3 + 16)));
    __int16 v22 = *((_WORD *)v21 + 2);
    if ((v22 & 8) == 0)
    {
      uint64_t v68 = a5;
      goto LABEL_12;
    }
    char v25 = 1;
    uint64_t v68 = a5;
  }
  else
  {
    uint64_t v20 = v15;
    uint64_t v68 = 0;
    uint64_t v21 = 0;
    char v25 = 1;
  }
LABEL_16:
  uint64_t v74 = v14;
  size_t v69 = a8;
  uint64_t v71 = a4;
  if (v19 == *(unsigned __int16 *)(v17 + 16))
  {
    if (a4)
    {
      int v26 = _findPage(v20, **(_DWORD **)(a4 + 32));
      __int16 v27 = *((_WORD *)v26 + 2);
      if ((v27 & 8) == 0)
      {
        uint64_t v67 = v76;
LABEL_22:
        char v28 = 0;
        *((_WORD *)v26 + 2) = v27 | 8;
        goto LABEL_26;
      }
      char v28 = 1;
      uint64_t v67 = v76;
    }
    else
    {
      uint64_t v67 = 0;
      int v26 = 0;
      char v28 = 1;
    }
  }
  else
  {
    int v26 = _findPage(v20, *(_DWORD *)(*(void *)(v17 + 32) + 4 * (v19 + 1)));
    __int16 v27 = *((_WORD *)v26 + 2);
    if ((v27 & 8) == 0)
    {
      uint64_t v67 = v17;
      goto LABEL_22;
    }
    char v28 = 1;
    uint64_t v67 = v17;
  }
LABEL_26:
  uint64_t v29 = _findPage(v20, *(_DWORD *)(*(void *)(v17 + 32) + 4 * v19));
  unsigned int v80 = v29;
  if (!v29)
  {
    gid_t v66 = __error();
    _BOMFatalException((uint64_t)"BOMTree in invalid state - nextNode is NULL!\n", "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 1604, *v66);
  }
  uint64_t v30 = a7;
  char v31 = v25;
  __int16 v32 = *((_WORD *)v29 + 2);
  if ((v32 & 8) == 0) {
    *((_WORD *)v29 + 2) = v32 | 8;
  }
  char v33 = v28;
  a3 = v72;
  if (v72) {
    *(_WORD *)(v72 + 4) &= ~4u;
  }
  a4 = v71;
  if (v71) {
    *(_WORD *)(v71 + 4) &= ~4u;
  }
  *((_WORD *)v29 + 2) &= ~4u;
  uint64_t result = _findRemove(v20, &v80, v21, v26, v68, v67, v30, v69, v78);
  if ((v31 & 1) == 0) {
    *((_WORD *)v21 + 2) &= ~8u;
  }
  if ((v33 & 1) == 0) {
    *((_WORD *)v26 + 2) &= ~8u;
  }
  uint64_t v15 = v20;
  if ((v32 & 8) == 0 && v80) {
    *((_WORD *)v80 + 2) &= ~8u;
  }
  uint64_t v14 = v74;
  a6 = v76;
  if (!result)
  {
    BOOL v23 = v81;
    if ((*(_WORD *)(v17 + 4) & 1) == 0) {
      goto LABEL_44;
    }
    goto LABEL_42;
  }
  return result;
}

uint64_t BOMTreeCopyToTree(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 1;
  if (a1 && a2)
  {
    if (!*(_DWORD *)(a2 + 20)) {
      *(unsigned char *)(a2 + 295) = 1;
    }
    uint64_t v4 = (char *)BOMTreeIteratorNew(a1, 0, 0, 0);
    if (!v4) {
      goto LABEL_13;
    }
    for (uint64_t i = v4; ; BOMTreeIteratorNext((uint64_t)i))
    {
      if (BOMTreeIteratorIsAtEnd((uint64_t)i))
      {
        uint64_t v3 = 0;
        goto LABEL_11;
      }
      uint64_t v6 = (const void *)BOMTreeIteratorKey((uint64_t)i);
      size_t v7 = BOMTreeIteratorKeySize((uint64_t)i);
      uint64_t v8 = BOMTreeIteratorValue((uint64_t)i);
      uint64_t v9 = BOMTreeIteratorValueSize((uint64_t)i);
      if (BOMTreeSetValue((void *)a2, v6, v7, v8, v9)) {
        break;
      }
    }
    uint64_t v3 = 1;
LABEL_11:
    BOMTreeIteratorFree(i);
  }
  if (a2) {
LABEL_13:
  }
    *(unsigned char *)(a2 + 295) = 0;
  return v3;
}

uint64_t BOMTreeIteratorValue(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 67)) {
      return 0;
    }
    if (!*(unsigned char *)(result + 65) && (unsigned int v2 = *(_DWORD **)(result + 8)) != 0 && *v2 == *(_DWORD *)(result + 16)
      || _revalidateIterator(result))
    {
      if (!*(unsigned char *)(v1 + 64))
      {
        unint64_t v3 = BOMStorageSizeOfBlock(**(void **)v1, *(_DWORD *)(*(void *)(*(void *)(v1 + 8) + 32) + 4 * *(unsigned int *)(v1 + 20)));
        uint64_t v4 = *(void **)(v1 + 48);
        unint64_t v5 = *(void *)(v1 + 56);
        if (v3 > v5)
        {
          unint64_t v6 = v3;
          if (v4)
          {
            free(*(void **)(v1 + 48));
            *(void *)(v1 + 48) = 0;
            unint64_t v5 = *(void *)(v1 + 56);
          }
          if (v6 <= 2 * v5) {
            size_t v7 = 2 * v5;
          }
          else {
            size_t v7 = v6;
          }
          *(void *)(v1 + 56) = v7;
          uint64_t v4 = BOM_malloc(v7);
          *(void *)(v1 + 48) = v4;
        }
        if (BOMStorageCopyFromBlock(**(void **)v1, *(_DWORD *)(*(void *)(*(void *)(v1 + 8) + 32) + 4 * *(unsigned int *)(v1 + 20)), v4))return 0; {
        *(unsigned char *)(v1 + 64) = 1;
        }
      }
      return *(void *)(v1 + 48);
    }
    else
    {
      uint64_t result = 0;
      *(unsigned char *)(v1 + 67) = 1;
    }
  }
  return result;
}

uint64_t BOMTreeIteratorValueSize(uint64_t a1)
{
  if (!a1 || *(unsigned char *)(a1 + 67)) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 65) || (uint64_t v3 = *(void *)(a1 + 8)) == 0 || *(_DWORD *)v3 != *(_DWORD *)(a1 + 16))
  {
    if (!_revalidateIterator(a1))
    {
      *(unsigned char *)(a1 + 67) = 1;
      return 0;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  uint64_t v4 = **(void **)a1;
  unsigned int v5 = *(_DWORD *)(*(void *)(v3 + 32) + 4 * *(unsigned int *)(a1 + 20));
  return BOMStorageSizeOfBlock(v4, v5);
}

uint64_t BOMTreeSetDensePacking(uint64_t result, char a2)
{
  if (result) {
    *(unsigned char *)(result + 295) = a2;
  }
  return result;
}

_DWORD *BOMTreeIteratorSet(uint64_t a1, const void *a2, size_t a3, BOOL *a4)
{
  *(unsigned char *)(a1 + 65) = 0;
  *(unsigned char *)(a1 + 67) = 0;
  uint64_t result = (_DWORD *)_findPagesForKey(*(void *)a1, 0, a2, a3);
  *(void *)(a1 + 8) = result;
  if (result)
  {
    *(_DWORD *)(a1 + 16) = *result;
    uint64_t result = (_DWORD *)_findIndexForKey(*(void *)a1, (uint64_t)result, a2, a3, a4);
    *(_DWORD *)(a1 + 20) = result;
    *(unsigned char *)(a1 + 66) = 1;
    uint64_t v9 = *(void *)(a1 + 8);
    if (result >= *(unsigned __int16 *)(v9 + 16))
    {
      *(_DWORD *)(a1 + 20) = 0;
      int v10 = *(_DWORD *)(v9 + 8);
      if (!v10
        || (*(_DWORD *)(a1 + 16) = v10, uint64_t result = _findPage(*(void *)a1, v10), (*(void *)(a1 + 8) = result) == 0))
      {
        *(unsigned char *)(a1 + 67) = 1;
      }
    }
  }
  else
  {
    *(_WORD *)(a1 + 66) = 256;
  }
  return result;
}

void *_findPage(uint64_t a1, int a2)
{
  if (a2)
  {
    if (a1)
    {
      uint64_t v4 = 0;
      while (1)
      {
        unsigned int v5 = *(void **)(a1 + 32 + v4);
        if (v5)
        {
          if (*(_DWORD *)v5 == a2) {
            break;
          }
        }
        v4 += 8;
        if (v4 == 256) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      unsigned int v5 = 0;
    }
    int v6 = 0;
    while (1)
    {
      if (v5) {
        return v5;
      }
      uint64_t v7 = *(int *)(a1 + 288);
      unsigned int v5 = *(void **)(a1 + 8 * v7 + 32);
      if (!v5)
      {
        unsigned int v5 = _NewPage(a1, a2);
        if (!v5) {
          return v5;
        }
        if (_ReadPage(a1, (uint64_t)v5)) {
          return 0;
        }
        uint64_t v7 = *(int *)(a1 + 288);
        *(void *)(a1 + 8 * v7 + 32) = v5;
        goto LABEL_22;
      }
      __int16 v8 = *((_WORD *)v5 + 2);
      if ((v8 & 0xC) == 4) {
        break;
      }
      if ((v8 & 4) != 0)
      {
        unsigned int v5 = 0;
LABEL_22:
        int v11 = v6;
        goto LABEL_23;
      }
      int v11 = 0;
      *((_WORD *)v5 + 2) = v8 | 4;
      LODWORD(v7) = *(_DWORD *)(a1 + 288);
      unsigned int v5 = 0;
LABEL_23:
      int v12 = v7 + 1;
      BOOL v13 = -v12 < 0;
      int v14 = -v12 & 0x1F;
      int v15 = v12 & 0x1F;
      if (!v13) {
        int v15 = -v14;
      }
      *(_DWORD *)(a1 + 288) = v15;
      int v6 = v11 + 1;
      if (!v5 && v11 >= 32)
      {
        unint64_t v16 = __error();
        _BOMExceptionHandlerCall((uint64_t)"btree cache is deadlocked", 0, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 2144, *v16);
        return 0;
      }
    }
    if ((v8 & 2) != 0) {
      _WritePage(a1, (uint64_t)v5);
    }
    uint64_t v9 = (void *)v5[3];
    int v10 = (void *)v5[4];
    *(_OWORD *)unsigned int v5 = 0u;
    *((_OWORD *)v5 + 1) = 0u;
    v5[4] = 0;
    bzero(v9, 4 * *(unsigned int *)(a1 + 316));
    bzero(v10, 4 * *(unsigned int *)(a1 + 320));
    *(_DWORD *)unsigned int v5 = a2;
    v5[1] = -1;
    v5[3] = v9;
    v5[4] = v10;
    if (_ReadPage(a1, (uint64_t)v5)) {
      return 0;
    }
    uint64_t v7 = *(int *)(a1 + 288);
    *(void *)(a1 + 8 * v7 + 32) = v5;
    goto LABEL_22;
  }
  return 0;
}

uint64_t _revalidateIterator(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 65))
  {
    Page = *(void **)(a1 + 8);
    if (Page)
    {
      int v5 = *(_DWORD *)(a1 + 16);
      if (*(_DWORD *)Page == v5) {
        goto LABEL_9;
      }
    }
    else
    {
      int v5 = *(_DWORD *)(a1 + 16);
    }
    Page = _findPage(*(void *)a1, v5);
    *(void *)(a1 + 8) = Page;
    if (!Page) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  uint64_t PagesForKey = _findPagesForKey(*(void *)a1, 0, *(const void **)(a1 + 24), *(void *)(a1 + 32));
  *(void *)(a1 + 8) = PagesForKey;
  if (!PagesForKey) {
    goto LABEL_11;
  }
  int IndexForKey = _findIndexForKey(*(void *)a1, PagesForKey, *(const void **)(a1 + 24), *(void *)(a1 + 32), (BOOL *)(a1 + 66));
  Page = *(void **)(a1 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)Page;
  *(_DWORD *)(a1 + 20) = IndexForKey;
  *(unsigned char *)(a1 + 65) = 0;
LABEL_9:
  if (*(_DWORD *)(a1 + 20) < *((unsigned __int16 *)Page + 8)) {
    return 1;
  }
LABEL_11:
  uint64_t result = 0;
  *(unsigned char *)(a1 + 65) = 1;
  return result;
}

uint64_t BOMTreeVerifyLeaves(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    unsigned int v2 = *(char **)(result + 24);
    if (!v2) {
      return 0;
    }
    _SyncCache(result);
    if ((*((_WORD *)v2 + 2) & 1) == 0)
    {
      while (1)
      {
        uint64_t v3 = (char *)_NewPage(v1, **((_DWORD **)v2 + 4));
        if (!v3)
        {
          int v5 = *__error();
          int v6 = "verifier: can't make page";
          int v7 = 2642;
          goto LABEL_24;
        }
        uint64_t v4 = v3;
        if (_ReadPage(v1, (uint64_t)v3)) {
          break;
        }
        if (v2 != *(char **)(v1 + 24)) {
          _FreePage(v2);
        }
        unsigned int v2 = v4;
        if (*((_WORD *)v4 + 2)) {
          goto LABEL_11;
        }
      }
      int v5 = *__error();
      int v6 = "verifier: can't read page";
      int v7 = 2647;
      goto LABEL_24;
    }
    uint64_t v4 = v2;
LABEL_11:
    if (*((_DWORD *)v4 + 3))
    {
      int v5 = *__error();
      int v6 = "verifier: first leaf has prev value";
      int v7 = 2658;
LABEL_24:
      _BOMExceptionHandlerCall((uint64_t)v6, 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", v7, v5);
      return 0;
    }
    uint64_t v9 = v4 + 8;
    int v8 = *((_DWORD *)v4 + 2);
    if (v8)
    {
      while (1)
      {
        int v10 = (char *)_NewPage(v1, v8);
        if (!v10)
        {
          int v5 = *__error();
          int v6 = "verifier: can't make page";
          int v7 = 2666;
          goto LABEL_24;
        }
        int v11 = v10;
        if (_ReadPage(v1, (uint64_t)v10))
        {
          int v5 = *__error();
          int v6 = "verifier: can't read page";
          int v7 = 2671;
          goto LABEL_24;
        }
        if (*v9 != *(_DWORD *)v11)
        {
          int v5 = *__error();
          int v6 = "verifier: page->next != next->bid";
          int v7 = 2678;
          goto LABEL_24;
        }
        if (*((_DWORD *)v11 + 3) != *(_DWORD *)v4) {
          break;
        }
        if (v4 != *(char **)(v1 + 24)) {
          _FreePage(v4);
        }
        uint64_t v9 = v11 + 8;
        int v8 = *((_DWORD *)v11 + 2);
        uint64_t v4 = v11;
        if (!v8) {
          goto LABEL_28;
        }
      }
      int v5 = *__error();
      int v6 = "verifier: next->prev != page->bid";
      int v7 = 2683;
      goto LABEL_24;
    }
    int v11 = v4;
LABEL_28:
    if (v11 != *(char **)(v1 + 24)) {
      _FreePage(v11);
    }
    return 1;
  }
  return result;
}

uint64_t _BOMTreeDiagnosticTraverse(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, void *a5, void *a6)
{
  if (!a1) {
    return 1;
  }
  uint64_t v10 = a2;
  if (!a2) {
    uint64_t v10 = *(void *)(a1 + 24);
  }
  if (*(_WORD *)(v10 + 4))
  {
    if (a3) {
      ++*a3;
    }
    if (!*(_WORD *)(v10 + 16))
    {
      uint64_t v16 = 0;
LABEL_28:
      int v13 = 0;
      if (a6)
      {
        unsigned int v19 = *(_DWORD *)(*(void *)(v10 + 32) + 4 * v16);
        if (v19)
        {
          int v13 = 0;
          *a6 += BOMStorageSizeOfBlock(*(void *)a1, v19);
        }
      }
      return v13 != 0;
    }
    uint64_t v16 = 0;
    while (!a5 || *(unsigned char *)(a1 + 294))
    {
      if (a6) {
        goto LABEL_19;
      }
LABEL_20:
      if (++v16 >= (unint64_t)*(unsigned __int16 *)(v10 + 16)) {
        goto LABEL_28;
      }
    }
    *a5 += BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)(*(void *)(v10 + 24) + 4 * v16));
    if (!a6) {
      goto LABEL_20;
    }
LABEL_19:
    *a6 += BOMStorageSizeOfBlock(*(void *)a1, *(_DWORD *)(*(void *)(v10 + 32) + 4 * v16));
    goto LABEL_20;
  }
  if (a4) {
    ++*a4;
  }
  if (*(_WORD *)(v10 + 16))
  {
    unint64_t v12 = 0;
    int v13 = 0;
    do
    {
      Page = _findPage(a1, *(_DWORD *)(*(void *)(v10 + 32) + 4 * v12));
      v13 += _BOMTreeDiagnosticTraverse(a1, Page, a3, a4, a5, a6);
      ++v12;
    }
    while (v12 < *(unsigned __int16 *)(v10 + 16));
  }
  else
  {
    unint64_t v12 = 0;
    int v13 = 0;
  }
  int v17 = *(_DWORD *)(*(void *)(v10 + 32) + 4 * v12);
  if (v17)
  {
    uint64_t v18 = _findPage(a1, v17);
    v13 += _BOMTreeDiagnosticTraverse(a1, v18, a3, a4, a5, a6);
  }
  return v13 != 0;
}

uint64_t _BOMTreePrintDiagnostics(uint64_t result)
{
  int v7 = 0;
  int v6 = 0;
  size_t v4 = 0;
  size_t v5 = 0;
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = _BOMTreeDiagnosticTraverse(result, 0, &v7, &v6, &v5, &v4);
    if (!result)
    {
      int v2 = v6 + v7;
      uint64_t v3 = (FILE **)MEMORY[0x263EF8348];
      fprintf((FILE *)*MEMORY[0x263EF8348], "   # records: %d\n", *(_DWORD *)(v1 + 20));
      fprintf(*v3, "   # pages  : %d (%d)\n", v2, *(_DWORD *)(v1 + 312) * v2);
      fprintf(*v3, "     leaf   : %d (%d)\n", v7, *(_DWORD *)(v1 + 312) * v7);
      fprintf(*v3, "     branch : %d (%d)\n", v6, *(_DWORD *)(v1 + 312) * v6);
      fprintf(*v3, "   key size : %zd\n", v5);
      return fprintf(*v3, "   data size: %zd\n", v4);
    }
  }
  return result;
}

uint64_t BOMMemoryDump(unsigned __int8 *a1, uint64_t a2, const char *a3)
{
  uint64_t v3 = a2;
  uint64_t v29 = *MEMORY[0x263EF8340];
  size_t v5 = (FILE **)MEMORY[0x263EF8358];
  int v6 = (FILE *)*MEMORY[0x263EF8358];
  __int16 v27 = a1;
  if (!a1)
  {
    fprintf(v6, "(%lu bytes) (NULL)\n", a2);
    return 0;
  }
  fprintf(v6, "(%lu bytes)\n", a2);
  if (v3 >= 1)
  {
    int v8 = v27;
    unint64_t v9 = (unint64_t)&v27[v3];
    uint64_t v10 = "";
    if (a3) {
      uint64_t v10 = a3;
    }
    uint64_t v25 = v3;
    int v26 = v10;
    while (1)
    {
      int v11 = v8;
      fprintf(*v5, "%s%08x:", v26, v8 - v27);
      uint64_t v12 = 0;
      int v13 = v28;
      do
      {
        fprintf(*v5, " %02x", *v8);
        uint64_t v14 = *v8;
        if ((v14 & 0x80) != 0) {
          int v15 = __maskrune(v14, 0x40000uLL);
        }
        else {
          int v15 = *(_DWORD *)(MEMORY[0x263EF8318] + 4 * v14 + 60) & 0x40000;
        }
        if (v15) {
          char v16 = v14;
        }
        else {
          char v16 = 46;
        }
        *int v13 = v16;
        int v17 = v13 + 1;
        uint64_t v18 = v12 + 1;
        if (v12 < 15)
        {
          unsigned int v19 = &v11[v18];
          if ((unint64_t)&v11[v18] < v9)
          {
            fprintf(*v5, "%02x", *v19);
            uint64_t v20 = *v19;
            if ((v20 & 0x80) != 0) {
              int v21 = __maskrune(v20, 0x40000uLL);
            }
            else {
              int v21 = *(_DWORD *)(MEMORY[0x263EF8318] + 4 * v20 + 60) & 0x40000;
            }
            if (v21) {
              char v22 = v20;
            }
            else {
              char v22 = 46;
            }
            int v17 = v13 + 2;
            v13[1] = v22;
            uint64_t v18 = v12 + 2;
          }
        }
        int v8 = &v11[v18];
        if (v18 > 15) {
          break;
        }
        int v13 = v17;
        uint64_t v12 = v18;
      }
      while ((unint64_t)v8 < v9);
      if (v18 > 15) {
        goto LABEL_29;
      }
      uint64_t v23 = 16 - v18;
      if (((16 - v18) & 1) == 0) {
        goto LABEL_28;
      }
      fwrite("  ", 2uLL, 1uLL, *v5);
      if (v18 != 15) {
        break;
      }
LABEL_29:
      *int v17 = 0;
      fprintf(*v5, "  %s\n", v28);
      if ((unint64_t)v8 >= v9) {
        return v25;
      }
    }
    uint64_t v23 = 15 - v18;
    do
    {
LABEL_28:
      fwrite("     ", 5uLL, 1uLL, *v5);
      v23 -= 2;
    }
    while (v23);
    goto LABEL_29;
  }
  return v3;
}

uint64_t BOMStorageDumpTree(uint64_t a1, const char *a2, unsigned int a3)
{
  size_t v4 = a2;
  uint64_t v5 = BOMTreeOpenWithName(a1, a2, 0);
  if (v5)
  {
    uint64_t v6 = v5;
    int v7 = (FILE **)MEMORY[0x263EF8358];
    fprintf((FILE *)*MEMORY[0x263EF8358], "        %s (%u entries)\n", v4, *(_DWORD *)(v5 + 20));
    uint64_t v26 = v6;
    int v8 = (char *)BOMTreeIteratorNew(v6, 0, 0, 0);
    if (!BOMTreeIteratorIsAtEnd((uint64_t)v8))
    {
      int v9 = HIWORD(a3) & 0xF;
      int v27 = v9;
      unsigned int v28 = a3;
      do
      {
        fprintf(*v7, "        %s   Key ", v4);
        uint64_t v10 = (unsigned __int8 *)BOMTreeIteratorKey((uint64_t)v8);
        uint64_t v11 = BOMTreeIteratorKeySize((uint64_t)v8);
        switch(v9)
        {
          case 3:
            BOMPathKeyDump((uint64_t)v10, v11);
            break;
          case 2:
            BOMPathIdDump(v10, v11);
            break;
          case 1:
            BOMPathDump((char *)v10);
            break;
          default:
            BOMMemoryDump(v10, v11, "        ");
            break;
        }
        fprintf(*v7, "        %s Value ", v4);
        uint64_t v12 = (unsigned __int8 *)BOMTreeIteratorValue((uint64_t)v8);
        unint64_t v13 = BOMTreeIteratorValueSize((uint64_t)v8);
        unint64_t v14 = v13;
        if ((a3 & 0x1000000) != 0)
        {
          if (v13 >= 4)
          {
            int v17 = v4;
            unsigned int v18 = a3;
            unsigned int v20 = *(_DWORD *)v12;
            v12 += 4;
            unsigned int v19 = v20;
            unsigned int v21 = bswap32(v20);
            char v22 = "ies";
            if (v20 == 0x1000000) {
              char v22 = "y";
            }
            fprintf(*v7, "(%lu bytes for %d entr%s)\n", v13, v21, v22);
            BOOL v15 = v19 != 0;
            v14 -= 4;
            unsigned int v16 = v18;
            size_t v4 = v17;
            if (!v14) {
              goto LABEL_32;
            }
LABEL_20:
            if (v15)
            {
              int v23 = (v16 >> 20) & 0xF;
              do
              {
                if ((v16 & 0x1000000) != 0) {
                  fprintf(*v7, "  %s", "        ");
                }
                switch(v23)
                {
                  case 3:
                    size_t v24 = BOMPathKeyDump((uint64_t)v12, v14);
                    break;
                  case 2:
                    size_t v24 = BOMPathIdDump(v12, v14);
                    break;
                  case 1:
                    size_t v24 = BOMPathDump((char *)v12);
                    break;
                  default:
                    size_t v24 = BOMMemoryDump(v12, v14, "        ");
                    break;
                }
                v12 += v24;
                v14 -= v24;
              }
              while (v14);
            }
            goto LABEL_32;
          }
          unsigned int v16 = 0;
          BOOL v15 = 1;
          if (v13) {
            goto LABEL_20;
          }
        }
        else
        {
          BOOL v15 = 1;
          unsigned int v16 = a3;
          if (v13) {
            goto LABEL_20;
          }
        }
LABEL_32:
        BOMTreeIteratorNext((uint64_t)v8);
        int v9 = v27;
        a3 = v28;
      }
      while (!BOMTreeIteratorIsAtEnd((uint64_t)v8));
    }
    fputc(10, *v7);
    if (v8) {
      BOMTreeIteratorFree(v8);
    }
    BOMTreeFree(v26);
    return 0;
  }
  else
  {
    fputc(10, (FILE *)*MEMORY[0x263EF8358]);
    return 0xFFFFFFFFLL;
  }
}

void *_newBOMTree(uint64_t a1, const char *a2)
{
  size_t v4 = BOM_malloczero(0x168uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    *size_t v4 = a1;
    if (a2) {
      v4[1] = strdup(a2);
    }
  }
  else
  {
    uint64_t v6 = (FILE *)*MEMORY[0x263EF8348];
    int v7 = __error();
    int v8 = strerror(*v7);
    fprintf(v6, "malloc: %s\n", v8);
  }
  return v5;
}

void *_NewPage(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = BOM_malloczero(4 * (*(_DWORD *)(a1 + 316) + 1));
  if (!v5) {
    return 0;
  }
  uint64_t v6 = v5;
  int v7 = BOM_malloczero(4 * (*(_DWORD *)(a1 + 320) + 1));
  if (!v7)
  {
    free(v6);
    return 0;
  }
  int v8 = v7;
  int v9 = BOM_malloczero(0x28uLL);
  if (v9)
  {
    if (!a2) {
      a2 = BOMStorageNewBlock(v4);
    }
    void v9[3] = v6;
    v9[4] = v8;
    *(_DWORD *)int v9 = a2;
  }
  else
  {
    free(v6);
    free(v8);
  }
  return v9;
}

uint64_t _ReadPage(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = BOMStreamWithBlockID(*(void *)a1, *(_DWORD *)a2, *(unsigned int *)(a1 + 312), 0);
  if (!v3) {
    return 1;
  }
  uint64_t v4 = v3;
  *(_WORD *)(a2 + 4) = *(_WORD *)(a2 + 4) & 0xFFFE | (BOMStreamReadUInt16(v3) != 0);
  *(_WORD *)(a2 + 16) = BOMStreamReadUInt16(v4);
  *(_DWORD *)(a2 + 8) = BOMStreamReadUInt32(v4);
  *(_DWORD *)(a2 + 12) = BOMStreamReadUInt32(v4);
  if (*(_WORD *)(a2 + 16))
  {
    unint64_t v5 = 0;
    do
    {
      *(_DWORD *)(*(void *)(a2 + 32) + 4 * v5) = BOMStreamReadUInt32(v4);
      *(_DWORD *)(*(void *)(a2 + 24) + 4 * v5++) = BOMStreamReadUInt32(v4);
    }
    while (v5 < *(unsigned __int16 *)(a2 + 16));
  }
  *(_DWORD *)(*(void *)(a2 + 32) + 4 * *(unsigned __int16 *)(a2 + 16)) = BOMStreamReadUInt32(v4);
  BOMStreamFree(v4);
  return 0;
}

void _invalidateIteratorsForPageID(uint64_t a1, unsigned int a2)
{
  CFArrayRef v3 = *(const __CFArray **)(a1 + 304);
  if (v3)
  {
    CFIndex v5 = BOMCFArrayMaxRange(v3);
    CFIndex v7 = v6;
    CFArrayRef v8 = *(const __CFArray **)(a1 + 304);
    v9.location = v5;
    v9.size_t length = v7;
    CFArrayApplyFunction(v8, v9, (CFArrayApplierFunction)_invalidateIterator, (void *)a2);
  }
}

void _addPageToCache(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1 + 8 * *(int *)(a1 + 288);
  CFIndex v6 = *(_WORD **)(v3 + 32);
  uint64_t v4 = (void *)(v3 + 32);
  CFIndex v5 = v6;
  if (v6)
  {
    while (1)
    {
      __int16 v8 = v5[2];
      if ((v8 & 0xC) == 4) {
        break;
      }
      v5[2] = v8 | 4;
      int v9 = *(_DWORD *)(a1 + 288) + 1;
      BOOL v10 = -v9 < 0;
      int v11 = -v9 & 0x1F;
      int v12 = v9 & 0x1F;
      if (!v10) {
        int v12 = -v11;
      }
      *(_DWORD *)(a1 + 288) = v12;
      uint64_t v13 = a1 + 8 * v12;
      unint64_t v14 = *(_WORD **)(v13 + 32);
      uint64_t v4 = (void *)(v13 + 32);
      CFIndex v5 = v14;
      if (!v14) {
        goto LABEL_10;
      }
    }
    if ((v8 & 2) != 0) {
      _WritePage(a1, (uint64_t)v5);
    }
    _FreePage(v5);
    uint64_t v4 = (void *)(a1 + 8 * *(int *)(a1 + 288) + 32);
  }
LABEL_10:
  *uint64_t v4 = a2;
}

uint64_t _invalidateIterator(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*(_DWORD *)(result + 16) == a2 && !*(unsigned char *)(result + 67) && !*(unsigned char *)(result + 65))
    {
      uint64_t result = *(void *)(result + 8);
      if (result && *(_DWORD *)result == a2
        || (uint64_t result = (uint64_t)_findPage(*(void *)v2, a2), (*(void *)(v2 + 8) = result) != 0))
      {
        if (*(unsigned char *)(*(void *)v2 + 294))
        {
          *(void *)(v2 + 24) = *(unsigned int *)(*(void *)(result + 24) + 4 * *(unsigned int *)(v2 + 20));
          *(void *)(v2 + 32) = 0;
        }
        else
        {
          size_t v3 = BOMStorageSizeOfBlock(**(void **)v2, *(_DWORD *)(*(void *)(result + 24) + 4 * *(unsigned int *)(v2 + 20)));
          *(void *)(v2 + 32) = v3;
          if (*(void *)(v2 + 24))
          {
            free(*(void **)(v2 + 24));
            *(void *)(v2 + 24) = 0;
            size_t v3 = *(void *)(v2 + 32);
          }
          uint64_t v4 = BOM_malloc(v3);
          *(void *)(v2 + 24) = v4;
          if (!v4)
          {
            CFIndex v5 = __error();
            _BOMFatalException((uint64_t)"BOMTree iterator cannot cache keys. This is a fatal error (!it->key).\n", "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 2550, *v5);
          }
          uint64_t result = BOMStorageCopyFromBlock(**(void **)v2, *(_DWORD *)(*(void *)(*(void *)(v2 + 8) + 24) + 4 * *(unsigned int *)(v2 + 20)), v4);
          if (result)
          {
            CFIndex v6 = __error();
            _BOMFatalException((uint64_t)"BOMTree iterator cannot cache keys. This is a fatal error (BOMStorageCopyFromBlock returned an error).\n", "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMTree.c", 2554, *v6);
          }
        }
      }
      *(unsigned char *)(v2 + 65) = 1;
    }
  }
  return result;
}

void _removePageFromCache(uint64_t a1, _WORD *a2)
{
  if ((a2[2] & 8) == 0)
  {
    for (uint64_t i = 32; i != 288; i += 8)
    {
      if (*(_WORD **)(a1 + i) == a2)
      {
        CFArrayRef v5 = *(const __CFArray **)(a1 + 304);
        if (v5)
        {
          CFIndex v6 = BOMCFArrayMaxRange(v5);
          CFIndex v8 = v7;
          v10.location = v6;
          v10.size_t length = v8;
          CFArrayApplyFunction(*(CFArrayRef *)(a1 + 304), v10, (CFArrayApplierFunction)_pageRemovedCallback, a2);
        }
        *(void *)(a1 + i) = 0;
      }
    }
    if ((a2[2] & 2) != 0)
    {
      _WritePage(a1, (uint64_t)a2);
    }
  }
}

uint64_t _pageRemovedCallback(uint64_t result, uint64_t a2)
{
  if (result && a2 && *(void *)(result + 8) == a2) {
    *(void *)(result + 8) = 0;
  }
  return result;
}

uint64_t _shiftKeysAndValues(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(unsigned __int16 *)(a3 + 16);
  unsigned int v5 = *(_DWORD *)(result + 324);
  BOOL v6 = v4 >= v5;
  int v8 = v4 - v5;
  BOOL v7 = v8 != 0 && v6;
  unsigned int v9 = (v8 + 1) >> 1;
  if (v7) {
    unsigned int v10 = v9;
  }
  else {
    unsigned int v10 = *(unsigned __int16 *)(a3 + 16);
  }
  uint64_t v11 = *(unsigned __int16 *)(a2 + 16);
  unsigned int v12 = v10 + v11;
  unint64_t v13 = v4 - v10;
  if (a4)
  {
    unsigned int v14 = 0;
    if (!v10) {
      goto LABEL_15;
    }
    goto LABEL_11;
  }
  uint64_t v15 = *(void *)(a2 + 32);
  *(_DWORD *)(v15 + 4 * v12) = *(_DWORD *)(v15 + 4 * v11);
  if (v11)
  {
    uint64_t v16 = *(void *)(a2 + 24);
    do
    {
      unsigned int v17 = v10 - 1 + v11--;
      *(_DWORD *)(v16 + 4 * v17) = *(_DWORD *)(v16 + 4 * v11);
      *(_DWORD *)(v15 + 4 * v17) = *(_DWORD *)(v15 + 4 * v11);
    }
    while (v11);
  }
  unsigned int v14 = v4 - v10;
  if (v10)
  {
LABEL_11:
    uint64_t v18 = *(void *)(a3 + 24);
    uint64_t v19 = *(void *)(a3 + 32);
    uint64_t v11 = v11;
    unsigned int v20 = v10;
    uint64_t v21 = *(void *)(a2 + 24);
    uint64_t result = *(void *)(a2 + 32);
    do
    {
      *(_DWORD *)(v21 + 4 * v11) = *(_DWORD *)(v18 + 4 * v14);
      *(_DWORD *)(result + 4 * v11) = *(_DWORD *)(v19 + 4 * v14);
      if (!a4)
      {
        *(_DWORD *)(v18 + 4 * v14) = 0;
        *(_DWORD *)(v19 + 4 * v14) = 0;
      }
      ++v11;
      ++v14;
      --v20;
    }
    while (v20);
  }
LABEL_15:
  if (a4)
  {
    if ((*(_WORD *)(a2 + 4) & 1) == 0 && v4 == v10)
    {
      uint64_t v22 = *(void *)(a3 + 32);
      *(_DWORD *)(*(void *)(a2 + 32) + 4 * v11) = *(_DWORD *)(v22 + 4 * v14);
      *(_DWORD *)(v22 + 4 * v14) = 0;
    }
    if (v4 != v10)
    {
      if (v4)
      {
        unint64_t v23 = 0;
        uint64_t v24 = 4 * v10;
        unint64_t v25 = v13 + v10;
        do
        {
          if (v23 >= v13)
          {
            uint64_t v27 = *(void *)(a3 + 24);
            if (v13 == v23)
            {
              *(_DWORD *)(v27 + 4 * v13) = 0;
              uint64_t v26 = *(void *)(a3 + 32);
              *(_DWORD *)(v26 + 4 * v13) = *(_DWORD *)(v26 + 4 * v25);
            }
            else
            {
              *(_DWORD *)(v27 + 4 * v23) = 0;
              uint64_t v26 = *(void *)(a3 + 32);
              *(_DWORD *)(v26 + 4 * v23) = 0;
            }
          }
          else
          {
            uint64_t v26 = *(void *)(a3 + 32);
            *(_DWORD *)(*(void *)(a3 + 24) + 4 * v23) = *(_DWORD *)(*(void *)(a3 + 24) + 4 * v23 + v24);
            *(_DWORD *)(v26 + 4 * v23) = *(_DWORD *)(v26 + 4 * v23 + v24);
          }
          ++v23;
        }
        while (v4 != v23);
      }
      else
      {
        uint64_t v26 = *(void *)(a3 + 32);
      }
      *(_DWORD *)(v26 + 4 * v4) = 0;
    }
  }
  *(_WORD *)(a2 + 16) = v12;
  *(_WORD *)(a2 + 4) |= 2u;
  *(_WORD *)(a3 + 16) = v13;
  *(_WORD *)(a3 + 4) |= 2u;
  return result;
}

uint64_t _findPagesForKey(uint64_t a1, char *a2, const void *a3, size_t a4)
{
  if (!a1) {
    return 0;
  }
  uint64_t v8 = *(void *)(a1 + 24);
  if (a2) {
    BOMStackPush(a2, v8);
  }
  if ((*(_WORD *)(v8 + 4) & 1) == 0)
  {
    do
    {
      unsigned int IndexForKey = _findIndexForKey(a1, v8, a3, a4, 0);
      Page = _findPage(a1, *(_DWORD *)(*(void *)(v8 + 32) + 4 * IndexForKey));
      uint64_t v8 = (uint64_t)Page;
      if (!Page) {
        break;
      }
      if (a2)
      {
        BOMStackPush(a2, (uint64_t)Page);
        __int16 v11 = *(_WORD *)(v8 + 4) | 8;
      }
      else
      {
        __int16 v11 = *((_WORD *)Page + 2);
      }
      *(_WORD *)(v8 + 4) = v11 & 0xFFFB;
    }
    while ((v11 & 1) == 0);
  }
  return v8;
}

size_t BOMPathDump(char *__s)
{
  if (__s) {
    size_t v2 = strlen(__s);
  }
  else {
    size_t v2 = 0;
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "\"%s\" (%lu bytes)\n", __s, v2);
  return v2;
}

uint64_t BOMPathIdDump(unsigned __int8 *a1, unint64_t a2)
{
  if (a2 < 4)
  {
    return BOMMemoryDump(a1, a2, "        ");
  }
  else
  {
    if (a1) {
      fprintf((FILE *)*MEMORY[0x263EF8358], "0x%02x%02x%02x%02x (%lu bytes)\n", *a1, a1[1], a1[2], a1[3], 4);
    }
    return 4;
  }
}

uint64_t BOMPathKeyDump(uint64_t a1, unint64_t a2)
{
  if (!a1) {
    return 0;
  }
  if (a2 >= 5)
  {
    size_t v2 = strlen((const char *)(a1 + 4)) + 5;
    fprintf((FILE *)*MEMORY[0x263EF8358], "0x%02x%02x%02x%02x \"%s\" (%lu bytes)\n");
    return v2;
  }
  if (a2 == 4)
  {
    size_t v2 = 4;
    fprintf((FILE *)*MEMORY[0x263EF8358], "0x%02x%02x%02x%02x (NULL) (%lu bytes)\n");
    return v2;
  }
  return BOMMemoryDump((unsigned __int8 *)a1, a2, "        ");
}

void *data_archive_entry_new(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return 0;
  }
  uint64_t result = platform_calloc(a1, 1uLL, 0x80uLL);
  if (result)
  {
    *(_DWORD *)uint64_t result = 1684369012;
    result[1] = a1;
    *((_DWORD *)result + 30) = 1953391972;
  }
  return result;
}

void data_archive_entry_free(void *__b)
{
  if (__b && *(_DWORD *)__b == 1684369012 && *((_DWORD *)__b + 30) == 1953391972)
  {
    size_t v2 = (void *)__b[3];
    if (v2) {
      platform_free(__b[1], v2);
    }
    uint64_t v3 = __b[1];
    platform_memset(v3, __b, 0, 0x80uLL);
    platform_free(v3, __b);
  }
}

_DWORD *data_archive_entry_get_type(_DWORD *result)
{
  if (result)
  {
    if (*result == 1684369012 && result[30] == 1953391972) {
      return (_DWORD *)result[4];
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t data_archive_entry_set_format_entry(uint64_t a1, int a2, int a3, _DWORD *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1 || *(_DWORD *)a1 != 1684369012 || *(_DWORD *)(a1 + 120) != 1953391972)
  {
    uint64_t v30 = "Invalid data archive entry";
    char v31 = a5;
    int v32 = 214;
LABEL_27:
    capture_error(v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", v32, (uint64_t)"data_archive_entry_set_format_entry", v30, a6, a7, a8, v136);
    return 0xFFFFFFFFLL;
  }
  if (!a2)
  {
    uint64_t v30 = "Unknown format type";
    char v31 = a5;
    int v32 = 220;
    goto LABEL_27;
  }
  if (!a4)
  {
    uint64_t v30 = "Invalid format entry";
    char v31 = a5;
    int v32 = 226;
    goto LABEL_27;
  }
  if (!darc_format_entry_get_type(a4))
  {
    uint64_t v30 = "Unknown data entry type";
    char v31 = a5;
    int v32 = 235;
    goto LABEL_27;
  }
  if (a2 == 9)
  {
    unsigned int type = darc_format_entry_get_type(a4);
    switch(type)
    {
      case 1u:
        goto LABEL_45;
      case 6u:
        uint64_t attribute = darc_format_entry_get_attribute((uint64_t)a4, "name", 0);
        if (attribute <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 948, (uint64_t)"populate_pkzip_entry_local_header", "PKZip local header format entry is missing %s attribute", v38, v39, v40, (char)"name");
          return 0xFFFFFFFFLL;
        }
        char v41 = attribute + 1;
        __int16 v42 = platform_calloc(*(void *)(a1 + 8), attribute + 1, 1uLL);
        if (!v42)
        {
          char v111 = __error();
          strerror(*v111);
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 956, (uint64_t)"populate_pkzip_entry_local_header", "Could not allocate %ld bytes for name buffer: %s", v112, v113, v114, v41);
          return 0xFFFFFFFFLL;
        }
        unsigned int v43 = v42;
        if (darc_format_entry_get_attribute((uint64_t)a4, "name", v42) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 963, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v44, v45, v46, (char)"name");
          return 0xFFFFFFFFLL;
        }
        *(void *)(a1 + 24) = v43;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip local header", 0) <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 978, (uint64_t)"populate_pkzip_entry_local_header", "PKZip local header format entry is missing %s attribute", v47, v48, v49, (char)"pkzip local header");
          return 0xFFFFFFFFLL;
        }
        long long v140 = 0u;
        long long v141 = 0u;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip local header", &v140) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 987, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v50, v51, v52, (char)"pkzip local header");
          return 0xFFFFFFFFLL;
        }
        uint64_t v53 = DWORD1(v141);
        *(void *)(a1 + 80) = DWORD2(v141);
        *(void *)(a1 + 112) = v53;
        time_t v54 = convert_dos_to_unix_time(a1, WORD5(v140), WORD6(v140));
        *(void *)(a1 + 88) = v54;
        *(void *)(a1 + 72) = v54;
        char v55 = BYTE6(v140);
        if (BYTE6(v140)) {
          *(unsigned char *)(a1 + 104) = 1;
        }
        if ((v55 & 8) != 0)
        {
          *(unsigned char *)(a1 + 105) = 1;
          BOOL v56 = (_DWORD *)(a1 + 108);
        }
        else
        {
          *(_DWORD *)(a1 + 108) = v141;
          BOOL v56 = (_DWORD *)(a1 + 108);
          if (!*(unsigned char *)(a1 + 105)) {
            goto LABEL_103;
          }
        }
        _DWORD *v56 = WORD5(v140);
LABEL_103:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field extended timestamp", 0) < 1) {
          goto LABEL_106;
        }
        memset(v137, 0, 24);
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field extended timestamp", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1041, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v119, v120, v121, (char)"pkzip extra field extended timestamp");
          return 0xFFFFFFFFLL;
        }
        *(void *)(a1 + 72) = *(void *)&v137[0];
        *(_OWORD *)(a1 + 88) = *(_OWORD *)((char *)v137 + 8);
LABEL_106:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", 0) < 1) {
          goto LABEL_112;
        }
        memset(v137, 0, 32);
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1064, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v122, v123, v124, (char)"pkzip extra field InfoZIP UNIX v1");
          return 0xFFFFFFFFLL;
        }
        uint64_t v125 = *((void *)&v137[0] + 1);
        *(void *)(a1 + 88) = *(void *)&v137[0];
        *(void *)(a1 + 72) = v125;
        if (LOBYTE(v137[1])) {
          *(_DWORD *)(a1 + 52) = DWORD1(v137[1]);
        }
        if (BYTE8(v137[1])) {
          *(_DWORD *)(a1 + 56) = HIDWORD(v137[1]);
        }
LABEL_112:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v3", 0) < 1) {
          goto LABEL_115;
        }
        DWORD2(v137[0]) = 0;
        *(void *)&v137[0] = 0;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v3", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1096, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v126, v127, v128, (char)"pkzip extra field InfoZIP UNIX v3");
          return 0xFFFFFFFFLL;
        }
        *(void *)(a1 + 52) = *(void *)((char *)v137 + 4);
LABEL_115:
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field ZIP64", 0) < 1) {
          goto LABEL_121;
        }
        memset(v137, 0, 40);
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field ZIP64", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1118, (uint64_t)"populate_pkzip_entry_local_header", "Could not get %s attribute", v129, v130, v131, (char)"pkzip extra field ZIP64");
          return 0xFFFFFFFFLL;
        }
        if (LOBYTE(v137[0])) {
          *(void *)(a1 + 80) = *((void *)&v137[0] + 1);
        }
        if (BYTE1(v137[0])) {
          *(void *)(a1 + 112) = *(void *)&v137[1];
        }
LABEL_121:
        size_t v132 = platform_strlen(*(void *)(a1 + 8), *(char **)(a1 + 24));
        uint64_t v133 = *(void *)(a1 + 24);
        __int16 v134 = *(_WORD *)(a1 + 48);
        if (*(unsigned char *)(v133 + v132 - 1) == 47)
        {
          *(_WORD *)(a1 + 48) = v134 | 0x41C0;
          *(unsigned char *)(v133 + v132 - 1) = 0;
        }
        else
        {
          *(_WORD *)(a1 + 48) = v134 | 0x8180;
        }
        *(_DWORD *)(a1 + 16) = 2;
        if (*(unsigned char *)(a1 + 104))
        {
          int v135 = *(unsigned __int8 *)(a1 + 105);
          if (*(unsigned char *)(a1 + 105)) {
            int v29 = 7;
          }
          else {
            int v29 = 4;
          }
          if (!WORD4(v140)) {
            goto LABEL_138;
          }
        }
        else
        {
          int v135 = *(unsigned __int8 *)(a1 + 105);
          if (!WORD4(v140))
          {
            if (*(unsigned char *)(a1 + 105))
            {
              int v29 = 5;
            }
            else if (*(void *)(a1 + 80))
            {
              int v29 = 2;
            }
            else
            {
              int v29 = 1;
            }
            goto LABEL_138;
          }
        }
        if (v135) {
          int v29 = 6;
        }
        else {
          int v29 = 3;
        }
LABEL_138:
        uint64_t result = 0;
        goto LABEL_25;
      case 7u:
      case 0xCu:
      case 0xDu:
      case 0xEu:
        goto LABEL_47;
      case 0xAu:
        *(void *)(a1 + 16) = 0x100000003;
        uint64_t v77 = darc_format_entry_get_attribute((uint64_t)a4, "name", 0);
        if (v77 <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1300, (uint64_t)"populate_pkzip_entry_central_directory_header", "PKZip local header format entry is missing %s attribute", v78, v79, v80, (char)"name");
          return 0xFFFFFFFFLL;
        }
        char v81 = v77 + 1;
        AAFieldKey v82 = (char *)platform_calloc(*(void *)(a1 + 8), v77 + 1, 1uLL);
        if (!v82)
        {
          CFBooleanRef v115 = __error();
          strerror(*v115);
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1308, (uint64_t)"populate_pkzip_entry_central_directory_header", "Could not allocate %ld bytes for name buffer: %s", v116, v117, v118, v81);
          return 0xFFFFFFFFLL;
        }
        uint64_t v83 = v82;
        if (darc_format_entry_get_attribute((uint64_t)a4, "name", v82) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1315, (uint64_t)"populate_pkzip_entry_central_directory_header", "Could not get %s attribute", v84, v85, v86, (char)"name");
          return 0xFFFFFFFFLL;
        }
        *(void *)(a1 + 24) = v83;
        size_t v87 = platform_strlen(*(void *)(a1 + 8), v83) - 1;
        uint64_t v88 = *(void *)(a1 + 24);
        int v89 = *(unsigned __int8 *)(v88 + v87);
        if (v89 == 47) {
          *(unsigned char *)(v88 + v87) = 0;
        }
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip central directory header", 0) <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1341, (uint64_t)"populate_pkzip_entry_central_directory_header", "PKZip local header format entry is missing %s attribute", v90, v91, v92, (char)"pkzip central directory header");
          return 0xFFFFFFFFLL;
        }
        memset(v137, 0, sizeof(v137));
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip central directory header", v137) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1350, (uint64_t)"populate_pkzip_entry_central_directory_header", "Could not get %s attribute", v93, v94, v95, (char)"pkzip central directory header");
          return 0xFFFFFFFFLL;
        }
        *(void *)(a1 + 80) = DWORD2(v137[1]);
        time_t v96 = convert_dos_to_unix_time(a1, WORD6(v137[0]), HIWORD(v137[0]));
        *(void *)(a1 + 88) = v96;
        *(void *)(a1 + 72) = v96;
        int v97 = (DWORD2(v137[2]) >> 4) & 1;
        if (v89 == 47) {
          int v97 = 1;
        }
        if (v97) {
          __int16 v98 = 16832;
        }
        else {
          __int16 v98 = -32384;
        }
        if (DWORD2(v137[2]) >> 28) {
          __int16 v98 = WORD5(v137[2]);
        }
        *(_WORD *)(a1 + 48) = v98;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", 0) < 1) {
          return 0;
        }
        long long v140 = 0u;
        long long v141 = 0u;
        if (darc_format_entry_get_attribute((uint64_t)a4, "pkzip extra field InfoZIP UNIX v1", &v140) == -1)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 1393, (uint64_t)"populate_pkzip_entry_central_directory_header", "Could not get %s attribute", v99, v100, v101, (char)"pkzip extra field InfoZIP UNIX v1");
          return 0xFFFFFFFFLL;
        }
        uint64_t v102 = *((void *)&v140 + 1);
        *(void *)(a1 + 88) = v140;
        *(void *)(a1 + 72) = v102;
        if ((_BYTE)v141) {
          *(_DWORD *)(a1 + 52) = DWORD1(v141);
        }
        if (BYTE8(v141)) {
          *(_DWORD *)(a1 + 56) = HIDWORD(v141);
        }
        return 0;
      default:
        capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 909, (uint64_t)"populate_pkzip_entry", "Unsupported format entry type: %d", v34, v35, v36, type);
        return 0xFFFFFFFFLL;
    }
  }
  if (a2 != 3)
  {
    if (a2 != 2)
    {
      capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 258, (uint64_t)"data_archive_entry_set_format_entry", "Unsupported format: %d", a6, a7, a8, a2);
      return 0xFFFFFFFFLL;
    }
    unsigned int v13 = darc_format_entry_get_type(a4);
    if (v13 != 1 && (a3 != 3 || v13 != 3))
    {
      if (v13 != 3)
      {
        uint64_t v14 = darc_format_entry_get_attribute((uint64_t)a4, "name", 0);
        if (v14 >= 1)
        {
          char v15 = v14 + 1;
          uint64_t v16 = platform_calloc(*(void *)(a1 + 8), v14 + 1, 1uLL);
          if (!v16)
          {
            CFTypeID v107 = __error();
            strerror(*v107);
            capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 647, (uint64_t)"populate_posix_ustar_entry", "Could not allocate %ld bytes for name buffer: %s", v108, v109, v110, v15);
            return 0xFFFFFFFFLL;
          }
          unsigned int v17 = v16;
          if (darc_format_entry_get_attribute((uint64_t)a4, "name", v16) == -1)
          {
            capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 654, (uint64_t)"populate_posix_ustar_entry", "Could not get %s attribute", v18, v19, v20, (char)"name");
            return 0xFFFFFFFFLL;
          }
          *(void *)(a1 + 24) = v17;
        }
        if (darc_format_entry_get_attribute((uint64_t)a4, "POSIX ustar header", 0) <= 0)
        {
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 670, (uint64_t)"populate_posix_ustar_entry", "POSIX ustar format entry is missing %s attribute", v21, v22, v23, (char)"POSIX ustar header");
        }
        else
        {
          memset(v137, 0, 40);
          if (darc_format_entry_get_attribute((uint64_t)a4, "POSIX ustar header", v137) != -1)
          {
            *(_WORD *)(a1 + 48) = WORD2(v137[0]);
            *(void *)(a1 + 52) = *((void *)&v137[0] + 1);
            uint64_t v27 = *(void *)&v137[1];
            *(int8x16_t *)(a1 + 72) = vextq_s8((int8x16_t)v137[1], (int8x16_t)v137[1], 8uLL);
            if (LODWORD(v137[0]) <= 4) {
              *(_DWORD *)(a1 + 16) = dword_210662E90[SLODWORD(v137[0])];
            }
            uint64_t result = 0;
            if (v27 <= 0) {
              int v29 = 1;
            }
            else {
              int v29 = 2;
            }
LABEL_25:
            *(_DWORD *)(a1 + 20) = v29;
            return result;
          }
          capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 679, (uint64_t)"populate_posix_ustar_entry", "Could not get %s attribute", v24, v25, v26, (char)"POSIX ustar header");
        }
        return 0xFFFFFFFFLL;
      }
      goto LABEL_47;
    }
    goto LABEL_45;
  }
  unsigned int v57 = darc_format_entry_get_type(a4);
  if (v57 == 5)
  {
LABEL_47:
    uint64_t result = 0;
    uint64_t v58 = 0x100000004;
    goto LABEL_48;
  }
  if (v57 == 1)
  {
LABEL_45:
    uint64_t result = 0;
    uint64_t v58 = 0x100000001;
LABEL_48:
    *(void *)(a1 + 16) = v58;
    return result;
  }
  uint64_t v59 = darc_format_entry_get_attribute((uint64_t)a4, "name", 0);
  if (v59 <= 0)
  {
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 768, (uint64_t)"populate_cpio_entry", "CPIO format entry is missing %s attribute", v60, v61, v62, (char)"name");
    return 0xFFFFFFFFLL;
  }
  char v63 = v59 + 1;
  unsigned __int16 v64 = platform_calloc(*(void *)(a1 + 8), v59 + 1, 1uLL);
  if (!v64)
  {
    int v103 = __error();
    strerror(*v103);
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 776, (uint64_t)"populate_cpio_entry", "Could not allocate %ld bytes for name buffer: %s", v104, v105, v106, v63);
    return 0xFFFFFFFFLL;
  }
  uint64_t v65 = v64;
  if (darc_format_entry_get_attribute((uint64_t)a4, "name", v64) == -1)
  {
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 783, (uint64_t)"populate_cpio_entry", "Could not get %s attribute", v66, v67, v68, (char)"name");
    return 0xFFFFFFFFLL;
  }
  *(void *)(a1 + 24) = v65;
  if (darc_format_entry_get_attribute((uint64_t)a4, "cpio header", 0) <= 0)
  {
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 798, (uint64_t)"populate_cpio_entry", "CPIO format entry is missing %s attribute", v69, v70, v71, (char)"cpio header");
    return 0xFFFFFFFFLL;
  }
  uint64_t v139 = 0;
  long long v138 = 0u;
  memset(v137, 0, sizeof(v137));
  if (darc_format_entry_get_attribute((uint64_t)a4, "cpio header", v137) == -1)
  {
    capture_error(a5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/data_archive/data_archive_entry.c", 807, (uint64_t)"populate_cpio_entry", "Could not get %s attribute", v72, v73, v74, (char)"cpio header");
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 32) = DWORD2(v137[0]);
  *(void *)(a1 + 40) = *(void *)&v137[1];
  *(_WORD *)(a1 + 48) = WORD4(v137[1]);
  *(void *)(a1 + 52) = *(void *)((char *)&v137[1] + 12);
  *(_WORD *)(a1 + 60) = WORD2(v137[2]);
  *(_DWORD *)(a1 + 64) = DWORD2(v137[2]);
  uint64_t v75 = v139;
  *(void *)(a1 + 72) = v138;
  *(void *)(a1 + 80) = v75;
  if (platform_strlen(*(void *)(a1 + 8), *(char **)(a1 + 24)) == 10)
  {
    uint64_t result = platform_strncmp(*(void *)(a1 + 8), "TRAILER!!!", *(char **)(a1 + 24), 0xAuLL);
    *(_DWORD *)(a1 + 20) = 1;
    uint64_t v76 = (_DWORD *)(a1 + 20);
    if (!result)
    {
      *(_DWORD *)(a1 + 16) = 4;
      return result;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 20) = 1;
    uint64_t v76 = (_DWORD *)(a1 + 20);
  }
  *(_DWORD *)(a1 + 16) = 2;
  if (*(uint64_t *)(a1 + 80) < 1) {
    return 0;
  }
  uint64_t result = 0;
  *uint64_t v76 = 2;
  return result;
}

_DWORD *data_archive_entry_get_data_type(_DWORD *result)
{
  if (result)
  {
    if (*result == 1684369012 && result[30] == 1953391972) {
      return (_DWORD *)result[5];
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t data_archive_entry_path(uint64_t result)
{
  if (result)
  {
    if (*(_DWORD *)result == 1684369012 && *(_DWORD *)(result + 120) == 1953391972) {
      return *(void *)(result + 24);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t data_archive_entry_dev(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972) {
    return a1[8];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t data_archive_entry_inode(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 40);
  }
  else {
    return -1;
  }
}

uint64_t data_archive_entry_nlink(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(unsigned __int16 *)(a1 + 60);
  }
  else {
    return 0xFFFFLL;
  }
}

uint64_t data_archive_entry_mode(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(unsigned __int16 *)(a1 + 48);
  }
  else {
    return 0xFFFFLL;
  }
}

uint64_t data_archive_entry_uid(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972) {
    return a1[13];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t data_archive_entry_gid(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972) {
    return a1[14];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t data_archive_entry_size(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 80);
  }
  else {
    return -1;
  }
}

uint64_t data_archive_entry_atime(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 88);
  }
  else {
    return -1;
  }
}

uint64_t data_archive_entry_atime_nsec(_DWORD *a1)
{
  if (!a1 || *a1 != 1684369012) {
    return -1;
  }
  if (a1[30] == 1953391972) {
    return 0;
  }
  return -1;
}

uint64_t data_archive_entry_mtime(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 72);
  }
  else {
    return -1;
  }
}

uint64_t data_archive_entry_ctime(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 96);
  }
  else {
    return -1;
  }
}

uint64_t data_archive_entry_compressed_size(uint64_t a1)
{
  if (a1 && *(_DWORD *)a1 == 1684369012 && *(_DWORD *)(a1 + 120) == 1953391972) {
    return *(void *)(a1 + 112);
  }
  else {
    return -1;
  }
}

uint64_t data_archive_entry_crc32(_DWORD *a1)
{
  if (a1 && *a1 == 1684369012 && a1[30] == 1953391972) {
    return a1[27];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

BOOL data_archive_entry_is_streamed(BOOL result)
{
  if (result) {
    return *(_DWORD *)result == 1684369012 && *(_DWORD *)(result + 120) == 1953391972 && *(unsigned char *)(result + 105) != 0;
  }
  return result;
}

time_t convert_dos_to_unix_time(uint64_t a1, unsigned int a2, unsigned int a3)
{
  memset(&v7, 0, sizeof(v7));
  platform_memset(*(void *)(a1 + 8), &v7, 0, 0x38uLL);
  v7.tm_mon = ((a2 >> 5) & 0xF) - 1;
  v7.tm_year = (a2 >> 9) + 80;
  v7.tm_hour = a3 >> 11;
  v7.tm_mday = a2 & 0x1F;
  v7.tm_sec = 2 * (a3 & 0x1F);
  v7.tm_min = (a3 >> 5) & 0x3F;
  v7.tm_isdst = -1;
  return platform_mktime(*(void *)(a1 + 8), &v7);
}

uint64_t BOMStreamWithBlockID(uint64_t a1, unsigned int a2, unint64_t a3, int a4)
{
  if (a3 > 0xE8D4A51000)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "stream maximum size exceeded: %lu > %lu");
    return 0;
  }
  uint64_t v8 = BOMStorageSizeOfBlock(a1, a2);
  if (!(a3 | v8)) {
    return 0;
  }
  size_t v9 = v8;
  unsigned int v10 = BOM_malloczero(0x58uLL);
  if (!v10)
  {
    uint64_t v16 = (FILE *)*MEMORY[0x263EF8348];
    unsigned int v17 = __error();
    strerror(*v17);
    fprintf(v16, "malloc: %s\n");
    return 0;
  }
  uint64_t v11 = (uint64_t)v10;
  v10[1] = 1;
  *((void *)v10 + 10) = BOMStorageGetSys(a1);
  *(_DWORD *)uint64_t v11 = 0;
  *(void *)(v11 + 8) = a1;
  *(_DWORD *)(v11 + 16) = a2;
  if (a3) {
    unint64_t v12 = a3;
  }
  else {
    unint64_t v12 = v9;
  }
  *(void *)(v11 + 32) = v12;
  *(_DWORD *)(v11 + 40) = a4;
  if (v9 <= a3) {
    size_t v13 = a3;
  }
  else {
    size_t v13 = v9;
  }
  uint64_t v14 = (char *)BOM_malloczero(v13);
  *(void *)(v11 + 48) = v14;
  if (!v14)
  {
    uint64_t v18 = (FILE *)*MEMORY[0x263EF8348];
    uint64_t v19 = __error();
    uint64_t v20 = strerror(*v19);
    fprintf(v18, "malloc: %s\n", v20);
LABEL_17:
    BOMStreamFree(v11);
    return 0;
  }
  *(unsigned char *)(v11 + 72) = 1;
  char v15 = &v14[*(void *)(v11 + 32)];
  *(void *)(v11 + 56) = v14;
  *(void *)(v11 + 64) = v15;
  if ((*(_DWORD *)(v11 + 40) | 2) == 2 && BOMStorageCopyFromBlock(a1, a2, v14)) {
    goto LABEL_17;
  }
  return v11;
}

uint64_t BOMStreamFree(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 73) && BOMStreamFlush((int *)result))
    {
      return 1;
    }
    else
    {
      size_t v2 = *(void **)(v1 + 48);
      if (v2)
      {
        if (*(unsigned char *)(v1 + 72)) {
          free(v2);
        }
      }
      free((void *)v1);
      return 0;
    }
  }
  return result;
}

uint64_t BOMStreamWithFile(int a1, uint64_t a2, unint64_t a3, int a4, char *a5)
{
  return BOMStreamWithFileAndSys(a1, a2, a3, a4, a5, 0);
}

uint64_t BOMStreamWithFileAndSys(int a1, uint64_t a2, unint64_t a3, int a4, char *a5, void *a6)
{
  size_t v6 = a3;
  if (a3 > 0xE8D4A51000)
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "stream maximum size exceeded: %lu > %lu");
    return 0;
  }
  if (!a3) {
    return 0;
  }
  unint64_t v12 = BOM_malloczero(0x58uLL);
  if (!v12)
  {
    uint64_t v14 = (FILE *)*MEMORY[0x263EF8348];
    char v15 = __error();
    strerror(*v15);
    fprintf(v14, "malloc: %s\n");
    return 0;
  }
  uint64_t v13 = (uint64_t)v12;
  if (!a6) {
    a6 = BomSys_default();
  }
  *(void *)(v13 + 80) = a6;
  *(void *)uint64_t v13 = 0x100000001;
  *(_DWORD *)(v13 + 20) = a1;
  *(void *)(v13 + 24) = a2;
  *(void *)(v13 + 32) = v6;
  *(_DWORD *)(v13 + 40) = a4;
  if (a5)
  {
    *(void *)(v13 + 48) = a5;
    *(unsigned char *)(v13 + 72) = 0;
  }
  else
  {
    uint64_t v16 = (char *)BOM_malloczero(v6);
    *(void *)(v13 + 48) = v16;
    if (!v16)
    {
      unsigned int v17 = "malloc: %s\n";
      goto LABEL_19;
    }
    a5 = v16;
    *(unsigned char *)(v13 + 72) = 1;
    size_t v6 = *(void *)(v13 + 32);
    a4 = *(_DWORD *)(v13 + 40);
  }
  *(void *)(v13 + 56) = a5;
  *(void *)(v13 + 64) = &a5[v6];
  if ((a4 | 2) == 2)
  {
    if ((*((uint64_t (**)(void, void, void, void))a6 + 8))(*((void *)a6 + 1), *(unsigned int *)(v13 + 20), *(void *)(v13 + 24), 0) == -1)
    {
      unsigned int v17 = "lseek: %s\n";
      goto LABEL_19;
    }
    if ((*((uint64_t (**)(void, void, void, void))a6 + 6))(*((void *)a6 + 1), *(unsigned int *)(v13 + 20), *(void *)(v13 + 48), *(void *)(v13 + 32)) != *(void *)(v13 + 32))
    {
      unsigned int v17 = "read: %s\n";
LABEL_19:
      uint64_t v18 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v19 = __error();
      uint64_t v20 = strerror(*v19);
      fprintf(v18, v17, v20);
      BOMStreamFree(v13);
      return 0;
    }
  }
  return v13;
}

void *BOMStreamWithAddress(uint64_t a1, unint64_t a2, int a3)
{
  if (a2 <= 0xE8D4A51000)
  {
    if (a2)
    {
      uint64_t result = BOM_malloczero(0x58uLL);
      if (result)
      {
        *uint64_t result = 0x100000002;
        result[4] = a2;
        *((_DWORD *)result + 10) = a3;
        *((unsigned char *)result + 72) = 0;
        result[6] = a1;
        result[7] = a1;
        result[8] = a1 + a2;
        return result;
      }
      tm v7 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v8 = __error();
      strerror(*v8);
      fprintf(v7, "malloc: %s\n");
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8348], "stream maximum size exceeded: %lu > %lu");
  }
  return 0;
}

uint64_t BOMStreamFlush(int *a1)
{
  if (a1)
  {
    if (!a1[10]) {
      goto LABEL_12;
    }
    int v2 = *a1;
    if (*a1 == 2) {
      goto LABEL_12;
    }
    if (v2 != 1)
    {
      if (!v2)
      {
        uint64_t v3 = BOMStorageSetBlockData(*((void *)a1 + 1), a1[4], *((void *)a1 + 6), *((void *)a1 + 4));
LABEL_13:
        *((unsigned char *)a1 + 73) = 0;
        return v3;
      }
      fprintf((FILE *)*MEMORY[0x263EF8348], "unknown stream type: %d\n", *a1);
LABEL_12:
      uint64_t v3 = 0;
      goto LABEL_13;
    }
    if ((*(uint64_t (**)(void, void, void, void))(*((void *)a1 + 10) + 64))(*(void *)(*((void *)a1 + 10) + 8), a1[5], *((void *)a1 + 3), 0) == -1)
    {
      tm v7 = (FILE *)*MEMORY[0x263EF8348];
      uint64_t v8 = __error();
      strerror(*v8);
      fprintf(v7, "lseek: %s\n");
    }
    else
    {
      if ((*(uint64_t (**)(void, void, void, void))(*((void *)a1 + 10) + 56))(*(void *)(*((void *)a1 + 10) + 8), a1[5], *((void *)a1 + 6), *((void *)a1 + 4)) == *((void *)a1 + 4))goto LABEL_12; {
      uint64_t v4 = (FILE *)*MEMORY[0x263EF8348];
      }
      unsigned int v5 = __error();
      strerror(*v5);
      fprintf(v4, "write: %s\n");
    }
    return 1;
  }
  uint64_t v3 = 1;
  fwrite("bad stream!\n", 0xCuLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  return v3;
}

uint64_t BOMStreamGetSys(uint64_t result)
{
  if (result) {
    return *(void *)(result + 80);
  }
  return result;
}

uint64_t BOMStreamSetByteOrder(uint64_t a1, unsigned int a2)
{
  uint64_t result = 1;
  if (a1)
  {
    if (a2 <= 2)
    {
      uint64_t result = 0;
      *(_DWORD *)(a1 + 4) = a2;
    }
  }
  return result;
}

uint64_t BOMStreamGetByteOrder(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 4);
  }
  return result;
}

unint64_t BOMStreamReadUInt64(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v2 = *__error();
    uint64_t v3 = "read called on write-only buffer!\n";
    unsigned __int8 v4 = 0;
    int v5 = 356;
LABEL_5:
    _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
    unint64_t v8 = 0;
    goto LABEL_7;
  }
  size_t v6 = *(unint64_t **)(a1 + 56);
  tm v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > *(void *)(a1 + 64))
  {
    int v2 = *__error();
    uint64_t v3 = "buffer overflow!";
    unsigned __int8 v4 = 1;
    int v5 = 604;
    goto LABEL_5;
  }
  unint64_t v8 = *v6;
  *(void *)(a1 + 56) = v7;
LABEL_7:
  unint64_t v9 = bswap64(v8);
  if (*(_DWORD *)(a1 + 4) == 2) {
    return v8;
  }
  else {
    return v9;
  }
}

uint64_t BOMStreamReadUInt32(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v2 = *__error();
    uint64_t v3 = "read called on write-only buffer!\n";
    unsigned __int8 v4 = 0;
    int v5 = 378;
LABEL_5:
    _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
    unsigned int v8 = 0;
    goto LABEL_7;
  }
  size_t v6 = *(unsigned int **)(a1 + 56);
  tm v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > *(void *)(a1 + 64))
  {
    int v2 = *__error();
    uint64_t v3 = "buffer overflow!";
    unsigned __int8 v4 = 1;
    int v5 = 604;
    goto LABEL_5;
  }
  unsigned int v8 = *v6;
  *(void *)(a1 + 56) = v7;
LABEL_7:
  unsigned int v9 = bswap32(v8);
  if (*(_DWORD *)(a1 + 4) == 2) {
    return v8;
  }
  else {
    return v9;
  }
}

uint64_t BOMStreamReadUInt16(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v2 = *__error();
    uint64_t v3 = "read called on write-only buffer!\n";
    unsigned __int8 v4 = 0;
    int v5 = 400;
LABEL_5:
    _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
    unsigned int v8 = 0;
    goto LABEL_7;
  }
  size_t v6 = *(unsigned __int16 **)(a1 + 56);
  tm v7 = v6 + 1;
  if ((unint64_t)(v6 + 1) > *(void *)(a1 + 64))
  {
    int v2 = *__error();
    uint64_t v3 = "buffer overflow!";
    unsigned __int8 v4 = 1;
    int v5 = 604;
    goto LABEL_5;
  }
  unsigned int v8 = *v6;
  *(void *)(a1 + 56) = v7;
LABEL_7:
  unsigned int v9 = __rev16(v8);
  if (*(_DWORD *)(a1 + 4) == 2) {
    return v8;
  }
  else {
    return v9;
  }
}

uint64_t BOMStreamReadUInt8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v1 = *__error();
    int v2 = "read called on write-only buffer!\n";
    unsigned __int8 v3 = 0;
    int v4 = 422;
  }
  else
  {
    int v5 = *(unsigned __int8 **)(a1 + 56);
    size_t v6 = v5 + 1;
    if ((unint64_t)(v5 + 1) <= *(void *)(a1 + 64))
    {
      uint64_t v7 = *v5;
      *(void *)(a1 + 56) = v6;
      return v7;
    }
    int v1 = *__error();
    int v2 = "buffer overflow!";
    unsigned __int8 v3 = 1;
    int v4 = 604;
  }
  _BOMExceptionHandlerCall((uint64_t)v2, v3, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v4, v1);
  return 0;
}

void *BOMStreamReadBuffer(uint64_t a1, void *__dst, size_t __len)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v3 = *__error();
    int v4 = "read called on write-only buffer!\n";
    unsigned __int8 v5 = 0;
    int v6 = 441;
  }
  else if (__len < 0xE8D4A51001)
  {
    unsigned int v9 = *(const void **)(a1 + 56);
    if ((unint64_t)v9 + __len <= *(void *)(a1 + 64))
    {
      uint64_t result = memmove(__dst, v9, __len);
      *(void *)(a1 + 56) += __len;
      return result;
    }
    int v3 = *__error();
    int v4 = "buffer overflow!";
    unsigned __int8 v5 = 1;
    int v6 = 604;
  }
  else
  {
    int v3 = *__error();
    int v4 = "buffer overflow!";
    unsigned __int8 v5 = 1;
    int v6 = 599;
  }
  return (void *)_BOMExceptionHandlerCall((uint64_t)v4, v5, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v6, v3);
}

uint64_t BOMStreamReadAddress(uint64_t a1, unint64_t a2)
{
  if (*(_DWORD *)(a1 + 40) == 1)
  {
    int v2 = *__error();
    int v3 = "read called on write-only buffer!\n";
    unsigned __int8 v4 = 0;
    int v5 = 464;
  }
  else if (*(_DWORD *)a1 == 2)
  {
    if (a2 < 0xE8D4A51001)
    {
      uint64_t v6 = *(void *)(a1 + 56);
      if (v6 + a2 <= *(void *)(a1 + 64))
      {
        *(void *)(a1 + 56) = v6 + a2;
        return v6;
      }
      int v2 = *__error();
      int v3 = "buffer overflow!";
      unsigned __int8 v4 = 1;
      int v5 = 604;
    }
    else
    {
      int v2 = *__error();
      int v3 = "buffer overflow!";
      unsigned __int8 v4 = 1;
      int v5 = 599;
    }
  }
  else
  {
    int v2 = *__error();
    int v3 = "BOMStreamReadAddress: bad buffer type!\n";
    unsigned __int8 v4 = 0;
    int v5 = 468;
  }
  _BOMExceptionHandlerCall((uint64_t)v3, v4, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v5, v2);
  return 0;
}

uint64_t BOMStreamWriteUInt32(uint64_t result, unsigned int a2)
{
  unsigned int v2 = bswap32(a2);
  if (*(_DWORD *)(result + 4) == 2) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = v2;
  }
  if (*(_DWORD *)(result + 40))
  {
    unsigned __int8 v4 = *(unsigned int **)(result + 56);
    if ((unint64_t)(v4 + 1) <= *(void *)(result + 64))
    {
      *unsigned __int8 v4 = v3;
      *(void *)(result + 56) += 4;
      *(unsigned char *)(result + 73) = 1;
      return result;
    }
    int v5 = *__error();
    uint64_t v6 = "buffer overflow!";
    unsigned __int8 v7 = 1;
    int v8 = 614;
  }
  else
  {
    int v5 = *__error();
    uint64_t v6 = "write called on read-only buffer!\n";
    unsigned __int8 v7 = 0;
    int v8 = 500;
  }
  return _BOMExceptionHandlerCall((uint64_t)v6, v7, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v8, v5);
}

uint64_t BOMStreamWriteUInt16(uint64_t result, __int16 a2)
{
  __int16 v2 = __rev16(a2);
  if (*(_DWORD *)(result + 4) == 2) {
    __int16 v3 = a2;
  }
  else {
    __int16 v3 = v2;
  }
  if (*(_DWORD *)(result + 40))
  {
    unsigned __int8 v4 = *(_WORD **)(result + 56);
    if ((unint64_t)(v4 + 1) <= *(void *)(result + 64))
    {
      *unsigned __int8 v4 = v3;
      *(void *)(result + 56) += 2;
      *(unsigned char *)(result + 73) = 1;
      return result;
    }
    int v5 = *__error();
    uint64_t v6 = "buffer overflow!";
    unsigned __int8 v7 = 1;
    int v8 = 614;
  }
  else
  {
    int v5 = *__error();
    uint64_t v6 = "write called on read-only buffer!\n";
    unsigned __int8 v7 = 0;
    int v8 = 527;
  }
  return _BOMExceptionHandlerCall((uint64_t)v6, v7, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v8, v5);
}

uint64_t BOMStreamWriteUInt8(uint64_t result, char a2)
{
  if (*(_DWORD *)(result + 40))
  {
    __int16 v2 = *(unsigned char **)(result + 56);
    if ((unint64_t)(v2 + 1) <= *(void *)(result + 64))
    {
      *__int16 v2 = a2;
      ++*(void *)(result + 56);
      *(unsigned char *)(result + 73) = 1;
      return result;
    }
    int v3 = *__error();
    unsigned __int8 v4 = "buffer overflow!";
    unsigned __int8 v5 = 1;
    int v6 = 614;
  }
  else
  {
    int v3 = *__error();
    unsigned __int8 v4 = "write called on read-only buffer!\n";
    unsigned __int8 v5 = 0;
    int v6 = 545;
  }
  return _BOMExceptionHandlerCall((uint64_t)v4, v5, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v6, v3);
}

void *BOMStreamWriteBuffer(uint64_t a1, const void *a2, size_t __len)
{
  if (*(_DWORD *)(a1 + 40))
  {
    if (__len < 0xE8D4A51001)
    {
      unsigned int v9 = *(void **)(a1 + 56);
      if ((unint64_t)v9 + __len <= *(void *)(a1 + 64))
      {
        uint64_t result = memmove(v9, a2, __len);
        *(void *)(a1 + 56) += __len;
        *(unsigned char *)(a1 + 73) = 1;
        return result;
      }
      int v4 = *__error();
      unsigned __int8 v5 = "buffer overflow!";
      unsigned __int8 v6 = 1;
      int v7 = 614;
    }
    else
    {
      int v4 = *__error();
      unsigned __int8 v5 = "buffer overflow!";
      unsigned __int8 v6 = 1;
      int v7 = 609;
    }
  }
  else
  {
    int v4 = *__error();
    unsigned __int8 v5 = "write called on read-only buffer!\n";
    unsigned __int8 v6 = 0;
    int v7 = 563;
  }
  return (void *)_BOMExceptionHandlerCall((uint64_t)v5, v6, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v7, v4);
}

uint64_t BOMStreamAdvance(uint64_t result, unint64_t a2)
{
  if (a2 < 0xE8D4A51001)
  {
    unint64_t v4 = *(void *)(result + 56) + a2;
    if (v4 <= *(void *)(result + 64))
    {
      *(void *)(result + 56) = v4;
      return result;
    }
    int v2 = *__error();
    int v3 = 614;
  }
  else
  {
    int v2 = *__error();
    int v3 = 609;
  }
  return _BOMExceptionHandlerCall((uint64_t)"buffer overflow!", 1u, "/Library/Caches/com.apple.xbs/Sources/Bom/Storage/BOMStream.c", v3, v2);
}

char *BOMBomEnumeratorNew(uint64_t a1, unsigned int *a2)
{
  return BOMBomEnumeratorNewWithOptions(a1, a2, 1);
}

char *BOMBomEnumeratorNewWithOptions(uint64_t a1, unsigned int *a2, int a3)
{
  int v3 = 0;
  if (a1)
  {
    if (a3)
    {
      int v7 = (char *)BOM_malloczero(0x440uLL);
      int v3 = v7;
      if (v7)
      {
        size_t v21 = 0;
        *((_DWORD *)v7 + 11) = a3;
        *(void *)int v7 = a1;
        *((void *)v7 + 1) = BOMBomPathsTree(a1);
        *((void *)v3 + 2) = BOMStackNew();
        *((void *)v3 + 3) = BOMStackNew();
        int v8 = BOMStackNew();
        *((void *)v3 + 4) = v8;
        if (!*((void *)v3 + 2) || !*((void *)v3 + 3) || !v8) {
          goto LABEL_20;
        }
        RootFSObject = a2;
        if (!a2)
        {
          RootFSObject = (unsigned int *)BOMBomGetRootFSObject(a1);
          if (!RootFSObject)
          {
            v3[49] = 1;
            return v3;
          }
        }
        signed int v10 = BOMFSObjectParentPathID((uint64_t)RootFSObject);
        uint64_t v11 = (char *)BOMFSObjectShortName((uint64_t)RootFSObject);
        unint64_t v12 = (const char *)BOMFSObjectPathName((uint64_t)RootFSObject);
        v3[48] = BOMFSObjectType(RootFSObject) == 2;
        int v13 = strlen(v12);
        memmove(v3 + 50, v12, v13);
        *((void *)v3 + 135) = &v3[v13 + 50];
        uint64_t v14 = BOMNewPathKey(v10, v11, &v21);
        if ((a3 & 4) != 0)
        {
          CFStringRef Value = (unsigned int *)BOMTreeGetValue(*((void *)v3 + 1), v14, v21);
          free(v14);
          signed int v10 = BOMPathIDFromPathKey(Value);
          uint64_t v14 = BOMNewPathKey(v10, "", &v21);
        }
        if (!a2) {
          BOMFSObjectFree((uint64_t)RootFSObject);
        }
        uint64_t v16 = BOMTreeIteratorNew(*((void *)v3 + 1), v14, v21, 0);
        free(v14);
        if (v16)
        {
          BOMStackPush(*((char **)v3 + 3), (uint64_t)v16);
          BOMStackPush(*((char **)v3 + 2), v10);
          BOMStackPush(*((char **)v3 + 4), 0);
          *((_DWORD *)v3 + 10) = v10;
          if ((a3 & 4) == 0)
          {
            unsigned int v17 = (unsigned __int8 *)(*((void *)v3 + 135) - 1);
            while (1)
            {
              uint64_t v18 = v17 + 1;
              if (v17 + 1 <= (unsigned __int8 *)v3 + 50) {
                break;
              }
              *((void *)v3 + 135) = v17;
              int v19 = *v17--;
              if (v19 == 47)
              {
                uint64_t v18 = v17 + 1;
                break;
              }
            }
            *uint64_t v18 = 0;
          }
        }
        else
        {
LABEL_20:
          BOMBomEnumeratorFree(v3);
          return 0;
        }
      }
    }
  }
  return v3;
}

void BOMBomEnumeratorFree(void *a1)
{
  if (a1)
  {
    int v2 = (void **)*((void *)a1 + 2);
    if (v2) {
      BOMStackFree(v2);
    }
    uint64_t v3 = *((void *)a1 + 3);
    if (v3)
    {
      while (!BOMStackIsEmpty(v3))
      {
        unint64_t v4 = BOMStackPop(*((uint64_t **)a1 + 3));
        BOMTreeIteratorFree((char *)v4);
        uint64_t v3 = *((void *)a1 + 3);
      }
      BOMStackFree(*((void ***)a1 + 3));
    }
    unsigned __int8 v5 = (void **)*((void *)a1 + 4);
    if (v5) {
      BOMStackFree(v5);
    }
    free(a1);
  }
}

_DWORD *BOMBomEnumeratorNext(uint64_t a1)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  if (!a1 || *(unsigned char *)(a1 + 49)) {
    return 0;
  }
  unsigned int v4 = 0;
  unsigned int v5 = 0;
  int v6 = 0;
  size_t v52 = 0;
  unint64_t v7 = a1 + 50;
  int v8 = 1;
  while (2)
  {
    unsigned int v9 = BOMStackPeek(*(void **)(a1 + 24));
    if (!v9)
    {
      FSObjectWithBlockID = 0;
      *(unsigned char *)(a1 + 49) = 1;
      return FSObjectWithBlockID;
    }
    uint64_t v10 = (uint64_t)v9;
    int v11 = 0;
    switch(BOMStackPeek(*(void **)(a1 + 32)))
    {
      case 0u:
        if (BOMTreeIteratorIsAtEnd(v10)) {
          goto LABEL_60;
        }
        unint64_t v12 = (unsigned int *)BOMTreeIteratorKey(v10);
        int v6 = BOMPathIDFromPathKey(v12);
        if (v6 != BOMStackPeek(*(void **)(a1 + 16))) {
          goto LABEL_60;
        }
        int v11 = *(_DWORD *)(a1 + 44) & 1;
        if (v11) {
          int v8 = 1;
        }
        int v13 = (const char *)BOMShortNameFromPathKey((uint64_t)v12);
        size_t v14 = strlen(v13);
        size_t v15 = v14;
        uint64_t v16 = *(unsigned char **)(a1 + 1080);
        if ((uint64_t)&v16[v14 - v7] >= 1024)
        {
          uint64_t v48 = BOMExceptionHandlerMessage("%lu + %p - %p > %d", v14, v16, (const void *)(a1 + 50), 1024);
          uint64_t v49 = __error();
          _BOMFatalException((uint64_t)v48, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBomEnumerator.c", 75, *v49);
        }
        if (v16 != (unsigned char *)v7)
        {
          *(void *)(a1 + 1080) = v16 + 1;
          *uint64_t v16 = 47;
          **(unsigned char **)(a1 + 1080) = 0;
        }
        if ((unint64_t)__strlcat_chk() >= 0x401)
        {
          uint64_t v50 = BOMExceptionHandlerMessage("strlcat(%p, %s, %lu) >= %lu)", (const void *)(a1 + 50), v13, 1025, 1025);
          uint64_t v51 = __error();
          _BOMFatalException((uint64_t)v50, "/Library/Caches/com.apple.xbs/Sources/Bom/Bom/BOMBomEnumerator.c", 83, *v51);
        }
        *(void *)(a1 + 1080) += v15;
        if (v11) {
          __strlcpy_chk();
        }
        unsigned int v17 = (unsigned int *)BOMTreeIteratorValue(v10);
        unsigned int v5 = BOMPathIDFromPathKey(v17);
        unsigned int v4 = BOMBlockIDFromPathValue((uint64_t)v17);
        uint64_t v18 = BOMTreeStorage(*(void *)(a1 + 8));
        int v19 = BOMStorageSizeOfBlock(v18, v4);
        uint64_t v20 = BOM_malloc(v19);
        uint64_t v21 = BOMTreeStorage(*(void *)(a1 + 8));
        if (BOMStorageCopyFromBlock(v21, v4, v20)) {
          goto LABEL_61;
        }
        unsigned int v22 = BOMFSObjectTypeFromRawData((unsigned __int8 *)v20);
        free(v20);
        if (v22 != 2 || (*(unsigned char *)(a1 + 44) & 4) != 0) {
          goto LABEL_39;
        }
        uint64_t v23 = *(void **)(a1 + 32);
        uint64_t v24 = 1;
        goto LABEL_40;
      case 1u:
        if (BOMTreeIteratorIsAtEnd(v10))
        {
          uint64_t v25 = (unsigned __int8 *)(*(void *)(a1 + 1080) - 1);
          while (1)
          {
            uint64_t v26 = v25 + 1;
            if ((unint64_t)(v25 + 1) <= v7) {
              goto LABEL_59;
            }
            *(void *)(a1 + 1080) = v25;
            int v27 = *v25--;
            if (v27 == 47) {
              goto LABEL_58;
            }
          }
        }
        uint64_t v35 = (unsigned int *)BOMTreeIteratorKey(v10);
        int v6 = BOMPathIDFromPathKey(v35);
        if (v6 == BOMStackPeek(*(void **)(a1 + 16)))
        {
          uint64_t v36 = strrchr((char *)(a1 + 50), 47);
          if (v36)
          {
            if (*v36)
            {
              unsigned int v37 = v36 + 1;
              uint64_t v38 = (const char *)BOMShortNameFromPathKey((uint64_t)v35);
              if (strcmp(v37, v38))
              {
                uint64_t v25 = (unsigned __int8 *)(*(void *)(a1 + 1080) - 1);
                while (1)
                {
                  uint64_t v26 = v25 + 1;
                  if ((unint64_t)(v25 + 1) <= v7) {
                    goto LABEL_59;
                  }
                  *(void *)(a1 + 1080) = v25;
                  int v39 = *v25--;
                  if (v39 == 47) {
                    goto LABEL_58;
                  }
                }
              }
            }
          }
          char v41 = (unsigned int *)BOMTreeIteratorValue(v10);
          unsigned int v5 = BOMPathIDFromPathKey(v41);
          __int16 v42 = BOMNewPathKey(v5, "", &v52);
          unsigned int v43 = BOMTreeIteratorNew(*(void *)(a1 + 8), v42, v52, 0);
          free(v42);
          BOMStackPush(*(char **)(a1 + 16), v5);
          BOMStackPush(*(char **)(a1 + 24), (uint64_t)v43);
          BOMStackPush(*(char **)(a1 + 32), 0);
          continue;
        }
        uint64_t v25 = (unsigned __int8 *)(*(void *)(a1 + 1080) - 1);
        while (1)
        {
          uint64_t v26 = v25 + 1;
          if ((unint64_t)(v25 + 1) <= v7) {
            break;
          }
          *(void *)(a1 + 1080) = v25;
          int v40 = *v25--;
          if (v40 == 47)
          {
LABEL_58:
            uint64_t v26 = v25 + 1;
            break;
          }
        }
LABEL_59:
        unsigned char *v26 = 0;
LABEL_60:
        BOMStackPoke(*(void **)(a1 + 32), 3);
        int v11 = 0;
LABEL_61:
        if (!v11) {
          continue;
        }
LABEL_67:
        FSObjectWithBlockID = _BOMBomGetFSObjectWithBlockID(*(void *)a1, v4);
        if (FSObjectWithBlockID)
        {
          uint64_t v46 = __s;
          uint64_t v47 = strrchr(__s, 47);
          if (v47) {
            uint64_t v46 = v47 + 1;
          }
          BOMFSObjectSetPathName((uint64_t)FSObjectWithBlockID, __s, 1);
          BOMFSObjectSetShortName((uint64_t)FSObjectWithBlockID, v46, 1);
          BOMFSObjectSetPathID((uint64_t)FSObjectWithBlockID, v5);
          BOMFSObjectSetParentPathID((uint64_t)FSObjectWithBlockID, v6);
          BOMFSObjectSetBlockID((uint64_t)FSObjectWithBlockID, v4);
          BOMFSObjectSetVisitOrder((uint64_t)FSObjectWithBlockID, v8);
        }
        return FSObjectWithBlockID;
      case 2u:
        if (BOMTreeIteratorIsAtEnd(v10)
          || (unsigned int v28 = (unsigned int *)BOMTreeIteratorKey(v10),
              int v6 = BOMPathIDFromPathKey(v28),
              v6 != BOMStackPeek(*(void **)(a1 + 16))))
        {
          int v11 = 0;
        }
        else
        {
          if ((*(unsigned char *)(a1 + 44) & 2) != 0)
          {
            uint64_t v44 = (unsigned int *)BOMTreeIteratorKey(v10);
            int v6 = BOMPathIDFromPathKey(v44);
            uint64_t v45 = (unsigned int *)BOMTreeIteratorValue(v10);
            unsigned int v5 = BOMPathIDFromPathKey(v45);
            unsigned int v4 = BOMBlockIDFromPathValue((uint64_t)v45);
            __strlcpy_chk();
            int v8 = 2;
            int v11 = 1;
          }
          else
          {
            int v11 = 0;
          }
          BOMTreeIteratorNext(v10);
        }
        int v29 = (unsigned __int8 *)(*(void *)(a1 + 1080) - 1);
        while (1)
        {
          uint64_t v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) <= v7) {
            break;
          }
          *(void *)(a1 + 1080) = v29;
          int v31 = *v29--;
          if (v31 == 47)
          {
            uint64_t v30 = v29 + 1;
            break;
          }
        }
        unsigned char *v30 = 0;
LABEL_37:
        if (!BOMTreeIteratorIsAtEnd(v10)
          && *(unsigned char *)(a1 + 48)
          && (unsigned int v33 = BOMStackPeek(*(void **)(a1 + 16)),
              uint64_t v34 = (unsigned int *)BOMTreeIteratorKey(v10),
              BOMPathIDFromPathKey(v34) == v33)
          && ((*(unsigned char *)(a1 + 44) & 4) != 0 || *(_DWORD *)(a1 + 40) != BOMStackPeek(*(void **)(a1 + 16))))
        {
          uint64_t v23 = *(void **)(a1 + 32);
          uint64_t v24 = 0;
        }
        else
        {
          int v32 = BOMStackPop(*(uint64_t **)(a1 + 24));
          BOMTreeIteratorFree((char *)v32);
          BOMStackPop(*(uint64_t **)(a1 + 16));
          BOMStackPop(*(uint64_t **)(a1 + 32));
LABEL_39:
          uint64_t v23 = *(void **)(a1 + 32);
          uint64_t v24 = 2;
        }
LABEL_40:
        BOMStackPoke(v23, v24);
        if (v11) {
          goto LABEL_67;
        }
        continue;
      case 3u:
        goto LABEL_37;
      default:
        goto LABEL_61;
    }
  }
}

void *BOMBomEnumeratorSkip(void *result)
{
  if (result)
  {
    int v1 = result;
    if (!*((unsigned char *)result + 49))
    {
      uint64_t result = BOMStackPeek((void *)result[4]);
      if (result == 1)
      {
        int v2 = (void *)v1[4];
        return BOMStackPoke(v2, 2);
      }
    }
  }
  return result;
}

uint64_t BOMBomEnumeratorSkipAll(uint64_t result)
{
  if (result)
  {
    if (!*(unsigned char *)(result + 49)) {
      *(_DWORD *)(result + 44) |= 4u;
    }
  }
  return result;
}

uint64_t BOMAppleDoublePathToADPath(char *__s, char *a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (__s && a2)
  {
    unsigned int v5 = __s;
    if (__s == a2)
    {
      size_t v6 = strlen(__s) + 1;
      unint64_t v7 = (char *)BOM_malloc(v6);
      if (!v7) {
        return 0xFFFFFFFFLL;
      }
      unsigned int v5 = v7;
      strlcpy(v7, __s, v6);
    }
    int v8 = rindex(v5, 47);
    if (v8) {
      unsigned int v9 = v8 + 1;
    }
    else {
      unsigned int v9 = v5;
    }
    *a2 = 0;
    if (v8)
    {
      size_t v10 = v8 - v5 + 1;
      memmove(a2, v5, v10);
      a2[v10] = 0;
    }
    strlcat(a2, "._", 0x400uLL);
    strlcat(a2, v9, 0x400uLL);
    if (__s == a2) {
      free(v5);
    }
    return 0;
  }
  return result;
}

uint64_t BOMAppleDoubleADPathToPath(char *a1, void *a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    unsigned int v5 = rindex(a1, 47);
    size_t v6 = v5;
    if (v5) {
      unint64_t v7 = v5 + 1;
    }
    else {
      unint64_t v7 = a1;
    }
    int v8 = &v7[2 * (strncmp("._", v7, 2uLL) == 0)];
    if (v6)
    {
      size_t v9 = v6 - a1 + 1;
      memmove(a2, a1, v9);
      *((unsigned char *)a2 + v9) = 0;
    }
    strlcat((char *)a2, v8, 0x400uLL);
    return 0;
  }
  return result;
}

uint64_t BOMAppleDoubleIsADFile(const char *a1)
{
  if (!a1) {
    return 255;
  }
  int v2 = rindex(a1, 47);
  if (v2) {
    uint64_t v3 = v2 + 1;
  }
  else {
    uint64_t v3 = a1;
  }
  return strncmp(v3, "._", 2uLL) == 0;
}

uint64_t BOMAppleDoubleSize(int a1, int a2)
{
  return (a1 + a2 + 50);
}

uint64_t BOMAppleDoubleCopyHeader(unsigned int a1, unsigned int a2, void *a3, void *a4)
{
  int v8 = (char *)BOM_malloc(0x32uLL);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  size_t v9 = v8;
  uint64_t result = 0;
  *(void *)size_t v9 = 0x20007160500;
  *(_OWORD *)(v9 + 8) = 0uLL;
  *((_WORD *)v9 + 12) = 512;
  *(void *)(v9 + 26) = 0x3200000009000000;
  *(_DWORD *)(v9 + 34) = bswap32(a1);
  LODWORD(v11) = 0x2000000;
  HIDWORD(v11) = bswap32(a1 + 50);
  *(void *)(v9 + 38) = v11;
  *(_DWORD *)(v9 + 46) = bswap32(a2);
  *a3 = v9;
  *a4 = 50;
  return result;
}

uint64_t BOMAppleDoubleWriteHeader(uint64_t a1, unsigned int a2, unsigned int a3)
{
  CFIndex v6 = 0;
  unint64_t v7 = 0;
  if (BOMAppleDoubleCopyHeader(a2, a3, &v7, &v6)) {
    return 0xFFFFFFFFLL;
  }
  CFIndex v5 = v6;
  if (BOMFileWrite(a1, v7, v6) == v5) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t BOMAppleDoubleReadHeader(int *a1, unsigned int *a2, unsigned int *a3)
{
  return BOMAppleDoubleReadHeaderWithOffsets(a1, a2, 0, a3, 0);
}

uint64_t BOMAppleDoubleReadHeaderWithOffsets(int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a4)
  {
    unsigned int v20 = 0;
    unint64_t v19 = 0;
    *a2 = 0;
    *a4 = 0;
    memset(v21, 0, sizeof(v21));
    unsigned __int16 v22 = 0;
    if (BOMFileRead(a1, (char *)v21, 0x1AuLL) == 26)
    {
      int v12 = v21[0];
      int v11 = HIDWORD(v21[0]);
      v21[0] = _byteswap_uint64(__PAIR64__(v21[0], HIDWORD(v21[0])));
      int v13 = v22;
      unsigned __int16 v22 = __rev16(v22);
      uint64_t result = 0xFFFFFFFFLL;
      if (v12 == 118883584 && v11 == 512)
      {
        if (v13)
        {
          int v14 = 0;
          while (1)
          {
            if (BOMFileRead(a1, (char *)&v19, 0xCuLL) != 12) {
              return 0xFFFFFFFFLL;
            }
            unsigned int v15 = bswap32(v19);
            unsigned int v16 = bswap32(HIDWORD(v19));
            unint64_t v19 = __PAIR64__(v16, v15);
            unsigned int v17 = bswap32(v20);
            unsigned int v20 = v17;
            if (v15 != 2) {
              break;
            }
            *a4 = v17;
            uint64_t v18 = a5;
            if (a5) {
              goto LABEL_14;
            }
LABEL_15:
            if (++v14 >= v22) {
              return 0;
            }
          }
          if (v15 != 9) {
            goto LABEL_15;
          }
          *a2 = v17;
          uint64_t v18 = a3;
          if (!a3) {
            goto LABEL_15;
          }
LABEL_14:
          *uint64_t v18 = v16;
          goto LABEL_15;
        }
        return 0;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t BOMCPIONew(uint64_t **a1, uint64_t a2, char a3, int a4)
{
  int v8 = (uint64_t *)BOM_malloc(0x468uLL);
  if (v8)
  {
    size_t v9 = v8;
    *int v8 = a2;
    *((unsigned char *)v8 + 8) = a3;
    *((_DWORD *)v8 + 3) = a4;
    *((unsigned char *)v8 + 24) = 0;
    size_t v10 = BOMHardLinkTableNew();
    _DWORD v9[2] = (uint64_t)v10;
    if (v10)
    {
      uint64_t result = 0;
      *a1 = v9;
      return result;
    }
    BOMCPIOFree(v9);
  }
  return 0xFFFFFFFFLL;
}

void BOMCPIOFree(uint64_t *a1)
{
  if (a1)
  {
    int v2 = (const void **)a1[2];
    if (v2) {
      BOMHardLinkTableFree(v2);
    }
    if (*((unsigned char *)a1 + 8)) {
      BOMFileClose(*a1);
    }
    free(a1);
  }
}

uint64_t BOMCPIOWriteHeader(uint64_t a1, char *__s, uint64_t a3)
{
  int v6 = strlen(__s) + 1;
  return BOMCPIOWriteHeaderAndData(a1, a3, __s, v6, 0, 0);
}

uint64_t BOMCPIOWriteHeaderAndData(uint64_t a1, uint64_t a2, void *a3, int a4, void *a5, int a6)
{
  if ((*(_WORD *)(a2 + 4) & 0xF000) == 0x8000 && *(unsigned __int16 *)(a2 + 6) >= 2u)
  {
    int v12 = BOMHardLinkTableGet(*(CFDictionaryRef **)(a1 + 16), *(_DWORD *)a2, *(void *)(a2 + 8));
    if (v12)
    {
      uint64_t v13 = *(void *)v12;
    }
    else
    {
      uint64_t v19 = *(unsigned int *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = v19 + 1;
      *(void *)bytes = v19;
      BOMHardLinkTableSet(*(CFDictionaryRef **)(a1 + 16), *(_DWORD *)a2, *(void *)(a2 + 8), bytes, 8);
      LODWORD(v13) = *(_DWORD *)bytes;
    }
  }
  else
  {
    LODWORD(v13) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 12) = v13 + 1;
  }
  *(void *)bytes = (unsigned __int16)v13;
  int v14 = *(unsigned __int16 *)(a2 + 4);
  if ((v14 & 0xD000 | 0x2000) == 0xA000)
  {
    unint64_t v15 = *(void *)(a2 + 96);
    if (v15 >> 33)
    {
      *__error() = 27;
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    unint64_t v15 = 0;
  }
  snprintf((char *)(a1 + 25), 0x4DuLL, "%s%06ho%06ho%06ho%06ho%06ho%06ho%06ho%011o%06ho%011llo", "070707", WORD1(v13), (unsigned __int16)v13, v14, *(unsigned __int16 *)(a2 + 16), *(unsigned __int16 *)(a2 + 20), *(unsigned __int16 *)(a2 + 6), *(unsigned __int16 *)(a2 + 24), *(void *)(a2 + 48), (unsigned __int16)a4, v15);
  int v16 = a4 + a6 + 76;
  if (v16 < 0x44D)
  {
    CFIndex v18 = v16;
    memcpy((void *)(a1 + 101), a3, a4);
    if (a5) {
      memcpy((void *)(a1 + 101 + a4), a5, a6);
    }
    if (BOMFileWrite(*(void *)a1, (UInt8 *)(a1 + 25), v18) != v18) {
      return 0xFFFFFFFFLL;
    }
  }
  else if (BOMFileWrite(*(void *)a1, (UInt8 *)(a1 + 25), 76) != 76 {
         || BOMFileWrite(*(void *)a1, (UInt8 *)a3, a4) != a4
  }
         || a5 && BOMFileWrite(*(void *)a1, (UInt8 *)a5, a6) != a6)
  {
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t BOMCPIOWriteDirectory(uint64_t a1, char *__s, uint64_t a3)
{
  int v6 = strlen(__s) + 1;
  return BOMCPIOWriteHeaderAndData(a1, a3, __s, v6, 0, 0);
}

uint64_t BOMCPIOWriteDevice(uint64_t a1, char *__s, uint64_t a3)
{
  int v6 = strlen(__s) + 1;
  return BOMCPIOWriteHeaderAndData(a1, a3, __s, v6, 0, 0);
}

uint64_t BOMCPIOWriteSymlink(uint64_t a1, char *__s, uint64_t a3, char *a4)
{
  int v8 = strlen(__s);
  uint64_t v9 = *(void *)(a3 + 96);
  size_t v10 = strlen(a4);
  *(void *)(a3 + 96) = v10;
  uint64_t result = BOMCPIOWriteHeaderAndData(a1, a3, __s, v8 + 1, a4, v10);
  *(void *)(a3 + 96) = v9;
  return result;
}

uint64_t BOMCPIOWriteTerminator(uint64_t *a1)
{
  memset(v8, 0, sizeof(v8));
  WORD3(v8[0]) = 1;
  if (BOMCPIOWriteHeaderAndData((uint64_t)a1, (uint64_t)v8, "TRAILER!!!", 11, 0, 0)) {
    return 0xFFFFFFFFLL;
  }
  BOOL v2 = 1;
  uint64_t v3 = (UInt8 *)BOM_calloc(0x200uLL, 1uLL);
  if (v3)
  {
    unsigned int v4 = v3;
    uint64_t v5 = BOMFileUncompressedOffset(*a1);
    if (v5 <= 0) {
      uint64_t v6 = -(-v5 & 0x1FF);
    }
    else {
      uint64_t v6 = v5 & 0x1FF;
    }
    BOOL v2 = BOMFileWrite(*a1, v4, 512 - v6) != 512 - v6;
    free(v4);
  }
  return v2;
}

uint64_t BOMCPIOReadHeader(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 24)) {
    return 4;
  }
  unsigned __int16 v22 = 0;
  int v20 = 0;
  int v21 = 0;
  unsigned __int16 v19 = 0;
  unsigned int v18 = 0;
  uint64_t v17 = 0;
  if (BOMFileRead(*(int **)a1, v24, 0x4CuLL) != 76) {
    return 0xFFFFFFFFLL;
  }
  v24[76] = 0;
  if (sscanf(v24, "%06s%06ho%06ho%06ho%06ho%06ho%06ho%06ho%011o%06ho%011llo", v23, (char *)&v21 + 2, &v21, a3 + 4, (char *)&v20 + 2, &v20, a3 + 6, &v19, &v18, &v22, &v17) != 11)return 3; {
  *(_DWORD *)a3 = HIWORD(v21);
  }
  *(void *)(a3 + 8) = (unsigned __int16)v21;
  int v7 = (unsigned __int16)v20;
  *(_DWORD *)(a3 + 16) = HIWORD(v20);
  *(_DWORD *)(a3 + 20) = v7;
  *(_DWORD *)(a3 + 24) = v19;
  BOOL v8 = v23[0] == 925906736 && *(_DWORD *)((char *)v23 + 3) == 3616823;
  uint64_t v9 = v18;
  *(void *)(a3 + 96) = v17;
  *(_DWORD *)(a3 + 116) = 0;
  *(void *)(a3 + 32) = v9;
  *(void *)(a3 + 40) = 0;
  *(void *)(a3 + 48) = v9;
  *(void *)(a3 + 56) = 0;
  if (!v8 || v22 > 0x400uLL) {
    return 3;
  }
  unint64_t v10 = BOMFileRead(*(int **)a1, a2, v22);
  int v11 = v22;
  if ((v10 & 0x8000000000000000) != 0 || (uint64_t v12 = v10, v10 != v22))
  {
    int v14 = (FILE *)*MEMORY[0x263EF8348];
    unint64_t v15 = __error();
    int v16 = strerror(*v15);
    fprintf(v14, "can't read path of size %d: %s\n", v11, v16);
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = 0;
  if (v22)
  {
    uint64_t result = 3;
    while (a2[v13])
    {
      if (v12 == ++v13) {
        return result;
      }
    }
  }
  if (v13 == v12 || a2[v13]) {
    return 3;
  }
  if (!strcmp(a2, "TRAILER!!!"))
  {
    *(unsigned char *)(a1 + 24) = 1;
    return 4;
  }
  return _sanitizePath(a2, v12);
}

uint64_t BOMCPIOGetFile(uint64_t a1)
{
  return *(void *)a1;
}

unint64_t BOMCPIORead(int **a1, char *a2, unint64_t a3)
{
  return BOMFileRead(*a1, a2, a3);
}

CFIndex BOMCPIOWrite(uint64_t *a1, UInt8 *a2, CFIndex a3)
{
  return BOMFileWrite(*a1, a2, a3);
}

unint64_t BOMCPIOSeek()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v3 = (int **)v0;
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (v4 == 1)
  {
    if (v1)
    {
      while (1)
      {
        unint64_t v5 = v2 >= 0x20000 ? 0x20000 : v2;
        unint64_t result = BOMFileRead(*v3, v7, v5);
        if (result == -1) {
          break;
        }
        if (result)
        {
          v2 -= result;
          if (v2) {
            continue;
          }
        }
        return 1;
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return BOMFileSeek();
  }
  return result;
}

uint64_t BOMPKZipNew(void *a1, uint64_t a2, char a3)
{
  uint64_t v6 = BOM_malloczero(0x58uLL);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  int v7 = v6;
  *(void *)uint64_t v6 = a2;
  v6[8] = a3;
  *((_DWORD *)v6 + 12) = 16;
  uint64_t v8 = BOM_calloc(0x10uLL, 0x40uLL);
  *((void *)v7 + 5) = v8;
  if (!v8) {
    return 1;
  }
  uint64_t result = 0;
  *a1 = v7;
  return result;
}

void BOMPKZipFree(void *a1)
{
  if (*((_DWORD *)a1 + 13))
  {
    unint64_t v2 = 0;
    uint64_t v3 = 40;
    do
    {
      free(*(void **)(a1[5] + v3));
      ++v2;
      v3 += 64;
    }
    while (v2 < *((unsigned int *)a1 + 13));
  }
  int v4 = (void *)a1[5];
  if (v4) {
    free(v4);
  }
  if (*((unsigned char *)a1 + 8)) {
    BOMFileClose(*a1);
  }
  if (*((_DWORD *)a1 + 16))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      free(*(void **)(a1[7] + v5));
      ++v6;
      v5 += 16;
    }
    while (v6 < *((unsigned int *)a1 + 16));
  }
  int v7 = (void *)a1[7];
  if (v7) {
    free(v7);
  }
  uint64_t v8 = (void *)a1[10];
  if (v8) {
    free(v8);
  }
  free(a1);
}

uint64_t BOMPKZipGetFile(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t BOMPKZipReadNextSignature(uint64_t a1, int *a2)
{
  uint64_t result = 1;
  if (a1 && a2)
  {
    int v9 = 0;
    __int16 v8 = 0;
    while (1)
    {
      if (BOMFileRead(*(int **)a1, (char *)&v9, 4uLL) != 4) {
        return 1;
      }
      if (v9 <= 101010255)
      {
        switch(v9)
        {
          case 33639248:
            uint64_t result = 0;
            int v7 = 2;
            goto LABEL_30;
          case 67324752:
            goto LABEL_26;
          case 84233040:
            uint64_t result = 0;
            int v7 = 3;
            goto LABEL_30;
        }
      }
      else if (v9 > 117853007)
      {
        if (v9 == 117853008)
        {
          uint64_t result = 0;
          int v7 = 5;
          goto LABEL_30;
        }
        if (v9 == 808471376) {
          return BOMPKZipReadNextSignature(a1, a2);
        }
      }
      else
      {
        if (v9 == 101010256)
        {
          uint64_t result = 0;
          int v7 = 6;
          goto LABEL_30;
        }
        if (v9 == 101075792)
        {
          uint64_t result = 0;
          int v7 = 4;
LABEL_30:
          *a2 = v7;
          return result;
        }
      }
      __int16 v8 = 19280;
      if ((unsigned __int16)v9 == 19280)
      {
        if (BOMFileRead(*(int **)a1, (char *)&v8, 2uLL) != 2) {
          return 1;
        }
        if (v8 == 1027)
        {
LABEL_26:
          uint64_t result = 0;
          int v7 = 1;
          goto LABEL_30;
        }
      }
      uint64_t v5 = *(void *)(a1 + 80);
      if (v5)
      {
        unsigned int v6 = *(_DWORD *)(a1 + 12) - 1;
        if (*(_DWORD *)(a1 + 72) <= v6) {
          LODWORD(v5) = 0;
        }
        else {
          LODWORD(v5) = *(_DWORD *)(v5 + 12 * v6);
        }
      }
      if (v5 != v9)
      {
        *a2 = 0;
        return 1;
      }
    }
  }
  return result;
}

uint64_t BOMPKZipGetNumLocalHeaders(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 12);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t BOMPKZipReadLocalHeader(uint64_t a1, char *a2, uint64_t a3, unint64_t *a4, _DWORD *a5, unsigned char *a6, int *a7, unsigned int *a8, unsigned char *a9)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t result = 1;
  if (a1 && a2 && a3 && a4)
  {
    if (BOMFileRead(*(int **)a1, v44, 0x1AuLL) != 26) {
      return 1;
    }
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    unsigned int v18 = BOMStreamWithAddress((uint64_t)v44, 0x1AuLL, 0);
    if (!v18) {
      return 1;
    }
    uint64_t v19 = (uint64_t)v18;
    if (BOMStreamSetByteOrder((uint64_t)v18, 2u))
    {
      uint64_t v20 = v19;
LABEL_9:
      BOMStreamFree(v20);
      return 1;
    }
    BOMStreamReadUInt16(v19);
    unsigned int UInt16 = BOMStreamReadUInt16(v19);
    *a5 = BOMStreamReadUInt16(v19);
    int v21 = BOMStreamReadUInt16(v19);
    int v22 = BOMStreamReadUInt16(v19);
    unsigned int UInt32 = BOMStreamReadUInt32(v19);
    *a4 = BOMStreamReadUInt32(v19);
    *(void *)(a3 + 96) = BOMStreamReadUInt32(v19);
    unsigned int v43 = BOMStreamReadUInt16(v19);
    unsigned int v41 = BOMStreamReadUInt16(v19);
    time_t v23 = _dos2unixtime(v21 | (v22 << 16));
    *(_DWORD *)(a3 + 116) = 0;
    *(void *)(a3 + 32) = v23;
    *(void *)(a3 + 40) = 0;
    *(void *)(a3 + 48) = v23;
    *(void *)(a3 + 56) = 0;
    if (a6) {
      *a6 = UInt16 & 1;
    }
    if (a7) {
      *a7 = (UInt16 >> 3) & 1;
    }
    *a9 = 0;
    if (a8)
    {
      unsigned int v24 = (v21 << 16) & 0xFF000000;
      if ((UInt16 & 8) == 0) {
        unsigned int v24 = UInt32;
      }
      *a8 = v24;
    }
    BOMStreamFree(v19);
    if (v43)
    {
      if (v43 > 0x3FF) {
        return 1;
      }
      uint64_t v25 = v43;
      if (BOMFileRead(*(int **)a1, a2, v43) != v43) {
        return 1;
      }
      __int16 v26 = *(_WORD *)(a3 + 4);
      if (a2[v43 - 1] == 47)
      {
        *(_WORD *)(a3 + 4) = v26 | 0x41C0;
        uint64_t v25 = (unsigned __int16)(v43 - 1);
      }
      else
      {
        *(_WORD *)(a3 + 4) = v26 | 0x8180;
      }
      a2[v25] = 0;
      BOOL v32 = _sanitizePath(a2, v25);
      unsigned int v27 = v41;
      if (v32) {
        return 1;
      }
    }
    else
    {
      *a2 = 0;
      unsigned int v27 = v41;
    }
    if (!v27)
    {
LABEL_62:
      uint64_t result = 0;
      ++*(_DWORD *)(a1 + 12);
      return result;
    }
    unint64_t v28 = v27;
    if (v27 < 0x1B)
    {
      int v29 = v44;
    }
    else
    {
      int v29 = (char *)BOM_malloc(v27);
      if (!v29) {
        return 1;
      }
    }
    if (BOMFileRead(*(int **)a1, v29, v28) != v28)
    {
      if (v29 != v44) {
        free(v29);
      }
      return 1;
    }
    uint64_t v30 = BOMStreamWithAddress((uint64_t)v29, v28, 0);
    if (!v30) {
      return 1;
    }
    uint64_t v31 = (uint64_t)v30;
    if (BOMStreamSetByteOrder((uint64_t)v30, 2u))
    {
LABEL_34:
      uint64_t v20 = v31;
      goto LABEL_9;
    }
    int v33 = 0;
    unsigned int v34 = v41;
    while (1)
    {
      int v35 = BOMStreamReadUInt16(v31);
      unsigned int v36 = BOMStreamReadUInt16(v31);
      int v37 = v33 + 4;
      if (v36 + (unsigned __int16)v37 > v34) {
        goto LABEL_34;
      }
      unsigned int v38 = v36;
      if (v35 == 1)
      {
        if (*(void *)(a3 + 96) == 0xFFFFFFFFLL)
        {
          *(void *)(a3 + 96) = BOMStreamReadUInt64(v31);
          int v39 = 8;
        }
        else
        {
          int v39 = 0;
        }
        if (*a4 == 0xFFFFFFFF)
        {
          *a4 = BOMStreamReadUInt64(v31);
          v39 += 8;
        }
        *a9 = 1;
        goto LABEL_55;
      }
      if (v35 != 22613)
      {
        int v39 = 0;
        goto LABEL_55;
      }
      *(void *)(a3 + 32) = BOMStreamReadUInt32(v31);
      *(void *)(a3 + 48) = BOMStreamReadUInt32(v31);
      if (v38 < 0xA) {
        break;
      }
      *(_DWORD *)(a3 + 16) = BOMStreamReadUInt16(v31);
      if (v38 != 12)
      {
        int v39 = 10;
LABEL_55:
        if (v38 != v39) {
          BOMStreamAdvance(v31, (unsigned __int16)(v38 - v39));
        }
        goto LABEL_57;
      }
      *(_DWORD *)(a3 + 20) = BOMStreamReadUInt16(v31);
LABEL_57:
      int v33 = v38 + v37;
      unsigned int v34 = v41;
      if (v41 == (unsigned __int16)v33)
      {
        BOMStreamFree(v31);
        if (v29 != v44) {
          free(v29);
        }
        goto LABEL_62;
      }
    }
    int v39 = 8;
    goto LABEL_55;
  }
  return result;
}

time_t _dos2unixtime(unsigned int a1)
{
  time_t v6 = time(0);
  unint64_t v2 = localtime(&v6);
  v3.i32[0] = a1;
  int8x16_t v4 = (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(a1), (uint32x4_t)xmmword_210662ED0);
  v4.i32[0] = vshlq_u32(v3, (uint32x4_t)xmmword_210662EC0).u32[0];
  *(int8x16_t *)&v2->tm_sec = vandq_s8(v4, (int8x16_t)xmmword_210662EE0);
  v2->tm_mon = ((a1 >> 21) & 0xF) - 1;
  v2->tm_year = (a1 >> 25) + 80;
  return mktime(v2);
}

uint64_t BOMPKZipWriteLocalHeader(uint64_t a1, char *__s, uint64_t a3, int a4, int a5)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v5 = 1;
  if (a1)
  {
    time_t v6 = __s;
    if (__s)
    {
      if (a3)
      {
        __int16 v11 = strlen(__s);
        int v12 = *v6;
        if (v12 != 46 || v11 != 1)
        {
          if (v12 == 46)
          {
            if (v6[1] == 47)
            {
              int v13 = v6[2];
              v6 += 2;
              int v12 = v13;
              v11 -= 2;
            }
            else
            {
              int v12 = 46;
            }
          }
          BOOL v14 = v12 == 47;
          __int16 v15 = v12 == 47;
          if (v14) {
            int v16 = v6 + 1;
          }
          else {
            int v16 = v6;
          }
          unsigned __int16 v17 = v11 - v15;
          int v18 = (unsigned __int16)(v11 - v15);
          int v19 = *(_WORD *)(a3 + 4) & 0xF000;
          if (v19 == 0x4000)
          {
            __memcpy_chk();
            v40[0] = 0;
            __int16 v23 = 0;
            __int16 v39 = 0;
            v41[v17++] = 47;
            v41[v17] = 0;
            unsigned int v20 = v18 + 47;
            __int16 v22 = 10;
            __src = v41;
          }
          else
          {
            unsigned int v20 = v18 + 46;
            __src = v16;
            if (v19 == 40960)
            {
              __int16 v23 = 0;
              __int16 v39 = 0;
              v40[0] = *(_DWORD *)(a3 + 96);
              __int16 v22 = 10;
            }
            else if (v19 == 0x8000)
            {
              *(void *)int v40 = *(void *)(a3 + 96);
              __int16 v21 = *(void *)v40 != 0;
              if (*(void *)v40) {
                __int16 v22 = 20;
              }
              else {
                __int16 v22 = 10;
              }
              __int16 v23 = 8 * v21;
              __int16 v39 = 8 * v21;
            }
            else
            {
              v40[0] = 0;
              __int16 v39 = 0;
              __int16 v23 = 8;
              __int16 v22 = 20;
            }
          }
          unint64_t v24 = v20;
          uint64_t v25 = BOM_malloc(v20);
          if (v25)
          {
            __int16 v26 = v25;
            __int16 v37 = v22;
            uint64_t v5 = 1;
            unsigned int v27 = BOMStreamWithAddress((uint64_t)v25, v24, 1);
            if (!v27) {
              return v5;
            }
            uint64_t v28 = (uint64_t)v27;
            if (BOMStreamSetByteOrder((uint64_t)v27, 2u))
            {
              BOMStreamFree(v28);
              free(v26);
              return v5;
            }
            BOMStreamWriteUInt32(v28, 0x4034B50u);
            BOMStreamWriteUInt16(v28, v37);
            BOMStreamWriteUInt16(v28, v23);
            BOMStreamWriteUInt16(v28, v39);
            unsigned int v29 = _unix2dostime((void *)(a3 + 48));
            BOMStreamWriteUInt32(v28, v29);
            int v30 = *(_WORD *)(a3 + 4) & 0xF000;
            if (v30 == 40960) {
              unsigned int v31 = a4;
            }
            else {
              unsigned int v31 = 0;
            }
            if (v30 == 40960) {
              unsigned int v32 = a5;
            }
            else {
              unsigned int v32 = 0;
            }
            if (v30 == 40960) {
              unsigned int v33 = v40[0];
            }
            else {
              unsigned int v33 = 0;
            }
            BOMStreamWriteUInt32(v28, v31);
            BOMStreamWriteUInt32(v28, v32);
            BOMStreamWriteUInt32(v28, v33);
            BOMStreamWriteUInt16(v28, v17);
            BOMStreamWriteUInt16(v28, 16 * ((*(_WORD *)(a3 + 4) & 0xF000) != 40960));
            BOMStreamWriteBuffer(v28, __src, v17);
            if ((*(_WORD *)(a3 + 4) & 0xF000) == 0xA000)
            {
              unint64_t v24 = (v24 - 16);
            }
            else
            {
              BOMStreamWriteUInt16(v28, 22613);
              BOMStreamWriteUInt16(v28, 12);
              BOMStreamWriteUInt32(v28, *(_DWORD *)(a3 + 32));
              BOMStreamWriteUInt32(v28, *(_DWORD *)(a3 + 48));
              BOMStreamWriteUInt16(v28, *(_WORD *)(a3 + 16));
              BOMStreamWriteUInt16(v28, *(_WORD *)(a3 + 20));
            }
            BOMStreamFree(v28);
            int v34 = BOMFileOffset(*(void *)a1);
            CFIndex v35 = BOMFileWrite(*(void *)a1, (UInt8 *)v26, v24);
            free(v26);
            if (v35 == v24 && !_squirrelAwayInfo(a1, v34, v37, v39, a3, a4, a5, v40[0], v17, __src))
            {
              uint64_t v5 = 0;
              ++*(_DWORD *)(a1 + 12);
              return v5;
            }
          }
          return 1;
        }
        return 0;
      }
    }
  }
  return v5;
}

uint64_t _unix2dostime(void *a1)
{
  time_t v4 = (*a1 + 1) & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v1 = localtime(&v4);
  int tm_year = v1->tm_year;
  if (tm_year >= 80) {
    return ((tm_year << 25) + 1610612736) | (v1->tm_sec >> 1) | (32 * v1->tm_min) | (v1->tm_hour << 11) | (v1->tm_mday << 16) | ((v1->tm_mon << 21) + 0x200000);
  }
  else {
    return 2162688;
  }
}

uint64_t _squirrelAwayInfo(uint64_t a1, int a2, __int16 a3, __int16 a4, uint64_t a5, int a6, int a7, int a8, unsigned __int16 a9, void *__src)
{
  unsigned int v18 = *(_DWORD *)(a1 + 52);
  if (v18 == *(_DWORD *)(a1 + 48))
  {
    unsigned int v19 = 2 * v18;
    if (v18 > 0x4000) {
      unsigned int v19 = v18 + 0x4000;
    }
    *(_DWORD *)(a1 + 48) = v19;
    unsigned int v20 = BOM_realloc(*(void **)(a1 + 40), (unint64_t)v19 << 6);
    *(void *)(a1 + 40) = v20;
    if (!v20) {
      return 1;
    }
    unsigned int v18 = *(_DWORD *)(a1 + 52);
  }
  *(_DWORD *)(a1 + 52) = v18 + 1;
  __int16 v21 = BOM_malloc(a9);
  if (!v21) {
    return 1;
  }
  __int16 v22 = v21;
  memcpy(v21, __src, a9);
  unint64_t v23 = *(void *)(a1 + 40) + ((unint64_t)v18 << 6);
  *(_WORD *)unint64_t v23 = a3;
  *(_WORD *)(v23 + 2) = a4;
  uint64_t v24 = *(void *)(a5 + 48);
  *(void *)(v23 + 8) = *(void *)(a5 + 32);
  *(void *)(v23 + 16) = v24;
  *(_DWORD *)(v23 + 24) = a6;
  *(_DWORD *)(v23 + 28) = a7;
  *(_DWORD *)(v23 + 32) = a8;
  *(_WORD *)(v23 + 36) = a9;
  *(void *)(v23 + 40) = v22;
  int v25 = *(unsigned __int16 *)(a5 + 4);
  *(_DWORD *)(v23 + 48) = (v25 << 16) | 0x4000;
  *(_DWORD *)(v23 + 52) = a2;
  if ((v25 & 0xF000) == 0xA000)
  {
    char v26 = 1;
  }
  else
  {
    char v26 = 0;
    *(_DWORD *)(a1 + 36) += 12;
  }
  uint64_t result = 0;
  *(unsigned char *)(v23 + 56) = v26;
  *(_DWORD *)(a1 + 36) += a9 + 46;
  return result;
}

uint64_t BOMPKZipReadDataDescriptor(int **a1, int a2, _DWORD *a3, unint64_t *a4, unint64_t *a5)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v5 = 1;
  if (a1 && a3 && a4 && a5)
  {
    unint64_t v10 = a2 ? 20 : 12;
    if (BOMFileRead(*a1, v15, v10) == v10)
    {
      __int16 v11 = BOMStreamWithAddress((uint64_t)v15, v10, 0);
      if (v11)
      {
        uint64_t v12 = (uint64_t)v11;
        if (!BOMStreamSetByteOrder((uint64_t)v11, 2u))
        {
          *a3 = BOMStreamReadUInt32(v12);
          if (a2)
          {
            *a4 = BOMStreamReadUInt64(v12);
            unint64_t UInt64 = BOMStreamReadUInt64(v12);
          }
          else
          {
            *a4 = BOMStreamReadUInt32(v12);
            unint64_t UInt64 = BOMStreamReadUInt32(v12);
          }
          uint64_t v5 = 0;
          *a5 = UInt64;
        }
        BOMStreamFree(v12);
      }
    }
  }
  return v5;
}

BOOL BOMPKZipWriteDataDescriptor(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  __int16 v8 = (_DWORD *)(*(void *)(a1 + 40) + ((unint64_t)(*(_DWORD *)(a1 + 52) - 1) << 6));
  v8[6] = a2;
  v8[7] = a3;
  v8[8] = a4;
  uint64_t v9 = 1;
  unint64_t v10 = BOMStreamWithAddress((uint64_t)v13, 0xCuLL, 1);
  if (v10)
  {
    uint64_t v11 = (uint64_t)v10;
    if (BOMStreamSetByteOrder((uint64_t)v10, 2u))
    {
      BOMStreamFree(v11);
    }
    else
    {
      BOMStreamWriteUInt32(v11, a2);
      BOMStreamWriteUInt32(v11, a3);
      BOMStreamWriteUInt32(v11, a4);
      BOMStreamFree(v11);
      return BOMFileWrite(*(void *)a1, v13, 12) != 12;
    }
  }
  return v9;
}

uint64_t BOMPKZipReadCentralHeader(int **a1, char *a2, uint64_t a3, void *a4)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t result = 1;
  if (a1 && a2 && a3)
  {
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    if (BOMFileRead(*a1, v22, 0x2AuLL) != 42) {
      return 1;
    }
    uint64_t v9 = BOMStreamWithAddress((uint64_t)v22, 0x2AuLL, 0);
    if (!v9) {
      return 1;
    }
    uint64_t v10 = (uint64_t)v9;
    if (BOMStreamSetByteOrder((uint64_t)v9, 2u))
    {
      BOMStreamFree(v10);
      return 1;
    }
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    unsigned int UInt32 = BOMStreamReadUInt32(v10);
    *(void *)(a3 + 48) = _dos2unixtime(UInt32);
    BOMStreamReadUInt32(v10);
    *a4 = BOMStreamReadUInt32(v10);
    *(void *)(a3 + 96) = BOMStreamReadUInt32(v10);
    unsigned int UInt16 = BOMStreamReadUInt16(v10);
    unsigned int v13 = BOMStreamReadUInt16(v10);
    *(_DWORD *)(a3 + 116) = 0;
    unsigned int v14 = BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    BOMStreamReadUInt16(v10);
    uint64_t v15 = BOMStreamReadUInt32(v10);
    char v16 = v15;
    *(_WORD *)(a3 + 4) = WORD1(v15);
    BOMStreamReadUInt32(v10);
    BOMStreamFree(v10);
    if (UInt16)
    {
      __int16 v17 = UInt16;
      if (UInt16 > 0x3FF) {
        return 1;
      }
      if (BOMFileRead(*a1, a2, UInt16) != UInt16) {
        return 1;
      }
      unsigned int UInt16 = a2[UInt16 - 1] == 47;
      uint64_t v18 = (unsigned __int16)(v17 - UInt16);
      a2[v18] = 0;
      if (_sanitizePath(a2, v18)) {
        return 1;
      }
    }
    if (*(unsigned __int16 *)(a3 + 4) <= 0xFFFu)
    {
      if (UInt16 | ((v16 & 0x10) >> 4)) {
        __int16 v19 = 0x4000;
      }
      else {
        __int16 v19 = 0x8000;
      }
      *(_WORD *)(a3 + 4) = v19;
    }
    if (v13)
    {
      if (v13 < 0x2B)
      {
        unsigned int v20 = v22;
      }
      else
      {
        unsigned int v20 = (char *)BOM_malloc(v13);
        if (!v20) {
          return 1;
        }
      }
      if (BOMFileRead(*a1, v20, v13) != v13) {
        return 1;
      }
      if (v20 != v22) {
        free(v20);
      }
    }
    if (!v14) {
      return 0;
    }
    if (v14 < 0x2B)
    {
      __int16 v21 = v22;
    }
    else
    {
      __int16 v21 = (char *)BOM_malloc(v14);
      if (!v21) {
        return 1;
      }
    }
    if (BOMFileRead(*a1, v21, v14) == v14)
    {
      if (v21 != v22) {
        free(v21);
      }
      return 0;
    }
    return 1;
  }
  return result;
}

uint64_t BOMPKZipWriteCentralDirectory(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  int v2 = *(_DWORD *)(a1 + 36);
  if (!v2) {
    return 1;
  }
  size_t v3 = (v2 + 22);
  time_t v4 = BOM_malloc(v3);
  if (!v4) {
    return 1;
  }
  uint64_t v5 = v4;
  time_t v6 = BOMStreamWithAddress((uint64_t)v4, v3, 1);
  if (!v6)
  {
LABEL_7:
    free(v5);
    return 1;
  }
  uint64_t v7 = (uint64_t)v6;
  if (BOMStreamSetByteOrder((uint64_t)v6, 2u))
  {
    BOMStreamFree(v7);
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 52))
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      BOMStreamWriteUInt32(v7, 0x2014B50u);
      BOMStreamWriteUInt16(v7, 789);
      BOMStreamWriteUInt16(v7, *(_WORD *)(*(void *)(a1 + 40) + v10));
      uint64_t v12 = *(void *)(a1 + 40) + v10;
      if (*(unsigned char *)(v12 + 56)) {
        __int16 v13 = 0;
      }
      else {
        __int16 v13 = 8 * (*(_DWORD *)(v12 + 32) != 0);
      }
      BOMStreamWriteUInt16(v7, v13);
      BOMStreamWriteUInt16(v7, *(_WORD *)(*(void *)(a1 + 40) + v10 + 2));
      unsigned int v14 = _unix2dostime((void *)(*(void *)(a1 + 40) + v10 + 16));
      BOMStreamWriteUInt32(v7, v14);
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 24));
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 28));
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 32));
      BOMStreamWriteUInt16(v7, *(_WORD *)(*(void *)(a1 + 40) + v10 + 36));
      if (*(unsigned char *)(*(void *)(a1 + 40) + v10 + 56)) {
        __int16 v15 = 0;
      }
      else {
        __int16 v15 = 12;
      }
      BOMStreamWriteUInt16(v7, v15);
      BOMStreamWriteUInt16(v7, 0);
      BOMStreamWriteUInt16(v7, 0);
      BOMStreamWriteUInt16(v7, 0);
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 48));
      BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 52));
      BOMStreamWriteBuffer(v7, *(const void **)(*(void *)(a1 + 40) + v10 + 40), *(unsigned __int16 *)(*(void *)(a1 + 40) + v10 + 36));
      if (!*(unsigned char *)(*(void *)(a1 + 40) + v10 + 56))
      {
        BOMStreamWriteUInt16(v7, 22613);
        BOMStreamWriteUInt16(v7, 8);
        BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 8));
        BOMStreamWriteUInt32(v7, *(_DWORD *)(*(void *)(a1 + 40) + v10 + 16));
      }
      ++v11;
      v10 += 64;
    }
    while (v11 < *(unsigned int *)(a1 + 52));
  }
  BOMStreamWriteUInt32(v7, 0x6054B50u);
  BOMStreamWriteUInt16(v7, 0);
  BOMStreamWriteUInt16(v7, 0);
  BOMStreamWriteUInt16(v7, *(_WORD *)(a1 + 52));
  BOMStreamWriteUInt16(v7, *(_WORD *)(a1 + 52));
  BOMStreamWriteUInt32(v7, *(_DWORD *)(a1 + 36));
  unsigned int v16 = BOMFileOffset(*(void *)a1);
  BOMStreamWriteUInt32(v7, v16);
  BOMStreamWriteUInt16(v7, 0);
  BOMStreamFree(v7);
  BOOL v8 = BOMFileWrite(*(void *)a1, (UInt8 *)v5, v3) != v3;
  free(v5);
  return v8;
}

uint64_t BOMPKZipSkipDigitalSignature(int **a1)
{
  if (!a1) {
    return 1;
  }
  unsigned __int16 v7 = 0;
  if (BOMFileRead(*a1, (char *)&v7, 2uLL) != 2) {
    return 1;
  }
  if (!v7) {
    return 0;
  }
  int v2 = (char *)BOM_malloc(v7);
  if (!v2) {
    return 1;
  }
  size_t v3 = v2;
  unint64_t v4 = BOMFileRead(*a1, v2, v7);
  BOOL v5 = v4 != v7;
  free(v3);
  return v5;
}

uint64_t BOMPKZipSkipZIP64CentralDirectoryRecord(int **a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t v6 = 0;
  if (BOMFileRead(*a1, (char *)&v6, 8uLL) != 8) {
    return 1;
  }
  if (!v6) {
    return 0;
  }
  int v2 = (char *)BOM_malloc(0x2CuLL);
  if (!v2) {
    return 1;
  }
  size_t v3 = v2;
  BOOL v4 = BOMFileRead(*a1, v2, 0x2CuLL) != 44;
  free(v3);
  return v4;
}

BOOL BOMPKZipSkipZIP64CentralDirectoryLocation(int **a1)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  return !a1 || BOMFileRead(*a1, v2, 0x10uLL) != 16;
}

uint64_t BOMPKZipSkipEndOfCentralDirectoryRecord(int **a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (BOMFileRead(*a1, v9, 0x12uLL) != 18) {
    return 1;
  }
  unsigned __int16 v6 = 0;
  if (_readEOCDRecord((uint64_t)v9, &v8, &v7, &v6)) {
    return 1;
  }
  unint64_t v4 = v6;
  if (!v6) {
    return 0;
  }
  BOOL v5 = v9;
  if (v6 >= 0x13u)
  {
    BOOL v5 = (char *)BOM_malloc(v6);
    if (!v5) {
      return 1;
    }
  }
  BOOL v2 = BOMFileRead(*a1, v5, v4) != v4;
  if (v5 != v9) {
    free(v5);
  }
  return v2;
}

uint64_t _readEOCDRecord(uint64_t a1, _WORD *a2, _DWORD *a3, _WORD *a4)
{
  int v7 = BOMStreamWithAddress(a1, 0x12uLL, 0);
  if (!v7) {
    return 1;
  }
  uint64_t v8 = (uint64_t)v7;
  if (BOMStreamSetByteOrder((uint64_t)v7, 2u))
  {
    uint64_t v9 = 1;
  }
  else
  {
    BOMStreamReadUInt16(v8);
    BOMStreamReadUInt16(v8);
    BOMStreamReadUInt16(v8);
    *a2 = BOMStreamReadUInt16(v8);
    BOMStreamReadUInt32(v8);
    *a3 = BOMStreamReadUInt32(v8);
    uint64_t v9 = 0;
    *a4 = BOMStreamReadUInt16(v8);
  }
  BOMStreamFree(v8);
  return v9;
}

uint64_t BOMPKZipGetFileCompressedSize(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 80);
    if (v2 && *(_DWORD *)(result + 72) > a2) {
      return *(unsigned int *)(v2 + 12 * a2 + 4);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t BOMPKZipGetFileUncompressedSize(uint64_t result, unsigned int a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 80);
    if (v2 && *(_DWORD *)(result + 72) > a2) {
      return *(unsigned int *)(v2 + 12 * a2 + 8);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t BOMPKZipLoadCentralDirectory(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  BOMFileOffset(*(void *)a1);
  if (BOMPKZipSeekToCentralDirectory() || (int v15 = 0, BOMPKZipReadNextSignature(a1, &v15)))
  {
LABEL_3:
    uint64_t v2 = 0xFFFFFFFFLL;
    goto LABEL_4;
  }
  while (v15 == 2)
  {
    if (BOMFileRead(*(int **)a1, v16, 0x2AuLL) != 42) {
      goto LABEL_3;
    }
    unint64_t v4 = *(void **)(a1 + 80);
    if (v4)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 68);
      if (*(_DWORD *)(a1 + 72) + 1 <= v5) {
        goto LABEL_12;
      }
      unsigned int v6 = v5 + 32;
      *(_DWORD *)(a1 + 68) = v6;
      int v7 = BOM_realloc(v4, 12 * v6);
    }
    else
    {
      *(void *)(a1 + 68) = 32;
      int v7 = BOM_malloczero(0x180uLL);
    }
    *(void *)(a1 + 80) = v7;
    if (!v7)
    {
      *(_DWORD *)(a1 + 68) = 0;
      *(_DWORD *)(a1 + 72) = 0;
      goto LABEL_3;
    }
LABEL_12:
    uint64_t v8 = BOMStreamWithAddress((uint64_t)v16, 0x2AuLL, 0);
    if (!v8) {
      goto LABEL_3;
    }
    uint64_t v9 = (uint64_t)v8;
    if (BOMStreamSetByteOrder((uint64_t)v8, 2u))
    {
      BOMStreamFree(v9);
      goto LABEL_3;
    }
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    int UInt32 = BOMStreamReadUInt32(v9);
    int v11 = BOMStreamReadUInt32(v9);
    int v12 = BOMStreamReadUInt32(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt16(v9);
    BOMStreamReadUInt32(v9);
    BOMStreamReadUInt32(v9);
    BOMStreamFree(v9);
    unsigned int v13 = *(_DWORD *)(a1 + 72);
    unsigned int v14 = (_DWORD *)(*(void *)(a1 + 80) + 12 * v13);
    *unsigned int v14 = UInt32;
    v14[1] = v11;
    int v14[2] = v12;
    *(_DWORD *)(a1 + 72) = v13 + 1;
    BOMFileSeek();
    int v15 = 0;
    if (BOMPKZipReadNextSignature(a1, &v15)) {
      goto LABEL_3;
    }
  }
  if (v15 == 6) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = 0xFFFFFFFFLL;
  }
LABEL_4:
  BOMFileSeek();
  return v2;
}

uint64_t BOMPKZipSeekToCentralDirectory()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v3 = (int **)v0;
  uint64_t v24 = *MEMORY[0x263EF8340];
  unint64_t v4 = BOMFileSeek();
  if ((v4 & 0x8000000000000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  int64_t v5 = v4;
  unint64_t v6 = v4 >= 0x10016 ? 65558 : v4;
  if (BOMFileSeek() < 0 || BOMFileRead(*v3, v23, v6) != v6 || v6 < 0x16) {
    return 0xFFFFFFFFLL;
  }
  int v7 = &v23[(v6 - 22)];
  if (*(_DWORD *)v7 != 101010256)
  {
    unint64_t v8 = v6 & 0x3FF | 0x400;
    if (v6 < v8) {
      LODWORD(v8) = v6;
    }
    uint64_t v9 = &v23[(int)v6 - (int)v8];
    if (v9 < v23) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v10 = v8 - 18;
    do
    {
      int v7 = 0;
      int v11 = v9;
LABEL_14:
      size_t v12 = (int)v10 - 3;
      if (v10 != 3)
      {
        unsigned int v13 = v11;
        do
        {
          unsigned int v14 = (char *)memchr(v13, 80, v12);
          if (!v14) {
            break;
          }
          if (*(_DWORD *)v14 == 101010256)
          {
            int v16 = v14 - v11 + 4;
            v10 -= v16;
            v11 += v16;
            int v7 = v14;
            if (v10 > 3) {
              goto LABEL_14;
            }
            goto LABEL_25;
          }
          int64_t v15 = v14 - v13;
          unsigned int v13 = v14 + 1;
          v12 += ~v15;
        }
        while (v12);
      }
      v9 -= 1024;
      if (v7) {
        break;
      }
      unsigned int v10 = 1027;
    }
    while (v9 >= v23);
  }
  unsigned int v14 = v7;
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
LABEL_25:
  int v21 = 0;
  unsigned int v22 = 0;
  if (_readEOCDRecord((uint64_t)(v14 + 4), (_WORD *)&v21 + 1, &v22, &v21)) {
    return 0xFFFFFFFFLL;
  }
  int64_t v18 = v22;
  unint64_t v19 = v5 - v22;
  do
  {
    if (v18 >= v5) {
      break;
    }
    v18 += 0x100000000;
    unint64_t v20 = HIDWORD(v19);
    v19 -= 0x100000000;
  }
  while (v20);
  if (v2) {
    *uint64_t v2 = HIWORD(v21);
  }
  return BOMFileSeek() >> 63;
}

uint64_t BOMPKZipStoreQuarantinePath(uint64_t a1, char *__s)
{
  uint64_t result = 1;
  if (a1 && __s)
  {
    unsigned __int8 v5 = strlen(__s);
    unsigned __int8 v6 = v5;
    int v7 = *(_DWORD *)(a1 + 64);
    if (v7)
    {
      unsigned int v20 = 0;
      char v19 = 0;
      _search(a1, 0, v7 - 1, __s, v5, &v20, &v19);
      if (v19) {
        return 1;
      }
      unint64_t v8 = (char *)BOM_realloc(*(void **)(a1 + 56), 16 * (v7 + 1));
      *(void *)(a1 + 56) = v8;
      if (!v8) {
        return 1;
      }
      uint64_t v9 = *(unsigned int *)(a1 + 64);
      uint64_t v10 = v20;
      if (v9 > v20)
      {
        int v11 = &v8[16 * v9 + 8];
        size_t v12 = &v8[16 * (v9 - 1) + 8];
        unsigned int v13 = *(_DWORD *)(a1 + 64);
        do
        {
          *((void *)v11 - 1) = *((void *)v12 - 1);
          char v14 = *v12;
          v12 -= 16;
          *int v11 = v14;
          v11 -= 16;
          --v13;
        }
        while (v10 < v13);
      }
      *(_DWORD *)(a1 + 64) = v9 + 1;
      int64_t v15 = BOM_malloc(v6);
      int v16 = *(void **)(a1 + 56);
      v16[2 * v10] = v15;
      if (v15)
      {
        memcpy(v15, __s, v6);
        uint64_t result = 0;
        *(unsigned char *)(*(void *)(a1 + 56) + 16 * v10 + 8) = v6;
        return result;
      }
    }
    else
    {
      uint64_t v17 = BOM_malloc(0x10uLL);
      *(void *)(a1 + 56) = v17;
      if (!v17) {
        return 1;
      }
      int64_t v18 = BOM_malloc(v6);
      int v16 = *(void **)(a1 + 56);
      *int v16 = v18;
      if (v18)
      {
        memcpy(v18, __s, v6);
        uint64_t result = 0;
        *(unsigned char *)(*(void *)(a1 + 56) + 8) = v6;
        ++*(_DWORD *)(a1 + 64);
        return result;
      }
    }
    free(v16);
    return 1;
  }
  return result;
}

uint64_t _search(uint64_t a1, unsigned int a2, unsigned int a3, void *__s1, unsigned int a5, unsigned int *a6, unsigned char *a7)
{
  uint64_t v13 = *(void *)(a1 + 56);
  while (1)
  {
    while (1)
    {
      unsigned int v14 = a2 + ((a3 - a2) >> 1);
      uint64_t v15 = v13 + 16 * v14;
      unsigned int v16 = *(unsigned __int8 *)(v15 + 8);
      size_t v17 = v16 >= a5 ? a5 : *(unsigned __int8 *)(v15 + 8);
      uint64_t result = memcmp(__s1, *(const void **)v15, v17);
      if ((result & 0x80000000) == 0) {
        break;
      }
      if (a3 == a2)
      {
        BOOL v20 = 0;
LABEL_21:
        *a6 = v14 + v20;
        return result;
      }
LABEL_15:
      a3 = v14 - (a3 - a2 > 1);
    }
    BOOL v20 = result != 0;
    if (!result && v16 <= a5) {
      break;
    }
    if (a3 == a2) {
      goto LABEL_21;
    }
    if (!result) {
      goto LABEL_15;
    }
LABEL_18:
    if (v14 == a3) {
      a2 += (a3 - a2) >> 1;
    }
    else {
      a2 = v14 + 1;
    }
  }
  if (a3 != a2)
  {
    if (v16 >= a5)
    {
      *a6 = v14;
LABEL_29:
      *a7 = 1;
      return result;
    }
    goto LABEL_18;
  }
  if (v16 >= a5) {
    unsigned int v21 = a2 + ((a3 - a2) >> 1);
  }
  else {
    unsigned int v21 = v14 + 1;
  }
  *a6 = v21;
  if (v16 >= a5) {
    goto LABEL_29;
  }
  return result;
}

uint64_t BOMPKZipLookupQuarantinePath(uint64_t a1, char *__s, unsigned char *a3)
{
  uint64_t result = 1;
  if (a1 && __s && a3)
  {
    int v7 = *(_DWORD *)(a1 + 64);
    *a3 = 0;
    if (v7)
    {
      unsigned __int8 v8 = strlen(__s);
      _search(a1, 0, *(_DWORD *)(a1 + 64) - 1, __s, v8, &v9, a3);
    }
    return 0;
  }
  return result;
}

uint64_t BOMPKZipQuarantinePathCount(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 64);
  }
  else {
    return 1;
  }
}

uint64_t BOMPKZipCopyQuarantinePath(uint64_t a1, unsigned int a2, void *__dst)
{
  if (!a1) {
    return 1;
  }
  if (*(_DWORD *)(a1 + 64) < a2) {
    return 1;
  }
  uint64_t v7 = *(void *)(a1 + 56) + 16 * a2;
  memcpy(__dst, *(const void **)v7, *(unsigned __int8 *)(v7 + 8));
  uint64_t result = 0;
  *((unsigned char *)__dst + *(unsigned __int8 *)(*(void *)(a1 + 56) + 16 * a2 + 8)) = 0;
  return result;
}

uint64_t decrypt_byte(uint64_t a1)
{
  return ((unsigned __int16)((*(_WORD *)(a1 + 8) & 0xFFFD ^ 3) * (*(_WORD *)(a1 + 8) | 2)) >> 8);
}

uint64_t update_keys(int *a1, uint64_t a2)
{
  int v2 = PKZip_crctab_0[(*a1 ^ a2)] ^ (*a1 >> 8);
  unsigned int v3 = 134775813 * (a1[1] + v2) + 1;
  *a1 = v2;
  a1[1] = v3;
  a1[2] = PKZip_crctab_0[a1[2] ^ HIBYTE(v3)] ^ (a1[2] >> 8);
  return a2;
}

uint64_t init_keys(uint64_t result, unsigned char *a2)
{
  *(void *)uint64_t result = 0x2345678912345678;
  *(_DWORD *)(result + 8) = 878082192;
  char v2 = *a2;
  if (*a2)
  {
    unsigned int v3 = (int *)result;
    unint64_t v4 = a2 + 1;
    do
    {
      uint64_t result = update_keys(v3, v2);
      int v5 = *v4++;
      char v2 = v5;
    }
    while (v5);
  }
  return result;
}

uint64_t *BOMCopierDataAnalyzerNew(int a1, void *a2)
{
  if (!a1)
  {
    BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 90, (uint64_t)"BOMCopierDataAnalyzerNew", "No flag is set.");
    return 0;
  }
  __int16 v3 = a1;
  unint64_t v4 = (uint64_t *)malloc_type_calloc(1uLL, 0x90uLL, 0x1030040F8F0F2B1uLL);
  if (!v4)
  {
    int v7 = *__error();
    unsigned __int8 v8 = __error();
    strerror(*v8);
    BOMCopierErrorCapture(a2, v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 103, (uint64_t)"BOMCopierDataAnalyzerNew", "Could not allocate BOMCopierDataAnalyzer: %s");
    return 0;
  }
  int v5 = v4;
  if (v3)
  {
    *v4 |= 1uLL;
    if ((v3 & 2) == 0)
    {
LABEL_5:
      if ((v3 & 8) == 0) {
        goto LABEL_6;
      }
      goto LABEL_20;
    }
  }
  else if ((v3 & 2) == 0)
  {
    goto LABEL_5;
  }
  *v4 |= 2uLL;
  if ((v3 & 8) == 0)
  {
LABEL_6:
    if ((v3 & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_21;
  }
LABEL_20:
  *v4 |= 8uLL;
  if ((v3 & 0x10) == 0)
  {
LABEL_7:
    if ((v3 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_22;
  }
LABEL_21:
  *v4 |= 0x10uLL;
  if ((v3 & 0x20) == 0)
  {
LABEL_8:
    if ((v3 & 0x40) == 0) {
      goto LABEL_9;
    }
    goto LABEL_23;
  }
LABEL_22:
  *v4 |= 0x20uLL;
  if ((v3 & 0x40) == 0)
  {
LABEL_9:
    if ((v3 & 0x80) == 0) {
      goto LABEL_10;
    }
    goto LABEL_24;
  }
LABEL_23:
  *v4 |= 0x40uLL;
  if ((v3 & 0x80) == 0)
  {
LABEL_10:
    if ((v3 & 0x100) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_24:
  *v4 |= 0x80uLL;
  if ((v3 & 0x100) != 0) {
LABEL_11:
  }
    *v4 |= 0x100uLL;
LABEL_12:
  int inited = init_data_analyzer(v4, a2);
  if (inited)
  {
    BOMCopierErrorCapture(a2, inited, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 112, (uint64_t)"BOMCopierDataAnalyzerNew", "Could not initialize BOMCopierDataAnalyzer");
    BOMCopierDataAnalyzerFree(v5);
    return 0;
  }
  return v5;
}

uint64_t init_data_analyzer(uint64_t *a1, void *a2)
{
  uint64_t v4 = *a1;
  if (*a1)
  {
    unsigned __int8 v6 = a1 + 1;
    if (a1[1])
    {
      CNCRCRelease();
      void *v6 = 0;
    }
    if (CNCRCInit())
    {
      int v7 = *__error();
      unsigned __int8 v8 = __error();
      strerror(*v8);
      BOMCopierErrorCapture(a2, v7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 474, (uint64_t)"init_data_analyzer", "Could not allocate CRC_32 context: %s");
      return 1;
    }
    *((_DWORD *)a1 + 4) = 0;
    uint64_t v4 = *a1;
    int v5 = 1;
    if ((*a1 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 8) == 0) {
        goto LABEL_4;
      }
      goto LABEL_21;
    }
  }
  else
  {
    int v5 = 0;
    if ((v4 & 2) == 0) {
      goto LABEL_3;
    }
  }
  if (a1[3])
  {
    CNCRCRelease();
    a1[3] = 0;
  }
  if (CNCRCInit())
  {
    int v9 = *__error();
    uint64_t v10 = __error();
    strerror(*v10);
    BOMCopierErrorCapture(a2, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 498, (uint64_t)"init_data_analyzer", "Could not allocate CRC_32 POSIX context: %s");
    return 1;
  }
  *((_DWORD *)a1 + 10) = 0;
  a1[4] = 0;
  ++v5;
  uint64_t v4 = *a1;
  if ((*a1 & 8) == 0)
  {
LABEL_4:
    if ((v4 & 0x10) == 0) {
      goto LABEL_5;
    }
    goto LABEL_26;
  }
LABEL_21:
  uint64_t v13 = (CC_MD5_CTX *)a1[6];
  if (!v13)
  {
    uint64_t v13 = (CC_MD5_CTX *)malloc_type_calloc(1uLL, 0x5CuLL, 0x100004034A301B9uLL);
    a1[6] = (uint64_t)v13;
    if (!v13)
    {
      int v27 = *__error();
      uint64_t v28 = __error();
      strerror(*v28);
      BOMCopierErrorCapture(a2, v27, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 519, (uint64_t)"init_data_analyzer", "Could not allocate MD5 context: %s");
      return 1;
    }
  }
  CC_MD5_Init(v13);
  if (!a1[12])
  {
    unsigned int v14 = malloc_type_malloc(0x10uLL, 0x53B91330uLL);
    a1[12] = (uint64_t)v14;
    if (!v14)
    {
      int v29 = *__error();
      int v30 = __error();
      strerror(*v30);
      BOMCopierErrorCapture(a2, v29, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 534, (uint64_t)"init_data_analyzer", "Could not allocate MD5 digest: %s");
      return 1;
    }
  }
  ++v5;
  uint64_t v4 = *a1;
  if ((*a1 & 0x10) == 0)
  {
LABEL_5:
    if ((v4 & 0x20) == 0) {
      goto LABEL_6;
    }
    goto LABEL_31;
  }
LABEL_26:
  uint64_t v15 = (CC_SHA1_CTX *)a1[7];
  if (!v15)
  {
    uint64_t v15 = (CC_SHA1_CTX *)malloc_type_calloc(1uLL, 0x60uLL, 0x1000040565EDBD2uLL);
    a1[7] = (uint64_t)v15;
    if (!v15)
    {
      int v31 = *__error();
      unsigned int v32 = __error();
      strerror(*v32);
      BOMCopierErrorCapture(a2, v31, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 553, (uint64_t)"init_data_analyzer", "Could not allocate SHA1 context: %s");
      return 1;
    }
  }
  CC_SHA1_Init(v15);
  if (!a1[13])
  {
    unsigned int v16 = malloc_type_malloc(0x14uLL, 0x40C8835uLL);
    a1[13] = (uint64_t)v16;
    if (!v16)
    {
      int v33 = *__error();
      int v34 = __error();
      strerror(*v34);
      BOMCopierErrorCapture(a2, v33, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 565, (uint64_t)"init_data_analyzer", "Could not allocate SHA1 digest: %s");
      return 1;
    }
  }
  ++v5;
  uint64_t v4 = *a1;
  if ((*a1 & 0x20) == 0)
  {
LABEL_6:
    if ((v4 & 0x40) == 0) {
      goto LABEL_7;
    }
LABEL_36:
    char v19 = (CC_SHA256_CTX *)a1[9];
    if (!v19)
    {
      char v19 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0x68uLL, 0x1000040ED882C02uLL);
      a1[9] = (uint64_t)v19;
      if (!v19)
      {
        int v39 = *__error();
        int v40 = __error();
        strerror(*v40);
        BOMCopierErrorCapture(a2, v39, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 615, (uint64_t)"init_data_analyzer", "Could not allocate SHA256 context: %s");
        return 1;
      }
    }
    CC_SHA256_Init(v19);
    if (!a1[15])
    {
      BOOL v20 = malloc_type_malloc(0x20uLL, 0x1E2B12uLL);
      a1[15] = (uint64_t)v20;
      if (!v20)
      {
        int v41 = *__error();
        uint64_t v42 = __error();
        strerror(*v42);
        BOMCopierErrorCapture(a2, v41, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 627, (uint64_t)"init_data_analyzer", "Could not allocate SHA256 digest: %s");
        return 1;
      }
    }
    ++v5;
    if ((*a1 & 0x80) == 0) {
      goto LABEL_46;
    }
    goto LABEL_41;
  }
LABEL_31:
  size_t v17 = (CC_SHA256_CTX *)a1[8];
  if (!v17)
  {
    size_t v17 = (CC_SHA256_CTX *)malloc_type_calloc(1uLL, 0x68uLL, 0x1000040ED882C02uLL);
    a1[8] = (uint64_t)v17;
    if (!v17)
    {
      int v35 = *__error();
      unsigned int v36 = __error();
      strerror(*v36);
      BOMCopierErrorCapture(a2, v35, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 584, (uint64_t)"init_data_analyzer", "Could not allocate SHA224 context: %s");
      return 1;
    }
  }
  CC_SHA224_Init(v17);
  if (!a1[14])
  {
    int64_t v18 = malloc_type_malloc(0x1CuLL, 0xA309EA1BuLL);
    a1[14] = (uint64_t)v18;
    if (!v18)
    {
      int v37 = *__error();
      unsigned int v38 = __error();
      strerror(*v38);
      BOMCopierErrorCapture(a2, v37, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 596, (uint64_t)"init_data_analyzer", "Could not allocate SHA224 digest: %s");
      return 1;
    }
  }
  ++v5;
  uint64_t v4 = *a1;
  if ((*a1 & 0x40) != 0) {
    goto LABEL_36;
  }
LABEL_7:
  if ((v4 & 0x80) != 0)
  {
LABEL_41:
    unsigned int v21 = (CC_SHA512_CTX *)a1[10];
    if (!v21)
    {
      unsigned int v21 = (CC_SHA512_CTX *)malloc_type_calloc(1uLL, 0xD0uLL, 0x10000400F93440CuLL);
      a1[10] = (uint64_t)v21;
      if (!v21)
      {
        int v43 = *__error();
        uint64_t v44 = __error();
        strerror(*v44);
        BOMCopierErrorCapture(a2, v43, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 646, (uint64_t)"init_data_analyzer", "Could not allocate SHA384 context: %s");
        return 1;
      }
    }
    CC_SHA384_Init(v21);
    if (!a1[16])
    {
      unsigned int v22 = malloc_type_malloc(0x30uLL, 0xEBA7307EuLL);
      a1[16] = (uint64_t)v22;
      if (!v22)
      {
        int v45 = *__error();
        uint64_t v46 = __error();
        strerror(*v46);
        BOMCopierErrorCapture(a2, v45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 658, (uint64_t)"init_data_analyzer", "Could not allocate SHA384 digest: %s");
        return 1;
      }
    }
    int v5 = 1;
  }
LABEL_46:
  if ((*((unsigned char *)a1 + 1) & 1) == 0)
  {
    if (!v5)
    {
      uint64_t v23 = __error();
      uint64_t v24 = strerror(*v23);
      uint64_t v11 = 22;
      BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 699, (uint64_t)"init_data_analyzer", "No method enabled", v24);
      return v11;
    }
    return 0;
  }
  int v25 = (CC_SHA512_CTX *)a1[11];
  if (v25
    || (int v25 = (CC_SHA512_CTX *)malloc_type_calloc(1uLL, 0xD0uLL, 0x10000400F93440CuLL), (a1[11] = (uint64_t)v25) != 0))
  {
    CC_SHA512_Init(v25);
    if (a1[17]) {
      return 0;
    }
    char v26 = malloc_type_malloc(0x40uLL, 0x333D1066uLL);
    a1[17] = (uint64_t)v26;
    if (v26) {
      return 0;
    }
    int v49 = *__error();
    uint64_t v50 = __error();
    strerror(*v50);
    BOMCopierErrorCapture(a2, v49, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 689, (uint64_t)"init_data_analyzer", "Could not allocate SHA512 digest: %s");
  }
  else
  {
    int v47 = *__error();
    uint64_t v48 = __error();
    strerror(*v48);
    BOMCopierErrorCapture(a2, v47, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 677, (uint64_t)"init_data_analyzer", "Could not allocate SHA512 context: %s");
  }
  return 1;
}

void BOMCopierDataAnalyzerFree(void *a1)
{
  if (a1)
  {
    if (a1[1]) {
      CNCRCRelease();
    }
    if (a1[3]) {
      CNCRCRelease();
    }
    char v2 = (void *)a1[6];
    if (v2) {
      free(v2);
    }
    __int16 v3 = (void *)a1[7];
    if (v3) {
      free(v3);
    }
    uint64_t v4 = (void *)a1[8];
    if (v4) {
      free(v4);
    }
    int v5 = (void *)a1[9];
    if (v5) {
      free(v5);
    }
    unsigned __int8 v6 = (void *)a1[10];
    if (v6) {
      free(v6);
    }
    int v7 = (void *)a1[11];
    if (v7) {
      free(v7);
    }
    unsigned __int8 v8 = (void *)a1[12];
    if (v8) {
      free(v8);
    }
    int v9 = (void *)a1[13];
    if (v9) {
      free(v9);
    }
    uint64_t v10 = (void *)a1[14];
    if (v10) {
      free(v10);
    }
    uint64_t v11 = (void *)a1[15];
    if (v11) {
      free(v11);
    }
    size_t v12 = (void *)a1[16];
    if (v12) {
      free(v12);
    }
    uint64_t v13 = (void *)a1[17];
    if (v13) {
      free(v13);
    }
    free(a1);
  }
}

uint64_t *BOMCopierDataAnalyzerReset(uint64_t *result)
{
  if (result)
  {
    uint64_t v1 = 0;
    uint64_t result = (uint64_t *)init_data_analyzer(result, &v1);
    if (result) {
      return BOMCopierErrorCapture(&v1, (int)result, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 219, (uint64_t)"BOMCopierDataAnalyzerReset", "Could not initialize BOMCopierDataAnalyzer");
    }
  }
  return result;
}

uint64_t BOMCopierDataAnalyzerUpdate(uint64_t *a1, void *data, uint64_t len, void *a4)
{
  if (a1)
  {
    if (data)
    {
      if (len)
      {
        uint64_t v8 = *a1;
        if (*a1)
        {
          if (CNCRCUpdate())
          {
            int v9 = *__error();
            uint64_t v10 = __error();
            strerror(*v10);
            BOMCopierErrorCapture(a4, v9, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 723, (uint64_t)"update_data_analyzer", "Could not update CRC_32 context: %s");
            return 1;
          }
          uint64_t v8 = *a1;
        }
        if ((v8 & 2) != 0)
        {
          if (CNCRCUpdate())
          {
            int v13 = *__error();
            unsigned int v14 = __error();
            strerror(*v14);
            BOMCopierErrorCapture(a4, v13, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 737, (uint64_t)"update_data_analyzer", "Could not update CRC_32 POSIX context: %s");
            return 1;
          }
          a1[4] += len;
          uint64_t v8 = *a1;
        }
        if ((v8 & 8) != 0)
        {
          CC_MD5_Update((CC_MD5_CTX *)a1[6], data, len);
          uint64_t v8 = *a1;
          if ((*a1 & 0x10) == 0)
          {
LABEL_19:
            if ((v8 & 0x20) == 0) {
              goto LABEL_20;
            }
            goto LABEL_27;
          }
        }
        else if ((v8 & 0x10) == 0)
        {
          goto LABEL_19;
        }
        CC_SHA1_Update((CC_SHA1_CTX *)a1[7], data, len);
        uint64_t v8 = *a1;
        if ((*a1 & 0x20) == 0)
        {
LABEL_20:
          if ((v8 & 0x40) == 0) {
            goto LABEL_21;
          }
          goto LABEL_28;
        }
LABEL_27:
        CC_SHA224_Update((CC_SHA256_CTX *)a1[8], data, len);
        uint64_t v8 = *a1;
        if ((*a1 & 0x40) == 0)
        {
LABEL_21:
          if ((v8 & 0x80) == 0) {
            goto LABEL_22;
          }
          goto LABEL_29;
        }
LABEL_28:
        CC_SHA256_Update((CC_SHA256_CTX *)a1[9], data, len);
        uint64_t v8 = *a1;
        if ((*a1 & 0x80) == 0)
        {
LABEL_22:
          if ((v8 & 0x100) == 0) {
            return 0;
          }
LABEL_23:
          CC_SHA512_Update((CC_SHA512_CTX *)a1[11], data, len);
          return 0;
        }
LABEL_29:
        CC_SHA384_Update((CC_SHA512_CTX *)a1[10], data, len);
        if ((*a1 & 0x100) == 0) {
          return 0;
        }
        goto LABEL_23;
      }
      uint64_t v11 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 249, (uint64_t)"BOMCopierDataAnalyzerUpdate", "data_size is 0");
    }
    else
    {
      uint64_t v11 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 243, (uint64_t)"BOMCopierDataAnalyzerUpdate", "data is NULL");
    }
  }
  else
  {
    uint64_t v11 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 237, (uint64_t)"BOMCopierDataAnalyzerUpdate", "data_analyzer is NULL");
  }
  return v11;
}

uint64_t BOMCopierDataAnalyzerFinalize(uint64_t *a1, void *a2)
{
  if (a1)
  {
    uint64_t v4 = *a1;
    if (*a1)
    {
      if (CNCRCFinal())
      {
        int v5 = *__error();
        unsigned __int8 v6 = __error();
        strerror(*v6);
        BOMCopierErrorCapture(a2, v5, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 820, (uint64_t)"finalize_data_analyzer", "Could not finalize CRC_32 context: %s");
        return 1;
      }
      *((_DWORD *)a1 + 4) = 0;
      uint64_t v4 = *a1;
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v8 = a1[4];
      if (v8)
      {
        while (!CNCRCUpdate())
        {
          BOOL v9 = (unint64_t)v8 > 0xFF;
          v8 >>= 8;
          if (!v9) {
            goto LABEL_11;
          }
        }
        int v12 = *__error();
        int v13 = __error();
        strerror(*v13);
        BOMCopierErrorCapture(a2, v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 842, (uint64_t)"finalize_data_analyzer", "Could not update length for CRC_32 POSIX context: %s");
        return 1;
      }
LABEL_11:
      if (CNCRCFinal())
      {
        int v10 = *__error();
        uint64_t v11 = __error();
        strerror(*v11);
        BOMCopierErrorCapture(a2, v10, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 851, (uint64_t)"finalize_data_analyzer", "Could not finalize CRC_32 POSIX context: %s");
        return 1;
      }
      *((_DWORD *)a1 + 10) = 0;
      uint64_t v4 = *a1;
    }
    if ((v4 & 8) != 0)
    {
      CC_MD5_Final((unsigned __int8 *)a1[12], (CC_MD5_CTX *)a1[6]);
      uint64_t v4 = *a1;
      if ((*a1 & 0x10) == 0)
      {
LABEL_18:
        if ((v4 & 0x20) == 0) {
          goto LABEL_19;
        }
        goto LABEL_27;
      }
    }
    else if ((v4 & 0x10) == 0)
    {
      goto LABEL_18;
    }
    CC_SHA1_Final((unsigned __int8 *)a1[13], (CC_SHA1_CTX *)a1[7]);
    uint64_t v4 = *a1;
    if ((*a1 & 0x20) == 0)
    {
LABEL_19:
      if ((v4 & 0x40) == 0) {
        goto LABEL_20;
      }
      goto LABEL_28;
    }
LABEL_27:
    CC_SHA224_Final((unsigned __int8 *)a1[14], (CC_SHA256_CTX *)a1[8]);
    uint64_t v4 = *a1;
    if ((*a1 & 0x40) == 0)
    {
LABEL_20:
      if ((v4 & 0x80) == 0) {
        goto LABEL_21;
      }
      goto LABEL_29;
    }
LABEL_28:
    CC_SHA256_Final((unsigned __int8 *)a1[15], (CC_SHA256_CTX *)a1[9]);
    uint64_t v4 = *a1;
    if ((*a1 & 0x80) == 0)
    {
LABEL_21:
      if ((v4 & 0x100) == 0) {
        return 0;
      }
LABEL_22:
      CC_SHA512_Final((unsigned __int8 *)a1[17], (CC_SHA512_CTX *)a1[11]);
      return 0;
    }
LABEL_29:
    CC_SHA384_Final((unsigned __int8 *)a1[16], (CC_SHA512_CTX *)a1[10]);
    if ((*a1 & 0x100) == 0) {
      return 0;
    }
    goto LABEL_22;
  }
  uint64_t v7 = 22;
  BOMCopierErrorCapture(a2, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 267, (uint64_t)"BOMCopierDataAnalyzerFinalize", "data_analyzer is NULL");
  return v7;
}

uint64_t BOMCopierDataAnalyzerGetDigest(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a1)
  {
    if (a3)
    {
      switch(a2)
      {
        case 1:
          if ((*(unsigned char *)a1 & 1) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 303, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "CRC32 is not supported");
            goto LABEL_23;
          }
          uint64_t v4 = 0;
          int v5 = *(_DWORD *)(a1 + 16);
          goto LABEL_27;
        case 2:
          if ((*(unsigned char *)a1 & 2) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 314, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "CRC32 POSIX is not supported");
            goto LABEL_23;
          }
          uint64_t v4 = 0;
          int v5 = *(_DWORD *)(a1 + 40);
LABEL_27:
          *(_DWORD *)a3 = v5;
          return v4;
        case 3:
          if ((*(unsigned char *)a1 & 8) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 325, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "MD5 is not supported");
            goto LABEL_23;
          }
          uint64_t v4 = 0;
          long long v6 = *(_OWORD *)*(void *)(a1 + 96);
          goto LABEL_31;
        case 4:
          if ((*(unsigned char *)a1 & 0x10) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 336, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA1 is not supported");
            goto LABEL_23;
          }
          uint64_t v4 = 0;
          uint64_t v7 = *(long long **)(a1 + 104);
          long long v6 = *v7;
          *(_DWORD *)(a3 + 16) = *((_DWORD *)v7 + 4);
          goto LABEL_31;
        case 5:
          if ((*(unsigned char *)a1 & 0x20) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 347, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA224 is not supported");
            goto LABEL_23;
          }
          uint64_t v4 = 0;
          uint64_t v8 = *(long long **)(a1 + 112);
          long long v6 = *v8;
          *(_OWORD *)(a3 + 12) = *(long long *)((char *)v8 + 12);
LABEL_31:
          *(_OWORD *)a3 = v6;
          return v4;
        case 6:
          if ((*(unsigned char *)a1 & 0x40) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 358, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA256 is not supported");
            goto LABEL_23;
          }
          uint64_t v4 = 0;
          BOOL v9 = *(long long **)(a1 + 120);
          long long v10 = *v9;
          long long v11 = v9[1];
          goto LABEL_36;
        case 7:
          if ((*(unsigned char *)a1 & 0x80) == 0)
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 369, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA384 is not supported");
            goto LABEL_23;
          }
          uint64_t v4 = 0;
          int v12 = *(long long **)(a1 + 128);
          long long v10 = *v12;
          long long v11 = v12[1];
          long long v13 = v12[2];
          goto LABEL_35;
        case 8:
          if (*(unsigned char *)(a1 + 1))
          {
            uint64_t v4 = 0;
            unsigned int v14 = *(long long **)(a1 + 136);
            long long v10 = *v14;
            long long v11 = v14[1];
            long long v13 = v14[2];
            *(_OWORD *)(a3 + 48) = v14[3];
LABEL_35:
            *(_OWORD *)(a3 + 32) = v13;
LABEL_36:
            *(_OWORD *)a3 = v10;
            *(_OWORD *)(a3 + 16) = v11;
          }
          else
          {
            BOMCopierErrorCapture(a4, 45, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 380, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "SHA512 is not supported");
LABEL_23:
            uint64_t v4 = 22;
          }
          break;
        default:
          uint64_t v4 = 22;
          BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 389, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "Unknown digest_type: %d");
          return v4;
      }
    }
    else
    {
      uint64_t v4 = 22;
      BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 293, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "message_digest is NULL");
    }
  }
  else
  {
    uint64_t v4 = 22;
    BOMCopierErrorCapture(a4, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopierDataAnalyzer.c", 287, (uint64_t)"BOMCopierDataAnalyzerGetDigest", "data_analyzer is NULL");
  }
  return v4;
}

uint64_t BOMCopierMultiCopy()
{
  return 22;
}

uint64_t BOMCopierMultiCopyWithOptions()
{
  return 22;
}

uint64_t volume_has_data_protection(const char *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  memset(&v6, 0, 512);
  if (!statfs(a1, &v6)) {
    return LOBYTE(v6.f_flags) >> 7;
  }
  char v2 = (FILE *)*MEMORY[0x263EF8348];
  __int16 v3 = __error();
  uint64_t v4 = strerror(*v3);
  fprintf(v2, "Could not statfs %s: %s\n", a1, v4);
  return 0;
}

BOOL set_timestamps_0(const char *a1, long long *a2, _OWORD *a3)
{
  uint64_t v7 = 0;
  long long v3 = *a2;
  v5[0] = *a3;
  v5[1] = v3;
  long long v6 = xmmword_2106632F8;
  return setattrlist(a1, &v6, v5, 0x20uLL, 1u) != 0;
}

uint64_t _mkdirs_parent(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  __strlcpy_chk();
  char v2 = strrchr(__s, 47);
  uint64_t result = 0;
  if (v2)
  {
    if (__s != v2)
    {
      *char v2 = 0;
      return _mkdirs(a1, (uint64_t)__s);
    }
  }
  return result;
}

uint64_t _mkdirs(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(a1 + 12832) + 80))(*(void *)(*(void *)(a1 + 12832)
                                                                                            + 8)))
  {
    *__error() = 20;
    return 0xFFFFFFFFLL;
  }
  if (*__error() != 2) {
    return 0xFFFFFFFFLL;
  }
  __strlcpy_chk();
  long long v3 = rindex(v8, 47);
  if (!v3 || v3 == v8) {
    return (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 168))(*(void *)(*(void *)(a1 + 12832) + 8), v8, 511);
  }
  uint64_t v4 = v3;
  char *v3 = 0;
  uint64_t result = _mkdirs(a1, v8);
  *uint64_t v4 = 47;
  if (result == -1) {
    return result;
  }
  int v7 = v4[1];
  long long v6 = v4 + 1;
  if (!v7) {
    return 0;
  }
  uint64_t result = strcmp(v6, ".");
  if (result)
  {
    uint64_t result = strcmp(v6, "..");
    if (result) {
      return (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 168))(*(void *)(*(void *)(a1 + 12832) + 8), v8, 511);
    }
  }
  return result;
}

uint64_t _initGroupList(uint64_t a1)
{
  int v2 = getgroups(16, (gid_t *)(a1 + 10500));
  *(_DWORD *)(a1 + 10564) = v2;
  if (v2 == -1) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t _chPerms(uint64_t a1, char *a2, uint64_t a3, unsigned char *a4, int a5)
{
  int v8 = *(_DWORD *)(a3 + 20);
  int v9 = *(unsigned __int16 *)(a3 + 4);
  if ((v9 & 0xF000) == 0x4000) {
    unsigned int v10 = 448;
  }
  else {
    unsigned int v10 = 0;
  }
  if (*(_DWORD *)(a1 + 10496))
  {
    uint64_t v11 = *(unsigned int *)(a1 + 10564);
    if ((int)v11 >= 1)
    {
      int v12 = (int *)(a1 + 10500);
      while (1)
      {
        int v13 = *v12++;
        if (v13 == v8) {
          break;
        }
        if (!--v11) {
          goto LABEL_9;
        }
      }
      uint64_t v15 = 0xFFFFFFFFLL;
      goto LABEL_16;
    }
LABEL_9:
    int v8 = -1;
    int v14 = 61951;
    uint64_t v15 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v15 = *(unsigned int *)(a3 + 16);
    if (*(unsigned char *)(a1 + 205) == 1)
    {
LABEL_16:
      int v14 = 61951;
      goto LABEL_17;
    }
    int v14 = 0xFFFF;
    if (*(unsigned char *)(a1 + 209) == 1)
    {
      if (*(unsigned char *)(a1 + 210)) {
        int v14 = 0xFFFF;
      }
      else {
        int v14 = 61951;
      }
    }
  }
LABEL_17:
  if ((v9 & 0xF000) == 0x8000 && *(unsigned char *)(a1 + 206) == 1) {
    v14 &= 0xFFB6u;
  }
  uint64_t v16 = v9 & v14;
  if (a4 && v10 > ((unsigned __int16)v9 & (unsigned __int16)v14 & 0x1C0u))
  {
    *(_WORD *)(a3 + 4) = v9 & v14;
    uint64_t v16 = v16 | v10;
    *a4 = 1;
  }
  if (a5
    && (v15 & v8) != 0xFFFFFFFF
    && (*(unsigned int (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 192))(*(void *)(*(void *)(a1 + 12832) + 8), a2, v15)&& (*__error() == 45 || *__error() == 1 && (v16 & 0xF000) == 0xA000))
  {
    *__error() = 0;
  }
  if ((v16 & 0xF000) == 0xA000)
  {
    return lchmod(a2, v16);
  }
  else
  {
    uint64_t v18 = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 200))(*(void *)(*(void *)(a1 + 12832) + 8), a2, v16);
    if (v18 && *__error() == 45)
    {
      uint64_t v18 = 0;
      *__error() = 0;
    }
    return v18;
  }
}

uint64_t _makeDestDir(uint64_t a1, char *a2, int a3, uint64_t a4, unsigned char *a5)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a3)
  {
    uint64_t result = _mkdirs(a1, (uint64_t)a2);
    if (result) {
      return result;
    }
    return _chPerms(a1, a2, a4, a5, 1);
  }
  unsigned int v10 = rindex(a2, 47);
  if (!v10
    || strcmp(v10, "/.")
    || (__strlcpy_chk(),
        __s[strlen(__s) - 2] = 0,
        uint64_t result = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 168))(*(void *)(*(void *)(a1 + 12832) + 8), __s, 511), !result))
  {
    uint64_t result = (*(uint64_t (**)(void, char *, uint64_t))(*(void *)(a1 + 12832) + 168))(*(void *)(*(void *)(a1 + 12832) + 8), a2, 511);
    if (!result) {
      return _chPerms(a1, a2, a4, a5, 1);
    }
  }
  return result;
}

uint64_t _filterFatArchs(uint64_t a1, unsigned int a2, _DWORD *a3, void *a4)
{
  int v8 = 0;
  uint64_t v9 = 0;
  *a4 = 0;
  unsigned int v10 = 0;
  if (a1 && a2)
  {
    unint64_t v11 = 0;
    uint64_t v12 = 0;
    int v8 = 0;
    uint64_t v13 = 0;
    do
    {
      int v14 = 0;
      unsigned int v10 = (_DWORD *)(a1 + 20 * v11);
      while (1)
      {
        int v15 = a3[8 * v14];
        if (v15 == -1) {
          break;
        }
        if (!v15)
        {
          uint64_t v9 = v13;
          unsigned int v10 = v12;
          goto LABEL_17;
        }
        if (*v10 == v15)
        {
          uint64_t v16 = &a3[8 * v14];
          if (*((unsigned char *)v16 + 4) || ((v16[2] ^ v10[1]) & 0xFFFFFF) == 0) {
            break;
          }
        }
        ++v14;
      }
      if (v13)
      {
        uint64_t v9 = (v13 + 1);
        int v8 = BOM_realloc(v8, 8 * (int)v9);
        if (!v8) {
          goto LABEL_41;
        }
      }
      else
      {
        int v8 = BOM_malloczero(8uLL);
        uint64_t v9 = 1;
        if (!v8) {
          goto LABEL_41;
        }
      }
      *((void *)v8 + (int)v13) = v10;
      uint64_t v12 = (_DWORD *)(a1 + 20 * v11);
      uint64_t v13 = v9;
LABEL_17:
      ++v11;
    }
    while (v11 < a2);
  }
  if (a2 && !v10 && a1)
  {
    unint64_t v17 = 0;
    unint64_t v18 = a2;
    do
    {
      if (*a3)
      {
        uint64_t v19 = 0;
        int v20 = 0;
        uint64_t v21 = a1 + 20 * v17;
        while (1)
        {
          unsigned int v22 = &a3[8 * v19];
          uint64_t v23 = (int *)*((void *)v22 + 2);
          if (v23 && v22[6] && (int v24 = *v23) != 0)
          {
            unsigned int v25 = 1;
            while (*(_DWORD *)(v21 + 4) != v24)
            {
              int v24 = v23[v25++];
              if (!v24) {
                goto LABEL_30;
              }
            }
            if (v9)
            {
              uint64_t v26 = (v9 + 1);
              int v8 = BOM_realloc(v8, 8 * (int)v26);
              if (!v8) {
                goto LABEL_42;
              }
            }
            else
            {
              int v8 = BOM_malloczero(8uLL);
              uint64_t v26 = 1;
              if (!v8) {
                goto LABEL_42;
              }
            }
            *((void *)v8 + (int)v9) = v21;
          }
          else
          {
LABEL_30:
            uint64_t v26 = v9;
          }
          uint64_t v19 = ++v20;
          uint64_t v9 = v26;
          if (!a3[8 * v19]) {
            goto LABEL_39;
          }
        }
      }
      uint64_t v26 = v9;
LABEL_39:
      ++v17;
      uint64_t v9 = v26;
    }
    while (v17 < v18);
  }
  else
  {
LABEL_41:
    uint64_t v26 = v9;
  }
LABEL_42:
  *a4 = v8;
  return v26;
}

uint64_t _determine_thin_type_and_archs(uint64_t a1, unsigned int a2, _DWORD *a3, void *a4, _DWORD *a5, _DWORD *a6, int a7)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  memset(v14, 0, sizeof(v14));
  LODWORD(v14[0]) = -1;
  BYTE4(v14[0]) = 1;
  *a4 = 0;
  *a5 = 0;
  if (!a1 || !a2) {
    goto LABEL_9;
  }
  if (a3) {
    goto LABEL_6;
  }
  if (!a7)
  {
LABEL_9:
    uint64_t result = 0;
    *a6 = 0;
    return result;
  }
  a3 = v14;
LABEL_6:
  int v11 = _filterFatArchs(a1, a2, a3, a4);
  if (!v11) {
    return 1;
  }
  int v12 = v11;
  if (!a7 && v11 == a2) {
    goto LABEL_9;
  }
  if (v11 == 1)
  {
    uint64_t result = 0;
    *a6 = 1;
  }
  else
  {
    uint64_t result = 0;
    *a6 = 2;
  }
  *a5 = v12;
  return result;
}

void *_sortFatArchsByOffset(void *result, int a2)
{
  if (result)
  {
    if (a2) {
      return (void *)mergesort(result, a2, 8uLL, (int (__cdecl *)(const void *, const void *))_compareFatArchsByOffset);
    }
  }
  return result;
}

uint64_t _compareFatArchsByOffset(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(*(void *)a1 + 8);
  unsigned int v3 = *(_DWORD *)(*(void *)a2 + 8);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

double _createNewFatArchArray(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2 >= 1)
  {
    BOOL v4 = (double *)(a3 + 12);
    uint64_t v5 = a2;
    do
    {
      uint64_t v6 = *a1++;
      *(double *)((char *)v4 - 12) = *(double *)v6;
      double result = *(double *)(v6 + 12);
      *BOOL v4 = result;
      uint64_t v8 = *(unsigned int *)(v6 + 12);
      uint64_t v9 = (a4 + (1 << *(_DWORD *)(v6 + 16)) - 1) & (0xFFFFFFFFLL << *(_DWORD *)(v6 + 16));
      *((_DWORD *)v4 - 1) = v9;
      a4 = v9 + v8;
      BOOL v4 = (double *)((char *)v4 + 20);
      --v5;
    }
    while (v5);
  }
  return result;
}

size_t _normalizeBomCopySpecification(uint64_t a1, unsigned int a2, unsigned int a3, size_t *a4)
{
  uint64_t v6 = *(unsigned int *)(a1 + 48);
  uint64_t v7 = a3;
  uint64_t v8 = a2;
  if ((int)v6 < 1)
  {
    int v9 = 0;
  }
  else
  {
    int v9 = 0;
    unsigned int v10 = (void *)(a1 + 64);
    do
    {
      switch(*((_DWORD *)v10 - 2))
      {
        case 0:
          uint64_t v12 = *v10 % (uint64_t)a2;
          BOOL v13 = *v10 < (uint64_t)a2;
          goto LABEL_8;
        case 1:
        case 3:
        case 4:
          int v11 = 1;
          break;
        case 2:
          uint64_t v12 = *v10 % (uint64_t)a3;
          BOOL v13 = *v10 < (uint64_t)a3;
LABEL_8:
          int v11 = !v13;
          if (v13) {
            int v14 = 1;
          }
          else {
            int v14 = 2;
          }
          if (v12) {
            int v11 = v14;
          }
          break;
        default:
          int v11 = 0;
          break;
      }
      v10 += 7;
      v9 += v11;
      --v6;
    }
    while (v6);
  }
  size_t result = (size_t)BOM_calloc(56 * v9 + 56, 1uLL);
  size_t v16 = result;
  *(void *)size_t result = *(void *)a1;
  *(void *)(result + 8) = *(void *)(a1 + 8);
  *(void *)(result + 16) = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 32);
  *(void *)(result + 24) = *(void *)(a1 + 24);
  *(void *)(result + 32) = v17;
  *(void *)(result + 40) = *(void *)(a1 + 40);
  *(_DWORD *)(result + 48) = v9;
  if (*(int *)(a1 + 48) >= 1)
  {
    uint64_t v18 = 0;
    int v19 = 0;
    uint64_t v20 = *(void *)(a1 + 16);
    uint64_t v21 = (void *)(a1 + 96);
    while (2)
    {
      if (*((_DWORD *)v21 - 6) <= 1u) {
        int v22 = 1;
      }
      else {
        int v22 = *((_DWORD *)v21 - 6);
      }
      int v23 = *((_DWORD *)v21 - 10);
      size_t result = 0;
      uint64_t v24 = 0;
      uint64_t v25 = *(v21 - 2);
      size_t v26 = *v21;
      uint64_t v27 = *(v21 - 4) * v22;
      switch(v23)
      {
        case 0:
          size_t result = v27 % v8;
          if (v27 != v27 % v8)
          {
            size_t v28 = v16 + 56 * v19;
            *(_DWORD *)(v28 + 56) = 0;
            *(void *)(v28 + 64) = v8;
            *(_DWORD *)(v28 + 72) = v27 / v8;
            *(void *)(v28 + 80) = v25;
            *(void *)(v28 + 88) = 0;
            *(void *)(v28 + 96) = v26;
            *(void *)(v28 + 104) = v20;
            ++v19;
          }
          if (result)
          {
            uint64_t v24 = 0;
            size_t v26 = v27 + v26 - result;
            goto LABEL_34;
          }
          goto LABEL_35;
        case 1:
          uint64_t v24 = *(v21 - 1);
          size_t result = *(v21 - 4) * v22;
          goto LABEL_34;
        case 2:
          size_t result = v27 % v7;
          uint64_t v29 = v27 - v27 % v7;
          if (v27 != v27 % v7)
          {
            size_t v30 = v16 + 56 * v19;
            *(_DWORD *)(v30 + 56) = 2;
            *(void *)(v30 + 64) = v7;
            *(_DWORD *)(v30 + 72) = v27 / v7;
            *(void *)(v30 + 80) = v25;
            *(void *)(v30 + 88) = 0;
            *(void *)(v30 + 96) = v26;
            *(void *)(v30 + 104) = v20;
            ++v19;
          }
          if (!result) {
            goto LABEL_35;
          }
          uint64_t v24 = 0;
          v25 += v29;
          v26 += v29;
LABEL_34:
          size_t v31 = v16 + 56 * v19;
          *(_DWORD *)(v31 + 56) = v23;
          *(void *)(v31 + 64) = result;
          *(_DWORD *)(v31 + 72) = 1;
          *(void *)(v31 + 80) = v25;
          *(void *)(v31 + 88) = v24;
          *(void *)(v31 + 96) = v26;
          *(void *)(v31 + 104) = v20;
          ++v19;
LABEL_35:
          v21 += 7;
          if (++v18 >= *(int *)(a1 + 48)) {
            goto LABEL_38;
          }
          continue;
        case 3:
        case 4:
          goto LABEL_34;
        default:
          goto LABEL_35;
      }
    }
  }
  int v19 = 0;
LABEL_38:
  if (v19 != v9) {
    size_t result = fwrite("BOMCopier: Inconsistency while preflighting copy\n", 0x31uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
  }
  *a4 = v16;
  return result;
}

uint64_t _printBomCopySpecification(const void **a1)
{
  printf("_BOMCopySpecification %p:\n", a1);
  printf("\tcopier:\t%p\n", *a1);
  printf("\tsource:\t%p\n", a1[1]);
  printf("\tdest:\t%p\n", a1[2]);
  printf("\toriginalSourceSize:\t%lld\n", a1[4]);
  printf("\ttotalDestinationSize:\t%lld\n", a1[5]);
  printf("\tnumSteps:\t%d\n", *((_DWORD *)a1 + 12));
  uint64_t result = puts("-------------------");
  if (*((int *)a1 + 12) >= 1)
  {
    uint64_t v3 = 0;
    BOOL v4 = a1 + 11;
    do
    {
      uint64_t result = printf("Step %d:\n", v3);
      switch(*((_DWORD *)v4 - 8))
      {
        case 0:
          uint64_t v5 = "_BOMCopyStepZero";
          goto LABEL_7;
        case 1:
          printf("\ttype:\t%s\n", "_BOMCopyStepBuffer");
          printf("\tsize:\t%lld\n", *(v4 - 3));
          printf("\tbuffer:\t%p\n");
          goto LABEL_9;
        case 2:
          uint64_t v5 = "_BOMCopyStepCopy";
LABEL_7:
          printf("\ttype:\t%s\n", v5);
          printf("\tsize:\t%lld\n", *(v4 - 3));
          printf("\titerationCount:\t%d\n");
          goto LABEL_9;
        case 3:
          printf("\ttype:\t%s\n");
LABEL_9:
          printf("\tsourceOffset:\t%lld\n", *(v4 - 1));
          uint64_t result = printf("\tdestOffset:\t%lld\n");
          break;
        case 4:
          printf("\ttype:\t%s\n", "_BOMCopyStepSeekToEndOfSource");
          uint64_t result = printf("\tsourceOffset:\t%lld\n");
          break;
        default:
          break;
      }
      v4 += 7;
      ++v3;
    }
    while (v3 < *((int *)a1 + 12));
  }
  return result;
}

uint64_t _executeBomCopySpecification(int *a1, unsigned int a2, unsigned int a3, unsigned int *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8 = a4;
  if (a4) {
    uLong v11 = *a4;
  }
  else {
    uLong v11 = 0;
  }
  if (!a1)
  {
    uint64_t v14 = 22;
    goto LABEL_124;
  }
  uint64_t v84 = (UInt8 *)BOM_calloc(a2, 1uLL);
  if (!v84)
  {
    uint64_t v14 = 12;
    goto LABEL_124;
  }
  uint64_t v12 = *(void *)a1;
  if (*(unsigned char *)(*(void *)a1 + 3328)) {
    uint64_t v13 = v12 + 3328;
  }
  else {
    uint64_t v13 = *(void *)(v12 + 2296);
  }
  uint64_t v81 = *(void *)a1;
  AAFieldKey v82 = v8;
  statfs buf = *(char **)(v12 + 8);
  uint64_t v15 = (int *)*((void *)a1 + 1);
  uLong crc = v11;
  if (a5)
  {
    uint64_t v16 = CNCRCInit();
    if (v16)
    {
      uint64_t v14 = v16;
      goto LABEL_123;
    }
  }
  if (a1[12] < 1)
  {
    uint64_t v14 = 0;
    goto LABEL_123;
  }
  uint64_t v77 = v13;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  int64_t v79 = a3;
  uint64_t v80 = a5;
  while (2)
  {
    uint64_t v20 = (uint64_t *)&a1[14 * v17];
    uint64_t v21 = v20[13];
    if (!v21) {
      uint64_t v21 = *((void *)a1 + 2);
    }
    switch(*((_DWORD *)v20 + 14))
    {
      case 0:
        int v22 = (uint64_t *)&a1[14 * v17];
        int v24 = *((_DWORD *)v22 + 18);
        int v23 = v22 + 9;
        if (v24 >= 1)
        {
          int v25 = 0;
          size_t v26 = (uint64_t *)&a1[14 * v17];
          CFIndex v29 = v26[8];
          size_t v28 = v26 + 8;
          CFIndex v27 = v29;
          do
          {
            CFIndex v30 = BOMFileWrite(v21, v84, v27);
            if (v30 != *v28) {
              goto LABEL_114;
            }
            CFIndex v27 = v30;
            if (v82)
            {
              uLong crc = crc32(crc, v84, v30);
              CFIndex v27 = *v28;
            }
            if (a5)
            {
              CNCRCUpdate();
              CFIndex v27 = *v28;
            }
            v18 += v27;
            ++v25;
          }
          while (v25 < *v23);
        }
        size_t v31 = *(void (**)(uint64_t, void, uint64_t))(v81 + 104);
        if (!v31) {
          goto LABEL_37;
        }
        v31(v81, *((void *)a1 + 3), v18);
        if (!*(unsigned char *)(v81 + 168)) {
          goto LABEL_37;
        }
        goto LABEL_127;
      case 1:
        unsigned int v32 = (uint64_t *)&a1[14 * v17];
        CFIndex v34 = v32[8];
        int v33 = v32 + 8;
        CFIndex v35 = BOMFileWrite(v21, (UInt8 *)v33[3], v34);
        if (v35 != *v33) {
          goto LABEL_114;
        }
        CFIndex v36 = v35;
        if (v82)
        {
          uLong crc = crc32(crc, (const Bytef *)v33[3], v35);
          CFIndex v36 = *v33;
        }
        if (a5)
        {
          CNCRCUpdate();
          CFIndex v36 = *v33;
        }
        v18 += v36;
        int v37 = *(void (**)(uint64_t, void, uint64_t))(v81 + 104);
        if (v37)
        {
          v37(v81, *((void *)a1 + 3), v18);
          if (*(unsigned char *)(v81 + 168)) {
            goto LABEL_127;
          }
        }
LABEL_37:
        uint64_t v14 = 0;
        goto LABEL_97;
      case 2:
        unsigned int v38 = (uint64_t *)&a1[14 * v17];
        uint64_t v40 = v38[10];
        int v39 = v38 + 10;
        if (v40 <= a6) {
          goto LABEL_41;
        }
        if (BOMFileSeek() < 0)
        {
LABEL_114:
          uint64_t v74 = __error();
          uint64_t v43 = v81;
          uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
          if (v70)
          {
LABEL_115:
            uint64_t v71 = *v74;
            uint64_t v72 = v43;
            uint64_t v73 = v77;
LABEL_116:
            unsigned int v75 = v70(v72, v73, v71);
            if (v75 == 1)
            {
              unsigned int v75 = 0;
LABEL_120:
              if (*(unsigned char *)(v43 + 168)) {
                uint64_t v14 = 2;
              }
              else {
                uint64_t v14 = v75;
              }
              goto LABEL_123;
            }
            if (v75) {
              goto LABEL_120;
            }
          }
          goto LABEL_118;
        }
        a6 = *v39;
LABEL_41:
        uint64_t v78 = &a1[14 * v17 + 18];
        if (*v78 >= 1)
        {
          int v41 = 0;
          uint64_t v42 = (unint64_t *)&a1[14 * v17 + 16];
          while (1)
          {
            uint64_t v43 = v81;
            unint64_t v44 = *v42;
            if (*(_DWORD *)(v81 + 12776))
            {
              CFIndex v45 = 0;
              while (1)
              {
                unint64_t v46 = BOMFileRead(v15, buf, v44 - v45);
                if ((v46 & 0x8000000000000000) != 0) {
                  goto LABEL_111;
                }
                v45 += v46;
                if (!BOMFileEndOfCompressionStream((BOOL)v15))
                {
                  unint64_t v44 = *v42;
                  if (v45 != *v42) {
                    continue;
                  }
                }
                goto LABEL_50;
              }
            }
            CFIndex v45 = BOMFileRead(v15, buf, v44);
LABEL_50:
            if (v45 != *v42) {
              goto LABEL_111;
            }
            CFIndex v47 = BOMFileWrite(v21, (UInt8 *)buf, v45);
            if (v47 != *v42) {
              break;
            }
            unint64_t v48 = v47;
            if (v82)
            {
              uLong crc = crc32(crc, (const Bytef *)buf, v47);
              unint64_t v48 = *v42;
            }
            if (v80)
            {
              CNCRCUpdate();
              unint64_t v48 = *v42;
            }
            v18 += v48;
            int v49 = *(void (**)(uint64_t, void, uint64_t))(v81 + 104);
            if (v49)
            {
              v49(v81, *((void *)a1 + 3), v18);
              if (*(unsigned char *)(v81 + 168))
              {
                uint64_t v14 = 2;
                goto LABEL_123;
              }
            }
            uint64_t v14 = 0;
            a6 += v45;
            if (++v41 >= *v78) {
              goto LABEL_97;
            }
          }
          uint64_t v74 = __error();
          uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
          if (v70) {
            goto LABEL_115;
          }
          goto LABEL_118;
        }
        goto LABEL_96;
      case 3:
        uint64_t v50 = *((void *)a1 + 4);
        unint64_t v51 = v50 - a6;
        if (v50 - a6 >= v79) {
          unint64_t v51 = v79;
        }
        if (v50 == -1) {
          unint64_t v52 = v79;
        }
        else {
          unint64_t v52 = v51;
        }
        uint64_t v14 = v19;
        if (!v52) {
          goto LABEL_97;
        }
        while (2)
        {
          if ((*(_DWORD *)(v81 + 12776) || *(unsigned char *)(v81 + 12796))
            && *(unsigned char *)(v81 + 12769)
            && BOMFileEndOfCompressionStream((BOOL)v15))
          {
            goto LABEL_96;
          }
          CFIndex v53 = BOMFileRead(v15, buf, v52);
          if (v53 < 0 || (CFIndex v54 = v53, v55 = *((void *)a1 + 4), v52 != v53) && v55 != -1)
          {
            uint64_t v61 = __error();
            uint64_t v62 = v81;
            char v63 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
            if (!v63) {
              goto LABEL_105;
            }
            uint64_t v64 = *v61;
            uint64_t v65 = v81;
            uint64_t v66 = v81 + 248;
LABEL_103:
            unsigned int v68 = v63(v65, v66, v64);
            if (v68 == 1)
            {
              unsigned int v68 = 0;
LABEL_107:
              if (*(unsigned char *)(v62 + 168)) {
                uint64_t v14 = 2;
              }
              else {
                uint64_t v14 = v68;
              }
              goto LABEL_97;
            }
            if (v68) {
              goto LABEL_107;
            }
LABEL_105:
            unsigned int v68 = 1;
            goto LABEL_107;
          }
          a6 += v53;
          if (!v53 && v55 == -1) {
            goto LABEL_96;
          }
          if (BOMFileWrite(v21, (UInt8 *)buf, v53) != v53)
          {
            uint64_t v67 = __error();
            uint64_t v62 = v81;
            char v63 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v81 + 72);
            if (!v63) {
              goto LABEL_105;
            }
            uint64_t v64 = *v67;
            uint64_t v65 = v81;
            uint64_t v66 = v77;
            goto LABEL_103;
          }
          if (v82) {
            uLong crc = crc32(crc, (const Bytef *)buf, v54);
          }
          if (v80) {
            CNCRCUpdate();
          }
          v18 += v54;
          BOOL v56 = *(void (**)(uint64_t, void, uint64_t))(v81 + 104);
          if (!v56 || (v56(v81, *((void *)a1 + 3), v18), !*(unsigned char *)(v81 + 168)))
          {
            uint64_t v19 = 0;
            uint64_t v14 = 0;
            uint64_t v57 = *((void *)a1 + 4);
            unint64_t v58 = v57 - a6;
            if (v57 - a6 >= v79) {
              unint64_t v58 = v79;
            }
            if (v57 == -1) {
              unint64_t v52 = v79;
            }
            else {
              unint64_t v52 = v58;
            }
            if (!v52) {
              goto LABEL_97;
            }
            continue;
          }
          break;
        }
LABEL_127:
        uint64_t v14 = 2;
LABEL_123:
        free(v84);
        uint64_t v8 = v82;
        LODWORD(v11) = crc;
LABEL_124:
        if (v8) {
          *uint64_t v8 = v11;
        }
        return v14;
      case 4:
        uint64_t v59 = *((void *)a1 + 4);
        if (v59 == -1)
        {
          uint64_t v43 = v81;
          if (!BOMFileEndOfCompressionStream((BOOL)v15))
          {
            while (1)
            {
              unint64_t v60 = BOMFileRead(v15, buf, v79);
              if ((v60 & 0x8000000000000000) != 0) {
                break;
              }
              a6 += v60;
              if (BOMFileEndOfCompressionStream((BOOL)v15)) {
                goto LABEL_96;
              }
            }
LABEL_111:
            uint64_t v69 = __error();
LABEL_112:
            uint64_t v70 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v43 + 72);
            if (v70)
            {
              uint64_t v71 = *v69;
              uint64_t v72 = v43;
              uint64_t v73 = v81 + 248;
              goto LABEL_116;
            }
LABEL_118:
            unsigned int v75 = 1;
            goto LABEL_120;
          }
        }
        else if (v59 > a6)
        {
          if (BOMFileSeek() < 0)
          {
            uint64_t v69 = __error();
            uint64_t v43 = v81;
            goto LABEL_112;
          }
          a6 = *((void *)a1 + 4);
        }
LABEL_96:
        uint64_t v14 = v19;
LABEL_97:
        ++v17;
        uint64_t v19 = v14;
        a5 = v80;
        if (v17 >= a1[12]) {
          goto LABEL_123;
        }
        continue;
      default:
        goto LABEL_96;
    }
  }
}

uint64_t _checkCopyFileError(uint64_t a1)
{
  unsigned int v2 = *(uint64_t (**)(uint64_t))(a1 + 72);
  if (!v2)
  {
LABEL_4:
    LODWORD(result) = 1;
    goto LABEL_6;
  }
  LODWORD(result) = v2(a1);
  if (result != 1)
  {
    if (result) {
      goto LABEL_6;
    }
    goto LABEL_4;
  }
  LODWORD(result) = 0;
LABEL_6:
  if (*(unsigned char *)(a1 + 168)) {
    return 2;
  }
  else {
    return result;
  }
}

uint64_t _checkCopyFileConflictError(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(a1 + 80);
  if (v1) {
    return v1();
  }
  else {
    return 0;
  }
}

uint64_t _ignore_readdir_entry(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int16 *)(a1 + 18);
  if (v1 == 2)
  {
    unsigned int v2 = (const char *)(a1 + 21);
    uint64_t v3 = "..";
    size_t v4 = 2;
    return !strncmp(v3, v2, v4);
  }
  if (v1 == 1) {
    return *(unsigned char *)(a1 + 21) == 46;
  }
  if (v1 < 4) {
    return 0;
  }
  uint64_t v5 = (const char *)(a1 + 21);
  if (strncmp(".nfs", (const char *)(a1 + 21), 4uLL))
  {
    if (v1 < 0xB) {
      return 0;
    }
    uint64_t v3 = ".afpDeleted";
    unsigned int v2 = v5;
    size_t v4 = 11;
    return !strncmp(v3, v2, v4);
  }
  return 1;
}

BOOL _sanitizePath(char *cStr, uint64_t a2)
{
  uint64_t v3 = 0;
  int v4 = 0;
  int v5 = 0;
  int v6 = 0;
  do
  {
    int v7 = cStr[v3];
    switch(v4)
    {
      case 0:
        if (v7 == 47) {
          int v4 = 0;
        }
        else {
          int v4 = 3;
        }
        if (v7 == 46) {
          int v4 = 1;
        }
        break;
      case 1:
        if (v7 == 47) {
          int v4 = 0;
        }
        else {
          int v4 = 3;
        }
        if (v7 == 46) {
          int v4 = 2;
        }
        break;
      case 2:
        if (v7 == 47) {
          int v8 = 1;
        }
        else {
          int v8 = v5;
        }
        if (v7 == 47) {
          int v9 = 0;
        }
        else {
          int v9 = 3;
        }
        if (cStr[v3]) {
          int v5 = v8;
        }
        else {
          int v5 = 1;
        }
        if (cStr[v3]) {
          int v4 = v9;
        }
        else {
          int v4 = 0;
        }
        break;
      case 3:
        if (v7 == 47) {
          int v4 = 0;
        }
        else {
          int v4 = 3;
        }
        break;
      default:
        break;
    }
    v6 |= cStr[v3++] < 0;
  }
  while (a2 + 1 != v3);
  if (((v6 | v5) & 1) == 0) {
    return 0;
  }
  CFStringEncoding v10 = 134217984;
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFStringRef v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], cStr, 0x8000100u);
  if (v12)
  {
    CFStringRef v13 = v12;
    if ((v5 & 1) == 0) {
      goto LABEL_54;
    }
    goto LABEL_38;
  }
  CFStringEncoding SystemEncoding = CFStringGetSystemEncoding();
  CFStringRef v13 = CFStringCreateWithCString(v11, cStr, SystemEncoding);
  if (v13)
  {
    if ((v5 & 1) == 0)
    {
LABEL_54:
      int CString = CFStringGetCString(v13, cStr, 1024, v10);
      CFRelease(v13);
      return CString == 0;
    }
LABEL_38:
    CFStringEncoding v28 = v10;
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v11, v13, @"/");
    CFAllocatorRef alloc = v11;
    CFArrayRef MutableCopy = CFArrayCreateMutableCopy(v11, 0, ArrayBySeparatingStrings);
    CFRelease(v13);
    CFRelease(ArrayBySeparatingStrings);
    CFIndex Count = CFArrayGetCount(MutableCopy);
    if (Count >= 1)
    {
      CFIndex v19 = Count;
      for (uint64_t i = 0; i != v19; ++i)
      {
        CFIndex v21 = CFArrayGetCount(MutableCopy);
        if (v21 >= 1)
        {
          uint64_t v22 = v21;
          CFIndex v23 = 0;
          while (1)
          {
            CFStringRef ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, v23);
            if (CFEqual(ValueAtIndex, @"..")) {
              break;
            }
            if (v23 && (CFEqual(ValueAtIndex, @".") || CFEqual(ValueAtIndex, &stru_26C28CFD8))) {
              goto LABEL_51;
            }
            if (v22 == ++v23) {
              goto LABEL_52;
            }
          }
          CFArrayRemoveValueAtIndex(MutableCopy, v23);
          if (v22 >= 2)
          {
            if (v23)
            {
              --v23;
LABEL_51:
              CFArrayRemoveValueAtIndex(MutableCopy, v23);
              continue;
            }
          }
        }
LABEL_52:
        ;
      }
    }
    CFStringRef v13 = CFStringCreateByCombiningStrings(alloc, MutableCopy, @"/");
    CFRelease(MutableCopy);
    CFStringEncoding v10 = v28;
    goto LABEL_54;
  }
  CFStringRef v26 = CFStringCreateWithCString(v11, cStr, 0x600u);
  if (v26)
  {
    CFStringRef v13 = v26;
    CFStringEncoding v10 = 3071;
    if ((v5 & 1) == 0) {
      goto LABEL_54;
    }
    goto LABEL_38;
  }
  return 1;
}

char *_parse_arch_list(uint64_t a1, CFArrayRef theArray, const __CFDictionary *a3, _DWORD *a4, void **a5)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  CFIndex Count = CFArrayGetCount(theArray);
  int v11 = Count;
  if (!Count)
  {
    unint64_t v52 = *(void (**)(uint64_t, char *))(a1 + 56);
    if (v52)
    {
      strcpy(__str, "archs array is empty");
      v52(a1, __str);
    }
    return 0;
  }
  *a4 = Count;
  uint64_t v12 = (Count << 32) + 0x100000000;
  CFStringRef v13 = (char *)BOM_malloczero(v12 >> 27);
  if (!v13) {
    return v13;
  }
  uint64_t v14 = BOM_malloczero(v12 >> 29);
  *a5 = v14;
  if (!v14)
  {
    free(v13);
    return 0;
  }
  if (v11 < 1) {
    return v13;
  }
  uint64_t v58 = a1;
  uint64_t v62 = v13;
  char v63 = a5;
  CFIndex v15 = 0;
  uint64_t v61 = v11;
  while (1)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v15);
    if (!ValueAtIndex || (CFStringRef v17 = ValueAtIndex, TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(v17)))
    {
      uint64_t v54 = v58;
      if (*(void *)(v58 + 56))
      {
        snprintf(__str, 0x800uLL, "can't read arch #%d from archs list");
LABEL_65:
        (*(void (**)(uint64_t, char *))(v54 + 56))(v54, __str);
      }
LABEL_66:
      free(*v63);
      free(v13);
      CFStringRef v13 = 0;
      *a4 = 0;
      return v13;
    }
    CFStringRef UTF8String = (char *)BOMCFStringGetUTF8String(v17);
    if (!UTF8String)
    {
      uint64_t v54 = v58;
      if (*(void *)(v58 + 56))
      {
        snprintf(__str, 0x800uLL, "can't convert arch #%d from archs listinto UTF8 encoded C string");
        goto LABEL_65;
      }
      goto LABEL_66;
    }
    uint64_t v20 = UTF8String;
    CFIndex v21 = BOMGetArchInfoFromName(UTF8String);
    if (!v21 || (int v22 = *((_DWORD *)v21 + 3), (v23 = BOMGetArchInfoFromCpuType(*((_DWORD *)v21 + 2), -1)) == 0))
    {
      if (*(void *)(v58 + 56))
      {
        snprintf(__str, 0x800uLL, "can't get arch info for '%s'", v20);
        (*(void (**)(uint64_t, char *))(v58 + 56))(v58, __str);
      }
      free(v20);
      goto LABEL_66;
    }
    int v25 = *((_DWORD *)v23 + 2);
    int v24 = *((_DWORD *)v23 + 3);
    BOOL v26 = v25 == 16777228 && v22 == 0;
    if (v26) {
      int v27 = 16777228;
    }
    else {
      int v27 = *((_DWORD *)v23 + 2);
    }
    char v28 = !v26;
    if (v26) {
      int v29 = v22;
    }
    else {
      int v29 = -1;
    }
    if (v25 == 16777223 && v22 == 3)
    {
      int v27 = 16777223;
      char v28 = 0;
      int v29 = v22;
    }
    BOOL v31 = v22 == v24;
    int v32 = v22 == v24 ? v27 : *((_DWORD *)v23 + 2);
    char v33 = v31 ? v28 : 0;
    int v34 = v31 ? v29 : v22;
    CFIndex v35 = &v13[32 * v15];
    *(_DWORD *)CFIndex v35 = v32;
    v35[4] = v33;
    *((void *)v35 + 2) = 0;
    CFIndex v36 = v35 + 16;
    *((_DWORD *)v35 + 2) = v34;
    *((_DWORD *)v35 + 6) = 0;
    int v37 = (unsigned int *)(v35 + 24);
    *((void *)*v63 + v15) = v20;
    CFDictionaryRef v38 = a3;
    if (a3)
    {
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a3, v17);
      if (Value)
      {
        CFArrayRef v40 = Value;
        CFTypeID v41 = CFArrayGetTypeID();
        if (v41 == CFGetTypeID(v40))
        {
          CFIndex v42 = CFArrayGetCount(v40);
          unsigned int v43 = v42;
          if (v42) {
            break;
          }
        }
      }
    }
LABEL_49:
    ++v15;
    a3 = v38;
    CFStringRef v13 = v62;
    if (v15 == v61) {
      return v13;
    }
  }
  unint64_t v60 = (char *)BOM_malloczero((4 * v42 + 4) & 0x3FFFFFFFCLL);
  if (!v60) {
    return 0;
  }
  unsigned int v56 = v43;
  uint64_t v57 = a4;
  uint64_t v44 = 0;
  uint64_t v59 = 4 * v43;
  while (1)
  {
    CFStringRef v45 = (const __CFString *)CFArrayGetValueAtIndex(v40, v15);
    if (!v45 || (CFStringRef v46 = v45, v47 = CFStringGetTypeID(), v47 != CFGetTypeID(v46)))
    {
      uint64_t v55 = v58;
      if (!*(void *)(v58 + 56)) {
        goto LABEL_73;
      }
      snprintf(__str, 0x800uLL, "can't read fallback arch #%d from fallback archs list");
LABEL_69:
      (*(void (**)(uint64_t, char *))(v55 + 56))(v55, __str);
      goto LABEL_73;
    }
    unint64_t v48 = (char *)BOMCFStringGetUTF8String(v46);
    if (!v48)
    {
      uint64_t v55 = v58;
      if (!*(void *)(v58 + 56)) {
        goto LABEL_73;
      }
      snprintf(__str, 0x800uLL, "can't convert fallback arch #%d from fallback archs listinto UTF8 encoded C string");
      goto LABEL_69;
    }
    int v49 = v48;
    uint64_t v50 = BOMGetArchInfoFromName(v48);
    if (!v50) {
      break;
    }
    unint64_t v51 = v50;
    free(v49);
    *(_DWORD *)&v60[v44] = *((_DWORD *)v51 + 3);
    v44 += 4;
    if (v59 == v44)
    {
      *CFIndex v36 = v60;
      a4 = v57;
      *int v37 = v56;
      goto LABEL_49;
    }
  }
  if (*(void *)(v58 + 56))
  {
    snprintf(__str, 0x800uLL, "can't get arch info for '%s'", v49);
    (*(void (**)(uint64_t, char *))(v58 + 56))(v58, __str);
  }
  free(v49);
LABEL_73:
  free(v60);
  free(v20);
  free(*v63);
  free(v62);
  CFStringRef v13 = 0;
  _DWORD *v57 = 0;
  return v13;
}

_DWORD *_BOMFreeListAllocate(const __CFDictionary *a1)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a1 && (CFArrayRef Value = (__CFString *)CFDictionaryGetValue(a1, @"Implementation")) != 0)
  {
    unsigned int v2 = Value;
    CFTypeID v3 = CFGetTypeID(Value);
    if (v3 == CFStringGetTypeID()) {
      int v4 = v2;
    }
    else {
      int v4 = 0;
    }
  }
  else
  {
    int v4 = 0;
  }
  if (v4) {
    int v5 = v4;
  }
  else {
    int v5 = @"dense";
  }
  if (CFEqual(v5, @"dense"))
  {
    return _BOMFreeListAllocateDense();
  }
  else
  {
    if (!CFEqual(v5, @"dense+trace")) {
      _BOMFreeListAllocate_cold_1();
    }
    int v7 = BOM_malloc(0x48uLL);
    if (!v7) {
      _BOMFreeListAllocate_cold_2();
    }
    int v8 = v7;
    v7[2] = _densetrace_initialize;
    void v7[3] = _densetrace_serialize;
    v7[4] = _densetrace_deallocate;
    v7[7] = _densetrace_clear;
    v7[5] = _densetrace_addFreeRange;
    v7[6] = _densetrace_allocateRange;
    v7[8] = _densetrace_print;
    int v9 = getenv("TMPDIR");
    if (v9) {
      CFStringEncoding v10 = v9;
    }
    else {
      CFStringEncoding v10 = "/tmp";
    }
    pid_t v11 = getpid();
    int v12 = _BOMFreeListAllocateDenseTrace_objnumber++;
    snprintf(__str, 0x400uLL, "%s/bomfreelist.trace.%d.%d.txt", v10, v11, v12);
    CFStringRef v13 = fopen(__str, "w");
    if (!v13) {
      _BOMFreeListAllocate_cold_3();
    }
    uint64_t v14 = v13;
    CFIndex v15 = BOM_malloc(0x18uLL);
    if (!v15) {
      _BOMFreeListAllocate_cold_4();
    }
    uint64_t v16 = v15;
    *CFIndex v15 = _BOMFreeListAllocateDense();
    *((_DWORD *)v16 + 2) = 1;
    _OWORD v16[2] = v14;
    *int v8 = v16;
    *((_DWORD *)v8 + 2) = 0;
    return v8;
  }
}

_DWORD *_BOMFreeListAllocateDense()
{
  uint64_t v0 = BOM_malloc(0x48uLL);
  unsigned int v1 = v0;
  if (v0)
  {
    v0[2] = _dense_initialize;
    v0[3] = _dense_serialize;
    v0[4] = _dense_deallocate;
    v0[7] = _dense_clear;
    v0[5] = _dense_addFreeRange;
    v0[6] = _dense_allocateRange;
    v0[8] = _dense_print;
    unsigned int v2 = BOM_malloc(0x18uLL);
    if (v2)
    {
      CFTypeID v3 = v2;
      int v4 = BOM_calloc(0x20uLL, 8uLL);
      void *v3 = v4;
      if (v4)
      {
        v3[1] = 0;
        *((_DWORD *)v3 + 4) = 32;
        *(void *)unsigned int v1 = v3;
        v1[2] = 0;
        return v1;
      }
      free(v1);
      int v5 = v3;
    }
    else
    {
      int v5 = v1;
    }
    free(v5);
    return 0;
  }
  return v1;
}

uint64_t _dense_initialize(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  if ((a3 & 7) == 0 && (int)(a3 >> 3) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = (a3 >> 3);
    int v7 = (unsigned int *)(a2 + 4);
    do
    {
      unsigned int v8 = *(v7 - 1);
      unsigned int v9 = bswap32(v8);
      unsigned int v10 = bswap32(*v7);
      if (a4) {
        uint64_t v11 = v9;
      }
      else {
        uint64_t v11 = v8;
      }
      if (a4) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = *v7;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v5 + 40))(v5, v11, v12);
      v7 += 2;
      --v6;
    }
    while (v6);
  }
  return result;
}

_DWORD *_dense_serialize(uint64_t **a1, int a2, size_t *a3)
{
  int v4 = *a1;
  size_t v5 = 8 * *((int *)a1 + 2);
  *a3 = v5;
  uint64_t result = BOM_malloc(v5);
  if (result)
  {
    int v7 = *((_DWORD *)v4 + 4);
    if (v7 < 1)
    {
      int v9 = 0;
    }
    else
    {
      uint64_t v8 = 0;
      int v9 = 0;
      uint64_t v10 = *v4;
      do
      {
        uint64_t v11 = *(uint64_t **)(v10 + 8 * v8);
        if (v11)
        {
          int v12 = 2 * v9;
          do
          {
            unsigned int v13 = *((_DWORD *)v11 + 2);
            unsigned int v14 = *((_DWORD *)v11 + 3);
            unsigned int v15 = bswap32(v13);
            unsigned int v16 = bswap32(v14);
            if (a2)
            {
              unsigned int v13 = v15;
              unsigned int v14 = v16;
            }
            result[v12] = v13;
            result[v12 + 1] = v14;
            uint64_t v11 = (uint64_t *)*v11;
            v12 += 2;
            ++v9;
          }
          while (v11);
          int v7 = *((_DWORD *)v4 + 4);
        }
        ++v8;
      }
      while (v8 < v7);
    }
    CFStringRef v17 = (uint64_t *)v4[1];
    if (v17)
    {
      int v18 = 2 * v9;
      do
      {
        unsigned int v19 = *((_DWORD *)v17 + 2);
        unsigned int v20 = *((_DWORD *)v17 + 3);
        unsigned int v21 = bswap32(v19);
        unsigned int v22 = bswap32(v20);
        if (a2) {
          unsigned int v19 = v21;
        }
        result[v18] = v19;
        if (a2) {
          unsigned int v23 = v22;
        }
        else {
          unsigned int v23 = v20;
        }
        result[v18 + 1] = v23;
        CFStringRef v17 = (uint64_t *)*v17;
        v18 += 2;
      }
      while (v17);
    }
  }
  return result;
}

void _dense_deallocate(uint64_t a1)
{
  unsigned int v2 = *(void ***)a1;
  (*(void (**)(void))(a1 + 56))();
  free(*v2);
  free(v2);
  *(void *)a1 = 0;
}

void *_dense_clear(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int v2 = *(_DWORD *)(*a1 + 16);
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      int v4 = *(void **)(*(void *)v1 + 8 * i);
      *(void *)(*(void *)v1 + 8 * i) = 0;
      if (v4)
      {
        do
        {
          size_t v5 = (void *)*v4;
          free(v4);
          int v4 = v5;
        }
        while (v5);
        int v2 = *(_DWORD *)(v1 + 16);
      }
    }
  }
  uint64_t result = *(void **)(v1 + 8);
  *(void *)(v1 + 8) = 0;
  if (result)
  {
    do
    {
      int v7 = (void *)*result;
      free(result);
      uint64_t result = v7;
    }
    while (v7);
  }
  return result;
}

_DWORD *_dense_addFreeRange(_DWORD *result, int a2, unint64_t a3)
{
  if (a3)
  {
    size_t v5 = result;
    uint64_t v6 = *(void *)result;
    if (a3 < 0x10000)
    {
      unint64_t v8 = *(int *)(v6 + 16);
      if (v8 <= a3)
      {
        int v9 = a3 + 1;
        uint64_t v10 = (char *)BOM_realloc(*(void **)v6, (8 * (a3 + 1)));
        *(void *)uint64_t v6 = v10;
        if ((int)v8 <= (int)a3) {
          bzero(&v10[8 * *(int *)(v6 + 16)], 8 * (v9 - (int)v8));
        }
        *(_DWORD *)(v6 + 16) = v9;
        uint64_t v6 = *(void *)v5;
      }
      uint64_t v11 = *(void *)(*(void *)v6 + 8 * a3);
      uint64_t result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(void *)uint64_t result = v11;
      *(void *)(*(void *)v6 + 8 * a3) = result;
    }
    else
    {
      uint64_t v7 = *(void *)(v6 + 8);
      uint64_t result = BOM_malloc(0x10uLL);
      result[2] = a2;
      result[3] = a3;
      *(void *)uint64_t result = v7;
      *(void *)(v6 + 8) = result;
    }
    ++v5[2];
  }
  return result;
}

uint64_t _dense_allocateRange(uint64_t a1, unint64_t a2)
{
  int v4 = *(void **)a1;
  unint64_t v5 = *(int *)(*(void *)a1 + 16);
  if (v5 > a2)
  {
    uint64_t v6 = *(unsigned int **)(*v4 + 8 * a2);
    if (v6)
    {
      uint64_t v7 = v6[2];
      uint64_t v8 = *(void *)v6;
      free(v6);
      *(void *)(*v4 + 8 * a2) = v8;
      --*(_DWORD *)(a1 + 8);
      return v7;
    }
  }
  LODWORD(v9) = 0;
  while (1)
  {
    uint64_t v10 = (a2 + 1 + v9);
    if (v10 >= v5) {
      break;
    }
    uint64_t v11 = *(unsigned int **)(*v4 + 8 * v10);
    uint64_t v9 = (v9 + 1);
    if (v11)
    {
      uint64_t v7 = v11[2];
      uint64_t v12 = *(void *)v11;
      free(v11);
      *(void *)(*v4 + 8 * v10) = v12;
      --*(_DWORD *)(a1 + 8);
      (*(void (**)(uint64_t, void, uint64_t))(a1 + 40))(a1, (v7 + a2), v9);
      return v7;
    }
  }
  unsigned int v15 = (void **)v4[1];
  unsigned int v14 = v4 + 1;
  unsigned int v13 = v15;
  if (!v15) {
    return 0;
  }
  unint64_t v16 = *((unsigned int *)v13 + 3);
  if (v16 < a2)
  {
    while (1)
    {
      CFStringRef v17 = v13;
      unsigned int v13 = (void **)*v13;
      if (!v13) {
        return 0;
      }
      unint64_t v16 = *((unsigned int *)v13 + 3);
      if (v16 >= a2) {
        goto LABEL_15;
      }
    }
  }
  CFStringRef v17 = 0;
LABEL_15:
  int v18 = (void **)*v13;
  uint64_t v7 = *((unsigned int *)v13 + 2);
  uint64_t v19 = (v7 + a2);
  uint64_t v20 = (v16 - a2);
  free(v13);
  if (v17) {
    unsigned int v21 = v17;
  }
  else {
    unsigned int v21 = v14;
  }
  *unsigned int v21 = v18;
  --*(_DWORD *)(a1 + 8);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 40))(a1, v19, v20);
  return v7;
}

uint64_t _dense_print(uint64_t result, FILE *__stream, int a3)
{
  uint64_t v5 = *(void *)result;
  int v6 = *(_DWORD *)(*(void *)result + 16);
  if (v6 >= 1)
  {
    for (uint64_t i = 0; i < v6; ++i)
    {
      uint64_t v8 = *(void **)(*(void *)v5 + 8 * i);
      if (v8)
      {
        int v9 = 0;
        do
        {
          ++v9;
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
        if (v9 == 1) {
          uint64_t v10 = "y";
        }
        else {
          uint64_t v10 = "ies";
        }
        uint64_t result = fprintf(__stream, "Size %d: %d entr%s\n", i, v9, v10);
        int v6 = *(_DWORD *)(v5 + 16);
      }
    }
  }
  uint64_t v11 = *(uint64_t **)(v5 + 8);
  if (v11)
  {
    if (a3) {
      fwrite("Large sizes:\n\t", 0xEuLL, 1uLL, __stream);
    }
    int v12 = 1;
    if (!a3) {
      goto LABEL_17;
    }
    while (1)
    {
      fprintf(__stream, "%d ", *((_DWORD *)v11 + 3));
      uint64_t v11 = (uint64_t *)*v11;
      if (!v11) {
        break;
      }
      while (1)
      {
        ++v12;
        if (a3) {
          break;
        }
LABEL_17:
        uint64_t v11 = (uint64_t *)*v11;
        if (!v11)
        {
          unsigned int v13 = "ies";
          if (v12 == 1) {
            unsigned int v13 = "y";
          }
          return fprintf(__stream, "Large sizes: %d entr%s\n", v12, v13);
        }
      }
    }
    return fputc(10, __stream);
  }
  return result;
}

uint64_t _densetrace_initialize(_DWORD *a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
  a1[2] = *(_DWORD *)(*(void *)v2 + 8);
  return result;
}

uint64_t _densetrace_serialize(_DWORD *a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)a1 + 24))();
  a1[2] = *(_DWORD *)(*(void *)v2 + 8);
  return result;
}

void _densetrace_deallocate(uint64_t *a1)
{
  uint64_t v2 = *a1;
  (*(void (**)(void))(*(void *)*a1 + 32))();
  free(*(void **)v2);
  fclose(*(FILE **)(v2 + 16));
  free((void *)v2);
  *a1 = 0;
}

uint64_t _densetrace_clear(_DWORD *a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)a1 + 56))();
  a1[2] = *(_DWORD *)(*(void *)v2 + 8);
  return result;
}

uint64_t _densetrace_addFreeRange(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(FILE ***)a1;
  if (*(_DWORD *)(*(void *)a1 + 8)) {
    fprintf(v4[2], "Add\t\t%#zx\n", a3);
  }
  uint64_t result = (*(uint64_t (**)(void))&(*v4)->_lbfsize)();
  a1[2] = (*v4)->_r;
  return result;
}

uint64_t _densetrace_allocateRange(_DWORD *a1, uint64_t a2)
{
  CFTypeID v3 = *(FILE ***)a1;
  if (*(_DWORD *)(*(void *)a1 + 8)) {
    fprintf(v3[2], "Remove\t\t%#zx\n", a2);
  }
  uint64_t result = ((uint64_t (*)(void))(*v3)->_cookie)();
  a1[2] = (*v3)->_r;
  return result;
}

uint64_t _densetrace_print(_DWORD *a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t result = (*(uint64_t (**)(void))(**(void **)a1 + 64))();
  a1[2] = *(_DWORD *)(*(void *)v2 + 8);
  return result;
}

void **BOMFilesystemInfoCreate(int a1)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  size_t v13 = 100;
  *(void *)unsigned int v14 = 0x200000001;
  if (sysctl(v14, 2u, __str, &v13, 0, 0))
  {
    fwrite("Could not determine kernel version\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x263EF8348]);
LABEL_3:
    int v2 = -1;
    goto LABEL_10;
  }
  __endptr = 0;
  int v3 = strtol(__str, &__endptr, 0);
  int v4 = *__endptr;
  if (v4 != 46 && v4 != 0) {
    goto LABEL_3;
  }
  int v2 = v3;
LABEL_10:
  int v6 = (char *)BOM_calloc(0x328uLL, 1uLL);
  uint64_t v7 = (void **)v6;
  if (v6)
  {
    if (v2 == -1) {
      int v8 = 7;
    }
    else {
      int v8 = v2;
    }
    *((_DWORD *)v6 + 2) = v8;
    *((_DWORD *)v6 + 3) = a1;
    if (pthread_mutex_init((pthread_mutex_t *)(v6 + 16), 0))
    {
      free(v7);
      return 0;
    }
    else
    {
      for (uint64_t i = 0; i != 91; i += 13)
      {
        uint64_t v10 = &v7[i];
        v7[i + 12] = 0;
        __strlcpy_chk();
        *(_OWORD *)(v10 + 13) = 0u;
        *(_OWORD *)(v10 + 15) = 0u;
        *(_OWORD *)(v10 + 17) = 0u;
        *(_OWORD *)(v10 + 19) = 0u;
        *(_OWORD *)(v10 + 21) = 0u;
      }
      *uint64_t v7 = BomSys_default();
    }
  }
  return v7;
}

void BOMFilesystemInfoDestroy(uint64_t a1)
{
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  free((void *)a1);
}

uint64_t BOMFilesystemInfoQuery(uint64_t a1, unsigned char *a2, _DWORD *a3, int a4, int a5)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  if (a3 == (_DWORD *)&DEVICE_ARCHIVE)
  {
    uint64_t v10 = (long long *)&archive;
  }
  else if (a3 {
         && (int v8 = *a3 % 7, *(_DWORD *)(a1 + 104 * v8 + 96))
  }
         && (uint64_t v9 = a1 + 104 * v8, *(_DWORD *)(v9 + 100) == *a3))
  {
    uint64_t v10 = (long long *)(v9 + 104);
  }
  else
  {
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    memset(v20, 0, sizeof(v20));
    int v19 = 0;
    if (!a2 || _recursive_statfs(a2, v20, &v19, *(void *)a1)) {
      return 0xFFFFFFFFLL;
    }
    if (DWORD2(v21) == 7562856)
    {
      uint64_t v10 = &hfs7;
    }
    else if (DWORD2(v21) == 1718642273 && WORD6(v21) == 115)
    {
      uint64_t v10 = &afp;
    }
    else if ((BYTE1(v21) & 0x10) != 0)
    {
      uint64_t v10 = (long long *)&flatlocal;
    }
    else
    {
      uint64_t v10 = (long long *)&flatnetwork;
    }
    int v12 = v19;
    uint64_t v13 = a1 + 104 * (v19 % 7);
    *(_DWORD *)(v13 + 96) = 1;
    *(_DWORD *)(v13 + 100) = v12;
    __strlcpy_chk();
    *(_OWORD *)(v13 + 120) = v10[1];
    *(_OWORD *)(v13 + 136) = v10[2];
    *(_OWORD *)(v13 + 152) = v10[3];
    *(_OWORD *)(v13 + 168) = v10[4];
    *(_OWORD *)(v13 + 104) = *v10;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a4 <= 1819173228)
  {
    if (a4 == 1633905696)
    {
      unsigned int v15 = (unsigned int *)v10 + 13;
      uint64_t v16 = (unsigned int *)v10 + 14;
      CFStringRef v17 = (unsigned int *)v10 + 15;
      v10 += 3;
    }
    else
    {
      if (a4 != 1718511215) {
        return result;
      }
      unsigned int v15 = (unsigned int *)v10 + 5;
      uint64_t v16 = (unsigned int *)v10 + 6;
      CFStringRef v17 = (unsigned int *)v10++ + 7;
    }
  }
  else
  {
    switch(a4)
    {
      case 1819173229:
        unsigned int v15 = (unsigned int *)v10 + 17;
        uint64_t v16 = (unsigned int *)v10 + 18;
        CFStringRef v17 = (unsigned int *)v10 + 19;
        v10 += 4;
        break;
      case 2020897906:
        unsigned int v15 = (unsigned int *)v10 + 9;
        uint64_t v16 = (unsigned int *)v10 + 10;
        CFStringRef v17 = (unsigned int *)v10 + 11;
        v10 += 2;
        break;
      case 1920168547:
        unsigned int v15 = (unsigned int *)v10 + 1;
        uint64_t v16 = (unsigned int *)v10 + 2;
        CFStringRef v17 = (unsigned int *)v10 + 3;
        break;
      default:
        return result;
    }
  }
  if (*(_DWORD *)v10 <= 1u) {
    unsigned int v18 = 1;
  }
  else {
    unsigned int v18 = *(_DWORD *)v10;
  }
  if (a4 != 1819173229 && *(_DWORD *)(a1 + 12) != 0) {
    uint64_t result = v18;
  }
  else {
    uint64_t result = *(unsigned int *)v10;
  }
  if (a5 > 1919905651)
  {
    if (a5 == 1919905652) {
      return *v17;
    }
    if (a5 != 1936749172) {
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if (a5 != 1634756896)
    {
      if (a5 == 1853126245) {
        return *v15;
      }
      return 0xFFFFFFFFLL;
    }
    if (a4 != 1819173229 && *(_DWORD *)(a1 + 12) != 0) {
      return 1633968748;
    }
    else {
      return *v16;
    }
  }
  return result;
}

uint64_t _recursive_statfs(unsigned char *a1, void *a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  memset(__src, 0, 512);
  bzero(v15, 0x3FEuLL);
  *(_WORD *)__s = 12078;
  if (*a1 == 47) {
    __strlcpy_chk();
  }
  else {
    __strlcat_chk();
  }
  uint64_t v8 = (*(uint64_t (**)(void, char *, unsigned char *))(a4 + 104))(*(void *)(a4 + 8), __s, __src);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*__error() != 2) {
      return v9;
    }
    uint64_t v10 = strrchr(__s, 47);
    if (!v10) {
      return v9;
    }
    while (1)
    {
      if (v10 == __s) {
        __strlcpy_chk();
      }
      else {
        *uint64_t v10 = 0;
      }
      uint64_t v11 = (*(uint64_t (**)(void, char *, unsigned char *))(a4 + 104))(*(void *)(a4 + 8), __s, __src);
      if (!v11) {
        break;
      }
      uint64_t v9 = v11;
      uint64_t v10 = strrchr(__s, 47);
      if (!v10) {
        return v9;
      }
    }
  }
  memset(v13, 0, sizeof(v13));
  memcpy(a2, __src, 0x878uLL);
  uint64_t v9 = (*(uint64_t (**)(void, char *, _OWORD *))(a4 + 80))(*(void *)(a4 + 8), __s, v13);
  if (!v9) {
    *a3 = v13[0];
  }
  return v9;
}

uint64_t BOMArchFlagForHeader(int *a1, unint64_t a2)
{
  uint64_t result = 0;
  if (a1 && a2 >= 8)
  {
    int v4 = *a1;
    BOOL v5 = *a1 == -889275714 || v4 == -1095041334;
    if (!v5 || ((v6 = bswap32(a1[1]), v8 = v6 > 0x2A, unint64_t v7 = 20 * v6 + 8, !v8) ? (v8 = v7 > a2) : (v8 = 1), v8))
    {
      if (a2 >= 0x1C)
      {
        uint64_t result = 1;
        if (v4 != -822415874 && v4 != -17958194)
        {
          BOOL v10 = v4 == -17958193 || v4 == -805638658;
          return a2 >= 0x20 && v10;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t BOMArchFlagForFile(uint64_t a1)
{
  return BOMArchFlagForFileWithSys(a1, 0);
}

uint64_t BOMArchFlagForFileWithSys(uint64_t a1, void *a2)
{
  int v2 = a2;
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (!a2) {
    int v2 = BomSys_default();
  }
  uint64_t v4 = (*((uint64_t (**)(void, uint64_t, void, void))v2 + 2))(*((void *)v2 + 1), a1, 0, 0);
  if (v4 == -1) {
    return 0;
  }
  uint64_t v5 = v4;
  unint64_t v6 = (*((uint64_t (**)(void, uint64_t, int *, uint64_t))v2 + 6))(*((void *)v2 + 1), v4, v8, 32);
  (*((void (**)(void, uint64_t))v2 + 4))(*((void *)v2 + 1), v5);
  if (v6 == -1) {
    return 0;
  }
  else {
    return BOMArchFlagForHeader(v8, v6);
  }
}

uint64_t _fat_header_big_to_host(unsigned int *a1, unint64_t a2)
{
  if (a2 < 8) {
    return 0;
  }
  unsigned int v2 = a1[1];
  uint64_t v3 = bswap32(v2);
  *a1 = bswap32(*a1);
  a1[1] = v3;
  if (20 * (unint64_t)v3 + 8 > a2) {
    return 0;
  }
  if (v2)
  {
    uint64_t v5 = a1 + 6;
    do
    {
      *((int8x16_t *)v5 - 1) = vrev32q_s8(*((int8x16_t *)v5 - 1));
      unsigned int *v5 = bswap32(*v5);
      v5 += 5;
      --v3;
    }
    while (v3);
  }
  return 1;
}

uint64_t _fat_header_host_to_big(unsigned int *a1, unint64_t a2)
{
  if (a2 < 8) {
    return 0;
  }
  uint64_t v2 = a1[1];
  *a1 = bswap32(*a1);
  a1[1] = bswap32(v2);
  if (20 * (unint64_t)v2 + 8 > a2) {
    return 0;
  }
  if (v2)
  {
    uint64_t v4 = a1 + 6;
    do
    {
      *((int8x16_t *)v4 - 1) = vrev32q_s8(*((int8x16_t *)v4 - 1));
      *uint64_t v4 = bswap32(*v4);
      v4 += 5;
      --v2;
    }
    while (v2);
  }
  return 1;
}

uint64_t BOMHostByteOrder()
{
  return 1;
}

char **BOMGetArchInfoFromName(char *__s2)
{
  if (!__s2) {
    return 0;
  }
  uint64_t v2 = &BOMArchInfoTable;
  uint64_t v3 = "hppa";
  while (strcmp(v3, __s2))
  {
    uint64_t v4 = v2[4];
    v2 += 4;
    uint64_t v3 = v4;
    if (!v4) {
      return 0;
    }
  }
  return v2;
}

char **BOMGetArchInfoFromCpuType(int a1, int a2)
{
  uint64_t v3 = &BOMArchInfoTable;
  while (*((_DWORD *)v3 + 2) != a1 || a2 != -1 && ((*((_DWORD *)v3 + 3) ^ a2) & 0xFFFFFF) != 0)
  {
    uint64_t v4 = v3[4];
    v3 += 4;
    if (!v4)
    {
      if (a1 == 18)
      {
        unint64_t v6 = (char **)malloc_type_malloc(0x20uLL, 0x1050040796EC678uLL);
        uint64_t v3 = v6;
        if (!v6) {
          return v3;
        }
        *(_OWORD *)unint64_t v6 = xmmword_264132A58;
        *((_OWORD *)v6 + 1) = unk_264132A68;
        *((_DWORD *)v6 + 3) = a2;
        BOOL v8 = 0;
        asprintf(&v8, "PowerPC cpusubtype %u");
LABEL_12:
        if (v8)
        {
          v3[3] = v8;
          return v3;
        }
        free(v3);
      }
      else if (a1 == 7)
      {
        uint64_t v5 = (char **)malloc_type_malloc(0x20uLL, 0x1050040796EC678uLL);
        uint64_t v3 = v5;
        if (!v5) {
          return v3;
        }
        *(_OWORD *)uint64_t v5 = xmmword_264132998;
        *((_OWORD *)v5 + 1) = unk_2641329A8;
        *((_DWORD *)v5 + 3) = a2;
        BOOL v8 = 0;
        asprintf(&v8, "Intel family %u model %u");
        goto LABEL_12;
      }
      return 0;
    }
  }
  return v3;
}

int8x8_t BOMSwapFatHeader(int8x8_t *a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
      int8x8_t result = vrev32_s8(*a1);
      *a1 = result;
    }
  }
  return result;
}

uint64_t BOMSwapFatArch(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    uint64_t v5 = a2;
    unint64_t v6 = (unsigned int *)(a1 + 16);
    do
    {
      *((int8x16_t *)v6 - 1) = vrev32q_s8(*((int8x16_t *)v6 - 1));
      unsigned int *v6 = bswap32(*v6);
      v6 += 5;
      --v5;
    }
    while (v5);
    return 0;
  }
  return result;
}

uint64_t BOMSwapFatArch64(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    uint64_t v3 = a2;
    do
    {
      *(int8x8_t *)a1 = vrev32_s8(*(int8x8_t *)a1);
      *(int8x16_t *)(a1 + 8) = vrev64q_s8(*(int8x16_t *)(a1 + 8));
      *(int8x8_t *)(a1 + 24) = vrev32_s8(*(int8x8_t *)(a1 + 24));
      a1 += 32;
      --v3;
    }
    while (v3);
  }
  return v3;
}

int8x8_t BOMSwapMachHeader(uint64_t a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
      *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
      int8x8_t result = vrev32_s8(*(int8x8_t *)(a1 + 16));
      *(int8x8_t *)(a1 + 16) = result;
      *(_DWORD *)(a1 + 24) = bswap32(*(_DWORD *)(a1 + 24));
    }
  }
  return result;
}

int8x16_t BOMSwapMachHeader64(int8x16_t *a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
      int8x16_t result = vrev32q_s8(*a1);
      int8x16_t v3 = vrev32q_s8(a1[1]);
      *a1 = result;
      a1[1] = v3;
    }
  }
  return result;
}

void *BOMBufferAllocate(size_t a1)
{
  uint64_t v2 = BOM_malloczero(0x48uLL);
  int8x16_t v3 = malloc_type_valloc(a1, 0x2E5E8A86uLL);
  v2[3] = v3;
  *uint64_t v2 = a1;
  if (!v3)
  {
    free(v2);
    return 0;
  }
  return v2;
}

void BOMBufferDeallocate(void **a1)
{
  if (a1)
  {
    free(a1[3]);
    a1[8] = 0;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }
}

void *BOMBufferPoolAllocate(size_t a1, unint64_t a2)
{
  uint64_t v4 = BOM_malloczero(0xA0uLL);
  if (pthread_cond_init((pthread_cond_t *)v4 + 1, 0)) {
    goto LABEL_4;
  }
  if (pthread_mutex_init((pthread_mutex_t *)(v4 + 12), 0))
  {
    pthread_cond_destroy((pthread_cond_t *)v4 + 1);
LABEL_4:
    free(v4);
    return 0;
  }
  *uint64_t v4 = 0;
  v4[1] = 0;
  v4[2] = a2;
  v4[3] = a1;
  v4[4] = 0;
  v4[5] = v4 + 4;
  if (a2 >= 0x40) {
    a2 = 64;
  }
  if (a2)
  {
    while (1)
    {
      unint64_t v6 = BOMBufferAllocate(a1);
      if (!v6) {
        break;
      }
      --v4[2];
      BOMBufferPoolAddBuffer((uint64_t)v4, (uint64_t)v6);
      if (!--a2) {
        return v4;
      }
    }
    BOMBufferPoolDeallocate((uint64_t)v4);
    return 0;
  }
  return v4;
}

void BOMBufferPoolDeallocate(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 96);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 96)) && !pthread_mutex_unlock(v2))
    {
      pthread_cond_destroy((pthread_cond_t *)(a1 + 48));
      pthread_mutex_destroy(v2);
      while (1)
      {
        uint64_t v3 = *(void *)(a1 + 32);
        if (!v3) {
          break;
        }
        uint64_t v4 = *(void *)(v3 + 56);
        uint64_t v5 = *(void **)(v3 + 64);
        if (v4)
        {
          *(void *)(v4 + 64) = v5;
          uint64_t v5 = *(void **)(v3 + 64);
        }
        else
        {
          *(void *)(a1 + 40) = v5;
        }
        void *v5 = v4;
        BOMBufferDeallocate((void **)v3);
      }
      *(void *)(a1 + 64) = 0;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)a1 = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      free((void *)a1);
    }
  }
}

uint64_t BOMBufferPoolAddBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 96);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!result)
  {
    unint64_t v6 = (void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 32);
    *(void *)(a2 + 56) = v7;
    if (v7) {
      BOOL v8 = (void *)(v7 + 64);
    }
    else {
      BOOL v8 = (void *)(a1 + 40);
    }
    *BOOL v8 = a2 + 56;
    void *v6 = a2;
    *(void *)(a2 + 64) = v6;
    *(int64x2_t *)a1 = vaddq_s64(*(int64x2_t *)a1, vdupq_n_s64(1uLL));
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  }
  return result;
}

void *BOMBufferPoolRequestBuffer(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 96);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 96))) {
    return 0;
  }
  while (1)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    if (v5) {
      break;
    }
    uint64_t v6 = *(void *)(a1 + 16);
    if (v6)
    {
      *(void *)(a1 + 16) = v6 - 1;
      ++*(void *)a1;
      pthread_mutex_unlock(v2);
      uint64_t v7 = BOMBufferAllocate(*(void *)(a1 + 24));
      if (v7) {
        return v7;
      }
      if (pthread_mutex_lock(v2)) {
        return 0;
      }
      ++*(void *)(a1 + 16);
      --*(void *)a1;
    }
    else if (pthread_cond_wait((pthread_cond_t *)(a1 + 48), v2))
    {
      return 0;
    }
  }
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(v3 + 56);
  uint64_t v9 = *(void **)(v3 + 64);
  if (v8)
  {
    *(void *)(v8 + 64) = v9;
    uint64_t v9 = *(void **)(v3 + 64);
  }
  else
  {
    *(void *)(a1 + 40) = v9;
  }
  *uint64_t v9 = v8;
  *(void *)(a1 + 8) = v5 - 1;
  pthread_mutex_unlock(v2);
  pthread_cond_signal((pthread_cond_t *)(a1 + 48));
  return (void *)v3;
}

uint64_t BOMBufferPoolReturnBuffer(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 96);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
  if (!result)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v6 = a1 + 32;
    *(void *)(a2 + 56) = v7;
    uint64_t v8 = (void *)(v7 + 64);
    if (v7) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = (void *)(v6 + 8);
    }
    *uint64_t v9 = a2 + 56;
    *(void *)uint64_t v6 = a2;
    *(void *)(a2 + 64) = v6;
    ++*(void *)(v6 - 24);
    pthread_mutex_unlock(v4);
    return pthread_cond_signal((pthread_cond_t *)(v6 + 16));
  }
  return result;
}

char *BOMBufferFIFOCreate()
{
  uint64_t v0 = (char *)BOM_malloczero(0x88uLL);
  if (!pthread_cond_init((pthread_cond_t *)(v0 + 24), 0))
  {
    if (!pthread_mutex_init((pthread_mutex_t *)(v0 + 72), 0))
    {
      *(void *)uint64_t v0 = 0;
      *((void *)v0 + 1) = 0;
      *((void *)v0 + 2) = v0 + 8;
      return v0;
    }
    pthread_cond_destroy((pthread_cond_t *)(v0 + 24));
  }
  free(v0);
  return 0;
}

void BOMBufferFIFODestroy(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 72);
    if (!pthread_mutex_lock((pthread_mutex_t *)(a1 + 72)))
    {
      if (*(void *)a1)
      {
        uint64_t v3 = BOMExceptionHandlerMessage("Attempting to destroy a non-empty FIFO!");
        uint64_t v4 = __error();
        _BOMFatalException((uint64_t)v3, "/Library/Caches/com.apple.xbs/Sources/Bom/Common/BOMBufferManager.c", 308, *v4);
      }
      if (!pthread_mutex_unlock(v2))
      {
        pthread_cond_destroy((pthread_cond_t *)(a1 + 24));
        pthread_mutex_destroy(v2);
        free((void *)a1);
      }
    }
  }
}

uint64_t BOMBufferFIFOEnqueue(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 72);
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  if (!result)
  {
    *(void *)(a2 + 56) = 0;
    uint64_t v6 = *(void **)(a1 + 16);
    *(void *)(a2 + 64) = v6;
    void *v6 = a2;
    *(void *)(a1 + 16) = a2 + 56;
    ++*(void *)a1;
    pthread_mutex_unlock(v4);
    return pthread_cond_broadcast((pthread_cond_t *)(a1 + 24));
  }
  return result;
}

uint64_t BOMBufferFIFODequeue(uint64_t *a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9))) {
    return 0;
  }
  while (1)
  {
    uint64_t v3 = *a1;
    if (*a1) {
      break;
    }
    if (pthread_cond_wait((pthread_cond_t *)(a1 + 3), v2)) {
      return 0;
    }
  }
  uint64_t v4 = a1[1];
  uint64_t v6 = *(void *)(v4 + 56);
  uint64_t v7 = *(void **)(v4 + 64);
  if (v6)
  {
    *(void *)(v6 + 64) = v7;
    uint64_t v7 = *(void **)(v4 + 64);
  }
  else
  {
    a1[2] = (uint64_t)v7;
  }
  *uint64_t v7 = v6;
  uint64_t v8 = v3 - 1;
  *a1 = v3 - 1;
  pthread_mutex_unlock(v2);
  uint64_t v9 = (pthread_cond_t *)(a1 + 3);
  if (v8) {
    pthread_cond_signal(v9);
  }
  else {
    pthread_cond_broadcast(v9);
  }
  return v4;
}

uint64_t BOMBufferFIFOCount(uint64_t *a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9);
  if (pthread_mutex_lock((pthread_mutex_t *)(a1 + 9))) {
    return 0;
  }
  uint64_t v3 = *a1;
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t BomSys_init(void *a1, uint64_t a2)
{
  return BomSys_clone(a1, &gDefaultSys, a2);
}

uint64_t BomSys_clone(void *a1, const void *a2, uint64_t a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = BOM_malloc(0x160uLL);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = v6;
  memcpy(v6, a2, 0x160uLL);
  uint64_t result = 0;
  v7[1] = a3;
  *a1 = v7;
  return result;
}

void BomSys_free(void *a1)
{
  if (a1)
  {
    if (a1 != &gDefaultSys) {
      free(a1);
    }
  }
}

uint64_t BomSys_set_open(uint64_t result, uint64_t (*a2)(int a1, char *a2, int a3, unsigned int a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_open;
    }
    *(void *)(result + 16) = v2;
  }
  return result;
}

uint64_t BomSys_open(int a1, char *a2, int a3, unsigned int a4)
{
  return open(a2, a3, a4);
}

uint64_t BomSys_set_close(uint64_t result, uint64_t (*a2)(int a1, int a2))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_close;
    }
    *(void *)(result + 32) = v2;
  }
  return result;
}

uint64_t BomSys_close(int a1, int a2)
{
  return close(a2);
}

uint64_t BomSys_set_read(uint64_t result, ssize_t (*a2)(int a1, int a2, void *a3, size_t a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_read;
    }
    *(void *)(result + 48) = v2;
  }
  return result;
}

ssize_t BomSys_read(int a1, int a2, void *a3, size_t a4)
{
  return read(a2, a3, a4);
}

uint64_t BomSys_set_lchown(uint64_t result, uint64_t (*a2)(int a1, char *a2, uid_t a3, gid_t a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_lchown;
    }
    *(void *)(result + 192) = v2;
  }
  return result;
}

uint64_t BomSys_lchown(int a1, char *a2, uid_t a3, gid_t a4)
{
  return lchown(a2, a3, a4);
}

uint64_t BomSys_set_chmod(uint64_t result, uint64_t (*a2)(int a1, char *a2, mode_t a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_chmod;
    }
    *(void *)(result + 200) = v2;
  }
  return result;
}

uint64_t BomSys_chmod(int a1, char *a2, mode_t a3)
{
  return chmod(a2, a3);
}

uint64_t BomSys_set_symlink(uint64_t result, uint64_t (*a2)(int a1, char *a2, char *a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_symlink;
    }
    *(void *)(result + 248) = v2;
  }
  return result;
}

uint64_t BomSys_symlink(int a1, char *a2, char *a3)
{
  return symlink(a2, a3);
}

uint64_t BomSys_set_opendir(uint64_t result, DIR *(*a2)(int a1, char *a2))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_opendir;
    }
    *(void *)(result + 272) = v2;
  }
  return result;
}

DIR *BomSys_opendir(int a1, char *a2)
{
  return opendir(a2);
}

uint64_t BomSys_set_closedir(uint64_t result, uint64_t (*a2)(int a1, DIR *a2))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_closedir;
    }
    *(void *)(result + 280) = v2;
  }
  return result;
}

uint64_t BomSys_closedir(int a1, DIR *a2)
{
  return closedir(a2);
}

uint64_t BomSys_set_readdir(uint64_t result, dirent *(*a2)(int a1, DIR *a2))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_readdir;
    }
    *(void *)(result + 288) = v2;
  }
  return result;
}

dirent *BomSys_readdir(int a1, DIR *a2)
{
  return readdir(a2);
}

uint64_t BomSys_set_readdir_r(uint64_t result, uint64_t (*a2)(int a1, DIR *a2, dirent *a3, dirent **a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_readdir_r;
    }
    *(void *)(result + 296) = v2;
  }
  return result;
}

uint64_t BomSys_readdir_r(int a1, DIR *a2, dirent *a3, dirent **a4)
{
  return readdir_r(a2, a3, a4);
}

uint64_t BomSys_set_copyfile(uint64_t result, uint64_t (*a2)(int a1, char *from, char *to, copyfile_state_t state, copyfile_flags_t flags))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_copyfile;
    }
    *(void *)(result + 344) = v2;
  }
  return result;
}

uint64_t BomSys_copyfile(int a1, char *from, char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return copyfile(from, to, state, flags);
}

uint64_t BomSys_set_access(uint64_t result, uint64_t (*a2)(int a1, char *a2, int a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_access;
    }
    *(void *)(result + 184) = v2;
  }
  return result;
}

uint64_t BomSys_access(int a1, char *a2, int a3)
{
  return access(a2, a3);
}

uint64_t BomSys_set_fstat(uint64_t result, uint64_t (*a2)(int a1, int a2, stat *a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_fstat;
    }
    *(void *)(result + 88) = v2;
  }
  return result;
}

uint64_t BomSys_fstat(int a1, int a2, stat *a3)
{
  return fstat(a2, a3);
}

uint64_t BomSys_set_lseek(uint64_t result, off_t (*a2)(int a1, int a2, off_t a3, int a4))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_lseek;
    }
    *(void *)(result + 64) = v2;
  }
  return result;
}

off_t BomSys_lseek(int a1, int a2, off_t a3, int a4)
{
  return lseek(a2, a3, a4);
}

uint64_t BomSys_set_mmap(uint64_t result, void *(*a2)(int a1, void *a2, size_t a3, int a4, int a5, int a6, off_t a7))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_mmap;
    }
    *(void *)(result + 320) = v2;
  }
  return result;
}

void *BomSys_mmap(int a1, void *a2, size_t a3, int a4, int a5, int a6, off_t a7)
{
  return mmap(a2, a3, a4, a5, a6, a7);
}

uint64_t BomSys_set_munmap(uint64_t result, uint64_t (*a2)(int a1, void *a2, size_t a3))
{
  if (result && (_UNKNOWN *)result != &gDefaultSys && !*(void *)result)
  {
    if (a2) {
      uint64_t v2 = a2;
    }
    else {
      uint64_t v2 = BomSys_munmap;
    }
    *(void *)(result + 328) = v2;
  }
  return result;
}

uint64_t BomSys_munmap(int a1, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

void *BomSys_default()
{
  return &gDefaultSys;
}

uint64_t BomSys_openFor(int a1, char *a2, int a3, unsigned int a4)
{
  return open(a2, a3, a4);
}

uint64_t BomSys_fcntl(int a1, int a2, int a3, uint64_t a4)
{
  return fcntl(a2, a3, a4);
}

ssize_t BomSys_write(int a1, int __fd, void *__buf, size_t __nbyte)
{
  return write(__fd, __buf, __nbyte);
}

uint64_t BomSys_fsync(int a1, int a2)
{
  return fsync(a2);
}

uint64_t BomSys_stat(int a1, char *a2, stat *a3)
{
  return stat(a2, a3);
}

uint64_t BomSys_lstat(int a1, char *a2, stat *a3)
{
  return lstat(a2, a3);
}

uint64_t BomSys_statfs(int a1, char *a2, statfs *a3)
{
  return statfs(a2, a3);
}

uint64_t BomSys_fstatfs(int a1, int a2, statfs *a3)
{
  return fstatfs(a2, a3);
}

uint64_t BomSys_getattrlist(int a1, char *a2, void *a3, void *a4, size_t a5, unsigned int a6)
{
  return getattrlist(a2, a3, a4, a5, a6);
}

ssize_t BomSys_getxattr(int a1, char *path, char *name, void *value, size_t size, u_int32_t position, int options)
{
  return getxattr(path, name, value, size, position, options);
}

uint64_t BomSys_setxattr(int a1, char *path, char *name, void *value, size_t size, u_int32_t position, int options)
{
  return setxattr(path, name, value, size, position, options);
}

ssize_t BomSys_listxattr(int a1, char *path, char *namebuff, size_t size, int options)
{
  return listxattr(path, namebuff, size, options);
}

uint64_t BomSys_removexattr(int a1, char *path, char *name, int options)
{
  return removexattr(path, name, options);
}

char *BomSys_realpath(int a1, char *a2, char *a3)
{
  return realpath_DARWIN_EXTSN(a2, a3);
}

uint64_t BomSys_mkdir(int a1, char *a2, mode_t a3)
{
  return mkdir(a2, a3);
}

uint64_t BomSys_mknod(int a1, char *a2, mode_t a3, dev_t a4)
{
  return mknod(a2, a3, a4);
}

uint64_t BomSys_chflags(int a1, char *a2, __uint32_t a3)
{
  return chflags(a2, a3);
}

uint64_t BomSys_utimes(int a1, char *a2, timeval *a3)
{
  return utimes(a2, a3);
}

uint64_t BomSys_unlink(int a1, char *a2)
{
  return unlink(a2);
}

uint64_t BomSys_rmdir(int a1, char *a2)
{
  return rmdir(a2);
}

uint64_t BomSys_link(int a1, char *a2, char *a3)
{
  return link(a2, a3);
}

ssize_t BomSys_readlink(int a1, char *a2, char *a3, size_t a4)
{
  return readlink(a2, a3, a4);
}

void BomSys_rename(int a1, std::__fs::filesystem::path *__from, std::__fs::filesystem::path *__to)
{
}

char *BomSys_getcwd(int a1, char *a2, size_t a3)
{
  return getcwd(a2, a3);
}

uint64_t BomSys_chdir(int a1, char *a2)
{
  return chdir(a2);
}

char *BomSys_mktemp(int a1, char *a2)
{
  return mktemp(a2);
}

uint64_t BomSys_log_attached(uint64_t result)
{
  if (result)
  {
    if (*(void *)result) {
      return *(void *)(*(void *)result + 352);
    }
    else {
      return 0;
    }
  }
  return result;
}

void *BomSys_log_attach(void **a1, int a2, int a3, uint64_t a4, char a5)
{
  uint64_t v9 = a1;
  if (!a1) {
    uint64_t v9 = (void **)BomSys_default();
  }
  BOOL v10 = *v9;
  if (!*v9) {
    BOOL v10 = BOM_malloczero(0x1A8uLL);
  }
  memcpy(v10, &gLogSysSTDIO, 0x160uLL);
  *BOOL v10 = v10;
  v10[1] = v10;
  v10[44] = v9;
  v10[45] = a4;
  *((unsigned char *)v10 + 368) = a5;
  *((_DWORD *)v10 + 93) = a3;
  if ((a3 & 0x100) != 0)
  {
    *((unsigned char *)v10 + 394) = a2;
    if ((a3 & 0x10000) == 0)
    {
LABEL_7:
      if ((a3 & 0x2000) == 0) {
        goto LABEL_8;
      }
      goto LABEL_18;
    }
  }
  else if ((a3 & 0x10000) == 0)
  {
    goto LABEL_7;
  }
  *((_DWORD *)v10 + 95) = 16843009 * a2;
  if ((a3 & 0x2000) == 0)
  {
LABEL_8:
    if ((a3 & 0x8000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_19;
  }
LABEL_18:
  *((unsigned char *)v10 + 388) = a2;
  *((_DWORD *)v10 + 96) = 16843009 * a2;
  if ((a3 & 0x8000) == 0)
  {
LABEL_9:
    if ((a3 & 0x200) == 0) {
      goto LABEL_10;
    }
    goto LABEL_20;
  }
LABEL_19:
  *((unsigned char *)v10 + 393) = a2;
  *(_DWORD *)((char *)v10 + 389) = 16843009 * a2;
  if ((a3 & 0x200) == 0)
  {
LABEL_10:
    if ((a3 & 0x400) == 0) {
      goto LABEL_11;
    }
    goto LABEL_21;
  }
LABEL_20:
  *((unsigned char *)v10 + 402) = a2;
  *((unsigned char *)v10 + 407) = a2;
  *((_DWORD *)v10 + 94) = 16843009 * a2;
  if ((a3 & 0x400) == 0)
  {
LABEL_11:
    if ((a3 & 0x1000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_22;
  }
LABEL_21:
  *((unsigned char *)v10 + 395) = a2;
  *((unsigned char *)v10 + 403) = a2;
  *((_DWORD *)v10 + 102) = 16843009 * a2;
  *((_WORD *)v10 + 206) = 257 * a2;
  if ((a3 & 0x1000) == 0)
  {
LABEL_12:
    if ((a3 & 0x800) == 0) {
      goto LABEL_13;
    }
LABEL_23:
    *((unsigned char *)v10 + 404) = a2;
    *((unsigned char *)v10 + 405) = a2;
    *((unsigned char *)v10 + 406) = a2;
    if ((a3 & 0x4000) == 0) {
      return v10;
    }
    goto LABEL_14;
  }
LABEL_22:
  *((unsigned char *)v10 + 396) = a2;
  if ((a3 & 0x800) != 0) {
    goto LABEL_23;
  }
LABEL_13:
  if ((a3 & 0x4000) != 0)
  {
LABEL_14:
    *((unsigned char *)v10 + 401) = a2;
    *(_DWORD *)((char *)v10 + 397) = 16843009 * a2;
  }
  return v10;
}

uint64_t BomSys_log_detach(void **a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *a1;
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1[44];
  free(v1);
  return v2;
}

uint64_t BomSys_log_config(uint64_t result, char *__s2, char a3)
{
  if (result)
  {
    if (__s2)
    {
      uint64_t v4 = *(unsigned char **)result;
      if (*(void *)result)
      {
        uint64_t result = strcmp("realpath", __s2);
        if (result)
        {
          uint64_t result = strcmp("mkdir", __s2);
          if (result)
          {
            uint64_t result = strcmp("read", __s2);
            if (result)
            {
              uint64_t result = strcmp("write", __s2);
              if (result)
              {
                uint64_t result = strcmp("lseek", __s2);
                if (result)
                {
                  uint64_t result = strcmp("fsync", __s2);
                  if (result)
                  {
                    uint64_t result = strcmp("stat", __s2);
                    if (result)
                    {
                      uint64_t result = strcmp("fstat", __s2);
                      if (result)
                      {
                        uint64_t result = strcmp("lstat", __s2);
                        if (result)
                        {
                          uint64_t result = strcmp("statfs", __s2);
                          if (result)
                          {
                            uint64_t result = strcmp("fstatfs", __s2);
                            if (result)
                            {
                              uint64_t result = strcmp("getattrlist", __s2);
                              if (result)
                              {
                                uint64_t result = strcmp("getxattr", __s2);
                                if (result)
                                {
                                  uint64_t result = strcmp("setxattr", __s2);
                                  if (result)
                                  {
                                    uint64_t result = strcmp("listxattr", __s2);
                                    if (result)
                                    {
                                      uint64_t result = strcmp("removexattr", __s2);
                                      if (result)
                                      {
                                        uint64_t result = strcmp("open", __s2);
                                        if (result)
                                        {
                                          uint64_t result = strcmp("openFor", __s2);
                                          if (result)
                                          {
                                            uint64_t result = strcmp("close", __s2);
                                            if (result)
                                            {
                                              uint64_t result = strcmp("fcntl", __s2);
                                              if (result)
                                              {
                                                uint64_t result = strcmp("unlink", __s2);
                                                if (result)
                                                {
                                                  uint64_t result = strcmp("rename", __s2);
                                                  if (result)
                                                  {
                                                    uint64_t result = strcmp("opendir", __s2);
                                                    if (result)
                                                    {
                                                      uint64_t result = strcmp("closedir", __s2);
                                                      if (result)
                                                      {
                                                        uint64_t result = strcmp("readdir", __s2);
                                                        if (result)
                                                        {
                                                          uint64_t result = strcmp("readdir_r", __s2);
                                                          if (result)
                                                          {
                                                            uint64_t result = strcmp("getcwd", __s2);
                                                            if (result)
                                                            {
                                                              uint64_t result = strcmp("chdir", __s2);
                                                              if (result)
                                                              {
                                                                uint64_t result = strcmp("rmdir", __s2);
                                                                if (result)
                                                                {
                                                                  uint64_t result = strcmp("mknod", __s2);
                                                                  if (result)
                                                                  {
                                                                    uint64_t result = strcmp("link", __s2);
                                                                    if (result)
                                                                    {
                                                                      uint64_t result = strcmp("symlink", __s2);
                                                                      if (result)
                                                                      {
                                                                        uint64_t result = strcmp("readlink", __s2);
                                                                        if (result)
                                                                        {
                                                                          uint64_t result = strcmp("access", __s2);
                                                                          if (result)
                                                                          {
                                                                            uint64_t result = strcmp("lchown", __s2);
                                                                            if (result)
                                                                            {
                                                                              uint64_t result = strcmp("chmod", __s2);
                                                                              if (result)
                                                                              {
                                                                                uint64_t result = strcmp("chflags", __s2);
                                                                                if (result)
                                                                                {
                                                                                  uint64_t result = strcmp("utimes", __s2);
                                                                                  if (result)
                                                                                  {
                                                                                    uint64_t result = strcmp("mmap", __s2);
                                                                                    if (result)
                                                                                    {
                                                                                      uint64_t result = strcmp("munmap", __s2);
                                                                                      if (result)
                                                                                      {
                                                                                        uint64_t result = strcmp("mktemp", __s2);
                                                                                        if (!result) {
                                                                                          v4[416] = a3;
                                                                                        }
                                                                                      }
                                                                                      else
                                                                                      {
                                                                                        v4[415] = a3;
                                                                                      }
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                      v4[414] = a3;
                                                                                    }
                                                                                  }
                                                                                  else
                                                                                  {
                                                                                    v4[401] = a3;
                                                                                  }
                                                                                }
                                                                                else
                                                                                {
                                                                                  v4[400] = a3;
                                                                                }
                                                                              }
                                                                              else
                                                                              {
                                                                                v4[399] = a3;
                                                                              }
                                                                            }
                                                                            else
                                                                            {
                                                                              v4[398] = a3;
                                                                            }
                                                                          }
                                                                          else
                                                                          {
                                                                            v4[397] = a3;
                                                                          }
                                                                        }
                                                                        else
                                                                        {
                                                                          v4[406] = a3;
                                                                        }
                                                                      }
                                                                      else
                                                                      {
                                                                        v4[405] = a3;
                                                                      }
                                                                    }
                                                                    else
                                                                    {
                                                                      v4[404] = a3;
                                                                    }
                                                                  }
                                                                  else
                                                                  {
                                                                    v4[396] = a3;
                                                                  }
                                                                }
                                                                else
                                                                {
                                                                  v4[403] = a3;
                                                                }
                                                              }
                                                              else
                                                              {
                                                                v4[413] = a3;
                                                              }
                                                            }
                                                            else
                                                            {
                                                              v4[412] = a3;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            v4[411] = a3;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          v4[410] = a3;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        v4[409] = a3;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v4[408] = a3;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    v4[407] = a3;
                                                  }
                                                }
                                                else
                                                {
                                                  v4[402] = a3;
                                                }
                                              }
                                              else
                                              {
                                                v4[379] = a3;
                                              }
                                            }
                                            else
                                            {
                                              v4[378] = a3;
                                            }
                                          }
                                          else
                                          {
                                            v4[377] = a3;
                                          }
                                        }
                                        else
                                        {
                                          v4[376] = a3;
                                        }
                                      }
                                      else
                                      {
                                        v4[393] = a3;
                                      }
                                    }
                                    else
                                    {
                                      v4[392] = a3;
                                    }
                                  }
                                  else
                                  {
                                    v4[391] = a3;
                                  }
                                }
                                else
                                {
                                  v4[390] = a3;
                                }
                              }
                              else
                              {
                                v4[389] = a3;
                              }
                            }
                            else
                            {
                              v4[388] = a3;
                            }
                          }
                          else
                          {
                            v4[387] = a3;
                          }
                        }
                        else
                        {
                          v4[386] = a3;
                        }
                      }
                      else
                      {
                        v4[385] = a3;
                      }
                    }
                    else
                    {
                      v4[384] = a3;
                    }
                  }
                  else
                  {
                    v4[383] = a3;
                  }
                }
                else
                {
                  v4[382] = a3;
                }
              }
              else
              {
                v4[381] = a3;
              }
            }
            else
            {
              v4[380] = a3;
            }
          }
          else
          {
            v4[395] = a3;
          }
        }
        else
        {
          v4[394] = a3;
        }
      }
    }
  }
  return result;
}

uint64_t BomSys_log_resume(uint64_t result)
{
  if (result)
  {
    if (*(void *)result) {
      *(unsigned char *)(*(void *)result + 368) = 1;
    }
  }
  return result;
}

uint64_t BomSys_log_pause(uint64_t result)
{
  if (result)
  {
    if (*(void *)result) {
      *(unsigned char *)(*(void *)result + 368) = 0;
    }
  }
  return result;
}

uint64_t BomSysLog_open(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 16))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 376)) {
    fprintf(*(FILE **)(a1 + 360), "open(\"%s\", %d, %d) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_openFor(uint64_t a1, const char *a2, int a3, int a4, const char *a5)
{
  uint64_t v10 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 24))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 377)) {
    fprintf(*(FILE **)(a1 + 360), "openFor(\"%s\", %d, %d, \"%s\") => %d\n", a2, a3, a4, a5, v10);
  }
  return v10;
}

uint64_t BomSysLog_close(uint64_t a1, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 32))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 378)) {
    fprintf(*(FILE **)(a1 + 360), "close(%d) => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_fcntl(uint64_t a1, int a2, int a3, const void *a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 40))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 379)) {
    fprintf(*(FILE **)(a1 + 360), "fcntl(%d, %d, %p) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_read(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 48))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 380)) {
    fprintf(*(FILE **)(a1 + 360), "read(%d, %p, %zu) => %zd\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_write(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 56))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 381)) {
    fprintf(*(FILE **)(a1 + 360), "write(%d, %p, %zu) => %zd\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_lseek(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 64))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 382)) {
    fprintf(*(FILE **)(a1 + 360), "lseek(%d, %lld, %d) => %lld\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_fsync(uint64_t a1, int a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 72))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 383)) {
    fprintf(*(FILE **)(a1 + 360), "fsync(%d) => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_stat(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 80))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 384)) {
    fprintf(*(FILE **)(a1 + 360), "stat(\"%s\", %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_fstat(uint64_t a1, int a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 88))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 385)) {
    fprintf(*(FILE **)(a1 + 360), "fstat(%d, %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_lstat(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 96))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 386)) {
    fprintf(*(FILE **)(a1 + 360), "lstat(\"%s\", %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_statfs(uint64_t a1, const char *a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 104))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 387)) {
    fprintf(*(FILE **)(a1 + 360), "statfs(\"%s\", %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_fstatfs(uint64_t a1, int a2, const void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 112))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 388)) {
    fprintf(*(FILE **)(a1 + 360), "fstatfs(%d, %p) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_getattrlist(uint64_t a1, const char *a2, const void *a3, const void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 120))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 389)) {
    fprintf(*(FILE **)(a1 + 360), "getattrlist(\"%s\", %p, %p, %zu, %lu) => %d\n", a2, a3, a4, a5, a6, v12);
  }
  return v12;
}

uint64_t BomSysLog_getxattr(uint64_t a1, const char *a2, const char *a3, const void *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v14 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 128))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 390)) {
    fprintf(*(FILE **)(a1 + 360), "getxattr(\"%s\", \"%s\", %p, %zu, %u, %d) => %zd\n", a2, a3, a4, a5, a6, a7, v14);
  }
  return v14;
}

uint64_t BomSysLog_setxattr(uint64_t a1, const char *a2, const char *a3, const void *a4, uint64_t a5, int a6, int a7)
{
  uint64_t v14 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 136))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 391)) {
    fprintf(*(FILE **)(a1 + 360), "setxattr(\"%s\", \"%s\", %p, %zu, %u, %d) => %d\n", a2, a3, a4, a5, a6, a7, v14);
  }
  return v14;
}

uint64_t BomSysLog_listxattr(uint64_t a1, const char *a2, const char *a3, uint64_t a4, int a5)
{
  uint64_t v10 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 144))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 392)) {
    fprintf(*(FILE **)(a1 + 360), "listxattr(\"%s\", \"%s\", %zu, %d) => %zd\n", a2, a3, a4, a5, v10);
  }
  return v10;
}

uint64_t BomSysLog_removexattr(uint64_t a1, const char *a2, const char *a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 152))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 393)) {
    fprintf(*(FILE **)(a1 + 360), "removexattr(\"%s\", \"%s\", %d) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_realpath(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 160))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 394))
  {
    uint64_t v7 = "(null)";
    if (a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = "(null)";
    }
    if (a3) {
      uint64_t v9 = a3;
    }
    else {
      uint64_t v9 = "(null)";
    }
    if (v6) {
      uint64_t v7 = (const char *)v6;
    }
    fprintf(*(FILE **)(a1 + 360), "realpath(\"%s\", \"%s\") => \"%s\"\n", v8, v9, v7);
  }
  return v6;
}

uint64_t BomSysLog_mkdir(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 168))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 395)) {
    fprintf(*(FILE **)(a1 + 360), "mkdir(\"%s\", %d) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_mknod(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 176))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 396)) {
    fprintf(*(FILE **)(a1 + 360), "mknod(\"%s\", %d, %d) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_access(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 184))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 397)) {
    fprintf(*(FILE **)(a1 + 360), "access(\"%s\", %d) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_lchown(uint64_t a1, const char *a2, int a3, int a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 192))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 398)) {
    fprintf(*(FILE **)(a1 + 360), "chown(\"%s\", %d, %d) => %d\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_chmod(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 200))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 399)) {
    fprintf(*(FILE **)(a1 + 360), "chmod(\"%s\", %d) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_chflags(uint64_t a1, const char *a2, int a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 208))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 400)) {
    fprintf(*(FILE **)(a1 + 360), "chflags(\"%s\", %u) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_utimes(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 216))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 401)) {
    fprintf(*(FILE **)(a1 + 360), "utimes(\"%s\") => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_unlink(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 224))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 402)) {
    fprintf(*(FILE **)(a1 + 360), "unlink(\"%s\") => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_rmdir(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 232))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 403)) {
    fprintf(*(FILE **)(a1 + 360), "rmdir(\"%s\") => %d\n", a2, v4);
  }
  return v4;
}

uint64_t BomSysLog_link(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 240))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 404))
  {
    uint64_t v7 = "(null)";
    if (a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = "(null)";
    }
    if (a3) {
      uint64_t v7 = a3;
    }
    fprintf(*(FILE **)(a1 + 360), "link(\"%s\", \"%s\") => %d\n", v8, v7, v6);
  }
  return v6;
}

uint64_t BomSysLog_symlink(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 248))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 405))
  {
    uint64_t v7 = "(null)";
    if (a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = "(null)";
    }
    if (a3) {
      uint64_t v7 = a3;
    }
    fprintf(*(FILE **)(a1 + 360), "symlink(\"%s\", \"%s\") => %d\n", v8, v7, v6);
  }
  return v6;
}

uint64_t BomSysLog_readlink(uint64_t a1, const char *a2, const void *a3, uint64_t a4)
{
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 256))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 406)) {
    fprintf(*(FILE **)(a1 + 360), "readlink(\"%s\", %p, %zu) => %zd\n", a2, a3, a4, v8);
  }
  return v8;
}

uint64_t BomSysLog_rename(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 264))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 407))
  {
    uint64_t v7 = "(null)";
    if (a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = "(null)";
    }
    if (a3) {
      uint64_t v7 = a3;
    }
    fprintf(*(FILE **)(a1 + 360), "rename(\"%s\", \"%s\") => %d\n", v8, v7, v6);
  }
  return v6;
}

uint64_t BomSysLog_opendir(uint64_t a1, const char *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 272))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 408))
  {
    BomSysLog_DIR(v6, v4);
    fprintf(*(FILE **)(a1 + 360), "opendir(\"%s\") => %s\n", a2, v6);
  }
  return v4;
}

uint64_t BomSysLog_closedir(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 409)) {
    BomSysLog_DIR(v6, a2);
  }
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 352) + 280))(*(void *)(*(void *)(a1 + 352) + 8), a2);
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 409)) {
    fprintf(*(FILE **)(a1 + 360), "closedir(%s) => %d\n", v6, v4);
  }
  return v4;
}

uint64_t BomSysLog_readdir(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 288))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 410))
  {
    BomSysLog_DIR(v7, a2);
    BomSysLog_DIRENT(v6, v4);
    fprintf(*(FILE **)(a1 + 360), "readdir(%s) => %s\n", v7, v6);
  }
  return v4;
}

uint64_t BomSysLog_readdir_r(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 296))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 411))
  {
    BomSysLog_DIR(v13, a2);
    BomSysLog_DIRENT(v12, a3);
    if (a4)
    {
      uint64_t v9 = *a4;
      if (*a4 == a3)
      {
        strcpy(v11, "<same>");
LABEL_8:
        fprintf(*(FILE **)(a1 + 360), "readdir_r(%s, %s, %s) => %d\n", v13, v12, v11, v8);
        return v8;
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    BomSysLog_DIRENT(v11, v9);
    goto LABEL_8;
  }
  return v8;
}

uint64_t BomSysLog_getcwd(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 304))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 412))
  {
    uint64_t v7 = "(null)";
    if (v6) {
      uint64_t v7 = (const char *)v6;
    }
    fprintf(*(FILE **)(a1 + 360), "getcwd(%p, %zu) => \"%s\"\n", a2, a3, v7);
  }
  return v6;
}

uint64_t BomSysLog_chdir(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 312))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 413)) {
    fprintf(*(FILE **)(a1 + 360), "chdir(\"%s\") => %d\n", a2, v4);
  }
  return v4;
}

const void *BomSysLog_mmap(uint64_t a1, const void *a2, uint64_t a3, int a4, int a5, int a6, uint64_t a7)
{
  uint64_t v14 = (const void *)(*(uint64_t (**)(void))(*(void *)(a1 + 352) + 320))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 414)) {
    fprintf(*(FILE **)(a1 + 360), "mmap(%p, %zu, %d, %d, %d, %lld) => %p\n", a2, a3, a4, a5, a6, a7, v14);
  }
  return v14;
}

uint64_t BomSysLog_munmap(uint64_t a1, const void *a2, uint64_t a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 328))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 415)) {
    fprintf(*(FILE **)(a1 + 360), "munmap(%p, %zd) => %d\n", a2, a3, v6);
  }
  return v6;
}

uint64_t BomSysLog_mktemp(uint64_t a1, const char *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 336))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 416))
  {
    uint64_t v5 = "(null)";
    if (a2) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = "(null)";
    }
    if (v4) {
      uint64_t v5 = (const char *)v4;
    }
    fprintf(*(FILE **)(a1 + 360), "mktemp(\"%s\") => \"%s\"\n", v6, v5);
  }
  return v4;
}

uint64_t BomSysLog_copyfile(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 352) + 344))(*(void *)(*(void *)(a1 + 352) + 8));
  if (*(unsigned char *)(a1 + 368) && *(unsigned char *)(a1 + 417)) {
    fprintf(*(FILE **)(a1 + 360), "copyfile(\"%s\", \"%s\")\n", a2, a3);
  }
  return v6;
}

uint64_t BomSysLog_DIR(char *a1, uint64_t a2)
{
  if (a2) {
    return snprintf(a1, 0x40uLL, "%p {%d}");
  }
  else {
    return snprintf(a1, 0x40uLL, "%p");
  }
}

uint64_t BomSysLog_DIRENT(char *a1, uint64_t a2)
{
  if (a2) {
    return snprintf(a1, 0x440uLL, "%p {%llu, %d, \"%s\"}");
  }
  else {
    return snprintf(a1, 0x440uLL, "%p");
  }
}

void BOMCopierErrorFree(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void *)a1[4];
    if (v2) {
      free(v2);
    }
    free(a1);
  }
}

uint64_t BOMCopierErrorGetFileName(uint64_t result)
{
  if (result) {
    return *(void *)result;
  }
  return result;
}

uint64_t BOMCopierErrorGetLineNumber(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 8);
  }
  return result;
}

uint64_t BOMCopierErrorGetCompilationDate(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t BOMCopierErrorGetFunctionName(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t BOMCopierErrorGetMessage(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

uint64_t BOMCopierErrorGetCode(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 40);
  }
  return result;
}

void *BOMCopierErrorCapture(void *result, int a2, uint64_t a3, int a4, uint64_t a5, char *a6, ...)
{
  va_start(va, a6);
  v17[0] = 0;
  if (result)
  {
    uint64_t v6 = result;
    if (!*result)
    {
      va_copy((va_list)&v17[1], va);
      if (vasprintf(v17, a6, va) < 0)
      {
        uint64_t v11 = (FILE *)*MEMORY[0x263EF8348];
        uint64_t v12 = __error();
        uint64_t v13 = strerror(*v12);
        return (void *)fprintf(v11, "Could not create error message: %s\n", v13);
      }
      else
      {
        if (v17[0])
        {
          uint64_t result = malloc_type_calloc(1uLL, 0x30uLL, 0x105004057D267B0uLL);
          if (result)
          {
            *uint64_t result = a3;
            *((_DWORD *)result + 2) = a4;
            result[2] = "Nov 10 2024";
            result[3] = a5;
            result[4] = v17[0];
            *((_DWORD *)result + 10) = a2;
            void *v6 = result;
            return result;
          }
          uint64_t v14 = (FILE *)*MEMORY[0x263EF8348];
          unsigned int v15 = "Could not allocate empty _BOMCopierError\n";
          size_t v16 = 41;
        }
        else
        {
          uint64_t v14 = (FILE *)*MEMORY[0x263EF8348];
          unsigned int v15 = "Error message is NULL\n";
          size_t v16 = 22;
        }
        return (void *)fwrite(v15, v16, 1uLL, v14);
      }
    }
  }
  return result;
}

uint64_t BOMCopierCopyWithOptions2(uint64_t a1, char *a2, char *a3, const void *a4)
{
  uint64_t v117 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 22;
  }
  uint64_t v9 = (unsigned char *)(a1 + 11616);
  uint64_t v109 = 0;
  if (os_variant_has_internal_content())
  {
    getenv("BOMCOPIER_LOGGING");
    goto LABEL_4;
  }
  int v15 = v9[1442];
  size_t v16 = getenv("BOMCOPIER_LOGGING");
  if (v16)
  {
    int v17 = strcmp(v16, "1");
    if (!v15 && v17) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (v15) {
LABEL_4:
  }
    *(void *)(a1 + 13000) = os_log_create("com.apple.Bom", "BOMCopier");
LABEL_5:
  uint64_t v10 = *(NSObject **)(a1 + 13000);
  if (v10)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)
      || (*(_DWORD *)statfs buf = 136315138,
          *(void *)&uint8_t buf[4] = a2,
          _os_log_impl(&dword_2105F8000, v10, OS_LOG_TYPE_DEFAULT, "fromObj: %s", buf, 0xCu),
          (uint64_t v10 = *(NSObject **)(a1 + 13000)) != 0))
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)statfs buf = 136315138;
        *(void *)&uint8_t buf[4] = a3;
        _os_log_impl(&dword_2105F8000, v10, OS_LOG_TYPE_DEFAULT, "toObj: %s", buf, 0xCu);
      }
    }
  }
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  *(void *)(a1 + 13008) = Mutable;
  if (!Mutable)
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 720, (uint64_t)"prepare_copy_state", "Could not create source options");
    goto LABEL_225;
  }
  CFMutableDictionaryRef v13 = CFDictionaryCreateMutable(v11, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  *(void *)(a1 + 13024) = v13;
  if (!v13)
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 727, (uint64_t)"prepare_copy_state", "Could not create destination options");
    goto LABEL_225;
  }
  if (!a4) {
    goto LABEL_85;
  }
  CFTypeID TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(a4))
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 735, (uint64_t)"prepare_copy_state", "The options dictionary is not a CFDictionary");
    goto LABEL_225;
  }
  if (parse_copier_options(a1, (const __CFDictionary *)a4, &v109))
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 742, (uint64_t)"prepare_copy_state", "Could not create parse copier options");
LABEL_225:
    uint64_t v4 = 1;
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 188, (uint64_t)"BOMCopierCopyWithOptions2", "Could not parse the client options", v104);
    goto LABEL_226;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"compressCPIO")
    && *(_DWORD *)(a1 + 12712) != 1
    && *(_DWORD *)(a1 + 12716) != 4)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3560, (uint64_t)"verify_copier_options", "Compression is only used for CPIO archives");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"skipCPIOTerminator") && *(_DWORD *)(a1 + 12716) != 4)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3569, (uint64_t)"verify_copier_options", "SkipTerminator is only used for CPIO archives");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"skipCPIORoot") && *(_DWORD *)(a1 + 12716) != 4)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3578, (uint64_t)"verify_copier_options", "SkipRoot is only used for CPIO archives");
    goto LABEL_224;
  }
  if (*(_DWORD *)(a1 + 12712) == 2 && *(_DWORD *)(a1 + 12716) != 3)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3589, (uint64_t)"verify_copier_options", "PKZip archives can only be extracted to filesystem destinations");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"sequesterResources")
    && *(_DWORD *)(a1 + 12716) != 5
    && *(_DWORD *)(a1 + 12712) != 2)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3597, (uint64_t)"verify_copier_options", "sequesterResources is only for PKZip archives");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"keepParent") && *(_DWORD *)(a1 + 12716) == 3)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3610, (uint64_t)"verify_copier_options", "keepParent is only for archives");
    goto LABEL_224;
  }
  int v18 = CFDictionaryContainsKey((CFDictionaryRef)a4, @"inputFD");
  if (a2 && v18)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3623, (uint64_t)"verify_copier_options", "Cannot specify a fromObj with kBOMCopierOptionInputFileDescriptorKey");
    goto LABEL_224;
  }
  int v19 = CFDictionaryContainsKey((CFDictionaryRef)a4, @"outputFD");
  if (a3 && v19)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3632, (uint64_t)"verify_copier_options", "Cannot specify a toObj with kBOMCopierOptionOutputFileDescriptorKey");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"inputStream"))
  {
    if (a2 || CFDictionaryContainsKey((CFDictionaryRef)a4, @"inputFD"))
    {
      BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3645, (uint64_t)"verify_copier_options", "Cannot specify fromObj or kBOMCopierOptionInputFileDescriptorKey with kBOMCopierOptionInputCFReadStreamKey");
      goto LABEL_224;
    }
    CFArrayRef Value = (__CFReadStream *)CFDictionaryGetValue((CFDictionaryRef)a4, @"inputStream");
    int v21 = 30;
    uint64_t v4 = (uint64_t)&xmmword_210662D70;
    while (1)
    {
      CFStreamStatus Status = CFReadStreamGetStatus(Value);
      if (Status != kCFStreamStatusOpening) {
        break;
      }
      if (!v21)
      {
        BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3669, (uint64_t)"verify_copier_options", "Timed out waiting for the read stream to open");
        goto LABEL_224;
      }
      *(_OWORD *)statfs buf = xmmword_210662D70;
      nanosleep((const timespec *)buf, 0);
      --v21;
    }
    if (Status != kCFStreamStatusOpen)
    {
      BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3685, (uint64_t)"verify_copier_options", "CFReadStream is not open: %u");
      goto LABEL_224;
    }
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"outputStream"))
  {
    if (a3 || CFDictionaryContainsKey((CFDictionaryRef)a4, @"outputFD"))
    {
      BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3694, (uint64_t)"verify_copier_options", "Cannot specify toObj or kBOMCopierOptionOutputFileDescriptorKey with kBOMCopierOptionOutputCFWriteStreamKey");
      goto LABEL_224;
    }
    long long v23 = (__CFWriteStream *)CFDictionaryGetValue((CFDictionaryRef)a4, @"outputStream");
    int v24 = 30;
    uint64_t v4 = (uint64_t)&xmmword_210662D70;
    while (1)
    {
      CFStreamStatus v25 = CFWriteStreamGetStatus(v23);
      if (v25 != kCFStreamStatusOpening) {
        break;
      }
      if (!v24)
      {
        BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3718, (uint64_t)"verify_copier_options", "Timed out waiting for the write stream to open");
        goto LABEL_224;
      }
      *(_OWORD *)statfs buf = xmmword_210662D70;
      nanosleep((const timespec *)buf, 0);
      --v24;
    }
    if (v25 != kCFStreamStatusOpen)
    {
      BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3734, (uint64_t)"verify_copier_options", "CFWriteStream is not open: %u");
      goto LABEL_224;
    }
  }
  int v26 = CFDictionaryContainsKey((CFDictionaryRef)a4, @"output2Nowhere");
  if (a3 && v26)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3743, (uint64_t)"verify_copier_options", "Cannot specify a toObj with kBOMCopierOptionOutputNowhereKey");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"setStaticContent") && *(_DWORD *)(a1 + 12716) != 3)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3756, (uint64_t)"verify_copier_options", "setStaticContent is only for filesystem destinations");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"setSingleWriter") && *(_DWORD *)(a1 + 12716) != 3)
  {
    BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3765, (uint64_t)"verify_copier_options", "setSingleWriter is only for filesystem destinations");
    goto LABEL_224;
  }
  if (CFDictionaryContainsKey((CFDictionaryRef)a4, @"applyProvenance"))
  {
    if (*(_DWORD *)(a1 + 12712))
    {
      if (*(_DWORD *)(a1 + 12716) == 3) {
        goto LABEL_82;
      }
      BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3780, (uint64_t)"verify_copier_options", "applyProvenance is only applicable when extracting from archives");
    }
    else
    {
      BOMCopierErrorCapture(&v109, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3774, (uint64_t)"verify_copier_options", "applyProvenance is only for extracting from archives");
    }
LABEL_224:
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 749, (uint64_t)"prepare_copy_state", "Could not verify copier options");
    goto LABEL_225;
  }
LABEL_82:
  long long v27 = *(NSObject **)(a1 + 13000);
  if (v27 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)statfs buf = 138412290;
    *(void *)&uint8_t buf[4] = a4;
    _os_log_impl(&dword_2105F8000, v27, OS_LOG_TYPE_DEFAULT, "options: %@", buf, 0xCu);
  }
LABEL_85:
  if (getenv("PRESERVECOMPRESSION"))
  {
    long long v28 = (const void *)*MEMORY[0x263EFFB40];
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverCompressionAttributes", (const void *)*MEMORY[0x263EFFB40]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"preserveAppleFSCompression", v28);
  }
  long long v29 = *(NSObject **)(a1 + 13000);
  if (v29)
  {
    if (!os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)
      || (uint64_t v30 = *(void *)(a1 + 13008),
          *(_DWORD *)statfs buf = 138412290,
          *(void *)&uint8_t buf[4] = v30,
          _os_log_impl(&dword_2105F8000, v29, OS_LOG_TYPE_DEFAULT, "source options: %@", buf, 0xCu),
          (long long v29 = *(NSObject **)(a1 + 13000)) != 0))
    {
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = *(void *)(a1 + 13024);
        *(_DWORD *)statfs buf = 138412290;
        *(void *)&uint8_t buf[4] = v31;
        _os_log_impl(&dword_2105F8000, v29, OS_LOG_TYPE_DEFAULT, "destination options: %@", buf, 0xCu);
        long long v29 = *(NSObject **)(a1 + 13000);
      }
    }
  }
  uint64_t v32 = BOMCopierSourceNew(a2, *(const __CFDictionary **)(a1 + 13008), (uint64_t)v29, &v109);
  *(void *)(a1 + 13016) = v32;
  if (!v32)
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 783, (uint64_t)"prepare_copy_state", "Could not create BOMCopierSource");
    goto LABEL_225;
  }
  long long v33 = BOMCopierDestinationNew(a3, *(const __CFDictionary **)(a1 + 13024), &v109);
  *(void *)(a1 + 13032) = v33;
  if (!v33)
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 790, (uint64_t)"prepare_copy_state", "Could not create BOMCopierDestination");
    goto LABEL_225;
  }
  BOMCopierDestinationSetLog(v33, *(void *)(a1 + 13000));
  if (BOMCopierSourceSetErrorHandler(*(void **)(a1 + 13016), (uint64_t)source_error_handler, a1, &v109))
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 803, (uint64_t)"prepare_copy_state", "Could not set BOMCopierSource error handler");
    goto LABEL_225;
  }
  if (*(void *)(a1 + 128))
  {
    if (BOMCopierSourceSetPassphraseCallback(*(void *)(a1 + 13016), (uint64_t)passphrase_callback, a1, &v109))
    {
      BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 816, (uint64_t)"prepare_copy_state", "Could not set BOMCopierSource passphrase callback");
      goto LABEL_225;
    }
    long long v34 = *(NSObject **)(a1 + 13000);
    if (v34 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_2105F8000, v34, OS_LOG_TYPE_DEFAULT, "Set passphrase callback", buf, 2u);
    }
  }
  long long v35 = (uint64_t *)(a1 + 13032);
  uint64_t v36 = *(void *)(a1 + 13040);
  if (v36)
  {
    if (BOMCopierDestinationSetAllowBom(*v35, v36, &v109))
    {
      BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 832, (uint64_t)"prepare_copy_state", "Could not set allow bom for destination");
      goto LABEL_225;
    }
    long long v37 = *(NSObject **)(a1 + 13000);
    if (v37 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_2105F8000, v37, OS_LOG_TYPE_DEFAULT, "Set allow bom with destination", buf, 2u);
    }
  }
  uint64_t v38 = *(void *)(a1 + 13048);
  if (v38)
  {
    if (BOMCopierDestinationSetDenyBom(*v35, v38, &v109))
    {
      BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 844, (uint64_t)"prepare_copy_state", "Could not set deny bom for destination");
      goto LABEL_225;
    }
    long long v39 = *(NSObject **)(a1 + 13000);
    if (v39 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_2105F8000, v39, OS_LOG_TYPE_DEFAULT, "Set deny bom with destination", buf, 2u);
    }
  }
  if (v9[1440])
  {
    uint64_t v40 = *(void *)(a1 + 13040);
    if (!v40)
    {
      BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 855, (uint64_t)"prepare_copy_state", "The client did not provide an index bom to use for enumeration");
      goto LABEL_225;
    }
    if (BOMCopierSourceSetEnumerationBom(*(void *)(a1 + 13016), v40, &v109))
    {
      BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 862, (uint64_t)"prepare_copy_state", "Could not set enumeration bom for source");
      goto LABEL_225;
    }
    long long v41 = *(NSObject **)(a1 + 13000);
    if (v41 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_2105F8000, v41, OS_LOG_TYPE_DEFAULT, "Set enumeration bom with source", buf, 2u);
    }
  }
  if (v9[1441])
  {
    uint64_t v42 = *(void *)(a1 + 13040);
    if (!v42)
    {
      BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 873, (uint64_t)"prepare_copy_state", "The client did not provide an index bom to use for checksum validation");
      goto LABEL_225;
    }
    if (BOMCopierDestinationSetChecksumBom(*v35, v42, &v109))
    {
      BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 880, (uint64_t)"prepare_copy_state", "Could not set checksum bom for destination");
      goto LABEL_225;
    }
    long long v43 = *(NSObject **)(a1 + 13000);
    if (v43 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)statfs buf = 0;
      _os_log_impl(&dword_2105F8000, v43, OS_LOG_TYPE_DEFAULT, "Set enumeration bom with destination", buf, 2u);
    }
  }
  if (BOMCopierDestinationSetConflictResolver(*(void *)(a1 + 13032), (uint64_t)conflict_resolver, a1, &v109))
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 894, (uint64_t)"prepare_copy_state", "Could not set conflict resolver");
    goto LABEL_225;
  }
  if (BOMCopierDestinationSetDataWrittenCallback(*(void *)(a1 + 13032), (uint64_t)data_written_callback, a1, &v109))
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 905, (uint64_t)"prepare_copy_state", "Could not set data written callback");
    goto LABEL_225;
  }
  if (BOMCopierDestinationSetFinalizationCallback(*(void *)(a1 + 13032), (uint64_t)finalization_callback, a1, &v109))
  {
    BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 916, (uint64_t)"prepare_copy_state", "Could not set finalization callback");
    goto LABEL_225;
  }
  long long v44 = *(NSObject **)(a1 + 13000);
  if (v44 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)statfs buf = 0;
    _os_log_impl(&dword_2105F8000, v44, OS_LOG_TYPE_DEFAULT, "Copy state prepared", buf, 2u);
    long long v44 = *(NSObject **)(a1 + 13000);
  }
  bzero(buf, 0x430uLL);
  *(_DWORD *)statfs buf = 1;
  uint64_t v51 = *(void *)(a1 + 8);
  *(void *)&buf[8] = a1 + 13032;
  uint64_t v113 = v51;
  uint64_t v52 = *(int *)(a1 + 16);
  uint64_t v53 = *(void *)(a1 + 24);
  uint64_t v115 = *(void *)(a1 + 32);
  uint64_t v116 = v53;
  uint64_t v114 = v52;
  if (v44 && os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v110 = 0;
    _os_log_impl(&dword_2105F8000, v44, OS_LOG_TYPE_DEFAULT, "Starting copy", v110, 2u);
  }
  while (1)
  {
    uint64_t v54 = *(NSObject **)(a1 + 13000);
    if (*(unsigned char *)(a1 + 168) == 1)
    {
      if (v54 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v110 = 0;
        int v97 = "Client cancelled";
        uint64_t v4 = 2;
        __int16 v98 = v54;
LABEL_245:
        _os_log_impl(&dword_2105F8000, v98, OS_LOG_TYPE_DEFAULT, v97, v110, 2u);
        goto LABEL_227;
      }
LABEL_274:
      uint64_t v4 = 2;
      goto LABEL_227;
    }
    if (v54 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v110 = 0;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, "Retrieving the next source entry", v110, 2u);
    }
    uint64_t v55 = BOMCopierSourceNext(*(void *)(a1 + 13016), &v109, v45, v46, v47, v48, v49, v50);
    unsigned int v56 = (unsigned int *)v55;
    if (v109)
    {
      if (v55) {
        BOMCopierSourceEntryFree((unsigned int *)v55);
      }
      uint64_t v4 = 1;
      BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 249, (uint64_t)"BOMCopierCopyWithOptions2", "Could not copy from %s to %s: %s", a2);
      goto LABEL_226;
    }
    if (!v55) {
      break;
    }
    unsigned int Type = BOMCopierSourceEntryGetType((uint64_t)v55);
    if (Type == 6)
    {
      __int16 Mode = BOMCopierSourceEntryGetMode((uint64_t)v56);
      if ((Mode & 0x80) == 0) {
        BOMCopierSourceEntrySetMode((uint64_t)v56, Mode | 0x80);
      }
      goto LABEL_163;
    }
    if (Type == 8)
    {
      if (*(_DWORD *)(a1 + 12712) || !BOMCopierSourceEntryCheckAccess((uint64_t)v56, 0)) {
        goto LABEL_163;
      }
      uint64_t Path = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v56);
      uint64_t v108 = 0;
      asprintf(&v108, "%s/%s", a2, Path);
      uint64_t v91 = v108;
      if (!v108)
      {
        int v94 = *__error();
        uint64_t v95 = __error();
        uint64_t v106 = strerror(*v95);
        BOMCopierErrorCapture(&v109, v94, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 358, (uint64_t)"BOMCopierCopyWithOptions2", "Could not create error path: %s", v106);
        goto LABEL_208;
      }
      v9[1443] = 1;
      uint64_t v92 = __error();
      int v93 = notify_file_error(a1, (uint64_t)v91, *v92);
      free(v108);
      if (v93 != 1)
      {
LABEL_214:
        BOMCopierSourceEntryFree(v56);
        release_copy_state_0(a1);
        uint64_t v4 = 2;
        int v62 = 1;
        goto LABEL_215;
      }
      uint64_t v61 = *(NSObject **)(a1 + 13000);
      if (!v61 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_158;
      }
LABEL_157:
      *(_DWORD *)uint64_t v110 = 136315138;
      char v111 = Path;
      _os_log_impl(&dword_2105F8000, v61, OS_LOG_TYPE_DEFAULT, "Skipping %s", v110, 0xCu);
LABEL_158:
      BOMCopierSourceEntryFree(v56);
      int v62 = 2;
LABEL_215:
      if (v62 != 2) {
        return v4;
      }
    }
    else
    {
      if (Type <= 2)
      {
        uint64_t Path = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v56);
        uint64_t v108 = 0;
        asprintf(&v108, "%s/%s", a2, Path);
        uint64_t v59 = v108;
        if (v108)
        {
          v9[1443] = 1;
          int v60 = notify_file_error(a1, (uint64_t)v59, 13);
          free(v108);
          if (v60 != 1) {
            goto LABEL_214;
          }
          uint64_t v61 = *(NSObject **)(a1 + 13000);
          if (!v61 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_158;
          }
          goto LABEL_157;
        }
        int v89 = *__error();
        uint64_t v90 = __error();
        uint64_t v105 = strerror(*v90);
        BOMCopierErrorCapture(&v109, v89, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 290, (uint64_t)"BOMCopierCopyWithOptions2", "Could not create error path: %s", v105);
LABEL_208:
        int v62 = 1;
        uint64_t v4 = 1;
        goto LABEL_215;
      }
LABEL_163:
      *uint64_t v9 = 0;
      v9[1025] = 0;
      if (!*(void *)(a1 + 88)) {
        goto LABEL_169;
      }
      uint64_t v64 = BOMCopierSourceEntryGetPath((uint64_t)v56);
      int v65 = BOMCopierSourceEntryGetType((uint64_t)v56);
      uint64_t Size = BOMCopierSourceEntryGetSize((uint64_t)v56);
      if ((v65 - 5) > 5) {
        uint64_t v67 = 0;
      }
      else {
        uint64_t v67 = dword_2106634C0[v65 - 5];
      }
      int v68 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 88))(a1, v64, v67, Size);
      if (v68 == 1)
      {
        uint64_t v86 = *(NSObject **)(a1 + 13000);
        if (v86 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v110 = 0;
          _os_log_impl(&dword_2105F8000, v86, OS_LOG_TYPE_DEFAULT, "Client skipped source entry", v110, 2u);
        }
        BOMCopierSourceEntryFree(v56);
      }
      else
      {
        if (v68 == 2)
        {
          uint64_t v100 = *(NSObject **)(a1 + 13000);
          if (v100 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v110 = 0;
            uint64_t v101 = "Client cancelled";
LABEL_272:
            _os_log_impl(&dword_2105F8000, v100, OS_LOG_TYPE_DEFAULT, v101, v110, 2u);
          }
LABEL_273:
          BOMCopierSourceEntryFree(v56);
          goto LABEL_274;
        }
LABEL_169:
        if (*(unsigned char *)(a1 + 168) == 1)
        {
          uint64_t v100 = *(NSObject **)(a1 + 13000);
          if (v100 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v110 = 0;
            uint64_t v101 = "Client cancelled";
            goto LABEL_272;
          }
          goto LABEL_273;
        }
        if (v9[1025] == 1)
        {
          uint64_t v69 = (const char *)BOMCopierSourceEntryGetPath((uint64_t)v56);
          if (!v69)
          {
            uint64_t v4 = 1;
            BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 460, (uint64_t)"BOMCopierCopyWithOptions2", "Could not get path for redirected source entry", v104, v107);
            goto LABEL_226;
          }
          uint64_t v70 = strdup(v69);
          if (!v70)
          {
            uint64_t v4 = 1;
            BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 468, (uint64_t)"BOMCopierCopyWithOptions2", "Could not duplicate path for redirected source entry", v104, v107);
            goto LABEL_226;
          }
          uint64_t v71 = v70;
          BOMCopierSourceEntryFree(v56);
          if (BOMCopierSourceSetRedirectCallback(*(void *)(a1 + 13016), (uint64_t)source_redirection_callback, a1, &v109))
          {
            uint64_t v4 = 1;
            BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 478, (uint64_t)"BOMCopierCopyWithOptions2", "Could not set source redirect callback", v104, v107);
            goto LABEL_268;
          }
          uint64_t v78 = BOMCopierSourceNext(*(void *)(a1 + 13016), &v109, v72, v73, v74, v75, v76, v77);
          unsigned int v56 = (unsigned int *)v78;
          if (v109)
          {
            if (v78) {
              BOMCopierSourceEntryFree((unsigned int *)v78);
            }
            uint64_t v4 = 1;
            BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 493, (uint64_t)"BOMCopierCopyWithOptions2", "Could not copy from %s to %s: %s", a2);
LABEL_268:
            free(v71);
LABEL_226:
            notify_fatal_error(a1, v109);
            goto LABEL_227;
          }
          if (!v78)
          {
            free(v71);
            goto LABEL_258;
          }
          if (BOMCopierSourceEntrySetPath(v78, v71))
          {
            uint64_t v4 = 1;
            BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 510, (uint64_t)"BOMCopierCopyWithOptions2", "Could not set the saved entry path");
            goto LABEL_268;
          }
          free(v71);
        }
        if (*v9 != 1) {
          goto LABEL_183;
        }
        if (BOMCopierDestinationSetRedirectCallback(*(void *)(a1 + 13032), (uint64_t)destination_redirection_callback, a1, &v109))
        {
          uint64_t v4 = 1;
          BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 530, (uint64_t)"BOMCopierCopyWithOptions2", "Could not set destination redirect callback");
          notify_fatal_error(a1, v109);
          goto LABEL_253;
        }
        int64_t v79 = *(NSObject **)(a1 + 13000);
        if (v79)
        {
          if (os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v110 = 0;
            _os_log_impl(&dword_2105F8000, v79, OS_LOG_TYPE_DEFAULT, "Set destination redirect callback", v110, 2u);
LABEL_183:
            int64_t v79 = *(NSObject **)(a1 + 13000);
            if (!v79) {
              goto LABEL_186;
            }
          }
          if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v110 = 0;
            _os_log_impl(&dword_2105F8000, v79, OS_LOG_TYPE_DEFAULT, "Copying source entry to destination set", v110, 2u);
          }
        }
LABEL_186:
        uint64_t v80 = BOMCopierSourceEntryGetPath((uint64_t)v56);
        uint64_t v81 = *(NSObject **)(a1 + 13000);
        if (v81)
        {
          uint64_t v82 = v80;
          if (os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v110 = 136315138;
            char v111 = (const char *)v82;
            _os_log_impl(&dword_2105F8000, v81, OS_LOG_TYPE_DEFAULT, " %s", v110, 0xCu);
          }
        }
        if (BOMCopierCopySourceEntryToDestinationSet((uint64_t)v56, (unsigned int *)buf, &v109))
        {
          uint64_t v4 = 1;
          BOMCopierErrorCapture(&v109, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 550, (uint64_t)"BOMCopierCopyWithOptions2", "Could not copy from %s to %s: %s", a2, a3, (const char *)0x8200102);
          notify_fatal_file_error(a1, (uint64_t)v56, v109);
LABEL_253:
          BOMCopierSourceEntryFree(v56);
          goto LABEL_227;
        }
        switch(BOMCopierDestinationGetCopyOperation(*v35))
        {
          case 0u:
            uint64_t v83 = *(NSObject **)(a1 + 13000);
            if (!v83 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_205;
            }
            *(_WORD *)uint64_t v110 = 0;
            uint64_t v84 = v83;
            uint64_t v85 = "Source entry copied to destination set\n";
            break;
          case 1u:
            size_t v87 = *(NSObject **)(a1 + 13000);
            if (!v87 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_205;
            }
            *(_WORD *)uint64_t v110 = 0;
            uint64_t v84 = v87;
            uint64_t v85 = "Source entry skipped\n";
            break;
          case 2u:
            uint64_t v100 = *(NSObject **)(a1 + 13000);
            if (!v100 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_273;
            }
            *(_WORD *)uint64_t v110 = 0;
            uint64_t v101 = "Client cancelled\n";
            goto LABEL_272;
          case 3u:
            uint64_t v88 = *(NSObject **)(a1 + 13000);
            if (!v88 || !os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_205;
            }
            *(_WORD *)uint64_t v110 = 0;
            uint64_t v84 = v88;
            uint64_t v85 = "Source entry retry?\n";
            break;
          default:
            goto LABEL_205;
        }
        _os_log_impl(&dword_2105F8000, v84, OS_LOG_TYPE_DEFAULT, v85, v110, 2u);
LABEL_205:
        BOMCopierSourceEntryFree(v56);
        if (*(unsigned char *)(a1 + 168) == 1)
        {
          uint64_t v102 = *(NSObject **)(a1 + 13000);
          if (v102 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)uint64_t v110 = 0;
            int v97 = "Client cancelled\n";
            uint64_t v4 = 2;
            __int16 v98 = v102;
            goto LABEL_245;
          }
          goto LABEL_274;
        }
      }
    }
  }
  uint64_t v99 = *(NSObject **)(a1 + 13000);
  if (v99 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v110 = 0;
    _os_log_impl(&dword_2105F8000, v99, OS_LOG_TYPE_DEFAULT, "Source exhausted", v110, 2u);
  }
LABEL_258:
  int v103 = *(NSObject **)(a1 + 13000);
  if (v9[1443])
  {
    if (v103 && os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v110 = 0;
      _os_log_impl(&dword_2105F8000, v103, OS_LOG_TYPE_DEFAULT, "Copy complete but a file error occurred", v110, 2u);
    }
    uint64_t v4 = 1;
  }
  else
  {
    if (v103)
    {
      uint64_t v4 = 0;
      if (!os_log_type_enabled(*(os_log_t *)(a1 + 13000), OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_227;
      }
      *(_WORD *)uint64_t v110 = 0;
      _os_log_impl(&dword_2105F8000, v103, OS_LOG_TYPE_DEFAULT, "Copy successful", v110, 2u);
    }
    uint64_t v4 = 0;
  }
LABEL_227:
  release_copy_state_0(a1);
  return v4;
}

void notify_fatal_error(uint64_t a1, void *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (a2)
  {
    uint64_t Message = BOMCopierErrorGetMessage((uint64_t)a2);
    if (Message)
    {
      uint64_t v5 = Message;
      uint64_t v6 = *(void (**)(uint64_t, uint64_t))(a1 + 56);
      if (v6) {
        v6(a1, Message);
      }
      uint64_t v7 = *(NSObject **)(a1 + 13000);
      if (v7)
      {
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 136315138;
          uint64_t v9 = v5;
          _os_log_impl(&dword_2105F8000, v7, OS_LOG_TYPE_DEFAULT, "fatal error: %s", (uint8_t *)&v8, 0xCu);
        }
      }
    }
    BOMCopierErrorFree(a2);
  }
}

void release_copy_state_0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 13048);
  if (v2)
  {
    BOMBomFree(v2);
    *(void *)(a1 + 13048) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 13040);
  if (v3)
  {
    BOMBomFree(v3);
    *(void *)(a1 + 13040) = 0;
  }
  uint64_t v4 = *(unsigned int **)(a1 + 13032);
  if (v4)
  {
    BOMCopierDestinationFree(v4);
    *(void *)(a1 + 13032) = 0;
  }
  uint64_t v5 = *(const void **)(a1 + 13024);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a1 + 13024) = 0;
  }
  uint64_t v6 = *(void **)(a1 + 13016);
  if (v6)
  {
    BOMCopierSourceFree(v6);
    *(void *)(a1 + 13016) = 0;
  }
  uint64_t v7 = *(const void **)(a1 + 13008);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a1 + 13008) = 0;
  }
  *(unsigned char *)(a1 + 13059) = 0;
}

uint64_t notify_file_error(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  int v3 = a3;
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 72);
  if (v6)
  {
    unsigned int v7 = v6(a1, a2, a3);
    if (v7 == 1) {
      unsigned int v8 = 0;
    }
    else {
      unsigned int v8 = v7;
    }
    if (v7) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = 1;
    }
  }
  else
  {
    uint64_t v9 = 1;
  }
  uint64_t v10 = *(NSObject **)(a1 + 13000);
  if (v10 && os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 136315906;
    uint64_t v13 = a2;
    __int16 v14 = 1024;
    int v15 = v3;
    __int16 v16 = 2080;
    int v17 = strerror(v3);
    __int16 v18 = 1024;
    int v19 = v9;
    _os_log_impl(&dword_2105F8000, v10, OS_LOG_TYPE_DEFAULT, "file error: %s %d (%s) [%u]", (uint8_t *)&v12, 0x22u);
  }
  return v9;
}

void source_redirection_callback(uint64_t a1, char **a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = strdup((const char *)(a3 + 11617));
    if (v4) {
      *a2 = v4;
    }
  }
}

void destination_redirection_callback(uint64_t a1, char **a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = strdup((const char *)(a3 + 10592));
    if (v4) {
      *a2 = v4;
    }
  }
}

void notify_fatal_file_error(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a3)
  {
    Actualuint64_t Path = BOMCopierSourceEntryGetActualPath(a2);
    uint64_t Code = BOMCopierErrorGetCode((uint64_t)a3);
    uint64_t Message = BOMCopierErrorGetMessage((uint64_t)a3);
    unsigned int v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 64);
    if (v8) {
      v8(a1, ActualPath, Code);
    }
    uint64_t v9 = *(NSObject **)(a1 + 13000);
    if (v9)
    {
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = 136315906;
        uint64_t v11 = ActualPath;
        __int16 v12 = 1024;
        int v13 = Code;
        __int16 v14 = 2080;
        int v15 = strerror(Code);
        __int16 v16 = 2080;
        uint64_t v17 = Message;
        _os_log_impl(&dword_2105F8000, v9, OS_LOG_TYPE_DEFAULT, "fatal file error: %s %d (%s) [%s]", (uint8_t *)&v10, 0x26u);
      }
    }
    BOMCopierErrorFree(a3);
  }
}

uint64_t parse_copier_options(uint64_t a1, const __CFDictionary *a2, void *a3)
{
  uint64_t v217 = *MEMORY[0x263EF8340];
  CFTypeID TypeID = CFBooleanGetTypeID();
  CFTypeID v7 = CFStringGetTypeID();
  CFTypeID v215 = CFDictionaryGetTypeID();
  CFTypeID v8 = CFNumberGetTypeID();
  CFTypeID v9 = CFWriteStreamGetTypeID();
  CFTypeID v10 = CFReadStreamGetTypeID();
  CFTypeID v214 = CFArrayGetTypeID();
  CFTypeID v11 = CFDataGetTypeID();
  *(void *)(a1 + 12712) = 0x300000000;
  CFArrayRef Value = CFDictionaryGetValue(a2, @"inputFD");
  if (Value)
  {
    int v13 = Value;
    if (v8 != CFGetTypeID(Value))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 972, (uint64_t)"parse_copier_options", "kBOMCopierOptionInputFileDescriptorKey must be a CFNumberRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"inputFD", v13);
  }
  __int16 v14 = CFDictionaryGetValue(a2, @"zipFileEncryptionKey");
  if (v14)
  {
    int v15 = v14;
    if (v7 != CFGetTypeID(v14))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1005, (uint64_t)"parse_copier_options", "kBOMCopierOptionEncryptionKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"passphrase", v15);
  }
  CFTypeID v213 = v11;
  __int16 v16 = CFDictionaryGetValue(a2, @"extractCPIO");
  if (v16)
  {
    uint64_t v17 = v16;
    if (TypeID != CFGetTypeID(v16))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1063, (uint64_t)"parse_copier_options", "kBOMCopierOptionExtractCPIOKey must be a CFBooleanRef");
      return v24;
    }
    uint64_t v18 = (const void *)*MEMORY[0x263EFFB40];
    if (CFEqual(v17, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1)
    {
      *(_DWORD *)(a1 + 12712) = 1;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"extractLibarchive", v18);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replaySymlinks", v18);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replayDirectories", v18);
    }
  }
  int v19 = CFDictionaryGetValue(a2, @"createCPIO");
  if (v19)
  {
    uint64_t v20 = v19;
    if (TypeID != CFGetTypeID(v19))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1125, (uint64_t)"parse_copier_options", "kBOMCopierOptionCreateCPIOKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"createArchive", v20);
    if (CFEqual(v20, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1) {
      *(_DWORD *)(a1 + 12716) = 4;
    }
  }
  int v21 = CFDictionaryGetValue(a2, @"compressCPIO");
  if (v21)
  {
    long long v22 = v21;
    if (TypeID == CFGetTypeID(v21))
    {
      if (CFEqual(v22, (CFTypeRef)*MEMORY[0x263EFFB40]) != 1 || *(_DWORD *)(a1 + 12716) != 4) {
        goto LABEL_34;
      }
      *(_DWORD *)unsigned int valuePtr = 1;
      CFNumberRef v23 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, valuePtr);
      if (!v23)
      {
        uint64_t v24 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1184, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
        return v24;
      }
      goto LABEL_33;
    }
    if (v7 != CFGetTypeID(v22))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1227, (uint64_t)"parse_copier_options", "kBOMCopierOptionCompressCPIOKey must be a CFBooleanRef or CFStringRef");
      return v24;
    }
    if (CFEqual(v22, @"auto")) {
      goto LABEL_27;
    }
    if (CFEqual(v22, @"none"))
    {
      *(_DWORD *)unsigned int valuePtr = 0;
LABEL_32:
      CFNumberRef v23 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, valuePtr);
      if (!v23)
      {
        uint64_t v24 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1219, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
        return v24;
      }
LABEL_33:
      CFNumberRef v26 = v23;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"libarchiveFilter", v23);
      CFRelease(v26);
      goto LABEL_34;
    }
    if (CFEqual(v22, @"gzip"))
    {
LABEL_27:
      int v25 = 1;
    }
    else
    {
      if (!CFEqual(v22, @"bzip2"))
      {
        uint64_t v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1212, (uint64_t)"parse_copier_options", "Unknown compression type");
        return v24;
      }
      int v25 = 2;
    }
    *(_DWORD *)unsigned int valuePtr = v25;
    goto LABEL_32;
  }
LABEL_34:
  long long v27 = CFDictionaryGetValue(a2, @"extractPKZip");
  if (v27)
  {
    long long v28 = v27;
    if (TypeID != CFGetTypeID(v27))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1274, (uint64_t)"parse_copier_options", "kBOMCopierOptionExtractPKZipKey must be a CFBooleanRef");
      return v24;
    }
    long long v29 = (const void *)*MEMORY[0x263EFFB40];
    if (CFEqual(v28, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1)
    {
      if (*(_DWORD *)(a1 + 12712))
      {
        uint64_t v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1282, (uint64_t)"parse_copier_options", "The source type has already been assigned to %d");
        return v24;
      }
      *(_DWORD *)(a1 + 12712) = 2;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"extractDataArchive", v29);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"enforceArchiveEntryPermissions", v29);
    }
  }
  uint64_t v30 = CFDictionaryGetValue(a2, @"createPKZip");
  if (v30)
  {
    uint64_t v31 = v30;
    if (TypeID != CFGetTypeID(v30))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1328, (uint64_t)"parse_copier_options", "kBOMCopierOptionExtractPKZipKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"createArchive", v31);
    if (CFEqual(v31, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1)
    {
      if (*(_DWORD *)(a1 + 12716) != 3)
      {
        uint64_t v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1338, (uint64_t)"parse_copier_options", "The destination type has already been assigned to %d");
        return v24;
      }
      *(_DWORD *)(a1 + 12716) = 5;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"excludeRootDirectory", v31);
      *(_DWORD *)unsigned int valuePtr = 327680;
      CFNumberRef v32 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, valuePtr);
      if (!v32)
      {
        uint64_t v24 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1359, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
        return v24;
      }
      CFNumberRef v33 = v32;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"libarchiveFormat", v32);
      CFRelease(v33);
    }
  }
  long long v34 = CFDictionaryGetValue(a2, @"createAppleArchive");
  if (v34)
  {
    long long v35 = v34;
    if (TypeID != CFGetTypeID(v34))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1377, (uint64_t)"parse_copier_options", "kBOMCopierOptionCreateAppleArchiveKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"createAppleArchive", v35);
    if (CFEqual(v35, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1)
    {
      if (*(_DWORD *)(a1 + 12716) != 3)
      {
        uint64_t v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1387, (uint64_t)"parse_copier_options", "The destination type has already been assigned to %d");
        return v24;
      }
      *(_DWORD *)(a1 + 12716) = 6;
    }
  }
  uint64_t v36 = CFDictionaryGetValue(a2, @"compressAppleArchive");
  if (v36)
  {
    long long v37 = v36;
    if (v7 != CFGetTypeID(v36))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1400, (uint64_t)"parse_copier_options", "kBOMCopierOptionCompressAppleArchiveKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"compressAppleArchive", v37);
  }
  uint64_t v38 = CFDictionaryGetValue(a2, @"extractAppleArchive");
  if (v38)
  {
    long long v39 = v38;
    if (TypeID != CFGetTypeID(v38))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1412, (uint64_t)"parse_copier_options", "kBOMCopierOptionExtractAppleArchiveKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"extractAppleArchive", v39);
    if (CFEqual(v39, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1)
    {
      if (*(_DWORD *)(a1 + 12712))
      {
        uint64_t v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1422, (uint64_t)"parse_copier_options", "The source type has already been assigned to %d");
        return v24;
      }
      *(_DWORD *)(a1 + 12712) = 3;
    }
  }
  uint64_t v40 = CFDictionaryGetValue(a2, @"crossDevices");
  if (v40)
  {
    long long v41 = v40;
    if (TypeID != CFGetTypeID(v40))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1457, (uint64_t)"parse_copier_options", "kBOMCopierSourceOptionUseFilesystemCacheKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"crossDevices", v41);
  }
  uint64_t v42 = CFDictionaryGetValue(a2, @"useFilesystemCache");
  if (v42)
  {
    long long v43 = v42;
    if (TypeID != CFGetTypeID(v42))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1502, (uint64_t)"parse_copier_options", "kBOMCopierOptionUseFilesystemCacheKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"useFilesystemCache", v43);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"useFilesystemCache", v43);
  }
  long long v44 = CFDictionaryGetValue(a2, @"applySourcePermissions");
  if (v44)
  {
    uint64_t v45 = v44;
    if (TypeID != CFGetTypeID(v44))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1541, (uint64_t)"parse_copier_options", "kBOMCopierOptionApplySourcePermissionsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"applySourcePermissions", v45);
  }
  uint64_t v46 = CFDictionaryGetValue(a2, @"copyResources");
  if (v46)
  {
    uint64_t v47 = v46;
    if (TypeID != CFGetTypeID(v46))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1601, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyResourcesKey must be a CFBooleanRef");
      return v24;
    }
    BOOL v48 = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v47) != 0;
  }
  else
  {
    BOOL v48 = 0;
  }
  uint64_t v49 = CFDictionaryGetValue(a2, @"copyExtendedAttributes");
  if (v49)
  {
    uint64_t v50 = v49;
    if (TypeID != CFGetTypeID(v49))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1642, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyExtendedAttributesKey must be a CFBooleanRef");
      return v24;
    }
    HIDWORD(v211) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v50) != 0;
  }
  else
  {
    HIDWORD(v211) = 0;
  }
  uint64_t v51 = CFDictionaryGetValue(a2, @"copyACLs");
  if (v51)
  {
    uint64_t v52 = v51;
    if (TypeID != CFGetTypeID(v51))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1683, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyACLsKey must be a CFBooleanRef");
      return v24;
    }
    LODWORD(v211) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v52) != 0;
  }
  else
  {
    LODWORD(v211) = 0;
  }
  uint64_t v53 = CFDictionaryGetValue(a2, @"sequesterResources");
  uint64_t v54 = v53;
  if (v53)
  {
    if (TypeID != CFGetTypeID(v53))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 1720, (uint64_t)"parse_copier_options", "kBOMCopierOptionSequesterResourcesKey must be a CFBooleanRef");
      return v24;
    }
    LODWORD(v54) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v54) != 0;
  }
  int v55 = *(_DWORD *)(a1 + 12712);
  int v56 = *(_DWORD *)(a1 + 12716);
  if (v55)
  {
    if (v56 == 3)
    {
      if (v55 == 2)
      {
        *(void *)&long long v206 = 0;
        uint64_t v208 = 0;
        long long v209 = 0uLL;
        uint64_t v207 = 0;
        BOOL v210 = 0;
        uint64_t v205 = v48 | 0x100000000;
        *((void *)&v206 + 1) = __PAIR64__(v48, v211);
        LODWORD(v54) = v48;
      }
      else
      {
        uint64_t v205 = 0;
        *(void *)&long long v206 = 0;
        uint64_t v208 = 0;
        *(void *)&long long v209 = 0;
        uint64_t v207 = v48;
        if (v55 == 3)
        {
          BOOL v210 = v48;
          int v57 = v211;
          *((void *)&v209 + 1) = v211;
          HIDWORD(v206) = v48;
        }
        else
        {
          BOOL v210 = 0;
          *((void *)&v209 + 1) = 0;
          HIDWORD(v206) = v48;
          int v57 = v211;
        }
        DWORD2(v206) = v57;
      }
    }
    else
    {
      long long v206 = 0uLL;
      uint64_t v208 = 0;
      long long v209 = 0uLL;
      uint64_t v207 = 0;
      BOOL v210 = 0;
      LODWORD(v54) = 0;
      uint64_t v205 = 0;
    }
  }
  else
  {
    if (v56 == 3)
    {
      LODWORD(v206) = 0;
      DWORD1(v206) = v48;
      uint64_t v208 = 0;
      *(void *)&long long v209 = 0;
      *((void *)&v206 + 1) = 0;
      LODWORD(v54) = 0;
      uint64_t v205 = 0;
      uint64_t v207 = 0x100000000;
    }
    else
    {
      if (v56 != 6)
      {
        HIDWORD(v206) = 0;
        uint64_t v207 = 0;
        BOOL v210 = 0;
        HIDWORD(v209) = 0;
        uint64_t v205 = 0;
        LODWORD(v209) = v48 | v54;
        *(void *)((char *)&v209 + 4) = v48 | HIDWORD(v211) | v211 | v54;
        LODWORD(v208) = v211;
        HIDWORD(v208) = HIDWORD(v211) | v54;
        LODWORD(v206) = v54;
        *(void *)((char *)&v206 + 4) = v48 | v54;
        LODWORD(v54) = 0;
        goto LABEL_119;
      }
      long long v206 = 0uLL;
      uint64_t v208 = 0;
      *(void *)&long long v209 = 0;
      uint64_t v207 = 0;
      LODWORD(v54) = 0;
      uint64_t v205 = 0;
    }
    BOOL v210 = v48;
    *((void *)&v209 + 1) = v211;
  }
LABEL_119:
  uint64_t v58 = getenv("BOMCOPIER_LOG_OPTION_RESULTS");
  if (!v58) {
    goto LABEL_121;
  }
  if (strcmp(v58, "1")) {
    goto LABEL_121;
  }
  uint64_t v108 = *(NSObject **)(a1 + 13000);
  if (!v108) {
    goto LABEL_121;
  }
  int v204 = (int)v54;
  uint64_t v54 = *(NSObject **)(a1 + 13000);
  if (!os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v110 = v54;
    goto LABEL_235;
  }
  uint64_t v109 = "false";
  if (v48) {
    uint64_t v109 = "true";
  }
  *(_DWORD *)unsigned int valuePtr = 136315138;
  *(void *)&valuePtr[4] = v109;
  _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, "copy_resources: %s", valuePtr, 0xCu);
  uint64_t v110 = *(NSObject **)(a1 + 13000);
  LODWORD(v54) = v204;
  if (v110)
  {
LABEL_235:
    uint64_t v54 = v110;
    if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
    {
      char v111 = "false";
      if (HIDWORD(v211)) {
        char v111 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v111;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, "copy_extended_attributes: %s", valuePtr, 0xCu);
      uint64_t v112 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v112) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v112 = v54;
    }
    uint64_t v54 = v112;
    if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v113 = "false";
      if (v211) {
        uint64_t v113 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v113;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, "copy_acls: %s", valuePtr, 0xCu);
      uint64_t v114 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v114) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v114 = v54;
    }
    uint64_t v54 = v114;
    if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v115 = "false";
      if (v210) {
        uint64_t v115 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v115;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " discover_resource_attributes: %s", valuePtr, 0xCu);
      uint64_t v116 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v116) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v116 = v54;
    }
    uint64_t v54 = v116;
    if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v117 = "false";
      if (HIDWORD(v209)) {
        uint64_t v117 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v117;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " discover_extended_attributes: %s", valuePtr, 0xCu);
      uint64_t v118 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v118) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v118 = v54;
    }
    uint64_t v54 = v118;
    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v119 = "false";
      if (DWORD2(v209)) {
        uint64_t v119 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v119;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " discover_acls: %s", valuePtr, 0xCu);
      uint64_t v120 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v120) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v120 = v54;
    }
    uint64_t v54 = v120;
    if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v121 = "false";
      if (DWORD1(v209)) {
        uint64_t v121 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v121;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " synthesize_apple_doubles: %s", valuePtr, 0xCu);
      uint64_t v122 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v122) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v122 = v54;
    }
    uint64_t v54 = v122;
    if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v123 = "false";
      if (v209) {
        uint64_t v123 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v123;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " capture_resource_attributes: %s", valuePtr, 0xCu);
      uint64_t v124 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v124) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v124 = v54;
    }
    uint64_t v54 = v124;
    if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v125 = "false";
      if (HIDWORD(v208)) {
        uint64_t v125 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v125;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " capture_extended_attributes: %s", valuePtr, 0xCu);
      uint64_t v126 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v126) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v126 = v54;
    }
    uint64_t v54 = v126;
    if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v128 = "false";
      if (v208) {
        uint64_t v128 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v128;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " capture_acls: %s", valuePtr, 0xCu);
      uint64_t v129 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v129) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v129 = v54;
    }
    uint64_t v54 = v129;
    if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v130 = "false";
      if (HIDWORD(v207)) {
        uint64_t v130 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v130;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " defer_apple_doubles: %s", valuePtr, 0xCu);
      uint64_t v131 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v131) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v131 = v54;
    }
    uint64_t v54 = v131;
    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
    {
      size_t v132 = "false";
      if (v207) {
        size_t v132 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v132;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " replay_apple_doubles: %s", valuePtr, 0xCu);
      uint64_t v133 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v133) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v133 = v54;
    }
    uint64_t v54 = v133;
    if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v134 = "false";
      if (HIDWORD(v206)) {
        __int16 v134 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v134;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " use_apple_double_suffix: %s", valuePtr, 0xCu);
      int v135 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v135) {
        goto LABEL_121;
      }
    }
    else
    {
      int v135 = v54;
    }
    uint64_t v54 = v135;
    if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
    {
      int v137 = "false";
      if (DWORD2(v206)) {
        int v137 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v137;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " merge_acls: %s", valuePtr, 0xCu);
      long long v138 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v138) {
        goto LABEL_121;
      }
    }
    else
    {
      long long v138 = v54;
    }
    uint64_t v54 = v138;
    if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
    {
      long long v140 = "false";
      if (DWORD1(v206)) {
        long long v140 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v140;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " ignore_apple_doubles: %s", valuePtr, 0xCu);
      long long v141 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v141) {
        goto LABEL_121;
      }
    }
    else
    {
      long long v141 = v54;
    }
    uint64_t v54 = v141;
    if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v143 = "false";
      if (v206) {
        uint64_t v143 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v143;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " sequester_apple_doubles: %s", valuePtr, 0xCu);
      uint64_t v144 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v144) {
        goto LABEL_121;
      }
    }
    else
    {
      uint64_t v144 = v54;
    }
    uint64_t v54 = v144;
    if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v145 = "false";
      if (v204) {
        uint64_t v145 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v145;
      int64_t v146 = v54;
      LODWORD(v54) = v204;
      _os_log_impl(&dword_2105F8000, v146, OS_LOG_TYPE_DEFAULT, " unsequester_apple_doubles: %s", valuePtr, 0xCu);
      BOOL v147 = *(NSObject **)(a1 + 13000);
      if (!v147) {
        goto LABEL_121;
      }
    }
    else
    {
      BOOL v147 = v54;
    }
    uint64_t v54 = v147;
    if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
    {
      int64_t v148 = "false";
      if (HIDWORD(v205)) {
        int64_t v148 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v148;
      _os_log_impl(&dword_2105F8000, v54, OS_LOG_TYPE_DEFAULT, " reorder_extra_files: %s", valuePtr, 0xCu);
      int v149 = *(NSObject **)(a1 + 13000);
      LODWORD(v54) = v204;
      if (!v149) {
        goto LABEL_121;
      }
    }
    else
    {
      int v149 = v54;
    }
    uint64_t v54 = v149;
    BOOL v150 = os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT);
    int v151 = v54;
    LODWORD(v54) = v204;
    if (v150)
    {
      int v152 = "false";
      if (v205) {
        int v152 = "true";
      }
      *(_DWORD *)unsigned int valuePtr = 136315138;
      *(void *)&valuePtr[4] = v152;
      _os_log_impl(&dword_2105F8000, v151, OS_LOG_TYPE_DEFAULT, " convert_extra_apple_doubles: %s", valuePtr, 0xCu);
    }
  }
LABEL_121:
  if (v210) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverResourceAttribute", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (HIDWORD(v209)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverExtendedAttributes", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (DWORD2(v209)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverACLs", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (DWORD1(v209)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"synthesizeAppleDoubles", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (v209) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"appleDoublesCaptureResourceAttributes", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (HIDWORD(v208)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"appleDoublesCaptureExtendedAttributes", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (v208) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"appleDoublesCaptureACLs", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (HIDWORD(v207)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"deferAppleDoubles", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (v207) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replayAppleDoubles", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (HIDWORD(v206)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"appleDoubleSuffix", @"__");
  }
  if (DWORD2(v206)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"appleDoubleMergeACLs", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (DWORD1(v206)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"ignoreAppleDoubles", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (v206) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"sequesterAppleDoubles", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (v54) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"unsequesterAppleDoubles", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (HIDWORD(v205)) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"reorderExtraEntries", (const void *)*MEMORY[0x263EFFB40]);
  }
  if (v205) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replayExtraAppleDoubles", (const void *)*MEMORY[0x263EFFB40]);
  }
  uint64_t v59 = CFDictionaryGetValue(a2, @"copyQuarantine");
  if (v59)
  {
    int v60 = v59;
    if (TypeID != CFGetTypeID(v59))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2048, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyQuarantineKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverQuarantine", v60);
  }
  uint64_t v61 = CFDictionaryGetValue(a2, @"quarantineFilePath");
  if (v61)
  {
    int v62 = v61;
    if (v7 != CFGetTypeID(v61))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2089, (uint64_t)"parse_copier_options", "kBOMCopierOptionCopyQuarantineKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replayQuarantineFromPath", v62);
  }
  char v63 = CFDictionaryGetValue(a2, @"useHFSPlusCompression");
  if (v63)
  {
    uint64_t v64 = v63;
    if (TypeID != CFGetTypeID(v63))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2121, (uint64_t)"parse_copier_options", "kBOMCopierOptionUseHFSPlusCompressionKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"useAppleFSCompression", v64);
  }
  int v65 = CFDictionaryGetValue(a2, @"preserveHFSPlusCompression");
  if (v65)
  {
    uint64_t v66 = v65;
    if (TypeID != CFGetTypeID(v65))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2152, (uint64_t)"parse_copier_options", "kBOMCopierOptionPreserveHFSPlusCompressionKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverCompressionAttributes", v66);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"preserveAppleFSCompression", v66);
  }
  CFDictionaryRef v67 = (const __CFDictionary *)CFDictionaryGetValue(a2, @"hfsPlusCompressionOptions");
  if (v67)
  {
    CFDictionaryRef v68 = v67;
    if (v215 != CFGetTypeID(v67))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2185, (uint64_t)"parse_copier_options", "kBOMCopierOptionPreserveHFSPlusCompressionKey must be a CFBooleanRef");
      return v24;
    }
    uint64_t v69 = CFDictionaryGetValue(v68, @"CompressionTypes");
    if (v69)
    {
      uint64_t v70 = v69;
      if (v8 != CFGetTypeID(v69))
      {
        uint64_t v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2206, (uint64_t)"parse_copier_options", "CompressionTypes must be a CFNumberRef");
        return v24;
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"AppleFSCompressionType", v70);
    }
  }
  CFStringRef v71 = (const __CFString *)CFDictionaryGetValue(a2, @"indexbom");
  if (v71)
  {
    CFStringRef v72 = v71;
    if (v7 != CFGetTypeID(v71))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2252, (uint64_t)"parse_copier_options", "kBOMCopierOptionIndexBomKey must be a CFStringRef");
      return v24;
    }
    CFIndex v73 = CFStringGetLength(v72) + 1;
    buffer = (char *)malloc_type_calloc(1uLL, v73, 0x1E606EADuLL);
    if (!buffer)
    {
      int v127 = *__error();
      BOMCopierErrorCapture(a3, v127, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2267, (uint64_t)"parse_copier_options", "Could not allocate %ld bytes for kBOMCopierOptionIndexBomKey");
      return 1;
    }
    if (!CFStringGetCString(v72, buffer, v73, 0x8000100u))
    {
      uint64_t v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2274, (uint64_t)"parse_copier_options", "Could not convert kBOMCopierOptionIndexBomKey to UTF8 C string");
      goto LABEL_330;
    }
    uint64_t v74 = BOMBomOpenWithSys(buffer, 0, 0);
    *(void *)(a1 + 13040) = v74;
    if (!v74)
    {
      uint64_t v139 = buffer;
      uint64_t v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2282, (uint64_t)"parse_copier_options", "Could not open allow bom at %s");
LABEL_346:
      CFDataRef v142 = v139;
      goto LABEL_347;
    }
    free(buffer);
  }
  CFStringRef v75 = (const __CFString *)CFDictionaryGetValue(a2, @"skipbom");
  if (v75)
  {
    CFStringRef v76 = v75;
    if (v7 != CFGetTypeID(v75))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2319, (uint64_t)"parse_copier_options", "kBOMCopierOptionSkipBomKey must be a CFStringRef");
      return v24;
    }
    CFIndex v77 = CFStringGetLength(v76) + 1;
    buffer = (char *)malloc_type_calloc(1uLL, v77, 0x943C7056uLL);
    if (buffer)
    {
      if (CFStringGetCString(v76, buffer, v77, 0x8000100u))
      {
        uint64_t v78 = BOMBomOpenWithSys(buffer, 0, 0);
        *(void *)(a1 + 13048) = v78;
        if (v78)
        {
          free(buffer);
          goto LABEL_182;
        }
        uint64_t v139 = buffer;
        uint64_t v24 = 1;
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2349, (uint64_t)"parse_copier_options", "Could not open deny bom at %s");
        goto LABEL_346;
      }
      uint64_t v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2341, (uint64_t)"parse_copier_options", "Could not convert kBOMCopierOptionIndexBomKey to UTF8 C string");
LABEL_330:
      CFDataRef v142 = buffer;
LABEL_347:
      free(v142);
      return v24;
    }
    int v136 = *__error();
    BOMCopierErrorCapture(a3, v136, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2334, (uint64_t)"parse_copier_options", "Could not allocate %ld bytes for kBOMCopierOptionIndexBomKey");
    return 1;
  }
LABEL_182:
  int64_t v79 = (BOOL *)(a1 + 13056);
  uint64_t v80 = CFDictionaryGetValue(a2, @"verifyFileDataPerIndexBom");
  if (v80)
  {
    uint64_t v81 = v80;
    if (TypeID != CFGetTypeID(v80))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2381, (uint64_t)"parse_copier_options", "kBOMCopierOptionVerifyFileDataPerIndexBomKey must be a CFStringRef");
      return v24;
    }
    *(unsigned char *)(a1 + 13057) = CFEqual(v81, (CFTypeRef)*MEMORY[0x263EFFB40]) != 0;
  }
  uint64_t v82 = CFDictionaryGetValue(a2, @"outputFD");
  if (v82)
  {
    uint64_t v83 = v82;
    if (v8 != CFGetTypeID(v82))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2416, (uint64_t)"parse_copier_options", "kBOMCopierOptionOutputFileDescriptorKey must be a CFNumberRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"outputFD", v83);
  }
  uint64_t v84 = CFDictionaryGetValue(a2, @"outputStream");
  if (v84)
  {
    uint64_t v85 = v84;
    if (v9 != CFGetTypeID(v84))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2446, (uint64_t)"parse_copier_options", "kBOMCopierOptionOutputCFWriteStreamKey must be a CFWriteStream");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"outputStream", v85);
  }
  uint64_t v86 = CFDictionaryGetValue(a2, @"inputStream");
  if (v86)
  {
    size_t v87 = v86;
    if (v10 != CFGetTypeID(v86))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2477, (uint64_t)"parse_copier_options", "kBOMCopierOptionInputCFReadStreamKey must be a CFReadStream");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"inputStream", v87);
  }
  CFArrayRef v88 = (const __CFArray *)CFDictionaryGetValue(a2, @"archs");
  if (v88)
  {
    CFArrayRef v89 = v88;
    if (v214 != CFGetTypeID(v88))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2552, (uint64_t)"parse_copier_options", "kBOMCopierOptionArchitectureArrayKey must be a CFArrayRef");
      return v24;
    }
    if (!CFArrayGetCount(v89))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2560, (uint64_t)"parse_copier_options", "kBOMCopierOptionArchitectureArrayKey is empty");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverBinaries", (const void *)*MEMORY[0x263EFFB40]);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"archs", v89);
  }
  uint64_t v90 = CFDictionaryGetValue(a2, @"fallbackForSubtype");
  if (v90)
  {
    uint64_t v91 = v90;
    if (v215 != CFGetTypeID(v90))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2599, (uint64_t)"parse_copier_options", "kBOMCopierOptionArchitectureFallbackKey must be a CFDictionaryRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"fallbackForSubtype", v91);
  }
  uint64_t v92 = CFDictionaryGetValue(a2, @"keepBinaries");
  if (v92)
  {
    int v93 = v92;
    if (TypeID != CFGetTypeID(v92))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2638, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepBinariesKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverBinaries", v93);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keepBinaries", v93);
  }
  int v94 = CFDictionaryGetValue(a2, @"keepBinariesList");
  if (v94)
  {
    uint64_t v95 = v94;
    if (v7 != CFGetTypeID(v94))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2670, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepBinariesListKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keptFileList", v95);
  }
  time_t v96 = CFDictionaryGetValue(a2, @"keepBinariesPattern");
  if (v96)
  {
    int v97 = v96;
    if (v7 != CFGetTypeID(v96))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2701, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepBinariesPatternKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keepFilePattern", v97);
  }
  __int16 v98 = CFDictionaryGetValue(a2, @"keepBinariesDir");
  if (v98)
  {
    uint64_t v99 = v98;
    if (v7 != CFGetTypeID(v98))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2721, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepBinariesDirKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keptFileDirectory", v99);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"balanceKeptFiles", (const void *)*MEMORY[0x263EFFB40]);
    *(_DWORD *)unsigned int valuePtr = 50;
    CFNumberRef v100 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, valuePtr);
    if (!v100)
    {
      uint64_t v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2734, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
      return v24;
    }
    CFNumberRef v101 = v100;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"keptFileBalanceLimit", v100);
    CFRelease(v101);
  }
  uint64_t v102 = CFDictionaryGetValue(a2, @"keepParent");
  if (v102)
  {
    int v103 = v102;
    if (TypeID != CFGetTypeID(v102))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2787, (uint64_t)"parse_copier_options", "kBOMCopierOptionKeepParentKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"keepParent", v103);
  }
  uint64_t v104 = CFDictionaryGetValue(a2, @"zlibCompressionLevel");
  if (v104)
  {
    uint64_t v105 = v104;
    if (v8 != CFGetTypeID(v104))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2822, (uint64_t)"parse_copier_options", "kBOMCopierOptionZlibCompressionLevel must be a CFNumberRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"zlibCompressionLevel", v105);
  }
  uint64_t v106 = CFDictionaryGetValue(a2, @"compress");
  if (v106)
  {
    uint64_t v107 = v106;
    if (v7 != CFGetTypeID(v106))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2851, (uint64_t)"parse_copier_options", "kBOMCopierOptionCompressDeprecatedKey must be a CFStringRef");
      return v24;
    }
    *(_DWORD *)unsigned int valuePtr = 1;
    if (CFEqual(v107, @"none") == 1)
    {
      *(_DWORD *)unsigned int valuePtr = 0;
    }
    else
    {
      if (CFEqual(v107, @"auto") == 1 || CFEqual(v107, @"gzip") == 1)
      {
        int v153 = 1;
      }
      else
      {
        if (CFEqual(v107, @"bzip2") != 1)
        {
          uint64_t v24 = 22;
          BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2871, (uint64_t)"parse_copier_options", "Unknown deprecated compression option");
          return v24;
        }
        int v153 = 2;
      }
      *(_DWORD *)unsigned int valuePtr = v153;
    }
    CFNumberRef v154 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberIntType, valuePtr);
    if (!v154)
    {
      uint64_t v24 = 1;
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2878, (uint64_t)"parse_copier_options", "Could not create CFNumber from %d");
      return v24;
    }
    CFNumberRef v155 = v154;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"libarchiveFilter", v154);
    CFRelease(v155);
  }
  int v156 = CFDictionaryGetValue(a2, @"symlinkTreatment");
  if (v156)
  {
    uint64_t v157 = v156;
    if (v7 != CFGetTypeID(v156))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2925, (uint64_t)"parse_copier_options", "kBOMCopierOptionSymlinkTreatmentKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"symlinkTreatment", v157);
  }
  uint64_t v158 = CFDictionaryGetValue(a2, @"enforceDestinationEncapsulation");
  if (v158)
  {
    int64_t v159 = v158;
    if (TypeID != CFGetTypeID(v158))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2964, (uint64_t)"parse_copier_options", "kBOMCopierOptionEnforceDestinationEncapsulationKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"enforceDestinationEncapsulation", v159);
  }
  uint64_t v160 = CFDictionaryGetValue(a2, @"enforceDestinationLocation");
  if (v160)
  {
    uint64_t v161 = v160;
    if (TypeID != CFGetTypeID(v160))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 2988, (uint64_t)"parse_copier_options", "kBOMCopierOptionEnforceDestinationLocationKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"enforceDestinationLocation", v161);
  }
  int v162 = CFDictionaryGetValue(a2, @"nonatomicCopy");
  if (v162)
  {
    uint64_t v163 = v162;
    if (TypeID != CFGetTypeID(v162))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3037, (uint64_t)"parse_copier_options", "kBOMCopierOptionNonAtomicCopyKey must be a CFBooleanRef");
      return v24;
    }
    os_log_t v164 = (const void *)*MEMORY[0x263EFFB40];
    if (CFEqual(v163, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1)
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"replaySymlinks", v164);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"enableAtomicCopies", (const void *)*MEMORY[0x263EFFB38]);
    }
  }
  int v165 = CFDictionaryGetValue(a2, @"applyIndexBomOwnership");
  if (v165)
  {
    uint64_t v166 = v165;
    if (TypeID != CFGetTypeID(v165))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3076, (uint64_t)"parse_copier_options", "kBOMCopierOptionApplyIndexBomOwnershipKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"applyBomOwnership", v166);
    if (*(void *)(a1 + 13040))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"useEnumerationBom", v166);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"allowAccessFailures", v166);
      *int64_t v79 = CFEqual(v166, (CFTypeRef)*MEMORY[0x263EFFB40]) != 0;
    }
  }
  uint64_t v167 = CFDictionaryGetValue(a2, @"sourceIsAppSandboxed");
  if (v167)
  {
    uint64_t v168 = v167;
    if (TypeID != CFGetTypeID(v167))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3124, (uint64_t)"parse_copier_options", "kBOMCopierOptionSourceIsAppSandboxed must be a CFBooleanRef");
      return v24;
    }
    if (*(void *)(a1 + 13040))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"useEnumerationBom", v168);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"allowAccessFailures", v168);
      *int64_t v79 = CFEqual(v168, (CFTypeRef)*MEMORY[0x263EFFB40]) != 0;
    }
  }
  uint64_t v169 = CFDictionaryGetValue(a2, @"persistRestrictedFlags");
  if (v169)
  {
    uint64_t v170 = v169;
    if (TypeID != CFGetTypeID(v169))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3169, (uint64_t)"parse_copier_options", "kBOMCopierOptionPersistRestrictedFlagsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"persistRestrictedFlags", v170);
  }
  uint64_t v171 = CFDictionaryGetValue(a2, @"preserveRestrictedFlags");
  if (v171)
  {
    int v172 = v171;
    if (TypeID != CFGetTypeID(v171))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3200, (uint64_t)"parse_copier_options", "kBOMCopierOptionPreserveRestrictedFlagsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"preserveRestrictedFlags", v172);
  }
  uint64_t v173 = CFDictionaryGetValue(a2, @"persistRootlessEAs");
  if (v173)
  {
    uint64_t v174 = v173;
    if (TypeID != CFGetTypeID(v173))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3233, (uint64_t)"parse_copier_options", "kBOMCopierOptionPersistRootlessExtendedAttributesKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"persistRootless", v174);
  }
  size_t v175 = CFDictionaryGetValue(a2, @"initialCPIOInode");
  if (v175)
  {
    stat v176 = v175;
    if (v8 != CFGetTypeID(v175))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3266, (uint64_t)"parse_copier_options", "kBOMCopierOptionInitialCPIOInodeRootKey must be a CFNumberRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"initialInode", v176);
  }
  char v177 = CFDictionaryGetValue(a2, @"skipCPIORoot");
  if (v177)
  {
    uint64_t v178 = v177;
    if (TypeID != CFGetTypeID(v177))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3298, (uint64_t)"parse_copier_options", "kBOMCopierOptionSkipCPIORootKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"skipRootDirectory", v178);
  }
  uint64_t v179 = CFDictionaryGetValue(a2, @"skipCPIOTerminator");
  if (v179)
  {
    uint64_t v180 = v179;
    if (TypeID != CFGetTypeID(v179))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3326, (uint64_t)"parse_copier_options", "kBOMCopierOptionSkipCPIOTerminatorKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"skipTerminator", v180);
  }
  uint64_t v181 = CFDictionaryGetValue(a2, @"segmentLargeFiles");
  if (v181)
  {
    uint64_t v182 = v181;
    if (TypeID != CFGetTypeID(v181))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3364, (uint64_t)"parse_copier_options", "kBOMCopierOptionSegmentLargeFilesKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13008), @"discoverSegmentedFiles", v182);
    if (CFEqual(v182, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1)
    {
      *(void *)unsigned int valuePtr = 0x40000000;
      CFNumberRef v183 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberLongLongType, valuePtr);
      if (!v183)
      {
        BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3377, (uint64_t)"parse_copier_options", "Could not create number for %lld", *(void *)valuePtr);
        return 22;
      }
      CFNumberRef v184 = v183;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"segmentFileSize", v183);
      CFRelease(v184);
    }
  }
  long long v185 = CFDictionaryGetValue(a2, @"enableLogging");
  if (v185)
  {
    long long v186 = v185;
    if (TypeID != CFGetTypeID(v185))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3391, (uint64_t)"parse_copier_options", "kBOMCopierOptionEnableLogging must be a CFBooleanRef");
      return v24;
    }
    *(unsigned char *)(a1 + 13058) = CFEqual((CFTypeRef)*MEMORY[0x263EFFB40], v186) != 0;
  }
  uint64_t v187 = CFDictionaryGetValue(a2, @"output2Nowhere");
  if (v187)
  {
    long long v188 = v187;
    if (TypeID != CFGetTypeID(v187))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3403, (uint64_t)"parse_copier_options", "kBOMCopierOptionOutputNowhereKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"output2Nowhere", v188);
  }
  long long v189 = CFDictionaryGetValue(a2, @"cloneFiles");
  if (v189)
  {
    long long v190 = v189;
    if (TypeID != CFGetTypeID(v189))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3415, (uint64_t)"parse_copier_options", "kBOMCopierOptionCloneFiles must be a CFBooleanRef");
      return v24;
    }
    if (CFEqual(v190, (CFTypeRef)*MEMORY[0x263EFFB40]) == 1)
    {
      if (*(_DWORD *)(a1 + 12712))
      {
        uint64_t v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3423, (uint64_t)"parse_copier_options", "kBOMCopierOptionCloneFiles requires the source to be a filesystem");
        return v24;
      }
      if (*(_DWORD *)(a1 + 12716) != 3)
      {
        uint64_t v24 = 22;
        BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3429, (uint64_t)"parse_copier_options", "kBOMCopierOptionCloneFiles requires the destination to be a filesystem");
        return v24;
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"cloneFiles", v190);
    }
  }
  uint64_t v191 = CFDictionaryGetValue(a2, @"removeSetuidPermissions");
  if (v191)
  {
    uint64_t v192 = v191;
    if (TypeID != CFGetTypeID(v191))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3442, (uint64_t)"parse_copier_options", "kBOMCopierOptionRemoveSetuidPermissionsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"removeSetuidPermissions", v192);
  }
  uint64_t v193 = CFDictionaryGetValue(a2, @"removeExecutablePermissions");
  if (v193)
  {
    uint64_t v194 = v193;
    if (TypeID != CFGetTypeID(v193))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3454, (uint64_t)"parse_copier_options", "kBOMCopierOptionRemoveSetuidPermissionsKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"removeExecutablePermissions", v194);
  }
  uint64_t v195 = CFDictionaryGetValue(a2, @"setStaticContent");
  if (v195)
  {
    uint64_t v196 = v195;
    if (TypeID != CFGetTypeID(v195))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3466, (uint64_t)"parse_copier_options", "kBOMCopierOptionSetStaticContentKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"setStaticContent", v196);
  }
  char v197 = CFDictionaryGetValue(a2, @"setSingleWriter");
  if (v197)
  {
    uint64_t v198 = v197;
    if (TypeID != CFGetTypeID(v197))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3478, (uint64_t)"parse_copier_options", "kBOMCopierOptionSetSingleWriterKey must be a CFBooleanRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"setSingleWriter", v198);
  }
  uint64_t v199 = CFDictionaryGetValue(a2, @"setDataProtectionClass");
  if (v199)
  {
    int v200 = v199;
    if (v7 != CFGetTypeID(v199))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3490, (uint64_t)"parse_copier_options", "kBOMCopierOptionSetDataProtectionClassKey must be a CFStringRef");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"setDataProtectionClass", v200);
  }
  CFDataRef v201 = (const __CFData *)CFDictionaryGetValue(a2, @"applyProvenance");
  if (v201)
  {
    CFDataRef v202 = v201;
    if (v213 != CFGetTypeID(v201))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3502, (uint64_t)"parse_copier_options", "kBOMCopierOptionApplyProvenanceKey must be a CFDataRef");
      return v24;
    }
    if (!CFDataGetLength(v202))
    {
      uint64_t v24 = 22;
      BOMCopierErrorCapture(a3, 22, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3510, (uint64_t)"parse_copier_options", "kBOMCopierOptionApplyProvenanceKey has an invalid size");
      return v24;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 13024), @"applyProvenance", v202);
  }
  return 0;
}

uint64_t source_error_handler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  *(unsigned char *)(a2 + 13059) = 1;
  uint64_t v5 = notify_file_error(a2, *(void *)(a3 + 8), *(unsigned int *)(a3 + 16));
  uint64_t v6 = *(NSObject **)(a2 + 13000);
  if (v6 && os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a3 + 8);
    int v8 = *(_DWORD *)(a3 + 16);
    int v10 = 136315906;
    uint64_t v11 = v7;
    __int16 v12 = 1024;
    int v13 = v8;
    __int16 v14 = 2080;
    int v15 = strerror(v8);
    __int16 v16 = 1024;
    int v17 = v5;
    _os_log_impl(&dword_2105F8000, v6, OS_LOG_TYPE_DEFAULT, "file error: %s %d (%s) [%d]", (uint8_t *)&v10, 0x22u);
  }
  return v5;
}

uint64_t passphrase_callback(int a1, uint64_t a2, void *a3)
{
  uint64_t result = *(void *)(a2 + 12800);
  if (!result)
  {
    uint64_t v5 = *(unsigned int (**)(uint64_t, const char *, uint64_t))(a2 + 128);
    if (!v5)
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3847, (uint64_t)"passphrase_callback", "Client did not register password request callback");
      return 0;
    }
    uint64_t v6 = a2 + 12800;
    if (v5(a2, "", a2 + 12800))
    {
      BOMCopierErrorCapture(a3, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 3856, (uint64_t)"passphrase_callback", "Could not request password from client");
      return 0;
    }
    return *(void *)v6;
  }
  return result;
}

uint64_t conflict_resolver(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (!a4 || !*(void *)(a4 + 80)) {
    return 2;
  }
  int Type = BOMCopierSourceEntryGetType(a2);
  int v9 = BOMCopierDestinationEntryGetType(a3, a5);
  if ((Type - 5) > 5) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = dword_2106634C0[Type - 5];
  }
  if ((v9 - 5) > 5) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = dword_2106634C0[v9 - 5];
  }
  uint64_t Path = BOMCopierDestinationEntryGetPath(a3, a5);
  if (!Path)
  {
    BOMCopierErrorCapture(a5, 1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Bom/Copier/BOMCopier2.c", 4056, (uint64_t)"conflict_resolver", "Could not get destination path");
    return 2;
  }
  int v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 80);
  return v13(a4, Path, v10, v11);
}

void data_written_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 && *(void *)(a4 + 104))
  {
    uint64_t Path = BOMCopierSourceEntryGetPath(a2);
    uint64_t TotalWritten = BOMCopierDestinationEntryGetTotalWritten(a3, 0);
    int v8 = *(void (**)(uint64_t, uint64_t, uint64_t))(a4 + 104);
    v8(a4, Path, TotalWritten);
  }
}

void finalization_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a5 && *(void *)(a5 + 96))
  {
    uint64_t Path = BOMCopierSourceEntryGetPath(a2);
    unsigned int v10 = BOMCopierSourceEntryGetType(a2) - 5;
    if (v10 > 5) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = dword_2106634C0[v10];
    }
    uint64_t TotalWritten = BOMCopierDestinationEntryGetTotalWritten(a3, 0);
    int v13 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 96);
    v13(a5, Path, v11, TotalWritten, a4);
  }
}

void BOMCopierSandbox_boxup(uint64_t a1, const char *a2, uint64_t a3)
{
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        uint64_t v6 = BOM_malloczero(0x400uLL);
        if (v6)
        {
          uint64_t v7 = v6;
          uint64_t v8 = (*(uint64_t (**)(void, const char *, void *))(*(void *)(a1 + 12832) + 160))(*(void *)(*(void *)(a1 + 12832) + 8), a2, v6);
          if (v8)
          {
            int v9 = (const char *)v8;
            unsigned int v10 = BOM_malloczero(0x100uLL);
            if (v10)
            {
              uint64_t v11 = v10;
              __int16 v12 = v10 + 8;
              BomSys_clone(v10 + 8, *(const void **)(a1 + 12832), (uint64_t)v10);
              BomSys_set_opendir(v11[8], (DIR *(*)(int, char *))BOMCopierSandbox_opendir);
              BomSys_set_closedir(v11[8], (uint64_t (*)(int, DIR *))BOMCopierSandbox_closedir);
              BomSys_set_readdir(v11[8], (dirent *(*)(int, DIR *))BOMCopierSandbox_readdir);
              BomSys_set_readdir_r(v11[8], (uint64_t (*)(int, DIR *, dirent *, dirent **))BOMCopierSandbox_readdir_r);
              uint64_t v13 = *(void *)(a1 + 12832);
              *(_OWORD *)(v11 + 1) = *(_OWORD *)(v13 + 272);
              *(_OWORD *)(v11 + 3) = *(_OWORD *)(v13 + 288);
              v11[9] = v7;
              v11[10] = strlen(v9);
              v11[14] = v11;
              v11[28] = a3;
              v11[29] = BOMBomGetRootFSObject(a3);
              __int16 v14 = BOMStackNew();
              v11[31] = v14;
              if (v14)
              {
                *uint64_t v11 = a1;
                v11[5] = *(void *)(a1 + 12832);
                *(void *)(a1 + 12840) = v11;
                uint64_t v15 = v11[6];
                if (!v15) {
                  uint64_t v15 = *v12;
                }
                *(void *)(a1 + 12832) = v15;
              }
            }
            else
            {
              free(v7);
            }
          }
          else
          {
            __int16 v16 = (FILE *)*MEMORY[0x263EF8348];
            int v17 = __error();
            uint64_t v18 = strerror(*v17);
            fprintf(v16, "Cannot get the real path for %s: %s", a2, v18);
          }
        }
      }
    }
  }
}

unsigned int *BOMCopierSandbox_opendir(uint64_t a1, char *__s)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (strlen(__s) > *(void *)(a1 + 80) && !strncmp(__s, *(const char **)(a1 + 72), *(void *)(a1 + 80)))
  {
    __strlcpy_chk();
    size_t v7 = strlen(__sa) - 1;
    if (__sa[v7] == 47) {
      __sa[v7] = 0;
    }
    uint64_t FSObjectAtPath = (unsigned int *)BOMBomGetFSObjectAtPath(*(void *)(a1 + 224), __sa);
    int v9 = FSObjectAtPath;
    if (!FSObjectAtPath)
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "Could not lookup %s in sandbox bom\n", __sa);
      return v9;
    }
    if (BOMFSObjectType(FSObjectAtPath) == 2)
    {
      unsigned int v10 = BOMBomEnumeratorNewWithOptions(*(void *)(a1 + 224), v9, 5);
      BOMFSObjectFree((uint64_t)v9);
      if (!v10) {
        return 0;
      }
      uint64_t v11 = BOM_malloczero(0x90uLL);
      if (v11)
      {
        *uint64_t v11 = v10;
        int v9 = (unsigned int *)(v11 + 1);
        BOMStackPush(*(char **)(a1 + 248), (uint64_t)v11);
        return v9;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8348], "%s is not a directory in the sandbox bom\n", __sa);
    }
    BOMFSObjectFree((uint64_t)v9);
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, char *))(a1 + 8);
  uint64_t v5 = *(void *)(*(void *)(a1 + 64) + 8);
  return (unsigned int *)v4(v5, __s);
}

uint64_t BOMCopierSandbox_closedir(uint64_t a1, void **a2)
{
  uint64_t v4 = (void **)BOMStackPeek(*(void **)(a1 + 248));
  if (v4 + 1 == a2)
  {
    uint64_t v8 = v4;
    BOMStackPop(*(uint64_t **)(a1 + 248));
    BOMBomEnumeratorFree(*v8);
    free(v8);
    return 0;
  }
  else
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, void **))(a1 + 16);
    uint64_t v6 = *(void *)(*(void *)(a1 + 64) + 8);
    return v5(v6, a2);
  }
}

uint64_t BOMCopierSandbox_readdir(uint64_t a1, void *a2)
{
  if (BOMStackPeek(*(void **)(a1 + 248)) + 1 == a2) {
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(a1 + 24);
  uint64_t v5 = *(void *)(*(void *)(a1 + 64) + 8);
  return v4(v5, a2);
}

uint64_t BOMCopierSandbox_readdir_r(uint64_t a1, uint64_t *a2, uint64_t a3, void *a4)
{
  uint64_t v8 = BOMStackPeek(*(void **)(a1 + 248));
  if (v8 + 1 == a2)
  {
    __int16 v12 = BOMBomEnumeratorNext(*v8);
    if (v12)
    {
      uint64_t v13 = (uint64_t)v12;
      bzero((void *)a3, 0x418uLL);
      __int16 v14 = (const char *)BOMFSObjectShortName(v13);
      uint64_t v15 = strcpy((char *)(a3 + 21), v14);
      *(_WORD *)(a3 + 18) = strlen(v15);
      *a4 = a3;
      BOMFSObjectFree(v13);
    }
    else
    {
      *a4 = 0;
    }
    return 0;
  }
  else
  {
    int v9 = *(uint64_t (**)(uint64_t, uint64_t *, uint64_t, void *))(a1 + 32);
    uint64_t v10 = *(void *)(*(void *)(a1 + 64) + 8);
    return v9(v10, a2, a3, a4);
  }
}

void BOMCopierSandbox_unbox(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 12840);
    if (v2)
    {
      int v3 = BOMStackPop(*((uint64_t **)v2 + 31));
      if (v3)
      {
        uint64_t v4 = v3;
        do
        {
          BOMBomEnumeratorFree((void *)*v4);
          *((_OWORD *)v4 + 7) = 0u;
          *((_OWORD *)v4 + 8) = 0u;
          *((_OWORD *)v4 + 5) = 0u;
          *((_OWORD *)v4 + 6) = 0u;
          *((_OWORD *)v4 + 3) = 0u;
          *((_OWORD *)v4 + 4) = 0u;
          *((_OWORD *)v4 + 1) = 0u;
          *((_OWORD *)v4 + 2) = 0u;
          *(_OWORD *)uint64_t v4 = 0u;
          free(v4);
          uint64_t v4 = BOMStackPop(*((uint64_t **)v2 + 31));
        }
        while (v4);
      }
      BOMStackFree(*((void ***)v2 + 31));
      *(void *)(a1 + 12832) = *((void *)v2 + 5);
      *(void *)(a1 + 12840) = 0;
      *((void *)v2 + 5) = 0;
      *(void *)uint64_t v2 = 0;
      uint64_t v5 = (void *)*((void *)v2 + 30);
      if (v5)
      {
        BOMBomEnumeratorFree(v5);
        *((void *)v2 + 30) = 0;
      }
      uint64_t v6 = (void *)*((void *)v2 + 9);
      if (v6)
      {
        free(v6);
        *((void *)v2 + 9) = 0;
      }
      uint64_t v7 = *((void *)v2 + 29);
      if (v7)
      {
        BOMFSObjectFree(v7);
        *((void *)v2 + 29) = 0;
      }
      uint64_t v8 = (void **)*((void *)v2 + 6);
      if (v8)
      {
        BomSys_log_detach(v8);
        *((void *)v2 + 6) = 0;
      }
      int v9 = (void *)*((void *)v2 + 8);
      if (v9) {
        BomSys_free(v9);
      }
      free(v2);
    }
  }
}

void _BOMFreeListAllocate_cold_1()
{
}

void _BOMFreeListAllocate_cold_2()
{
}

void _BOMFreeListAllocate_cold_3()
{
}

void _BOMFreeListAllocate_cold_4()
{
}

int AAArchiveStreamClose(AAArchiveStream s)
{
  return MEMORY[0x270F90C30](s);
}

int AAArchiveStreamReadBlob(AAArchiveStream s, AAFieldKey key, void *buf, size_t nbyte)
{
  return MEMORY[0x270F90C40](s, *(void *)key.skey, buf, nbyte);
}

int AAArchiveStreamReadHeader(AAArchiveStream s, AAHeader *header)
{
  return MEMORY[0x270F90C48](s, header);
}

int AAArchiveStreamWriteBlob(AAArchiveStream s, AAFieldKey key, const void *buf, size_t nbyte)
{
  return MEMORY[0x270F90C50](s, *(void *)key.skey, buf, nbyte);
}

int AAArchiveStreamWriteHeader(AAArchiveStream s, AAHeader header)
{
  return MEMORY[0x270F90C58](s, header);
}

int AAByteStreamClose(AAByteStream s)
{
  return MEMORY[0x270F90C78](s);
}

AAByteStream AACompressionOutputStreamOpen(AAByteStream compressed_stream, AACompressionAlgorithm compression_algorithm, size_t block_size, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)MEMORY[0x270F90CB8](compressed_stream, *(void *)&compression_algorithm, block_size, flags, *(void *)&n_threads);
}

AAByteStream AACustomByteStreamOpen(void)
{
  return (AAByteStream)MEMORY[0x270F90D00]();
}

void AACustomByteStreamSetCloseProc(AAByteStream s, AAByteStreamCloseProc proc)
{
}

void AACustomByteStreamSetData(AAByteStream s, void *data)
{
}

void AACustomByteStreamSetReadProc(AAByteStream s, AAByteStreamReadProc proc)
{
}

void AACustomByteStreamSetWriteProc(AAByteStream s, AAByteStreamWriteProc proc)
{
}

AAArchiveStream AADecodeArchiveInputStreamOpen(AAByteStream stream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  return (AAArchiveStream)MEMORY[0x270F90D70](stream, msg_data, msg_proc, flags, *(void *)&n_threads);
}

AAByteStream AADecompressionInputStreamOpen(AAByteStream compressed_stream, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)MEMORY[0x270F90D78](compressed_stream, flags, *(void *)&n_threads);
}

AAArchiveStream AAEncodeArchiveOutputStreamOpen(AAByteStream stream, void *msg_data, AAEntryMessageProc msg_proc, AAFlagSet flags, int n_threads)
{
  return (AAArchiveStream)MEMORY[0x270F90D88](stream, msg_data, msg_proc, flags, *(void *)&n_threads);
}

int AAEntryACLBlobApplyToPath(AAEntryACLBlob acl, const char *dir, const char *path, AAFlagSet flags)
{
  return MEMORY[0x270F90D90](acl, dir, path, flags);
}

int AAEntryACLBlobClear(AAEntryACLBlob acl)
{
  return MEMORY[0x270F90D98](acl);
}

AAEntryACLBlob AAEntryACLBlobCreateWithEncodedData(const uint8_t *data, size_t data_size)
{
  return (AAEntryACLBlob)MEMORY[0x270F90DA0](data, data_size);
}

AAEntryACLBlob AAEntryACLBlobCreateWithPath(const char *dir, const char *path, AAFlagSet flags)
{
  return (AAEntryACLBlob)MEMORY[0x270F90DA8](dir, path, flags);
}

void AAEntryACLBlobDestroy(AAEntryACLBlob acl)
{
}

const uint8_t *__cdecl AAEntryACLBlobGetEncodedData(AAEntryACLBlob acl)
{
  return (const uint8_t *)MEMORY[0x270F90DB8](acl);
}

size_t AAEntryACLBlobGetEncodedSize(AAEntryACLBlob acl)
{
  return MEMORY[0x270F90DC0](acl);
}

int AAEntryXATBlobAppendEntry(AAEntryXATBlob xat, const char *key, const uint8_t *data, size_t data_size)
{
  return MEMORY[0x270F90DC8](xat, key, data, data_size);
}

int AAEntryXATBlobClear(AAEntryXATBlob xat)
{
  return MEMORY[0x270F90DD8](xat);
}

AAEntryXATBlob AAEntryXATBlobCreate(void)
{
  return (AAEntryXATBlob)MEMORY[0x270F90DE0]();
}

AAEntryXATBlob AAEntryXATBlobCreateWithEncodedData(const uint8_t *data, size_t data_size)
{
  return (AAEntryXATBlob)MEMORY[0x270F90DE8](data, data_size);
}

void AAEntryXATBlobDestroy(AAEntryXATBlob xat)
{
}

const uint8_t *__cdecl AAEntryXATBlobGetEncodedData(AAEntryXATBlob xat)
{
  return (const uint8_t *)MEMORY[0x270F90E00](xat);
}

size_t AAEntryXATBlobGetEncodedSize(AAEntryXATBlob xat)
{
  return MEMORY[0x270F90E08](xat);
}

int AAEntryXATBlobGetEntry(AAEntryXATBlob xat, uint32_t i, size_t key_capacity, char *key, size_t *key_length, size_t data_capacity, uint8_t *data, size_t *data_size)
{
  return MEMORY[0x270F90E10](xat, *(void *)&i, key_capacity, key, key_length, data_capacity, data, data_size);
}

uint32_t AAEntryXATBlobGetEntryCount(AAEntryXATBlob xat)
{
  return MEMORY[0x270F90E18](xat);
}

AAByteStream AAFileStreamOpenWithFD(int fd, int automatic_close)
{
  return (AAByteStream)MEMORY[0x270F90EA8](*(void *)&fd, *(void *)&automatic_close);
}

AAByteStream AAFileStreamOpenWithPath(const char *path, int open_flags, mode_t open_mode)
{
  return (AAByteStream)MEMORY[0x270F90EB0](path, *(void *)&open_flags, open_mode);
}

AAHeader AAHeaderCreate(void)
{
  return (AAHeader)MEMORY[0x270F90ED0]();
}

void AAHeaderDestroy(AAHeader header)
{
}

int AAHeaderGetFieldBlob(AAHeader header, uint32_t i, uint64_t *size, uint64_t *offset)
{
  return MEMORY[0x270F90F00](header, *(void *)&i, size, offset);
}

uint32_t AAHeaderGetFieldCount(AAHeader header)
{
  return MEMORY[0x270F90F08](header);
}

AAFieldKey AAHeaderGetFieldKey(AAHeader header, uint32_t i)
{
  return (AAFieldKey)MEMORY[0x270F90F18](header, *(void *)&i);
}

int AAHeaderGetFieldString(AAHeader header, uint32_t i, size_t capacity, char *value, size_t *length)
{
  return MEMORY[0x270F90F20](header, *(void *)&i, capacity, value, length);
}

int AAHeaderGetFieldTimespec(AAHeader header, uint32_t i, timespec *value)
{
  return MEMORY[0x270F90F28](header, *(void *)&i, value);
}

int AAHeaderGetFieldType(AAHeader header, uint32_t i)
{
  return MEMORY[0x270F90F30](header, *(void *)&i);
}

int AAHeaderGetFieldUInt(AAHeader header, uint32_t i, uint64_t *value)
{
  return MEMORY[0x270F90F38](header, *(void *)&i, value);
}

int AAHeaderGetKeyIndex(AAHeader header, AAFieldKey key)
{
  return MEMORY[0x270F90F40](header, *(void *)key.skey);
}

int AAHeaderSetFieldBlob(AAHeader header, uint32_t i, AAFieldKey key, uint64_t size)
{
  return MEMORY[0x270F90F50](header, *(void *)&i, *(void *)key.skey, size);
}

int AAHeaderSetFieldString(AAHeader header, uint32_t i, AAFieldKey key, const char *value, size_t length)
{
  return MEMORY[0x270F90F68](header, *(void *)&i, *(void *)key.skey, value, length);
}

int AAHeaderSetFieldTimespec(AAHeader header, uint32_t i, AAFieldKey key, const timespec *value)
{
  return MEMORY[0x270F90F70](header, *(void *)&i, *(void *)key.skey, value);
}

int AAHeaderSetFieldUInt(AAHeader header, uint32_t i, AAFieldKey key, uint64_t value)
{
  return MEMORY[0x270F90F78](header, *(void *)&i, *(void *)key.skey, value);
}

uint64_t AFSCLockFilePath()
{
  return MEMORY[0x270F0D570]();
}

uint64_t AFSCUnlockFile()
{
  return MEMORY[0x270F0D578]();
}

int BZ2_bzCompress(bz_stream *strm, int action)
{
  return MEMORY[0x270F981A8](strm, *(void *)&action);
}

int BZ2_bzCompressEnd(bz_stream *strm)
{
  return MEMORY[0x270F981B0](strm);
}

int BZ2_bzCompressInit(bz_stream *strm, int blockSize100k, int verbosity, int workFactor)
{
  return MEMORY[0x270F981B8](strm, *(void *)&blockSize100k, *(void *)&verbosity, *(void *)&workFactor);
}

int BZ2_bzDecompress(bz_stream *strm)
{
  return MEMORY[0x270F981C0](strm);
}

int BZ2_bzDecompressEnd(bz_stream *strm)
{
  return MEMORY[0x270F981C8](strm);
}

int BZ2_bzDecompressInit(bz_stream *strm, int verbosity, int small)
{
  return MEMORY[0x270F981D0](strm, *(void *)&verbosity, *(void *)&small);
}

int CC_MD5_Final(unsigned __int8 *md, CC_MD5_CTX *c)
{
  return MEMORY[0x270ED7AD8](md, c);
}

int CC_MD5_Init(CC_MD5_CTX *c)
{
  return MEMORY[0x270ED7AE0](c);
}

int CC_MD5_Update(CC_MD5_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7AE8](c, data, *(void *)&len);
}

int CC_SHA1_Final(unsigned __int8 *md, CC_SHA1_CTX *c)
{
  return MEMORY[0x270ED7AF8](md, c);
}

int CC_SHA1_Init(CC_SHA1_CTX *c)
{
  return MEMORY[0x270ED7B00](c);
}

int CC_SHA1_Update(CC_SHA1_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B08](c, data, *(void *)&len);
}

int CC_SHA224_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B10](md, c);
}

int CC_SHA224_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B18](c);
}

int CC_SHA224_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B20](c, data, *(void *)&len);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B30](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B38](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B40](c, data, *(void *)&len);
}

int CC_SHA384_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x270ED7B50](md, c);
}

int CC_SHA384_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x270ED7B58](c);
}

int CC_SHA384_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B60](c, data, *(void *)&len);
}

int CC_SHA512_Final(unsigned __int8 *md, CC_SHA512_CTX *c)
{
  return MEMORY[0x270ED7B70](md, c);
}

int CC_SHA512_Init(CC_SHA512_CTX *c)
{
  return MEMORY[0x270ED7B78](c);
}

int CC_SHA512_Update(CC_SHA512_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B80](c, data, *(void *)&len);
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x270EE42E8](theArray, range.location, range.length, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x270EE4300](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x270EE4310](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x270EE4320](theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x270EE4338](theArray, range.location, range.length, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x270EE4348]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x270EE4360](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x270EE4528]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x270EE4530](BOOLean);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x270EE47C8](allocator, bytes, length);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x270EE47F0](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x270EE4808](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x270EE4820](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x270EE4838]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x270EE48F0](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x270EE4908](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x270EE4930](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x270EE4948]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x270EE4968](theDict, key, value);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x270EE4998](cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x270EE4BE8](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x270EE4C58]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x270EE4C70](number, theType, valuePtr);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x270EE4D10](allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x270EE4D40](allocator, data, options, format, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFStreamStatus CFReadStreamGetStatus(CFReadStreamRef stream)
{
  return MEMORY[0x270EE4DA0](stream);
}

CFTypeID CFReadStreamGetTypeID(void)
{
  return MEMORY[0x270EE4DA8]();
}

CFIndex CFReadStreamRead(CFReadStreamRef stream, UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x270EE4DC0](stream, buffer, bufferLength);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4E10](cf);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x270EE5088](alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return (CFStringRef)MEMORY[0x270EE5090](alloc, theArray, separatorString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x270EE50E0](alloc, cStr, *(void *)&encoding);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x270EE5178](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x270EE5180](theString, *(void *)&encoding);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x270EE51D8](theString);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x270EE5210]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x270EE5218]();
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFStreamStatus CFWriteStreamGetStatus(CFWriteStreamRef stream)
{
  return MEMORY[0x270EE5548](stream);
}

CFTypeID CFWriteStreamGetTypeID(void)
{
  return MEMORY[0x270EE5550]();
}

CFIndex CFWriteStreamWrite(CFWriteStreamRef stream, const UInt8 *buffer, CFIndex bufferLength)
{
  return MEMORY[0x270EE5590](stream, buffer, bufferLength);
}

uint64_t CNCRCFinal()
{
  return MEMORY[0x270ED7B90]();
}

uint64_t CNCRCInit()
{
  return MEMORY[0x270ED7B98]();
}

uint64_t CNCRCRelease()
{
  return MEMORY[0x270ED7BA0]();
}

uint64_t CNCRCUpdate()
{
  return MEMORY[0x270ED7BA8]();
}

uint64_t CloseStreamCompressor()
{
  return MEMORY[0x270F0D580]();
}

uint64_t CreateStreamCompressor()
{
  return MEMORY[0x270F0D588]();
}

uint64_t CreateStreamCompressorQueueWithOptions()
{
  return MEMORY[0x270F0D590]();
}

uint64_t FinishStreamCompressorQueue()
{
  return MEMORY[0x270F0D598]();
}

uint64_t ParallelCompressionAFSCStreamClose()
{
  return MEMORY[0x270F96640]();
}

uint64_t ParallelCompressionAFSCStreamOpen()
{
  return MEMORY[0x270F96648]();
}

uint64_t ParallelCompressionAFSCStreamWrite()
{
  return MEMORY[0x270F96650]();
}

uint64_t VolumeSupportsCompression()
{
  return MEMORY[0x270F0D5A0]();
}

uint64_t WriteToStreamCompressor()
{
  return MEMORY[0x270F0D5A8]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

int *__error(void)
{
  return (int *)MEMORY[0x270ED7DC0]();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x270ED7E28](*(void *)&a1, a2);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x270ED7E38]();
}

uint64_t __strlcat_chk()
{
  return MEMORY[0x270ED7ED8]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x270ED7EE0]();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x270ED7F00](*(void *)&a1);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

int access(const char *a1, int a2)
{
  return MEMORY[0x270ED8480](a1, *(void *)&a2);
}

int acl_copy_entry(acl_entry_t dest_d, acl_entry_t src_d)
{
  return MEMORY[0x270ED84A8](dest_d, src_d);
}

int acl_create_entry(acl_t *acl_p, acl_entry_t *entry_p)
{
  return MEMORY[0x270ED84B8](acl_p, entry_p);
}

int acl_free(void *obj_p)
{
  return MEMORY[0x270ED84C8](obj_p);
}

acl_t acl_from_text(const char *buf_p)
{
  return (acl_t)MEMORY[0x270ED84D0](buf_p);
}

int acl_get_entry(acl_t acl, int entry_id, acl_entry_t *entry_p)
{
  return MEMORY[0x270ED84D8](acl, *(void *)&entry_id, entry_p);
}

acl_t acl_get_file(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x270ED84F0](path_p, *(void *)&type);
}

int acl_get_flag_np(acl_flagset_t flagset_d, acl_flag_t flag)
{
  return MEMORY[0x270ED84F8](flagset_d, *(void *)&flag);
}

int acl_get_flagset_np(void *obj_p, acl_flagset_t *flagset_p)
{
  return MEMORY[0x270ED8500](obj_p, flagset_p);
}

acl_t acl_get_link_np(const char *path_p, acl_type_t type)
{
  return (acl_t)MEMORY[0x270ED8508](path_p, *(void *)&type);
}

acl_t acl_init(int count)
{
  return (acl_t)MEMORY[0x270ED8538](*(void *)&count);
}

int acl_set_fd_np(int fd, acl_t acl, acl_type_t acl_type)
{
  return MEMORY[0x270ED8548](*(void *)&fd, acl, *(void *)&acl_type);
}

int acl_set_file(const char *path_p, acl_type_t type, acl_t acl)
{
  return MEMORY[0x270ED8550](path_p, *(void *)&type, acl);
}

int acl_set_link_np(const char *path_p, acl_type_t type, acl_t acl)
{
  return MEMORY[0x270ED8558](path_p, *(void *)&type, acl);
}

char *__cdecl acl_to_text(acl_t acl, ssize_t *len_p)
{
  return (char *)MEMORY[0x270ED8580](acl, len_p);
}

uint64_t archive_entry_atime()
{
  return MEMORY[0x270F97D00]();
}

uint64_t archive_entry_atime_nsec()
{
  return MEMORY[0x270F97D08]();
}

uint64_t archive_entry_ctime()
{
  return MEMORY[0x270F97D20]();
}

uint64_t archive_entry_ctime_nsec()
{
  return MEMORY[0x270F97D30]();
}

uint64_t archive_entry_dev()
{
  return MEMORY[0x270F97D38]();
}

uint64_t archive_entry_free()
{
  return MEMORY[0x270F97D48]();
}

uint64_t archive_entry_gid()
{
  return MEMORY[0x270F97D50]();
}

uint64_t archive_entry_ino()
{
  return MEMORY[0x270F97D58]();
}

uint64_t archive_entry_mode()
{
  return MEMORY[0x270F97D60]();
}

uint64_t archive_entry_mtime()
{
  return MEMORY[0x270F97D68]();
}

uint64_t archive_entry_mtime_nsec()
{
  return MEMORY[0x270F97D70]();
}

uint64_t archive_entry_new()
{
  return MEMORY[0x270F97D78]();
}

uint64_t archive_entry_nlink()
{
  return MEMORY[0x270F97D80]();
}

uint64_t archive_entry_pathname()
{
  return MEMORY[0x270F97D88]();
}

uint64_t archive_entry_set_atime()
{
  return MEMORY[0x270F97DA8]();
}

uint64_t archive_entry_set_ctime()
{
  return MEMORY[0x270F97DB0]();
}

uint64_t archive_entry_set_dev()
{
  return MEMORY[0x270F97DB8]();
}

uint64_t archive_entry_set_filetype()
{
  return MEMORY[0x270F97DC0]();
}

uint64_t archive_entry_set_gid()
{
  return MEMORY[0x270F97DC8]();
}

uint64_t archive_entry_set_ino64()
{
  return MEMORY[0x270F97DD0]();
}

uint64_t archive_entry_set_mode()
{
  return MEMORY[0x270F97DD8]();
}

uint64_t archive_entry_set_mtime()
{
  return MEMORY[0x270F97DE0]();
}

uint64_t archive_entry_set_nlink()
{
  return MEMORY[0x270F97DE8]();
}

uint64_t archive_entry_set_pathname()
{
  return MEMORY[0x270F97DF0]();
}

uint64_t archive_entry_set_perm()
{
  return MEMORY[0x270F97E00]();
}

uint64_t archive_entry_set_size()
{
  return MEMORY[0x270F97E08]();
}

uint64_t archive_entry_set_symlink()
{
  return MEMORY[0x270F97E10]();
}

uint64_t archive_entry_set_uid()
{
  return MEMORY[0x270F97E18]();
}

uint64_t archive_entry_size()
{
  return MEMORY[0x270F97E20]();
}

uint64_t archive_entry_symlink()
{
  return MEMORY[0x270F97E38]();
}

uint64_t archive_entry_uid()
{
  return MEMORY[0x270F97E40]();
}

uint64_t archive_errno()
{
  return MEMORY[0x270F97E50]();
}

uint64_t archive_error_string()
{
  return MEMORY[0x270F97E58]();
}

uint64_t archive_read_add_passphrase()
{
  return MEMORY[0x270F97E70]();
}

uint64_t archive_read_free()
{
  return MEMORY[0x270F97EE0]();
}

uint64_t archive_read_has_encrypted_entries()
{
  return MEMORY[0x270F97EE8]();
}

uint64_t archive_read_new()
{
  return MEMORY[0x270F97EF0]();
}

uint64_t archive_read_next_header()
{
  return MEMORY[0x270F97EF8]();
}

uint64_t archive_read_open()
{
  return MEMORY[0x270F97F08]();
}

uint64_t archive_read_open_fd()
{
  return MEMORY[0x270F97F18]();
}

uint64_t archive_read_open_filename()
{
  return MEMORY[0x270F97F20]();
}

uint64_t archive_read_set_options()
{
  return MEMORY[0x270F97F38]();
}

uint64_t archive_read_set_passphrase_callback()
{
  return MEMORY[0x270F97F40]();
}

uint64_t archive_read_support_filter_all()
{
  return MEMORY[0x270F97F50]();
}

uint64_t archive_read_support_format_all()
{
  return MEMORY[0x270F97F68]();
}

uint64_t archive_set_error()
{
  return MEMORY[0x270F97F88]();
}

uint64_t archive_write_add_filter()
{
  return MEMORY[0x270F97F90]();
}

uint64_t archive_write_close()
{
  return MEMORY[0x270F97FA8]();
}

uint64_t archive_write_data()
{
  return MEMORY[0x270F97FB0]();
}

uint64_t archive_write_free()
{
  return MEMORY[0x270F97FE8]();
}

uint64_t archive_write_header()
{
  return MEMORY[0x270F97FF0]();
}

uint64_t archive_write_new()
{
  return MEMORY[0x270F97FF8]();
}

uint64_t archive_write_open2()
{
  return MEMORY[0x270F98008]();
}

uint64_t archive_write_open_fd()
{
  return MEMORY[0x270F98010]();
}

uint64_t archive_write_open_filename()
{
  return MEMORY[0x270F98018]();
}

uint64_t archive_write_set_filter_option()
{
  return MEMORY[0x270F98048]();
}

uint64_t archive_write_set_format()
{
  return MEMORY[0x270F98050]();
}

uint64_t archive_write_set_format_option()
{
  return MEMORY[0x270F98068]();
}

int asprintf(char **a1, const char *a2, ...)
{
  return MEMORY[0x270ED8688](a1, a2);
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x270ED8748](a1, a2);
}

void bzero(void *a1, size_t a2)
{
}

int chdir(const char *a1)
{
  return MEMORY[0x270ED8EB8](a1);
}

int chflags(const char *a1, __uint32_t a2)
{
  return MEMORY[0x270ED8EC0](a1, *(void *)&a2);
}

int chmod(const char *a1, mode_t a2)
{
  return MEMORY[0x270ED8EC8](a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x270ED8ED0](a1, *(void *)&a2, *(void *)&a3);
}

int close(int a1)
{
  return MEMORY[0x270ED8F18](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x270ED8F30](a1);
}

int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return MEMORY[0x270ED9100](from, to, state, *(void *)&flags);
}

uLong crc32(uLong crc, const Bytef *buf, uInt len)
{
  return MEMORY[0x270F9C690](crc, buf, *(void *)&len);
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  return (char *)MEMORY[0x270ED9170](a1, a2);
}

int deflate(z_streamp strm, int flush)
{
  return MEMORY[0x270F9C698](strm, *(void *)&flush);
}

int deflateEnd(z_streamp strm)
{
  return MEMORY[0x270F9C6A8](strm);
}

int deflateInit2_(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return MEMORY[0x270F9C6B0](strm, *(void *)&level, *(void *)&method, *(void *)&windowBits, *(void *)&memLevel, *(void *)&strategy, version, *(void *)&stream_size);
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return (char *)MEMORY[0x270ED9198](a1, a2);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x270ED9340]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x270ED9378](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_release(dispatch_object_t object)
{
}

void err(int a1, const char *a2, ...)
{
}

void errx(int a1, const char *a2, ...)
{
}

int faccessat(int a1, const char *a2, int a3, int a4)
{
  return MEMORY[0x270ED9888](*(void *)&a1, a2, *(void *)&a3, *(void *)&a4);
}

int fclose(FILE *a1)
{
  return MEMORY[0x270ED98C8](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x270ED98D0](*(void *)&a1, *(void *)&a2);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x270ED9968](a1, *(void *)&a2, a3);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x270ED99F0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x270ED9A08](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x270ED9A18](*(void *)&a1, a2);
}

void free(void *a1)
{
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return MEMORY[0x270ED9AB8](a1, a2, a3, *(void *)&a4);
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x270ED9AF0](*(void *)&a1, a2);
}

int fstatfs(int a1, statfs *a2)
{
  return MEMORY[0x270ED9B00](*(void *)&a1, a2);
}

int fsync(int a1)
{
  return MEMORY[0x270ED9B10](*(void *)&a1);
}

int fts_close(FTS *a1)
{
  return MEMORY[0x270ED9B48](a1);
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  return (FTS *)MEMORY[0x270ED9B50](a1, *(void *)&a2, a3);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  return (FTSENT *)MEMORY[0x270ED9B60](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x270ED9BA0](a1, a2, a3, a4, *(void *)&a5);
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return (char *)MEMORY[0x270ED9BD0](a1, a2);
}

gid_t getegid(void)
{
  return MEMORY[0x270ED9BE0]();
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x270ED9BE8](a1);
}

uid_t geteuid(void)
{
  return MEMORY[0x270ED9BF0]();
}

group *__cdecl getgrgid(gid_t a1)
{
  return (group *)MEMORY[0x270ED9C18](*(void *)&a1);
}

int getgroups(int a1, gid_t a2[])
{
  return MEMORY[0x270ED9C38](*(void *)&a1, a2);
}

int getpagesize(void)
{
  return MEMORY[0x270ED9CC8]();
}

pid_t getpid(void)
{
  return MEMORY[0x270ED9CE0]();
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return (passwd *)MEMORY[0x270ED9D38](*(void *)&a1);
}

int getrlimit(int a1, rlimit *a2)
{
  return MEMORY[0x270ED9D48](*(void *)&a1, a2);
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x270ED9D98](a1, a2);
}

ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x270ED9DC0](path, name, value, size, *(void *)&position, *(void *)&options);
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x270F9C730](strm, *(void *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x270F9C738](strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return MEMORY[0x270F9C740](strm, *(void *)&windowBits, version, *(void *)&stream_size);
}

int issetugid(void)
{
  return MEMORY[0x270ED9F18]();
}

int lchmod(const char *a1, mode_t a2)
{
  return MEMORY[0x270EDA018](a1, a2);
}

int lchown(const char *a1, uid_t a2, gid_t a3)
{
  return MEMORY[0x270EDA020](a1, *(void *)&a2, *(void *)&a3);
}

int link(const char *a1, const char *a2)
{
  return MEMORY[0x270EDA068](a1, a2);
}

ssize_t listxattr(const char *path, char *namebuff, size_t size, int options)
{
  return MEMORY[0x270EDA080](path, namebuff, size, *(void *)&options);
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x270EDA098](a1);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x270EDA118](*(void *)&a1, a2, *(void *)&a3);
}

int lstat(const char *a1, stat *a2)
{
  return MEMORY[0x270EDA120](a1, a2);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA3A0](ptr, size, type_id);
}

void *__cdecl malloc_type_valloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA3A8](size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x270EDA458](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

int mergesort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return MEMORY[0x270EDA4C0](__base, __nel, __width, __compar);
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x270EDA518](a1, a2);
}

int mknod(const char *a1, mode_t a2, dev_t a3)
{
  return MEMORY[0x270EDA540](a1, a2, *(void *)&a3);
}

int mkstemp(char *a1)
{
  return MEMORY[0x270EDA560](a1);
}

char *__cdecl mktemp(char *a1)
{
  return (char *)MEMORY[0x270EDA580](a1);
}

time_t mktime(tm *a1)
{
  return MEMORY[0x270EDA588](a1);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x270EDA598](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x270EDA5F8](a1, a2);
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  return MEMORY[0x270EDA618](__rqtp, __rmtp);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x270EDA828](a1, *(void *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x270EDA830](a1, *(void *)&a2, *(void *)&a3, *(void *)&a4);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x270EDA858](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x270EDAB30]();
}

void perror(const char *a1)
{
}

int printf(const char *a1, ...)
{
  return MEMORY[0x270EDAD20](a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x270EDAE10](a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return MEMORY[0x270EDAE18](__attr, *(void *)&__qos_class, *(void *)&__relative_priority);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x270EDAE50](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x270EDAE58](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x270EDAE60](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x270EDAE68](a1);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x270EDAE88](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x270EDAEA0](a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x270EDAF10](a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF50](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x270EDAF58](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF60](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF70](a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return MEMORY[0x270EDAFA0](a1, a2);
}

int puts(const char *a1)
{
  return MEMORY[0x270EDB098](a1);
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x270EDB0B0]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x270EDB120](*(void *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x270EDB128](a1);
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  return MEMORY[0x270EDB130](a1, a2, a3);
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return MEMORY[0x270EDB138](a1, a2, a3);
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return (void *)MEMORY[0x270EDB158](__ptr, __size);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x270EDB170](a1, a2);
}

int regcomp(regex_t *a1, const char *a2, int a3)
{
  return MEMORY[0x270EDB1A8](a1, a2, *(void *)&a3);
}

int regexec(const regex_t *a1, const char *a2, size_t a3, regmatch_t __pmatch[], int a5)
{
  return MEMORY[0x270EDB1B8](a1, a2, a3, __pmatch, *(void *)&a5);
}

void regfree(regex_t *a1)
{
}

int removexattr(const char *path, const char *name, int options)
{
  return MEMORY[0x270EDB218](path, name, *(void *)&options);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

char *__cdecl rindex(const char *a1, int a2)
{
  return (char *)MEMORY[0x270EDB260](a1, *(void *)&a2);
}

int rmdir(const char *a1)
{
  return MEMORY[0x270EDB268](a1);
}

int setattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return MEMORY[0x270EDB3C8](a1, a2, a3, a4, *(void *)&a5);
}

int setrlimit(int a1, const rlimit *a2)
{
  return MEMORY[0x270EDB428](*(void *)&a1, a2);
}

int setxattr(const char *path, const char *name, const void *value, size_t size, u_int32_t position, int options)
{
  return MEMORY[0x270EDB460](path, name, value, size, *(void *)&position, *(void *)&options);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x270EDB560](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x270EDB568](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x270EDB570](a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return (char *)MEMORY[0x270EDB5A8](__s, *(void *)&__c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x270EDB5C0](__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x270EDB5D0](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x270EDB5D8](*(void *)&__errnum);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x270EDB5F8](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x270EDB600](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

void strmode(int __mode, char *__bp)
{
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x270EDB630](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x270EDB638](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x270EDB648](__dst, __src, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return MEMORY[0x270EDB658](__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x270EDB680](__s, *(void *)&__c);
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  return (char *)MEMORY[0x270EDB688](__stringp, __delim);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB6D8](__str, __endptr, *(void *)&__base);
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB6E8](__str, __endptr, *(void *)&__base);
}

uint64_t strtoq(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB700](__str, __endptr, *(void *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB708](__str, __endptr, *(void *)&__base);
}

int symlink(const char *a1, const char *a2)
{
  return MEMORY[0x270EDB770](a1, a2);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x270EDB7D0](a1, *(void *)&a2, a3, a4, a5, a6);
}

time_t time(time_t *a1)
{
  return MEMORY[0x270EDB930](a1);
}

int unlink(const char *a1)
{
  return MEMORY[0x270EDB9A8](a1);
}

int utimes(const char *a1, const timeval *a2)
{
  return MEMORY[0x270EDB9F8](a1, a2);
}

void uuid_generate(uuid_t out)
{
}

void uuid_generate_random(uuid_t out)
{
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x270EDBA58](a1, a2, a3);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return MEMORY[0x270EDBA80](*(void *)&target_task, address, size, *(void *)&flags);
}

kern_return_t vm_copy(vm_map_t target_task, vm_address_t source_address, vm_size_t size, vm_address_t dest_address)
{
  return MEMORY[0x270EDBA88](*(void *)&target_task, source_address, size, dest_address);
}

kern_return_t vm_deallocate(vm_map_t target_task, vm_address_t address, vm_size_t size)
{
  return MEMORY[0x270EDBA90](*(void *)&target_task, address, size);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x270EDBB18](__str, __size, __format, a4);
}

void warnx(const char *a1, ...)
{
}