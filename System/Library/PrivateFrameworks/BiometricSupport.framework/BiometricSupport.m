void sub_21FFF60E8(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_21FFF6448(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_21FFFAE0C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_21FFFAE8C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_21FFFB344(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_21FFFB6A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

void sub_21FFFC07C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_21FFFC598(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_21FFFCA8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_21FFFCF28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_21FFFD43C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_21FFFD958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_21FFFDE5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_220002178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_220002698(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_2200076AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_220009B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_220009FE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_22000A1D8(_Unwind_Exception *exception_object)
{
}

void sub_22000A24C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22000A3AC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22000A4FC(_Unwind_Exception *exception_object)
{
}

void sub_22000A590(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22000A620(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22000A6B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22000A8F0(_Unwind_Exception *exception_object)
{
}

void sub_22000AA7C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void __PasscodeChangedNotificationCallback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (__osLogTrace) {
    v10 = __osLogTrace;
  }
  else {
    v10 = &_os_log_internal;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    int v12 = 134219010;
    uint64_t v13 = a1;
    __int16 v14 = 2048;
    v15 = a2;
    __int16 v16 = 2112;
    uint64_t v17 = a3;
    __int16 v18 = 2048;
    uint64_t v19 = a4;
    __int16 v20 = 2112;
    uint64_t v21 = a5;
    _os_log_impl(&dword_21FFF3000, v10, OS_LOG_TYPE_DEBUG, "__PasscodeChangedNotificationCallback %p %p %@ %p %@\n", (uint8_t *)&v12, 0x34u);
  }
  v11 = (void *)MEMORY[0x223C64ED0]();
  [a2 checkTemplatesValidityForUser:501];
}

void sub_22000CBA0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22000CD8C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22000CFD0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2200110B0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2200117FC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2200119D0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2200123D0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_220012688(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_220012988(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_220012B40(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_220013558(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long long a9, int a10, __int16 a11, __int16 a12, void *a13, long long a14)
{
  if (a2 == 1)
  {
    objc_begin_catch(a1);
    if (__osLog) {
      __int16 v14 = __osLog;
    }
    else {
      __int16 v14 = &_os_log_internal;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LODWORD(a9) = 136316162;
      *(void *)((char *)&a9 + 4) = "0";
      WORD6(a9) = 2048;
      *(void *)((char *)&a9 + 14) = 0;
      a12 = 2080;
      a13 = &unk_22004A573;
      LOWORD(a14) = 2080;
      *(void *)((char *)&a14 + 2) = "/Library/Caches/com.apple.xbs/Sources/BiometricSupport/BiometricSupport/biometrick"
                                      "itd/BiometricKitXPCServer.m";
      WORD5(a14) = 1024;
      HIDWORD(a14) = 2404;
      _os_log_impl(&dword_21FFF3000, v14, OS_LOG_TYPE_ERROR, "AssertMacros: %s (value = 0x%lx), %s file: %s, line: %d\n\n", (uint8_t *)&a9, 0x30u);
    }
    objc_end_catch();
    JUMPOUT(0x22001354CLL);
  }
  _Unwind_Resume(a1);
}

void sub_2200177CC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2200180A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj)
{
}

void sub_220018330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_220019134(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001B3C4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001B5CC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001B62C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001B850(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001BBE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj)
{
}

void sub_22001BFEC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001C2A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001C46C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001C6C4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001DC48(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22001E7D8(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_220020B74()
{
}

void sub_220020D2C(uint64_t a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x220020D38);
  }
  JUMPOUT(0x220020D5CLL);
}

void sub_2200218F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_220021C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_220021CF4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_220021E6C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_2200221E4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22002382C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  objc_sync_exit(v17);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_220024F28(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22002CCA0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22002CD2C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_22002D354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

uint64_t MCDMExtractMessageData(_DWORD *a1, _DWORD *a2, uint64_t *a3, uint64_t **a4, void *a5, void *a6, void *a7)
{
  if (a1 && a4 && a3 && *a1 == -469794816)
  {
    *a1 = *((_DWORD *)a3 + 2);
    if (a2) {
      *a2 = *((_DWORD *)a3 + 3);
    }
    if (a7) {
      *a7 = a3[2];
    }
    uint64_t result = *a3;
    if (!*a3)
    {
      if (a3[4]) {
        v8 = a3 + 5;
      }
      else {
        v8 = (uint64_t *)a3[3];
      }
      *a4 = v8;
    }
    if (a6) {
      *a6 = a3[3];
    }
    if (a5) {
      *a5 = a3[4];
    }
  }
  else
  {
    if (a2) {
      *a2 = 0;
    }
    if (a4) {
      *a4 = 0;
    }
    if (a5) {
      *a5 = 0;
    }
    if (a6) {
      *a6 = 0;
    }
    uint64_t result = 0;
    if (a7) {
      *a7 = 0;
    }
  }
  return result;
}

void sub_2200301A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_220030498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t AWDBiometricKitEventLogReadFrom(uint64_t a1, uint64_t a2)
{
  v3 = (int *)MEMORY[0x263F62298];
  v4 = (int *)MEMORY[0x263F62288];
  v5 = (int *)MEMORY[0x263F62270];
  if (*(void *)(a2 + (int)*MEMORY[0x263F62298]) < *(void *)(a2 + (int)*MEMORY[0x263F62288]))
  {
    v7 = (int *)MEMORY[0x263F62268];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      int v16 = v10 & 7;
      if (v15 || v16 == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        if (v16 == 2)
        {
          uint64_t result = PBReaderPlaceMark();
          if (!result) {
            return result;
          }
          while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4) && !*(unsigned char *)(a2 + *v5))
          {
            char v25 = 0;
            unsigned int v26 = 0;
            uint64_t v27 = 0;
            while (1)
            {
              uint64_t v28 = *v3;
              unint64_t v29 = *(void *)(a2 + v28);
              if (v29 == -1 || v29 >= *(void *)(a2 + *v4)) {
                break;
              }
              char v30 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
              *(void *)(a2 + v28) = v29 + 1;
              v27 |= (unint64_t)(v30 & 0x7F) << v25;
              if (v30 < 0)
              {
                v25 += 7;
                BOOL v14 = v26++ >= 9;
                if (!v14) {
                  continue;
                }
              }
              goto LABEL_39;
            }
            *(unsigned char *)(a2 + *v5) = 1;
LABEL_39:
            PBRepeatedUInt32Add();
          }
          PBReaderRecallMark();
        }
        else
        {
          char v31 = 0;
          unsigned int v32 = 0;
          uint64_t v33 = 0;
          while (1)
          {
            uint64_t v34 = *v3;
            unint64_t v35 = *(void *)(a2 + v34);
            if (v35 == -1 || v35 >= *(void *)(a2 + *v4)) {
              break;
            }
            char v36 = *(unsigned char *)(*(void *)(a2 + *v7) + v35);
            *(void *)(a2 + v34) = v35 + 1;
            v33 |= (unint64_t)(v36 & 0x7F) << v31;
            if (v36 < 0)
            {
              v31 += 7;
              BOOL v14 = v32++ >= 9;
              if (!v14) {
                continue;
              }
            }
            goto LABEL_55;
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_55:
          PBRepeatedUInt32Add();
        }
      }
      else if ((v10 >> 3) == 1)
      {
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 40) |= 1u;
        while (1)
        {
          uint64_t v21 = *v3;
          unint64_t v22 = *(void *)(a2 + v21);
          if (v22 == -1 || v22 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0) {
            goto LABEL_43;
          }
          v18 += 7;
          BOOL v14 = v19++ >= 9;
          if (v14)
          {
            uint64_t v20 = 0;
            goto LABEL_45;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_43:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_45:
        *(void *)(a1 + 32) = v20;
      }
      else if ((PBReaderSkipValueWithTag() & 1) == 0)
      {
        return 0;
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t lib_platform_rng()
{
  uint64_t v0 = ccrng();
  REQUIRE_func(v0 != 0, 22, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
  REQUIRE_func(0, 23, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
  return v0;
}

uint64_t lib_platform_read_random(uint64_t a1, unsigned int a2)
{
  v4 = *(unsigned int (**)(uint64_t, void, uint64_t))platform_rng();
  uint64_t v5 = platform_rng();
  BOOL v6 = v4(v5, a2, a1) == 0;
  return REQUIRE_func(v6, 31, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
}

uint64_t rfc3394_wrap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), uint64_t *a5, unint64_t a6, void *a7, unint64_t *a8)
{
  uint64_t v41 = a1;
  uint64_t v42 = a3;
  uint64_t v45 = *MEMORY[0x263EF8340];
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = ccaes_cbc_encrypt_mode();
  MEMORY[0x270FA5388]();
  uint64_t v43 = (uint64_t)&v36 - v15;
  bzero((char *)&v36 - v15, v15);
  MEMORY[0x270FA5388]();
  uint64_t v17 = (char *)&v36 - v16;
  bzero((char *)&v36 - v16, v16);
  uint64_t v18 = 0xFFFFFFFFLL;
  if (HIDWORD(a6) || (a6 - 40) < 0xFFFFFFE0) {
    goto LABEL_30;
  }
  v39 = &v36;
  v40 = a8;
  v38 = a7;
  if (!a4)
  {
    BOOL v20 = (a2 & 0xFFFFFFFFFFFFFFF7) == 0x10 || a2 == 32;
    if (!v20 || !a8 || *a8 < a6 + 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_31;
    }
    unint64_t v37 = a6 + 8;
    cccbc_init();
    goto LABEL_15;
  }
  if (a8)
  {
    unint64_t v19 = *v40;
    unint64_t v37 = a6 + 8;
    if (v19 >= a6 + 8)
    {
LABEL_15:
      uint64_t v21 = 0;
      unsigned int v22 = a6 >> 3;
      if (a6 >> 3 <= 1) {
        uint64_t v23 = 1;
      }
      else {
        uint64_t v23 = v22;
      }
      do
      {
        uint64_t v24 = *a5++;
        *((void *)&__s[v21++] + 1) = v24;
      }
      while (v23 != v21);
      uint64_t v25 = 0;
      *(void *)&__s[0] = v42;
      uint64_t v26 = 1;
      uint64_t v41 = v22;
      do
      {
        uint64_t v42 = v25;
        uint64_t v27 = 0;
        uint64_t v28 = (uint64_t *)__s;
        do
        {
          if (a4)
          {
            if ((a4(1, &firebloom_null_iv, v28, v28, 16) & 1) == 0) {
              goto LABEL_6;
            }
          }
          else
          {
            cccbc_clear_iv();
            firebloom_cbc_update_f(v14, v43, (uint64_t)v17, 0x10uLL);
          }
          uint64_t v29 = *v28;
          v28 += 2;
          unint64_t v30 = v29 ^ bswap64(v26 + v27++);
          *(void *)&__s[v27 % v22] = v30;
        }
        while (v23 != v27);
        uint64_t v25 = v42 + 1;
        v26 += v41;
      }
      while (v42 != 5);
      char v31 = v38;
      void *v38 = *(void *)&__s[0];
      unsigned int v32 = v31 + 1;
      uint64_t v33 = (uint64_t *)__s + 1;
      do
      {
        uint64_t v34 = *v33;
        v33 += 2;
        *v32++ = v34;
        --v23;
      }
      while (v23);
      uint64_t v18 = 0;
      unint64_t *v40 = v37 & 0xFFFFFFF8;
LABEL_30:
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      if (a4) {
        return v18;
      }
LABEL_31:
      cc_clear();
      return v18;
    }
  }
LABEL_6:
  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

uint64_t rfc3394_wrap_legacy(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), uint64_t *a5, unsigned int a6, void *a7, _DWORD *a8)
{
  unint64_t v11 = *a8;
  uint64_t v9 = rfc3394_wrap(a1, a2, a3, a4, a5, a6, a7, &v11);
  REQUIRE_func(HIDWORD(v11) == 0, 171, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t rfc3394_unwrap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, void *, unint64_t *, unint64_t *, uint64_t), void *a5, unint64_t a6, void *a7, void *a8)
{
  uint64_t v45 = a5;
  uint64_t v43 = a1;
  uint64_t v48 = *MEMORY[0x263EF8340];
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = ccaes_cbc_decrypt_mode();
  MEMORY[0x270FA5388]();
  uint64_t v46 = (uint64_t)&v37 - v15;
  bzero((char *)&v37 - v15, v15);
  MEMORY[0x270FA5388]();
  uint64_t v17 = (char *)&v37 - v16;
  bzero((char *)&v37 - v16, v16);
  uint64_t v18 = 0xFFFFFFFFLL;
  if (HIDWORD(a6)) {
    goto LABEL_33;
  }
  uint64_t v39 = a3;
  unsigned int v19 = a6 >> 3;
  if ((a6 >> 3) - 6 < 0xFFFFFFFC) {
    goto LABEL_33;
  }
  v40 = &v37;
  uint64_t v41 = a8;
  v38 = a7;
  unint64_t v44 = a6;
  if (!a4)
  {
    BOOL v20 = (a2 & 0xFFFFFFFFFFFFFFF7) == 0x10 || a2 == 32;
    if (!v20 || !a8 || *a8 < a6 - 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_34;
    }
    cccbc_init();
    goto LABEL_15;
  }
  if (a8 && *v41 >= v44 - 8)
  {
LABEL_15:
    *(void *)&__s[0] = *v45;
    uint64_t v21 = v19 - 1;
    if (v19 != 1)
    {
      unsigned int v22 = (void *)__s + 1;
      uint64_t v23 = v45 + 1;
      uint64_t v24 = v19 - 1;
      do
      {
        uint64_t v25 = *v23++;
        *unsigned int v22 = v25;
        v22 += 2;
        --v24;
      }
      while (v24);
    }
    int v26 = 6 * v19 - 6;
    LODWORD(v43) = 1 - v19;
    int v27 = 5;
    uint64_t v42 = (unint64_t *)&__s[v19 - 2];
    do
    {
      LODWORD(v45) = v27;
      if (v44 >= 0x10)
      {
        uint64_t v28 = v42;
        int v29 = v21;
        unsigned int v30 = v26;
        do
        {
          *uint64_t v28 = *(void *)&__s[v29 % v21] ^ bswap64(v30);
          if (a4)
          {
            if ((a4(0, &firebloom_null_iv, v28, v28, 16) & 1) == 0) {
              goto LABEL_6;
            }
          }
          else
          {
            cccbc_clear_iv();
            firebloom_cbc_update_f(v14, v46, (uint64_t)v17, 0x10uLL);
          }
          --v30;
          v28 -= 2;
          BOOL v31 = __OFSUB__(v29--, 1);
        }
        while (!((v29 < 0) ^ v31 | (v29 == 0)));
      }
      int v27 = v45 - 1;
      v26 += v43;
    }
    while (v45);
    if (*(void *)&__s[0] == v39)
    {
      unsigned int v32 = v38;
      if (v21)
      {
        uint64_t v33 = (uint64_t *)__s + 1;
        uint64_t v34 = v21;
        do
        {
          uint64_t v35 = *v33;
          v33 += 2;
          *v32++ = v35;
          --v34;
        }
        while (v34);
      }
      uint64_t v18 = 0;
      *uint64_t v41 = (8 * v21);
    }
    else
    {
      uint64_t v18 = 0xFFFFFFFFLL;
    }
LABEL_33:
    memset_s(__s, 0x40uLL, 0, 0x40uLL);
    if (a4) {
      return v18;
    }
LABEL_34:
    cc_clear();
    return v18;
  }
LABEL_6:
  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

uint64_t rfc3394_unwrap_legacy(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(void, void *, unint64_t *, unint64_t *, uint64_t), void *a5, unsigned int a6, void *a7, _DWORD *a8)
{
  uint64_t v11 = *a8;
  uint64_t v9 = rfc3394_unwrap(a1, a2, a3, a4, a5, a6, a7, &v11);
  REQUIRE_func(HIDWORD(v11) == 0, 261, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t rfc3394_wrapped_size_legacy(unsigned int a1, _DWORD *a2)
{
  uint64_t v2 = a1 + 15;
  uint64_t v3 = v2 << 31 >> 31;
  BOOL v4 = v3 != v2 || v3 < 0;
  int v5 = v4;
  if (!v4) {
    *a2 = v3 & 0xFFFFFFF8;
  }
  return v5 ^ 1u;
}

uint64_t rfc3394_wrapped_size(unint64_t a1, unint64_t *a2)
{
  uint64_t v2 = a1 >= 0xFFFFFFFFFFFFFFF1;
  BOOL v3 = v2 << 63 >> 63 != v2 || v2 << 63 >> 63 == -1;
  int v4 = v3;
  if (!v3) {
    *a2 = (a1 + 15) & 0xFFFFFFFFFFFFFFF8;
  }
  return v4 ^ 1u;
}

BOOL rfc3394_unwrapped_size_legacy(unsigned int a1, unsigned int *a2)
{
  unsigned int v2 = a1 - 8;
  BOOL result = a1 > 7;
  *a2 = v2;
  return result;
}

BOOL rfc3394_unwrapped_size(unint64_t a1, unint64_t *a2)
{
  unint64_t v2 = a1 - 8;
  BOOL result = a1 > 7;
  *a2 = v2;
  return result;
}

uint64_t aks_fv_new_vek()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  int v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v11 = v0;
  v22[0] = *MEMORY[0x263EF8340];
  bzero(__s, 0x1000uLL);
  *(void *)&long long v18 = __s;
  *((void *)&v18 + 1) = v22;
  size_t v19 = 4096;
  uint64_t v12 = 3758097090;
  if (v6 && v4)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (!aks_client_connection)
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fv_new_vek", ":", 179, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v12 = 3758097084;
      goto LABEL_16;
    }
    mach_port_t v14 = aks_client_connection;
    if (!ccder_blob_encode_body_tl()
      || !der_utils_encode_fv_data(&v18, v8)
      || !der_utils_encode_fv_data(&v18, v10)
      || !der_utils_encode_fv_params(&v18, v11)
      || !ccder_blob_encode_tl())
    {
      goto LABEL_14;
    }
    input[0] = *((void *)&v18 + 1);
    input[1] = (uint64_t)v22 - *((void *)&v18 + 1);
    uint64_t v15 = IOConnectCallMethod(v14, 0x4Au, input, 2u, 0, 0, 0, 0, __s, &v19);
    if (v15)
    {
      uint64_t v12 = v15;
      goto LABEL_16;
    }
    *(void *)&long long v17 = __s;
    *((void *)&v17 + 1) = &__s[v19];
    if (!ccder_blob_decode_range() || !der_utils_decode_fv_data(&v17, 0, v4)) {
      goto LABEL_14;
    }
    if (!v2)
    {
      uint64_t v12 = 0;
      goto LABEL_16;
    }
    uint64_t v12 = 0;
    if ((der_utils_decode_fv_key(&v17, 0, v2) & 1) == 0) {
LABEL_14:
    }
      uint64_t v12 = 3758097098;
  }
LABEL_16:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v12;
}

uint64_t get_aks_client_connection()
{
  if (get_aks_client_dispatch_queue_onceToken != -1) {
    dispatch_once(&get_aks_client_dispatch_queue_onceToken, &__block_literal_global_173);
  }
  dispatch_sync((dispatch_queue_t)get_aks_client_dispatch_queue_connection_queue, &__block_literal_global_152);
  uint64_t result = get_aks_client_connection_connection;
  if (!get_aks_client_connection_connection)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return get_aks_client_connection_connection;
  }
  return result;
}

unint64_t _aks_save_file(char *a1, const void *a2, size_t a3)
{
  unint64_t v3 = (unint64_t)a1;
  if (a1)
  {
    int v6 = open_dprotected_np(a1, 1793, 4, 0, 384);
    if (v6 == -1)
    {
      uint64_t v10 = __error();
      uint64_t v11 = strerror(*v10);
      syslog(3, "could not create file: %s (%s)\n", (const char *)v3, v11);
      return 0;
    }
    else
    {
      int v7 = v6;
      ssize_t v8 = write(v6, a2, a3);
      unint64_t v3 = v8 != -1;
      if (v8 == -1)
      {
        uint64_t v12 = __error();
        char v13 = strerror(*v12);
        syslog(3, "failed to write restore bag to disk %s\n", v13);
      }
      close(v7);
    }
  }
  return v3;
}

const char *_aks_load_file(char *a1, void *a2, size_t *a3)
{
  unint64_t v3 = a1;
  memset(&v14, 0, sizeof(v14));
  if (a1)
  {
    if (!stat(a1, &v14))
    {
      size_t st_size = v14.st_size;
      int v7 = open(v3, 0);
      if (v7 == -1)
      {
        uint64_t v12 = __error();
        char v13 = strerror(*v12);
        syslog(3, "could not open file: %s (%s)\n", v3, v13);
      }
      else
      {
        int v8 = v7;
        uint64_t v9 = calloc(st_size, 1uLL);
        unint64_t v3 = (const char *)(v9 != 0);
        if (!v9)
        {
LABEL_7:
          close(v8);
          return v3;
        }
        uint64_t v10 = v9;
        if (read(v8, v9, st_size) == st_size)
        {
          *a2 = v10;
          *a3 = st_size;
          goto LABEL_7;
        }
        close(v8);
        free(v10);
      }
    }
    return 0;
  }
  return v3;
}

uint64_t aks_delete_xart_leak(unsigned int a1, const void *a2)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x6Cu, input, 1u, a2, 0x10uLL, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_delete_xart_leak", ":", 268, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

char *_iterate_path(char *result, uint64_t a2, uint64_t a3)
{
  v9[2] = *(char **)MEMORY[0x263EF8340];
  if (result)
  {
    v9[0] = result;
    v9[1] = 0;
    uint64_t result = (char *)fts_open(v9, 84, 0);
    if (result)
    {
      uint64_t v5 = (FTS *)result;
      int v6 = fts_read((FTS *)result);
      if (v6)
      {
        int v7 = v6;
        do
        {
          int fts_info = v7->fts_info;
          if (fts_info != 6)
          {
            if (fts_info == 1)
            {
              if (a2)
              {
                if (((*(uint64_t (**)(uint64_t, FTSENT *))(a2 + 16))(a2, v7) & 1) == 0) {
                  fts_set(v5, v7, 4);
                }
              }
            }
            else if (a3 && fts_info == 8)
            {
              (*(void (**)(uint64_t, FTSENT *))(a3 + 16))(a3, v7);
            }
          }
          int v7 = fts_read(v5);
        }
        while (v7);
      }
      return (char *)fts_close(v5);
    }
  }
  return result;
}

char *aks_dump_path(char *result, int a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (result)
  {
    unint64_t v3 = result;
    bzero(v8, 0x400uLL);
    uint64_t result = realpath_DARWIN_EXTSN(v3, v8);
    if (result)
    {
      v6[0] = MEMORY[0x263EF8330];
      v6[1] = 0x40000000;
      v6[2] = __aks_dump_path_block_invoke;
      v6[3] = &__block_descriptor_tmp;
      int v7 = a2;
      v4[0] = MEMORY[0x263EF8330];
      v4[1] = 0x40000000;
      v4[2] = __aks_dump_path_block_invoke_2;
      v4[3] = &__block_descriptor_tmp_127;
      int v5 = a2;
      return _iterate_path(v8, (uint64_t)v6, (uint64_t)v4);
    }
  }
  return result;
}

uint64_t __aks_dump_path_block_invoke(uint64_t a1, uint64_t a2)
{
  int path_class = _get_path_class(*(const char **)(a2 + 48));
  int v5 = *(_DWORD *)(a1 + 32);
  if (v5 == -1 || path_class == v5) {
    printf(" dir: %s %i\n", *(const char **)(a2 + 48), path_class);
  }
  return 1;
}

uint64_t _get_path_class(const char *a1)
{
  int v1 = open_dprotected_np(a1, 0, 0, 1);
  if (v1 == -1) {
    return 0xFFFFFFFFLL;
  }
  int v2 = v1;
  uint64_t v3 = fcntl(v1, 63);
  if ((v2 & 0x80000000) == 0) {
    close(v2);
  }
  return v3;
}

uint64_t __aks_dump_path_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result = _get_path_class(*(const char **)(a2 + 48));
  int v5 = *(_DWORD *)(a1 + 32);
  if (v5 == -1 || result == v5) {
    return printf("file: %s %i\n", *(const char **)(a2 + 48), result);
  }
  return result;
}

uint64_t aks_fs_supports_enhanced_apfs()
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  io_registry_entry_t v0 = IORegistryEntryFromPath(*MEMORY[0x263F0EC90], "IODeviceTree:/filesystems");
  if (v0)
  {
    io_object_t v1 = v0;
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v0, @"e-apfs", (CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
    BOOL v3 = CFProperty != 0;
    if (CFProperty) {
      CFRelease(CFProperty);
    }
    IOObjectRelease(v1);
  }
  else
  {
    BOOL v3 = 0;
  }
  size_t __len = 1023;
  bzero(__big, 0x400uLL);
  if ((_aks_check_apfs_shared_datavolume_bootarg_init & 1) == 0)
  {
    if (!sysctlbyname("kern.bootargs", __big, &__len, 0, 0) && strnstr(__big, "-apfs_shared_datavolume", __len)) {
      _aks_check_apfs_shared_datavolume_bootarg_value = 1;
    }
    _aks_check_apfs_shared_datavolume_bootarg_init = 1;
  }
  unsigned int v4 = _aks_check_apfs_shared_datavolume_bootarg_value;
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s ioreg: %d, boot_arg: %d%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fs_supports_enhanced_apfs", ":", 437, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, v3, _aks_check_apfs_shared_datavolume_bootarg_value, (const char *)&unk_22004A573);
  return v3 | v4;
}

uint64_t aks_fs_status(const char *a1)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  bzero(v4, 0x400uLL);
  bzero(__str, 0x400uLL);
  if (realpath_DARWIN_EXTSN(a1, v4))
  {
    snprintf(__str, 0x400uLL, "%s/mobile", v4);
    aks_fs_status_with_map(v4, (uint64_t)&sharedPathMap, 35);
    if ((aks_fs_supports_enhanced_apfs() & 1) == 0) {
      aks_fs_status_with_map(__str, (uint64_t)&userPathMap, 72);
    }
  }
  return 0;
}

void aks_fs_status_with_map(const char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  bzero(__str, 0x400uLL);
  memset(&v7, 0, sizeof(v7));
  if (a3)
  {
    uint64_t v6 = a2 + 16;
    do
    {
      snprintf(__str, 0x400uLL, "%s%s", a1, *(const char **)(v6 - 16));
      if (stat(__str, &v7))
      {
        printf("stat failed: %s\n");
      }
      else
      {
        _get_path_class(__str);
        printf("%s: mode=%o, u/g=%i:%i class=%i%s\n");
      }
      v6 += 48;
      --a3;
    }
    while (a3);
  }
}

uint64_t aks_user_fs_status(const char *a1)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  bzero(v3, 0x400uLL);
  if (realpath_DARWIN_EXTSN(a1, v3)) {
    aks_fs_status_with_map(v3, (uint64_t)&userPathMap, 72);
  }
  return 0;
}

const char *aks_show_allowlist()
{
  puts("shared allow list:");
  aks_show_allowlist_with_map("<var>", (uint64_t)&sharedPathMap, 35);
  puts("user allow list:");
  return aks_show_allowlist_with_map("<user>", (uint64_t)&userPathMap, 72);
}

const char *aks_show_allowlist_with_map(const char *result, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    uint64_t v4 = result;
    uint64_t v5 = (const char **)(a2 + 16);
    uint64_t v6 = (const char **)(a2 + 16);
    do
    {
      char v7 = *(unsigned char *)v6;
      v6 += 6;
      if (v7) {
        uint64_t result = (const char *)printf("%s%s\n", v4, *(v5 - 2));
      }
      uint64_t v5 = v6;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t aks_fv_new_kek()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  int v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  unsigned int v8 = v7;
  uint64_t v9 = v0;
  uint64_t v20 = *MEMORY[0x263EF8340];
  bzero(__s, 0x1000uLL);
  *(void *)&long long v16 = __s;
  *((void *)&v16 + 1) = &v20;
  size_t v17 = 4096;
  uint64_t v10 = 3758097090;
  if (v4 && v2)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      mach_port_t v12 = aks_client_connection;
      if (!ccder_blob_encode_body_tl()
        || !der_utils_encode_fv_data(&v16, v6)
        || !der_utils_encode_fv_params(&v16, v9)
        || !ccder_blob_encode_tl())
      {
        goto LABEL_10;
      }
      input[0] = v8;
      input[1] = *((void *)&v16 + 1);
      uint64_t input[2] = (uint64_t)&v20 - *((void *)&v16 + 1);
      uint64_t v13 = IOConnectCallMethod(v12, 0x4Cu, input, 3u, 0, 0, 0, 0, __s, &v17);
      if (v13)
      {
        uint64_t v10 = v13;
        goto LABEL_12;
      }
      *(void *)&long long v15 = __s;
      *((void *)&v15 + 1) = &__s[v17];
      if (!ccder_blob_decode_range() || (uint64_t v10 = 0, (der_utils_decode_fv_data(&v15, 0, v2) & 1) == 0)) {
LABEL_10:
      }
        uint64_t v10 = 3758097098;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fv_new_kek", ":", 508, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v10 = 3758097084;
    }
  }
LABEL_12:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v10;
}

uint64_t aks_fv_new_sibling_vek()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v0;
  uint64_t v20 = *MEMORY[0x263EF8340];
  bzero(__s, 0x1000uLL);
  *(void *)&long long v16 = __s;
  *((void *)&v16 + 1) = &v20;
  size_t v17 = 4096;
  uint64_t v10 = 3758097090;
  if (v6 && v4)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (!aks_client_connection)
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fv_new_sibling_vek", ":", 543, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v10 = 3758097084;
      goto LABEL_15;
    }
    mach_port_t v12 = aks_client_connection;
    if (!ccder_blob_encode_body_tl()
      || !der_utils_encode_fv_data(&v16, v8)
      || !der_utils_encode_fv_params(&v16, v9)
      || !ccder_blob_encode_tl())
    {
      goto LABEL_13;
    }
    input[0] = *((void *)&v16 + 1);
    input[1] = (uint64_t)&v20 - *((void *)&v16 + 1);
    uint64_t v13 = IOConnectCallMethod(v12, 0x63u, input, 2u, 0, 0, 0, 0, __s, &v17);
    if (v13)
    {
      uint64_t v10 = v13;
      goto LABEL_15;
    }
    *(void *)&long long v15 = __s;
    *((void *)&v15 + 1) = &__s[v17];
    if (!ccder_blob_decode_range() || !der_utils_decode_fv_data(&v15, 0, v4)) {
      goto LABEL_13;
    }
    if (!v2)
    {
      uint64_t v10 = 0;
      goto LABEL_15;
    }
    uint64_t v10 = 0;
    if ((der_utils_decode_fv_key(&v15, 0, v2) & 1) == 0) {
LABEL_13:
    }
      uint64_t v10 = 3758097098;
  }
LABEL_15:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v10;
}

uint64_t aks_fv_rewrap_kek()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  uint64_t v11 = v0;
  v22[0] = *MEMORY[0x263EF8340];
  bzero(__s, 0x1000uLL);
  *(void *)&long long v18 = __s;
  *((void *)&v18 + 1) = v22;
  size_t v19 = 4096;
  uint64_t v12 = 3758097090;
  if (v8 && v6 && v4 && v2)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      mach_port_t v14 = aks_client_connection;
      if (!der_utils_encode_fv_data(&v18, v4)
        || !ccder_blob_encode_body_tl()
        || !der_utils_encode_fv_data(&v18, v8)
        || !der_utils_encode_fv_data(&v18, v10)
        || !der_utils_encode_fv_params(&v18, v11)
        || !ccder_blob_encode_tl())
      {
        goto LABEL_14;
      }
      input[0] = *((void *)&v18 + 1);
      input[1] = (uint64_t)v22 - *((void *)&v18 + 1);
      uint64_t v15 = IOConnectCallMethod(v14, 0x4Du, input, 2u, 0, 0, 0, 0, __s, &v19);
      if (v15)
      {
        uint64_t v12 = v15;
        goto LABEL_16;
      }
      *(void *)&long long v17 = __s;
      *((void *)&v17 + 1) = &__s[v19];
      if (!ccder_blob_decode_range() || (uint64_t v12 = 0, (der_utils_decode_fv_data(&v17, 0, v2) & 1) == 0)) {
LABEL_14:
      }
        uint64_t v12 = 3758097098;
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fv_rewrap_kek", ":", 582, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v12 = 3758097084;
    }
  }
LABEL_16:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v12;
}

uint64_t aks_fv_set_protection()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  long long v18 = v1;
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v9 = v8;
  unsigned int v11 = v10;
  uint64_t v12 = v0;
  v24[0] = *MEMORY[0x263EF8340];
  uint64_t v13 = 3758097098;
  bzero(__s, 0x1000uLL);
  *(void *)&long long v20 = __s;
  *((void *)&v20 + 1) = v24;
  size_t v21 = 4096;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fv_set_protection", ":", 616, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v13 = 3758097084;
    goto LABEL_14;
  }
  mach_port_t v15 = aks_client_connection;
  if (der_utils_encode_fv_data(&v20, v3)
    && der_utils_encode_fv_data(&v20, v5)
    && der_utils_encode_fv_data(&v20, v7)
    && der_utils_encode_fv_params(&v20, v12)
    && ccder_blob_encode_tl())
  {
    input[0] = v11;
    input[1] = v9;
    uint64_t input[2] = *((void *)&v20 + 1);
    uint64_t input[3] = (uint64_t)v24 - *((void *)&v20 + 1);
    uint64_t v16 = IOConnectCallMethod(v15, 0x54u, input, 4u, 0, 0, 0, 0, __s, &v21);
    if (v16)
    {
      uint64_t v13 = v16;
      goto LABEL_14;
    }
    *(void *)&long long v19 = __s;
    *((void *)&v19 + 1) = &__s[v21];
    if (!v21) {
      goto LABEL_13;
    }
    if (!ccder_blob_decode_range()) {
      goto LABEL_14;
    }
    if (!v18)
    {
LABEL_13:
      uint64_t v13 = 0;
      goto LABEL_14;
    }
    uint64_t v13 = 0;
    if ((der_utils_decode_fv_data(&v19, 0, v18) & 1) == 0) {
      uint64_t v13 = 3758097098;
    }
  }
LABEL_14:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v13;
}

uint64_t aks_fv_unwrap_vek_with_acm()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v10 = v9;
  unsigned int v12 = v11;
  uint64_t v13 = v0;
  v24[0] = *MEMORY[0x263EF8340];
  bzero(__s, 0x1000uLL);
  *(void *)&long long v20 = __s;
  *((void *)&v20 + 1) = v24;
  size_t v21 = 4096;
  if (!v6)
  {
    uint64_t v17 = 3758097090;
    goto LABEL_15;
  }
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fv_unwrap_vek_with_acm", ":", 653, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v17 = 3758097084;
    goto LABEL_15;
  }
  mach_port_t v15 = aks_client_connection;
  if (!der_utils_encode_fv_data(&v20, v4)
    || !der_utils_encode_fv_data(&v20, v6)
    || !der_utils_encode_fv_data(&v20, v8)
    || !der_utils_encode_fv_data(&v20, v10)
    || !der_utils_encode_fv_params(&v20, v13)
    || !ccder_blob_encode_tl())
  {
    goto LABEL_13;
  }
  input[0] = *((void *)&v20 + 1);
  input[1] = (uint64_t)v24 - *((void *)&v20 + 1);
  uint64_t input[2] = v12;
  uint64_t v16 = IOConnectCallMethod(v15, 0x4Bu, input, 3u, 0, 0, 0, 0, __s, &v21);
  if (v16)
  {
    uint64_t v17 = v16;
    goto LABEL_15;
  }
  *(void *)&long long v19 = __s;
  *((void *)&v19 + 1) = &__s[v21];
  if (!ccder_blob_decode_range()) {
    goto LABEL_13;
  }
  if (!v2)
  {
    uint64_t v17 = 0;
    goto LABEL_15;
  }
  uint64_t v17 = 0;
  if ((der_utils_decode_fv_key(&v19, 0, v2) & 1) == 0) {
LABEL_13:
  }
    uint64_t v17 = 3758097098;
LABEL_15:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v17;
}

uint64_t aks_fv_unwrap_vek_with_opts()
{
  return aks_fv_unwrap_vek_with_acm();
}

void aks_gather_stats(const char *a1, char a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (a1)
  {
    bzero(&v13, 0x878uLL);
    bzero(v12, 0x400uLL);
    if (realpath_DARWIN_EXTSN(a1, v12))
    {
      uint64_t v4 = (char *)malloc(0x818uLL);
      memset_s(v4, 0x818uLL, 0, 0x818uLL);
      v11[0] = MEMORY[0x263EF8330];
      v11[1] = 0x40000000;
      v11[2] = __aks_gather_stats_block_invoke_2;
      v11[3] = &__block_descriptor_tmp_140;
      v11[4] = v4;
      _iterate_path(v12, (uint64_t)&__block_literal_global_1, (uint64_t)v11);
      if (!statfs(v12, &v13))
      {
        if (a2) {
          printf("Free Blocks:%lld blocks of size:%d\n");
        }
        else {
          printf("%lld,%d\n");
        }
      }
      uint64_t v5 = v4 + 340;
      for (uint64_t i = 1; i != 5; ++i)
      {
        if (a2)
        {
          uint64_t v9 = &v4[296 * i];
          printf("%s:\n\tNum files:\t%u,\n\tNum hardlinks:\t%u,\n\tNum compressed:\t%u,\n\tTotal Size:\t%lld,\n\tMin File Size:\t%lld,\n\tMax File Size:\t%lld,\n", class_names[i], *(_DWORD *)v9, *((_DWORD *)v9 + 2), *((_DWORD *)v9 + 1), *((void *)v9 + 2), *((void *)v9 + 3), *((void *)v9 + 4));
          printf("\tSize Distribution:");
          printf("%i", *((_DWORD *)v9 + 10));
          for (uint64_t j = 0; j != 252; j += 4)
          {
            putchar(44);
            printf("%i", *(_DWORD *)&v5[j]);
          }
        }
        else
        {
          uint64_t v7 = &v4[296 * i];
          printf("%i,%u,%u,%u,%lld,%lld,%lld,", i, *(_DWORD *)v7, *((_DWORD *)v7 + 2), *((_DWORD *)v7 + 1), *((void *)v7 + 2), *((void *)v7 + 3), *((void *)v7 + 4));
          printf("%i", *((_DWORD *)v7 + 10));
          for (uint64_t k = 0; k != 252; k += 4)
          {
            putchar(44);
            printf("%i", *(_DWORD *)&v5[k]);
          }
        }
        putchar(10);
        v5 += 296;
      }
      free(v4);
    }
  }
}

uint64_t __aks_gather_stats_block_invoke()
{
  return 1;
}

uint64_t __aks_gather_stats_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result = _get_path_class(*(const char **)(a2 + 48));
  if ((result - 7) >= 0xFFFFFFFA)
  {
    uint64_t v5 = *(void *)(a2 + 96);
    int64_t v6 = *(void *)(v5 + 96);
    uint64_t v7 = *(void *)(a1 + 32);
    ++*(_DWORD *)(v7 + 296 * result);
    if (*(unsigned __int16 *)(v5 + 6) >= 2u) {
      ++*(_DWORD *)(v7 + 296 * result + 8);
    }
    if ((*(unsigned char *)(v5 + 116) & 0x20) != 0) {
      ++*(_DWORD *)(v7 + 296 * result + 4);
    }
    uint64_t v8 = v7 + 296 * result;
    int64_t v10 = *(void *)(v8 + 32);
    uint64_t v9 = (int64_t *)(v8 + 32);
    *(v9 - 2) += v6;
    if (v6 > v10) {
      *uint64_t v9 = v6;
    }
    uint64_t v11 = v7 + 296 * result;
    int64_t v14 = *(void *)(v11 + 24);
    unsigned int v12 = (int64_t *)(v11 + 24);
    int64_t v13 = v14;
    if (v14) {
      BOOL v15 = v6 < v13;
    }
    else {
      BOOL v15 = 1;
    }
    if (v15) {
      *unsigned int v12 = v6;
    }
    if (v6) {
      unint64_t v16 = v7 + 296 * result + 4 * (63 - __clz(v6));
    }
    else {
      unint64_t v16 = v7 + 296 * result;
    }
    ++*(_DWORD *)(v16 + 40);
  }
  return result;
}

uint64_t aks_kext_set_options(unsigned int a1, uint64_t a2)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  input[0] = 1;
  input[1] = a1;
  uint64_t input[2] = a2;
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x56u, input, 3u, 0, 0, &output, &outputCnt, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_kext_set_options", ":", 820, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_kext_get_options(unsigned int a1, uint64_t *a2)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  uint64_t v2 = 3758097084;
  if (!a2) {
    return 3758097090;
  }
  input[0] = 0;
  input[1] = a1;
  uint64_t input[2] = 0;
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v2 = IOConnectCallMethod(aks_client_connection, 0x56u, input, 3u, 0, 0, &output, &outputCnt, 0, 0);
    if (!v2) {
      *a2 = output;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_kext_get_options", ":", 841, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v2;
}

uint64_t aks_internal_state()
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x10u, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_internal_state", ":", 857, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_run_internal_test(unsigned int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x86u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_run_internal_test", ":", 871, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_stash_escrow()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  int v6 = v5;
  uint64_t v8 = v7;
  int v10 = v9;
  uint64_t v12 = v11;
  unsigned int v14 = v13;
  int v15 = v0;
  uint64_t v23 = *MEMORY[0x263EF8340];
  bzero(__src, 0x8000uLL);
  size_t __count = 0x8000;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = v15;
    input[1] = v14;
    uint64_t input[2] = v12;
    uint64_t input[3] = v10;
    if (!v14 || (uint64_t v17 = 3758097090, v4) && v2)
    {
      uint64_t v17 = IOConnectCallMethod(aks_client_connection, 0x36u, input, 4u, v8, v6, 0, 0, __src, &__count);
      if (!v17 && v14)
      {
        long long v18 = calloc(__count, 1uLL);
        void *v4 = v18;
        if (v18)
        {
          memcpy(v18, __src, __count);
          uint64_t v17 = 0;
          _DWORD *v2 = __count;
        }
        else
        {
          uint64_t v17 = 3758097085;
        }
      }
    }
  }
  else
  {
    uint64_t v17 = 3758097084;
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_stash_escrow", ":", 890, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v17;
}

void __get_aks_client_connection_block_invoke()
{
  if (!get_aks_client_connection_connection) {
    get_aks_client_connection_connection = _copy_aks_client_connection("IOService:/IOResources/AppleKeyStore", "AppleKeyStore");
  }
}

uint64_t get_akstest_client_connection()
{
  if (get_aks_client_dispatch_queue_onceToken != -1) {
    dispatch_once(&get_aks_client_dispatch_queue_onceToken, &__block_literal_global_173);
  }
  dispatch_sync((dispatch_queue_t)get_aks_client_dispatch_queue_connection_queue, &__block_literal_global_157);
  uint64_t result = get_akstest_client_connection_connection;
  if (!get_akstest_client_connection_connection)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStoreTest");
    return get_akstest_client_connection_connection;
  }
  return result;
}

void __get_akstest_client_connection_block_invoke()
{
  if (!get_akstest_client_connection_connection) {
    get_akstest_client_connection_connection = _copy_aks_client_connection("IOService:/IOResources/AppleKeyStoreTest", "AppleKeyStoreTest");
  }
}

uint64_t akstest_new_key(mach_port_t a1, const void *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, _DWORD *a7)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  input[0] = a4;
  input[1] = a3;
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  bzero(outputStruct, 0x400uLL);
  size_t v19 = 1024;
  uint64_t v11 = IOConnectCallMethod(a1, 0xFu, input, 2u, a2, 0x10uLL, &output, &outputCnt, outputStruct, &v19);
  if (v11) {
    return v11;
  }
  uint64_t v17 = 3758097084;
  if (outputCnt == 1)
  {
    *a7 = output;
    if (aks_unpack_data(outputStruct, v19, 3u, v12, v13, v14, v15, v16, a5)) {
      return 3758097084;
    }
    else {
      return 0;
    }
  }
  return v17;
}

uint64_t akstest_new_ekwk(mach_port_t a1, const void *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, _DWORD *a7, uint64_t a8, uint64_t a9, _DWORD *a10, uint64_t a11, uint64_t a12, _DWORD *a13)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  input[0] = a4;
  input[1] = a3;
  uint64_t output = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint32_t outputCnt = 3;
  bzero(outputStruct, 0x400uLL);
  size_t v26 = 1024;
  uint64_t v17 = IOConnectCallMethod(a1, 0x13u, input, 2u, a2, 0x10uLL, &output, &outputCnt, outputStruct, &v26);
  if (v17) {
    return v17;
  }
  uint64_t v23 = 3758097084;
  if (outputCnt == 3)
  {
    int v24 = v30;
    *a7 = output;
    *a10 = v24;
    *a13 = v31;
    if (aks_unpack_data(outputStruct, v26, 5u, v18, v19, v20, v21, v22, a5)) {
      return 3758097084;
    }
    else {
      return 0;
    }
  }
  return v23;
}

uint64_t akstest_new_ek(mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, size_t *a8)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a3;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, a4, a5, a6, (uint64_t)a7, (uint64_t)a8, a2);
  uint64_t v11 = IOConnectCallMethod(a1, 0x14u, input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, a7, a8);
  free(*(void **)&inputStructCnt[1]);
  return v11;
}

uint64_t akstest_rewrap_ek(mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, uint64_t a10, uint64_t a11, unsigned int a12, void *outputStruct, size_t *a14, _DWORD *a15)
{
  uint64_t input[4] = *MEMORY[0x263EF8340];
  input[0] = a3;
  input[1] = a6;
  uint64_t input[2] = a9;
  uint64_t input[3] = a12;
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 4, a4, a5, a6, a7, a8, a2);
  uint64_t v16 = IOConnectCallMethod(a1, 0x15u, input, 4u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], &output, &outputCnt, outputStruct, a14);
  if (v16)
  {
    uint64_t v17 = v16;
  }
  else if (outputCnt == 1)
  {
    uint64_t v17 = 0;
    *a15 = output;
  }
  else
  {
    uint64_t v17 = 3758097084;
  }
  free(*(void **)&inputStructCnt[1]);
  return v17;
}

uint64_t akstest_unwrap_key(mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  input[0] = a3;
  input[1] = a6;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(outputStruct, 0x400uLL);
  size_t outputStructCnt = 1024;
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v10, v11, v12, v13, v14, a2);
  uint64_t v15 = IOConnectCallMethod(a1, 0x10u, input, 2u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, outputStruct, &outputStructCnt);
  if (v15)
  {
    uint64_t v21 = v15;
  }
  else if (aks_unpack_data(outputStruct, outputStructCnt, 2u, v16, v17, v18, v19, v20, a7))
  {
    uint64_t v21 = 3758097084;
  }
  else
  {
    uint64_t v21 = 0;
  }
  free(*(void **)&inputStructCnt[1]);
  return v21;
}

uint64_t akstest_unwrap_ek(mach_port_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, unsigned int a9, uint64_t a10)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  input[0] = a3;
  input[1] = a6;
  uint64_t input[2] = a9;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(outputStruct, 0x400uLL);
  size_t v25 = 1024;
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 3, v12, v13, v14, v15, v16, a2);
  uint64_t v17 = IOConnectCallMethod(a1, 0x17u, input, 3u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, outputStruct, &v25);
  if (v17)
  {
    uint64_t v23 = v17;
  }
  else if (aks_unpack_data(outputStruct, v25, 2u, v18, v19, v20, v21, v22, a10))
  {
    uint64_t v23 = 3758097084;
  }
  else
  {
    uint64_t v23 = 0;
  }
  free(*(void **)&inputStructCnt[1]);
  return v23;
}

uint64_t akstest_check_class(mach_port_t a1, void *inputStruct, unsigned int a3)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a3;
  return IOConnectCallMethod(a1, 0x11u, input, 1u, inputStruct, 0x10uLL, 0, 0, 0, 0);
}

uint64_t akstest_last_user(mach_port_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a2;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 1, a4, a5, a6, a7, a8, a3);
  uint64_t v9 = IOConnectCallMethod(a1, 0x12u, input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, 0, 0);
  free(*(void **)&inputStructCnt[1]);
  return v9;
}

uint64_t aks_get_internal_info_for_key()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  int v6 = v5;
  input[1] = *MEMORY[0x263EF8340];
  input[0] = v0;
  bzero(__src, 0x8000uLL);
  size_t __count = 0x8000;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v6) {
      size_t v8 = 18;
    }
    else {
      size_t v8 = 0;
    }
    uint64_t v9 = IOConnectCallMethod(aks_client_connection, 0x5Du, input, 1u, v6, v8, 0, 0, __src, &__count);
    size_t v10 = __count;
    if (v9)
    {
      uint64_t v12 = v9;
    }
    else if (__count - 32769 < 0xFFFFFFFFFFFF8000)
    {
      uint64_t v12 = 3758097090;
    }
    else
    {
      uint64_t v11 = calloc(__count, 1uLL);
      void *v4 = v11;
      size_t v10 = __count;
      if (v11)
      {
        size_t *v2 = __count;
        memcpy(v11, __src, v10);
        uint64_t v12 = 0;
        size_t v10 = __count;
      }
      else
      {
        uint64_t v12 = 3758097085;
      }
    }
  }
  else
  {
    uint64_t v12 = 3758097084;
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_get_internal_info_for_key", ":", 1246, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    size_t v10 = 0x8000;
  }
  memset_s(__src, v10, 0, v10);
  return v12;
}

dispatch_queue_t __get_aks_client_dispatch_queue_block_invoke()
{
  dispatch_queue_t result = dispatch_queue_create("aks-client-queue", 0);
  get_aks_client_dispatch_queue_connection_queue = (uint64_t)result;
  return result;
}

uint64_t _copy_aks_client_connection(char *path, const char *a2)
{
  kern_return_t v7;
  CFDictionaryRef v8;
  io_service_t MatchingService;
  io_object_t v10;
  uint64_t result;
  kern_return_t v12;
  io_connect_t connect;

  connect = 0;
  mach_port_t v3 = *MEMORY[0x263F0EC90];
  io_service_t v4 = IORegistryEntryFromPath(*MEMORY[0x263F0EC90], path);
  int v5 = (task_port_t *)MEMORY[0x263EF8960];
  if (!v4 || (io_object_t v6 = v4, v7 = IOServiceOpen(v4, *MEMORY[0x263EF8960], 0, &connect), IOObjectRelease(v6), v7))
  {
    size_t v8 = IOServiceMatching(a2);
    MatchingService = IOServiceGetMatchingService(v3, v8);
    if (MatchingService)
    {
      size_t v10 = MatchingService;
      IOServiceOpen(MatchingService, *v5, 0, &connect);
      IOObjectRelease(v10);
    }
  }
  dispatch_queue_t result = connect;
  if (connect)
  {
    uint64_t v12 = IOConnectCallMethod(connect, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    dispatch_queue_t result = connect;
    if (v12)
    {
      IOServiceClose(connect);
      return 0;
    }
  }
  return result;
}

uint64_t sizeof_backup_bag()
{
  ccder_sizeof_implicit_uint64();
  ccder_sizeof_raw_octet_string();
  ccder_sizeof_raw_octet_string();
  ccder_sizeof_implicit_uint64();
  return ccder_sizeof();
}

uint64_t encode_backup_bag(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a2 + a3;
  if (!ccder_blob_encode_implicit_uint64()
    || !ccder_blob_encode_body_tl()
    || !ccder_blob_encode_body_tl()
    || !ccder_blob_encode_body_tl()
    || !ccder_blob_encode_implicit_uint64())
  {
    return 4294967273;
  }
  int v3 = ccder_blob_encode_tl();
  uint64_t result = 4294967273;
  if (v3)
  {
    if (a2 == v6) {
      return 0;
    }
    else {
      return 4294967273;
    }
  }
  return result;
}

uint64_t decode_backup_bag(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)&long long v6 = a1;
  *((void *)&v6 + 1) = a1 + a2;
  if (!ccder_blob_decode_range()
    || !der_utils_decode_implicit_uint64(&v6, 0x8000000000000000, a3)
    || !der_utils_decode_implicit_raw_octet_string_copy(&v6, 0x8000000000000001, (uint64_t)(a3 + 1), 16)
    || !der_utils_decode_implicit_raw_octet_string_copy(&v6, 0x8000000000000002, (uint64_t)(a3 + 3), 40)
    || !der_utils_decode_implicit_raw_octet_string_copy(&v6, 0x8000000000000003, (uint64_t)(a3 + 8), 16))
  {
    return 4294967277;
  }
  int v4 = der_utils_decode_implicit_uint64(&v6, 0x8000000000000004, a3 + 10);
  uint64_t result = 4294967277;
  if (v4)
  {
    if ((void)v6 == *((void *)&v6 + 1)) {
      return 0;
    }
    else {
      return 4294967277;
    }
  }
  return result;
}

uint64_t wrap_backup_bag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  memset(__s, 0, sizeof(__s));
  int v12 = 40;
  *(void *)a4 = 0;
  uuid_copy((unsigned __int8 *)(a4 + 8), (const unsigned __int8 *)(a1 + 32));
  *(void *)(a4 + 80) = 1;
  platform_read_random(a4 + 64, 0x10u);
  uint64_t v8 = ccsha256_di();
  if (firebloom_ccpbkdf2_hmac(v8, a3, a2, 16, a4 + 64, *(void *)(a4 + 80), 32, __s))
  {
    uint64_t v10 = 4294967286;
  }
  else
  {
    uint64_t v9 = rfc3394_wrap_legacy((uint64_t)__s, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, (uint64_t *)a1, 0x20u, (void *)(a4 + 24), &v12);
    if (v9)
    {
      uint64_t v10 = v9;
    }
    else if (v12 == 40)
    {
      uint64_t v10 = 0;
    }
    else
    {
      uint64_t v10 = 4294967286;
    }
  }
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v10;
}

uint64_t unwrap_backup_bag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  memset(__s, 0, sizeof(__s));
  int v12 = 32;
  if (*(void *)a1)
  {
    uint64_t v10 = 4294967284;
  }
  else
  {
    uint64_t v8 = ccsha256_di();
    if (firebloom_ccpbkdf2_hmac(v8, a3, a2, 16, a1 + 64, *(void *)(a1 + 80), 32, __s)) {
      goto LABEL_9;
    }
    uint64_t v9 = rfc3394_unwrap_legacy((uint64_t)__s, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, (void *)(a1 + 24), 0x28u, (void *)a4, &v12);
    if (v9)
    {
      uint64_t v10 = v9;
      goto LABEL_8;
    }
    if (v12 != 32)
    {
LABEL_9:
      uint64_t v10 = 4294967286;
    }
    else
    {
      cccurve25519_make_pub();
      if (uuid_compare((const unsigned __int8 *)(a1 + 8), (const unsigned __int8 *)(a4 + 32))) {
        uint64_t v10 = 4294967272;
      }
      else {
        uint64_t v10 = 0;
      }
    }
  }
LABEL_8:
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v10;
}

uint64_t aks_stash_create_for_bag_and_kek()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  int v4 = v3;
  uint64_t v6 = v5;
  unsigned int v8 = v7;
  unsigned int v10 = v9;
  int v11 = v0;
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v12 = 3758097098;
  bzero(v18, 0x1000uLL);
  *(void *)&long long v16 = v18;
  *((void *)&v16 + 1) = &v19;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v14 = aks_client_connection;
    if (der_utils_encode_fv_data(&v16, v2) && ccder_blob_encode_tl())
    {
      input[0] = v11;
      input[1] = v10;
      uint64_t input[2] = v6;
      uint64_t input[3] = v4;
      uint64_t input[4] = v8;
      uint64_t input[5] = *((void *)&v16 + 1);
      input[6] = (uint64_t)&v19 - *((void *)&v16 + 1);
      return IOConnectCallMethod(v14, 0x21u, input, 7u, 0, 0, 0, 0, 0, 0);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_stash_create_for_bag_and_kek", ":", 50, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  return v12;
}

uint64_t aks_stash_create()
{
  return aks_stash_create_for_bag_and_kek();
}

uint64_t aks_stash_load(int a1)
{
  return _aks_stash_load(a1, 0, 0);
}

uint64_t _aks_stash_load(int a1, unsigned int a2, BOOL *a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    uint64_t output = 0;
    uint32_t outputCnt = 1;
    uint64_t result = IOConnectCallMethod(aks_client_connection, 0x22u, input, 2u, 0, 0, &output, &outputCnt, 0, 0);
    if (!result)
    {
      uint64_t result = 0;
      if (a3) {
        *a3 = output != 0;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "_aks_stash_load", ":", 77, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  return result;
}

uint64_t aks_stash_verify(int a1, unsigned char *a2)
{
  BOOL v4 = 0;
  if (!a2) {
    return _aks_stash_load(a1, 1u, &v4);
  }
  *a2 = 0;
  uint64_t result = _aks_stash_load(a1, 1u, &v4);
  if (!result) {
    *a2 = v4;
  }
  return result;
}

uint64_t aks_stash_destroy()
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x25u, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_stash_destroy", ":", 125, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_stash_commit(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x24u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_stash_commit", ":", 138, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_stash_enable(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x33u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_stash_enable", ":", 154, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_stash_persist(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x35u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_stash_persist", ":", 170, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_prederived_free(void **a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1634431856) {
    return 0xFFFFFFFFLL;
  }
  free(a1[1]);
  free(a1);
  return 0;
}

uint64_t aks_prederived_create(int a1, uint64_t a2, unint64_t a3, int a4, void ***a5)
{
  mach_port_t v14 = 0;
  if (!a2 && a3) {
    return 0xFFFFFFFFLL;
  }
  if (_aks_prederived_create_ctx(a4, &v14) || (unsigned int v9 = calloc(0x20uLL, 1uLL)) == 0)
  {
    uint64_t v12 = 0xFFFFFFFFLL;
  }
  else
  {
    unsigned int v10 = v9;
    int v11 = _aks_prederive_passcode(v14, a2, a3, (uint64_t)v9);
    uint64_t v12 = 0xFFFFFFFFLL;
    if (a3 <= 0x7FFFFFFE
      && !v11
      && !_set_prederived_configuration(a1, a2, a3, (uint64_t)v10, (uint64_t)v14))
    {
      uint64_t v12 = 0;
      if (a5)
      {
        *a5 = v14;
        mach_port_t v14 = 0;
      }
    }
    memset_s(v10, 0x20uLL, 0, 0x20uLL);
    free(v10);
  }
  if (v14) {
    aks_prederived_free(v14);
  }
  return v12;
}

uint64_t _aks_prederived_create_ctx(int a1, void *a2)
{
  if ((a1 - 1) > 2 || a2 == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = calloc(0x20uLL, 1uLL);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = v6;
  *((void *)v6 + 2) = 20;
  unsigned int v8 = calloc(0x14uLL, 1uLL);
  *((void *)v7 + 1) = v8;
  if (!v8)
  {
LABEL_19:
    free(v7);
    return 0xFFFFFFFFLL;
  }
  _DWORD *v7 = 1634431856;
  v7[6] = a1;
  uint64_t result = CCRandomCopyBytes();
  if (result)
  {
    unsigned int v10 = (void *)*((void *)v7 + 1);
    if (v10) {
      free(v10);
    }
    goto LABEL_19;
  }
  if (a1 == 3) {
    int v9 = 2000;
  }
  else {
    int v9 = 10000000;
  }
  if (a1 == 2) {
    int v9 = 1000;
  }
  v7[1] = v9;
  *a2 = v7;
  return result;
}

uint64_t _aks_prederive_passcode(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*a1 != 1634431856 || !a2 && a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a4 && (a1[6] - 4) >= 0xFFFFFFFD)
  {
    ccsha256_di();
    if (ccpbkdf2_hmac()) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t _set_prederived_configuration(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  rsize_t __n = 0;
  __s = 0;
  uint64_t v10 = 3758097090;
  mach_port_t v14 = 0;
  if ((a2 || !a3) && a4 && a5)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      mach_port_t v12 = aks_client_connection;
      if (!encode_list_add_data(&v14, (uint64_t)der_key_config_prederived_salt, *(void *)(a5 + 8))
        && !encode_list_add_data(&v14, (uint64_t)der_key_config_prederived_passcode, a4)
        && !encode_list_add_number(&v14, (uint64_t)der_key_config_prederived_iterations, *(unsigned int *)(a5 + 4))&& !encode_list_add_number(&v14, (uint64_t)der_key_config_prederived_type, *(unsigned int *)(a5 + 24))&& (a3 < 1 || !encode_list_add_data(&v14, (uint64_t)der_key_passcode, a2))&& !encode_list_is_empty(&v14)&& !encode_list_dict(&v14, &__s, &__n))
      {
        input[0] = a1;
        input[1] = (uint64_t)__s;
        uint64_t input[2] = __n;
        uint64_t v10 = IOConnectCallMethod(v12, 0x1Eu, input, 3u, 0, 0, 0, 0, 0, 0);
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "_set_prederived_configuration", ":", 218, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v10 = 3758097084;
    }
  }
  encode_list_free(&v14);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v10;
}

uint64_t aks_prederived_is_enabled()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  int v3 = v0;
  uint64_t result = (uint64_t)calloc(0x20uLL, 1uLL);
  if (!result) {
    return result;
  }
  uint64_t v5 = result;
  *(_DWORD *)uint64_t result = 1634431856;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "_get_prederived_configuration", ":", 384, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
LABEL_16:
    aks_prederived_free((void **)v5);
    return 0;
  }
  mach_port_t v7 = aks_client_connection;
  bzero(outputStruct, 0x8000uLL);
  v13[0] = 0x8000;
  uint64_t input = v3;
  if (IOConnectCallMethod(v7, 0x1Fu, &input, 1u, 0, 0, 0, 0, outputStruct, v13) || v13[0] > 0x8000) {
    goto LABEL_16;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  long long v15 = 0u;
  long long v17 = 0u;
  uint64_t v18 = 0;
  long long v14 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  v13[1] = (size_t)der_key_config_prederived_salt;
  long long v16 = (unint64_t)der_key_config_prederived_iterations;
  uint64_t v19 = der_key_config_prederived_type;
  der_dict_iterate();
  uint64_t v9 = ccder_decode_tl();
  if (v9)
  {
    uint64_t v10 = (const void *)v9;
    int v11 = calloc(*(void *)(v5 + 16), 1uLL);
    *(void *)(v5 + 8) = v11;
    if (!v11)
    {
      int v12 = 0;
      if (!Mutable) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    memcpy(v11, v10, *(void *)(v5 + 16));
    *(_DWORD *)(v5 + 4) = der_get_number();
    *(_DWORD *)(v5 + 24) = der_get_number();
  }
  int v12 = 1;
  if (Mutable) {
LABEL_10:
  }
    CFRelease(Mutable);
LABEL_11:
  if (!v12 || !*(void *)(v5 + 16)) {
    goto LABEL_16;
  }
  uint64_t *v2 = v5;
  return 1;
}

uint64_t aks_prederived_unlock_keybag(int a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  memset(v9, 0, sizeof(v9));
  if (a3) {
    BOOL v4 = a2 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  BOOL v5 = v4 || a4 == 0;
  if (v5 || *a4 != 1634431856 || _aks_prederive_passcode(a4, a2, a3, (uint64_t)v9)) {
    uint64_t v7 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v7 = aks_unlock_bag(a1, (uint64_t)v9, 32);
  }
  memset_s(v9, 0x20uLL, 0, 0x20uLL);
  return v7;
}

uint64_t aks_unlock_bag(int a1, uint64_t a2, int a3)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    uint64_t input[2] = a3;
    return IOConnectCallMethod(aks_client_connection, 0xCu, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_unlock_bag", ":", 807, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_prederived_change_secret(int a1, uint64_t a2, int a3, uint64_t a4, int a5, void ***a6)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  memset(__s, 0, sizeof(__s));
  memset(v17, 0, sizeof(v17));
  long long v16 = 0;
  if (!a6) {
    goto LABEL_17;
  }
  uint64_t v7 = *a6;
  if (!*a6 || *(_DWORD *)v7 != 1634431856 || !a2 && a3) {
    goto LABEL_17;
  }
  if (!a4 && a5 || _aks_prederive_passcode(*a6, a2, a3, (uint64_t)__s)) {
    goto LABEL_17;
  }
  int v11 = _aks_prederived_create_ctx(*((_DWORD *)v7 + 6), &v16);
  int v12 = v16;
  if (v11 || (v13 = _aks_prederive_passcode(v16, a4, a5, (uint64_t)v17), int v12 = v16, v13))
  {
LABEL_15:
    if (v12) {
      aks_prederived_free(v12);
    }
LABEL_17:
    uint64_t v14 = 0xFFFFFFFFLL;
    goto LABEL_13;
  }
  if (_set_prederived_configuration(a1, (uint64_t)__s, 32, (uint64_t)v17, (uint64_t)v16))
  {
    int v12 = v16;
    goto LABEL_15;
  }
  aks_prederived_free(v7);
  uint64_t v14 = 0;
  *a6 = v16;
LABEL_13:
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  memset_s(v17, 0x20uLL, 0, 0x20uLL);
  return v14;
}

uint64_t aks_create_bag(uint64_t a1, int a2, unsigned int a3, _DWORD *a4)
{
  return _create_bag(a1, a2, 0, 0, a3, -1, a4);
}

uint64_t _create_bag(uint64_t a1, int a2, uint64_t a3, int a4, unsigned int a5, int a6, _DWORD *a7)
{
  input[6] = *MEMORY[0x263EF8340];
  uint64_t v14 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a7)
    {
      input[0] = a5;
      input[1] = a6;
      uint64_t input[2] = a1;
      uint64_t input[3] = a2;
      uint64_t input[4] = a3;
      uint64_t input[5] = a4;
      uint64_t output = 0;
      uint32_t outputCnt = 1;
      uint64_t v14 = IOConnectCallMethod(aks_client_connection, 2u, input, 6u, 0, 0, &output, &outputCnt, 0, 0);
      if (!v14) {
        *a7 = output;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "_create_bag", ":", 187, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v14;
}

uint64_t aks_create_escrow_bag(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  return _create_bag(a1, a2, 0, 0, 2u, a3, a4);
}

uint64_t aks_create_escrow_bag_with_auth(uint64_t a1, int a2, uint64_t a3, int a4, int a5, _DWORD *a6)
{
  return _create_bag(a3, a4, a1, a2, 2u, a5, a6);
}

uint64_t aks_create_sync_bag(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  return _create_bag(a1, a2, 0, 0, 0x8000002u, a3, a4);
}

uint64_t aks_create_sync_bag_with_auth(uint64_t a1, int a2, uint64_t a3, int a4, int a5, _DWORD *a6)
{
  return _create_bag(a3, a4, a1, a2, 0x8000002u, a5, a6);
}

uint64_t aks_invalidate_sync_bags()
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x42u, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_invalidate_sync_bags", ":", 544, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_unlock_with_sync_bag(const void *a1, int a2, uint64_t a3, int a4, int a5)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  uint64_t v10 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a1)
    {
      input[0] = a5;
      input[1] = a3;
      uint64_t input[2] = a4;
      return IOConnectCallMethod(aks_client_connection, 0x43u, input, 3u, a1, a2, 0, 0, 0, 0);
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_unlock_with_sync_bag", ":", 557, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v10;
}

uint64_t aks_load_bag(const void *a1, int a2, _DWORD *a3)
{
  output[1] = *MEMORY[0x263EF8340];
  uint64_t v6 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v6 = 3758097090;
    if (a1)
    {
      if (a3)
      {
        output[0] = 0;
        uint32_t outputCnt = 1;
        uint64_t v6 = IOConnectCallMethod(aks_client_connection, 6u, 0, 0, a1, a2, output, &outputCnt, 0, 0);
        if (!v6) {
          *a3 = output[0];
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_load_bag", ":", 574, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v6;
}

uint64_t aks_invalidate_bag(const void *a1, int a2)
{
  uint64_t v4 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a1) {
      return IOConnectCallMethod(aks_client_connection, 0x57u, 0, 0, a1, a2, 0, 0, 0, 0);
    }
    return 3758097090;
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_invalidate_bag", ":", 596, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v4;
}

uint64_t aks_unload_bag(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 4u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_unload_bag", ":", 612, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_unload_session_bags(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x37u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_unload_session_bags", ":", 629, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_save_bag()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  int v5 = v0;
  uint64_t v13 = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v7 = aks_client_connection;
    uint64_t result = 3758097090;
    if (v4)
    {
      if (v2)
      {
        bzero(__src, 0x8000uLL);
        size_t __count = 0x8000;
        uint64_t input = v5;
        uint64_t result = IOConnectCallMethod(v7, 3u, &input, 1u, 0, 0, 0, 0, __src, &__count);
        if (!result)
        {
          uint64_t v9 = calloc(__count, 1uLL);
          void *v4 = v9;
          if (v9)
          {
            memcpy(v9, __src, __count);
            uint64_t result = 0;
            _DWORD *v2 = __count;
          }
          else
          {
            return 3758097085;
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_save_bag", ":", 646, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  return result;
}

uint64_t aks_change_secret_opts(int a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, uint64_t a8, int a9, unsigned __int8 a10, unsigned int a11, unsigned int a12, _DWORD *a13)
{
  input[12] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a11;
    uint64_t input[2] = a10;
    uint64_t input[3] = a2;
    uint64_t input[4] = a3;
    uint64_t input[5] = a4;
    input[6] = a5;
    uint64_t input[7] = a6;
    input[8] = a7;
    input[9] = a8;
    input[10] = a9;
    input[11] = a12;
    uint64_t output = 0;
    uint32_t outputCnt = 1;
    uint64_t result = IOConnectCallMethod(aks_client_connection, 0xFu, input, 0xCu, 0, 0, &output, &outputCnt, 0, 0);
    if (a13)
    {
      if (!result) {
        *a13 = output;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_change_secret_opts", ":", 678, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  return result;
}

uint64_t aks_change_secret_se(int a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, uint64_t a8, int a9, unsigned __int8 a10, unsigned int a11, _DWORD *a12)
{
  return aks_change_secret_opts(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, 0, a12);
}

uint64_t aks_change_secret(int a1, uint64_t a2, int a3, uint64_t a4, int a5, unsigned int a6, _DWORD *a7)
{
  return aks_change_secret_opts(a1, a2, a3, a4, a5, 0, 0, 0, 0, 0xFFu, a6, 0, a7);
}

uint64_t aks_get_bag_uuid(int a1, _OWORD *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  size_t v7 = 16;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      long long outputStruct = 0uLL;
      uint64_t input = a1;
      uint64_t v4 = IOConnectCallMethod(aks_client_connection, 0x17u, &input, 1u, 0, 0, 0, 0, &outputStruct, &v7);
      if (!v4) {
        *a2 = outputStruct;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_get_bag_uuid", ":", 729, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v4;
}

uint64_t aks_copy_volume_cookie(int a1, void *a2, size_t *a3)
{
  return aks_copy_volume_cookie_persona(a1, (uint64_t)&UUID_NULL, a2, a3);
}

uint64_t aks_copy_volume_cookie_persona(int a1, uint64_t a2, void *a3, size_t *a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  __int16 v23 = 0;
  memset(__src, 0, sizeof(__src));
  size_t __count = 34;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v14 = 3758097090;
    if (a3 && a4)
    {
      mach_port_t v15 = aks_client_connection;
      uint64_t input = a1;
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 1, v9, v10, v11, v12, v13, a2);
      if (*(void *)&inputStructCnt[1])
      {
        uint64_t v16 = IOConnectCallMethod(v15, 0x44u, &input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
        if (v16)
        {
          uint64_t v14 = v16;
        }
        else
        {
          long long v17 = calloc(__count, 1uLL);
          *a3 = v17;
          uint64_t v14 = 3758097085;
          if (v17)
          {
            memcpy(v17, __src, __count);
            uint64_t v14 = 0;
            *a4 = __count;
          }
        }
      }
      else
      {
        uint64_t v14 = 3758097085;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_copy_volume_cookie_persona", ":", 760, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v14 = 3758097084;
  }
  free(*(void **)&inputStructCnt[1]);
  return v14;
}

uint64_t aks_lock_bag(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0xDu, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_lock_bag", ":", 790, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_get_lock_state(int a1, _DWORD *a2)
{
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      uint64_t output = 0;
      input[0] = a1;
      uint32_t outputCnt = 1;
      uint64_t v4 = IOConnectCallMethod(aks_client_connection, 7u, input, 1u, 0, 0, &output, &outputCnt, 0, 0);
      if (!v4) {
        *a2 = output;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_get_lock_state", ":", 824, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v4;
}

uint64_t aks_wrap_key(const void *a1, int a2, int a3, int a4, void *a5, int *a6, _DWORD *a7)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  uint64_t v14 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v14 = 3758097090;
    if (a1 && a5 && a6)
    {
      input[0] = a4;
      input[1] = a3;
      uint64_t output = 0;
      uint32_t outputCnt = 1;
      size_t v18 = *a6;
      uint64_t v16 = IOConnectCallMethod(aks_client_connection, 0xAu, input, 2u, a1, a2, &output, &outputCnt, a5, &v18);
      if (v16)
      {
        return v16;
      }
      else
      {
        *a6 = v18;
        uint64_t v14 = 0;
        if (a7) {
          *a7 = output;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_wrap_key", ":", 848, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v14;
}

uint64_t aks_unwrap_key(const void *a1, int a2, int a3, int a4, void *a5, int *a6)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  uint64_t v12 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v12 = 3758097090;
    if (a1)
    {
      if (a5)
      {
        if (a6)
        {
          input[0] = a4;
          input[1] = a3;
          size_t v15 = *a6;
          uint64_t v12 = IOConnectCallMethod(aks_client_connection, 0xBu, input, 2u, a1, a2, 0, 0, a5, &v15);
          if (!v12) {
            *a6 = v15;
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_unwrap_key", ":", 877, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v12;
}

uint64_t aks_rewrap_key_for_backup(const void *a1, int a2, int a3, int a4, uint64_t a5, unsigned int a6, void *a7)
{
  uint64_t input[4] = *MEMORY[0x263EF8340];
  uint64_t v14 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v14 = 3758097090;
    if (a1 && a7)
    {
      input[0] = a3;
      input[1] = a4;
      uint64_t input[2] = a5;
      uint64_t input[3] = a6;
      size_t v17 = 108;
      return IOConnectCallMethod(aks_client_connection, 0x18u, input, 4u, a1, a2, 0, 0, a7, &v17);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_rewrap_key_for_backup", ":", 901, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v14;
}

uint64_t aks_get_system(int a1, _DWORD *a2)
{
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      uint64_t output = 0;
      input[0] = a1;
      uint32_t outputCnt = 1;
      uint64_t v4 = IOConnectCallMethod(aks_client_connection, 0xEu, input, a1 != 0, 0, 0, &output, &outputCnt, 0, 0);
      if (!v4) {
        *a2 = output;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_get_system", ":", 922, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v4;
}

uint64_t aks_set_system_with_passcode(int a1, int a2, uint64_t a3, int a4)
{
  uint64_t input[4] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    uint64_t input[2] = a3;
    uint64_t input[3] = a4;
    return IOConnectCallMethod(aks_client_connection, 5u, input, 4u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_set_system_with_passcode", ":", 950, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_set_system(int a1, int a2)
{
  return aks_set_system_with_passcode(a1, a2, 0, 0);
}

uint64_t aks_set_keybag_for_volume(int a1, uint64_t a2, unsigned int a3)
{
  return aks_set_keybag_for_volume_with_cookie_persona(a1, a2, a3);
}

uint64_t aks_set_keybag_for_volume_with_cookie(int a1, uint64_t a2, unsigned int a3)
{
  return aks_set_keybag_for_volume_with_cookie_persona(a1, a2, a3);
}

uint64_t aks_set_keybag_for_volume_with_cookie_persona(int a1, uint64_t a2, unsigned int a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  uint64_t v6 = 3758097084;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v13 = aks_client_connection;
    input[0] = a1;
    input[1] = a3;
    aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 3, v8, v9, v10, v11, v12, a2);
    if (*(void *)&inputStructCnt[1])
    {
      uint64_t v6 = IOConnectCallMethod(v13, 0x41u, input, 2u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, 0, 0);
      uint64_t v14 = *(void **)&inputStructCnt[1];
    }
    else
    {
      uint64_t v14 = 0;
      uint64_t v6 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_set_keybag_for_volume_with_cookie_persona", ":", 987, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v14 = 0;
  }
  free(v14);
  return v6;
}

uint64_t aks_backup_enable_volume()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v0;
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v10 = 3758097085;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(__src, 0x8000uLL);
  size_t __count = 0x8000;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v17 = aks_client_connection;
    input[0] = v8;
    input[1] = v6;
    aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 1, v12, v13, v14, v15, v16, v9);
    if (*(void *)&inputStructCnt[1])
    {
      uint64_t v18 = IOConnectCallMethod(v17, 0x6Eu, input, 2u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
      if (v18)
      {
        uint64_t v10 = v18;
      }
      else
      {
        uint64_t v19 = calloc(__count, 1uLL);
        void *v4 = v19;
        if (v19)
        {
          memcpy(v19, __src, __count);
          uint64_t v10 = 0;
          size_t *v2 = __count;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_backup_enable_volume", ":", 1014, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v10 = 3758097084;
  }
  free(*(void **)&inputStructCnt[1]);
  return v10;
}

uint64_t aks_backup_disable_volume(uint64_t a1)
{
  uint64_t v2 = 3758097084;
  uint64_t v13 = 0;
  int v12 = 0;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v9 = aks_client_connection;
    aks_pack_data(&v13, (unsigned int *)&v12, 1, v4, v5, v6, v7, v8, a1);
    if (v13)
    {
      uint64_t v2 = IOConnectCallMethod(v9, 0x6Fu, 0, 0, v13, v12, 0, 0, 0, 0);
      uint64_t v10 = v13;
    }
    else
    {
      uint64_t v10 = 0;
      uint64_t v2 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_backup_disable_volume", ":", 1044, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v10 = 0;
  }
  free(v10);
  return v2;
}

uint64_t aks_backup_copy_current_bag_uuid(uint64_t a1, void *a2)
{
  uint64_t v4 = 3758097084;
  uint64_t v16 = 0;
  int v15 = 0;
  size_t v14 = 16;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v11 = aks_client_connection;
    aks_pack_data(&v16, (unsigned int *)&v15, 1, v6, v7, v8, v9, v10, a1);
    if (v16)
    {
      uint64_t v4 = IOConnectCallMethod(v11, 0x70u, 0, 0, v16, v15, 0, 0, a2, &v14);
      int v12 = v16;
    }
    else
    {
      int v12 = 0;
      uint64_t v4 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_backup_copy_current_bag_uuid", ":", 1066, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    int v12 = 0;
  }
  free(v12);
  return v4;
}

uint64_t aks_backup_rewrap_key(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unsigned int a6, void *a7)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  uint64_t v13 = 3758097084;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v20 = aks_client_connection;
    long long v21 = 0;
    uint64_t v13 = 3758097090;
    if (a2 && a7)
    {
      input[0] = a4;
      input[1] = a5;
      uint64_t input[2] = a6;
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v15, v16, v17, v18, v19, a1);
      size_t v23 = 108;
      uint64_t v13 = IOConnectCallMethod(v20, 0x71u, input, 3u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, a7, &v23);
      long long v21 = *(void **)&inputStructCnt[1];
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_backup_rewrap_key", ":", 1087, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    long long v21 = 0;
  }
  free(v21);
  return v13;
}

uint64_t aks_backup_rewrap_ek(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, unsigned int a8, void *outputStruct)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  uint64_t v15 = 3758097084;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v22 = aks_client_connection;
    size_t v23 = 0;
    uint64_t v15 = 3758097090;
    if (a2 && a4 && outputStruct)
    {
      input[0] = a6;
      input[1] = a7;
      uint64_t input[2] = a8;
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 3, v17, v18, v19, v20, v21, a1);
      size_t v25 = 108;
      uint64_t v15 = IOConnectCallMethod(v22, 0x71u, input, 3u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, outputStruct, &v25);
      size_t v23 = *(void **)&inputStructCnt[1];
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_backup_rewrap_ek", ":", 1113, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    size_t v23 = 0;
  }
  free(v23);
  return v15;
}

uint64_t aks_backup_unwrap_bag(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  long long v17 = 0u;
  long long v18 = 0u;
  long long __s = 0u;
  long long v16 = 0u;
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  uint64_t v8 = decode_backup_bag(a1, a2, v13);
  if (v8)
  {
    uint64_t v9 = v8;
  }
  else
  {
    uint64_t v9 = unwrap_backup_bag((uint64_t)v13, a3, a4, (uint64_t)&__s);
    if (!v9)
    {
      long long v10 = v16;
      *a5 = __s;
      a5[1] = v10;
      long long v11 = v18;
      a5[2] = v17;
      a5[3] = v11;
    }
  }
  memset_s(v13, 0x58uLL, 0, 0x58uLL);
  memset_s(&__s, 0x40uLL, 0, 0x40uLL);
  return err_sks_to_aks(v9);
}

uint64_t aks_backup_copy_bag_uuid(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  uint64_t v4 = decode_backup_bag(a1, a2, v6);
  if (!v4) {
    uuid_copy(a3, (const unsigned __int8 *)v6 + 8);
  }
  memset_s(v6, 0x58uLL, 0, 0x58uLL);
  return err_sks_to_aks(v4);
}

uint64_t aks_backup_unwrap_key(long long *a1, void *a2, unsigned int a3, void *a4, void *a5)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  long long v6 = a1[1];
  long long v12 = *a1;
  long long v13 = v6;
  long long v7 = a1[3];
  long long v14 = a1[2];
  long long v15 = v7;
  unsigned int v10 = *a5;
  int __s = 1;
  uint64_t v8 = unwrap_data((uint64_t)&__s, 0, 0, a2, a3, a4, &v10);
  *a5 = v10;
  memset_s(&__s, 0x44uLL, 0, 0x44uLL);
  return err_sks_to_aks(v8);
}

uint64_t aks_kc_backup_unwrap_key(uint64_t a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  uint64_t v10 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v10 = 3758097090;
    if (a2 && a4)
    {
      input[0] = a1;
      input[1] = 64;
      return IOConnectCallMethod(aks_client_connection, 0x82u, input, 2u, a2, a3, 0, 0, a4, a5);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_kc_backup_unwrap_key", ":", 1193, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v10;
}

uint64_t aks_kc_backup_wrap_key(int a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v10 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v10 = 3758097090;
    if (a2 && a4)
    {
      input[0] = a1;
      return IOConnectCallMethod(aks_client_connection, 0x81u, input, 1u, a2, a3, 0, 0, a4, a5);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_kc_backup_wrap_key", ":", 1212, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v10;
}

uint64_t aks_kc_backup_get_handle(int a1, _DWORD *a2)
{
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      uint64_t output = 0;
      input[0] = a1;
      uint32_t outputCnt = 1;
      uint64_t v4 = IOConnectCallMethod(aks_client_connection, 0x83u, input, 1u, 0, 0, &output, &outputCnt, 0, 0);
      if (!v4) {
        *a2 = output;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_kc_backup_get_handle", ":", 1231, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v4;
}

uint64_t aks_kc_backup_get_uuid(int a1, unsigned __int8 *a2)
{
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      uint64_t v10 = 0;
      input[0] = a1;
      size_t v8 = 16;
      *(void *)src = 0;
      uint64_t v6 = IOConnectCallMethod(aks_client_connection, 0x84u, input, 1u, 0, 0, 0, 0, src, &v8);
      if (v6)
      {
        return v6;
      }
      else if (v8 == 16)
      {
        uuid_copy(a2, src);
        return 0;
      }
      else
      {
        return 3758604298;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_kc_backup_get_uuid", ":", 1253, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v4;
}

uint64_t aks_kc_backup_open_keybag(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, _OWORD *a6)
{
  if (a5)
  {
    int v7 = a4;
    int v9 = a2;
    *a5 = -1;
    int v11 = aks_backup_unwrap_bag((uint64_t)a1, a2, a3, a4, a6);
    long long v12 = (FILE **)MEMORY[0x263EF8358];
    long long v13 = (FILE *)*MEMORY[0x263EF8358];
    if (!v11)
    {
      fprintf(v13, "%s%s:%s%s%s%s%u:%s%u:%s Unwrapped DER backup bag%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_kc_backup_open_keybag", ":", 1302, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v17 = 0;
      goto LABEL_9;
    }
    fprintf(v13, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unwrap backup bag as DER: 0x%08x%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_kc_backup_open_keybag", ":", 1290, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, v11, (const char *)&unk_22004A573);
    uint64_t bag = aks_load_bag(a1, v9, a5);
    if (bag)
    {
      uint64_t v17 = bag;
      fprintf(*v12, "%s%s:%s%s%s%s%u:%s%u:%s Failed to load in-kernel backup bag: 0x%08x%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_kc_backup_open_keybag", ":", 1292, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, bag, (const char *)&unk_22004A573);
    }
    else
    {
      int is_enabled = aks_prederived_is_enabled();
      int v16 = *a5;
      if (is_enabled)
      {
        uint64_t v17 = aks_prederived_unlock_keybag(v16, a3, v7, 0);
        if (!v17) {
          goto LABEL_9;
        }
        fprintf(*v12, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unlock in-kernel backup bag with prederived secret: 0x%08x%s\n", "aks", &unk_22004A573, &unk_22004A573, &unk_22004A573, "aks_kc_backup_open_keybag", ":");
      }
      else
      {
        uint64_t v17 = aks_unlock_bag(v16, a3, v7);
        if (!v17) {
          goto LABEL_9;
        }
        fprintf(*v12, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unlock in-kernel backup bag: 0x%08x%s\n", "aks", &unk_22004A573, &unk_22004A573, &unk_22004A573, "aks_kc_backup_open_keybag", ":");
      }
    }
  }
  else
  {
    uint64_t v17 = 3758097090;
  }
  if (*a5 != -1)
  {
    aks_unload_bag(*a5);
    *a5 = -1;
  }
LABEL_9:
  aks_prederived_free(0);
  return v17;
}

uint64_t aks_keybag_persona_create(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  uint64_t v8 = 3758097084;
  uint64_t v19 = 0;
  int v18 = 0;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v15 = aks_client_connection;
    input[0] = a1;
    input[1] = a2;
    uint64_t input[2] = a3;
    aks_pack_data(&v19, (unsigned int *)&v18, 1, v10, v11, v12, v13, v14, a4);
    if (v19)
    {
      uint64_t v8 = IOConnectCallMethod(v15, 0x60u, input, 3u, v19, v18, 0, 0, 0, 0);
      int v16 = v19;
    }
    else
    {
      int v16 = 0;
      uint64_t v8 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_keybag_persona_create", ":", 1324, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    int v16 = 0;
  }
  free(v16);
  return v8;
}

uint64_t aks_keybag_persona_create_with_flags(int a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t input[4] = *MEMORY[0x263EF8340];
  uint64_t v10 = 3758097084;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v17 = aks_client_connection;
    input[0] = a1;
    input[1] = a2;
    uint64_t input[2] = a3;
    uint64_t input[3] = a5;
    aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 1, v12, v13, v14, v15, v16, a4);
    if (*(void *)&inputStructCnt[1])
    {
      uint64_t v10 = IOConnectCallMethod(v17, 0x75u, input, 4u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, 0, 0);
      int v18 = *(void **)&inputStructCnt[1];
    }
    else
    {
      int v18 = 0;
      uint64_t v10 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_keybag_persona_create_with_flags", ":", 1346, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    int v18 = 0;
  }
  free(v18);
  return v10;
}

uint64_t aks_keybag_persona_list()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  int v5 = v0;
  uint64_t v15 = *MEMORY[0x263EF8340];
  bzero(__src, 0x2000uLL);
  size_t __count = 0x2000;
  uint64_t input = v5;
  uint64_t v6 = 3758097090;
  if (v4 && v2)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      uint64_t v8 = IOConnectCallMethod(aks_client_connection, 0x61u, &input, 1u, 0, 0, 0, 0, __src, &__count);
      if (v8)
      {
        uint64_t v6 = v8;
      }
      else
      {
        if (__count)
        {
          int v9 = calloc(__count, 1uLL);
          void *v4 = v9;
          if (!v9)
          {
            uint64_t v6 = 3758097085;
            goto LABEL_10;
          }
          memcpy(v9, __src, __count);
          size_t v10 = __count;
        }
        else
        {
          size_t v10 = 0;
          void *v4 = 0;
        }
        uint64_t v6 = 0;
        size_t *v2 = v10;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_keybag_persona_list", ":", 1372, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v6 = 3758097084;
    }
  }
LABEL_10:
  memset_s(__src, 0x2000uLL, 0, 0x2000uLL);
  return v6;
}

uint64_t aks_keybag_persona_delete(int a1, uint64_t a2)
{
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  uint64_t v15 = 0;
  int v14 = 0;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v11 = aks_client_connection;
    input[0] = a1;
    aks_pack_data(&v15, (unsigned int *)&v14, 1, v6, v7, v8, v9, v10, a2);
    if (v15)
    {
      uint64_t v4 = IOConnectCallMethod(v11, 0x62u, input, 1u, v15, v14, 0, 0, 0, 0);
      uint64_t v12 = v15;
    }
    else
    {
      uint64_t v12 = 0;
      uint64_t v4 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_keybag_persona_delete", ":", 1394, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v12 = 0;
  }
  free(v12);
  return v4;
}

uint64_t aks_auth_token_create(int a1, uint64_t a2, int a3, unsigned int a4, void *a5, size_t *a6)
{
  uint64_t input[4] = *MEMORY[0x263EF8340];
  uint64_t v12 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v12 = 3758097090;
    if (a5 && a6)
    {
      input[0] = a1;
      input[1] = a4;
      uint64_t input[2] = a2;
      uint64_t input[3] = a3;
      return IOConnectCallMethod(aks_client_connection, 0x26u, input, 4u, 0, 0, 0, 0, a5, a6);
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_auth_token_create", ":", 1415, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v12;
}

uint64_t aks_set_configuration(int a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  rsize_t __n = 0;
  int __s = 0;
  uint64_t v7 = 3758097090;
  uint64_t v20 = 0;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v9 = aks_client_connection;
    CFTypeID TypeID = CFNumberGetTypeID();
    if (!_copy_cf_key(a4, @"GracePeriod", TypeID, (uint64_t)der_key_config_graceperiod, &v20))
    {
      CFTypeID v11 = CFNumberGetTypeID();
      if (!_copy_cf_key(a4, @"BackOffDelay", v11, (uint64_t)der_key_config_backoff_delay, &v20))
      {
        CFTypeID v12 = CFNumberGetTypeID();
        if (!_copy_cf_key(a4, @"MaxUnlockAttempts", v12, (uint64_t)der_key_config_max_unlock_attempts, &v20))
        {
          CFTypeID v13 = CFNumberGetTypeID();
          if (!_copy_cf_key(a4, @"EscrowPasscodePeriod", v13, (uint64_t)der_key_config_escrow_passcode_period, &v20))
          {
            CFTypeID v14 = CFNumberGetTypeID();
            if (!_copy_cf_key(a4, @"EscrowTokenPeriod", v14, (uint64_t)der_key_config_escrow_token_period, &v20))
            {
              CFTypeID v15 = CFDataGetTypeID();
              if (!_copy_cf_key(a4, @"UserUUID", v15, (uint64_t)der_key_config_user_uuid, &v20))
              {
                CFTypeID v16 = CFDataGetTypeID();
                if (!_copy_cf_key(a4, @"BindKEKToKB", v16, (uint64_t)der_key_config_bind_kek, &v20))
                {
                  CFTypeID v17 = CFBooleanGetTypeID();
                  if (!_copy_cf_key(a4, @"InactivityRebootEnabled", v17, (uint64_t)der_key_inactivity_reboot_enabled, &v20))
                  {
                    CFTypeID v18 = CFBooleanGetTypeID();
                    if (!_copy_cf_key(a4, @"OnenessAutomaticMode", v18, (uint64_t)der_key_oneness_automatic_mode, &v20)&& !encode_list_is_empty(&v20)&& (!a2 || !encode_list_add_data(&v20, (uint64_t)der_key_passcode, a2))&& !encode_list_dict(&v20, &__s, &__n))
                    {
                      input[0] = a1;
                      input[1] = (uint64_t)__s;
                      uint64_t input[2] = __n;
                      uint64_t v7 = IOConnectCallMethod(v9, 0x1Eu, input, 3u, 0, 0, 0, 0, 0, 0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_set_configuration", ":", 1488, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v7 = 3758097084;
  }
  encode_list_free(&v20);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t _copy_cf_key(const __CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  value = 0;
  uint64_t result = CFDictionaryGetValueIfPresent(a1, a2, (const void **)&value);
  if (result)
  {
    if (CFGetTypeID(value) == a3)
    {
      if (CFNumberGetTypeID() == a3)
      {
        uint64_t v10 = 0;
        if (!CFNumberGetValue((CFNumberRef)value, kCFNumberSInt64Type, &v10)
          || encode_list_add_number(a5, a4, v10))
        {
          return 0xFFFFFFFFLL;
        }
        return 0;
      }
      if (CFBooleanGetTypeID() == a3)
      {
        CFBooleanGetValue((CFBooleanRef)value);
        if (encode_list_add_BOOL(a5, a4)) {
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        if (CFDataGetTypeID() != a3) {
          return 0xFFFFFFFFLL;
        }
        BytePtr = CFDataGetBytePtr((CFDataRef)value);
        CFDataGetLength((CFDataRef)value);
        if (encode_list_add_data(a5, a4, (uint64_t)BytePtr)) {
          return 0xFFFFFFFFLL;
        }
      }
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t aks_get_configuration()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  int v3 = v0;
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v2)
    {
      mach_port_t v6 = aks_client_connection;
      bzero(outputStruct, 0x8000uLL);
      v46[0] = 0x8000;
      uint64_t input = v3;
      uint64_t v7 = IOConnectCallMethod(v6, 0x1Fu, &input, 1u, 0, 0, 0, 0, outputStruct, v46);
      if (v7)
      {
        return v7;
      }
      else if (v46[0] > 0x8000)
      {
        return 3758604298;
      }
      else
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
        bzero(v47, 0x250uLL);
        v46[1] = (size_t)der_key_config_graceperiod;
        v47[4] = der_key_config_backoff_delay;
        v47[9] = der_key_config_max_unlock_attempts;
        v47[14] = der_key_config_escrow_passcode_period;
        v47[19] = der_key_config_escrow_token_period;
        v47[24] = der_key_config_flags;
        v47[29] = der_key_config_user_uuid;
        v47[34] = der_key_config_group_uuid;
        v47[39] = der_key_config_recovery_iterations;
        v47[44] = der_key_config_recovery_flags;
        v47[49] = der_key_config_recovery_target_iterations;
        v47[54] = der_key_memento_supported;
        v47[59] = der_key_memento_blob_exists;
        v47[64] = der_key_config_memento_passcode_generation;
        v47[69] = der_key_config_passcode_generation;
        der_dict_iterate();
        uint64_t v9 = v47[0];
        uint64_t v10 = v47[5];
        uint64_t v11 = v47[10];
        uint64_t v12 = v47[15];
        uint64_t v13 = v47[20];
        uint64_t v14 = v47[25];
        uint64_t v15 = v47[30];
        uint64_t v45 = v2;
        uint64_t v16 = v47[35];
        uint64_t v38 = v47[40];
        uint64_t v39 = v47[45];
        uint64_t v40 = v47[50];
        uint64_t v41 = v47[55];
        uint64_t v42 = v47[60];
        uint64_t v43 = v47[65];
        uint64_t v44 = v47[70];
        CFTypeID TypeID = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"GracePeriod", TypeID, v9);
        CFTypeID v18 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"BackOffDelay", v18, v10);
        CFTypeID v19 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"MaxUnlockAttempts", v19, v11);
        CFTypeID v20 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"EscrowPasscodePeriod", v20, v12);
        CFTypeID v21 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"EscrowTokenPeriod", v21, v13);
        CFTypeID v22 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"ConfigFlags", v22, v14);
        CFTypeID v23 = CFDataGetTypeID();
        _set_cf_key(Mutable, @"UserUUID", v23, v15);
        CFTypeID v24 = CFDataGetTypeID();
        _set_cf_key(Mutable, @"GroupUUID", v24, v16);
        CFTypeID v25 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"RecoveryIterations", v25, v38);
        CFTypeID v26 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"RecoveryFlags", v26, v39);
        CFTypeID v27 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"RecoveryTargetIterations", v27, v40);
        CFTypeID v28 = CFBooleanGetTypeID();
        _set_cf_key(Mutable, @"MementoSupported", v28, v41);
        CFTypeID v29 = CFBooleanGetTypeID();
        _set_cf_key(Mutable, @"MementoBlobExists", v29, v42);
        CFTypeID v30 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"MementoPasscodeGeneration", v30, v43);
        CFTypeID v31 = CFNumberGetTypeID();
        _set_cf_key(Mutable, @"PasscodeGeneration", v31, v44);
        char number = der_get_number();
        uint64_t v33 = (const void *)*MEMORY[0x263EFFB38];
        uint64_t v34 = (const void *)*MEMORY[0x263EFFB40];
        if ((number & 2) != 0) {
          uint64_t v35 = (const void *)*MEMORY[0x263EFFB40];
        }
        else {
          uint64_t v35 = (const void *)*MEMORY[0x263EFFB38];
        }
        CFDictionarySetValue(Mutable, @"InactivityRebootEnabled", v35);
        if ((number & 8) != 0) {
          uint64_t v36 = v34;
        }
        else {
          uint64_t v36 = v33;
        }
        CFDictionarySetValue(Mutable, @"OnenessAutomaticMode", v36);
        uint64_t v4 = 0;
        *uint64_t v45 = Mutable;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_get_configuration", ":", 1556, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v4;
}

void _set_cf_key(__CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    if (CFNumberGetTypeID() == a3)
    {
      CFIndex valuePtr = der_get_number();
      CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt64Type, &valuePtr);
      if (!v7) {
        return;
      }
LABEL_14:
      CFNumberRef v12 = v7;
      CFDictionaryAddValue(a1, a2, v7);
      CFRelease(v12);
      return;
    }
    if (CFBooleanGetTypeID() == a3)
    {
      int v8 = der_get_BOOL();
      uint64_t v9 = (const void **)MEMORY[0x263EFFB40];
      if (!v8) {
        uint64_t v9 = (const void **)MEMORY[0x263EFFB38];
      }
      uint64_t v10 = *v9;
      CFDictionaryAddValue(a1, a2, v10);
    }
    else if (CFDataGetTypeID() == a3)
    {
      CFIndex valuePtr = 0;
      uint64_t v11 = (const UInt8 *)ccder_decode_tl();
      if (v11)
      {
        CFNumberRef v7 = CFDataCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], v11, valuePtr);
        goto LABEL_14;
      }
    }
  }
}

uint64_t aks_assert_hold(int a1, unsigned int a2, uint64_t a3)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  input[0] = a2;
  input[1] = a3;
  uint64_t input[2] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x1Au, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_assert_hold", ":", 1654, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_assert_drop(int a1, unsigned int a2)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  input[0] = a2;
  input[1] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x1Bu, input, 2u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_assert_drop", ":", 1672, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_assert_promote(int a1, unsigned int a2)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a2;
    input[1] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x64u, input, 2u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_assert_promote", ":", 1687, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_oneness_heartbeat(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x91u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_oneness_heartbeat", ":", 1707, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_assert_consume(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x65u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_assert_consume", ":", 1722, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_recover_with_escrow_bag(int a1, uint64_t a2)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  uint64_t v15 = 0;
  int v14 = 0;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v10 = aks_client_connection;
    aks_pack_data((char **)&v15, (unsigned int *)&v14, 3, v5, v6, v7, v8, v9, a2);
    input[0] = a1;
    input[1] = (uint64_t)v15;
    uint64_t input[2] = v14;
    uint64_t v11 = IOConnectCallMethod(v10, 0x12u, input, 3u, 0, 0, 0, 0, 0, 0);
    CFNumberRef v12 = v15;
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_recover_with_escrow_bag", ":", 1739, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    CFNumberRef v12 = 0;
    uint64_t v11 = 3758097084;
  }
  free(v12);
  return v11;
}

uint64_t aks_fdr_hmac_data()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  int v6 = v5;
  uint64_t v7 = (const void *)v0;
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v8 = 3758097090;
  bzero(__src, 0x8000uLL);
  size_t __count = 0x8000;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v7 && v4 && v2)
    {
      uint64_t v10 = IOConnectCallMethod(aks_client_connection, 0x29u, 0, 0, v7, v6, 0, 0, __src, &__count);
      if (v10)
      {
        uint64_t v8 = v10;
      }
      else
      {
        uint64_t v11 = calloc(__count, 1uLL);
        void *v4 = v11;
        if (v11)
        {
          memcpy(v11, __src, __count);
          uint64_t v8 = 0;
          _DWORD *v2 = __count;
        }
        else
        {
          uint64_t v8 = 3758097085;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fdr_hmac_data", ":", 1758, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v8 = 3758097084;
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v8;
}

uint64_t aks_generation(int a1, unsigned int a2, _DWORD *a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    uint64_t output = 0;
    uint32_t outputCnt = 1;
    uint64_t result = IOConnectCallMethod(aks_client_connection, 0x28u, input, 2u, 0, 0, &output, &outputCnt, 0, 0);
    if (a3)
    {
      if (!result) {
        *a3 = output;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_generation", ":", 1781, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  return result;
}

uint64_t _aks_verify_password(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  uint64_t input[4] = *MEMORY[0x263EF8340];
  uint64_t v9 = 3758097084;
  CFTypeID v21 = 0;
  int v20 = 0;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v16 = aks_client_connection;
    if (a2) {
      CFTypeID v17 = a2;
    }
    else {
      CFTypeID v17 = &unk_22004A573;
    }
    aks_pack_data((char **)&v21, (unsigned int *)&v20, 2, v11, v12, v13, v14, v15, (uint64_t)v17);
    if (v21)
    {
      input[0] = a1;
      input[1] = a6;
      uint64_t input[2] = (uint64_t)v21;
      uint64_t input[3] = v20;
      uint64_t v9 = IOConnectCallMethod(v16, 0x2Au, input, 4u, 0, 0, 0, 0, 0, 0);
      CFTypeID v18 = v21;
    }
    else
    {
      CFTypeID v18 = 0;
      uint64_t v9 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "_aks_verify_password", ":", 1807, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    CFTypeID v18 = 0;
  }
  free(v18);
  return v9;
}

uint64_t aks_verify_password(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _aks_verify_password(a1, a2, a3, a4, a5, 0);
}

uint64_t aks_verify_password_memento(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return _aks_verify_password(a1, a2, a3, a4, a5, 1u);
}

uint64_t aks_register_for_notifications()
{
  if (get_aks_client_connection())
  {
    JUMPOUT(0x223C64650);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_register_for_notifications", ":", 1840, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_create_signing_key(int a1, int a2, void *a3, size_t *a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  size_t __count = 256;
  input[0] = a1;
  input[1] = a2;
  uint64_t result = 3758097090;
  if (a3 && a4)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      memset(__src, 0, sizeof(__src));
      uint64_t result = IOConnectCallMethod(aks_client_connection, 0x31u, input, 2u, 0, 0, 0, 0, __src, &__count);
      if (!result)
      {
        if (__count > 0x100)
        {
          return 3758604298;
        }
        else
        {
          uint64_t v8 = calloc(__count, 1uLL);
          *a3 = v8;
          if (v8)
          {
            memcpy(v8, __src, __count);
            uint64_t result = 0;
            *a4 = __count;
          }
          else
          {
            return 3758097085;
          }
        }
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_create_signing_key", ":", 1859, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      return 3758097084;
    }
  }
  return result;
}

uint64_t aks_create_signing_key_with_params()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v17 = *MEMORY[0x263EF8340];
  size_t __count = 0x8000;
  input[0] = v0;
  input[1] = v5;
  uint64_t result = 3758097090;
  if (v3)
  {
    uint64_t v7 = v4;
    if (v4)
    {
      uint64_t v8 = v3;
      size_t v9 = v2;
      uint64_t v10 = v1;
      mach_port_t aks_client_connection = get_aks_client_connection();
      if (aks_client_connection)
      {
        mach_port_t v12 = aks_client_connection;
        bzero(__src, 0x8000uLL);
        uint64_t result = IOConnectCallMethod(v12, 0x31u, input, 2u, v10, v9, 0, 0, __src, &__count);
        if (!result)
        {
          if (__count > 0x8000)
          {
            return 3758604298;
          }
          else
          {
            uint64_t v13 = calloc(__count, 1uLL);
            void *v8 = v13;
            if (v13)
            {
              memcpy(v13, __src, __count);
              uint64_t result = 0;
              size_t *v7 = __count;
            }
            else
            {
              return 3758097085;
            }
          }
        }
      }
      else
      {
        fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_create_signing_key_with_params", ":", 1881, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
        return 3758097084;
      }
    }
  }
  return result;
}

uint64_t aks_obliterate_signing_keys()
{
  return remote_session_operate();
}

uint64_t remote_session_operate()
{
  int v0 = MEMORY[0x270FA5388]();
  size_t v2 = v1;
  uint64_t v4 = v3;
  uint32_t v6 = v5;
  uint64_t v19 = *MEMORY[0x263EF8340];
  size_t __count = 15360;
  input[0] = v0;
  input[1] = v7;
  uint64_t input[2] = v8;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v10 = aks_client_connection;
    bzero(__src, 0x3C00uLL);
    uint64_t v11 = IOConnectCallMethod(v10, v6, input, 3u, 0, 0, 0, 0, __src, &__count);
    if (v11)
    {
      return v11;
    }
    else if (__count > 0x3C00)
    {
      return 3758604298;
    }
    else
    {
      uint64_t v12 = 0;
      if (v4 && v2)
      {
        if (__count)
        {
          uint64_t v13 = calloc(__count, 1uLL);
          void *v4 = v13;
          if (!v13) {
            return 3758097085;
          }
          memcpy(v13, __src, __count);
          size_t v14 = __count;
        }
        else
        {
          size_t v14 = 0;
        }
        uint64_t v12 = 0;
        size_t *v2 = v14;
      }
    }
  }
  else
  {
    uint64_t v12 = 3758097084;
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "remote_session_operate", ":", 2017, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v12;
}

uint64_t aks_sign_signing_key(int a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, void *a8, size_t *a9)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  memset(__src, 0, sizeof(__src));
  size_t __count = 256;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  input[0] = a1;
  input[1] = a2;
  uint64_t v9 = 3758097090;
  uint64_t input[2] = a5;
  if (a8 && a9)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      mach_port_t v18 = aks_client_connection;
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v13, v14, v15, v16, v17, a3);
      if (*(void *)&inputStructCnt[1])
      {
        uint64_t v19 = IOConnectCallMethod(v18, 0x32u, input, 3u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
        if (v19)
        {
          uint64_t v9 = v19;
        }
        else if (__count > 0x100)
        {
          uint64_t v9 = 3758604298;
        }
        else
        {
          int v20 = calloc(__count, 1uLL);
          *a8 = v20;
          uint64_t v9 = 3758097085;
          if (v20)
          {
            memcpy(v20, __src, __count);
            uint64_t v9 = 0;
            *a9 = __count;
          }
        }
      }
      else
      {
        uint64_t v9 = 3758097085;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_sign_signing_key", ":", 1911, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v9 = 3758097084;
    }
  }
  free(*(void **)&inputStructCnt[1]);
  return v9;
}

uint64_t aks_remote_session(int a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  uint64_t v10 = 3758097084;
  input[0] = a2;
  input[1] = a1;
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v17 = aks_client_connection;
    aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 3, v12, v13, v14, v15, v16, a3);
    if (*(void *)&inputStructCnt[1])
    {
      uint64_t v18 = IOConnectCallMethod(v17, 0x2Cu, input, 2u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], &output, &outputCnt, 0, 0);
      uint64_t v10 = v18;
      if (a9 && !v18) {
        *a9 = output;
      }
    }
    else
    {
      uint64_t v10 = 3758097085;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_remote_session", ":", 1938, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  free(*(void **)&inputStructCnt[1]);
  return v10;
}

uint64_t aks_validate_local_key(int a1, int a2, uint64_t a3, uint64_t a4)
{
  mach_port_t v17 = 0;
  int __s = 0;
  uint64_t v4 = 3758097084;
  rsize_t __n = 0;
  uint64_t v16 = 0;
  uint64_t v5 = 3758097090;
  rsize_t __smax = 0;
  if (!a3 || !a4) {
    goto LABEL_12;
  }
  int v8 = -536870212;
  *(void *)&long long v19 = a3;
  *((void *)&v19 + 1) = a3 + a4;
  if (!(a3 + a4)) {
    goto LABEL_19;
  }
  uint64_t v16 = 0;
  if ((ccder_blob_decode_range() & 1) == 0)
  {
    int v8 = -536870198;
LABEL_19:
    syslog(3, "error parsing signing key: %d", v8);
    uint64_t v5 = 3758097084;
LABEL_12:
    uint64_t v12 = __s;
    uint64_t v4 = v5;
    goto LABEL_13;
  }
  der_utils_decode_implicit_uint64(&v19, 0x8000000000000001, &v16);
  if (v16)
  {
    uint64_t v5 = remote_session_operate();
    if (v5) {
      syslog(3, "error: validating v1 local signing key failed: %d");
    }
    goto LABEL_12;
  }
  uint64_t v11 = aks_create_signing_key(a1, 11, &__s, &__n);
  if (v11)
  {
    uint64_t v5 = v11;
    syslog(3, "error: validating (create) v0 local signing key failed: %d", v11);
    goto LABEL_12;
  }
  uint64_t v12 = __s;
  if (__s && __n)
  {
    uint64_t v5 = aks_sign_signing_key(a1, a2, a3, a4, 11, (uint64_t)__s, __n, &v17, &__smax);
    if (v5) {
      syslog(3, "error: validating (sign) v0 local signing key failed: %d");
    }
    goto LABEL_12;
  }
LABEL_13:
  if (v12)
  {
    memset_s(v12, __n, 0, __n);
    free(__s);
  }
  if (v17)
  {
    memset_s(v17, __smax, 0, __smax);
    free(v17);
  }
  return v4;
}

uint64_t aks_remote_session_step()
{
  return remote_session_operate();
}

uint64_t aks_remote_peer_setup()
{
  return remote_session_operate();
}

uint64_t aks_remote_peer_setup_with_acm()
{
  return remote_session_operate();
}

uint64_t aks_remote_peer_confirm()
{
  return remote_session_operate();
}

uint64_t aks_remote_session_token()
{
  return remote_session_operate();
}

uint64_t aks_drain_backup_keys()
{
  int v0 = MEMORY[0x270FA5388]();
  size_t v2 = v1;
  uint64_t v4 = v3;
  int v5 = v0;
  uint64_t v13 = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v7 = aks_client_connection;
    uint64_t result = 3758097090;
    if (v4)
    {
      if (v2)
      {
        bzero(__src, 0x8000uLL);
        size_t __count = 0x8000;
        input[0] = v5;
        input[1] = 0;
        uint64_t result = IOConnectCallMethod(v7, 0x14u, input, 2u, 0, 0, 0, 0, __src, &__count);
        if (!result)
        {
          if (__count)
          {
            uint64_t v9 = calloc(__count, 1uLL);
            void *v4 = v9;
            if (v9)
            {
              memcpy(v9, __src, __count);
              uint64_t result = 0;
              _DWORD *v2 = __count;
            }
            else
            {
              return 3758097085;
            }
          }
          else
          {
            return 3758097136;
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_drain_backup_keys", ":", 2072, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  return result;
}

uint64_t aks_drain_backup_keys_info()
{
  int v0 = MEMORY[0x270FA5388]();
  size_t v2 = v1;
  uint64_t v4 = v3;
  int v5 = v0;
  uint64_t v13 = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v7 = aks_client_connection;
    uint64_t result = 3758097090;
    if (v4)
    {
      if (v2)
      {
        bzero(__src, 0x8000uLL);
        size_t __count = 0x8000;
        input[0] = v5;
        input[1] = 1;
        uint64_t result = IOConnectCallMethod(v7, 0x14u, input, 2u, 0, 0, 0, 0, __src, &__count);
        if (!result)
        {
          if (__count)
          {
            if (__ROR8__(0xEF7BDEF7BDEF7BDFLL * __count, 2) > 0x210842108421084uLL)
            {
              return 3758604298;
            }
            else
            {
              uint64_t v9 = calloc(__count, 1uLL);
              void *v4 = v9;
              if (v9)
              {
                memcpy(v9, __src, __count);
                uint64_t result = 0;
                size_t *v2 = __count / 0x7C;
              }
              else
              {
                return 3758097085;
              }
            }
          }
          else
          {
            return 3758097136;
          }
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_drain_backup_keys_info", ":", 2100, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  return result;
}

uint64_t aks_clear_backup_bag(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    return IOConnectCallMethod(aks_client_connection, 0x16u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_clear_backup_bag", ":", 2129, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_set_backup_bag()
{
  int v0 = MEMORY[0x270FA5388]();
  size_t v2 = v1;
  uint64_t v4 = v3;
  int v6 = v5;
  uint64_t v8 = v7;
  int v10 = v9;
  int v11 = v0;
  uint64_t v22 = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_set_backup_bag", ":", 2146, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  mach_port_t v13 = aks_client_connection;
  if (v4)
  {
    if (!v2) {
      return 3758097090;
    }
    long long outputStruct = __src;
    p_count = &__count;
    uint64_t v16 = 1;
  }
  else
  {
    p_count = 0;
    long long outputStruct = 0;
    uint64_t v16 = 0;
  }
  bzero(__src, 0x8000uLL);
  size_t __count = 0x8000;
  input[0] = v11;
  input[1] = v10;
  uint64_t input[2] = v16;
  uint64_t input[3] = v8;
  uint64_t input[4] = v6;
  uint64_t result = IOConnectCallMethod(v13, 0x15u, input, 5u, 0, 0, 0, 0, outputStruct, p_count);
  if (v4 && !result)
  {
    uint64_t v18 = calloc(__count, 1uLL);
    void *v4 = v18;
    if (v18)
    {
      memcpy(v18, __src, __count);
      uint64_t result = 0;
      _DWORD *v2 = __count;
    }
    else
    {
      return 3758097085;
    }
  }
  return result;
}

uint64_t aks_make_public_backup_bag(int a1, _DWORD *a2)
{
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2)
    {
      uint64_t output = 0;
      input[0] = a1;
      uint32_t outputCnt = 1;
      uint64_t v4 = IOConnectCallMethod(aks_client_connection, 0x52u, input, 1u, 0, 0, &output, &outputCnt, 0, 0);
      if (!v4) {
        *a2 = output;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_make_public_backup_bag", ":", 2178, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v4;
}

uint64_t aks_remote_session_reset()
{
  return remote_session_operate();
}

uint64_t aks_remote_session_reset_all()
{
  return remote_session_operate();
}

uint64_t aks_get_device_state()
{
  return _get_device_state();
}

uint64_t _get_device_state()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint32_t v4 = v3;
  input[1] = *MEMORY[0x263EF8340];
  input[0] = v0;
  *(void *)uint64_t v12 = 4096;
  uint64_t v5 = 3758097084;
  int v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long __s = 0u;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v2)
    {
      mach_port_t v7 = aks_client_connection;
      bzero(outputStruct, 0x1000uLL);
      uint64_t v8 = IOConnectCallMethod(v7, v4, input, 1u, 0, 0, 0, 0, outputStruct, (size_t *)v12);
      if (v8)
      {
        return v8;
      }
      else
      {
        uint64_t v5 = 0;
        if (!decode_extended_state((uint64_t)outputStruct, v12[0], (char *)&__s))
        {
          long long v9 = v16;
          *(_OWORD *)(v2 + 32) = v15;
          *(_OWORD *)(v2 + 48) = v9;
          *(_WORD *)(v2 + 64) = v17;
          long long v10 = v14;
          *(_OWORD *)uint64_t v2 = __s;
          *(_OWORD *)(v2 + 16) = v10;
        }
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "_get_device_state", ":", 2224, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v5;
}

uint64_t aks_get_extended_device_state()
{
  return _get_device_state();
}

uint64_t aks_remote_peer_get_state()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  size_t v4 = v3;
  int v6 = v5;
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v7 = 3758097084;
  v12[0] = 4096;
  uint64_t input = v0;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (v2)
    {
      mach_port_t v9 = aks_client_connection;
      bzero(outputStruct, 0x1000uLL);
      memset_s(v2, 0x10uLL, 0, 0x10uLL);
      uint64_t v10 = IOConnectCallMethod(v9, 0x39u, &input, 1u, v6, v4, 0, 0, outputStruct, v12);
      if (v10)
      {
        return v10;
      }
      else
      {
        uint64_t v17 = 0;
        long long v21 = 0u;
        long long v13 = 0u;
        long long v14 = 0u;
        long long v16 = 0u;
        long long v19 = 0u;
        long long v20 = 0u;
        long long v22 = 0u;
        uint64_t v23 = 0;
        v12[1] = (size_t)der_key_peer_unlock_token_status;
        long long v15 = (unint64_t)der_key_peer_unwrapped_escrow_record_status;
        int v18 = der_key_peer_wrapped_escrow_record_status;
        *(void *)&long long v21 = der_key_peer_flags;
        der_dict_iterate();
        _DWORD *v2 = der_get_number();
        v2[1] = der_get_number();
        v2[2] = der_get_number();
        uint64_t v7 = 0;
        v2[3] = der_get_number();
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_remote_peer_get_state", ":", 2255, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v7;
}

uint64_t aks_remote_peer_drop(int a1, const void *a2, size_t a3)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x3Au, input, 1u, a2, a3, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_remote_peer_drop", ":", 2292, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_lock_device(int a1, int a2)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2) {
      uint32_t v4 = 32;
    }
    else {
      uint32_t v4 = 8;
    }
    return IOConnectCallMethod(aks_client_connection, v4, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_lock_device", ":", 2307, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_lock_cx(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x8Du, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_lock_cx", ":", 2327, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_unlock_device(int a1, uint64_t a2, int a3)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  input[0] = a1;
  input[1] = a2;
  uint64_t input[2] = a3;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 9u, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_unlock_device", ":", 2342, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_obliterate_class_d()
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x13u, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_obliterate_class_d", ":", 2355, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_migrate_s_key(int a1, unsigned int a2, uint64_t a3, unsigned int a4, const void *a5, int a6)
{
  uint64_t input[4] = *MEMORY[0x263EF8340];
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    input[0] = a1;
    input[1] = a2;
    uint64_t input[2] = a3;
    uint64_t input[3] = a4;
    return IOConnectCallMethod(aks_client_connection, 0x3Fu, input, 4u, a5, a6, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_migrate_s_key", ":", 2367, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_smartcard_register(int a1, uint64_t a2, uint64_t a3, unsigned int a4, const void *a5, size_t a6, void *a7, size_t *a8)
{
  uint64_t input[4] = *MEMORY[0x263EF8340];
  input[0] = a1;
  input[1] = a4;
  uint64_t input[2] = a2;
  uint64_t input[3] = a3;
  size_t __count = 2048;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v13 = aks_client_connection;
    bzero(__src, 0x800uLL);
    uint64_t v14 = IOConnectCallMethod(v13, 0x3Bu, input, 4u, a5, a6, 0, 0, __src, &__count);
    if (v14)
    {
      return v14;
    }
    else if (__count > 0x800)
    {
      return 3758604298;
    }
    else
    {
      uint64_t v15 = 0;
      if (a7 && a8)
      {
        if (__count)
        {
          long long v16 = calloc(__count, 1uLL);
          *a7 = v16;
          if (!v16) {
            return 3758097085;
          }
          memcpy(v16, __src, __count);
          size_t v17 = __count;
        }
        else
        {
          size_t v17 = 0;
        }
        uint64_t v15 = 0;
        *a8 = v17;
      }
    }
  }
  else
  {
    uint64_t v15 = 3758097084;
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_smartcard_register", ":", 2388, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v15;
}

uint64_t aks_smartcard_unregister(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x3Cu, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_smartcard_unregister", ":", 2412, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_smartcard_request_unlock(int a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  size_t __count = 2048;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v10 = aks_client_connection;
    bzero(__src, 0x800uLL);
    uint64_t v11 = IOConnectCallMethod(v10, 0x3Du, input, 1u, a2, a3, 0, 0, __src, &__count);
    if (v11)
    {
      return v11;
    }
    else if (__count > 0x800)
    {
      return 3758604298;
    }
    else
    {
      uint64_t v12 = 0;
      if (a4 && a5)
      {
        if (__count)
        {
          mach_port_t v13 = calloc(__count, 1uLL);
          *a4 = v13;
          if (!v13) {
            return 3758097085;
          }
          memcpy(v13, __src, __count);
          size_t v14 = __count;
        }
        else
        {
          size_t v14 = 0;
        }
        uint64_t v12 = 0;
        *a5 = v14;
      }
    }
  }
  else
  {
    uint64_t v12 = 3758097084;
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_smartcard_request_unlock", ":", 2429, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  return v12;
}

uint64_t aks_smartcard_unlock(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, size_t *a7)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  bzero(__src, 0x800uLL);
  size_t __count = 2048;
  aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v10, v11, v12, v13, v14, a2);
  if (!*(void *)&inputStructCnt[1])
  {
    uint64_t v17 = 3758097085;
    goto LABEL_12;
  }
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_smartcard_unlock", ":", 2460, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v17 = 3758097084;
    goto LABEL_12;
  }
  uint64_t v16 = IOConnectCallMethod(aks_client_connection, 0x3Eu, input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
  if (v16)
  {
    uint64_t v17 = v16;
    goto LABEL_12;
  }
  if (__count > 0x800)
  {
    uint64_t v17 = 3758604298;
    goto LABEL_12;
  }
  uint64_t v17 = 0;
  if (a6 && a7)
  {
    if (!__count)
    {
      size_t v19 = 0;
      goto LABEL_11;
    }
    int v18 = calloc(__count, 1uLL);
    *a6 = v18;
    uint64_t v17 = 3758097085;
    if (v18)
    {
      memcpy(v18, __src, __count);
      size_t v19 = __count;
LABEL_11:
      uint64_t v17 = 0;
      *a7 = v19;
    }
  }
LABEL_12:
  free(*(void **)&inputStructCnt[1]);
  return v17;
}

uint64_t aks_smartcard_get_sc_usk(unint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a3 && a4)
  {
    if (aks_smartcard_get_foo((uint64_t)der_key_sc_enc_sc_usk, 0, a1, a2, a3, a4)) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t aks_smartcard_get_foo(uint64_t a1, int a2, unint64_t a3, uint64_t a4, uint64_t *a5, void *a6)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a6 && a3 && a4 && a5 && a3 + a4 > a3)
  {
    der_dict_iterate();
    if (a2)
    {
      if (*a6 == 8)
      {
        uint64_t number = der_get_number();
        uint64_t result = 0;
        *a5 = number;
        return result;
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v11 = ccder_decode_tl();
    if (!v11) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v12 = v11;
    uint64_t result = 0;
    *a5 = v12;
    *a6 = 0;
  }
  return result;
}

uint64_t aks_smartcard_get_ec_pub(unint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a3 && a4)
  {
    if (aks_smartcard_get_foo((uint64_t)der_key_sc_auth_eph_pub, 0, a1, a2, a3, a4)) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t aks_smartcard_get_mode(unint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5 = 8;
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = 0;
  uint64_t result = aks_smartcard_get_foo((uint64_t)der_key_sc_auth_mode, 1, a1, a2, &v6, &v5);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *a3 = v6;
  return result;
}

uint64_t aks_smartcard_get_version(unint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5 = 8;
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = 0;
  uint64_t result = aks_smartcard_get_foo((uint64_t)der_key_sc_auth_version, 1, a1, a2, &v6, &v5);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  *a3 = v6;
  return result;
}

uint64_t aks_se_fail(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x47u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_fail", ":", 2589, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_se_set_healthy(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x49u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_set_healthy", ":", 2605, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_se_set_secret(int a1, uint64_t a2, uint64_t a3)
{
  return __aks_se_set_secret(a1, a2, a3, 0x45u);
}

uint64_t __aks_se_set_secret(int a1, uint64_t a2, uint64_t a3, uint32_t a4)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  input[0] = a1;
  input[1] = a2;
  uint64_t input[2] = a3;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, a4, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "__aks_se_set_secret", ":", 2621, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_se_set_secret_memento(int a1, uint64_t a2, uint64_t a3)
{
  return __aks_se_set_secret(a1, a2, a3, 0x8Cu);
}

uint64_t aks_se_recover(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  input[0] = a1;
  input[1] = a2;
  uint64_t input[2] = a3;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x46u, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_recover", ":", 2649, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_change_secret_epilogue(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  input[0] = a1;
  input[1] = a2;
  uint64_t input[2] = a3;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x69u, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_change_secret_epilogue", ":", 2665, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_se_get_reset_token_for_memento_secret()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t input[3] = *MEMORY[0x263EF8340];
  input[0] = v0;
  input[1] = v3;
  uint64_t input[2] = v4;
  bzero(__s, 0x1000uLL);
  __n[0] = 4096;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    uint64_t v8 = 3758097084;
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_get_reset_token_for_memento_secret", ":", 2683, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    goto LABEL_10;
  }
  uint64_t v6 = IOConnectCallMethod(aks_client_connection, 0x48u, input, 3u, 0, 0, 0, 0, __s, __n);
  if (v6)
  {
    uint64_t v8 = v6;
    goto LABEL_10;
  }
  if (__n[0] - 4097 < 0xFFFFFFFFFFFFF000)
  {
    uint64_t v8 = 3758604298;
    goto LABEL_10;
  }
  uint64_t v15 = 0;
  long long v14 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  __n[1] = (rsize_t)der_key_config_se_reset_token;
  long long v13 = (unint64_t)der_key_config_se_slot;
  der_dict_iterate();
  if ((void)v11)
  {
    ccder_decode_tl();
LABEL_9:
    uint64_t v8 = 0;
    goto LABEL_10;
  }
  if (!*((void *)&v13 + 1)) {
    goto LABEL_9;
  }
  unint64_t number = der_get_number();
  if (number > 0xFF) {
    goto LABEL_9;
  }
  uint64_t v8 = 0;
  unsigned char *v2 = number;
LABEL_10:
  memset_s(__s, __n[0], 0, __n[0]);
  return v8;
}

uint64_t aks_se_get_reset_token()
{
  return aks_se_get_reset_token_for_memento_secret();
}

uint64_t aks_se_set_nonce(int a1, const void *a2, size_t a3)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    if (a2) {
      size_t v6 = a3;
    }
    else {
      size_t v6 = 0;
    }
    return IOConnectCallMethod(aks_client_connection, 0x58u, input, 1u, a2, v6, 0, 0, 0, 0);
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_set_nonce", ":", 2737, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
}

uint64_t aks_se_get_reset_sig()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  size_t v6 = v5;
  uint64_t v8 = v7;
  input[1] = *MEMORY[0x263EF8340];
  input[0] = v0;
  bzero(&__s, 0x1000uLL);
  size_t __n = 4096;
  uint64_t v9 = 3758097090;
  if (v8)
  {
    if (v6)
    {
      uint64_t v9 = 3758097090;
      if (v4)
      {
        if (v2)
        {
          mach_port_t aks_client_connection = get_aks_client_connection();
          if (aks_client_connection)
          {
            uint64_t v11 = IOConnectCallMethod(aks_client_connection, 0x5Au, input, 1u, 0, 0, 0, 0, &__s, &__n);
            if (v11)
            {
              uint64_t v9 = v11;
            }
            else if (__n - 4097 < 0xFFFFFFFFFFFFF005)
            {
              uint64_t v9 = 3758604298;
            }
            else
            {
              long long v12 = calloc(5uLL, 1uLL);
              void *v4 = v12;
              if (v12)
              {
                void *v2 = 5;
                int v13 = __s;
                v12[4] = v19;
                *(_DWORD *)long long v12 = v13;
                long long v14 = calloc(__n - 5, 1uLL);
                void *v8 = v14;
                uint64_t v9 = 3758097085;
                if (v14)
                {
                  size_t v15 = __n;
                  *size_t v6 = __n - 5;
                  memcpy(v14, v20, v15);
                  uint64_t v9 = 0;
                }
              }
              else
              {
                uint64_t v9 = 3758097085;
              }
            }
          }
          else
          {
            fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_get_reset_sig", ":", 2759, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
            uint64_t v9 = 3758097084;
          }
        }
      }
    }
  }
  memset_s(&__s, __n, 0, __n);
  return v9;
}

uint64_t aks_se_get_reset_pubkey()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  input[1] = *MEMORY[0x263EF8340];
  input[0] = v0;
  size_t v5 = 4096;
  bzero(__src, 0x1000uLL);
  size_t __count = 4096;
  uint64_t v6 = 3758097090;
  if (v4 && v2)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      uint64_t v8 = IOConnectCallMethod(aks_client_connection, 0x59u, input, 1u, 0, 0, 0, 0, __src, &__count);
      size_t v5 = __count;
      if (v8)
      {
        uint64_t v6 = v8;
      }
      else if (__count - 4097 < 0xFFFFFFFFFFFFF000)
      {
        uint64_t v6 = 3758604298;
      }
      else
      {
        uint64_t v9 = calloc(__count, 1uLL);
        void *v4 = v9;
        size_t v5 = __count;
        if (v9)
        {
          size_t *v2 = __count;
          memcpy(v9, __src, v5);
          uint64_t v6 = 0;
          size_t v5 = __count;
        }
        else
        {
          uint64_t v6 = 3758097085;
        }
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_get_reset_pubkey", ":", 2791, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      size_t v5 = 4096;
      uint64_t v6 = 3758097084;
    }
  }
  memset_s(__src, v5, 0, v5);
  return v6;
}

uint64_t aks_se_delete_reset_token(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x5Bu, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_delete_reset_token", ":", 2815, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_se_support_in_rm(unsigned int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x5Eu, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_support_in_rm", ":", 2832, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_se_support_in_rm_is_set(BOOL *a1)
{
  output[1] = *MEMORY[0x263EF8340];
  output[0] = 0;
  uint32_t outputCnt = 1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t result = IOConnectCallMethod(aks_client_connection, 0x6Bu, 0, 0, 0, 0, output, &outputCnt, 0, 0);
    if (a1)
    {
      if (!result) {
        *a1 = output[0] != 0;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_support_in_rm_is_set", ":", 2848, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  return result;
}

uint64_t aks_se_stage_stash()
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x5Fu, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_stage_stash", ":", 2865, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_fv_lock_volume_bag()
{
  return aks_fv_set_protection();
}

uint64_t aks_fv_unwrap_vek()
{
  return aks_fv_unwrap_vek_with_acm();
}

uint64_t aks_fv_get_blob_state()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v5 = v0;
  uint64_t v14 = *MEMORY[0x263EF8340];
  bzero(__s, 0x1000uLL);
  *(void *)&long long v11 = __s;
  *((void *)&v11 + 1) = &v14;
  *(void *)long long v12 = 4096;
  uint64_t v6 = 3758097090;
  if (v4 && v2)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      mach_port_t v8 = aks_client_connection;
      if (der_utils_encode_fv_data(&v11, v4) && der_utils_encode_fv_params(&v11, v5))
      {
        uint64_t v6 = 3758097098;
        if (ccder_blob_encode_tl())
        {
          uint64_t v9 = IOConnectCallMethod(v8, 0x55u, 0, 0, *((const void **)&v11 + 1), (size_t)&v14 - *((void *)&v11 + 1), 0, 0, __s, (size_t *)v12);
          if (!v9) {
            uint64_t v9 = decode_fv_blob_state((uint64_t)__s, *(uint64_t *)v12, v2);
          }
          uint64_t v6 = v9;
        }
      }
      else
      {
        uint64_t v6 = 3758097098;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fv_get_blob_state", ":", 2900, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v6 = 3758097084;
    }
  }
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v6;
}

uint64_t aks_fv_get_last_known_gp_state()
{
  return aks_fv_get_blob_state();
}

uint64_t aks_fv_get_size()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v3 = v0;
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097098;
  uint64_t output = 0;
  input[0] = v5;
  uint32_t outputCnt = 1;
  bzero(__s, 0x1000uLL);
  *(void *)&long long v9 = __s;
  *((void *)&v9 + 1) = &output;
  if (v2)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      mach_port_t v7 = aks_client_connection;
      if (der_utils_encode_fv_params(&v9, v3))
      {
        if (ccder_blob_encode_tl())
        {
          uint64_t v4 = IOConnectCallMethod(v7, 0x4Eu, input, 1u, *((const void **)&v9 + 1), (size_t)&input[-1] - *((void *)&v9 + 1), &output, &outputCnt, 0, 0);
          if (!v4) {
            uint64_t *v2 = output;
          }
        }
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fv_get_size", ":", 2943, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v4 = 3758097084;
    }
  }
  else
  {
    uint64_t v4 = 3758097090;
  }
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v4;
}

uint64_t aks_fv_import()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  uint64_t v7 = v0;
  input[1] = *MEMORY[0x263EF8340];
  input[0] = v8;
  bzero(__s, 0x1000uLL);
  *(void *)&long long v15 = __s;
  *((void *)&v15 + 1) = input;
  size_t v16 = 4096;
  uint64_t v9 = 3758097090;
  if (v6 && v4)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (!aks_client_connection)
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fv_import", ":", 2971, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v9 = 3758097084;
      goto LABEL_14;
    }
    mach_port_t v11 = aks_client_connection;
    if (!ccder_blob_encode_body_tl()
      || !der_utils_encode_fv_data(&v15, v6)
      || !der_utils_encode_fv_params(&v15, v7)
      || !ccder_blob_encode_tl())
    {
      goto LABEL_12;
    }
    uint64_t v12 = IOConnectCallMethod(v11, 0x4Fu, input, 1u, *((const void **)&v15 + 1), (size_t)input - *((void *)&v15 + 1), 0, 0, __s, &v16);
    if (v12)
    {
      uint64_t v9 = v12;
      goto LABEL_14;
    }
    *(void *)&long long v14 = __s;
    *((void *)&v14 + 1) = &__s[v16];
    if (!ccder_blob_decode_range()) {
      goto LABEL_12;
    }
    if (!v2)
    {
      uint64_t v9 = 0;
      goto LABEL_14;
    }
    uint64_t v9 = 0;
    if ((der_utils_decode_fv_data(&v14, 0, v2) & 1) == 0) {
LABEL_12:
    }
      uint64_t v9 = 3758097098;
  }
LABEL_14:
  memset_s(__s, 0x1000uLL, 0, 0x1000uLL);
  return v9;
}

uint64_t aks_fv_get_verifier_size()
{
  return aks_fv_get_size();
}

uint64_t aks_fv_get_access_token_size()
{
  return aks_fv_get_size();
}

uint64_t aks_fv_new_verifier()
{
  return aks_fv_new_kek();
}

uint64_t aks_fv_rewrap_verifier()
{
  return aks_fv_rewrap_kek();
}

uint64_t aks_fv_new_access_token()
{
  return aks_fv_new_vek();
}

uint64_t aks_fv_new_unbound_access_token()
{
  return aks_fv_new_vek();
}

uint64_t aks_fv_bind_access_token()
{
  return aks_fv_set_protection();
}

uint64_t aks_fv_is_access_token_unbound(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 3758097090;
  }
  uint64_t result = aks_fv_get_blob_state();
  if (!result) {
    return 3758604312;
  }
  return result;
}

uint64_t aks_fv_load_access_token_as_system_keychain()
{
  return aks_fv_set_protection();
}

uint64_t aks_fv_verify_user_opts()
{
  return aks_fv_unwrap_vek_with_acm();
}

uint64_t aks_fv_grant_ownership()
{
  MEMORY[0x270FA5388]();
  uint64_t v1 = v0;
  uint64_t v3 = v2;
  uint64_t v5 = v4;
  uint64_t v7 = v6;
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v8 = 3758097098;
  bzero(v13, 0x1000uLL);
  bzero(v12, 0x1000uLL);
  *(void *)&long long v11 = v13;
  *((void *)&v11 + 1) = &v14;
  *(void *)&long long v10 = v12;
  *((void *)&v10 + 1) = v13;
  if (der_utils_encode_fv_data(&v11, v7)
    && der_utils_encode_fv_data(&v11, v5)
    && ccder_blob_encode_tl()
    && der_utils_encode_fv_data(&v10, v3)
    && der_utils_encode_fv_data(&v10, v1)
    && ccder_blob_encode_tl())
  {
    return aks_fv_set_protection();
  }
  return v8;
}

uint64_t aks_fv_owners_exist()
{
  return aks_fv_set_protection();
}

uint64_t aks_fv_remove_external_kek_group()
{
  return aks_fv_set_protection();
}

uint64_t aks_fv_sidp_status()
{
  MEMORY[0x270FA5388]();
  uint64_t v1 = v0;
  uint64_t v3 = v2;
  uint64_t v6 = *MEMORY[0x263EF8340];
  bzero(v5, 0x4000uLL);
  uint64_t result = aks_fv_set_protection();
  if (!result)
  {
    if (ccder_decode_sequence_tl() && ccder_decode_tl())
    {
      __memcpy_chk();
      if (v3) {
        unsigned char *v3 = 0;
      }
      if (v1) {
        unsigned char *v1 = 0;
      }
      return 0;
    }
    else
    {
      return 3758097084;
    }
  }
  return result;
}

uint64_t aks_fv_stash_kek()
{
  return aks_fv_set_protection();
}

uint64_t aks_fv_stash_kek_with_secret(int a1)
{
  uint64_t v1 = 8;
  if (a1) {
    uint64_t v1 = 12;
  }
  uint64_t v4 = v1;
  uint64_t v2 = aks_fv_set_protection();
  syslog(6, "aks_fv_prot_cmd_stash_kek(%llu) = %d", v4, v2);
  return v2;
}

uint64_t aks_fv_commit_stashed_kek()
{
  uint64_t v0 = aks_fv_set_protection();
  syslog(6, "aks_fv_prot_cmd_stash_commit = %d", v0);
  return v0;
}

uint64_t aks_fv_destroy_stashed_kek()
{
  uint64_t v0 = aks_fv_set_protection();
  syslog(6, "aks_fv_prot_cmd_stash_destroy = %d", v0);
  return v0;
}

uint64_t aks_fv_verify_user()
{
  return aks_fv_unwrap_vek_with_acm();
}

uint64_t aks_fv_delete_verifier()
{
  return aks_fv_set_protection();
}

uint64_t aks_absinthe_collection()
{
  unsigned int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  uint64_t v6 = v5;
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v7 = 3758097084;
  input[0] = v0;
  bzero(__src, 0x8000uLL);
  size_t __count = 0x8000;
  memset(inputStructCnt, 0, sizeof(inputStructCnt));
  if (v4)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      mach_port_t v14 = aks_client_connection;
      if (v6) {
        long long v15 = v6;
      }
      else {
        long long v15 = &unk_22004A573;
      }
      aks_pack_data((char **)&inputStructCnt[1], inputStructCnt, 2, v9, v10, v11, v12, v13, (uint64_t)v15);
      uint64_t v16 = IOConnectCallMethod(v14, 0x50u, input, 1u, *(const void **)&inputStructCnt[1], (int)inputStructCnt[0], 0, 0, __src, &__count);
      if (v16)
      {
        uint64_t v7 = v16;
      }
      else
      {
        uint64_t v17 = calloc(__count, 1uLL);
        void *v4 = v17;
        if (v17)
        {
          memcpy(v17, __src, __count);
          uint64_t v7 = 0;
          void *v2 = (int)__count;
        }
        else
        {
          uint64_t v7 = 3758097085;
        }
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_absinthe_collection", ":", 3220, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    }
  }
  else
  {
    uint64_t v7 = 3758097090;
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  free(*(void **)&inputStructCnt[1]);
  return v7;
}

uint64_t aks_absinthe_generate(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, size_t *a7)
{
  input[1] = *MEMORY[0x263EF8340];
  long long v21 = 0;
  input[0] = a1;
  int v20 = 0;
  uint64_t v7 = 3758097090;
  if (a2 && a6 && a7)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      mach_port_t v17 = aks_client_connection;
      aks_pack_data(&v21, (unsigned int *)&v20, 2, v12, v13, v14, v15, v16, a2);
      size_t v19 = *a7;
      uint64_t v7 = IOConnectCallMethod(v17, 0x51u, input, 1u, v21, v20, 0, 0, a6, &v19);
      if (!v7) {
        *a7 = (int)v19;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_absinthe_generate", ":", 3253, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      uint64_t v7 = 3758097084;
    }
  }
  free(v21);
  return v7;
}

uint64_t aks_drop_auxiliary_auth_by_uid(unsigned int a1)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  input[0] = 0;
  input[1] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x53u, input, 2u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_drop_auxiliary_auth_by_uid", ":", 3280, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_drop_auxiliary_auth_by_handle(int a1)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  input[0] = 1;
  input[1] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x53u, input, 2u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_drop_auxiliary_auth_by_handle", ":", 3296, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_lower_iteration_count()
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x5Cu, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_lower_iteration_count", ":", 3310, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_se_secret_drop(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x6Au, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_se_secret_drop", ":", 3326, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_get_current_sep_measurement(uint64_t a1, uint64_t a2)
{
  if (a1 && a2 && !aks_get_internal_info_for_key()) {
    der_dict_get_data((uint64_t)der_key_sep_measurement);
  }
  free(0);
  return 3758097084;
}

uint64_t aks_get_internal_info()
{
  return aks_get_internal_info_for_key();
}

uint64_t aks_get_seconds_since_passcode_change(uint64_t a1, void *a2)
{
  uint64_t v3 = 3758097084;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v7 = 0;
  if (!aks_get_internal_info_for_key()
    && der_dict_get_number((uint64_t)der_key_passcode_change_time, (uint64_t)v9, (uint64_t)v9 + v8, (uint64_t)&v7))
  {
    if (a2)
    {
      time_t v4 = time(0);
      uint64_t v3 = 0;
      time_t v5 = v4 - v7;
      if (v4 <= v7) {
        time_t v5 = 0;
      }
      *a2 = v5;
    }
    else
    {
      uint64_t v3 = 0;
    }
  }
  free(v9);
  return v3;
}

uint64_t aks_get_internal_state()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  input[1] = *MEMORY[0x263EF8340];
  uint64_t v3 = 3758097090;
  input[0] = v0;
  bzero(__s, 0x1000uLL);
  rsize_t __n = 4096;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (!aks_client_connection)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_get_internal_state", ":", 3405, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v3 = 3758097084;
    goto LABEL_11;
  }
  if (!v2)
  {
LABEL_11:
    rsize_t v6 = 4096;
    goto LABEL_9;
  }
  uint64_t v5 = IOConnectCallMethod(aks_client_connection, 0x8Eu, input, 1u, 0, 0, 0, 0, __s, &__n);
  rsize_t v6 = __n;
  if (v5)
  {
    uint64_t v3 = v5;
  }
  else if (__n - 4097 >= 0xFFFFFFFFFFFFF000)
  {
    if (decode_extended_state((uint64_t)__s, __n, v2)) {
      uint64_t v3 = 3758097090;
    }
    else {
      uint64_t v3 = 0;
    }
    rsize_t v6 = __n;
  }
LABEL_9:
  memset_s(__s, v6, 0, v6);
  return v3;
}

uint64_t aks_fairplay_wrap(const void *a1, size_t a2, void *a3, size_t *a4)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = 266;
  uint64_t result = 3758097090;
  if (a3 && a4)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      size_t v10 = *a4;
      uint64_t result = IOConnectCallMethod(aks_client_connection, 0x68u, input, 1u, a1, a2, 0, 0, a3, &v10);
      if (!result) {
        *a4 = (int)v10;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_fairplay_wrap", ":", 3431, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      return 3758097084;
    }
  }
  return result;
}

uint64_t _fairplay_generate_csk_internal(unsigned int a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = ((unint64_t)a1 << 8) | 1;
  uint64_t result = 3758097090;
  if (a4 && a5)
  {
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      size_t v11 = *a5;
      uint64_t result = IOConnectCallMethod(aks_client_connection, 0x68u, input, 1u, a2, a3, 0, 0, a4, &v11);
      if (!result) {
        *a5 = (int)v11;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "_fairplay_generate_csk_internal", ":", 3455, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
      return 3758097084;
    }
  }
  return result;
}

uint64_t aks_fairplay_generate_csk(const void *a1, size_t a2, void *a3, size_t *a4)
{
  return _fairplay_generate_csk_internal(0, a1, a2, a3, a4);
}

uint64_t aks_fairplay_generate_csk_v1(const void *a1, size_t a2, void *a3, size_t *a4)
{
  return _fairplay_generate_csk_internal(1u, a1, a2, a3, a4);
}

uint64_t aks_bak_get_beacon_internal()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  time_t v4 = v3;
  size_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v0;
  uint64_t v20 = *MEMORY[0x263EF8340];
  long long v18 = 0u;
  memset(v19, 0, sizeof(v19));
  bzero(__s, 0x4000uLL);
  size_t v15 = 0x4000;
  input[0] = 1;
  input[1] = v9;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v11 = IOConnectCallMethod(aks_client_connection, 0x87u, input, 2u, v8, v6, 0, 0, __s, &v15);
    if (v11)
    {
      uint64_t v13 = v11;
    }
    else
    {
      __memcpy_chk();
      void *v2 = 44;
      uint64_t v12 = calloc(0x2CuLL, 1uLL);
      void *v4 = v12;
      if (v12)
      {
        __memcpy_chk();
        uint64_t v13 = 0;
      }
      else
      {
        uint64_t v13 = 3758097085;
      }
    }
  }
  else
  {
    uint64_t v13 = 3758097084;
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_bak_get_beacon_internal", ":", 3491, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  }
  memset_s(__s, 0x4000uLL, 0, 0x4000uLL);
  return v13;
}

uint64_t aks_bak_get_beacon()
{
  uint64_t beacon_internal = aks_bak_get_beacon_internal();
  if (beacon_internal) {
    return beacon_internal;
  }
  else {
    return 3758604312;
  }
}

uint64_t aks_bak_get_swizzler_internal()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  time_t v4 = v3;
  size_t v6 = v5;
  uint64_t v8 = v7;
  uint64_t input[2] = *MEMORY[0x263EF8340];
  input[0] = 2;
  input[1] = v0;
  int v36 = 0;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  memset(v26, 0, sizeof(v26));
  bzero(__s, 0x4000uLL);
  size_t v24 = 0x4000;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v10 = IOConnectCallMethod(aks_client_connection, 0x87u, input, 2u, 0, 0, 0, 0, __s, &v24);
    if (v10)
    {
      uint64_t v11 = v10;
    }
    else
    {
      uint64_t v11 = 3758097085;
      __memcpy_chk();
      uint64_t v12 = calloc(0x28uLL, 1uLL);
      void *v8 = v12;
      if (v12)
      {
        *size_t v6 = 40;
        long long v13 = *(_OWORD *)&v26[1];
        long long v14 = *(_OWORD *)&v26[3];
        v12[4] = v26[5];
        *(_OWORD *)uint64_t v12 = v13;
        *((_OWORD *)v12 + 1) = v14;
        size_t v15 = calloc(0x91uLL, 1uLL);
        void *v4 = v15;
        if (v15)
        {
          uint64_t v11 = 0;
          void *v2 = 145;
          long long v16 = v28;
          _OWORD *v15 = v27;
          v15[1] = v16;
          long long v17 = v29;
          long long v18 = v30;
          long long v19 = v32;
          v15[4] = v31;
          v15[5] = v19;
          v15[2] = v17;
          v15[3] = v18;
          long long v20 = v33;
          long long v21 = v34;
          long long v22 = v35;
          *((unsigned char *)v15 + 144) = v36;
          v15[7] = v21;
          v15[8] = v22;
          v15[6] = v20;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_bak_get_swizzler_internal", ":", 3551, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v11 = 3758097084;
  }
  memset_s(__s, 0x4000uLL, 0, 0x4000uLL);
  memset_s(v26, 0xC4uLL, 0, 0xC4uLL);
  return v11;
}

uint64_t aks_bak_get_swizzler()
{
  return aks_bak_get_swizzler_internal();
}

uint64_t aks_test_stashed_kek(uint64_t a1)
{
  mach_port_t akstest_client_connection = get_akstest_client_connection();
  if (akstest_client_connection) {
    return IOConnectCallMethod(akstest_client_connection, 0xCu, 0, 0, *(const void **)a1, *(void *)(a1 + 8), 0, 0, 0, 0);
  }
  else {
    return 3758097084;
  }
}

uint64_t aks_get_dsme_key()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  uint64_t v3 = (void *)v0;
  uint64_t v12 = *MEMORY[0x263EF8340];
  bzero(__src, 0x4000uLL);
  size_t __count = 0x4000;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v5 = 3758097090;
    if (v3 && v2)
    {
      uint64_t v6 = IOConnectCallMethod(aks_client_connection, 0x96u, 0, 0, 0, 0, 0, 0, __src, &__count);
      if (v6)
      {
        uint64_t v5 = v6;
      }
      else
      {
        uint64_t v7 = calloc(__count, 1uLL);
        void *v3 = v7;
        if (v7)
        {
          size_t v8 = __count;
          size_t *v2 = __count;
          memcpy(v7, __src, v8);
          uint64_t v5 = 0;
        }
        else
        {
          uint64_t v5 = 3758097085;
        }
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_get_dsme_key", ":", 3600, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v5 = 3758097084;
  }
  memset_s(__src, 0x4000uLL, 0, 0x4000uLL);
  return v5;
}

BOOL aks_bag_in_xart(uint64_t a1, uint64_t a2)
{
  return a2 == 4 || a2 == 32;
}

uint64_t aks_prewarm_sps()
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x73u, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_prewarm_sps", ":", 3627, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_sealed_hashes_set(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  v11[1] = *MEMORY[0x263EF8340];
  uint64_t v4 = 4294967285;
  if (a3 && a4 <= 0x30)
  {
    uint64_t v4 = 3758097084;
    mach_port_t aks_client_connection = get_aks_client_connection();
    if (aks_client_connection)
    {
      mach_port_t v6 = aks_client_connection;
      ccder_sizeof_raw_octet_string();
      ccder_sizeof_uint64();
      ccder_sizeof_raw_octet_string();
      size_t v7 = ccder_sizeof();
      MEMORY[0x270FA5388]();
      uint64_t v9 = (char *)v11 - v8;
      bzero((char *)v11 - v8, v7);
      ccder_encode_raw_octet_string();
      ccder_encode_uint64();
      ccder_encode_raw_octet_string();
      if ((char *)ccder_encode_constructed_tl() == v9) {
        return IOConnectCallMethod(v6, 0x72u, 0, 0, v9, v7, 0, 0, 0, 0);
      }
      else {
        return 3758097090;
      }
    }
    else
    {
      fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_sealed_hashes_set", ":", 3644, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    }
  }
  return v4;
}

uint64_t aks_measure_and_seal_cryptex_manifest(const void *a1, size_t a2)
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x90u, 0, 0, a1, a2, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_measure_and_seal_cryptex_manifest", ":", 3674, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_seal_cryptex_manifest_lock()
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x95u, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_seal_cryptex_manifest_lock", ":", 3688, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_lkgp_recover(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  input[0] = a1;
  input[1] = a2;
  uint64_t input[2] = a3;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x85u, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_lkgp_recover", ":", 3704, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_memento_efface_blob(int a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x8Au, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_memento_efface_blob", ":", 3720, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_memento_get_state()
{
  int v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  input[1] = *MEMORY[0x263EF8340];
  input[0] = v0;
  bzero(__s, 0x1000uLL);
  rsize_t __n = 4096;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    uint64_t v4 = IOConnectCallMethod(aks_client_connection, 0x8Bu, input, 1u, 0, 0, 0, 0, __s, &__n);
    rsize_t v5 = __n;
    if (v4)
    {
      uint64_t v6 = v4;
    }
    else
    {
      uint64_t v6 = 3758097090;
      if (__n - 4097 >= 0xFFFFFFFFFFFFF000)
      {
        if (decode_memento_state((uint64_t)__s, __n, v2)) {
          uint64_t v6 = 3758097090;
        }
        else {
          uint64_t v6 = 0;
        }
        rsize_t v5 = __n;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_memento_get_state", ":", 3738, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    uint64_t v6 = 3758097084;
    rsize_t v5 = 4096;
  }
  memset_s(__s, v5, 0, v5);
  return v6;
}

uint64_t aks_set_jcop_supports_updated_kud_policy()
{
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x89u, &input, 0, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_set_jcop_supports_updated_kud_policy", ":", 3758, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_set_cx_window(uint64_t a1)
{
  input[1] = *MEMORY[0x263EF8340];
  input[0] = a1;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection) {
    return IOConnectCallMethod(aks_client_connection, 0x97u, input, 1u, 0, 0, 0, 0, 0, 0);
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_set_cx_window", ":", 3774, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 3758097084;
}

uint64_t aks_get_cx_window()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  outputStruct[512] = *MEMORY[0x263EF8340];
  size_t v5 = 4096;
  if (!v0) {
    return 4294967285;
  }
  uint64_t v1 = (void *)v0;
  mach_port_t aks_client_connection = get_aks_client_connection();
  if (aks_client_connection)
  {
    mach_port_t v3 = aks_client_connection;
    bzero(outputStruct, 0x1000uLL);
    uint64_t result = IOConnectCallMethod(v3, 0x98u, 0, 0, 0, 0, 0, 0, outputStruct, &v5);
    if (!result)
    {
      if (v5 == 8)
      {
        uint64_t result = 0;
        void *v1 = outputStruct[0];
      }
      else
      {
        return 3758604298;
      }
    }
  }
  else
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "aks_get_cx_window", ":", 3791, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 3758097084;
  }
  return result;
}

uint64_t get_aks_log_pid()
{
  return 0;
}

uint64_t compress_uuid()
{
  return 0;
}

unint64_t time_seconds_to_abs_interval(unsigned int a1)
{
  mach_timebase_info info = 0;
  mach_timebase_info(&info);
  return 1000000000 * info.denom * (unint64_t)a1 / info.numer;
}

unint64_t time_absolute_to_nanoseconds(uint64_t a1)
{
  mach_timebase_info info = 0;
  mach_timebase_info(&info);
  return (unint64_t)info.numer * a1 / info.denom;
}

uint64_t get_usec_time()
{
  mach_timebase_info info = 0;
  mach_timebase_info(&info);
  return mach_continuous_time() * info.numer / info.denom / 0x3E8;
}

__darwin_time_t get_clock_time()
{
  v1.tv_sec = 0;
  *(void *)&v1.tv_usec = 0;
  gettimeofday(&v1, 0);
  return v1.tv_sec;
}

uint64_t ipc_seconds_to_microsecond_interval(uint64_t a1)
{
  return 1000000 * a1;
}

unint64_t ipc_microseconds_to_seconds(uint64_t a1)
{
  return (a1 + 999999) / 0xF4240uLL;
}

void *circular_queue_init(unsigned int a1, unsigned int a2)
{
  uint64_t v2 = a1 + 1;
  uint64_t v3 = v2 << 31 >> 31;
  if (v3 != v2 || v3 < 0)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s overflow%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "circular_queue_init", ":", 341, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    return 0;
  }
  else
  {
    size_t v5 = calloc(0x20uLL, 1uLL);
    uint64_t v6 = v5;
    if (v5)
    {
      v5[1] = 0;
      size_t v7 = (v3 & 0x1FFFFFFFFLL) * a2;
      *(_DWORD *)size_t v5 = a2;
      *((_DWORD *)v5 + 1) = v2;
      uint64_t v8 = calloc(v7, 1uLL);
      v6[2] = v7;
      v6[3] = v8;
    }
  }
  return v6;
}

uint64_t circular_queue_size(_DWORD *a1)
{
  unsigned int v3 = a1[2];
  unsigned int v2 = a1[3];
  uint64_t result = v2 - v3;
  if (v2 < v3) {
    return (result + a1[1]);
  }
  return result;
}

uint64_t circular_queue_enqueue(unsigned int *a1, const void *a2)
{
  unsigned int v3 = a1[3];
  unsigned int v4 = (v3 + 1) % a1[1];
  memcpy((void *)(*((void *)a1 + 3) + *a1 * v3), a2, *a1);
  a1[3] = v4;
  if (v4 == a1[2]) {
    a1[2] = (v4 + 1) % a1[1];
  }
  return 0;
}

uint64_t circular_queue_dequeue(unsigned int *a1, void *__dst)
{
  unsigned int v2 = a1[2];
  if (v2 == a1[3]) {
    return 0xFFFFFFFFLL;
  }
  if (__dst)
  {
    memcpy(__dst, (const void *)(*((void *)a1 + 3) + *a1 * v2), *a1);
    unsigned int v2 = a1[2];
  }
  memset_s((void *)(*((void *)a1 + 3) + *a1 * v2), *a1, 0, *a1);
  uint64_t result = 0;
  a1[2] = (a1[2] + 1) % a1[1];
  return result;
}

uint64_t circular_queue_peek(unsigned int *a1, void *__dst)
{
  unsigned int v2 = a1[2];
  if (v2 == a1[3]) {
    return 0xFFFFFFFFLL;
  }
  memcpy(__dst, (const void *)(*((void *)a1 + 3) + *a1 * v2), *a1);
  return 0;
}

uint64_t circular_queue_dequeue_all(int *a1, void *a2, unsigned int *a3)
{
  unsigned int v7 = a1[2];
  unsigned int v6 = a1[3];
  unsigned int v8 = v6 - v7;
  if (v6 < v7) {
    v8 += a1[1];
  }
  if (!v8) {
    return 0;
  }
  unsigned int v9 = *a1 * v8;
  uint64_t v10 = (char *)calloc(v9, 1uLL);
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = v10;
  unsigned int v12 = a1[2];
  unsigned int v13 = a1[3];
  if (v13 <= v12)
  {
    if (v12 <= v13) {
      goto LABEL_13;
    }
    unsigned int v17 = a1[1] - v12;
    memcpy(v10, (const void *)(*((void *)a1 + 3) + *a1 * v12), *a1 * v17);
    if (v8 <= v17) {
      goto LABEL_13;
    }
    uint64_t v10 = &v11[*a1 * v17];
    long long v14 = (const void *)*((void *)a1 + 3);
    size_t v15 = *a1 * (v8 - v17);
  }
  else
  {
    long long v14 = (const void *)(*((void *)a1 + 3) + *a1 * v12);
    size_t v15 = *a1 * v8;
  }
  memcpy(v10, v14, v15);
LABEL_13:
  unsigned int v18 = a1[1];
  int v19 = *a1;
  a1[2] = (a1[2] + v8) % v18;
  memset_s(*((void **)a1 + 3), v19 * v18, 0, v19 * v18);
  uint64_t result = 0;
  *a2 = v11;
  *a3 = v9;
  return result;
}

uint64_t circular_queue_clear(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  rsize_t v1 = (*(_DWORD *)a1 * *(_DWORD *)(a1 + 4));
  return memset_s(*(void **)(a1 + 24), v1, 0, v1);
}

void circular_queue_free(void *a1)
{
  *((void *)a1 + 1) = 0;
  rsize_t v2 = (*(_DWORD *)a1 * *((_DWORD *)a1 + 1));
  memset_s(*((void **)a1 + 3), v2, 0, v2);
  memset_s(*((void **)a1 + 3), *((void *)a1 + 2), 0, *((void *)a1 + 2));
  free(*((void **)a1 + 3));
  memset_s(a1, 0x20uLL, 0, 0x20uLL);
  free(a1);
}

uint64_t class_gen_get(unsigned int a1)
{
  return (a1 >> 5) & 1;
}

BOOL persona_uuid_is_valid(uint8x16_t *a1)
{
  int8x16_t v1 = (int8x16_t)vmovl_high_u8(*a1);
  int8x16_t v2 = (int8x16_t)vmovl_u8(*(uint8x8_t *)a1->i8);
  int8x16_t v3 = (int8x16_t)vmovl_u16((uint16x4_t)vorr_s8(vorr_s8(*(int8x8_t *)v2.i8, *(int8x8_t *)v1.i8), vorr_s8((int8x8_t)*(_OWORD *)&vextq_s8(v2, v2, 8uLL), (int8x8_t)*(_OWORD *)&vextq_s8(v1, v1, 8uLL))));
  return vorr_s8(*(int8x8_t *)v3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL)) != 0;
}

BOOL is_non_zero(unsigned __int8 *a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  int v2 = 0;
  do
  {
    int v3 = *a1++;
    v2 |= v3;
    --a2;
  }
  while (a2);
  return v2 != 0;
}

_DWORD *pfk_params_is_valid(_DWORD *result)
{
  if (result) {
    return (_DWORD *)(*result != 0);
  }
  return result;
}

uint64_t class_gen_set(char a1, int a2)
{
  return a1 & 0x1F | (32 * a2);
}

uint64_t class_persona_get(unsigned int a1)
{
  return (a1 >> 6) & 1;
}

uint64_t class_persona_unset(int a1)
{
  return a1 & 0xFFFFFFBF;
}

uint64_t class_persona_set(int a1)
{
  return a1 | 0x40u;
}

uint64_t keychain_key(char a1)
{
  char v1 = a1 & 0x1F;
  if ((a1 & 0x1Fu) >= 0x14) {
    char v1 = -1;
  }
  return ((a1 & 0x1Fu) < 0x14) & (0xC3FC0u >> v1);
}

uint64_t class_id_get(char a1)
{
  if ((a1 & 0x1Fu) > 0x13) {
    return 0xFFFFFFFFLL;
  }
  else {
    return a1 & 0x1F;
  }
}

uint64_t fs_class_key(char a1)
{
  unsigned int v1 = a1 & 0x1F;
  if (v1 > 0x13) {
    unsigned int v1 = -1;
  }
  return (v1 < 0x12) & (0x2E03Eu >> v1);
}

uint64_t keystore_type(char a1)
{
  return a1 & 0xF;
}

BOOL store_type_equal(int a1, int a2)
{
  return ((a2 ^ a1) & 0xF) == 0;
}

uint64_t memcmp_c(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x270ED87D8](a3, a1, a2);
}

uint64_t dump_bytes_internal(const char *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  unsigned int v4 = a1;
  uint64_t v25 = *MEMORY[0x263EF8340];
  char v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)__str = 0u;
  long long v17 = 0u;
  size_t v5 = (FILE **)MEMORY[0x263EF8358];
  if (a3 >= 0x41)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s %sdump %s (len = %zd)%s%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "dump_bytes_internal", ":", 786, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573, a1, a3, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
    unsigned int v4 = (const char *)&unk_22004A573;
  }
  else if (!a3)
  {
    return memset_s(__str, 0x81uLL, 0, 0x81uLL);
  }
  unint64_t v6 = 0;
  unint64_t v15 = v3;
  do
  {
    unsigned int v7 = v5;
    if (v3 - v6 >= 0x40) {
      uint64_t v8 = 64;
    }
    else {
      uint64_t v8 = v3 - v6;
    }
    if (v8)
    {
      unsigned int v9 = (unsigned __int8 *)(a2 + v6);
      uint64_t v10 = __str;
      uint64_t v11 = v8;
      do
      {
        int v12 = *v9++;
        snprintf(v10, 3uLL, "%02x", v12);
        v10 += 2;
        --v11;
      }
      while (v11);
    }
    size_t v5 = v7;
    fprintf(*v7, "%s%s:%s%s%s%s%u:%s%u:%s %s%s%s[%04zu,%04zu): %s%s%s%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "dump_bytes_internal", ":", 796, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573, v4, (const char *)&unk_22004A573, v6, v8 + v6, (const char *)&unk_22004A573, __str,
      (const char *)&unk_22004A573,
      (const char *)&unk_22004A573);
    v6 += v8;
    unint64_t v3 = v15;
  }
  while (v6 < v15);
  return memset_s(__str, 0x81uLL, 0, 0x81uLL);
}

unsigned char *bytes_to_str_hint(unsigned __int8 *a1, unint64_t a2)
{
  if (a2 >= 0x10) {
    uint64_t v2 = 16;
  }
  else {
    uint64_t v2 = a2;
  }
  if (v2)
  {
    unsigned int v4 = bytes_to_str_hint_buf;
    uint64_t v5 = v2;
    do
    {
      int v6 = *a1++;
      snprintf(v4, 3uLL, "%02x", v6);
      v4 += 2;
      --v5;
    }
    while (v5);
  }
  bytes_to_str_hint_buf[2 * v2] = 0;
  return bytes_to_str_hint_buf;
}

uint64_t get_kcv(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  memset(__s, 0, sizeof(__s));
  if (a4 == 3)
  {
    ccsha256_di();
    cchmac();
    uint64_t v5 = 0;
    *(_WORD *)a3 = __s[0];
    *(unsigned char *)(a3 + 2) = BYTE2(__s[0]);
  }
  else
  {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v5;
}

uint64_t print_kcv(const char *a1, uint64_t a2, uint64_t a3)
{
  char v6 = 0;
  __int16 v5 = 0;
  get_kcv(a2, a3, (uint64_t)&v5, 3);
  return dump_bytes_internal(a1, (uint64_t)&v5, 3uLL);
}

char *byte_swap_val(char *result, unint64_t a2)
{
  if (a2 >= 2)
  {
    unint64_t v2 = a2 >> 1;
    unint64_t v3 = &result[a2 - 1];
    do
    {
      char v4 = *result;
      *result++ = *v3;
      *v3-- = v4;
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t ascii_hex_to_bytes(unsigned __int8 *a1, unint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v5 = 0xFFFFFFFFLL;
  if ((a2 & 1) == 0)
  {
    char v6 = a1;
    if (a1)
    {
      if (a3 && a4)
      {
        unint64_t v9 = a2 >> 1;
        uint64_t v10 = calloc(a2 >> 1, 1uLL);
        if (v10)
        {
          if (a2 >= 2)
          {
            if (v9 <= 1) {
              uint64_t v11 = 1;
            }
            else {
              uint64_t v11 = a2 >> 1;
            }
            int v12 = v10;
            do
            {
              int v13 = *v6;
              unsigned int v14 = v13 - 48;
              unsigned int v15 = v13 - 97;
              if ((v13 - 65) >= 6) {
                char v16 = -1;
              }
              else {
                char v16 = v13 - 55;
              }
              char v17 = v13 - 87;
              if (v15 > 5) {
                char v17 = v16;
              }
              if (v14 < 0xA) {
                char v17 = v14;
              }
              char v18 = 16 * v17;
              int v19 = v6[1];
              unsigned int v20 = v19 - 48;
              unsigned int v21 = v19 - 97;
              if ((v19 - 65) >= 6) {
                char v22 = -1;
              }
              else {
                char v22 = v19 - 55;
              }
              char v23 = v19 - 87;
              if (v21 > 5) {
                char v23 = v22;
              }
              if (v20 < 0xA) {
                char v23 = v20;
              }
              *v12++ = v23 | v18;
              v6 += 2;
              --v11;
            }
            while (v11);
          }
          uint64_t v5 = 0;
          *a3 = v10;
          *a4 = v9;
        }
        else
        {
          return 4294967279;
        }
      }
    }
  }
  return v5;
}

uint64_t err_sks_to_aks(uint64_t result)
{
  if (result == 0 || result >= 0xFFFFFFDA) {
    return dword_22004A430[(int)result + 38];
  }
  return result;
}

uint64_t fv_init_cred_from_secret(void *a1, uint64_t a2, char a3)
{
  memset_s(a1, 0x10uLL, 0, 0x10uLL);
  if (a3) {
    return 4294967285;
  }
  if (a2 && *(void *)a2 && (size_t v7 = *(void *)(a2 + 8)) != 0)
  {
    uint64_t v8 = calloc(v7, 1uLL);
    if (v8)
    {
      *a1 = v8;
      unint64_t v9 = *(const void **)a2;
      a1[1] = *(void *)(a2 + 8);
      memcpy(v8, v9, *(void *)(a2 + 8));
      return 0;
    }
    else
    {
      return 4294967279;
    }
  }
  else
  {
    uint64_t result = 0;
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

uint64_t REQUIRE_func(uint64_t result, int a2, const char *a3)
{
  if ((result & 1) == 0)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s failed REQUIRE condition (%s:%d)\n%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "REQUIRE_func", ":", 1047, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, a3, a2, (const char *)&unk_22004A573);
    abort();
  }
  return result;
}

uint64_t generate_wrapping_key_curve25519(long long *a1, long long *a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  memset(v14, 0, sizeof(v14));
  platform_read_random((uint64_t)v14, 0x20u);
  cccurve25519_make_pub();
  long long v8 = 0u;
  long long v9 = 0u;
  int __s = 0x1000000;
  long long v4 = a2[1];
  long long v10 = *a2;
  long long v11 = v4;
  long long v5 = a1[1];
  long long v12 = *a1;
  long long v13 = v5;
  cccurve25519();
  ccsha256_di();
  ccdigest();
  memset_s(&__s, 0x64uLL, 0, 0x64uLL);
  memset_s(v14, 0x20uLL, 0, 0x20uLL);
  return 0;
}

uint64_t wrap_data(int *a1, uint64_t (*a2)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), char a3, uint64_t *a4, unsigned int a5, uint64_t a6, unsigned int *a7)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unsigned int v32 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  memset(__s, 0, sizeof(__s));
  uint64_t v8 = 0xFFFFFFFFLL;
  if (!a6 || !a7) {
    goto LABEL_40;
  }
  if (!a1)
  {
LABEL_14:
    if (a2)
    {
      if (rfc3394_wrapped_size_legacy(a5, &v32))
      {
        if (*a7 < v32) {
          goto LABEL_40;
        }
        char v18 = 0;
        unsigned int v19 = 0;
        unsigned int v20 = a2;
        unsigned int v21 = a4;
        goto LABEL_38;
      }
    }
    else
    {
      if ((a3 & 4) != 0)
      {
        if ((a5 & 0xF) != 0 || *a7 < a5) {
          goto LABEL_40;
        }
        unsigned int v32 = a5;
        uint64_t v29 = ccaes_cbc_encrypt_mode();
        firebloom_cbc_one_shot_f(v29, 32, (uint64_t)(a1 + 2), (uint64_t)&firebloom_null_iv, a5 & 0xFFFFFFF0);
LABEL_39:
        uint64_t v8 = 0;
        *a7 = v32;
        goto LABEL_40;
      }
      if (rfc3394_wrapped_size_legacy(a5, &v32))
      {
        if (*a7 < v32) {
          goto LABEL_40;
        }
        if ((a3 & 8) != 0)
        {
          ccsha256_di();
          cchkdf();
          char v18 = __s;
        }
        else
        {
          char v18 = a1 + 2;
        }
        unsigned int v19 = 32;
        unsigned int v20 = 0;
        unsigned int v21 = a4;
LABEL_38:
        if (rfc3394_wrap_legacy((uint64_t)v18, v19, 0xA6A6A6A6A6A6A6A6, v20, v21, a5, (void *)a6, &v32))goto LABEL_40; {
        goto LABEL_39;
        }
      }
    }
    uint64_t v8 = 4294967285;
    if ((a3 & 8) == 0) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  int v14 = *a1;
  if ((*a1 - 1) >= 2)
  {
    if (v14) {
      goto LABEL_40;
    }
    goto LABEL_14;
  }
  if ((a3 & 4) != 0) {
    unsigned int v15 = 64;
  }
  else {
    unsigned int v15 = 72;
  }
  unsigned int v32 = v15;
  if (!a2 && a5 == 32 && *a7 >= v15)
  {
    if (v14 == 1)
    {
      generate_wrapping_key_curve25519((long long *)(a1 + 9), &v34);
    }
    else
    {
      long long v23 = *(_OWORD *)(a1 + 5);
      long long v34 = *(_OWORD *)(a1 + 1);
      long long v35 = v23;
      long long v24 = *(_OWORD *)(a1 + 13);
      long long v36 = *(_OWORD *)(a1 + 9);
      long long v37 = v24;
    }
    if ((a3 & 0x80) == 0)
    {
      long long v25 = v35;
      *(_OWORD *)a6 = v34;
      *(_OWORD *)(a6 + 16) = v25;
      if ((a3 & 4) != 0)
      {
        uint64_t v28 = ccaes_cbc_encrypt_mode();
        firebloom_cbc_one_shot_f(v28, 32, (uint64_t)&v36, (uint64_t)&firebloom_null_iv, 0x20uLL);
        goto LABEL_34;
      }
      int v31 = 40;
      if ((a3 & 8) != 0)
      {
        ccsha256_di();
        cchkdf();
        long long v27 = (void *)(a6 + 32);
        uint64_t v26 = __s;
      }
      else
      {
        uint64_t v26 = &v36;
        long long v27 = (void *)(a6 + 32);
      }
      if (!rfc3394_wrap_legacy((uint64_t)v26, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, a4, 0x20u, v27, &v31))
      {
LABEL_34:
        uint64_t v8 = 0;
        *a7 = v15;
        if ((a3 & 8) == 0) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }
    }
  }
LABEL_40:
  if ((a3 & 8) != 0) {
LABEL_41:
  }
    memset_s(__s, 0x20uLL, 0, 0x20uLL);
LABEL_42:
  memset_s(&v34, 0x40uLL, 0, 0x40uLL);
  return v8;
}

uint64_t generate_unwrap_shared_key_curve25519(long long *a1, uint64_t a2, long long *a3)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  long long v8 = 0u;
  long long v7 = 0u;
  long long v3 = a1[1];
  long long v9 = *a1;
  long long v10 = v3;
  long long v4 = a3[1];
  long long v11 = *a3;
  int __s = 0x1000000;
  long long v12 = v4;
  cccurve25519();
  ccsha256_di();
  ccdigest();
  memset_s(&__s, 0x64uLL, 0, 0x64uLL);
  return 0;
}

uint64_t unwrap_data(uint64_t a1, uint64_t (*a2)(void, void *, unint64_t *, unint64_t *, uint64_t), char a3, void *a4, unsigned int a5, void *a6, unsigned int *a7)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  unsigned int v24 = 0;
  memset(v26, 0, sizeof(v26));
  uint64_t v8 = 0xFFFFFFFFLL;
  if (a4 && a5)
  {
    if (!a1) {
      goto LABEL_6;
    }
    if (*(_DWORD *)a1 != 1)
    {
      if (!*(_DWORD *)a1)
      {
LABEL_6:
        if (a5 <= 0x28)
        {
          if (a2)
          {
            if (rfc3394_unwrapped_size_legacy(a5, &v24) && *a7 >= v24)
            {
              unsigned int v15 = 0;
              unsigned int v16 = 0;
              char v17 = a2;
              goto LABEL_30;
            }
          }
          else if ((a3 & 4) != 0)
          {
            if ((a5 & 0xF) == 0 && *a7 >= a5)
            {
              unsigned int v24 = a5;
              uint64_t v20 = ccaes_cbc_decrypt_mode();
              firebloom_cbc_one_shot_f(v20, 32, a1 + 8, (uint64_t)&firebloom_null_iv, a5 & 0xFFFFFFF0);
LABEL_31:
              uint64_t v8 = 0;
              *a7 = v24;
              goto LABEL_35;
            }
          }
          else if (rfc3394_unwrapped_size_legacy(a5, &v24) && *a7 >= v24)
          {
            if ((a3 & 8) != 0)
            {
              ccsha256_di();
              cchkdf();
              unsigned int v15 = v26;
            }
            else
            {
              unsigned int v15 = (_OWORD *)(a1 + 8);
            }
            unsigned int v16 = 32;
            char v17 = 0;
LABEL_30:
            if (!rfc3394_unwrap_legacy((uint64_t)v15, v16, 0xA6A6A6A6A6A6A6A6, v17, a4, a5, a6, &v24)) {
              goto LABEL_31;
            }
            goto LABEL_40;
          }
        }
LABEL_38:
        uint64_t v8 = 4294967285;
        goto LABEL_35;
      }
LABEL_22:
      uint64_t v8 = 0xFFFFFFFFLL;
      goto LABEL_35;
    }
    unsigned int v24 = 32;
    if (*a7 < 0x20) {
      goto LABEL_38;
    }
    memset(__s, 0, sizeof(__s));
    if ((a3 & 4) != 0)
    {
      if (a5 != 64) {
        goto LABEL_38;
      }
      generate_unwrap_shared_key_curve25519((long long *)a4, a1 + 4, (long long *)(a1 + 36));
      uint64_t v21 = ccaes_cbc_decrypt_mode();
      firebloom_cbc_one_shot_f(v21, 32, (uint64_t)__s, (uint64_t)&firebloom_null_iv, 0x20uLL);
    }
    else
    {
      if (a5 != 72) {
        goto LABEL_38;
      }
      generate_unwrap_shared_key_curve25519((long long *)a4, a1 + 4, (long long *)(a1 + 36));
      if (a3 < 0) {
        goto LABEL_22;
      }
      int v23 = 32;
      if ((a3 & 8) != 0)
      {
        ccsha256_di();
        cchkdf();
        char v18 = a4 + 4;
        unsigned int v19 = v26;
      }
      else
      {
        char v18 = a4 + 4;
        unsigned int v19 = __s;
      }
      if (rfc3394_unwrap_legacy((uint64_t)v19, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, v18, 0x28u, a6, &v23))
      {
        memset_s(__s, 0x20uLL, 0, 0x20uLL);
LABEL_40:
        uint64_t v8 = 4294967277;
        goto LABEL_35;
      }
    }
    memset_s(__s, 0x20uLL, 0, 0x20uLL);
    uint64_t v8 = 0;
    *a7 = 32;
  }
LABEL_35:
  if ((a3 & 8) != 0) {
    memset_s(v26, 0x20uLL, 0, 0x20uLL);
  }
  return v8;
}

uint64_t firebloom_export_pub_key(uint64_t a1, void *a2, size_t *a3)
{
  size_t v5 = ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
  char v6 = calloc(v5, 1uLL);
  if (!v6) {
    return 4294967279;
  }
  long long v7 = v6;
  ccec_export_pub();
  uint64_t result = 0;
  *a2 = v7;
  *a3 = v5;
  return result;
}

unint64_t firebloom_cp_prime_size()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

unint64_t firebloom_sign_max_size()
{
  return (((unint64_t)(cczp_bitlen() + 7) >> 2) & 0x3FFFFFFFFFFFFFFELL) + 9;
}

unint64_t firebloom_ec_export_pub_size()
{
  return ((unint64_t)(cczp_bitlen() + 7) >> 2) | 1;
}

unint64_t firebloom_ec_compact_export_pub_size()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

uint64_t firebloom_cbc_one_shot_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  return MEMORY[0x270ED8830](a1, a2, a3, a4, a5 >> 4);
}

uint64_t firebloom_ecb_one_shot_f(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return MEMORY[0x270ED8B30](a1, a2, a3, a4 >> 4);
}

uint64_t firebloom_cbc_update_f(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return MEMORY[0x270ED8840](a1, a2, a3, a4 >> 4);
}

BOOL firebloom_ec_import()
{
  return !MEMORY[0x223C64B10]() && ccn_read_uint() == 0;
}

uint64_t firebloom_ec_export()
{
  return 1;
}

uint64_t dict_find_params_cb(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)(a5 + 8) >= *(void *)a5)
  {
    char v13 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      BOOL v11 = der_equal(*(const void **)(*(void *)(a5 + 24) + v9), *(void *)(*(void *)(a5 + 24) + v9)+ *(unsigned __int8 *)(*(void *)(*(void *)(a5 + 24) + v9) + 1)+ 2, a1);
      if (v11) {
        break;
      }
      ++v10;
      v9 += 40;
      if (v10 >= *(void *)a5) {
        goto LABEL_10;
      }
    }
    int v14 = (void *)(*(void *)(a5 + 24) + v9);
    if (v14[1])
    {
      char v12 = 0;
      *(unsigned char *)(a5 + 16) = 1;
    }
    else
    {
      ++*(void *)(a5 + 8);
      v14[1] = a3;
      _OWORD v14[2] = a3 + a4;
      v14[3] = a3;
      v14[4] = a3 + a4;
      char v12 = 1;
    }
LABEL_10:
    char v13 = v12 | !v11;
  }
  return v13 & 1;
}

BOOL der_key_equal(unsigned __int8 *a1, const void *a2)
{
  return der_equal(a1, (uint64_t)&a1[a1[1] + 2], a2);
}

BOOL der_equal(const void *a1, uint64_t a2, const void *a3)
{
  size_t v5 = der_get_sizeof((uint64_t)a1);
  return v5 == der_get_sizeof((uint64_t)a3) && memcmp(a1, a3, v5) == 0;
}

uint64_t der_get_sizeof(uint64_t a1)
{
  if (ccder_blob_decode_tag() && ccder_blob_decode_len()) {
    return a1 - a1;
  }
  else {
    return 0;
  }
}

uint64_t der_dict_iterate()
{
  uint64_t result = ccder_blob_decode_range();
  if (result)
  {
    if (ccder_blob_decode_sequence_tl())
    {
      uint64_t result = ccder_blob_decode_tl();
      if (result) {
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t der_dict_find_value(uint64_t a1, void *a2, void *a3)
{
  if (a1)
  {
    der_dict_iterate();
    if (a2)
    {
      if (a3)
      {
        *a2 = 0;
        *a3 = 0;
      }
    }
  }
  return 0;
}

BOOL _dict_find_value_cb(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v8 = der_equal(*(const void **)a5, *(void *)a5 + *(unsigned __int8 *)(*(void *)a5 + 1) + 2, a1);
  if (v8)
  {
    *(unsigned char *)(a5 + 24) = 1;
    *(void *)(a5 + 8) = a3;
    *(void *)(a5 + 16) = a3 + a4;
  }
  return !v8;
}

uint64_t der_dict_get_number(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  if (result)
  {
    der_dict_iterate();
    return 0;
  }
  return result;
}

uint64_t der_get_number()
{
  return 0;
}

uint64_t der_dict_get_data(uint64_t result)
{
  if (result)
  {
    der_dict_iterate();
    return 0;
  }
  return result;
}

double der_utils_decode_implicit_raw_octet_string(long long *a1, uint64_t a2, _DWORD *a3, void *a4)
{
  long long v8 = *a1;
  if (ccder_blob_decode_range())
  {
    *a4 = 0;
    *a3 = 0;
    double result = *(double *)&v8;
    *a1 = v8;
  }
  return result;
}

uint64_t der_array_iterate(uint64_t a1, uint64_t a2, unsigned int (*a3)(uint64_t, void, uint64_t), uint64_t a4)
{
  *(void *)&long long v12 = a1;
  *((void *)&v12 + 1) = a2;
  uint64_t v6 = ccder_blob_decode_range();
  if (v6)
  {
    uint64_t v11 = 0;
    uint64_t v7 = v12;
    if (der_utils_decode_tl(&v12, &v10, &v11))
    {
      do
      {
        uint64_t v8 = v12 + v11;
        if (!a3(v7, v12 + v11 - v7, a4)) {
          break;
        }
        *(void *)&long long v12 = v8;
        uint64_t v7 = v8;
      }
      while ((der_utils_decode_tl(&v12, &v10, &v11) & 1) != 0);
    }
  }
  return v6;
}

uint64_t der_utils_decode_tl(long long *a1, void *a2, void *a3)
{
  long long v7 = *a1;
  uint64_t result = ccder_blob_decode_tag();
  if (result)
  {
    uint64_t result = ccder_blob_decode_len();
    if (result)
    {
      *a1 = v7;
      *a2 = 0;
      *a3 = 0;
      return 1;
    }
  }
  return result;
}

uint64_t der_get_BOOL()
{
  return 0;
}

uint64_t encode_list_free(void **a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    unint64_t v2 = *a1;
    if (!*a1) {
      break;
    }
    long long v3 = (void *)*((void *)v2 + 1);
    *a1 = *(void **)v2;
    if (v3)
    {
      memset_s(v3, *((void *)v2 + 2), 0, *((void *)v2 + 2));
      free(*((void **)v2 + 1));
    }
    memset_s(v2, 0x18uLL, 0, 0x18uLL);
    free(v2);
  }
  return 0;
}

uint64_t encode_list_remove_key(void *a1, unsigned __int8 *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v2 = (void **)a1;
  uint64_t result = (uint64_t)_encode_list_find_key(a1, a2);
  if (result)
  {
    uint64_t v4 = result;
    for (uint64_t i = *v2; i != (void *)result; uint64_t i = (void *)*i)
      unint64_t v2 = (void **)i;
    void *v2 = *(void **)result;
    uint64_t v6 = *(void **)(result + 8);
    if (v6)
    {
      memset_s(v6, *(void *)(v4 + 16), 0, *(void *)(v4 + 16));
      free(*(void **)(v4 + 8));
    }
    memset_s((void *)v4, 0x18uLL, 0, 0x18uLL);
    free((void *)v4);
    return 0;
  }
  return result;
}

void *_encode_list_find_key(void *a1, unsigned __int8 *a2)
{
  if (!a1) {
    return 0;
  }
  unint64_t v2 = (void *)*a1;
  if (*a1)
  {
    do
    {
      size_t v5 = (const void *)v2[1];
      if (ccder_blob_decode_sequence_tl() && der_equal(a2, (uint64_t)&a2[a2[1] + 2], v5)) {
        break;
      }
      unint64_t v2 = (void *)*v2;
    }
    while (v2);
  }
  return v2;
}

uint64_t encode_list_get_data(void *a1, unsigned __int8 *a2, int a3, void *a4, void *a5)
{
  key = _encode_list_find_key(a1, a2);
  if (!key) {
    return 0;
  }
  uint64_t v9 = 1;
  if (a4)
  {
    if (a5)
    {
      uint64_t v10 = key[1] + key[2];
      *(void *)&long long v15 = key[1];
      *((void *)&v15 + 1) = v10;
      uint64_t v9 = ccder_blob_decode_sequence_tl();
      if (v9)
      {
        if (der_utils_decode_implicit_raw_octet_string_copy(&v15, 12, 0, 0))
        {
          uint64_t v11 = v15;
          if (ccder_blob_decode_tag())
          {
            if (ccder_blob_decode_len())
            {
              uint64_t v13 = 0;
              uint64_t v12 = v15;
              if (a3)
              {
                uint64_t v13 = (v15 - v11);
                uint64_t v12 = v11;
              }
              *a4 = v12;
              *a5 = v13;
            }
          }
        }
      }
    }
  }
  return v9;
}

uint64_t der_utils_decode_implicit_raw_octet_string_copy(long long *a1, uint64_t a2, uint64_t a3, int a4)
{
  long long v8 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0 || a3 && a4) {
    return 0;
  }
  *a1 = v8;
  return 1;
}

uint64_t encode_list_cstr_get_data(void *a1, char *__s, void *a3, size_t a4)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  memset(v18, 0, sizeof(v18));
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  v11[0] = 12;
  v11[1] = strlen(__s);
  long long v7 = (unsigned __int8 *)der_key_validate((uint64_t)v11);
  uint64_t result = 0xFFFFFFFFLL;
  if (a3 && v7)
  {
    __memcpy_chk();
    __src = 0;
    uint64_t v10 = 0;
    if (encode_list_get_data(a1, v7, 0, &__src, &v10))
    {
      if (v10 == a4)
      {
        memcpy(a3, __src, a4);
        return 0;
      }
      else
      {
        return 4294967277;
      }
    }
    else
    {
      return 4294967293;
    }
  }
  return result;
}

uint64_t der_key_validate(uint64_t a1)
{
  if ((ccder_blob_decode_tl() & 1) == 0)
  {
    fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s bad 1%s\n", "aks", &unk_22004A573, &unk_22004A573, &unk_22004A573, "der_key_validate");
    return 0;
  }
  return a1;
}

uint64_t encode_list_get_number(void *a1, unsigned __int8 *a2, uint64_t *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t data = encode_list_get_data(a1, a2, 1, &v7, &v8);
  uint64_t v5 = data;
  if (a3 && data) {
    *a3 = der_get_number();
  }
  return v5;
}

uint64_t encode_list_get_BOOL(void *a1, unsigned __int8 *a2, unsigned char *a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t data = encode_list_get_data(a1, a2, 1, &v7, &v8);
  uint64_t v5 = data;
  if (a3 && data) {
    *a3 = der_get_BOOL();
  }
  return v5;
}

uint64_t encode_list_merge_dict(uint64_t a1)
{
  if (a1) {
    return der_dict_iterate() - 1;
  }
  else {
    return 4294967285;
  }
}

uint64_t _merge_dict_cb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8 = (unsigned __int8 *)der_key_validate(a1);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    if (!encode_list_remove_key(a5, v8) && !encode_list_add_der(a5, v9, a3, a3 + a4)) {
      return 1;
    }
  }
  fprintf((FILE *)*MEMORY[0x263EF8358], "%s%s:%s%s%s%s%u:%s%u:%s fail%s\n", "aks", (const char *)&unk_22004A573, (const char *)&unk_22004A573, (const char *)&unk_22004A573, "_merge_dict_cb", ":", 647, (const char *)&unk_22004A573, 0, (const char *)&unk_22004A573, (const char *)&unk_22004A573);
  return 0;
}

uint64_t encode_list_dict(void *a1, void *a2, size_t *a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        uint64_t v7 = (void *)*a1;
        if (*a1)
        {
          unint64_t v8 = 0;
          uint64_t v9 = 0;
          uint64_t v10 = 0;
          do
          {
            v10 += v7[2];
            uint64_t v7 = (void *)*v7;
            v9 -= 16;
            --v8;
          }
          while (v7);
          if (v8 >= 0xF000000000000001 && (v11 = -v9, (long long v12 = calloc(-v9, 1uLL)) != 0))
          {
            long long v13 = v12;
            long long v14 = (void *)*a1;
            if (*a1)
            {
              long long v15 = v12;
              do
              {
                *v15++ = *(_OWORD *)(v14 + 1);
                long long v14 = (void *)*v14;
              }
              while (v14);
            }
            qsort(v12, -(uint64_t)v8, 0x10uLL, (int (__cdecl *)(const void *, const void *))_qsort_compare);
            size_t v16 = ccder_sizeof();
            long long v17 = (char *)calloc(v16, 1uLL);
            char v18 = v17;
            if (v17)
            {
              long long v25 = v17;
              uint64_t v26 = &v17[v16];
              unint64_t v19 = v8 - 1;
              uint64_t v20 = (uint64_t)v13 - v9 - 8;
              while (!__CFADD__(v19++, 1))
              {
                uint64_t v22 = v20 - 16;
                char v23 = ccder_blob_encode_body();
                uint64_t v20 = v22;
                if ((v23 & 1) == 0) {
                  goto LABEL_16;
                }
              }
              if (!ccder_blob_encode_tl() || v25 != v26)
              {
LABEL_16:
                uint64_t v3 = 0xFFFFFFFFLL;
                goto LABEL_20;
              }
              uint64_t v3 = 0;
              *a2 = v18;
              *a3 = v16;
              char v18 = 0;
            }
            else
            {
              uint64_t v3 = 4294967279;
            }
LABEL_20:
            memset_s(v13, v11, 0, v11);
            free(v13);
            if (v18)
            {
              memset_s(v18, v16, 0, v16);
              free(v18);
            }
          }
          else
          {
            return 0xFFFFFFFFLL;
          }
        }
      }
    }
  }
  return v3;
}

uint64_t encode_list_add_der(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3 && a4)
  {
    if (der_get_sizeof(a3) <= (unint64_t)(a4 - a3))
    {
      size_t v6 = ccder_sizeof();
      uint64_t v7 = (char *)calloc(v6, 1uLL);
      if (!v7) {
        return 4294967279;
      }
      unint64_t v8 = v7;
      size_t v16 = &v7[v6];
      if (ccder_blob_encode_body())
      {
        int v9 = ccder_blob_encode_body();
        uint64_t v10 = v16;
        if (!v9) {
          uint64_t v10 = 0;
        }
        long long v17 = v10;
        int v11 = ccder_blob_encode_tl();
        long long v12 = v17;
        if (!v11) {
          long long v12 = 0;
        }
        if (v12 && v12 == v8)
        {
          long long v14 = calloc(0x18uLL, 1uLL);
          if (v14)
          {
            long long v15 = v14;
            uint64_t result = 0;
            v15[1] = v8;
            v15[2] = v6;
            void *v15 = *a1;
            *a1 = v15;
            return result;
          }
        }
      }
      memset_s(v8, v6, 0, v6);
      free(v8);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t encode_list_add_key(void *a1, uint64_t a2, uint64_t a3)
{
  return encode_list_add_der(a1, a2, a3, a3 + *(unsigned __int8 *)(a3 + 1) + 2);
}

uint64_t encode_list_add_data(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    ccder_sizeof();
    size_t v5 = ccder_sizeof();
    size_t v6 = (char *)calloc(v5, 1uLL);
    if (v6)
    {
      uint64_t v7 = v6;
      long long v15 = &v6[v5];
      if (!ccder_blob_encode_body() || !ccder_blob_encode_tl()) {
        goto LABEL_19;
      }
      int v8 = ccder_blob_encode_body();
      int v9 = v15;
      if (!v8) {
        int v9 = 0;
      }
      size_t v16 = v9;
      int v10 = ccder_blob_encode_tl();
      int v11 = v16;
      if (!v10) {
        int v11 = 0;
      }
      BOOL v12 = v11 && v11 == v7;
      if (v12 && (long long v13 = calloc(0x18uLL, 1uLL)) != 0)
      {
        long long v14 = v13;
        uint64_t result = 0;
        v14[1] = v7;
        _OWORD v14[2] = v5;
        *long long v14 = *a1;
        *a1 = v14;
      }
      else
      {
LABEL_19:
        memset_s(v7, v5, 0, v5);
        free(v7);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t encode_list_cstr_add_data(void *a1, char *__s, uint64_t a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  memset(v14, 0, sizeof(v14));
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  long long v8 = 0u;
  v7[0] = 12;
  v7[1] = strlen(__s);
  uint64_t v5 = der_key_validate((uint64_t)v7);
  uint64_t result = 4294967285;
  if (a3)
  {
    if (v5)
    {
      __memcpy_chk();
      return encode_list_add_data(a1, v5, a3);
    }
  }
  return result;
}

uint64_t encode_list_add_BOOL(void *a1, uint64_t a2)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    ccder_sizeof();
    size_t v4 = ccder_sizeof();
    uint64_t v5 = (char *)calloc(v4, 1uLL);
    if (v5)
    {
      size_t v6 = v5;
      long long v14 = &v5[v4];
      if (!ccder_blob_encode_body() || !ccder_blob_encode_tl()) {
        goto LABEL_18;
      }
      int v7 = ccder_blob_encode_body();
      long long v8 = v14;
      if (!v7) {
        long long v8 = 0;
      }
      uint64_t v15 = v8;
      int v9 = ccder_blob_encode_tl();
      long long v10 = v15;
      if (!v9) {
        long long v10 = 0;
      }
      BOOL v11 = v10 && v10 == v6;
      if (v11 && (long long v12 = calloc(0x18uLL, 1uLL)) != 0)
      {
        long long v13 = v12;
        uint64_t result = 0;
        v13[1] = v6;
        size_t v13[2] = v4;
        *long long v13 = *a1;
        *a1 = v13;
      }
      else
      {
LABEL_18:
        memset_s(v6, v4, 0, v4);
        free(v6);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t encode_list_add_number(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  v25[1] = *MEMORY[0x263EF8340];
  unint64_t v5 = HIBYTE(a3);
  if ((HIBYTE(a3) + 1) > 1u)
  {
    uint64_t v10 = 8;
  }
  else
  {
    uint64_t v6 = 9;
    uint64_t v7 = 48;
    uint64_t v8 = 1;
    while ((unint64_t)(v6 - 2) >= 2)
    {
      uint64_t v9 = a3 >> v7;
      --v6;
      v7 -= 8;
      if (v5 != v9)
      {
        uint64_t v8 = v6 - 1;
        goto LABEL_8;
      }
    }
    uint64_t v6 = 2;
LABEL_8:
    if ((((a3 >> (8 * v8 - 8)) ^ v5) & 0x80) != 0) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v8;
    }
  }
  v25[0] = 0;
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    ccder_sizeof();
    size_t v12 = ccder_sizeof();
    long long v13 = (char *)calloc(v12, 1uLL);
    if (v13)
    {
      long long v14 = v13;
      uint64_t v15 = v10;
      do
      {
        *((unsigned char *)v25 + v15 - 1) = v3;
        v3 >>= 8;
        --v15;
      }
      while (v15);
      char v23 = &v13[v12];
      if ((ccder_blob_encode_body() & 1) == 0 || !ccder_blob_encode_tl()) {
        goto LABEL_30;
      }
      int v16 = ccder_blob_encode_body();
      long long v17 = v23;
      if (!v16) {
        long long v17 = 0;
      }
      unsigned int v24 = v17;
      int v18 = ccder_blob_encode_tl();
      unint64_t v19 = v24;
      if (!v18) {
        unint64_t v19 = 0;
      }
      BOOL v20 = v19 && v19 == v14;
      if (v20 && (uint64_t v21 = calloc(0x18uLL, 1uLL)) != 0)
      {
        uint64_t v22 = v21;
        uint64_t result = 0;
        v22[1] = v14;
        void v22[2] = v12;
        *uint64_t v22 = *a1;
        *a1 = v22;
      }
      else
      {
LABEL_30:
        memset_s(v14, v12, 0, v12);
        free(v14);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t encode_list_add_string(void *a1, uint64_t a2, char *__s)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && __s)
  {
    strlen(__s);
    ccder_sizeof();
    size_t v5 = ccder_sizeof();
    uint64_t v6 = (char *)calloc(v5, 1uLL);
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v15 = &v6[v5];
      if (!ccder_blob_encode_body() || !ccder_blob_encode_tl()) {
        goto LABEL_19;
      }
      int v8 = ccder_blob_encode_body();
      uint64_t v9 = v15;
      if (!v8) {
        uint64_t v9 = 0;
      }
      int v16 = v9;
      int v10 = ccder_blob_encode_tl();
      BOOL v11 = v16;
      if (!v10) {
        BOOL v11 = 0;
      }
      BOOL v12 = v11 && v11 == v7;
      if (v12 && (long long v13 = calloc(0x18uLL, 1uLL)) != 0)
      {
        long long v14 = v13;
        uint64_t result = 0;
        v14[1] = v7;
        _OWORD v14[2] = v5;
        *long long v14 = *a1;
        *a1 = v14;
      }
      else
      {
LABEL_19:
        memset_s(v7, v5, 0, v5);
        free(v7);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t encode_list_add_list(void *a1, uint64_t a2, void *a3)
{
  uint64_t v3 = 0;
  int __s = 0;
  rsize_t __n = 0;
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    size_t v5 = 0;
    if (a3)
    {
      if (encode_list_dict(a3, &__s, &__n))
      {
        uint64_t v3 = 0;
        size_t v5 = 0;
      }
      else
      {
        size_t v5 = ccder_sizeof();
        uint64_t v7 = (char *)calloc(v5, 1uLL);
        uint64_t v3 = v7;
        if (v7)
        {
          uint64_t v15 = &v7[v5];
          if (!ccder_blob_encode_body()) {
            goto LABEL_23;
          }
          int v18 = v3;
          unint64_t v19 = v15;
          int v8 = ccder_blob_encode_body();
          uint64_t v9 = v19;
          if (!v8) {
            uint64_t v9 = 0;
          }
          int v18 = v3;
          unint64_t v19 = v9;
          int v10 = ccder_blob_encode_tl();
          BOOL v11 = v19;
          if (!v10) {
            BOOL v11 = 0;
          }
          BOOL v12 = v11 && v11 == v3;
          if (v12 && (long long v13 = calloc(0x18uLL, 1uLL)) != 0)
          {
            uint64_t v4 = 0;
            v13[1] = v3;
            size_t v13[2] = v5;
            *long long v13 = *a1;
            *a1 = v13;
            uint64_t v3 = 0;
          }
          else
          {
LABEL_23:
            uint64_t v4 = 0xFFFFFFFFLL;
          }
        }
        else
        {
          uint64_t v4 = 4294967279;
        }
      }
    }
  }
  else
  {
    size_t v5 = 0;
  }
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  if (v3)
  {
    memset_s(v3, v5, 0, v5);
    free(v3);
  }
  return v4;
}

BOOL encode_list_is_empty(void *a1)
{
  return *a1 == 0;
}

uint64_t ccder_sizeof_fv_data()
{
  return ccder_sizeof();
}

uint64_t ccder_sizeof_fv_key()
{
  uint64_t v0 = ccder_sizeof();
  return ccder_sizeof() + v0;
}

uint64_t der_utils_encode_fv_key(long long *a1, uint64_t a2)
{
  long long v4 = *a1;
  if (a2)
  {
    uint64_t result = ccder_blob_encode_body_tl();
    if (!result) {
      return result;
    }
    if ((ccder_blob_encode_body_tl() & 1) == 0) {
      return 0;
    }
  }
  else if (!ccder_blob_encode_body_tl() || (ccder_blob_encode_tl() & 1) == 0)
  {
    return 0;
  }
  *a1 = v4;
  return 1;
}

uint64_t der_utils_decode_fv_key(long long *a1, int a2, uint64_t a3)
{
  uint64_t v6 = *(void *)a3;
  uint64_t v5 = *(void *)(a3 + 8);
  int v7 = *(_DWORD *)(a3 + 20);
  long long v11 = *a1;
  if (a2)
  {
    long long v14 = *a1;
    BOOL v12 = 0;
    uint64_t v13 = 0;
    if ((ccder_blob_decode_range() & 1) == 0) {
      return 0;
    }
    uint64_t v6 = (uint64_t)v12;
    unsigned int v8 = v13 - v12;
    long long v11 = v14;
  }
  else
  {
    LODWORD(v14) = v5;
    uint64_t result = der_utils_decode_implicit_raw_octet_string_copy_len(&v11, 4, v6, &v14);
    if (!result) {
      return result;
    }
    unsigned int v8 = v14;
  }
  long long v14 = v11;
  BOOL v12 = 0;
  uint64_t v13 = 0;
  if ((ccder_blob_decode_range() & 1) == 0) {
    return 0;
  }
  long long v11 = v14;
  if ((v13 - v12) > 4) {
    return 0;
  }
  int v10 = *v12;
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v8;
  *(_DWORD *)(a3 + 16) = v10;
  *(_DWORD *)(a3 + 20) = v7;
  *a1 = v11;
  return 1;
}

uint64_t der_utils_decode_implicit_raw_octet_string_copy_len(long long *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  long long v8 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0) {
    return 0;
  }
  if (a3)
  {
    if (a4) {
      *a4 = 0;
    }
  }
  *a1 = v8;
  return 1;
}

uint64_t der_utils_encode_fv_data(long long *a1, uint64_t a2)
{
  long long v4 = *a1;
  if (a2)
  {
    if ((ccder_blob_encode_body_tl() & 1) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t result = ccder_blob_encode_tl();
    if (!result) {
      return result;
    }
  }
  *a1 = v4;
  return 1;
}

uint64_t der_utils_decode_fv_data(long long *a1, int a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  long long v9 = *a1;
  if (a2)
  {
    long long v12 = *a1;
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t result = ccder_blob_decode_range();
    if (!result) {
      return result;
    }
    uint64_t v6 = v10;
    unsigned int v8 = v11 - v10;
    long long v9 = v12;
  }
  else
  {
    LODWORD(v12) = v5;
    uint64_t result = der_utils_decode_implicit_raw_octet_string_copy_len(&v9, 4, v6, &v12);
    if (!result) {
      return result;
    }
    unsigned int v8 = v12;
  }
  *a3 = v6;
  a3[1] = v8;
  *a1 = v9;
  return 1;
}

uint64_t der_utils_encode_fv_params(long long *a1, uint64_t a2)
{
  long long v4 = *a1;
  if (a2)
  {
    if ((ccder_blob_encode_body_tl() & 1) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t result = ccder_blob_encode_tl();
    if (!result) {
      return result;
    }
  }
  *a1 = v4;
  return 1;
}

uint64_t der_utils_decode_fv_params(long long *a1)
{
  long long v3 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0) {
    return 0;
  }
  *a1 = v3;
  return 1;
}

uint64_t encode_extended_state(unsigned int *a1, int a2, void *a3, _DWORD *a4)
{
  long long v12 = 0;
  if (encode_list_add_number(&v12, (uint64_t)der_key_state_state, *a1)
    || encode_list_add_number(&v12, (uint64_t)der_key_state_lock_state, a1[1])
    || encode_list_add_number(&v12, (uint64_t)der_key_state_backoff, *((void *)a1 + 1))
    || encode_list_add_number(&v12, (uint64_t)der_key_state_failed_attempts, a1[4])
    || encode_list_add_number(&v12, (uint64_t)der_key_state_generation_state, a1[5])
    || encode_list_add_number(&v12, (uint64_t)der_key_state_recovery_countdown, *(void *)((char *)a1 + 26))|| encode_list_add_number(&v12, (uint64_t)der_key_state_more_state, *(void *)((char *)a1 + 34))|| encode_list_add_number(&v12, (uint64_t)der_key_keybag_handle, *(int *)((char *)a1 + 42))|| encode_list_add_number(&v12, (uint64_t)der_key_config_max_unlock_attempts, *(unsigned int *)((char *)a1 + 46))|| encode_list_add_data(&v12, (uint64_t)der_key_config_user_uuid, (uint64_t)a1 + 50)|| a2&& (encode_list_add_number(&v12, (uint64_t)der_key_state_assertion_set, *((char *)a1 + 66))|| encode_list_add_number(&v12, (uint64_t)der_key_state_grace_period_enabled, *((char *)a1 + 67))|| encode_list_add_number(&v12, (uint64_t)der_key_lock_time, *(void *)(a1 + 17))|| encode_list_add_number(&v12, (uint64_t)der_key_cx_window, *(void *)(a1 + 19)))|| (uint64_t v10 = 0, v11 = 0, encode_list_dict(&v12, &v10, &v11)))
  {
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v8 = 0;
    *a3 = v10;
    *a4 = v11;
  }
  encode_list_free(&v12);
  return v8;
}

uint64_t decode_extended_state(uint64_t a1, int a2, char *__s)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a1)
  {
    if (__s)
    {
      memset_s(__s, 0x54uLL, 0, 0x54uLL);
      bzero(v7, 0x228uLL);
      v7[4] = der_key_state_lock_state;
      v7[9] = der_key_state_backoff;
      v7[14] = der_key_state_failed_attempts;
      v7[19] = der_key_state_generation_state;
      v7[24] = der_key_state_assertion_set;
      v7[29] = der_key_state_grace_period_enabled;
      v7[34] = der_key_state_recovery_countdown;
      v7[39] = der_key_state_more_state;
      v7[44] = der_key_keybag_handle;
      v7[49] = der_key_config_max_unlock_attempts;
      v7[54] = der_key_config_user_uuid;
      long long v9 = der_key_lock_time;
      uint64_t v10 = der_key_cx_window;
      der_dict_iterate();
      *(_DWORD *)int __s = der_get_number();
      *((_DWORD *)__s + 1) = der_get_number();
      *((void *)__s + 1) = der_get_number();
      *((_DWORD *)__s + 4) = der_get_number();
      *((_DWORD *)__s + 5) = der_get_number();
      *(void *)(__s + 26) = der_get_number();
      *(void *)(__s + 34) = der_get_number();
      *(_DWORD *)(__s + 42) = der_get_number();
      *(_DWORD *)(__s + 46) = der_get_number();
      der_utils_decode_implicit_raw_octet_string_copy(&v8, 4, (uint64_t)(__s + 50), 16);
      __s[66] = der_get_number();
      __s[67] = der_get_number();
      *(void *)(__s + 68) = der_get_number();
      uint64_t number = der_get_number();
      uint64_t result = 0;
      *(void *)(__s + 76) = number;
    }
  }
  return result;
}

uint64_t decode_memento_state(uint64_t a1, int a2, unsigned char *__s)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a1 && __s)
  {
    memset_s(__s, 0x10uLL, 0, 0x10uLL);
    if (der_dict_iterate())
    {
      void *__s = der_get_number();
      *((_DWORD *)__s + 1) = der_get_number();
      *((_DWORD *)__s + 2) = der_get_number();
      int number = der_get_number();
      uint64_t result = 0;
      *((_DWORD *)__s + 3) = number;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t decode_primary_identity_state(uint64_t a1, int a2, void *__s, void *a4, uint64_t a5)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a1 && __s && a4)
  {
    memset_s(__s, 0x10uLL, 0, 0x10uLL);
    memset_s(a4, 0x10uLL, 0, 0x10uLL);
    uint64_t v12 = 0;
    v10[0] = 0u;
    long long v11 = 0u;
    long long v14 = 0u;
    long long v15 = 0u;
    v10[1] = (unint64_t)der_key_group_uuid;
    uint64_t v13 = der_key_uuid;
    der_dict_iterate();
    if (der_utils_decode_implicit_raw_octet_string_copy(v10, 4, (uint64_t)__s, 16)
      && der_utils_decode_implicit_raw_octet_string_copy((long long *)((char *)&v11 + 8), 4, (uint64_t)a4, 16))
    {
      return der_utils_decode_implicit_raw_octet_string_copy(&v15, 4, a5, 16) - 1;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t decode_fv_blob_state(uint64_t a1, uint64_t a2, _DWORD *__s)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a1 && __s)
  {
    memset_s(__s, 0x58uLL, 0, 0x58uLL);
    long long v24 = 0u;
    uint64_t v26 = 0;
    long long v27 = 0u;
    uint64_t v28 = 0;
    long long v30 = 0u;
    long long v31 = 0u;
    uint64_t v33 = 0;
    long long v34 = 0u;
    uint64_t v35 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    uint64_t v40 = 0;
    long long v41 = 0u;
    uint64_t v42 = 0;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v8 = 0u;
    uint64_t v9 = 0;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    uint64_t v15 = 0;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    uint64_t v21 = 0;
    long long v23 = 0u;
    uint64_t v10 = der_key_id;
    *(void *)&long long v13 = der_key_flags;
    uint64_t v16 = der_key_version;
    *(void *)&long long v19 = der_key_state_reserved;
    uint64_t v22 = der_key_state_failed_attempts;
    long long v25 = der_key_state_failed_attempts_other;
    uint64_t v29 = der_key_config_max_unlock_attempts;
    unsigned int v32 = der_key_state_backoff;
    long long v36 = der_key_state_backoff_other;
    uint64_t v39 = der_key_config_capabilities;
    uint64_t v43 = der_key_state_refcount;
    der_dict_iterate();
    void *__s = der_get_number();
    if (der_utils_decode_implicit_raw_octet_string_copy((long long *)((char *)&v8 + 8), 4, (uint64_t)(__s + 1), 16)&& der_utils_decode_implicit_raw_octet_string_copy(&v12, 4, (uint64_t)(__s + 5), 16)&& (__s[9] = der_get_number(), __s[10] = der_get_number(), __s[11] = der_get_number(), __s[12] = der_get_number(), __s[15] = der_get_number(), __s[13] = der_get_number(), __s[14] = der_get_number(), der_utils_decode_implicit_raw_octet_string_copy_partial((long long *)((char *)&v20 + 8))))
    {
      int v6 = __s[9];
      if ((v6 & 0x400) != 0)
      {
        *((void *)__s + 9) = der_get_number();
        int v6 = __s[9];
      }
      if ((v6 & 0x800) != 0)
      {
        int number = der_get_number();
        uint64_t result = 0;
        __s[20] = number;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t der_utils_decode_implicit_raw_octet_string_copy_partial(long long *a1)
{
  long long v4 = *a1;
  uint64_t v2 = ccder_blob_decode_range();
  if (v2) {
    *a1 = v4;
  }
  return v2;
}

uint64_t encode_pfk_params_public(int *a1, void *a2, _DWORD *a3)
{
  long long v11 = 0;
  uint64_t v3 = 4294967273;
  if (a2 && a3)
  {
    if (a1 && (int v7 = *a1) != 0)
    {
      if (v7)
      {
        encode_list_cstr_add_data(&v11, "persona_uuid", (uint64_t)(a1 + 1));
        int v7 = *a1;
      }
      if ((v7 & 2) != 0) {
        encode_list_cstr_add_data(&v11, "volume_uuid", (uint64_t)(a1 + 5));
      }
      uint64_t v9 = 0;
      size_t v10 = 0;
      if (!encode_list_dict(&v11, &v9, &v10))
      {
        uint64_t v3 = 0;
        *a2 = v9;
        *a3 = v10;
      }
    }
    else
    {
      uint64_t v3 = 0;
      *a2 = 0;
      *a3 = 0;
    }
  }
  encode_list_free(&v11);
  return v3;
}

uint64_t decode_pfk_params_internal(uint64_t a1, uint64_t a2, char *__s)
{
  int v6 = 0;
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a2 && a1 && __s)
  {
    memset_s(__s, 0x24uLL, 0, 0x24uLL);
    if (der_dict_iterate())
    {
      if (!encode_list_cstr_get_data(&v6, "volume_uuid", __s + 20, 0x10uLL)) {
        *(_DWORD *)__s |= 2u;
      }
      uint64_t v3 = 0;
      if (!encode_list_cstr_get_data(&v6, "persona_uuid", __s + 4, 0x10uLL)) {
        *(_DWORD *)__s |= 1u;
      }
    }
    else
    {
      uint64_t v3 = 0xFFFFFFFFLL;
    }
  }
  encode_list_free(&v6);
  return v3;
}

uint64_t encode_fv_params_internal(uint64_t a1, void *a2, _DWORD *a3)
{
  size_t v10 = 0;
  uint64_t v3 = 4294967273;
  if (a2 && a3)
  {
    if (a1)
    {
      if (!encode_list_cstr_add_data(&v10, "options", a1)
        && !encode_list_cstr_add_data(&v10, "kc", a1 + 8))
      {
        uint64_t v8 = 0;
        size_t v9 = 0;
        if (!encode_list_dict(&v10, &v8, &v9))
        {
          uint64_t v3 = 0;
          *a2 = v8;
          *a3 = v9;
        }
      }
    }
    else
    {
      uint64_t v3 = 0;
      *a2 = 0;
      *a3 = 0;
    }
  }
  encode_list_free(&v10);
  return v3;
}

uint64_t decode_fv_params_internal(uint64_t a1, uint64_t a2, char *__s)
{
  int v6 = 0;
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a2 && a1 && __s)
  {
    memset_s(__s, 0x10uLL, 0, 0x10uLL);
    if (der_dict_iterate())
    {
      encode_list_cstr_get_data(&v6, "options", __s, 8uLL);
      encode_list_cstr_get_data(&v6, "kc", __s + 8, 4uLL);
      uint64_t v3 = 0;
    }
    else
    {
      uint64_t v3 = 0xFFFFFFFFLL;
    }
  }
  encode_list_free(&v6);
  return v3;
}

void *ref_key_op_der_to_enum(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v4 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a2)
    {
      uint64_t v2 = der_key_op;
      if (der_key_op)
      {
        der_dict_iterate();
        return 0;
      }
    }
  }
  return v2;
}

uint64_t der_utils_decode_implicit_raw_octet_string_alloc(long long *a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  long long v8 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0) {
    return 0;
  }
  if (a3 && a4)
  {
    uint64_t result = (uint64_t)calloc(0, 1uLL);
    if (!result) {
      return result;
    }
    *a3 = result;
    *a4 = 0;
  }
  *a1 = v8;
  return 1;
}

uint64_t der_utils_decode_implicit_uint64(long long *a1, uint64_t a2, void *a3)
{
  if (a3) {
    *a3 = 0;
  }
  long long v6 = *a1;
  uint64_t result = ccder_blob_decode_range();
  if (result)
  {
    if (ccn_read_uint())
    {
      return 0;
    }
    else
    {
      *a1 = v6;
      if (a3) {
        *a3 = 0;
      }
      return 1;
    }
  }
  return result;
}

uint64_t _qsort_compare(const void **a1, void **a2)
{
  uint64_t v5 = *a1;
  __s2 = *a2;
  if (!ccder_blob_decode_sequence_tl()
    || !ccder_blob_decode_sequence_tl()
    || !ccder_blob_decode_tag()
    || !ccder_blob_decode_len()
    || !v5
    || !ccder_blob_decode_tag()
    || !ccder_blob_decode_len()
    || !__s2)
  {
    return 4294967293;
  }
  int v2 = memcmp(v5, __s2, 0);
  if (v2 > 0) {
    return 1;
  }
  else {
    return ((v2 < 0) << 31 >> 31);
  }
}

uint64_t platform_get_measurement(uint64_t a1, int a2, void *a3, size_t *a4)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 36, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  if (!lib_platform_callbacks) {
    return 4294967284;
  }
  if (a1 >= 7) {
    abort();
  }
  unsigned int v8 = a1;
  size_t v9 = (char *)&pm_id_table + 72 * a1;
  int v11 = v9[4];
  size_t v10 = v9 + 4;
  if (!v11)
  {
    uint64_t result = ((uint64_t (*)(uint64_t, char *, char *))lib_platform_callbacks)(a1, (char *)&pm_id_table + 72 * a1 + 5, (char *)&pm_id_table + 72 * a1 + 64);
    if (result) {
      return result;
    }
    unsigned char *v10 = 1;
  }
  long long v13 = (char *)&pm_id_table + 72 * a1;
  size_t v15 = *((void *)v13 + 8);
  long long v14 = (unint64_t *)(v13 + 64);
  if (*a4 < v15) {
    return 4294967285;
  }
  memcpy(a3, (char *)&pm_id_table + 72 * v8 + 5, *a4);
  unint64_t v16 = *v14;
  *a4 = *v14;
  if (a2) {
    byte_swap_val((char *)a3, v16);
  }
  return 0;
}

uint64_t platform_rng()
{
  REQUIRE_func(&lib_platform_callbacks != 0, 62, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(off_26D1DA470[0] != 0, 63, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  uint64_t v0 = off_26D1DA470[0];
  return v0();
}

uint64_t platform_read_random(uint64_t a1, unsigned int a2)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 70, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(off_26D1DA478 != 0, 71, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  uint64_t v4 = (uint64_t (*)(uint64_t, unsigned int))off_26D1DA478;
  return v4(a1, a2);
}

uint64_t platform_pka_get_pub_key(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 78, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA480 != 0, 79, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  unint64_t v16 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))unk_26D1DA480;
  return v16(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t platform_pka_ecdh(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 86, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA488 != 0, 87, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  long long v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))unk_26D1DA488;
  return v18(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t platform_pka_sign(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 94, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA490 != 0, 95, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  long long v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))unk_26D1DA490;
  return v18(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t platform_pka_sika_attest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 106, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA498 != 0, 107, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  long long v17 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, void, void, void, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))unk_26D1DA498;
  return v17(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

uint64_t platform_pka_shared_encrypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 115, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4A0 != 0, 116, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  long long v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))unk_26D1DA4A0;
  return v18(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
}

uint64_t platform_ref_key_hw_crypt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 123, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4A8 != 0, 124, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  size_t v10 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))unk_26D1DA4A8;
  return v10(a1, a2, a3, a4, a5);
}

uint64_t platform_ref_key_hw_crypt_clear_cache()
{
  REQUIRE_func(&lib_platform_callbacks != 0, 131, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4B0 != 0, 132, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  uint64_t v0 = (uint64_t (*)(void))unk_26D1DA4B0;
  return v0();
}

uint64_t platform_get_device_id(uint64_t a1, uint64_t a2)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 139, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4B8 != 0, 140, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t))unk_26D1DA4B8;
  return v4(a1, a2);
}

uint64_t platform_get_aon_security(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 147, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4C0 != 0, 148, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  int v2 = (uint64_t (*)(uint64_t))unk_26D1DA4C0;
  return v2(a1);
}

uint64_t platform_get_att_sep_chip_rev(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 155, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4C8 != 0, 156, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  int v2 = (uint64_t (*)(uint64_t))unk_26D1DA4C8;
  return v2(a1);
}

uint64_t platform_get_chip_id(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 163, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4D0 != 0, 164, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  int v2 = (uint64_t (*)(uint64_t))unk_26D1DA4D0;
  return v2(a1);
}

uint64_t platform_get_ecid(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 171, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4D8 != 0, 172, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  int v2 = (uint64_t (*)(uint64_t))unk_26D1DA4D8;
  return v2(a1);
}

uint64_t platform_get_board_id(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 179, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4E0 != 0, 180, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  int v2 = (uint64_t (*)(uint64_t))unk_26D1DA4E0;
  return v2(a1);
}

uint64_t platform_get_fuse_bits(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 187, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4E8 != 0, 188, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  int v2 = (uint64_t (*)(uint64_t))unk_26D1DA4E8;
  return v2(a1);
}

uint64_t platform_get_att_board_and_chip_id(uint64_t a1)
{
  REQUIRE_func(&lib_platform_callbacks != 0, 195, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  REQUIRE_func(unk_26D1DA4F0 != 0, 196, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  int v2 = (uint64_t (*)(uint64_t))unk_26D1DA4F0;
  return v2(a1);
}

uint64_t aks_get_pad_size(int a1)
{
  return -a1 & 3;
}

char *aks_copy_packed_data(_DWORD *a1, const void *a2, int a3)
{
  uint64_t v3 = (char *)(a1 + 1);
  if (a2)
  {
    *a1 = a3;
    memcpy(a1 + 1, a2, a3);
    v3 += a3;
    int v5 = -a3;
    size_t v6 = -a3 & 3;
    if ((v5 & 3) != 0)
    {
      int __s = 0;
      memset_s(&__s, 4uLL, 0, 4uLL);
      memcpy(v3, &__s, v6);
      v3 += v6;
    }
  }
  else
  {
    *a1 = 0;
  }
  return v3;
}

char *aks_pack_data(char **a1, unsigned int *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v21 = &a9;
  unsigned int v12 = 4;
  if (a3)
  {
    int v13 = a3;
    do
    {
      long long v14 = v21;
      v21 += 2;
      v12 += *((_DWORD *)v14 + 2) + (-*((_DWORD *)v14 + 2) & 3) + 4;
      --v13;
    }
    while (v13);
  }
  uint64_t result = (char *)calloc(1uLL, v12);
  unint64_t v16 = result;
  uint64_t v22 = (const void **)&a9;
  int v17 = 0;
  if (a3)
  {
    uint64_t v18 = 4;
    do
    {
      long long v19 = v22;
      long long v20 = *v22;
      v22 += 2;
      uint64_t result = aks_copy_packed_data(&v16[v18], v20, *((_DWORD *)v19 + 2));
      uint64_t v18 = result - v16;
      ++v17;
    }
    while (a3 != v17);
  }
  *(_DWORD *)unint64_t v16 = v17;
  *a1 = v16;
  *a2 = v12;
  return result;
}

uint64_t aks_unpack_data(unsigned int *a1, unint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a2 < 4) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v9 = a3;
  if (*a1 >= a3)
  {
    long long v19 = (void **)&a9;
    if (!a3) {
      return 0;
    }
    int v11 = (char *)(a1 + 1);
    while (1)
    {
      unsigned int v12 = v19;
      int v13 = *v19;
      v19 += 2;
      unsigned int v16 = *(_DWORD *)v11;
      long long v14 = v11 + 4;
      size_t v15 = v16;
      if (v16 > a2) {
        break;
      }
      if (v13)
      {
        int v17 = (size_t *)v12[1];
        if (*v17 < v15) {
          return 0xFFFFFFFFLL;
        }
        memcpy(v13, v14, v15);
        *int v17 = v15;
      }
      int v11 = &v14[v15];
      if (!--v9) {
        return 0;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t AWDPostMetric()
{
  return MEMORY[0x270F858D8]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x270F18A48]();
}

uint64_t CCRandomCopyBytes()
{
  return MEMORY[0x270ED7A78]();
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x270EE4528]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x270EE4530](BOOLean);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x270EE47C8](allocator, bytes, length);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x270EE4808](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x270EE4820](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x270EE4838]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x270EE4968](theDict, key, value);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x270EE4B88]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x270EE4BE8](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x270EE4C58]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x270EE4C70](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x270EE4CC0](key, applicationID, userName, hostName);
}

void CFRelease(CFTypeRef cf)
{
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return (CFUserNotificationRef)MEMORY[0x270EE54C8](allocator, flags, error, dictionary, timeout);
}

SInt32 CFUserNotificationDisplayAlert(CFTimeInterval timeout, CFOptionFlags flags, CFURLRef iconURL, CFURLRef soundURL, CFURLRef localizationURL, CFStringRef alertHeader, CFStringRef alertMessage, CFStringRef defaultButtonTitle, CFStringRef alternateButtonTitle, CFStringRef otherButtonTitle, CFOptionFlags *responseFlags)
{
  return MEMORY[0x270EE54D8](flags, iconURL, soundURL, localizationURL, alertHeader, alertMessage, defaultButtonTitle, alternateButtonTitle, timeout);
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  return MEMORY[0x270EE5500](userNotification, responseFlags, timeout);
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x270EF3F30](*(void *)&connection, *(void *)&selector, input, *(void *)&inputCnt, inputStruct, inputStructCnt, output, outputCnt);
}

kern_return_t IOConnectMapMemory(io_connect_t connect, uint32_t memoryType, task_port_t intoTask, mach_vm_address_t *atAddress, mach_vm_size_t *ofSize, IOOptionBits options)
{
  return MEMORY[0x270EF3F50](*(void *)&connect, *(void *)&memoryType, *(void *)&intoTask, atAddress, ofSize, *(void *)&options);
}

kern_return_t IOConnectSetNotificationPort(io_connect_t connect, uint32_t type, mach_port_t port, uintptr_t reference)
{
  return MEMORY[0x270EF3F78](*(void *)&connect, *(void *)&type, *(void *)&port, reference);
}

kern_return_t IOConnectUnmapMemory(io_connect_t connect, uint32_t memoryType, task_port_t fromTask, mach_vm_address_t atAddress)
{
  return MEMORY[0x270EF3FB8](*(void *)&connect, *(void *)&memoryType, *(void *)&fromTask, atAddress);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x270EF47B8](*(void *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x270EF4820](*(void *)&object);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x270EF49D8](*(void *)&entry, key, allocator, *(void *)&options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return MEMORY[0x270EF49E8](*(void *)&mainPort, path);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x270EF4A98](*(void *)&connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x270EF4AB0](*(void *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EF4AD0](name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return MEMORY[0x270EF4AE0](*(void *)&service, *(void *)&owningTask, *(void *)&type, connect);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x270F95F98]();
}

uint64_t MKBDeviceSetGracePeriod()
{
  return MEMORY[0x270F4AE10]();
}

uint64_t MKBDeviceUnlockedSinceBoot()
{
  return MEMORY[0x270F4AE20]();
}

uint64_t MKBGetDeviceLockStateInfo()
{
  return MEMORY[0x270F4AE50]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x270EF2A50](aClassName);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x270EF2BE8](aSelectorName);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x270EF2C08](aClass);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x270EF2C38](aSelector);
}

uint64_t PBDataWriterWriteUint32Field()
{
  return MEMORY[0x270F585B0]();
}

uint64_t PBDataWriterWriteUint64Field()
{
  return MEMORY[0x270F585B8]();
}

uint64_t PBReaderPlaceMark()
{
  return MEMORY[0x270F585D8]();
}

uint64_t PBReaderRecallMark()
{
  return MEMORY[0x270F585F8]();
}

uint64_t PBReaderSkipValueWithTag()
{
  return MEMORY[0x270F58600]();
}

uint64_t PBRepeatedUInt32Add()
{
  return MEMORY[0x270F586F8]();
}

uint64_t PBRepeatedUInt32Clear()
{
  return MEMORY[0x270F58708]();
}

uint64_t PBRepeatedUInt32Copy()
{
  return MEMORY[0x270F58710]();
}

uint64_t PBRepeatedUInt32Hash()
{
  return MEMORY[0x270F58720]();
}

uint64_t PBRepeatedUInt32IsEqual()
{
  return MEMORY[0x270F58730]();
}

uint64_t PBRepeatedUInt32NSArray()
{
  return MEMORY[0x270F58740]();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

int *__error(void)
{
  return (int *)MEMORY[0x270ED7DC0]();
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x270ED7E38]();
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x270ED7EE0]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x270ED85F8](*(void *)&__upper_bound);
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return (void *)MEMORY[0x270ED87B0](__count, __size);
}

uint64_t cc_clear()
{
  return MEMORY[0x270ED87D0]();
}

uint64_t ccaes_cbc_decrypt_mode()
{
  return MEMORY[0x270ED87E0]();
}

uint64_t ccaes_cbc_encrypt_mode()
{
  return MEMORY[0x270ED87E8]();
}

uint64_t cccbc_clear_iv()
{
  return MEMORY[0x270ED8820]();
}

uint64_t cccbc_init()
{
  return MEMORY[0x270ED8828]();
}

uint64_t cccurve25519()
{
  return MEMORY[0x270ED8868]();
}

uint64_t cccurve25519_make_pub()
{
  return MEMORY[0x270ED8878]();
}

uint64_t ccder_blob_decode_len()
{
  return MEMORY[0x270ED8890]();
}

uint64_t ccder_blob_decode_range()
{
  return MEMORY[0x270ED88A0]();
}

uint64_t ccder_blob_decode_sequence_tl()
{
  return MEMORY[0x270ED88A8]();
}

uint64_t ccder_blob_decode_tag()
{
  return MEMORY[0x270ED88B0]();
}

uint64_t ccder_blob_decode_tl()
{
  return MEMORY[0x270ED88B8]();
}

uint64_t ccder_blob_encode_body()
{
  return MEMORY[0x270ED88C8]();
}

uint64_t ccder_blob_encode_body_tl()
{
  return MEMORY[0x270ED88D0]();
}

uint64_t ccder_blob_encode_implicit_raw_octet_string()
{
  return MEMORY[0x270ED88D8]();
}

uint64_t ccder_blob_encode_implicit_uint64()
{
  return MEMORY[0x270ED88E0]();
}

uint64_t ccder_blob_encode_tl()
{
  return MEMORY[0x270ED88E8]();
}

uint64_t ccder_decode_sequence_tl()
{
  return MEMORY[0x270ED8920]();
}

uint64_t ccder_decode_tl()
{
  return MEMORY[0x270ED8930]();
}

uint64_t ccder_encode_constructed_tl()
{
  return MEMORY[0x270ED8950]();
}

uint64_t ccder_encode_raw_octet_string()
{
  return MEMORY[0x270ED8968]();
}

uint64_t ccder_encode_uint64()
{
  return MEMORY[0x270ED8978]();
}

uint64_t ccder_sizeof()
{
  return MEMORY[0x270ED8980]();
}

uint64_t ccder_sizeof_implicit_uint64()
{
  return MEMORY[0x270ED8990]();
}

uint64_t ccder_sizeof_raw_octet_string()
{
  return MEMORY[0x270ED89B0]();
}

uint64_t ccder_sizeof_uint64()
{
  return MEMORY[0x270ED89C0]();
}

uint64_t ccdigest()
{
  return MEMORY[0x270ED8A40]();
}

uint64_t ccec_export_pub()
{
  return MEMORY[0x270ED8AB8]();
}

uint64_t ccec_import_pub()
{
  return MEMORY[0x270ED8AD8]();
}

uint64_t cchkdf()
{
  return MEMORY[0x270ED8BA8]();
}

uint64_t cchmac()
{
  return MEMORY[0x270ED8BC0]();
}

uint64_t ccn_read_uint()
{
  return MEMORY[0x270ED8C40]();
}

uint64_t ccn_write_uint_padded()
{
  return MEMORY[0x270ED8C60]();
}

uint64_t ccpbkdf2_hmac()
{
  return MEMORY[0x270ED8C88]();
}

uint64_t ccrng()
{
  return MEMORY[0x270ED8C90]();
}

uint64_t ccsha1_di()
{
  return MEMORY[0x270ED8D60]();
}

uint64_t ccsha256_di()
{
  return MEMORY[0x270ED8D70]();
}

uint64_t cczp_bitlen()
{
  return MEMORY[0x270ED8E70]();
}

objc_property_t *__cdecl class_copyPropertyList(Class cls, unsigned int *outCount)
{
  return (objc_property_t *)MEMORY[0x270F9A438](cls, outCount);
}

int close(int a1)
{
  return MEMORY[0x270ED8F18](*(void *)&a1);
}

uint64_t dictionaryGetBool()
{
  return MEMORY[0x270F10C28]();
}

uint64_t dictionaryGetData()
{
  return MEMORY[0x270F10C30]();
}

uint64_t dictionaryGetInteger()
{
  return MEMORY[0x270F10C38]();
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x270ED9278](flags, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9448](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9458](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x270ED9510](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x270ED95A8](when, delta);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x270ED98D0](*(void *)&a1, *(void *)&a2);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x270ED9A08](a1, a2);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x270ED9AF0](*(void *)&a1, a2);
}

int fts_close(FTS *a1)
{
  return MEMORY[0x270ED9B48](a1);
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  return (FTS *)MEMORY[0x270ED9B50](a1, *(void *)&a2, a3);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  return (FTSENT *)MEMORY[0x270ED9B60](a1);
}

int fts_set(FTS *a1, FTSENT *a2, int a3)
{
  return MEMORY[0x270ED9B68](a1, a2, *(void *)&a3);
}

uint64_t getBootArgs()
{
  return MEMORY[0x270F10C40]();
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x270ED9D98](a1, a2);
}

uint64_t isEphemeralMultiUser()
{
  return MEMORY[0x270F10C48]();
}

uint64_t isInternalBuild()
{
  return MEMORY[0x270F10C50]();
}

uint64_t kdebug_trace()
{
  return MEMORY[0x270ED9F50]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x270EDA158]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x270EDA288](info);
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x270EDA328](__size);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return MEMORY[0x270EDA4B8](__s, __smax, *(void *)&__c, __n);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x270EDA738](*(void *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x270EDA748](*(void *)&token, state64);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x270EDA760](name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x270EDA768](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x270EDA770](name, out_token, queue, handler);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return MEMORY[0x270EDA798](*(void *)&token, state64);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x270F9A568](a1);
}

{
  MEMORY[0x270F9A570](context);
}

{
  return (void *)MEMORY[0x270F9A588]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x270F9A598](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_rethrow(void)
{
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x270F9A678](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x270F9A688](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x270F9A6B0](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x270F9A700]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x270F9A728]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A890](a1);
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x270F9A9F8](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x270F9AA18](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x270F9AA20](obj);
}

void objc_terminate(void)
{
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x270EDA828](a1, *(void *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x270EDA830](a1, *(void *)&a2, *(void *)&a3, *(void *)&a4);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

uint64_t os_state_add_handler()
{
  return MEMORY[0x270EDAA78]();
}

uint64_t os_state_remove_handler()
{
  return MEMORY[0x270EDAA80]();
}

uint64_t os_transaction_create()
{
  return MEMORY[0x270EDAA90]();
}

int printf(const char *a1, ...)
{
  return MEMORY[0x270EDAD20](a1);
}

const char *__cdecl property_getName(objc_property_t property)
{
  return (const char *)MEMORY[0x270F9AA98](property);
}

int putchar(int a1)
{
  return MEMORY[0x270EDB090](*(void *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x270EDB098](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x270EDB120](*(void *)&a1, a2, a3);
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  return (char *)MEMORY[0x270EDB170](a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return MEMORY[0x270EDB508](*(void *)&a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x270EDB568](a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return MEMORY[0x270EDB570](a1, a2);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x270EDB5D8](*(void *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return (char *)MEMORY[0x270EDB660](__big, __little, __len);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return MEMORY[0x270EDB7D8](a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
}

time_t time(time_t *a1)
{
  return MEMORY[0x270EDB930](a1);
}

void uuid_clear(uuid_t uu)
{
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return MEMORY[0x270EDBA08](uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x270EDBC30](*(void *)&__fd, __buf, __nbyte);
}