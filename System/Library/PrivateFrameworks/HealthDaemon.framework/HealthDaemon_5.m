__n128 std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>(long long *a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  long long v18;
  long long v19;
  long long v20;
  __n128 result;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  long long v28;
  long long v29;
  long long v30;
  long long v31;
  long long v32;
  long long v33;
  long long v34;
  long long v35;
  long long v36;
  long long v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  long long v44;
  long long v45;
  unsigned char v46[32];
  unsigned char v47[32];
  unsigned char v48[32];
  unsigned char v49[24];

  v4 = *((void *)a2 + 3);
  v5 = *((void *)a1 + 3);
  if (v4 == v5) {
    goto LABEL_23;
  }
  v6 = *(char **)(*(void *)a4 + 232);
  v7 = *(char **)(*(void *)a4 + 240);
  if (v6 == v7)
  {
    v9 = *(char **)(*(void *)a4 + 232);
    v8 = v9;
  }
  else
  {
    v8 = *(char **)(*(void *)a4 + 232);
    while (*(void *)v8 != v4)
    {
      v8 += 8;
      if (v8 == v7)
      {
        v8 = *(char **)(*(void *)a4 + 240);
        break;
      }
    }
    v9 = *(char **)(*(void *)a4 + 232);
    while (*(void *)v9 != v5)
    {
      v9 += 8;
      if (v9 == v7)
      {
        v9 = *(char **)(*(void *)a4 + 240);
        break;
      }
    }
  }
  if (v8 - v6 >= v9 - v6)
  {
LABEL_23:
    v13 = *((void *)a3 + 3);
    if (v13 != v4)
    {
      v14 = *(char **)(*(void *)a4 + 232);
      v15 = *(char **)(*(void *)a4 + 240);
      v16 = v14;
      v17 = v14;
      if (v14 != v15)
      {
        do
        {
          if (*(void *)v17 == v13) {
            goto LABEL_28;
          }
          v17 += 8;
        }
        while (v17 != v15);
        v17 = *(char **)(*(void *)a4 + 240);
LABEL_28:
        while (*(void *)v16 != v4)
        {
          v16 += 8;
          if (v16 == v15)
          {
            v16 = *(char **)(*(void *)a4 + 240);
            break;
          }
        }
      }
      if (v17 - v14 < v16 - v14)
      {
        v18 = *a2;
        *(_OWORD *)v46 = a2[1];
        *(_OWORD *)&v46[16] = a2[2];
        v19 = *(long long *)((char *)a3 + 27);
        v20 = a3[1];
        *a2 = *a3;
        a2[1] = v20;
        *(long long *)((char *)a2 + 27) = v19;
        *a3 = v18;
        a3[1] = *(_OWORD *)v46;
        result = *(__n128 *)&v46[11];
        *(long long *)((char *)a3 + 27) = *(_OWORD *)&v46[11];
        v22 = *((void *)a2 + 3);
        v23 = *((void *)a1 + 3);
        if (v22 != v23)
        {
          v24 = *(char **)(*(void *)a4 + 232);
          v25 = *(char **)(*(void *)a4 + 240);
          v26 = v24;
          v27 = v24;
          if (v24 != v25)
          {
            do
            {
              if (*(void *)v27 == v22) {
                goto LABEL_37;
              }
              v27 += 8;
            }
            while (v27 != v25);
            v27 = *(char **)(*(void *)a4 + 240);
LABEL_37:
            while (*(void *)v26 != v23)
            {
              v26 += 8;
              if (v26 == v25)
              {
                v26 = *(char **)(*(void *)a4 + 240);
                break;
              }
            }
          }
          if (v27 - v24 < v26 - v24)
          {
            v28 = *a1;
            *(_OWORD *)v47 = a1[1];
            *(_OWORD *)&v47[16] = a1[2];
            v29 = *(long long *)((char *)a2 + 27);
            v30 = a2[1];
            *a1 = *a2;
            a1[1] = v30;
            *(long long *)((char *)a1 + 27) = v29;
            *a2 = v28;
            a2[1] = *(_OWORD *)v47;
            result = *(__n128 *)&v47[11];
            *(long long *)((char *)a2 + 27) = *(_OWORD *)&v47[11];
          }
        }
      }
    }
  }
  else
  {
    v10 = *((void *)a3 + 3);
    if (v10 != v4)
    {
      if (v6 == v7)
      {
        v12 = *(char **)(*(void *)a4 + 232);
        v11 = v12;
      }
      else
      {
        v11 = *(char **)(*(void *)a4 + 232);
        while (*(void *)v11 != v10)
        {
          v11 += 8;
          if (v11 == v7)
          {
            v11 = *(char **)(*(void *)a4 + 240);
            break;
          }
        }
        v12 = *(char **)(*(void *)a4 + 232);
        while (*(void *)v12 != v4)
        {
          v12 += 8;
          if (v12 == v7)
          {
            v12 = *(char **)(*(void *)a4 + 240);
            break;
          }
        }
      }
      if (v11 - v6 < v12 - v6)
      {
        v31 = a1[1];
        v32 = *a1;
        *(void *)v49 = *((void *)&v31 + 1);
        *(_OWORD *)&v49[8] = a1[2];
        v33 = *(long long *)((char *)a3 + 27);
        v34 = a3[1];
        *a1 = *a3;
        a1[1] = v34;
        *(long long *)((char *)a1 + 27) = v33;
LABEL_55:
        *a3 = v32;
        a3[1] = v31;
        result = *(__n128 *)&v49[3];
        *(long long *)((char *)a3 + 27) = *(_OWORD *)&v49[3];
        return result;
      }
    }
    v35 = *a1;
    *(_OWORD *)v48 = a1[1];
    *(_OWORD *)&v48[16] = a1[2];
    v36 = *(long long *)((char *)a2 + 27);
    v37 = a2[1];
    *a1 = *a2;
    a1[1] = v37;
    *(long long *)((char *)a1 + 27) = v36;
    *a2 = v35;
    a2[1] = *(_OWORD *)v48;
    result = *(__n128 *)&v48[11];
    *(long long *)((char *)a2 + 27) = *(_OWORD *)&v48[11];
    v38 = *((void *)a3 + 3);
    v39 = *((void *)a2 + 3);
    if (v38 != v39)
    {
      v40 = *(char **)(*(void *)a4 + 232);
      v41 = *(char **)(*(void *)a4 + 240);
      v42 = v40;
      v43 = v40;
      if (v40 != v41)
      {
        do
        {
          if (*(void *)v43 == v38) {
            goto LABEL_50;
          }
          v43 += 8;
        }
        while (v43 != v41);
        v43 = *(char **)(*(void *)a4 + 240);
LABEL_50:
        while (*(void *)v42 != v39)
        {
          v42 += 8;
          if (v42 == v41)
          {
            v42 = *(char **)(*(void *)a4 + 240);
            break;
          }
        }
      }
      if (v43 - v40 < v42 - v40)
      {
        v31 = a2[1];
        v32 = *a2;
        *(void *)v49 = *((void *)&v31 + 1);
        *(_OWORD *)&v49[8] = a2[2];
        v44 = *(long long *)((char *)a3 + 27);
        v45 = a3[1];
        *a2 = *a3;
        a2[1] = v45;
        *(long long *)((char *)a2 + 27) = v44;
        goto LABEL_55;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = *(void *)(a2 - 24);
      uint64_t v9 = *(void *)(a1 + 24);
      if (v8 == v9) {
        return result;
      }
      v10 = *(char **)(*(void *)a3 + 232);
      v11 = *(char **)(*(void *)a3 + 240);
      v12 = v10;
      v13 = v10;
      if (v10 == v11) {
        goto LABEL_10;
      }
      do
      {
        if (*(void *)v13 == v8) {
          goto LABEL_7;
        }
        v13 += 8;
      }
      while (v13 != v11);
      v13 = *(char **)(*(void *)a3 + 240);
      do
      {
LABEL_7:
        if (*(void *)v12 == v9) {
          goto LABEL_10;
        }
        v12 += 8;
      }
      while (v12 != v11);
      v12 = *(char **)(*(void *)a3 + 240);
LABEL_10:
      if (v13 - v10 < v12 - v10)
      {
        v14 = (long long *)(a2 - 48);
        long long v15 = *(_OWORD *)a1;
        *(_OWORD *)v35 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v35[16] = *(_OWORD *)(a1 + 32);
        long long v16 = *(_OWORD *)(a2 - 21);
        long long v17 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a1 + 16) = v17;
        *(_OWORD *)(a1 + 27) = v16;
        long long *v14 = v15;
        v14[1] = *(_OWORD *)v35;
        *(long long *)((char *)v14 + 27) = *(_OWORD *)&v35[11];
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a2 - 48), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a2 - 48, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a1 + 144, a2 - 48, a3);
      return 1;
    default:
      uint64_t v18 = a1 + 96;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a1 + 96), a3);
      uint64_t v19 = a1 + 144;
      if (a1 + 144 == a2) {
        return 1;
      }
      int v20 = 0;
      break;
  }
  while (1)
  {
    uint64_t v21 = *(void *)(v19 + 24);
    uint64_t v22 = *(void *)(v18 + 24);
    if (v21 != v22)
    {
      v23 = *(char **)(*(void *)a3 + 232);
      v24 = *(char **)(*(void *)a3 + 240);
      v25 = v23;
      v26 = v23;
      if (v23 != v24)
      {
        do
        {
          if (*(void *)v26 == v21) {
            goto LABEL_19;
          }
          v26 += 8;
        }
        while (v26 != v24);
        v26 = *(char **)(*(void *)a3 + 240);
LABEL_19:
        while (*(void *)v25 != v22)
        {
          v25 += 8;
          if (v25 == v24)
          {
            v25 = *(char **)(*(void *)a3 + 240);
            break;
          }
        }
      }
      if (v26 - v23 < v25 - v23)
      {
        long long v34 = *(_OWORD *)v19;
        uint64_t v36 = *(void *)(v19 + 16);
        long long v37 = *(_OWORD *)(v19 + 32);
        uint64_t v27 = v19;
        while (1)
        {
          long long v28 = *(_OWORD *)(v18 + 16);
          *(_OWORD *)uint64_t v27 = *(_OWORD *)v18;
          *(_OWORD *)(v27 + 16) = v28;
          *(_OWORD *)(v27 + 27) = *(_OWORD *)(v18 + 27);
          if (v18 == a1) {
            break;
          }
          uint64_t v27 = v18;
          uint64_t v29 = *(void *)(v18 - 24);
          if (v21 != v29)
          {
            v30 = *(char **)(*(void *)a3 + 232);
            v31 = *(char **)(*(void *)a3 + 240);
            v32 = v30;
            v33 = v30;
            if (v30 != v31)
            {
              do
              {
                if (*(void *)v33 == v21) {
                  goto LABEL_30;
                }
                v33 += 8;
              }
              while (v33 != v31);
              v33 = *(char **)(*(void *)a3 + 240);
LABEL_30:
              while (*(void *)v32 != v29)
              {
                v32 += 8;
                if (v32 == v31)
                {
                  v32 = *(char **)(*(void *)a3 + 240);
                  break;
                }
              }
            }
            v18 -= 48;
            if (v33 - v30 < v32 - v30) {
              continue;
            }
          }
          goto LABEL_36;
        }
        uint64_t v27 = a1;
LABEL_36:
        *(_OWORD *)uint64_t v27 = v34;
        *(void *)(v27 + 16) = v36;
        *(void *)(v27 + 24) = v21;
        *(void *)(v27 + 32) = v37;
        *(_DWORD *)(v27 + 39) = *(_DWORD *)((char *)&v37 + 7);
        if (++v20 == 8) {
          return v19 + 48 == a2;
        }
      }
    }
    uint64_t v18 = v19;
    v19 += 48;
    if (v19 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  result.n128_u64[0] = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>((long long *)a1, (long long *)a2, (long long *)a3, a5).n128_u64[0];
  uint64_t v11 = *(void *)(a4 + 24);
  uint64_t v12 = *(void *)(a3 + 24);
  if (v11 != v12)
  {
    v13 = *(char **)(*(void *)a5 + 232);
    v14 = *(char **)(*(void *)a5 + 240);
    long long v15 = v13;
    long long v16 = v13;
    if (v13 != v14)
    {
      do
      {
        if (*(void *)v16 == v11) {
          goto LABEL_6;
        }
        v16 += 8;
      }
      while (v16 != v14);
      long long v16 = *(char **)(*(void *)a5 + 240);
LABEL_6:
      while (*(void *)v15 != v12)
      {
        v15 += 8;
        if (v15 == v14)
        {
          long long v15 = *(char **)(*(void *)a5 + 240);
          break;
        }
      }
    }
    if (v16 - v13 < v15 - v13)
    {
      long long v17 = *(_OWORD *)a3;
      *(_OWORD *)v38 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)&v38[16] = *(_OWORD *)(a3 + 32);
      long long v18 = *(_OWORD *)(a4 + 27);
      long long v19 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)(a3 + 16) = v19;
      *(_OWORD *)(a3 + 27) = v18;
      *(_OWORD *)a4 = v17;
      *(_OWORD *)(a4 + 16) = *(_OWORD *)v38;
      __n128 result = *(__n128 *)&v38[11];
      *(_OWORD *)(a4 + 27) = *(_OWORD *)&v38[11];
      uint64_t v20 = *(void *)(a3 + 24);
      uint64_t v21 = *(void *)(a2 + 24);
      if (v20 != v21)
      {
        uint64_t v22 = *(char **)(*(void *)a5 + 232);
        v23 = *(char **)(*(void *)a5 + 240);
        v24 = v22;
        v25 = v22;
        if (v22 != v23)
        {
          do
          {
            if (*(void *)v25 == v20) {
              goto LABEL_15;
            }
            v25 += 8;
          }
          while (v25 != v23);
          v25 = *(char **)(*(void *)a5 + 240);
LABEL_15:
          while (*(void *)v24 != v21)
          {
            v24 += 8;
            if (v24 == v23)
            {
              v24 = *(char **)(*(void *)a5 + 240);
              break;
            }
          }
        }
        if (v25 - v22 < v24 - v22)
        {
          long long v26 = *(_OWORD *)a2;
          *(_OWORD *)v39 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)&v39[16] = *(_OWORD *)(a2 + 32);
          long long v27 = *(_OWORD *)(a3 + 27);
          long long v28 = *(_OWORD *)(a3 + 16);
          *(_OWORD *)a2 = *(_OWORD *)a3;
          *(_OWORD *)(a2 + 16) = v28;
          *(_OWORD *)(a2 + 27) = v27;
          *(_OWORD *)a3 = v26;
          *(_OWORD *)(a3 + 16) = *(_OWORD *)v39;
          __n128 result = *(__n128 *)&v39[11];
          *(_OWORD *)(a3 + 27) = *(_OWORD *)&v39[11];
          uint64_t v29 = *(void *)(a2 + 24);
          uint64_t v30 = *(void *)(a1 + 24);
          if (v29 != v30)
          {
            v31 = *(char **)(*(void *)a5 + 232);
            v32 = *(char **)(*(void *)a5 + 240);
            v33 = v31;
            long long v34 = v31;
            if (v31 != v32)
            {
              do
              {
                if (*(void *)v34 == v29) {
                  goto LABEL_24;
                }
                v34 += 8;
              }
              while (v34 != v32);
              long long v34 = *(char **)(*(void *)a5 + 240);
LABEL_24:
              while (*(void *)v33 != v30)
              {
                v33 += 8;
                if (v33 == v32)
                {
                  v33 = *(char **)(*(void *)a5 + 240);
                  break;
                }
              }
            }
            if (v34 - v31 < v33 - v31)
            {
              long long v35 = *(_OWORD *)a1;
              *(_OWORD *)v40 = *(_OWORD *)(a1 + 16);
              *(_OWORD *)&v40[16] = *(_OWORD *)(a1 + 32);
              long long v36 = *(_OWORD *)(a2 + 27);
              long long v37 = *(_OWORD *)(a2 + 16);
              *(_OWORD *)a1 = *(_OWORD *)a2;
              *(_OWORD *)(a1 + 16) = v37;
              *(_OWORD *)(a1 + 27) = v36;
              *(_OWORD *)a2 = v35;
              *(_OWORD *)(a2 + 16) = *(_OWORD *)v40;
              __n128 result = *(__n128 *)&v40[11];
              *(_OWORD *)(a2 + 27) = *(_OWORD *)&v40[11];
            }
          }
        }
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  result.n128_u64[0] = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsPresence>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsPresence>::_SampleRemainder*>(a1, a2, a3, a4, a6).n128_u64[0];
  uint64_t v13 = *(void *)(a5 + 24);
  uint64_t v14 = *(void *)(a4 + 24);
  if (v13 != v14)
  {
    long long v15 = *(char **)(*(void *)a6 + 232);
    long long v16 = *(char **)(*(void *)a6 + 240);
    long long v17 = v15;
    long long v18 = v15;
    if (v15 != v16)
    {
      do
      {
        if (*(void *)v18 == v13) {
          goto LABEL_6;
        }
        v18 += 8;
      }
      while (v18 != v16);
      long long v18 = *(char **)(*(void *)a6 + 240);
LABEL_6:
      while (*(void *)v17 != v14)
      {
        v17 += 8;
        if (v17 == v16)
        {
          long long v17 = *(char **)(*(void *)a6 + 240);
          break;
        }
      }
    }
    if (v18 - v15 < v17 - v15)
    {
      long long v19 = *(_OWORD *)a4;
      *(_OWORD *)v49 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)&v49[16] = *(_OWORD *)(a4 + 32);
      long long v20 = *(_OWORD *)(a5 + 27);
      long long v21 = *(_OWORD *)(a5 + 16);
      *(_OWORD *)a4 = *(_OWORD *)a5;
      *(_OWORD *)(a4 + 16) = v21;
      *(_OWORD *)(a4 + 27) = v20;
      *(_OWORD *)a5 = v19;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)v49;
      __n128 result = *(__n128 *)&v49[11];
      *(_OWORD *)(a5 + 27) = *(_OWORD *)&v49[11];
      uint64_t v22 = *(void *)(a4 + 24);
      uint64_t v23 = *(void *)(a3 + 24);
      if (v22 != v23)
      {
        v24 = *(char **)(*(void *)a6 + 232);
        v25 = *(char **)(*(void *)a6 + 240);
        long long v26 = v24;
        long long v27 = v24;
        if (v24 != v25)
        {
          do
          {
            if (*(void *)v27 == v22) {
              goto LABEL_15;
            }
            v27 += 8;
          }
          while (v27 != v25);
          long long v27 = *(char **)(*(void *)a6 + 240);
LABEL_15:
          while (*(void *)v26 != v23)
          {
            v26 += 8;
            if (v26 == v25)
            {
              long long v26 = *(char **)(*(void *)a6 + 240);
              break;
            }
          }
        }
        if (v27 - v24 < v26 - v24)
        {
          long long v28 = *(_OWORD *)a3;
          *(_OWORD *)v50 = *(_OWORD *)(a3 + 16);
          *(_OWORD *)&v50[16] = *(_OWORD *)(a3 + 32);
          long long v29 = *(_OWORD *)(a4 + 27);
          long long v30 = *(_OWORD *)(a4 + 16);
          *(_OWORD *)a3 = *(_OWORD *)a4;
          *(_OWORD *)(a3 + 16) = v30;
          *(_OWORD *)(a3 + 27) = v29;
          *(_OWORD *)a4 = v28;
          *(_OWORD *)(a4 + 16) = *(_OWORD *)v50;
          __n128 result = *(__n128 *)&v50[11];
          *(_OWORD *)(a4 + 27) = *(_OWORD *)&v50[11];
          uint64_t v31 = *(void *)(a3 + 24);
          uint64_t v32 = *(void *)(a2 + 24);
          if (v31 != v32)
          {
            v33 = *(char **)(*(void *)a6 + 232);
            long long v34 = *(char **)(*(void *)a6 + 240);
            long long v35 = v33;
            long long v36 = v33;
            if (v33 != v34)
            {
              do
              {
                if (*(void *)v36 == v31) {
                  goto LABEL_24;
                }
                v36 += 8;
              }
              while (v36 != v34);
              long long v36 = *(char **)(*(void *)a6 + 240);
LABEL_24:
              while (*(void *)v35 != v32)
              {
                v35 += 8;
                if (v35 == v34)
                {
                  long long v35 = *(char **)(*(void *)a6 + 240);
                  break;
                }
              }
            }
            if (v36 - v33 < v35 - v33)
            {
              long long v37 = *(_OWORD *)a2;
              *(_OWORD *)v51 = *(_OWORD *)(a2 + 16);
              *(_OWORD *)&v51[16] = *(_OWORD *)(a2 + 32);
              long long v38 = *(_OWORD *)(a3 + 27);
              long long v39 = *(_OWORD *)(a3 + 16);
              *(_OWORD *)a2 = *(_OWORD *)a3;
              *(_OWORD *)(a2 + 16) = v39;
              *(_OWORD *)(a2 + 27) = v38;
              *(_OWORD *)a3 = v37;
              *(_OWORD *)(a3 + 16) = *(_OWORD *)v51;
              __n128 result = *(__n128 *)&v51[11];
              *(_OWORD *)(a3 + 27) = *(_OWORD *)&v51[11];
              uint64_t v40 = *(void *)(a2 + 24);
              uint64_t v41 = *(void *)(a1 + 24);
              if (v40 != v41)
              {
                v42 = *(char **)(*(void *)a6 + 232);
                v43 = *(char **)(*(void *)a6 + 240);
                v44 = v42;
                v45 = v42;
                if (v42 != v43)
                {
                  do
                  {
                    if (*(void *)v45 == v40) {
                      goto LABEL_33;
                    }
                    v45 += 8;
                  }
                  while (v45 != v43);
                  v45 = *(char **)(*(void *)a6 + 240);
LABEL_33:
                  while (*(void *)v44 != v41)
                  {
                    v44 += 8;
                    if (v44 == v43)
                    {
                      v44 = *(char **)(*(void *)a6 + 240);
                      break;
                    }
                  }
                }
                if (v45 - v42 < v44 - v42)
                {
                  long long v46 = *(_OWORD *)a1;
                  *(_OWORD *)v52 = *(_OWORD *)(a1 + 16);
                  *(_OWORD *)&v52[16] = *(_OWORD *)(a1 + 32);
                  long long v47 = *(_OWORD *)(a2 + 27);
                  long long v48 = *(_OWORD *)(a2 + 16);
                  *(_OWORD *)a1 = *(_OWORD *)a2;
                  *(_OWORD *)(a1 + 16) = v48;
                  *(_OWORD *)(a1 + 27) = v47;
                  *(_OWORD *)a2 = v46;
                  *(_OWORD *)(a2 + 16) = *(_OWORD *)v52;
                  __n128 result = *(__n128 *)&v52[11];
                  *(_OWORD *)(a2 + 27) = *(_OWORD *)&v52[11];
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1}>,HDStatisticsPresence const& ()(HDStatisticsPresence const&)>::~__func()
{
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1}>,HDStatisticsPresence const& ()(HDStatisticsPresence const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F1726690;
  return result;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1}>,HDStatisticsPresence const& ()(HDStatisticsPresence const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1726690;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1}>,HDStatisticsPresence const& ()(HDStatisticsPresence const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1}>,HDStatisticsPresence const& ()(HDStatisticsPresence const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addStatisticsFromFinishedBucket<HDStatisticsPresence>(HKStatistics *,HDStatisticsBucket<HDStatisticsPresence> const&)::{lambda(HDStatisticsPresence const&)#1}>,HDStatisticsPresence const& ()(HDStatisticsPresence const&)>::target_type()
{
}

void *std::__function::__value_func<HDStatisticsPresence const& ()(HDStatisticsPresence const&)>::~__value_func[abi:ne180100](void *a1)
{
  v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_primitiveAddSample(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 528))
  {
    if ((a3 & 1) == 0)
    {
      objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a4, 3, @"Cannot configure statistics collection calculator engine with a sample if we cannot merge up to the sample's start date");
      return 0;
    }
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_configureForStartTime(a1);
  }
  double v8 = *(double *)(a2 + 8);
  if (v8 >= _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_earliestStartTimeWithoutInvalidation(a1))
  {
    if (*(void *)(a1 + 40) && a3) {
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_advanceToTime(a1, v8);
    }
    HDStatisticsCollectionEngine<HDStatisticsPresence>::addSample(a1 + 112, a2, a3);
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_notifyForCurrentBucket(a1);
    return 1;
  }
  else
  {
    uint64_t v9 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:", v8, *(double *)(a2 + 16));
    uint64_t v10 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v9, a4);
  }
  return v10;
}

void sub_1BD16F3D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_earliestStartTimeWithoutInvalidation(uint64_t a1)
{
  if (*(void *)(a1 + 40))
  {
    if (!*(unsigned char *)(a1 + 528))
    {
      double v1 = *(double *)(a1 + 176);
      double result = *(double *)(a1 + 120);
      if (v1 <= result)
      {
        double v1 = -1.79769313e308;
      }
      else if (*(unsigned char *)(a1 + 144))
      {
        double v1 = -1.79769313e308;
      }
      if (v1 >= result) {
        return v1;
      }
      return result;
    }
    return -1.79769313e308;
  }
  double result = *(double *)(a1 + 176);
  if (result <= *(double *)(a1 + 120)) {
    return -1.79769313e308;
  }
  if (*(unsigned char *)(a1 + 144)) {
    return -1.79769313e308;
  }
  return result;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_advanceToTime(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 128) <= a2)
  {
    uint64_t v4 = a1 + 112;
    uint64_t v5 = a1 + 120;
    do
    {
      uint64_t v6 = *(void *)(a1 + 496);
      uint64_t v7 = *(void *)(a1 + 504);
      if (v7 == v6)
      {
        uint64_t v22 = 0;
        long long v15 = *(void **)(a1 + 40);
        long long v16 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:a2];
        double v8 = [v15 dateIntervalContainingDate:v16 index:&v22];

        HDStatisticsBucket<HDStatisticsPresence>::_updateSourceOrder(v5);
        HDStatisticsBucket<HDStatisticsPresence>::_mergeThroughTime(v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_statisticsFromFinishedBucket(a1, v5);
        uint64_t v17 = v22;
        uint64_t v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v19 = v18;
        long long v20 = [v8 endDate];
        [v20 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsPresence>::resetToBucket(v4, v17, v19, v21);
      }
      else
      {
        double v8 = [*(id *)(a1 + 40) dateIntervalAtIndex:*(void *)(a1 + 112) + 1];
        HDStatisticsBucket<HDStatisticsPresence>::_updateSourceOrder(v5);
        HDStatisticsBucket<HDStatisticsPresence>::_mergeThroughTime(v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_statisticsFromFinishedBucket(a1, v5);
        uint64_t v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v12 = v11;
        uint64_t v13 = [v8 endDate];
        [v13 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsPresence>::advanceBucket(v4, v12, v14);
      }
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_didChangeBucket(a1, v9);
      if (v7 != v6) {
        _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_notifyForCurrentBucket(a1);
      }
    }
    while (*(double *)(a1 + 128) <= a2);
  }
}

void sub_1BD16F660(_Unwind_Exception *exception_object)
{
}

void HDStatisticsCollectionEngine<HDStatisticsPresence>::addSample(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = a1 + 8;
  double v6 = *(double *)a2;
  double v7 = *(double *)(a2 + 8);
  double v8 = *(double *)(a2 + 16);
  uint64_t v9 = *(uint64_t **)(a2 + 24);
  unsigned __int8 v10 = *(unsigned char *)(a2 + 32);
  char v11 = *(unsigned char *)(a2 + 33);
  double v12 = *(double *)(a1 + 8) - v7;
  int v13 = v10;
  unint64_t v14 = (unint64_t)v9;
  char v15 = v11;
  double v16 = v8;
  double v17 = v7;
  double v18 = *(double *)a2;
  if (v12 >= 0.01)
  {
    if (v8 - v7 - v12 >= 0.01)
    {
      int v13 = *(unsigned __int8 *)(a2 + 32);
      double v18 = v6 - v6 * (v12 / (v8 - v7));
      unint64_t v14 = *(void *)(a2 + 24);
      char v15 = *(unsigned char *)(a2 + 33);
      double v16 = *(double *)(a2 + 16);
      double v17 = *(double *)(a1 + 8);
    }
    else
    {
      int v13 = 0;
      unint64_t v14 = 0;
      char v15 = 0;
      double v16 = 0.0;
      double v17 = 0.0;
      double v18 = 0.0;
    }
  }
  double v19 = *(double *)(a1 + 16);
  double v20 = v19 - v17;
  double v21 = v16 - v17;
  double v22 = v16 - v17 - (v19 - v17);
  if (!*(_DWORD *)(a1 + 36))
  {
    if (v22 < 0.01) {
      goto LABEL_10;
    }
    if (v20 >= 0.01) {
      goto LABEL_24;
    }
LABEL_22:
    int v23 = v13;
    unint64_t v31 = v14;
    double v25 = v16;
    double v19 = v17;
    double v24 = v18;
    if (!v23) {
      return;
    }
    goto LABEL_60;
  }
  if (v20 < 0.01) {
    goto LABEL_22;
  }
  if (v22 >= 0.01)
  {
LABEL_24:
    double v25 = v16;
    unint64_t v69 = v14;
    double v24 = v18 - v18 * (v20 / v21);
    int v23 = v13;
    char v70 = v15;
    double v16 = *(double *)(a1 + 16);
    double v18 = v18 * (v20 / v21);
    if (!v13)
    {
LABEL_25:
      char v15 = v70;
      unint64_t v31 = v69;
      if (!v23) {
        return;
      }
      goto LABEL_60;
    }
    goto LABEL_11;
  }
LABEL_10:
  unint64_t v69 = 0;
  int v23 = 0;
  char v70 = 0;
  double v24 = 0.0;
  double v19 = 0.0;
  double v25 = 0.0;
  if (!v13) {
    goto LABEL_25;
  }
LABEL_11:
  double v67 = v17;
  double v68 = v16;
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>(a1 + 200, v14, v14);
  unint64_t v26 = *(void *)(a1 + 112);
  if (v26 == *(void *)(a1 + 104) && *(uint64_t *)(a1 + 128) <= 0)
  {
    v32.f64[1] = *(float64_t *)(a1 + 16);
    double v28 = v67;
    double v27 = v68;
    v32.f64[0] = v67;
    v33.f64[0] = *(float64_t *)(a1 + 8);
    v33.f64[1] = v68;
    int8x16_t v34 = (int8x16_t)vcgtq_f64(v33, v32);
    v33.f64[0] = v67;
    *(int8x16_t *)(a1 + 48) = vbslq_s8(v34, *(int8x16_t *)(a1 + 8), (int8x16_t)v33);
  }
  else
  {
    double v28 = v67;
    double v27 = v68;
    if (v67 < *(double *)(a1 + 48))
    {
      double v29 = *(double *)(a1 + 8);
      if (v67 >= v29) {
        double v29 = v67;
      }
      *(double *)(a1 + 48) = v29;
    }
    if (v68 > *(double *)(a1 + 56))
    {
      double v30 = *(double *)(a1 + 16);
      if (v30 >= v68) {
        double v30 = v68;
      }
      *(double *)(a1 + 56) = v30;
    }
  }
  if (*(unsigned char *)(a1 + 32))
  {
    double v35 = *(double *)(a1 + 64);
    if (v28 < v35) {
      double v35 = v28;
    }
    *(double *)(a1 + 64) = v35;
  }
  if (a3 && v28 < *(double *)(a1 + 16))
  {
    HDStatisticsBucket<HDStatisticsPresence>::_mergeThroughTime(v5, v28);
    double v28 = v67;
    double v27 = v68;
    unint64_t v26 = *(void *)(a1 + 112);
  }
  unint64_t v36 = *(void *)(a1 + 120);
  if (v26 >= v36)
  {
    uint64_t v38 = *(void *)(a1 + 104);
    unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v26 - v38) >> 4);
    unint64_t v40 = v39 + 1;
    if (v39 + 1 > 0x555555555555555) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v41 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v36 - v38) >> 4);
    if (2 * v41 > v40) {
      unint64_t v40 = 2 * v41;
    }
    if (v41 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v42 = 0x555555555555555;
    }
    else {
      unint64_t v42 = v40;
    }
    if (v42)
    {
      unint64_t v42 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v42);
      double v28 = v67;
      double v27 = v68;
    }
    else
    {
      uint64_t v43 = 0;
    }
    unint64_t v44 = v42 + 48 * v39;
    unint64_t v45 = v42 + 48 * v43;
    *(double *)unint64_t v44 = v18;
    *(double *)(v44 + 8) = v28;
    *(double *)(v44 + 16) = v27;
    *(void *)(v44 + 24) = v14;
    *(unsigned char *)(v44 + 32) = v13;
    *(unsigned char *)(v44 + 33) = v15;
    *(_WORD *)(v44 + 40) = 0;
    *(unsigned char *)(v44 + 42) = 0;
    unint64_t v37 = v44 + 48;
    long long v47 = *(char **)(a1 + 104);
    long long v46 = *(char **)(a1 + 112);
    if (v46 == v47)
    {
      char v15 = v70;
      unint64_t v31 = v69;
    }
    else
    {
      char v15 = v70;
      unint64_t v31 = v69;
      do
      {
        long long v48 = *((_OWORD *)v46 - 3);
        long long v49 = *((_OWORD *)v46 - 2);
        *(_OWORD *)(v44 - 21) = *(_OWORD *)(v46 - 21);
        *(_OWORD *)(v44 - 48) = v48;
        *(_OWORD *)(v44 - 32) = v49;
        v44 -= 48;
        v46 -= 48;
      }
      while (v46 != v47);
      long long v46 = *(char **)(a1 + 104);
    }
    *(void *)(a1 + 104) = v44;
    *(void *)(a1 + 112) = v37;
    *(void *)(a1 + 120) = v45;
    if (v46) {
      operator delete(v46);
    }
  }
  else
  {
    *(double *)unint64_t v26 = v18;
    *(double *)(v26 + 8) = v28;
    *(double *)(v26 + 16) = v27;
    *(void *)(v26 + 24) = v14;
    *(unsigned char *)(v26 + 32) = v13;
    *(unsigned char *)(v26 + 33) = v15;
    *(_WORD *)(v26 + 40) = 0;
    unint64_t v37 = v26 + 48;
    *(unsigned char *)(v26 + 42) = 0;
    char v15 = v70;
    unint64_t v31 = v69;
  }
  *(void *)(a1 + 112) = v37;
  if (!*(unsigned char *)(a1 + 168) || *(double *)(a1 + 144) <= v7)
  {
    *(double *)(a1 + 136) = v6;
    *(double *)(a1 + 144) = v7;
    *(double *)(a1 + 152) = v8;
    *(void *)(a1 + 160) = v9;
    *(unsigned char *)(a1 + 168) = v10;
    *(unsigned char *)(a1 + 169) = v11;
  }
  if (*(unsigned char *)(a1 + 33)
    && ((unint64_t v50 = HDStatisticsBucket<HDStatisticsPresence>::_canonicalSourceIDForSourceID(v5, v14),
         v51 = HDStatisticsBucket<HDStatisticsPresence>::_statisticsForSource(v5, v50),
         !*((unsigned char *)v51 + 40))
     || *((double *)v51 + 2) <= v7))
  {
    *((double *)v51 + 1) = v6;
    *((double *)v51 + 2) = v7;
    *((double *)v51 + 3) = v8;
    v51[4] = v9;
    *((unsigned char *)v51 + 40) = v10;
    *((unsigned char *)v51 + 41) = v11;
    if (!v23) {
      return;
    }
  }
  else if (!v23)
  {
    return;
  }
LABEL_60:
  unint64_t v52 = *(void *)(a1 + 392);
  unint64_t v53 = *(void *)(a1 + 400);
  if (v52 >= v53)
  {
    uint64_t v55 = *(void *)(a1 + 384);
    unint64_t v56 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v52 - v55) >> 3);
    unint64_t v57 = v56 + 1;
    if (v56 + 1 > 0x666666666666666) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v58 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v53 - v55) >> 3);
    if (2 * v58 > v57) {
      unint64_t v57 = 2 * v58;
    }
    if (v58 >= 0x333333333333333) {
      unint64_t v59 = 0x666666666666666;
    }
    else {
      unint64_t v59 = v57;
    }
    if (v59) {
      unint64_t v59 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v59);
    }
    else {
      uint64_t v60 = 0;
    }
    unint64_t v61 = v59 + 40 * v56;
    unint64_t v62 = v59 + 40 * v60;
    *(double *)unint64_t v61 = v24;
    *(double *)(v61 + 8) = v19;
    *(double *)(v61 + 16) = v25;
    *(void *)(v61 + 24) = v31;
    *(unsigned char *)(v61 + 32) = v23;
    *(unsigned char *)(v61 + 33) = v15;
    unint64_t v54 = v61 + 40;
    v64 = *(char **)(a1 + 384);
    v63 = *(char **)(a1 + 392);
    if (v63 != v64)
    {
      do
      {
        long long v65 = *(_OWORD *)(v63 - 40);
        long long v66 = *(_OWORD *)(v63 - 24);
        *(_WORD *)(v61 - 8) = *((_WORD *)v63 - 4);
        *(_OWORD *)(v61 - 24) = v66;
        *(_OWORD *)(v61 - 40) = v65;
        v61 -= 40;
        v63 -= 40;
      }
      while (v63 != v64);
      v63 = *(char **)(a1 + 384);
    }
    *(void *)(a1 + 384) = v61;
    *(void *)(a1 + 392) = v54;
    *(void *)(a1 + 400) = v62;
    if (v63) {
      operator delete(v63);
    }
  }
  else
  {
    *(double *)unint64_t v52 = v24;
    *(double *)(v52 + 8) = v19;
    *(double *)(v52 + 16) = v25;
    *(void *)(v52 + 24) = v31;
    *(unsigned char *)(v52 + 32) = v23;
    unint64_t v54 = v52 + 40;
    *(unsigned char *)(v52 + 33) = v15;
  }
  *(void *)(a1 + 392) = v54;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_notifyForCurrentBucket(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 530))
  {
    *(unsigned char *)(a1 + 532) = 1;
  }
  else
  {
    *(unsigned char *)(a1 + 532) = 0;
    v2 = (void (**)(id, void *))_Block_copy(*(const void **)(a1 + 96));
    if (v2)
    {
      uint64_t v4 = v2;
      v3 = (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
      if (v3) {
        v4[2](v4, v3);
      }

      v2 = v4;
    }
  }
}

void sub_1BD16FCA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsCollectionEngine<HDStatisticsPresence>::advanceBucket(uint64_t a1, double a2, double a3)
{
  uint64_t v9 = 0;
  unsigned __int8 v10 = 0;
  uint64_t v11 = 0;
  std::vector<HDRawQuantitySample>::__init_with_size[abi:ne180100]<HDRawQuantitySample*,HDRawQuantitySample*>(&v9, *(const void **)(a1 + 384), *(void *)(a1 + 392), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 392) - *(void *)(a1 + 384)) >> 3));
  HDStatisticsCollectionEngine<HDStatisticsPresence>::resetToBucket(a1, *(void *)a1 + 1, a2, a3);
  double v6 = v9;
  double v7 = v10;
  if (v9 != v10)
  {
    uint64_t v8 = (uint64_t)v9;
    do
    {
      HDStatisticsCollectionEngine<HDStatisticsPresence>::addSample(a1, v8, 1);
      v8 += 40;
    }
    while ((void *)v8 != v7);
  }
  if (v6)
  {
    operator delete(v6);
  }
}

void sub_1BD16FD9C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void HDStatisticsCollectionEngine<HDStatisticsPresence>::resetToBucket(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v8 = a1 + 40;
  objc_storeStrong((id *)(a1 + 408), *(id *)(a1 + 40));
  *(double *)(v8 - 32) = a3;
  *(double *)(v8 - 24) = a4;
  *(double *)(v8 + 24) = a3;
  *(void *)(v8 + 72) = *(void *)(v8 + 64);
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 120) = 0u;
  if (*(void *)(v8 + 152))
  {
    uint64_t v9 = *(void *)(a1 + 184);
    unsigned __int8 v10 = *(void **)(a1 + 176);
    *(void *)(a1 + 176) = a1 + 184;
    *(void *)(v9 + 16) = 0;
    *(void *)(a1 + 184) = 0;
    *(void *)(a1 + 192) = 0;
    if (v10[1]) {
      uint64_t v11 = (void *)v10[1];
    }
    else {
      uint64_t v11 = v10;
    }
    if (v11)
    {
      double v12 = (void *)v11[2];
      if (v12)
      {
        int v13 = (void *)*v12;
        if ((void *)*v12 == v11)
        {
          void *v12 = 0;
          while (1)
          {
            char v15 = (void *)v12[1];
            if (!v15) {
              break;
            }
            do
            {
              double v12 = v15;
              char v15 = (void *)*v15;
            }
            while (v15);
          }
        }
        else
        {
          for (v12[1] = 0; v13; int v13 = (void *)v12[1])
          {
            do
            {
              double v12 = v13;
              int v13 = (void *)*v13;
            }
            while (v13);
          }
        }
        std::__tree<long>::destroy(v11);
        for (i = (void *)v12[2]; i; i = (void *)i[2])
          double v12 = i;
        uint64_t v11 = v12;
      }
    }
    std::__tree<long>::destroy(v11);
  }
  objc_storeStrong((id *)v8, *(id *)(a1 + 408));
  *(void *)(a1 + 392) = *(void *)(a1 + 384);
  *(void *)a1 = a2;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_didChangeBucket(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 532))
  {
    if (v3)
    {
      id v6 = v3;
      uint64_t v4 = _Block_copy(*(const void **)(a1 + 96));
      uint64_t v5 = v4;
      if (v4) {
        (*((void (**)(void *, id))v4 + 2))(v4, v6);
      }

      id v3 = v6;
    }
    *(unsigned char *)(a1 + 532) = 0;
  }
}

void sub_1BD16FF50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_currentBucketInterval(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 528))
  {
    double v1 = 0;
  }
  else
  {
    double v1 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:", *(double *)(a1 + 120), *(double *)(a1 + 128));
  }

  return v1;
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE38_collapsedPendingInvalidationIntervalsERb_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = [a2 startDate];
  id v6 = [v4 startDate];
  uint64_t v7 = [v5 compare:v6];

  return v7;
}

void sub_1BD170024(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_primitiveInvalidateInterval(id *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 13);
  if (WeakRetained)
  {
    if (v5
      && (_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_currentBucketInterval((uint64_t)a1),
          (uint64_t v7 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      uint64_t v8 = [v5 endDate];
      uint64_t v9 = [v7 startDate];
      if (objc_msgSend(v8, "hk_isAfterDate:", v9))
      {
        unsigned __int8 v10 = [v5 startDate];
        uint64_t v11 = [v7 endDate];
        char v12 = objc_msgSend(v10, "hk_isBeforeOrEqualToDate:", v11);
      }
      else
      {
        char v12 = 0;
      }

      int v13 = _Block_copy(a1[12]);
      if ((v12 & 1) == 0) {
        operator new();
      }
    }
    else
    {
      int v13 = _Block_copy(a1[12]);
    }
    *((unsigned char *)a1 + 528) = 1;
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 3221225472;
    v27[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke;
    v27[3] = &unk_1E6308FF8;
    id v15 = v5;
    id v28 = v15;
    id v16 = v13;
    id v29 = v16;
    (*((void (**)(id *, void *))*a1 + 9))(a1, v27);
    if (v5)
    {
      double v17 = [v15 startDate];
      [v17 timeIntervalSinceReferenceDate];
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_configureForStartTime((uint64_t)a1);
    }
    else
    {
      (*((void (**)(id *))*a1 + 4))(a1);
      id v15 = (id)objc_claimAutoreleasedReturnValue();
    }
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2;
    v21[3] = &unk_1E6309060;
    double v24 = a1;
    id v5 = v15;
    char v26 = 1;
    id v22 = v5;
    double v25 = a1;
    id v23 = WeakRetained;
    uint64_t v14 = (*((uint64_t (**)(id *, void *, uint64_t))*a1 + 14))(a1, v21, a3);
    double v18 = _Block_copy(v16);
    id v19 = a1[12];
    a1[12] = v18;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a3, 3, @"Unable to invalidate interval: no data source available.");
    uint64_t v14 = 0;
  }

  return v14;
}

void sub_1BD170474(_Unwind_Exception *a1)
{
  MEMORY[0x1C187B8A0](v4, 0x10F1C405E2A77A1);
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke(uint64_t a1, void *a2)
{
  id v10 = a2;
  if (!*(void *)(a1 + 32)) {
    goto LABEL_11;
  }
  id v3 = [v10 endDate];
  uint64_t v4 = [*(id *)(a1 + 32) startDate];
  char v5 = objc_msgSend(v3, "hk_isBeforeOrEqualToDate:", v4);

  if ((v5 & 1) == 0)
  {
    id v6 = [v10 startDate];
    uint64_t v7 = [*(id *)(a1 + 32) endDate];
    char v8 = objc_msgSend(v6, "hk_isAfterOrEqualToDate:", v7);

    if ((v8 & 1) == 0)
    {
LABEL_11:
      uint64_t v9 = *(void *)(a1 + 40);
      if (v9) {
        (*(void (**)(uint64_t, id))(v9 + 16))(v9, v10);
      }
    }
  }
}

void sub_1BD170658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  char v5 = [*(id *)(a1 + 32) startDate];
  [v5 timeIntervalSinceReferenceDate];
  uint64_t v7 = v6;

  char v8 = [*(id *)(a1 + 32) endDate];
  [v8 timeIntervalSinceReferenceDate];
  uint64_t v10 = v9;

  uint64_t v11 = *(void **)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(v4 + 8));
  uint64_t v13 = *(void *)(a1 + 32);
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3;
  v30[3] = &__block_descriptor_57_e24_B52__0d8d16d24q32B40__44l;
  char v32 = *(unsigned char *)(a1 + 64);
  v30[4] = v7;
  v30[5] = v10;
  uint64_t v31 = *(void *)(a1 + 56);
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4;
  v29[3] = &__block_descriptor_40_e8_v16__0d8l;
  v29[4] = v31;
  uint64_t v14 = [v11 collectionCalculator:WeakRetained queryForInterval:v13 error:a2 sampleHandler:v30 mergeHandler:v29];

  if (v14)
  {
    uint64_t v15 = *(void *)(a1 + 56);
    if (v15 != v4)
    {
      id v16 = [*(id *)(a1 + 32) endDate];
      [v16 timeIntervalSinceReferenceDate];
      if (*(void *)(v15 + 40))
      {
        double v18 = v17;
        while (*(double *)(v15 + 120) < v18)
        {
          id v19 = [*(id *)(v15 + 40) dateIntervalAtIndex:*(void *)(v15 + 112) + 1];
          HDStatisticsBucket<HDStatisticsPresence>::_updateSourceOrder(v15 + 120);
          HDStatisticsBucket<HDStatisticsPresence>::_mergeThroughTime(v15 + 120, *(double *)(v15 + 128));
          double v20 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_statisticsFromFinishedBucket(v15, v15 + 120);
          double v21 = [v19 startDate];
          [v21 timeIntervalSinceReferenceDate];
          double v23 = v22;
          double v24 = [v19 endDate];
          [v24 timeIntervalSinceReferenceDate];
          HDStatisticsCollectionEngine<HDStatisticsPresence>::advanceBucket(v15 + 112, v23, v25);

          if (v20)
          {
            char v26 = _Block_copy(*(const void **)(v15 + 96));
            double v27 = v26;
            if (v26) {
              (*((void (**)(void *, void *))v26 + 2))(v26, v20);
            }
          }
          _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_didChangeBucket(v15, 0);
        }
      }
    }
  }
  return v14;
}

void sub_1BD170904(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  double v7 = *(double *)(a1 + 32) - a6;
  if (v7 >= 0.01)
  {
    double v9 = a7 - a6;
    if (v9 - v7 >= 0.01)
    {
      a5 = a5 - v7 / v9 * a5;
      int v8 = 1;
      a6 = *(double *)(a1 + 32);
    }
    else
    {
      a2 = 0;
      int v8 = 0;
      a5 = 0.0;
      a6 = 0.0;
      a7 = 0.0;
    }
  }
  else
  {
    int v8 = 1;
  }
  *(double *)uint64_t v13 = a5;
  *(double *)&v13[1] = a6;
  double v14 = a7;
  uint64_t v15 = a2;
  char v16 = v8;
  char v17 = 0;
  if (*(unsigned char *)(a1 + 56))
  {
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_primitiveAddSample(*(void *)(a1 + 48), (uint64_t)v13, a3, a4);
    }
  }
  else
  {
    double v11 = *(double *)(a1 + 40) - a6;
    if (v11 >= 0.01)
    {
      double v12 = a7 - a6;
      if (v12 - v11 >= 0.01)
      {
        a5 = a5 * (v11 / v12);
        a7 = *(double *)(a1 + 40);
      }
    }
    else
    {
      int v8 = 0;
    }
    *(double *)uint64_t v13 = a5;
    double v14 = a7;
    char v16 = v8;
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_primitiveAddSample(*(void *)(a1 + 48), (uint64_t)v13, a3, a4);
    }
  }
  return 1;
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4(uint64_t a1, double a2)
{
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_mergeToTime(uint64_t a1, double a2)
{
  if (*(unsigned char *)(a1 + 528)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_configureForStartTime(a1);
  }
  if (*(void *)(a1 + 40)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_advanceToTime(a1, a2);
  }
  if (*(double *)(a1 + 128) > a2)
  {
    HDStatisticsBucket<HDStatisticsPresence>::_mergeThroughTime(a1 + 120, a2);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(double *)(a2 - 32) < *(double *)(v10 + 8))
                {
                  uint64_t v129 = *(void *)(v10 + 32);
                  long long v113 = *(_OWORD *)v10;
                  long long v121 = *(_OWORD *)(v10 + 16);
                  long long v52 = *(_OWORD *)(a2 - 40);
                  long long v53 = *(_OWORD *)(a2 - 24);
                  *(_WORD *)(v10 + 32) = *(_WORD *)(a2 - 8);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 16) = v53;
                  *(_WORD *)(a2 - 8) = v129;
                  *(_OWORD *)(a2 - 24) = v121;
                  *(_OWORD *)(a2 - 40) = v113;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v10, (double *)(v10 + 40), (double *)(a2 - 40));
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, a2 - 40);
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, v10 + 120, a2 - 40);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 959)
          {
            unint64_t v54 = (void *)(v10 + 40);
            BOOL v56 = v10 == a2 || v54 == (void *)a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  unint64_t v59 = v54;
                  double v60 = *(double *)(v58 + 48);
                  if (v60 < *(double *)(v58 + 8))
                  {
                    uint64_t v61 = *v54;
                    long long v114 = *(_OWORD *)(v58 + 56);
                    uint64_t v122 = *(void *)(v58 + 72);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      uint64_t v63 = v10 + v62;
                      long long v64 = *(_OWORD *)(v10 + v62 + 16);
                      *(_OWORD *)(v63 + 40) = *(_OWORD *)(v10 + v62);
                      *(_OWORD *)(v63 + 56) = v64;
                      *(_WORD *)(v63 + 72) = *(_WORD *)(v10 + v62 + 32);
                      if (!v62) {
                        break;
                      }
                      v62 -= 40;
                      if (v60 >= *(double *)(v63 - 32))
                      {
                        uint64_t v65 = v10 + v62 + 40;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_81:
                    *(void *)uint64_t v65 = v61;
                    *(double *)(v65 + 8) = v60;
                    *(_OWORD *)(v65 + 16) = v114;
                    *(_WORD *)(v65 + 32) = v122;
                  }
                  unint64_t v54 = v59 + 5;
                  v57 += 40;
                  unint64_t v58 = (unint64_t)v59;
                }
                while (v59 + 5 != (void *)a2);
              }
            }
            else if (!v56)
            {
              do
              {
                v98 = v54;
                double v99 = *(double *)(a1 + 48);
                if (v99 < *(double *)(a1 + 8))
                {
                  uint64_t v100 = *v54;
                  long long v117 = *(_OWORD *)(a1 + 56);
                  uint64_t v125 = *(void *)(a1 + 72);
                  v101 = v54;
                  do
                  {
                    long long v102 = *(_OWORD *)(v101 - 3);
                    *(_OWORD *)v101 = *(_OWORD *)(v101 - 5);
                    *((_OWORD *)v101 + 1) = v102;
                    *((_WORD *)v101 + 16) = *((_WORD *)v101 - 4);
                    double v103 = *((double *)v101 - 9);
                    v101 -= 5;
                  }
                  while (v99 < v103);
                  void *v101 = v100;
                  *((double *)v101 + 1) = v99;
                  *((_WORD *)v101 + 16) = v125;
                  *((_OWORD *)v101 + 1) = v117;
                }
                v54 += 5;
                a1 = (unint64_t)v98;
              }
              while (v98 + 5 != (void *)a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 40 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)(v10 + 40 * v69 + 8) < *(double *)(v70 + 48))
                  {
                    v70 += 40;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  double v71 = *(double *)(v10 + 40 * v68 + 8);
                  if (*(double *)(v70 + 8) >= v71)
                  {
                    unint64_t v72 = v10 + 40 * v68;
                    uint64_t v73 = *(void *)v72;
                    uint64_t v123 = *(void *)(v72 + 32);
                    long long v115 = *(_OWORD *)(v72 + 16);
                    do
                    {
                      unint64_t v74 = v72;
                      unint64_t v72 = v70;
                      long long v75 = *(_OWORD *)v70;
                      long long v76 = *(_OWORD *)(v70 + 16);
                      *(_WORD *)(v74 + 32) = *(_WORD *)(v70 + 32);
                      *(_OWORD *)unint64_t v74 = v75;
                      *(_OWORD *)(v74 + 16) = v76;
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v77 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 40 * v77;
                      uint64_t v78 = 2 * v69 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v10 + 40 * v77 + 8) < *(double *)(v70 + 48))
                      {
                        v70 += 40;
                        uint64_t v77 = v78;
                      }
                      uint64_t v69 = v77;
                    }
                    while (*(double *)(v70 + 8) >= v71);
                    *(void *)unint64_t v72 = v73;
                    *(double *)(v72 + 8) = v71;
                    *(_OWORD *)(v72 + 16) = v115;
                    *(_WORD *)(v72 + 32) = v123;
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              int64_t v79 = v11 / 0x28uLL;
              do
              {
                uint64_t v80 = 0;
                uint64_t v130 = *(void *)(v10 + 32);
                long long v116 = *(_OWORD *)v10;
                long long v124 = *(_OWORD *)(v10 + 16);
                unint64_t v81 = v10;
                do
                {
                  unint64_t v82 = v81;
                  uint64_t v83 = v80 + 1;
                  v81 += 40 * (v80 + 1);
                  uint64_t v84 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  int64_t v85 = v84 + 2;
                  if (v85 < v79 && *(double *)(v82 + 40 * v83 + 8) < *(double *)(v81 + 48))
                  {
                    v81 += 40;
                    uint64_t v80 = v85;
                  }
                  long long v86 = *(_OWORD *)v81;
                  long long v87 = *(_OWORD *)(v81 + 16);
                  *(_WORD *)(v82 + 32) = *(_WORD *)(v81 + 32);
                  *(_OWORD *)unint64_t v82 = v86;
                  *(_OWORD *)(v82 + 16) = v87;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 40;
                if (v81 == a2)
                {
                  *(_WORD *)(v81 + 32) = v130;
                  *(_OWORD *)unint64_t v81 = v116;
                  *(_OWORD *)(v81 + 16) = v124;
                }
                else
                {
                  long long v88 = *(_OWORD *)a2;
                  long long v89 = *(_OWORD *)(a2 + 16);
                  *(_WORD *)(v81 + 32) = *(_WORD *)(a2 + 32);
                  *(_OWORD *)unint64_t v81 = v88;
                  *(_OWORD *)(v81 + 16) = v89;
                  *(_WORD *)(a2 + 32) = v130;
                  *(_OWORD *)a2 = v116;
                  *(_OWORD *)(a2 + 16) = v124;
                  uint64_t v90 = v81 - v10 + 40;
                  if (v90 >= 41)
                  {
                    unint64_t v91 = (v90 / 0x28uLL - 2) >> 1;
                    double v92 = *(double *)(v81 + 8);
                    if (*(double *)(v10 + 40 * v91 + 8) < v92)
                    {
                      uint64_t v93 = *(void *)v81;
                      uint64_t v109 = *(void *)(v81 + 32);
                      long long v106 = *(_OWORD *)(v81 + 16);
                      do
                      {
                        unint64_t v94 = v81;
                        unint64_t v81 = v10 + 40 * v91;
                        long long v95 = *(_OWORD *)v81;
                        long long v96 = *(_OWORD *)(v81 + 16);
                        *(_WORD *)(v94 + 32) = *(_WORD *)(v81 + 32);
                        *(_OWORD *)unint64_t v94 = v95;
                        *(_OWORD *)(v94 + 16) = v96;
                        if (!v91) {
                          break;
                        }
                        unint64_t v91 = (v91 - 1) >> 1;
                      }
                      while (*(double *)(v10 + 40 * v91 + 8) < v92);
                      *(void *)unint64_t v81 = v93;
                      *(double *)(v81 + 8) = v92;
                      *(_WORD *)(v81 + 32) = v109;
                      *(_OWORD *)(v81 + 16) = v106;
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 40 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x1401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40 * (v12 >> 1)), (double *)(a2 - 40));
            uint64_t v15 = 5 * v13;
            char v16 = (double *)(a1 + 40 * v13 - 40);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40), v16, (double *)(a2 - 80));
            char v17 = (double *)(a1 + 40 + 8 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 80), v17, (double *)(a2 - 120));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v16, (double *)v14, v17);
            uint64_t v126 = *(void *)(a1 + 32);
            long long v110 = *(_OWORD *)a1;
            long long v118 = *(_OWORD *)(a1 + 16);
            long long v18 = *(_OWORD *)v14;
            long long v19 = *(_OWORD *)(v14 + 16);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v14 + 32);
            *(_OWORD *)a1 = v18;
            *(_OWORD *)(a1 + 16) = v19;
            *(_WORD *)(v14 + 32) = v126;
            *(_OWORD *)unint64_t v14 = v110;
            *(_OWORD *)(v14 + 16) = v118;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40 * (v12 >> 1)), (double *)a1, (double *)(a2 - 40));
          }
          --a3;
          if (a4) {
            break;
          }
          double v20 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 32) < v20) {
            goto LABEL_12;
          }
          uint64_t v38 = *(void *)a1;
          long long v105 = *(_OWORD *)(a1 + 16);
          uint64_t v108 = *(void *)(a1 + 32);
          if (v20 >= *(double *)(a2 - 32))
          {
            unint64_t v41 = a1 + 40;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= a2) {
                break;
              }
              double v42 = *(double *)(v41 + 8);
              v41 += 40;
            }
            while (v20 >= v42);
          }
          else
          {
            unint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 40;
              double v40 = *(double *)(v39 + 48);
              v39 += 40;
            }
            while (v20 >= v40);
          }
          unint64_t v43 = a2;
          if (v10 < a2)
          {
            unint64_t v44 = a2;
            do
            {
              unint64_t v43 = v44 - 40;
              double v45 = *(double *)(v44 - 32);
              v44 -= 40;
            }
            while (v20 < v45);
          }
          while (v10 < v43)
          {
            uint64_t v128 = *(void *)(v10 + 32);
            long long v112 = *(_OWORD *)v10;
            long long v120 = *(_OWORD *)(v10 + 16);
            long long v46 = *(_OWORD *)v43;
            long long v47 = *(_OWORD *)(v43 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v43 + 32);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(_WORD *)(v43 + 32) = v128;
            *(_OWORD *)unint64_t v43 = v112;
            *(_OWORD *)(v43 + 16) = v120;
            do
            {
              double v48 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v20 >= v48);
            do
            {
              double v49 = *(double *)(v43 - 32);
              v43 -= 40;
            }
            while (v20 < v49);
          }
          BOOL v4 = v10 - 40 >= a1;
          BOOL v5 = v10 - 40 == a1;
          if (v10 - 40 != a1)
          {
            long long v50 = *(_OWORD *)(v10 - 40);
            long long v51 = *(_OWORD *)(v10 - 24);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 16) = v51;
          }
          a4 = 0;
          *(void *)(v10 - 40) = v38;
          *(double *)(v10 - 32) = v20;
          *(_WORD *)(v10 - 8) = v108;
          *(_OWORD *)(v10 - 24) = v105;
        }
        double v20 = *(double *)(a1 + 8);
LABEL_12:
        uint64_t v21 = 0;
        uint64_t v22 = *(void *)a1;
        long long v104 = *(_OWORD *)(a1 + 16);
        uint64_t v107 = *(void *)(a1 + 32);
        do
        {
          double v23 = *(double *)(a1 + v21 + 48);
          v21 += 40;
        }
        while (v23 < v20);
        unint64_t v24 = a1 + v21;
        unint64_t v25 = a2;
        if (v21 == 40)
        {
          unint64_t v28 = a2;
          while (v24 < v28)
          {
            unint64_t v26 = v28 - 40;
            double v29 = *(double *)(v28 - 32);
            v28 -= 40;
            if (v29 < v20) {
              goto LABEL_22;
            }
          }
          unint64_t v26 = v28;
        }
        else
        {
          do
          {
            unint64_t v26 = v25 - 40;
            double v27 = *(double *)(v25 - 32);
            v25 -= 40;
          }
          while (v27 >= v20);
        }
LABEL_22:
        unint64_t v10 = v24;
        if (v24 < v26)
        {
          unint64_t v30 = v26;
          do
          {
            uint64_t v127 = *(void *)(v10 + 32);
            long long v111 = *(_OWORD *)v10;
            long long v119 = *(_OWORD *)(v10 + 16);
            long long v31 = *(_OWORD *)v30;
            long long v32 = *(_OWORD *)(v30 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v30 + 32);
            *(_OWORD *)unint64_t v10 = v31;
            *(_OWORD *)(v10 + 16) = v32;
            *(_WORD *)(v30 + 32) = v127;
            *(_OWORD *)unint64_t v30 = v111;
            *(_OWORD *)(v30 + 16) = v119;
            do
            {
              double v33 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v33 < v20);
            do
            {
              double v34 = *(double *)(v30 - 32);
              v30 -= 40;
            }
            while (v34 >= v20);
          }
          while (v10 < v30);
        }
        if (v10 - 40 != a1)
        {
          long long v35 = *(_OWORD *)(v10 - 40);
          long long v36 = *(_OWORD *)(v10 - 24);
          *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
        }
        *(void *)(v10 - 40) = v22;
        *(double *)(v10 - 32) = v20;
        *(_WORD *)(v10 - 8) = v107;
        *(_OWORD *)(v10 - 24) = v104;
        if (v24 >= v26) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(a1, v10 - 40, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, v10 - 40);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 40;
    if (!v37) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 32) < *(double *)(a1 + 8))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        long long v7 = *(_OWORD *)a1;
        long long v8 = *(_OWORD *)(a1 + 16);
        __int16 v9 = *(_WORD *)(a2 - 8);
        long long v10 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
        *(_OWORD *)(a1 + 16) = v10;
        *(_WORD *)(a1 + 32) = v9;
        *(_OWORD *)(a2 - 24) = v8;
        *(_OWORD *)(a2 - 40) = v7;
        *(_WORD *)(a2 - 8) = v6;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a2 - 40));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a1 + 120, a2 - 40);
      return 1;
    default:
      uint64_t v11 = a1 + 80;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a1 + 80));
      uint64_t v12 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (1)
  {
    double v15 = *(double *)(v12 + 8);
    if (v15 < *(double *)(v11 + 8))
    {
      uint64_t v16 = *(void *)v12;
      long long v21 = *(_OWORD *)(v12 + 16);
      uint64_t v22 = *(void *)(v12 + 32);
      uint64_t v17 = v13;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        long long v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(_WORD *)(v18 + 152) = *(_WORD *)(a1 + v17 + 112);
        if (v17 == -80) {
          break;
        }
        v17 -= 40;
        if (v15 >= *(double *)(v18 + 48))
        {
          uint64_t v20 = a1 + v17 + 120;
          goto LABEL_12;
        }
      }
      uint64_t v20 = a1;
LABEL_12:
      *(void *)uint64_t v20 = v16;
      *(double *)(v20 + 8) = v15;
      *(_OWORD *)(v20 + 16) = v21;
      *(_WORD *)(v20 + 32) = v22;
      if (++v14 == 8) {
        return v12 + 40 == a2;
      }
    }
    uint64_t v11 = v12;
    v13 += 40;
    v12 += 40;
    if (v12 == a2) {
      return 1;
    }
  }
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke(void *a1, uint64_t a2)
{
  id v3 = (void *)a1[5];
  uint64_t v4 = a1[6];
  BOOL v5 = (void *)a1[4];
  uint64_t v6 = [v5 dateInterval];
  v9[4] = v4;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2;
  v10[3] = &__block_descriptor_40_e24_B52__0d8d16d24q32B40__44l;
  v10[4] = v4;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3;
  v9[3] = &__block_descriptor_40_e8_v16__0d8l;
  uint64_t v7 = [v3 collectionCalculator:v5 queryForInterval:v6 error:a2 sampleHandler:v10 mergeHandler:v9];

  return v7;
}

void sub_1BD1716A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  uint64_t v10 = *(void *)(a1 + 32);
  *(double *)int v14 = a5;
  *(double *)&v14[1] = a6;
  *(double *)&v14[2] = a7;
  v14[3] = a2;
  char v15 = 1;
  uint64_t v11 = [MEMORY[0x1E4F1C9C8] distantFuture];
  [v11 timeIntervalSinceReferenceDate];
  BOOL v16 = v12 <= a7;

  return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsPresence>::_primitiveAddSample(v10, (uint64_t)v14, a3, a4);
}

void sub_1BD171748(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsPresenceE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, double a2)
{
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_HDConcreteStatisticsCollectionCalculatorImplementation(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  char v6 = a3;
  uint64_t v8 = _HDStatisticsCollectionCalculatorImplementation::_HDStatisticsCollectionCalculatorImplementation(a1, a2, a3, a4, a5, a6);
  *(void *)uint64_t v8 = &unk_1F1726740;
  double v9 = 900.0;
  if ((v6 & 0x10) == 0) {
    double v9 = 0.0;
  }
  *(double *)(v8 + 56) = v9;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(void *)(v8 + 104) = 0;
  *(void *)(v8 + 112) = 0;
  *(void *)(v8 + 96) = 0;
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::HDStatisticsBucket(v8 + 120, 0, -1.79769313e308, 1.79769313e308);
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)(a1 + 712) = 0u;
  *(_WORD *)(a1 + 728) = 1;
  *(unsigned char *)(a1 + 730) = 0;
  *(unsigned char *)(a1 + 732) = 0;
  *(void *)(a1 + 736) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_OWORD *)(a1 + 760) = 0u;
  *(void *)(a1 + 776) = 0;
  return a1;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~_HDConcreteStatisticsCollectionCalculatorImplementation(uint64_t a1)
{
  _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~_HDConcreteStatisticsCollectionCalculatorImplementation(a1);

  JUMPOUT(0x1C187B8A0);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)a1 = &unk_1F1726740;
  v2 = *(void **)(a1 + 760);
  if (v2)
  {
    *(void *)(a1 + 768) = v2;
    operator delete(v2);
  }

  id v3 = *(void **)(a1 + 696);
  if (v3)
  {
    *(void *)(a1 + 704) = v3;
    operator delete(v3);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsBucket(a1 + 120);
  objc_destroyWeak((id *)(a1 + 104));

  uint64_t v4 = *(void **)(a1 + 72);
  if (v4)
  {
    *(void *)(a1 + 80) = v4;
    operator delete(v4);
  }

  _HDStatisticsCollectionCalculatorImplementation::~_HDStatisticsCollectionCalculatorImplementation((_HDStatisticsCollectionCalculatorImplementation *)a1);
}

double _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::mergeGranularity(uint64_t a1)
{
  return *(double *)(a1 + 56);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::setMergeGranularity(uint64_t result, double a2)
{
  if (*(double *)(result + 56) != a2)
  {
    *(double *)(result + 56) = a2;
    *(unsigned char *)(result + 728) = 1;
  }
  return result;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::dateInterval(uint64_t a1)
{
  return *(id *)(a1 + 64);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::setDateInterval(uint64_t a1, void *a2)
{
  id v6 = a2;
  uint64_t v3 = [v6 copy];
  uint64_t v4 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = v3;

  BOOL v5 = [v6 startDate];
  [v5 timeIntervalSinceReferenceDate];
  _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_configureForStartTime(a1);
}

void sub_1BD1718F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::configureMergeAnchor(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!*(void *)(a1 + 40))
  {
    id v5 = v3;
    [v3 timeIntervalSinceReferenceDate];
    *(void *)(a1 + 736) = v4;
    id v3 = v5;
  }
}

void sub_1BD17196C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::setStatisticsConfiguration(id *a1, void *a2)
{
  objc_storeStrong(a1 + 93, a2);
  id v7 = a2;
  id v4 = a1[93];
  id v5 = a1[90];
  a1[90] = v4;
  id v6 = v4;

  objc_storeStrong(a1 + 19, a1[90]);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::setIntervalMask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = (char *)(a1 + 72);
  if (v6 != (char *)a2) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(v6, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  }
  if (*(void *)(a1 + 40)) {
    return 1;
  }
  BOOL v7 = *(void *)(a1 + 224) == *(void *)(a1 + 216) && *(uint64_t *)(a1 + 248) < 1
    || HKIntervalMask<double>::firstDifference(*(void *)(a1 + 184), *(void *)(a1 + 192), *(void *)a2, *(void *)(a2 + 8)) >= *(double *)(a1 + 176);
  if (a1 + 184 != a2) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((char *)(a1 + 184), *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  }
  if (v7) {
    return 1;
  }
  double v9 = *(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 128);

  return v9(a1, 0, a3);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::setStatisticsHandler(uint64_t a1, void *a2)
{
  id v5 = a2;
  uint64_t v3 = [v5 copy];
  id v4 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = v3;
}

void sub_1BD171B54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::dataSource(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 104));

  return WeakRetained;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::setDataSource(uint64_t a1, void *a2)
{
  return objc_storeWeak((id *)(a1 + 104), a2);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::currentStatistics(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 728))
  {
    double v1 = 0;
  }
  else
  {
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::HDStatisticsBucket((uint64_t)v4, a1 + 120);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_updateSourceOrder((uint64_t)v4);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeThroughTime((uint64_t)v4, v4[1]);
    double v1 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsFromFinishedBucket(a1, (uint64_t)v4);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsBucket((uint64_t)v4);
  }

  return v1;
}

void sub_1BD171C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::addSample(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = *(id *)(a1 + 64);
  BOOL v7 = v6;
  if (!v6) {
    goto LABEL_4;
  }
  uint64_t v8 = [v6 startDate];
  [v8 timeIntervalSinceReferenceDate];
  if (v9 > *(double *)(a2 + 16))
  {

    goto LABEL_10;
  }
  uint64_t v10 = [v7 endDate];
  [v10 timeIntervalSinceReferenceDate];
  double v12 = v11;
  double v13 = *(double *)(a2 + 8);

  if (v12 >= v13)
  {
LABEL_4:
    if (!*(unsigned char *)(a1 + 730)) {
      goto LABEL_21;
    }
    if (!*(unsigned char *)(a1 + 729))
    {
      if (*(void *)(a1 + 40))
      {
        if (*(unsigned char *)(a1 + 728))
        {
          double v14 = -1.79769313e308;
        }
        else
        {
          double v16 = *(double *)(a1 + 176);
          double v14 = *(double *)(a1 + 120);
          if (v16 <= v14) {
            double v16 = -1.79769313e308;
          }
          if (v16 >= v14) {
            double v14 = v16;
          }
        }
      }
      else
      {
        double v14 = -1.79769313e308;
        if (*(double *)(a1 + 176) > *(double *)(a1 + 120)) {
          double v14 = *(double *)(a1 + 176);
        }
      }
      if (v14 > *(double *)(a2 + 8))
      {
        uint64_t v17 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:");
        uint64_t v15 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v17, a3);

        goto LABEL_22;
      }
      if (*(unsigned char *)(a1 + 731))
      {
LABEL_21:
        uint64_t v15 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveAddSample(a1, a2, 1, a3);
        goto LABEL_22;
      }
      unint64_t v19 = *(void *)(a1 + 768);
      unint64_t v20 = *(void *)(a1 + 776);
      if (v19 >= v20)
      {
        uint64_t v24 = *(void *)(a1 + 760);
        unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v19 - v24) >> 3);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0x666666666666666) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - v24) >> 3);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x333333333333333) {
          unint64_t v28 = 0x666666666666666;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28) {
          unint64_t v28 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v28);
        }
        else {
          uint64_t v29 = 0;
        }
        unint64_t v30 = v28 + 40 * v25;
        unint64_t v31 = v28 + 40 * v29;
        long long v32 = *(_OWORD *)a2;
        long long v33 = *(_OWORD *)(a2 + 16);
        *(void *)(v30 + 32) = *(void *)(a2 + 32);
        *(_OWORD *)unint64_t v30 = v32;
        *(_OWORD *)(v30 + 16) = v33;
        unint64_t v23 = v30 + 40;
        double v34 = *(char **)(a1 + 768);
        long long v35 = *(char **)(a1 + 760);
        if (v34 != v35)
        {
          do
          {
            long long v36 = *(_OWORD *)(v34 - 40);
            long long v37 = *(_OWORD *)(v34 - 24);
            *(_WORD *)(v30 - 8) = *((_WORD *)v34 - 4);
            *(_OWORD *)(v30 - 24) = v37;
            *(_OWORD *)(v30 - 40) = v36;
            v30 -= 40;
            v34 -= 40;
          }
          while (v34 != v35);
          double v34 = *(char **)(a1 + 760);
        }
        *(void *)(a1 + 760) = v30;
        *(void *)(a1 + 768) = v23;
        *(void *)(a1 + 776) = v31;
        if (v34) {
          operator delete(v34);
        }
      }
      else
      {
        long long v21 = *(_OWORD *)a2;
        long long v22 = *(_OWORD *)(a2 + 16);
        *(void *)(v19 + 32) = *(void *)(a2 + 32);
        *(_OWORD *)unint64_t v19 = v21;
        *(_OWORD *)(v19 + 16) = v22;
        unint64_t v23 = v19 + 40;
      }
      *(void *)(a1 + 768) = v23;
    }
  }
LABEL_10:
  uint64_t v15 = 1;
LABEL_22:

  return v15;
}

void sub_1BD171EE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::performAddSampleTransaction(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = v5;
  if (*(unsigned char *)(a1 + 730))
  {
    uint64_t v7 = (*((uint64_t (**)(id, uint64_t))v5 + 2))(v5, a3);
    goto LABEL_83;
  }
  *(_WORD *)(a1 + 730) = 1;
  uint64_t v67 = a3;
  if (!(*((unsigned int (**)(id, uint64_t))v5 + 2))(v5, a3))
  {
    uint64_t v7 = 0;
    goto LABEL_82;
  }
  uint64_t v65 = v6;
  if (*(unsigned char *)(a1 + 729)) {
    goto LABEL_5;
  }
  double v9 = *(void **)(a1 + 752);
  if (!v9)
  {
    id v68 = 0;
    goto LABEL_28;
  }
  if (!*(void *)(a1 + 40))
  {
LABEL_5:
    int v8 = 0;
    id v68 = 0;
    goto LABEL_29;
  }
  [v9 sortUsingComparator:&__block_literal_global_1092];
  id v68 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  id v10 = *(id *)(a1 + 752);
  uint64_t v11 = [v10 countByEnumeratingWithState:&v69 objects:v73 count:16];
  if (!v11)
  {

    id v12 = 0;
    goto LABEL_27;
  }
  id v12 = 0;
  uint64_t v13 = *(void *)v70;
  do
  {
    for (uint64_t i = 0; i != v11; ++i)
    {
      if (*(void *)v70 != v13) {
        objc_enumerationMutation(v10);
      }
      id v15 = *(id *)(*((void *)&v69 + 1) + 8 * i);
      double v16 = v15;
      if (v12)
      {
        uint64_t v17 = [v15 startDate];
        uint64_t v18 = [v12 endDate];
        int v19 = objc_msgSend(v17, "hk_isBeforeOrEqualToDate:", v18);

        if (v19)
        {
          unint64_t v20 = [v16 endDate];
          long long v21 = [v12 endDate];
          int v22 = objc_msgSend(v20, "hk_isAfterDate:", v21);

          if (!v22) {
            goto LABEL_21;
          }
          id v23 = objc_alloc(MEMORY[0x1E4F28C18]);
          uint64_t v24 = [v12 startDate];
          unint64_t v25 = [v16 endDate];
          id v26 = (id)[v23 initWithStartDate:v24 endDate:v25];
        }
        else
        {
          [v68 addObject:v12];
          id v26 = v16;
        }
        id v12 = v26;
      }
      else
      {
        id v12 = v15;
      }
LABEL_21:
    }
    uint64_t v11 = [v10 countByEnumeratingWithState:&v69 objects:v73 count:16];
  }
  while (v11);

  if (v12) {
    [v68 addObject:v12];
  }
LABEL_27:

LABEL_28:
  int v8 = 1;
LABEL_29:
  unint64_t v27 = *(void **)(a1 + 752);
  *(void *)(a1 + 752) = 0;

  *(unsigned char *)(a1 + 729) = 0;
  if (!v8)
  {
    unint64_t v38 = *(void *)(a1 + 760);
    *(void *)(a1 + 776) = 0;
    *(void *)(a1 + 768) = 0;
    *(void *)(a1 + 760) = 0;
    unint64_t v39 = v38;
    goto LABEL_47;
  }
  unint64_t v28 = [v68 lastObject];
  if (v28)
  {
    uint64_t v29 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_currentBucketInterval(a1);
    unint64_t v30 = [v29 endDate];
    unint64_t v31 = [v28 endDate];
    int v32 = objc_msgSend(v30, "hk_isBeforeOrEqualToDate:", v31);

    if (v32)
    {
      long long v33 = [v28 endDate];
      [v33 timeIntervalSinceReferenceDate];
      double v35 = v34;

      uint64_t v36 = *(void *)(a1 + 760);
      long long v37 = *(long long **)(a1 + 768);
      while ((long long *)v36 != v37)
      {
        if (*(double *)(v36 + 8) < v35)
        {
          if ((long long *)v36 != v37)
          {
            double v40 = (long long *)(v36 + 40);
            if ((long long *)(v36 + 40) != v37)
            {
              do
              {
                if (*((double *)v40 + 1) >= v35)
                {
                  long long v41 = *v40;
                  long long v42 = v40[1];
                  *(_WORD *)(v36 + 32) = *((_WORD *)v40 + 16);
                  *(_OWORD *)uint64_t v36 = v41;
                  *(_OWORD *)(v36 + 16) = v42;
                  v36 += 40;
                }
                double v40 = (long long *)((char *)v40 + 40);
              }
              while (v40 != v37);
              long long v37 = *(long long **)(a1 + 768);
            }
          }
          if ((long long *)v36 != v37) {
            *(void *)(a1 + 768) = v36;
          }
          break;
        }
        v36 += 40;
      }
    }
  }
  unint64_t v38 = *(void *)(a1 + 760);
  unint64_t v39 = *(void *)(a1 + 768);
  *(void *)(a1 + 776) = 0;
  *(void *)(a1 + 760) = 0;
  *(void *)(a1 + 768) = 0;
  if (![v68 count]) {
    goto LABEL_60;
  }
LABEL_47:
  id v43 = v68;
  __p = (void *)v38;
  if (v43)
  {
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    id v44 = v43;
    uint64_t v45 = [v44 countByEnumeratingWithState:&v69 objects:v73 count:16];
    if (v45)
    {
      uint64_t v46 = *(void *)v70;
      while (2)
      {
        for (uint64_t j = 0; j != v45; ++j)
        {
          if (*(void *)v70 != v46) {
            objc_enumerationMutation(v44);
          }
          id v48 = *(id *)(*((void *)&v69 + 1) + 8 * j);
          int v49 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveInvalidateInterval((id *)a1, v48, v67);

          if (!v49)
          {

            goto LABEL_70;
          }
        }
        uint64_t v45 = [v44 countByEnumeratingWithState:&v69 objects:v73 count:16];
        if (v45) {
          continue;
        }
        break;
      }
    }

LABEL_59:
    unint64_t v38 = (unint64_t)__p;
LABEL_60:
    unint64_t v51 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v39 - v38) >> 3));
    if (v39 == v38) {
      uint64_t v52 = 0;
    }
    else {
      uint64_t v52 = v51;
    }
    int v53 = 1;
    std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(v38, v39, v52, 1);
    __p = (void *)v38;
    if (v39 != v38)
    {
      uint64_t v54 = v38;
      uint64_t v50 = v67;
      do
      {
        int v55 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveAddSample(a1, v54, 1, v50);
        int v53 = v55;
        v54 += 40;
        if (v54 == v39) {
          char v56 = 0;
        }
        else {
          char v56 = v55;
        }
        uint64_t v50 = v67;
      }
      while ((v56 & 1) != 0);
    }
  }
  else
  {
    if (_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveInvalidateInterval((id *)a1, 0, v67))goto LABEL_59; {
LABEL_70:
    }
    int v53 = 0;
  }
  if (*(void *)(a1 + 40) && *(void *)(a1 + 704) != *(void *)(a1 + 696))
  {
    do
    {
      uint64_t v57 = objc_msgSend(*(id *)(a1 + 40), "dateIntervalAtIndex:", *(void *)(a1 + 112) + 1, v50, v65);
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_updateSourceOrder(a1 + 120);
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeThroughTime(a1 + 120, *(double *)(a1 + 128));
      unint64_t v58 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsFromFinishedBucket(a1, a1 + 120);
      unint64_t v59 = [v57 startDate];
      [v59 timeIntervalSinceReferenceDate];
      double v61 = v60;
      uint64_t v62 = [v57 endDate];
      [v62 timeIntervalSinceReferenceDate];
      HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::advanceBucket(a1 + 112, v61, v63);

      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_didChangeBucket(a1, v58);
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_notifyForCurrentBucket(a1);
    }
    while (*(void *)(a1 + 704) != *(void *)(a1 + 696));
  }
  *(unsigned char *)(a1 + 730) = 0;
  if (__p) {
    operator delete(__p);
  }

  if (v53)
  {
    if (*(unsigned char *)(a1 + 732))
    {
      *(unsigned char *)(a1 + 732) = 0;
      id v6 = v65;
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_notifyForCurrentBucket(a1);
      uint64_t v7 = 1;
      goto LABEL_82;
    }
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = 0;
  }
  id v6 = v65;
LABEL_82:
  *(unsigned char *)(a1 + 730) = 0;
LABEL_83:

  return v7;
}

void sub_1BD1725E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, void *a12)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    *(unsigned char *)(v13 + 730) = 0;
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::enableImmediateSampleInsertion(uint64_t result)
{
  *(unsigned char *)(result + 731) = 1;
  return result;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::invalidateInterval(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = *(void **)(a1 + 40);
  if (!v6)
  {

    goto LABEL_11;
  }
  if (!v5)
  {
LABEL_11:
    if (*(unsigned char *)(a1 + 730)) {
      goto LABEL_12;
    }
    uint64_t v7 = 0;
LABEL_14:
    uint64_t v11 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveInvalidateInterval((id *)a1, v7, a3);
    goto LABEL_15;
  }
  uint64_t v7 = [v6 dateIntervalForIntervalsContainingInterval:v5];

  if (!*(unsigned char *)(a1 + 730)) {
    goto LABEL_14;
  }
  if (!v7)
  {
LABEL_12:
    id v12 = *(void **)(a1 + 752);
    *(void *)(a1 + 752) = 0;

    uint64_t v7 = 0;
    uint64_t v11 = 1;
    *(unsigned char *)(a1 + 729) = 1;
    goto LABEL_15;
  }
  if (!*(unsigned char *)(a1 + 729))
  {
    int v8 = *(void **)(a1 + 752);
    if (!v8)
    {
      id v9 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      id v10 = *(void **)(a1 + 752);
      *(void *)(a1 + 752) = v9;

      int v8 = *(void **)(a1 + 752);
    }
    [v8 addObject:v7];
  }
  uint64_t v11 = 1;
LABEL_15:

  return v11;
}

void sub_1BD1728E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::queryForInitialStatistics(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 104));
  if (WeakRetained)
  {
    *(unsigned char *)(a1 + 728) = 1;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke;
    v9[3] = &unk_1E63043E8;
    uint64_t v12 = a1;
    id v10 = v5;
    id v11 = WeakRetained;
    uint64_t v7 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 112))(a1, v9, a3);
    if (v7 && *(unsigned char *)(a1 + 728) && !*(void *)(a1 + 40)) {
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_configureForStartTime(a1);
    }
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a3, 3, @"Unable to query for initial statistics: no data source available.");
    uint64_t v7 = 0;
  }

  return v7;
}

void sub_1BD172A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::reset(uint64_t result)
{
  *(unsigned char *)(result + 728) = 1;
  return result;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::encodeInternalsWithEncoder(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 encodeBool:*(unsigned __int8 *)(a1 + 728) forKey:@"needs_config"];
  v3;
  v27[0] = &unk_1F1726FA0;
  v27[1] = 0;
  int v28 = 0;
  uint64_t v4 = *(void *)(a1 + 112);
  LOBYTE(v28) = 1;
  v27[2] = v4;
  memset(&v27[3], 0, 24);
  statistics::StatisticsEngine::makeCurrentBucket((uint64_t)v27);
  int v8 = &unk_1F171B9C8;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  int v26 = 511;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v22 = 0;
  int8x16_t v9 = vextq_s8(*(int8x16_t *)(a1 + 120), *(int8x16_t *)(a1 + 120), 8uLL);
  uint64_t v5 = *(void *)(a1 + 136);
  char v24 = *(unsigned char *)(a1 + 144);
  char v25 = *(unsigned char *)(a1 + 145);
  BOOL v23 = *(_DWORD *)(a1 + 148) == 0;
  int8x16_t v10 = vextq_s8(*(int8x16_t *)(a1 + 160), *(int8x16_t *)(a1 + 160), 8uLL);
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v14 = v5;
  uint64_t v15 = v6;
  uint64_t v7 = *(int8x16_t **)(a1 + 216);
  if (v7 != *(int8x16_t **)(a1 + 224))
  {
    v29[0] = &unk_1F17206F8;
    int v34 = 127;
    int8x16_t v30 = vextq_s8(*v7, *v7, 8uLL);
    v29[1] = v7[1].i64[0];
    v29[2] = v7[1].i64[1];
    char v33 = 0;
    __int8 v32 = v7[2].i8[9];
    __int8 v31 = v7[2].i8[10];
    PB::PtrVector<statistics::RawQuantitySample>::emplace_back<statistics::RawQuantitySample&>();
  }
  statistics::StatisticsBucket::makeStatistics((uint64_t)&v8);
  HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::archive((uint64_t)v29, a1 + 240);
}

void sub_1BD172E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&a35);

  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::decodeInternalsWithDecoder(uint64_t a1, void *a2)
{
  id v62 = a2;
  *(unsigned char *)(a1 + 728) = [v62 decodeBoolForKey:@"needs_config"];
  id v3 = v62;
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::HDStatisticsBucket((uint64_t)v67, 0, -1.79769313e308, 1.79769313e308);
  long long v68 = 0u;
  long long v69 = 0u;
  unint64_t v115 = 0;
  id v65 = v3;
  PB::Reader::Reader((PB::Reader *)v114, (const unsigned __int8 *)[v65 decodeBytesForKey:@"hdsce_archived_representation" returnedLength:&v115]);
  uint64_t v64 = a1;
  uint64_t v107 = &unk_1F1726FA0;
  uint64_t v108 = 0;
  uint64_t v112 = 0;
  uint64_t v110 = 0;
  uint64_t v111 = 0;
  int v113 = 0;
  statistics::StatisticsEngine::readFrom((statistics::StatisticsEngine *)&v107, (PB::Reader *)v114);
  uint64_t v66 = v109;
  if (v108)
  {
    uint64_t v73 = 0;
    memset(v76, 0, sizeof(v76));
    __p = 0;
    unint64_t v79 = 0;
    uint64_t v78 = 0;
    int v80 = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v83 = xmmword_1BD330210;
    *(_OWORD *)&v84[8] = xmmword_1BD330220;
    *(void *)uint64_t v84 = 0;
    *(void *)&v84[24] = 0;
    long long v85 = xmmword_1BD330230;
    *(_OWORD *)&v86[8] = xmmword_1BD330240;
    *(void *)long long v86 = 0;
    *(void *)&v86[24] = 0;
    long long v87 = xmmword_1BD330250;
    *(void *)&long long v88 = 0;
    *((void *)&v88 + 1) = 0x7FFFFFFFFFFFFFFFLL;
    memset(v89, 0, 74);
    uint64_t v92 = 0;
    unint64_t v91 = 0;
    uint64_t v90 = &v91;
    long long v93 = 0u;
    long long v94 = 0u;
    int v95 = 1065353216;
    long long v96 = 0u;
    long long v97 = 0u;
    long long v98 = 0u;
    uint64_t v99 = 0;
    int v100 = 1065353216;
    long long v101 = 0u;
    long long v102 = 0u;
    int v103 = 1065353216;
    long long v104 = 0u;
    long long v105 = 0u;
    int v106 = 1065353216;
    int8x16_t v70 = vextq_s8(*(int8x16_t *)(v108 + 8), *(int8x16_t *)(v108 + 8), 8uLL);
    uint64_t v4 = *(void *)(v108 + 72);
    uint64_t v71 = *(void *)(v108 + 64);
    __int16 v72 = *(_WORD *)(v108 + 185);
    int8x16_t v74 = vextq_s8(*(int8x16_t *)(v108 + 24), *(int8x16_t *)(v108 + 24), 8uLL);
    uint64_t v75 = v4;
    uint64_t v5 = *(void *)(v108 + 80);
    uint64_t v6 = *(void *)(v108 + 88);
    double v63 = (void *)v108;
    if (v5 != v6)
    {
      uint64_t v7 = 0;
      do
      {
        uint64_t v8 = *(void *)(*(void *)v5 + 24);
        uint64_t v9 = *(void *)(*(void *)v5 + 32);
        uint64_t v10 = *(void *)(*(void *)v5 + 8);
        uint64_t v11 = *(void *)(*(void *)v5 + 16);
        char v12 = *(unsigned char *)(*(void *)v5 + 41);
        char v13 = *(unsigned char *)(*(void *)v5 + 40);
        if ((unint64_t)v7 >= v79)
        {
          uint64_t v14 = (char *)__p;
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (unsigned char *)__p) >> 4);
          unint64_t v16 = v15 + 1;
          if (v15 + 1 > 0x555555555555555) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          if (0x5555555555555556 * ((uint64_t)(v79 - (void)__p) >> 4) > v16) {
            unint64_t v16 = 0x5555555555555556 * ((uint64_t)(v79 - (void)__p) >> 4);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v79 - (void)__p) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v17 = 0x555555555555555;
          }
          else {
            unint64_t v17 = v16;
          }
          if (v17)
          {
            unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v17);
            uint64_t v7 = v78;
            uint64_t v14 = (char *)__p;
          }
          else
          {
            uint64_t v18 = 0;
          }
          long long v19 = (void *)(v17 + 48 * v15);
          *long long v19 = v9;
          v19[1] = v8;
          v19[2] = v10;
          v19[3] = v11;
          *((_WORD *)v19 + 16) = 1;
          *((unsigned char *)v19 + 40) = 0;
          *((unsigned char *)v19 + 41) = v12;
          *((unsigned char *)v19 + 42) = v13;
          long long v20 = (char *)v19;
          if (v7 != v14)
          {
            do
            {
              long long v21 = *((_OWORD *)v7 - 3);
              long long v22 = *((_OWORD *)v7 - 2);
              *(_OWORD *)(v20 - 21) = *(_OWORD *)(v7 - 21);
              *((_OWORD *)v20 - 3) = v21;
              *((_OWORD *)v20 - 2) = v22;
              v20 -= 48;
              v7 -= 48;
            }
            while (v7 != v14);
            uint64_t v14 = (char *)__p;
          }
          uint64_t v7 = (char *)(v19 + 6);
          __p = v20;
          uint64_t v78 = (char *)(v19 + 6);
          unint64_t v79 = v17 + 48 * v18;
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          *(void *)uint64_t v7 = v9;
          *((void *)v7 + 1) = v8;
          *((void *)v7 + 2) = v10;
          *((void *)v7 + 3) = v11;
          *((_WORD *)v7 + 16) = 1;
          v7[40] = 0;
          v7[41] = v12;
          v7[42] = v13;
          v7 += 48;
        }
        uint64_t v78 = v7;
        v5 += 8;
      }
      while (v5 != v6);
    }
    BOOL v23 = (void *)v63[13];
    if (v23)
    {
      HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::unarchive((uint64_t)&v116, v23);
      int v80 = v116;
      *(_OWORD *)long long v86 = v123;
      *(_OWORD *)&v86[16] = v124;
      long long v87 = v125;
      long long v88 = v126;
      long long v83 = v119;
      *(_OWORD *)uint64_t v84 = v120;
      *(_OWORD *)&v84[16] = v121;
      long long v85 = v122;
      long long v81 = v117;
      long long v82 = v118;
      v89[0] = v127;
      if (v89[1])
      {
        v89[2] = v89[1];
        operator delete((void *)v89[1]);
      }
      *(_OWORD *)&v89[1] = v128;
      v89[3] = v129;
      uint64_t v129 = 0;
      long long v128 = 0uLL;
      v89[4] = v130;
      *(_OWORD *)&v89[5] = v131;
      *(_OWORD *)&v89[7] = v132;
      LOWORD(v89[9]) = v133;
    }
    char v24 = (void **)v63[17];
    for (uint64_t i = (void **)v63[18]; v24 != i; ++v24)
    {
      uint64_t v26 = (uint64_t)*v24;
      HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::unarchive((uint64_t)&v116, *v24);
      uint64_t v27 = *(void *)(v26 + 144);
      int v28 = v91;
      uint64_t v29 = &v91;
      int8x16_t v30 = &v91;
      if (v91)
      {
        do
        {
          while (1)
          {
            int8x16_t v30 = (uint64_t **)v28;
            uint64_t v31 = v28[4];
            if (v31 <= v27) {
              break;
            }
            int v28 = *v30;
            uint64_t v29 = v30;
            if (!*v30) {
              goto LABEL_34;
            }
          }
          if (v31 >= v27)
          {
            char v33 = (char *)v30;
            goto LABEL_37;
          }
          int v28 = v30[1];
        }
        while (v28);
        uint64_t v29 = v30 + 1;
      }
LABEL_34:
      char v33 = (char *)operator new(0x120uLL);
      *((void *)v33 + 4) = v27;
      *(_OWORD *)(v33 + 72) = 0u;
      *(_OWORD *)(v33 + 88) = 0u;
      *(_OWORD *)(v33 + 120) = 0u;
      *(_OWORD *)(v33 + 136) = 0u;
      *(_OWORD *)(v33 + 168) = 0u;
      *(_OWORD *)(v33 + 184) = 0u;
      *(_OWORD *)(v33 + 200) = 0u;
      *(_OWORD *)(v33 + 40) = 0u;
      *(_OWORD *)(v33 + 56) = 0u;
      *(_OWORD *)(v33 + 216) = 0u;
      *(_OWORD *)(v33 + 232) = 0u;
      *(_OWORD *)(v33 + 248) = 0u;
      *((void *)v33 + 35) = 0;
      *(_OWORD *)(v33 + 264) = 0u;
      *((_OWORD *)v33 + 5) = xmmword_1BD330210;
      *(_OWORD *)(v33 + 104) = xmmword_1BD330220;
      *((_OWORD *)v33 + 8) = xmmword_1BD330230;
      *(_OWORD *)(v33 + 152) = xmmword_1BD330240;
      *((_OWORD *)v33 + 11) = xmmword_1BD330250;
      *((void *)v33 + 25) = 0x7FFFFFFFFFFFFFFFLL;
      *(_OWORD *)(v33 + 266) = 0u;
      *((_OWORD *)v33 + 15) = 0u;
      *((_OWORD *)v33 + 16) = 0u;
      *((_OWORD *)v33 + 13) = 0u;
      *((_OWORD *)v33 + 14) = 0u;
      *(void *)char v33 = 0;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = v30;
      *uint64_t v29 = (uint64_t *)v33;
      __int8 v32 = (uint64_t *)v33;
      if (*v90)
      {
        uint64_t v90 = (uint64_t **)*v90;
        __int8 v32 = *v29;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v91, v32);
      ++v92;
LABEL_37:
      *((_DWORD *)v33 + 10) = v116;
      long long v34 = v122;
      *((_OWORD *)v33 + 7) = v121;
      *((_OWORD *)v33 + 8) = v34;
      long long v35 = v120;
      *((_OWORD *)v33 + 5) = v119;
      *((_OWORD *)v33 + 6) = v35;
      long long v36 = v126;
      *((_OWORD *)v33 + 11) = v125;
      *((_OWORD *)v33 + 12) = v36;
      long long v37 = v124;
      *((_OWORD *)v33 + 9) = v123;
      *((_OWORD *)v33 + 10) = v37;
      long long v38 = v118;
      *((_OWORD *)v33 + 3) = v117;
      *((_OWORD *)v33 + 4) = v38;
      unint64_t v39 = (void *)*((void *)v33 + 27);
      *((void *)v33 + 26) = v127;
      if (v39)
      {
        *((void *)v33 + 28) = v39;
        operator delete(v39);
        *((void *)v33 + 27) = 0;
        *((void *)v33 + 28) = 0;
        *((void *)v33 + 29) = 0;
      }
      *(_OWORD *)(v33 + 216) = v128;
      *((void *)v33 + 29) = v129;
      *((void *)v33 + 30) = v130;
      long long v40 = v132;
      *(_OWORD *)(v33 + 248) = v131;
      uint64_t v129 = 0;
      long long v128 = 0uLL;
      *(_OWORD *)(v33 + 264) = v40;
      *((_WORD *)v33 + 140) = v133;
    }
    uint64_t v41 = v63[5];
    for (uint64_t j = v63[6]; v41 != j; v41 += 8)
    {
      double v44 = *(double *)(*(void *)v41 + 8);
      double v43 = *(double *)(*(void *)v41 + 16);
      if (v44 >= v43) {
        double v45 = *(double *)(*(void *)v41 + 16);
      }
      else {
        double v45 = *(double *)(*(void *)v41 + 8);
      }
      if (v43 < v44) {
        double v43 = *(double *)(*(void *)v41 + 8);
      }
      HKIntervalMask<double>::_insertInterval(v76, v45, v43);
    }
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::operator=((uint64_t)v67, (uint64_t)&v70);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsBucket((uint64_t)&v70);
  }
  uint64_t v46 = v110;
  uint64_t v47 = v111;
  if (v110 != v111)
  {
    unint64_t v48 = *((void *)&v68 + 1);
    do
    {
      uint64_t v49 = *(void *)(*(void *)v46 + 24);
      uint64_t v50 = *(void *)(*(void *)v46 + 32);
      uint64_t v51 = *(void *)(*(void *)v46 + 8);
      uint64_t v52 = *(void *)(*(void *)v46 + 16);
      if (v48 >= (unint64_t)v69)
      {
        int v53 = (void *)v68;
        unint64_t v54 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v48 - v68) >> 3);
        unint64_t v55 = v54 + 1;
        if (v54 + 1 > 0x666666666666666) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        if (0x999999999999999ALL * ((uint64_t)(v69 - v68) >> 3) > v55) {
          unint64_t v55 = 0x999999999999999ALL * ((uint64_t)(v69 - v68) >> 3);
        }
        if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v69 - v68) >> 3) >= 0x333333333333333) {
          unint64_t v56 = 0x666666666666666;
        }
        else {
          unint64_t v56 = v55;
        }
        if (v56)
        {
          unint64_t v56 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v56);
          unint64_t v48 = *((void *)&v68 + 1);
          int v53 = (void *)v68;
        }
        else
        {
          uint64_t v57 = 0;
        }
        unint64_t v58 = v56 + 40 * v54;
        *(void *)unint64_t v58 = v50;
        *(void *)(v58 + 8) = v49;
        *(void *)(v58 + 16) = v51;
        *(void *)(v58 + 24) = v52;
        *(_WORD *)(v58 + 32) = 1;
        unint64_t v59 = v58;
        if ((void *)v48 != v53)
        {
          do
          {
            long long v60 = *(_OWORD *)(v48 - 40);
            long long v61 = *(_OWORD *)(v48 - 24);
            *(_WORD *)(v59 - 8) = *(_WORD *)(v48 - 8);
            *(_OWORD *)(v59 - 24) = v61;
            *(_OWORD *)(v59 - 40) = v60;
            v59 -= 40;
            v48 -= 40;
          }
          while ((void *)v48 != v53);
          int v53 = (void *)v68;
        }
        *(void *)&long long v68 = v59;
        unint64_t v48 = v58 + 40;
        *((void *)&v68 + 1) = v58 + 40;
        *(void *)&long long v69 = v56 + 40 * v57;
        if (v53) {
          operator delete(v53);
        }
      }
      else
      {
        *(void *)unint64_t v48 = v50;
        *(void *)(v48 + 8) = v49;
        *(void *)(v48 + 16) = v51;
        *(void *)(v48 + 24) = v52;
        *(_WORD *)(v48 + 32) = 1;
        v48 += 40;
      }
      *((void *)&v68 + 1) = v48;
      v46 += 8;
    }
    while (v46 != v47);
  }
  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&v107);

  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::operator=((void *)(v64 + 112), (uint64_t)&v66);
  if ((void)v68)
  {
    *((void *)&v68 + 1) = v68;
    operator delete((void *)v68);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsBucket((uint64_t)v67);
}

void sub_1BD17370C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::~__hash_table(a10);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table((uint64_t)&STACK[0x4F0]);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&STACK[0x4C8]);
  uint64_t v29 = (void *)STACK[0x4B0];
  if (STACK[0x4B0])
  {
    STACK[0x4B8] = (unint64_t)v29;
    operator delete(v29);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a11);
  std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::destroy((void *)STACK[0x478]);
  int8x16_t v30 = (void *)STACK[0x428];
  if (STACK[0x428])
  {
    STACK[0x430] = (unint64_t)v30;
    operator delete(v30);
  }
  uint64_t v31 = (void *)STACK[0x360];
  if (STACK[0x360])
  {
    STACK[0x368] = (unint64_t)v31;
    operator delete(v31);
  }
  objc_destroyWeak((id *)&STACK[0x358]);
  __int8 v32 = (void *)STACK[0x340];
  if (STACK[0x340])
  {
    STACK[0x348] = (unint64_t)v32;
    operator delete(v32);
  }

  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&STACK[0x548]);
  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsCollectionEngine((uint64_t)&a28);

  _Unwind_Resume(a1);
}

uint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::HDStatisticsBucket(uint64_t a1, void *a2, double a3, double a4)
{
  *(double *)a1 = a3;
  *(double *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 24) = 256;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(double *)(a1 + 56) = a3;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  objc_initWeak((id *)(a1 + 88), a2);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = xmmword_1BD330210;
  *(void *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 184) = xmmword_1BD330220;
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 208) = xmmword_1BD330230;
  *(void *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 232) = xmmword_1BD330240;
  *(void *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 256) = xmmword_1BD330250;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0x7FFFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 346) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 368) = a1 + 376;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_DWORD *)(a1 + 424) = 1065353216;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(void *)(a1 + 480) = 0;
  *(_DWORD *)(a1 + 488) = 1065353216;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_DWORD *)(a1 + 528) = 1065353216;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_DWORD *)(a1 + 568) = 1065353216;
  return a1;
}

uint64_t HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsCollectionEngine(uint64_t a1)
{
  v2 = *(void **)(a1 + 584);
  if (v2)
  {
    *(void *)(a1 + 592) = v2;
    operator delete(v2);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsBucket(a1 + 8);
  return a1;
}

uint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsBucket(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::~__hash_table(a1 + 536);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table(a1 + 496);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a1 + 456);
  v2 = *(void **)(a1 + 432);
  if (v2)
  {
    *(void *)(a1 + 440) = v2;
    operator delete(v2);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a1 + 392);
  std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::destroy(*(void **)(a1 + 376));
  id v3 = *(void **)(a1 + 296);
  if (v3)
  {
    *(void *)(a1 + 304) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 96);
  if (v4)
  {
    *(void *)(a1 + 104) = v4;
    operator delete(v4);
  }
  objc_destroyWeak((id *)(a1 + 88));
  uint64_t v5 = *(void **)(a1 + 64);
  if (v5)
  {
    *(void *)(a1 + 72) = v5;
    operator delete(v5);
  }

  return a1;
}

void std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::destroy(*a1);
    std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::destroy(a1[1]);
    v2 = (void *)a1[27];
    if (v2)
    {
      a1[28] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_configureForStartTime(uint64_t a1)
{
  uint64_t v29 = 0;
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    id v3 = objc_msgSend(MEMORY[0x1E4F1C9C8], "dateWithTimeIntervalSinceReferenceDate:");
    uint64_t v4 = [v2 dateIntervalContainingDate:v3 index:&v29];

    uint64_t v5 = [v4 startDate];
    [v5 timeIntervalSinceReferenceDate];
    double v7 = v6;

    uint64_t v8 = [v4 endDate];
    [v8 timeIntervalSinceReferenceDate];
LABEL_5:
    double v13 = v9;

    goto LABEL_6;
  }
  id v10 = *(id *)(a1 + 64);
  uint64_t v4 = v10;
  if (v10)
  {
    uint64_t v11 = [v10 startDate];
    [v11 timeIntervalSinceReferenceDate];
    double v7 = v12;

    uint64_t v8 = [v4 endDate];
    [v8 timeIntervalSinceReferenceDate];
    goto LABEL_5;
  }
  double v7 = -1.79769313e308;
  double v13 = 1.79769313e308;
LABEL_6:

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::HDStatisticsBucket((uint64_t)v22, WeakRetained, v7, v13);

  if (*(void *)(a1 + 32) == 1) {
    char v24 = 1;
  }
  uint64_t v23 = *(void *)(a1 + 56);
  char v25 = *(unsigned char *)(a1 + 24) & 1;
  if (v28 != (char *)(a1 + 72)) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(v28, *(char **)(a1 + 72), *(void *)(a1 + 80), (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 4);
  }
  objc_storeStrong(&v27, *(id *)(a1 + 744));
  if (!*(void *)(a1 + 40)) {
    int v26 = 0;
  }
  uint64_t v15 = v29;
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::HDStatisticsBucket((uint64_t)v17, (uint64_t)v22);
  uint64_t v18 = v15;
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::HDStatisticsBucket((uint64_t)v19, (uint64_t)v17);
  long long __p = 0u;
  long long v21 = 0u;
  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::operator=((void *)(a1 + 112), (uint64_t)&v18);

  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsBucket((uint64_t)v19);
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsBucket((uint64_t)v17);
  *(unsigned char *)(a1 + 728) = 0;
  return HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::~HDStatisticsBucket((uint64_t)v22);
}

void sub_1BD173D14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::operator=(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::operator=((uint64_t)(a1 + 1), a2 + 8);
  std::vector<HKRawInterval<double>>::__move_assign((uint64_t)(a1 + 73), (__n128 *)(a2 + 584));
  uint64_t v4 = *(void *)(a2 + 608);
  *(void *)(a2 + 608) = 0;
  uint64_t v5 = (void *)a1[76];
  a1[76] = v4;

  return a1;
}

uint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::HDStatisticsBucket(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(id *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 56);
  long long v6 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 40) = v6;
  *(void *)(a1 + 56) = v5;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((void *)(a1 + 64), *(const void **)(a2 + 64), *(void *)(a2 + 72), (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 4);
  objc_copyWeak((id *)(a1 + 88), (id *)(a2 + 88));
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  uint64_t v8 = *(unsigned char **)(a2 + 96);
  double v7 = *(unsigned char **)(a2 + 104);
  uint64_t v9 = v7 - v8;
  if (v7 != v8)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v9 >> 4) >= 0x555555555555556) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    id v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(0xAAAAAAAAAAAAAAABLL * (v9 >> 4));
    *(void *)(a1 + 96) = v10;
    *(void *)(a1 + 104) = v10;
    *(void *)(a1 + 112) = &v10[48 * v11];
    memmove(v10, v8, v9 - 5);
    *(void *)(a1 + 104) = &v10[16 * (v9 >> 4)];
  }
  *(_DWORD *)(a1 + 120) = *(_DWORD *)(a2 + 120);
  long long v12 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = v12;
  long long v13 = *(_OWORD *)(a2 + 160);
  long long v14 = *(_OWORD *)(a2 + 176);
  long long v15 = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(a1 + 192) = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 160) = v13;
  *(_OWORD *)(a1 + 176) = v14;
  long long v16 = *(_OWORD *)(a2 + 224);
  long long v17 = *(_OWORD *)(a2 + 240);
  long long v18 = *(_OWORD *)(a2 + 272);
  *(_OWORD *)(a1 + 256) = *(_OWORD *)(a2 + 256);
  *(_OWORD *)(a1 + 272) = v18;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 240) = v17;
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 312) = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((void *)(a1 + 296), *(const void **)(a2 + 296), *(void *)(a2 + 304), (uint64_t)(*(void *)(a2 + 304) - *(void *)(a2 + 296)) >> 4);
  *(void *)(a1 + 320) = *(void *)(a2 + 320);
  long long v19 = *(_OWORD *)(a2 + 344);
  uint64_t v20 = *(void *)(a2 + 360);
  *(_OWORD *)(a1 + 328) = *(_OWORD *)(a2 + 328);
  *(_OWORD *)(a1 + 344) = v19;
  long long v21 = (void *)(a1 + 376);
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 360) = v20;
  *(void *)(a1 + 368) = a1 + 376;
  long long v22 = *(void **)(a2 + 368);
  if (v22 != (void *)(a2 + 376))
  {
    uint64_t v23 = 0;
    char v24 = (void *)(a1 + 376);
    while (1)
    {
      char v25 = (void *)(a1 + 376);
      if (v24 == v21) {
        goto LABEL_12;
      }
      int v26 = v23;
      id v27 = (void *)(a1 + 376);
      if (v23)
      {
        do
        {
          char v25 = v26;
          int v26 = (void *)v26[1];
        }
        while (v26);
      }
      else
      {
        do
        {
          char v25 = (void *)v27[2];
          BOOL v28 = *v25 == (void)v27;
          id v27 = v25;
        }
        while (v28);
      }
      uint64_t v29 = v22[4];
      if (v25[4] < v29)
      {
LABEL_12:
        if (v23) {
          int8x16_t v30 = (uint64_t **)v25;
        }
        else {
          int8x16_t v30 = (uint64_t **)(a1 + 376);
        }
        if (v23) {
          uint64_t v31 = (uint64_t **)(v25 + 1);
        }
        else {
          uint64_t v31 = (uint64_t **)(a1 + 376);
        }
        if (!*v31)
        {
LABEL_28:
          long long v34 = (char *)operator new(0x120uLL);
          *((void *)v34 + 4) = v22[4];
          *((_DWORD *)v34 + 10) = *((_DWORD *)v22 + 10);
          long long v35 = *((_OWORD *)v22 + 4);
          *((_OWORD *)v34 + 3) = *((_OWORD *)v22 + 3);
          *((_OWORD *)v34 + 4) = v35;
          long long v36 = *((_OWORD *)v22 + 5);
          long long v37 = *((_OWORD *)v22 + 6);
          long long v38 = *((_OWORD *)v22 + 8);
          *((_OWORD *)v34 + 7) = *((_OWORD *)v22 + 7);
          *((_OWORD *)v34 + 8) = v38;
          *((_OWORD *)v34 + 5) = v36;
          *((_OWORD *)v34 + 6) = v37;
          long long v39 = *((_OWORD *)v22 + 9);
          long long v40 = *((_OWORD *)v22 + 10);
          long long v41 = *((_OWORD *)v22 + 12);
          *((_OWORD *)v34 + 11) = *((_OWORD *)v22 + 11);
          *((_OWORD *)v34 + 12) = v41;
          *((_OWORD *)v34 + 9) = v39;
          *((_OWORD *)v34 + 10) = v40;
          uint64_t v42 = v22[26];
          *((void *)v34 + 27) = 0;
          *((void *)v34 + 26) = v42;
          *((void *)v34 + 28) = 0;
          *((void *)v34 + 29) = 0;
          std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((void *)v34 + 27, (const void *)v22[27], v22[28], (uint64_t)(v22[28] - v22[27]) >> 4);
          *((void *)v34 + 30) = v22[30];
          long long v43 = *(_OWORD *)(v22 + 31);
          long long v44 = *(_OWORD *)(v22 + 33);
          *((void *)v34 + 35) = v22[35];
          *(_OWORD *)(v34 + 264) = v44;
          *(_OWORD *)(v34 + 248) = v43;
          std::__tree<unsigned long long>::__insert_node_at((uint64_t **)(a1 + 368), (uint64_t)v30, v31, (uint64_t *)v34);
        }
      }
      else
      {
        uint64_t v31 = (uint64_t **)(a1 + 376);
        int8x16_t v30 = (uint64_t **)(a1 + 376);
        if (!v23) {
          goto LABEL_28;
        }
        __int8 v32 = v23;
        while (1)
        {
          while (1)
          {
            int8x16_t v30 = (uint64_t **)v32;
            uint64_t v33 = v32[4];
            if (v33 <= v29) {
              break;
            }
            __int8 v32 = *v30;
            uint64_t v31 = v30;
            if (!*v30) {
              goto LABEL_28;
            }
          }
          if (v33 >= v29) {
            break;
          }
          __int8 v32 = v30[1];
          if (!v32)
          {
            uint64_t v31 = v30 + 1;
            goto LABEL_28;
          }
        }
      }
      double v45 = (void *)v22[1];
      if (v45)
      {
        do
        {
          uint64_t v46 = v45;
          double v45 = (void *)*v45;
        }
        while (v45);
      }
      else
      {
        do
        {
          uint64_t v46 = (void *)v22[2];
          BOOL v28 = *v46 == (void)v22;
          long long v22 = v46;
        }
        while (!v28);
      }
      if (v46 == (void *)(a2 + 376)) {
        break;
      }
      uint64_t v23 = (void *)*v21;
      char v24 = *(void **)(a1 + 368);
      long long v22 = v46;
    }
  }
  std::unordered_set<long long>::unordered_set(a1 + 392, a2 + 392);
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 448) = 0;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>((void *)(a1 + 432), *(const void **)(a2 + 432), *(void *)(a2 + 440), (uint64_t)(*(void *)(a2 + 440) - *(void *)(a2 + 432)) >> 3);
  std::unordered_map<long long,long long>::unordered_map(a1 + 456, a2 + 456);
  std::unordered_map<NSString * {__strong},long long,HDStringHash,HDStringEqual,std::allocator<std::pair<NSString * const {__strong},long long>>>::unordered_map(a1 + 496, a2 + 496);
  std::unordered_map<long long,NSString * {__strong}>::unordered_map(a1 + 536, a2 + 536);
  return a1;
}

void sub_1BD174160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, void **a10, id *location, void **a12)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table(v17);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v16);
  long long v19 = *v15;
  if (*v15)
  {
    *(void *)(v12 + 440) = v19;
    operator delete(v19);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v14);
  std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::destroy(*v13);
  uint64_t v20 = *a9;
  if (*a9)
  {
    *(void *)(v12 + 304) = v20;
    operator delete(v20);
  }
  long long v21 = *a10;
  if (*a10)
  {
    *(void *)(v12 + 104) = v21;
    operator delete(v21);
  }
  objc_destroyWeak(location);
  long long v22 = *a12;
  if (*a12)
  {
    *(void *)(v12 + 72) = v22;
    operator delete(v22);
  }

  _Unwind_Resume(a1);
}

uint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::operator=(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  long long v6 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = v5;

  long long v7 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v7;
  std::vector<HKRawInterval<double>>::__move_assign(a1 + 64, (__n128 *)(a2 + 64));
  id WeakRetained = objc_loadWeakRetained((id *)(a2 + 88));
  objc_storeWeak((id *)(a1 + 88), WeakRetained);

  uint64_t v9 = *(void **)(a1 + 96);
  if (v9)
  {
    *(void *)(a1 + 104) = v9;
    operator delete(v9);
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
  }
  int v10 = *(_DWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(_DWORD *)(a1 + 120) = v10;
  long long v11 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = v11;
  long long v12 = *(_OWORD *)(a2 + 160);
  long long v13 = *(_OWORD *)(a2 + 176);
  long long v14 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 160) = v12;
  long long v15 = *(_OWORD *)(a2 + 224);
  long long v16 = *(_OWORD *)(a2 + 240);
  long long v17 = *(_OWORD *)(a2 + 256);
  *(_OWORD *)(a1 + 272) = *(_OWORD *)(a2 + 272);
  *(_OWORD *)(a1 + 256) = v17;
  *(_OWORD *)(a1 + 240) = v16;
  *(_OWORD *)(a1 + 224) = v15;
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  std::vector<HKRawInterval<double>>::__move_assign(a1 + 296, (__n128 *)(a2 + 296));
  *(void *)(a1 + 320) = *(void *)(a2 + 320);
  long long v18 = *(_OWORD *)(a2 + 328);
  long long v19 = *(_OWORD *)(a2 + 344);
  *(_WORD *)(a1 + 360) = *(_WORD *)(a2 + 360);
  *(_OWORD *)(a1 + 328) = v18;
  *(_OWORD *)(a1 + 344) = v19;
  uint64_t v20 = a1 + 376;
  std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::destroy(*(void **)(a1 + 376));
  *(void *)(a1 + 368) = *(void *)(a2 + 368);
  uint64_t v21 = *(void *)(a2 + 376);
  *(void *)(a1 + 376) = v21;
  uint64_t v22 = *(void *)(a2 + 384);
  *(void *)(a1 + 384) = v22;
  if (v22)
  {
    *(void *)(v21 + 16) = v20;
    *(void *)(a2 + 368) = a2 + 376;
    *(void *)(a2 + 376) = 0;
    *(void *)(a2 + 384) = 0;
  }
  else
  {
    *(void *)(a1 + 368) = v20;
  }
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__move_assign(a1 + 392, (uint64_t *)(a2 + 392));
  std::vector<HKRawInterval<double>>::__move_assign(a1 + 432, (__n128 *)(a2 + 432));
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__move_assign(a1 + 456, (uint64_t *)(a2 + 456));
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::__move_assign(a1 + 496, (uint64_t *)(a2 + 496));
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::__move_assign(a1 + 536, (uint64_t *)(a2 + 536));
  return a1;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsFromFinishedBucket(uint64_t a1, uint64_t a2)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  double v4 = *(double *)a2;
  id v5 = objc_alloc(MEMORY[0x1E4F1C9C8]);
  long long v6 = (double *)(a2 + 40);
  if (v4 != -1.79769313e308) {
    long long v6 = (double *)a2;
  }
  uint64_t v81 = [v5 initWithTimeIntervalSinceReferenceDate:*v6];
  uint64_t v84 = a2;
  if (*(double *)(a2 + 8) == 1.79769313e308) {
    uint64_t v7 = [objc_alloc(MEMORY[0x1E4F1C9C8]) initWithTimeIntervalSinceReferenceDate:*(double *)(a2 + 48)];
  }
  else {
    uint64_t v7 = [objc_alloc(MEMORY[0x1E4F1C9C8]) initWithTimeIntervalSinceReferenceDate:*(double *)(a2 + 8)];
  }
  uint64_t v8 = (void *)v7;
  uint64_t v9 = (void *)v81;
  id v10 = *(id *)(a1 + 16);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v11 = *(id *)(a1 + 16);
    if ([v11 shouldUseUnderlyingTypeForStatistics])
    {
      uint64_t v12 = [v11 underlyingSampleType];

      id v10 = (id)v12;
    }
  }
  long long v13 = (void *)[objc_alloc(MEMORY[0x1E4F2B5B0]) initWithDataType:v10 startDate:v81 endDate:v8];
  if (*(unsigned char *)(a1 + 24))
  {
    v2 = (id *)(a1 + 48);
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));

    if (WeakRetained)
    {
      id v15 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      long long v16 = *(uint64_t **)(a2 + 432);
      long long v17 = *(uint64_t **)(a2 + 440);
      while (v16 != v17)
      {
        uint64_t v18 = *v16;
        id v19 = objc_loadWeakRetained(v2);
        uint64_t v20 = [v19 sourceForSourceID:v18];

        if (v20)
        {
          if (([v15 containsObject:v20] & 1) == 0) {
            [v15 addObject:v20];
          }
        }

        ++v16;
      }
      v2 = (id *)[v15 copy];
      uint64_t v9 = (void *)v81;
      [v13 _setSources:v2];
    }
  }

  v91[0] = &unk_1F1726930;
  v91[3] = v91;
  id v82 = v13;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__value_func[abi:ne180100]((uint64_t)v93, (uint64_t)v91);
  int v95 = 0;
  uint64_t v21 = operator new(0x28uLL);
  *uint64_t v21 = &unk_1F1726810;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__value_func[abi:ne180100]((uint64_t)(v21 + 1), (uint64_t)v93);
  int v95 = v21;
  id v85 = v82;
  uint64_t v22 = (void *)MEMORY[0x1E4F2B370];
  uint64_t v23 = [MEMORY[0x1E4F2B618] secondUnit];
  __n128 v24 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::overallStatistics((uint64_t)v87, v84);
  if (!v95) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v25 = (*(uint64_t (**)(void *, unsigned char *, __n128))(*v95 + 48))(v95, v87, v24);
  int v26 = *(double **)(v25 + 8);
  double v27 = 0.0;
  while (v26 != *(double **)(v25 + 16))
  {
    double v29 = *v26;
    double v28 = v26[1];
    v26 += 2;
    double v27 = v27 + v28 - v29;
  }
  id v30 = [v22 quantityWithUnit:v23 doubleValue:v27 + *(double *)(v25 + 32)];
  [v85 setDuration:v30];

  if (__p)
  {
    uint64_t v90 = __p;
    operator delete(__p);
  }

  __n128 v31 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::overallStatistics((uint64_t)v87, v84);
  if (!v95) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  objc_msgSend(v85, "setDataCount:", *(void *)(*(uint64_t (**)(void *, unsigned char *, __n128))(*v95 + 48))(v95, v87, v31));
  if (__p)
  {
    uint64_t v90 = __p;
    operator delete(__p);
  }
  if (*(unsigned char *)(a1 + 24))
  {
    id v32 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    id v30 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::statisticsByBundleIdentifier((uint64_t)v87, v84);
    for (uint64_t i = v88; i; uint64_t i = (uint64_t **)*i)
    {
      long long v34 = i[2];
      long long v35 = (void *)MEMORY[0x1E4F2B370];
      long long v36 = [MEMORY[0x1E4F2B618] secondUnit];
      if (!v95) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      uint64_t v37 = (*(uint64_t (**)(void *, uint64_t *))(*v95 + 48))(v95, (uint64_t *)i + 3);
      long long v38 = *(double **)(v37 + 8);
      double v39 = 0.0;
      while (v38 != *(double **)(v37 + 16))
      {
        double v41 = *v38;
        double v40 = v38[1];
        v38 += 2;
        double v39 = v39 + v40 - v41;
      }
      uint64_t v42 = [v35 quantityWithUnit:v36 doubleValue:v39 + *(double *)(v37 + 32)];
      [v32 setObject:v42 forKeyedSubscript:v34];

      if (!v95) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      objc_msgSend(NSNumber, "numberWithLongLong:", *(void *)(*(uint64_t (**)(void *, uint64_t *))(*v95 + 48))(v95, (uint64_t *)i + 3));
      v2 = (id *)objc_claimAutoreleasedReturnValue();
      [v30 setObject:v2 forKeyedSubscript:v34];
    }
    std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::~__hash_table((uint64_t)v87);
    [v85 setDurationBySource:v32];
    [v85 setDataCountBySource:v30];
  }
  std::__function::__value_func<HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](v94);
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](v93);
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__value_func[abi:ne180100]((uint64_t)v92, (uint64_t)v91);
  int v95 = 0;
  long long v43 = operator new(0x28uLL);
  void *v43 = &unk_1F17268A0;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__value_func[abi:ne180100]((uint64_t)(v43 + 1), (uint64_t)v92);
  int v95 = v43;
  id v86 = v85;
  __n128 v44 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::overallStatistics((uint64_t)v87, v84);
  if (!v95) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v45 = (*(uint64_t (**)(void *, unsigned char *, __n128))(*v95 + 48))(v95, v87, v44);
  uint64_t v46 = 0;
  double v47 = 0.0;
  uint64_t v48 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v49 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    uint64_t v50 = v45 + v46;
    double v51 = *(double *)(v45 + v46 + 24);
    if (v51 > 2.22507386e-308 && v51 >= v47)
    {
      if (v51 <= v47)
      {
        if (*(void *)(v45 + v46 + 32) < v48)
        {
          uint64_t v49 = *(void *)(v50 + 16);
          double v47 = *(double *)(v45 + v46 + 24);
          uint64_t v48 = *(void *)(v45 + v46 + 32);
        }
      }
      else
      {
        uint64_t v49 = *(void *)(v50 + 16);
        uint64_t v48 = *(void *)(v45 + v46 + 32);
        double v47 = *(double *)(v45 + v46 + 24);
      }
    }
    v46 += 24;
  }
  while (v46 != 144);
  if (__p)
  {
    uint64_t v90 = __p;
    operator delete(__p);
  }
  if (v49 != 0x7FFFFFFFFFFFFFFFLL)
  {
    int v53 = objc_msgSend(NSNumber, "numberWithInteger:", v49, v47);
    [v86 setCategoryValue:v53];
  }
  __n128 v54 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::overallStatistics((uint64_t)v87, v84);
  if (!v95) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  objc_msgSend(v86, "setDataCount:", *(void *)(*(uint64_t (**)(void *, unsigned char *, __n128))(*v95 + 48))(v95, v87, v54));
  if (__p)
  {
    uint64_t v90 = __p;
    operator delete(__p);
  }
  if (*(unsigned char *)(a1 + 24))
  {
    id v55 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    unint64_t v56 = *(uint64_t **)(v84 + 432);
    for (uint64_t j = *(uint64_t **)(v84 + 440); v56 != j; ++v56)
    {
      uint64_t v58 = *v56;
      v2 = (id *)objc_loadWeakRetained((id *)(a1 + 48));
      unint64_t v59 = [v2 sourceForSourceID:v58];

      if (v59 && ([v55 containsObject:v59] & 1) == 0) {
        [v55 addObject:v59];
      }
    }
    long long v60 = (void *)[v55 copy];
    [v86 _setSources:v60];

    id v30 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    id v61 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::statisticsByBundleIdentifier((uint64_t)v87, v84);
    for (k = v88; k; k = (uint64_t **)*k)
    {
      double v63 = k[2];
      if (!v95) {
        goto LABEL_96;
      }
      uint64_t v64 = (*(uint64_t (**)(void *, uint64_t *))(*v95 + 48))(v95, (uint64_t *)k + 3);
      uint64_t v65 = 0;
      double v66 = 0.0;
      uint64_t v67 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v68 = 0x7FFFFFFFFFFFFFFFLL;
      do
      {
        uint64_t v69 = v64 + v65;
        double v70 = *(double *)(v64 + v65 + 24);
        if (v70 > 2.22507386e-308 && v70 >= v66)
        {
          if (v70 <= v66)
          {
            if (*(void *)(v64 + v65 + 32) < v67)
            {
              uint64_t v68 = *(void *)(v69 + 16);
              double v66 = *(double *)(v64 + v65 + 24);
              uint64_t v67 = *(void *)(v64 + v65 + 32);
            }
          }
          else
          {
            uint64_t v68 = *(void *)(v69 + 16);
            uint64_t v67 = *(void *)(v64 + v65 + 32);
            double v66 = *(double *)(v64 + v65 + 24);
          }
        }
        v65 += 24;
      }
      while (v65 != 144);
      if (v68 != 0x7FFFFFFFFFFFFFFFLL)
      {
        __int16 v72 = [NSNumber numberWithInteger:v66];
        [v30 setObject:v72 forKeyedSubscript:v63];
      }
      if (!v95) {
LABEL_96:
      }
        std::__throw_bad_function_call[abi:ne180100]();
      objc_msgSend(NSNumber, "numberWithLongLong:", *(void *)(*(uint64_t (**)(void *, uint64_t *))(*v95 + 48))(v95, (uint64_t *)k + 3));
      v2 = (id *)objc_claimAutoreleasedReturnValue();
      [v61 setObject:v2 forKeyedSubscript:v63];
    }
    std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::~__hash_table((uint64_t)v87);
    [v86 setCategoryValueBySource:v30];
    [v86 setDataCountBySource:v61];
  }
  std::__function::__value_func<HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](v94);
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](v92);

  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](v91);
  uint64_t v73 = [*(id *)(a1 + 16) _unitForChangeInCanonicalUnit];
  int8x16_t v74 = [v86 averageQuantity];
  if (v74)
  {
    id v30 = [v86 averageQuantity];
    if (([v30 isCompatibleWithUnit:v73] & 1) == 0)
    {

LABEL_92:
      [MEMORY[0x1E4F1CA00] raise:*MEMORY[0x1E4F1C3B8], @"Expected compatibility with %@", v73, v82 format];
      goto LABEL_93;
    }
  }
  uint64_t v75 = [v86 minimumQuantity];
  if (v75)
  {
    v2 = [v86 minimumQuantity];
    if (![v2 isCompatibleWithUnit:v73])
    {
      int v76 = 1;
      goto LABEL_86;
    }
  }
  uint64_t v77 = [v86 maximumQuantity];
  if (v77)
  {
    uint64_t v78 = [v86 maximumQuantity];
    int v79 = [v78 isCompatibleWithUnit:v73];

    int v76 = v79 ^ 1;
    if (v75) {
      goto LABEL_86;
    }
  }
  else
  {
    int v76 = 0;
    if (v75)
    {
LABEL_86:

      if (v74) {
        goto LABEL_87;
      }
LABEL_91:

      if (!v76) {
        goto LABEL_93;
      }
      goto LABEL_92;
    }
  }
  if (!v74) {
    goto LABEL_91;
  }
LABEL_87:

  if (v76) {
    goto LABEL_92;
  }
LABEL_93:

  return v86;
}

void sub_1BD174EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *__p,uint64_t a37)
{
  if (v40) {
  if (v38)
  }

  _Unwind_Resume(a1);
}

void HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_updateSourceOrder(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 416);
  uint64_t v2 = *(void *)(a1 + 432);
  if (v1 != (*(void *)(a1 + 440) - v2) >> 3)
  {
    double v4 = (void **)(a1 + 432);
    *(void *)(a1 + 440) = v2;
    std::vector<long long>::reserve((void **)(a1 + 432), v1);
    id v5 = *(void **)(a1 + 408);
    if (v5)
    {
      long long v6 = *(char **)(a1 + 440);
      do
      {
        uint64_t v7 = v5[2];
        unint64_t v8 = *(void *)(a1 + 448);
        if ((unint64_t)v6 >= v8)
        {
          id v10 = (char *)*v4;
          uint64_t v11 = (v6 - (unsigned char *)*v4) >> 3;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 61) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v13 = v8 - (void)v10;
          if (v13 >> 2 > v12) {
            unint64_t v12 = v13 >> 2;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14)
          {
            unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v14);
            id v10 = *(char **)(a1 + 432);
            long long v6 = *(char **)(a1 + 440);
          }
          else
          {
            uint64_t v15 = 0;
          }
          long long v16 = (void *)(v14 + 8 * v11);
          *long long v16 = v7;
          uint64_t v9 = (char *)(v16 + 1);
          while (v6 != v10)
          {
            uint64_t v17 = *((void *)v6 - 1);
            v6 -= 8;
            *--long long v16 = v17;
          }
          *(void *)(a1 + 432) = v16;
          *(void *)(a1 + 440) = v9;
          *(void *)(a1 + 448) = v14 + 8 * v15;
          if (v10) {
            operator delete(v10);
          }
        }
        else
        {
          *(void *)long long v6 = v7;
          uint64_t v9 = v6 + 8;
        }
        *(void *)(a1 + 440) = v9;
        id v5 = (void *)*v5;
        long long v6 = v9;
      }
      while (v5);
    }
    uint64_t v18 = (id *)(a1 + 88);
    id WeakRetained = objc_loadWeakRetained(v18);

    if (WeakRetained)
    {
      id v20 = objc_loadWeakRetained(v18);
      [v20 orderSourceIDs:v4];
    }
  }
}

void sub_1BD175370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeThroughTime(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 16);
  if (v4 > 0.0 && *(double *)(a1 + 8) > a2) {
    a2 = v4 * floor(a2 / v4);
  }
  double v5 = *(double *)(a1 + 56);
  if (v5 < a2)
  {
    long long v121 = (void **)(a1 + 96);
    long long v117 = (double **)(a1 + 64);
    unint64_t v115 = (uint64_t *)(a1 + 120);
    location = (id *)(a1 + 88);
    uint64_t v111 = (double **)(a1 + 296);
    uint64_t v110 = (void *)(a1 + 376);
    while (1)
    {
      unint64_t v6 = *(void *)(a1 + 96);
      uint64_t v7 = *(long long **)(a1 + 104);
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v7 - v6) >> 4);
      if (v8) {
        break;
      }
LABEL_127:
      *(double *)(a1 + 56) = a2;
LABEL_128:
      double v107 = *(double *)(a1 + 56);
      if (v107 == v5)
      {
        uint64_t v108 = [MEMORY[0x1E4F28B00] currentHandler];
        uint64_t v109 = objc_msgSend(NSString, "stringWithUTF8String:", "void HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages, HDStatisticsTimeInterval>>>::_mergeThroughTime(double) [Statistics = HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages, HDStatisticsTimeInterval>>]");
        [v108 handleFailureInFunction:v109 file:@"HDStatisticsBucket.hpp" lineNumber:234 description:@"Failed to make forward progress during statistics merge."];

        double v107 = *(double *)(a1 + 56);
      }
      double v5 = v107;
      if (v107 >= a2) {
        return;
      }
    }
    if (v8 != 1)
    {
      double v17 = a2;
      double v18 = a2;
      double v19 = v5;
      uint64_t v20 = *(void *)(a1 + 96);
      if ((long long *)v6 != v7)
      {
        do
        {
          double v21 = *(double *)(v20 + 8);
          double v22 = *(double *)(v20 + 16);
          if (v21 > v19 && v21 < v18) {
            double v18 = *(double *)(v20 + 8);
          }
          if (v22 > v5) {
            double v24 = *(double *)(v20 + 16);
          }
          else {
            double v24 = v17;
          }
          if (v22 < v17)
          {
            double v19 = v5;
            double v17 = v24;
          }
          v20 += 48;
        }
        while ((long long *)v20 != v7);
      }
      if (v17 >= v18) {
        double v25 = v18;
      }
      else {
        double v25 = v17;
      }
      double v26 = *(double *)(a1 + 16);
      if (v26 > 0.0)
      {
        double v27 = v26 * floor(v25 / v26);
        double v28 = v26 * floor((v26 + v5) / v26);
        if (v27 >= v28) {
          double v25 = v27;
        }
        else {
          double v25 = v28;
        }
      }
      *long long v121 = 0;
      v121[1] = 0;
      v121[2] = 0;
      if ((long long *)v6 != v7)
      {
        if (v8 > 0x555555555555555) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        double v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v8);
        id v32 = *(char **)(a1 + 96);
        __n128 v31 = *(char **)(a1 + 104);
        uint64_t v33 = v29;
        if (v31 != v32)
        {
          do
          {
            long long v34 = *((_OWORD *)v31 - 3);
            long long v35 = *((_OWORD *)v31 - 2);
            *(_OWORD *)(v33 - 21) = *(_OWORD *)(v31 - 21);
            *((_OWORD *)v33 - 3) = v34;
            *((_OWORD *)v33 - 2) = v35;
            v33 -= 48;
            v31 -= 48;
          }
          while (v31 != v32);
          __n128 v31 = (char *)*v121;
        }
        *(void *)(a1 + 96) = v33;
        *(void *)(a1 + 104) = v29;
        *(void *)(a1 + 112) = &v29[48 * v30];
        if (v31) {
          operator delete(v31);
        }
      }
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_updateSourceOrder(a1);
      id WeakRetained = objc_loadWeakRetained(location);

      unint64_t v37 = __clz(v8);
      if (WeakRetained)
      {
        *(void *)&v123.double var0 = a1;
        uint64_t v38 = 126 - 2 * v37;
        if ((long long *)v6 == v7) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = v38;
        }
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*,false>(v6, v7, (uint64_t)&v123, v39, 1);
      }
      else
      {
        uint64_t v42 = 126 - 2 * v37;
        if ((long long *)v6 == v7) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = v42;
        }
      }
      std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*,false>(v6, v7, v39, 1);
      if (*(unsigned char *)(a1 + 25)) {
        id v114 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
      }
      else {
        id v114 = 0;
      }
      int v113 = (void *)v6;
      if ((long long *)v6 == v7)
      {
LABEL_109:
        *(double *)(a1 + 320) = HKIntervalMask<double>::removeIntervalsBefore(v111, v25) + *(double *)(a1 + 320);
        uint64_t v92 = *(void **)(a1 + 368);
        if (v92 != v110)
        {
          do
          {
            *((double *)v92 + 30) = HKIntervalMask<double>::removeIntervalsBefore((double **)v92 + 27, v25)
                                  + *((double *)v92 + 30);
            long long v93 = (void *)v92[1];
            if (v93)
            {
              do
              {
                long long v94 = v93;
                long long v93 = (void *)*v93;
              }
              while (v93);
            }
            else
            {
              do
              {
                long long v94 = (void *)v92[2];
                BOOL v95 = *v94 == (void)v92;
                uint64_t v92 = v94;
              }
              while (!v95);
            }
            uint64_t v92 = v94;
          }
          while (v94 != v110);
        }
        *(double *)(a1 + 56) = v25;

        if (v113) {
          operator delete(v113);
        }
        goto LABEL_128;
      }
      int64_t v116 = 0;
      char v43 = 0;
      unint64_t v44 = v6;
      while (2)
      {
        long long v45 = *(_OWORD *)(v44 + 16);
        *(_OWORD *)&v123.double var0 = *(_OWORD *)v44;
        *(_OWORD *)&v123.var2 = v45;
        *(void *)&v123.BOOL var4 = *(void *)(v44 + 32);
        double var0 = v123.var0;
        uint64_t v47 = v45;
        if (*(double *)&v45 - v123.var1 - (v25 - v123.var1) < 0.01)
        {
          int64_t v48 = 0;
          BOOL var4 = 0;
          BOOL var5 = 0;
          double v51 = 0.0;
          uint64_t v47 = 0;
          if (!v123.var4) {
            goto LABEL_62;
          }
LABEL_57:
          BOOL v119 = var5;
          int64_t v120 = v48;
          HDRawQuantitySample::applyMask((uint64_t)&v123, v117);
          int v52 = *(unsigned __int8 *)(v44 + 42);
          int v53 = *(unsigned __int8 *)(v44 + 41);
          char v118 = *(unsigned char *)(v44 + 40);
          if (!v123.var4) {
            goto LABEL_90;
          }
          if (v43)
          {
            unint64_t var3 = v123.var3;
            if (v116 == v123.var3 || *(unsigned char *)(a1 + 24))
            {
              HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(v115, &v123, v52 == 0);
              int v52 = 1;
            }
          }
          else
          {
            HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(v115, &v123, v52 == 0);
            int v52 = 1;
            unint64_t var3 = v123.var3;
            int64_t v116 = v123.var3;
          }
          if (!*(unsigned char *)(a1 + 25)) {
            goto LABEL_89;
          }
          uint64_t v65 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_bundleIdentifierForSourceID(a1, var3);
          if (!v65) {
            goto LABEL_88;
          }
          double v66 = [v114 objectForKeyedSubscript:v65];
          uint64_t v67 = v66;
          if (v66)
          {
            if ([v66 longLongValue] != var3 && !*(unsigned char *)(a1 + 24))
            {
LABEL_87:

LABEL_88:
LABEL_89:
              char v43 = 1;
LABEL_90:
              if (var4)
              {
                BOOL v80 = v52 != 0;
                id v82 = *(char **)(a1 + 104);
                unint64_t v81 = *(void *)(a1 + 112);
                if ((unint64_t)v82 < v81)
                {
                  *(double *)id v82 = var0;
                  *((double *)v82 + 1) = v51;
                  *((void *)v82 + 2) = v47;
                  *((void *)v82 + 3) = v120;
                  v82[32] = var4;
                  v82[33] = v119;
                  v82[40] = v118;
                  v82[41] = v53;
                  unint64_t v59 = v82 + 48;
                  v82[42] = v80;
                  goto LABEL_107;
                }
                int v76 = (char *)*v121;
                unint64_t v83 = 0xAAAAAAAAAAAAAAABLL * ((v82 - (unsigned char *)*v121) >> 4);
                unint64_t v84 = v83 + 1;
                if (v83 + 1 > 0x555555555555555) {
                  std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
                }
                unint64_t v85 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v81 - (void)v76) >> 4);
                if (2 * v85 > v84) {
                  unint64_t v84 = 2 * v85;
                }
                if (v85 >= 0x2AAAAAAAAAAAAAALL) {
                  unint64_t v86 = 0x555555555555555;
                }
                else {
                  unint64_t v86 = v84;
                }
                if (v86)
                {
                  unint64_t v86 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v86);
                  int v76 = *(char **)(a1 + 96);
                  id v82 = *(char **)(a1 + 104);
                }
                else
                {
                  uint64_t v87 = 0;
                }
                unint64_t v88 = v86 + 48 * v83;
                *(double *)unint64_t v88 = var0;
                *(double *)(v88 + 8) = v51;
                *(void *)(v88 + 16) = v47;
                *(void *)(v88 + 24) = v120;
                *(unsigned char *)(v88 + 32) = var4;
                *(unsigned char *)(v88 + 33) = v119;
                *(unsigned char *)(v88 + 40) = v118;
                *(unsigned char *)(v88 + 41) = v53;
                *(unsigned char *)(v88 + 42) = v80;
                unint64_t v89 = v88;
                if (v82 != v76)
                {
                  do
                  {
                    long long v90 = *((_OWORD *)v82 - 3);
                    long long v91 = *((_OWORD *)v82 - 2);
                    *(_OWORD *)(v89 - 21) = *(_OWORD *)(v82 - 21);
                    *(_OWORD *)(v89 - 48) = v90;
                    *(_OWORD *)(v89 - 32) = v91;
                    v89 -= 48;
                    v82 -= 48;
                  }
                  while (v82 != v76);
                  int v76 = (char *)*v121;
                }
                unint64_t v59 = (_OWORD *)(v88 + 48);
                *(void *)(a1 + 96) = v89;
                *(void *)(a1 + 104) = v88 + 48;
                *(void *)(a1 + 112) = v86 + 48 * v87;
                if (v76) {
LABEL_106:
                }
                  operator delete(v76);
                goto LABEL_107;
              }
              goto LABEL_108;
            }
          }
          else
          {
            uint64_t v77 = [NSNumber numberWithLongLong:var3];
            [v114 setObject:v77 forKeyedSubscript:v65];
          }
          unint64_t v78 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_canonicalSourceIDForSourceID(a1, var3);
          int v79 = (uint64_t *)HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsForSource(a1, v78);
          HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(v79, &v123, v53 == 0);
          LOBYTE(v53) = 1;
          goto LABEL_87;
        }
        if (v25 - v123.var1 < 0.01)
        {
          v123.BOOL var4 = 0;
          goto LABEL_62;
        }
        int64_t v48 = v123.var3;
        BOOL var5 = v123.var5;
        v123.var2 = v25;
        double v51 = v25;
        BOOL var4 = v123.var4;
        if (v123.var4) {
          goto LABEL_57;
        }
LABEL_62:
        id v55 = *(_OWORD **)(a1 + 104);
        unint64_t v56 = *(void *)(a1 + 112);
        if ((unint64_t)v55 < v56)
        {
          long long v57 = *(_OWORD *)v44;
          long long v58 = *(_OWORD *)(v44 + 32);
          v55[1] = *(_OWORD *)(v44 + 16);
          v55[2] = v58;
          *id v55 = v57;
          unint64_t v59 = v55 + 3;
          goto LABEL_107;
        }
        unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * (((char *)v55 - (unsigned char *)*v121) >> 4);
        unint64_t v61 = v60 + 1;
        if (v60 + 1 > 0x555555555555555) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v56 - (void)*v121) >> 4);
        if (2 * v62 > v61) {
          unint64_t v61 = 2 * v62;
        }
        if (v62 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v63 = 0x555555555555555;
        }
        else {
          unint64_t v63 = v61;
        }
        if (v63) {
          unint64_t v63 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v63);
        }
        else {
          uint64_t v64 = 0;
        }
        uint64_t v68 = (_OWORD *)(v63 + 48 * v60);
        long long v69 = *(_OWORD *)v44;
        long long v70 = *(_OWORD *)(v44 + 32);
        v68[1] = *(_OWORD *)(v44 + 16);
        v68[2] = v70;
        *uint64_t v68 = v69;
        __int16 v72 = *(char **)(a1 + 96);
        uint64_t v71 = *(char **)(a1 + 104);
        uint64_t v73 = v68;
        if (v71 != v72)
        {
          do
          {
            long long v74 = *((_OWORD *)v71 - 3);
            long long v75 = *((_OWORD *)v71 - 2);
            *(_OWORD *)((char *)v73 - 21) = *(_OWORD *)(v71 - 21);
            *(v73 - 3) = v74;
            *(v73 - 2) = v75;
            v73 -= 3;
            v71 -= 48;
          }
          while (v71 != v72);
          uint64_t v71 = (char *)*v121;
        }
        unint64_t v59 = v68 + 3;
        *(void *)(a1 + 96) = v73;
        *(void *)(a1 + 104) = v68 + 3;
        *(void *)(a1 + 112) = v63 + 48 * v64;
        if (v71)
        {
          int v76 = v71;
          goto LABEL_106;
        }
LABEL_107:
        *(void *)(a1 + 104) = v59;
LABEL_108:
        v44 += 48;
        if ((long long *)v44 == v7) {
          goto LABEL_109;
        }
        continue;
      }
    }
    double v9 = *(double *)(v6 + 8);
    double v10 = *(double *)(v6 + 16);
    int64_t v11 = *(void *)(v6 + 24);
    char v12 = *(unsigned char *)(v6 + 32);
    char v13 = *(unsigned char *)(v6 + 33);
    if (a2 - v9 >= 0.01)
    {
      if (v10 - v9 - (a2 - v9) < 0.01)
      {
        uint64_t v40 = 0;
        char v41 = 0;
        double v16 = 0.0;
        double v15 = *(double *)(v6 + 16);
        char v14 = *(unsigned char *)(v6 + 32);
        double v10 = 0.0;
        char v12 = 0;
LABEL_120:
        int v96 = *(unsigned __int8 *)(v6 + 42);
        int v97 = *(unsigned __int8 *)(v6 + 41);
        int v98 = *(unsigned __int8 *)(v6 + 40);
        double v99 = *(double *)v6;
        v123.var1 = *(double *)(v6 + 8);
        v123.var2 = v15;
        v123.unint64_t var3 = v11;
        v123.BOOL var4 = v14;
        v123.BOOL var5 = v13;
        *(_DWORD *)(&v123.var5 + 1) = *(_DWORD *)(v6 + 34);
        *(_WORD *)(&v123.var5 + 5) = *(_WORD *)(v6 + 38);
        *((double *)&v124 + 1) = v16;
        *(double *)&long long v125 = v10;
        *((void *)&v125 + 1) = v40;
        LOBYTE(v126) = v12;
        HIBYTE(v126) = v41;
        v123.double var0 = v99;
        *(double *)&long long v124 = v99;
        HDRawQuantitySample::applyMask((uint64_t)&v123, v117);
        BOOL v100 = v98 != 0;
        BOOL v101 = v97 != 0;
        BOOL v102 = v96 != 0;
        if (v123.var4)
        {
          HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(v115, &v123, v96 == 0);
          if (*(unsigned char *)(a1 + 25))
          {
            unint64_t v103 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_canonicalSourceIDForSourceID(a1, v123.var3);
            long long v104 = (uint64_t *)HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsForSource(a1, v103);
            HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(v104, &v123, v97 == 0);
          }
          BOOL v100 = 1;
          BOOL v101 = 1;
          BOOL v102 = 1;
        }
        if ((_BYTE)v126)
        {
          LOWORD(v122) = v126;
          long long v105 = v125;
          int v106 = (char *)*v121;
          *(_OWORD *)int v106 = v124;
          *((_OWORD *)v106 + 1) = v105;
          *((void *)v106 + 4) = v122;
          v106[40] = v100;
          v106[41] = v101;
          v106[42] = v102;
        }
        else
        {
          *(void *)(a1 + 104) = *(void *)(a1 + 96);
        }
        goto LABEL_127;
      }
      double v15 = a2;
      char v14 = *(unsigned char *)(v6 + 32);
      double v16 = a2;
    }
    else
    {
      char v14 = 0;
      double v15 = *(double *)(v6 + 16);
      double v16 = *(double *)(v6 + 8);
    }
    uint64_t v40 = *(void *)(v6 + 24);
    char v41 = *(unsigned char *)(v6 + 33);
    goto LABEL_120;
  }
}

void sub_1BD175CF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t *HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(uint64_t *result, HDRawQuantitySample *a2, int a3)
{
  double v5 = result;
  int v6 = 2 * (a2->var0 != -1.79769313e308);
  if (a2->var0 == 1.79769313e308) {
    int v6 = 1;
  }
  if (!v6)
  {
    if (*(_DWORD *)result) {
      return result;
    }
    ++result;
    if (v5[1]) {
      return result;
    }
    HDStatisticsSleepStages::addSample((HDStatisticsSleepStages *)result, a2, a3);
    uint64_t v7 = v5 + 21;
    goto LABEL_18;
  }
  if (v6 == 1)
  {
    if (*(_DWORD *)result) {
      return result;
    }
    int v10 = 1;
    goto LABEL_15;
  }
  if (v6 != 2) {
    return result;
  }
  if (*(_DWORD *)result != 2)
  {
    int v10 = 2;
LABEL_15:
    *(_DWORD *)BOOL result = v10;
    long long v11 = 0uLL;
    *(_OWORD *)(result + 1) = 0u;
    *(_OWORD *)(result + 3) = 0u;
    *(_OWORD *)(result + 5) = xmmword_1BD330210;
    result[7] = 0;
    *((_OWORD *)result + 4) = xmmword_1BD330220;
    result[10] = 0;
    *(_OWORD *)(result + 11) = xmmword_1BD330230;
    result[13] = 0;
    *((_OWORD *)result + 7) = xmmword_1BD330240;
    result[16] = 0;
    *(_OWORD *)(result + 17) = xmmword_1BD330250;
    result[19] = 0;
    *((_OWORD *)result + 10) = xmmword_1BD330260;
    char v12 = (void *)result[22];
    if (v12)
    {
      v5[23] = (uint64_t)v12;
      operator delete(v12);
      long long v11 = 0uLL;
    }
    *((_OWORD *)v5 + 11) = v11;
    *((_OWORD *)v5 + 12) = v11;
    HDStatisticsSleepStages::addSample((HDStatisticsSleepStages *)(v5 + 1), a2, a3);
    uint64_t v7 = v5 + 21;
LABEL_18:
    unint64_t v8 = a2;
    int v9 = a3;
    goto LABEL_19;
  }
  HDStatisticsSleepStages::addSample((HDStatisticsSleepStages *)(result + 1), a2, 1);
  uint64_t v7 = v5 + 21;
  unint64_t v8 = a2;
  int v9 = 1;
LABEL_19:

  return HDStatisticsTimeInterval::addSample(v7, v8, v9);
}

uint64_t **HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsForSource(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a2;
  id v3 = *(void **)(a1 + 376);
  if (!v3) {
    goto LABEL_11;
  }
  double v4 = (uint64_t **)(a1 + 376);
  do
  {
    uint64_t v5 = v3[4];
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (!v6) {
      double v4 = (uint64_t **)v3;
    }
    id v3 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t **)(a1 + 376) || (uint64_t)v4[4] > a2)
  {
LABEL_11:
    unint64_t v8 = (uint64_t **)(a1 + 368);
    std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 368), a2, &v10);
    double v4 = std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v8, a2, &v10);
  }
  return v4 + 5;
}

unint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_canonicalSourceIDForSourceID(uint64_t a1, unint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));

  if (WeakRetained)
  {
    uint64_t v5 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>((void *)(a1 + 456), a2);
    if (v5)
    {
      return v5[3];
    }
    else
    {
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_bundleIdentifierForSourceID(a1, a2);
      id v6 = (id)objc_claimAutoreleasedReturnValue();
      id v10 = v6;
      uint64_t v7 = (void *)(a1 + 496);
      unint64_t v8 = std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::find<NSString * {__strong}>(v7, &v10);
      if (v8)
      {
        a2 = (unint64_t)v8[3];
      }
      else
      {
        long long v11 = &v10;
        *((void *)std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>((uint64_t)v7, &v10, &v11)+ 3) = a2;
        id v6 = v10;
      }
    }
  }
  return a2;
}

void sub_1BD176084(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

id HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_bundleIdentifierForSourceID(uint64_t a1, unint64_t a2)
{
  unint64_t v12 = a2;
  double v4 = (id *)(a1 + 88);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));

  if (WeakRetained)
  {
    id v6 = (void *)(a1 + 536);
    uint64_t v7 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(v6, a2);
    if (v7)
    {
      id v8 = (id)v7[3];
    }
    else
    {
      id v9 = objc_loadWeakRetained(v4);
      id v8 = [v9 bundleIdentifierForSourceID:a2];

      if (v8)
      {
        id v10 = (id *)std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t)v6, a2, &v12);
        objc_storeStrong(v10 + 3, v8);
      }
    }
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void sub_1BD176168(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, void *a3)
{
  id v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        id v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        id v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    id v9 = (char *)operator new(0x120uLL);
    *((void *)v9 + 4) = *a3;
    *(_OWORD *)(v9 + 72) = 0u;
    *(_OWORD *)(v9 + 88) = 0u;
    *(_OWORD *)(v9 + 120) = 0u;
    *(_OWORD *)(v9 + 136) = 0u;
    *(_OWORD *)(v9 + 168) = 0u;
    *(_OWORD *)(v9 + 184) = 0u;
    *(_OWORD *)(v9 + 200) = 0u;
    *(_OWORD *)(v9 + 40) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    *(_OWORD *)(v9 + 216) = 0u;
    *(_OWORD *)(v9 + 232) = 0u;
    *(_OWORD *)(v9 + 248) = 0u;
    *((void *)v9 + 35) = 0;
    *(_OWORD *)(v9 + 264) = 0u;
    *((_OWORD *)v9 + 5) = xmmword_1BD330210;
    *(_OWORD *)(v9 + 104) = xmmword_1BD330220;
    *((_OWORD *)v9 + 8) = xmmword_1BD330230;
    *(_OWORD *)(v9 + 152) = xmmword_1BD330240;
    *((_OWORD *)v9 + 11) = xmmword_1BD330250;
    *((void *)v9 + 25) = 0x7FFFFFFFFFFFFFFFLL;
    *(_OWORD *)(v9 + 266) = 0u;
    *((_OWORD *)v9 + 15) = 0u;
    *((_OWORD *)v9 + 16) = 0u;
    *((_OWORD *)v9 + 13) = 0u;
    *((_OWORD *)v9 + 14) = 0u;
    std::__tree<unsigned long long>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

void std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*,false>(unint64_t a1, long long *a2, uint64_t a3, uint64_t a4, char a5)
{
  while (2)
  {
    unint64_t v12 = a2 - 3;
    unint64_t v13 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v13;
          uint64_t v14 = (uint64_t)a2 - v13;
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v13) >> 4);
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v103 = *((void *)a2 - 3);
                uint64_t v104 = *(void *)(v13 + 24);
                if (v103 == v104) {
                  return;
                }
                long long v105 = *(char **)(*(void *)a3 + 432);
                int v106 = *(char **)(*(void *)a3 + 440);
                double v107 = v105;
                uint64_t v108 = v105;
                if (v105 == v106) {
                  goto LABEL_171;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)v13, (long long *)(v13 + 48), a2 - 3, a3);
                return;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v13, v13 + 48, v13 + 96, (uint64_t)(a2 - 3), a3);
                return;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v13, v13 + 48, v13 + 96, v13 + 144, (uint64_t)(a2 - 3), a3);
                return;
              default:
                JUMPOUT(0);
            }
            do
            {
              if (*(void *)v108 == v103) {
                goto LABEL_168;
              }
              v108 += 8;
            }
            while (v108 != v106);
            uint64_t v108 = *(char **)(*(void *)a3 + 440);
LABEL_168:
            while (*(void *)v107 != v104)
            {
              v107 += 8;
              if (v107 == v106)
              {
                double v107 = *(char **)(*(void *)a3 + 440);
                break;
              }
            }
LABEL_171:
            if (v108 - v105 < v107 - v105)
            {
              *(_OWORD *)v226 = *(_OWORD *)(v13 + 16);
              *(_OWORD *)&v226[16] = *(_OWORD *)(v13 + 32);
              long long v218 = *(_OWORD *)v13;
              long long v109 = *v12;
              long long v110 = *(a2 - 2);
              *(_OWORD *)(v13 + 27) = *(long long *)((char *)a2 - 21);
              *(_OWORD *)unint64_t v13 = v109;
              *(_OWORD *)(v13 + 16) = v110;
              *(long long *)((char *)a2 - 21) = *(_OWORD *)&v226[11];
              long long *v12 = v218;
              *(a2 - 2) = *(_OWORD *)v226;
            }
            return;
          }
          if (v14 <= 1151)
          {
            uint64_t v111 = (long long *)(v13 + 48);
            BOOL v113 = (long long *)v13 == a2 || v111 == a2;
            if (a5)
            {
              if (!v113)
              {
                unint64_t v114 = v13;
                do
                {
                  unint64_t v115 = v114;
                  unint64_t v114 = (unint64_t)v111;
                  uint64_t v116 = *(void *)(v115 + 72);
                  uint64_t v117 = *(void *)(v115 + 24);
                  if (v116 != v117)
                  {
                    char v118 = *(char **)(*(void *)a3 + 432);
                    BOOL v119 = *(char **)(*(void *)a3 + 440);
                    int64_t v120 = v118;
                    long long v121 = v118;
                    if (v118 != v119)
                    {
                      do
                      {
                        if (*(void *)v121 == v116) {
                          goto LABEL_196;
                        }
                        v121 += 8;
                      }
                      while (v121 != v119);
                      long long v121 = *(char **)(*(void *)a3 + 440);
LABEL_196:
                      while (*(void *)v120 != v117)
                      {
                        v120 += 8;
                        if (v120 == v119)
                        {
                          int64_t v120 = *(char **)(*(void *)a3 + 440);
                          break;
                        }
                      }
                    }
                    if (v121 - v118 < v120 - v118)
                    {
                      uint64_t v227 = *(void *)(v114 + 16);
                      long long v219 = *(_OWORD *)v114;
                      long long v236 = *(_OWORD *)(v115 + 80);
                      unint64_t v122 = v114;
                      while (1)
                      {
                        long long v123 = *(_OWORD *)(v115 + 16);
                        *(_OWORD *)unint64_t v122 = *(_OWORD *)v115;
                        *(_OWORD *)(v122 + 16) = v123;
                        *(_OWORD *)(v122 + 27) = *(_OWORD *)(v115 + 27);
                        if (v115 == v13) {
                          break;
                        }
                        unint64_t v122 = v115;
                        uint64_t v124 = *(void *)(v115 - 24);
                        if (v116 != v124)
                        {
                          long long v125 = *(char **)(*(void *)a3 + 432);
                          __int16 v126 = *(char **)(*(void *)a3 + 440);
                          uint64_t v127 = v125;
                          long long v128 = v125;
                          if (v125 != v126)
                          {
                            do
                            {
                              if (*(void *)v128 == v116) {
                                goto LABEL_208;
                              }
                              v128 += 8;
                            }
                            while (v128 != v126);
                            long long v128 = *(char **)(*(void *)a3 + 440);
LABEL_208:
                            while (*(void *)v127 != v124)
                            {
                              v127 += 8;
                              if (v127 == v126)
                              {
                                uint64_t v127 = *(char **)(*(void *)a3 + 440);
                                break;
                              }
                            }
                          }
                          unint64_t v115 = v122 - 48;
                          if (v128 - v125 < v127 - v125) {
                            continue;
                          }
                        }
                        goto LABEL_212;
                      }
                      unint64_t v122 = v13;
LABEL_212:
                      *(_OWORD *)unint64_t v122 = v219;
                      *(void *)(v122 + 16) = v227;
                      *(void *)(v122 + 24) = v116;
                      *(void *)(v122 + 32) = v236;
                      *(_DWORD *)(v122 + 39) = *(_DWORD *)((char *)&v236 + 7);
                    }
                  }
                  uint64_t v111 = (long long *)(v114 + 48);
                }
                while ((long long *)(v114 + 48) != a2);
              }
            }
            else if (!v113)
            {
              do
              {
                unint64_t v201 = a1;
                a1 = (unint64_t)v111;
                uint64_t v202 = *(void *)(v201 + 72);
                uint64_t v203 = *(void *)(v201 + 24);
                if (v202 != v203)
                {
                  v204 = *(char **)(*(void *)a3 + 432);
                  v205 = *(char **)(*(void *)a3 + 440);
                  v206 = v204;
                  v207 = v204;
                  if (v204 != v205)
                  {
                    do
                    {
                      if (*(void *)v207 == v202) {
                        goto LABEL_312;
                      }
                      v207 += 8;
                    }
                    while (v207 != v205);
                    v207 = *(char **)(*(void *)a3 + 440);
LABEL_312:
                    while (*(void *)v206 != v203)
                    {
                      v206 += 8;
                      if (v206 == v205)
                      {
                        v206 = *(char **)(*(void *)a3 + 440);
                        break;
                      }
                    }
                  }
                  if (v207 - v204 < v206 - v204)
                  {
                    uint64_t v230 = *(void *)(a1 + 16);
                    long long v222 = *(_OWORD *)a1;
                    long long v239 = *(_OWORD *)(v201 + 80);
                    unint64_t v208 = a1;
                    do
                    {
                      v209 = (_OWORD *)v208;
                      unint64_t v208 = v201;
                      long long v210 = *(_OWORD *)(v201 + 16);
                      _OWORD *v209 = *(_OWORD *)v201;
                      v209[1] = v210;
                      *(_OWORD *)((char *)v209 + 27) = *(_OWORD *)(v201 + 27);
                      uint64_t v211 = *(void *)(v201 - 24);
                      if (v202 == v211) {
                        break;
                      }
                      v212 = *(char **)(*(void *)a3 + 432);
                      v213 = *(char **)(*(void *)a3 + 440);
                      v214 = v212;
                      v215 = v212;
                      if (v212 != v213)
                      {
                        do
                        {
                          if (*(void *)v215 == v202) {
                            goto LABEL_322;
                          }
                          v215 += 8;
                        }
                        while (v215 != v213);
                        v215 = *(char **)(*(void *)a3 + 440);
LABEL_322:
                        while (*(void *)v214 != v211)
                        {
                          v214 += 8;
                          if (v214 == v213)
                          {
                            v214 = *(char **)(*(void *)a3 + 440);
                            break;
                          }
                        }
                      }
                      unint64_t v201 = v208 - 48;
                    }
                    while (v215 - v212 < v214 - v212);
                    *(_OWORD *)unint64_t v208 = v222;
                    *(void *)(v208 + 16) = v230;
                    *(void *)(v208 + 24) = v202;
                    *(void *)(v208 + 32) = v239;
                    *(_DWORD *)(v208 + 39) = *(_DWORD *)((char *)&v239 + 7);
                  }
                }
                uint64_t v111 = (long long *)(a1 + 48);
              }
              while ((long long *)(a1 + 48) != a2);
            }
            return;
          }
          if (!a4)
          {
            if ((long long *)v13 != a2)
            {
              int64_t v129 = (v15 - 2) >> 1;
              int64_t v130 = v129;
              do
              {
                int64_t v131 = v130;
                if (v129 >= v130)
                {
                  uint64_t v132 = (2 * v130) | 1;
                  unint64_t v133 = v13 + 48 * v132;
                  if (2 * v131 + 2 < (uint64_t)v15)
                  {
                    uint64_t v134 = *(void *)(v133 + 24);
                    uint64_t v135 = *(void *)(v133 + 72);
                    if (v134 != v135)
                    {
                      v137 = *(char **)(*(void *)a3 + 432);
                      v136 = *(char **)(*(void *)a3 + 440);
                      v138 = v137;
                      v139 = v137;
                      if (v137 != v136)
                      {
                        do
                        {
                          if (*(void *)v139 == v134) {
                            goto LABEL_224;
                          }
                          v139 += 8;
                        }
                        while (v139 != v136);
                        v139 = *(char **)(*(void *)a3 + 440);
LABEL_224:
                        while (*(void *)v138 != v135)
                        {
                          v138 += 8;
                          if (v138 == v136)
                          {
                            v138 = *(char **)(*(void *)a3 + 440);
                            break;
                          }
                        }
                      }
                      v133 += 48 * (v139 - v137 < v138 - v137);
                      if (v139 - v137 < v138 - v137) {
                        uint64_t v132 = 2 * v131 + 2;
                      }
                    }
                  }
                  unint64_t v140 = v13 + 48 * v131;
                  uint64_t v141 = *(void *)(v133 + 24);
                  uint64_t v142 = *(void *)(v140 + 24);
                  if (v141 == v142) {
                    goto LABEL_238;
                  }
                  v144 = *(char **)(*(void *)a3 + 432);
                  v143 = *(char **)(*(void *)a3 + 440);
                  v145 = v144;
                  v146 = v144;
                  if (v144 != v143)
                  {
                    do
                    {
                      if (*(void *)v146 == v141) {
                        goto LABEL_234;
                      }
                      v146 += 8;
                    }
                    while (v146 != v143);
                    v146 = *(char **)(*(void *)a3 + 440);
LABEL_234:
                    while (*(void *)v145 != v142)
                    {
                      v145 += 8;
                      if (v145 == v143)
                      {
                        v145 = *(char **)(*(void *)a3 + 440);
                        break;
                      }
                    }
                  }
                  if (v146 - v144 >= v145 - v144)
                  {
LABEL_238:
                    uint64_t v228 = *(void *)(v140 + 16);
                    long long v220 = *(_OWORD *)v140;
                    long long v237 = *(_OWORD *)(v140 + 32);
                    long long v147 = *(_OWORD *)v133;
                    long long v148 = *(_OWORD *)(v133 + 16);
                    *(_OWORD *)(v140 + 27) = *(_OWORD *)(v133 + 27);
                    *(_OWORD *)unint64_t v140 = v147;
                    *(_OWORD *)(v140 + 16) = v148;
                    if (v129 >= v132)
                    {
                      while (1)
                      {
                        uint64_t v150 = 2 * v132;
                        uint64_t v132 = (2 * v132) | 1;
                        unint64_t v149 = v13 + 48 * v132;
                        uint64_t v151 = v150 + 2;
                        if (v151 < (uint64_t)v15)
                        {
                          uint64_t v152 = *(void *)(v149 + 24);
                          uint64_t v153 = *(void *)(v149 + 72);
                          if (v152 != v153)
                          {
                            v154 = *(char **)(*(void *)a3 + 432);
                            v155 = *(char **)(*(void *)a3 + 440);
                            v156 = v154;
                            v157 = v154;
                            if (v154 != v155)
                            {
                              do
                              {
                                if (*(void *)v157 == v152) {
                                  goto LABEL_246;
                                }
                                v157 += 8;
                              }
                              while (v157 != v155);
                              v157 = *(char **)(*(void *)a3 + 440);
LABEL_246:
                              while (*(void *)v156 != v153)
                              {
                                v156 += 8;
                                if (v156 == v155)
                                {
                                  v156 = *(char **)(*(void *)a3 + 440);
                                  break;
                                }
                              }
                            }
                            v149 += 48 * (v157 - v154 < v156 - v154);
                            if (v157 - v154 < v156 - v154) {
                              uint64_t v132 = v151;
                            }
                          }
                        }
                        uint64_t v158 = *(void *)(v149 + 24);
                        if (v158 != v142)
                        {
                          v160 = *(char **)(*(void *)a3 + 432);
                          v159 = *(char **)(*(void *)a3 + 440);
                          v161 = v160;
                          v162 = v160;
                          if (v160 != v159)
                          {
                            do
                            {
                              if (*(void *)v162 == v158) {
                                goto LABEL_256;
                              }
                              v162 += 8;
                            }
                            while (v162 != v159);
                            v162 = *(char **)(*(void *)a3 + 440);
LABEL_256:
                            while (*(void *)v161 != v142)
                            {
                              v161 += 8;
                              if (v161 == v159)
                              {
                                v161 = *(char **)(*(void *)a3 + 440);
                                break;
                              }
                            }
                          }
                          if (v162 - v160 < v161 - v160) {
                            break;
                          }
                        }
                        long long v163 = *(_OWORD *)v149;
                        long long v164 = *(_OWORD *)(v149 + 16);
                        *(_OWORD *)(v133 + 27) = *(_OWORD *)(v149 + 27);
                        *(_OWORD *)unint64_t v133 = v163;
                        *(_OWORD *)(v133 + 16) = v164;
                        unint64_t v133 = v149;
                        if (v129 < v132) {
                          goto LABEL_261;
                        }
                      }
                    }
                    unint64_t v149 = v133;
LABEL_261:
                    *(_OWORD *)unint64_t v149 = v220;
                    *(void *)(v149 + 16) = v228;
                    *(void *)(v149 + 24) = v142;
                    *(void *)(v149 + 32) = v237;
                    *(_DWORD *)(v149 + 39) = *(_DWORD *)((char *)&v237 + 7);
                  }
                }
                int64_t v130 = v131 - 1;
              }
              while (v131);
              int64_t v165 = v14 / 0x30uLL;
              do
              {
                uint64_t v166 = 0;
                *(_OWORD *)v229 = *(_OWORD *)(v13 + 16);
                *(_OWORD *)&v229[16] = *(_OWORD *)(v13 + 32);
                long long v221 = *(_OWORD *)v13;
                uint64_t v167 = v165 - 2;
                if (v165 < 2) {
                  uint64_t v167 = v165 - 1;
                }
                uint64_t v168 = v167 >> 1;
                unint64_t v169 = v13;
                do
                {
                  v170 = (_OWORD *)v169;
                  v169 += 48 * v166 + 48;
                  uint64_t v171 = 2 * v166;
                  uint64_t v166 = (2 * v166) | 1;
                  uint64_t v172 = v171 + 2;
                  if (v171 + 2 < v165)
                  {
                    uint64_t v173 = *(void *)(v169 + 24);
                    uint64_t v174 = *(void *)(v169 + 72);
                    if (v173 != v174)
                    {
                      v176 = *(char **)(*(void *)a3 + 432);
                      v175 = *(char **)(*(void *)a3 + 440);
                      v177 = v176;
                      v178 = v176;
                      if (v176 != v175)
                      {
                        do
                        {
                          if (*(void *)v178 == v173) {
                            goto LABEL_273;
                          }
                          v178 += 8;
                        }
                        while (v178 != v175);
                        v178 = *(char **)(*(void *)a3 + 440);
LABEL_273:
                        while (*(void *)v177 != v174)
                        {
                          v177 += 8;
                          if (v177 == v175)
                          {
                            v177 = *(char **)(*(void *)a3 + 440);
                            break;
                          }
                        }
                      }
                      v169 += 48 * (v178 - v176 < v177 - v176);
                      if (v178 - v176 < v177 - v176) {
                        uint64_t v166 = v172;
                      }
                    }
                  }
                  long long v179 = *(_OWORD *)v169;
                  long long v180 = *(_OWORD *)(v169 + 16);
                  *(_OWORD *)((char *)v170 + 27) = *(_OWORD *)(v169 + 27);
                  _OWORD *v170 = v179;
                  v170[1] = v180;
                }
                while (v166 <= v168);
                a2 -= 3;
                if ((long long *)v169 == a2)
                {
                  *(_OWORD *)(v169 + 27) = *(_OWORD *)&v229[11];
                  *(_OWORD *)unint64_t v169 = v221;
                  *(_OWORD *)(v169 + 16) = *(_OWORD *)v229;
                }
                else
                {
                  long long v181 = *a2;
                  long long v182 = a2[1];
                  *(_OWORD *)(v169 + 27) = *(long long *)((char *)a2 + 27);
                  *(_OWORD *)unint64_t v169 = v181;
                  *(_OWORD *)(v169 + 16) = v182;
                  *(long long *)((char *)a2 + 27) = *(_OWORD *)&v229[11];
                  *a2 = v221;
                  a2[1] = *(_OWORD *)v229;
                  uint64_t v183 = v169 - v13 + 48;
                  if (v183 >= 49)
                  {
                    unint64_t v184 = (v183 / 0x30uLL - 2) >> 1;
                    unint64_t v185 = v13 + 48 * v184;
                    uint64_t v186 = *(void *)(v185 + 24);
                    uint64_t v187 = *(void *)(v169 + 24);
                    if (v186 != v187)
                    {
                      v189 = *(char **)(*(void *)a3 + 432);
                      v188 = *(char **)(*(void *)a3 + 440);
                      v190 = v189;
                      v191 = v189;
                      if (v189 != v188)
                      {
                        do
                        {
                          if (*(void *)v191 == v186) {
                            goto LABEL_286;
                          }
                          v191 += 8;
                        }
                        while (v191 != v188);
                        v191 = *(char **)(*(void *)a3 + 440);
LABEL_286:
                        while (*(void *)v190 != v187)
                        {
                          v190 += 8;
                          if (v190 == v188)
                          {
                            v190 = *(char **)(*(void *)a3 + 440);
                            break;
                          }
                        }
                      }
                      if (v191 - v189 < v190 - v189)
                      {
                        uint64_t v242 = *(void *)(v169 + 16);
                        long long v238 = *(_OWORD *)v169;
                        long long v233 = *(_OWORD *)(v169 + 32);
                        do
                        {
                          v192 = (_OWORD *)v169;
                          unint64_t v169 = v185;
                          long long v193 = *(_OWORD *)v185;
                          long long v194 = *(_OWORD *)(v185 + 16);
                          *(_OWORD *)((char *)v192 + 27) = *(_OWORD *)(v185 + 27);
                          _OWORD *v192 = v193;
                          v192[1] = v194;
                          if (!v184) {
                            break;
                          }
                          unint64_t v184 = (v184 - 1) >> 1;
                          unint64_t v185 = v13 + 48 * v184;
                          uint64_t v195 = *(void *)(v185 + 24);
                          if (v195 == v187) {
                            break;
                          }
                          v197 = *(char **)(*(void *)a3 + 432);
                          v196 = *(char **)(*(void *)a3 + 440);
                          v198 = v197;
                          v199 = v197;
                          if (v197 != v196)
                          {
                            do
                            {
                              if (*(void *)v199 == v195) {
                                goto LABEL_297;
                              }
                              v199 += 8;
                            }
                            while (v199 != v196);
                            v199 = *(char **)(*(void *)a3 + 440);
LABEL_297:
                            while (*(void *)v198 != v187)
                            {
                              v198 += 8;
                              if (v198 == v196)
                              {
                                v198 = *(char **)(*(void *)a3 + 440);
                                break;
                              }
                            }
                          }
                        }
                        while (v199 - v197 < v198 - v197);
                        *(_OWORD *)unint64_t v169 = v238;
                        *(void *)(v169 + 16) = v242;
                        *(void *)(v169 + 24) = v187;
                        *(void *)(v169 + 32) = v233;
                        *(_DWORD *)(v169 + 39) = *(_DWORD *)((char *)&v233 + 7);
                      }
                    }
                  }
                }
              }
              while (v165-- > 2);
            }
            return;
          }
          unint64_t v16 = v15 >> 1;
          double v17 = (long long *)(v13 + 48 * (v15 >> 1));
          if ((unint64_t)v14 >= 0x1801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48 * (v15 >> 1)), a2 - 3, a3);
            uint64_t v18 = 3 * v16;
            double v19 = (long long *)(a1 + 48 * v16 - 48);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48), v19, a2 - 6, a3);
            uint64_t v20 = (long long *)(a1 + 48 + 16 * v18);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 96), v20, a2 - 9, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v19, v17, v20, a3);
            *(_OWORD *)v223 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&v223[16] = *(_OWORD *)(a1 + 32);
            long long v216 = *(_OWORD *)a1;
            long long v21 = *(long long *)((char *)v17 + 27);
            long long v22 = v17[1];
            *(_OWORD *)a1 = *v17;
            *(_OWORD *)(a1 + 16) = v22;
            *(_OWORD *)(a1 + 27) = v21;
            *(long long *)((char *)v17 + 27) = *(_OWORD *)&v223[11];
            *double v17 = v216;
            v17[1] = *(_OWORD *)v223;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48 * (v15 >> 1)), (long long *)a1, a2 - 3, a3);
          }
          --a4;
          if (a5)
          {
            uint64_t v23 = *(void *)(a1 + 24);
            uint64_t v24 = *(void *)a3;
            break;
          }
          uint64_t v25 = *(void *)(a1 - 24);
          uint64_t v23 = *(void *)(a1 + 24);
          if (v25 != v23)
          {
            uint64_t v24 = *(void *)a3;
            double v26 = *(char **)(*(void *)a3 + 432);
            double v27 = *(char **)(*(void *)a3 + 440);
            double v28 = v26;
            double v29 = v26;
            if (v26 != v27)
            {
              do
              {
                if (*(void *)v29 == v25) {
                  goto LABEL_16;
                }
                v29 += 8;
              }
              while (v29 != v27);
              double v29 = *(char **)(*(void *)a3 + 440);
LABEL_16:
              while (*(void *)v28 != v23)
              {
                v28 += 8;
                if (v28 == v27)
                {
                  double v28 = *(char **)(*(void *)a3 + 440);
                  break;
                }
              }
            }
            if (v29 - v26 < v28 - v26) {
              break;
            }
          }
          uint64_t v241 = *(void *)(a1 + 16);
          long long v232 = *(_OWORD *)(a1 + 32);
          long long v235 = *(_OWORD *)a1;
          uint64_t v67 = *((void *)a2 - 3);
          if (v23 == v67) {
            goto LABEL_107;
          }
          uint64_t v68 = *(char **)(*(void *)a3 + 432);
          long long v69 = *(char **)(*(void *)a3 + 440);
          if (v68 == v69)
          {
            uint64_t v71 = *(char **)(*(void *)a3 + 432);
            long long v70 = v71;
          }
          else
          {
            long long v70 = *(char **)(*(void *)a3 + 432);
            while (*(void *)v70 != v23)
            {
              v70 += 8;
              if (v70 == v69)
              {
                long long v70 = *(char **)(*(void *)a3 + 440);
                break;
              }
            }
            uint64_t v71 = *(char **)(*(void *)a3 + 432);
            while (*(void *)v71 != v67)
            {
              v71 += 8;
              if (v71 == v69)
              {
                uint64_t v71 = *(char **)(*(void *)a3 + 440);
                break;
              }
            }
          }
          if (v70 - v68 >= v71 - v68)
          {
LABEL_107:
            unint64_t v13 = a1 + 48;
            if (a1 + 48 < (unint64_t)a2)
            {
              uint64_t v75 = *(void *)a3;
              unint64_t v76 = a1;
              do
              {
                uint64_t v77 = *(void *)(v76 + 72);
                unint64_t v76 = v13;
                if (v23 != v77)
                {
                  unint64_t v78 = *(char **)(v75 + 432);
                  int v79 = *(char **)(v75 + 440);
                  BOOL v80 = v78;
                  unint64_t v81 = v78;
                  if (v78 != v79)
                  {
                    do
                    {
                      if (*(void *)v81 == v23) {
                        goto LABEL_114;
                      }
                      v81 += 8;
                    }
                    while (v81 != v79);
                    unint64_t v81 = *(char **)(v75 + 440);
LABEL_114:
                    while (*(void *)v80 != v77)
                    {
                      v80 += 8;
                      if (v80 == v79)
                      {
                        BOOL v80 = *(char **)(v75 + 440);
                        break;
                      }
                    }
                  }
                  if (v81 - v78 < v80 - v78) {
                    break;
                  }
                }
                v13 += 48;
              }
              while (v76 + 48 < (unint64_t)a2);
            }
          }
          else
          {
            unint64_t v13 = a1;
            do
            {
              do
              {
                uint64_t v72 = *(void *)(v13 + 72);
                v13 += 48;
              }
              while (v23 == v72);
              if (v68 == v69)
              {
                long long v74 = *(char **)(*(void *)a3 + 432);
                uint64_t v73 = v74;
              }
              else
              {
                uint64_t v73 = *(char **)(*(void *)a3 + 432);
                while (*(void *)v73 != v23)
                {
                  v73 += 8;
                  if (v73 == v69)
                  {
                    uint64_t v73 = *(char **)(*(void *)a3 + 440);
                    break;
                  }
                }
                long long v74 = *(char **)(*(void *)a3 + 432);
                while (*(void *)v74 != v72)
                {
                  v74 += 8;
                  if (v74 == v69)
                  {
                    long long v74 = *(char **)(*(void *)a3 + 440);
                    break;
                  }
                }
              }
            }
            while (v73 - v68 >= v74 - v68);
          }
          id v82 = a2;
          if (v13 < (unint64_t)a2)
          {
            uint64_t v83 = *(void *)a3;
            id v82 = a2;
            do
            {
              uint64_t v84 = *((void *)v82 - 3);
              v82 -= 3;
              if (v23 == v84) {
                break;
              }
              unint64_t v85 = *(char **)(v83 + 432);
              unint64_t v86 = *(char **)(v83 + 440);
              uint64_t v87 = v85;
              unint64_t v88 = v85;
              if (v85 != v86)
              {
                do
                {
                  if (*(void *)v88 == v23) {
                    goto LABEL_126;
                  }
                  v88 += 8;
                }
                while (v88 != v86);
                unint64_t v88 = *(char **)(v83 + 440);
LABEL_126:
                while (*(void *)v87 != v84)
                {
                  v87 += 8;
                  if (v87 == v86)
                  {
                    uint64_t v87 = *(char **)(v83 + 440);
                    break;
                  }
                }
              }
            }
            while (v88 - v85 < v87 - v85);
          }
          while (v13 < (unint64_t)v82)
          {
            *(_OWORD *)v225 = *(_OWORD *)(v13 + 16);
            *(_OWORD *)&v225[16] = *(_OWORD *)(v13 + 32);
            long long v217 = *(_OWORD *)v13;
            long long v89 = *v82;
            long long v90 = v82[1];
            *(_OWORD *)(v13 + 27) = *(long long *)((char *)v82 + 27);
            *(_OWORD *)unint64_t v13 = v89;
            *(_OWORD *)(v13 + 16) = v90;
            *(long long *)((char *)v82 + 27) = *(_OWORD *)&v225[11];
            *id v82 = v217;
            v82[1] = *(_OWORD *)v225;
            uint64_t v91 = *(void *)a3;
            do
            {
              do
              {
                uint64_t v92 = *(void *)(v13 + 72);
                v13 += 48;
              }
              while (v23 == v92);
              long long v93 = *(char **)(v91 + 432);
              long long v94 = *(char **)(v91 + 440);
              if (v93 == v94)
              {
                int v96 = *(char **)(v91 + 432);
                BOOL v95 = v96;
              }
              else
              {
                BOOL v95 = *(char **)(v91 + 432);
                while (*(void *)v95 != v23)
                {
                  v95 += 8;
                  if (v95 == v94)
                  {
                    BOOL v95 = *(char **)(v91 + 440);
                    break;
                  }
                }
                int v96 = *(char **)(v91 + 432);
                while (*(void *)v96 != v92)
                {
                  v96 += 8;
                  if (v96 == v94)
                  {
                    int v96 = *(char **)(v91 + 440);
                    break;
                  }
                }
              }
            }
            while (v95 - v93 >= v96 - v93);
            do
            {
              uint64_t v97 = *((void *)v82 - 3);
              v82 -= 3;
              if (v23 == v97) {
                break;
              }
              if (v93 == v94)
              {
                double v99 = v93;
                int v98 = v93;
              }
              else
              {
                int v98 = v93;
                while (*(void *)v98 != v23)
                {
                  v98 += 8;
                  if (v98 == v94)
                  {
                    int v98 = v94;
                    break;
                  }
                }
                double v99 = v93;
                while (*(void *)v99 != v97)
                {
                  v99 += 8;
                  if (v99 == v94)
                  {
                    double v99 = v94;
                    break;
                  }
                }
              }
            }
            while (v98 - v93 < v99 - v93);
          }
          BOOL v100 = (long long *)(v13 - 48);
          BOOL v5 = v13 - 48 >= a1;
          BOOL v6 = v13 - 48 == a1;
          if (v13 - 48 != a1)
          {
            long long v101 = *v100;
            long long v102 = *(_OWORD *)(v13 - 32);
            *(_OWORD *)(a1 + 27) = *(_OWORD *)(v13 - 21);
            *(_OWORD *)a1 = v101;
            *(_OWORD *)(a1 + 16) = v102;
          }
          a5 = 0;
          *BOOL v100 = v235;
          *(void *)(v13 - 32) = v241;
          *(void *)(v13 - 24) = v23;
          *(_DWORD *)(v13 - 9) = *(_DWORD *)((char *)&v232 + 7);
          *(void *)(v13 - 16) = v232;
        }
        uint64_t v240 = *(void *)(a1 + 16);
        long long v231 = *(_OWORD *)(a1 + 32);
        long long v234 = *(_OWORD *)a1;
        unint64_t v30 = a1;
        do
        {
          unint64_t v31 = v30;
          v30 += 48;
          uint64_t v32 = *(void *)(v31 + 72);
          if (v32 == v23) {
            break;
          }
          uint64_t v33 = *(char **)(v24 + 432);
          long long v34 = *(char **)(v24 + 440);
          long long v35 = v33;
          long long v36 = v33;
          if (v33 != v34)
          {
            do
            {
              if (*(void *)v36 == v32) {
                goto LABEL_26;
              }
              v36 += 8;
            }
            while (v36 != v34);
            long long v36 = *(char **)(v24 + 440);
LABEL_26:
            while (*(void *)v35 != v23)
            {
              v35 += 8;
              if (v35 == v34)
              {
                long long v35 = *(char **)(v24 + 440);
                break;
              }
            }
          }
        }
        while (v36 - v33 < v35 - v33);
        unint64_t v37 = a2;
        if (v31 == a1)
        {
          unint64_t v37 = a2;
          if (v30 < (unint64_t)a2)
          {
            unint64_t v37 = a2;
            do
            {
              uint64_t v43 = *((void *)v37 - 3);
              v37 -= 3;
              if (v43 != v23)
              {
                unint64_t v44 = *(char **)(v24 + 432);
                long long v45 = *(char **)(v24 + 440);
                uint64_t v46 = v44;
                uint64_t v47 = v44;
                if (v44 != v45)
                {
                  do
                  {
                    if (*(void *)v47 == v43) {
                      goto LABEL_48;
                    }
                    v47 += 8;
                  }
                  while (v47 != v45);
                  uint64_t v47 = *(char **)(v24 + 440);
LABEL_48:
                  while (*(void *)v46 != v23)
                  {
                    v46 += 8;
                    if (v46 == v45)
                    {
                      uint64_t v46 = *(char **)(v24 + 440);
                      break;
                    }
                  }
                }
                if (v47 - v44 < v46 - v44) {
                  break;
                }
              }
            }
            while (v30 < (unint64_t)v37);
          }
        }
        else
        {
          do
          {
            do
            {
              uint64_t v38 = *((void *)v37 - 3);
              v37 -= 3;
            }
            while (v38 == v23);
            uint64_t v39 = *(char **)(v24 + 432);
            uint64_t v40 = *(char **)(v24 + 440);
            char v41 = v39;
            uint64_t v42 = v39;
            if (v39 != v40)
            {
              do
              {
                if (*(void *)v42 == v38) {
                  goto LABEL_36;
                }
                v42 += 8;
              }
              while (v42 != v40);
              uint64_t v42 = *(char **)(v24 + 440);
LABEL_36:
              while (*(void *)v41 != v23)
              {
                v41 += 8;
                if (v41 == v40)
                {
                  char v41 = *(char **)(v24 + 440);
                  break;
                }
              }
            }
          }
          while (v42 - v39 >= v41 - v39);
        }
        unint64_t v13 = v30;
        if (v30 < (unint64_t)v37)
        {
          int64_t v48 = v37;
          do
          {
            *(_OWORD *)v224 = *(_OWORD *)(v13 + 16);
            *(_OWORD *)&v224[16] = *(_OWORD *)(v13 + 32);
            long long v49 = *(_OWORD *)v13;
            long long v51 = *v48;
            long long v50 = v48[1];
            *(_OWORD *)(v13 + 27) = *(long long *)((char *)v48 + 27);
            *(_OWORD *)unint64_t v13 = v51;
            *(_OWORD *)(v13 + 16) = v50;
            *(long long *)((char *)v48 + 27) = *(_OWORD *)&v224[11];
            *int64_t v48 = v49;
            v48[1] = *(_OWORD *)v224;
            uint64_t v52 = *(void *)a3;
            do
            {
              uint64_t v53 = *(void *)(v13 + 72);
              v13 += 48;
              if (v53 == v23) {
                break;
              }
              __n128 v54 = *(char **)(v52 + 432);
              id v55 = *(char **)(v52 + 440);
              unint64_t v56 = v54;
              long long v57 = v54;
              if (v54 != v55)
              {
                do
                {
                  if (*(void *)v57 == v53) {
                    goto LABEL_61;
                  }
                  v57 += 8;
                }
                while (v57 != v55);
                long long v57 = *(char **)(v52 + 440);
LABEL_61:
                while (*(void *)v56 != v23)
                {
                  v56 += 8;
                  if (v56 == v55)
                  {
                    unint64_t v56 = *(char **)(v52 + 440);
                    break;
                  }
                }
              }
            }
            while (v57 - v54 < v56 - v54);
            do
            {
              do
              {
                uint64_t v58 = *((void *)v48 - 3);
                v48 -= 3;
              }
              while (v58 == v23);
              unint64_t v59 = *(char **)(v52 + 432);
              unint64_t v60 = *(char **)(v52 + 440);
              unint64_t v61 = v59;
              unint64_t v62 = v59;
              if (v59 != v60)
              {
                do
                {
                  if (*(void *)v62 == v58) {
                    goto LABEL_70;
                  }
                  v62 += 8;
                }
                while (v62 != v60);
                unint64_t v62 = *(char **)(v52 + 440);
LABEL_70:
                while (*(void *)v61 != v23)
                {
                  v61 += 8;
                  if (v61 == v60)
                  {
                    unint64_t v61 = *(char **)(v52 + 440);
                    break;
                  }
                }
              }
            }
            while (v62 - v59 >= v61 - v59);
          }
          while (v13 < (unint64_t)v48);
        }
        unint64_t v63 = (long long *)(v13 - 48);
        if (v13 - 48 != a1)
        {
          long long v64 = *v63;
          long long v65 = *(_OWORD *)(v13 - 32);
          *(_OWORD *)(a1 + 27) = *(_OWORD *)(v13 - 21);
          *(_OWORD *)a1 = v64;
          *(_OWORD *)(a1 + 16) = v65;
        }
        long long *v63 = v234;
        *(void *)(v13 - 32) = v240;
        *(void *)(v13 - 24) = v23;
        *(_DWORD *)(v13 - 9) = *(_DWORD *)((char *)&v231 + 7);
        *(void *)(v13 - 16) = v231;
        if (v30 >= (unint64_t)v37) {
          break;
        }
LABEL_80:
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*,false>(a1, v13 - 48, a3, a4, a5 & 1);
        a5 = 0;
      }
      BOOL v66 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, v13 - 48, a3);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v13, (uint64_t)a2, a3))
      {
        break;
      }
      if (!v66) {
        goto LABEL_80;
      }
    }
    a2 = (long long *)(v13 - 48);
    if (!v66) {
      continue;
    }
    break;
  }
}

__n128 std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(long long *a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = *((void *)a2 + 3);
  uint64_t v5 = *((void *)a1 + 3);
  if (v4 == v5) {
    goto LABEL_23;
  }
  BOOL v6 = *(char **)(*(void *)a4 + 432);
  uint64_t v7 = *(char **)(*(void *)a4 + 440);
  if (v6 == v7)
  {
    id v9 = *(char **)(*(void *)a4 + 432);
    uint64_t v8 = v9;
  }
  else
  {
    uint64_t v8 = *(char **)(*(void *)a4 + 432);
    while (*(void *)v8 != v4)
    {
      v8 += 8;
      if (v8 == v7)
      {
        uint64_t v8 = *(char **)(*(void *)a4 + 440);
        break;
      }
    }
    id v9 = *(char **)(*(void *)a4 + 432);
    while (*(void *)v9 != v5)
    {
      v9 += 8;
      if (v9 == v7)
      {
        id v9 = *(char **)(*(void *)a4 + 440);
        break;
      }
    }
  }
  if (v8 - v6 >= v9 - v6)
  {
LABEL_23:
    uint64_t v13 = *((void *)a3 + 3);
    if (v13 != v4)
    {
      uint64_t v14 = *(char **)(*(void *)a4 + 432);
      unint64_t v15 = *(char **)(*(void *)a4 + 440);
      unint64_t v16 = v14;
      double v17 = v14;
      if (v14 != v15)
      {
        do
        {
          if (*(void *)v17 == v13) {
            goto LABEL_28;
          }
          v17 += 8;
        }
        while (v17 != v15);
        double v17 = *(char **)(*(void *)a4 + 440);
LABEL_28:
        while (*(void *)v16 != v4)
        {
          v16 += 8;
          if (v16 == v15)
          {
            unint64_t v16 = *(char **)(*(void *)a4 + 440);
            break;
          }
        }
      }
      if (v17 - v14 < v16 - v14)
      {
        long long v18 = *a2;
        *(_OWORD *)uint64_t v46 = a2[1];
        *(_OWORD *)&v46[16] = a2[2];
        long long v19 = *(long long *)((char *)a3 + 27);
        long long v20 = a3[1];
        *a2 = *a3;
        a2[1] = v20;
        *(long long *)((char *)a2 + 27) = v19;
        *a3 = v18;
        a3[1] = *(_OWORD *)v46;
        __n128 result = *(__n128 *)&v46[11];
        *(long long *)((char *)a3 + 27) = *(_OWORD *)&v46[11];
        uint64_t v22 = *((void *)a2 + 3);
        uint64_t v23 = *((void *)a1 + 3);
        if (v22 != v23)
        {
          uint64_t v24 = *(char **)(*(void *)a4 + 432);
          uint64_t v25 = *(char **)(*(void *)a4 + 440);
          double v26 = v24;
          double v27 = v24;
          if (v24 != v25)
          {
            do
            {
              if (*(void *)v27 == v22) {
                goto LABEL_37;
              }
              v27 += 8;
            }
            while (v27 != v25);
            double v27 = *(char **)(*(void *)a4 + 440);
LABEL_37:
            while (*(void *)v26 != v23)
            {
              v26 += 8;
              if (v26 == v25)
              {
                double v26 = *(char **)(*(void *)a4 + 440);
                break;
              }
            }
          }
          if (v27 - v24 < v26 - v24)
          {
            long long v28 = *a1;
            *(_OWORD *)uint64_t v47 = a1[1];
            *(_OWORD *)&v47[16] = a1[2];
            long long v29 = *(long long *)((char *)a2 + 27);
            long long v30 = a2[1];
            *a1 = *a2;
            a1[1] = v30;
            *(long long *)((char *)a1 + 27) = v29;
            *a2 = v28;
            a2[1] = *(_OWORD *)v47;
            __n128 result = *(__n128 *)&v47[11];
            *(long long *)((char *)a2 + 27) = *(_OWORD *)&v47[11];
          }
        }
      }
    }
  }
  else
  {
    uint64_t v10 = *((void *)a3 + 3);
    if (v10 != v4)
    {
      if (v6 == v7)
      {
        unint64_t v12 = *(char **)(*(void *)a4 + 432);
        long long v11 = v12;
      }
      else
      {
        long long v11 = *(char **)(*(void *)a4 + 432);
        while (*(void *)v11 != v10)
        {
          v11 += 8;
          if (v11 == v7)
          {
            long long v11 = *(char **)(*(void *)a4 + 440);
            break;
          }
        }
        unint64_t v12 = *(char **)(*(void *)a4 + 432);
        while (*(void *)v12 != v4)
        {
          v12 += 8;
          if (v12 == v7)
          {
            unint64_t v12 = *(char **)(*(void *)a4 + 440);
            break;
          }
        }
      }
      if (v11 - v6 < v12 - v6)
      {
        long long v31 = a1[1];
        long long v32 = *a1;
        *(void *)long long v49 = *((void *)&v31 + 1);
        *(_OWORD *)&v49[8] = a1[2];
        long long v33 = *(long long *)((char *)a3 + 27);
        long long v34 = a3[1];
        *a1 = *a3;
        a1[1] = v34;
        *(long long *)((char *)a1 + 27) = v33;
LABEL_55:
        *a3 = v32;
        a3[1] = v31;
        __n128 result = *(__n128 *)&v49[3];
        *(long long *)((char *)a3 + 27) = *(_OWORD *)&v49[3];
        return result;
      }
    }
    long long v35 = *a1;
    *(_OWORD *)int64_t v48 = a1[1];
    *(_OWORD *)&v48[16] = a1[2];
    long long v36 = *(long long *)((char *)a2 + 27);
    long long v37 = a2[1];
    *a1 = *a2;
    a1[1] = v37;
    *(long long *)((char *)a1 + 27) = v36;
    *a2 = v35;
    a2[1] = *(_OWORD *)v48;
    __n128 result = *(__n128 *)&v48[11];
    *(long long *)((char *)a2 + 27) = *(_OWORD *)&v48[11];
    uint64_t v38 = *((void *)a3 + 3);
    uint64_t v39 = *((void *)a2 + 3);
    if (v38 != v39)
    {
      uint64_t v40 = *(char **)(*(void *)a4 + 432);
      char v41 = *(char **)(*(void *)a4 + 440);
      uint64_t v42 = v40;
      uint64_t v43 = v40;
      if (v40 != v41)
      {
        do
        {
          if (*(void *)v43 == v38) {
            goto LABEL_50;
          }
          v43 += 8;
        }
        while (v43 != v41);
        uint64_t v43 = *(char **)(*(void *)a4 + 440);
LABEL_50:
        while (*(void *)v42 != v39)
        {
          v42 += 8;
          if (v42 == v41)
          {
            uint64_t v42 = *(char **)(*(void *)a4 + 440);
            break;
          }
        }
      }
      if (v43 - v40 < v42 - v40)
      {
        long long v31 = a2[1];
        long long v32 = *a2;
        *(void *)long long v49 = *((void *)&v31 + 1);
        *(_OWORD *)&v49[8] = a2[2];
        long long v44 = *(long long *)((char *)a3 + 27);
        long long v45 = a3[1];
        *a2 = *a3;
        a2[1] = v45;
        *(long long *)((char *)a2 + 27) = v44;
        goto LABEL_55;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = *(void *)(a2 - 24);
      uint64_t v9 = *(void *)(a1 + 24);
      if (v8 == v9) {
        return result;
      }
      uint64_t v10 = *(char **)(*(void *)a3 + 432);
      long long v11 = *(char **)(*(void *)a3 + 440);
      unint64_t v12 = v10;
      uint64_t v13 = v10;
      if (v10 == v11) {
        goto LABEL_10;
      }
      do
      {
        if (*(void *)v13 == v8) {
          goto LABEL_7;
        }
        v13 += 8;
      }
      while (v13 != v11);
      uint64_t v13 = *(char **)(*(void *)a3 + 440);
      do
      {
LABEL_7:
        if (*(void *)v12 == v9) {
          goto LABEL_10;
        }
        v12 += 8;
      }
      while (v12 != v11);
      unint64_t v12 = *(char **)(*(void *)a3 + 440);
LABEL_10:
      if (v13 - v10 < v12 - v10)
      {
        uint64_t v14 = (long long *)(a2 - 48);
        long long v15 = *(_OWORD *)a1;
        *(_OWORD *)long long v35 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v35[16] = *(_OWORD *)(a1 + 32);
        long long v16 = *(_OWORD *)(a2 - 21);
        long long v17 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a1 + 16) = v17;
        *(_OWORD *)(a1 + 27) = v16;
        long long *v14 = v15;
        v14[1] = *(_OWORD *)v35;
        *(long long *)((char *)v14 + 27) = *(_OWORD *)&v35[11];
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a2 - 48), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a2 - 48, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a1 + 144, a2 - 48, a3);
      return 1;
    default:
      uint64_t v18 = a1 + 96;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a1 + 96), a3);
      uint64_t v19 = a1 + 144;
      if (a1 + 144 == a2) {
        return 1;
      }
      int v20 = 0;
      break;
  }
  while (1)
  {
    uint64_t v21 = *(void *)(v19 + 24);
    uint64_t v22 = *(void *)(v18 + 24);
    if (v21 != v22)
    {
      uint64_t v23 = *(char **)(*(void *)a3 + 432);
      uint64_t v24 = *(char **)(*(void *)a3 + 440);
      uint64_t v25 = v23;
      double v26 = v23;
      if (v23 != v24)
      {
        do
        {
          if (*(void *)v26 == v21) {
            goto LABEL_19;
          }
          v26 += 8;
        }
        while (v26 != v24);
        double v26 = *(char **)(*(void *)a3 + 440);
LABEL_19:
        while (*(void *)v25 != v22)
        {
          v25 += 8;
          if (v25 == v24)
          {
            uint64_t v25 = *(char **)(*(void *)a3 + 440);
            break;
          }
        }
      }
      if (v26 - v23 < v25 - v23)
      {
        long long v34 = *(_OWORD *)v19;
        uint64_t v36 = *(void *)(v19 + 16);
        long long v37 = *(_OWORD *)(v19 + 32);
        uint64_t v27 = v19;
        while (1)
        {
          long long v28 = *(_OWORD *)(v18 + 16);
          *(_OWORD *)uint64_t v27 = *(_OWORD *)v18;
          *(_OWORD *)(v27 + 16) = v28;
          *(_OWORD *)(v27 + 27) = *(_OWORD *)(v18 + 27);
          if (v18 == a1) {
            break;
          }
          uint64_t v27 = v18;
          uint64_t v29 = *(void *)(v18 - 24);
          if (v21 != v29)
          {
            long long v30 = *(char **)(*(void *)a3 + 432);
            long long v31 = *(char **)(*(void *)a3 + 440);
            long long v32 = v30;
            long long v33 = v30;
            if (v30 != v31)
            {
              do
              {
                if (*(void *)v33 == v21) {
                  goto LABEL_30;
                }
                v33 += 8;
              }
              while (v33 != v31);
              long long v33 = *(char **)(*(void *)a3 + 440);
LABEL_30:
              while (*(void *)v32 != v29)
              {
                v32 += 8;
                if (v32 == v31)
                {
                  long long v32 = *(char **)(*(void *)a3 + 440);
                  break;
                }
              }
            }
            v18 -= 48;
            if (v33 - v30 < v32 - v30) {
              continue;
            }
          }
          goto LABEL_36;
        }
        uint64_t v27 = a1;
LABEL_36:
        *(_OWORD *)uint64_t v27 = v34;
        *(void *)(v27 + 16) = v36;
        *(void *)(v27 + 24) = v21;
        *(void *)(v27 + 32) = v37;
        *(_DWORD *)(v27 + 39) = *(_DWORD *)((char *)&v37 + 7);
        if (++v20 == 8) {
          return v19 + 48 == a2;
        }
      }
    }
    uint64_t v18 = v19;
    v19 += 48;
    if (v19 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  result.n128_u64[0] = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)a2, (long long *)a3, a5).n128_u64[0];
  uint64_t v11 = *(void *)(a4 + 24);
  uint64_t v12 = *(void *)(a3 + 24);
  if (v11 != v12)
  {
    uint64_t v13 = *(char **)(*(void *)a5 + 432);
    uint64_t v14 = *(char **)(*(void *)a5 + 440);
    long long v15 = v13;
    long long v16 = v13;
    if (v13 != v14)
    {
      do
      {
        if (*(void *)v16 == v11) {
          goto LABEL_6;
        }
        v16 += 8;
      }
      while (v16 != v14);
      long long v16 = *(char **)(*(void *)a5 + 440);
LABEL_6:
      while (*(void *)v15 != v12)
      {
        v15 += 8;
        if (v15 == v14)
        {
          long long v15 = *(char **)(*(void *)a5 + 440);
          break;
        }
      }
    }
    if (v16 - v13 < v15 - v13)
    {
      long long v17 = *(_OWORD *)a3;
      *(_OWORD *)uint64_t v38 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)&v38[16] = *(_OWORD *)(a3 + 32);
      long long v18 = *(_OWORD *)(a4 + 27);
      long long v19 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)(a3 + 16) = v19;
      *(_OWORD *)(a3 + 27) = v18;
      *(_OWORD *)a4 = v17;
      *(_OWORD *)(a4 + 16) = *(_OWORD *)v38;
      __n128 result = *(__n128 *)&v38[11];
      *(_OWORD *)(a4 + 27) = *(_OWORD *)&v38[11];
      uint64_t v20 = *(void *)(a3 + 24);
      uint64_t v21 = *(void *)(a2 + 24);
      if (v20 != v21)
      {
        uint64_t v22 = *(char **)(*(void *)a5 + 432);
        uint64_t v23 = *(char **)(*(void *)a5 + 440);
        uint64_t v24 = v22;
        uint64_t v25 = v22;
        if (v22 != v23)
        {
          do
          {
            if (*(void *)v25 == v20) {
              goto LABEL_15;
            }
            v25 += 8;
          }
          while (v25 != v23);
          uint64_t v25 = *(char **)(*(void *)a5 + 440);
LABEL_15:
          while (*(void *)v24 != v21)
          {
            v24 += 8;
            if (v24 == v23)
            {
              uint64_t v24 = *(char **)(*(void *)a5 + 440);
              break;
            }
          }
        }
        if (v25 - v22 < v24 - v22)
        {
          long long v26 = *(_OWORD *)a2;
          *(_OWORD *)uint64_t v39 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)&v39[16] = *(_OWORD *)(a2 + 32);
          long long v27 = *(_OWORD *)(a3 + 27);
          long long v28 = *(_OWORD *)(a3 + 16);
          *(_OWORD *)a2 = *(_OWORD *)a3;
          *(_OWORD *)(a2 + 16) = v28;
          *(_OWORD *)(a2 + 27) = v27;
          *(_OWORD *)a3 = v26;
          *(_OWORD *)(a3 + 16) = *(_OWORD *)v39;
          __n128 result = *(__n128 *)&v39[11];
          *(_OWORD *)(a3 + 27) = *(_OWORD *)&v39[11];
          uint64_t v29 = *(void *)(a2 + 24);
          uint64_t v30 = *(void *)(a1 + 24);
          if (v29 != v30)
          {
            long long v31 = *(char **)(*(void *)a5 + 432);
            long long v32 = *(char **)(*(void *)a5 + 440);
            long long v33 = v31;
            long long v34 = v31;
            if (v31 != v32)
            {
              do
              {
                if (*(void *)v34 == v29) {
                  goto LABEL_24;
                }
                v34 += 8;
              }
              while (v34 != v32);
              long long v34 = *(char **)(*(void *)a5 + 440);
LABEL_24:
              while (*(void *)v33 != v30)
              {
                v33 += 8;
                if (v33 == v32)
                {
                  long long v33 = *(char **)(*(void *)a5 + 440);
                  break;
                }
              }
            }
            if (v34 - v31 < v33 - v31)
            {
              long long v35 = *(_OWORD *)a1;
              *(_OWORD *)uint64_t v40 = *(_OWORD *)(a1 + 16);
              *(_OWORD *)&v40[16] = *(_OWORD *)(a1 + 32);
              long long v36 = *(_OWORD *)(a2 + 27);
              long long v37 = *(_OWORD *)(a2 + 16);
              *(_OWORD *)a1 = *(_OWORD *)a2;
              *(_OWORD *)(a1 + 16) = v37;
              *(_OWORD *)(a1 + 27) = v36;
              *(_OWORD *)a2 = v35;
              *(_OWORD *)(a2 + 16) = *(_OWORD *)v40;
              __n128 result = *(__n128 *)&v40[11];
              *(_OWORD *)(a2 + 27) = *(_OWORD *)&v40[11];
            }
          }
        }
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  result.n128_u64[0] = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a2, a3, a4, a6).n128_u64[0];
  uint64_t v13 = *(void *)(a5 + 24);
  uint64_t v14 = *(void *)(a4 + 24);
  if (v13 != v14)
  {
    long long v15 = *(char **)(*(void *)a6 + 432);
    long long v16 = *(char **)(*(void *)a6 + 440);
    long long v17 = v15;
    long long v18 = v15;
    if (v15 != v16)
    {
      do
      {
        if (*(void *)v18 == v13) {
          goto LABEL_6;
        }
        v18 += 8;
      }
      while (v18 != v16);
      long long v18 = *(char **)(*(void *)a6 + 440);
LABEL_6:
      while (*(void *)v17 != v14)
      {
        v17 += 8;
        if (v17 == v16)
        {
          long long v17 = *(char **)(*(void *)a6 + 440);
          break;
        }
      }
    }
    if (v18 - v15 < v17 - v15)
    {
      long long v19 = *(_OWORD *)a4;
      *(_OWORD *)long long v49 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)&v49[16] = *(_OWORD *)(a4 + 32);
      long long v20 = *(_OWORD *)(a5 + 27);
      long long v21 = *(_OWORD *)(a5 + 16);
      *(_OWORD *)a4 = *(_OWORD *)a5;
      *(_OWORD *)(a4 + 16) = v21;
      *(_OWORD *)(a4 + 27) = v20;
      *(_OWORD *)a5 = v19;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)v49;
      __n128 result = *(__n128 *)&v49[11];
      *(_OWORD *)(a5 + 27) = *(_OWORD *)&v49[11];
      uint64_t v22 = *(void *)(a4 + 24);
      uint64_t v23 = *(void *)(a3 + 24);
      if (v22 != v23)
      {
        uint64_t v24 = *(char **)(*(void *)a6 + 432);
        uint64_t v25 = *(char **)(*(void *)a6 + 440);
        long long v26 = v24;
        long long v27 = v24;
        if (v24 != v25)
        {
          do
          {
            if (*(void *)v27 == v22) {
              goto LABEL_15;
            }
            v27 += 8;
          }
          while (v27 != v25);
          long long v27 = *(char **)(*(void *)a6 + 440);
LABEL_15:
          while (*(void *)v26 != v23)
          {
            v26 += 8;
            if (v26 == v25)
            {
              long long v26 = *(char **)(*(void *)a6 + 440);
              break;
            }
          }
        }
        if (v27 - v24 < v26 - v24)
        {
          long long v28 = *(_OWORD *)a3;
          *(_OWORD *)long long v50 = *(_OWORD *)(a3 + 16);
          *(_OWORD *)&v50[16] = *(_OWORD *)(a3 + 32);
          long long v29 = *(_OWORD *)(a4 + 27);
          long long v30 = *(_OWORD *)(a4 + 16);
          *(_OWORD *)a3 = *(_OWORD *)a4;
          *(_OWORD *)(a3 + 16) = v30;
          *(_OWORD *)(a3 + 27) = v29;
          *(_OWORD *)a4 = v28;
          *(_OWORD *)(a4 + 16) = *(_OWORD *)v50;
          __n128 result = *(__n128 *)&v50[11];
          *(_OWORD *)(a4 + 27) = *(_OWORD *)&v50[11];
          uint64_t v31 = *(void *)(a3 + 24);
          uint64_t v32 = *(void *)(a2 + 24);
          if (v31 != v32)
          {
            long long v33 = *(char **)(*(void *)a6 + 432);
            long long v34 = *(char **)(*(void *)a6 + 440);
            long long v35 = v33;
            long long v36 = v33;
            if (v33 != v34)
            {
              do
              {
                if (*(void *)v36 == v31) {
                  goto LABEL_24;
                }
                v36 += 8;
              }
              while (v36 != v34);
              long long v36 = *(char **)(*(void *)a6 + 440);
LABEL_24:
              while (*(void *)v35 != v32)
              {
                v35 += 8;
                if (v35 == v34)
                {
                  long long v35 = *(char **)(*(void *)a6 + 440);
                  break;
                }
              }
            }
            if (v36 - v33 < v35 - v33)
            {
              long long v37 = *(_OWORD *)a2;
              *(_OWORD *)long long v51 = *(_OWORD *)(a2 + 16);
              *(_OWORD *)&v51[16] = *(_OWORD *)(a2 + 32);
              long long v38 = *(_OWORD *)(a3 + 27);
              long long v39 = *(_OWORD *)(a3 + 16);
              *(_OWORD *)a2 = *(_OWORD *)a3;
              *(_OWORD *)(a2 + 16) = v39;
              *(_OWORD *)(a2 + 27) = v38;
              *(_OWORD *)a3 = v37;
              *(_OWORD *)(a3 + 16) = *(_OWORD *)v51;
              __n128 result = *(__n128 *)&v51[11];
              *(_OWORD *)(a3 + 27) = *(_OWORD *)&v51[11];
              uint64_t v40 = *(void *)(a2 + 24);
              uint64_t v41 = *(void *)(a1 + 24);
              if (v40 != v41)
              {
                uint64_t v42 = *(char **)(*(void *)a6 + 432);
                uint64_t v43 = *(char **)(*(void *)a6 + 440);
                long long v44 = v42;
                long long v45 = v42;
                if (v42 != v43)
                {
                  do
                  {
                    if (*(void *)v45 == v40) {
                      goto LABEL_33;
                    }
                    v45 += 8;
                  }
                  while (v45 != v43);
                  long long v45 = *(char **)(*(void *)a6 + 440);
LABEL_33:
                  while (*(void *)v44 != v41)
                  {
                    v44 += 8;
                    if (v44 == v43)
                    {
                      long long v44 = *(char **)(*(void *)a6 + 440);
                      break;
                    }
                  }
                }
                if (v45 - v42 < v44 - v42)
                {
                  long long v46 = *(_OWORD *)a1;
                  *(_OWORD *)uint64_t v52 = *(_OWORD *)(a1 + 16);
                  *(_OWORD *)&v52[16] = *(_OWORD *)(a1 + 32);
                  long long v47 = *(_OWORD *)(a2 + 27);
                  long long v48 = *(_OWORD *)(a2 + 16);
                  *(_OWORD *)a1 = *(_OWORD *)a2;
                  *(_OWORD *)(a1 + 16) = v48;
                  *(_OWORD *)(a1 + 27) = v47;
                  *(_OWORD *)a2 = v46;
                  *(_OWORD *)(a2 + 16) = *(_OWORD *)v52;
                  __n128 result = *(__n128 *)&v52[11];
                  *(_OWORD *)(a2 + 27) = *(_OWORD *)&v52[11];
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*,false>(unint64_t a1, long long *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 4);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*((double *)a2 - 5) < *(double *)(v10 + 8))
                {
                  *(_OWORD *)char v118 = *(_OWORD *)(v10 + 16);
                  *(_OWORD *)&v118[16] = *(_OWORD *)(v10 + 32);
                  long long v110 = *(_OWORD *)v10;
                  long long v52 = *(a2 - 3);
                  long long v53 = *(a2 - 2);
                  *(_OWORD *)(v10 + 27) = *(long long *)((char *)a2 - 21);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 16) = v53;
                  *(long long *)((char *)a2 - 21) = *(_OWORD *)&v118[11];
                  *(a2 - 3) = v110;
                  *(a2 - 2) = *(_OWORD *)v118;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)v10, (long long *)(v10 + 48), a2 - 3);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v10, v10 + 48, v10 + 96, (uint64_t)(a2 - 3));
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v10, v10 + 48, v10 + 96, v10 + 144, (uint64_t)(a2 - 3));
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 1151)
          {
            __n128 v54 = (long long *)(v10 + 48);
            BOOL v56 = (long long *)v10 == a2 || v54 == a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  unint64_t v59 = v54;
                  double v60 = *(double *)(v58 + 56);
                  if (v60 < *(double *)(v58 + 8))
                  {
                    uint64_t v61 = *(void *)v54;
                    *(_OWORD *)uint64_t v111 = *(_OWORD *)(v58 + 64);
                    *(_OWORD *)&v111[16] = *(_OWORD *)(v58 + 80);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      unint64_t v63 = (_OWORD *)(v10 + v62);
                      long long v64 = *(_OWORD *)(v10 + v62 + 16);
                      v63[3] = *(_OWORD *)(v10 + v62);
                      v63[4] = v64;
                      *(_OWORD *)((char *)v63 + 75) = *(_OWORD *)(v10 + v62 + 27);
                      if (!v62) {
                        break;
                      }
                      v62 -= 48;
                      if (v60 >= *((double *)v63 - 5))
                      {
                        uint64_t v65 = v10 + v62 + 48;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_81:
                    *(void *)uint64_t v65 = v61;
                    *(double *)(v65 + 8) = v60;
                    *(_OWORD *)(v65 + 16) = *(_OWORD *)v111;
                    *(_OWORD *)(v65 + 27) = *(_OWORD *)&v111[11];
                  }
                  __n128 v54 = v59 + 3;
                  v57 += 48;
                  unint64_t v58 = (unint64_t)v59;
                }
                while (v59 + 3 != a2);
              }
            }
            else if (!v56)
            {
              do
              {
                int v98 = v54;
                double v99 = *(double *)(a1 + 56);
                if (v99 < *(double *)(a1 + 8))
                {
                  uint64_t v100 = *(void *)v54;
                  *(_OWORD *)unint64_t v114 = *(_OWORD *)(a1 + 64);
                  *(_OWORD *)&v114[16] = *(_OWORD *)(a1 + 80);
                  long long v101 = v54;
                  do
                  {
                    long long v102 = *(v101 - 2);
                    long long *v101 = *(v101 - 3);
                    v101[1] = v102;
                    *(long long *)((char *)v101 + 27) = *(long long *)((char *)v101 - 21);
                    double v103 = *((double *)v101 - 11);
                    v101 -= 3;
                  }
                  while (v99 < v103);
                  *(void *)long long v101 = v100;
                  *((double *)v101 + 1) = v99;
                  *(long long *)((char *)v101 + 27) = *(_OWORD *)&v114[11];
                  v101[1] = *(_OWORD *)v114;
                }
                v54 += 3;
                a1 = (unint64_t)v98;
              }
              while (v98 + 3 != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((long long *)v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 48 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)(v70 + 8) < *(double *)(v70 + 56))
                  {
                    v70 += 48;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  unint64_t v71 = v10 + 48 * v68;
                  double v72 = *(double *)(v71 + 8);
                  if (*(double *)(v70 + 8) >= v72)
                  {
                    uint64_t v73 = *(void *)v71;
                    *(_OWORD *)uint64_t v112 = *(_OWORD *)(v71 + 16);
                    *(_OWORD *)&v112[16] = *(_OWORD *)(v71 + 32);
                    do
                    {
                      long long v74 = (_OWORD *)v71;
                      unint64_t v71 = v70;
                      long long v75 = *(_OWORD *)v70;
                      long long v76 = *(_OWORD *)(v70 + 16);
                      *(_OWORD *)((char *)v74 + 27) = *(_OWORD *)(v70 + 27);
                      *long long v74 = v75;
                      v74[1] = v76;
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v77 = 2 * v69;
                      uint64_t v69 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 48 * v69;
                      uint64_t v78 = v77 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v70 + 8) < *(double *)(v70 + 56))
                      {
                        v70 += 48;
                        uint64_t v69 = v78;
                      }
                    }
                    while (*(double *)(v70 + 8) >= v72);
                    *(void *)unint64_t v71 = v73;
                    *(double *)(v71 + 8) = v72;
                    *(_OWORD *)(v71 + 16) = *(_OWORD *)v112;
                    *(_OWORD *)(v71 + 27) = *(_OWORD *)&v112[11];
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              int64_t v79 = v11 / 0x30uLL;
              do
              {
                uint64_t v80 = 0;
                *(_OWORD *)BOOL v119 = *(_OWORD *)(v10 + 16);
                *(_OWORD *)&v119[16] = *(_OWORD *)(v10 + 32);
                long long v113 = *(_OWORD *)v10;
                unint64_t v81 = v10;
                do
                {
                  id v82 = (_OWORD *)v81;
                  v81 += 48 * v80 + 48;
                  uint64_t v83 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  int64_t v84 = v83 + 2;
                  if (v84 < v79 && *(double *)(v81 + 8) < *(double *)(v81 + 56))
                  {
                    v81 += 48;
                    uint64_t v80 = v84;
                  }
                  long long v85 = *(_OWORD *)v81;
                  long long v86 = *(_OWORD *)(v81 + 16);
                  *(_OWORD *)((char *)v82 + 27) = *(_OWORD *)(v81 + 27);
                  *id v82 = v85;
                  v82[1] = v86;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 3;
                if ((long long *)v81 == a2)
                {
                  *(_OWORD *)(v81 + 27) = *(_OWORD *)&v119[11];
                  *(_OWORD *)unint64_t v81 = v113;
                  *(_OWORD *)(v81 + 16) = *(_OWORD *)v119;
                }
                else
                {
                  long long v87 = *a2;
                  long long v88 = a2[1];
                  *(_OWORD *)(v81 + 27) = *(long long *)((char *)a2 + 27);
                  *(_OWORD *)unint64_t v81 = v87;
                  *(_OWORD *)(v81 + 16) = v88;
                  *(long long *)((char *)a2 + 27) = *(_OWORD *)&v119[11];
                  *a2 = v113;
                  a2[1] = *(_OWORD *)v119;
                  uint64_t v89 = v81 - v10 + 48;
                  if (v89 >= 49)
                  {
                    unint64_t v90 = (v89 / 0x30uLL - 2) >> 1;
                    unint64_t v91 = v10 + 48 * v90;
                    double v92 = *(double *)(v81 + 8);
                    if (*(double *)(v91 + 8) < v92)
                    {
                      uint64_t v93 = *(void *)v81;
                      *(_OWORD *)int v106 = *(_OWORD *)(v81 + 16);
                      *(_OWORD *)&v106[16] = *(_OWORD *)(v81 + 32);
                      do
                      {
                        long long v94 = (_OWORD *)v81;
                        unint64_t v81 = v91;
                        long long v95 = *(_OWORD *)v91;
                        long long v96 = *(_OWORD *)(v91 + 16);
                        *(_OWORD *)((char *)v94 + 27) = *(_OWORD *)(v91 + 27);
                        *long long v94 = v95;
                        v94[1] = v96;
                        if (!v90) {
                          break;
                        }
                        unint64_t v90 = (v90 - 1) >> 1;
                        unint64_t v91 = v10 + 48 * v90;
                      }
                      while (*(double *)(v91 + 8) < v92);
                      *(void *)unint64_t v81 = v93;
                      *(double *)(v81 + 8) = v92;
                      *(_OWORD *)(v81 + 16) = *(_OWORD *)v106;
                      *(_OWORD *)(v81 + 27) = *(_OWORD *)&v106[11];
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (long long *)(v10 + 48 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x1801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48 * (v12 >> 1)), a2 - 3);
            uint64_t v15 = 3 * v13;
            long long v16 = (long long *)(a1 + 48 * v13 - 48);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48), v16, a2 - 6);
            long long v17 = (long long *)(a1 + 48 + 16 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 96), v17, a2 - 9);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v16, v14, v17);
            *(_OWORD *)unint64_t v115 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&v115[16] = *(_OWORD *)(a1 + 32);
            long long v107 = *(_OWORD *)a1;
            long long v18 = *(long long *)((char *)v14 + 27);
            long long v19 = v14[1];
            *(_OWORD *)a1 = *v14;
            *(_OWORD *)(a1 + 16) = v19;
            *(_OWORD *)(a1 + 27) = v18;
            *(long long *)((char *)v14 + 27) = *(_OWORD *)&v115[11];
            long long *v14 = v107;
            v14[1] = *(_OWORD *)v115;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48 * (v12 >> 1)), (long long *)a1, a2 - 3);
          }
          --a3;
          if (a4) {
            break;
          }
          double v20 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 40) < v20) {
            goto LABEL_12;
          }
          uint64_t v38 = *(void *)a1;
          *(_OWORD *)long long v105 = *(_OWORD *)(a1 + 16);
          *(_OWORD *)&v105[16] = *(_OWORD *)(a1 + 32);
          if (v20 >= *((double *)a2 - 5))
          {
            unint64_t v41 = a1 + 48;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= (unint64_t)a2) {
                break;
              }
              double v42 = *(double *)(v41 + 8);
              v41 += 48;
            }
            while (v20 >= v42);
          }
          else
          {
            unint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 48;
              double v40 = *(double *)(v39 + 56);
              v39 += 48;
            }
            while (v20 >= v40);
          }
          uint64_t v43 = a2;
          if (v10 < (unint64_t)a2)
          {
            long long v44 = a2;
            do
            {
              uint64_t v43 = v44 - 3;
              double v45 = *((double *)v44 - 5);
              v44 -= 3;
            }
            while (v20 < v45);
          }
          while (v10 < (unint64_t)v43)
          {
            *(_OWORD *)uint64_t v117 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)&v117[16] = *(_OWORD *)(v10 + 32);
            long long v109 = *(_OWORD *)v10;
            long long v46 = *v43;
            long long v47 = v43[1];
            *(_OWORD *)(v10 + 27) = *(long long *)((char *)v43 + 27);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(long long *)((char *)v43 + 27) = *(_OWORD *)&v117[11];
            long long *v43 = v109;
            v43[1] = *(_OWORD *)v117;
            do
            {
              double v48 = *(double *)(v10 + 56);
              v10 += 48;
            }
            while (v20 >= v48);
            do
            {
              double v49 = *((double *)v43 - 5);
              v43 -= 3;
            }
            while (v20 < v49);
          }
          BOOL v4 = v10 - 48 >= a1;
          BOOL v5 = v10 - 48 == a1;
          if (v10 - 48 != a1)
          {
            long long v50 = *(_OWORD *)(v10 - 48);
            long long v51 = *(_OWORD *)(v10 - 32);
            *(_OWORD *)(a1 + 27) = *(_OWORD *)(v10 - 21);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 16) = v51;
          }
          a4 = 0;
          *(void *)(v10 - 48) = v38;
          *(double *)(v10 - 40) = v20;
          *(_OWORD *)(v10 - 21) = *(_OWORD *)&v105[11];
          *(_OWORD *)(v10 - 32) = *(_OWORD *)v105;
        }
        double v20 = *(double *)(a1 + 8);
LABEL_12:
        uint64_t v21 = 0;
        uint64_t v22 = *(void *)a1;
        *(_OWORD *)uint64_t v104 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v104[16] = *(_OWORD *)(a1 + 32);
        do
        {
          double v23 = *(double *)(a1 + v21 + 56);
          v21 += 48;
        }
        while (v23 < v20);
        unint64_t v24 = a1 + v21;
        uint64_t v25 = a2;
        if (v21 == 48)
        {
          long long v28 = a2;
          while (v24 < (unint64_t)v28)
          {
            long long v26 = v28 - 3;
            double v29 = *((double *)v28 - 5);
            v28 -= 3;
            if (v29 < v20) {
              goto LABEL_22;
            }
          }
          long long v26 = v28;
        }
        else
        {
          do
          {
            long long v26 = v25 - 3;
            double v27 = *((double *)v25 - 5);
            v25 -= 3;
          }
          while (v27 >= v20);
        }
LABEL_22:
        unint64_t v10 = v24;
        if (v24 < (unint64_t)v26)
        {
          long long v30 = v26;
          do
          {
            *(_OWORD *)uint64_t v116 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)&v116[16] = *(_OWORD *)(v10 + 32);
            long long v108 = *(_OWORD *)v10;
            long long v31 = *v30;
            long long v32 = v30[1];
            *(_OWORD *)(v10 + 27) = *(long long *)((char *)v30 + 27);
            *(_OWORD *)unint64_t v10 = v31;
            *(_OWORD *)(v10 + 16) = v32;
            *(long long *)((char *)v30 + 27) = *(_OWORD *)&v116[11];
            long long *v30 = v108;
            v30[1] = *(_OWORD *)v116;
            do
            {
              double v33 = *(double *)(v10 + 56);
              v10 += 48;
            }
            while (v33 < v20);
            do
            {
              double v34 = *((double *)v30 - 5);
              v30 -= 3;
            }
            while (v34 >= v20);
          }
          while (v10 < (unint64_t)v30);
        }
        if (v10 - 48 != a1)
        {
          long long v35 = *(_OWORD *)(v10 - 48);
          long long v36 = *(_OWORD *)(v10 - 32);
          *(_OWORD *)(a1 + 27) = *(_OWORD *)(v10 - 21);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
        }
        *(void *)(v10 - 48) = v22;
        *(double *)(v10 - 40) = v20;
        *(_OWORD *)(v10 - 21) = *(_OWORD *)&v104[11];
        *(_OWORD *)(v10 - 32) = *(_OWORD *)v104;
        if (v24 >= (unint64_t)v26) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*,false>(a1, v10 - 48, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, v10 - 48);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_33;
      }
    }
    a2 = (long long *)(v10 - 48);
    if (!v37) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_SampleRemainder*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 40) < *(double *)(a1 + 8))
      {
        long long v6 = *(_OWORD *)a1;
        *(_OWORD *)double v20 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v20[16] = *(_OWORD *)(a1 + 32);
        long long v7 = *(_OWORD *)(a2 - 21);
        long long v8 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a1 + 16) = v8;
        *(_OWORD *)(a1 + 27) = v7;
        *(_OWORD *)(a2 - 48) = v6;
        *(_OWORD *)(a2 - 32) = *(_OWORD *)v20;
        *(_OWORD *)(a2 - 21) = *(_OWORD *)&v20[11];
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a2 - 48));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a2 - 48);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a1 + 144, a2 - 48);
      return 1;
    default:
      uint64_t v9 = a1 + 96;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a1 + 96));
      uint64_t v10 = a1 + 144;
      if (a1 + 144 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    double v13 = *(double *)(v10 + 8);
    if (v13 < *(double *)(v9 + 8))
    {
      uint64_t v14 = *(void *)v10;
      *(_OWORD *)long long v19 = *(_OWORD *)(v10 + 16);
      *(_OWORD *)&v19[16] = *(_OWORD *)(v10 + 32);
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        long long v17 = *(_OWORD *)(a1 + v15 + 112);
        *(_OWORD *)(v16 + 144) = *(_OWORD *)(a1 + v15 + 96);
        *(_OWORD *)(v16 + 160) = v17;
        *(_OWORD *)(v16 + 171) = *(_OWORD *)(a1 + v15 + 123);
        if (v15 == -96) {
          break;
        }
        v15 -= 48;
        if (v13 >= *(double *)(v16 + 56))
        {
          uint64_t v18 = a1 + v15 + 144;
          goto LABEL_12;
        }
      }
      uint64_t v18 = a1;
LABEL_12:
      *(void *)uint64_t v18 = v14;
      *(double *)(v18 + 8) = v13;
      *(_OWORD *)(v18 + 16) = *(_OWORD *)v19;
      *(_OWORD *)(v18 + 27) = *(_OWORD *)&v19[11];
      if (++v12 == 8) {
        return v10 + 48 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 48;
    v10 += 48;
    if (v10 == a2) {
      return 1;
    }
  }
}

__n128 HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::overallStatistics(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 + 120;
  *(_DWORD *)a1 = *(_DWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 224);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 240);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 256);
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 272);
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 56) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 88) = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 144);
  *(void *)(a1 + 176) = 0;
  uint64_t v3 = a1 + 176;
  uint64_t v5 = *(void *)(a2 + 288);
  uint64_t v4 = *(const void **)(a2 + 296);
  *(void *)(a1 + 168) = v5;
  uint64_t v6 = *(void *)(v2 + 184);
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((void *)(a1 + 176), v4, v6, (v6 - (uint64_t)v4) >> 4);
  *(void *)(v3 + 24) = *(void *)(v2 + 200);
  __n128 result = *(__n128 *)(v2 + 208);
  long long v8 = *(_OWORD *)(v2 + 224);
  *(__n128 *)(v3 + 32) = result;
  *(_OWORD *)(v3 + 48) = v8;
  *(void *)(v3 + 64) = *(void *)(v2 + 240);
  return result;
}

void HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::statisticsByBundleIdentifier(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  uint64_t v3 = *(void **)(a2 + 368);
  long long v52 = (void *)(a2 + 376);
  if (v3 == (void *)(a2 + 376)) {
    return;
  }
  __n128 v54 = (void *)(a1 + 16);
  do
  {
    uint64_t v5 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_bundleIdentifierForSourceID(a2, v3[4]);
    uint64_t v6 = v5;
    if (!v5) {
      goto LABEL_81;
    }
    unint64_t v7 = [v5 hash];
    unint64_t v8 = v7;
    unint64_t v9 = *(void *)(a1 + 8);
    if (!v9) {
      goto LABEL_21;
    }
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v55 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v2 = v7;
      if (v7 >= v9) {
        unint64_t v2 = v7 % v9;
      }
    }
    else
    {
      unint64_t v2 = (v9 - 1) & v7;
    }
    uint64_t v11 = *(uint64_t ***)(*(void *)a1 + 8 * v2);
    if (!v11 || (int v12 = *v11) == 0)
    {
LABEL_21:
      long long v19 = (char *)operator new(0x110uLL);
      v56[0] = v19;
      v56[1] = v54;
      *(void *)long long v19 = 0;
      *((void *)v19 + 1) = v8;
      *((void *)v19 + 2) = v6;
      *(_OWORD *)(v19 + 56) = 0u;
      *(_OWORD *)(v19 + 72) = 0u;
      *(_OWORD *)(v19 + 104) = 0u;
      *(_OWORD *)(v19 + 120) = 0u;
      *(_OWORD *)(v19 + 152) = 0u;
      *(_OWORD *)(v19 + 168) = 0u;
      *(_OWORD *)(v19 + 184) = 0u;
      *(_OWORD *)(v19 + 24) = 0u;
      *(_OWORD *)(v19 + 40) = 0u;
      *(_OWORD *)(v19 + 200) = 0u;
      *(_OWORD *)(v19 + 216) = 0u;
      *(_OWORD *)(v19 + 232) = 0u;
      *(_OWORD *)(v19 + 248) = 0u;
      *((void *)v19 + 33) = 0;
      *((_OWORD *)v19 + 4) = xmmword_1BD330210;
      *(_OWORD *)(v19 + 88) = xmmword_1BD330220;
      *((_OWORD *)v19 + 7) = xmmword_1BD330230;
      *(_OWORD *)(v19 + 136) = xmmword_1BD330240;
      *((_OWORD *)v19 + 10) = xmmword_1BD330250;
      *((void *)v19 + 23) = 0x7FFFFFFFFFFFFFFFLL;
      *(_OWORD *)(v19 + 250) = 0u;
      *((_OWORD *)v19 + 14) = 0u;
      *((_OWORD *)v19 + 15) = 0u;
      *((_OWORD *)v19 + 12) = 0u;
      *((_OWORD *)v19 + 13) = 0u;
      char v57 = 1;
      float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v21 = *(float *)(a1 + 32);
      if (v9 && (float)(v21 * (float)v9) >= v20)
      {
LABEL_68:
        BOOL v37 = *(void **)(*(void *)a1 + 8 * v2);
        int v12 = (uint64_t *)v56[0];
        if (v37)
        {
          *(void *)v56[0] = *v37;
        }
        else
        {
          *(void *)v56[0] = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v12;
          *(void *)(*(void *)a1 + 8 * v2) = v54;
          if (!*v12)
          {
LABEL_77:
            v56[0] = 0;
            ++*(void *)(a1 + 24);
            std::unique_ptr<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,void *>>>>::reset[abi:ne180100]((uint64_t)v56);
            goto LABEL_78;
          }
          unint64_t v38 = *(void *)(*v12 + 8);
          if ((v9 & (v9 - 1)) != 0)
          {
            if (v38 >= v9) {
              v38 %= v9;
            }
          }
          else
          {
            v38 &= v9 - 1;
          }
          BOOL v37 = (void *)(*(void *)a1 + 8 * v38);
        }
        *BOOL v37 = v12;
        goto LABEL_77;
      }
      BOOL v22 = v9 < 3 || (v9 & (v9 - 1)) != 0;
      unint64_t v23 = v22 | (2 * v9);
      unint64_t v24 = vcvtps_u32_f32(v20 / v21);
      if (v23 <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      else {
        int8x8_t prime = (int8x8_t)v23;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      }
      unint64_t v9 = *(void *)(a1 + 8);
      if (*(void *)&prime > v9) {
        goto LABEL_34;
      }
      if (*(void *)&prime < v9)
      {
        unint64_t v32 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
        if (v9 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
        {
          unint64_t v32 = std::__next_prime(v32);
        }
        else
        {
          uint64_t v34 = 1 << -(char)__clz(v32 - 1);
          if (v32 >= 2) {
            unint64_t v32 = v34;
          }
        }
        if (*(void *)&prime <= v32) {
          int8x8_t prime = (int8x8_t)v32;
        }
        if (*(void *)&prime >= v9)
        {
          unint64_t v9 = *(void *)(a1 + 8);
        }
        else
        {
          if (prime)
          {
LABEL_34:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            long long v26 = operator new(8 * *(void *)&prime);
            double v27 = *(void **)a1;
            *(void *)a1 = v26;
            if (v27) {
              operator delete(v27);
            }
            uint64_t v28 = 0;
            *(int8x8_t *)(a1 + 8) = prime;
            do
              *(void *)(*(void *)a1 + 8 * v28++) = 0;
            while (*(void *)&prime != v28);
            double v29 = (void *)*v54;
            if (*v54)
            {
              unint64_t v30 = v29[1];
              uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
              v31.i16[0] = vaddlv_u8(v31);
              if (v31.u32[0] > 1uLL)
              {
                if (v30 >= *(void *)&prime) {
                  v30 %= *(void *)&prime;
                }
              }
              else
              {
                v30 &= *(void *)&prime - 1;
              }
              *(void *)(*(void *)a1 + 8 * v30) = v54;
              long long v35 = (void *)*v29;
              if (*v29)
              {
                do
                {
                  unint64_t v36 = v35[1];
                  if (v31.u32[0] > 1uLL)
                  {
                    if (v36 >= *(void *)&prime) {
                      v36 %= *(void *)&prime;
                    }
                  }
                  else
                  {
                    v36 &= *(void *)&prime - 1;
                  }
                  if (v36 != v30)
                  {
                    if (!*(void *)(*(void *)a1 + 8 * v36))
                    {
                      *(void *)(*(void *)a1 + 8 * v36) = v29;
                      goto LABEL_59;
                    }
                    *double v29 = *v35;
                    *long long v35 = **(void **)(*(void *)a1 + 8 * v36);
                    **(void **)(*(void *)a1 + 8 * v36) = v35;
                    long long v35 = v29;
                  }
                  unint64_t v36 = v30;
LABEL_59:
                  double v29 = v35;
                  long long v35 = (void *)*v35;
                  unint64_t v30 = v36;
                }
                while (v35);
              }
            }
            unint64_t v9 = (unint64_t)prime;
            goto LABEL_63;
          }
          long long v51 = *(void **)a1;
          *(void *)a1 = 0;
          if (v51) {
            operator delete(v51);
          }
          unint64_t v9 = 0;
          *(void *)(a1 + 8) = 0;
        }
      }
LABEL_63:
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v8 >= v9) {
          unint64_t v2 = v8 % v9;
        }
        else {
          unint64_t v2 = v8;
        }
      }
      else
      {
        unint64_t v2 = (v9 - 1) & v8;
      }
      goto LABEL_68;
    }
    while (1)
    {
      unint64_t v13 = v12[1];
      if (v13 == v8) {
        break;
      }
      if (v55 > 1)
      {
        if (v13 >= v9) {
          v13 %= v9;
        }
      }
      else
      {
        v13 &= v9 - 1;
      }
      if (v13 != v2) {
        goto LABEL_21;
      }
LABEL_20:
      int v12 = (uint64_t *)*v12;
      if (!v12) {
        goto LABEL_21;
      }
    }
    id v14 = (id)v12[2];
    uint64_t v15 = v6;
    id v16 = v6;
    long long v17 = v16;
    if (v14 != v16)
    {
      char v18 = [v14 isEqualToString:v16];

      uint64_t v6 = v15;
      if (v18) {
        goto LABEL_78;
      }
      goto LABEL_20;
    }

    uint64_t v6 = v15;
LABEL_78:
    *((_DWORD *)v12 + 6) = *((_DWORD *)v3 + 10);
    long long v39 = *((_OWORD *)v3 + 4);
    *((_OWORD *)v12 + 2) = *((_OWORD *)v3 + 3);
    *((_OWORD *)v12 + 3) = v39;
    long long v40 = *((_OWORD *)v3 + 5);
    long long v41 = *((_OWORD *)v3 + 6);
    long long v42 = *((_OWORD *)v3 + 8);
    *((_OWORD *)v12 + 6) = *((_OWORD *)v3 + 7);
    *((_OWORD *)v12 + 7) = v42;
    *((_OWORD *)v12 + 4) = v40;
    *((_OWORD *)v12 + 5) = v41;
    long long v43 = *((_OWORD *)v3 + 9);
    long long v44 = *((_OWORD *)v3 + 10);
    long long v45 = *((_OWORD *)v3 + 12);
    *((_OWORD *)v12 + 10) = *((_OWORD *)v3 + 11);
    *((_OWORD *)v12 + 11) = v45;
    *((_OWORD *)v12 + 8) = v43;
    *((_OWORD *)v12 + 9) = v44;
    v12[24] = v3[26];
    if (v12 + 2 != v3 + 4) {
      std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((char *)v12 + 200, (char *)v3[27], v3[28], (uint64_t)(v3[28] - v3[27]) >> 4);
    }
    v12[28] = v3[30];
    long long v46 = *(_OWORD *)(v3 + 31);
    long long v47 = *(_OWORD *)(v3 + 33);
    *((_WORD *)v12 + 132) = *((_WORD *)v3 + 140);
    *(_OWORD *)(v12 + 31) = v47;
    *(_OWORD *)(v12 + 29) = v46;

LABEL_81:
    double v48 = (void *)v3[1];
    if (v48)
    {
      do
      {
        double v49 = v48;
        double v48 = (void *)*v48;
      }
      while (v48);
    }
    else
    {
      do
      {
        double v49 = (void *)v3[2];
        BOOL v50 = *v49 == (void)v3;
        uint64_t v3 = v49;
      }
      while (!v50);
    }
    uint64_t v3 = v49;
  }
  while (v49 != v52);
}

void sub_1BD1792BC(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,void *>>>>::reset[abi:ne180100](v3 - 104);

  std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<NSString * const {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<NSString * const {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,0>(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 184);
  if (v2)
  {
    *(void *)(a1 + 192) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
}

uint64_t std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::~__hash_table(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<NSString * const {__strong},HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F1726810;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](a1 + 1);
  return a1;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F1726810;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](a1 + 1);

  JUMPOUT(0x1C187B8A0);
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unint64_t v2 = operator new(0x28uLL);
  void *v2 = &unk_1F1726810;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1BD179598(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1726810;
  return std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48))(v1) + 160;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::target_type()
{
}

void *std::__function::__value_func<HDStatisticsTimeInterval const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F17268A0;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](a1 + 1);
  return a1;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F17268A0;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](a1 + 1);

  JUMPOUT(0x1C187B8A0);
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unint64_t v2 = operator new(0x28uLL);
  void *v2 = &unk_1F17268A0;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1BD179830(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F17268A0;
  return std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  unint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::target_type()
{
}

void *std::__function::__value_func<HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__func()
{
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F1726930;
  return result;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1726930;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return a2 + 8;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>> const&)::{lambda(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::target_type()
{
}

void *std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveAddSample(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 728))
  {
    if ((a3 & 1) == 0)
    {
      objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a4, 3, @"Cannot configure statistics collection calculator engine with a sample if we cannot merge up to the sample's start date");
      return 0;
    }
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_configureForStartTime(a1);
  }
  double v8 = *(double *)(a2 + 8);
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9)
  {
    if (*(unsigned char *)(a1 + 728))
    {
      double v10 = -1.79769313e308;
    }
    else
    {
      double v10 = *(double *)(a1 + 176);
      double v12 = *(double *)(a1 + 120);
      if (v10 <= v12) {
        double v10 = -1.79769313e308;
      }
      if (v10 < v12) {
        double v10 = *(double *)(a1 + 120);
      }
    }
  }
  else
  {
    double v10 = *(double *)(a1 + 176);
    if (v10 <= *(double *)(a1 + 120)) {
      double v10 = -1.79769313e308;
    }
  }
  if (v10 <= v8)
  {
    if (v9 && a3) {
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_advanceToTime(a1, v8);
    }
    HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::addSample(a1 + 112, a2, a3);
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_notifyForCurrentBucket(a1);
    return 1;
  }
  else
  {
    unint64_t v13 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:");
    uint64_t v11 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v13, a4);
  }
  return v11;
}

void sub_1BD179C7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_advanceToTime(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 128) <= a2)
  {
    uint64_t v4 = a1 + 112;
    uint64_t v5 = a1 + 120;
    do
    {
      uint64_t v6 = *(void *)(a1 + 704);
      uint64_t v7 = *(void *)(a1 + 696);
      if (v6 == v7)
      {
        uint64_t v22 = 0;
        uint64_t v15 = *(void **)(a1 + 40);
        id v16 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:a2];
        double v8 = [v15 dateIntervalContainingDate:v16 index:&v22];

        HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_updateSourceOrder(v5);
        HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeThroughTime(v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsFromFinishedBucket(a1, v5);
        uint64_t v17 = v22;
        double v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v19 = v18;
        float v20 = [v8 endDate];
        [v20 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::resetToBucket(v4, v17, v19, v21);
      }
      else
      {
        double v8 = [*(id *)(a1 + 40) dateIntervalAtIndex:*(void *)(a1 + 112) + 1];
        HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_updateSourceOrder(v5);
        HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeThroughTime(v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsFromFinishedBucket(a1, v5);
        double v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v12 = v11;
        unint64_t v13 = [v8 endDate];
        [v13 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::advanceBucket(v4, v12, v14);
      }
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_didChangeBucket(a1, v9);
      if (v6 != v7) {
        _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_notifyForCurrentBucket(a1);
      }
    }
    while (*(double *)(a1 + 128) <= a2);
  }
}

void sub_1BD179E88(_Unwind_Exception *exception_object)
{
}

void HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::addSample(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = a1 + 8;
  double v6 = *(double *)(a1 + 8);
  double v7 = *(double *)(a2 + 8);
  double v8 = *(double *)(a2 + 16);
  uint64_t v9 = *(uint64_t **)(a2 + 24);
  unsigned __int8 v10 = *(unsigned char *)(a2 + 32);
  char v11 = *(unsigned char *)(a2 + 33);
  int v12 = v10;
  char v13 = v11;
  unint64_t v14 = (unint64_t)v9;
  double v15 = v8;
  double v16 = v7;
  if (v6 - v7 >= 0.01)
  {
    if (v8 - v7 - (v6 - v7) >= 0.01)
    {
      int v12 = *(unsigned __int8 *)(a2 + 32);
      char v13 = *(unsigned char *)(a2 + 33);
      unint64_t v14 = *(void *)(a2 + 24);
      double v15 = *(double *)(a2 + 16);
      double v16 = *(double *)(a1 + 8);
    }
    else
    {
      int v12 = 0;
      char v13 = 0;
      unint64_t v14 = 0;
      double v15 = 0.0;
      double v16 = 0.0;
    }
  }
  uint64_t v17 = *(uint64_t **)a2;
  double v18 = *(double *)(a1 + 16);
  double v19 = v18 - v16;
  double v20 = v15 - v16 - (v18 - v16);
  if (!*(_DWORD *)(a1 + 36))
  {
    if (v20 < 0.01)
    {
LABEL_10:
      unint64_t v65 = 0;
      int v21 = 0;
      char v66 = 0;
      double v18 = 0.0;
      double v22 = 0.0;
      if (!v12) {
        goto LABEL_28;
      }
      goto LABEL_11;
    }
    if (v19 >= 0.01) {
      goto LABEL_27;
    }
LABEL_25:
    int v21 = v12;
    unint64_t v28 = v14;
    double v22 = v15;
    double v18 = v16;
    if (!v21) {
      return;
    }
    goto LABEL_56;
  }
  if (v19 < 0.01) {
    goto LABEL_25;
  }
  if (v20 < 0.01) {
    goto LABEL_10;
  }
LABEL_27:
  double v22 = v15;
  unint64_t v65 = v14;
  int v21 = v12;
  char v66 = v13;
  double v15 = *(double *)(a1 + 16);
  if (!v12)
  {
LABEL_28:
    char v13 = v66;
    unint64_t v28 = v65;
    if (!v21) {
      return;
    }
    goto LABEL_56;
  }
LABEL_11:
  double v63 = v16;
  double v64 = v15;
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>(a1 + 400, v14, v14);
  unint64_t v23 = *(void *)(a1 + 112);
  if (v23 == *(void *)(a1 + 104) && *(uint64_t *)(a1 + 136) <= 0)
  {
    v29.f64[1] = *(float64_t *)(a1 + 16);
    double v24 = v63;
    double v25 = v64;
    v29.f64[0] = v63;
    v30.f64[0] = *(float64_t *)(a1 + 8);
    v30.f64[1] = v64;
    int8x16_t v31 = (int8x16_t)vcgtq_f64(v30, v29);
    v30.f64[0] = v63;
    *(int8x16_t *)(a1 + 48) = vbslq_s8(v31, *(int8x16_t *)(a1 + 8), (int8x16_t)v30);
    if (!a3) {
      goto LABEL_31;
    }
    goto LABEL_22;
  }
  double v24 = v63;
  double v25 = v64;
  if (v63 < *(double *)(a1 + 48))
  {
    double v26 = *(double *)(a1 + 8);
    if (v63 >= v26) {
      double v26 = v63;
    }
    *(double *)(a1 + 48) = v26;
  }
  if (v64 > *(double *)(a1 + 56))
  {
    double v27 = *(double *)(a1 + 16);
    if (v27 >= v64) {
      double v27 = v64;
    }
    *(double *)(a1 + 56) = v27;
  }
  if (a3)
  {
LABEL_22:
    if (v24 < *(double *)(a1 + 16))
    {
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeThroughTime(v5, v24);
      double v24 = v63;
      double v25 = v64;
      unint64_t v23 = *(void *)(a1 + 112);
    }
  }
LABEL_31:
  unint64_t v32 = *(void *)(a1 + 120);
  if (v23 >= v32)
  {
    uint64_t v34 = *(void *)(a1 + 104);
    unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v34) >> 4);
    unint64_t v36 = v35 + 1;
    if (v35 + 1 > 0x555555555555555) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v32 - v34) >> 4);
    if (2 * v37 > v36) {
      unint64_t v36 = 2 * v37;
    }
    if (v37 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v38 = 0x555555555555555;
    }
    else {
      unint64_t v38 = v36;
    }
    if (v38)
    {
      unint64_t v38 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v38);
      double v24 = v63;
      double v25 = v64;
    }
    else
    {
      uint64_t v39 = 0;
    }
    unint64_t v40 = v38 + 48 * v35;
    unint64_t v41 = v38 + 48 * v39;
    *(void *)unint64_t v40 = v17;
    *(double *)(v40 + 8) = v24;
    *(double *)(v40 + 16) = v25;
    *(void *)(v40 + 24) = v14;
    *(unsigned char *)(v40 + 32) = v12;
    *(unsigned char *)(v40 + 33) = v13;
    *(_WORD *)(v40 + 40) = 0;
    *(unsigned char *)(v40 + 42) = 0;
    unint64_t v33 = v40 + 48;
    long long v43 = *(char **)(a1 + 104);
    long long v42 = *(char **)(a1 + 112);
    if (v42 == v43)
    {
      char v13 = v66;
      unint64_t v28 = v65;
    }
    else
    {
      char v13 = v66;
      unint64_t v28 = v65;
      do
      {
        long long v44 = *((_OWORD *)v42 - 3);
        long long v45 = *((_OWORD *)v42 - 2);
        *(_OWORD *)(v40 - 21) = *(_OWORD *)(v42 - 21);
        *(_OWORD *)(v40 - 48) = v44;
        *(_OWORD *)(v40 - 32) = v45;
        v40 -= 48;
        v42 -= 48;
      }
      while (v42 != v43);
      long long v42 = *(char **)(a1 + 104);
    }
    *(void *)(a1 + 104) = v40;
    *(void *)(a1 + 112) = v33;
    *(void *)(a1 + 120) = v41;
    if (v42) {
      operator delete(v42);
    }
  }
  else
  {
    *(void *)unint64_t v23 = v17;
    *(double *)(v23 + 8) = v24;
    *(double *)(v23 + 16) = v25;
    *(void *)(v23 + 24) = v14;
    *(unsigned char *)(v23 + 32) = v12;
    *(unsigned char *)(v23 + 33) = v13;
    *(_WORD *)(v23 + 40) = 0;
    unint64_t v33 = v23 + 48;
    *(unsigned char *)(v23 + 42) = 0;
    char v13 = v66;
    unint64_t v28 = v65;
  }
  *(void *)(a1 + 112) = v33;
  if (!*(unsigned char *)(a1 + 368) || *(double *)(a1 + 344) <= v7)
  {
    *(void *)(a1 + 336) = v17;
    *(double *)(a1 + 344) = v7;
    *(double *)(a1 + 352) = v8;
    *(void *)(a1 + 360) = v9;
    *(unsigned char *)(a1 + 368) = v10;
    *(unsigned char *)(a1 + 369) = v11;
  }
  if (*(unsigned char *)(a1 + 33)
    && ((unint64_t v46 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_canonicalSourceIDForSourceID(v5, v14), v47 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsForSource(v5, v46), !*((unsigned char *)v47 + 240))|| *((double *)v47 + 27) <= v7))
  {
    v47[26] = v17;
    *((double *)v47 + 27) = v7;
    *((double *)v47 + 28) = v8;
    v47[29] = v9;
    *((unsigned char *)v47 + 240) = v10;
    *((unsigned char *)v47 + 241) = v11;
    if (!v21) {
      return;
    }
  }
  else if (!v21)
  {
    return;
  }
LABEL_56:
  unint64_t v48 = *(void *)(a1 + 592);
  unint64_t v49 = *(void *)(a1 + 600);
  if (v48 >= v49)
  {
    uint64_t v51 = *(void *)(a1 + 584);
    unint64_t v52 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v48 - v51) >> 3);
    unint64_t v53 = v52 + 1;
    if (v52 + 1 > 0x666666666666666) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v54 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v49 - v51) >> 3);
    if (2 * v54 > v53) {
      unint64_t v53 = 2 * v54;
    }
    if (v54 >= 0x333333333333333) {
      unint64_t v55 = 0x666666666666666;
    }
    else {
      unint64_t v55 = v53;
    }
    if (v55) {
      unint64_t v55 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v55);
    }
    else {
      uint64_t v56 = 0;
    }
    unint64_t v57 = v55 + 40 * v52;
    unint64_t v58 = v55 + 40 * v56;
    *(void *)unint64_t v57 = v17;
    *(double *)(v57 + 8) = v18;
    *(double *)(v57 + 16) = v22;
    *(void *)(v57 + 24) = v28;
    *(unsigned char *)(v57 + 32) = v21;
    *(unsigned char *)(v57 + 33) = v13;
    unint64_t v50 = v57 + 40;
    unint64_t v59 = *(char **)(a1 + 592);
    double v60 = *(char **)(a1 + 584);
    if (v59 != v60)
    {
      do
      {
        long long v61 = *(_OWORD *)(v59 - 40);
        long long v62 = *(_OWORD *)(v59 - 24);
        *(_WORD *)(v57 - 8) = *((_WORD *)v59 - 4);
        *(_OWORD *)(v57 - 24) = v62;
        *(_OWORD *)(v57 - 40) = v61;
        v57 -= 40;
        v59 -= 40;
      }
      while (v59 != v60);
      unint64_t v59 = *(char **)(a1 + 584);
    }
    *(void *)(a1 + 584) = v57;
    *(void *)(a1 + 592) = v50;
    *(void *)(a1 + 600) = v58;
    if (v59) {
      operator delete(v59);
    }
  }
  else
  {
    *(void *)unint64_t v48 = v17;
    *(double *)(v48 + 8) = v18;
    *(double *)(v48 + 16) = v22;
    *(void *)(v48 + 24) = v28;
    *(unsigned char *)(v48 + 32) = v21;
    unint64_t v50 = v48 + 40;
    *(unsigned char *)(v48 + 33) = v13;
  }
  *(void *)(a1 + 592) = v50;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_notifyForCurrentBucket(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 730))
  {
    *(unsigned char *)(a1 + 732) = 1;
  }
  else
  {
    *(unsigned char *)(a1 + 732) = 0;
    unint64_t v2 = (void (**)(id, void *))_Block_copy(*(const void **)(a1 + 96));
    if (v2)
    {
      uint64_t v4 = v2;
      uint64_t v3 = (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
      if (v3) {
        v4[2](v4, v3);
      }

      unint64_t v2 = v4;
    }
  }
}

void sub_1BD17A488(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::advanceBucket(uint64_t a1, double a2, double a3)
{
  uint64_t v9 = 0;
  unsigned __int8 v10 = 0;
  uint64_t v11 = 0;
  std::vector<HDRawQuantitySample>::__init_with_size[abi:ne180100]<HDRawQuantitySample*,HDRawQuantitySample*>(&v9, *(const void **)(a1 + 584), *(void *)(a1 + 592), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 592) - *(void *)(a1 + 584)) >> 3));
  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::resetToBucket(a1, *(void *)a1 + 1, a2, a3);
  double v6 = v9;
  double v7 = v10;
  if (v9 != v10)
  {
    uint64_t v8 = (uint64_t)v9;
    do
    {
      HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::addSample(a1, v8, 1);
      v8 += 40;
    }
    while ((void *)v8 != v7);
  }
  if (v6)
  {
    operator delete(v6);
  }
}

void sub_1BD17A588(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::resetToBucket(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v8 = (id *)(a1 + 40);
  objc_storeStrong((id *)(a1 + 608), *(id *)(a1 + 40));
  *((double *)v8 - 4) = a3;
  *(double *)(a1 + 16) = a4;
  *(double *)(a1 + 64) = a3;
  *(void *)(a1 + 112) = *(void *)(a1 + 104);
  memset(v17, 0, sizeof(v17));
  *(_DWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 136) = *(_OWORD *)&v17[4];
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 168) = xmmword_1BD330210;
  *(void *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 192) = xmmword_1BD330220;
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 216) = xmmword_1BD330230;
  *(void *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 240) = xmmword_1BD330240;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 272) = 5;
  *(void *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 288) = xmmword_1BD330260;
  uint64_t v9 = *(void **)(a1 + 304);
  if (v9)
  {
    *(void *)(a1 + 312) = v9;
    operator delete(v9);
  }
  *(_WORD *)(a1 + 368) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  if (*(void *)(a1 + 392))
  {
    unsigned __int8 v10 = *(void **)(a1 + 376);
    uint64_t v11 = *(void *)(a1 + 384);
    *(void *)(a1 + 376) = a1 + 384;
    *(void *)(v11 + 16) = 0;
    *(void *)(a1 + 384) = 0;
    *(void *)(a1 + 392) = 0;
    if (v10[1]) {
      int v12 = (void *)v10[1];
    }
    else {
      int v12 = v10;
    }
    if (v12)
    {
      char v13 = (void *)v12[2];
      if (v13)
      {
        unint64_t v14 = (void *)*v13;
        if ((void *)*v13 == v12)
        {
          void *v13 = 0;
          while (1)
          {
            double v16 = (void *)v13[1];
            if (!v16) {
              break;
            }
            do
            {
              char v13 = v16;
              double v16 = (void *)*v16;
            }
            while (v16);
          }
        }
        else
        {
          for (v13[1] = 0; v14; unint64_t v14 = (void *)v13[1])
          {
            do
            {
              char v13 = v14;
              unint64_t v14 = (void *)*v14;
            }
            while (v14);
          }
        }
        std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::destroy(v12);
        for (uint64_t i = (void *)v13[2]; i; uint64_t i = (void *)i[2])
          char v13 = i;
        int v12 = v13;
      }
    }
    std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>>::destroy(v12);
  }
  objc_storeStrong(v8, *(id *)(a1 + 608));
  *(void *)(a1 + 592) = *(void *)(a1 + 584);
  *(void *)a1 = a2;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_didChangeBucket(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 732))
  {
    if (v3)
    {
      id v6 = v3;
      uint64_t v4 = _Block_copy(*(const void **)(a1 + 96));
      uint64_t v5 = v4;
      if (v4) {
        (*((void (**)(void *, id))v4 + 2))(v4, v6);
      }

      id v3 = v6;
    }
    *(unsigned char *)(a1 + 732) = 0;
  }
}

void sub_1BD17A7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_currentBucketInterval(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 728))
  {
    uint64_t v1 = 0;
  }
  else
  {
    uint64_t v1 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:", *(double *)(a1 + 120), *(double *)(a1 + 128));
  }

  return v1;
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE38_collapsedPendingInvalidationIntervalsERb_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = [a2 startDate];
  id v6 = [v4 startDate];
  uint64_t v7 = [v5 compare:v6];

  return v7;
}

void sub_1BD17A8D0(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveInvalidateInterval(id *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 13);
  if (WeakRetained)
  {
    if (v5
      && (_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_currentBucketInterval((uint64_t)a1),
          (uint64_t v7 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      uint64_t v8 = [v5 endDate];
      uint64_t v9 = [v7 startDate];
      if (objc_msgSend(v8, "hk_isAfterDate:", v9))
      {
        unsigned __int8 v10 = [v5 startDate];
        uint64_t v11 = [v7 endDate];
        char v12 = objc_msgSend(v10, "hk_isBeforeOrEqualToDate:", v11);
      }
      else
      {
        char v12 = 0;
      }

      char v13 = _Block_copy(a1[12]);
      if ((v12 & 1) == 0) {
        operator new();
      }
    }
    else
    {
      char v13 = _Block_copy(a1[12]);
    }
    *((unsigned char *)a1 + 728) = 1;
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 3221225472;
    v27[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke;
    v27[3] = &unk_1E6308FF8;
    id v15 = v5;
    id v28 = v15;
    id v16 = v13;
    id v29 = v16;
    (*((void (**)(id *, void *))*a1 + 9))(a1, v27);
    if (v5)
    {
      uint64_t v17 = [v15 startDate];
      [v17 timeIntervalSinceReferenceDate];
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_configureForStartTime((uint64_t)a1);
    }
    else
    {
      (*((void (**)(id *))*a1 + 4))(a1);
      id v15 = (id)objc_claimAutoreleasedReturnValue();
    }
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2;
    v21[3] = &unk_1E6309060;
    double v24 = a1;
    id v5 = v15;
    char v26 = 1;
    id v22 = v5;
    double v25 = a1;
    id v23 = WeakRetained;
    uint64_t v14 = (*((uint64_t (**)(id *, void *, uint64_t))*a1 + 14))(a1, v21, a3);
    double v18 = _Block_copy(v16);
    id v19 = a1[12];
    a1[12] = v18;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a3, 3, @"Unable to invalidate interval: no data source available.");
    uint64_t v14 = 0;
  }

  return v14;
}

void sub_1BD17AD20(_Unwind_Exception *a1)
{
  MEMORY[0x1C187B8A0](v4, 0x10F1C4080798BF6);
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke(uint64_t a1, void *a2)
{
  id v10 = a2;
  if (!*(void *)(a1 + 32)) {
    goto LABEL_11;
  }
  id v3 = [v10 endDate];
  uint64_t v4 = [*(id *)(a1 + 32) startDate];
  char v5 = objc_msgSend(v3, "hk_isBeforeOrEqualToDate:", v4);

  if ((v5 & 1) == 0)
  {
    id v6 = [v10 startDate];
    uint64_t v7 = [*(id *)(a1 + 32) endDate];
    char v8 = objc_msgSend(v6, "hk_isAfterOrEqualToDate:", v7);

    if ((v8 & 1) == 0)
    {
LABEL_11:
      uint64_t v9 = *(void *)(a1 + 40);
      if (v9) {
        (*(void (**)(uint64_t, id))(v9 + 16))(v9, v10);
      }
    }
  }
}

void sub_1BD17AF04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  char v5 = [*(id *)(a1 + 32) startDate];
  [v5 timeIntervalSinceReferenceDate];
  uint64_t v7 = v6;

  char v8 = [*(id *)(a1 + 32) endDate];
  [v8 timeIntervalSinceReferenceDate];
  uint64_t v10 = v9;

  uint64_t v11 = *(void **)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(v4 + 8));
  uint64_t v13 = *(void *)(a1 + 32);
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3;
  v30[3] = &__block_descriptor_57_e24_B52__0d8d16d24q32B40__44l;
  char v32 = *(unsigned char *)(a1 + 64);
  v30[4] = v7;
  v30[5] = v10;
  uint64_t v31 = *(void *)(a1 + 56);
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4;
  void v29[3] = &__block_descriptor_40_e8_v16__0d8l;
  v29[4] = v31;
  uint64_t v14 = [v11 collectionCalculator:WeakRetained queryForInterval:v13 error:a2 sampleHandler:v30 mergeHandler:v29];

  if (v14)
  {
    uint64_t v15 = *(void *)(a1 + 56);
    if (v15 != v4)
    {
      id v16 = [*(id *)(a1 + 32) endDate];
      [v16 timeIntervalSinceReferenceDate];
      if (*(void *)(v15 + 40))
      {
        double v18 = v17;
        while (*(double *)(v15 + 120) < v18)
        {
          id v19 = [*(id *)(v15 + 40) dateIntervalAtIndex:*(void *)(v15 + 112) + 1];
          HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_updateSourceOrder(v15 + 120);
          HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeThroughTime(v15 + 120, *(double *)(v15 + 128));
          double v20 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_statisticsFromFinishedBucket(v15, v15 + 120);
          int v21 = [v19 startDate];
          [v21 timeIntervalSinceReferenceDate];
          double v23 = v22;
          double v24 = [v19 endDate];
          [v24 timeIntervalSinceReferenceDate];
          HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::advanceBucket(v15 + 112, v23, v25);

          if (v20)
          {
            char v26 = _Block_copy(*(const void **)(v15 + 96));
            double v27 = v26;
            if (v26) {
              (*((void (**)(void *, void *))v26 + 2))(v26, v20);
            }
          }
          _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_didChangeBucket(v15, 0);
        }
      }
    }
  }
  return v14;
}

void sub_1BD17B1B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  double v7 = *(double *)(a1 + 32) - a6;
  if (v7 >= 0.01)
  {
    if (a7 - a6 - v7 >= 0.01)
    {
      int v8 = 1;
      a6 = *(double *)(a1 + 32);
    }
    else
    {
      a2 = 0;
      int v8 = 0;
      a6 = 0.0;
      a7 = 0.0;
    }
  }
  else
  {
    int v8 = 1;
  }
  double v11 = a5;
  double v12 = a6;
  double v13 = a7;
  uint64_t v14 = a2;
  char v15 = v8;
  char v16 = 0;
  if (*(unsigned char *)(a1 + 56))
  {
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveAddSample(*(void *)(a1 + 48), (uint64_t)&v11, a3, a4);
    }
  }
  else
  {
    double v10 = *(double *)(a1 + 40) - a6;
    if (v10 >= 0.01)
    {
      if (a7 - a6 - v10 >= 0.01) {
        a7 = *(double *)(a1 + 40);
      }
    }
    else
    {
      int v8 = 0;
    }
    double v12 = a6;
    double v13 = a7;
    char v15 = v8;
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveAddSample(*(void *)(a1 + 48), (uint64_t)&v11, a3, a4);
    }
  }
  return 1;
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4(uint64_t a1, double a2)
{
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeToTime(uint64_t a1, double a2)
{
  if (*(unsigned char *)(a1 + 728)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_configureForStartTime(a1);
  }
  if (*(void *)(a1 + 40)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_advanceToTime(a1, a2);
  }
  if (*(double *)(a1 + 128) > a2)
  {
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_mergeThroughTime(a1 + 120, a2);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(double *)(a2 - 32) < *(double *)(v10 + 8))
                {
                  uint64_t v129 = *(void *)(v10 + 32);
                  long long v113 = *(_OWORD *)v10;
                  long long v121 = *(_OWORD *)(v10 + 16);
                  long long v52 = *(_OWORD *)(a2 - 40);
                  long long v53 = *(_OWORD *)(a2 - 24);
                  *(_WORD *)(v10 + 32) = *(_WORD *)(a2 - 8);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 16) = v53;
                  *(_WORD *)(a2 - 8) = v129;
                  *(_OWORD *)(a2 - 24) = v121;
                  *(_OWORD *)(a2 - 40) = v113;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v10, (double *)(v10 + 40), (double *)(a2 - 40));
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, a2 - 40);
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, v10 + 120, a2 - 40);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 959)
          {
            unint64_t v54 = (void *)(v10 + 40);
            BOOL v56 = v10 == a2 || v54 == (void *)a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  unint64_t v59 = v54;
                  double v60 = *(double *)(v58 + 48);
                  if (v60 < *(double *)(v58 + 8))
                  {
                    uint64_t v61 = *v54;
                    long long v114 = *(_OWORD *)(v58 + 56);
                    uint64_t v122 = *(void *)(v58 + 72);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      uint64_t v63 = v10 + v62;
                      long long v64 = *(_OWORD *)(v10 + v62 + 16);
                      *(_OWORD *)(v63 + 40) = *(_OWORD *)(v10 + v62);
                      *(_OWORD *)(v63 + 56) = v64;
                      *(_WORD *)(v63 + 72) = *(_WORD *)(v10 + v62 + 32);
                      if (!v62) {
                        break;
                      }
                      v62 -= 40;
                      if (v60 >= *(double *)(v63 - 32))
                      {
                        uint64_t v65 = v10 + v62 + 40;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_81:
                    *(void *)uint64_t v65 = v61;
                    *(double *)(v65 + 8) = v60;
                    *(_OWORD *)(v65 + 16) = v114;
                    *(_WORD *)(v65 + 32) = v122;
                  }
                  unint64_t v54 = v59 + 5;
                  v57 += 40;
                  unint64_t v58 = (unint64_t)v59;
                }
                while (v59 + 5 != (void *)a2);
              }
            }
            else if (!v56)
            {
              do
              {
                int v98 = v54;
                double v99 = *(double *)(a1 + 48);
                if (v99 < *(double *)(a1 + 8))
                {
                  uint64_t v100 = *v54;
                  long long v117 = *(_OWORD *)(a1 + 56);
                  uint64_t v125 = *(void *)(a1 + 72);
                  long long v101 = v54;
                  do
                  {
                    long long v102 = *(_OWORD *)(v101 - 3);
                    *(_OWORD *)long long v101 = *(_OWORD *)(v101 - 5);
                    *((_OWORD *)v101 + 1) = v102;
                    *((_WORD *)v101 + 16) = *((_WORD *)v101 - 4);
                    double v103 = *((double *)v101 - 9);
                    v101 -= 5;
                  }
                  while (v99 < v103);
                  void *v101 = v100;
                  *((double *)v101 + 1) = v99;
                  *((_WORD *)v101 + 16) = v125;
                  *((_OWORD *)v101 + 1) = v117;
                }
                v54 += 5;
                a1 = (unint64_t)v98;
              }
              while (v98 + 5 != (void *)a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 40 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)(v10 + 40 * v69 + 8) < *(double *)(v70 + 48))
                  {
                    v70 += 40;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  double v71 = *(double *)(v10 + 40 * v68 + 8);
                  if (*(double *)(v70 + 8) >= v71)
                  {
                    unint64_t v72 = v10 + 40 * v68;
                    uint64_t v73 = *(void *)v72;
                    uint64_t v123 = *(void *)(v72 + 32);
                    long long v115 = *(_OWORD *)(v72 + 16);
                    do
                    {
                      unint64_t v74 = v72;
                      unint64_t v72 = v70;
                      long long v75 = *(_OWORD *)v70;
                      long long v76 = *(_OWORD *)(v70 + 16);
                      *(_WORD *)(v74 + 32) = *(_WORD *)(v70 + 32);
                      *(_OWORD *)unint64_t v74 = v75;
                      *(_OWORD *)(v74 + 16) = v76;
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v77 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 40 * v77;
                      uint64_t v78 = 2 * v69 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v10 + 40 * v77 + 8) < *(double *)(v70 + 48))
                      {
                        v70 += 40;
                        uint64_t v77 = v78;
                      }
                      uint64_t v69 = v77;
                    }
                    while (*(double *)(v70 + 8) >= v71);
                    *(void *)unint64_t v72 = v73;
                    *(double *)(v72 + 8) = v71;
                    *(_OWORD *)(v72 + 16) = v115;
                    *(_WORD *)(v72 + 32) = v123;
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              int64_t v79 = v11 / 0x28uLL;
              do
              {
                uint64_t v80 = 0;
                uint64_t v130 = *(void *)(v10 + 32);
                long long v116 = *(_OWORD *)v10;
                long long v124 = *(_OWORD *)(v10 + 16);
                unint64_t v81 = v10;
                do
                {
                  unint64_t v82 = v81;
                  uint64_t v83 = v80 + 1;
                  v81 += 40 * (v80 + 1);
                  uint64_t v84 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  int64_t v85 = v84 + 2;
                  if (v85 < v79 && *(double *)(v82 + 40 * v83 + 8) < *(double *)(v81 + 48))
                  {
                    v81 += 40;
                    uint64_t v80 = v85;
                  }
                  long long v86 = *(_OWORD *)v81;
                  long long v87 = *(_OWORD *)(v81 + 16);
                  *(_WORD *)(v82 + 32) = *(_WORD *)(v81 + 32);
                  *(_OWORD *)unint64_t v82 = v86;
                  *(_OWORD *)(v82 + 16) = v87;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 40;
                if (v81 == a2)
                {
                  *(_WORD *)(v81 + 32) = v130;
                  *(_OWORD *)unint64_t v81 = v116;
                  *(_OWORD *)(v81 + 16) = v124;
                }
                else
                {
                  long long v88 = *(_OWORD *)a2;
                  long long v89 = *(_OWORD *)(a2 + 16);
                  *(_WORD *)(v81 + 32) = *(_WORD *)(a2 + 32);
                  *(_OWORD *)unint64_t v81 = v88;
                  *(_OWORD *)(v81 + 16) = v89;
                  *(_WORD *)(a2 + 32) = v130;
                  *(_OWORD *)a2 = v116;
                  *(_OWORD *)(a2 + 16) = v124;
                  uint64_t v90 = v81 - v10 + 40;
                  if (v90 >= 41)
                  {
                    unint64_t v91 = (v90 / 0x28uLL - 2) >> 1;
                    double v92 = *(double *)(v81 + 8);
                    if (*(double *)(v10 + 40 * v91 + 8) < v92)
                    {
                      uint64_t v93 = *(void *)v81;
                      uint64_t v109 = *(void *)(v81 + 32);
                      long long v106 = *(_OWORD *)(v81 + 16);
                      do
                      {
                        unint64_t v94 = v81;
                        unint64_t v81 = v10 + 40 * v91;
                        long long v95 = *(_OWORD *)v81;
                        long long v96 = *(_OWORD *)(v81 + 16);
                        *(_WORD *)(v94 + 32) = *(_WORD *)(v81 + 32);
                        *(_OWORD *)unint64_t v94 = v95;
                        *(_OWORD *)(v94 + 16) = v96;
                        if (!v91) {
                          break;
                        }
                        unint64_t v91 = (v91 - 1) >> 1;
                      }
                      while (*(double *)(v10 + 40 * v91 + 8) < v92);
                      *(void *)unint64_t v81 = v93;
                      *(double *)(v81 + 8) = v92;
                      *(_WORD *)(v81 + 32) = v109;
                      *(_OWORD *)(v81 + 16) = v106;
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 40 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x1401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40 * (v12 >> 1)), (double *)(a2 - 40));
            uint64_t v15 = 5 * v13;
            char v16 = (double *)(a1 + 40 * v13 - 40);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40), v16, (double *)(a2 - 80));
            double v17 = (double *)(a1 + 40 + 8 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 80), v17, (double *)(a2 - 120));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v16, (double *)v14, v17);
            uint64_t v126 = *(void *)(a1 + 32);
            long long v110 = *(_OWORD *)a1;
            long long v118 = *(_OWORD *)(a1 + 16);
            long long v18 = *(_OWORD *)v14;
            long long v19 = *(_OWORD *)(v14 + 16);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v14 + 32);
            *(_OWORD *)a1 = v18;
            *(_OWORD *)(a1 + 16) = v19;
            *(_WORD *)(v14 + 32) = v126;
            *(_OWORD *)unint64_t v14 = v110;
            *(_OWORD *)(v14 + 16) = v118;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40 * (v12 >> 1)), (double *)a1, (double *)(a2 - 40));
          }
          --a3;
          if (a4) {
            break;
          }
          double v20 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 32) < v20) {
            goto LABEL_12;
          }
          uint64_t v38 = *(void *)a1;
          long long v105 = *(_OWORD *)(a1 + 16);
          uint64_t v108 = *(void *)(a1 + 32);
          if (v20 >= *(double *)(a2 - 32))
          {
            unint64_t v41 = a1 + 40;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= a2) {
                break;
              }
              double v42 = *(double *)(v41 + 8);
              v41 += 40;
            }
            while (v20 >= v42);
          }
          else
          {
            unint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 40;
              double v40 = *(double *)(v39 + 48);
              v39 += 40;
            }
            while (v20 >= v40);
          }
          unint64_t v43 = a2;
          if (v10 < a2)
          {
            unint64_t v44 = a2;
            do
            {
              unint64_t v43 = v44 - 40;
              double v45 = *(double *)(v44 - 32);
              v44 -= 40;
            }
            while (v20 < v45);
          }
          while (v10 < v43)
          {
            uint64_t v128 = *(void *)(v10 + 32);
            long long v112 = *(_OWORD *)v10;
            long long v120 = *(_OWORD *)(v10 + 16);
            long long v46 = *(_OWORD *)v43;
            long long v47 = *(_OWORD *)(v43 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v43 + 32);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(_WORD *)(v43 + 32) = v128;
            *(_OWORD *)unint64_t v43 = v112;
            *(_OWORD *)(v43 + 16) = v120;
            do
            {
              double v48 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v20 >= v48);
            do
            {
              double v49 = *(double *)(v43 - 32);
              v43 -= 40;
            }
            while (v20 < v49);
          }
          BOOL v4 = v10 - 40 >= a1;
          BOOL v5 = v10 - 40 == a1;
          if (v10 - 40 != a1)
          {
            long long v50 = *(_OWORD *)(v10 - 40);
            long long v51 = *(_OWORD *)(v10 - 24);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 16) = v51;
          }
          a4 = 0;
          *(void *)(v10 - 40) = v38;
          *(double *)(v10 - 32) = v20;
          *(_WORD *)(v10 - 8) = v108;
          *(_OWORD *)(v10 - 24) = v105;
        }
        double v20 = *(double *)(a1 + 8);
LABEL_12:
        uint64_t v21 = 0;
        uint64_t v22 = *(void *)a1;
        long long v104 = *(_OWORD *)(a1 + 16);
        uint64_t v107 = *(void *)(a1 + 32);
        do
        {
          double v23 = *(double *)(a1 + v21 + 48);
          v21 += 40;
        }
        while (v23 < v20);
        unint64_t v24 = a1 + v21;
        unint64_t v25 = a2;
        if (v21 == 40)
        {
          unint64_t v28 = a2;
          while (v24 < v28)
          {
            unint64_t v26 = v28 - 40;
            double v29 = *(double *)(v28 - 32);
            v28 -= 40;
            if (v29 < v20) {
              goto LABEL_22;
            }
          }
          unint64_t v26 = v28;
        }
        else
        {
          do
          {
            unint64_t v26 = v25 - 40;
            double v27 = *(double *)(v25 - 32);
            v25 -= 40;
          }
          while (v27 >= v20);
        }
LABEL_22:
        unint64_t v10 = v24;
        if (v24 < v26)
        {
          unint64_t v30 = v26;
          do
          {
            uint64_t v127 = *(void *)(v10 + 32);
            long long v111 = *(_OWORD *)v10;
            long long v119 = *(_OWORD *)(v10 + 16);
            long long v31 = *(_OWORD *)v30;
            long long v32 = *(_OWORD *)(v30 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v30 + 32);
            *(_OWORD *)unint64_t v10 = v31;
            *(_OWORD *)(v10 + 16) = v32;
            *(_WORD *)(v30 + 32) = v127;
            *(_OWORD *)unint64_t v30 = v111;
            *(_OWORD *)(v30 + 16) = v119;
            do
            {
              double v33 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v33 < v20);
            do
            {
              double v34 = *(double *)(v30 - 32);
              v30 -= 40;
            }
            while (v34 >= v20);
          }
          while (v10 < v30);
        }
        if (v10 - 40 != a1)
        {
          long long v35 = *(_OWORD *)(v10 - 40);
          long long v36 = *(_OWORD *)(v10 - 24);
          *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
        }
        *(void *)(v10 - 40) = v22;
        *(double *)(v10 - 32) = v20;
        *(_WORD *)(v10 - 8) = v107;
        *(_OWORD *)(v10 - 24) = v104;
        if (v24 >= v26) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(a1, v10 - 40, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, v10 - 40);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 40;
    if (!v37) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 32) < *(double *)(a1 + 8))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        long long v7 = *(_OWORD *)a1;
        long long v8 = *(_OWORD *)(a1 + 16);
        __int16 v9 = *(_WORD *)(a2 - 8);
        long long v10 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
        *(_OWORD *)(a1 + 16) = v10;
        *(_WORD *)(a1 + 32) = v9;
        *(_OWORD *)(a2 - 24) = v8;
        *(_OWORD *)(a2 - 40) = v7;
        *(_WORD *)(a2 - 8) = v6;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a2 - 40));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a1 + 120, a2 - 40);
      return 1;
    default:
      uint64_t v11 = a1 + 80;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a1 + 80));
      uint64_t v12 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (1)
  {
    double v15 = *(double *)(v12 + 8);
    if (v15 < *(double *)(v11 + 8))
    {
      uint64_t v16 = *(void *)v12;
      long long v21 = *(_OWORD *)(v12 + 16);
      uint64_t v22 = *(void *)(v12 + 32);
      uint64_t v17 = v13;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        long long v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(_WORD *)(v18 + 152) = *(_WORD *)(a1 + v17 + 112);
        if (v17 == -80) {
          break;
        }
        v17 -= 40;
        if (v15 >= *(double *)(v18 + 48))
        {
          uint64_t v20 = a1 + v17 + 120;
          goto LABEL_12;
        }
      }
      uint64_t v20 = a1;
LABEL_12:
      *(void *)uint64_t v20 = v16;
      *(double *)(v20 + 8) = v15;
      *(_OWORD *)(v20 + 16) = v21;
      *(_WORD *)(v20 + 32) = v22;
      if (++v14 == 8) {
        return v12 + 40 == a2;
      }
    }
    uint64_t v11 = v12;
    v13 += 40;
    v12 += 40;
    if (v12 == a2) {
      return 1;
    }
  }
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke(void *a1, uint64_t a2)
{
  id v3 = (void *)a1[5];
  uint64_t v4 = a1[6];
  BOOL v5 = (void *)a1[4];
  uint64_t v6 = [v5 dateInterval];
  void v9[4] = v4;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2;
  v10[3] = &__block_descriptor_40_e24_B52__0d8d16d24q32B40__44l;
  v10[4] = v4;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3;
  v9[3] = &__block_descriptor_40_e8_v16__0d8l;
  uint64_t v7 = [v3 collectionCalculator:v5 queryForInterval:v6 error:a2 sampleHandler:v10 mergeHandler:v9];

  return v7;
}

void sub_1BD17BF34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  uint64_t v10 = *(void *)(a1 + 32);
  *(double *)int v14 = a5;
  *(double *)&v14[1] = a6;
  *(double *)&v14[2] = a7;
  v14[3] = a2;
  char v15 = 1;
  uint64_t v11 = [MEMORY[0x1E4F1C9C8] distantFuture];
  [v11 timeIntervalSinceReferenceDate];
  BOOL v16 = v12 <= a7;

  return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>::_primitiveAddSample(v10, (uint64_t)v14, a3, a4);
}

void sub_1BD17BFD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, double a2)
{
}

void HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::archive(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F171B978;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  statistics::Statistics::makePrimaryStatistics(a1);
  HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>::archive((uint64_t)&v3, (HDStatisticsSleepStages *)(a2 + 8));
}

void sub_1BD17C060()
{
  statistics::Statistics::operator=(*(statistics **)(v0 + 128), (uint64_t)v4);
  statistics::Statistics::~Statistics((statistics::Statistics *)v4);
  uint64_t v3 = v1->i32[0];
  *(_DWORD *)(v0 + 204) |= 0x100u;
  *(void *)(v0 + 136) = v3;
  statistics::Statistics::makeMostRecentDatum(v0);
  v4[0] = &unk_1F17206F8;
  int v8 = 127;
  int8x16_t v5 = vextq_s8(v1[13], v1[13], 8uLL);
  v4[1] = v1[14].i64[0];
  v4[2] = v1[14].i64[1];
  __int16 v6 = 0;
  char v7 = 0;
  statistics::RawQuantitySample::operator=(*v2, (uint64_t)v4);
  PB::Base::~Base((PB::Base *)v4);
}

void sub_1BD17C108(_Unwind_Exception *a1)
{
  statistics::Statistics::~Statistics(v1);
  _Unwind_Resume(a1);
}

void HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>::archive(uint64_t a1, HDStatisticsSleepStages *a2)
{
  *(void *)a1 = &unk_1F171B978;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 112) = 0;
  statistics::Statistics::makePrimaryStatistics(a1);
  HDStatisticsSleepStages::archive(a2);
}

void sub_1BD17C190()
{
  statistics::Statistics::operator=(*(statistics **)(v0 + 128), (uint64_t)v3);
  statistics::Statistics::~Statistics((statistics::Statistics *)v3);
  statistics::Statistics::makeAuxiliaryStatistics(v0);
  HDStatisticsTimeInterval::archive((HDStatisticsTimeInterval *)(v1 + 160), (uint64_t)v3);
  statistics::Statistics::operator=(*v2, (uint64_t)v3);
  statistics::Statistics::~Statistics((statistics::Statistics *)v3);
}

void sub_1BD17C1E0(_Unwind_Exception *a1)
{
  statistics::Statistics::~Statistics(v1);
  _Unwind_Resume(a1);
}

double HDStatisticsRelative<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::unarchive(uint64_t a1, void *a2)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  int8x16_t v5 = (_OWORD *)(a1 + 8);
  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = xmmword_1BD330210;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 64) = xmmword_1BD330220;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 88) = xmmword_1BD330230;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = xmmword_1BD330240;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 136) = xmmword_1BD330250;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0x7FFFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 226) = 0u;
  __int16 v6 = (const statistics::Statistics *)a2[16];
  if (v6)
  {
    HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>::unarchive((uint64_t)v14, v6);
    long long v7 = v14[7];
    v5[6] = v14[6];
    v5[7] = v7;
    long long v8 = v14[9];
    v5[8] = v14[8];
    v5[9] = v8;
    long long v9 = v14[3];
    v5[2] = v14[2];
    v5[3] = v9;
    long long v10 = v14[5];
    v5[4] = v14[4];
    v5[5] = v10;
    long long v11 = v14[1];
    *int8x16_t v5 = v14[0];
    v5[1] = v11;
    *(void *)(a1 + 168) = v15;
    *(_OWORD *)(a1 + 176) = v16;
    *(void *)(a1 + 192) = v17;
    double result = v18;
    *(double *)(a1 + 200) = v18;
  }
  *(_DWORD *)a1 = a2[17];
  uint64_t v12 = a2[14];
  if (v12)
  {
    double result = *(double *)(v12 + 8);
    uint64_t v13 = *(void *)(v12 + 16);
    *(int8x16_t *)(a1 + 208) = vextq_s8(*(int8x16_t *)(v12 + 24), *(int8x16_t *)(v12 + 24), 8uLL);
    *(double *)(a1 + 224) = result;
    *(void *)(a1 + 232) = v13;
    *(_WORD *)(a1 + 240) = 1;
  }
  return result;
}

double HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>::unarchive(uint64_t a1, const statistics::Statistics *a2)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = xmmword_1BD330210;
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 56) = xmmword_1BD330220;
  *(void *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 80) = xmmword_1BD330230;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 104) = xmmword_1BD330240;
  *(void *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 128) = xmmword_1BD330250;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0x7FFFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(void *)(a1 + 192) = 0;
  uint64_t v4 = (HDStatisticsSleepStages *)*((void *)a2 + 16);
  if (v4) {
    HDStatisticsSleepStages::unarchive(v4, a2);
  }
  int8x16_t v5 = (HDStatisticsTimeInterval *)*((void *)a2 + 1);
  if (v5)
  {
    HDStatisticsTimeInterval::unarchive(v5, (uint64_t)v7);
    *(void *)(a1 + 160) = v7[0];
    double result = *(double *)&v7[4];
    uint64_t v6 = v7[3];
    *(_OWORD *)(a1 + 168) = *(_OWORD *)&v7[1];
    *(void *)(a1 + 184) = v6;
    *(double *)(a1 + 192) = result;
  }
  return result;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_HDConcreteStatisticsCollectionCalculatorImplementation(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  char v6 = a3;
  uint64_t v8 = _HDStatisticsCollectionCalculatorImplementation::_HDStatisticsCollectionCalculatorImplementation(a1, a2, a3, a4, a5, a6);
  *(void *)uint64_t v8 = &unk_1F17269E0;
  double v9 = 900.0;
  if ((v6 & 0x10) == 0) {
    double v9 = 0.0;
  }
  *(double *)(v8 + 56) = v9;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(void *)(v8 + 104) = 0;
  *(void *)(v8 + 112) = 0;
  *(void *)(v8 + 96) = 0;
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::HDStatisticsBucket(v8 + 120, 0, -1.79769313e308, 1.79769313e308);
  *(_OWORD *)(a1 + 648) = 0u;
  *(_OWORD *)(a1 + 664) = 0u;
  *(_WORD *)(a1 + 680) = 1;
  *(unsigned char *)(a1 + 682) = 0;
  *(unsigned char *)(a1 + 684) = 0;
  *(void *)(a1 + 688) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_OWORD *)(a1 + 712) = 0u;
  *(void *)(a1 + 728) = 0;
  return a1;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~_HDConcreteStatisticsCollectionCalculatorImplementation(uint64_t a1)
{
  _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~_HDConcreteStatisticsCollectionCalculatorImplementation(a1);

  JUMPOUT(0x1C187B8A0);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)a1 = &unk_1F17269E0;
  unint64_t v2 = *(void **)(a1 + 712);
  if (v2)
  {
    *(void *)(a1 + 720) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)(a1 + 648);
  if (v3)
  {
    *(void *)(a1 + 656) = v3;
    operator delete(v3);
  }
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsBucket(a1 + 120);
  objc_destroyWeak((id *)(a1 + 104));

  uint64_t v4 = *(void **)(a1 + 72);
  if (v4)
  {
    *(void *)(a1 + 80) = v4;
    operator delete(v4);
  }

  _HDStatisticsCollectionCalculatorImplementation::~_HDStatisticsCollectionCalculatorImplementation((_HDStatisticsCollectionCalculatorImplementation *)a1);
}

double _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::mergeGranularity(uint64_t a1)
{
  return *(double *)(a1 + 56);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::setMergeGranularity(uint64_t result, double a2)
{
  if (*(double *)(result + 56) != a2)
  {
    *(double *)(result + 56) = a2;
    *(unsigned char *)(result + 680) = 1;
  }
  return result;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::dateInterval(uint64_t a1)
{
  return *(id *)(a1 + 64);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::setDateInterval(uint64_t a1, void *a2)
{
  id v6 = a2;
  uint64_t v3 = [v6 copy];
  uint64_t v4 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = v3;

  int8x16_t v5 = [v6 startDate];
  [v5 timeIntervalSinceReferenceDate];
  _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_configureForStartTime(a1);
}

void sub_1BD17C5DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::configureMergeAnchor(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!*(void *)(a1 + 40))
  {
    id v5 = v3;
    [v3 timeIntervalSinceReferenceDate];
    *(void *)(a1 + 688) = v4;
    id v3 = v5;
  }
}

void sub_1BD17C650(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::setStatisticsConfiguration(id *a1, void *a2)
{
  objc_storeStrong(a1 + 87, a2);
  id v7 = a2;
  id v4 = a1[87];
  id v5 = a1[84];
  a1[84] = v4;
  id v6 = v4;

  objc_storeStrong(a1 + 19, a1[84]);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::setIntervalMask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = (char *)(a1 + 72);
  if (v6 != (char *)a2) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(v6, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  }
  if (*(void *)(a1 + 40)) {
    return 1;
  }
  BOOL v7 = *(void *)(a1 + 224) == *(void *)(a1 + 216) && *(uint64_t *)(a1 + 240) < 1
    || HKIntervalMask<double>::firstDifference(*(void *)(a1 + 184), *(void *)(a1 + 192), *(void *)a2, *(void *)(a2 + 8)) >= *(double *)(a1 + 176);
  if (a1 + 184 != a2) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((char *)(a1 + 184), *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  }
  if (v7) {
    return 1;
  }
  double v9 = *(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 128);

  return v9(a1, 0, a3);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::setStatisticsHandler(uint64_t a1, void *a2)
{
  id v5 = a2;
  uint64_t v3 = [v5 copy];
  id v4 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = v3;
}

void sub_1BD17C838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::dataSource(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 104));

  return WeakRetained;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::setDataSource(uint64_t a1, void *a2)
{
  return objc_storeWeak((id *)(a1 + 104), a2);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::currentStatistics(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 680))
  {
    uint64_t v1 = 0;
  }
  else
  {
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::HDStatisticsBucket((uint64_t)v4, a1 + 120);
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_updateSourceOrder((uint64_t)v4);
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeThroughTime((uint64_t)v4, v4[1]);
    uint64_t v1 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsFromFinishedBucket(a1, (uint64_t)v4);
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsBucket((uint64_t)v4);
  }

  return v1;
}

void sub_1BD17C908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(uint64_t a1, double *a2, uint64_t a3)
{
  id v6 = *(id *)(a1 + 64);
  BOOL v7 = v6;
  if (!v6) {
    goto LABEL_4;
  }
  uint64_t v8 = [v6 startDate];
  [v8 timeIntervalSinceReferenceDate];
  if (v9 > a2[2])
  {

    goto LABEL_10;
  }
  long long v10 = [v7 endDate];
  [v10 timeIntervalSinceReferenceDate];
  double v12 = v11;
  double v13 = a2[1];

  if (v12 >= v13)
  {
LABEL_4:
    if (!*(unsigned char *)(a1 + 682)) {
      goto LABEL_21;
    }
    if (!*(unsigned char *)(a1 + 681))
    {
      if (*(void *)(a1 + 40))
      {
        if (*(unsigned char *)(a1 + 680))
        {
          double v14 = -1.79769313e308;
        }
        else
        {
          double v16 = *(double *)(a1 + 176);
          double v14 = *(double *)(a1 + 120);
          if (v16 <= v14) {
            double v16 = -1.79769313e308;
          }
          if (v16 >= v14) {
            double v14 = v16;
          }
        }
      }
      else
      {
        double v14 = -1.79769313e308;
        if (*(double *)(a1 + 176) > *(double *)(a1 + 120)) {
          double v14 = *(double *)(a1 + 176);
        }
      }
      if (v14 > a2[1])
      {
        uint64_t v17 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:");
        uint64_t v15 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v17, a3);

        goto LABEL_22;
      }
      if (*(unsigned char *)(a1 + 683))
      {
LABEL_21:
        uint64_t v15 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveAddSample(a1, a2, 1, a3);
        goto LABEL_22;
      }
      unint64_t v19 = *(void *)(a1 + 720);
      unint64_t v20 = *(void *)(a1 + 728);
      if (v19 >= v20)
      {
        uint64_t v24 = *(void *)(a1 + 712);
        unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v19 - v24) >> 3);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0x666666666666666) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - v24) >> 3);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x333333333333333) {
          unint64_t v28 = 0x666666666666666;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28) {
          unint64_t v28 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v28);
        }
        else {
          uint64_t v29 = 0;
        }
        unint64_t v30 = v28 + 40 * v25;
        unint64_t v31 = v28 + 40 * v29;
        long long v32 = *(_OWORD *)a2;
        long long v33 = *((_OWORD *)a2 + 1);
        *(double *)(v30 + 32) = a2[4];
        *(_OWORD *)unint64_t v30 = v32;
        *(_OWORD *)(v30 + 16) = v33;
        unint64_t v23 = v30 + 40;
        double v34 = *(char **)(a1 + 720);
        long long v35 = *(char **)(a1 + 712);
        if (v34 != v35)
        {
          do
          {
            long long v36 = *(_OWORD *)(v34 - 40);
            long long v37 = *(_OWORD *)(v34 - 24);
            *(_WORD *)(v30 - 8) = *((_WORD *)v34 - 4);
            *(_OWORD *)(v30 - 24) = v37;
            *(_OWORD *)(v30 - 40) = v36;
            v30 -= 40;
            v34 -= 40;
          }
          while (v34 != v35);
          double v34 = *(char **)(a1 + 712);
        }
        *(void *)(a1 + 712) = v30;
        *(void *)(a1 + 720) = v23;
        *(void *)(a1 + 728) = v31;
        if (v34) {
          operator delete(v34);
        }
      }
      else
      {
        long long v21 = *(_OWORD *)a2;
        long long v22 = *((_OWORD *)a2 + 1);
        *(double *)(v19 + 32) = a2[4];
        *(_OWORD *)unint64_t v19 = v21;
        *(_OWORD *)(v19 + 16) = v22;
        unint64_t v23 = v19 + 40;
      }
      *(void *)(a1 + 720) = v23;
    }
  }
LABEL_10:
  uint64_t v15 = 1;
LABEL_22:

  return v15;
}

void sub_1BD17CBC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::performAddSampleTransaction(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = v5;
  if (*(unsigned char *)(a1 + 682))
  {
    uint64_t v7 = (*((uint64_t (**)(id, uint64_t))v5 + 2))(v5, a3);
    goto LABEL_83;
  }
  *(_WORD *)(a1 + 682) = 1;
  uint64_t v67 = a3;
  if (!(*((unsigned int (**)(id, uint64_t))v5 + 2))(v5, a3))
  {
    uint64_t v7 = 0;
    goto LABEL_82;
  }
  uint64_t v65 = v6;
  if (*(unsigned char *)(a1 + 681)) {
    goto LABEL_5;
  }
  double v9 = *(void **)(a1 + 704);
  if (!v9)
  {
    id v68 = 0;
    goto LABEL_28;
  }
  if (!*(void *)(a1 + 40))
  {
LABEL_5:
    int v8 = 0;
    id v68 = 0;
    goto LABEL_29;
  }
  [v9 sortUsingComparator:&__block_literal_global_1115];
  id v68 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  id v10 = *(id *)(a1 + 704);
  uint64_t v11 = [v10 countByEnumeratingWithState:&v69 objects:v73 count:16];
  if (!v11)
  {

    id v12 = 0;
    goto LABEL_27;
  }
  id v12 = 0;
  uint64_t v13 = *(void *)v70;
  do
  {
    for (uint64_t i = 0; i != v11; ++i)
    {
      if (*(void *)v70 != v13) {
        objc_enumerationMutation(v10);
      }
      id v15 = *(id *)(*((void *)&v69 + 1) + 8 * i);
      double v16 = v15;
      if (v12)
      {
        uint64_t v17 = [v15 startDate];
        double v18 = [v12 endDate];
        int v19 = objc_msgSend(v17, "hk_isBeforeOrEqualToDate:", v18);

        if (v19)
        {
          unint64_t v20 = [v16 endDate];
          long long v21 = [v12 endDate];
          int v22 = objc_msgSend(v20, "hk_isAfterDate:", v21);

          if (!v22) {
            goto LABEL_21;
          }
          id v23 = objc_alloc(MEMORY[0x1E4F28C18]);
          uint64_t v24 = [v12 startDate];
          unint64_t v25 = [v16 endDate];
          id v26 = (id)[v23 initWithStartDate:v24 endDate:v25];
        }
        else
        {
          [v68 addObject:v12];
          id v26 = v16;
        }
        id v12 = v26;
      }
      else
      {
        id v12 = v15;
      }
LABEL_21:
    }
    uint64_t v11 = [v10 countByEnumeratingWithState:&v69 objects:v73 count:16];
  }
  while (v11);

  if (v12) {
    [v68 addObject:v12];
  }
LABEL_27:

LABEL_28:
  int v8 = 1;
LABEL_29:
  unint64_t v27 = *(void **)(a1 + 704);
  *(void *)(a1 + 704) = 0;

  *(unsigned char *)(a1 + 681) = 0;
  if (!v8)
  {
    unint64_t v38 = *(void *)(a1 + 712);
    *(void *)(a1 + 728) = 0;
    *(void *)(a1 + 720) = 0;
    *(void *)(a1 + 712) = 0;
    unint64_t v39 = v38;
    goto LABEL_47;
  }
  unint64_t v28 = [v68 lastObject];
  if (v28)
  {
    uint64_t v29 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_currentBucketInterval(a1);
    unint64_t v30 = [v29 endDate];
    unint64_t v31 = [v28 endDate];
    int v32 = objc_msgSend(v30, "hk_isBeforeOrEqualToDate:", v31);

    if (v32)
    {
      long long v33 = [v28 endDate];
      [v33 timeIntervalSinceReferenceDate];
      double v35 = v34;

      uint64_t v36 = *(void *)(a1 + 712);
      long long v37 = *(long long **)(a1 + 720);
      while ((long long *)v36 != v37)
      {
        if (*(double *)(v36 + 8) < v35)
        {
          if ((long long *)v36 != v37)
          {
            double v40 = (long long *)(v36 + 40);
            if ((long long *)(v36 + 40) != v37)
            {
              do
              {
                if (*((double *)v40 + 1) >= v35)
                {
                  long long v41 = *v40;
                  long long v42 = v40[1];
                  *(_WORD *)(v36 + 32) = *((_WORD *)v40 + 16);
                  *(_OWORD *)uint64_t v36 = v41;
                  *(_OWORD *)(v36 + 16) = v42;
                  v36 += 40;
                }
                double v40 = (long long *)((char *)v40 + 40);
              }
              while (v40 != v37);
              long long v37 = *(long long **)(a1 + 720);
            }
          }
          if ((long long *)v36 != v37) {
            *(void *)(a1 + 720) = v36;
          }
          break;
        }
        v36 += 40;
      }
    }
  }
  unint64_t v38 = *(void *)(a1 + 712);
  unint64_t v39 = *(void *)(a1 + 720);
  *(void *)(a1 + 728) = 0;
  *(void *)(a1 + 712) = 0;
  *(void *)(a1 + 720) = 0;
  if (![v68 count]) {
    goto LABEL_60;
  }
LABEL_47:
  id v43 = v68;
  long long __p = (void *)v38;
  if (v43)
  {
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    id v44 = v43;
    uint64_t v45 = [v44 countByEnumeratingWithState:&v69 objects:v73 count:16];
    if (v45)
    {
      uint64_t v46 = *(void *)v70;
      while (2)
      {
        for (uint64_t j = 0; j != v45; ++j)
        {
          if (*(void *)v70 != v46) {
            objc_enumerationMutation(v44);
          }
          id v48 = *(id *)(*((void *)&v69 + 1) + 8 * j);
          int v49 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveInvalidateInterval((id *)a1, v48, v67);

          if (!v49)
          {

            goto LABEL_70;
          }
        }
        uint64_t v45 = [v44 countByEnumeratingWithState:&v69 objects:v73 count:16];
        if (v45) {
          continue;
        }
        break;
      }
    }

LABEL_59:
    unint64_t v38 = (unint64_t)__p;
LABEL_60:
    unint64_t v51 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v39 - v38) >> 3));
    if (v39 == v38) {
      uint64_t v52 = 0;
    }
    else {
      uint64_t v52 = v51;
    }
    int v53 = 1;
    std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(v38, v39, v52, 1);
    long long __p = (void *)v38;
    if (v39 != v38)
    {
      unint64_t v54 = (double *)v38;
      uint64_t v50 = v67;
      do
      {
        int v55 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveAddSample(a1, v54, 1, v50);
        int v53 = v55;
        v54 += 5;
        if (v54 == (double *)v39) {
          char v56 = 0;
        }
        else {
          char v56 = v55;
        }
        uint64_t v50 = v67;
      }
      while ((v56 & 1) != 0);
    }
  }
  else
  {
    if (_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveInvalidateInterval((id *)a1, 0, v67))goto LABEL_59; {
LABEL_70:
    }
    int v53 = 0;
  }
  if (*(void *)(a1 + 40) && *(void *)(a1 + 656) != *(void *)(a1 + 648))
  {
    do
    {
      uint64_t v57 = objc_msgSend(*(id *)(a1 + 40), "dateIntervalAtIndex:", *(void *)(a1 + 112) + 1, v50, v65);
      HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_updateSourceOrder(a1 + 120);
      HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeThroughTime(a1 + 120, *(double *)(a1 + 128));
      unint64_t v58 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsFromFinishedBucket(a1, a1 + 120);
      unint64_t v59 = [v57 startDate];
      [v59 timeIntervalSinceReferenceDate];
      double v61 = v60;
      uint64_t v62 = [v57 endDate];
      [v62 timeIntervalSinceReferenceDate];
      HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::advanceBucket(a1 + 112, v61, v63);

      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_didChangeBucket(a1, v58);
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_notifyForCurrentBucket(a1);
    }
    while (*(void *)(a1 + 656) != *(void *)(a1 + 648));
  }
  *(unsigned char *)(a1 + 682) = 0;
  if (__p) {
    operator delete(__p);
  }

  if (v53)
  {
    if (*(unsigned char *)(a1 + 684))
    {
      *(unsigned char *)(a1 + 684) = 0;
      id v6 = v65;
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_notifyForCurrentBucket(a1);
      uint64_t v7 = 1;
      goto LABEL_82;
    }
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = 0;
  }
  id v6 = v65;
LABEL_82:
  *(unsigned char *)(a1 + 682) = 0;
LABEL_83:

  return v7;
}

void sub_1BD17D2C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, void *a12)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    *(unsigned char *)(v13 + 682) = 0;
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::enableImmediateSampleInsertion(uint64_t result)
{
  *(unsigned char *)(result + 683) = 1;
  return result;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::invalidateInterval(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = *(void **)(a1 + 40);
  if (!v6)
  {

    goto LABEL_11;
  }
  if (!v5)
  {
LABEL_11:
    if (*(unsigned char *)(a1 + 682)) {
      goto LABEL_12;
    }
    uint64_t v7 = 0;
LABEL_14:
    uint64_t v11 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveInvalidateInterval((id *)a1, v7, a3);
    goto LABEL_15;
  }
  uint64_t v7 = [v6 dateIntervalForIntervalsContainingInterval:v5];

  if (!*(unsigned char *)(a1 + 682)) {
    goto LABEL_14;
  }
  if (!v7)
  {
LABEL_12:
    id v12 = *(void **)(a1 + 704);
    *(void *)(a1 + 704) = 0;

    uint64_t v7 = 0;
    uint64_t v11 = 1;
    *(unsigned char *)(a1 + 681) = 1;
    goto LABEL_15;
  }
  if (!*(unsigned char *)(a1 + 681))
  {
    int v8 = *(void **)(a1 + 704);
    if (!v8)
    {
      id v9 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      id v10 = *(void **)(a1 + 704);
      *(void *)(a1 + 704) = v9;

      int v8 = *(void **)(a1 + 704);
    }
    [v8 addObject:v7];
  }
  uint64_t v11 = 1;
LABEL_15:

  return v11;
}

void sub_1BD17D5C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::queryForInitialStatistics(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 104));
  if (WeakRetained)
  {
    *(unsigned char *)(a1 + 680) = 1;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke;
    v9[3] = &unk_1E63043E8;
    uint64_t v12 = a1;
    id v10 = v5;
    id v11 = WeakRetained;
    uint64_t v7 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 112))(a1, v9, a3);
    if (v7 && *(unsigned char *)(a1 + 680) && !*(void *)(a1 + 40)) {
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_configureForStartTime(a1);
    }
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a3, 3, @"Unable to query for initial statistics: no data source available.");
    uint64_t v7 = 0;
  }

  return v7;
}

void sub_1BD17D71C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::reset(uint64_t result)
{
  *(unsigned char *)(result + 680) = 1;
  return result;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::encodeInternalsWithEncoder(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 encodeBool:*(unsigned __int8 *)(a1 + 680) forKey:@"needs_config"];
  v3;
  v27[0] = &unk_1F1726FA0;
  v27[1] = 0;
  int v28 = 0;
  uint64_t v4 = *(void *)(a1 + 112);
  LOBYTE(v28) = 1;
  v27[2] = v4;
  memset(&v27[3], 0, 24);
  statistics::StatisticsEngine::makeCurrentBucket((uint64_t)v27);
  int v8 = &unk_1F171B9C8;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  int v26 = 511;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v22 = 0;
  int8x16_t v9 = vextq_s8(*(int8x16_t *)(a1 + 120), *(int8x16_t *)(a1 + 120), 8uLL);
  uint64_t v5 = *(void *)(a1 + 136);
  char v24 = *(unsigned char *)(a1 + 144);
  char v25 = *(unsigned char *)(a1 + 145);
  BOOL v23 = *(_DWORD *)(a1 + 148) == 0;
  int8x16_t v10 = vextq_s8(*(int8x16_t *)(a1 + 160), *(int8x16_t *)(a1 + 160), 8uLL);
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v14 = v5;
  uint64_t v15 = v6;
  uint64_t v7 = *(int8x16_t **)(a1 + 216);
  if (v7 != *(int8x16_t **)(a1 + 224))
  {
    v29[0] = &unk_1F17206F8;
    int v34 = 127;
    int8x16_t v30 = vextq_s8(*v7, *v7, 8uLL);
    v29[1] = v7[1].i64[0];
    v29[2] = v7[1].i64[1];
    char v33 = 0;
    __int8 v32 = v7[2].i8[9];
    __int8 v31 = v7[2].i8[10];
    PB::PtrVector<statistics::RawQuantitySample>::emplace_back<statistics::RawQuantitySample&>();
  }
  statistics::StatisticsBucket::makeStatistics((uint64_t)&v8);
  HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>::archive((uint64_t)v29, (HDStatisticsSleepStages *)(a1 + 240));
}

void sub_1BD17DB1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&a35);

  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::decodeInternalsWithDecoder(uint64_t a1, void *a2)
{
  id v61 = a2;
  *(unsigned char *)(a1 + 680) = [v61 decodeBoolForKey:@"needs_config"];
  id v3 = v61;
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::HDStatisticsBucket((uint64_t)v66, 0, -1.79769313e308, 1.79769313e308);
  long long v67 = 0u;
  long long v68 = 0u;
  unint64_t v112 = 0;
  id v64 = v3;
  PB::Reader::Reader((PB::Reader *)v111, (const unsigned __int8 *)[v64 decodeBytesForKey:@"hdsce_archived_representation" returnedLength:&v112]);
  uint64_t v63 = a1;
  long long v104 = &unk_1F1726FA0;
  uint64_t v105 = 0;
  uint64_t v109 = 0;
  uint64_t v107 = 0;
  uint64_t v108 = 0;
  int v110 = 0;
  statistics::StatisticsEngine::readFrom((statistics::StatisticsEngine *)&v104, (PB::Reader *)v111);
  uint64_t v65 = v106;
  if (v105)
  {
    uint64_t v73 = 0;
    memset(v76, 0, sizeof(v76));
    long long __p = 0u;
    memset(v78, 0, sizeof(v78));
    long long v79 = xmmword_1BD330210;
    *(_OWORD *)&v80[8] = xmmword_1BD330220;
    *(void *)uint64_t v80 = 0;
    *(void *)&v80[24] = 0;
    long long v81 = xmmword_1BD330230;
    *(_OWORD *)&v82[8] = xmmword_1BD330240;
    *(void *)unint64_t v82 = 0;
    *(void *)&v82[24] = 0;
    long long v83 = xmmword_1BD330250;
    *(void *)&long long v84 = 0;
    *((void *)&v84 + 1) = 0x7FFFFFFFFFFFFFFFLL;
    memset(v85, 0, sizeof(v85));
    long long v88 = 0;
    uint64_t v89 = 0;
    uint64_t v86 = 0;
    long long v87 = &v88;
    long long v90 = 0u;
    long long v91 = 0u;
    int v92 = 1065353216;
    long long v93 = 0u;
    long long v94 = 0u;
    long long v95 = 0u;
    uint64_t v96 = 0;
    int v97 = 1065353216;
    long long v98 = 0u;
    long long v99 = 0u;
    int v100 = 1065353216;
    long long v101 = 0u;
    long long v102 = 0u;
    int v103 = 1065353216;
    int8x16_t v69 = vextq_s8(*(int8x16_t *)(v105 + 8), *(int8x16_t *)(v105 + 8), 8uLL);
    uint64_t v4 = *(void *)(v105 + 72);
    uint64_t v70 = *(void *)(v105 + 64);
    char v71 = *(unsigned char *)(v105 + 185);
    char v72 = *(unsigned char *)(v105 + 186);
    int8x16_t v74 = vextq_s8(*(int8x16_t *)(v105 + 24), *(int8x16_t *)(v105 + 24), 8uLL);
    uint64_t v75 = v4;
    uint64_t v5 = *(void *)(v105 + 80);
    uint64_t v6 = *(void *)(v105 + 88);
    uint64_t v62 = (void *)v105;
    if (v5 != v6)
    {
      uint64_t v7 = 0;
      do
      {
        uint64_t v8 = *(void *)(*(void *)v5 + 24);
        uint64_t v9 = *(void *)(*(void *)v5 + 32);
        uint64_t v10 = *(void *)(*(void *)v5 + 8);
        uint64_t v11 = *(void *)(*(void *)v5 + 16);
        char v12 = *(unsigned char *)(*(void *)v5 + 41);
        char v13 = *(unsigned char *)(*(void *)v5 + 40);
        if ((unint64_t)v7 >= v78[0])
        {
          uint64_t v14 = (void *)__p;
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v7 - __p) >> 4);
          unint64_t v16 = v15 + 1;
          if (v15 + 1 > 0x555555555555555) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          if (0x5555555555555556 * ((uint64_t)(v78[0] - __p) >> 4) > v16) {
            unint64_t v16 = 0x5555555555555556 * ((uint64_t)(v78[0] - __p) >> 4);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v78[0] - __p) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v17 = 0x555555555555555;
          }
          else {
            unint64_t v17 = v16;
          }
          if (v17)
          {
            unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v17);
            uint64_t v7 = (void *)*((void *)&__p + 1);
            uint64_t v14 = (void *)__p;
          }
          else
          {
            uint64_t v18 = 0;
          }
          unint64_t v19 = v17 + 48 * v15;
          *(void *)unint64_t v19 = v9;
          *(void *)(v19 + 8) = v8;
          *(void *)(v19 + 16) = v10;
          *(void *)(v19 + 24) = v11;
          *(_WORD *)(v19 + 32) = 1;
          *(unsigned char *)(v19 + 40) = 0;
          *(unsigned char *)(v19 + 41) = v12;
          *(unsigned char *)(v19 + 42) = v13;
          unint64_t v20 = v19;
          if (v7 != v14)
          {
            do
            {
              long long v21 = *((_OWORD *)v7 - 3);
              long long v22 = *((_OWORD *)v7 - 2);
              *(_OWORD *)(v20 - 21) = *(_OWORD *)((char *)v7 - 21);
              *(_OWORD *)(v20 - 48) = v21;
              *(_OWORD *)(v20 - 32) = v22;
              v20 -= 48;
              v7 -= 6;
            }
            while (v7 != v14);
            uint64_t v14 = (void *)__p;
          }
          uint64_t v7 = (void *)(v19 + 48);
          *(void *)&long long __p = v20;
          *((void *)&__p + 1) = v19 + 48;
          v78[0] = v17 + 48 * v18;
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          *uint64_t v7 = v9;
          v7[1] = v8;
          v7[2] = v10;
          v7[3] = v11;
          *((_WORD *)v7 + 16) = 1;
          *((unsigned char *)v7 + 40) = 0;
          *((unsigned char *)v7 + 41) = v12;
          *((unsigned char *)v7 + 42) = v13;
          v7 += 6;
        }
        *((void *)&__p + 1) = v7;
        v5 += 8;
      }
      while (v5 != v6);
    }
    BOOL v23 = (const statistics::Statistics *)v62[13];
    if (v23)
    {
      HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>::unarchive((uint64_t)&v113, v23);
      *(_OWORD *)unint64_t v82 = v119;
      *(_OWORD *)&v82[16] = v120;
      long long v83 = v121;
      long long v84 = v122;
      long long v79 = v115;
      *(_OWORD *)uint64_t v80 = v116;
      *(_OWORD *)&v80[16] = v117;
      long long v81 = v118;
      *(_OWORD *)&v78[1] = v113;
      *(_OWORD *)&v78[3] = v114;
      v85[0] = v123;
      if (v85[1])
      {
        v85[2] = v85[1];
        operator delete((void *)v85[1]);
      }
      *(_OWORD *)&v85[1] = v124;
      v85[3] = v125;
      uint64_t v125 = 0;
      long long v124 = 0uLL;
      uint64_t v86 = v126;
    }
    char v25 = (const statistics::Statistics **)v62[17];
    for (uint64_t i = (const statistics::Statistics **)v62[18]; v25 != i; ++v25)
    {
      int v26 = *v25;
      HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>::unarchive((uint64_t)&v113, *v25);
      uint64_t v27 = *((void *)v26 + 18);
      int v28 = v88;
      uint64_t v29 = &v88;
      int8x16_t v30 = &v88;
      if (v88)
      {
        do
        {
          while (1)
          {
            int8x16_t v30 = (uint64_t **)v28;
            uint64_t v31 = v28[4];
            if (v31 <= v27) {
              break;
            }
            int v28 = *v30;
            uint64_t v29 = v30;
            if (!*v30) {
              goto LABEL_34;
            }
          }
          if (v31 >= v27)
          {
            char v33 = (char *)v30;
            goto LABEL_37;
          }
          int v28 = v30[1];
        }
        while (v28);
        uint64_t v29 = v30 + 1;
      }
LABEL_34:
      char v33 = (char *)operator new(0xF0uLL);
      *((void *)v33 + 4) = v27;
      *(_OWORD *)(v33 + 40) = 0u;
      *(_OWORD *)(v33 + 56) = 0u;
      *(_OWORD *)(v33 + 72) = xmmword_1BD330210;
      *((void *)v33 + 11) = 0;
      *((_OWORD *)v33 + 6) = xmmword_1BD330220;
      *((void *)v33 + 14) = 0;
      *(_OWORD *)(v33 + 120) = xmmword_1BD330230;
      *((void *)v33 + 17) = 0;
      *((_OWORD *)v33 + 9) = xmmword_1BD330240;
      *((void *)v33 + 20) = 0;
      *(_OWORD *)(v33 + 168) = xmmword_1BD330250;
      *((void *)v33 + 23) = 0;
      *((void *)v33 + 24) = 0x7FFFFFFFFFFFFFFFLL;
      *(_OWORD *)(v33 + 200) = 0u;
      *(_OWORD *)(v33 + 216) = 0u;
      *((void *)v33 + 29) = 0;
      *(void *)char v33 = 0;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = v30;
      *uint64_t v29 = (uint64_t *)v33;
      __int8 v32 = (uint64_t *)v33;
      if (*v87)
      {
        long long v87 = (uint64_t **)*v87;
        __int8 v32 = *v29;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v88, v32);
      ++v89;
LABEL_37:
      long long v34 = v117;
      *(_OWORD *)(v33 + 120) = v118;
      *(_OWORD *)(v33 + 104) = v34;
      long long v35 = v115;
      *(_OWORD *)(v33 + 88) = v116;
      *(_OWORD *)(v33 + 72) = v35;
      long long v36 = v121;
      *(_OWORD *)(v33 + 184) = v122;
      *(_OWORD *)(v33 + 168) = v36;
      long long v37 = v119;
      *(_OWORD *)(v33 + 152) = v120;
      *(_OWORD *)(v33 + 136) = v37;
      long long v38 = v114;
      *(_OWORD *)(v33 + 40) = v113;
      *(_OWORD *)(v33 + 56) = v38;
      unint64_t v39 = (void *)*((void *)v33 + 26);
      *((void *)v33 + 25) = v123;
      if (v39)
      {
        *((void *)v33 + 27) = v39;
        operator delete(v39);
        *((void *)v33 + 26) = 0;
        *((void *)v33 + 27) = 0;
        *((void *)v33 + 28) = 0;
      }
      *((_OWORD *)v33 + 13) = v124;
      *((void *)v33 + 28) = v125;
      uint64_t v125 = 0;
      long long v124 = 0uLL;
      *((void *)v33 + 29) = v126;
    }
    uint64_t v40 = v62[5];
    for (uint64_t j = v62[6]; v40 != j; v40 += 8)
    {
      double v43 = *(double *)(*(void *)v40 + 8);
      double v42 = *(double *)(*(void *)v40 + 16);
      if (v43 >= v42) {
        double v44 = *(double *)(*(void *)v40 + 16);
      }
      else {
        double v44 = *(double *)(*(void *)v40 + 8);
      }
      if (v42 < v43) {
        double v42 = *(double *)(*(void *)v40 + 8);
      }
      HKIntervalMask<double>::_insertInterval(v76, v44, v42);
    }
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::operator=((uint64_t)v66, (uint64_t)&v69);
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsBucket((uint64_t)&v69);
  }
  uint64_t v45 = v107;
  uint64_t v46 = v108;
  if (v107 != v108)
  {
    unint64_t v47 = *((void *)&v67 + 1);
    do
    {
      uint64_t v48 = *(void *)(*(void *)v45 + 24);
      uint64_t v49 = *(void *)(*(void *)v45 + 32);
      uint64_t v50 = *(void *)(*(void *)v45 + 8);
      uint64_t v51 = *(void *)(*(void *)v45 + 16);
      if (v47 >= (unint64_t)v68)
      {
        uint64_t v52 = (void *)v67;
        unint64_t v53 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v47 - v67) >> 3);
        unint64_t v54 = v53 + 1;
        if (v53 + 1 > 0x666666666666666) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        if (0x999999999999999ALL * ((uint64_t)(v68 - v67) >> 3) > v54) {
          unint64_t v54 = 0x999999999999999ALL * ((uint64_t)(v68 - v67) >> 3);
        }
        if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v68 - v67) >> 3) >= 0x333333333333333) {
          unint64_t v55 = 0x666666666666666;
        }
        else {
          unint64_t v55 = v54;
        }
        if (v55)
        {
          unint64_t v55 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v55);
          unint64_t v47 = *((void *)&v67 + 1);
          uint64_t v52 = (void *)v67;
        }
        else
        {
          uint64_t v56 = 0;
        }
        unint64_t v57 = v55 + 40 * v53;
        *(void *)unint64_t v57 = v49;
        *(void *)(v57 + 8) = v48;
        *(void *)(v57 + 16) = v50;
        *(void *)(v57 + 24) = v51;
        *(_WORD *)(v57 + 32) = 1;
        unint64_t v58 = v57;
        if ((void *)v47 != v52)
        {
          do
          {
            long long v59 = *(_OWORD *)(v47 - 40);
            long long v60 = *(_OWORD *)(v47 - 24);
            *(_WORD *)(v58 - 8) = *(_WORD *)(v47 - 8);
            *(_OWORD *)(v58 - 24) = v60;
            *(_OWORD *)(v58 - 40) = v59;
            v58 -= 40;
            v47 -= 40;
          }
          while ((void *)v47 != v52);
          uint64_t v52 = (void *)v67;
        }
        *(void *)&long long v67 = v58;
        unint64_t v47 = v57 + 40;
        *((void *)&v67 + 1) = v57 + 40;
        *(void *)&long long v68 = v55 + 40 * v56;
        if (v52) {
          operator delete(v52);
        }
      }
      else
      {
        *(void *)unint64_t v47 = v49;
        *(void *)(v47 + 8) = v48;
        *(void *)(v47 + 16) = v50;
        *(void *)(v47 + 24) = v51;
        *(_WORD *)(v47 + 32) = 1;
        v47 += 40;
      }
      *((void *)&v67 + 1) = v47;
      v45 += 8;
    }
    while (v45 != v46);
  }
  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&v104);

  HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::operator=((void *)(v63 + 112), (uint64_t)&v65);
  if ((void)v67)
  {
    *((void *)&v67 + 1) = v67;
    operator delete((void *)v67);
  }
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsBucket((uint64_t)v66);
}

void sub_1BD17E3E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::~__hash_table(a9);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table((uint64_t)&STACK[0x490]);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&STACK[0x468]);
  uint64_t v29 = (void *)STACK[0x450];
  if (STACK[0x450])
  {
    STACK[0x458] = (unint64_t)v29;
    operator delete(v29);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a10);
  std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::destroy((void *)STACK[0x418]);
  int8x16_t v30 = (void *)STACK[0x3F0];
  if (STACK[0x3F0])
  {
    STACK[0x3F8] = (unint64_t)v30;
    operator delete(v30);
  }
  uint64_t v31 = (void *)STACK[0x330];
  if (STACK[0x330])
  {
    STACK[0x338] = (unint64_t)v31;
    operator delete(v31);
  }
  objc_destroyWeak((id *)&STACK[0x328]);
  __int8 v32 = (void *)STACK[0x310];
  if (STACK[0x310])
  {
    STACK[0x318] = (unint64_t)v32;
    operator delete(v32);
  }

  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&STACK[0x4E8]);
  HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsCollectionEngine((uint64_t)&a28);

  _Unwind_Resume(a1);
}

uint64_t HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::HDStatisticsBucket(uint64_t a1, void *a2, double a3, double a4)
{
  *(double *)a1 = a3;
  *(double *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 24) = 256;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(double *)(a1 + 56) = a3;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  objc_initWeak((id *)(a1 + 88), a2);
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = xmmword_1BD330210;
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 176) = xmmword_1BD330220;
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 200) = xmmword_1BD330230;
  *(void *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 224) = xmmword_1BD330240;
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 248) = xmmword_1BD330250;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0x7FFFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 312) = 0;
  *(void *)(a1 + 320) = a1 + 328;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_DWORD *)(a1 + 376) = 1065353216;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(void *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 440) = 1065353216;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 480) = 1065353216;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_DWORD *)(a1 + 520) = 1065353216;
  return a1;
}

uint64_t HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsCollectionEngine(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 536);
  if (v2)
  {
    *(void *)(a1 + 544) = v2;
    operator delete(v2);
  }
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsBucket(a1 + 8);
  return a1;
}

uint64_t HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsBucket(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::~__hash_table(a1 + 488);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table(a1 + 448);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a1 + 408);
  unint64_t v2 = *(void **)(a1 + 384);
  if (v2)
  {
    *(void *)(a1 + 392) = v2;
    operator delete(v2);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a1 + 344);
  std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::destroy(*(void **)(a1 + 328));
  id v3 = *(void **)(a1 + 288);
  if (v3)
  {
    *(void *)(a1 + 296) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 96);
  if (v4)
  {
    *(void *)(a1 + 104) = v4;
    operator delete(v4);
  }
  objc_destroyWeak((id *)(a1 + 88));
  uint64_t v5 = *(void **)(a1 + 64);
  if (v5)
  {
    *(void *)(a1 + 72) = v5;
    operator delete(v5);
  }

  return a1;
}

void std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::destroy(*a1);
    std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::destroy(a1[1]);
    unint64_t v2 = (void *)a1[26];
    if (v2)
    {
      a1[27] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_configureForStartTime(uint64_t a1)
{
  uint64_t v29 = 0;
  unint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    id v3 = objc_msgSend(MEMORY[0x1E4F1C9C8], "dateWithTimeIntervalSinceReferenceDate:");
    uint64_t v4 = [v2 dateIntervalContainingDate:v3 index:&v29];

    uint64_t v5 = [v4 startDate];
    [v5 timeIntervalSinceReferenceDate];
    double v7 = v6;

    uint64_t v8 = [v4 endDate];
    [v8 timeIntervalSinceReferenceDate];
LABEL_5:
    double v13 = v9;

    goto LABEL_6;
  }
  id v10 = *(id *)(a1 + 64);
  uint64_t v4 = v10;
  if (v10)
  {
    uint64_t v11 = [v10 startDate];
    [v11 timeIntervalSinceReferenceDate];
    double v7 = v12;

    uint64_t v8 = [v4 endDate];
    [v8 timeIntervalSinceReferenceDate];
    goto LABEL_5;
  }
  double v7 = -1.79769313e308;
  double v13 = 1.79769313e308;
LABEL_6:

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::HDStatisticsBucket((uint64_t)v22, WeakRetained, v7, v13);

  if (*(void *)(a1 + 32) == 1) {
    char v24 = 1;
  }
  uint64_t v23 = *(void *)(a1 + 56);
  char v25 = *(unsigned char *)(a1 + 24) & 1;
  if (v28 != (char *)(a1 + 72)) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(v28, *(char **)(a1 + 72), *(void *)(a1 + 80), (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 4);
  }
  objc_storeStrong(&v27, *(id *)(a1 + 696));
  if (!*(void *)(a1 + 40)) {
    int v26 = 0;
  }
  uint64_t v15 = v29;
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::HDStatisticsBucket((uint64_t)v17, (uint64_t)v22);
  uint64_t v18 = v15;
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::HDStatisticsBucket((uint64_t)v19, (uint64_t)v17);
  long long __p = 0u;
  long long v21 = 0u;
  HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::operator=((void *)(a1 + 112), (uint64_t)&v18);

  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsBucket((uint64_t)v19);
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsBucket((uint64_t)v17);
  *(unsigned char *)(a1 + 680) = 0;
  return HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::~HDStatisticsBucket((uint64_t)v22);
}

void sub_1BD17E9E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::operator=(void *a1, uint64_t a2)
{
  *a1 = *(void *)a2;
  HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::operator=((uint64_t)(a1 + 1), a2 + 8);
  std::vector<HKRawInterval<double>>::__move_assign((uint64_t)(a1 + 67), (__n128 *)(a2 + 536));
  uint64_t v4 = *(void *)(a2 + 560);
  *(void *)(a2 + 560) = 0;
  uint64_t v5 = (void *)a1[70];
  a1[70] = v4;

  return a1;
}

uint64_t HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::HDStatisticsBucket(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(id *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 56);
  long long v6 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 40) = v6;
  *(void *)(a1 + 56) = v5;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((void *)(a1 + 64), *(const void **)(a2 + 64), *(void *)(a2 + 72), (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 4);
  objc_copyWeak((id *)(a1 + 88), (id *)(a2 + 88));
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  uint64_t v8 = *(unsigned char **)(a2 + 96);
  double v7 = *(unsigned char **)(a2 + 104);
  uint64_t v9 = v7 - v8;
  if (v7 != v8)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v9 >> 4) >= 0x555555555555556) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    id v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(0xAAAAAAAAAAAAAAABLL * (v9 >> 4));
    *(void *)(a1 + 96) = v10;
    *(void *)(a1 + 104) = v10;
    *(void *)(a1 + 112) = &v10[48 * v11];
    memmove(v10, v8, v9 - 5);
    *(void *)(a1 + 104) = &v10[16 * (v9 >> 4)];
  }
  long long v12 = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v12;
  long long v13 = *(_OWORD *)(a2 + 152);
  long long v14 = *(_OWORD *)(a2 + 168);
  long long v15 = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 184) = v15;
  *(_OWORD *)(a1 + 168) = v14;
  *(_OWORD *)(a1 + 152) = v13;
  long long v16 = *(_OWORD *)(a2 + 216);
  long long v17 = *(_OWORD *)(a2 + 232);
  long long v18 = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 264) = *(_OWORD *)(a2 + 264);
  *(_OWORD *)(a1 + 248) = v18;
  *(_OWORD *)(a1 + 232) = v17;
  *(_OWORD *)(a1 + 216) = v16;
  *(void *)(a1 + 280) = *(void *)(a2 + 280);
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((void *)(a1 + 288), *(const void **)(a2 + 288), *(void *)(a2 + 296), (uint64_t)(*(void *)(a2 + 296) - *(void *)(a2 + 288)) >> 4);
  *(void *)(a1 + 312) = *(void *)(a2 + 312);
  unint64_t v19 = (void *)(a1 + 328);
  *(void *)(a1 + 328) = 0;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 320) = a1 + 328;
  unint64_t v20 = *(void **)(a2 + 320);
  if (v20 != (void *)(a2 + 328))
  {
    long long v21 = 0;
    long long v22 = (void *)(a1 + 328);
    while (1)
    {
      uint64_t v23 = (void *)(a1 + 328);
      if (v22 == v19) {
        goto LABEL_12;
      }
      char v24 = v21;
      char v25 = (void *)(a1 + 328);
      if (v21)
      {
        do
        {
          uint64_t v23 = v24;
          char v24 = (void *)v24[1];
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v23 = (void *)v25[2];
          BOOL v26 = *v23 == (void)v25;
          char v25 = v23;
        }
        while (v26);
      }
      uint64_t v27 = v20[4];
      if (v23[4] < v27)
      {
LABEL_12:
        if (v21) {
          int v28 = (uint64_t **)v23;
        }
        else {
          int v28 = (uint64_t **)(a1 + 328);
        }
        if (v21) {
          uint64_t v29 = (uint64_t **)(v23 + 1);
        }
        else {
          uint64_t v29 = (uint64_t **)(a1 + 328);
        }
        if (!*v29)
        {
LABEL_28:
          __int8 v32 = (char *)operator new(0xF0uLL);
          *((void *)v32 + 4) = v20[4];
          long long v33 = *(_OWORD *)(v20 + 5);
          *(_OWORD *)(v32 + 56) = *(_OWORD *)(v20 + 7);
          *(_OWORD *)(v32 + 40) = v33;
          long long v34 = *(_OWORD *)(v20 + 9);
          long long v35 = *(_OWORD *)(v20 + 11);
          long long v36 = *(_OWORD *)(v20 + 13);
          *(_OWORD *)(v32 + 120) = *(_OWORD *)(v20 + 15);
          *(_OWORD *)(v32 + 104) = v36;
          *(_OWORD *)(v32 + 88) = v35;
          *(_OWORD *)(v32 + 72) = v34;
          long long v37 = *(_OWORD *)(v20 + 17);
          long long v38 = *(_OWORD *)(v20 + 19);
          long long v39 = *(_OWORD *)(v20 + 21);
          *(_OWORD *)(v32 + 184) = *(_OWORD *)(v20 + 23);
          *(_OWORD *)(v32 + 168) = v39;
          *(_OWORD *)(v32 + 152) = v38;
          *(_OWORD *)(v32 + 136) = v37;
          uint64_t v40 = v20[25];
          *((void *)v32 + 26) = 0;
          *((void *)v32 + 25) = v40;
          *((void *)v32 + 27) = 0;
          *((void *)v32 + 28) = 0;
          std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((void *)v32 + 26, (const void *)v20[26], v20[27], (uint64_t)(v20[27] - v20[26]) >> 4);
          *((void *)v32 + 29) = v20[29];
          std::__tree<unsigned long long>::__insert_node_at((uint64_t **)(a1 + 320), (uint64_t)v28, v29, (uint64_t *)v32);
        }
      }
      else
      {
        uint64_t v29 = (uint64_t **)(a1 + 328);
        int v28 = (uint64_t **)(a1 + 328);
        if (!v21) {
          goto LABEL_28;
        }
        int8x16_t v30 = v21;
        while (1)
        {
          while (1)
          {
            int v28 = (uint64_t **)v30;
            uint64_t v31 = v30[4];
            if (v31 <= v27) {
              break;
            }
            int8x16_t v30 = *v28;
            uint64_t v29 = v28;
            if (!*v28) {
              goto LABEL_28;
            }
          }
          if (v31 >= v27) {
            break;
          }
          int8x16_t v30 = v28[1];
          if (!v30)
          {
            uint64_t v29 = v28 + 1;
            goto LABEL_28;
          }
        }
      }
      long long v41 = (void *)v20[1];
      if (v41)
      {
        do
        {
          double v42 = v41;
          long long v41 = (void *)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          double v42 = (void *)v20[2];
          BOOL v26 = *v42 == (void)v20;
          unint64_t v20 = v42;
        }
        while (!v26);
      }
      if (v42 == (void *)(a2 + 328)) {
        break;
      }
      long long v21 = (void *)*v19;
      long long v22 = *(void **)(a1 + 320);
      unint64_t v20 = v42;
    }
  }
  std::unordered_set<long long>::unordered_set(a1 + 344, a2 + 344);
  *(void *)(a1 + 384) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>((void *)(a1 + 384), *(const void **)(a2 + 384), *(void *)(a2 + 392), (uint64_t)(*(void *)(a2 + 392) - *(void *)(a2 + 384)) >> 3);
  std::unordered_map<long long,long long>::unordered_map(a1 + 408, a2 + 408);
  std::unordered_map<NSString * {__strong},long long,HDStringHash,HDStringEqual,std::allocator<std::pair<NSString * const {__strong},long long>>>::unordered_map(a1 + 448, a2 + 448);
  std::unordered_map<long long,NSString * {__strong}>::unordered_map(a1 + 488, a2 + 488);
  return a1;
}

void sub_1BD17EE40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void **a9, void **a10, id *location, void **a12)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table(v17);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v16);
  unint64_t v19 = *v15;
  if (*v15)
  {
    *(void *)(v12 + 392) = v19;
    operator delete(v19);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v14);
  std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::destroy(*v13);
  unint64_t v20 = *a9;
  if (*a9)
  {
    *(void *)(v12 + 296) = v20;
    operator delete(v20);
  }
  long long v21 = *a10;
  if (*a10)
  {
    *(void *)(v12 + 104) = v21;
    operator delete(v21);
  }
  objc_destroyWeak(location);
  long long v22 = *a12;
  if (*a12)
  {
    *(void *)(v12 + 72) = v22;
    operator delete(v22);
  }

  _Unwind_Resume(a1);
}

uint64_t HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::operator=(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  long long v6 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = v5;

  long long v7 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v7;
  std::vector<HKRawInterval<double>>::__move_assign(a1 + 64, (__n128 *)(a2 + 64));
  id WeakRetained = objc_loadWeakRetained((id *)(a2 + 88));
  objc_storeWeak((id *)(a1 + 88), WeakRetained);

  uint64_t v9 = *(void **)(a1 + 96);
  if (v9)
  {
    *(void *)(a1 + 104) = v9;
    operator delete(v9);
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
  }
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  long long v10 = *(_OWORD *)(a2 + 168);
  long long v11 = *(_OWORD *)(a2 + 184);
  long long v12 = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
  *(_OWORD *)(a1 + 200) = v12;
  *(_OWORD *)(a1 + 184) = v11;
  *(_OWORD *)(a1 + 168) = v10;
  long long v13 = *(_OWORD *)(a2 + 232);
  long long v14 = *(_OWORD *)(a2 + 248);
  long long v15 = *(_OWORD *)(a2 + 264);
  *(_OWORD *)(a1 + 216) = *(_OWORD *)(a2 + 216);
  *(_OWORD *)(a1 + 264) = v15;
  *(_OWORD *)(a1 + 248) = v14;
  *(_OWORD *)(a1 + 232) = v13;
  long long v16 = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v16;
  *(void *)(a1 + 280) = *(void *)(a2 + 280);
  std::vector<HKRawInterval<double>>::__move_assign(a1 + 288, (__n128 *)(a2 + 288));
  *(void *)(a1 + 312) = *(void *)(a2 + 312);
  uint64_t v17 = a1 + 328;
  std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::destroy(*(void **)(a1 + 328));
  *(void *)(a1 + 320) = *(void *)(a2 + 320);
  uint64_t v18 = *(void *)(a2 + 328);
  *(void *)(a1 + 328) = v18;
  uint64_t v19 = *(void *)(a2 + 336);
  *(void *)(a1 + 336) = v19;
  if (v19)
  {
    *(void *)(v18 + 16) = v17;
    *(void *)(a2 + 320) = a2 + 328;
    *(void *)(a2 + 328) = 0;
    *(void *)(a2 + 336) = 0;
  }
  else
  {
    *(void *)(a1 + 320) = v17;
  }
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__move_assign(a1 + 344, (uint64_t *)(a2 + 344));
  std::vector<HKRawInterval<double>>::__move_assign(a1 + 384, (__n128 *)(a2 + 384));
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__move_assign(a1 + 408, (uint64_t *)(a2 + 408));
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::__move_assign(a1 + 448, (uint64_t *)(a2 + 448));
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::__move_assign(a1 + 488, (uint64_t *)(a2 + 488));
  return a1;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsFromFinishedBucket(uint64_t a1, uint64_t a2)
{
  uint64_t v130 = *MEMORY[0x1E4F143B8];
  double v3 = *(double *)a2;
  id v4 = objc_alloc(MEMORY[0x1E4F1C9C8]);
  uint64_t v5 = (double *)(a2 + 40);
  if (v3 != -1.79769313e308) {
    uint64_t v5 = (double *)a2;
  }
  uint64_t v105 = [v4 initWithTimeIntervalSinceReferenceDate:*v5];
  if (*(double *)(a2 + 8) == 1.79769313e308) {
    uint64_t v6 = [objc_alloc(MEMORY[0x1E4F1C9C8]) initWithTimeIntervalSinceReferenceDate:*(double *)(a2 + 48)];
  }
  else {
    uint64_t v6 = [objc_alloc(MEMORY[0x1E4F1C9C8]) initWithTimeIntervalSinceReferenceDate:*(double *)(a2 + 8)];
  }
  long long v7 = (void *)v6;
  uint64_t v8 = (void *)v105;
  id v9 = *(id *)(a1 + 16);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v10 = *(id *)(a1 + 16);
    if ([v10 shouldUseUnderlyingTypeForStatistics])
    {
      uint64_t v11 = [v10 underlyingSampleType];

      id v9 = (id)v11;
    }
  }
  long long v12 = (void *)[objc_alloc(MEMORY[0x1E4F2B5B0]) initWithDataType:v9 startDate:v105 endDate:v7];
  if (*(unsigned char *)(a1 + 24))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));

    if (WeakRetained)
    {
      id v14 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      long long v15 = *(uint64_t **)(a2 + 384);
      long long v16 = *(uint64_t **)(a2 + 392);
      while (v15 != v16)
      {
        uint64_t v17 = *v15;
        id v18 = objc_loadWeakRetained((id *)(a1 + 48));
        uint64_t v19 = [v18 sourceForSourceID:v17];

        if (v19)
        {
          if (([v14 containsObject:v19] & 1) == 0) {
            [v14 addObject:v19];
          }
        }

        ++v15;
      }
      unint64_t v20 = (void *)[v14 copy];
      uint64_t v8 = (void *)v105;
      [v12 _setSources:v20];
    }
  }

  v125[0] = &unk_1F1726BD0;
  v125[3] = v125;
  id v106 = v12;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__value_func[abi:ne180100]((uint64_t)v127, (uint64_t)v125);
  uint64_t v129 = 0;
  long long v21 = operator new(0x28uLL);
  *long long v21 = &unk_1F1726AB0;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__value_func[abi:ne180100]((uint64_t)(v21 + 1), (uint64_t)v127);
  uint64_t v129 = v21;
  id v108 = v106;
  long long v22 = (void *)MEMORY[0x1E4F2B370];
  uint64_t v23 = [MEMORY[0x1E4F2B618] secondUnit];
  char v24 = (long long *)(a2 + 120);
  long long v25 = *(_OWORD *)(a2 + 232);
  long long v116 = *(_OWORD *)(a2 + 216);
  long long v117 = v25;
  long long v26 = *(_OWORD *)(a2 + 248);
  long long v27 = *(_OWORD *)(a2 + 168);
  long long v112 = *(_OWORD *)(a2 + 152);
  long long v113 = v27;
  long long v28 = *(_OWORD *)(a2 + 200);
  long long v114 = *(_OWORD *)(a2 + 184);
  long long v115 = v28;
  long long v29 = *(_OWORD *)(a2 + 136);
  long long v110 = *(_OWORD *)(a2 + 120);
  long long v111 = v29;
  long long v30 = *(_OWORD *)(a2 + 264);
  long long v118 = v26;
  long long v119 = v30;
  uint64_t v31 = *(const void **)(a2 + 288);
  uint64_t v120 = *(void *)(a2 + 280);
  long long __p = 0;
  uint64_t v32 = *(void *)(a2 + 296);
  long long v122 = 0;
  uint64_t v123 = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(&__p, v31, v32, (v32 - (uint64_t)v31) >> 4);
  uint64_t v124 = *(void *)(a2 + 312);
  if (!v129) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v33 = (*(uint64_t (**)(void *, long long *))(*v129 + 48))(v129, &v110);
  long long v34 = *(double **)(v33 + 8);
  double v35 = 0.0;
  while (v34 != *(double **)(v33 + 16))
  {
    double v37 = *v34;
    double v36 = v34[1];
    v34 += 2;
    double v35 = v35 + v36 - v37;
  }
  long long v38 = [v22 quantityWithUnit:v23 doubleValue:v35 + *(double *)(v33 + 32)];
  [v108 setDuration:v38];

  if (__p)
  {
    long long v122 = __p;
    operator delete(__p);
  }

  long long v39 = *(_OWORD *)(a2 + 232);
  long long v116 = *(_OWORD *)(a2 + 216);
  long long v117 = v39;
  long long v40 = *(_OWORD *)(a2 + 264);
  long long v118 = *(_OWORD *)(a2 + 248);
  long long v119 = v40;
  long long v41 = *(_OWORD *)(a2 + 168);
  long long v112 = *(_OWORD *)(a2 + 152);
  long long v113 = v41;
  long long v42 = *(_OWORD *)(a2 + 200);
  long long v114 = *(_OWORD *)(a2 + 184);
  long long v115 = v42;
  long long v43 = *(_OWORD *)(a2 + 136);
  long long v110 = *v24;
  long long v111 = v43;
  double v44 = *(const void **)(a2 + 288);
  uint64_t v120 = *(void *)(a2 + 280);
  long long __p = 0;
  uint64_t v45 = *(void *)(a2 + 296);
  long long v122 = 0;
  uint64_t v123 = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(&__p, v44, v45, (v45 - (uint64_t)v44) >> 4);
  uint64_t v124 = *(void *)(a2 + 312);
  if (!v129) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  objc_msgSend(v108, "setDataCount:", *(void *)(*(uint64_t (**)(void *, long long *))(*v129 + 48))(v129, &v110));
  if (__p)
  {
    long long v122 = __p;
    operator delete(__p);
  }
  if (*(unsigned char *)(a1 + 24))
  {
    id v46 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    id v47 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::statisticsByBundleIdentifier((uint64_t)&v110, a2);
    for (uint64_t i = (uint64_t **)v111; i; uint64_t i = (uint64_t **)*i)
    {
      uint64_t v49 = i[2];
      uint64_t v50 = (void *)MEMORY[0x1E4F2B370];
      uint64_t v51 = [MEMORY[0x1E4F2B618] secondUnit];
      if (!v129) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      uint64_t v52 = (*(uint64_t (**)(void *, uint64_t *))(*v129 + 48))(v129, (uint64_t *)i + 3);
      unint64_t v53 = *(double **)(v52 + 8);
      double v54 = 0.0;
      while (v53 != *(double **)(v52 + 16))
      {
        double v56 = *v53;
        double v55 = v53[1];
        v53 += 2;
        double v54 = v54 + v55 - v56;
      }
      unint64_t v57 = [v50 quantityWithUnit:v51 doubleValue:v54 + *(double *)(v52 + 32)];
      [v46 setObject:v57 forKeyedSubscript:v49];

      if (!v129) {
        std::__throw_bad_function_call[abi:ne180100]();
      }
      unint64_t v58 = objc_msgSend(NSNumber, "numberWithLongLong:", *(void *)(*(uint64_t (**)(void *, uint64_t *))(*v129 + 48))(v129, (uint64_t *)i + 3));
      [v47 setObject:v58 forKeyedSubscript:v49];
    }
    std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::~__hash_table((uint64_t)&v110);
    [v108 setDurationBySource:v46];
    [v108 setDataCountBySource:v47];
  }
  std::__function::__value_func<HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](v128);
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](v127);
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__value_func[abi:ne180100]((uint64_t)v126, (uint64_t)v125);
  uint64_t v129 = 0;
  long long v59 = operator new(0x28uLL);
  *long long v59 = &unk_1F1726B40;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__value_func[abi:ne180100]((uint64_t)(v59 + 1), (uint64_t)v126);
  uint64_t v129 = v59;
  id v109 = v108;
  long long v60 = *(_OWORD *)(a2 + 232);
  long long v116 = *(_OWORD *)(a2 + 216);
  long long v117 = v60;
  long long v61 = *(_OWORD *)(a2 + 264);
  long long v118 = *(_OWORD *)(a2 + 248);
  long long v119 = v61;
  long long v62 = *(_OWORD *)(a2 + 168);
  long long v112 = *(_OWORD *)(a2 + 152);
  long long v113 = v62;
  long long v63 = *(_OWORD *)(a2 + 200);
  long long v114 = *(_OWORD *)(a2 + 184);
  long long v115 = v63;
  long long v64 = *(_OWORD *)(a2 + 136);
  long long v110 = *v24;
  long long v111 = v64;
  uint64_t v65 = *(const void **)(a2 + 288);
  uint64_t v120 = *(void *)(a2 + 280);
  long long __p = 0;
  uint64_t v66 = *(void *)(a2 + 296);
  long long v122 = 0;
  uint64_t v123 = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(&__p, v65, v66, (v66 - (uint64_t)v65) >> 4);
  uint64_t v124 = *(void *)(a2 + 312);
  if (!v129) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v67 = (*(uint64_t (**)(void *, long long *))(*v129 + 48))(v129, &v110);
  uint64_t v68 = 0;
  double v69 = 0.0;
  uint64_t v70 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v71 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    uint64_t v72 = v67 + v68;
    double v73 = *(double *)(v67 + v68 + 24);
    if (v73 > 2.22507386e-308 && v73 >= v69)
    {
      if (v73 <= v69)
      {
        if (*(void *)(v67 + v68 + 32) < v70)
        {
          uint64_t v71 = *(void *)(v72 + 16);
          double v69 = *(double *)(v67 + v68 + 24);
          uint64_t v70 = *(void *)(v67 + v68 + 32);
        }
      }
      else
      {
        uint64_t v71 = *(void *)(v72 + 16);
        uint64_t v70 = *(void *)(v67 + v68 + 32);
        double v69 = *(double *)(v67 + v68 + 24);
      }
    }
    v68 += 24;
  }
  while (v68 != 144);
  if (__p)
  {
    long long v122 = __p;
    operator delete(__p);
  }
  if (v71 != 0x7FFFFFFFFFFFFFFFLL)
  {
    uint64_t v75 = objc_msgSend(NSNumber, "numberWithInteger:", v71, v69);
    [v109 setCategoryValue:v75];
  }
  long long v76 = *(_OWORD *)(a2 + 232);
  long long v116 = *(_OWORD *)(a2 + 216);
  long long v117 = v76;
  long long v77 = *(_OWORD *)(a2 + 264);
  long long v118 = *(_OWORD *)(a2 + 248);
  long long v119 = v77;
  long long v78 = *(_OWORD *)(a2 + 168);
  long long v112 = *(_OWORD *)(a2 + 152);
  long long v113 = v78;
  long long v79 = *(_OWORD *)(a2 + 200);
  long long v114 = *(_OWORD *)(a2 + 184);
  long long v115 = v79;
  long long v80 = *(_OWORD *)(a2 + 136);
  long long v110 = *v24;
  long long v111 = v80;
  long long v81 = *(const void **)(a2 + 288);
  uint64_t v120 = *(void *)(a2 + 280);
  long long __p = 0;
  uint64_t v82 = *(void *)(a2 + 296);
  long long v122 = 0;
  uint64_t v123 = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(&__p, v81, v82, (v82 - (uint64_t)v81) >> 4);
  uint64_t v124 = *(void *)(a2 + 312);
  if (!v129) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  objc_msgSend(v109, "setDataCount:", *(void *)(*(uint64_t (**)(void *, long long *))(*v129 + 48))(v129, &v110));
  if (__p)
  {
    long long v122 = __p;
    operator delete(__p);
  }
  if (*(unsigned char *)(a1 + 24))
  {
    id v83 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v84 = *(uint64_t **)(a2 + 384);
    for (uint64_t j = *(uint64_t **)(a2 + 392); v84 != j; ++v84)
    {
      uint64_t v86 = *v84;
      id v87 = objc_loadWeakRetained((id *)(a1 + 48));
      long long v88 = [v87 sourceForSourceID:v86];

      if (v88 && ([v83 containsObject:v88] & 1) == 0) {
        [v83 addObject:v88];
      }
    }
    uint64_t v89 = (void *)[v83 copy];
    [v109 _setSources:v89];

    id v90 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    id v91 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::statisticsByBundleIdentifier((uint64_t)&v110, a2);
    for (k = (uint64_t **)v111; k; k = (uint64_t **)*k)
    {
      long long v93 = k[2];
      if (!v129) {
        goto LABEL_81;
      }
      uint64_t v94 = (*(uint64_t (**)(void *, uint64_t *))(*v129 + 48))(v129, (uint64_t *)k + 3);
      uint64_t v95 = 0;
      double v96 = 0.0;
      uint64_t v97 = 0x7FFFFFFFFFFFFFFFLL;
      uint64_t v98 = 0x7FFFFFFFFFFFFFFFLL;
      do
      {
        uint64_t v99 = v94 + v95;
        double v100 = *(double *)(v94 + v95 + 24);
        if (v100 > 2.22507386e-308 && v100 >= v96)
        {
          if (v100 <= v96)
          {
            if (*(void *)(v94 + v95 + 32) < v97)
            {
              uint64_t v98 = *(void *)(v99 + 16);
              double v96 = *(double *)(v94 + v95 + 24);
              uint64_t v97 = *(void *)(v94 + v95 + 32);
            }
          }
          else
          {
            uint64_t v98 = *(void *)(v99 + 16);
            uint64_t v97 = *(void *)(v94 + v95 + 32);
            double v96 = *(double *)(v94 + v95 + 24);
          }
        }
        v95 += 24;
      }
      while (v95 != 144);
      if (v98 != 0x7FFFFFFFFFFFFFFFLL)
      {
        long long v102 = [NSNumber numberWithInteger:v96];
        [v90 setObject:v102 forKeyedSubscript:v93];
      }
      if (!v129) {
LABEL_81:
      }
        std::__throw_bad_function_call[abi:ne180100]();
      int v103 = objc_msgSend(NSNumber, "numberWithLongLong:", *(void *)(*(uint64_t (**)(void *, uint64_t *))(*v129 + 48))(v129, (uint64_t *)k + 3));
      [v91 setObject:v103 forKeyedSubscript:v93];
    }
    std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::~__hash_table((uint64_t)&v110);
    [v109 setCategoryValueBySource:v90];
    [v109 setDataCountBySource:v91];
  }
  std::__function::__value_func<HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](v128);
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](v126);

  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](v125);

  return v109;
}

void sub_1BD17FBAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Unwind_Resume(a1);
}

void HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_updateSourceOrder(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 368);
  uint64_t v2 = *(void *)(a1 + 384);
  if (v1 != (*(void *)(a1 + 392) - v2) >> 3)
  {
    id v4 = (void **)(a1 + 384);
    *(void *)(a1 + 392) = v2;
    std::vector<long long>::reserve((void **)(a1 + 384), v1);
    uint64_t v5 = *(void **)(a1 + 360);
    if (v5)
    {
      uint64_t v6 = *(char **)(a1 + 392);
      do
      {
        uint64_t v7 = v5[2];
        unint64_t v8 = *(void *)(a1 + 400);
        if ((unint64_t)v6 >= v8)
        {
          id v10 = (char *)*v4;
          uint64_t v11 = (v6 - (unsigned char *)*v4) >> 3;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 61) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v13 = v8 - (void)v10;
          if (v13 >> 2 > v12) {
            unint64_t v12 = v13 >> 2;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14)
          {
            unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v14);
            id v10 = *(char **)(a1 + 384);
            uint64_t v6 = *(char **)(a1 + 392);
          }
          else
          {
            uint64_t v15 = 0;
          }
          long long v16 = (void *)(v14 + 8 * v11);
          *long long v16 = v7;
          id v9 = (char *)(v16 + 1);
          while (v6 != v10)
          {
            uint64_t v17 = *((void *)v6 - 1);
            v6 -= 8;
            *--long long v16 = v17;
          }
          *(void *)(a1 + 384) = v16;
          *(void *)(a1 + 392) = v9;
          *(void *)(a1 + 400) = v14 + 8 * v15;
          if (v10) {
            operator delete(v10);
          }
        }
        else
        {
          *(void *)uint64_t v6 = v7;
          id v9 = v6 + 8;
        }
        *(void *)(a1 + 392) = v9;
        uint64_t v5 = (void *)*v5;
        uint64_t v6 = v9;
      }
      while (v5);
    }
    id v18 = (id *)(a1 + 88);
    id WeakRetained = objc_loadWeakRetained(v18);

    if (WeakRetained)
    {
      id v20 = objc_loadWeakRetained(v18);
      [v20 orderSourceIDs:v4];
    }
  }
}

void sub_1BD17FF8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeThroughTime(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 16);
  if (v4 > 0.0 && *(double *)(a1 + 8) > a2) {
    a2 = v4 * floor(a2 / v4);
  }
  double v5 = *(double *)(a1 + 56);
  if (v5 < a2)
  {
    uint64_t v150 = (void *)(a1 + 96);
    v145 = (void *)(a1 + 120);
    v146 = (double **)(a1 + 64);
    v143 = (uint64_t *)(a1 + 280);
    location = (id *)(a1 + 88);
    v139 = (double **)(a1 + 288);
    v138 = (void *)(a1 + 328);
    while (1)
    {
      unint64_t v6 = *(void *)(a1 + 96);
      uint64_t v7 = *(long long **)(a1 + 104);
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v7 - v6) >> 4);
      if (v8) {
        break;
      }
LABEL_147:
      *(double *)(a1 + 56) = a2;
LABEL_148:
      double v135 = *(double *)(a1 + 56);
      if (v135 == v5)
      {
        v136 = [MEMORY[0x1E4F28B00] currentHandler];
        v137 = objc_msgSend(NSString, "stringWithUTF8String:", "void HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages, HDStatisticsTimeInterval>>::_mergeThroughTime(double) [Statistics = HDStatisticsCombined<HDStatisticsSleepStages, HDStatisticsTimeInterval>]");
        [v136 handleFailureInFunction:v137 file:@"HDStatisticsBucket.hpp" lineNumber:234 description:@"Failed to make forward progress during statistics merge."];

        double v135 = *(double *)(a1 + 56);
      }
      double v5 = v135;
      if (v135 >= a2) {
        return;
      }
    }
    if (v8 != 1)
    {
      double v17 = a2;
      double v18 = a2;
      double v19 = v5;
      uint64_t v20 = *(void *)(a1 + 96);
      if ((long long *)v6 != v7)
      {
        do
        {
          double v21 = *(double *)(v20 + 8);
          double v22 = *(double *)(v20 + 16);
          if (v21 > v19 && v21 < v18) {
            double v18 = *(double *)(v20 + 8);
          }
          if (v22 > v5) {
            double v24 = *(double *)(v20 + 16);
          }
          else {
            double v24 = v17;
          }
          if (v22 < v17)
          {
            double v19 = v5;
            double v17 = v24;
          }
          v20 += 48;
        }
        while ((long long *)v20 != v7);
      }
      if (v17 >= v18) {
        double v25 = v18;
      }
      else {
        double v25 = v17;
      }
      double v26 = *(double *)(a1 + 16);
      if (v26 > 0.0)
      {
        double v27 = v26 * floor(v25 / v26);
        double v28 = v26 * floor((v26 + v5) / v26);
        if (v27 >= v28) {
          double v25 = v27;
        }
        else {
          double v25 = v28;
        }
      }
      *uint64_t v150 = 0;
      v150[1] = 0;
      v150[2] = 0;
      if ((long long *)v6 != v7)
      {
        if (v8 > 0x555555555555555) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        long long v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v8);
        uint64_t v32 = *(char **)(a1 + 96);
        uint64_t v31 = *(char **)(a1 + 104);
        uint64_t v33 = v29;
        if (v31 != v32)
        {
          do
          {
            long long v34 = *((_OWORD *)v31 - 3);
            long long v35 = *((_OWORD *)v31 - 2);
            *(_OWORD *)(v33 - 21) = *(_OWORD *)(v31 - 21);
            *((_OWORD *)v33 - 3) = v34;
            *((_OWORD *)v33 - 2) = v35;
            v33 -= 48;
            v31 -= 48;
          }
          while (v31 != v32);
          uint64_t v31 = (char *)*v150;
        }
        *(void *)(a1 + 96) = v33;
        *(void *)(a1 + 104) = v29;
        *(void *)(a1 + 112) = &v29[48 * v30];
        if (v31) {
          operator delete(v31);
        }
      }
      HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_updateSourceOrder(a1);
      id WeakRetained = objc_loadWeakRetained(location);

      unint64_t v37 = __clz(v8);
      if (WeakRetained)
      {
        *(void *)&v152.double var0 = a1;
        uint64_t v38 = 126 - 2 * v37;
        if ((long long *)v6 == v7) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = v38;
        }
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*,false>(v6, v7, (uint64_t)&v152, v39, 1);
      }
      else
      {
        uint64_t v42 = 126 - 2 * v37;
        if ((long long *)v6 == v7) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = v42;
        }
      }
      std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*,false>(v6, v7, v39, 1);
      if (*(unsigned char *)(a1 + 25)) {
        id v142 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
      }
      else {
        id v142 = 0;
      }
      uint64_t v141 = (void *)v6;
      if ((long long *)v6 == v7)
      {
LABEL_121:
        *(double *)(a1 + 312) = HKIntervalMask<double>::removeIntervalsBefore(v139, v25) + *(double *)(a1 + 312);
        id v108 = *(void **)(a1 + 320);
        if (v108 != v138)
        {
          do
          {
            *((double *)v108 + 29) = HKIntervalMask<double>::removeIntervalsBefore((double **)v108 + 26, v25)
                                   + *((double *)v108 + 29);
            id v109 = (void *)v108[1];
            if (v109)
            {
              do
              {
                long long v110 = v109;
                id v109 = (void *)*v109;
              }
              while (v109);
            }
            else
            {
              do
              {
                long long v110 = (void *)v108[2];
                BOOL v111 = *v110 == (void)v108;
                id v108 = v110;
              }
              while (!v111);
            }
            id v108 = v110;
          }
          while (v110 != v138);
        }
        *(double *)(a1 + 56) = v25;

        if (v141) {
          operator delete(v141);
        }
        goto LABEL_148;
      }
      int64_t v144 = 0;
      char v43 = 0;
      unint64_t v44 = v6;
      while (2)
      {
        long long v45 = *(_OWORD *)(v44 + 16);
        *(_OWORD *)&v152.double var0 = *(_OWORD *)v44;
        *(_OWORD *)&v152.var2 = v45;
        *(void *)&v152.BOOL var4 = *(void *)(v44 + 32);
        double var0 = v152.var0;
        uint64_t v47 = v45;
        if (*(double *)&v45 - v152.var1 - (v25 - v152.var1) >= 0.01)
        {
          if (v25 - v152.var1 < 0.01)
          {
            v152.BOOL var4 = 0;
            goto LABEL_66;
          }
          int64_t var3 = v152.var3;
          BOOL var5 = v152.var5;
          v152.var2 = v25;
          double v51 = v25;
          BOOL var4 = v152.var4;
          if (v152.var4) {
            goto LABEL_57;
          }
LABEL_66:
          long long v60 = *(_OWORD **)(a1 + 104);
          unint64_t v61 = *(void *)(a1 + 112);
          if ((unint64_t)v60 < v61)
          {
            long long v62 = *(_OWORD *)v44;
            long long v63 = *(_OWORD *)(v44 + 32);
            v60[1] = *(_OWORD *)(v44 + 16);
            v60[2] = v63;
            *long long v60 = v62;
            long long v64 = v60 + 3;
            goto LABEL_119;
          }
          unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v60 - *v150) >> 4);
          unint64_t v66 = v65 + 1;
          if (v65 + 1 > 0x555555555555555) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v67 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v61 - *v150) >> 4);
          if (2 * v67 > v66) {
            unint64_t v66 = 2 * v67;
          }
          if (v67 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v68 = 0x555555555555555;
          }
          else {
            unint64_t v68 = v66;
          }
          if (v68) {
            unint64_t v68 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v68);
          }
          else {
            uint64_t v69 = 0;
          }
          long long v80 = (_OWORD *)(v68 + 48 * v65);
          long long v81 = *(_OWORD *)v44;
          long long v82 = *(_OWORD *)(v44 + 32);
          v80[1] = *(_OWORD *)(v44 + 16);
          v80[2] = v82;
          *long long v80 = v81;
          long long v84 = *(char **)(a1 + 96);
          id v83 = *(char **)(a1 + 104);
          int64_t v85 = v80;
          if (v83 != v84)
          {
            do
            {
              long long v86 = *((_OWORD *)v83 - 3);
              long long v87 = *((_OWORD *)v83 - 2);
              *(_OWORD *)((char *)v85 - 21) = *(_OWORD *)(v83 - 21);
              *(v85 - 3) = v86;
              *(v85 - 2) = v87;
              v85 -= 3;
              v83 -= 48;
            }
            while (v83 != v84);
            id v83 = (char *)*v150;
          }
          long long v64 = v80 + 3;
          *(void *)(a1 + 96) = v85;
          *(void *)(a1 + 104) = v80 + 3;
          *(void *)(a1 + 112) = v68 + 48 * v69;
          if (v83)
          {
            long long v88 = v83;
            goto LABEL_118;
          }
LABEL_119:
          *(void *)(a1 + 104) = v64;
        }
        else
        {
          int64_t var3 = 0;
          BOOL var4 = 0;
          BOOL var5 = 0;
          double v51 = 0.0;
          uint64_t v47 = 0;
          if (!v152.var4) {
            goto LABEL_66;
          }
LABEL_57:
          BOOL v148 = var5;
          int64_t v149 = var3;
          HDRawQuantitySample::applyMask((uint64_t)&v152, v146);
          int v52 = *(unsigned __int8 *)(v44 + 42);
          int v53 = *(unsigned __int8 *)(v44 + 41);
          char v147 = *(unsigned char *)(v44 + 40);
          if (v152.var4)
          {
            if (v43)
            {
              unint64_t v54 = v152.var3;
              if (v144 == v152.var3 || *(unsigned char *)(a1 + 24))
              {
                if (!*(unsigned char *)(v44 + 42)) {
                  ++*v145;
                }
                double v55 = (double *)&v145[3 * (uint64_t)v152.var0];
                double v56 = v55[3];
                uint64_t v57 = *((void *)v55 + 4);
                uint64_t v58 = *(void *)(a1 + 128);
                if (v58 < v57)
                {
                  uint64_t v57 = v58 + 1;
                  *(void *)(a1 + 128) = v58 + 1;
                }
                long long v59 = v55 + 2;
                v59[1] = v56 + v152.var2 - v152.var1;
                *((void *)v59 + 2) = v57;
                HDStatisticsTimeInterval::addSample(v143, &v152, v52 == 0);
                int v52 = 1;
              }
            }
            else
            {
              if (!*(unsigned char *)(v44 + 42)) {
                ++*v145;
              }
              uint64_t v70 = (double *)&v145[3 * (uint64_t)v152.var0];
              double v71 = v70[3];
              uint64_t v72 = *((void *)v70 + 4);
              uint64_t v73 = *(void *)(a1 + 128);
              if (v73 < v72)
              {
                uint64_t v72 = v73 + 1;
                *(void *)(a1 + 128) = v73 + 1;
              }
              int8x16_t v74 = v70 + 2;
              v74[1] = v71 + v152.var2 - v152.var1;
              *((void *)v74 + 2) = v72;
              HDStatisticsTimeInterval::addSample(v143, &v152, v52 == 0);
              int v52 = 1;
              unint64_t v54 = v152.var3;
              int64_t v144 = v152.var3;
            }
            if (*(unsigned char *)(a1 + 25))
            {
              uint64_t v75 = HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_bundleIdentifierForSourceID(a1, v54);
              if (v75)
              {
                long long v76 = [v142 objectForKeyedSubscript:v75];
                long long v77 = v76;
                if (v76)
                {
                  if ([v76 longLongValue] == v54 || *(unsigned char *)(a1 + 24))
                  {
                    unint64_t v78 = HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_canonicalSourceIDForSourceID(a1, v54);
                    long long v79 = HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsForSource(a1, v78);
                    goto LABEL_94;
                  }
                }
                else
                {
                  uint64_t v89 = [NSNumber numberWithLongLong:v54];
                  [v142 setObject:v89 forKeyedSubscript:v75];

                  unint64_t v90 = HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_canonicalSourceIDForSourceID(a1, v54);
                  long long v79 = HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsForSource(a1, v90);
LABEL_94:
                  if (!v53) {
                    *long long v79 = (uint64_t *)((char *)*v79 + 1);
                  }
                  id v91 = &v79[3 * (uint64_t)v152.var0];
                  double v92 = *((double *)v91 + 3);
                  long long v93 = v91[4];
                  uint64_t v94 = v79[1];
                  if ((uint64_t)v94 < (uint64_t)v93)
                  {
                    long long v93 = (uint64_t *)((char *)v94 + 1);
                    v79[1] = (uint64_t *)((char *)v94 + 1);
                  }
                  uint64_t v95 = v91 + 2;
                  *((double *)v95 + 1) = v92 + v152.var2 - v152.var1;
                  v95[2] = v93;
                  HDStatisticsTimeInterval::addSample((uint64_t *)v79 + 20, &v152, v53 == 0);
                  LOBYTE(v53) = 1;
                }
              }
            }
            char v43 = 1;
          }
          if (var4)
          {
            BOOL v96 = v52 != 0;
            uint64_t v98 = *(char **)(a1 + 104);
            unint64_t v97 = *(void *)(a1 + 112);
            if ((unint64_t)v98 < v97)
            {
              *(double *)uint64_t v98 = var0;
              *((double *)v98 + 1) = v51;
              *((void *)v98 + 2) = v47;
              *((void *)v98 + 3) = v149;
              v98[32] = var4;
              v98[33] = v148;
              v98[40] = v147;
              v98[41] = v53;
              long long v64 = v98 + 48;
              v98[42] = v96;
              goto LABEL_119;
            }
            long long v88 = (char *)*v150;
            unint64_t v99 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v98[-*v150] >> 4);
            unint64_t v100 = v99 + 1;
            if (v99 + 1 > 0x555555555555555) {
              std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v101 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v97 - (void)v88) >> 4);
            if (2 * v101 > v100) {
              unint64_t v100 = 2 * v101;
            }
            if (v101 >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v102 = 0x555555555555555;
            }
            else {
              unint64_t v102 = v100;
            }
            if (v102)
            {
              unint64_t v102 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v102);
              long long v88 = *(char **)(a1 + 96);
              uint64_t v98 = *(char **)(a1 + 104);
            }
            else
            {
              uint64_t v103 = 0;
            }
            unint64_t v104 = v102 + 48 * v99;
            *(double *)unint64_t v104 = var0;
            *(double *)(v104 + 8) = v51;
            *(void *)(v104 + 16) = v47;
            *(void *)(v104 + 24) = v149;
            *(unsigned char *)(v104 + 32) = var4;
            *(unsigned char *)(v104 + 33) = v148;
            *(unsigned char *)(v104 + 40) = v147;
            *(unsigned char *)(v104 + 41) = v53;
            *(unsigned char *)(v104 + 42) = v96;
            unint64_t v105 = v104;
            if (v98 != v88)
            {
              do
              {
                long long v106 = *((_OWORD *)v98 - 3);
                long long v107 = *((_OWORD *)v98 - 2);
                *(_OWORD *)(v105 - 21) = *(_OWORD *)(v98 - 21);
                *(_OWORD *)(v105 - 48) = v106;
                *(_OWORD *)(v105 - 32) = v107;
                v105 -= 48;
                v98 -= 48;
              }
              while (v98 != v88);
              long long v88 = (char *)*v150;
            }
            long long v64 = (_OWORD *)(v104 + 48);
            *(void *)(a1 + 96) = v105;
            *(void *)(a1 + 104) = v104 + 48;
            *(void *)(a1 + 112) = v102 + 48 * v103;
            if (v88) {
LABEL_118:
            }
              operator delete(v88);
            goto LABEL_119;
          }
        }
        v44 += 48;
        if ((long long *)v44 == v7) {
          goto LABEL_121;
        }
        continue;
      }
    }
    double v9 = *(double *)(v6 + 8);
    double v10 = *(double *)(v6 + 16);
    int64_t v11 = *(void *)(v6 + 24);
    char v12 = *(unsigned char *)(v6 + 32);
    char v13 = *(unsigned char *)(v6 + 33);
    if (a2 - v9 >= 0.01)
    {
      if (v10 - v9 - (a2 - v9) < 0.01)
      {
        uint64_t v40 = 0;
        char v41 = 0;
        double v16 = 0.0;
        double v15 = *(double *)(v6 + 16);
        char v14 = *(unsigned char *)(v6 + 32);
        double v10 = 0.0;
        char v12 = 0;
LABEL_132:
        int v112 = *(unsigned __int8 *)(v6 + 42);
        int v113 = *(unsigned __int8 *)(v6 + 41);
        int v114 = *(unsigned __int8 *)(v6 + 40);
        double v115 = *(double *)v6;
        v152.var1 = *(double *)(v6 + 8);
        v152.var2 = v15;
        v152.int64_t var3 = v11;
        v152.BOOL var4 = v14;
        v152.BOOL var5 = v13;
        *(_DWORD *)(&v152.var5 + 1) = *(_DWORD *)(v6 + 34);
        *(_WORD *)(&v152.var5 + 5) = *(_WORD *)(v6 + 38);
        *((double *)&v153 + 1) = v16;
        *(double *)&long long v154 = v10;
        *((void *)&v154 + 1) = v40;
        LOBYTE(v155) = v12;
        HIBYTE(v155) = v41;
        v152.double var0 = v115;
        *(double *)&long long v153 = v115;
        HDRawQuantitySample::applyMask((uint64_t)&v152, v146);
        BOOL v116 = v114 != 0;
        BOOL v117 = v113 != 0;
        BOOL v118 = v112 != 0;
        if (v152.var4)
        {
          if (!v112) {
            ++*v145;
          }
          uint64_t v119 = (uint64_t)v152.var0;
          uint64_t v120 = (double *)&v145[3 * (uint64_t)v152.var0];
          double v121 = v120[3];
          uint64_t v122 = *((void *)v120 + 4);
          uint64_t v123 = *(void *)(a1 + 128);
          if (v123 < v122)
          {
            uint64_t v122 = v123 + 1;
            *(void *)(a1 + 128) = v123 + 1;
          }
          uint64_t v124 = v120 + 2;
          double v125 = v152.var2 - v152.var1;
          v124[1] = v121 + v152.var2 - v152.var1;
          *((void *)v124 + 2) = v122;
          HDStatisticsTimeInterval::addSample(v143, &v152, v112 == 0);
          if (*(unsigned char *)(a1 + 25))
          {
            unint64_t v126 = HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_canonicalSourceIDForSourceID(a1, v152.var3);
            uint64_t v127 = HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsForSource(a1, v126);
            if (!v113) {
              *uint64_t v127 = (uint64_t *)((char *)*v127 + 1);
            }
            uint64_t v128 = &v127[3 * v119];
            double v129 = *((double *)v128 + 3);
            uint64_t v130 = v128[4];
            int64_t v131 = v127[1];
            if ((uint64_t)v131 < (uint64_t)v130)
            {
              uint64_t v130 = (uint64_t *)((char *)v131 + 1);
              v127[1] = (uint64_t *)((char *)v131 + 1);
            }
            uint64_t v132 = v128 + 2;
            *((double *)v132 + 1) = v125 + v129;
            v132[2] = v130;
            HDStatisticsTimeInterval::addSample((uint64_t *)v127 + 20, &v152, v113 == 0);
          }
          BOOL v116 = 1;
          BOOL v117 = 1;
          BOOL v118 = 1;
        }
        if ((_BYTE)v155)
        {
          LOWORD(v151) = v155;
          long long v133 = v154;
          uint64_t v134 = (char *)*v150;
          *(_OWORD *)uint64_t v134 = v153;
          *((_OWORD *)v134 + 1) = v133;
          *((void *)v134 + 4) = v151;
          v134[40] = v116;
          v134[41] = v117;
          v134[42] = v118;
        }
        else
        {
          *(void *)(a1 + 104) = *(void *)(a1 + 96);
        }
        goto LABEL_147;
      }
      double v15 = a2;
      char v14 = *(unsigned char *)(v6 + 32);
      double v16 = a2;
    }
    else
    {
      char v14 = 0;
      double v15 = *(double *)(v6 + 16);
      double v16 = *(double *)(v6 + 8);
    }
    uint64_t v40 = *(void *)(v6 + 24);
    char v41 = *(unsigned char *)(v6 + 33);
    goto LABEL_132;
  }
}

void sub_1BD180AE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsForSource(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a2;
  double v3 = *(void **)(a1 + 328);
  if (!v3) {
    goto LABEL_11;
  }
  double v4 = (uint64_t **)(a1 + 328);
  do
  {
    uint64_t v5 = v3[4];
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (!v6) {
      double v4 = (uint64_t **)v3;
    }
    double v3 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t **)(a1 + 328) || (uint64_t)v4[4] > a2)
  {
LABEL_11:
    unint64_t v8 = (uint64_t **)(a1 + 320);
    std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 320), a2, &v10);
    double v4 = std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v8, a2, &v10);
  }
  return v4 + 5;
}

unint64_t HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_canonicalSourceIDForSourceID(uint64_t a1, unint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));

  if (WeakRetained)
  {
    uint64_t v5 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>((void *)(a1 + 408), a2);
    if (v5)
    {
      return v5[3];
    }
    else
    {
      HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_bundleIdentifierForSourceID(a1, a2);
      id v6 = (id)objc_claimAutoreleasedReturnValue();
      id v10 = v6;
      uint64_t v7 = (void *)(a1 + 448);
      unint64_t v8 = std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::find<NSString * {__strong}>(v7, &v10);
      if (v8)
      {
        a2 = (unint64_t)v8[3];
      }
      else
      {
        int64_t v11 = &v10;
        *((void *)std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>((uint64_t)v7, &v10, &v11)+ 3) = a2;
        id v6 = v10;
      }
    }
  }
  return a2;
}

void sub_1BD180CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

id HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_bundleIdentifierForSourceID(uint64_t a1, unint64_t a2)
{
  unint64_t v12 = a2;
  double v4 = (id *)(a1 + 88);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));

  if (WeakRetained)
  {
    id v6 = (void *)(a1 + 488);
    uint64_t v7 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(v6, a2);
    if (v7)
    {
      id v8 = (id)v7[3];
    }
    else
    {
      id v9 = objc_loadWeakRetained(v4);
      id v8 = [v9 bundleIdentifierForSourceID:a2];

      if (v8)
      {
        id v10 = (id *)std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t)v6, a2, &v12);
        objc_storeStrong(v10 + 3, v8);
      }
    }
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void sub_1BD180DA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, void *a3)
{
  id v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        id v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        id v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    id v9 = (char *)operator new(0xF0uLL);
    *((void *)v9 + 4) = *a3;
    *(_OWORD *)(v9 + 40) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    *(_OWORD *)(v9 + 72) = xmmword_1BD330210;
    *((void *)v9 + 11) = 0;
    *((_OWORD *)v9 + 6) = xmmword_1BD330220;
    *((void *)v9 + 14) = 0;
    *(_OWORD *)(v9 + 120) = xmmword_1BD330230;
    *((void *)v9 + 17) = 0;
    *((_OWORD *)v9 + 9) = xmmword_1BD330240;
    *((void *)v9 + 20) = 0;
    *(_OWORD *)(v9 + 168) = xmmword_1BD330250;
    *((void *)v9 + 23) = 0;
    *((void *)v9 + 24) = 0x7FFFFFFFFFFFFFFFLL;
    *(_OWORD *)(v9 + 200) = 0u;
    *(_OWORD *)(v9 + 216) = 0u;
    *((void *)v9 + 29) = 0;
    std::__tree<unsigned long long>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

void std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*,false>(unint64_t a1, long long *a2, uint64_t a3, uint64_t a4, char a5)
{
  while (2)
  {
    unint64_t v12 = a2 - 3;
    unint64_t v13 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v13;
          uint64_t v14 = (uint64_t)a2 - v13;
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v13) >> 4);
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v103 = *((void *)a2 - 3);
                uint64_t v104 = *(void *)(v13 + 24);
                if (v103 == v104) {
                  return;
                }
                unint64_t v105 = *(char **)(*(void *)a3 + 384);
                long long v106 = *(char **)(*(void *)a3 + 392);
                long long v107 = v105;
                id v108 = v105;
                if (v105 == v106) {
                  goto LABEL_171;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)v13, (long long *)(v13 + 48), a2 - 3, a3);
                return;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v13, v13 + 48, v13 + 96, (uint64_t)(a2 - 3), a3);
                return;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v13, v13 + 48, v13 + 96, v13 + 144, (uint64_t)(a2 - 3), a3);
                return;
              default:
                JUMPOUT(0);
            }
            do
            {
              if (*(void *)v108 == v103) {
                goto LABEL_168;
              }
              v108 += 8;
            }
            while (v108 != v106);
            id v108 = *(char **)(*(void *)a3 + 392);
LABEL_168:
            while (*(void *)v107 != v104)
            {
              v107 += 8;
              if (v107 == v106)
              {
                long long v107 = *(char **)(*(void *)a3 + 392);
                break;
              }
            }
LABEL_171:
            if (v108 - v105 < v107 - v105)
            {
              *(_OWORD *)v226 = *(_OWORD *)(v13 + 16);
              *(_OWORD *)&v226[16] = *(_OWORD *)(v13 + 32);
              long long v218 = *(_OWORD *)v13;
              long long v109 = *v12;
              long long v110 = *(a2 - 2);
              *(_OWORD *)(v13 + 27) = *(long long *)((char *)a2 - 21);
              *(_OWORD *)unint64_t v13 = v109;
              *(_OWORD *)(v13 + 16) = v110;
              *(long long *)((char *)a2 - 21) = *(_OWORD *)&v226[11];
              long long *v12 = v218;
              *(a2 - 2) = *(_OWORD *)v226;
            }
            return;
          }
          if (v14 <= 1151)
          {
            BOOL v111 = (long long *)(v13 + 48);
            BOOL v113 = (long long *)v13 == a2 || v111 == a2;
            if (a5)
            {
              if (!v113)
              {
                unint64_t v114 = v13;
                do
                {
                  unint64_t v115 = v114;
                  unint64_t v114 = (unint64_t)v111;
                  uint64_t v116 = *(void *)(v115 + 72);
                  uint64_t v117 = *(void *)(v115 + 24);
                  if (v116 != v117)
                  {
                    BOOL v118 = *(char **)(*(void *)a3 + 384);
                    uint64_t v119 = *(char **)(*(void *)a3 + 392);
                    uint64_t v120 = v118;
                    double v121 = v118;
                    if (v118 != v119)
                    {
                      do
                      {
                        if (*(void *)v121 == v116) {
                          goto LABEL_196;
                        }
                        v121 += 8;
                      }
                      while (v121 != v119);
                      double v121 = *(char **)(*(void *)a3 + 392);
LABEL_196:
                      while (*(void *)v120 != v117)
                      {
                        v120 += 8;
                        if (v120 == v119)
                        {
                          uint64_t v120 = *(char **)(*(void *)a3 + 392);
                          break;
                        }
                      }
                    }
                    if (v121 - v118 < v120 - v118)
                    {
                      uint64_t v227 = *(void *)(v114 + 16);
                      long long v219 = *(_OWORD *)v114;
                      long long v236 = *(_OWORD *)(v115 + 80);
                      unint64_t v122 = v114;
                      while (1)
                      {
                        long long v123 = *(_OWORD *)(v115 + 16);
                        *(_OWORD *)unint64_t v122 = *(_OWORD *)v115;
                        *(_OWORD *)(v122 + 16) = v123;
                        *(_OWORD *)(v122 + 27) = *(_OWORD *)(v115 + 27);
                        if (v115 == v13) {
                          break;
                        }
                        unint64_t v122 = v115;
                        uint64_t v124 = *(void *)(v115 - 24);
                        if (v116 != v124)
                        {
                          double v125 = *(char **)(*(void *)a3 + 384);
                          unint64_t v126 = *(char **)(*(void *)a3 + 392);
                          uint64_t v127 = v125;
                          uint64_t v128 = v125;
                          if (v125 != v126)
                          {
                            do
                            {
                              if (*(void *)v128 == v116) {
                                goto LABEL_208;
                              }
                              v128 += 8;
                            }
                            while (v128 != v126);
                            uint64_t v128 = *(char **)(*(void *)a3 + 392);
LABEL_208:
                            while (*(void *)v127 != v124)
                            {
                              v127 += 8;
                              if (v127 == v126)
                              {
                                uint64_t v127 = *(char **)(*(void *)a3 + 392);
                                break;
                              }
                            }
                          }
                          unint64_t v115 = v122 - 48;
                          if (v128 - v125 < v127 - v125) {
                            continue;
                          }
                        }
                        goto LABEL_212;
                      }
                      unint64_t v122 = v13;
LABEL_212:
                      *(_OWORD *)unint64_t v122 = v219;
                      *(void *)(v122 + 16) = v227;
                      *(void *)(v122 + 24) = v116;
                      *(void *)(v122 + 32) = v236;
                      *(_DWORD *)(v122 + 39) = *(_DWORD *)((char *)&v236 + 7);
                    }
                  }
                  BOOL v111 = (long long *)(v114 + 48);
                }
                while ((long long *)(v114 + 48) != a2);
              }
            }
            else if (!v113)
            {
              do
              {
                unint64_t v201 = a1;
                a1 = (unint64_t)v111;
                uint64_t v202 = *(void *)(v201 + 72);
                uint64_t v203 = *(void *)(v201 + 24);
                if (v202 != v203)
                {
                  v204 = *(char **)(*(void *)a3 + 384);
                  v205 = *(char **)(*(void *)a3 + 392);
                  v206 = v204;
                  v207 = v204;
                  if (v204 != v205)
                  {
                    do
                    {
                      if (*(void *)v207 == v202) {
                        goto LABEL_312;
                      }
                      v207 += 8;
                    }
                    while (v207 != v205);
                    v207 = *(char **)(*(void *)a3 + 392);
LABEL_312:
                    while (*(void *)v206 != v203)
                    {
                      v206 += 8;
                      if (v206 == v205)
                      {
                        v206 = *(char **)(*(void *)a3 + 392);
                        break;
                      }
                    }
                  }
                  if (v207 - v204 < v206 - v204)
                  {
                    uint64_t v230 = *(void *)(a1 + 16);
                    long long v222 = *(_OWORD *)a1;
                    long long v239 = *(_OWORD *)(v201 + 80);
                    unint64_t v208 = a1;
                    do
                    {
                      v209 = (_OWORD *)v208;
                      unint64_t v208 = v201;
                      long long v210 = *(_OWORD *)(v201 + 16);
                      _OWORD *v209 = *(_OWORD *)v201;
                      v209[1] = v210;
                      *(_OWORD *)((char *)v209 + 27) = *(_OWORD *)(v201 + 27);
                      uint64_t v211 = *(void *)(v201 - 24);
                      if (v202 == v211) {
                        break;
                      }
                      v212 = *(char **)(*(void *)a3 + 384);
                      v213 = *(char **)(*(void *)a3 + 392);
                      v214 = v212;
                      v215 = v212;
                      if (v212 != v213)
                      {
                        do
                        {
                          if (*(void *)v215 == v202) {
                            goto LABEL_322;
                          }
                          v215 += 8;
                        }
                        while (v215 != v213);
                        v215 = *(char **)(*(void *)a3 + 392);
LABEL_322:
                        while (*(void *)v214 != v211)
                        {
                          v214 += 8;
                          if (v214 == v213)
                          {
                            v214 = *(char **)(*(void *)a3 + 392);
                            break;
                          }
                        }
                      }
                      unint64_t v201 = v208 - 48;
                    }
                    while (v215 - v212 < v214 - v212);
                    *(_OWORD *)unint64_t v208 = v222;
                    *(void *)(v208 + 16) = v230;
                    *(void *)(v208 + 24) = v202;
                    *(void *)(v208 + 32) = v239;
                    *(_DWORD *)(v208 + 39) = *(_DWORD *)((char *)&v239 + 7);
                  }
                }
                BOOL v111 = (long long *)(a1 + 48);
              }
              while ((long long *)(a1 + 48) != a2);
            }
            return;
          }
          if (!a4)
          {
            if ((long long *)v13 != a2)
            {
              int64_t v129 = (v15 - 2) >> 1;
              int64_t v130 = v129;
              do
              {
                int64_t v131 = v130;
                if (v129 >= v130)
                {
                  uint64_t v132 = (2 * v130) | 1;
                  unint64_t v133 = v13 + 48 * v132;
                  if (2 * v131 + 2 < (uint64_t)v15)
                  {
                    uint64_t v134 = *(void *)(v133 + 24);
                    uint64_t v135 = *(void *)(v133 + 72);
                    if (v134 != v135)
                    {
                      v137 = *(char **)(*(void *)a3 + 384);
                      v136 = *(char **)(*(void *)a3 + 392);
                      v138 = v137;
                      v139 = v137;
                      if (v137 != v136)
                      {
                        do
                        {
                          if (*(void *)v139 == v134) {
                            goto LABEL_224;
                          }
                          v139 += 8;
                        }
                        while (v139 != v136);
                        v139 = *(char **)(*(void *)a3 + 392);
LABEL_224:
                        while (*(void *)v138 != v135)
                        {
                          v138 += 8;
                          if (v138 == v136)
                          {
                            v138 = *(char **)(*(void *)a3 + 392);
                            break;
                          }
                        }
                      }
                      v133 += 48 * (v139 - v137 < v138 - v137);
                      if (v139 - v137 < v138 - v137) {
                        uint64_t v132 = 2 * v131 + 2;
                      }
                    }
                  }
                  unint64_t v140 = v13 + 48 * v131;
                  uint64_t v141 = *(void *)(v133 + 24);
                  uint64_t v142 = *(void *)(v140 + 24);
                  if (v141 == v142) {
                    goto LABEL_238;
                  }
                  int64_t v144 = *(char **)(*(void *)a3 + 384);
                  v143 = *(char **)(*(void *)a3 + 392);
                  v145 = v144;
                  v146 = v144;
                  if (v144 != v143)
                  {
                    do
                    {
                      if (*(void *)v146 == v141) {
                        goto LABEL_234;
                      }
                      v146 += 8;
                    }
                    while (v146 != v143);
                    v146 = *(char **)(*(void *)a3 + 392);
LABEL_234:
                    while (*(void *)v145 != v142)
                    {
                      v145 += 8;
                      if (v145 == v143)
                      {
                        v145 = *(char **)(*(void *)a3 + 392);
                        break;
                      }
                    }
                  }
                  if (v146 - v144 >= v145 - v144)
                  {
LABEL_238:
                    uint64_t v228 = *(void *)(v140 + 16);
                    long long v220 = *(_OWORD *)v140;
                    long long v237 = *(_OWORD *)(v140 + 32);
                    long long v147 = *(_OWORD *)v133;
                    long long v148 = *(_OWORD *)(v133 + 16);
                    *(_OWORD *)(v140 + 27) = *(_OWORD *)(v133 + 27);
                    *(_OWORD *)unint64_t v140 = v147;
                    *(_OWORD *)(v140 + 16) = v148;
                    if (v129 >= v132)
                    {
                      while (1)
                      {
                        uint64_t v150 = 2 * v132;
                        uint64_t v132 = (2 * v132) | 1;
                        unint64_t v149 = v13 + 48 * v132;
                        uint64_t v151 = v150 + 2;
                        if (v151 < (uint64_t)v15)
                        {
                          uint64_t v152 = *(void *)(v149 + 24);
                          uint64_t v153 = *(void *)(v149 + 72);
                          if (v152 != v153)
                          {
                            long long v154 = *(char **)(*(void *)a3 + 384);
                            __int16 v155 = *(char **)(*(void *)a3 + 392);
                            v156 = v154;
                            v157 = v154;
                            if (v154 != v155)
                            {
                              do
                              {
                                if (*(void *)v157 == v152) {
                                  goto LABEL_246;
                                }
                                v157 += 8;
                              }
                              while (v157 != v155);
                              v157 = *(char **)(*(void *)a3 + 392);
LABEL_246:
                              while (*(void *)v156 != v153)
                              {
                                v156 += 8;
                                if (v156 == v155)
                                {
                                  v156 = *(char **)(*(void *)a3 + 392);
                                  break;
                                }
                              }
                            }
                            v149 += 48 * (v157 - v154 < v156 - v154);
                            if (v157 - v154 < v156 - v154) {
                              uint64_t v132 = v151;
                            }
                          }
                        }
                        uint64_t v158 = *(void *)(v149 + 24);
                        if (v158 != v142)
                        {
                          v160 = *(char **)(*(void *)a3 + 384);
                          v159 = *(char **)(*(void *)a3 + 392);
                          v161 = v160;
                          v162 = v160;
                          if (v160 != v159)
                          {
                            do
                            {
                              if (*(void *)v162 == v158) {
                                goto LABEL_256;
                              }
                              v162 += 8;
                            }
                            while (v162 != v159);
                            v162 = *(char **)(*(void *)a3 + 392);
LABEL_256:
                            while (*(void *)v161 != v142)
                            {
                              v161 += 8;
                              if (v161 == v159)
                              {
                                v161 = *(char **)(*(void *)a3 + 392);
                                break;
                              }
                            }
                          }
                          if (v162 - v160 < v161 - v160) {
                            break;
                          }
                        }
                        long long v163 = *(_OWORD *)v149;
                        long long v164 = *(_OWORD *)(v149 + 16);
                        *(_OWORD *)(v133 + 27) = *(_OWORD *)(v149 + 27);
                        *(_OWORD *)unint64_t v133 = v163;
                        *(_OWORD *)(v133 + 16) = v164;
                        unint64_t v133 = v149;
                        if (v129 < v132) {
                          goto LABEL_261;
                        }
                      }
                    }
                    unint64_t v149 = v133;
LABEL_261:
                    *(_OWORD *)unint64_t v149 = v220;
                    *(void *)(v149 + 16) = v228;
                    *(void *)(v149 + 24) = v142;
                    *(void *)(v149 + 32) = v237;
                    *(_DWORD *)(v149 + 39) = *(_DWORD *)((char *)&v237 + 7);
                  }
                }
                int64_t v130 = v131 - 1;
              }
              while (v131);
              int64_t v165 = v14 / 0x30uLL;
              do
              {
                uint64_t v166 = 0;
                *(_OWORD *)v229 = *(_OWORD *)(v13 + 16);
                *(_OWORD *)&v229[16] = *(_OWORD *)(v13 + 32);
                long long v221 = *(_OWORD *)v13;
                uint64_t v167 = v165 - 2;
                if (v165 < 2) {
                  uint64_t v167 = v165 - 1;
                }
                uint64_t v168 = v167 >> 1;
                unint64_t v169 = v13;
                do
                {
                  v170 = (_OWORD *)v169;
                  v169 += 48 * v166 + 48;
                  uint64_t v171 = 2 * v166;
                  uint64_t v166 = (2 * v166) | 1;
                  uint64_t v172 = v171 + 2;
                  if (v171 + 2 < v165)
                  {
                    uint64_t v173 = *(void *)(v169 + 24);
                    uint64_t v174 = *(void *)(v169 + 72);
                    if (v173 != v174)
                    {
                      v176 = *(char **)(*(void *)a3 + 384);
                      v175 = *(char **)(*(void *)a3 + 392);
                      v177 = v176;
                      v178 = v176;
                      if (v176 != v175)
                      {
                        do
                        {
                          if (*(void *)v178 == v173) {
                            goto LABEL_273;
                          }
                          v178 += 8;
                        }
                        while (v178 != v175);
                        v178 = *(char **)(*(void *)a3 + 392);
LABEL_273:
                        while (*(void *)v177 != v174)
                        {
                          v177 += 8;
                          if (v177 == v175)
                          {
                            v177 = *(char **)(*(void *)a3 + 392);
                            break;
                          }
                        }
                      }
                      v169 += 48 * (v178 - v176 < v177 - v176);
                      if (v178 - v176 < v177 - v176) {
                        uint64_t v166 = v172;
                      }
                    }
                  }
                  long long v179 = *(_OWORD *)v169;
                  long long v180 = *(_OWORD *)(v169 + 16);
                  *(_OWORD *)((char *)v170 + 27) = *(_OWORD *)(v169 + 27);
                  _OWORD *v170 = v179;
                  v170[1] = v180;
                }
                while (v166 <= v168);
                a2 -= 3;
                if ((long long *)v169 == a2)
                {
                  *(_OWORD *)(v169 + 27) = *(_OWORD *)&v229[11];
                  *(_OWORD *)unint64_t v169 = v221;
                  *(_OWORD *)(v169 + 16) = *(_OWORD *)v229;
                }
                else
                {
                  long long v181 = *a2;
                  long long v182 = a2[1];
                  *(_OWORD *)(v169 + 27) = *(long long *)((char *)a2 + 27);
                  *(_OWORD *)unint64_t v169 = v181;
                  *(_OWORD *)(v169 + 16) = v182;
                  *(long long *)((char *)a2 + 27) = *(_OWORD *)&v229[11];
                  *a2 = v221;
                  a2[1] = *(_OWORD *)v229;
                  uint64_t v183 = v169 - v13 + 48;
                  if (v183 >= 49)
                  {
                    unint64_t v184 = (v183 / 0x30uLL - 2) >> 1;
                    unint64_t v185 = v13 + 48 * v184;
                    uint64_t v186 = *(void *)(v185 + 24);
                    uint64_t v187 = *(void *)(v169 + 24);
                    if (v186 != v187)
                    {
                      v189 = *(char **)(*(void *)a3 + 384);
                      v188 = *(char **)(*(void *)a3 + 392);
                      v190 = v189;
                      v191 = v189;
                      if (v189 != v188)
                      {
                        do
                        {
                          if (*(void *)v191 == v186) {
                            goto LABEL_286;
                          }
                          v191 += 8;
                        }
                        while (v191 != v188);
                        v191 = *(char **)(*(void *)a3 + 392);
LABEL_286:
                        while (*(void *)v190 != v187)
                        {
                          v190 += 8;
                          if (v190 == v188)
                          {
                            v190 = *(char **)(*(void *)a3 + 392);
                            break;
                          }
                        }
                      }
                      if (v191 - v189 < v190 - v189)
                      {
                        uint64_t v242 = *(void *)(v169 + 16);
                        long long v238 = *(_OWORD *)v169;
                        long long v233 = *(_OWORD *)(v169 + 32);
                        do
                        {
                          v192 = (_OWORD *)v169;
                          unint64_t v169 = v185;
                          long long v193 = *(_OWORD *)v185;
                          long long v194 = *(_OWORD *)(v185 + 16);
                          *(_OWORD *)((char *)v192 + 27) = *(_OWORD *)(v185 + 27);
                          _OWORD *v192 = v193;
                          v192[1] = v194;
                          if (!v184) {
                            break;
                          }
                          unint64_t v184 = (v184 - 1) >> 1;
                          unint64_t v185 = v13 + 48 * v184;
                          uint64_t v195 = *(void *)(v185 + 24);
                          if (v195 == v187) {
                            break;
                          }
                          v197 = *(char **)(*(void *)a3 + 384);
                          v196 = *(char **)(*(void *)a3 + 392);
                          v198 = v197;
                          v199 = v197;
                          if (v197 != v196)
                          {
                            do
                            {
                              if (*(void *)v199 == v195) {
                                goto LABEL_297;
                              }
                              v199 += 8;
                            }
                            while (v199 != v196);
                            v199 = *(char **)(*(void *)a3 + 392);
LABEL_297:
                            while (*(void *)v198 != v187)
                            {
                              v198 += 8;
                              if (v198 == v196)
                              {
                                v198 = *(char **)(*(void *)a3 + 392);
                                break;
                              }
                            }
                          }
                        }
                        while (v199 - v197 < v198 - v197);
                        *(_OWORD *)unint64_t v169 = v238;
                        *(void *)(v169 + 16) = v242;
                        *(void *)(v169 + 24) = v187;
                        *(void *)(v169 + 32) = v233;
                        *(_DWORD *)(v169 + 39) = *(_DWORD *)((char *)&v233 + 7);
                      }
                    }
                  }
                }
              }
              while (v165-- > 2);
            }
            return;
          }
          unint64_t v16 = v15 >> 1;
          double v17 = (long long *)(v13 + 48 * (v15 >> 1));
          if ((unint64_t)v14 >= 0x1801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48 * (v15 >> 1)), a2 - 3, a3);
            uint64_t v18 = 3 * v16;
            double v19 = (long long *)(a1 + 48 * v16 - 48);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48), v19, a2 - 6, a3);
            uint64_t v20 = (long long *)(a1 + 48 + 16 * v18);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 96), v20, a2 - 9, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v19, v17, v20, a3);
            *(_OWORD *)v223 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&v223[16] = *(_OWORD *)(a1 + 32);
            long long v216 = *(_OWORD *)a1;
            long long v21 = *(long long *)((char *)v17 + 27);
            long long v22 = v17[1];
            *(_OWORD *)a1 = *v17;
            *(_OWORD *)(a1 + 16) = v22;
            *(_OWORD *)(a1 + 27) = v21;
            *(long long *)((char *)v17 + 27) = *(_OWORD *)&v223[11];
            *double v17 = v216;
            v17[1] = *(_OWORD *)v223;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48 * (v15 >> 1)), (long long *)a1, a2 - 3, a3);
          }
          --a4;
          if (a5)
          {
            uint64_t v23 = *(void *)(a1 + 24);
            uint64_t v24 = *(void *)a3;
            break;
          }
          uint64_t v25 = *(void *)(a1 - 24);
          uint64_t v23 = *(void *)(a1 + 24);
          if (v25 != v23)
          {
            uint64_t v24 = *(void *)a3;
            double v26 = *(char **)(*(void *)a3 + 384);
            double v27 = *(char **)(*(void *)a3 + 392);
            double v28 = v26;
            long long v29 = v26;
            if (v26 != v27)
            {
              do
              {
                if (*(void *)v29 == v25) {
                  goto LABEL_16;
                }
                v29 += 8;
              }
              while (v29 != v27);
              long long v29 = *(char **)(*(void *)a3 + 392);
LABEL_16:
              while (*(void *)v28 != v23)
              {
                v28 += 8;
                if (v28 == v27)
                {
                  double v28 = *(char **)(*(void *)a3 + 392);
                  break;
                }
              }
            }
            if (v29 - v26 < v28 - v26) {
              break;
            }
          }
          uint64_t v241 = *(void *)(a1 + 16);
          long long v232 = *(_OWORD *)(a1 + 32);
          long long v235 = *(_OWORD *)a1;
          uint64_t v67 = *((void *)a2 - 3);
          if (v23 == v67) {
            goto LABEL_107;
          }
          unint64_t v68 = *(char **)(*(void *)a3 + 384);
          uint64_t v69 = *(char **)(*(void *)a3 + 392);
          if (v68 == v69)
          {
            double v71 = *(char **)(*(void *)a3 + 384);
            uint64_t v70 = v71;
          }
          else
          {
            uint64_t v70 = *(char **)(*(void *)a3 + 384);
            while (*(void *)v70 != v23)
            {
              v70 += 8;
              if (v70 == v69)
              {
                uint64_t v70 = *(char **)(*(void *)a3 + 392);
                break;
              }
            }
            double v71 = *(char **)(*(void *)a3 + 384);
            while (*(void *)v71 != v67)
            {
              v71 += 8;
              if (v71 == v69)
              {
                double v71 = *(char **)(*(void *)a3 + 392);
                break;
              }
            }
          }
          if (v70 - v68 >= v71 - v68)
          {
LABEL_107:
            unint64_t v13 = a1 + 48;
            if (a1 + 48 < (unint64_t)a2)
            {
              uint64_t v75 = *(void *)a3;
              unint64_t v76 = a1;
              do
              {
                uint64_t v77 = *(void *)(v76 + 72);
                unint64_t v76 = v13;
                if (v23 != v77)
                {
                  unint64_t v78 = *(char **)(v75 + 384);
                  long long v79 = *(char **)(v75 + 392);
                  long long v80 = v78;
                  long long v81 = v78;
                  if (v78 != v79)
                  {
                    do
                    {
                      if (*(void *)v81 == v23) {
                        goto LABEL_114;
                      }
                      v81 += 8;
                    }
                    while (v81 != v79);
                    long long v81 = *(char **)(v75 + 392);
LABEL_114:
                    while (*(void *)v80 != v77)
                    {
                      v80 += 8;
                      if (v80 == v79)
                      {
                        long long v80 = *(char **)(v75 + 392);
                        break;
                      }
                    }
                  }
                  if (v81 - v78 < v80 - v78) {
                    break;
                  }
                }
                v13 += 48;
              }
              while (v76 + 48 < (unint64_t)a2);
            }
          }
          else
          {
            unint64_t v13 = a1;
            do
            {
              do
              {
                uint64_t v72 = *(void *)(v13 + 72);
                v13 += 48;
              }
              while (v23 == v72);
              if (v68 == v69)
              {
                int8x16_t v74 = *(char **)(*(void *)a3 + 384);
                uint64_t v73 = v74;
              }
              else
              {
                uint64_t v73 = *(char **)(*(void *)a3 + 384);
                while (*(void *)v73 != v23)
                {
                  v73 += 8;
                  if (v73 == v69)
                  {
                    uint64_t v73 = *(char **)(*(void *)a3 + 392);
                    break;
                  }
                }
                int8x16_t v74 = *(char **)(*(void *)a3 + 384);
                while (*(void *)v74 != v72)
                {
                  v74 += 8;
                  if (v74 == v69)
                  {
                    int8x16_t v74 = *(char **)(*(void *)a3 + 392);
                    break;
                  }
                }
              }
            }
            while (v73 - v68 >= v74 - v68);
          }
          long long v82 = a2;
          if (v13 < (unint64_t)a2)
          {
            uint64_t v83 = *(void *)a3;
            long long v82 = a2;
            do
            {
              uint64_t v84 = *((void *)v82 - 3);
              v82 -= 3;
              if (v23 == v84) {
                break;
              }
              int64_t v85 = *(char **)(v83 + 384);
              long long v86 = *(char **)(v83 + 392);
              long long v87 = v85;
              long long v88 = v85;
              if (v85 != v86)
              {
                do
                {
                  if (*(void *)v88 == v23) {
                    goto LABEL_126;
                  }
                  v88 += 8;
                }
                while (v88 != v86);
                long long v88 = *(char **)(v83 + 392);
LABEL_126:
                while (*(void *)v87 != v84)
                {
                  v87 += 8;
                  if (v87 == v86)
                  {
                    long long v87 = *(char **)(v83 + 392);
                    break;
                  }
                }
              }
            }
            while (v88 - v85 < v87 - v85);
          }
          while (v13 < (unint64_t)v82)
          {
            *(_OWORD *)v225 = *(_OWORD *)(v13 + 16);
            *(_OWORD *)&v225[16] = *(_OWORD *)(v13 + 32);
            long long v217 = *(_OWORD *)v13;
            long long v89 = *v82;
            long long v90 = v82[1];
            *(_OWORD *)(v13 + 27) = *(long long *)((char *)v82 + 27);
            *(_OWORD *)unint64_t v13 = v89;
            *(_OWORD *)(v13 + 16) = v90;
            *(long long *)((char *)v82 + 27) = *(_OWORD *)&v225[11];
            *long long v82 = v217;
            v82[1] = *(_OWORD *)v225;
            uint64_t v91 = *(void *)a3;
            do
            {
              do
              {
                uint64_t v92 = *(void *)(v13 + 72);
                v13 += 48;
              }
              while (v23 == v92);
              long long v93 = *(char **)(v91 + 384);
              uint64_t v94 = *(char **)(v91 + 392);
              if (v93 == v94)
              {
                BOOL v96 = *(char **)(v91 + 384);
                uint64_t v95 = v96;
              }
              else
              {
                uint64_t v95 = *(char **)(v91 + 384);
                while (*(void *)v95 != v23)
                {
                  v95 += 8;
                  if (v95 == v94)
                  {
                    uint64_t v95 = *(char **)(v91 + 392);
                    break;
                  }
                }
                BOOL v96 = *(char **)(v91 + 384);
                while (*(void *)v96 != v92)
                {
                  v96 += 8;
                  if (v96 == v94)
                  {
                    BOOL v96 = *(char **)(v91 + 392);
                    break;
                  }
                }
              }
            }
            while (v95 - v93 >= v96 - v93);
            do
            {
              uint64_t v97 = *((void *)v82 - 3);
              v82 -= 3;
              if (v23 == v97) {
                break;
              }
              if (v93 == v94)
              {
                unint64_t v99 = v93;
                uint64_t v98 = v93;
              }
              else
              {
                uint64_t v98 = v93;
                while (*(void *)v98 != v23)
                {
                  v98 += 8;
                  if (v98 == v94)
                  {
                    uint64_t v98 = v94;
                    break;
                  }
                }
                unint64_t v99 = v93;
                while (*(void *)v99 != v97)
                {
                  v99 += 8;
                  if (v99 == v94)
                  {
                    unint64_t v99 = v94;
                    break;
                  }
                }
              }
            }
            while (v98 - v93 < v99 - v93);
          }
          unint64_t v100 = (long long *)(v13 - 48);
          BOOL v5 = v13 - 48 >= a1;
          BOOL v6 = v13 - 48 == a1;
          if (v13 - 48 != a1)
          {
            long long v101 = *v100;
            long long v102 = *(_OWORD *)(v13 - 32);
            *(_OWORD *)(a1 + 27) = *(_OWORD *)(v13 - 21);
            *(_OWORD *)a1 = v101;
            *(_OWORD *)(a1 + 16) = v102;
          }
          a5 = 0;
          *unint64_t v100 = v235;
          *(void *)(v13 - 32) = v241;
          *(void *)(v13 - 24) = v23;
          *(_DWORD *)(v13 - 9) = *(_DWORD *)((char *)&v232 + 7);
          *(void *)(v13 - 16) = v232;
        }
        uint64_t v240 = *(void *)(a1 + 16);
        long long v231 = *(_OWORD *)(a1 + 32);
        long long v234 = *(_OWORD *)a1;
        unint64_t v30 = a1;
        do
        {
          unint64_t v31 = v30;
          v30 += 48;
          uint64_t v32 = *(void *)(v31 + 72);
          if (v32 == v23) {
            break;
          }
          uint64_t v33 = *(char **)(v24 + 384);
          long long v34 = *(char **)(v24 + 392);
          long long v35 = v33;
          double v36 = v33;
          if (v33 != v34)
          {
            do
            {
              if (*(void *)v36 == v32) {
                goto LABEL_26;
              }
              v36 += 8;
            }
            while (v36 != v34);
            double v36 = *(char **)(v24 + 392);
LABEL_26:
            while (*(void *)v35 != v23)
            {
              v35 += 8;
              if (v35 == v34)
              {
                long long v35 = *(char **)(v24 + 392);
                break;
              }
            }
          }
        }
        while (v36 - v33 < v35 - v33);
        unint64_t v37 = a2;
        if (v31 == a1)
        {
          unint64_t v37 = a2;
          if (v30 < (unint64_t)a2)
          {
            unint64_t v37 = a2;
            do
            {
              uint64_t v43 = *((void *)v37 - 3);
              v37 -= 3;
              if (v43 != v23)
              {
                unint64_t v44 = *(char **)(v24 + 384);
                long long v45 = *(char **)(v24 + 392);
                id v46 = v44;
                uint64_t v47 = v44;
                if (v44 != v45)
                {
                  do
                  {
                    if (*(void *)v47 == v43) {
                      goto LABEL_48;
                    }
                    v47 += 8;
                  }
                  while (v47 != v45);
                  uint64_t v47 = *(char **)(v24 + 392);
LABEL_48:
                  while (*(void *)v46 != v23)
                  {
                    v46 += 8;
                    if (v46 == v45)
                    {
                      id v46 = *(char **)(v24 + 392);
                      break;
                    }
                  }
                }
                if (v47 - v44 < v46 - v44) {
                  break;
                }
              }
            }
            while (v30 < (unint64_t)v37);
          }
        }
        else
        {
          do
          {
            do
            {
              uint64_t v38 = *((void *)v37 - 3);
              v37 -= 3;
            }
            while (v38 == v23);
            uint64_t v39 = *(char **)(v24 + 384);
            uint64_t v40 = *(char **)(v24 + 392);
            char v41 = v39;
            uint64_t v42 = v39;
            if (v39 != v40)
            {
              do
              {
                if (*(void *)v42 == v38) {
                  goto LABEL_36;
                }
                v42 += 8;
              }
              while (v42 != v40);
              uint64_t v42 = *(char **)(v24 + 392);
LABEL_36:
              while (*(void *)v41 != v23)
              {
                v41 += 8;
                if (v41 == v40)
                {
                  char v41 = *(char **)(v24 + 392);
                  break;
                }
              }
            }
          }
          while (v42 - v39 >= v41 - v39);
        }
        unint64_t v13 = v30;
        if (v30 < (unint64_t)v37)
        {
          uint64_t v48 = v37;
          do
          {
            *(_OWORD *)v224 = *(_OWORD *)(v13 + 16);
            *(_OWORD *)&v224[16] = *(_OWORD *)(v13 + 32);
            long long v49 = *(_OWORD *)v13;
            long long v51 = *v48;
            long long v50 = v48[1];
            *(_OWORD *)(v13 + 27) = *(long long *)((char *)v48 + 27);
            *(_OWORD *)unint64_t v13 = v51;
            *(_OWORD *)(v13 + 16) = v50;
            *(long long *)((char *)v48 + 27) = *(_OWORD *)&v224[11];
            *uint64_t v48 = v49;
            v48[1] = *(_OWORD *)v224;
            uint64_t v52 = *(void *)a3;
            do
            {
              uint64_t v53 = *(void *)(v13 + 72);
              v13 += 48;
              if (v53 == v23) {
                break;
              }
              unint64_t v54 = *(char **)(v52 + 384);
              double v55 = *(char **)(v52 + 392);
              double v56 = v54;
              uint64_t v57 = v54;
              if (v54 != v55)
              {
                do
                {
                  if (*(void *)v57 == v53) {
                    goto LABEL_61;
                  }
                  v57 += 8;
                }
                while (v57 != v55);
                uint64_t v57 = *(char **)(v52 + 392);
LABEL_61:
                while (*(void *)v56 != v23)
                {
                  v56 += 8;
                  if (v56 == v55)
                  {
                    double v56 = *(char **)(v52 + 392);
                    break;
                  }
                }
              }
            }
            while (v57 - v54 < v56 - v54);
            do
            {
              do
              {
                uint64_t v58 = *((void *)v48 - 3);
                v48 -= 3;
              }
              while (v58 == v23);
              long long v59 = *(char **)(v52 + 384);
              long long v60 = *(char **)(v52 + 392);
              unint64_t v61 = v59;
              long long v62 = v59;
              if (v59 != v60)
              {
                do
                {
                  if (*(void *)v62 == v58) {
                    goto LABEL_70;
                  }
                  v62 += 8;
                }
                while (v62 != v60);
                long long v62 = *(char **)(v52 + 392);
LABEL_70:
                while (*(void *)v61 != v23)
                {
                  v61 += 8;
                  if (v61 == v60)
                  {
                    unint64_t v61 = *(char **)(v52 + 392);
                    break;
                  }
                }
              }
            }
            while (v62 - v59 >= v61 - v59);
          }
          while (v13 < (unint64_t)v48);
        }
        long long v63 = (long long *)(v13 - 48);
        if (v13 - 48 != a1)
        {
          long long v64 = *v63;
          long long v65 = *(_OWORD *)(v13 - 32);
          *(_OWORD *)(a1 + 27) = *(_OWORD *)(v13 - 21);
          *(_OWORD *)a1 = v64;
          *(_OWORD *)(a1 + 16) = v65;
        }
        long long *v63 = v234;
        *(void *)(v13 - 32) = v240;
        *(void *)(v13 - 24) = v23;
        *(_DWORD *)(v13 - 9) = *(_DWORD *)((char *)&v231 + 7);
        *(void *)(v13 - 16) = v231;
        if (v30 >= (unint64_t)v37) {
          break;
        }
LABEL_80:
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*,false>(a1, v13 - 48, a3, a4, a5 & 1);
        a5 = 0;
      }
      BOOL v66 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*>(a1, v13 - 48, a3);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*>(v13, (uint64_t)a2, a3))
      {
        break;
      }
      if (!v66) {
        goto LABEL_80;
      }
    }
    a2 = (long long *)(v13 - 48);
    if (!v66) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = *(void *)(a2 - 24);
      uint64_t v9 = *(void *)(a1 + 24);
      if (v8 == v9) {
        return result;
      }
      id v10 = *(char **)(*(void *)a3 + 384);
      int64_t v11 = *(char **)(*(void *)a3 + 392);
      unint64_t v12 = v10;
      unint64_t v13 = v10;
      if (v10 == v11) {
        goto LABEL_10;
      }
      do
      {
        if (*(void *)v13 == v8) {
          goto LABEL_7;
        }
        v13 += 8;
      }
      while (v13 != v11);
      unint64_t v13 = *(char **)(*(void *)a3 + 392);
      do
      {
LABEL_7:
        if (*(void *)v12 == v9) {
          goto LABEL_10;
        }
        v12 += 8;
      }
      while (v12 != v11);
      unint64_t v12 = *(char **)(*(void *)a3 + 392);
LABEL_10:
      if (v13 - v10 < v12 - v10)
      {
        uint64_t v14 = (long long *)(a2 - 48);
        long long v15 = *(_OWORD *)a1;
        *(_OWORD *)long long v35 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v35[16] = *(_OWORD *)(a1 + 32);
        long long v16 = *(_OWORD *)(a2 - 21);
        long long v17 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a1 + 16) = v17;
        *(_OWORD *)(a1 + 27) = v16;
        long long *v14 = v15;
        v14[1] = *(_OWORD *)v35;
        *(long long *)((char *)v14 + 27) = *(_OWORD *)&v35[11];
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a2 - 48), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a2 - 48, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a1 + 144, a2 - 48, a3);
      return 1;
    default:
      uint64_t v18 = a1 + 96;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a1 + 96), a3);
      uint64_t v19 = a1 + 144;
      if (a1 + 144 == a2) {
        return 1;
      }
      int v20 = 0;
      break;
  }
  while (1)
  {
    uint64_t v21 = *(void *)(v19 + 24);
    uint64_t v22 = *(void *)(v18 + 24);
    if (v21 != v22)
    {
      uint64_t v23 = *(char **)(*(void *)a3 + 384);
      uint64_t v24 = *(char **)(*(void *)a3 + 392);
      uint64_t v25 = v23;
      double v26 = v23;
      if (v23 != v24)
      {
        do
        {
          if (*(void *)v26 == v21) {
            goto LABEL_19;
          }
          v26 += 8;
        }
        while (v26 != v24);
        double v26 = *(char **)(*(void *)a3 + 392);
LABEL_19:
        while (*(void *)v25 != v22)
        {
          v25 += 8;
          if (v25 == v24)
          {
            uint64_t v25 = *(char **)(*(void *)a3 + 392);
            break;
          }
        }
      }
      if (v26 - v23 < v25 - v23)
      {
        long long v34 = *(_OWORD *)v19;
        uint64_t v36 = *(void *)(v19 + 16);
        long long v37 = *(_OWORD *)(v19 + 32);
        uint64_t v27 = v19;
        while (1)
        {
          long long v28 = *(_OWORD *)(v18 + 16);
          *(_OWORD *)uint64_t v27 = *(_OWORD *)v18;
          *(_OWORD *)(v27 + 16) = v28;
          *(_OWORD *)(v27 + 27) = *(_OWORD *)(v18 + 27);
          if (v18 == a1) {
            break;
          }
          uint64_t v27 = v18;
          uint64_t v29 = *(void *)(v18 - 24);
          if (v21 != v29)
          {
            unint64_t v30 = *(char **)(*(void *)a3 + 384);
            unint64_t v31 = *(char **)(*(void *)a3 + 392);
            uint64_t v32 = v30;
            uint64_t v33 = v30;
            if (v30 != v31)
            {
              do
              {
                if (*(void *)v33 == v21) {
                  goto LABEL_30;
                }
                v33 += 8;
              }
              while (v33 != v31);
              uint64_t v33 = *(char **)(*(void *)a3 + 392);
LABEL_30:
              while (*(void *)v32 != v29)
              {
                v32 += 8;
                if (v32 == v31)
                {
                  uint64_t v32 = *(char **)(*(void *)a3 + 392);
                  break;
                }
              }
            }
            v18 -= 48;
            if (v33 - v30 < v32 - v30) {
              continue;
            }
          }
          goto LABEL_36;
        }
        uint64_t v27 = a1;
LABEL_36:
        *(_OWORD *)uint64_t v27 = v34;
        *(void *)(v27 + 16) = v36;
        *(void *)(v27 + 24) = v21;
        *(void *)(v27 + 32) = v37;
        *(_DWORD *)(v27 + 39) = *(_DWORD *)((char *)&v37 + 7);
        if (++v20 == 8) {
          return v19 + 48 == a2;
        }
      }
    }
    uint64_t v18 = v19;
    v19 += 48;
    if (v19 == a2) {
      return 1;
    }
  }
}

void std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*,false>(unint64_t a1, long long *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 4);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*((double *)a2 - 5) < *(double *)(v10 + 8))
                {
                  *(_OWORD *)BOOL v118 = *(_OWORD *)(v10 + 16);
                  *(_OWORD *)&v118[16] = *(_OWORD *)(v10 + 32);
                  long long v110 = *(_OWORD *)v10;
                  long long v52 = *(a2 - 3);
                  long long v53 = *(a2 - 2);
                  *(_OWORD *)(v10 + 27) = *(long long *)((char *)a2 - 21);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 16) = v53;
                  *(long long *)((char *)a2 - 21) = *(_OWORD *)&v118[11];
                  *(a2 - 3) = v110;
                  *(a2 - 2) = *(_OWORD *)v118;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)v10, (long long *)(v10 + 48), a2 - 3);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v10, v10 + 48, v10 + 96, (uint64_t)(a2 - 3));
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v10, v10 + 48, v10 + 96, v10 + 144, (uint64_t)(a2 - 3));
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 1151)
          {
            unint64_t v54 = (long long *)(v10 + 48);
            BOOL v56 = (long long *)v10 == a2 || v54 == a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  long long v59 = v54;
                  double v60 = *(double *)(v58 + 56);
                  if (v60 < *(double *)(v58 + 8))
                  {
                    uint64_t v61 = *(void *)v54;
                    *(_OWORD *)BOOL v111 = *(_OWORD *)(v58 + 64);
                    *(_OWORD *)&v111[16] = *(_OWORD *)(v58 + 80);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      long long v63 = (_OWORD *)(v10 + v62);
                      long long v64 = *(_OWORD *)(v10 + v62 + 16);
                      v63[3] = *(_OWORD *)(v10 + v62);
                      v63[4] = v64;
                      *(_OWORD *)((char *)v63 + 75) = *(_OWORD *)(v10 + v62 + 27);
                      if (!v62) {
                        break;
                      }
                      v62 -= 48;
                      if (v60 >= *((double *)v63 - 5))
                      {
                        uint64_t v65 = v10 + v62 + 48;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_81:
                    *(void *)uint64_t v65 = v61;
                    *(double *)(v65 + 8) = v60;
                    *(_OWORD *)(v65 + 16) = *(_OWORD *)v111;
                    *(_OWORD *)(v65 + 27) = *(_OWORD *)&v111[11];
                  }
                  unint64_t v54 = v59 + 3;
                  v57 += 48;
                  unint64_t v58 = (unint64_t)v59;
                }
                while (v59 + 3 != a2);
              }
            }
            else if (!v56)
            {
              do
              {
                uint64_t v98 = v54;
                double v99 = *(double *)(a1 + 56);
                if (v99 < *(double *)(a1 + 8))
                {
                  uint64_t v100 = *(void *)v54;
                  *(_OWORD *)unint64_t v114 = *(_OWORD *)(a1 + 64);
                  *(_OWORD *)&v114[16] = *(_OWORD *)(a1 + 80);
                  long long v101 = v54;
                  do
                  {
                    long long v102 = *(v101 - 2);
                    long long *v101 = *(v101 - 3);
                    v101[1] = v102;
                    *(long long *)((char *)v101 + 27) = *(long long *)((char *)v101 - 21);
                    double v103 = *((double *)v101 - 11);
                    v101 -= 3;
                  }
                  while (v99 < v103);
                  *(void *)long long v101 = v100;
                  *((double *)v101 + 1) = v99;
                  *(long long *)((char *)v101 + 27) = *(_OWORD *)&v114[11];
                  v101[1] = *(_OWORD *)v114;
                }
                v54 += 3;
                a1 = (unint64_t)v98;
              }
              while (v98 + 3 != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((long long *)v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 48 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)(v70 + 8) < *(double *)(v70 + 56))
                  {
                    v70 += 48;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  unint64_t v71 = v10 + 48 * v68;
                  double v72 = *(double *)(v71 + 8);
                  if (*(double *)(v70 + 8) >= v72)
                  {
                    uint64_t v73 = *(void *)v71;
                    *(_OWORD *)int v112 = *(_OWORD *)(v71 + 16);
                    *(_OWORD *)&v112[16] = *(_OWORD *)(v71 + 32);
                    do
                    {
                      int8x16_t v74 = (_OWORD *)v71;
                      unint64_t v71 = v70;
                      long long v75 = *(_OWORD *)v70;
                      long long v76 = *(_OWORD *)(v70 + 16);
                      *(_OWORD *)((char *)v74 + 27) = *(_OWORD *)(v70 + 27);
                      *int8x16_t v74 = v75;
                      v74[1] = v76;
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v77 = 2 * v69;
                      uint64_t v69 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 48 * v69;
                      uint64_t v78 = v77 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v70 + 8) < *(double *)(v70 + 56))
                      {
                        v70 += 48;
                        uint64_t v69 = v78;
                      }
                    }
                    while (*(double *)(v70 + 8) >= v72);
                    *(void *)unint64_t v71 = v73;
                    *(double *)(v71 + 8) = v72;
                    *(_OWORD *)(v71 + 16) = *(_OWORD *)v112;
                    *(_OWORD *)(v71 + 27) = *(_OWORD *)&v112[11];
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              int64_t v79 = v11 / 0x30uLL;
              do
              {
                uint64_t v80 = 0;
                *(_OWORD *)uint64_t v119 = *(_OWORD *)(v10 + 16);
                *(_OWORD *)&v119[16] = *(_OWORD *)(v10 + 32);
                long long v113 = *(_OWORD *)v10;
                unint64_t v81 = v10;
                do
                {
                  long long v82 = (_OWORD *)v81;
                  v81 += 48 * v80 + 48;
                  uint64_t v83 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  int64_t v84 = v83 + 2;
                  if (v84 < v79 && *(double *)(v81 + 8) < *(double *)(v81 + 56))
                  {
                    v81 += 48;
                    uint64_t v80 = v84;
                  }
                  long long v85 = *(_OWORD *)v81;
                  long long v86 = *(_OWORD *)(v81 + 16);
                  *(_OWORD *)((char *)v82 + 27) = *(_OWORD *)(v81 + 27);
                  *long long v82 = v85;
                  v82[1] = v86;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 3;
                if ((long long *)v81 == a2)
                {
                  *(_OWORD *)(v81 + 27) = *(_OWORD *)&v119[11];
                  *(_OWORD *)unint64_t v81 = v113;
                  *(_OWORD *)(v81 + 16) = *(_OWORD *)v119;
                }
                else
                {
                  long long v87 = *a2;
                  long long v88 = a2[1];
                  *(_OWORD *)(v81 + 27) = *(long long *)((char *)a2 + 27);
                  *(_OWORD *)unint64_t v81 = v87;
                  *(_OWORD *)(v81 + 16) = v88;
                  *(long long *)((char *)a2 + 27) = *(_OWORD *)&v119[11];
                  *a2 = v113;
                  a2[1] = *(_OWORD *)v119;
                  uint64_t v89 = v81 - v10 + 48;
                  if (v89 >= 49)
                  {
                    unint64_t v90 = (v89 / 0x30uLL - 2) >> 1;
                    unint64_t v91 = v10 + 48 * v90;
                    double v92 = *(double *)(v81 + 8);
                    if (*(double *)(v91 + 8) < v92)
                    {
                      uint64_t v93 = *(void *)v81;
                      *(_OWORD *)long long v106 = *(_OWORD *)(v81 + 16);
                      *(_OWORD *)&v106[16] = *(_OWORD *)(v81 + 32);
                      do
                      {
                        uint64_t v94 = (_OWORD *)v81;
                        unint64_t v81 = v91;
                        long long v95 = *(_OWORD *)v91;
                        long long v96 = *(_OWORD *)(v91 + 16);
                        *(_OWORD *)((char *)v94 + 27) = *(_OWORD *)(v91 + 27);
                        *uint64_t v94 = v95;
                        v94[1] = v96;
                        if (!v90) {
                          break;
                        }
                        unint64_t v90 = (v90 - 1) >> 1;
                        unint64_t v91 = v10 + 48 * v90;
                      }
                      while (*(double *)(v91 + 8) < v92);
                      *(void *)unint64_t v81 = v93;
                      *(double *)(v81 + 8) = v92;
                      *(_OWORD *)(v81 + 16) = *(_OWORD *)v106;
                      *(_OWORD *)(v81 + 27) = *(_OWORD *)&v106[11];
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (long long *)(v10 + 48 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x1801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48 * (v12 >> 1)), a2 - 3);
            uint64_t v15 = 3 * v13;
            long long v16 = (long long *)(a1 + 48 * v13 - 48);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48), v16, a2 - 6);
            long long v17 = (long long *)(a1 + 48 + 16 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 96), v17, a2 - 9);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v16, v14, v17);
            *(_OWORD *)unint64_t v115 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&v115[16] = *(_OWORD *)(a1 + 32);
            long long v107 = *(_OWORD *)a1;
            long long v18 = *(long long *)((char *)v14 + 27);
            long long v19 = v14[1];
            *(_OWORD *)a1 = *v14;
            *(_OWORD *)(a1 + 16) = v19;
            *(_OWORD *)(a1 + 27) = v18;
            *(long long *)((char *)v14 + 27) = *(_OWORD *)&v115[11];
            long long *v14 = v107;
            v14[1] = *(_OWORD *)v115;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48 * (v12 >> 1)), (long long *)a1, a2 - 3);
          }
          --a3;
          if (a4) {
            break;
          }
          double v20 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 40) < v20) {
            goto LABEL_12;
          }
          uint64_t v38 = *(void *)a1;
          *(_OWORD *)unint64_t v105 = *(_OWORD *)(a1 + 16);
          *(_OWORD *)&v105[16] = *(_OWORD *)(a1 + 32);
          if (v20 >= *((double *)a2 - 5))
          {
            unint64_t v41 = a1 + 48;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= (unint64_t)a2) {
                break;
              }
              double v42 = *(double *)(v41 + 8);
              v41 += 48;
            }
            while (v20 >= v42);
          }
          else
          {
            unint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 48;
              double v40 = *(double *)(v39 + 56);
              v39 += 48;
            }
            while (v20 >= v40);
          }
          uint64_t v43 = a2;
          if (v10 < (unint64_t)a2)
          {
            unint64_t v44 = a2;
            do
            {
              uint64_t v43 = v44 - 3;
              double v45 = *((double *)v44 - 5);
              v44 -= 3;
            }
            while (v20 < v45);
          }
          while (v10 < (unint64_t)v43)
          {
            *(_OWORD *)uint64_t v117 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)&v117[16] = *(_OWORD *)(v10 + 32);
            long long v109 = *(_OWORD *)v10;
            long long v46 = *v43;
            long long v47 = v43[1];
            *(_OWORD *)(v10 + 27) = *(long long *)((char *)v43 + 27);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(long long *)((char *)v43 + 27) = *(_OWORD *)&v117[11];
            long long *v43 = v109;
            v43[1] = *(_OWORD *)v117;
            do
            {
              double v48 = *(double *)(v10 + 56);
              v10 += 48;
            }
            while (v20 >= v48);
            do
            {
              double v49 = *((double *)v43 - 5);
              v43 -= 3;
            }
            while (v20 < v49);
          }
          BOOL v4 = v10 - 48 >= a1;
          BOOL v5 = v10 - 48 == a1;
          if (v10 - 48 != a1)
          {
            long long v50 = *(_OWORD *)(v10 - 48);
            long long v51 = *(_OWORD *)(v10 - 32);
            *(_OWORD *)(a1 + 27) = *(_OWORD *)(v10 - 21);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 16) = v51;
          }
          a4 = 0;
          *(void *)(v10 - 48) = v38;
          *(double *)(v10 - 40) = v20;
          *(_OWORD *)(v10 - 21) = *(_OWORD *)&v105[11];
          *(_OWORD *)(v10 - 32) = *(_OWORD *)v105;
        }
        double v20 = *(double *)(a1 + 8);
LABEL_12:
        uint64_t v21 = 0;
        uint64_t v22 = *(void *)a1;
        *(_OWORD *)uint64_t v104 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v104[16] = *(_OWORD *)(a1 + 32);
        do
        {
          double v23 = *(double *)(a1 + v21 + 56);
          v21 += 48;
        }
        while (v23 < v20);
        unint64_t v24 = a1 + v21;
        uint64_t v25 = a2;
        if (v21 == 48)
        {
          long long v28 = a2;
          while (v24 < (unint64_t)v28)
          {
            double v26 = v28 - 3;
            double v29 = *((double *)v28 - 5);
            v28 -= 3;
            if (v29 < v20) {
              goto LABEL_22;
            }
          }
          double v26 = v28;
        }
        else
        {
          do
          {
            double v26 = v25 - 3;
            double v27 = *((double *)v25 - 5);
            v25 -= 3;
          }
          while (v27 >= v20);
        }
LABEL_22:
        unint64_t v10 = v24;
        if (v24 < (unint64_t)v26)
        {
          unint64_t v30 = v26;
          do
          {
            *(_OWORD *)uint64_t v116 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)&v116[16] = *(_OWORD *)(v10 + 32);
            long long v108 = *(_OWORD *)v10;
            long long v31 = *v30;
            long long v32 = v30[1];
            *(_OWORD *)(v10 + 27) = *(long long *)((char *)v30 + 27);
            *(_OWORD *)unint64_t v10 = v31;
            *(_OWORD *)(v10 + 16) = v32;
            *(long long *)((char *)v30 + 27) = *(_OWORD *)&v116[11];
            long long *v30 = v108;
            v30[1] = *(_OWORD *)v116;
            do
            {
              double v33 = *(double *)(v10 + 56);
              v10 += 48;
            }
            while (v33 < v20);
            do
            {
              double v34 = *((double *)v30 - 5);
              v30 -= 3;
            }
            while (v34 >= v20);
          }
          while (v10 < (unint64_t)v30);
        }
        if (v10 - 48 != a1)
        {
          long long v35 = *(_OWORD *)(v10 - 48);
          long long v36 = *(_OWORD *)(v10 - 32);
          *(_OWORD *)(a1 + 27) = *(_OWORD *)(v10 - 21);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
        }
        *(void *)(v10 - 48) = v22;
        *(double *)(v10 - 40) = v20;
        *(_OWORD *)(v10 - 21) = *(_OWORD *)&v104[11];
        *(_OWORD *)(v10 - 32) = *(_OWORD *)v104;
        if (v24 >= (unint64_t)v26) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*,false>(a1, v10 - 48, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*>(a1, v10 - 48);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_33;
      }
    }
    a2 = (long long *)(v10 - 48);
    if (!v37) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_SampleRemainder*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 40) < *(double *)(a1 + 8))
      {
        long long v6 = *(_OWORD *)a1;
        *(_OWORD *)double v20 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v20[16] = *(_OWORD *)(a1 + 32);
        long long v7 = *(_OWORD *)(a2 - 21);
        long long v8 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a1 + 16) = v8;
        *(_OWORD *)(a1 + 27) = v7;
        *(_OWORD *)(a2 - 48) = v6;
        *(_OWORD *)(a2 - 32) = *(_OWORD *)v20;
        *(_OWORD *)(a2 - 21) = *(_OWORD *)&v20[11];
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a2 - 48));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a2 - 48);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a1 + 144, a2 - 48);
      return 1;
    default:
      uint64_t v9 = a1 + 96;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a1 + 96));
      uint64_t v10 = a1 + 144;
      if (a1 + 144 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    double v13 = *(double *)(v10 + 8);
    if (v13 < *(double *)(v9 + 8))
    {
      uint64_t v14 = *(void *)v10;
      *(_OWORD *)long long v19 = *(_OWORD *)(v10 + 16);
      *(_OWORD *)&v19[16] = *(_OWORD *)(v10 + 32);
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        long long v17 = *(_OWORD *)(a1 + v15 + 112);
        *(_OWORD *)(v16 + 144) = *(_OWORD *)(a1 + v15 + 96);
        *(_OWORD *)(v16 + 160) = v17;
        *(_OWORD *)(v16 + 171) = *(_OWORD *)(a1 + v15 + 123);
        if (v15 == -96) {
          break;
        }
        v15 -= 48;
        if (v13 >= *(double *)(v16 + 56))
        {
          uint64_t v18 = a1 + v15 + 144;
          goto LABEL_12;
        }
      }
      uint64_t v18 = a1;
LABEL_12:
      *(void *)uint64_t v18 = v14;
      *(double *)(v18 + 8) = v13;
      *(_OWORD *)(v18 + 16) = *(_OWORD *)v19;
      *(_OWORD *)(v18 + 27) = *(_OWORD *)&v19[11];
      if (++v12 == 8) {
        return v10 + 48 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 48;
    v10 += 48;
    if (v10 == a2) {
      return 1;
    }
  }
}

void HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::statisticsByBundleIdentifier(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  double v3 = *(void **)(a2 + 320);
  long long v50 = (void *)(a2 + 328);
  if (v3 == (void *)(a2 + 328)) {
    return;
  }
  long long v52 = (void *)(a1 + 16);
  do
  {
    BOOL v5 = HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_bundleIdentifierForSourceID(a2, v3[4]);
    long long v6 = v5;
    if (!v5) {
      goto LABEL_81;
    }
    unint64_t v7 = [v5 hash];
    unint64_t v8 = v7;
    unint64_t v9 = *(void *)(a1 + 8);
    if (!v9) {
      goto LABEL_21;
    }
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    unint64_t v53 = v10.u32[0];
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v2 = v7;
      if (v7 >= v9) {
        unint64_t v2 = v7 % v9;
      }
    }
    else
    {
      unint64_t v2 = (v9 - 1) & v7;
    }
    uint64_t v11 = *(char ***)(*(void *)a1 + 8 * v2);
    if (!v11 || (int v12 = *v11) == 0)
    {
LABEL_21:
      long long v19 = (char *)operator new(0xE0uLL);
      v54[0] = v19;
      v54[1] = v52;
      *(void *)long long v19 = 0;
      *((void *)v19 + 1) = v8;
      *((void *)v19 + 2) = v6;
      *(_OWORD *)(v19 + 24) = 0u;
      *(_OWORD *)(v19 + 40) = 0u;
      *(_OWORD *)(v19 + 56) = xmmword_1BD330210;
      *((void *)v19 + 9) = 0;
      *((_OWORD *)v19 + 5) = xmmword_1BD330220;
      *((void *)v19 + 12) = 0;
      *(_OWORD *)(v19 + 104) = xmmword_1BD330230;
      *((void *)v19 + 15) = 0;
      *((_OWORD *)v19 + 8) = xmmword_1BD330240;
      *((void *)v19 + 18) = 0;
      *(_OWORD *)(v19 + 152) = xmmword_1BD330250;
      *((void *)v19 + 21) = 0;
      *((void *)v19 + 22) = 0x7FFFFFFFFFFFFFFFLL;
      *(_OWORD *)(v19 + 184) = 0u;
      *(_OWORD *)(v19 + 200) = 0u;
      *((void *)v19 + 27) = 0;
      char v55 = 1;
      float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v21 = *(float *)(a1 + 32);
      if (v9 && (float)(v21 * (float)v9) >= v20)
      {
LABEL_68:
        BOOL v37 = *(char ***)(*(void *)a1 + 8 * v2);
        int v12 = (char *)v54[0];
        if (v37)
        {
          *(void *)v54[0] = *v37;
        }
        else
        {
          *(void *)v54[0] = *(void *)(a1 + 16);
          *(void *)(a1 + 16) = v12;
          *(void *)(*(void *)a1 + 8 * v2) = v52;
          if (!*(void *)v12)
          {
LABEL_77:
            v54[0] = 0;
            ++*(void *)(a1 + 24);
            std::unique_ptr<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,void *>>>>::reset[abi:ne180100]((uint64_t)v54);
            goto LABEL_78;
          }
          unint64_t v38 = *(void *)(*(void *)v12 + 8);
          if ((v9 & (v9 - 1)) != 0)
          {
            if (v38 >= v9) {
              v38 %= v9;
            }
          }
          else
          {
            v38 &= v9 - 1;
          }
          BOOL v37 = (char **)(*(void *)a1 + 8 * v38);
        }
        *BOOL v37 = v12;
        goto LABEL_77;
      }
      BOOL v22 = v9 < 3 || (v9 & (v9 - 1)) != 0;
      unint64_t v23 = v22 | (2 * v9);
      unint64_t v24 = vcvtps_u32_f32(v20 / v21);
      if (v23 <= v24) {
        int8x8_t prime = (int8x8_t)v24;
      }
      else {
        int8x8_t prime = (int8x8_t)v23;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      }
      unint64_t v9 = *(void *)(a1 + 8);
      if (*(void *)&prime > v9) {
        goto LABEL_34;
      }
      if (*(void *)&prime < v9)
      {
        unint64_t v32 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
        if (v9 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
        {
          unint64_t v32 = std::__next_prime(v32);
        }
        else
        {
          uint64_t v34 = 1 << -(char)__clz(v32 - 1);
          if (v32 >= 2) {
            unint64_t v32 = v34;
          }
        }
        if (*(void *)&prime <= v32) {
          int8x8_t prime = (int8x8_t)v32;
        }
        if (*(void *)&prime >= v9)
        {
          unint64_t v9 = *(void *)(a1 + 8);
        }
        else
        {
          if (prime)
          {
LABEL_34:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            double v26 = operator new(8 * *(void *)&prime);
            double v27 = *(void **)a1;
            *(void *)a1 = v26;
            if (v27) {
              operator delete(v27);
            }
            uint64_t v28 = 0;
            *(int8x8_t *)(a1 + 8) = prime;
            do
              *(void *)(*(void *)a1 + 8 * v28++) = 0;
            while (*(void *)&prime != v28);
            double v29 = (void *)*v52;
            if (*v52)
            {
              unint64_t v30 = v29[1];
              uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
              v31.i16[0] = vaddlv_u8(v31);
              if (v31.u32[0] > 1uLL)
              {
                if (v30 >= *(void *)&prime) {
                  v30 %= *(void *)&prime;
                }
              }
              else
              {
                v30 &= *(void *)&prime - 1;
              }
              *(void *)(*(void *)a1 + 8 * v30) = v52;
              long long v35 = (void *)*v29;
              if (*v29)
              {
                do
                {
                  unint64_t v36 = v35[1];
                  if (v31.u32[0] > 1uLL)
                  {
                    if (v36 >= *(void *)&prime) {
                      v36 %= *(void *)&prime;
                    }
                  }
                  else
                  {
                    v36 &= *(void *)&prime - 1;
                  }
                  if (v36 != v30)
                  {
                    if (!*(void *)(*(void *)a1 + 8 * v36))
                    {
                      *(void *)(*(void *)a1 + 8 * v36) = v29;
                      goto LABEL_59;
                    }
                    *double v29 = *v35;
                    *long long v35 = **(void **)(*(void *)a1 + 8 * v36);
                    **(void **)(*(void *)a1 + 8 * v36) = v35;
                    long long v35 = v29;
                  }
                  unint64_t v36 = v30;
LABEL_59:
                  double v29 = v35;
                  long long v35 = (void *)*v35;
                  unint64_t v30 = v36;
                }
                while (v35);
              }
            }
            unint64_t v9 = (unint64_t)prime;
            goto LABEL_63;
          }
          double v49 = *(void **)a1;
          *(void *)a1 = 0;
          if (v49) {
            operator delete(v49);
          }
          unint64_t v9 = 0;
          *(void *)(a1 + 8) = 0;
        }
      }
LABEL_63:
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v8 >= v9) {
          unint64_t v2 = v8 % v9;
        }
        else {
          unint64_t v2 = v8;
        }
      }
      else
      {
        unint64_t v2 = (v9 - 1) & v8;
      }
      goto LABEL_68;
    }
    while (1)
    {
      unint64_t v13 = *((void *)v12 + 1);
      if (v13 == v8) {
        break;
      }
      if (v53 > 1)
      {
        if (v13 >= v9) {
          v13 %= v9;
        }
      }
      else
      {
        v13 &= v9 - 1;
      }
      if (v13 != v2) {
        goto LABEL_21;
      }
LABEL_20:
      int v12 = *(char **)v12;
      if (!v12) {
        goto LABEL_21;
      }
    }
    id v14 = *((id *)v12 + 2);
    uint64_t v15 = v6;
    id v16 = v6;
    long long v17 = v16;
    if (v14 != v16)
    {
      char v18 = [v14 isEqualToString:v16];

      long long v6 = v15;
      if (v18) {
        goto LABEL_78;
      }
      goto LABEL_20;
    }

    long long v6 = v15;
LABEL_78:
    long long v39 = *(_OWORD *)(v3 + 5);
    *(_OWORD *)(v12 + 40) = *(_OWORD *)(v3 + 7);
    *(_OWORD *)(v12 + 24) = v39;
    long long v40 = *(_OWORD *)(v3 + 9);
    long long v41 = *(_OWORD *)(v3 + 11);
    long long v42 = *(_OWORD *)(v3 + 13);
    *(_OWORD *)(v12 + 104) = *(_OWORD *)(v3 + 15);
    *(_OWORD *)(v12 + 88) = v42;
    *(_OWORD *)(v12 + 72) = v41;
    *(_OWORD *)(v12 + 56) = v40;
    long long v43 = *(_OWORD *)(v3 + 17);
    long long v44 = *(_OWORD *)(v3 + 19);
    long long v45 = *(_OWORD *)(v3 + 21);
    *(_OWORD *)(v12 + 168) = *(_OWORD *)(v3 + 23);
    *(_OWORD *)(v12 + 152) = v45;
    *(_OWORD *)(v12 + 136) = v44;
    *(_OWORD *)(v12 + 120) = v43;
    *((void *)v12 + 23) = v3[25];
    if (v12 + 16 != (char *)(v3 + 4)) {
      std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(v12 + 192, (char *)v3[26], v3[27], (uint64_t)(v3[27] - v3[26]) >> 4);
    }
    *((void *)v12 + 27) = v3[29];

LABEL_81:
    long long v46 = (void *)v3[1];
    if (v46)
    {
      do
      {
        long long v47 = v46;
        long long v46 = (void *)*v46;
      }
      while (v46);
    }
    else
    {
      do
      {
        long long v47 = (void *)v3[2];
        BOOL v48 = *v47 == (void)v3;
        double v3 = v47;
      }
      while (!v48);
    }
    double v3 = v47;
  }
  while (v47 != v50);
}

void sub_1BD183630(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,void *>>>>::reset[abi:ne180100](v3 - 104);

  std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<NSString * const {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,0>((uint64_t)v1 + 16);
    }
    operator delete(v1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<NSString * const {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,0>(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 176);
  if (v2)
  {
    *(void *)(a1 + 184) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
}

uint64_t std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::~__hash_table(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<NSString * const {__strong},HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F1726AB0;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](a1 + 1);
  return a1;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F1726AB0;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](a1 + 1);

  JUMPOUT(0x1C187B8A0);
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unint64_t v2 = operator new(0x28uLL);
  void *v2 = &unk_1F1726AB0;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1BD18390C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1726AB0;
  return std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 48))(v1) + 160;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::target_type()
{
}

void *std::__function::__value_func<HDStatisticsTimeInterval const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F1726B40;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](a1 + 1);
  return a1;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__func(void *a1)
{
  *a1 = &unk_1F1726B40;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](a1 + 1);

  JUMPOUT(0x1C187B8A0);
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  unint64_t v2 = operator new(0x28uLL);
  void *v2 = &unk_1F1726B40;
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__value_func[abi:ne180100]((uint64_t)(v2 + 1), v1);
  return v2;
}

void sub_1BD183BA4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1726B40;
  return std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__value_func[abi:ne180100]((uint64_t)(a2 + 1), a1 + 8);
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100]((void *)(a1 + 8));
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](a1 + 1);

  operator delete(a1);
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  unint64_t v2 = *(uint64_t (**)(void))(*(void *)v1 + 48);

  return v2();
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages,HDStatisticsTimeInterval>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&,std::function<HDStatisticsCombined const&<HDStatisticsSleepStages,HDStatisticsTimeInterval> ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#2}>,HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::target_type()
{
}

void *std::__function::__value_func<HDStatisticsSleepStages const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__func()
{
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F1726BD0;
  return result;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1726BD0;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addStatisticsFromFinishedBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>(HKStatistics *,HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>> const&)::{lambda(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)#1}>,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::target_type()
{
}

void *std::__function::__value_func<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const& ()(HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval> const&)>::~__value_func[abi:ne180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveAddSample(uint64_t a1, double *a2, int a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 680))
  {
    if ((a3 & 1) == 0)
    {
      objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a4, 3, @"Cannot configure statistics collection calculator engine with a sample if we cannot merge up to the sample's start date");
      return 0;
    }
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_configureForStartTime(a1);
  }
  double v8 = a2[1];
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9)
  {
    if (*(unsigned char *)(a1 + 680))
    {
      double v10 = -1.79769313e308;
    }
    else
    {
      double v10 = *(double *)(a1 + 176);
      double v12 = *(double *)(a1 + 120);
      if (v10 <= v12) {
        double v10 = -1.79769313e308;
      }
      if (v10 < v12) {
        double v10 = *(double *)(a1 + 120);
      }
    }
  }
  else
  {
    double v10 = *(double *)(a1 + 176);
    if (v10 <= *(double *)(a1 + 120)) {
      double v10 = -1.79769313e308;
    }
  }
  if (v10 <= v8)
  {
    if (v9 && a3) {
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_advanceToTime(a1, v8);
    }
    HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(a1 + 112, a2, a3);
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_notifyForCurrentBucket(a1);
    return 1;
  }
  else
  {
    unint64_t v13 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:");
    uint64_t v11 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v13, a4);
  }
  return v11;
}

void sub_1BD183FF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_advanceToTime(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 128) <= a2)
  {
    uint64_t v4 = a1 + 112;
    uint64_t v5 = a1 + 120;
    do
    {
      uint64_t v6 = *(void *)(a1 + 656);
      uint64_t v7 = *(void *)(a1 + 648);
      if (v6 == v7)
      {
        uint64_t v22 = 0;
        uint64_t v15 = *(void **)(a1 + 40);
        id v16 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:a2];
        double v8 = [v15 dateIntervalContainingDate:v16 index:&v22];

        HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_updateSourceOrder(v5);
        HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeThroughTime(v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsFromFinishedBucket(a1, v5);
        uint64_t v17 = v22;
        double v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v19 = v18;
        float v20 = [v8 endDate];
        [v20 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::resetToBucket(v4, v17, v19, v21);
      }
      else
      {
        double v8 = [*(id *)(a1 + 40) dateIntervalAtIndex:*(void *)(a1 + 112) + 1];
        HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_updateSourceOrder(v5);
        HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeThroughTime(v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsFromFinishedBucket(a1, v5);
        double v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v12 = v11;
        unint64_t v13 = [v8 endDate];
        [v13 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::advanceBucket(v4, v12, v14);
      }
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_didChangeBucket(a1, v9);
      if (v6 != v7) {
        _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_notifyForCurrentBucket(a1);
      }
    }
    while (*(double *)(a1 + 128) <= a2);
  }
}

void sub_1BD1841FC(_Unwind_Exception *exception_object)
{
}

void HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(uint64_t a1, double *a2, int a3)
{
  uint64_t v5 = a1 + 8;
  double v6 = *(double *)(a1 + 8);
  double v7 = a2[1];
  double v8 = a2[2];
  unint64_t v9 = *((void *)a2 + 3);
  int v10 = *((unsigned __int8 *)a2 + 32);
  char v11 = *((unsigned char *)a2 + 33);
  if (v6 - v7 >= 0.01)
  {
    if (v8 - v7 - (v6 - v7) < 0.01)
    {
      int v10 = 0;
      char v11 = 0;
      unint64_t v9 = 0;
      double v8 = 0.0;
      double v6 = 0.0;
    }
  }
  else
  {
    double v6 = a2[1];
  }
  double v12 = *a2;
  double v13 = *(double *)(a1 + 16);
  double v14 = v13 - v6;
  double v15 = v8 - v6 - (v13 - v6);
  if (!*(_DWORD *)(a1 + 36))
  {
    if (v15 < 0.01) {
      goto LABEL_10;
    }
    if (v14 >= 0.01) {
      goto LABEL_14;
    }
LABEL_13:
    char v18 = v11;
    int v17 = v10;
    unint64_t v16 = v9;
    double v19 = v8;
    double v13 = v6;
    goto LABEL_47;
  }
  if (v14 < 0.01) {
    goto LABEL_13;
  }
  if (v15 >= 0.01)
  {
LABEL_14:
    double v19 = v8;
    unint64_t v16 = v9;
    int v17 = v10;
    char v18 = v11;
    double v8 = *(double *)(a1 + 16);
    if (!v10) {
      goto LABEL_47;
    }
    goto LABEL_15;
  }
LABEL_10:
  unint64_t v16 = 0;
  int v17 = 0;
  char v18 = 0;
  double v13 = 0.0;
  double v19 = 0.0;
  if (!v10) {
    goto LABEL_47;
  }
LABEL_15:
  double v58 = v6;
  double v59 = v8;
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>(a1 + 352, v9, v9);
  unint64_t v20 = *(void *)(a1 + 112);
  if (v20 != *(void *)(a1 + 104) || *(uint64_t *)(a1 + 128) > 0)
  {
    double v21 = v58;
    double v22 = v59;
    if (v58 < *(double *)(a1 + 48))
    {
      double v23 = *(double *)(a1 + 8);
      if (v58 >= v23) {
        double v23 = v58;
      }
      *(double *)(a1 + 48) = v23;
    }
    if (v59 > *(double *)(a1 + 56))
    {
      double v24 = *(double *)(a1 + 16);
      if (v24 >= v59) {
        double v24 = v59;
      }
      *(double *)(a1 + 56) = v24;
    }
    if (!a3) {
      goto LABEL_29;
    }
    goto LABEL_26;
  }
  v25.f64[1] = *(float64_t *)(a1 + 16);
  double v21 = v58;
  double v22 = v59;
  v25.f64[0] = v58;
  v26.f64[0] = *(float64_t *)(a1 + 8);
  v26.f64[1] = v59;
  int8x16_t v27 = (int8x16_t)vcgtq_f64(v26, v25);
  v26.f64[0] = v58;
  *(int8x16_t *)(a1 + 48) = vbslq_s8(v27, *(int8x16_t *)(a1 + 8), (int8x16_t)v26);
  if (a3)
  {
LABEL_26:
    if (v21 < *(double *)(a1 + 16))
    {
      HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeThroughTime(v5, v21);
      double v21 = v58;
      double v22 = v59;
      unint64_t v20 = *(void *)(a1 + 112);
    }
  }
LABEL_29:
  unint64_t v28 = *(void *)(a1 + 120);
  if (v20 >= v28)
  {
    uint64_t v30 = *(void *)(a1 + 104);
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v30) >> 4);
    unint64_t v32 = v31 + 1;
    if (v31 + 1 > 0x555555555555555) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v28 - v30) >> 4);
    if (2 * v33 > v32) {
      unint64_t v32 = 2 * v33;
    }
    if (v33 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v34 = 0x555555555555555;
    }
    else {
      unint64_t v34 = v32;
    }
    if (v34)
    {
      unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v34);
      double v21 = v58;
      double v22 = v59;
    }
    else
    {
      uint64_t v35 = 0;
    }
    unint64_t v36 = v34 + 48 * v31;
    unint64_t v37 = v34 + 48 * v35;
    *(double *)unint64_t v36 = v12;
    *(double *)(v36 + 8) = v21;
    *(double *)(v36 + 16) = v22;
    *(void *)(v36 + 24) = v9;
    *(unsigned char *)(v36 + 32) = v10;
    *(unsigned char *)(v36 + 33) = v11;
    *(_WORD *)(v36 + 40) = 0;
    *(unsigned char *)(v36 + 42) = 0;
    unint64_t v29 = v36 + 48;
    long long v39 = *(char **)(a1 + 104);
    unint64_t v38 = *(char **)(a1 + 112);
    if (v38 != v39)
    {
      do
      {
        long long v40 = *((_OWORD *)v38 - 3);
        long long v41 = *((_OWORD *)v38 - 2);
        *(_OWORD *)(v36 - 21) = *(_OWORD *)(v38 - 21);
        *(_OWORD *)(v36 - 48) = v40;
        *(_OWORD *)(v36 - 32) = v41;
        v36 -= 48;
        v38 -= 48;
      }
      while (v38 != v39);
      unint64_t v38 = *(char **)(a1 + 104);
    }
    *(void *)(a1 + 104) = v36;
    *(void *)(a1 + 112) = v29;
    *(void *)(a1 + 120) = v37;
    if (v38) {
      operator delete(v38);
    }
  }
  else
  {
    *(double *)unint64_t v20 = v12;
    *(double *)(v20 + 8) = v21;
    *(double *)(v20 + 16) = v22;
    *(void *)(v20 + 24) = v9;
    *(unsigned char *)(v20 + 32) = v10;
    *(unsigned char *)(v20 + 33) = v11;
    *(_WORD *)(v20 + 40) = 0;
    unint64_t v29 = v20 + 48;
    *(unsigned char *)(v20 + 42) = 0;
  }
  *(void *)(a1 + 112) = v29;
  if (*(unsigned char *)(a1 + 33))
  {
    unint64_t v42 = HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_canonicalSourceIDForSourceID(v5, v9);
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsForSource(v5, v42);
  }
LABEL_47:
  if (v17)
  {
    unint64_t v43 = *(void *)(a1 + 544);
    unint64_t v44 = *(void *)(a1 + 552);
    if (v43 >= v44)
    {
      uint64_t v46 = *(void *)(a1 + 536);
      unint64_t v47 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v43 - v46) >> 3);
      unint64_t v48 = v47 + 1;
      if (v47 + 1 > 0x666666666666666) {
        std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v49 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v44 - v46) >> 3);
      if (2 * v49 > v48) {
        unint64_t v48 = 2 * v49;
      }
      if (v49 >= 0x333333333333333) {
        unint64_t v50 = 0x666666666666666;
      }
      else {
        unint64_t v50 = v48;
      }
      if (v50) {
        unint64_t v50 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v50);
      }
      else {
        uint64_t v51 = 0;
      }
      unint64_t v52 = v50 + 40 * v47;
      unint64_t v53 = v50 + 40 * v51;
      *(double *)unint64_t v52 = v12;
      *(double *)(v52 + 8) = v13;
      *(double *)(v52 + 16) = v19;
      *(void *)(v52 + 24) = v16;
      *(unsigned char *)(v52 + 32) = v17;
      *(unsigned char *)(v52 + 33) = v18;
      unint64_t v45 = v52 + 40;
      unint64_t v54 = *(char **)(a1 + 544);
      char v55 = *(char **)(a1 + 536);
      if (v54 != v55)
      {
        do
        {
          long long v56 = *(_OWORD *)(v54 - 40);
          long long v57 = *(_OWORD *)(v54 - 24);
          *(_WORD *)(v52 - 8) = *((_WORD *)v54 - 4);
          *(_OWORD *)(v52 - 24) = v57;
          *(_OWORD *)(v52 - 40) = v56;
          v52 -= 40;
          v54 -= 40;
        }
        while (v54 != v55);
        unint64_t v54 = *(char **)(a1 + 536);
      }
      *(void *)(a1 + 536) = v52;
      *(void *)(a1 + 544) = v45;
      *(void *)(a1 + 552) = v53;
      if (v54) {
        operator delete(v54);
      }
    }
    else
    {
      *(double *)unint64_t v43 = v12;
      *(double *)(v43 + 8) = v13;
      *(double *)(v43 + 16) = v19;
      *(void *)(v43 + 24) = v16;
      *(unsigned char *)(v43 + 32) = v17;
      unint64_t v45 = v43 + 40;
      *(unsigned char *)(v43 + 33) = v18;
    }
    *(void *)(a1 + 544) = v45;
  }
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_notifyForCurrentBucket(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 682))
  {
    *(unsigned char *)(a1 + 684) = 1;
  }
  else
  {
    *(unsigned char *)(a1 + 684) = 0;
    unint64_t v2 = (void (**)(id, void *))_Block_copy(*(const void **)(a1 + 96));
    if (v2)
    {
      uint64_t v4 = v2;
      uint64_t v3 = (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
      if (v3) {
        v4[2](v4, v3);
      }

      unint64_t v2 = v4;
    }
  }
}

void sub_1BD184750(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::advanceBucket(uint64_t a1, double a2, double a3)
{
  unint64_t v9 = 0;
  int v10 = 0;
  uint64_t v11 = 0;
  std::vector<HDRawQuantitySample>::__init_with_size[abi:ne180100]<HDRawQuantitySample*,HDRawQuantitySample*>(&v9, *(const void **)(a1 + 536), *(void *)(a1 + 544), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 544) - *(void *)(a1 + 536)) >> 3));
  HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::resetToBucket(a1, *(void *)a1 + 1, a2, a3);
  double v6 = v9;
  double v7 = v10;
  if (v9 != v10)
  {
    double v8 = v9;
    do
    {
      HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::addSample(a1, v8, 1);
      v8 += 5;
    }
    while (v8 != v7);
  }
  if (v6)
  {
    operator delete(v6);
  }
}

void sub_1BD184850(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::resetToBucket(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v8 = a1 + 40;
  objc_storeStrong((id *)(a1 + 560), *(id *)(a1 + 40));
  *(double *)(v8 - 32) = a3;
  *(double *)(v8 - 24) = a4;
  *(double *)(v8 + 24) = a3;
  *(void *)(v8 + 72) = *(void *)(v8 + 64);
  long long v9 = 0uLL;
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 120) = xmmword_1BD330210;
  *(void *)(v8 + 136) = 0;
  *(_OWORD *)(v8 + 144) = xmmword_1BD330220;
  *(void *)(v8 + 160) = 0;
  *(_OWORD *)(v8 + 168) = xmmword_1BD330230;
  *(void *)(v8 + 184) = 0;
  *(_OWORD *)(v8 + 192) = xmmword_1BD330240;
  *(void *)(v8 + 208) = 0;
  *(_OWORD *)(v8 + 216) = xmmword_1BD330250;
  *(void *)(v8 + 232) = 0;
  *(void *)(v8 + 240) = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)(v8 + 248) = 0;
  int v10 = *(void **)(v8 + 256);
  if (v10)
  {
    *(void *)(a1 + 304) = v10;
    operator delete(v10);
    long long v9 = 0uLL;
  }
  *(_OWORD *)(v8 + 256) = v9;
  *(_OWORD *)(v8 + 272) = v9;
  if (*(void *)(a1 + 344))
  {
    uint64_t v11 = *(void **)(a1 + 328);
    uint64_t v12 = *(void *)(a1 + 336);
    *(void *)(a1 + 328) = a1 + 336;
    *(void *)(v12 + 16) = 0;
    *(void *)(a1 + 336) = 0;
    *(void *)(a1 + 344) = 0;
    if (v11[1]) {
      double v13 = (void *)v11[1];
    }
    else {
      double v13 = v11;
    }
    if (v13)
    {
      double v14 = (void *)v13[2];
      if (v14)
      {
        double v15 = (void *)*v14;
        if ((void *)*v14 == v13)
        {
          void *v14 = 0;
          while (1)
          {
            int v17 = (void *)v14[1];
            if (!v17) {
              break;
            }
            do
            {
              double v14 = v17;
              int v17 = (void *)*v17;
            }
            while (v17);
          }
        }
        else
        {
          for (v14[1] = 0; v15; double v15 = (void *)v14[1])
          {
            do
            {
              double v14 = v15;
              double v15 = (void *)*v15;
            }
            while (v15);
          }
        }
        std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::destroy(v13);
        for (uint64_t i = (void *)v14[2]; i; uint64_t i = (void *)i[2])
          double v14 = i;
        double v13 = v14;
      }
    }
    std::__tree<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>>>::destroy(v13);
  }
  objc_storeStrong((id *)v8, *(id *)(a1 + 560));
  *(void *)(a1 + 544) = *(void *)(a1 + 536);
  *(void *)a1 = a2;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_didChangeBucket(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 684))
  {
    if (v3)
    {
      id v6 = v3;
      uint64_t v4 = _Block_copy(*(const void **)(a1 + 96));
      uint64_t v5 = v4;
      if (v4) {
        (*((void (**)(void *, id))v4 + 2))(v4, v6);
      }

      id v3 = v6;
    }
    *(unsigned char *)(a1 + 684) = 0;
  }
}

void sub_1BD184A70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE38_collapsedPendingInvalidationIntervalsERb_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = [a2 startDate];
  id v6 = [v4 startDate];
  uint64_t v7 = [v5 compare:v6];

  return v7;
}

void sub_1BD184AF8(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveInvalidateInterval(id *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 13);
  if (WeakRetained)
  {
    if (v5
      && (_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_currentBucketInterval((uint64_t)a1),
          (uint64_t v7 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      uint64_t v8 = [v5 endDate];
      long long v9 = [v7 startDate];
      if (objc_msgSend(v8, "hk_isAfterDate:", v9))
      {
        int v10 = [v5 startDate];
        uint64_t v11 = [v7 endDate];
        char v12 = objc_msgSend(v10, "hk_isBeforeOrEqualToDate:", v11);
      }
      else
      {
        char v12 = 0;
      }

      double v13 = _Block_copy(a1[12]);
      if ((v12 & 1) == 0) {
        operator new();
      }
    }
    else
    {
      double v13 = _Block_copy(a1[12]);
    }
    *((unsigned char *)a1 + 680) = 1;
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 3221225472;
    v27[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke;
    v27[3] = &unk_1E6308FF8;
    id v15 = v5;
    id v28 = v15;
    id v16 = v13;
    id v29 = v16;
    (*((void (**)(id *, void *))*a1 + 9))(a1, v27);
    if (v5)
    {
      int v17 = [v15 startDate];
      [v17 timeIntervalSinceReferenceDate];
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_configureForStartTime((uint64_t)a1);
    }
    else
    {
      (*((void (**)(id *))*a1 + 4))(a1);
      id v15 = (id)objc_claimAutoreleasedReturnValue();
    }
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2;
    v21[3] = &unk_1E6309060;
    double v24 = a1;
    id v5 = v15;
    char v26 = 1;
    id v22 = v5;
    float64x2_t v25 = a1;
    id v23 = WeakRetained;
    uint64_t v14 = (*((uint64_t (**)(id *, void *, uint64_t))*a1 + 14))(a1, v21, a3);
    char v18 = _Block_copy(v16);
    id v19 = a1[12];
    a1[12] = v18;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a3, 3, @"Unable to invalidate interval: no data source available.");
    uint64_t v14 = 0;
  }

  return v14;
}

void sub_1BD184F48(_Unwind_Exception *a1)
{
  MEMORY[0x1C187B8A0](v4, 0x10F1C40A18ECEBDLL);
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke(uint64_t a1, void *a2)
{
  id v10 = a2;
  if (!*(void *)(a1 + 32)) {
    goto LABEL_11;
  }
  id v3 = [v10 endDate];
  uint64_t v4 = [*(id *)(a1 + 32) startDate];
  char v5 = objc_msgSend(v3, "hk_isBeforeOrEqualToDate:", v4);

  if ((v5 & 1) == 0)
  {
    id v6 = [v10 startDate];
    uint64_t v7 = [*(id *)(a1 + 32) endDate];
    char v8 = objc_msgSend(v6, "hk_isAfterOrEqualToDate:", v7);

    if ((v8 & 1) == 0)
    {
LABEL_11:
      uint64_t v9 = *(void *)(a1 + 40);
      if (v9) {
        (*(void (**)(uint64_t, id))(v9 + 16))(v9, v10);
      }
    }
  }
}

void sub_1BD18512C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  char v5 = [*(id *)(a1 + 32) startDate];
  [v5 timeIntervalSinceReferenceDate];
  uint64_t v7 = v6;

  char v8 = [*(id *)(a1 + 32) endDate];
  [v8 timeIntervalSinceReferenceDate];
  uint64_t v10 = v9;

  uint64_t v11 = *(void **)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(v4 + 8));
  uint64_t v13 = *(void *)(a1 + 32);
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3;
  v30[3] = &__block_descriptor_57_e24_B52__0d8d16d24q32B40__44l;
  char v32 = *(unsigned char *)(a1 + 64);
  v30[4] = v7;
  v30[5] = v10;
  uint64_t v31 = *(void *)(a1 + 56);
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4;
  void v29[3] = &__block_descriptor_40_e8_v16__0d8l;
  v29[4] = v31;
  uint64_t v14 = [v11 collectionCalculator:WeakRetained queryForInterval:v13 error:a2 sampleHandler:v30 mergeHandler:v29];

  if (v14)
  {
    uint64_t v15 = *(void *)(a1 + 56);
    if (v15 != v4)
    {
      id v16 = [*(id *)(a1 + 32) endDate];
      [v16 timeIntervalSinceReferenceDate];
      if (*(void *)(v15 + 40))
      {
        double v18 = v17;
        while (*(double *)(v15 + 120) < v18)
        {
          id v19 = [*(id *)(v15 + 40) dateIntervalAtIndex:*(void *)(v15 + 112) + 1];
          HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_updateSourceOrder(v15 + 120);
          HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeThroughTime(v15 + 120, *(double *)(v15 + 128));
          unint64_t v20 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_statisticsFromFinishedBucket(v15, v15 + 120);
          double v21 = [v19 startDate];
          [v21 timeIntervalSinceReferenceDate];
          double v23 = v22;
          double v24 = [v19 endDate];
          [v24 timeIntervalSinceReferenceDate];
          HDStatisticsCollectionEngine<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::advanceBucket(v15 + 112, v23, v25);

          if (v20)
          {
            char v26 = _Block_copy(*(const void **)(v15 + 96));
            int8x16_t v27 = v26;
            if (v26) {
              (*((void (**)(void *, void *))v26 + 2))(v26, v20);
            }
          }
          _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_didChangeBucket(v15, 0);
        }
      }
    }
  }
  return v14;
}

void sub_1BD1853D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  double v7 = *(double *)(a1 + 32) - a6;
  if (v7 >= 0.01)
  {
    if (a7 - a6 - v7 >= 0.01)
    {
      int v8 = 1;
      a6 = *(double *)(a1 + 32);
    }
    else
    {
      a2 = 0;
      int v8 = 0;
      a6 = 0.0;
      a7 = 0.0;
    }
  }
  else
  {
    int v8 = 1;
  }
  double v11 = a5;
  double v12 = a6;
  double v13 = a7;
  uint64_t v14 = a2;
  char v15 = v8;
  char v16 = 0;
  if (*(unsigned char *)(a1 + 56))
  {
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveAddSample(*(void *)(a1 + 48), &v11, a3, a4);
    }
  }
  else
  {
    double v10 = *(double *)(a1 + 40) - a6;
    if (v10 >= 0.01)
    {
      if (a7 - a6 - v10 >= 0.01) {
        a7 = *(double *)(a1 + 40);
      }
    }
    else
    {
      int v8 = 0;
    }
    double v12 = a6;
    double v13 = a7;
    char v15 = v8;
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveAddSample(*(void *)(a1 + 48), &v11, a3, a4);
    }
  }
  return 1;
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4(uint64_t a1, double a2)
{
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeToTime(uint64_t a1, double a2)
{
  if (*(unsigned char *)(a1 + 680)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_configureForStartTime(a1);
  }
  if (*(void *)(a1 + 40)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_advanceToTime(a1, a2);
  }
  if (*(double *)(a1 + 128) > a2)
  {
    HDStatisticsBucket<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_mergeThroughTime(a1 + 120, a2);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(double *)(a2 - 32) < *(double *)(v10 + 8))
                {
                  uint64_t v129 = *(void *)(v10 + 32);
                  long long v113 = *(_OWORD *)v10;
                  long long v121 = *(_OWORD *)(v10 + 16);
                  long long v52 = *(_OWORD *)(a2 - 40);
                  long long v53 = *(_OWORD *)(a2 - 24);
                  *(_WORD *)(v10 + 32) = *(_WORD *)(a2 - 8);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 16) = v53;
                  *(_WORD *)(a2 - 8) = v129;
                  *(_OWORD *)(a2 - 24) = v121;
                  *(_OWORD *)(a2 - 40) = v113;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v10, (double *)(v10 + 40), (double *)(a2 - 40));
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, a2 - 40);
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, v10 + 120, a2 - 40);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 959)
          {
            unint64_t v54 = (void *)(v10 + 40);
            BOOL v56 = v10 == a2 || v54 == (void *)a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  double v59 = v54;
                  double v60 = *(double *)(v58 + 48);
                  if (v60 < *(double *)(v58 + 8))
                  {
                    uint64_t v61 = *v54;
                    long long v114 = *(_OWORD *)(v58 + 56);
                    uint64_t v122 = *(void *)(v58 + 72);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      uint64_t v63 = v10 + v62;
                      long long v64 = *(_OWORD *)(v10 + v62 + 16);
                      *(_OWORD *)(v63 + 40) = *(_OWORD *)(v10 + v62);
                      *(_OWORD *)(v63 + 56) = v64;
                      *(_WORD *)(v63 + 72) = *(_WORD *)(v10 + v62 + 32);
                      if (!v62) {
                        break;
                      }
                      v62 -= 40;
                      if (v60 >= *(double *)(v63 - 32))
                      {
                        uint64_t v65 = v10 + v62 + 40;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_81:
                    *(void *)uint64_t v65 = v61;
                    *(double *)(v65 + 8) = v60;
                    *(_OWORD *)(v65 + 16) = v114;
                    *(_WORD *)(v65 + 32) = v122;
                  }
                  unint64_t v54 = v59 + 5;
                  v57 += 40;
                  unint64_t v58 = (unint64_t)v59;
                }
                while (v59 + 5 != (void *)a2);
              }
            }
            else if (!v56)
            {
              do
              {
                uint64_t v98 = v54;
                double v99 = *(double *)(a1 + 48);
                if (v99 < *(double *)(a1 + 8))
                {
                  uint64_t v100 = *v54;
                  long long v117 = *(_OWORD *)(a1 + 56);
                  uint64_t v125 = *(void *)(a1 + 72);
                  long long v101 = v54;
                  do
                  {
                    long long v102 = *(_OWORD *)(v101 - 3);
                    *(_OWORD *)long long v101 = *(_OWORD *)(v101 - 5);
                    *((_OWORD *)v101 + 1) = v102;
                    *((_WORD *)v101 + 16) = *((_WORD *)v101 - 4);
                    double v103 = *((double *)v101 - 9);
                    v101 -= 5;
                  }
                  while (v99 < v103);
                  void *v101 = v100;
                  *((double *)v101 + 1) = v99;
                  *((_WORD *)v101 + 16) = v125;
                  *((_OWORD *)v101 + 1) = v117;
                }
                v54 += 5;
                a1 = (unint64_t)v98;
              }
              while (v98 + 5 != (void *)a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 40 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)(v10 + 40 * v69 + 8) < *(double *)(v70 + 48))
                  {
                    v70 += 40;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  double v71 = *(double *)(v10 + 40 * v68 + 8);
                  if (*(double *)(v70 + 8) >= v71)
                  {
                    unint64_t v72 = v10 + 40 * v68;
                    uint64_t v73 = *(void *)v72;
                    uint64_t v123 = *(void *)(v72 + 32);
                    long long v115 = *(_OWORD *)(v72 + 16);
                    do
                    {
                      unint64_t v74 = v72;
                      unint64_t v72 = v70;
                      long long v75 = *(_OWORD *)v70;
                      long long v76 = *(_OWORD *)(v70 + 16);
                      *(_WORD *)(v74 + 32) = *(_WORD *)(v70 + 32);
                      *(_OWORD *)unint64_t v74 = v75;
                      *(_OWORD *)(v74 + 16) = v76;
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v77 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 40 * v77;
                      uint64_t v78 = 2 * v69 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v10 + 40 * v77 + 8) < *(double *)(v70 + 48))
                      {
                        v70 += 40;
                        uint64_t v77 = v78;
                      }
                      uint64_t v69 = v77;
                    }
                    while (*(double *)(v70 + 8) >= v71);
                    *(void *)unint64_t v72 = v73;
                    *(double *)(v72 + 8) = v71;
                    *(_OWORD *)(v72 + 16) = v115;
                    *(_WORD *)(v72 + 32) = v123;
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              int64_t v79 = v11 / 0x28uLL;
              do
              {
                uint64_t v80 = 0;
                uint64_t v130 = *(void *)(v10 + 32);
                long long v116 = *(_OWORD *)v10;
                long long v124 = *(_OWORD *)(v10 + 16);
                unint64_t v81 = v10;
                do
                {
                  unint64_t v82 = v81;
                  uint64_t v83 = v80 + 1;
                  v81 += 40 * (v80 + 1);
                  uint64_t v84 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  int64_t v85 = v84 + 2;
                  if (v85 < v79 && *(double *)(v82 + 40 * v83 + 8) < *(double *)(v81 + 48))
                  {
                    v81 += 40;
                    uint64_t v80 = v85;
                  }
                  long long v86 = *(_OWORD *)v81;
                  long long v87 = *(_OWORD *)(v81 + 16);
                  *(_WORD *)(v82 + 32) = *(_WORD *)(v81 + 32);
                  *(_OWORD *)unint64_t v82 = v86;
                  *(_OWORD *)(v82 + 16) = v87;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 40;
                if (v81 == a2)
                {
                  *(_WORD *)(v81 + 32) = v130;
                  *(_OWORD *)unint64_t v81 = v116;
                  *(_OWORD *)(v81 + 16) = v124;
                }
                else
                {
                  long long v88 = *(_OWORD *)a2;
                  long long v89 = *(_OWORD *)(a2 + 16);
                  *(_WORD *)(v81 + 32) = *(_WORD *)(a2 + 32);
                  *(_OWORD *)unint64_t v81 = v88;
                  *(_OWORD *)(v81 + 16) = v89;
                  *(_WORD *)(a2 + 32) = v130;
                  *(_OWORD *)a2 = v116;
                  *(_OWORD *)(a2 + 16) = v124;
                  uint64_t v90 = v81 - v10 + 40;
                  if (v90 >= 41)
                  {
                    unint64_t v91 = (v90 / 0x28uLL - 2) >> 1;
                    double v92 = *(double *)(v81 + 8);
                    if (*(double *)(v10 + 40 * v91 + 8) < v92)
                    {
                      uint64_t v93 = *(void *)v81;
                      uint64_t v109 = *(void *)(v81 + 32);
                      long long v106 = *(_OWORD *)(v81 + 16);
                      do
                      {
                        unint64_t v94 = v81;
                        unint64_t v81 = v10 + 40 * v91;
                        long long v95 = *(_OWORD *)v81;
                        long long v96 = *(_OWORD *)(v81 + 16);
                        *(_WORD *)(v94 + 32) = *(_WORD *)(v81 + 32);
                        *(_OWORD *)unint64_t v94 = v95;
                        *(_OWORD *)(v94 + 16) = v96;
                        if (!v91) {
                          break;
                        }
                        unint64_t v91 = (v91 - 1) >> 1;
                      }
                      while (*(double *)(v10 + 40 * v91 + 8) < v92);
                      *(void *)unint64_t v81 = v93;
                      *(double *)(v81 + 8) = v92;
                      *(_WORD *)(v81 + 32) = v109;
                      *(_OWORD *)(v81 + 16) = v106;
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 40 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x1401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40 * (v12 >> 1)), (double *)(a2 - 40));
            uint64_t v15 = 5 * v13;
            char v16 = (double *)(a1 + 40 * v13 - 40);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40), v16, (double *)(a2 - 80));
            double v17 = (double *)(a1 + 40 + 8 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 80), v17, (double *)(a2 - 120));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v16, (double *)v14, v17);
            uint64_t v126 = *(void *)(a1 + 32);
            long long v110 = *(_OWORD *)a1;
            long long v118 = *(_OWORD *)(a1 + 16);
            long long v18 = *(_OWORD *)v14;
            long long v19 = *(_OWORD *)(v14 + 16);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v14 + 32);
            *(_OWORD *)a1 = v18;
            *(_OWORD *)(a1 + 16) = v19;
            *(_WORD *)(v14 + 32) = v126;
            *(_OWORD *)unint64_t v14 = v110;
            *(_OWORD *)(v14 + 16) = v118;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40 * (v12 >> 1)), (double *)a1, (double *)(a2 - 40));
          }
          --a3;
          if (a4) {
            break;
          }
          double v20 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 32) < v20) {
            goto LABEL_12;
          }
          uint64_t v38 = *(void *)a1;
          long long v105 = *(_OWORD *)(a1 + 16);
          uint64_t v108 = *(void *)(a1 + 32);
          if (v20 >= *(double *)(a2 - 32))
          {
            unint64_t v41 = a1 + 40;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= a2) {
                break;
              }
              double v42 = *(double *)(v41 + 8);
              v41 += 40;
            }
            while (v20 >= v42);
          }
          else
          {
            unint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 40;
              double v40 = *(double *)(v39 + 48);
              v39 += 40;
            }
            while (v20 >= v40);
          }
          unint64_t v43 = a2;
          if (v10 < a2)
          {
            unint64_t v44 = a2;
            do
            {
              unint64_t v43 = v44 - 40;
              double v45 = *(double *)(v44 - 32);
              v44 -= 40;
            }
            while (v20 < v45);
          }
          while (v10 < v43)
          {
            uint64_t v128 = *(void *)(v10 + 32);
            long long v112 = *(_OWORD *)v10;
            long long v120 = *(_OWORD *)(v10 + 16);
            long long v46 = *(_OWORD *)v43;
            long long v47 = *(_OWORD *)(v43 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v43 + 32);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(_WORD *)(v43 + 32) = v128;
            *(_OWORD *)unint64_t v43 = v112;
            *(_OWORD *)(v43 + 16) = v120;
            do
            {
              double v48 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v20 >= v48);
            do
            {
              double v49 = *(double *)(v43 - 32);
              v43 -= 40;
            }
            while (v20 < v49);
          }
          BOOL v4 = v10 - 40 >= a1;
          BOOL v5 = v10 - 40 == a1;
          if (v10 - 40 != a1)
          {
            long long v50 = *(_OWORD *)(v10 - 40);
            long long v51 = *(_OWORD *)(v10 - 24);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 16) = v51;
          }
          a4 = 0;
          *(void *)(v10 - 40) = v38;
          *(double *)(v10 - 32) = v20;
          *(_WORD *)(v10 - 8) = v108;
          *(_OWORD *)(v10 - 24) = v105;
        }
        double v20 = *(double *)(a1 + 8);
LABEL_12:
        uint64_t v21 = 0;
        uint64_t v22 = *(void *)a1;
        long long v104 = *(_OWORD *)(a1 + 16);
        uint64_t v107 = *(void *)(a1 + 32);
        do
        {
          double v23 = *(double *)(a1 + v21 + 48);
          v21 += 40;
        }
        while (v23 < v20);
        unint64_t v24 = a1 + v21;
        unint64_t v25 = a2;
        if (v21 == 40)
        {
          unint64_t v28 = a2;
          while (v24 < v28)
          {
            unint64_t v26 = v28 - 40;
            double v29 = *(double *)(v28 - 32);
            v28 -= 40;
            if (v29 < v20) {
              goto LABEL_22;
            }
          }
          unint64_t v26 = v28;
        }
        else
        {
          do
          {
            unint64_t v26 = v25 - 40;
            double v27 = *(double *)(v25 - 32);
            v25 -= 40;
          }
          while (v27 >= v20);
        }
LABEL_22:
        unint64_t v10 = v24;
        if (v24 < v26)
        {
          unint64_t v30 = v26;
          do
          {
            uint64_t v127 = *(void *)(v10 + 32);
            long long v111 = *(_OWORD *)v10;
            long long v119 = *(_OWORD *)(v10 + 16);
            long long v31 = *(_OWORD *)v30;
            long long v32 = *(_OWORD *)(v30 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v30 + 32);
            *(_OWORD *)unint64_t v10 = v31;
            *(_OWORD *)(v10 + 16) = v32;
            *(_WORD *)(v30 + 32) = v127;
            *(_OWORD *)unint64_t v30 = v111;
            *(_OWORD *)(v30 + 16) = v119;
            do
            {
              double v33 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v33 < v20);
            do
            {
              double v34 = *(double *)(v30 - 32);
              v30 -= 40;
            }
            while (v34 >= v20);
          }
          while (v10 < v30);
        }
        if (v10 - 40 != a1)
        {
          long long v35 = *(_OWORD *)(v10 - 40);
          long long v36 = *(_OWORD *)(v10 - 24);
          *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
        }
        *(void *)(v10 - 40) = v22;
        *(double *)(v10 - 32) = v20;
        *(_WORD *)(v10 - 8) = v107;
        *(_OWORD *)(v10 - 24) = v104;
        if (v24 >= v26) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(a1, v10 - 40, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, v10 - 40);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 40;
    if (!v37) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 32) < *(double *)(a1 + 8))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        long long v7 = *(_OWORD *)a1;
        long long v8 = *(_OWORD *)(a1 + 16);
        __int16 v9 = *(_WORD *)(a2 - 8);
        long long v10 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
        *(_OWORD *)(a1 + 16) = v10;
        *(_WORD *)(a1 + 32) = v9;
        *(_OWORD *)(a2 - 24) = v8;
        *(_OWORD *)(a2 - 40) = v7;
        *(_WORD *)(a2 - 8) = v6;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a2 - 40));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a1 + 120, a2 - 40);
      return 1;
    default:
      uint64_t v11 = a1 + 80;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a1 + 80));
      uint64_t v12 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (1)
  {
    double v15 = *(double *)(v12 + 8);
    if (v15 < *(double *)(v11 + 8))
    {
      uint64_t v16 = *(void *)v12;
      long long v21 = *(_OWORD *)(v12 + 16);
      uint64_t v22 = *(void *)(v12 + 32);
      uint64_t v17 = v13;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        long long v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(_WORD *)(v18 + 152) = *(_WORD *)(a1 + v17 + 112);
        if (v17 == -80) {
          break;
        }
        v17 -= 40;
        if (v15 >= *(double *)(v18 + 48))
        {
          uint64_t v20 = a1 + v17 + 120;
          goto LABEL_12;
        }
      }
      uint64_t v20 = a1;
LABEL_12:
      *(void *)uint64_t v20 = v16;
      *(double *)(v20 + 8) = v15;
      *(_OWORD *)(v20 + 16) = v21;
      *(_WORD *)(v20 + 32) = v22;
      if (++v14 == 8) {
        return v12 + 40 == a2;
      }
    }
    uint64_t v11 = v12;
    v13 += 40;
    v12 += 40;
    if (v12 == a2) {
      return 1;
    }
  }
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke(void *a1, uint64_t a2)
{
  id v3 = (void *)a1[5];
  uint64_t v4 = a1[6];
  BOOL v5 = (void *)a1[4];
  uint64_t v6 = [v5 dateInterval];
  void v9[4] = v4;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2;
  v10[3] = &__block_descriptor_40_e24_B52__0d8d16d24q32B40__44l;
  v10[4] = v4;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3;
  v9[3] = &__block_descriptor_40_e8_v16__0d8l;
  uint64_t v7 = [v3 collectionCalculator:v5 queryForInterval:v6 error:a2 sampleHandler:v10 mergeHandler:v9];

  return v7;
}

void sub_1BD18615C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  uint64_t v10 = *(void *)(a1 + 32);
  v14[0] = a5;
  v14[1] = a6;
  v14[2] = a7;
  *(void *)&v14[3] = a2;
  char v15 = 1;
  uint64_t v11 = [MEMORY[0x1E4F1C9C8] distantFuture];
  [v11 timeIntervalSinceReferenceDate];
  BOOL v16 = v12 <= a7;

  return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsCombined<HDStatisticsSleepStages,HDStatisticsTimeInterval>>::_primitiveAddSample(v10, v14, a3, a4);
}

void sub_1BD186200(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsCombinedI23HDStatisticsSleepStages24HDStatisticsTimeIntervalEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, double a2)
{
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_HDConcreteStatisticsCollectionCalculatorImplementation(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  char v6 = a3;
  uint64_t v8 = _HDStatisticsCollectionCalculatorImplementation::_HDStatisticsCollectionCalculatorImplementation(a1, a2, a3, a4, a5, a6);
  *(void *)uint64_t v8 = &unk_1F1726C80;
  double v9 = 900.0;
  if ((v6 & 0x10) == 0) {
    double v9 = 0.0;
  }
  *(double *)(v8 + 56) = v9;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(void *)(v8 + 104) = 0;
  *(void *)(v8 + 112) = 0;
  *(void *)(v8 + 96) = 0;
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::HDStatisticsBucket(v8 + 120, 0, -1.79769313e308, 1.79769313e308);
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_WORD *)(a1 + 688) = 1;
  *(unsigned char *)(a1 + 690) = 0;
  *(unsigned char *)(a1 + 692) = 0;
  *(void *)(a1 + 696) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(void *)(a1 + 736) = 0;
  return a1;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::~_HDConcreteStatisticsCollectionCalculatorImplementation(uint64_t a1)
{
  _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::~_HDConcreteStatisticsCollectionCalculatorImplementation(a1);

  JUMPOUT(0x1C187B8A0);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)a1 = &unk_1F1726C80;
  unint64_t v2 = *(void **)(a1 + 720);
  if (v2)
  {
    *(void *)(a1 + 728) = v2;
    operator delete(v2);
  }

  id v3 = *(void **)(a1 + 656);
  if (v3)
  {
    *(void *)(a1 + 664) = v3;
    operator delete(v3);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket(a1 + 120);
  objc_destroyWeak((id *)(a1 + 104));

  uint64_t v4 = *(void **)(a1 + 72);
  if (v4)
  {
    *(void *)(a1 + 80) = v4;
    operator delete(v4);
  }

  _HDStatisticsCollectionCalculatorImplementation::~_HDStatisticsCollectionCalculatorImplementation((_HDStatisticsCollectionCalculatorImplementation *)a1);
}

double _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::mergeGranularity(uint64_t a1)
{
  return *(double *)(a1 + 56);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::setMergeGranularity(uint64_t result, double a2)
{
  if (*(double *)(result + 56) != a2)
  {
    *(double *)(result + 56) = a2;
    *(unsigned char *)(result + 688) = 1;
  }
  return result;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::dateInterval(uint64_t a1)
{
  return *(id *)(a1 + 64);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::setDateInterval(uint64_t a1, void *a2)
{
  id v6 = a2;
  uint64_t v3 = [v6 copy];
  uint64_t v4 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = v3;

  BOOL v5 = [v6 startDate];
  [v5 timeIntervalSinceReferenceDate];
  _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_configureForStartTime(a1);
}

void sub_1BD1863A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::configureMergeAnchor(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!*(void *)(a1 + 40))
  {
    id v5 = v3;
    [v3 timeIntervalSinceReferenceDate];
    *(void *)(a1 + 696) = v4;
    id v3 = v5;
  }
}

void sub_1BD18641C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::setStatisticsConfiguration(id *a1, void *a2)
{
  objc_storeStrong(a1 + 88, a2);
  id v7 = a2;
  id v4 = a1[88];
  id v5 = a1[85];
  a1[85] = v4;
  id v6 = v4;

  objc_storeStrong(a1 + 19, a1[85]);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::setIntervalMask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = (char *)(a1 + 72);
  if (v6 != (char *)a2) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(v6, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  }
  if (*(void *)(a1 + 40)) {
    return 1;
  }
  BOOL v7 = *(void *)(a1 + 224) == *(void *)(a1 + 216) && *(uint64_t *)(a1 + 248) < 1
    || HKIntervalMask<double>::firstDifference(*(void *)(a1 + 184), *(void *)(a1 + 192), *(void *)a2, *(void *)(a2 + 8)) >= *(double *)(a1 + 176);
  if (a1 + 184 != a2) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((char *)(a1 + 184), *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  }
  if (v7) {
    return 1;
  }
  double v9 = *(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 128);

  return v9(a1, 0, a3);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::setStatisticsHandler(uint64_t a1, void *a2)
{
  id v5 = a2;
  uint64_t v3 = [v5 copy];
  id v4 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = v3;
}

void sub_1BD186604(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::dataSource(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 104));

  return WeakRetained;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::setDataSource(uint64_t a1, void *a2)
{
  return objc_storeWeak((id *)(a1 + 104), a2);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::currentStatistics(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 688))
  {
    uint64_t v1 = 0;
  }
  else
  {
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::HDStatisticsBucket((uint64_t)v4, a1 + 120);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_updateSourceOrder((uint64_t)v4);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeThroughTime((uint64_t)v4, v4[1]);
    uint64_t v1 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsFromFinishedBucket(a1, v4);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket((uint64_t)v4);
  }

  return v1;
}

void sub_1BD1866D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::addSample(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = *(id *)(a1 + 64);
  BOOL v7 = v6;
  if (!v6) {
    goto LABEL_4;
  }
  uint64_t v8 = [v6 startDate];
  [v8 timeIntervalSinceReferenceDate];
  if (v9 > *(double *)(a2 + 16))
  {

    goto LABEL_10;
  }
  uint64_t v10 = [v7 endDate];
  [v10 timeIntervalSinceReferenceDate];
  double v12 = v11;
  double v13 = *(double *)(a2 + 8);

  if (v12 >= v13)
  {
LABEL_4:
    if (!*(unsigned char *)(a1 + 690)) {
      goto LABEL_21;
    }
    if (!*(unsigned char *)(a1 + 689))
    {
      if (*(void *)(a1 + 40))
      {
        if (*(unsigned char *)(a1 + 688))
        {
          double v14 = -1.79769313e308;
        }
        else
        {
          double v16 = *(double *)(a1 + 176);
          double v14 = *(double *)(a1 + 120);
          if (v16 <= v14) {
            double v16 = -1.79769313e308;
          }
          if (v16 >= v14) {
            double v14 = v16;
          }
        }
      }
      else
      {
        double v14 = -1.79769313e308;
        if (*(double *)(a1 + 176) > *(double *)(a1 + 120)) {
          double v14 = *(double *)(a1 + 176);
        }
      }
      if (v14 > *(double *)(a2 + 8))
      {
        uint64_t v17 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:");
        uint64_t v15 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v17, a3);

        goto LABEL_22;
      }
      if (*(unsigned char *)(a1 + 691))
      {
LABEL_21:
        uint64_t v15 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveAddSample(a1, a2, 1, a3);
        goto LABEL_22;
      }
      unint64_t v19 = *(void *)(a1 + 728);
      unint64_t v20 = *(void *)(a1 + 736);
      if (v19 >= v20)
      {
        uint64_t v24 = *(void *)(a1 + 720);
        unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v19 - v24) >> 3);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0x666666666666666) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - v24) >> 3);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x333333333333333) {
          unint64_t v28 = 0x666666666666666;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28) {
          unint64_t v28 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v28);
        }
        else {
          uint64_t v29 = 0;
        }
        unint64_t v30 = v28 + 40 * v25;
        unint64_t v31 = v28 + 40 * v29;
        long long v32 = *(_OWORD *)a2;
        long long v33 = *(_OWORD *)(a2 + 16);
        *(void *)(v30 + 32) = *(void *)(a2 + 32);
        *(_OWORD *)unint64_t v30 = v32;
        *(_OWORD *)(v30 + 16) = v33;
        unint64_t v23 = v30 + 40;
        double v34 = *(char **)(a1 + 728);
        long long v35 = *(char **)(a1 + 720);
        if (v34 != v35)
        {
          do
          {
            long long v36 = *(_OWORD *)(v34 - 40);
            long long v37 = *(_OWORD *)(v34 - 24);
            *(_WORD *)(v30 - 8) = *((_WORD *)v34 - 4);
            *(_OWORD *)(v30 - 24) = v37;
            *(_OWORD *)(v30 - 40) = v36;
            v30 -= 40;
            v34 -= 40;
          }
          while (v34 != v35);
          double v34 = *(char **)(a1 + 720);
        }
        *(void *)(a1 + 720) = v30;
        *(void *)(a1 + 728) = v23;
        *(void *)(a1 + 736) = v31;
        if (v34) {
          operator delete(v34);
        }
      }
      else
      {
        long long v21 = *(_OWORD *)a2;
        long long v22 = *(_OWORD *)(a2 + 16);
        *(void *)(v19 + 32) = *(void *)(a2 + 32);
        *(_OWORD *)unint64_t v19 = v21;
        *(_OWORD *)(v19 + 16) = v22;
        unint64_t v23 = v19 + 40;
      }
      *(void *)(a1 + 728) = v23;
    }
  }
LABEL_10:
  uint64_t v15 = 1;
LABEL_22:

  return v15;
}

void sub_1BD186990(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::performAddSampleTransaction(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = v5;
  if (*(unsigned char *)(a1 + 690))
  {
    uint64_t v7 = (*((uint64_t (**)(id, uint64_t))v5 + 2))(v5, a3);
    goto LABEL_83;
  }
  *(_WORD *)(a1 + 690) = 1;
  uint64_t v67 = a3;
  if (!(*((unsigned int (**)(id, uint64_t))v5 + 2))(v5, a3))
  {
    uint64_t v7 = 0;
    goto LABEL_82;
  }
  uint64_t v65 = v6;
  if (*(unsigned char *)(a1 + 689)) {
    goto LABEL_5;
  }
  double v9 = *(void **)(a1 + 712);
  if (!v9)
  {
    id v68 = 0;
    goto LABEL_28;
  }
  if (!*(void *)(a1 + 40))
  {
LABEL_5:
    int v8 = 0;
    id v68 = 0;
    goto LABEL_29;
  }
  [v9 sortUsingComparator:&__block_literal_global_1124];
  id v68 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  id v10 = *(id *)(a1 + 712);
  uint64_t v11 = [v10 countByEnumeratingWithState:&v69 objects:v73 count:16];
  if (!v11)
  {

    id v12 = 0;
    goto LABEL_27;
  }
  id v12 = 0;
  uint64_t v13 = *(void *)v70;
  do
  {
    for (uint64_t i = 0; i != v11; ++i)
    {
      if (*(void *)v70 != v13) {
        objc_enumerationMutation(v10);
      }
      id v15 = *(id *)(*((void *)&v69 + 1) + 8 * i);
      double v16 = v15;
      if (v12)
      {
        uint64_t v17 = [v15 startDate];
        uint64_t v18 = [v12 endDate];
        int v19 = objc_msgSend(v17, "hk_isBeforeOrEqualToDate:", v18);

        if (v19)
        {
          unint64_t v20 = [v16 endDate];
          long long v21 = [v12 endDate];
          int v22 = objc_msgSend(v20, "hk_isAfterDate:", v21);

          if (!v22) {
            goto LABEL_21;
          }
          id v23 = objc_alloc(MEMORY[0x1E4F28C18]);
          uint64_t v24 = [v12 startDate];
          unint64_t v25 = [v16 endDate];
          id v26 = (id)[v23 initWithStartDate:v24 endDate:v25];
        }
        else
        {
          [v68 addObject:v12];
          id v26 = v16;
        }
        id v12 = v26;
      }
      else
      {
        id v12 = v15;
      }
LABEL_21:
    }
    uint64_t v11 = [v10 countByEnumeratingWithState:&v69 objects:v73 count:16];
  }
  while (v11);

  if (v12) {
    [v68 addObject:v12];
  }
LABEL_27:

LABEL_28:
  int v8 = 1;
LABEL_29:
  unint64_t v27 = *(void **)(a1 + 712);
  *(void *)(a1 + 712) = 0;

  *(unsigned char *)(a1 + 689) = 0;
  if (!v8)
  {
    unint64_t v38 = *(void *)(a1 + 720);
    *(void *)(a1 + 736) = 0;
    *(void *)(a1 + 728) = 0;
    *(void *)(a1 + 720) = 0;
    unint64_t v39 = v38;
    goto LABEL_47;
  }
  unint64_t v28 = [v68 lastObject];
  if (v28)
  {
    uint64_t v29 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_currentBucketInterval(a1);
    unint64_t v30 = [v29 endDate];
    unint64_t v31 = [v28 endDate];
    int v32 = objc_msgSend(v30, "hk_isBeforeOrEqualToDate:", v31);

    if (v32)
    {
      long long v33 = [v28 endDate];
      [v33 timeIntervalSinceReferenceDate];
      double v35 = v34;

      uint64_t v36 = *(void *)(a1 + 720);
      long long v37 = *(long long **)(a1 + 728);
      while ((long long *)v36 != v37)
      {
        if (*(double *)(v36 + 8) < v35)
        {
          if ((long long *)v36 != v37)
          {
            double v40 = (long long *)(v36 + 40);
            if ((long long *)(v36 + 40) != v37)
            {
              do
              {
                if (*((double *)v40 + 1) >= v35)
                {
                  long long v41 = *v40;
                  long long v42 = v40[1];
                  *(_WORD *)(v36 + 32) = *((_WORD *)v40 + 16);
                  *(_OWORD *)uint64_t v36 = v41;
                  *(_OWORD *)(v36 + 16) = v42;
                  v36 += 40;
                }
                double v40 = (long long *)((char *)v40 + 40);
              }
              while (v40 != v37);
              long long v37 = *(long long **)(a1 + 728);
            }
          }
          if ((long long *)v36 != v37) {
            *(void *)(a1 + 728) = v36;
          }
          break;
        }
        v36 += 40;
      }
    }
  }
  unint64_t v38 = *(void *)(a1 + 720);
  unint64_t v39 = *(void *)(a1 + 728);
  *(void *)(a1 + 736) = 0;
  *(void *)(a1 + 720) = 0;
  *(void *)(a1 + 728) = 0;
  if (![v68 count]) {
    goto LABEL_60;
  }
LABEL_47:
  id v43 = v68;
  long long __p = (void *)v38;
  if (v43)
  {
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    id v44 = v43;
    uint64_t v45 = [v44 countByEnumeratingWithState:&v69 objects:v73 count:16];
    if (v45)
    {
      uint64_t v46 = *(void *)v70;
      while (2)
      {
        for (uint64_t j = 0; j != v45; ++j)
        {
          if (*(void *)v70 != v46) {
            objc_enumerationMutation(v44);
          }
          id v48 = *(id *)(*((void *)&v69 + 1) + 8 * j);
          int v49 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveInvalidateInterval((id *)a1, v48, v67);

          if (!v49)
          {

            goto LABEL_70;
          }
        }
        uint64_t v45 = [v44 countByEnumeratingWithState:&v69 objects:v73 count:16];
        if (v45) {
          continue;
        }
        break;
      }
    }

LABEL_59:
    unint64_t v38 = (unint64_t)__p;
LABEL_60:
    unint64_t v51 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v39 - v38) >> 3));
    if (v39 == v38) {
      uint64_t v52 = 0;
    }
    else {
      uint64_t v52 = v51;
    }
    int v53 = 1;
    std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(v38, v39, v52, 1);
    long long __p = (void *)v38;
    if (v39 != v38)
    {
      uint64_t v54 = v38;
      uint64_t v50 = v67;
      do
      {
        int v55 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveAddSample(a1, v54, 1, v50);
        int v53 = v55;
        v54 += 40;
        if (v54 == v39) {
          char v56 = 0;
        }
        else {
          char v56 = v55;
        }
        uint64_t v50 = v67;
      }
      while ((v56 & 1) != 0);
    }
  }
  else
  {
    if (_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveInvalidateInterval((id *)a1, 0, v67))goto LABEL_59; {
LABEL_70:
    }
    int v53 = 0;
  }
  if (*(void *)(a1 + 40) && *(void *)(a1 + 664) != *(void *)(a1 + 656))
  {
    do
    {
      uint64_t v57 = objc_msgSend(*(id *)(a1 + 40), "dateIntervalAtIndex:", *(void *)(a1 + 112) + 1, v50, v65);
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_updateSourceOrder(a1 + 120);
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeThroughTime(a1 + 120, *(double *)(a1 + 128));
      unint64_t v58 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsFromFinishedBucket(a1, (double *)(a1 + 120));
      double v59 = [v57 startDate];
      [v59 timeIntervalSinceReferenceDate];
      double v61 = v60;
      uint64_t v62 = [v57 endDate];
      [v62 timeIntervalSinceReferenceDate];
      HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::advanceBucket(a1 + 112, v61, v63);

      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_didChangeBucket(a1, v58);
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_notifyForCurrentBucket(a1);
    }
    while (*(void *)(a1 + 664) != *(void *)(a1 + 656));
  }
  *(unsigned char *)(a1 + 690) = 0;
  if (__p) {
    operator delete(__p);
  }

  if (v53)
  {
    if (*(unsigned char *)(a1 + 692))
    {
      *(unsigned char *)(a1 + 692) = 0;
      id v6 = v65;
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_notifyForCurrentBucket(a1);
      uint64_t v7 = 1;
      goto LABEL_82;
    }
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = 0;
  }
  id v6 = v65;
LABEL_82:
  *(unsigned char *)(a1 + 690) = 0;
LABEL_83:

  return v7;
}

void sub_1BD187094(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, void *a12)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    *(unsigned char *)(v13 + 690) = 0;
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::enableImmediateSampleInsertion(uint64_t result)
{
  *(unsigned char *)(result + 691) = 1;
  return result;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::invalidateInterval(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = *(void **)(a1 + 40);
  if (!v6)
  {

    goto LABEL_11;
  }
  if (!v5)
  {
LABEL_11:
    if (*(unsigned char *)(a1 + 690)) {
      goto LABEL_12;
    }
    uint64_t v7 = 0;
LABEL_14:
    uint64_t v11 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveInvalidateInterval((id *)a1, v7, a3);
    goto LABEL_15;
  }
  uint64_t v7 = [v6 dateIntervalForIntervalsContainingInterval:v5];

  if (!*(unsigned char *)(a1 + 690)) {
    goto LABEL_14;
  }
  if (!v7)
  {
LABEL_12:
    id v12 = *(void **)(a1 + 712);
    *(void *)(a1 + 712) = 0;

    uint64_t v7 = 0;
    uint64_t v11 = 1;
    *(unsigned char *)(a1 + 689) = 1;
    goto LABEL_15;
  }
  if (!*(unsigned char *)(a1 + 689))
  {
    int v8 = *(void **)(a1 + 712);
    if (!v8)
    {
      id v9 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      id v10 = *(void **)(a1 + 712);
      *(void *)(a1 + 712) = v9;

      int v8 = *(void **)(a1 + 712);
    }
    [v8 addObject:v7];
  }
  uint64_t v11 = 1;
LABEL_15:

  return v11;
}

void sub_1BD187394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::queryForInitialStatistics(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 104));
  if (WeakRetained)
  {
    *(unsigned char *)(a1 + 688) = 1;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke;
    v9[3] = &unk_1E63043E8;
    uint64_t v12 = a1;
    id v10 = v5;
    id v11 = WeakRetained;
    uint64_t v7 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 112))(a1, v9, a3);
    if (v7 && *(unsigned char *)(a1 + 688) && !*(void *)(a1 + 40)) {
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_configureForStartTime(a1);
    }
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a3, 3, @"Unable to query for initial statistics: no data source available.");
    uint64_t v7 = 0;
  }

  return v7;
}

void sub_1BD1874E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::reset(uint64_t result)
{
  *(unsigned char *)(result + 688) = 1;
  return result;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::encodeInternalsWithEncoder(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 encodeBool:*(unsigned __int8 *)(a1 + 688) forKey:@"needs_config"];
  v3;
  v27[0] = &unk_1F1726FA0;
  v27[1] = 0;
  int v28 = 0;
  uint64_t v4 = *(void *)(a1 + 112);
  LOBYTE(v28) = 1;
  v27[2] = v4;
  memset(&v27[3], 0, 24);
  statistics::StatisticsEngine::makeCurrentBucket((uint64_t)v27);
  int v8 = &unk_1F171B9C8;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  int v26 = 511;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v22 = 0;
  int8x16_t v9 = vextq_s8(*(int8x16_t *)(a1 + 120), *(int8x16_t *)(a1 + 120), 8uLL);
  uint64_t v5 = *(void *)(a1 + 136);
  char v24 = *(unsigned char *)(a1 + 144);
  char v25 = *(unsigned char *)(a1 + 145);
  BOOL v23 = *(_DWORD *)(a1 + 148) == 0;
  int8x16_t v10 = vextq_s8(*(int8x16_t *)(a1 + 160), *(int8x16_t *)(a1 + 160), 8uLL);
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v14 = v5;
  uint64_t v15 = v6;
  uint64_t v7 = *(int8x16_t **)(a1 + 216);
  if (v7 != *(int8x16_t **)(a1 + 224))
  {
    v29[0] = &unk_1F17206F8;
    int v34 = 127;
    int8x16_t v30 = vextq_s8(*v7, *v7, 8uLL);
    v29[1] = v7[1].i64[0];
    v29[2] = v7[1].i64[1];
    char v33 = 0;
    __int8 v32 = v7[2].i8[9];
    __int8 v31 = v7[2].i8[10];
    PB::PtrVector<statistics::RawQuantitySample>::emplace_back<statistics::RawQuantitySample&>();
  }
  statistics::StatisticsBucket::makeStatistics((uint64_t)&v8);
  HDStatisticsRelative<HDStatisticsSleepStages>::archive((uint64_t)v29, a1 + 240);
}

void sub_1BD1878E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&a35);

  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::decodeInternalsWithDecoder(uint64_t a1, void *a2)
{
  id v65 = a2;
  *(unsigned char *)(a1 + 688) = [v65 decodeBoolForKey:@"needs_config"];
  id v3 = v65;
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::HDStatisticsBucket((uint64_t)&v69.n128_i64[1], 0, -1.79769313e308, 1.79769313e308);
  *(_OWORD *)long long v70 = 0u;
  long long v71 = 0u;
  unint64_t v114 = 0;
  id v68 = v3;
  PB::Reader::Reader((PB::Reader *)v113, (const unsigned __int8 *)[v68 decodeBytesForKey:@"hdsce_archived_representation" returnedLength:&v114]);
  long long v106 = &unk_1F1726FA0;
  uint64_t v107 = 0;
  uint64_t v111 = 0;
  uint64_t v109 = 0;
  uint64_t v110 = 0;
  int v112 = 0;
  statistics::StatisticsEngine::readFrom((statistics::StatisticsEngine *)&v106, (PB::Reader *)v113);
  uint64_t v67 = a1;
  v69.n128_u64[0] = v108;
  if (v107)
  {
    uint64_t v76 = 0;
    memset(v79, 0, sizeof(v79));
    long long __p = 0;
    unint64_t v82 = 0;
    unint64_t v81 = 0;
    *(_DWORD *)uint64_t v83 = 0;
    memset(&v83[8], 0, 32);
    *(_OWORD *)&v83[40] = xmmword_1BD330210;
    long long v84 = xmmword_1BD330220;
    *(void *)&v83[56] = 0;
    *(void *)int64_t v85 = 0;
    *(_OWORD *)&v85[8] = xmmword_1BD330230;
    long long v86 = xmmword_1BD330240;
    *(void *)&v85[24] = 0;
    *(void *)long long v87 = 0;
    *(_OWORD *)&v87[8] = xmmword_1BD330250;
    *(void *)&v87[24] = 0;
    *(void *)long long v88 = 0x7FFFFFFFFFFFFFFFLL;
    memset(&v88[8], 0, 34);
    uint64_t v91 = 0;
    uint64_t v90 = 0;
    long long v89 = &v90;
    long long v93 = 0u;
    long long v92 = 0u;
    int v94 = 1065353216;
    long long v95 = 0u;
    long long v96 = 0u;
    long long v97 = 0u;
    uint64_t v98 = 0;
    int v99 = 1065353216;
    long long v100 = 0u;
    long long v101 = 0u;
    int v102 = 1065353216;
    long long v103 = 0u;
    long long v104 = 0u;
    int v105 = 1065353216;
    int8x16_t v72 = vextq_s8(*(int8x16_t *)(v107 + 8), *(int8x16_t *)(v107 + 8), 8uLL);
    uint64_t v4 = *(void *)(v107 + 72);
    uint64_t v73 = *(void *)(v107 + 64);
    char v74 = *(unsigned char *)(v107 + 185);
    char v75 = *(unsigned char *)(v107 + 186);
    int8x16_t v77 = vextq_s8(*(int8x16_t *)(v107 + 24), *(int8x16_t *)(v107 + 24), 8uLL);
    uint64_t v78 = v4;
    uint64_t v5 = *(void *)(v107 + 80);
    uint64_t v6 = *(void *)(v107 + 88);
    int64_t v66 = (void *)v107;
    if (v5 != v6)
    {
      uint64_t v7 = 0;
      do
      {
        uint64_t v8 = *(void *)(*(void *)v5 + 24);
        uint64_t v9 = *(void *)(*(void *)v5 + 32);
        uint64_t v10 = *(void *)(*(void *)v5 + 8);
        uint64_t v11 = *(void *)(*(void *)v5 + 16);
        char v12 = *(unsigned char *)(*(void *)v5 + 41);
        char v13 = *(unsigned char *)(*(void *)v5 + 40);
        if ((unint64_t)v7 >= v82)
        {
          uint64_t v14 = (char *)__p;
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (unsigned char *)__p) >> 4);
          unint64_t v16 = v15 + 1;
          if (v15 + 1 > 0x555555555555555) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          if (0x5555555555555556 * ((uint64_t)(v82 - (void)__p) >> 4) > v16) {
            unint64_t v16 = 0x5555555555555556 * ((uint64_t)(v82 - (void)__p) >> 4);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v82 - (void)__p) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v17 = 0x555555555555555;
          }
          else {
            unint64_t v17 = v16;
          }
          if (v17)
          {
            unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v17);
            uint64_t v7 = v81;
            uint64_t v14 = (char *)__p;
          }
          else
          {
            uint64_t v18 = 0;
          }
          long long v19 = (void *)(v17 + 48 * v15);
          *long long v19 = v9;
          v19[1] = v8;
          v19[2] = v10;
          v19[3] = v11;
          *((_WORD *)v19 + 16) = 1;
          *((unsigned char *)v19 + 40) = 0;
          *((unsigned char *)v19 + 41) = v12;
          *((unsigned char *)v19 + 42) = v13;
          long long v20 = (char *)v19;
          if (v7 != v14)
          {
            do
            {
              long long v21 = *((_OWORD *)v7 - 3);
              long long v22 = *((_OWORD *)v7 - 2);
              *(_OWORD *)(v20 - 21) = *(_OWORD *)(v7 - 21);
              *((_OWORD *)v20 - 3) = v21;
              *((_OWORD *)v20 - 2) = v22;
              v20 -= 48;
              v7 -= 48;
            }
            while (v7 != v14);
            uint64_t v14 = (char *)__p;
          }
          uint64_t v7 = (char *)(v19 + 6);
          long long __p = v20;
          unint64_t v81 = (char *)(v19 + 6);
          unint64_t v82 = v17 + 48 * v18;
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          *(void *)uint64_t v7 = v9;
          *((void *)v7 + 1) = v8;
          *((void *)v7 + 2) = v10;
          *((void *)v7 + 3) = v11;
          *((_WORD *)v7 + 16) = 1;
          v7[40] = 0;
          v7[41] = v12;
          v7[42] = v13;
          v7 += 48;
        }
        unint64_t v81 = v7;
        v5 += 8;
      }
      while (v5 != v6);
    }
    BOOL v23 = (const statistics::Statistics *)v66[13];
    if (v23)
    {
      HDStatisticsRelative<HDStatisticsSleepStages>::unarchive((uint64_t)&v115, v23);
      *(_OWORD *)long long v88 = v125;
      *(_OWORD *)&v88[16] = v126;
      *(_OWORD *)&v88[32] = v127;
      *(_OWORD *)&v85[16] = v121;
      long long v86 = v122;
      *(_OWORD *)long long v87 = v123;
      *(_OWORD *)&unsigned char v87[16] = v124;
      *(_OWORD *)&v83[32] = v117;
      *(_OWORD *)&v83[48] = v118;
      long long v84 = v119;
      *(_OWORD *)int64_t v85 = v120;
      *(_OWORD *)uint64_t v83 = v115;
      *(_OWORD *)&v83[16] = v116;
    }
    char v24 = (const statistics::Statistics **)v66[17];
    for (uint64_t i = (const statistics::Statistics **)v66[18]; v24 != i; *(_OWORD *)(v33 + 40) = v43)
    {
      int v26 = *v24;
      HDStatisticsRelative<HDStatisticsSleepStages>::unarchive((uint64_t)&v115, *v24);
      uint64_t v27 = *((void *)v26 + 18);
      int v28 = v90;
      uint64_t v29 = &v90;
      int8x16_t v30 = &v90;
      if (v90)
      {
        do
        {
          while (1)
          {
            int8x16_t v30 = (uint64_t **)v28;
            uint64_t v31 = v28[4];
            if (v31 <= v27) {
              break;
            }
            int v28 = *v30;
            uint64_t v29 = v30;
            if (!*v30) {
              goto LABEL_32;
            }
          }
          if (v31 >= v27)
          {
            char v33 = (char *)v30;
            goto LABEL_35;
          }
          int v28 = v30[1];
        }
        while (v28);
        uint64_t v29 = v30 + 1;
      }
LABEL_32:
      char v33 = (char *)operator new(0xF8uLL);
      *((void *)v33 + 4) = v27;
      *(_OWORD *)(v33 + 72) = 0u;
      *(_OWORD *)(v33 + 88) = 0u;
      *(_OWORD *)(v33 + 120) = 0u;
      *(_OWORD *)(v33 + 136) = 0u;
      *(_OWORD *)(v33 + 168) = 0u;
      *(_OWORD *)(v33 + 184) = 0u;
      *(_OWORD *)(v33 + 200) = 0u;
      *(_OWORD *)(v33 + 40) = 0u;
      *(_OWORD *)(v33 + 56) = 0u;
      *(_OWORD *)(v33 + 216) = 0u;
      *(_OWORD *)(v33 + 232) = 0u;
      *((_OWORD *)v33 + 5) = xmmword_1BD330210;
      *(_OWORD *)(v33 + 104) = xmmword_1BD330220;
      *((_OWORD *)v33 + 8) = xmmword_1BD330230;
      *(_OWORD *)(v33 + 152) = xmmword_1BD330240;
      *((_OWORD *)v33 + 11) = xmmword_1BD330250;
      *((void *)v33 + 25) = 0x7FFFFFFFFFFFFFFFLL;
      *((_WORD *)v33 + 120) = 0;
      *((_OWORD *)v33 + 13) = 0u;
      *((_OWORD *)v33 + 14) = 0u;
      *(void *)char v33 = 0;
      *((void *)v33 + 1) = 0;
      *((void *)v33 + 2) = v30;
      *uint64_t v29 = (uint64_t *)v33;
      __int8 v32 = (uint64_t *)v33;
      if (*v89)
      {
        long long v89 = (uint64_t **)*v89;
        __int8 v32 = *v29;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v90, v32);
      ++v91;
LABEL_35:
      long long v34 = v127;
      long long v35 = v126;
      long long v36 = v125;
      long long v37 = v123;
      *(_OWORD *)(v33 + 184) = v124;
      *(_OWORD *)(v33 + 200) = v36;
      *(_OWORD *)(v33 + 216) = v35;
      *(_OWORD *)(v33 + 232) = v34;
      long long v38 = v122;
      long long v39 = v121;
      long long v40 = v119;
      *(_OWORD *)(v33 + 120) = v120;
      *(_OWORD *)(v33 + 136) = v39;
      *(_OWORD *)(v33 + 152) = v38;
      *(_OWORD *)(v33 + 168) = v37;
      long long v41 = v118;
      long long v42 = v117;
      long long v43 = v115;
      *(_OWORD *)(v33 + 56) = v116;
      *(_OWORD *)(v33 + 72) = v42;
      *(_OWORD *)(v33 + 88) = v41;
      *(_OWORD *)(v33 + 104) = v40;
      ++v24;
    }
    uint64_t v44 = v66[5];
    for (uint64_t j = v66[6]; v44 != j; v44 += 8)
    {
      double v47 = *(double *)(*(void *)v44 + 8);
      double v46 = *(double *)(*(void *)v44 + 16);
      if (v47 >= v46) {
        double v48 = *(double *)(*(void *)v44 + 16);
      }
      else {
        double v48 = *(double *)(*(void *)v44 + 8);
      }
      if (v46 < v47) {
        double v46 = *(double *)(*(void *)v44 + 8);
      }
      HKIntervalMask<double>::_insertInterval(v79, v48, v46);
    }
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::operator=((uint64_t)&v69.n128_i64[1], (uint64_t)&v72);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket((uint64_t)&v72);
  }
  uint64_t v49 = v109;
  uint64_t v50 = v110;
  if (v109 != v110)
  {
    unint64_t v51 = (char *)v70[1];
    do
    {
      uint64_t v52 = *(void *)(*(void *)v49 + 24);
      uint64_t v53 = *(void *)(*(void *)v49 + 32);
      uint64_t v54 = *(void *)(*(void *)v49 + 8);
      uint64_t v55 = *(void *)(*(void *)v49 + 16);
      if ((unint64_t)v51 >= (unint64_t)v71)
      {
        char v56 = (char *)v70[0];
        unint64_t v57 = 0xCCCCCCCCCCCCCCCDLL * ((v51 - (char *)v70[0]) >> 3);
        unint64_t v58 = v57 + 1;
        if (v57 + 1 > 0x666666666666666) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        if (0x999999999999999ALL * ((uint64_t)(v71 - (unint64_t)v70[0]) >> 3) > v58) {
          unint64_t v58 = 0x999999999999999ALL * ((uint64_t)(v71 - (unint64_t)v70[0]) >> 3);
        }
        if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v71 - (unint64_t)v70[0]) >> 3) >= 0x333333333333333) {
          unint64_t v59 = 0x666666666666666;
        }
        else {
          unint64_t v59 = v58;
        }
        if (v59)
        {
          unint64_t v59 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v59);
          unint64_t v51 = (char *)v70[1];
          char v56 = (char *)v70[0];
        }
        else
        {
          uint64_t v60 = 0;
        }
        unint64_t v61 = v59 + 40 * v57;
        *(void *)unint64_t v61 = v53;
        *(void *)(v61 + 8) = v52;
        *(void *)(v61 + 16) = v54;
        *(void *)(v61 + 24) = v55;
        *(_WORD *)(v61 + 32) = 1;
        uint64_t v62 = (char *)v61;
        if (v51 != v56)
        {
          do
          {
            long long v63 = *(_OWORD *)(v51 - 40);
            long long v64 = *(_OWORD *)(v51 - 24);
            *((_WORD *)v62 - 4) = *((_WORD *)v51 - 4);
            *(_OWORD *)(v62 - 24) = v64;
            *(_OWORD *)(v62 - 40) = v63;
            v62 -= 40;
            v51 -= 40;
          }
          while (v51 != v56);
          char v56 = (char *)v70[0];
        }
        v70[0] = v62;
        unint64_t v51 = (char *)(v61 + 40);
        v70[1] = (void *)(v61 + 40);
        *(void *)&long long v71 = v59 + 40 * v60;
        if (v56) {
          operator delete(v56);
        }
      }
      else
      {
        *(void *)unint64_t v51 = v53;
        *((void *)v51 + 1) = v52;
        *((void *)v51 + 2) = v54;
        *((void *)v51 + 3) = v55;
        *((_WORD *)v51 + 16) = 1;
        v51 += 40;
      }
      v70[1] = v51;
      v49 += 8;
    }
    while (v49 != v50);
  }
  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&v106);

  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::operator=((void *)(v67 + 112), &v69);
  if (v70[0])
  {
    v70[1] = v70[0];
    operator delete(v70[0]);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket((uint64_t)&v69.n128_i64[1]);
}

void sub_1BD188104(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::~__hash_table((uint64_t)&STACK[0x4B0]);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table(a2);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&STACK[0x460]);
  uint64_t v18 = (void *)STACK[0x448];
  if (STACK[0x448])
  {
    STACK[0x450] = (unint64_t)v18;
    operator delete(v18);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&STACK[0x420]);
  std::__tree<long>::destroy((void *)STACK[0x410]);
  long long v19 = (void *)STACK[0x320];
  if (STACK[0x320])
  {
    STACK[0x328] = (unint64_t)v19;
    operator delete(v19);
  }
  objc_destroyWeak((id *)&STACK[0x318]);
  long long v20 = (void *)STACK[0x300];
  if (STACK[0x300])
  {
    STACK[0x308] = (unint64_t)v20;
    operator delete(v20);
  }

  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&STACK[0x4E0]);
  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsCollectionEngine((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::HDStatisticsBucket(uint64_t a1, void *a2, double a3, double a4)
{
  *(double *)a1 = a3;
  *(double *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 24) = 256;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(double *)(a1 + 56) = a3;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  objc_initWeak((id *)(a1 + 88), a2);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = xmmword_1BD330210;
  *(void *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 184) = xmmword_1BD330220;
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 208) = xmmword_1BD330230;
  *(void *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 232) = xmmword_1BD330240;
  *(void *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 256) = xmmword_1BD330250;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0x7FFFFFFFFFFFFFFFLL;
  *(_WORD *)(a1 + 320) = 0;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 328) = a1 + 336;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_DWORD *)(a1 + 384) = 1065353216;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(void *)(a1 + 440) = 0;
  *(_DWORD *)(a1 + 448) = 1065353216;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_DWORD *)(a1 + 488) = 1065353216;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_DWORD *)(a1 + 528) = 1065353216;
  return a1;
}

uint64_t HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsCollectionEngine(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 544);
  if (v2)
  {
    *(void *)(a1 + 552) = v2;
    operator delete(v2);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket(a1 + 8);
  return a1;
}

uint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::~__hash_table(a1 + 496);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table(a1 + 456);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a1 + 416);
  unint64_t v2 = *(void **)(a1 + 392);
  if (v2)
  {
    *(void *)(a1 + 400) = v2;
    operator delete(v2);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a1 + 352);
  std::__tree<long>::destroy(*(void **)(a1 + 336));
  id v3 = *(void **)(a1 + 96);
  if (v3)
  {
    *(void *)(a1 + 104) = v3;
    operator delete(v3);
  }
  objc_destroyWeak((id *)(a1 + 88));
  uint64_t v4 = *(void **)(a1 + 64);
  if (v4)
  {
    *(void *)(a1 + 72) = v4;
    operator delete(v4);
  }

  return a1;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_configureForStartTime(uint64_t a1)
{
  unint64_t v28 = 0;
  unint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    id v3 = objc_msgSend(MEMORY[0x1E4F1C9C8], "dateWithTimeIntervalSinceReferenceDate:");
    uint64_t v4 = [v2 dateIntervalContainingDate:v3 index:&v28];

    uint64_t v5 = [v4 startDate];
    [v5 timeIntervalSinceReferenceDate];
    double v7 = v6;

    uint64_t v8 = [v4 endDate];
    [v8 timeIntervalSinceReferenceDate];
LABEL_5:
    double v13 = v9;

    goto LABEL_6;
  }
  id v10 = *(id *)(a1 + 64);
  uint64_t v4 = v10;
  if (v10)
  {
    uint64_t v11 = [v10 startDate];
    [v11 timeIntervalSinceReferenceDate];
    double v7 = v12;

    uint64_t v8 = [v4 endDate];
    [v8 timeIntervalSinceReferenceDate];
    goto LABEL_5;
  }
  double v7 = -1.79769313e308;
  double v13 = 1.79769313e308;
LABEL_6:

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::HDStatisticsBucket((uint64_t)v21, WeakRetained, v7, v13);

  if (*(void *)(a1 + 32) == 1) {
    char v23 = 1;
  }
  uint64_t v22 = *(void *)(a1 + 56);
  char v24 = *(unsigned char *)(a1 + 24) & 1;
  if (v27 != (char *)(a1 + 72)) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(v27, *(char **)(a1 + 72), *(void *)(a1 + 80), (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 4);
  }
  objc_storeStrong(&v26, *(id *)(a1 + 704));
  if (!*(void *)(a1 + 40)) {
    int v25 = 0;
  }
  unint64_t v15 = v28;
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::HDStatisticsBucket((uint64_t)v17, (uint64_t)v21);
  v18.n128_u64[0] = v15;
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::HDStatisticsBucket((uint64_t)&v18.n128_i64[1], (uint64_t)v17);
  long long __p = 0u;
  long long v20 = 0u;
  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::operator=((void *)(a1 + 112), &v18);

  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket((uint64_t)&v18.n128_i64[1]);
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket((uint64_t)v17);
  *(unsigned char *)(a1 + 688) = 0;
  return HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::~HDStatisticsBucket((uint64_t)v21);
}

void sub_1BD188674(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::operator=(void *a1, __n128 *a2)
{
  *a1 = a2->n128_u64[0];
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::operator=((uint64_t)(a1 + 1), (uint64_t)&a2->n128_i64[1]);
  std::vector<HKRawInterval<double>>::__move_assign((uint64_t)(a1 + 68), a2 + 34);
  unint64_t v4 = a2[35].n128_u64[1];
  a2[35].n128_u64[1] = 0;
  uint64_t v5 = (void *)a1[71];
  a1[71] = v4;

  return a1;
}

uint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::HDStatisticsBucket(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(id *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 56);
  long long v6 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 40) = v6;
  *(void *)(a1 + 56) = v5;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((void *)(a1 + 64), *(const void **)(a2 + 64), *(void *)(a2 + 72), (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 4);
  objc_copyWeak((id *)(a1 + 88), (id *)(a2 + 88));
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  uint64_t v8 = *(unsigned char **)(a2 + 96);
  double v7 = *(unsigned char **)(a2 + 104);
  uint64_t v9 = v7 - v8;
  if (v7 != v8)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v9 >> 4) >= 0x555555555555556) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    id v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(0xAAAAAAAAAAAAAAABLL * (v9 >> 4));
    *(void *)(a1 + 96) = v10;
    *(void *)(a1 + 104) = v10;
    *(void *)(a1 + 112) = &v10[48 * v11];
    memmove(v10, v8, v9 - 5);
    *(void *)(a1 + 104) = &v10[16 * (v9 >> 4)];
  }
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  long long v12 = *(_OWORD *)(a2 + 136);
  long long v13 = *(_OWORD *)(a2 + 152);
  long long v14 = *(_OWORD *)(a2 + 168);
  *(_OWORD *)(a1 + 184) = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 168) = v14;
  *(_OWORD *)(a1 + 152) = v13;
  *(_OWORD *)(a1 + 136) = v12;
  long long v15 = *(_OWORD *)(a2 + 200);
  long long v16 = *(_OWORD *)(a2 + 216);
  long long v17 = *(_OWORD *)(a2 + 232);
  *(_OWORD *)(a1 + 248) = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 232) = v17;
  *(_OWORD *)(a1 + 216) = v16;
  *(_OWORD *)(a1 + 200) = v15;
  long long v18 = *(_OWORD *)(a2 + 264);
  long long v19 = *(_OWORD *)(a2 + 280);
  long long v20 = *(_OWORD *)(a2 + 312);
  *(_OWORD *)(a1 + 296) = *(_OWORD *)(a2 + 296);
  *(_OWORD *)(a1 + 312) = v20;
  *(_OWORD *)(a1 + 264) = v18;
  *(_OWORD *)(a1 + 280) = v19;
  long long v21 = (void *)(a1 + 336);
  *(void *)(a1 + 336) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 328) = a1 + 336;
  uint64_t v22 = *(void **)(a2 + 328);
  if (v22 != (void *)(a2 + 336))
  {
    char v23 = 0;
    char v24 = (void *)(a1 + 336);
    while (1)
    {
      uint64_t v25 = v22[4];
      id v26 = (void *)(a1 + 336);
      if (v24 == v21) {
        goto LABEL_12;
      }
      uint64_t v27 = v23;
      unint64_t v28 = (void *)(a1 + 336);
      if (v23)
      {
        do
        {
          id v26 = v27;
          uint64_t v27 = (void *)v27[1];
        }
        while (v27);
      }
      else
      {
        do
        {
          id v26 = (void *)v28[2];
          BOOL v29 = *v26 == (void)v28;
          unint64_t v28 = v26;
        }
        while (v29);
      }
      if (v26[4] < v25)
      {
LABEL_12:
        if (v23) {
          int8x16_t v30 = (uint64_t **)v26;
        }
        else {
          int8x16_t v30 = (uint64_t **)(a1 + 336);
        }
        if (v23) {
          uint64_t v31 = (uint64_t **)(v26 + 1);
        }
        else {
          uint64_t v31 = (uint64_t **)(a1 + 336);
        }
        if (!*v31)
        {
LABEL_28:
          long long v34 = operator new(0xF8uLL);
          long long v35 = *((_OWORD *)v22 + 3);
          v34[2] = *((_OWORD *)v22 + 2);
          v34[3] = v35;
          long long v36 = *((_OWORD *)v22 + 4);
          long long v37 = *((_OWORD *)v22 + 5);
          long long v38 = *((_OWORD *)v22 + 7);
          v34[6] = *((_OWORD *)v22 + 6);
          v34[7] = v38;
          v34[4] = v36;
          v34[5] = v37;
          long long v39 = *((_OWORD *)v22 + 8);
          long long v40 = *((_OWORD *)v22 + 9);
          long long v41 = *((_OWORD *)v22 + 11);
          v34[10] = *((_OWORD *)v22 + 10);
          v34[11] = v41;
          v34[8] = v39;
          v34[9] = v40;
          long long v42 = *((_OWORD *)v22 + 12);
          long long v43 = *((_OWORD *)v22 + 13);
          long long v44 = *((_OWORD *)v22 + 14);
          *((void *)v34 + 30) = v22[30];
          v34[13] = v43;
          v34[14] = v44;
          v34[12] = v42;
          std::__tree<unsigned long long>::__insert_node_at((uint64_t **)(a1 + 328), (uint64_t)v30, v31, (uint64_t *)v34);
        }
      }
      else
      {
        uint64_t v31 = (uint64_t **)(a1 + 336);
        int8x16_t v30 = (uint64_t **)(a1 + 336);
        if (!v23) {
          goto LABEL_28;
        }
        __int8 v32 = v23;
        while (1)
        {
          while (1)
          {
            int8x16_t v30 = (uint64_t **)v32;
            uint64_t v33 = v32[4];
            if (v33 <= v25) {
              break;
            }
            __int8 v32 = *v30;
            uint64_t v31 = v30;
            if (!*v30) {
              goto LABEL_28;
            }
          }
          if (v33 >= v25) {
            break;
          }
          __int8 v32 = v30[1];
          if (!v32)
          {
            uint64_t v31 = v30 + 1;
            goto LABEL_28;
          }
        }
      }
      uint64_t v45 = (void *)v22[1];
      if (v45)
      {
        do
        {
          double v46 = v45;
          uint64_t v45 = (void *)*v45;
        }
        while (v45);
      }
      else
      {
        do
        {
          double v46 = (void *)v22[2];
          BOOL v29 = *v46 == (void)v22;
          uint64_t v22 = v46;
        }
        while (!v29);
      }
      if (v46 == (void *)(a2 + 336)) {
        break;
      }
      char v23 = (void *)*v21;
      char v24 = *(void **)(a1 + 328);
      uint64_t v22 = v46;
    }
  }
  std::unordered_set<long long>::unordered_set(a1 + 352, a2 + 352);
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>((void *)(a1 + 392), *(const void **)(a2 + 392), *(void *)(a2 + 400), (uint64_t)(*(void *)(a2 + 400) - *(void *)(a2 + 392)) >> 3);
  std::unordered_map<long long,long long>::unordered_map(a1 + 416, a2 + 416);
  std::unordered_map<NSString * {__strong},long long,HDStringHash,HDStringEqual,std::allocator<std::pair<NSString * const {__strong},long long>>>::unordered_map(a1 + 456, a2 + 456);
  std::unordered_map<long long,NSString * {__strong}>::unordered_map(a1 + 496, a2 + 496);
  return a1;
}

void sub_1BD188A74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, id *location, void **a12)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table(v16);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v15);
  long long v19 = *v14;
  if (*v14)
  {
    *(void *)(v12 + 400) = v19;
    operator delete(v19);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v13);
  std::__tree<long>::destroy(*v17);
  long long v20 = *a10;
  if (*a10)
  {
    *(void *)(v12 + 104) = v20;
    operator delete(v20);
  }
  objc_destroyWeak(location);
  long long v21 = *a12;
  if (*a12)
  {
    *(void *)(v12 + 72) = v21;
    operator delete(v21);
  }

  _Unwind_Resume(a1);
}

uint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::operator=(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = 0;
  long long v6 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = v5;

  long long v7 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v7;
  std::vector<HKRawInterval<double>>::__move_assign(a1 + 64, (__n128 *)(a2 + 64));
  id WeakRetained = objc_loadWeakRetained((id *)(a2 + 88));
  objc_storeWeak((id *)(a1 + 88), WeakRetained);

  uint64_t v9 = *(void **)(a1 + 96);
  if (v9)
  {
    *(void *)(a1 + 104) = v9;
    operator delete(v9);
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
  }
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  long long v10 = *(_OWORD *)(a2 + 152);
  long long v11 = *(_OWORD *)(a2 + 168);
  long long v12 = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 184) = v12;
  *(_OWORD *)(a1 + 168) = v11;
  *(_OWORD *)(a1 + 152) = v10;
  long long v13 = *(_OWORD *)(a2 + 216);
  long long v14 = *(_OWORD *)(a2 + 232);
  long long v15 = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 248) = v15;
  *(_OWORD *)(a1 + 232) = v14;
  *(_OWORD *)(a1 + 216) = v13;
  long long v16 = *(_OWORD *)(a2 + 312);
  long long v18 = *(_OWORD *)(a2 + 264);
  long long v17 = *(_OWORD *)(a2 + 280);
  *(_OWORD *)(a1 + 296) = *(_OWORD *)(a2 + 296);
  *(_OWORD *)(a1 + 312) = v16;
  *(_OWORD *)(a1 + 264) = v18;
  *(_OWORD *)(a1 + 280) = v17;
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  uint64_t v19 = a1 + 336;
  std::__tree<long>::destroy(*(void **)(a1 + 336));
  *(void *)(a1 + 328) = *(void *)(a2 + 328);
  uint64_t v20 = *(void *)(a2 + 336);
  *(void *)(a1 + 336) = v20;
  uint64_t v21 = *(void *)(a2 + 344);
  *(void *)(a1 + 344) = v21;
  if (v21)
  {
    *(void *)(v20 + 16) = v19;
    *(void *)(a2 + 328) = a2 + 336;
    *(void *)(a2 + 336) = 0;
    *(void *)(a2 + 344) = 0;
  }
  else
  {
    *(void *)(a1 + 328) = v19;
  }
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__move_assign(a1 + 352, (uint64_t *)(a2 + 352));
  std::vector<HKRawInterval<double>>::__move_assign(a1 + 392, (__n128 *)(a2 + 392));
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__move_assign(a1 + 416, (uint64_t *)(a2 + 416));
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::__move_assign(a1 + 456, (uint64_t *)(a2 + 456));
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::__move_assign(a1 + 496, (uint64_t *)(a2 + 496));
  return a1;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsFromFinishedBucket(uint64_t a1, double *a2)
{
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  double v5 = *a2;
  id v6 = objc_alloc(MEMORY[0x1E4F1C9C8]);
  long long v7 = a2 + 5;
  if (v5 != -1.79769313e308) {
    long long v7 = a2;
  }
  id v115 = (id)[v6 initWithTimeIntervalSinceReferenceDate:*v7];
  uint64_t v117 = (uint64_t)a2;
  if (a2[1] == 1.79769313e308) {
    uint64_t v8 = [objc_alloc(MEMORY[0x1E4F1C9C8]) initWithTimeIntervalSinceReferenceDate:a2[6]];
  }
  else {
    uint64_t v8 = [objc_alloc(MEMORY[0x1E4F1C9C8]) initWithTimeIntervalSinceReferenceDate:a2[1]];
  }
  uint64_t v9 = (void *)v8;
  id v10 = *(id *)(a1 + 16);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v11 = *(id *)(a1 + 16);
    if ([v11 shouldUseUnderlyingTypeForStatistics])
    {
      uint64_t v12 = [v11 underlyingSampleType];

      id v10 = (id)v12;
    }
  }
  long long v13 = (void *)[objc_alloc(MEMORY[0x1E4F2B5B0]) initWithDataType:v10 startDate:v115 endDate:v9];
  if (*(unsigned char *)(a1 + 24))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));

    if (WeakRetained)
    {
      id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      long long v15 = *(uint64_t **)(v117 + 392);
      long long v16 = *(uint64_t **)(v117 + 400);
      while (v15 != v16)
      {
        uint64_t v17 = *v15;
        id v18 = objc_loadWeakRetained((id *)(a1 + 48));
        unint64_t v3 = [v18 sourceForSourceID:v17];

        if (v3)
        {
          if (([v2 containsObject:v3] & 1) == 0) {
            [v2 addObject:v3];
          }
        }

        ++v15;
      }
      uint64_t v19 = (void *)[v2 copy];
      [v13 _setSources:v19];
    }
  }

  v131[0] = &unk_1F1726D50;
  uint64_t v132 = v131;
  id v116 = v13;
  long long v20 = *(_OWORD *)(v117 + 264);
  long long v21 = *(_OWORD *)(v117 + 296);
  long long v22 = *(_OWORD *)(v117 + 312);
  long long v128 = *(_OWORD *)(v117 + 280);
  long long v129 = v21;
  long long v130 = v22;
  long long v23 = *(_OWORD *)(v117 + 200);
  long long v24 = *(_OWORD *)(v117 + 232);
  long long v124 = *(_OWORD *)(v117 + 216);
  long long v125 = v24;
  long long v126 = *(_OWORD *)(v117 + 248);
  long long v127 = v20;
  long long v25 = *(_OWORD *)(v117 + 136);
  long long v26 = *(_OWORD *)(v117 + 168);
  long long v120 = *(_OWORD *)(v117 + 152);
  long long v121 = v26;
  long long v122 = *(_OWORD *)(v117 + 184);
  long long v123 = v23;
  *(_OWORD *)long long __p = *(_OWORD *)(v117 + 120);
  long long v119 = v25;
  if (!v132) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v27 = (*(uint64_t (**)(void *, void **))(*v132 + 48))(v132, __p);
  uint64_t v28 = 0;
  double v29 = 0.0;
  uint64_t v30 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v31 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    uint64_t v32 = v27 + v28;
    double v33 = *(double *)(v27 + v28 + 24);
    if (v33 > 2.22507386e-308 && v33 >= v29)
    {
      if (v33 <= v29)
      {
        if (*(void *)(v27 + v28 + 32) < v30)
        {
          uint64_t v31 = *(void *)(v32 + 16);
          double v29 = *(double *)(v27 + v28 + 24);
          uint64_t v30 = *(void *)(v27 + v28 + 32);
        }
      }
      else
      {
        uint64_t v31 = *(void *)(v32 + 16);
        uint64_t v30 = *(void *)(v27 + v28 + 32);
        double v29 = *(double *)(v27 + v28 + 24);
      }
    }
    v28 += 24;
  }
  while (v28 != 144);
  if (v31 != 0x7FFFFFFFFFFFFFFFLL)
  {
    long long v35 = [NSNumber numberWithInteger:v29];
    [v116 setCategoryValue:v35];
  }
  long long v36 = *(_OWORD *)(v117 + 296);
  long long v128 = *(_OWORD *)(v117 + 280);
  long long v129 = v36;
  long long v130 = *(_OWORD *)(v117 + 312);
  long long v37 = *(_OWORD *)(v117 + 232);
  long long v124 = *(_OWORD *)(v117 + 216);
  long long v125 = v37;
  long long v38 = *(_OWORD *)(v117 + 264);
  long long v126 = *(_OWORD *)(v117 + 248);
  long long v127 = v38;
  long long v39 = *(_OWORD *)(v117 + 168);
  long long v120 = *(_OWORD *)(v117 + 152);
  long long v121 = v39;
  long long v40 = *(_OWORD *)(v117 + 200);
  long long v122 = *(_OWORD *)(v117 + 184);
  long long v123 = v40;
  long long v41 = *(_OWORD *)(v117 + 136);
  *(_OWORD *)long long __p = *(_OWORD *)(v117 + 120);
  long long v119 = v41;
  if (!v132) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  objc_msgSend(v116, "setDataCount:", *(void *)(*(uint64_t (**)(void *, void **))(*v132 + 48))(v132, __p));
  if (*(unsigned char *)(a1 + 24))
  {
    id v114 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v42 = *(uint64_t **)(v117 + 392);
    for (uint64_t i = *(uint64_t **)(v117 + 400); v42 != i; ++v42)
    {
      uint64_t v44 = *v42;
      id v2 = objc_loadWeakRetained((id *)(a1 + 48));
      uint64_t v45 = [v2 sourceForSourceID:v44];

      if (v45 && ([v114 containsObject:v45] & 1) == 0) {
        [v114 addObject:v45];
      }
    }
    id v10 = (id)[v114 copy];
    [v116 _setSources:v10];

    id v110 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    id v113 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    *(_OWORD *)long long __p = 0u;
    long long v119 = 0u;
    LODWORD(v120) = 1065353216;
    double v46 = *(void **)(v117 + 328);
    if (v46 != (void *)(v117 + 336))
    {
      while (1)
      {
        double v47 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_bundleIdentifierForSourceID(v117, v46[4]);
        id v2 = v47;
        if (!v47) {
          goto LABEL_117;
        }
        unint64_t v48 = [v47 hash];
        unint64_t v49 = v48;
        unint64_t v50 = (unint64_t)__p[1];
        if (!__p[1]) {
          break;
        }
        uint8x8_t v51 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
        v51.i16[0] = vaddlv_u8(v51);
        unint64_t v52 = v51.u32[0];
        if (v51.u32[0] > 1uLL)
        {
          unint64_t v3 = v48;
          if ((void *)v48 >= __p[1]) {
            unint64_t v3 = v48 % (unint64_t)__p[1];
          }
        }
        else
        {
          unint64_t v3 = ((unint64_t)__p[1] - 1) & v48;
        }
        uint64_t v53 = (void **)*((void *)__p[0] + v3);
        if (!v53) {
          break;
        }
        uint64_t v54 = (char *)*v53;
        if (!*v53) {
          break;
        }
        unint64_t v112 = (unint64_t)__p[1] - 1;
        while (1)
        {
          unint64_t v55 = *((void *)v54 + 1);
          if (v55 == v49) {
            break;
          }
          if (v52 > 1)
          {
            if (v55 >= v50) {
              v55 %= v50;
            }
          }
          else
          {
            v55 &= v112;
          }
          if (v55 != v3) {
            goto LABEL_59;
          }
LABEL_58:
          uint64_t v54 = *(char **)v54;
          if (!v54) {
            goto LABEL_59;
          }
        }
        id v56 = *((id *)v54 + 2);
        id v57 = v2;
        id v10 = v57;
        if (v56 != v57)
        {
          char v58 = [v56 isEqualToString:v57];

          if (v58) {
            goto LABEL_116;
          }
          goto LABEL_58;
        }

LABEL_116:
        *(_OWORD *)(v54 + 24) = *(_OWORD *)(v46 + 5);
        long long v78 = *(_OWORD *)(v46 + 7);
        long long v79 = *(_OWORD *)(v46 + 9);
        long long v80 = *(_OWORD *)(v46 + 11);
        *(_OWORD *)(v54 + 88) = *(_OWORD *)(v46 + 13);
        *(_OWORD *)(v54 + 72) = v80;
        *(_OWORD *)(v54 + 56) = v79;
        *(_OWORD *)(v54 + 40) = v78;
        long long v81 = *(_OWORD *)(v46 + 15);
        long long v82 = *(_OWORD *)(v46 + 17);
        long long v83 = *(_OWORD *)(v46 + 19);
        *(_OWORD *)(v54 + 152) = *(_OWORD *)(v46 + 21);
        *(_OWORD *)(v54 + 136) = v83;
        *(_OWORD *)(v54 + 120) = v82;
        *(_OWORD *)(v54 + 104) = v81;
        long long v84 = *(_OWORD *)(v46 + 23);
        long long v85 = *(_OWORD *)(v46 + 25);
        long long v86 = *(_OWORD *)(v46 + 27);
        *(_OWORD *)(v54 + 216) = *(_OWORD *)(v46 + 29);
        *(_OWORD *)(v54 + 200) = v86;
        *(_OWORD *)(v54 + 184) = v85;
        *(_OWORD *)(v54 + 168) = v84;

LABEL_117:
        long long v87 = (void *)v46[1];
        if (v87)
        {
          do
          {
            long long v88 = v87;
            long long v87 = (void *)*v87;
          }
          while (v87);
        }
        else
        {
          do
          {
            long long v88 = (void *)v46[2];
            BOOL v89 = *v88 == (void)v46;
            double v46 = v88;
          }
          while (!v89);
        }
        double v46 = v88;
        if (v88 == (void *)(v117 + 336))
        {
          for (uint64_t j = (uint64_t **)v119; j; uint64_t j = (uint64_t **)*j)
          {
            long long v92 = j[2];
            if (!v132) {
              goto LABEL_169;
            }
            id v2 = j + 3;
            uint64_t v93 = (*(uint64_t (**)(void *, uint64_t *))(*v132 + 48))(v132, (uint64_t *)j + 3);
            uint64_t v94 = 0;
            double v95 = 0.0;
            uint64_t v96 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v97 = 0x7FFFFFFFFFFFFFFFLL;
            do
            {
              uint64_t v98 = v93 + v94;
              double v99 = *(double *)(v93 + v94 + 24);
              if (v99 > 2.22507386e-308 && v99 >= v95)
              {
                if (v99 <= v95)
                {
                  if (*(void *)(v93 + v94 + 32) < v96)
                  {
                    uint64_t v97 = *(void *)(v98 + 16);
                    double v95 = *(double *)(v93 + v94 + 24);
                    uint64_t v96 = *(void *)(v93 + v94 + 32);
                  }
                }
                else
                {
                  uint64_t v97 = *(void *)(v98 + 16);
                  uint64_t v96 = *(void *)(v93 + v94 + 32);
                  double v95 = *(double *)(v93 + v94 + 24);
                }
              }
              v94 += 24;
            }
            while (v94 != 144);
            if (v97 != 0x7FFFFFFFFFFFFFFFLL)
            {
              long long v101 = [NSNumber numberWithInteger:v95];
              [v110 setObject:v101 forKeyedSubscript:v92];
            }
            if (!v132) {
LABEL_169:
            }
              std::__throw_bad_function_call[abi:ne180100]();
            objc_msgSend(NSNumber, "numberWithLongLong:", *(void *)(*(uint64_t (**)(void *, uint64_t *))(*v132 + 48))(v132, (uint64_t *)j + 3));
            id v10 = (id)objc_claimAutoreleasedReturnValue();
            [v113 setObject:v10 forKeyedSubscript:v92];
          }
          goto LABEL_150;
        }
      }
LABEL_59:
      uint64_t v54 = (char *)operator new(0xE8uLL);
      *(void *)uint64_t v54 = 0;
      *((void *)v54 + 1) = v49;
      *((void *)v54 + 2) = v2;
      *(_OWORD *)(v54 + 56) = 0u;
      *(_OWORD *)(v54 + 72) = 0u;
      *(_OWORD *)(v54 + 104) = 0u;
      *(_OWORD *)(v54 + 120) = 0u;
      *(_OWORD *)(v54 + 152) = 0u;
      *(_OWORD *)(v54 + 168) = 0u;
      *(_OWORD *)(v54 + 184) = 0u;
      *(_OWORD *)(v54 + 24) = 0u;
      *(_OWORD *)(v54 + 40) = 0u;
      *(_OWORD *)(v54 + 200) = 0u;
      *(_OWORD *)(v54 + 216) = 0u;
      *((_OWORD *)v54 + 4) = xmmword_1BD330210;
      *(_OWORD *)(v54 + 88) = xmmword_1BD330220;
      *((_OWORD *)v54 + 7) = xmmword_1BD330230;
      *(_OWORD *)(v54 + 136) = xmmword_1BD330240;
      *((_OWORD *)v54 + 10) = xmmword_1BD330250;
      *((void *)v54 + 23) = 0x7FFFFFFFFFFFFFFFLL;
      *((_WORD *)v54 + 112) = 0;
      *((_OWORD *)v54 + 12) = 0u;
      *((_OWORD *)v54 + 13) = 0u;
      float v59 = (float)(unint64_t)(*((void *)&v119 + 1) + 1);
      if (!v50 || (float)(*(float *)&v120 * (float)v50) < v59)
      {
        BOOL v60 = v50 < 3 || (v50 & (v50 - 1)) != 0;
        unint64_t v61 = v60 | (2 * v50);
        unint64_t v62 = vcvtps_u32_f32(v59 / *(float *)&v120);
        if (v61 <= v62) {
          int8x8_t prime = (int8x8_t)v62;
        }
        else {
          int8x8_t prime = (int8x8_t)v61;
        }
        if (*(void *)&prime == 1)
        {
          int8x8_t prime = (int8x8_t)2;
        }
        else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
        {
          int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        }
        unint64_t v50 = (unint64_t)__p[1];
        if ((void *)*(void *)&prime <= __p[1])
        {
          if ((void *)*(void *)&prime < __p[1])
          {
            unint64_t v70 = vcvtps_u32_f32((float)*((unint64_t *)&v119 + 1) / *(float *)&v120);
            if (__p[1] < (void *)3
              || (uint8x8_t v71 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]), v71.i16[0] = vaddlv_u8(v71), v71.u32[0] > 1uLL))
            {
              unint64_t v70 = std::__next_prime(v70);
            }
            else
            {
              uint64_t v72 = 1 << -(char)__clz(v70 - 1);
              if (v70 >= 2) {
                unint64_t v70 = v72;
              }
            }
            if (*(void *)&prime <= v70) {
              int8x8_t prime = (int8x8_t)v70;
            }
            if (*(void *)&prime >= v50)
            {
              unint64_t v50 = (unint64_t)__p[1];
            }
            else
            {
              if (prime) {
                goto LABEL_72;
              }
              uint64_t v90 = __p[0];
              __p[0] = 0;
              if (v90) {
                operator delete(v90);
              }
              unint64_t v50 = 0;
              __p[1] = 0;
            }
          }
        }
        else
        {
LABEL_72:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          long long v64 = operator new(8 * *(void *)&prime);
          id v65 = __p[0];
          __p[0] = v64;
          if (v65) {
            operator delete(v65);
          }
          uint64_t v66 = 0;
          __p[1] = (void *)prime;
          do
            *((void *)__p[0] + v66++) = 0;
          while (*(void *)&prime != v66);
          uint64_t v67 = (void **)v119;
          if ((void)v119)
          {
            unint64_t v68 = *(void *)(v119 + 8);
            uint8x8_t v69 = (uint8x8_t)vcnt_s8(prime);
            v69.i16[0] = vaddlv_u8(v69);
            if (v69.u32[0] > 1uLL)
            {
              if (v68 >= *(void *)&prime) {
                v68 %= *(void *)&prime;
              }
            }
            else
            {
              v68 &= *(void *)&prime - 1;
            }
            *((void *)__p[0] + v68) = &v119;
            for (k = *v67; k; unint64_t v68 = v74)
            {
              unint64_t v74 = k[1];
              if (v69.u32[0] > 1uLL)
              {
                if (v74 >= *(void *)&prime) {
                  v74 %= *(void *)&prime;
                }
              }
              else
              {
                v74 &= *(void *)&prime - 1;
              }
              if (v74 != v68)
              {
                if (!*((void *)__p[0] + v74))
                {
                  *((void *)__p[0] + v74) = v67;
                  goto LABEL_97;
                }
                *uint64_t v67 = (void *)*k;
                void *k = **((void **)__p[0] + v74);
                **((void **)__p[0] + v74) = k;
                k = v67;
              }
              unint64_t v74 = v68;
LABEL_97:
              uint64_t v67 = (void **)k;
              k = (void *)*k;
            }
          }
          unint64_t v50 = (unint64_t)prime;
        }
        if ((v50 & (v50 - 1)) != 0)
        {
          if (v49 >= v50) {
            unint64_t v3 = v49 % v50;
          }
          else {
            unint64_t v3 = v49;
          }
        }
        else
        {
          unint64_t v3 = (v50 - 1) & v49;
        }
      }
      char v75 = __p[0];
      uint64_t v76 = (void *)*((void *)__p[0] + v3);
      if (v76)
      {
        *(void *)uint64_t v54 = *v76;
      }
      else
      {
        *(void *)uint64_t v54 = v119;
        *(void *)&long long v119 = v54;
        v75[v3] = &v119;
        if (!*(void *)v54)
        {
LABEL_115:
          ++*((void *)&v119 + 1);
          goto LABEL_116;
        }
        unint64_t v77 = *(void *)(*(void *)v54 + 8);
        if ((v50 & (v50 - 1)) != 0)
        {
          if (v77 >= v50) {
            v77 %= v50;
          }
        }
        else
        {
          v77 &= v50 - 1;
        }
        uint64_t v76 = (char *)__p[0] + 8 * v77;
      }
      *uint64_t v76 = v54;
      goto LABEL_115;
    }
LABEL_150:
    std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsDiscrete>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsDiscrete>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsDiscrete>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsDiscrete>>>>::~__hash_table((uint64_t)__p);
    [v116 setCategoryValueBySource:v110];
    [v116 setDataCountBySource:v113];
  }
  std::__function::__value_func<HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsSleepStages> const&)>::~__value_func[abi:ne180100](v131);
  int v102 = [*(id *)(a1 + 16) _unitForChangeInCanonicalUnit];
  long long v103 = [v116 averageQuantity];
  if (v103)
  {
    id v10 = [v116 averageQuantity];
    if (([v10 isCompatibleWithUnit:v102] & 1) == 0)
    {

LABEL_165:
      [MEMORY[0x1E4F1CA00] raise:*MEMORY[0x1E4F1C3B8], @"Expected compatibility with %@", v102 format];
      goto LABEL_166;
    }
  }
  long long v104 = [v116 minimumQuantity];
  if (v104)
  {
    id v2 = [v116 minimumQuantity];
    if (![v2 isCompatibleWithUnit:v102])
    {
      int v105 = 1;
      goto LABEL_159;
    }
  }
  long long v106 = [v116 maximumQuantity];
  if (v106)
  {
    uint64_t v107 = [v116 maximumQuantity];
    int v108 = [v107 isCompatibleWithUnit:v102];

    int v105 = v108 ^ 1;
    if (v104) {
      goto LABEL_159;
    }
  }
  else
  {
    int v105 = 0;
    if (v104)
    {
LABEL_159:

      if (v103) {
        goto LABEL_160;
      }
LABEL_164:

      if (!v105) {
        goto LABEL_166;
      }
      goto LABEL_165;
    }
  }
  if (!v103) {
    goto LABEL_164;
  }
LABEL_160:

  if (v105) {
    goto LABEL_165;
  }
LABEL_166:

  return v116;
}

void sub_1BD189A0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29)
{
  if (v32) {
  if (v30)
  }

  _Unwind_Resume(a1);
}

void HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_updateSourceOrder(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 376);
  uint64_t v2 = *(void *)(a1 + 392);
  if (v1 != (*(void *)(a1 + 400) - v2) >> 3)
  {
    long long v4 = (void **)(a1 + 392);
    *(void *)(a1 + 400) = v2;
    std::vector<long long>::reserve((void **)(a1 + 392), v1);
    double v5 = *(void **)(a1 + 368);
    if (v5)
    {
      id v6 = *(char **)(a1 + 400);
      do
      {
        uint64_t v7 = v5[2];
        unint64_t v8 = *(void *)(a1 + 408);
        if ((unint64_t)v6 >= v8)
        {
          id v10 = (char *)*v4;
          uint64_t v11 = (v6 - (unsigned char *)*v4) >> 3;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 61) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v13 = v8 - (void)v10;
          if (v13 >> 2 > v12) {
            unint64_t v12 = v13 >> 2;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14)
          {
            unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v14);
            id v10 = *(char **)(a1 + 392);
            id v6 = *(char **)(a1 + 400);
          }
          else
          {
            uint64_t v15 = 0;
          }
          long long v16 = (void *)(v14 + 8 * v11);
          *long long v16 = v7;
          uint64_t v9 = (char *)(v16 + 1);
          while (v6 != v10)
          {
            uint64_t v17 = *((void *)v6 - 1);
            v6 -= 8;
            *--long long v16 = v17;
          }
          *(void *)(a1 + 392) = v16;
          *(void *)(a1 + 400) = v9;
          *(void *)(a1 + 408) = v14 + 8 * v15;
          if (v10) {
            operator delete(v10);
          }
        }
        else
        {
          *(void *)id v6 = v7;
          uint64_t v9 = v6 + 8;
        }
        *(void *)(a1 + 400) = v9;
        double v5 = (void *)*v5;
        id v6 = v9;
      }
      while (v5);
    }
    id v18 = (id *)(a1 + 88);
    id WeakRetained = objc_loadWeakRetained(v18);

    if (WeakRetained)
    {
      id v20 = objc_loadWeakRetained(v18);
      [v20 orderSourceIDs:v4];
    }
  }
}

void sub_1BD189D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeThroughTime(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 16);
  if (v4 > 0.0 && *(double *)(a1 + 8) > a2) {
    a2 = v4 * floor(a2 / v4);
  }
  double v5 = *(double *)(a1 + 56);
  if (v5 < a2)
  {
    long long v121 = (void **)(a1 + 96);
    uint64_t v117 = (double **)(a1 + 64);
    uint64_t v115 = a1 + 120;
    location = (id *)(a1 + 88);
    uint64_t v111 = (void *)(a1 + 336);
    while (1)
    {
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v7 = *(long long **)(a1 + 104);
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - v6) >> 4);
      if (v8) {
        break;
      }
LABEL_127:
      *(double *)(a1 + 56) = a2;
LABEL_128:
      double v108 = *(double *)(a1 + 56);
      if (v108 == v5)
      {
        uint64_t v109 = [MEMORY[0x1E4F28B00] currentHandler];
        id v110 = [NSString stringWithUTF8String:"void HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeThroughTime(double) [Statistics = HDStatisticsRelative<HDStatisticsSleepStages>]"];
        [v109 handleFailureInFunction:v110 file:@"HDStatisticsBucket.hpp" lineNumber:234 description:@"Failed to make forward progress during statistics merge."];

        double v108 = *(double *)(a1 + 56);
      }
      double v5 = v108;
      if (v108 >= a2) {
        return;
      }
    }
    if (v8 != 1)
    {
      double v17 = a2;
      double v18 = a2;
      double v19 = v5;
      uint64_t v20 = *(void *)(a1 + 96);
      if ((long long *)v6 != v7)
      {
        do
        {
          double v21 = *(double *)(v20 + 8);
          double v22 = *(double *)(v20 + 16);
          if (v21 > v19 && v21 < v18) {
            double v18 = *(double *)(v20 + 8);
          }
          if (v22 > v5) {
            double v24 = *(double *)(v20 + 16);
          }
          else {
            double v24 = v17;
          }
          if (v22 < v17)
          {
            double v19 = v5;
            double v17 = v24;
          }
          v20 += 48;
        }
        while ((long long *)v20 != v7);
      }
      if (v17 >= v18) {
        double v25 = v18;
      }
      else {
        double v25 = v17;
      }
      double v26 = *(double *)(a1 + 16);
      if (v26 > 0.0)
      {
        double v27 = v26 * floor(v25 / v26);
        double v28 = v26 * floor((v26 + v5) / v26);
        if (v27 >= v28) {
          double v25 = v27;
        }
        else {
          double v25 = v28;
        }
      }
      *long long v121 = 0;
      v121[1] = 0;
      v121[2] = 0;
      id v113 = (long long *)v6;
      if ((long long *)v6 != v7)
      {
        if (v8 > 0x555555555555555) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        double v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - v6) >> 4));
        uint64_t v32 = *(char **)(a1 + 96);
        uint64_t v31 = *(char **)(a1 + 104);
        double v33 = v29;
        if (v31 != v32)
        {
          do
          {
            long long v34 = *((_OWORD *)v31 - 3);
            long long v35 = *((_OWORD *)v31 - 2);
            *(_OWORD *)(v33 - 21) = *(_OWORD *)(v31 - 21);
            *((_OWORD *)v33 - 3) = v34;
            *((_OWORD *)v33 - 2) = v35;
            v33 -= 48;
            v31 -= 48;
          }
          while (v31 != v32);
          uint64_t v31 = (char *)*v121;
        }
        *(void *)(a1 + 96) = v33;
        *(void *)(a1 + 104) = v29;
        *(void *)(a1 + 112) = &v29[48 * v30];
        if (v31) {
          operator delete(v31);
        }
      }
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_updateSourceOrder(a1);
      id WeakRetained = objc_loadWeakRetained(location);

      if (WeakRetained)
      {
        *(void *)&v123.double var0 = a1;
        unint64_t v37 = 126 - 2 * __clz(v8);
        unint64_t v38 = (unint64_t)v113;
        if (v113 == v7) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = v37;
        }
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*,false>((unint64_t)v113, v7, (uint64_t)&v123, v39, 1);
      }
      else
      {
        unint64_t v42 = 126 - 2 * __clz(v8);
        unint64_t v38 = (unint64_t)v113;
        if (v113 == v7) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = v42;
        }
      }
      std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*,false>(v38, v7, v39, 1);
      if (*(unsigned char *)(a1 + 25)) {
        id v114 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
      }
      else {
        id v114 = 0;
      }
      if (v113 == v7)
      {
LABEL_109:
        long long v92 = *(void **)(a1 + 328);
        if (v92 != v111)
        {
          do
          {
            uint64_t v93 = (void *)v92[1];
            if (v93)
            {
              do
              {
                uint64_t v94 = v93;
                uint64_t v93 = (void *)*v93;
              }
              while (v93);
            }
            else
            {
              do
              {
                uint64_t v94 = (void *)v92[2];
                BOOL v95 = *v94 == (void)v92;
                long long v92 = v94;
              }
              while (!v95);
            }
            long long v92 = v94;
          }
          while (v94 != v111);
        }
        *(double *)(a1 + 56) = v25;

        if (v113) {
          operator delete(v113);
        }
        goto LABEL_128;
      }
      int64_t v116 = 0;
      char v43 = 0;
      uint64_t v44 = v113;
      while (2)
      {
        long long v45 = v44[1];
        *(_OWORD *)&v123.double var0 = *v44;
        *(_OWORD *)&v123.var2 = v45;
        *(void *)&v123.BOOL var4 = *((void *)v44 + 4);
        double var0 = v123.var0;
        uint64_t v47 = v45;
        if (*(double *)&v45 - v123.var1 - (v25 - v123.var1) < 0.01)
        {
          int64_t v48 = 0;
          BOOL var4 = 0;
          BOOL var5 = 0;
          double v51 = 0.0;
          uint64_t v47 = 0;
          if (!v123.var4) {
            goto LABEL_62;
          }
LABEL_57:
          BOOL v119 = var5;
          int64_t v120 = v48;
          HDRawQuantitySample::applyMask((uint64_t)&v123, v117);
          int v52 = *((unsigned __int8 *)v44 + 42);
          int v53 = *((unsigned __int8 *)v44 + 41);
          char v118 = *((unsigned char *)v44 + 40);
          if (!v123.var4) {
            goto LABEL_90;
          }
          if (v43)
          {
            unint64_t var3 = v123.var3;
            if (v116 == v123.var3 || *(unsigned char *)(a1 + 24))
            {
              HDStatisticsRelative<HDStatisticsSleepStages>::addSample(v115, &v123, v52 == 0);
              int v52 = 1;
            }
          }
          else
          {
            HDStatisticsRelative<HDStatisticsSleepStages>::addSample(v115, &v123, v52 == 0);
            int v52 = 1;
            unint64_t var3 = v123.var3;
            int64_t v116 = v123.var3;
          }
          if (!*(unsigned char *)(a1 + 25)) {
            goto LABEL_89;
          }
          id v65 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_bundleIdentifierForSourceID(a1, var3);
          if (!v65) {
            goto LABEL_88;
          }
          uint64_t v66 = [v114 objectForKeyedSubscript:v65];
          uint64_t v67 = v66;
          if (v66)
          {
            if ([v66 longLongValue] != var3 && !*(unsigned char *)(a1 + 24))
            {
LABEL_87:

LABEL_88:
LABEL_89:
              char v43 = 1;
LABEL_90:
              if (var4)
              {
                BOOL v80 = v52 != 0;
                long long v82 = *(char **)(a1 + 104);
                unint64_t v81 = *(void *)(a1 + 112);
                if ((unint64_t)v82 < v81)
                {
                  *(double *)long long v82 = var0;
                  *((double *)v82 + 1) = v51;
                  *((void *)v82 + 2) = v47;
                  *((void *)v82 + 3) = v120;
                  unsigned char v82[32] = var4;
                  v82[33] = v119;
                  v82[40] = v118;
                  v82[41] = v53;
                  float v59 = v82 + 48;
                  v82[42] = v80;
                  goto LABEL_107;
                }
                uint64_t v76 = (char *)*v121;
                unint64_t v83 = 0xAAAAAAAAAAAAAAABLL * ((v82 - (unsigned char *)*v121) >> 4);
                unint64_t v84 = v83 + 1;
                if (v83 + 1 > 0x555555555555555) {
                  std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
                }
                unint64_t v85 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v81 - (void)v76) >> 4);
                if (2 * v85 > v84) {
                  unint64_t v84 = 2 * v85;
                }
                if (v85 >= 0x2AAAAAAAAAAAAAALL) {
                  unint64_t v86 = 0x555555555555555;
                }
                else {
                  unint64_t v86 = v84;
                }
                if (v86)
                {
                  unint64_t v86 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v86);
                  uint64_t v76 = *(char **)(a1 + 96);
                  long long v82 = *(char **)(a1 + 104);
                }
                else
                {
                  uint64_t v87 = 0;
                }
                unint64_t v88 = v86 + 48 * v83;
                *(double *)unint64_t v88 = var0;
                *(double *)(v88 + 8) = v51;
                *(void *)(v88 + 16) = v47;
                *(void *)(v88 + 24) = v120;
                *(unsigned char *)(v88 + 32) = var4;
                *(unsigned char *)(v88 + 33) = v119;
                *(unsigned char *)(v88 + 40) = v118;
                *(unsigned char *)(v88 + 41) = v53;
                *(unsigned char *)(v88 + 42) = v80;
                unint64_t v89 = v88;
                if (v82 != v76)
                {
                  do
                  {
                    long long v90 = *((_OWORD *)v82 - 3);
                    long long v91 = *((_OWORD *)v82 - 2);
                    *(_OWORD *)(v89 - 21) = *(_OWORD *)(v82 - 21);
                    *(_OWORD *)(v89 - 48) = v90;
                    *(_OWORD *)(v89 - 32) = v91;
                    v89 -= 48;
                    v82 -= 48;
                  }
                  while (v82 != v76);
                  uint64_t v76 = (char *)*v121;
                }
                float v59 = (_OWORD *)(v88 + 48);
                *(void *)(a1 + 96) = v89;
                *(void *)(a1 + 104) = v88 + 48;
                *(void *)(a1 + 112) = v86 + 48 * v87;
                if (v76) {
LABEL_106:
                }
                  operator delete(v76);
                goto LABEL_107;
              }
              goto LABEL_108;
            }
          }
          else
          {
            unint64_t v77 = [NSNumber numberWithLongLong:var3];
            [v114 setObject:v77 forKeyedSubscript:v65];
          }
          unint64_t v78 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_canonicalSourceIDForSourceID(a1, var3);
          long long v79 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsForSource(a1, v78);
          HDStatisticsRelative<HDStatisticsSleepStages>::addSample((uint64_t)v79, &v123, v53 == 0);
          LOBYTE(v53) = 1;
          goto LABEL_87;
        }
        if (v25 - v123.var1 < 0.01)
        {
          v123.BOOL var4 = 0;
          goto LABEL_62;
        }
        int64_t v48 = v123.var3;
        BOOL var5 = v123.var5;
        v123.var2 = v25;
        double v51 = v25;
        BOOL var4 = v123.var4;
        if (v123.var4) {
          goto LABEL_57;
        }
LABEL_62:
        unint64_t v55 = *(long long **)(a1 + 104);
        unint64_t v56 = *(void *)(a1 + 112);
        if ((unint64_t)v55 < v56)
        {
          long long v57 = *v44;
          long long v58 = v44[2];
          v55[1] = v44[1];
          v55[2] = v58;
          *unint64_t v55 = v57;
          float v59 = v55 + 3;
          goto LABEL_107;
        }
        unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * (((char *)v55 - (unsigned char *)*v121) >> 4);
        unint64_t v61 = v60 + 1;
        if (v60 + 1 > 0x555555555555555) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v62 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v56 - (void)*v121) >> 4);
        if (2 * v62 > v61) {
          unint64_t v61 = 2 * v62;
        }
        if (v62 >= 0x2AAAAAAAAAAAAAALL) {
          unint64_t v63 = 0x555555555555555;
        }
        else {
          unint64_t v63 = v61;
        }
        if (v63) {
          unint64_t v63 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v63);
        }
        else {
          uint64_t v64 = 0;
        }
        unint64_t v68 = (long long *)(v63 + 48 * v60);
        long long v69 = *v44;
        long long v70 = v44[2];
        v68[1] = v44[1];
        v68[2] = v70;
        *unint64_t v68 = v69;
        uint64_t v72 = *(char **)(a1 + 96);
        uint8x8_t v71 = *(char **)(a1 + 104);
        uint64_t v73 = v68;
        if (v71 != v72)
        {
          do
          {
            long long v74 = *((_OWORD *)v71 - 3);
            long long v75 = *((_OWORD *)v71 - 2);
            *(long long *)((char *)v73 - 21) = *(_OWORD *)(v71 - 21);
            *(v73 - 3) = v74;
            *(v73 - 2) = v75;
            v73 -= 3;
            v71 -= 48;
          }
          while (v71 != v72);
          uint8x8_t v71 = (char *)*v121;
        }
        float v59 = v68 + 3;
        *(void *)(a1 + 96) = v73;
        *(void *)(a1 + 104) = v68 + 3;
        *(void *)(a1 + 112) = v63 + 48 * v64;
        if (v71)
        {
          uint64_t v76 = v71;
          goto LABEL_106;
        }
LABEL_107:
        *(void *)(a1 + 104) = v59;
LABEL_108:
        v44 += 3;
        if (v44 == v7) {
          goto LABEL_109;
        }
        continue;
      }
    }
    double v9 = *(double *)(v6 + 8);
    double v10 = *(double *)(v6 + 16);
    int64_t v11 = *(void *)(v6 + 24);
    char v12 = *(unsigned char *)(v6 + 32);
    char v13 = *(unsigned char *)(v6 + 33);
    if (a2 - v9 >= 0.01)
    {
      if (v10 - v9 - (a2 - v9) < 0.01)
      {
        uint64_t v40 = 0;
        char v41 = 0;
        double v16 = 0.0;
        double v15 = *(double *)(v6 + 16);
        char v14 = *(unsigned char *)(v6 + 32);
        double v10 = 0.0;
        char v12 = 0;
LABEL_120:
        int v96 = *(unsigned __int8 *)(v6 + 42);
        int v97 = *(unsigned __int8 *)(v6 + 41);
        uint64_t v98 = *(void *)(a1 + 96);
        int v99 = *(unsigned __int8 *)(v6 + 40);
        double v100 = *(double *)v98;
        v123.var1 = v9;
        v123.var2 = v15;
        v123.unint64_t var3 = v11;
        v123.BOOL var4 = v14;
        v123.BOOL var5 = v13;
        *(_DWORD *)(&v123.var5 + 1) = *(_DWORD *)(v98 + 34);
        *(_WORD *)(&v123.var5 + 5) = *(_WORD *)(v98 + 38);
        *((double *)&v124 + 1) = v16;
        *(double *)&long long v125 = v10;
        *((void *)&v125 + 1) = v40;
        LOBYTE(v126) = v12;
        HIBYTE(v126) = v41;
        v123.double var0 = v100;
        *(double *)&long long v124 = v100;
        HDRawQuantitySample::applyMask((uint64_t)&v123, v117);
        BOOL v101 = v99 != 0;
        BOOL v102 = v97 != 0;
        BOOL v103 = v96 != 0;
        if (v123.var4)
        {
          HDStatisticsRelative<HDStatisticsSleepStages>::addSample(v115, &v123, v96 == 0);
          if (*(unsigned char *)(a1 + 25))
          {
            unint64_t v104 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_canonicalSourceIDForSourceID(a1, v123.var3);
            int v105 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsForSource(a1, v104);
            HDStatisticsRelative<HDStatisticsSleepStages>::addSample((uint64_t)v105, &v123, v97 == 0);
          }
          BOOL v101 = 1;
          BOOL v102 = 1;
          BOOL v103 = 1;
        }
        if ((_BYTE)v126)
        {
          LOWORD(v122) = v126;
          long long v106 = v125;
          uint64_t v107 = (char *)*v121;
          *(_OWORD *)uint64_t v107 = v124;
          *((_OWORD *)v107 + 1) = v106;
          *((void *)v107 + 4) = v122;
          v107[40] = v101;
          v107[41] = v102;
          v107[42] = v103;
        }
        else
        {
          *(void *)(a1 + 104) = *(void *)(a1 + 96);
        }
        goto LABEL_127;
      }
      double v15 = a2;
      char v14 = *(unsigned char *)(v6 + 32);
      double v16 = a2;
    }
    else
    {
      char v14 = 0;
      double v15 = *(double *)(v6 + 16);
      double v16 = *(double *)(v6 + 8);
    }
    uint64_t v40 = *(void *)(v6 + 24);
    char v41 = *(unsigned char *)(v6 + 33);
    goto LABEL_120;
  }
}

void sub_1BD18A6F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  _Unwind_Resume(a1);
}

void HDStatisticsRelative<HDStatisticsSleepStages>::addSample(uint64_t a1, const HDRawQuantitySample *a2, int a3)
{
  int v3 = 2 * (a2->var0 != -1.79769313e308);
  if (a2->var0 == 1.79769313e308) {
    int v3 = 1;
  }
  if (v3)
  {
    if (v3 == 1)
    {
      if (!*(_DWORD *)a1)
      {
        int v6 = 1;
        goto LABEL_16;
      }
    }
    else if (v3 == 2)
    {
      if (*(_DWORD *)a1 == 2)
      {
        double v4 = (HDStatisticsSleepStages *)(a1 + 8);
        a3 = 1;
LABEL_8:
        HDStatisticsSleepStages::addSample(v4, a2, a3);
        return;
      }
      int v6 = 2;
LABEL_16:
      *(_DWORD *)a1 = v6;
      *(_OWORD *)(a1 + 24) = 0u;
      *(_OWORD *)(a1 + 8) = 0u;
      *(_OWORD *)(a1 + 40) = xmmword_1BD330210;
      *(void *)(a1 + 56) = 0;
      *(_OWORD *)(a1 + 64) = xmmword_1BD330220;
      *(void *)(a1 + 80) = 0;
      *(_OWORD *)(a1 + 88) = xmmword_1BD330230;
      *(void *)(a1 + 104) = 0;
      *(_OWORD *)(a1 + 112) = xmmword_1BD330240;
      *(void *)(a1 + 128) = 0;
      *(_OWORD *)(a1 + 136) = xmmword_1BD330250;
      *(void *)(a1 + 152) = 0;
      *(void *)(a1 + 160) = 0x7FFFFFFFFFFFFFFFLL;
      double v4 = (HDStatisticsSleepStages *)(a1 + 8);
      goto LABEL_8;
    }
  }
  else if (!*(_DWORD *)a1)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    double v4 = (HDStatisticsSleepStages *)(a1 + 8);
    if (!v5) {
      goto LABEL_8;
    }
  }
}

uint64_t **HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsForSource(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a2;
  int v3 = *(void **)(a1 + 336);
  if (!v3) {
    goto LABEL_11;
  }
  double v4 = (uint64_t **)(a1 + 336);
  do
  {
    uint64_t v5 = v3[4];
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (!v6) {
      double v4 = (uint64_t **)v3;
    }
    int v3 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t **)(a1 + 336) || (uint64_t)v4[4] > a2)
  {
LABEL_11:
    unint64_t v8 = (uint64_t **)(a1 + 328);
    std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsSleepStages>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsSleepStages>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsSleepStages>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 328), a2, &v10);
    double v4 = std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsSleepStages>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsSleepStages>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsSleepStages>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v8, a2, &v10);
  }
  return v4 + 5;
}

unint64_t HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_canonicalSourceIDForSourceID(uint64_t a1, unint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));

  if (WeakRetained)
  {
    uint64_t v5 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>((void *)(a1 + 416), a2);
    if (v5)
    {
      return v5[3];
    }
    else
    {
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_bundleIdentifierForSourceID(a1, a2);
      id v6 = (id)objc_claimAutoreleasedReturnValue();
      id v10 = v6;
      uint64_t v7 = (void *)(a1 + 456);
      unint64_t v8 = std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::find<NSString * {__strong}>(v7, &v10);
      if (v8)
      {
        a2 = (unint64_t)v8[3];
      }
      else
      {
        int64_t v11 = &v10;
        *((void *)std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>((uint64_t)v7, &v10, &v11)+ 3) = a2;
        id v6 = v10;
      }
    }
  }
  return a2;
}

void sub_1BD18A9B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

id HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_bundleIdentifierForSourceID(uint64_t a1, unint64_t a2)
{
  unint64_t v12 = a2;
  double v4 = (id *)(a1 + 88);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));

  if (WeakRetained)
  {
    id v6 = (void *)(a1 + 496);
    uint64_t v7 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(v6, a2);
    if (v7)
    {
      id v8 = (id)v7[3];
    }
    else
    {
      id v9 = objc_loadWeakRetained(v4);
      id v8 = [v9 bundleIdentifierForSourceID:a2];

      if (v8)
      {
        id v10 = (id *)std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t)v6, a2, &v12);
        objc_storeStrong(v10 + 3, v8);
      }
    }
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void sub_1BD18AA9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<long long,HDStatisticsRelative<HDStatisticsSleepStages>>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsRelative<HDStatisticsSleepStages>>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsRelative<HDStatisticsSleepStages>>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, void *a3)
{
  id v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        id v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        id v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    id v9 = (char *)operator new(0xF8uLL);
    *((void *)v9 + 4) = *a3;
    *(_OWORD *)(v9 + 72) = 0u;
    *(_OWORD *)(v9 + 88) = 0u;
    *(_OWORD *)(v9 + 120) = 0u;
    *(_OWORD *)(v9 + 136) = 0u;
    *(_OWORD *)(v9 + 168) = 0u;
    *(_OWORD *)(v9 + 184) = 0u;
    *(_OWORD *)(v9 + 200) = 0u;
    *(_OWORD *)(v9 + 40) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    *(_OWORD *)(v9 + 216) = 0u;
    *(_OWORD *)(v9 + 232) = 0u;
    *((_OWORD *)v9 + 5) = xmmword_1BD330210;
    *(_OWORD *)(v9 + 104) = xmmword_1BD330220;
    *((_OWORD *)v9 + 8) = xmmword_1BD330230;
    *(_OWORD *)(v9 + 152) = xmmword_1BD330240;
    *((_OWORD *)v9 + 11) = xmmword_1BD330250;
    *((void *)v9 + 25) = 0x7FFFFFFFFFFFFFFFLL;
    *((_WORD *)v9 + 120) = 0;
    *((_OWORD *)v9 + 13) = 0u;
    *((_OWORD *)v9 + 14) = 0u;
    std::__tree<unsigned long long>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

void std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*,false>(unint64_t a1, long long *a2, uint64_t a3, uint64_t a4, char a5)
{
  while (2)
  {
    unint64_t v12 = a2 - 3;
    unint64_t v13 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v13;
          uint64_t v14 = (uint64_t)a2 - v13;
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v13) >> 4);
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v103 = *((void *)a2 - 3);
                uint64_t v104 = *(void *)(v13 + 24);
                if (v103 == v104) {
                  return;
                }
                int v105 = *(char **)(*(void *)a3 + 392);
                long long v106 = *(char **)(*(void *)a3 + 400);
                uint64_t v107 = v105;
                double v108 = v105;
                if (v105 == v106) {
                  goto LABEL_171;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>((long long *)v13, (long long *)(v13 + 48), a2 - 3, a3);
                return;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(v13, v13 + 48, v13 + 96, (uint64_t)(a2 - 3), a3);
                return;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(v13, v13 + 48, v13 + 96, v13 + 144, (uint64_t)(a2 - 3), a3);
                return;
              default:
                JUMPOUT(0);
            }
            do
            {
              if (*(void *)v108 == v103) {
                goto LABEL_168;
              }
              v108 += 8;
            }
            while (v108 != v106);
            double v108 = *(char **)(*(void *)a3 + 400);
LABEL_168:
            while (*(void *)v107 != v104)
            {
              v107 += 8;
              if (v107 == v106)
              {
                uint64_t v107 = *(char **)(*(void *)a3 + 400);
                break;
              }
            }
LABEL_171:
            if (v108 - v105 < v107 - v105)
            {
              *(_OWORD *)v226 = *(_OWORD *)(v13 + 16);
              *(_OWORD *)&v226[16] = *(_OWORD *)(v13 + 32);
              long long v218 = *(_OWORD *)v13;
              long long v109 = *v12;
              long long v110 = *(a2 - 2);
              *(_OWORD *)(v13 + 27) = *(long long *)((char *)a2 - 21);
              *(_OWORD *)unint64_t v13 = v109;
              *(_OWORD *)(v13 + 16) = v110;
              *(long long *)((char *)a2 - 21) = *(_OWORD *)&v226[11];
              long long *v12 = v218;
              *(a2 - 2) = *(_OWORD *)v226;
            }
            return;
          }
          if (v14 <= 1151)
          {
            uint64_t v111 = (long long *)(v13 + 48);
            BOOL v113 = (long long *)v13 == a2 || v111 == a2;
            if (a5)
            {
              if (!v113)
              {
                unint64_t v114 = v13;
                do
                {
                  unint64_t v115 = v114;
                  unint64_t v114 = (unint64_t)v111;
                  uint64_t v116 = *(void *)(v115 + 72);
                  uint64_t v117 = *(void *)(v115 + 24);
                  if (v116 != v117)
                  {
                    char v118 = *(char **)(*(void *)a3 + 392);
                    BOOL v119 = *(char **)(*(void *)a3 + 400);
                    int64_t v120 = v118;
                    long long v121 = v118;
                    if (v118 != v119)
                    {
                      do
                      {
                        if (*(void *)v121 == v116) {
                          goto LABEL_196;
                        }
                        v121 += 8;
                      }
                      while (v121 != v119);
                      long long v121 = *(char **)(*(void *)a3 + 400);
LABEL_196:
                      while (*(void *)v120 != v117)
                      {
                        v120 += 8;
                        if (v120 == v119)
                        {
                          int64_t v120 = *(char **)(*(void *)a3 + 400);
                          break;
                        }
                      }
                    }
                    if (v121 - v118 < v120 - v118)
                    {
                      uint64_t v227 = *(void *)(v114 + 16);
                      long long v219 = *(_OWORD *)v114;
                      long long v236 = *(_OWORD *)(v115 + 80);
                      unint64_t v122 = v114;
                      while (1)
                      {
                        long long v123 = *(_OWORD *)(v115 + 16);
                        *(_OWORD *)unint64_t v122 = *(_OWORD *)v115;
                        *(_OWORD *)(v122 + 16) = v123;
                        *(_OWORD *)(v122 + 27) = *(_OWORD *)(v115 + 27);
                        if (v115 == v13) {
                          break;
                        }
                        unint64_t v122 = v115;
                        uint64_t v124 = *(void *)(v115 - 24);
                        if (v116 != v124)
                        {
                          long long v125 = *(char **)(*(void *)a3 + 392);
                          __int16 v126 = *(char **)(*(void *)a3 + 400);
                          long long v127 = v125;
                          long long v128 = v125;
                          if (v125 != v126)
                          {
                            do
                            {
                              if (*(void *)v128 == v116) {
                                goto LABEL_208;
                              }
                              v128 += 8;
                            }
                            while (v128 != v126);
                            long long v128 = *(char **)(*(void *)a3 + 400);
LABEL_208:
                            while (*(void *)v127 != v124)
                            {
                              v127 += 8;
                              if (v127 == v126)
                              {
                                long long v127 = *(char **)(*(void *)a3 + 400);
                                break;
                              }
                            }
                          }
                          unint64_t v115 = v122 - 48;
                          if (v128 - v125 < v127 - v125) {
                            continue;
                          }
                        }
                        goto LABEL_212;
                      }
                      unint64_t v122 = v13;
LABEL_212:
                      *(_OWORD *)unint64_t v122 = v219;
                      *(void *)(v122 + 16) = v227;
                      *(void *)(v122 + 24) = v116;
                      *(void *)(v122 + 32) = v236;
                      *(_DWORD *)(v122 + 39) = *(_DWORD *)((char *)&v236 + 7);
                    }
                  }
                  uint64_t v111 = (long long *)(v114 + 48);
                }
                while ((long long *)(v114 + 48) != a2);
              }
            }
            else if (!v113)
            {
              do
              {
                unint64_t v201 = a1;
                a1 = (unint64_t)v111;
                uint64_t v202 = *(void *)(v201 + 72);
                uint64_t v203 = *(void *)(v201 + 24);
                if (v202 != v203)
                {
                  v204 = *(char **)(*(void *)a3 + 392);
                  v205 = *(char **)(*(void *)a3 + 400);
                  v206 = v204;
                  v207 = v204;
                  if (v204 != v205)
                  {
                    do
                    {
                      if (*(void *)v207 == v202) {
                        goto LABEL_312;
                      }
                      v207 += 8;
                    }
                    while (v207 != v205);
                    v207 = *(char **)(*(void *)a3 + 400);
LABEL_312:
                    while (*(void *)v206 != v203)
                    {
                      v206 += 8;
                      if (v206 == v205)
                      {
                        v206 = *(char **)(*(void *)a3 + 400);
                        break;
                      }
                    }
                  }
                  if (v207 - v204 < v206 - v204)
                  {
                    uint64_t v230 = *(void *)(a1 + 16);
                    long long v222 = *(_OWORD *)a1;
                    long long v239 = *(_OWORD *)(v201 + 80);
                    unint64_t v208 = a1;
                    do
                    {
                      v209 = (_OWORD *)v208;
                      unint64_t v208 = v201;
                      long long v210 = *(_OWORD *)(v201 + 16);
                      _OWORD *v209 = *(_OWORD *)v201;
                      v209[1] = v210;
                      *(_OWORD *)((char *)v209 + 27) = *(_OWORD *)(v201 + 27);
                      uint64_t v211 = *(void *)(v201 - 24);
                      if (v202 == v211) {
                        break;
                      }
                      v212 = *(char **)(*(void *)a3 + 392);
                      v213 = *(char **)(*(void *)a3 + 400);
                      v214 = v212;
                      v215 = v212;
                      if (v212 != v213)
                      {
                        do
                        {
                          if (*(void *)v215 == v202) {
                            goto LABEL_322;
                          }
                          v215 += 8;
                        }
                        while (v215 != v213);
                        v215 = *(char **)(*(void *)a3 + 400);
LABEL_322:
                        while (*(void *)v214 != v211)
                        {
                          v214 += 8;
                          if (v214 == v213)
                          {
                            v214 = *(char **)(*(void *)a3 + 400);
                            break;
                          }
                        }
                      }
                      unint64_t v201 = v208 - 48;
                    }
                    while (v215 - v212 < v214 - v212);
                    *(_OWORD *)unint64_t v208 = v222;
                    *(void *)(v208 + 16) = v230;
                    *(void *)(v208 + 24) = v202;
                    *(void *)(v208 + 32) = v239;
                    *(_DWORD *)(v208 + 39) = *(_DWORD *)((char *)&v239 + 7);
                  }
                }
                uint64_t v111 = (long long *)(a1 + 48);
              }
              while ((long long *)(a1 + 48) != a2);
            }
            return;
          }
          if (!a4)
          {
            if ((long long *)v13 != a2)
            {
              int64_t v129 = (v15 - 2) >> 1;
              int64_t v130 = v129;
              do
              {
                int64_t v131 = v130;
                if (v129 >= v130)
                {
                  uint64_t v132 = (2 * v130) | 1;
                  unint64_t v133 = v13 + 48 * v132;
                  if (2 * v131 + 2 < (uint64_t)v15)
                  {
                    uint64_t v134 = *(void *)(v133 + 24);
                    uint64_t v135 = *(void *)(v133 + 72);
                    if (v134 != v135)
                    {
                      v137 = *(char **)(*(void *)a3 + 392);
                      v136 = *(char **)(*(void *)a3 + 400);
                      v138 = v137;
                      v139 = v137;
                      if (v137 != v136)
                      {
                        do
                        {
                          if (*(void *)v139 == v134) {
                            goto LABEL_224;
                          }
                          v139 += 8;
                        }
                        while (v139 != v136);
                        v139 = *(char **)(*(void *)a3 + 400);
LABEL_224:
                        while (*(void *)v138 != v135)
                        {
                          v138 += 8;
                          if (v138 == v136)
                          {
                            v138 = *(char **)(*(void *)a3 + 400);
                            break;
                          }
                        }
                      }
                      v133 += 48 * (v139 - v137 < v138 - v137);
                      if (v139 - v137 < v138 - v137) {
                        uint64_t v132 = 2 * v131 + 2;
                      }
                    }
                  }
                  unint64_t v140 = v13 + 48 * v131;
                  uint64_t v141 = *(void *)(v133 + 24);
                  uint64_t v142 = *(void *)(v140 + 24);
                  if (v141 == v142) {
                    goto LABEL_238;
                  }
                  int64_t v144 = *(char **)(*(void *)a3 + 392);
                  v143 = *(char **)(*(void *)a3 + 400);
                  v145 = v144;
                  v146 = v144;
                  if (v144 != v143)
                  {
                    do
                    {
                      if (*(void *)v146 == v141) {
                        goto LABEL_234;
                      }
                      v146 += 8;
                    }
                    while (v146 != v143);
                    v146 = *(char **)(*(void *)a3 + 400);
LABEL_234:
                    while (*(void *)v145 != v142)
                    {
                      v145 += 8;
                      if (v145 == v143)
                      {
                        v145 = *(char **)(*(void *)a3 + 400);
                        break;
                      }
                    }
                  }
                  if (v146 - v144 >= v145 - v144)
                  {
LABEL_238:
                    uint64_t v228 = *(void *)(v140 + 16);
                    long long v220 = *(_OWORD *)v140;
                    long long v237 = *(_OWORD *)(v140 + 32);
                    long long v147 = *(_OWORD *)v133;
                    long long v148 = *(_OWORD *)(v133 + 16);
                    *(_OWORD *)(v140 + 27) = *(_OWORD *)(v133 + 27);
                    *(_OWORD *)unint64_t v140 = v147;
                    *(_OWORD *)(v140 + 16) = v148;
                    if (v129 >= v132)
                    {
                      while (1)
                      {
                        uint64_t v150 = 2 * v132;
                        uint64_t v132 = (2 * v132) | 1;
                        unint64_t v149 = v13 + 48 * v132;
                        uint64_t v151 = v150 + 2;
                        if (v151 < (uint64_t)v15)
                        {
                          uint64_t v152 = *(void *)(v149 + 24);
                          uint64_t v153 = *(void *)(v149 + 72);
                          if (v152 != v153)
                          {
                            long long v154 = *(char **)(*(void *)a3 + 392);
                            __int16 v155 = *(char **)(*(void *)a3 + 400);
                            v156 = v154;
                            v157 = v154;
                            if (v154 != v155)
                            {
                              do
                              {
                                if (*(void *)v157 == v152) {
                                  goto LABEL_246;
                                }
                                v157 += 8;
                              }
                              while (v157 != v155);
                              v157 = *(char **)(*(void *)a3 + 400);
LABEL_246:
                              while (*(void *)v156 != v153)
                              {
                                v156 += 8;
                                if (v156 == v155)
                                {
                                  v156 = *(char **)(*(void *)a3 + 400);
                                  break;
                                }
                              }
                            }
                            v149 += 48 * (v157 - v154 < v156 - v154);
                            if (v157 - v154 < v156 - v154) {
                              uint64_t v132 = v151;
                            }
                          }
                        }
                        uint64_t v158 = *(void *)(v149 + 24);
                        if (v158 != v142)
                        {
                          v160 = *(char **)(*(void *)a3 + 392);
                          v159 = *(char **)(*(void *)a3 + 400);
                          v161 = v160;
                          v162 = v160;
                          if (v160 != v159)
                          {
                            do
                            {
                              if (*(void *)v162 == v158) {
                                goto LABEL_256;
                              }
                              v162 += 8;
                            }
                            while (v162 != v159);
                            v162 = *(char **)(*(void *)a3 + 400);
LABEL_256:
                            while (*(void *)v161 != v142)
                            {
                              v161 += 8;
                              if (v161 == v159)
                              {
                                v161 = *(char **)(*(void *)a3 + 400);
                                break;
                              }
                            }
                          }
                          if (v162 - v160 < v161 - v160) {
                            break;
                          }
                        }
                        long long v163 = *(_OWORD *)v149;
                        long long v164 = *(_OWORD *)(v149 + 16);
                        *(_OWORD *)(v133 + 27) = *(_OWORD *)(v149 + 27);
                        *(_OWORD *)unint64_t v133 = v163;
                        *(_OWORD *)(v133 + 16) = v164;
                        unint64_t v133 = v149;
                        if (v129 < v132) {
                          goto LABEL_261;
                        }
                      }
                    }
                    unint64_t v149 = v133;
LABEL_261:
                    *(_OWORD *)unint64_t v149 = v220;
                    *(void *)(v149 + 16) = v228;
                    *(void *)(v149 + 24) = v142;
                    *(void *)(v149 + 32) = v237;
                    *(_DWORD *)(v149 + 39) = *(_DWORD *)((char *)&v237 + 7);
                  }
                }
                int64_t v130 = v131 - 1;
              }
              while (v131);
              int64_t v165 = v14 / 0x30uLL;
              do
              {
                uint64_t v166 = 0;
                *(_OWORD *)v229 = *(_OWORD *)(v13 + 16);
                *(_OWORD *)&v229[16] = *(_OWORD *)(v13 + 32);
                long long v221 = *(_OWORD *)v13;
                uint64_t v167 = v165 - 2;
                if (v165 < 2) {
                  uint64_t v167 = v165 - 1;
                }
                uint64_t v168 = v167 >> 1;
                unint64_t v169 = v13;
                do
                {
                  v170 = (_OWORD *)v169;
                  v169 += 48 * v166 + 48;
                  uint64_t v171 = 2 * v166;
                  uint64_t v166 = (2 * v166) | 1;
                  uint64_t v172 = v171 + 2;
                  if (v171 + 2 < v165)
                  {
                    uint64_t v173 = *(void *)(v169 + 24);
                    uint64_t v174 = *(void *)(v169 + 72);
                    if (v173 != v174)
                    {
                      v176 = *(char **)(*(void *)a3 + 392);
                      v175 = *(char **)(*(void *)a3 + 400);
                      v177 = v176;
                      v178 = v176;
                      if (v176 != v175)
                      {
                        do
                        {
                          if (*(void *)v178 == v173) {
                            goto LABEL_273;
                          }
                          v178 += 8;
                        }
                        while (v178 != v175);
                        v178 = *(char **)(*(void *)a3 + 400);
LABEL_273:
                        while (*(void *)v177 != v174)
                        {
                          v177 += 8;
                          if (v177 == v175)
                          {
                            v177 = *(char **)(*(void *)a3 + 400);
                            break;
                          }
                        }
                      }
                      v169 += 48 * (v178 - v176 < v177 - v176);
                      if (v178 - v176 < v177 - v176) {
                        uint64_t v166 = v172;
                      }
                    }
                  }
                  long long v179 = *(_OWORD *)v169;
                  long long v180 = *(_OWORD *)(v169 + 16);
                  *(_OWORD *)((char *)v170 + 27) = *(_OWORD *)(v169 + 27);
                  _OWORD *v170 = v179;
                  v170[1] = v180;
                }
                while (v166 <= v168);
                a2 -= 3;
                if ((long long *)v169 == a2)
                {
                  *(_OWORD *)(v169 + 27) = *(_OWORD *)&v229[11];
                  *(_OWORD *)unint64_t v169 = v221;
                  *(_OWORD *)(v169 + 16) = *(_OWORD *)v229;
                }
                else
                {
                  long long v181 = *a2;
                  long long v182 = a2[1];
                  *(_OWORD *)(v169 + 27) = *(long long *)((char *)a2 + 27);
                  *(_OWORD *)unint64_t v169 = v181;
                  *(_OWORD *)(v169 + 16) = v182;
                  *(long long *)((char *)a2 + 27) = *(_OWORD *)&v229[11];
                  *a2 = v221;
                  a2[1] = *(_OWORD *)v229;
                  uint64_t v183 = v169 - v13 + 48;
                  if (v183 >= 49)
                  {
                    unint64_t v184 = (v183 / 0x30uLL - 2) >> 1;
                    unint64_t v185 = v13 + 48 * v184;
                    uint64_t v186 = *(void *)(v185 + 24);
                    uint64_t v187 = *(void *)(v169 + 24);
                    if (v186 != v187)
                    {
                      v189 = *(char **)(*(void *)a3 + 392);
                      v188 = *(char **)(*(void *)a3 + 400);
                      v190 = v189;
                      v191 = v189;
                      if (v189 != v188)
                      {
                        do
                        {
                          if (*(void *)v191 == v186) {
                            goto LABEL_286;
                          }
                          v191 += 8;
                        }
                        while (v191 != v188);
                        v191 = *(char **)(*(void *)a3 + 400);
LABEL_286:
                        while (*(void *)v190 != v187)
                        {
                          v190 += 8;
                          if (v190 == v188)
                          {
                            v190 = *(char **)(*(void *)a3 + 400);
                            break;
                          }
                        }
                      }
                      if (v191 - v189 < v190 - v189)
                      {
                        uint64_t v242 = *(void *)(v169 + 16);
                        long long v238 = *(_OWORD *)v169;
                        long long v233 = *(_OWORD *)(v169 + 32);
                        do
                        {
                          v192 = (_OWORD *)v169;
                          unint64_t v169 = v185;
                          long long v193 = *(_OWORD *)v185;
                          long long v194 = *(_OWORD *)(v185 + 16);
                          *(_OWORD *)((char *)v192 + 27) = *(_OWORD *)(v185 + 27);
                          _OWORD *v192 = v193;
                          v192[1] = v194;
                          if (!v184) {
                            break;
                          }
                          unint64_t v184 = (v184 - 1) >> 1;
                          unint64_t v185 = v13 + 48 * v184;
                          uint64_t v195 = *(void *)(v185 + 24);
                          if (v195 == v187) {
                            break;
                          }
                          v197 = *(char **)(*(void *)a3 + 392);
                          v196 = *(char **)(*(void *)a3 + 400);
                          v198 = v197;
                          v199 = v197;
                          if (v197 != v196)
                          {
                            do
                            {
                              if (*(void *)v199 == v195) {
                                goto LABEL_297;
                              }
                              v199 += 8;
                            }
                            while (v199 != v196);
                            v199 = *(char **)(*(void *)a3 + 400);
LABEL_297:
                            while (*(void *)v198 != v187)
                            {
                              v198 += 8;
                              if (v198 == v196)
                              {
                                v198 = *(char **)(*(void *)a3 + 400);
                                break;
                              }
                            }
                          }
                        }
                        while (v199 - v197 < v198 - v197);
                        *(_OWORD *)unint64_t v169 = v238;
                        *(void *)(v169 + 16) = v242;
                        *(void *)(v169 + 24) = v187;
                        *(void *)(v169 + 32) = v233;
                        *(_DWORD *)(v169 + 39) = *(_DWORD *)((char *)&v233 + 7);
                      }
                    }
                  }
                }
              }
              while (v165-- > 2);
            }
            return;
          }
          unint64_t v16 = v15 >> 1;
          double v17 = (long long *)(v13 + 48 * (v15 >> 1));
          if ((unint64_t)v14 >= 0x1801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48 * (v15 >> 1)), a2 - 3, a3);
            uint64_t v18 = 3 * v16;
            double v19 = (long long *)(a1 + 48 * v16 - 48);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>((long long *)(a1 + 48), v19, a2 - 6, a3);
            uint64_t v20 = (long long *)(a1 + 48 + 16 * v18);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>((long long *)(a1 + 96), v20, a2 - 9, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(v19, v17, v20, a3);
            *(_OWORD *)v223 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&v223[16] = *(_OWORD *)(a1 + 32);
            long long v216 = *(_OWORD *)a1;
            long long v21 = *(long long *)((char *)v17 + 27);
            long long v22 = v17[1];
            *(_OWORD *)a1 = *v17;
            *(_OWORD *)(a1 + 16) = v22;
            *(_OWORD *)(a1 + 27) = v21;
            *(long long *)((char *)v17 + 27) = *(_OWORD *)&v223[11];
            *double v17 = v216;
            v17[1] = *(_OWORD *)v223;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>((long long *)(a1 + 48 * (v15 >> 1)), (long long *)a1, a2 - 3, a3);
          }
          --a4;
          if (a5)
          {
            uint64_t v23 = *(void *)(a1 + 24);
            uint64_t v24 = *(void *)a3;
            break;
          }
          uint64_t v25 = *(void *)(a1 - 24);
          uint64_t v23 = *(void *)(a1 + 24);
          if (v25 != v23)
          {
            uint64_t v24 = *(void *)a3;
            double v26 = *(char **)(*(void *)a3 + 392);
            double v27 = *(char **)(*(void *)a3 + 400);
            double v28 = v26;
            double v29 = v26;
            if (v26 != v27)
            {
              do
              {
                if (*(void *)v29 == v25) {
                  goto LABEL_16;
                }
                v29 += 8;
              }
              while (v29 != v27);
              double v29 = *(char **)(*(void *)a3 + 400);
LABEL_16:
              while (*(void *)v28 != v23)
              {
                v28 += 8;
                if (v28 == v27)
                {
                  double v28 = *(char **)(*(void *)a3 + 400);
                  break;
                }
              }
            }
            if (v29 - v26 < v28 - v26) {
              break;
            }
          }
          uint64_t v241 = *(void *)(a1 + 16);
          long long v232 = *(_OWORD *)(a1 + 32);
          long long v235 = *(_OWORD *)a1;
          uint64_t v67 = *((void *)a2 - 3);
          if (v23 == v67) {
            goto LABEL_107;
          }
          unint64_t v68 = *(char **)(*(void *)a3 + 392);
          long long v69 = *(char **)(*(void *)a3 + 400);
          if (v68 == v69)
          {
            uint8x8_t v71 = *(char **)(*(void *)a3 + 392);
            long long v70 = v71;
          }
          else
          {
            long long v70 = *(char **)(*(void *)a3 + 392);
            while (*(void *)v70 != v23)
            {
              v70 += 8;
              if (v70 == v69)
              {
                long long v70 = *(char **)(*(void *)a3 + 400);
                break;
              }
            }
            uint8x8_t v71 = *(char **)(*(void *)a3 + 392);
            while (*(void *)v71 != v67)
            {
              v71 += 8;
              if (v71 == v69)
              {
                uint8x8_t v71 = *(char **)(*(void *)a3 + 400);
                break;
              }
            }
          }
          if (v70 - v68 >= v71 - v68)
          {
LABEL_107:
            unint64_t v13 = a1 + 48;
            if (a1 + 48 < (unint64_t)a2)
            {
              uint64_t v75 = *(void *)a3;
              unint64_t v76 = a1;
              do
              {
                uint64_t v77 = *(void *)(v76 + 72);
                unint64_t v76 = v13;
                if (v23 != v77)
                {
                  unint64_t v78 = *(char **)(v75 + 392);
                  long long v79 = *(char **)(v75 + 400);
                  BOOL v80 = v78;
                  unint64_t v81 = v78;
                  if (v78 != v79)
                  {
                    do
                    {
                      if (*(void *)v81 == v23) {
                        goto LABEL_114;
                      }
                      v81 += 8;
                    }
                    while (v81 != v79);
                    unint64_t v81 = *(char **)(v75 + 400);
LABEL_114:
                    while (*(void *)v80 != v77)
                    {
                      v80 += 8;
                      if (v80 == v79)
                      {
                        BOOL v80 = *(char **)(v75 + 400);
                        break;
                      }
                    }
                  }
                  if (v81 - v78 < v80 - v78) {
                    break;
                  }
                }
                v13 += 48;
              }
              while (v76 + 48 < (unint64_t)a2);
            }
          }
          else
          {
            unint64_t v13 = a1;
            do
            {
              do
              {
                uint64_t v72 = *(void *)(v13 + 72);
                v13 += 48;
              }
              while (v23 == v72);
              if (v68 == v69)
              {
                long long v74 = *(char **)(*(void *)a3 + 392);
                uint64_t v73 = v74;
              }
              else
              {
                uint64_t v73 = *(char **)(*(void *)a3 + 392);
                while (*(void *)v73 != v23)
                {
                  v73 += 8;
                  if (v73 == v69)
                  {
                    uint64_t v73 = *(char **)(*(void *)a3 + 400);
                    break;
                  }
                }
                long long v74 = *(char **)(*(void *)a3 + 392);
                while (*(void *)v74 != v72)
                {
                  v74 += 8;
                  if (v74 == v69)
                  {
                    long long v74 = *(char **)(*(void *)a3 + 400);
                    break;
                  }
                }
              }
            }
            while (v73 - v68 >= v74 - v68);
          }
          long long v82 = a2;
          if (v13 < (unint64_t)a2)
          {
            uint64_t v83 = *(void *)a3;
            long long v82 = a2;
            do
            {
              uint64_t v84 = *((void *)v82 - 3);
              v82 -= 3;
              if (v23 == v84) {
                break;
              }
              unint64_t v85 = *(char **)(v83 + 392);
              unint64_t v86 = *(char **)(v83 + 400);
              uint64_t v87 = v85;
              unint64_t v88 = v85;
              if (v85 != v86)
              {
                do
                {
                  if (*(void *)v88 == v23) {
                    goto LABEL_126;
                  }
                  v88 += 8;
                }
                while (v88 != v86);
                unint64_t v88 = *(char **)(v83 + 400);
LABEL_126:
                while (*(void *)v87 != v84)
                {
                  v87 += 8;
                  if (v87 == v86)
                  {
                    uint64_t v87 = *(char **)(v83 + 400);
                    break;
                  }
                }
              }
            }
            while (v88 - v85 < v87 - v85);
          }
          while (v13 < (unint64_t)v82)
          {
            *(_OWORD *)v225 = *(_OWORD *)(v13 + 16);
            *(_OWORD *)&v225[16] = *(_OWORD *)(v13 + 32);
            long long v217 = *(_OWORD *)v13;
            long long v89 = *v82;
            long long v90 = v82[1];
            *(_OWORD *)(v13 + 27) = *(long long *)((char *)v82 + 27);
            *(_OWORD *)unint64_t v13 = v89;
            *(_OWORD *)(v13 + 16) = v90;
            *(long long *)((char *)v82 + 27) = *(_OWORD *)&v225[11];
            *long long v82 = v217;
            v82[1] = *(_OWORD *)v225;
            uint64_t v91 = *(void *)a3;
            do
            {
              do
              {
                uint64_t v92 = *(void *)(v13 + 72);
                v13 += 48;
              }
              while (v23 == v92);
              uint64_t v93 = *(char **)(v91 + 392);
              uint64_t v94 = *(char **)(v91 + 400);
              if (v93 == v94)
              {
                int v96 = *(char **)(v91 + 392);
                BOOL v95 = v96;
              }
              else
              {
                BOOL v95 = *(char **)(v91 + 392);
                while (*(void *)v95 != v23)
                {
                  v95 += 8;
                  if (v95 == v94)
                  {
                    BOOL v95 = *(char **)(v91 + 400);
                    break;
                  }
                }
                int v96 = *(char **)(v91 + 392);
                while (*(void *)v96 != v92)
                {
                  v96 += 8;
                  if (v96 == v94)
                  {
                    int v96 = *(char **)(v91 + 400);
                    break;
                  }
                }
              }
            }
            while (v95 - v93 >= v96 - v93);
            do
            {
              uint64_t v97 = *((void *)v82 - 3);
              v82 -= 3;
              if (v23 == v97) {
                break;
              }
              if (v93 == v94)
              {
                int v99 = v93;
                uint64_t v98 = v93;
              }
              else
              {
                uint64_t v98 = v93;
                while (*(void *)v98 != v23)
                {
                  v98 += 8;
                  if (v98 == v94)
                  {
                    uint64_t v98 = v94;
                    break;
                  }
                }
                int v99 = v93;
                while (*(void *)v99 != v97)
                {
                  v99 += 8;
                  if (v99 == v94)
                  {
                    int v99 = v94;
                    break;
                  }
                }
              }
            }
            while (v98 - v93 < v99 - v93);
          }
          double v100 = (long long *)(v13 - 48);
          BOOL v5 = v13 - 48 >= a1;
          BOOL v6 = v13 - 48 == a1;
          if (v13 - 48 != a1)
          {
            long long v101 = *v100;
            long long v102 = *(_OWORD *)(v13 - 32);
            *(_OWORD *)(a1 + 27) = *(_OWORD *)(v13 - 21);
            *(_OWORD *)a1 = v101;
            *(_OWORD *)(a1 + 16) = v102;
          }
          a5 = 0;
          *double v100 = v235;
          *(void *)(v13 - 32) = v241;
          *(void *)(v13 - 24) = v23;
          *(_DWORD *)(v13 - 9) = *(_DWORD *)((char *)&v232 + 7);
          *(void *)(v13 - 16) = v232;
        }
        uint64_t v240 = *(void *)(a1 + 16);
        long long v231 = *(_OWORD *)(a1 + 32);
        long long v234 = *(_OWORD *)a1;
        unint64_t v30 = a1;
        do
        {
          unint64_t v31 = v30;
          v30 += 48;
          uint64_t v32 = *(void *)(v31 + 72);
          if (v32 == v23) {
            break;
          }
          double v33 = *(char **)(v24 + 392);
          long long v34 = *(char **)(v24 + 400);
          long long v35 = v33;
          long long v36 = v33;
          if (v33 != v34)
          {
            do
            {
              if (*(void *)v36 == v32) {
                goto LABEL_26;
              }
              v36 += 8;
            }
            while (v36 != v34);
            long long v36 = *(char **)(v24 + 400);
LABEL_26:
            while (*(void *)v35 != v23)
            {
              v35 += 8;
              if (v35 == v34)
              {
                long long v35 = *(char **)(v24 + 400);
                break;
              }
            }
          }
        }
        while (v36 - v33 < v35 - v33);
        unint64_t v37 = a2;
        if (v31 == a1)
        {
          unint64_t v37 = a2;
          if (v30 < (unint64_t)a2)
          {
            unint64_t v37 = a2;
            do
            {
              uint64_t v43 = *((void *)v37 - 3);
              v37 -= 3;
              if (v43 != v23)
              {
                uint64_t v44 = *(char **)(v24 + 392);
                long long v45 = *(char **)(v24 + 400);
                double v46 = v44;
                uint64_t v47 = v44;
                if (v44 != v45)
                {
                  do
                  {
                    if (*(void *)v47 == v43) {
                      goto LABEL_48;
                    }
                    v47 += 8;
                  }
                  while (v47 != v45);
                  uint64_t v47 = *(char **)(v24 + 400);
LABEL_48:
                  while (*(void *)v46 != v23)
                  {
                    v46 += 8;
                    if (v46 == v45)
                    {
                      double v46 = *(char **)(v24 + 400);
                      break;
                    }
                  }
                }
                if (v47 - v44 < v46 - v44) {
                  break;
                }
              }
            }
            while (v30 < (unint64_t)v37);
          }
        }
        else
        {
          do
          {
            do
            {
              uint64_t v38 = *((void *)v37 - 3);
              v37 -= 3;
            }
            while (v38 == v23);
            uint64_t v39 = *(char **)(v24 + 392);
            uint64_t v40 = *(char **)(v24 + 400);
            char v41 = v39;
            unint64_t v42 = v39;
            if (v39 != v40)
            {
              do
              {
                if (*(void *)v42 == v38) {
                  goto LABEL_36;
                }
                v42 += 8;
              }
              while (v42 != v40);
              unint64_t v42 = *(char **)(v24 + 400);
LABEL_36:
              while (*(void *)v41 != v23)
              {
                v41 += 8;
                if (v41 == v40)
                {
                  char v41 = *(char **)(v24 + 400);
                  break;
                }
              }
            }
          }
          while (v42 - v39 >= v41 - v39);
        }
        unint64_t v13 = v30;
        if (v30 < (unint64_t)v37)
        {
          int64_t v48 = v37;
          do
          {
            *(_OWORD *)v224 = *(_OWORD *)(v13 + 16);
            *(_OWORD *)&v224[16] = *(_OWORD *)(v13 + 32);
            long long v49 = *(_OWORD *)v13;
            long long v51 = *v48;
            long long v50 = v48[1];
            *(_OWORD *)(v13 + 27) = *(long long *)((char *)v48 + 27);
            *(_OWORD *)unint64_t v13 = v51;
            *(_OWORD *)(v13 + 16) = v50;
            *(long long *)((char *)v48 + 27) = *(_OWORD *)&v224[11];
            *int64_t v48 = v49;
            v48[1] = *(_OWORD *)v224;
            uint64_t v52 = *(void *)a3;
            do
            {
              uint64_t v53 = *(void *)(v13 + 72);
              v13 += 48;
              if (v53 == v23) {
                break;
              }
              uint64_t v54 = *(char **)(v52 + 392);
              unint64_t v55 = *(char **)(v52 + 400);
              unint64_t v56 = v54;
              long long v57 = v54;
              if (v54 != v55)
              {
                do
                {
                  if (*(void *)v57 == v53) {
                    goto LABEL_61;
                  }
                  v57 += 8;
                }
                while (v57 != v55);
                long long v57 = *(char **)(v52 + 400);
LABEL_61:
                while (*(void *)v56 != v23)
                {
                  v56 += 8;
                  if (v56 == v55)
                  {
                    unint64_t v56 = *(char **)(v52 + 400);
                    break;
                  }
                }
              }
            }
            while (v57 - v54 < v56 - v54);
            do
            {
              do
              {
                uint64_t v58 = *((void *)v48 - 3);
                v48 -= 3;
              }
              while (v58 == v23);
              float v59 = *(char **)(v52 + 392);
              unint64_t v60 = *(char **)(v52 + 400);
              unint64_t v61 = v59;
              unint64_t v62 = v59;
              if (v59 != v60)
              {
                do
                {
                  if (*(void *)v62 == v58) {
                    goto LABEL_70;
                  }
                  v62 += 8;
                }
                while (v62 != v60);
                unint64_t v62 = *(char **)(v52 + 400);
LABEL_70:
                while (*(void *)v61 != v23)
                {
                  v61 += 8;
                  if (v61 == v60)
                  {
                    unint64_t v61 = *(char **)(v52 + 400);
                    break;
                  }
                }
              }
            }
            while (v62 - v59 >= v61 - v59);
          }
          while (v13 < (unint64_t)v48);
        }
        unint64_t v63 = (long long *)(v13 - 48);
        if (v13 - 48 != a1)
        {
          long long v64 = *v63;
          long long v65 = *(_OWORD *)(v13 - 32);
          *(_OWORD *)(a1 + 27) = *(_OWORD *)(v13 - 21);
          *(_OWORD *)a1 = v64;
          *(_OWORD *)(a1 + 16) = v65;
        }
        long long *v63 = v234;
        *(void *)(v13 - 32) = v240;
        *(void *)(v13 - 24) = v23;
        *(_DWORD *)(v13 - 9) = *(_DWORD *)((char *)&v231 + 7);
        *(void *)(v13 - 16) = v231;
        if (v30 >= (unint64_t)v37) {
          break;
        }
LABEL_80:
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*,false>(a1, v13 - 48, a3, a4, a5 & 1);
        a5 = 0;
      }
      BOOL v66 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(a1, v13 - 48, a3);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(v13, (uint64_t)a2, a3))
      {
        break;
      }
      if (!v66) {
        goto LABEL_80;
      }
    }
    a2 = (long long *)(v13 - 48);
    if (!v66) {
      continue;
    }
    break;
  }
}

__n128 std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(long long *a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v4 = *((void *)a2 + 3);
  uint64_t v5 = *((void *)a1 + 3);
  if (v4 == v5) {
    goto LABEL_23;
  }
  BOOL v6 = *(char **)(*(void *)a4 + 392);
  uint64_t v7 = *(char **)(*(void *)a4 + 400);
  if (v6 == v7)
  {
    id v9 = *(char **)(*(void *)a4 + 392);
    uint64_t v8 = v9;
  }
  else
  {
    uint64_t v8 = *(char **)(*(void *)a4 + 392);
    while (*(void *)v8 != v4)
    {
      v8 += 8;
      if (v8 == v7)
      {
        uint64_t v8 = *(char **)(*(void *)a4 + 400);
        break;
      }
    }
    id v9 = *(char **)(*(void *)a4 + 392);
    while (*(void *)v9 != v5)
    {
      v9 += 8;
      if (v9 == v7)
      {
        id v9 = *(char **)(*(void *)a4 + 400);
        break;
      }
    }
  }
  if (v8 - v6 >= v9 - v6)
  {
LABEL_23:
    uint64_t v13 = *((void *)a3 + 3);
    if (v13 != v4)
    {
      uint64_t v14 = *(char **)(*(void *)a4 + 392);
      unint64_t v15 = *(char **)(*(void *)a4 + 400);
      unint64_t v16 = v14;
      double v17 = v14;
      if (v14 != v15)
      {
        do
        {
          if (*(void *)v17 == v13) {
            goto LABEL_28;
          }
          v17 += 8;
        }
        while (v17 != v15);
        double v17 = *(char **)(*(void *)a4 + 400);
LABEL_28:
        while (*(void *)v16 != v4)
        {
          v16 += 8;
          if (v16 == v15)
          {
            unint64_t v16 = *(char **)(*(void *)a4 + 400);
            break;
          }
        }
      }
      if (v17 - v14 < v16 - v14)
      {
        long long v18 = *a2;
        *(_OWORD *)double v46 = a2[1];
        *(_OWORD *)&v46[16] = a2[2];
        long long v19 = *(long long *)((char *)a3 + 27);
        long long v20 = a3[1];
        *a2 = *a3;
        a2[1] = v20;
        *(long long *)((char *)a2 + 27) = v19;
        *a3 = v18;
        a3[1] = *(_OWORD *)v46;
        __n128 result = *(__n128 *)&v46[11];
        *(long long *)((char *)a3 + 27) = *(_OWORD *)&v46[11];
        uint64_t v22 = *((void *)a2 + 3);
        uint64_t v23 = *((void *)a1 + 3);
        if (v22 != v23)
        {
          uint64_t v24 = *(char **)(*(void *)a4 + 392);
          uint64_t v25 = *(char **)(*(void *)a4 + 400);
          double v26 = v24;
          double v27 = v24;
          if (v24 != v25)
          {
            do
            {
              if (*(void *)v27 == v22) {
                goto LABEL_37;
              }
              v27 += 8;
            }
            while (v27 != v25);
            double v27 = *(char **)(*(void *)a4 + 400);
LABEL_37:
            while (*(void *)v26 != v23)
            {
              v26 += 8;
              if (v26 == v25)
              {
                double v26 = *(char **)(*(void *)a4 + 400);
                break;
              }
            }
          }
          if (v27 - v24 < v26 - v24)
          {
            long long v28 = *a1;
            *(_OWORD *)uint64_t v47 = a1[1];
            *(_OWORD *)&v47[16] = a1[2];
            long long v29 = *(long long *)((char *)a2 + 27);
            long long v30 = a2[1];
            *a1 = *a2;
            a1[1] = v30;
            *(long long *)((char *)a1 + 27) = v29;
            *a2 = v28;
            a2[1] = *(_OWORD *)v47;
            __n128 result = *(__n128 *)&v47[11];
            *(long long *)((char *)a2 + 27) = *(_OWORD *)&v47[11];
          }
        }
      }
    }
  }
  else
  {
    uint64_t v10 = *((void *)a3 + 3);
    if (v10 != v4)
    {
      if (v6 == v7)
      {
        unint64_t v12 = *(char **)(*(void *)a4 + 392);
        int64_t v11 = v12;
      }
      else
      {
        int64_t v11 = *(char **)(*(void *)a4 + 392);
        while (*(void *)v11 != v10)
        {
          v11 += 8;
          if (v11 == v7)
          {
            int64_t v11 = *(char **)(*(void *)a4 + 400);
            break;
          }
        }
        unint64_t v12 = *(char **)(*(void *)a4 + 392);
        while (*(void *)v12 != v4)
        {
          v12 += 8;
          if (v12 == v7)
          {
            unint64_t v12 = *(char **)(*(void *)a4 + 400);
            break;
          }
        }
      }
      if (v11 - v6 < v12 - v6)
      {
        long long v31 = a1[1];
        long long v32 = *a1;
        *(void *)long long v49 = *((void *)&v31 + 1);
        *(_OWORD *)&v49[8] = a1[2];
        long long v33 = *(long long *)((char *)a3 + 27);
        long long v34 = a3[1];
        *a1 = *a3;
        a1[1] = v34;
        *(long long *)((char *)a1 + 27) = v33;
LABEL_55:
        *a3 = v32;
        a3[1] = v31;
        __n128 result = *(__n128 *)&v49[3];
        *(long long *)((char *)a3 + 27) = *(_OWORD *)&v49[3];
        return result;
      }
    }
    long long v35 = *a1;
    *(_OWORD *)int64_t v48 = a1[1];
    *(_OWORD *)&v48[16] = a1[2];
    long long v36 = *(long long *)((char *)a2 + 27);
    long long v37 = a2[1];
    *a1 = *a2;
    a1[1] = v37;
    *(long long *)((char *)a1 + 27) = v36;
    *a2 = v35;
    a2[1] = *(_OWORD *)v48;
    __n128 result = *(__n128 *)&v48[11];
    *(long long *)((char *)a2 + 27) = *(_OWORD *)&v48[11];
    uint64_t v38 = *((void *)a3 + 3);
    uint64_t v39 = *((void *)a2 + 3);
    if (v38 != v39)
    {
      uint64_t v40 = *(char **)(*(void *)a4 + 392);
      char v41 = *(char **)(*(void *)a4 + 400);
      unint64_t v42 = v40;
      uint64_t v43 = v40;
      if (v40 != v41)
      {
        do
        {
          if (*(void *)v43 == v38) {
            goto LABEL_50;
          }
          v43 += 8;
        }
        while (v43 != v41);
        uint64_t v43 = *(char **)(*(void *)a4 + 400);
LABEL_50:
        while (*(void *)v42 != v39)
        {
          v42 += 8;
          if (v42 == v41)
          {
            unint64_t v42 = *(char **)(*(void *)a4 + 400);
            break;
          }
        }
      }
      if (v43 - v40 < v42 - v40)
      {
        long long v31 = a2[1];
        long long v32 = *a2;
        *(void *)long long v49 = *((void *)&v31 + 1);
        *(_OWORD *)&v49[8] = a2[2];
        long long v44 = *(long long *)((char *)a3 + 27);
        long long v45 = a3[1];
        *a2 = *a3;
        a2[1] = v45;
        *(long long *)((char *)a2 + 27) = v44;
        goto LABEL_55;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = *(void *)(a2 - 24);
      uint64_t v9 = *(void *)(a1 + 24);
      if (v8 == v9) {
        return result;
      }
      uint64_t v10 = *(char **)(*(void *)a3 + 392);
      int64_t v11 = *(char **)(*(void *)a3 + 400);
      unint64_t v12 = v10;
      uint64_t v13 = v10;
      if (v10 == v11) {
        goto LABEL_10;
      }
      do
      {
        if (*(void *)v13 == v8) {
          goto LABEL_7;
        }
        v13 += 8;
      }
      while (v13 != v11);
      uint64_t v13 = *(char **)(*(void *)a3 + 400);
      do
      {
LABEL_7:
        if (*(void *)v12 == v9) {
          goto LABEL_10;
        }
        v12 += 8;
      }
      while (v12 != v11);
      unint64_t v12 = *(char **)(*(void *)a3 + 400);
LABEL_10:
      if (v13 - v10 < v12 - v10)
      {
        uint64_t v14 = (long long *)(a2 - 48);
        long long v15 = *(_OWORD *)a1;
        *(_OWORD *)long long v35 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v35[16] = *(_OWORD *)(a1 + 32);
        long long v16 = *(_OWORD *)(a2 - 21);
        long long v17 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a1 + 16) = v17;
        *(_OWORD *)(a1 + 27) = v16;
        long long *v14 = v15;
        v14[1] = *(_OWORD *)v35;
        *(long long *)((char *)v14 + 27) = *(_OWORD *)&v35[11];
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a2 - 48), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a2 - 48, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a1 + 144, a2 - 48, a3);
      return 1;
    default:
      uint64_t v18 = a1 + 96;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a1 + 96), a3);
      uint64_t v19 = a1 + 144;
      if (a1 + 144 == a2) {
        return 1;
      }
      int v20 = 0;
      break;
  }
  while (1)
  {
    uint64_t v21 = *(void *)(v19 + 24);
    uint64_t v22 = *(void *)(v18 + 24);
    if (v21 != v22)
    {
      uint64_t v23 = *(char **)(*(void *)a3 + 392);
      uint64_t v24 = *(char **)(*(void *)a3 + 400);
      uint64_t v25 = v23;
      double v26 = v23;
      if (v23 != v24)
      {
        do
        {
          if (*(void *)v26 == v21) {
            goto LABEL_19;
          }
          v26 += 8;
        }
        while (v26 != v24);
        double v26 = *(char **)(*(void *)a3 + 400);
LABEL_19:
        while (*(void *)v25 != v22)
        {
          v25 += 8;
          if (v25 == v24)
          {
            uint64_t v25 = *(char **)(*(void *)a3 + 400);
            break;
          }
        }
      }
      if (v26 - v23 < v25 - v23)
      {
        long long v34 = *(_OWORD *)v19;
        uint64_t v36 = *(void *)(v19 + 16);
        long long v37 = *(_OWORD *)(v19 + 32);
        uint64_t v27 = v19;
        while (1)
        {
          long long v28 = *(_OWORD *)(v18 + 16);
          *(_OWORD *)uint64_t v27 = *(_OWORD *)v18;
          *(_OWORD *)(v27 + 16) = v28;
          *(_OWORD *)(v27 + 27) = *(_OWORD *)(v18 + 27);
          if (v18 == a1) {
            break;
          }
          uint64_t v27 = v18;
          uint64_t v29 = *(void *)(v18 - 24);
          if (v21 != v29)
          {
            long long v30 = *(char **)(*(void *)a3 + 392);
            long long v31 = *(char **)(*(void *)a3 + 400);
            long long v32 = v30;
            long long v33 = v30;
            if (v30 != v31)
            {
              do
              {
                if (*(void *)v33 == v21) {
                  goto LABEL_30;
                }
                v33 += 8;
              }
              while (v33 != v31);
              long long v33 = *(char **)(*(void *)a3 + 400);
LABEL_30:
              while (*(void *)v32 != v29)
              {
                v32 += 8;
                if (v32 == v31)
                {
                  long long v32 = *(char **)(*(void *)a3 + 400);
                  break;
                }
              }
            }
            v18 -= 48;
            if (v33 - v30 < v32 - v30) {
              continue;
            }
          }
          goto LABEL_36;
        }
        uint64_t v27 = a1;
LABEL_36:
        *(_OWORD *)uint64_t v27 = v34;
        *(void *)(v27 + 16) = v36;
        *(void *)(v27 + 24) = v21;
        *(void *)(v27 + 32) = v37;
        *(_DWORD *)(v27 + 39) = *(_DWORD *)((char *)&v37 + 7);
        if (++v20 == 8) {
          return v19 + 48 == a2;
        }
      }
    }
    uint64_t v18 = v19;
    v19 += 48;
    if (v19 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  result.n128_u64[0] = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>((long long *)a1, (long long *)a2, (long long *)a3, a5).n128_u64[0];
  uint64_t v11 = *(void *)(a4 + 24);
  uint64_t v12 = *(void *)(a3 + 24);
  if (v11 != v12)
  {
    uint64_t v13 = *(char **)(*(void *)a5 + 392);
    uint64_t v14 = *(char **)(*(void *)a5 + 400);
    long long v15 = v13;
    long long v16 = v13;
    if (v13 != v14)
    {
      do
      {
        if (*(void *)v16 == v11) {
          goto LABEL_6;
        }
        v16 += 8;
      }
      while (v16 != v14);
      long long v16 = *(char **)(*(void *)a5 + 400);
LABEL_6:
      while (*(void *)v15 != v12)
      {
        v15 += 8;
        if (v15 == v14)
        {
          long long v15 = *(char **)(*(void *)a5 + 400);
          break;
        }
      }
    }
    if (v16 - v13 < v15 - v13)
    {
      long long v17 = *(_OWORD *)a3;
      *(_OWORD *)uint64_t v38 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)&v38[16] = *(_OWORD *)(a3 + 32);
      long long v18 = *(_OWORD *)(a4 + 27);
      long long v19 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)(a3 + 16) = v19;
      *(_OWORD *)(a3 + 27) = v18;
      *(_OWORD *)a4 = v17;
      *(_OWORD *)(a4 + 16) = *(_OWORD *)v38;
      __n128 result = *(__n128 *)&v38[11];
      *(_OWORD *)(a4 + 27) = *(_OWORD *)&v38[11];
      uint64_t v20 = *(void *)(a3 + 24);
      uint64_t v21 = *(void *)(a2 + 24);
      if (v20 != v21)
      {
        uint64_t v22 = *(char **)(*(void *)a5 + 392);
        uint64_t v23 = *(char **)(*(void *)a5 + 400);
        uint64_t v24 = v22;
        uint64_t v25 = v22;
        if (v22 != v23)
        {
          do
          {
            if (*(void *)v25 == v20) {
              goto LABEL_15;
            }
            v25 += 8;
          }
          while (v25 != v23);
          uint64_t v25 = *(char **)(*(void *)a5 + 400);
LABEL_15:
          while (*(void *)v24 != v21)
          {
            v24 += 8;
            if (v24 == v23)
            {
              uint64_t v24 = *(char **)(*(void *)a5 + 400);
              break;
            }
          }
        }
        if (v25 - v22 < v24 - v22)
        {
          long long v26 = *(_OWORD *)a2;
          *(_OWORD *)uint64_t v39 = *(_OWORD *)(a2 + 16);
          *(_OWORD *)&v39[16] = *(_OWORD *)(a2 + 32);
          long long v27 = *(_OWORD *)(a3 + 27);
          long long v28 = *(_OWORD *)(a3 + 16);
          *(_OWORD *)a2 = *(_OWORD *)a3;
          *(_OWORD *)(a2 + 16) = v28;
          *(_OWORD *)(a2 + 27) = v27;
          *(_OWORD *)a3 = v26;
          *(_OWORD *)(a3 + 16) = *(_OWORD *)v39;
          __n128 result = *(__n128 *)&v39[11];
          *(_OWORD *)(a3 + 27) = *(_OWORD *)&v39[11];
          uint64_t v29 = *(void *)(a2 + 24);
          uint64_t v30 = *(void *)(a1 + 24);
          if (v29 != v30)
          {
            long long v31 = *(char **)(*(void *)a5 + 392);
            long long v32 = *(char **)(*(void *)a5 + 400);
            long long v33 = v31;
            long long v34 = v31;
            if (v31 != v32)
            {
              do
              {
                if (*(void *)v34 == v29) {
                  goto LABEL_24;
                }
                v34 += 8;
              }
              while (v34 != v32);
              long long v34 = *(char **)(*(void *)a5 + 400);
LABEL_24:
              while (*(void *)v33 != v30)
              {
                v33 += 8;
                if (v33 == v32)
                {
                  long long v33 = *(char **)(*(void *)a5 + 400);
                  break;
                }
              }
            }
            if (v34 - v31 < v33 - v31)
            {
              long long v35 = *(_OWORD *)a1;
              *(_OWORD *)uint64_t v40 = *(_OWORD *)(a1 + 16);
              *(_OWORD *)&v40[16] = *(_OWORD *)(a1 + 32);
              long long v36 = *(_OWORD *)(a2 + 27);
              long long v37 = *(_OWORD *)(a2 + 16);
              *(_OWORD *)a1 = *(_OWORD *)a2;
              *(_OWORD *)(a1 + 16) = v37;
              *(_OWORD *)(a1 + 27) = v36;
              *(_OWORD *)a2 = v35;
              *(_OWORD *)(a2 + 16) = *(_OWORD *)v40;
              __n128 result = *(__n128 *)&v40[11];
              *(_OWORD *)(a2 + 27) = *(_OWORD *)&v40[11];
            }
          }
        }
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  result.n128_u64[0] = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(a1, a2, a3, a4, a6).n128_u64[0];
  uint64_t v13 = *(void *)(a5 + 24);
  uint64_t v14 = *(void *)(a4 + 24);
  if (v13 != v14)
  {
    long long v15 = *(char **)(*(void *)a6 + 392);
    long long v16 = *(char **)(*(void *)a6 + 400);
    long long v17 = v15;
    long long v18 = v15;
    if (v15 != v16)
    {
      do
      {
        if (*(void *)v18 == v13) {
          goto LABEL_6;
        }
        v18 += 8;
      }
      while (v18 != v16);
      long long v18 = *(char **)(*(void *)a6 + 400);
LABEL_6:
      while (*(void *)v17 != v14)
      {
        v17 += 8;
        if (v17 == v16)
        {
          long long v17 = *(char **)(*(void *)a6 + 400);
          break;
        }
      }
    }
    if (v18 - v15 < v17 - v15)
    {
      long long v19 = *(_OWORD *)a4;
      *(_OWORD *)long long v49 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)&v49[16] = *(_OWORD *)(a4 + 32);
      long long v20 = *(_OWORD *)(a5 + 27);
      long long v21 = *(_OWORD *)(a5 + 16);
      *(_OWORD *)a4 = *(_OWORD *)a5;
      *(_OWORD *)(a4 + 16) = v21;
      *(_OWORD *)(a4 + 27) = v20;
      *(_OWORD *)a5 = v19;
      *(_OWORD *)(a5 + 16) = *(_OWORD *)v49;
      __n128 result = *(__n128 *)&v49[11];
      *(_OWORD *)(a5 + 27) = *(_OWORD *)&v49[11];
      uint64_t v22 = *(void *)(a4 + 24);
      uint64_t v23 = *(void *)(a3 + 24);
      if (v22 != v23)
      {
        uint64_t v24 = *(char **)(*(void *)a6 + 392);
        uint64_t v25 = *(char **)(*(void *)a6 + 400);
        long long v26 = v24;
        long long v27 = v24;
        if (v24 != v25)
        {
          do
          {
            if (*(void *)v27 == v22) {
              goto LABEL_15;
            }
            v27 += 8;
          }
          while (v27 != v25);
          long long v27 = *(char **)(*(void *)a6 + 400);
LABEL_15:
          while (*(void *)v26 != v23)
          {
            v26 += 8;
            if (v26 == v25)
            {
              long long v26 = *(char **)(*(void *)a6 + 400);
              break;
            }
          }
        }
        if (v27 - v24 < v26 - v24)
        {
          long long v28 = *(_OWORD *)a3;
          *(_OWORD *)long long v50 = *(_OWORD *)(a3 + 16);
          *(_OWORD *)&v50[16] = *(_OWORD *)(a3 + 32);
          long long v29 = *(_OWORD *)(a4 + 27);
          long long v30 = *(_OWORD *)(a4 + 16);
          *(_OWORD *)a3 = *(_OWORD *)a4;
          *(_OWORD *)(a3 + 16) = v30;
          *(_OWORD *)(a3 + 27) = v29;
          *(_OWORD *)a4 = v28;
          *(_OWORD *)(a4 + 16) = *(_OWORD *)v50;
          __n128 result = *(__n128 *)&v50[11];
          *(_OWORD *)(a4 + 27) = *(_OWORD *)&v50[11];
          uint64_t v31 = *(void *)(a3 + 24);
          uint64_t v32 = *(void *)(a2 + 24);
          if (v31 != v32)
          {
            long long v33 = *(char **)(*(void *)a6 + 392);
            long long v34 = *(char **)(*(void *)a6 + 400);
            long long v35 = v33;
            long long v36 = v33;
            if (v33 != v34)
            {
              do
              {
                if (*(void *)v36 == v31) {
                  goto LABEL_24;
                }
                v36 += 8;
              }
              while (v36 != v34);
              long long v36 = *(char **)(*(void *)a6 + 400);
LABEL_24:
              while (*(void *)v35 != v32)
              {
                v35 += 8;
                if (v35 == v34)
                {
                  long long v35 = *(char **)(*(void *)a6 + 400);
                  break;
                }
              }
            }
            if (v36 - v33 < v35 - v33)
            {
              long long v37 = *(_OWORD *)a2;
              *(_OWORD *)long long v51 = *(_OWORD *)(a2 + 16);
              *(_OWORD *)&v51[16] = *(_OWORD *)(a2 + 32);
              long long v38 = *(_OWORD *)(a3 + 27);
              long long v39 = *(_OWORD *)(a3 + 16);
              *(_OWORD *)a2 = *(_OWORD *)a3;
              *(_OWORD *)(a2 + 16) = v39;
              *(_OWORD *)(a2 + 27) = v38;
              *(_OWORD *)a3 = v37;
              *(_OWORD *)(a3 + 16) = *(_OWORD *)v51;
              __n128 result = *(__n128 *)&v51[11];
              *(_OWORD *)(a3 + 27) = *(_OWORD *)&v51[11];
              uint64_t v40 = *(void *)(a2 + 24);
              uint64_t v41 = *(void *)(a1 + 24);
              if (v40 != v41)
              {
                unint64_t v42 = *(char **)(*(void *)a6 + 392);
                uint64_t v43 = *(char **)(*(void *)a6 + 400);
                long long v44 = v42;
                long long v45 = v42;
                if (v42 != v43)
                {
                  do
                  {
                    if (*(void *)v45 == v40) {
                      goto LABEL_33;
                    }
                    v45 += 8;
                  }
                  while (v45 != v43);
                  long long v45 = *(char **)(*(void *)a6 + 400);
LABEL_33:
                  while (*(void *)v44 != v41)
                  {
                    v44 += 8;
                    if (v44 == v43)
                    {
                      long long v44 = *(char **)(*(void *)a6 + 400);
                      break;
                    }
                  }
                }
                if (v45 - v42 < v44 - v42)
                {
                  long long v46 = *(_OWORD *)a1;
                  *(_OWORD *)uint64_t v52 = *(_OWORD *)(a1 + 16);
                  *(_OWORD *)&v52[16] = *(_OWORD *)(a1 + 32);
                  long long v47 = *(_OWORD *)(a2 + 27);
                  long long v48 = *(_OWORD *)(a2 + 16);
                  *(_OWORD *)a1 = *(_OWORD *)a2;
                  *(_OWORD *)(a1 + 16) = v48;
                  *(_OWORD *)(a1 + 27) = v47;
                  *(_OWORD *)a2 = v46;
                  *(_OWORD *)(a2 + 16) = *(_OWORD *)v52;
                  __n128 result = *(__n128 *)&v52[11];
                  *(_OWORD *)(a2 + 27) = *(_OWORD *)&v52[11];
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*,false>(unint64_t a1, long long *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 4);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*((double *)a2 - 5) < *(double *)(v10 + 8))
                {
                  *(_OWORD *)char v118 = *(_OWORD *)(v10 + 16);
                  *(_OWORD *)&v118[16] = *(_OWORD *)(v10 + 32);
                  long long v110 = *(_OWORD *)v10;
                  long long v52 = *(a2 - 3);
                  long long v53 = *(a2 - 2);
                  *(_OWORD *)(v10 + 27) = *(long long *)((char *)a2 - 21);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 16) = v53;
                  *(long long *)((char *)a2 - 21) = *(_OWORD *)&v118[11];
                  *(a2 - 3) = v110;
                  *(a2 - 2) = *(_OWORD *)v118;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)v10, (long long *)(v10 + 48), a2 - 3);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v10, v10 + 48, v10 + 96, (uint64_t)(a2 - 3));
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v10, v10 + 48, v10 + 96, v10 + 144, (uint64_t)(a2 - 3));
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 1151)
          {
            uint64_t v54 = (long long *)(v10 + 48);
            BOOL v56 = (long long *)v10 == a2 || v54 == a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  float v59 = v54;
                  double v60 = *(double *)(v58 + 56);
                  if (v60 < *(double *)(v58 + 8))
                  {
                    uint64_t v61 = *(void *)v54;
                    *(_OWORD *)uint64_t v111 = *(_OWORD *)(v58 + 64);
                    *(_OWORD *)&v111[16] = *(_OWORD *)(v58 + 80);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      unint64_t v63 = (_OWORD *)(v10 + v62);
                      long long v64 = *(_OWORD *)(v10 + v62 + 16);
                      v63[3] = *(_OWORD *)(v10 + v62);
                      v63[4] = v64;
                      *(_OWORD *)((char *)v63 + 75) = *(_OWORD *)(v10 + v62 + 27);
                      if (!v62) {
                        break;
                      }
                      v62 -= 48;
                      if (v60 >= *((double *)v63 - 5))
                      {
                        uint64_t v65 = v10 + v62 + 48;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_81:
                    *(void *)uint64_t v65 = v61;
                    *(double *)(v65 + 8) = v60;
                    *(_OWORD *)(v65 + 16) = *(_OWORD *)v111;
                    *(_OWORD *)(v65 + 27) = *(_OWORD *)&v111[11];
                  }
                  uint64_t v54 = v59 + 3;
                  v57 += 48;
                  unint64_t v58 = (unint64_t)v59;
                }
                while (v59 + 3 != a2);
              }
            }
            else if (!v56)
            {
              do
              {
                uint64_t v98 = v54;
                double v99 = *(double *)(a1 + 56);
                if (v99 < *(double *)(a1 + 8))
                {
                  uint64_t v100 = *(void *)v54;
                  *(_OWORD *)unint64_t v114 = *(_OWORD *)(a1 + 64);
                  *(_OWORD *)&v114[16] = *(_OWORD *)(a1 + 80);
                  long long v101 = v54;
                  do
                  {
                    long long v102 = *(v101 - 2);
                    long long *v101 = *(v101 - 3);
                    v101[1] = v102;
                    *(long long *)((char *)v101 + 27) = *(long long *)((char *)v101 - 21);
                    double v103 = *((double *)v101 - 11);
                    v101 -= 3;
                  }
                  while (v99 < v103);
                  *(void *)long long v101 = v100;
                  *((double *)v101 + 1) = v99;
                  *(long long *)((char *)v101 + 27) = *(_OWORD *)&v114[11];
                  v101[1] = *(_OWORD *)v114;
                }
                v54 += 3;
                a1 = (unint64_t)v98;
              }
              while (v98 + 3 != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((long long *)v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 48 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)(v70 + 8) < *(double *)(v70 + 56))
                  {
                    v70 += 48;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  unint64_t v71 = v10 + 48 * v68;
                  double v72 = *(double *)(v71 + 8);
                  if (*(double *)(v70 + 8) >= v72)
                  {
                    uint64_t v73 = *(void *)v71;
                    *(_OWORD *)unint64_t v112 = *(_OWORD *)(v71 + 16);
                    *(_OWORD *)&v112[16] = *(_OWORD *)(v71 + 32);
                    do
                    {
                      long long v74 = (_OWORD *)v71;
                      unint64_t v71 = v70;
                      long long v75 = *(_OWORD *)v70;
                      long long v76 = *(_OWORD *)(v70 + 16);
                      *(_OWORD *)((char *)v74 + 27) = *(_OWORD *)(v70 + 27);
                      *long long v74 = v75;
                      v74[1] = v76;
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v77 = 2 * v69;
                      uint64_t v69 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 48 * v69;
                      uint64_t v78 = v77 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v70 + 8) < *(double *)(v70 + 56))
                      {
                        v70 += 48;
                        uint64_t v69 = v78;
                      }
                    }
                    while (*(double *)(v70 + 8) >= v72);
                    *(void *)unint64_t v71 = v73;
                    *(double *)(v71 + 8) = v72;
                    *(_OWORD *)(v71 + 16) = *(_OWORD *)v112;
                    *(_OWORD *)(v71 + 27) = *(_OWORD *)&v112[11];
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              int64_t v79 = v11 / 0x30uLL;
              do
              {
                uint64_t v80 = 0;
                *(_OWORD *)BOOL v119 = *(_OWORD *)(v10 + 16);
                *(_OWORD *)&v119[16] = *(_OWORD *)(v10 + 32);
                long long v113 = *(_OWORD *)v10;
                unint64_t v81 = v10;
                do
                {
                  long long v82 = (_OWORD *)v81;
                  v81 += 48 * v80 + 48;
                  uint64_t v83 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  int64_t v84 = v83 + 2;
                  if (v84 < v79 && *(double *)(v81 + 8) < *(double *)(v81 + 56))
                  {
                    v81 += 48;
                    uint64_t v80 = v84;
                  }
                  long long v85 = *(_OWORD *)v81;
                  long long v86 = *(_OWORD *)(v81 + 16);
                  *(_OWORD *)((char *)v82 + 27) = *(_OWORD *)(v81 + 27);
                  *long long v82 = v85;
                  v82[1] = v86;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 3;
                if ((long long *)v81 == a2)
                {
                  *(_OWORD *)(v81 + 27) = *(_OWORD *)&v119[11];
                  *(_OWORD *)unint64_t v81 = v113;
                  *(_OWORD *)(v81 + 16) = *(_OWORD *)v119;
                }
                else
                {
                  long long v87 = *a2;
                  long long v88 = a2[1];
                  *(_OWORD *)(v81 + 27) = *(long long *)((char *)a2 + 27);
                  *(_OWORD *)unint64_t v81 = v87;
                  *(_OWORD *)(v81 + 16) = v88;
                  *(long long *)((char *)a2 + 27) = *(_OWORD *)&v119[11];
                  *a2 = v113;
                  a2[1] = *(_OWORD *)v119;
                  uint64_t v89 = v81 - v10 + 48;
                  if (v89 >= 49)
                  {
                    unint64_t v90 = (v89 / 0x30uLL - 2) >> 1;
                    unint64_t v91 = v10 + 48 * v90;
                    double v92 = *(double *)(v81 + 8);
                    if (*(double *)(v91 + 8) < v92)
                    {
                      uint64_t v93 = *(void *)v81;
                      *(_OWORD *)long long v106 = *(_OWORD *)(v81 + 16);
                      *(_OWORD *)&v106[16] = *(_OWORD *)(v81 + 32);
                      do
                      {
                        uint64_t v94 = (_OWORD *)v81;
                        unint64_t v81 = v91;
                        long long v95 = *(_OWORD *)v91;
                        long long v96 = *(_OWORD *)(v91 + 16);
                        *(_OWORD *)((char *)v94 + 27) = *(_OWORD *)(v91 + 27);
                        *uint64_t v94 = v95;
                        v94[1] = v96;
                        if (!v90) {
                          break;
                        }
                        unint64_t v90 = (v90 - 1) >> 1;
                        unint64_t v91 = v10 + 48 * v90;
                      }
                      while (*(double *)(v91 + 8) < v92);
                      *(void *)unint64_t v81 = v93;
                      *(double *)(v81 + 8) = v92;
                      *(_OWORD *)(v81 + 16) = *(_OWORD *)v106;
                      *(_OWORD *)(v81 + 27) = *(_OWORD *)&v106[11];
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (long long *)(v10 + 48 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x1801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48 * (v12 >> 1)), a2 - 3);
            uint64_t v15 = 3 * v13;
            long long v16 = (long long *)(a1 + 48 * v13 - 48);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48), v16, a2 - 6);
            long long v17 = (long long *)(a1 + 48 + 16 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 96), v17, a2 - 9);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v16, v14, v17);
            *(_OWORD *)unint64_t v115 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&v115[16] = *(_OWORD *)(a1 + 32);
            long long v107 = *(_OWORD *)a1;
            long long v18 = *(long long *)((char *)v14 + 27);
            long long v19 = v14[1];
            *(_OWORD *)a1 = *v14;
            *(_OWORD *)(a1 + 16) = v19;
            *(_OWORD *)(a1 + 27) = v18;
            *(long long *)((char *)v14 + 27) = *(_OWORD *)&v115[11];
            long long *v14 = v107;
            v14[1] = *(_OWORD *)v115;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48 * (v12 >> 1)), (long long *)a1, a2 - 3);
          }
          --a3;
          if (a4) {
            break;
          }
          double v20 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 40) < v20) {
            goto LABEL_12;
          }
          uint64_t v38 = *(void *)a1;
          *(_OWORD *)int v105 = *(_OWORD *)(a1 + 16);
          *(_OWORD *)&v105[16] = *(_OWORD *)(a1 + 32);
          if (v20 >= *((double *)a2 - 5))
          {
            unint64_t v41 = a1 + 48;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= (unint64_t)a2) {
                break;
              }
              double v42 = *(double *)(v41 + 8);
              v41 += 48;
            }
            while (v20 >= v42);
          }
          else
          {
            unint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 48;
              double v40 = *(double *)(v39 + 56);
              v39 += 48;
            }
            while (v20 >= v40);
          }
          uint64_t v43 = a2;
          if (v10 < (unint64_t)a2)
          {
            long long v44 = a2;
            do
            {
              uint64_t v43 = v44 - 3;
              double v45 = *((double *)v44 - 5);
              v44 -= 3;
            }
            while (v20 < v45);
          }
          while (v10 < (unint64_t)v43)
          {
            *(_OWORD *)uint64_t v117 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)&v117[16] = *(_OWORD *)(v10 + 32);
            long long v109 = *(_OWORD *)v10;
            long long v46 = *v43;
            long long v47 = v43[1];
            *(_OWORD *)(v10 + 27) = *(long long *)((char *)v43 + 27);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(long long *)((char *)v43 + 27) = *(_OWORD *)&v117[11];
            long long *v43 = v109;
            v43[1] = *(_OWORD *)v117;
            do
            {
              double v48 = *(double *)(v10 + 56);
              v10 += 48;
            }
            while (v20 >= v48);
            do
            {
              double v49 = *((double *)v43 - 5);
              v43 -= 3;
            }
            while (v20 < v49);
          }
          BOOL v4 = v10 - 48 >= a1;
          BOOL v5 = v10 - 48 == a1;
          if (v10 - 48 != a1)
          {
            long long v50 = *(_OWORD *)(v10 - 48);
            long long v51 = *(_OWORD *)(v10 - 32);
            *(_OWORD *)(a1 + 27) = *(_OWORD *)(v10 - 21);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 16) = v51;
          }
          a4 = 0;
          *(void *)(v10 - 48) = v38;
          *(double *)(v10 - 40) = v20;
          *(_OWORD *)(v10 - 21) = *(_OWORD *)&v105[11];
          *(_OWORD *)(v10 - 32) = *(_OWORD *)v105;
        }
        double v20 = *(double *)(a1 + 8);
LABEL_12:
        uint64_t v21 = 0;
        uint64_t v22 = *(void *)a1;
        *(_OWORD *)uint64_t v104 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v104[16] = *(_OWORD *)(a1 + 32);
        do
        {
          double v23 = *(double *)(a1 + v21 + 56);
          v21 += 48;
        }
        while (v23 < v20);
        unint64_t v24 = a1 + v21;
        uint64_t v25 = a2;
        if (v21 == 48)
        {
          long long v28 = a2;
          while (v24 < (unint64_t)v28)
          {
            long long v26 = v28 - 3;
            double v29 = *((double *)v28 - 5);
            v28 -= 3;
            if (v29 < v20) {
              goto LABEL_22;
            }
          }
          long long v26 = v28;
        }
        else
        {
          do
          {
            long long v26 = v25 - 3;
            double v27 = *((double *)v25 - 5);
            v25 -= 3;
          }
          while (v27 >= v20);
        }
LABEL_22:
        unint64_t v10 = v24;
        if (v24 < (unint64_t)v26)
        {
          long long v30 = v26;
          do
          {
            *(_OWORD *)uint64_t v116 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)&v116[16] = *(_OWORD *)(v10 + 32);
            long long v108 = *(_OWORD *)v10;
            long long v31 = *v30;
            long long v32 = v30[1];
            *(_OWORD *)(v10 + 27) = *(long long *)((char *)v30 + 27);
            *(_OWORD *)unint64_t v10 = v31;
            *(_OWORD *)(v10 + 16) = v32;
            *(long long *)((char *)v30 + 27) = *(_OWORD *)&v116[11];
            long long *v30 = v108;
            v30[1] = *(_OWORD *)v116;
            do
            {
              double v33 = *(double *)(v10 + 56);
              v10 += 48;
            }
            while (v33 < v20);
            do
            {
              double v34 = *((double *)v30 - 5);
              v30 -= 3;
            }
            while (v34 >= v20);
          }
          while (v10 < (unint64_t)v30);
        }
        if (v10 - 48 != a1)
        {
          long long v35 = *(_OWORD *)(v10 - 48);
          long long v36 = *(_OWORD *)(v10 - 32);
          *(_OWORD *)(a1 + 27) = *(_OWORD *)(v10 - 21);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
        }
        *(void *)(v10 - 48) = v22;
        *(double *)(v10 - 40) = v20;
        *(_OWORD *)(v10 - 21) = *(_OWORD *)&v104[11];
        *(_OWORD *)(v10 - 32) = *(_OWORD *)v104;
        if (v24 >= (unint64_t)v26) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*,false>(a1, v10 - 48, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(a1, v10 - 48);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_33;
      }
    }
    a2 = (long long *)(v10 - 48);
    if (!v37) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_SampleRemainder*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 40) < *(double *)(a1 + 8))
      {
        long long v6 = *(_OWORD *)a1;
        *(_OWORD *)double v20 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v20[16] = *(_OWORD *)(a1 + 32);
        long long v7 = *(_OWORD *)(a2 - 21);
        long long v8 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a1 + 16) = v8;
        *(_OWORD *)(a1 + 27) = v7;
        *(_OWORD *)(a2 - 48) = v6;
        *(_OWORD *)(a2 - 32) = *(_OWORD *)v20;
        *(_OWORD *)(a2 - 21) = *(_OWORD *)&v20[11];
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a2 - 48));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a2 - 48);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a1 + 144, a2 - 48);
      return 1;
    default:
      uint64_t v9 = a1 + 96;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a1 + 96));
      uint64_t v10 = a1 + 144;
      if (a1 + 144 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    double v13 = *(double *)(v10 + 8);
    if (v13 < *(double *)(v9 + 8))
    {
      uint64_t v14 = *(void *)v10;
      *(_OWORD *)long long v19 = *(_OWORD *)(v10 + 16);
      *(_OWORD *)&v19[16] = *(_OWORD *)(v10 + 32);
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        long long v17 = *(_OWORD *)(a1 + v15 + 112);
        *(_OWORD *)(v16 + 144) = *(_OWORD *)(a1 + v15 + 96);
        *(_OWORD *)(v16 + 160) = v17;
        *(_OWORD *)(v16 + 171) = *(_OWORD *)(a1 + v15 + 123);
        if (v15 == -96) {
          break;
        }
        v15 -= 48;
        if (v13 >= *(double *)(v16 + 56))
        {
          uint64_t v18 = a1 + v15 + 144;
          goto LABEL_12;
        }
      }
      uint64_t v18 = a1;
LABEL_12:
      *(void *)uint64_t v18 = v14;
      *(double *)(v18 + 8) = v13;
      *(_OWORD *)(v18 + 16) = *(_OWORD *)v19;
      *(_OWORD *)(v18 + 27) = *(_OWORD *)&v19[11];
      if (++v12 == 8) {
        return v10 + 48 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 48;
    v10 += 48;
    if (v10 == a2) {
      return 1;
    }
  }
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsSleepStages> const&)>::~__func()
{
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsSleepStages> const&)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F1726D50;
  return result;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsSleepStages> const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1726D50;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsSleepStages> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return a2 + 8;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsSleepStages> const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>> const&)::{lambda(HDStatisticsRelative<HDStatisticsSleepStages> const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsSleepStages> const&)>::target_type()
{
}

void *std::__function::__value_func<HDStatisticsSleepStages const& ()(HDStatisticsRelative<HDStatisticsSleepStages> const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveAddSample(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 688))
  {
    if ((a3 & 1) == 0)
    {
      objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a4, 3, @"Cannot configure statistics collection calculator engine with a sample if we cannot merge up to the sample's start date");
      return 0;
    }
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_configureForStartTime(a1);
  }
  double v8 = *(double *)(a2 + 8);
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9)
  {
    if (*(unsigned char *)(a1 + 688))
    {
      double v10 = -1.79769313e308;
    }
    else
    {
      double v10 = *(double *)(a1 + 176);
      double v12 = *(double *)(a1 + 120);
      if (v10 <= v12) {
        double v10 = -1.79769313e308;
      }
      if (v10 < v12) {
        double v10 = *(double *)(a1 + 120);
      }
    }
  }
  else
  {
    double v10 = *(double *)(a1 + 176);
    if (v10 <= *(double *)(a1 + 120)) {
      double v10 = -1.79769313e308;
    }
  }
  if (v10 <= v8)
  {
    if (v9 && a3) {
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_advanceToTime(a1, v8);
    }
    HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::addSample(a1 + 112, a2, a3);
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_notifyForCurrentBucket(a1);
    return 1;
  }
  else
  {
    double v13 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:");
    uint64_t v11 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v13, a4);
  }
  return v11;
}

void sub_1BD18D7A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_advanceToTime(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 128) <= a2)
  {
    uint64_t v4 = a1 + 112;
    BOOL v5 = (double *)(a1 + 120);
    do
    {
      uint64_t v6 = *(void *)(a1 + 664);
      uint64_t v7 = *(void *)(a1 + 656);
      if (v6 == v7)
      {
        uint64_t v22 = 0;
        uint64_t v15 = *(void **)(a1 + 40);
        uint64_t v16 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:a2];
        double v8 = [v15 dateIntervalContainingDate:v16 index:&v22];

        HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_updateSourceOrder((uint64_t)v5);
        HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeThroughTime((uint64_t)v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsFromFinishedBucket(a1, v5);
        uint64_t v17 = v22;
        double v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v19 = v18;
        double v20 = [v8 endDate];
        [v20 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::resetToBucket(v4, v17, v19, v21);
      }
      else
      {
        double v8 = [*(id *)(a1 + 40) dateIntervalAtIndex:*(void *)(a1 + 112) + 1];
        HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_updateSourceOrder((uint64_t)v5);
        HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeThroughTime((uint64_t)v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsFromFinishedBucket(a1, v5);
        double v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v12 = v11;
        double v13 = [v8 endDate];
        [v13 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::advanceBucket(v4, v12, v14);
      }
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_didChangeBucket(a1, v9);
      if (v6 != v7) {
        _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_notifyForCurrentBucket(a1);
      }
    }
    while (*(double *)(a1 + 128) <= a2);
  }
}

void sub_1BD18D9AC(_Unwind_Exception *exception_object)
{
}

void HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::addSample(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = a1 + 8;
  double v6 = *(double *)(a1 + 8);
  double v7 = *(double *)(a2 + 8);
  double v8 = *(double *)(a2 + 16);
  uint64_t v9 = *(uint64_t **)(a2 + 24);
  unsigned __int8 v10 = *(unsigned char *)(a2 + 32);
  char v11 = *(unsigned char *)(a2 + 33);
  int v12 = v10;
  char v13 = v11;
  unint64_t v14 = (unint64_t)v9;
  double v15 = v8;
  double v16 = v7;
  if (v6 - v7 >= 0.01)
  {
    if (v8 - v7 - (v6 - v7) >= 0.01)
    {
      int v12 = *(unsigned __int8 *)(a2 + 32);
      char v13 = *(unsigned char *)(a2 + 33);
      unint64_t v14 = *(void *)(a2 + 24);
      double v15 = *(double *)(a2 + 16);
      double v16 = *(double *)(a1 + 8);
    }
    else
    {
      int v12 = 0;
      char v13 = 0;
      unint64_t v14 = 0;
      double v15 = 0.0;
      double v16 = 0.0;
    }
  }
  uint64_t v17 = *(uint64_t **)a2;
  double v18 = *(double *)(a1 + 16);
  double v19 = v18 - v16;
  double v20 = v15 - v16 - (v18 - v16);
  if (!*(_DWORD *)(a1 + 36))
  {
    if (v20 < 0.01)
    {
LABEL_10:
      unint64_t v65 = 0;
      int v21 = 0;
      char v66 = 0;
      double v18 = 0.0;
      double v22 = 0.0;
      if (!v12) {
        goto LABEL_28;
      }
      goto LABEL_11;
    }
    if (v19 >= 0.01) {
      goto LABEL_27;
    }
LABEL_25:
    int v21 = v12;
    unint64_t v28 = v14;
    double v22 = v15;
    double v18 = v16;
    if (!v21) {
      return;
    }
    goto LABEL_56;
  }
  if (v19 < 0.01) {
    goto LABEL_25;
  }
  if (v20 < 0.01) {
    goto LABEL_10;
  }
LABEL_27:
  double v22 = v15;
  unint64_t v65 = v14;
  int v21 = v12;
  char v66 = v13;
  double v15 = *(double *)(a1 + 16);
  if (!v12)
  {
LABEL_28:
    char v13 = v66;
    unint64_t v28 = v65;
    if (!v21) {
      return;
    }
    goto LABEL_56;
  }
LABEL_11:
  double v63 = v16;
  double v64 = v15;
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>(a1 + 360, v14, v14);
  unint64_t v23 = *(void *)(a1 + 112);
  if (v23 == *(void *)(a1 + 104) && *(uint64_t *)(a1 + 136) <= 0)
  {
    v29.f64[1] = *(float64_t *)(a1 + 16);
    double v24 = v63;
    double v25 = v64;
    v29.f64[0] = v63;
    v30.f64[0] = *(float64_t *)(a1 + 8);
    v30.f64[1] = v64;
    int8x16_t v31 = (int8x16_t)vcgtq_f64(v30, v29);
    v30.f64[0] = v63;
    *(int8x16_t *)(a1 + 48) = vbslq_s8(v31, *(int8x16_t *)(a1 + 8), (int8x16_t)v30);
    if (!a3) {
      goto LABEL_31;
    }
    goto LABEL_22;
  }
  double v24 = v63;
  double v25 = v64;
  if (v63 < *(double *)(a1 + 48))
  {
    double v26 = *(double *)(a1 + 8);
    if (v63 >= v26) {
      double v26 = v63;
    }
    *(double *)(a1 + 48) = v26;
  }
  if (v64 > *(double *)(a1 + 56))
  {
    double v27 = *(double *)(a1 + 16);
    if (v27 >= v64) {
      double v27 = v64;
    }
    *(double *)(a1 + 56) = v27;
  }
  if (a3)
  {
LABEL_22:
    if (v24 < *(double *)(a1 + 16))
    {
      HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeThroughTime(v5, v24);
      double v24 = v63;
      double v25 = v64;
      unint64_t v23 = *(void *)(a1 + 112);
    }
  }
LABEL_31:
  unint64_t v32 = *(void *)(a1 + 120);
  if (v23 >= v32)
  {
    uint64_t v34 = *(void *)(a1 + 104);
    unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - v34) >> 4);
    unint64_t v36 = v35 + 1;
    if (v35 + 1 > 0x555555555555555) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v32 - v34) >> 4);
    if (2 * v37 > v36) {
      unint64_t v36 = 2 * v37;
    }
    if (v37 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v38 = 0x555555555555555;
    }
    else {
      unint64_t v38 = v36;
    }
    if (v38)
    {
      unint64_t v38 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v38);
      double v24 = v63;
      double v25 = v64;
    }
    else
    {
      uint64_t v39 = 0;
    }
    unint64_t v40 = v38 + 48 * v35;
    unint64_t v41 = v38 + 48 * v39;
    *(void *)unint64_t v40 = v17;
    *(double *)(v40 + 8) = v24;
    *(double *)(v40 + 16) = v25;
    *(void *)(v40 + 24) = v14;
    *(unsigned char *)(v40 + 32) = v12;
    *(unsigned char *)(v40 + 33) = v13;
    *(_WORD *)(v40 + 40) = 0;
    *(unsigned char *)(v40 + 42) = 0;
    unint64_t v33 = v40 + 48;
    uint64_t v43 = *(char **)(a1 + 104);
    double v42 = *(char **)(a1 + 112);
    if (v42 == v43)
    {
      char v13 = v66;
      unint64_t v28 = v65;
    }
    else
    {
      char v13 = v66;
      unint64_t v28 = v65;
      do
      {
        long long v44 = *((_OWORD *)v42 - 3);
        long long v45 = *((_OWORD *)v42 - 2);
        *(_OWORD *)(v40 - 21) = *(_OWORD *)(v42 - 21);
        *(_OWORD *)(v40 - 48) = v44;
        *(_OWORD *)(v40 - 32) = v45;
        v40 -= 48;
        v42 -= 48;
      }
      while (v42 != v43);
      double v42 = *(char **)(a1 + 104);
    }
    *(void *)(a1 + 104) = v40;
    *(void *)(a1 + 112) = v33;
    *(void *)(a1 + 120) = v41;
    if (v42) {
      operator delete(v42);
    }
  }
  else
  {
    *(void *)unint64_t v23 = v17;
    *(double *)(v23 + 8) = v24;
    *(double *)(v23 + 16) = v25;
    *(void *)(v23 + 24) = v14;
    *(unsigned char *)(v23 + 32) = v12;
    *(unsigned char *)(v23 + 33) = v13;
    *(_WORD *)(v23 + 40) = 0;
    unint64_t v33 = v23 + 48;
    *(unsigned char *)(v23 + 42) = 0;
    char v13 = v66;
    unint64_t v28 = v65;
  }
  *(void *)(a1 + 112) = v33;
  if (!*(unsigned char *)(a1 + 328) || *(double *)(a1 + 304) <= v7)
  {
    *(void *)(a1 + 296) = v17;
    *(double *)(a1 + 304) = v7;
    *(double *)(a1 + 312) = v8;
    *(void *)(a1 + 320) = v9;
    *(unsigned char *)(a1 + 328) = v10;
    *(unsigned char *)(a1 + 329) = v11;
  }
  if (*(unsigned char *)(a1 + 33)
    && ((unint64_t v46 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_canonicalSourceIDForSourceID(v5, v14),
         long long v47 = HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsForSource(v5, v46),
         !*((unsigned char *)v47 + 200))
     || *((double *)v47 + 22) <= v7))
  {
    v47[21] = v17;
    *((double *)v47 + 22) = v7;
    *((double *)v47 + 23) = v8;
    v47[24] = v9;
    *((unsigned char *)v47 + 200) = v10;
    *((unsigned char *)v47 + 201) = v11;
    if (!v21) {
      return;
    }
  }
  else if (!v21)
  {
    return;
  }
LABEL_56:
  unint64_t v48 = *(void *)(a1 + 552);
  unint64_t v49 = *(void *)(a1 + 560);
  if (v48 >= v49)
  {
    uint64_t v51 = *(void *)(a1 + 544);
    unint64_t v52 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v48 - v51) >> 3);
    unint64_t v53 = v52 + 1;
    if (v52 + 1 > 0x666666666666666) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v54 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v49 - v51) >> 3);
    if (2 * v54 > v53) {
      unint64_t v53 = 2 * v54;
    }
    if (v54 >= 0x333333333333333) {
      unint64_t v55 = 0x666666666666666;
    }
    else {
      unint64_t v55 = v53;
    }
    if (v55) {
      unint64_t v55 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v55);
    }
    else {
      uint64_t v56 = 0;
    }
    unint64_t v57 = v55 + 40 * v52;
    unint64_t v58 = v55 + 40 * v56;
    *(void *)unint64_t v57 = v17;
    *(double *)(v57 + 8) = v18;
    *(double *)(v57 + 16) = v22;
    *(void *)(v57 + 24) = v28;
    *(unsigned char *)(v57 + 32) = v21;
    *(unsigned char *)(v57 + 33) = v13;
    unint64_t v50 = v57 + 40;
    float v59 = *(char **)(a1 + 552);
    double v60 = *(char **)(a1 + 544);
    if (v59 != v60)
    {
      do
      {
        long long v61 = *(_OWORD *)(v59 - 40);
        long long v62 = *(_OWORD *)(v59 - 24);
        *(_WORD *)(v57 - 8) = *((_WORD *)v59 - 4);
        *(_OWORD *)(v57 - 24) = v62;
        *(_OWORD *)(v57 - 40) = v61;
        v57 -= 40;
        v59 -= 40;
      }
      while (v59 != v60);
      float v59 = *(char **)(a1 + 544);
    }
    *(void *)(a1 + 544) = v57;
    *(void *)(a1 + 552) = v50;
    *(void *)(a1 + 560) = v58;
    if (v59) {
      operator delete(v59);
    }
  }
  else
  {
    *(void *)unint64_t v48 = v17;
    *(double *)(v48 + 8) = v18;
    *(double *)(v48 + 16) = v22;
    *(void *)(v48 + 24) = v28;
    *(unsigned char *)(v48 + 32) = v21;
    unint64_t v50 = v48 + 40;
    *(unsigned char *)(v48 + 33) = v13;
  }
  *(void *)(a1 + 552) = v50;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_notifyForCurrentBucket(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 690))
  {
    *(unsigned char *)(a1 + 692) = 1;
  }
  else
  {
    *(unsigned char *)(a1 + 692) = 0;
    uint64_t v2 = (void (**)(id, void *))_Block_copy(*(const void **)(a1 + 96));
    if (v2)
    {
      uint64_t v4 = v2;
      int v3 = (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
      if (v3) {
        v4[2](v4, v3);
      }

      uint64_t v2 = v4;
    }
  }
}

void sub_1BD18DFAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::advanceBucket(uint64_t a1, double a2, double a3)
{
  uint64_t v9 = 0;
  unsigned __int8 v10 = 0;
  uint64_t v11 = 0;
  std::vector<HDRawQuantitySample>::__init_with_size[abi:ne180100]<HDRawQuantitySample*,HDRawQuantitySample*>(&v9, *(const void **)(a1 + 544), *(void *)(a1 + 552), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 552) - *(void *)(a1 + 544)) >> 3));
  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::resetToBucket(a1, *(void *)a1 + 1, a2, a3);
  double v6 = v9;
  double v7 = v10;
  if (v9 != v10)
  {
    uint64_t v8 = (uint64_t)v9;
    do
    {
      HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::addSample(a1, v8, 1);
      v8 += 40;
    }
    while ((void *)v8 != v7);
  }
  if (v6)
  {
    operator delete(v6);
  }
}

void sub_1BD18E0AC(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::resetToBucket(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v8 = (id *)(a1 + 40);
  objc_storeStrong((id *)(a1 + 568), *(id *)(a1 + 40));
  *(double *)(a1 + 8) = a3;
  *(double *)(a1 + 16) = a4;
  *(double *)(a1 + 64) = a3;
  *(void *)(a1 + 112) = *(void *)(a1 + 104);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 168) = xmmword_1BD330210;
  *(void *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 192) = xmmword_1BD330220;
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 216) = xmmword_1BD330230;
  *(void *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 240) = xmmword_1BD330240;
  *(void *)(a1 + 256) = 0;
  *(void *)(a1 + 264) = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 272) = 5;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 328) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  if (*(void *)(a1 + 352))
  {
    uint64_t v9 = *(void **)(a1 + 336);
    uint64_t v10 = *(void *)(a1 + 344);
    *(void *)(a1 + 336) = a1 + 344;
    *(void *)(v10 + 16) = 0;
    *(void *)(a1 + 344) = 0;
    *(void *)(a1 + 352) = 0;
    if (v9[1]) {
      uint64_t v11 = (void *)v9[1];
    }
    else {
      uint64_t v11 = v9;
    }
    if (v11)
    {
      int v12 = (void *)v11[2];
      if (v12)
      {
        char v13 = (void *)*v12;
        if ((void *)*v12 == v11)
        {
          void *v12 = 0;
          while (1)
          {
            double v15 = (void *)v12[1];
            if (!v15) {
              break;
            }
            do
            {
              int v12 = v15;
              double v15 = (void *)*v15;
            }
            while (v15);
          }
        }
        else
        {
          for (v12[1] = 0; v13; char v13 = (void *)v12[1])
          {
            do
            {
              int v12 = v13;
              char v13 = (void *)*v13;
            }
            while (v13);
          }
        }
        std::__tree<long>::destroy(v11);
        for (uint64_t i = (void *)v12[2]; i; uint64_t i = (void *)i[2])
          int v12 = i;
        uint64_t v11 = v12;
      }
    }
    std::__tree<long>::destroy(v11);
  }
  objc_storeStrong(v8, *(id *)(a1 + 568));
  *(void *)(a1 + 552) = *(void *)(a1 + 544);
  *(void *)a1 = a2;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_didChangeBucket(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 692))
  {
    if (v3)
    {
      id v6 = v3;
      uint64_t v4 = _Block_copy(*(const void **)(a1 + 96));
      uint64_t v5 = v4;
      if (v4) {
        (*((void (**)(void *, id))v4 + 2))(v4, v6);
      }

      id v3 = v6;
    }
    *(unsigned char *)(a1 + 692) = 0;
  }
}

void sub_1BD18E2B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_currentBucketInterval(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 688))
  {
    unint64_t v1 = 0;
  }
  else
  {
    unint64_t v1 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:", *(double *)(a1 + 120), *(double *)(a1 + 128));
  }

  return v1;
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE38_collapsedPendingInvalidationIntervalsERb_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = [a2 startDate];
  id v6 = [v4 startDate];
  uint64_t v7 = [v5 compare:v6];

  return v7;
}

void sub_1BD18E38C(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveInvalidateInterval(id *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 13);
  if (WeakRetained)
  {
    if (v5
      && (_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_currentBucketInterval((uint64_t)a1),
          (uint64_t v7 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      uint64_t v8 = [v5 endDate];
      uint64_t v9 = [v7 startDate];
      if (objc_msgSend(v8, "hk_isAfterDate:", v9))
      {
        uint64_t v10 = [v5 startDate];
        uint64_t v11 = [v7 endDate];
        char v12 = objc_msgSend(v10, "hk_isBeforeOrEqualToDate:", v11);
      }
      else
      {
        char v12 = 0;
      }

      char v13 = _Block_copy(a1[12]);
      if ((v12 & 1) == 0) {
        operator new();
      }
    }
    else
    {
      char v13 = _Block_copy(a1[12]);
    }
    *((unsigned char *)a1 + 688) = 1;
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 3221225472;
    v27[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke;
    v27[3] = &unk_1E6308FF8;
    id v15 = v5;
    id v28 = v15;
    id v16 = v13;
    id v29 = v16;
    (*((void (**)(id *, void *))*a1 + 9))(a1, v27);
    if (v5)
    {
      uint64_t v17 = [v15 startDate];
      [v17 timeIntervalSinceReferenceDate];
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_configureForStartTime((uint64_t)a1);
    }
    else
    {
      (*((void (**)(id *))*a1 + 4))(a1);
      id v15 = (id)objc_claimAutoreleasedReturnValue();
    }
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2;
    v21[3] = &unk_1E6309060;
    double v24 = a1;
    id v5 = v15;
    char v26 = 1;
    id v22 = v5;
    double v25 = a1;
    id v23 = WeakRetained;
    uint64_t v14 = (*((uint64_t (**)(id *, void *, uint64_t))*a1 + 14))(a1, v21, a3);
    double v18 = _Block_copy(v16);
    id v19 = a1[12];
    a1[12] = v18;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a3, 3, @"Unable to invalidate interval: no data source available.");
    uint64_t v14 = 0;
  }

  return v14;
}

void sub_1BD18E7DC(_Unwind_Exception *a1)
{
  MEMORY[0x1C187B8A0](v4, 0x10F1C40A21595ACLL);
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke(uint64_t a1, void *a2)
{
  id v10 = a2;
  if (!*(void *)(a1 + 32)) {
    goto LABEL_11;
  }
  id v3 = [v10 endDate];
  uint64_t v4 = [*(id *)(a1 + 32) startDate];
  char v5 = objc_msgSend(v3, "hk_isBeforeOrEqualToDate:", v4);

  if ((v5 & 1) == 0)
  {
    id v6 = [v10 startDate];
    uint64_t v7 = [*(id *)(a1 + 32) endDate];
    char v8 = objc_msgSend(v6, "hk_isAfterOrEqualToDate:", v7);

    if ((v8 & 1) == 0)
    {
LABEL_11:
      uint64_t v9 = *(void *)(a1 + 40);
      if (v9) {
        (*(void (**)(uint64_t, id))(v9 + 16))(v9, v10);
      }
    }
  }
}

void sub_1BD18E9C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  char v5 = [*(id *)(a1 + 32) startDate];
  [v5 timeIntervalSinceReferenceDate];
  uint64_t v7 = v6;

  char v8 = [*(id *)(a1 + 32) endDate];
  [v8 timeIntervalSinceReferenceDate];
  uint64_t v10 = v9;

  uint64_t v11 = *(void **)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(v4 + 8));
  uint64_t v13 = *(void *)(a1 + 32);
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3;
  v30[3] = &__block_descriptor_57_e24_B52__0d8d16d24q32B40__44l;
  char v32 = *(unsigned char *)(a1 + 64);
  v30[4] = v7;
  v30[5] = v10;
  uint64_t v31 = *(void *)(a1 + 56);
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4;
  void v29[3] = &__block_descriptor_40_e8_v16__0d8l;
  v29[4] = v31;
  uint64_t v14 = [v11 collectionCalculator:WeakRetained queryForInterval:v13 error:a2 sampleHandler:v30 mergeHandler:v29];

  if (v14)
  {
    uint64_t v15 = *(void *)(a1 + 56);
    if (v15 != v4)
    {
      id v16 = [*(id *)(a1 + 32) endDate];
      [v16 timeIntervalSinceReferenceDate];
      if (*(void *)(v15 + 40))
      {
        double v18 = v17;
        while (*(double *)(v15 + 120) < v18)
        {
          id v19 = [*(id *)(v15 + 40) dateIntervalAtIndex:*(void *)(v15 + 112) + 1];
          HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_updateSourceOrder(v15 + 120);
          HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeThroughTime(v15 + 120, *(double *)(v15 + 128));
          double v20 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_statisticsFromFinishedBucket(v15, (double *)(v15 + 120));
          int v21 = [v19 startDate];
          [v21 timeIntervalSinceReferenceDate];
          double v23 = v22;
          double v24 = [v19 endDate];
          [v24 timeIntervalSinceReferenceDate];
          HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsSleepStages>>::advanceBucket(v15 + 112, v23, v25);

          if (v20)
          {
            char v26 = _Block_copy(*(const void **)(v15 + 96));
            double v27 = v26;
            if (v26) {
              (*((void (**)(void *, void *))v26 + 2))(v26, v20);
            }
          }
          _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_didChangeBucket(v15, 0);
        }
      }
    }
  }
  return v14;
}

void sub_1BD18EC6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  double v7 = *(double *)(a1 + 32) - a6;
  if (v7 >= 0.01)
  {
    if (a7 - a6 - v7 >= 0.01)
    {
      int v8 = 1;
      a6 = *(double *)(a1 + 32);
    }
    else
    {
      a2 = 0;
      int v8 = 0;
      a6 = 0.0;
      a7 = 0.0;
    }
  }
  else
  {
    int v8 = 1;
  }
  double v11 = a5;
  double v12 = a6;
  double v13 = a7;
  uint64_t v14 = a2;
  char v15 = v8;
  char v16 = 0;
  if (*(unsigned char *)(a1 + 56))
  {
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveAddSample(*(void *)(a1 + 48), (uint64_t)&v11, a3, a4);
    }
  }
  else
  {
    double v10 = *(double *)(a1 + 40) - a6;
    if (v10 >= 0.01)
    {
      if (a7 - a6 - v10 >= 0.01) {
        a7 = *(double *)(a1 + 40);
      }
    }
    else
    {
      int v8 = 0;
    }
    double v12 = a6;
    double v13 = a7;
    char v15 = v8;
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveAddSample(*(void *)(a1 + 48), (uint64_t)&v11, a3, a4);
    }
  }
  return 1;
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4(uint64_t a1, double a2)
{
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeToTime(uint64_t a1, double a2)
{
  if (*(unsigned char *)(a1 + 688)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_configureForStartTime(a1);
  }
  if (*(void *)(a1 + 40)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_advanceToTime(a1, a2);
  }
  if (*(double *)(a1 + 128) > a2)
  {
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsSleepStages>>::_mergeThroughTime(a1 + 120, a2);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(double *)(a2 - 32) < *(double *)(v10 + 8))
                {
                  uint64_t v129 = *(void *)(v10 + 32);
                  long long v113 = *(_OWORD *)v10;
                  long long v121 = *(_OWORD *)(v10 + 16);
                  long long v52 = *(_OWORD *)(a2 - 40);
                  long long v53 = *(_OWORD *)(a2 - 24);
                  *(_WORD *)(v10 + 32) = *(_WORD *)(a2 - 8);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 16) = v53;
                  *(_WORD *)(a2 - 8) = v129;
                  *(_OWORD *)(a2 - 24) = v121;
                  *(_OWORD *)(a2 - 40) = v113;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v10, (double *)(v10 + 40), (double *)(a2 - 40));
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, a2 - 40);
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, v10 + 120, a2 - 40);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 959)
          {
            unint64_t v54 = (void *)(v10 + 40);
            BOOL v56 = v10 == a2 || v54 == (void *)a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  float v59 = v54;
                  double v60 = *(double *)(v58 + 48);
                  if (v60 < *(double *)(v58 + 8))
                  {
                    uint64_t v61 = *v54;
                    long long v114 = *(_OWORD *)(v58 + 56);
                    uint64_t v122 = *(void *)(v58 + 72);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      uint64_t v63 = v10 + v62;
                      long long v64 = *(_OWORD *)(v10 + v62 + 16);
                      *(_OWORD *)(v63 + 40) = *(_OWORD *)(v10 + v62);
                      *(_OWORD *)(v63 + 56) = v64;
                      *(_WORD *)(v63 + 72) = *(_WORD *)(v10 + v62 + 32);
                      if (!v62) {
                        break;
                      }
                      v62 -= 40;
                      if (v60 >= *(double *)(v63 - 32))
                      {
                        uint64_t v65 = v10 + v62 + 40;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_81:
                    *(void *)uint64_t v65 = v61;
                    *(double *)(v65 + 8) = v60;
                    *(_OWORD *)(v65 + 16) = v114;
                    *(_WORD *)(v65 + 32) = v122;
                  }
                  unint64_t v54 = v59 + 5;
                  v57 += 40;
                  unint64_t v58 = (unint64_t)v59;
                }
                while (v59 + 5 != (void *)a2);
              }
            }
            else if (!v56)
            {
              do
              {
                uint64_t v98 = v54;
                double v99 = *(double *)(a1 + 48);
                if (v99 < *(double *)(a1 + 8))
                {
                  uint64_t v100 = *v54;
                  long long v117 = *(_OWORD *)(a1 + 56);
                  uint64_t v125 = *(void *)(a1 + 72);
                  long long v101 = v54;
                  do
                  {
                    long long v102 = *(_OWORD *)(v101 - 3);
                    *(_OWORD *)long long v101 = *(_OWORD *)(v101 - 5);
                    *((_OWORD *)v101 + 1) = v102;
                    *((_WORD *)v101 + 16) = *((_WORD *)v101 - 4);
                    double v103 = *((double *)v101 - 9);
                    v101 -= 5;
                  }
                  while (v99 < v103);
                  void *v101 = v100;
                  *((double *)v101 + 1) = v99;
                  *((_WORD *)v101 + 16) = v125;
                  *((_OWORD *)v101 + 1) = v117;
                }
                v54 += 5;
                a1 = (unint64_t)v98;
              }
              while (v98 + 5 != (void *)a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 40 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)(v10 + 40 * v69 + 8) < *(double *)(v70 + 48))
                  {
                    v70 += 40;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  double v71 = *(double *)(v10 + 40 * v68 + 8);
                  if (*(double *)(v70 + 8) >= v71)
                  {
                    unint64_t v72 = v10 + 40 * v68;
                    uint64_t v73 = *(void *)v72;
                    uint64_t v123 = *(void *)(v72 + 32);
                    long long v115 = *(_OWORD *)(v72 + 16);
                    do
                    {
                      unint64_t v74 = v72;
                      unint64_t v72 = v70;
                      long long v75 = *(_OWORD *)v70;
                      long long v76 = *(_OWORD *)(v70 + 16);
                      *(_WORD *)(v74 + 32) = *(_WORD *)(v70 + 32);
                      *(_OWORD *)unint64_t v74 = v75;
                      *(_OWORD *)(v74 + 16) = v76;
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v77 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 40 * v77;
                      uint64_t v78 = 2 * v69 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v10 + 40 * v77 + 8) < *(double *)(v70 + 48))
                      {
                        v70 += 40;
                        uint64_t v77 = v78;
                      }
                      uint64_t v69 = v77;
                    }
                    while (*(double *)(v70 + 8) >= v71);
                    *(void *)unint64_t v72 = v73;
                    *(double *)(v72 + 8) = v71;
                    *(_OWORD *)(v72 + 16) = v115;
                    *(_WORD *)(v72 + 32) = v123;
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              int64_t v79 = v11 / 0x28uLL;
              do
              {
                uint64_t v80 = 0;
                uint64_t v130 = *(void *)(v10 + 32);
                long long v116 = *(_OWORD *)v10;
                long long v124 = *(_OWORD *)(v10 + 16);
                unint64_t v81 = v10;
                do
                {
                  unint64_t v82 = v81;
                  uint64_t v83 = v80 + 1;
                  v81 += 40 * (v80 + 1);
                  uint64_t v84 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  int64_t v85 = v84 + 2;
                  if (v85 < v79 && *(double *)(v82 + 40 * v83 + 8) < *(double *)(v81 + 48))
                  {
                    v81 += 40;
                    uint64_t v80 = v85;
                  }
                  long long v86 = *(_OWORD *)v81;
                  long long v87 = *(_OWORD *)(v81 + 16);
                  *(_WORD *)(v82 + 32) = *(_WORD *)(v81 + 32);
                  *(_OWORD *)unint64_t v82 = v86;
                  *(_OWORD *)(v82 + 16) = v87;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 40;
                if (v81 == a2)
                {
                  *(_WORD *)(v81 + 32) = v130;
                  *(_OWORD *)unint64_t v81 = v116;
                  *(_OWORD *)(v81 + 16) = v124;
                }
                else
                {
                  long long v88 = *(_OWORD *)a2;
                  long long v89 = *(_OWORD *)(a2 + 16);
                  *(_WORD *)(v81 + 32) = *(_WORD *)(a2 + 32);
                  *(_OWORD *)unint64_t v81 = v88;
                  *(_OWORD *)(v81 + 16) = v89;
                  *(_WORD *)(a2 + 32) = v130;
                  *(_OWORD *)a2 = v116;
                  *(_OWORD *)(a2 + 16) = v124;
                  uint64_t v90 = v81 - v10 + 40;
                  if (v90 >= 41)
                  {
                    unint64_t v91 = (v90 / 0x28uLL - 2) >> 1;
                    double v92 = *(double *)(v81 + 8);
                    if (*(double *)(v10 + 40 * v91 + 8) < v92)
                    {
                      uint64_t v93 = *(void *)v81;
                      uint64_t v109 = *(void *)(v81 + 32);
                      long long v106 = *(_OWORD *)(v81 + 16);
                      do
                      {
                        unint64_t v94 = v81;
                        unint64_t v81 = v10 + 40 * v91;
                        long long v95 = *(_OWORD *)v81;
                        long long v96 = *(_OWORD *)(v81 + 16);
                        *(_WORD *)(v94 + 32) = *(_WORD *)(v81 + 32);
                        *(_OWORD *)unint64_t v94 = v95;
                        *(_OWORD *)(v94 + 16) = v96;
                        if (!v91) {
                          break;
                        }
                        unint64_t v91 = (v91 - 1) >> 1;
                      }
                      while (*(double *)(v10 + 40 * v91 + 8) < v92);
                      *(void *)unint64_t v81 = v93;
                      *(double *)(v81 + 8) = v92;
                      *(_WORD *)(v81 + 32) = v109;
                      *(_OWORD *)(v81 + 16) = v106;
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 40 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x1401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40 * (v12 >> 1)), (double *)(a2 - 40));
            uint64_t v15 = 5 * v13;
            char v16 = (double *)(a1 + 40 * v13 - 40);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40), v16, (double *)(a2 - 80));
            double v17 = (double *)(a1 + 40 + 8 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 80), v17, (double *)(a2 - 120));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v16, (double *)v14, v17);
            uint64_t v126 = *(void *)(a1 + 32);
            long long v110 = *(_OWORD *)a1;
            long long v118 = *(_OWORD *)(a1 + 16);
            long long v18 = *(_OWORD *)v14;
            long long v19 = *(_OWORD *)(v14 + 16);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v14 + 32);
            *(_OWORD *)a1 = v18;
            *(_OWORD *)(a1 + 16) = v19;
            *(_WORD *)(v14 + 32) = v126;
            *(_OWORD *)unint64_t v14 = v110;
            *(_OWORD *)(v14 + 16) = v118;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40 * (v12 >> 1)), (double *)a1, (double *)(a2 - 40));
          }
          --a3;
          if (a4) {
            break;
          }
          double v20 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 32) < v20) {
            goto LABEL_12;
          }
          uint64_t v38 = *(void *)a1;
          long long v105 = *(_OWORD *)(a1 + 16);
          uint64_t v108 = *(void *)(a1 + 32);
          if (v20 >= *(double *)(a2 - 32))
          {
            unint64_t v41 = a1 + 40;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= a2) {
                break;
              }
              double v42 = *(double *)(v41 + 8);
              v41 += 40;
            }
            while (v20 >= v42);
          }
          else
          {
            unint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 40;
              double v40 = *(double *)(v39 + 48);
              v39 += 40;
            }
            while (v20 >= v40);
          }
          unint64_t v43 = a2;
          if (v10 < a2)
          {
            unint64_t v44 = a2;
            do
            {
              unint64_t v43 = v44 - 40;
              double v45 = *(double *)(v44 - 32);
              v44 -= 40;
            }
            while (v20 < v45);
          }
          while (v10 < v43)
          {
            uint64_t v128 = *(void *)(v10 + 32);
            long long v112 = *(_OWORD *)v10;
            long long v120 = *(_OWORD *)(v10 + 16);
            long long v46 = *(_OWORD *)v43;
            long long v47 = *(_OWORD *)(v43 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v43 + 32);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(_WORD *)(v43 + 32) = v128;
            *(_OWORD *)unint64_t v43 = v112;
            *(_OWORD *)(v43 + 16) = v120;
            do
            {
              double v48 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v20 >= v48);
            do
            {
              double v49 = *(double *)(v43 - 32);
              v43 -= 40;
            }
            while (v20 < v49);
          }
          BOOL v4 = v10 - 40 >= a1;
          BOOL v5 = v10 - 40 == a1;
          if (v10 - 40 != a1)
          {
            long long v50 = *(_OWORD *)(v10 - 40);
            long long v51 = *(_OWORD *)(v10 - 24);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 16) = v51;
          }
          a4 = 0;
          *(void *)(v10 - 40) = v38;
          *(double *)(v10 - 32) = v20;
          *(_WORD *)(v10 - 8) = v108;
          *(_OWORD *)(v10 - 24) = v105;
        }
        double v20 = *(double *)(a1 + 8);
LABEL_12:
        uint64_t v21 = 0;
        uint64_t v22 = *(void *)a1;
        long long v104 = *(_OWORD *)(a1 + 16);
        uint64_t v107 = *(void *)(a1 + 32);
        do
        {
          double v23 = *(double *)(a1 + v21 + 48);
          v21 += 40;
        }
        while (v23 < v20);
        unint64_t v24 = a1 + v21;
        unint64_t v25 = a2;
        if (v21 == 40)
        {
          unint64_t v28 = a2;
          while (v24 < v28)
          {
            unint64_t v26 = v28 - 40;
            double v29 = *(double *)(v28 - 32);
            v28 -= 40;
            if (v29 < v20) {
              goto LABEL_22;
            }
          }
          unint64_t v26 = v28;
        }
        else
        {
          do
          {
            unint64_t v26 = v25 - 40;
            double v27 = *(double *)(v25 - 32);
            v25 -= 40;
          }
          while (v27 >= v20);
        }
LABEL_22:
        unint64_t v10 = v24;
        if (v24 < v26)
        {
          unint64_t v30 = v26;
          do
          {
            uint64_t v127 = *(void *)(v10 + 32);
            long long v111 = *(_OWORD *)v10;
            long long v119 = *(_OWORD *)(v10 + 16);
            long long v31 = *(_OWORD *)v30;
            long long v32 = *(_OWORD *)(v30 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v30 + 32);
            *(_OWORD *)unint64_t v10 = v31;
            *(_OWORD *)(v10 + 16) = v32;
            *(_WORD *)(v30 + 32) = v127;
            *(_OWORD *)unint64_t v30 = v111;
            *(_OWORD *)(v30 + 16) = v119;
            do
            {
              double v33 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v33 < v20);
            do
            {
              double v34 = *(double *)(v30 - 32);
              v30 -= 40;
            }
            while (v34 >= v20);
          }
          while (v10 < v30);
        }
        if (v10 - 40 != a1)
        {
          long long v35 = *(_OWORD *)(v10 - 40);
          long long v36 = *(_OWORD *)(v10 - 24);
          *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
        }
        *(void *)(v10 - 40) = v22;
        *(double *)(v10 - 32) = v20;
        *(_WORD *)(v10 - 8) = v107;
        *(_OWORD *)(v10 - 24) = v104;
        if (v24 >= v26) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(a1, v10 - 40, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, v10 - 40);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 40;
    if (!v37) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 32) < *(double *)(a1 + 8))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        long long v7 = *(_OWORD *)a1;
        long long v8 = *(_OWORD *)(a1 + 16);
        __int16 v9 = *(_WORD *)(a2 - 8);
        long long v10 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
        *(_OWORD *)(a1 + 16) = v10;
        *(_WORD *)(a1 + 32) = v9;
        *(_OWORD *)(a2 - 24) = v8;
        *(_OWORD *)(a2 - 40) = v7;
        *(_WORD *)(a2 - 8) = v6;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a2 - 40));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a1 + 120, a2 - 40);
      return 1;
    default:
      uint64_t v11 = a1 + 80;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a1 + 80));
      uint64_t v12 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (1)
  {
    double v15 = *(double *)(v12 + 8);
    if (v15 < *(double *)(v11 + 8))
    {
      uint64_t v16 = *(void *)v12;
      long long v21 = *(_OWORD *)(v12 + 16);
      uint64_t v22 = *(void *)(v12 + 32);
      uint64_t v17 = v13;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        long long v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(_WORD *)(v18 + 152) = *(_WORD *)(a1 + v17 + 112);
        if (v17 == -80) {
          break;
        }
        v17 -= 40;
        if (v15 >= *(double *)(v18 + 48))
        {
          uint64_t v20 = a1 + v17 + 120;
          goto LABEL_12;
        }
      }
      uint64_t v20 = a1;
LABEL_12:
      *(void *)uint64_t v20 = v16;
      *(double *)(v20 + 8) = v15;
      *(_OWORD *)(v20 + 16) = v21;
      *(_WORD *)(v20 + 32) = v22;
      if (++v14 == 8) {
        return v12 + 40 == a2;
      }
    }
    uint64_t v11 = v12;
    v13 += 40;
    v12 += 40;
    if (v12 == a2) {
      return 1;
    }
  }
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke(void *a1, uint64_t a2)
{
  id v3 = (void *)a1[5];
  uint64_t v4 = a1[6];
  BOOL v5 = (void *)a1[4];
  uint64_t v6 = [v5 dateInterval];
  void v9[4] = v4;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2;
  v10[3] = &__block_descriptor_40_e24_B52__0d8d16d24q32B40__44l;
  v10[4] = v4;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3;
  v9[3] = &__block_descriptor_40_e8_v16__0d8l;
  uint64_t v7 = [v3 collectionCalculator:v5 queryForInterval:v6 error:a2 sampleHandler:v10 mergeHandler:v9];

  return v7;
}

void sub_1BD18F9F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  uint64_t v10 = *(void *)(a1 + 32);
  *(double *)int v14 = a5;
  *(double *)&v14[1] = a6;
  *(double *)&v14[2] = a7;
  v14[3] = a2;
  char v15 = 1;
  uint64_t v11 = [MEMORY[0x1E4F1C9C8] distantFuture];
  [v11 timeIntervalSinceReferenceDate];
  BOOL v16 = v12 <= a7;

  return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsSleepStages>>::_primitiveAddSample(v10, (uint64_t)v14, a3, a4);
}

void sub_1BD18FA94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI20HDStatisticsRelativeI23HDStatisticsSleepStagesEE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, double a2)
{
}

void HDStatisticsRelative<HDStatisticsSleepStages>::archive(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 204) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F171B978;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  statistics::Statistics::makePrimaryStatistics(a1);
  HDStatisticsSleepStages::archive((HDStatisticsSleepStages *)(a2 + 8));
}

void sub_1BD18FB1C()
{
  statistics::Statistics::operator=(*(statistics **)(v0 + 128), (uint64_t)v4);
  statistics::Statistics::~Statistics((statistics::Statistics *)v4);
  uint64_t v3 = *v1;
  *(_DWORD *)(v0 + 204) |= 0x100u;
  *(void *)(v0 + 136) = v3;
  statistics::Statistics::makeMostRecentDatum(v0);
  v4[0] = &unk_1F17206F8;
  int v8 = 127;
  int8x16_t v5 = vextq_s8(*(int8x16_t *)(v1 + 42), *(int8x16_t *)(v1 + 42), 8uLL);
  v4[1] = *((void *)v1 + 23);
  v4[2] = *((void *)v1 + 24);
  __int16 v6 = 0;
  char v7 = 0;
  statistics::RawQuantitySample::operator=(*v2, (uint64_t)v4);
  PB::Base::~Base((PB::Base *)v4);
}

void sub_1BD18FBC4(_Unwind_Exception *a1)
{
  statistics::Statistics::~Statistics(v1);
  _Unwind_Resume(a1);
}

double HDStatisticsRelative<HDStatisticsSleepStages>::unarchive(uint64_t a1, const statistics::Statistics *a2)
{
  *(_DWORD *)a1 = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = xmmword_1BD330210;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 64) = xmmword_1BD330220;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 88) = xmmword_1BD330230;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = xmmword_1BD330240;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 136) = xmmword_1BD330250;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0x7FFFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_WORD *)(a1 + 200) = 0;
  uint64_t v4 = (HDStatisticsSleepStages *)*((void *)a2 + 16);
  if (v4) {
    HDStatisticsSleepStages::unarchive(v4, a2);
  }
  *(_DWORD *)a1 = *((void *)a2 + 17);
  uint64_t v5 = *((void *)a2 + 14);
  if (v5)
  {
    double result = *(double *)(v5 + 8);
    uint64_t v6 = *(void *)(v5 + 16);
    *(int8x16_t *)(a1 + 168) = vextq_s8(*(int8x16_t *)(v5 + 24), *(int8x16_t *)(v5 + 24), 8uLL);
    *(double *)(a1 + 184) = result;
    *(void *)(a1 + 192) = v6;
    *(_WORD *)(a1 + 200) = 1;
  }
  return result;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_HDConcreteStatisticsCollectionCalculatorImplementation(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  char v6 = a3;
  uint64_t v8 = _HDStatisticsCollectionCalculatorImplementation::_HDStatisticsCollectionCalculatorImplementation(a1, a2, a3, a4, a5, a6);
  *(void *)uint64_t v8 = &unk_1F1726E00;
  double v9 = 900.0;
  if ((v6 & 0x10) == 0) {
    double v9 = 0.0;
  }
  *(double *)(v8 + 56) = v9;
  *(_OWORD *)(v8 + 64) = 0u;
  *(_OWORD *)(v8 + 80) = 0u;
  *(void *)(v8 + 104) = 0;
  *(void *)(v8 + 112) = 0;
  *(void *)(v8 + 96) = 0;
  HDStatisticsBucket<HDStatisticsSleepStages>::HDStatisticsBucket(v8 + 120, 0, -1.79769313e308, 1.79769313e308);
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_WORD *)(a1 + 640) = 1;
  *(unsigned char *)(a1 + 642) = 0;
  *(unsigned char *)(a1 + 644) = 0;
  *(void *)(a1 + 648) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(void *)(a1 + 688) = 0;
  return a1;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::~_HDConcreteStatisticsCollectionCalculatorImplementation(uint64_t a1)
{
  _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::~_HDConcreteStatisticsCollectionCalculatorImplementation(a1);

  JUMPOUT(0x1C187B8A0);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t vars8;

  *(void *)a1 = &unk_1F1726E00;
  uint64_t v2 = *(void **)(a1 + 672);
  if (v2)
  {
    *(void *)(a1 + 680) = v2;
    operator delete(v2);
  }

  uint64_t v3 = *(void **)(a1 + 608);
  if (v3)
  {
    *(void *)(a1 + 616) = v3;
    operator delete(v3);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::~HDStatisticsBucket(a1 + 120);
  objc_destroyWeak((id *)(a1 + 104));

  uint64_t v4 = *(void **)(a1 + 72);
  if (v4)
  {
    *(void *)(a1 + 80) = v4;
    operator delete(v4);
  }

  _HDStatisticsCollectionCalculatorImplementation::~_HDStatisticsCollectionCalculatorImplementation((_HDStatisticsCollectionCalculatorImplementation *)a1);
}

double _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::mergeGranularity(uint64_t a1)
{
  return *(double *)(a1 + 56);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::setMergeGranularity(uint64_t result, double a2)
{
  if (*(double *)(result + 56) != a2)
  {
    *(double *)(result + 56) = a2;
    *(unsigned char *)(result + 640) = 1;
  }
  return result;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::dateInterval(uint64_t a1)
{
  return *(id *)(a1 + 64);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::setDateInterval(uint64_t a1, void *a2)
{
  id v6 = a2;
  uint64_t v3 = [v6 copy];
  uint64_t v4 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = v3;

  uint64_t v5 = [v6 startDate];
  [v5 timeIntervalSinceReferenceDate];
  _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_configureForStartTime(a1);
}

void sub_1BD18FE80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::configureMergeAnchor(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!*(void *)(a1 + 40))
  {
    id v5 = v3;
    [v3 timeIntervalSinceReferenceDate];
    *(void *)(a1 + 648) = v4;
    id v3 = v5;
  }
}

void sub_1BD18FEF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::setStatisticsConfiguration(id *a1, void *a2)
{
  objc_storeStrong(a1 + 82, a2);
  id v7 = a2;
  id v4 = a1[82];
  id v5 = a1[79];
  a1[79] = v4;
  id v6 = v4;

  objc_storeStrong(a1 + 19, a1[79]);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::setIntervalMask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = (char *)(a1 + 72);
  if (v6 != (char *)a2) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(v6, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  }
  if (*(void *)(a1 + 40)) {
    return 1;
  }
  BOOL v7 = *(void *)(a1 + 224) == *(void *)(a1 + 216) && *(uint64_t *)(a1 + 240) < 1
    || HKIntervalMask<double>::firstDifference(*(void *)(a1 + 184), *(void *)(a1 + 192), *(void *)a2, *(void *)(a2 + 8)) >= *(double *)(a1 + 176);
  if (a1 + 184 != a2) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((char *)(a1 + 184), *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 4);
  }
  if (v7) {
    return 1;
  }
  double v9 = *(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 128);

  return v9(a1, 0, a3);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::setStatisticsHandler(uint64_t a1, void *a2)
{
  id v5 = a2;
  uint64_t v3 = [v5 copy];
  id v4 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = v3;
}

void sub_1BD1900DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::dataSource(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 104));

  return WeakRetained;
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::setDataSource(uint64_t a1, void *a2)
{
  return objc_storeWeak((id *)(a1 + 104), a2);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::currentStatistics(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 640))
  {
    unint64_t v1 = 0;
  }
  else
  {
    HDStatisticsBucket<HDStatisticsSleepStages>::HDStatisticsBucket((uint64_t)v4, a1 + 120);
    HDStatisticsBucket<HDStatisticsSleepStages>::_updateSourceOrder((uint64_t)v4);
    HDStatisticsBucket<HDStatisticsSleepStages>::_mergeThroughTime((uint64_t)v4, v5);
    unint64_t v1 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_statisticsFromFinishedBucket(a1, (uint64_t)v4);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::~HDStatisticsBucket((uint64_t)v4);
  }

  return v1;
}

void sub_1BD1901AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::~HDStatisticsBucket((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::addSample(uint64_t a1, double *a2, uint64_t a3)
{
  id v6 = *(id *)(a1 + 64);
  BOOL v7 = v6;
  if (!v6) {
    goto LABEL_4;
  }
  uint64_t v8 = [v6 startDate];
  [v8 timeIntervalSinceReferenceDate];
  if (v9 > a2[2])
  {

    goto LABEL_10;
  }
  uint64_t v10 = [v7 endDate];
  [v10 timeIntervalSinceReferenceDate];
  double v12 = v11;
  double v13 = a2[1];

  if (v12 >= v13)
  {
LABEL_4:
    if (!*(unsigned char *)(a1 + 642)) {
      goto LABEL_21;
    }
    if (!*(unsigned char *)(a1 + 641))
    {
      if (*(void *)(a1 + 40))
      {
        if (*(unsigned char *)(a1 + 640))
        {
          double v14 = -1.79769313e308;
        }
        else
        {
          double v16 = *(double *)(a1 + 176);
          double v14 = *(double *)(a1 + 120);
          if (v16 <= v14) {
            double v16 = -1.79769313e308;
          }
          if (v16 >= v14) {
            double v14 = v16;
          }
        }
      }
      else
      {
        double v14 = -1.79769313e308;
        if (*(double *)(a1 + 176) > *(double *)(a1 + 120)) {
          double v14 = *(double *)(a1 + 176);
        }
      }
      if (v14 > a2[1])
      {
        uint64_t v17 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:");
        uint64_t v15 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v17, a3);

        goto LABEL_22;
      }
      if (*(unsigned char *)(a1 + 643))
      {
LABEL_21:
        uint64_t v15 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveAddSample(a1, a2, 1, a3);
        goto LABEL_22;
      }
      unint64_t v19 = *(void *)(a1 + 680);
      unint64_t v20 = *(void *)(a1 + 688);
      if (v19 >= v20)
      {
        uint64_t v24 = *(void *)(a1 + 672);
        unint64_t v25 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v19 - v24) >> 3);
        unint64_t v26 = v25 + 1;
        if (v25 + 1 > 0x666666666666666) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - v24) >> 3);
        if (2 * v27 > v26) {
          unint64_t v26 = 2 * v27;
        }
        if (v27 >= 0x333333333333333) {
          unint64_t v28 = 0x666666666666666;
        }
        else {
          unint64_t v28 = v26;
        }
        if (v28) {
          unint64_t v28 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v28);
        }
        else {
          uint64_t v29 = 0;
        }
        unint64_t v30 = v28 + 40 * v25;
        unint64_t v31 = v28 + 40 * v29;
        long long v32 = *(_OWORD *)a2;
        long long v33 = *((_OWORD *)a2 + 1);
        *(double *)(v30 + 32) = a2[4];
        *(_OWORD *)unint64_t v30 = v32;
        *(_OWORD *)(v30 + 16) = v33;
        unint64_t v23 = v30 + 40;
        double v34 = *(char **)(a1 + 680);
        long long v35 = *(char **)(a1 + 672);
        if (v34 != v35)
        {
          do
          {
            long long v36 = *(_OWORD *)(v34 - 40);
            long long v37 = *(_OWORD *)(v34 - 24);
            *(_WORD *)(v30 - 8) = *((_WORD *)v34 - 4);
            *(_OWORD *)(v30 - 24) = v37;
            *(_OWORD *)(v30 - 40) = v36;
            v30 -= 40;
            v34 -= 40;
          }
          while (v34 != v35);
          double v34 = *(char **)(a1 + 672);
        }
        *(void *)(a1 + 672) = v30;
        *(void *)(a1 + 680) = v23;
        *(void *)(a1 + 688) = v31;
        if (v34) {
          operator delete(v34);
        }
      }
      else
      {
        long long v21 = *(_OWORD *)a2;
        long long v22 = *((_OWORD *)a2 + 1);
        *(double *)(v19 + 32) = a2[4];
        *(_OWORD *)unint64_t v19 = v21;
        *(_OWORD *)(v19 + 16) = v22;
        unint64_t v23 = v19 + 40;
      }
      *(void *)(a1 + 680) = v23;
    }
  }
LABEL_10:
  uint64_t v15 = 1;
LABEL_22:

  return v15;
}

void sub_1BD190468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::performAddSampleTransaction(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = v5;
  if (*(unsigned char *)(a1 + 642))
  {
    uint64_t v7 = (*((uint64_t (**)(id, uint64_t))v5 + 2))(v5, a3);
    goto LABEL_83;
  }
  *(_WORD *)(a1 + 642) = 1;
  uint64_t v67 = a3;
  if (!(*((unsigned int (**)(id, uint64_t))v5 + 2))(v5, a3))
  {
    uint64_t v7 = 0;
    goto LABEL_82;
  }
  uint64_t v65 = v6;
  if (*(unsigned char *)(a1 + 641)) {
    goto LABEL_5;
  }
  double v9 = *(void **)(a1 + 664);
  if (!v9)
  {
    id v68 = 0;
    goto LABEL_28;
  }
  if (!*(void *)(a1 + 40))
  {
LABEL_5:
    int v8 = 0;
    id v68 = 0;
    goto LABEL_29;
  }
  [v9 sortUsingComparator:&__block_literal_global_1133];
  id v68 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  id v10 = *(id *)(a1 + 664);
  uint64_t v11 = [v10 countByEnumeratingWithState:&v69 objects:v73 count:16];
  if (!v11)
  {

    id v12 = 0;
    goto LABEL_27;
  }
  id v12 = 0;
  uint64_t v13 = *(void *)v70;
  do
  {
    for (uint64_t i = 0; i != v11; ++i)
    {
      if (*(void *)v70 != v13) {
        objc_enumerationMutation(v10);
      }
      id v15 = *(id *)(*((void *)&v69 + 1) + 8 * i);
      double v16 = v15;
      if (v12)
      {
        uint64_t v17 = [v15 startDate];
        uint64_t v18 = [v12 endDate];
        int v19 = objc_msgSend(v17, "hk_isBeforeOrEqualToDate:", v18);

        if (v19)
        {
          unint64_t v20 = [v16 endDate];
          long long v21 = [v12 endDate];
          int v22 = objc_msgSend(v20, "hk_isAfterDate:", v21);

          if (!v22) {
            goto LABEL_21;
          }
          id v23 = objc_alloc(MEMORY[0x1E4F28C18]);
          uint64_t v24 = [v12 startDate];
          unint64_t v25 = [v16 endDate];
          id v26 = (id)[v23 initWithStartDate:v24 endDate:v25];
        }
        else
        {
          [v68 addObject:v12];
          id v26 = v16;
        }
        id v12 = v26;
      }
      else
      {
        id v12 = v15;
      }
LABEL_21:
    }
    uint64_t v11 = [v10 countByEnumeratingWithState:&v69 objects:v73 count:16];
  }
  while (v11);

  if (v12) {
    [v68 addObject:v12];
  }
LABEL_27:

LABEL_28:
  int v8 = 1;
LABEL_29:
  unint64_t v27 = *(void **)(a1 + 664);
  *(void *)(a1 + 664) = 0;

  *(unsigned char *)(a1 + 641) = 0;
  if (!v8)
  {
    unint64_t v38 = *(void *)(a1 + 672);
    *(void *)(a1 + 688) = 0;
    *(void *)(a1 + 680) = 0;
    *(void *)(a1 + 672) = 0;
    unint64_t v39 = v38;
    goto LABEL_47;
  }
  unint64_t v28 = [v68 lastObject];
  if (v28)
  {
    uint64_t v29 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_currentBucketInterval(a1);
    unint64_t v30 = [v29 endDate];
    unint64_t v31 = [v28 endDate];
    int v32 = objc_msgSend(v30, "hk_isBeforeOrEqualToDate:", v31);

    if (v32)
    {
      long long v33 = [v28 endDate];
      [v33 timeIntervalSinceReferenceDate];
      double v35 = v34;

      uint64_t v36 = *(void *)(a1 + 672);
      long long v37 = *(long long **)(a1 + 680);
      while ((long long *)v36 != v37)
      {
        if (*(double *)(v36 + 8) < v35)
        {
          if ((long long *)v36 != v37)
          {
            double v40 = (long long *)(v36 + 40);
            if ((long long *)(v36 + 40) != v37)
            {
              do
              {
                if (*((double *)v40 + 1) >= v35)
                {
                  long long v41 = *v40;
                  long long v42 = v40[1];
                  *(_WORD *)(v36 + 32) = *((_WORD *)v40 + 16);
                  *(_OWORD *)uint64_t v36 = v41;
                  *(_OWORD *)(v36 + 16) = v42;
                  v36 += 40;
                }
                double v40 = (long long *)((char *)v40 + 40);
              }
              while (v40 != v37);
              long long v37 = *(long long **)(a1 + 680);
            }
          }
          if ((long long *)v36 != v37) {
            *(void *)(a1 + 680) = v36;
          }
          break;
        }
        v36 += 40;
      }
    }
  }
  unint64_t v38 = *(void *)(a1 + 672);
  unint64_t v39 = *(void *)(a1 + 680);
  *(void *)(a1 + 688) = 0;
  *(void *)(a1 + 672) = 0;
  *(void *)(a1 + 680) = 0;
  if (![v68 count]) {
    goto LABEL_60;
  }
LABEL_47:
  id v43 = v68;
  long long __p = (void *)v38;
  if (v43)
  {
    long long v71 = 0u;
    long long v72 = 0u;
    long long v69 = 0u;
    long long v70 = 0u;
    id v44 = v43;
    uint64_t v45 = [v44 countByEnumeratingWithState:&v69 objects:v73 count:16];
    if (v45)
    {
      uint64_t v46 = *(void *)v70;
      while (2)
      {
        for (uint64_t j = 0; j != v45; ++j)
        {
          if (*(void *)v70 != v46) {
            objc_enumerationMutation(v44);
          }
          id v48 = *(id *)(*((void *)&v69 + 1) + 8 * j);
          int v49 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveInvalidateInterval((id *)a1, v48, v67);

          if (!v49)
          {

            goto LABEL_70;
          }
        }
        uint64_t v45 = [v44 countByEnumeratingWithState:&v69 objects:v73 count:16];
        if (v45) {
          continue;
        }
        break;
      }
    }

LABEL_59:
    unint64_t v38 = (unint64_t)__p;
LABEL_60:
    unint64_t v51 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v39 - v38) >> 3));
    if (v39 == v38) {
      uint64_t v52 = 0;
    }
    else {
      uint64_t v52 = v51;
    }
    int v53 = 1;
    std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(v38, v39, v52, 1);
    long long __p = (void *)v38;
    if (v39 != v38)
    {
      unint64_t v54 = (double *)v38;
      uint64_t v50 = v67;
      do
      {
        int v55 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveAddSample(a1, v54, 1, v50);
        int v53 = v55;
        v54 += 5;
        if (v54 == (double *)v39) {
          char v56 = 0;
        }
        else {
          char v56 = v55;
        }
        uint64_t v50 = v67;
      }
      while ((v56 & 1) != 0);
    }
  }
  else
  {
    if (_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveInvalidateInterval((id *)a1, 0, v67))goto LABEL_59; {
LABEL_70:
    }
    int v53 = 0;
  }
  if (*(void *)(a1 + 40) && *(void *)(a1 + 616) != *(void *)(a1 + 608))
  {
    do
    {
      uint64_t v57 = objc_msgSend(*(id *)(a1 + 40), "dateIntervalAtIndex:", *(void *)(a1 + 112) + 1, v50, v65);
      HDStatisticsBucket<HDStatisticsSleepStages>::_updateSourceOrder(a1 + 120);
      HDStatisticsBucket<HDStatisticsSleepStages>::_mergeThroughTime(a1 + 120, *(double *)(a1 + 128));
      unint64_t v58 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_statisticsFromFinishedBucket(a1, a1 + 120);
      float v59 = [v57 startDate];
      [v59 timeIntervalSinceReferenceDate];
      double v61 = v60;
      uint64_t v62 = [v57 endDate];
      [v62 timeIntervalSinceReferenceDate];
      HDStatisticsCollectionEngine<HDStatisticsSleepStages>::advanceBucket(a1 + 112, v61, v63);

      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_didChangeBucket(a1, v58);
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_notifyForCurrentBucket(a1);
    }
    while (*(void *)(a1 + 616) != *(void *)(a1 + 608));
  }
  *(unsigned char *)(a1 + 642) = 0;
  if (__p) {
    operator delete(__p);
  }

  if (v53)
  {
    if (*(unsigned char *)(a1 + 644))
    {
      *(unsigned char *)(a1 + 644) = 0;
      id v6 = v65;
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_notifyForCurrentBucket(a1);
      uint64_t v7 = 1;
      goto LABEL_82;
    }
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = 0;
  }
  id v6 = v65;
LABEL_82:
  *(unsigned char *)(a1 + 642) = 0;
LABEL_83:

  return v7;
}

void sub_1BD190B6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, void *a12)
{
  if (a2)
  {

    objc_begin_catch(exception_object);
    *(unsigned char *)(v13 + 642) = 0;
    objc_exception_rethrow();
  }
  _Unwind_Resume(exception_object);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::enableImmediateSampleInsertion(uint64_t result)
{
  *(unsigned char *)(result + 643) = 1;
  return result;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::invalidateInterval(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = *(void **)(a1 + 40);
  if (!v6)
  {

    goto LABEL_11;
  }
  if (!v5)
  {
LABEL_11:
    if (*(unsigned char *)(a1 + 642)) {
      goto LABEL_12;
    }
    uint64_t v7 = 0;
LABEL_14:
    uint64_t v11 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveInvalidateInterval((id *)a1, v7, a3);
    goto LABEL_15;
  }
  uint64_t v7 = [v6 dateIntervalForIntervalsContainingInterval:v5];

  if (!*(unsigned char *)(a1 + 642)) {
    goto LABEL_14;
  }
  if (!v7)
  {
LABEL_12:
    id v12 = *(void **)(a1 + 664);
    *(void *)(a1 + 664) = 0;

    uint64_t v7 = 0;
    uint64_t v11 = 1;
    *(unsigned char *)(a1 + 641) = 1;
    goto LABEL_15;
  }
  if (!*(unsigned char *)(a1 + 641))
  {
    int v8 = *(void **)(a1 + 664);
    if (!v8)
    {
      id v9 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      id v10 = *(void **)(a1 + 664);
      *(void *)(a1 + 664) = v9;

      int v8 = *(void **)(a1 + 664);
    }
    [v8 addObject:v7];
  }
  uint64_t v11 = 1;
LABEL_15:

  return v11;
}

void sub_1BD190E6C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::queryForInitialStatistics(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 104));
  if (WeakRetained)
  {
    *(unsigned char *)(a1 + 640) = 1;
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke;
    v9[3] = &unk_1E63043E8;
    uint64_t v12 = a1;
    id v10 = v5;
    id v11 = WeakRetained;
    uint64_t v7 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 112))(a1, v9, a3);
    if (v7 && *(unsigned char *)(a1 + 640) && !*(void *)(a1 + 40)) {
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_configureForStartTime(a1);
    }
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a3, 3, @"Unable to query for initial statistics: no data source available.");
    uint64_t v7 = 0;
  }

  return v7;
}

void sub_1BD190FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::reset(uint64_t result)
{
  *(unsigned char *)(result + 640) = 1;
  return result;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::encodeInternalsWithEncoder(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 encodeBool:*(unsigned __int8 *)(a1 + 640) forKey:@"needs_config"];
  v3;
  v27[0] = &unk_1F1726FA0;
  v27[1] = 0;
  int v28 = 0;
  uint64_t v4 = *(void *)(a1 + 112);
  LOBYTE(v28) = 1;
  v27[2] = v4;
  memset(&v27[3], 0, 24);
  statistics::StatisticsEngine::makeCurrentBucket((uint64_t)v27);
  int v8 = &unk_1F171B9C8;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  int v26 = 511;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  uint64_t v22 = 0;
  int8x16_t v9 = vextq_s8(*(int8x16_t *)(a1 + 120), *(int8x16_t *)(a1 + 120), 8uLL);
  uint64_t v5 = *(void *)(a1 + 136);
  char v24 = *(unsigned char *)(a1 + 144);
  char v25 = *(unsigned char *)(a1 + 145);
  BOOL v23 = *(_DWORD *)(a1 + 148) == 0;
  int8x16_t v10 = vextq_s8(*(int8x16_t *)(a1 + 160), *(int8x16_t *)(a1 + 160), 8uLL);
  uint64_t v6 = *(void *)(a1 + 176);
  uint64_t v14 = v5;
  uint64_t v15 = v6;
  uint64_t v7 = *(int8x16_t **)(a1 + 216);
  if (v7 != *(int8x16_t **)(a1 + 224))
  {
    uint64_t v29 = &unk_1F17206F8;
    int v36 = 127;
    int8x16_t v32 = vextq_s8(*v7, *v7, 8uLL);
    uint64_t v30 = v7[1].i64[0];
    uint64_t v31 = v7[1].i64[1];
    char v35 = 0;
    __int8 v34 = v7[2].i8[9];
    __int8 v33 = v7[2].i8[10];
    PB::PtrVector<statistics::RawQuantitySample>::emplace_back<statistics::RawQuantitySample&>();
  }
  statistics::StatisticsBucket::makeStatistics((uint64_t)&v8);
  HDStatisticsSleepStages::archive((HDStatisticsSleepStages *)(a1 + 240));
}

void sub_1BD1913C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&a35);

  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::decodeInternalsWithDecoder(uint64_t a1, void *a2)
{
  id v46 = a2;
  *(unsigned char *)(a1 + 640) = [v46 decodeBoolForKey:@"needs_config"];
  id v3 = v46;
  HDStatisticsBucket<HDStatisticsSleepStages>::HDStatisticsBucket((uint64_t)&v50.n128_i64[1], 0, -1.79769313e308, 1.79769313e308);
  *(_OWORD *)unint64_t v51 = 0u;
  long long v52 = 0u;
  unint64_t v100 = 0;
  id v49 = v3;
  PB::Reader::Reader((PB::Reader *)v99, (const unsigned __int8 *)[v49 decodeBytesForKey:@"hdsce_archived_representation" returnedLength:&v100]);
  double v92 = &unk_1F1726FA0;
  uint64_t v93 = 0;
  uint64_t v97 = 0;
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  int v98 = 0;
  statistics::StatisticsEngine::readFrom((statistics::StatisticsEngine *)&v92, (PB::Reader *)v99);
  uint64_t v48 = a1;
  v50.n128_u64[0] = v94;
  if (v93)
  {
    uint64_t v57 = 0;
    memset(v60, 0, sizeof(v60));
    *(_OWORD *)long long __p = 0u;
    long long v62 = 0u;
    long long v63 = 0u;
    long long v65 = xmmword_1BD330210;
    uint64_t v64 = 0;
    uint64_t v66 = 0;
    long long v67 = xmmword_1BD330220;
    long long v69 = xmmword_1BD330230;
    uint64_t v68 = 0;
    uint64_t v70 = 0;
    long long v71 = xmmword_1BD330240;
    long long v73 = xmmword_1BD330250;
    uint64_t v72 = 0;
    uint64_t v74 = 0;
    v77[1] = 0;
    v77[0] = 0;
    uint64_t v75 = 0x7FFFFFFFFFFFFFFFLL;
    long long v76 = v77;
    long long v78 = 0u;
    long long v79 = 0u;
    int v80 = 1065353216;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v83 = 0u;
    uint64_t v84 = 0;
    int v85 = 1065353216;
    long long v86 = 0u;
    long long v87 = 0u;
    int v88 = 1065353216;
    long long v89 = 0u;
    long long v90 = 0u;
    int v91 = 1065353216;
    int8x16_t v53 = vextq_s8(*(int8x16_t *)(v93 + 8), *(int8x16_t *)(v93 + 8), 8uLL);
    uint64_t v5 = *(void *)(v93 + 72);
    uint64_t v54 = *(void *)(v93 + 64);
    char v55 = *(unsigned char *)(v93 + 185);
    char v56 = *(unsigned char *)(v93 + 186);
    int8x16_t v58 = vextq_s8(*(int8x16_t *)(v93 + 24), *(int8x16_t *)(v93 + 24), 8uLL);
    uint64_t v59 = v5;
    uint64_t v6 = *(void *)(v93 + 80);
    uint64_t v7 = *(void *)(v93 + 88);
    long long v47 = (void *)v93;
    if (v6 != v7)
    {
      int v8 = 0;
      do
      {
        uint64_t v9 = *(void *)(*(void *)v6 + 24);
        uint64_t v10 = *(void *)(*(void *)v6 + 32);
        uint64_t v11 = *(void *)(*(void *)v6 + 8);
        uint64_t v12 = *(void *)(*(void *)v6 + 16);
        char v13 = *(unsigned char *)(*(void *)v6 + 41);
        char v14 = *(unsigned char *)(*(void *)v6 + 40);
        if ((unint64_t)v8 >= (unint64_t)v62)
        {
          uint64_t v15 = (char *)__p[0];
          unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v8 - (char *)__p[0]) >> 4);
          unint64_t v17 = v16 + 1;
          if (v16 + 1 > 0x555555555555555) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          if (0x5555555555555556 * ((uint64_t)(v62 - (unint64_t)__p[0]) >> 4) > v17) {
            unint64_t v17 = 0x5555555555555556 * ((uint64_t)(v62 - (unint64_t)__p[0]) >> 4);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v62 - (unint64_t)__p[0]) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v18 = 0x555555555555555;
          }
          else {
            unint64_t v18 = v17;
          }
          if (v18)
          {
            unint64_t v18 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v18);
            int v8 = (char *)__p[1];
            uint64_t v15 = (char *)__p[0];
          }
          else
          {
            uint64_t v4 = 0;
          }
          unint64_t v19 = v18 + 48 * v16;
          *(void *)unint64_t v19 = v10;
          *(void *)(v19 + 8) = v9;
          *(void *)(v19 + 16) = v11;
          *(void *)(v19 + 24) = v12;
          *(_WORD *)(v19 + 32) = 1;
          *(unsigned char *)(v19 + 40) = 0;
          *(unsigned char *)(v19 + 41) = v13;
          *(unsigned char *)(v19 + 42) = v14;
          long long v20 = (char *)v19;
          if (v8 != v15)
          {
            do
            {
              long long v21 = *((_OWORD *)v8 - 3);
              long long v22 = *((_OWORD *)v8 - 2);
              *(_OWORD *)(v20 - 21) = *(_OWORD *)(v8 - 21);
              *((_OWORD *)v20 - 3) = v21;
              *((_OWORD *)v20 - 2) = v22;
              v20 -= 48;
              v8 -= 48;
            }
            while (v8 != v15);
            uint64_t v15 = (char *)__p[0];
          }
          int v8 = (char *)(v19 + 48);
          __p[0] = v20;
          __p[1] = (void *)(v19 + 48);
          *(void *)&long long v62 = v18 + 48 * (void)v4;
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *(void *)int v8 = v10;
          *((void *)v8 + 1) = v9;
          *((void *)v8 + 2) = v11;
          *((void *)v8 + 3) = v12;
          *((_WORD *)v8 + 16) = 1;
          v8[40] = 0;
          v8[41] = v13;
          v8[42] = v14;
          v8 += 48;
        }
        __p[1] = v8;
        v6 += 8;
      }
      while (v6 != v7);
    }
    BOOL v23 = (HDStatisticsSleepStages *)v47[13];
    if (v23) {
      HDStatisticsSleepStages::unarchive(v23, v4);
    }
    char v24 = (HDStatisticsSleepStages **)v47[17];
    if (v24 != (HDStatisticsSleepStages **)v47[18]) {
      HDStatisticsSleepStages::unarchive(*v24, v4);
    }
    uint64_t v25 = v47[5];
    for (uint64_t i = v47[6]; v25 != i; v25 += 8)
    {
      double v28 = *(double *)(*(void *)v25 + 8);
      double v27 = *(double *)(*(void *)v25 + 16);
      if (v28 >= v27) {
        double v29 = *(double *)(*(void *)v25 + 16);
      }
      else {
        double v29 = *(double *)(*(void *)v25 + 8);
      }
      if (v27 < v28) {
        double v27 = *(double *)(*(void *)v25 + 8);
      }
      HKIntervalMask<double>::_insertInterval(v60, v29, v27);
    }
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::operator=((uint64_t)&v50.n128_i64[1], (uint64_t)&v53);
    HDStatisticsBucket<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::~HDStatisticsBucket((uint64_t)&v53);
  }
  uint64_t v30 = v95;
  uint64_t v31 = v96;
  if (v95 != v96)
  {
    int8x16_t v32 = (char *)v51[1];
    do
    {
      uint64_t v33 = *(void *)(*(void *)v30 + 24);
      uint64_t v34 = *(void *)(*(void *)v30 + 32);
      uint64_t v35 = *(void *)(*(void *)v30 + 8);
      uint64_t v36 = *(void *)(*(void *)v30 + 16);
      if ((unint64_t)v32 >= (unint64_t)v52)
      {
        long long v37 = (char *)v51[0];
        unint64_t v38 = 0xCCCCCCCCCCCCCCCDLL * ((v32 - (char *)v51[0]) >> 3);
        unint64_t v39 = v38 + 1;
        if (v38 + 1 > 0x666666666666666) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        if (0x999999999999999ALL * ((uint64_t)(v52 - (unint64_t)v51[0]) >> 3) > v39) {
          unint64_t v39 = 0x999999999999999ALL * ((uint64_t)(v52 - (unint64_t)v51[0]) >> 3);
        }
        if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v52 - (unint64_t)v51[0]) >> 3) >= 0x333333333333333) {
          unint64_t v40 = 0x666666666666666;
        }
        else {
          unint64_t v40 = v39;
        }
        if (v40)
        {
          unint64_t v40 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v40);
          int8x16_t v32 = (char *)v51[1];
          long long v37 = (char *)v51[0];
        }
        else
        {
          uint64_t v41 = 0;
        }
        unint64_t v42 = v40 + 40 * v38;
        *(void *)unint64_t v42 = v34;
        *(void *)(v42 + 8) = v33;
        *(void *)(v42 + 16) = v35;
        *(void *)(v42 + 24) = v36;
        *(_WORD *)(v42 + 32) = 1;
        id v43 = (char *)v42;
        if (v32 != v37)
        {
          do
          {
            long long v44 = *(_OWORD *)(v32 - 40);
            long long v45 = *(_OWORD *)(v32 - 24);
            *((_WORD *)v43 - 4) = *((_WORD *)v32 - 4);
            *(_OWORD *)(v43 - 24) = v45;
            *(_OWORD *)(v43 - 40) = v44;
            v43 -= 40;
            v32 -= 40;
          }
          while (v32 != v37);
          long long v37 = (char *)v51[0];
        }
        int8x16_t v32 = (char *)(v42 + 40);
        v51[0] = v43;
        v51[1] = (void *)(v42 + 40);
        *(void *)&long long v52 = v40 + 40 * v41;
        if (v37) {
          operator delete(v37);
        }
      }
      else
      {
        *(void *)int8x16_t v32 = v34;
        *((void *)v32 + 1) = v33;
        *((void *)v32 + 2) = v35;
        *((void *)v32 + 3) = v36;
        *((_WORD *)v32 + 16) = 1;
        v32 += 40;
      }
      v51[1] = v32;
      v30 += 8;
    }
    while (v30 != v31);
  }
  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&v92);

  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::operator=((void *)(v48 + 112), &v50);
  if (v51[0])
  {
    v51[1] = v51[0];
    operator delete(v51[0]);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::~HDStatisticsBucket((uint64_t)&v50.n128_i64[1]);
}

void sub_1BD191B80(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::~__hash_table((uint64_t)&STACK[0x450]);
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table(a2);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&STACK[0x400]);
  unint64_t v18 = (void *)STACK[0x3E8];
  if (STACK[0x3E8])
  {
    STACK[0x3F0] = (unint64_t)v18;
    operator delete(v18);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&STACK[0x3C0]);
  std::__tree<long>::destroy((void *)STACK[0x3B0]);
  unint64_t v19 = (void *)STACK[0x2F0];
  if (STACK[0x2F0])
  {
    STACK[0x2F8] = (unint64_t)v19;
    operator delete(v19);
  }
  objc_destroyWeak((id *)&STACK[0x2E8]);
  long long v20 = (void *)STACK[0x2D0];
  if (STACK[0x2D0])
  {
    STACK[0x2D8] = (unint64_t)v20;
    operator delete(v20);
  }

  statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)&STACK[0x480]);
  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::~HDStatisticsCollectionEngine((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t HDStatisticsBucket<HDStatisticsSleepStages>::HDStatisticsBucket(uint64_t a1, void *a2, double a3, double a4)
{
  *(double *)a1 = a3;
  *(double *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 24) = 256;
  *(_DWORD *)(a1 + 28) = 1;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 32) = 0;
  *(double *)(a1 + 56) = a3;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  objc_initWeak((id *)(a1 + 88), a2);
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 144) = 0;
  *(_OWORD *)(a1 + 152) = xmmword_1BD330210;
  *(void *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 176) = xmmword_1BD330220;
  *(void *)(a1 + 192) = 0;
  *(_OWORD *)(a1 + 200) = xmmword_1BD330230;
  *(void *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 224) = xmmword_1BD330240;
  *(void *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 248) = xmmword_1BD330250;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0x7FFFFFFFFFFFFFFFLL;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 280) = a1 + 288;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_DWORD *)(a1 + 336) = 1065353216;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(void *)(a1 + 392) = 0;
  *(_DWORD *)(a1 + 400) = 1065353216;
  *(_OWORD *)(a1 + 408) = 0u;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_DWORD *)(a1 + 440) = 1065353216;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 480) = 1065353216;
  return a1;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_configureForStartTime(uint64_t a1)
{
  unint64_t v28 = 0;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    id v3 = objc_msgSend(MEMORY[0x1E4F1C9C8], "dateWithTimeIntervalSinceReferenceDate:");
    uint64_t v4 = [v2 dateIntervalContainingDate:v3 index:&v28];

    uint64_t v5 = [v4 startDate];
    [v5 timeIntervalSinceReferenceDate];
    double v7 = v6;

    int v8 = [v4 endDate];
    [v8 timeIntervalSinceReferenceDate];
LABEL_5:
    double v13 = v9;

    goto LABEL_6;
  }
  id v10 = *(id *)(a1 + 64);
  uint64_t v4 = v10;
  if (v10)
  {
    uint64_t v11 = [v10 startDate];
    [v11 timeIntervalSinceReferenceDate];
    double v7 = v12;

    int v8 = [v4 endDate];
    [v8 timeIntervalSinceReferenceDate];
    goto LABEL_5;
  }
  double v7 = -1.79769313e308;
  double v13 = 1.79769313e308;
LABEL_6:

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  HDStatisticsBucket<HDStatisticsSleepStages>::HDStatisticsBucket((uint64_t)v21, WeakRetained, v7, v13);

  if (*(void *)(a1 + 32) == 1) {
    char v23 = 1;
  }
  uint64_t v22 = *(void *)(a1 + 56);
  char v24 = *(unsigned char *)(a1 + 24) & 1;
  if (v27 != (char *)(a1 + 72)) {
    std::vector<HKRawInterval<double>>::__assign_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>(v27, *(char **)(a1 + 72), *(void *)(a1 + 80), (uint64_t)(*(void *)(a1 + 80) - *(void *)(a1 + 72)) >> 4);
  }
  objc_storeStrong(&v26, *(id *)(a1 + 656));
  if (!*(void *)(a1 + 40)) {
    int v25 = 0;
  }
  unint64_t v15 = v28;
  HDStatisticsBucket<HDStatisticsSleepStages>::HDStatisticsBucket((uint64_t)v17, (uint64_t)v21);
  v18.n128_u64[0] = v15;
  HDStatisticsBucket<HDStatisticsSleepStages>::HDStatisticsBucket((uint64_t)&v18.n128_i64[1], (uint64_t)v17);
  long long __p = 0u;
  long long v20 = 0u;
  HDStatisticsCollectionEngine<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::operator=((void *)(a1 + 112), &v18);

  if ((void)__p)
  {
    *((void *)&__p + 1) = __p;
    operator delete((void *)__p);
  }
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::~HDStatisticsBucket((uint64_t)&v18.n128_i64[1]);
  HDStatisticsBucket<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::~HDStatisticsBucket((uint64_t)v17);
  *(unsigned char *)(a1 + 640) = 0;
  return HDStatisticsBucket<HDStatisticsRelative<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>>>::~HDStatisticsBucket((uint64_t)v21);
}

void sub_1BD192014(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t HDStatisticsBucket<HDStatisticsSleepStages>::HDStatisticsBucket(uint64_t a1, uint64_t a2)
{
  long long v4 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 16) = v4;
  *(void *)(a1 + 32) = *(id *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 56);
  long long v6 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 40) = v6;
  *(void *)(a1 + 56) = v5;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  std::vector<HKRawInterval<double>>::__init_with_size[abi:ne180100]<HKRawInterval<double>*,HKRawInterval<double>*>((void *)(a1 + 64), *(const void **)(a2 + 64), *(void *)(a2 + 72), (uint64_t)(*(void *)(a2 + 72) - *(void *)(a2 + 64)) >> 4);
  objc_copyWeak((id *)(a1 + 88), (id *)(a2 + 88));
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  int v8 = *(unsigned char **)(a2 + 96);
  double v7 = *(unsigned char **)(a2 + 104);
  uint64_t v9 = v7 - v8;
  if (v7 != v8)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v9 >> 4) >= 0x555555555555556) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    id v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(0xAAAAAAAAAAAAAAABLL * (v9 >> 4));
    *(void *)(a1 + 96) = v10;
    *(void *)(a1 + 104) = v10;
    *(void *)(a1 + 112) = &v10[48 * v11];
    memmove(v10, v8, v9 - 5);
    *(void *)(a1 + 104) = &v10[16 * (v9 >> 4)];
  }
  long long v12 = *(_OWORD *)(a2 + 120);
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
  *(_OWORD *)(a1 + 120) = v12;
  long long v13 = *(_OWORD *)(a2 + 152);
  long long v14 = *(_OWORD *)(a2 + 168);
  long long v15 = *(_OWORD *)(a2 + 184);
  *(_OWORD *)(a1 + 200) = *(_OWORD *)(a2 + 200);
  *(_OWORD *)(a1 + 184) = v15;
  *(_OWORD *)(a1 + 168) = v14;
  *(_OWORD *)(a1 + 152) = v13;
  long long v16 = *(_OWORD *)(a2 + 216);
  long long v17 = *(_OWORD *)(a2 + 232);
  long long v18 = *(_OWORD *)(a2 + 248);
  *(_OWORD *)(a1 + 264) = *(_OWORD *)(a2 + 264);
  *(_OWORD *)(a1 + 248) = v18;
  *(_OWORD *)(a1 + 232) = v17;
  *(_OWORD *)(a1 + 216) = v16;
  unint64_t v19 = (void *)(a1 + 288);
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 280) = a1 + 288;
  long long v20 = *(void **)(a2 + 280);
  if (v20 != (void *)(a2 + 288))
  {
    long long v21 = 0;
    uint64_t v22 = (void *)(a1 + 288);
    while (1)
    {
      uint64_t v23 = v20[4];
      char v24 = (void *)(a1 + 288);
      if (v22 == v19) {
        goto LABEL_12;
      }
      int v25 = v21;
      id v26 = (void *)(a1 + 288);
      if (v21)
      {
        do
        {
          char v24 = v25;
          int v25 = (void *)v25[1];
        }
        while (v25);
      }
      else
      {
        do
        {
          char v24 = (void *)v26[2];
          BOOL v27 = *v24 == (void)v26;
          id v26 = v24;
        }
        while (v27);
      }
      if (v24[4] < v23)
      {
LABEL_12:
        if (v21) {
          unint64_t v28 = (uint64_t **)v24;
        }
        else {
          unint64_t v28 = (uint64_t **)(a1 + 288);
        }
        if (v21) {
          double v29 = (uint64_t **)(v24 + 1);
        }
        else {
          double v29 = (uint64_t **)(a1 + 288);
        }
        if (!*v29)
        {
LABEL_28:
          int8x16_t v32 = operator new(0xC8uLL);
          long long v33 = *((_OWORD *)v20 + 2);
          long long v34 = *((_OWORD *)v20 + 4);
          v32[3] = *((_OWORD *)v20 + 3);
          v32[4] = v34;
          v32[2] = v33;
          long long v35 = *((_OWORD *)v20 + 5);
          long long v36 = *((_OWORD *)v20 + 6);
          long long v37 = *((_OWORD *)v20 + 8);
          v32[7] = *((_OWORD *)v20 + 7);
          v32[8] = v37;
          v32[5] = v35;
          v32[6] = v36;
          long long v38 = *((_OWORD *)v20 + 9);
          long long v39 = *((_OWORD *)v20 + 10);
          long long v40 = *((_OWORD *)v20 + 11);
          *((void *)v32 + 24) = v20[24];
          v32[10] = v39;
          v32[11] = v40;
          v32[9] = v38;
          std::__tree<unsigned long long>::__insert_node_at((uint64_t **)(a1 + 280), (uint64_t)v28, v29, (uint64_t *)v32);
        }
      }
      else
      {
        double v29 = (uint64_t **)(a1 + 288);
        unint64_t v28 = (uint64_t **)(a1 + 288);
        if (!v21) {
          goto LABEL_28;
        }
        uint64_t v30 = v21;
        while (1)
        {
          while (1)
          {
            unint64_t v28 = (uint64_t **)v30;
            uint64_t v31 = v30[4];
            if (v31 <= v23) {
              break;
            }
            uint64_t v30 = *v28;
            double v29 = v28;
            if (!*v28) {
              goto LABEL_28;
            }
          }
          if (v31 >= v23) {
            break;
          }
          uint64_t v30 = v28[1];
          if (!v30)
          {
            double v29 = v28 + 1;
            goto LABEL_28;
          }
        }
      }
      uint64_t v41 = (void *)v20[1];
      if (v41)
      {
        do
        {
          unint64_t v42 = v41;
          uint64_t v41 = (void *)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          unint64_t v42 = (void *)v20[2];
          BOOL v27 = *v42 == (void)v20;
          long long v20 = v42;
        }
        while (!v27);
      }
      if (v42 == (void *)(a2 + 288)) {
        break;
      }
      long long v21 = (void *)*v19;
      uint64_t v22 = *(void **)(a1 + 280);
      long long v20 = v42;
    }
  }
  std::unordered_set<long long>::unordered_set(a1 + 304, a2 + 304);
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0;
  *(void *)(a1 + 360) = 0;
  std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>((void *)(a1 + 344), *(const void **)(a2 + 344), *(void *)(a2 + 352), (uint64_t)(*(void *)(a2 + 352) - *(void *)(a2 + 344)) >> 3);
  std::unordered_map<long long,long long>::unordered_map(a1 + 368, a2 + 368);
  std::unordered_map<NSString * {__strong},long long,HDStringHash,HDStringEqual,std::allocator<std::pair<NSString * const {__strong},long long>>>::unordered_map(a1 + 408, a2 + 408);
  std::unordered_map<long long,NSString * {__strong}>::unordered_map(a1 + 448, a2 + 448);
  return a1;
}

void sub_1BD1923B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, id *location, void **a12)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::~__hash_table(v16);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v15);
  unint64_t v19 = *v14;
  if (*v14)
  {
    *(void *)(v12 + 352) = v19;
    operator delete(v19);
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(v13);
  std::__tree<long>::destroy(*v17);
  long long v20 = *a10;
  if (*a10)
  {
    *(void *)(v12 + 104) = v20;
    operator delete(v20);
  }
  objc_destroyWeak(location);
  long long v21 = *a12;
  if (*a12)
  {
    *(void *)(v12 + 72) = v21;
    operator delete(v21);
  }

  _Unwind_Resume(a1);
}

id _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_statisticsFromFinishedBucket(uint64_t a1, uint64_t a2)
{
  uint64_t v124 = *MEMORY[0x1E4F143B8];
  double v5 = *(double *)a2;
  id v6 = objc_alloc(MEMORY[0x1E4F1C9C8]);
  double v7 = (double *)(a2 + 40);
  if (v5 != -1.79769313e308) {
    double v7 = (double *)a2;
  }
  id v108 = (id)[v6 initWithTimeIntervalSinceReferenceDate:*v7];
  uint64_t v111 = a2;
  if (*(double *)(a2 + 8) == 1.79769313e308) {
    uint64_t v8 = [objc_alloc(MEMORY[0x1E4F1C9C8]) initWithTimeIntervalSinceReferenceDate:*(double *)(a2 + 48)];
  }
  else {
    uint64_t v8 = [objc_alloc(MEMORY[0x1E4F1C9C8]) initWithTimeIntervalSinceReferenceDate:*(double *)(a2 + 8)];
  }
  uint64_t v9 = (void *)v8;
  id v10 = *(id *)(a1 + 16);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v11 = *(id *)(a1 + 16);
    if ([v11 shouldUseUnderlyingTypeForStatistics])
    {
      uint64_t v12 = [v11 underlyingSampleType];

      id v10 = (id)v12;
    }
  }
  uint64_t v13 = (void *)[objc_alloc(MEMORY[0x1E4F2B5B0]) initWithDataType:v10 startDate:v108 endDate:v9];
  if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v2 = a1 + 48;
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));

    if (WeakRetained)
    {
      id v15 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
      uint64_t v16 = *(uint64_t **)(a2 + 344);
      long long v17 = *(uint64_t **)(a2 + 352);
      while (v16 != v17)
      {
        uint64_t v18 = *v16;
        id v19 = objc_loadWeakRetained((id *)(a1 + 48));
        long long v20 = [v19 sourceForSourceID:v18];

        if (v20)
        {
          if (([v15 containsObject:v20] & 1) == 0) {
            [v15 addObject:v20];
          }
        }

        ++v16;
      }
      uint64_t v2 = [v15 copy];
      [v13 _setSources:v2];
    }
  }

  v122[0] = &unk_1F1726ED0;
  uint64_t v123 = v122;
  id v109 = v13;
  long long v21 = *(_OWORD *)(v111 + 232);
  long long v118 = *(_OWORD *)(v111 + 216);
  long long v119 = v21;
  long long v22 = *(_OWORD *)(v111 + 264);
  long long v120 = *(_OWORD *)(v111 + 248);
  long long v121 = v22;
  long long v23 = *(_OWORD *)(v111 + 168);
  long long v114 = *(_OWORD *)(v111 + 152);
  long long v115 = v23;
  long long v24 = *(_OWORD *)(v111 + 200);
  long long v116 = *(_OWORD *)(v111 + 184);
  long long v117 = v24;
  long long v25 = *(_OWORD *)(v111 + 136);
  *(_OWORD *)long long __p = *(_OWORD *)(v111 + 120);
  long long v113 = v25;
  if (!v123) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v26 = (*(uint64_t (**)(void *, void **))(*v123 + 48))(v123, __p);
  uint64_t v27 = 0;
  double v28 = 0.0;
  uint64_t v29 = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v30 = 0x7FFFFFFFFFFFFFFFLL;
  do
  {
    uint64_t v31 = v26 + v27;
    double v32 = *(double *)(v26 + v27 + 24);
    if (v32 > 2.22507386e-308 && v32 >= v28)
    {
      if (v32 <= v28)
      {
        if (*(void *)(v26 + v27 + 32) < v29)
        {
          uint64_t v30 = *(void *)(v31 + 16);
          double v28 = *(double *)(v26 + v27 + 24);
          uint64_t v29 = *(void *)(v26 + v27 + 32);
        }
      }
      else
      {
        uint64_t v30 = *(void *)(v31 + 16);
        uint64_t v29 = *(void *)(v26 + v27 + 32);
        double v28 = *(double *)(v26 + v27 + 24);
      }
    }
    v27 += 24;
  }
  while (v27 != 144);
  if (v30 != 0x7FFFFFFFFFFFFFFFLL)
  {
    long long v34 = [NSNumber numberWithInteger:v28];
    [v109 setCategoryValue:v34];
  }
  long long v35 = *(_OWORD *)(v111 + 232);
  long long v118 = *(_OWORD *)(v111 + 216);
  long long v119 = v35;
  long long v36 = *(_OWORD *)(v111 + 264);
  long long v120 = *(_OWORD *)(v111 + 248);
  long long v121 = v36;
  long long v37 = *(_OWORD *)(v111 + 168);
  long long v114 = *(_OWORD *)(v111 + 152);
  long long v115 = v37;
  long long v38 = *(_OWORD *)(v111 + 200);
  long long v116 = *(_OWORD *)(v111 + 184);
  long long v117 = v38;
  long long v39 = *(_OWORD *)(v111 + 136);
  *(_OWORD *)long long __p = *(_OWORD *)(v111 + 120);
  long long v113 = v39;
  if (!v123) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  objc_msgSend(v109, "setDataCount:", *(void *)(*(uint64_t (**)(void *, void **))(*v123 + 48))(v123, __p));
  if (*(unsigned char *)(a1 + 24))
  {
    id v110 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
    long long v40 = *(uint64_t **)(v111 + 344);
    uint64_t v41 = *(uint64_t **)(v111 + 352);
    if (v40 != v41)
    {
      unint64_t v42 = (id *)(a1 + 48);
      do
      {
        uint64_t v43 = *v40;
        id v44 = objc_loadWeakRetained(v42);
        long long v45 = [v44 sourceForSourceID:v43];

        if (v45 && ([v110 containsObject:v45] & 1) == 0) {
          [v110 addObject:v45];
        }

        ++v40;
      }
      while (v40 != v41);
    }
    id v46 = (void *)[v110 copy];
    [v109 _setSources:v46];

    id v105 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    id v107 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    *(_OWORD *)long long __p = 0u;
    long long v113 = 0u;
    LODWORD(v114) = 1065353216;
    long long v47 = *(void **)(v111 + 280);
    if (v47 != (void *)(v111 + 288))
    {
      while (1)
      {
        uint64_t v48 = HDStatisticsBucket<HDStatisticsSleepStages>::_bundleIdentifierForSourceID(v111, v47[4]);
        id v49 = v48;
        if (!v48) {
          goto LABEL_117;
        }
        unint64_t v50 = [v48 hash];
        unint64_t v51 = v50;
        unint64_t v52 = (unint64_t)__p[1];
        if (!__p[1]) {
          break;
        }
        uint8x8_t v53 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
        v53.i16[0] = vaddlv_u8(v53);
        unint64_t v54 = v53.u32[0];
        if (v53.u32[0] > 1uLL)
        {
          uint64_t v2 = v50;
          if ((void *)v50 >= __p[1]) {
            uint64_t v2 = v50 % (unint64_t)__p[1];
          }
        }
        else
        {
          uint64_t v2 = ((unint64_t)__p[1] - 1) & v50;
        }
        char v55 = (void **)*((void *)__p[0] + v2);
        if (!v55) {
          break;
        }
        char v56 = (char *)*v55;
        if (!*v55) {
          break;
        }
        unint64_t v106 = (unint64_t)__p[1] - 1;
        while (1)
        {
          unint64_t v57 = *((void *)v56 + 1);
          if (v57 == v51) {
            break;
          }
          if (v54 > 1)
          {
            if (v57 >= v52) {
              v57 %= v52;
            }
          }
          else
          {
            v57 &= v106;
          }
          if (v57 != v2) {
            goto LABEL_60;
          }
LABEL_59:
          char v56 = *(char **)v56;
          if (!v56) {
            goto LABEL_60;
          }
        }
        id v58 = *((id *)v56 + 2);
        id v59 = v49;
        double v60 = v59;
        if (v58 != v59)
        {
          char v61 = [v58 isEqualToString:v59];

          if (v61) {
            goto LABEL_116;
          }
          goto LABEL_59;
        }

LABEL_116:
        long long v81 = *(_OWORD *)(v47 + 5);
        *(_OWORD *)(v56 + 40) = *(_OWORD *)(v47 + 7);
        *(_OWORD *)(v56 + 24) = v81;
        long long v82 = *(_OWORD *)(v47 + 9);
        long long v83 = *(_OWORD *)(v47 + 11);
        long long v84 = *(_OWORD *)(v47 + 13);
        *(_OWORD *)(v56 + 104) = *(_OWORD *)(v47 + 15);
        *(_OWORD *)(v56 + 88) = v84;
        *(_OWORD *)(v56 + 72) = v83;
        *(_OWORD *)(v56 + 56) = v82;
        long long v85 = *(_OWORD *)(v47 + 17);
        long long v86 = *(_OWORD *)(v47 + 19);
        long long v87 = *(_OWORD *)(v47 + 21);
        *(_OWORD *)(v56 + 168) = *(_OWORD *)(v47 + 23);
        *(_OWORD *)(v56 + 152) = v87;
        *(_OWORD *)(v56 + 136) = v86;
        *(_OWORD *)(v56 + 120) = v85;

LABEL_117:
        int v88 = (void *)v47[1];
        if (v88)
        {
          do
          {
            long long v89 = v88;
            int v88 = (void *)*v88;
          }
          while (v88);
        }
        else
        {
          do
          {
            long long v89 = (void *)v47[2];
            BOOL v90 = *v89 == (void)v47;
            long long v47 = v89;
          }
          while (!v90);
        }
        long long v47 = v89;
        if (v89 == (void *)(v111 + 288))
        {
          for (uint64_t i = (uint64_t **)v113; i; uint64_t i = (uint64_t **)*i)
          {
            uint64_t v93 = i[2];
            if (!v123) {
              goto LABEL_154;
            }
            uint64_t v94 = (*(uint64_t (**)(void *, uint64_t *))(*v123 + 48))(v123, (uint64_t *)i + 3);
            uint64_t v95 = 0;
            double v96 = 0.0;
            uint64_t v97 = 0x7FFFFFFFFFFFFFFFLL;
            uint64_t v98 = 0x7FFFFFFFFFFFFFFFLL;
            do
            {
              uint64_t v99 = v94 + v95;
              double v100 = *(double *)(v94 + v95 + 24);
              if (v100 > 2.22507386e-308 && v100 >= v96)
              {
                if (v100 <= v96)
                {
                  if (*(void *)(v94 + v95 + 32) < v97)
                  {
                    uint64_t v98 = *(void *)(v99 + 16);
                    double v96 = *(double *)(v94 + v95 + 24);
                    uint64_t v97 = *(void *)(v94 + v95 + 32);
                  }
                }
                else
                {
                  uint64_t v98 = *(void *)(v99 + 16);
                  uint64_t v97 = *(void *)(v94 + v95 + 32);
                  double v96 = *(double *)(v94 + v95 + 24);
                }
              }
              v95 += 24;
            }
            while (v95 != 144);
            if (v98 != 0x7FFFFFFFFFFFFFFFLL)
            {
              long long v102 = [NSNumber numberWithInteger:v96];
              [v105 setObject:v102 forKeyedSubscript:v93];
            }
            if (!v123) {
LABEL_154:
            }
              std::__throw_bad_function_call[abi:ne180100]();
            double v103 = objc_msgSend(NSNumber, "numberWithLongLong:", *(void *)(*(uint64_t (**)(void *, uint64_t *))(*v123 + 48))(v123, (uint64_t *)i + 3));
            [v107 setObject:v103 forKeyedSubscript:v93];
          }
          goto LABEL_150;
        }
      }
LABEL_60:
      char v56 = (char *)operator new(0xB8uLL);
      *(void *)char v56 = 0;
      *((void *)v56 + 1) = v51;
      *((void *)v56 + 2) = v49;
      *(_OWORD *)(v56 + 24) = 0u;
      *(_OWORD *)(v56 + 40) = 0u;
      *(_OWORD *)(v56 + 56) = xmmword_1BD330210;
      *((void *)v56 + 9) = 0;
      *((_OWORD *)v56 + 5) = xmmword_1BD330220;
      *((void *)v56 + 12) = 0;
      *(_OWORD *)(v56 + 104) = xmmword_1BD330230;
      *((void *)v56 + 15) = 0;
      *((_OWORD *)v56 + 8) = xmmword_1BD330240;
      *((void *)v56 + 18) = 0;
      *(_OWORD *)(v56 + 152) = xmmword_1BD330250;
      *((void *)v56 + 21) = 0;
      *((void *)v56 + 22) = 0x7FFFFFFFFFFFFFFFLL;
      float v62 = (float)(unint64_t)(*((void *)&v113 + 1) + 1);
      if (!v52 || (float)(*(float *)&v114 * (float)v52) < v62)
      {
        BOOL v63 = (v52 & (v52 - 1)) != 0;
        if (v52 < 3) {
          BOOL v63 = 1;
        }
        unint64_t v64 = v63 | (2 * v52);
        unint64_t v65 = vcvtps_u32_f32(v62 / *(float *)&v114);
        if (v64 <= v65) {
          int8x8_t prime = (int8x8_t)v65;
        }
        else {
          int8x8_t prime = (int8x8_t)v64;
        }
        if (*(void *)&prime == 1)
        {
          int8x8_t prime = (int8x8_t)2;
        }
        else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
        {
          int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        }
        unint64_t v52 = (unint64_t)__p[1];
        if ((void *)*(void *)&prime <= __p[1])
        {
          if ((void *)*(void *)&prime < __p[1])
          {
            unint64_t v73 = vcvtps_u32_f32((float)*((unint64_t *)&v113 + 1) / *(float *)&v114);
            if (__p[1] < (void *)3
              || (uint8x8_t v74 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]), v74.i16[0] = vaddlv_u8(v74), v74.u32[0] > 1uLL))
            {
              unint64_t v73 = std::__next_prime(v73);
            }
            else
            {
              uint64_t v75 = 1 << -(char)__clz(v73 - 1);
              if (v73 >= 2) {
                unint64_t v73 = v75;
              }
            }
            if (*(void *)&prime <= v73) {
              int8x8_t prime = (int8x8_t)v73;
            }
            if (*(void *)&prime >= v52)
            {
              unint64_t v52 = (unint64_t)__p[1];
            }
            else
            {
              if (prime) {
                goto LABEL_72;
              }
              int v91 = __p[0];
              __p[0] = 0;
              if (v91) {
                operator delete(v91);
              }
              unint64_t v52 = 0;
              __p[1] = 0;
            }
          }
        }
        else
        {
LABEL_72:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          long long v67 = operator new(8 * *(void *)&prime);
          uint64_t v68 = __p[0];
          __p[0] = v67;
          if (v68) {
            operator delete(v68);
          }
          uint64_t v69 = 0;
          __p[1] = (void *)prime;
          do
            *((void *)__p[0] + v69++) = 0;
          while (*(void *)&prime != v69);
          uint64_t v70 = (void **)v113;
          if ((void)v113)
          {
            unint64_t v71 = *(void *)(v113 + 8);
            uint8x8_t v72 = (uint8x8_t)vcnt_s8(prime);
            v72.i16[0] = vaddlv_u8(v72);
            if (v72.u32[0] > 1uLL)
            {
              if (v71 >= *(void *)&prime) {
                v71 %= *(void *)&prime;
              }
            }
            else
            {
              v71 &= *(void *)&prime - 1;
            }
            *((void *)__p[0] + v71) = &v113;
            for (j = *v70; j; unint64_t v71 = v77)
            {
              unint64_t v77 = j[1];
              if (v72.u32[0] > 1uLL)
              {
                if (v77 >= *(void *)&prime) {
                  v77 %= *(void *)&prime;
                }
              }
              else
              {
                v77 &= *(void *)&prime - 1;
              }
              if (v77 != v71)
              {
                if (!*((void *)__p[0] + v77))
                {
                  *((void *)__p[0] + v77) = v70;
                  goto LABEL_97;
                }
                *uint64_t v70 = (void *)*j;
                *uint64_t j = **((void **)__p[0] + v77);
                **((void **)__p[0] + v77) = j;
                uint64_t j = v70;
              }
              unint64_t v77 = v71;
LABEL_97:
              uint64_t v70 = (void **)j;
              uint64_t j = (void *)*j;
            }
          }
          unint64_t v52 = (unint64_t)prime;
        }
        if ((v52 & (v52 - 1)) != 0)
        {
          if (v51 >= v52) {
            uint64_t v2 = v51 % v52;
          }
          else {
            uint64_t v2 = v51;
          }
        }
        else
        {
          uint64_t v2 = (v52 - 1) & v51;
        }
      }
      long long v78 = __p[0];
      long long v79 = (void *)*((void *)__p[0] + v2);
      if (v79)
      {
        *(void *)char v56 = *v79;
      }
      else
      {
        *(void *)char v56 = v113;
        *(void *)&long long v113 = v56;
        v78[v2] = &v113;
        if (!*(void *)v56)
        {
LABEL_115:
          ++*((void *)&v113 + 1);
          goto LABEL_116;
        }
        unint64_t v80 = *(void *)(*(void *)v56 + 8);
        if ((v52 & (v52 - 1)) != 0)
        {
          if (v80 >= v52) {
            v80 %= v52;
          }
        }
        else
        {
          v80 &= v52 - 1;
        }
        long long v79 = (char *)__p[0] + 8 * v80;
      }
      *long long v79 = v56;
      goto LABEL_115;
    }
LABEL_150:
    std::__hash_table<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsDiscrete>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsDiscrete>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsDiscrete>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},HDStatisticsRelative<HDStatisticsDiscrete>>>>::~__hash_table((uint64_t)__p);
    [v109 setCategoryValueBySource:v105];
    [v109 setDataCountBySource:v107];
  }
  std::__function::__value_func<HDStatisticsSleepStages const& ()(HDStatisticsSleepStages const&)>::~__value_func[abi:ne180100](v122);

  return v109;
}

void sub_1BD193008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  _Unwind_Resume(a1);
}

void HDStatisticsBucket<HDStatisticsSleepStages>::_updateSourceOrder(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 328);
  uint64_t v2 = *(void *)(a1 + 344);
  if (v1 != (*(void *)(a1 + 352) - v2) >> 3)
  {
    long long v4 = (void **)(a1 + 344);
    *(void *)(a1 + 352) = v2;
    std::vector<long long>::reserve((void **)(a1 + 344), v1);
    double v5 = *(void **)(a1 + 320);
    if (v5)
    {
      id v6 = *(char **)(a1 + 352);
      do
      {
        uint64_t v7 = v5[2];
        unint64_t v8 = *(void *)(a1 + 360);
        if ((unint64_t)v6 >= v8)
        {
          id v10 = (char *)*v4;
          uint64_t v11 = (v6 - (unsigned char *)*v4) >> 3;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 61) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v13 = v8 - (void)v10;
          if (v13 >> 2 > v12) {
            unint64_t v12 = v13 >> 2;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14)
          {
            unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v14);
            id v10 = *(char **)(a1 + 344);
            id v6 = *(char **)(a1 + 352);
          }
          else
          {
            uint64_t v15 = 0;
          }
          uint64_t v16 = (void *)(v14 + 8 * v11);
          *uint64_t v16 = v7;
          uint64_t v9 = (char *)(v16 + 1);
          while (v6 != v10)
          {
            uint64_t v17 = *((void *)v6 - 1);
            v6 -= 8;
            *--uint64_t v16 = v17;
          }
          *(void *)(a1 + 344) = v16;
          *(void *)(a1 + 352) = v9;
          *(void *)(a1 + 360) = v14 + 8 * v15;
          if (v10) {
            operator delete(v10);
          }
        }
        else
        {
          *(void *)id v6 = v7;
          uint64_t v9 = v6 + 8;
        }
        *(void *)(a1 + 352) = v9;
        double v5 = (void *)*v5;
        id v6 = v9;
      }
      while (v5);
    }
    uint64_t v18 = (id *)(a1 + 88);
    id WeakRetained = objc_loadWeakRetained(v18);

    if (WeakRetained)
    {
      id v20 = objc_loadWeakRetained(v18);
      [v20 orderSourceIDs:v4];
    }
  }
}

void sub_1BD1932F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsBucket<HDStatisticsSleepStages>::_mergeThroughTime(uint64_t a1, double a2)
{
  double v4 = *(double *)(a1 + 16);
  if (v4 > 0.0 && *(double *)(a1 + 8) > a2) {
    a2 = v4 * floor(a2 / v4);
  }
  double v5 = *(double *)(a1 + 56);
  if (v5 < a2)
  {
    long long v147 = (void *)(a1 + 96);
    v143 = (double **)(a1 + 64);
    location = (id *)(a1 + 88);
    v138 = (void *)(a1 + 288);
    while (1)
    {
      uint64_t v6 = *(void *)(a1 + 96);
      uint64_t v7 = *(long long **)(a1 + 104);
      unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - v6) >> 4);
      if (v8) {
        break;
      }
LABEL_147:
      *(double *)(a1 + 56) = a2;
LABEL_148:
      double v135 = *(double *)(a1 + 56);
      if (v135 == v5)
      {
        v136 = [MEMORY[0x1E4F28B00] currentHandler];
        v137 = [NSString stringWithUTF8String:"void HDStatisticsBucket<HDStatisticsSleepStages>::_mergeThroughTime(double) [Statistics = HDStatisticsSleepStages]"];
        [v136 handleFailureInFunction:v137 file:@"HDStatisticsBucket.hpp" lineNumber:234 description:@"Failed to make forward progress during statistics merge."];

        double v135 = *(double *)(a1 + 56);
      }
      double v5 = v135;
      if (v135 >= a2) {
        return;
      }
    }
    if (v8 != 1)
    {
      double v17 = a2;
      double v18 = a2;
      double v19 = v5;
      uint64_t v20 = *(void *)(a1 + 96);
      if ((long long *)v6 != v7)
      {
        do
        {
          double v21 = *(double *)(v20 + 8);
          double v22 = *(double *)(v20 + 16);
          if (v21 > v19 && v21 < v18) {
            double v18 = *(double *)(v20 + 8);
          }
          if (v22 > v5) {
            double v24 = *(double *)(v20 + 16);
          }
          else {
            double v24 = v17;
          }
          if (v22 < v17)
          {
            double v19 = v5;
            double v17 = v24;
          }
          v20 += 48;
        }
        while ((long long *)v20 != v7);
      }
      if (v17 >= v18) {
        double v25 = v18;
      }
      else {
        double v25 = v17;
      }
      double v26 = *(double *)(a1 + 16);
      if (v26 > 0.0)
      {
        double v27 = v26 * floor(v25 / v26);
        double v28 = v26 * floor((v26 + v5) / v26);
        if (v27 >= v28) {
          double v25 = v27;
        }
        else {
          double v25 = v28;
        }
      }
      *long long v147 = 0;
      v147[1] = 0;
      v147[2] = 0;
      unint64_t v140 = (long long *)v6;
      if ((long long *)v6 != v7)
      {
        if (v8 > 0x555555555555555) {
          std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - v6) >> 4));
        double v32 = *(char **)(a1 + 96);
        uint64_t v31 = *(char **)(a1 + 104);
        long long v33 = v29;
        if (v31 != v32)
        {
          do
          {
            long long v34 = *((_OWORD *)v31 - 3);
            long long v35 = *((_OWORD *)v31 - 2);
            *(_OWORD *)(v33 - 21) = *(_OWORD *)(v31 - 21);
            *((_OWORD *)v33 - 3) = v34;
            *((_OWORD *)v33 - 2) = v35;
            v33 -= 48;
            v31 -= 48;
          }
          while (v31 != v32);
          uint64_t v31 = (char *)*v147;
        }
        *(void *)(a1 + 96) = v33;
        *(void *)(a1 + 104) = v29;
        *(void *)(a1 + 112) = &v29[48 * v30];
        if (v31) {
          operator delete(v31);
        }
      }
      HDStatisticsBucket<HDStatisticsSleepStages>::_updateSourceOrder(a1);
      id WeakRetained = objc_loadWeakRetained(location);

      if (WeakRetained)
      {
        *(void *)&long long v149 = a1;
        unint64_t v37 = 126 - 2 * __clz(v8);
        unint64_t v38 = (unint64_t)v140;
        if (v140 == v7) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = v37;
        }
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*,false>((unint64_t)v140, v7, (uint64_t)&v149, v39, 1);
      }
      else
      {
        unint64_t v42 = 126 - 2 * __clz(v8);
        unint64_t v38 = (unint64_t)v140;
        if (v140 == v7) {
          uint64_t v39 = 0;
        }
        else {
          uint64_t v39 = v42;
        }
      }
      std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*,false>(v38, v7, v39, 1);
      if (*(unsigned char *)(a1 + 25)) {
        id v141 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
      }
      else {
        id v141 = 0;
      }
      if (v140 == v7)
      {
LABEL_121:
        id v107 = *(void **)(a1 + 280);
        if (v107 != v138)
        {
          do
          {
            id v108 = (void *)v107[1];
            if (v108)
            {
              do
              {
                id v109 = v108;
                id v108 = (void *)*v108;
              }
              while (v108);
            }
            else
            {
              do
              {
                id v109 = (void *)v107[2];
                BOOL v110 = *v109 == (void)v107;
                id v107 = v109;
              }
              while (!v110);
            }
            id v107 = v109;
          }
          while (v109 != v138);
        }
        *(double *)(a1 + 56) = v25;

        if (v140) {
          operator delete(v140);
        }
        goto LABEL_148;
      }
      uint64_t v142 = 0;
      char v43 = 0;
      id v44 = v140;
      while (2)
      {
        long long v45 = v44[1];
        long long v149 = *v44;
        long long v150 = v45;
        uint64_t v151 = *((void *)v44 + 4);
        uint64_t v46 = v149;
        uint64_t v47 = v45;
        if (*(double *)&v45 - *((double *)&v149 + 1) - (v25 - *((double *)&v149 + 1)) >= 0.01)
        {
          if (v25 - *((double *)&v149 + 1) < 0.01)
          {
            LOBYTE(v151) = 0;
            goto LABEL_66;
          }
          uint64_t v48 = *((void *)&v150 + 1);
          char v50 = BYTE1(v151);
          *(double *)&long long v150 = v25;
          double v51 = v25;
          int v49 = v151;
          if ((_BYTE)v151) {
            goto LABEL_57;
          }
LABEL_66:
          double v60 = *(long long **)(a1 + 104);
          unint64_t v61 = *(void *)(a1 + 112);
          if ((unint64_t)v60 < v61)
          {
            long long v62 = *v44;
            long long v63 = v44[2];
            v60[1] = v44[1];
            v60[2] = v63;
            *double v60 = v62;
            unint64_t v64 = v60 + 3;
            goto LABEL_119;
          }
          unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v60 - *v147) >> 4);
          unint64_t v66 = v65 + 1;
          if (v65 + 1 > 0x555555555555555) {
            std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v67 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v61 - *v147) >> 4);
          if (2 * v67 > v66) {
            unint64_t v66 = 2 * v67;
          }
          if (v67 >= 0x2AAAAAAAAAAAAAALL) {
            unint64_t v68 = 0x555555555555555;
          }
          else {
            unint64_t v68 = v66;
          }
          if (v68) {
            unint64_t v68 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v68);
          }
          else {
            uint64_t v69 = 0;
          }
          long long v78 = (long long *)(v68 + 48 * v65);
          long long v79 = *v44;
          long long v80 = v44[2];
          v78[1] = v44[1];
          v78[2] = v80;
          *long long v78 = v79;
          long long v82 = *(char **)(a1 + 96);
          long long v81 = *(char **)(a1 + 104);
          long long v83 = v78;
          if (v81 != v82)
          {
            do
            {
              long long v84 = *((_OWORD *)v81 - 3);
              long long v85 = *((_OWORD *)v81 - 2);
              *(long long *)((char *)v83 - 21) = *(_OWORD *)(v81 - 21);
              *(v83 - 3) = v84;
              *(v83 - 2) = v85;
              v83 -= 3;
              v81 -= 48;
            }
            while (v81 != v82);
            long long v81 = (char *)*v147;
          }
          unint64_t v64 = v78 + 3;
          *(void *)(a1 + 96) = v83;
          *(void *)(a1 + 104) = v78 + 3;
          *(void *)(a1 + 112) = v68 + 48 * v69;
          if (v81)
          {
            long long v86 = v81;
            goto LABEL_118;
          }
LABEL_119:
          *(void *)(a1 + 104) = v64;
        }
        else
        {
          uint64_t v48 = 0;
          int v49 = 0;
          char v50 = 0;
          double v51 = 0.0;
          uint64_t v47 = 0;
          if (!(_BYTE)v151) {
            goto LABEL_66;
          }
LABEL_57:
          char v145 = v50;
          uint64_t v146 = v48;
          HDRawQuantitySample::applyMask((uint64_t)&v149, v143);
          int v52 = *((unsigned __int8 *)v44 + 42);
          int v53 = *((unsigned __int8 *)v44 + 41);
          char v144 = *((unsigned char *)v44 + 40);
          if ((_BYTE)v151)
          {
            if (v43)
            {
              unint64_t v54 = *((void *)&v150 + 1);
              if (v142 == *((void *)&v150 + 1) || *(unsigned char *)(a1 + 24))
              {
                if (!*((unsigned char *)v44 + 42)) {
                  ++*(void *)(a1 + 120);
                }
                uint64_t v55 = a1 + 24 * (uint64_t)*(double *)&v149;
                double v56 = *(double *)(v55 + 144);
                uint64_t v57 = *(void *)(v55 + 152);
                uint64_t v58 = *(void *)(a1 + 128);
                if (v58 < v57)
                {
                  uint64_t v57 = v58 + 1;
                  *(void *)(a1 + 128) = v58 + 1;
                }
                uint64_t v59 = v55 + 136;
                *(double *)(v59 + 8) = v56 + *(double *)&v150 - *((double *)&v149 + 1);
                *(void *)(v59 + 16) = v57;
                int v52 = 1;
              }
            }
            else
            {
              if (!*((unsigned char *)v44 + 42)) {
                ++*(void *)(a1 + 120);
              }
              uint64_t v70 = a1 + 24 * (uint64_t)*(double *)&v149;
              double v71 = *(double *)(v70 + 144);
              uint64_t v72 = *(void *)(v70 + 152);
              uint64_t v73 = *(void *)(a1 + 128);
              if (v73 < v72)
              {
                uint64_t v72 = v73 + 1;
                *(void *)(a1 + 128) = v73 + 1;
              }
              uint64_t v74 = v70 + 136;
              *(double *)(v74 + 8) = v71 + *(double *)&v150 - *((double *)&v149 + 1);
              *(void *)(v74 + 16) = v72;
              int v52 = 1;
              unint64_t v54 = *((void *)&v150 + 1);
              uint64_t v142 = *((void *)&v150 + 1);
            }
            if (*(unsigned char *)(a1 + 25))
            {
              uint64_t v75 = HDStatisticsBucket<HDStatisticsSleepStages>::_bundleIdentifierForSourceID(a1, v54);
              if (v75)
              {
                long long v76 = [v141 objectForKeyedSubscript:v75];
                unint64_t v77 = v76;
                if (v76)
                {
                  if ([v76 longLongValue] != v54 && !*(unsigned char *)(a1 + 24)) {
                    goto LABEL_99;
                  }
                }
                else
                {
                  long long v87 = [NSNumber numberWithLongLong:v54];
                  [v141 setObject:v87 forKeyedSubscript:v75];
                }
                unint64_t v88 = HDStatisticsBucket<HDStatisticsSleepStages>::_canonicalSourceIDForSourceID(a1, v54);
                long long v89 = HDStatisticsBucket<HDStatisticsSleepStages>::_statisticsForSource(a1, v88);
                if (!v53) {
                  *long long v89 = (uint64_t *)((char *)*v89 + 1);
                }
                BOOL v90 = &v89[3 * (uint64_t)*(double *)&v149];
                double v91 = *((double *)v90 + 3);
                double v92 = v90[4];
                uint64_t v93 = v89[1];
                if ((uint64_t)v93 < (uint64_t)v92)
                {
                  double v92 = (uint64_t *)((char *)v93 + 1);
                  v89[1] = (uint64_t *)((char *)v93 + 1);
                }
                uint64_t v94 = v90 + 2;
                *((double *)v94 + 1) = v91 + *(double *)&v150 - *((double *)&v149 + 1);
                v94[2] = v92;
                LOBYTE(v53) = 1;
LABEL_99:
              }
            }
            char v43 = 1;
          }
          if (v49)
          {
            BOOL v95 = v52 != 0;
            uint64_t v97 = *(char **)(a1 + 104);
            unint64_t v96 = *(void *)(a1 + 112);
            if ((unint64_t)v97 < v96)
            {
              *(void *)uint64_t v97 = v46;
              *((double *)v97 + 1) = v51;
              *((void *)v97 + 2) = v47;
              *((void *)v97 + 3) = v146;
              v97[32] = v49;
              v97[33] = v145;
              v97[40] = v144;
              v97[41] = v53;
              unint64_t v64 = v97 + 48;
              v97[42] = v95;
              goto LABEL_119;
            }
            long long v86 = (char *)*v147;
            unint64_t v98 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v97[-*v147] >> 4);
            unint64_t v99 = v98 + 1;
            if (v98 + 1 > 0x555555555555555) {
              std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v100 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v96 - (void)v86) >> 4);
            if (2 * v100 > v99) {
              unint64_t v99 = 2 * v100;
            }
            if (v100 >= 0x2AAAAAAAAAAAAAALL) {
              unint64_t v101 = 0x555555555555555;
            }
            else {
              unint64_t v101 = v99;
            }
            if (v101)
            {
              unint64_t v101 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v101);
              long long v86 = *(char **)(a1 + 96);
              uint64_t v97 = *(char **)(a1 + 104);
            }
            else
            {
              uint64_t v102 = 0;
            }
            unint64_t v103 = v101 + 48 * v98;
            *(void *)unint64_t v103 = v46;
            *(double *)(v103 + 8) = v51;
            *(void *)(v103 + 16) = v47;
            *(void *)(v103 + 24) = v146;
            *(unsigned char *)(v103 + 32) = v49;
            *(unsigned char *)(v103 + 33) = v145;
            *(unsigned char *)(v103 + 40) = v144;
            *(unsigned char *)(v103 + 41) = v53;
            *(unsigned char *)(v103 + 42) = v95;
            unint64_t v104 = v103;
            if (v97 != v86)
            {
              do
              {
                long long v105 = *((_OWORD *)v97 - 3);
                long long v106 = *((_OWORD *)v97 - 2);
                *(_OWORD *)(v104 - 21) = *(_OWORD *)(v97 - 21);
                *(_OWORD *)(v104 - 48) = v105;
                *(_OWORD *)(v104 - 32) = v106;
                v104 -= 48;
                v97 -= 48;
              }
              while (v97 != v86);
              long long v86 = (char *)*v147;
            }
            unint64_t v64 = (_OWORD *)(v103 + 48);
            *(void *)(a1 + 96) = v104;
            *(void *)(a1 + 104) = v103 + 48;
            *(void *)(a1 + 112) = v101 + 48 * v102;
            if (v86) {
LABEL_118:
            }
              operator delete(v86);
            goto LABEL_119;
          }
        }
        v44 += 3;
        if (v44 == v7) {
          goto LABEL_121;
        }
        continue;
      }
    }
    double v9 = *(double *)(v6 + 8);
    double v10 = *(double *)(v6 + 16);
    uint64_t v11 = *(void *)(v6 + 24);
    char v12 = *(unsigned char *)(v6 + 32);
    char v13 = *(unsigned char *)(v6 + 33);
    if (a2 - v9 >= 0.01)
    {
      if (v10 - v9 - (a2 - v9) < 0.01)
      {
        uint64_t v40 = 0;
        char v41 = 0;
        double v16 = 0.0;
        double v15 = *(double *)(v6 + 16);
        char v14 = *(unsigned char *)(v6 + 32);
        double v10 = 0.0;
        char v12 = 0;
LABEL_132:
        int v111 = *(unsigned __int8 *)(v6 + 42);
        int v112 = *(unsigned __int8 *)(v6 + 41);
        long long v113 = *(uint64_t **)(a1 + 96);
        int v114 = *(unsigned __int8 *)(v6 + 40);
        uint64_t v115 = *v113;
        *((double *)&v149 + 1) = v9;
        *(double *)&long long v150 = v15;
        *((void *)&v150 + 1) = v11;
        LOBYTE(v151) = v14;
        BYTE1(v151) = v13;
        *(_DWORD *)((char *)&v151 + 2) = *(_DWORD *)((char *)v113 + 34);
        HIWORD(v151) = *((_WORD *)v113 + 19);
        *((double *)&v152 + 1) = v16;
        *(double *)&long long v153 = v10;
        *((void *)&v153 + 1) = v40;
        LOBYTE(v154) = v12;
        HIBYTE(v154) = v41;
        *(void *)&long long v149 = v115;
        *(void *)&long long v152 = v115;
        HDRawQuantitySample::applyMask((uint64_t)&v149, v143);
        BOOL v116 = v114 != 0;
        BOOL v117 = v112 != 0;
        BOOL v118 = v111 != 0;
        if ((_BYTE)v151)
        {
          if (!v111) {
            ++*(void *)(a1 + 120);
          }
          uint64_t v119 = (uint64_t)*(double *)&v149;
          uint64_t v120 = a1 + 24 * (uint64_t)*(double *)&v149;
          double v121 = *(double *)(v120 + 144);
          uint64_t v122 = *(void *)(v120 + 152);
          uint64_t v123 = *(void *)(a1 + 128);
          if (v123 < v122)
          {
            uint64_t v122 = v123 + 1;
            *(void *)(a1 + 128) = v123 + 1;
          }
          uint64_t v124 = v120 + 136;
          double v125 = *(double *)&v150 - *((double *)&v149 + 1);
          *(double *)(v124 + 8) = v121 + *(double *)&v150 - *((double *)&v149 + 1);
          *(void *)(v124 + 16) = v122;
          if (*(unsigned char *)(a1 + 25))
          {
            unint64_t v126 = HDStatisticsBucket<HDStatisticsSleepStages>::_canonicalSourceIDForSourceID(a1, *((unint64_t *)&v150 + 1));
            uint64_t v127 = HDStatisticsBucket<HDStatisticsSleepStages>::_statisticsForSource(a1, v126);
            if (!v112) {
              *uint64_t v127 = (uint64_t *)((char *)*v127 + 1);
            }
            uint64_t v128 = &v127[3 * v119];
            double v129 = *((double *)v128 + 3);
            uint64_t v130 = v128[4];
            int64_t v131 = v127[1];
            if ((uint64_t)v131 < (uint64_t)v130)
            {
              uint64_t v130 = (uint64_t *)((char *)v131 + 1);
              v127[1] = (uint64_t *)((char *)v131 + 1);
            }
            uint64_t v132 = v128 + 2;
            *((double *)v132 + 1) = v125 + v129;
            v132[2] = v130;
          }
          BOOL v116 = 1;
          BOOL v117 = 1;
          BOOL v118 = 1;
        }
        if ((_BYTE)v154)
        {
          LOWORD(v148) = v154;
          long long v133 = v153;
          uint64_t v134 = (char *)*v147;
          *(_OWORD *)uint64_t v134 = v152;
          *((_OWORD *)v134 + 1) = v133;
          *((void *)v134 + 4) = v148;
          v134[40] = v116;
          v134[41] = v117;
          v134[42] = v118;
        }
        else
        {
          *(void *)(a1 + 104) = *(void *)(a1 + 96);
        }
        goto LABEL_147;
      }
      double v15 = a2;
      char v14 = *(unsigned char *)(v6 + 32);
      double v16 = a2;
    }
    else
    {
      char v14 = 0;
      double v15 = *(double *)(v6 + 16);
      double v16 = *(double *)(v6 + 8);
    }
    uint64_t v40 = *(void *)(v6 + 24);
    char v41 = *(unsigned char *)(v6 + 33);
    goto LABEL_132;
  }
}

void sub_1BD193D80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  _Unwind_Resume(a1);
}

uint64_t **HDStatisticsBucket<HDStatisticsSleepStages>::_statisticsForSource(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a2;
  id v3 = *(void **)(a1 + 288);
  if (!v3) {
    goto LABEL_11;
  }
  double v4 = (uint64_t **)(a1 + 288);
  do
  {
    uint64_t v5 = v3[4];
    BOOL v6 = v5 < a2;
    if (v5 >= a2) {
      uint64_t v7 = v3;
    }
    else {
      uint64_t v7 = v3 + 1;
    }
    if (!v6) {
      double v4 = (uint64_t **)v3;
    }
    id v3 = (void *)*v7;
  }
  while (*v7);
  if (v4 == (uint64_t **)(a1 + 288) || (uint64_t)v4[4] > a2)
  {
LABEL_11:
    unint64_t v8 = (uint64_t **)(a1 + 280);
    std::__tree<std::__value_type<long long,HDStatisticsSleepStages>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsSleepStages>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsSleepStages>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t **)(a1 + 280), a2, &v10);
    double v4 = std::__tree<std::__value_type<long long,HDStatisticsSleepStages>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsSleepStages>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsSleepStages>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(v8, a2, &v10);
  }
  return v4 + 5;
}

unint64_t HDStatisticsBucket<HDStatisticsSleepStages>::_canonicalSourceIDForSourceID(uint64_t a1, unint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));

  if (WeakRetained)
  {
    uint64_t v5 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>((void *)(a1 + 368), a2);
    if (v5)
    {
      return v5[3];
    }
    else
    {
      HDStatisticsBucket<HDStatisticsSleepStages>::_bundleIdentifierForSourceID(a1, a2);
      id v6 = (id)objc_claimAutoreleasedReturnValue();
      id v10 = v6;
      uint64_t v7 = (void *)(a1 + 408);
      unint64_t v8 = std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::find<NSString * {__strong}>(v7, &v10);
      if (v8)
      {
        a2 = (unint64_t)v8[3];
      }
      else
      {
        uint64_t v11 = &v10;
        *((void *)std::__hash_table<std::__hash_value_type<NSString * {__strong},long long>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},long long>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},long long>>>::__emplace_unique_key_args<NSString * {__strong},std::piecewise_construct_t const&,std::tuple<NSString * const {__strong}&>,std::tuple<>>((uint64_t)v7, &v10, &v11)+ 3) = a2;
        id v6 = v10;
      }
    }
  }
  return a2;
}

void sub_1BD193F58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

id HDStatisticsBucket<HDStatisticsSleepStages>::_bundleIdentifierForSourceID(uint64_t a1, unint64_t a2)
{
  unint64_t v12 = a2;
  double v4 = (id *)(a1 + 88);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 88));

  if (WeakRetained)
  {
    id v6 = (void *)(a1 + 448);
    uint64_t v7 = std::__hash_table<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,health::TransactionalCache<unsigned long long,health::FilePage>::CacheLine>>>::find<unsigned long long>(v6, a2);
    if (v7)
    {
      id v8 = (id)v7[3];
    }
    else
    {
      id v9 = objc_loadWeakRetained(v4);
      id v8 = [v9 bundleIdentifierForSourceID:a2];

      if (v8)
      {
        id v10 = (id *)std::__hash_table<std::__hash_value_type<long long,NSString * {__strong}>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,NSString * {__strong}>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,NSString * {__strong}>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>((uint64_t)v6, a2, &v12);
        objc_storeStrong(v10 + 3, v8);
      }
    }
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void sub_1BD19403C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::__value_type<long long,HDStatisticsSleepStages>,std::__map_value_compare<long long,std::__value_type<long long,HDStatisticsSleepStages>,std::less<long long>,true>,std::allocator<std::__value_type<long long,HDStatisticsSleepStages>>>::__emplace_unique_key_args<long long,std::piecewise_construct_t const&,std::tuple<long long const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, void *a3)
{
  id v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (uint64_t **)v5;
        uint64_t v8 = v5[4];
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        id v6 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        id v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = a1 + 1;
LABEL_9:
    id v9 = (char *)operator new(0xC8uLL);
    *((void *)v9 + 4) = *a3;
    *(_OWORD *)(v9 + 40) = 0u;
    *(_OWORD *)(v9 + 56) = 0u;
    *(_OWORD *)(v9 + 72) = xmmword_1BD330210;
    *((void *)v9 + 11) = 0;
    *((_OWORD *)v9 + 6) = xmmword_1BD330220;
    *((void *)v9 + 14) = 0;
    *(_OWORD *)(v9 + 120) = xmmword_1BD330230;
    *((void *)v9 + 17) = 0;
    *((_OWORD *)v9 + 9) = xmmword_1BD330240;
    *((void *)v9 + 20) = 0;
    *(_OWORD *)(v9 + 168) = xmmword_1BD330250;
    *((void *)v9 + 23) = 0;
    *((void *)v9 + 24) = 0x7FFFFFFFFFFFFFFFLL;
    std::__tree<unsigned long long>::__insert_node_at(a1, (uint64_t)v7, v6, (uint64_t *)v9);
    return (uint64_t **)v9;
  }
  return v7;
}

void std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*,false>(unint64_t a1, long long *a2, uint64_t a3, uint64_t a4, char a5)
{
  while (2)
  {
    unint64_t v12 = a2 - 3;
    unint64_t v13 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v13;
          uint64_t v14 = (uint64_t)a2 - v13;
          unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v13) >> 4);
          if (v6 || !v5)
          {
            switch(v15)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v103 = *((void *)a2 - 3);
                uint64_t v104 = *(void *)(v13 + 24);
                if (v103 == v104) {
                  return;
                }
                long long v105 = *(char **)(*(void *)a3 + 344);
                long long v106 = *(char **)(*(void *)a3 + 352);
                id v107 = v105;
                id v108 = v105;
                if (v105 == v106) {
                  goto LABEL_171;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)v13, (long long *)(v13 + 48), a2 - 3, a3);
                return;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v13, v13 + 48, v13 + 96, (uint64_t)(a2 - 3), a3);
                return;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v13, v13 + 48, v13 + 96, v13 + 144, (uint64_t)(a2 - 3), a3);
                return;
              default:
                JUMPOUT(0);
            }
            do
            {
              if (*(void *)v108 == v103) {
                goto LABEL_168;
              }
              v108 += 8;
            }
            while (v108 != v106);
            id v108 = *(char **)(*(void *)a3 + 352);
LABEL_168:
            while (*(void *)v107 != v104)
            {
              v107 += 8;
              if (v107 == v106)
              {
                id v107 = *(char **)(*(void *)a3 + 352);
                break;
              }
            }
LABEL_171:
            if (v108 - v105 < v107 - v105)
            {
              *(_OWORD *)v226 = *(_OWORD *)(v13 + 16);
              *(_OWORD *)&v226[16] = *(_OWORD *)(v13 + 32);
              long long v218 = *(_OWORD *)v13;
              long long v109 = *v12;
              long long v110 = *(a2 - 2);
              *(_OWORD *)(v13 + 27) = *(long long *)((char *)a2 - 21);
              *(_OWORD *)unint64_t v13 = v109;
              *(_OWORD *)(v13 + 16) = v110;
              *(long long *)((char *)a2 - 21) = *(_OWORD *)&v226[11];
              long long *v12 = v218;
              *(a2 - 2) = *(_OWORD *)v226;
            }
            return;
          }
          if (v14 <= 1151)
          {
            int v111 = (long long *)(v13 + 48);
            BOOL v113 = (long long *)v13 == a2 || v111 == a2;
            if (a5)
            {
              if (!v113)
              {
                unint64_t v114 = v13;
                do
                {
                  unint64_t v115 = v114;
                  unint64_t v114 = (unint64_t)v111;
                  uint64_t v116 = *(void *)(v115 + 72);
                  uint64_t v117 = *(void *)(v115 + 24);
                  if (v116 != v117)
                  {
                    BOOL v118 = *(char **)(*(void *)a3 + 344);
                    uint64_t v119 = *(char **)(*(void *)a3 + 352);
                    uint64_t v120 = v118;
                    double v121 = v118;
                    if (v118 != v119)
                    {
                      do
                      {
                        if (*(void *)v121 == v116) {
                          goto LABEL_196;
                        }
                        v121 += 8;
                      }
                      while (v121 != v119);
                      double v121 = *(char **)(*(void *)a3 + 352);
LABEL_196:
                      while (*(void *)v120 != v117)
                      {
                        v120 += 8;
                        if (v120 == v119)
                        {
                          uint64_t v120 = *(char **)(*(void *)a3 + 352);
                          break;
                        }
                      }
                    }
                    if (v121 - v118 < v120 - v118)
                    {
                      uint64_t v227 = *(void *)(v114 + 16);
                      long long v219 = *(_OWORD *)v114;
                      long long v236 = *(_OWORD *)(v115 + 80);
                      unint64_t v122 = v114;
                      while (1)
                      {
                        long long v123 = *(_OWORD *)(v115 + 16);
                        *(_OWORD *)unint64_t v122 = *(_OWORD *)v115;
                        *(_OWORD *)(v122 + 16) = v123;
                        *(_OWORD *)(v122 + 27) = *(_OWORD *)(v115 + 27);
                        if (v115 == v13) {
                          break;
                        }
                        unint64_t v122 = v115;
                        uint64_t v124 = *(void *)(v115 - 24);
                        if (v116 != v124)
                        {
                          double v125 = *(char **)(*(void *)a3 + 344);
                          unint64_t v126 = *(char **)(*(void *)a3 + 352);
                          uint64_t v127 = v125;
                          uint64_t v128 = v125;
                          if (v125 != v126)
                          {
                            do
                            {
                              if (*(void *)v128 == v116) {
                                goto LABEL_208;
                              }
                              v128 += 8;
                            }
                            while (v128 != v126);
                            uint64_t v128 = *(char **)(*(void *)a3 + 352);
LABEL_208:
                            while (*(void *)v127 != v124)
                            {
                              v127 += 8;
                              if (v127 == v126)
                              {
                                uint64_t v127 = *(char **)(*(void *)a3 + 352);
                                break;
                              }
                            }
                          }
                          unint64_t v115 = v122 - 48;
                          if (v128 - v125 < v127 - v125) {
                            continue;
                          }
                        }
                        goto LABEL_212;
                      }
                      unint64_t v122 = v13;
LABEL_212:
                      *(_OWORD *)unint64_t v122 = v219;
                      *(void *)(v122 + 16) = v227;
                      *(void *)(v122 + 24) = v116;
                      *(void *)(v122 + 32) = v236;
                      *(_DWORD *)(v122 + 39) = *(_DWORD *)((char *)&v236 + 7);
                    }
                  }
                  int v111 = (long long *)(v114 + 48);
                }
                while ((long long *)(v114 + 48) != a2);
              }
            }
            else if (!v113)
            {
              do
              {
                unint64_t v201 = a1;
                a1 = (unint64_t)v111;
                uint64_t v202 = *(void *)(v201 + 72);
                uint64_t v203 = *(void *)(v201 + 24);
                if (v202 != v203)
                {
                  v204 = *(char **)(*(void *)a3 + 344);
                  v205 = *(char **)(*(void *)a3 + 352);
                  v206 = v204;
                  v207 = v204;
                  if (v204 != v205)
                  {
                    do
                    {
                      if (*(void *)v207 == v202) {
                        goto LABEL_312;
                      }
                      v207 += 8;
                    }
                    while (v207 != v205);
                    v207 = *(char **)(*(void *)a3 + 352);
LABEL_312:
                    while (*(void *)v206 != v203)
                    {
                      v206 += 8;
                      if (v206 == v205)
                      {
                        v206 = *(char **)(*(void *)a3 + 352);
                        break;
                      }
                    }
                  }
                  if (v207 - v204 < v206 - v204)
                  {
                    uint64_t v230 = *(void *)(a1 + 16);
                    long long v222 = *(_OWORD *)a1;
                    long long v239 = *(_OWORD *)(v201 + 80);
                    unint64_t v208 = a1;
                    do
                    {
                      v209 = (_OWORD *)v208;
                      unint64_t v208 = v201;
                      long long v210 = *(_OWORD *)(v201 + 16);
                      _OWORD *v209 = *(_OWORD *)v201;
                      v209[1] = v210;
                      *(_OWORD *)((char *)v209 + 27) = *(_OWORD *)(v201 + 27);
                      uint64_t v211 = *(void *)(v201 - 24);
                      if (v202 == v211) {
                        break;
                      }
                      v212 = *(char **)(*(void *)a3 + 344);
                      v213 = *(char **)(*(void *)a3 + 352);
                      v214 = v212;
                      v215 = v212;
                      if (v212 != v213)
                      {
                        do
                        {
                          if (*(void *)v215 == v202) {
                            goto LABEL_322;
                          }
                          v215 += 8;
                        }
                        while (v215 != v213);
                        v215 = *(char **)(*(void *)a3 + 352);
LABEL_322:
                        while (*(void *)v214 != v211)
                        {
                          v214 += 8;
                          if (v214 == v213)
                          {
                            v214 = *(char **)(*(void *)a3 + 352);
                            break;
                          }
                        }
                      }
                      unint64_t v201 = v208 - 48;
                    }
                    while (v215 - v212 < v214 - v212);
                    *(_OWORD *)unint64_t v208 = v222;
                    *(void *)(v208 + 16) = v230;
                    *(void *)(v208 + 24) = v202;
                    *(void *)(v208 + 32) = v239;
                    *(_DWORD *)(v208 + 39) = *(_DWORD *)((char *)&v239 + 7);
                  }
                }
                int v111 = (long long *)(a1 + 48);
              }
              while ((long long *)(a1 + 48) != a2);
            }
            return;
          }
          if (!a4)
          {
            if ((long long *)v13 != a2)
            {
              int64_t v129 = (v15 - 2) >> 1;
              int64_t v130 = v129;
              do
              {
                int64_t v131 = v130;
                if (v129 >= v130)
                {
                  uint64_t v132 = (2 * v130) | 1;
                  unint64_t v133 = v13 + 48 * v132;
                  if (2 * v131 + 2 < (uint64_t)v15)
                  {
                    uint64_t v134 = *(void *)(v133 + 24);
                    uint64_t v135 = *(void *)(v133 + 72);
                    if (v134 != v135)
                    {
                      v137 = *(char **)(*(void *)a3 + 344);
                      v136 = *(char **)(*(void *)a3 + 352);
                      v138 = v137;
                      v139 = v137;
                      if (v137 != v136)
                      {
                        do
                        {
                          if (*(void *)v139 == v134) {
                            goto LABEL_224;
                          }
                          v139 += 8;
                        }
                        while (v139 != v136);
                        v139 = *(char **)(*(void *)a3 + 352);
LABEL_224:
                        while (*(void *)v138 != v135)
                        {
                          v138 += 8;
                          if (v138 == v136)
                          {
                            v138 = *(char **)(*(void *)a3 + 352);
                            break;
                          }
                        }
                      }
                      v133 += 48 * (v139 - v137 < v138 - v137);
                      if (v139 - v137 < v138 - v137) {
                        uint64_t v132 = 2 * v131 + 2;
                      }
                    }
                  }
                  unint64_t v140 = v13 + 48 * v131;
                  uint64_t v141 = *(void *)(v133 + 24);
                  uint64_t v142 = *(void *)(v140 + 24);
                  if (v141 == v142) {
                    goto LABEL_238;
                  }
                  char v144 = *(char **)(*(void *)a3 + 344);
                  v143 = *(char **)(*(void *)a3 + 352);
                  char v145 = v144;
                  uint64_t v146 = v144;
                  if (v144 != v143)
                  {
                    do
                    {
                      if (*(void *)v146 == v141) {
                        goto LABEL_234;
                      }
                      v146 += 8;
                    }
                    while (v146 != v143);
                    uint64_t v146 = *(char **)(*(void *)a3 + 352);
LABEL_234:
                    while (*(void *)v145 != v142)
                    {
                      v145 += 8;
                      if (v145 == v143)
                      {
                        char v145 = *(char **)(*(void *)a3 + 352);
                        break;
                      }
                    }
                  }
                  if (v146 - v144 >= v145 - v144)
                  {
LABEL_238:
                    uint64_t v228 = *(void *)(v140 + 16);
                    long long v220 = *(_OWORD *)v140;
                    long long v237 = *(_OWORD *)(v140 + 32);
                    long long v147 = *(_OWORD *)v133;
                    long long v148 = *(_OWORD *)(v133 + 16);
                    *(_OWORD *)(v140 + 27) = *(_OWORD *)(v133 + 27);
                    *(_OWORD *)unint64_t v140 = v147;
                    *(_OWORD *)(v140 + 16) = v148;
                    if (v129 >= v132)
                    {
                      while (1)
                      {
                        uint64_t v150 = 2 * v132;
                        uint64_t v132 = (2 * v132) | 1;
                        unint64_t v149 = v13 + 48 * v132;
                        uint64_t v151 = v150 + 2;
                        if (v151 < (uint64_t)v15)
                        {
                          uint64_t v152 = *(void *)(v149 + 24);
                          uint64_t v153 = *(void *)(v149 + 72);
                          if (v152 != v153)
                          {
                            __int16 v154 = *(char **)(*(void *)a3 + 344);
                            __int16 v155 = *(char **)(*(void *)a3 + 352);
                            v156 = v154;
                            v157 = v154;
                            if (v154 != v155)
                            {
                              do
                              {
                                if (*(void *)v157 == v152) {
                                  goto LABEL_246;
                                }
                                v157 += 8;
                              }
                              while (v157 != v155);
                              v157 = *(char **)(*(void *)a3 + 352);
LABEL_246:
                              while (*(void *)v156 != v153)
                              {
                                v156 += 8;
                                if (v156 == v155)
                                {
                                  v156 = *(char **)(*(void *)a3 + 352);
                                  break;
                                }
                              }
                            }
                            v149 += 48 * (v157 - v154 < v156 - v154);
                            if (v157 - v154 < v156 - v154) {
                              uint64_t v132 = v151;
                            }
                          }
                        }
                        uint64_t v158 = *(void *)(v149 + 24);
                        if (v158 != v142)
                        {
                          v160 = *(char **)(*(void *)a3 + 344);
                          v159 = *(char **)(*(void *)a3 + 352);
                          v161 = v160;
                          v162 = v160;
                          if (v160 != v159)
                          {
                            do
                            {
                              if (*(void *)v162 == v158) {
                                goto LABEL_256;
                              }
                              v162 += 8;
                            }
                            while (v162 != v159);
                            v162 = *(char **)(*(void *)a3 + 352);
LABEL_256:
                            while (*(void *)v161 != v142)
                            {
                              v161 += 8;
                              if (v161 == v159)
                              {
                                v161 = *(char **)(*(void *)a3 + 352);
                                break;
                              }
                            }
                          }
                          if (v162 - v160 < v161 - v160) {
                            break;
                          }
                        }
                        long long v163 = *(_OWORD *)v149;
                        long long v164 = *(_OWORD *)(v149 + 16);
                        *(_OWORD *)(v133 + 27) = *(_OWORD *)(v149 + 27);
                        *(_OWORD *)unint64_t v133 = v163;
                        *(_OWORD *)(v133 + 16) = v164;
                        unint64_t v133 = v149;
                        if (v129 < v132) {
                          goto LABEL_261;
                        }
                      }
                    }
                    unint64_t v149 = v133;
LABEL_261:
                    *(_OWORD *)unint64_t v149 = v220;
                    *(void *)(v149 + 16) = v228;
                    *(void *)(v149 + 24) = v142;
                    *(void *)(v149 + 32) = v237;
                    *(_DWORD *)(v149 + 39) = *(_DWORD *)((char *)&v237 + 7);
                  }
                }
                int64_t v130 = v131 - 1;
              }
              while (v131);
              int64_t v165 = v14 / 0x30uLL;
              do
              {
                uint64_t v166 = 0;
                *(_OWORD *)v229 = *(_OWORD *)(v13 + 16);
                *(_OWORD *)&v229[16] = *(_OWORD *)(v13 + 32);
                long long v221 = *(_OWORD *)v13;
                uint64_t v167 = v165 - 2;
                if (v165 < 2) {
                  uint64_t v167 = v165 - 1;
                }
                uint64_t v168 = v167 >> 1;
                unint64_t v169 = v13;
                do
                {
                  v170 = (_OWORD *)v169;
                  v169 += 48 * v166 + 48;
                  uint64_t v171 = 2 * v166;
                  uint64_t v166 = (2 * v166) | 1;
                  uint64_t v172 = v171 + 2;
                  if (v171 + 2 < v165)
                  {
                    uint64_t v173 = *(void *)(v169 + 24);
                    uint64_t v174 = *(void *)(v169 + 72);
                    if (v173 != v174)
                    {
                      v176 = *(char **)(*(void *)a3 + 344);
                      v175 = *(char **)(*(void *)a3 + 352);
                      v177 = v176;
                      v178 = v176;
                      if (v176 != v175)
                      {
                        do
                        {
                          if (*(void *)v178 == v173) {
                            goto LABEL_273;
                          }
                          v178 += 8;
                        }
                        while (v178 != v175);
                        v178 = *(char **)(*(void *)a3 + 352);
LABEL_273:
                        while (*(void *)v177 != v174)
                        {
                          v177 += 8;
                          if (v177 == v175)
                          {
                            v177 = *(char **)(*(void *)a3 + 352);
                            break;
                          }
                        }
                      }
                      v169 += 48 * (v178 - v176 < v177 - v176);
                      if (v178 - v176 < v177 - v176) {
                        uint64_t v166 = v172;
                      }
                    }
                  }
                  long long v179 = *(_OWORD *)v169;
                  long long v180 = *(_OWORD *)(v169 + 16);
                  *(_OWORD *)((char *)v170 + 27) = *(_OWORD *)(v169 + 27);
                  _OWORD *v170 = v179;
                  v170[1] = v180;
                }
                while (v166 <= v168);
                a2 -= 3;
                if ((long long *)v169 == a2)
                {
                  *(_OWORD *)(v169 + 27) = *(_OWORD *)&v229[11];
                  *(_OWORD *)unint64_t v169 = v221;
                  *(_OWORD *)(v169 + 16) = *(_OWORD *)v229;
                }
                else
                {
                  long long v181 = *a2;
                  long long v182 = a2[1];
                  *(_OWORD *)(v169 + 27) = *(long long *)((char *)a2 + 27);
                  *(_OWORD *)unint64_t v169 = v181;
                  *(_OWORD *)(v169 + 16) = v182;
                  *(long long *)((char *)a2 + 27) = *(_OWORD *)&v229[11];
                  *a2 = v221;
                  a2[1] = *(_OWORD *)v229;
                  uint64_t v183 = v169 - v13 + 48;
                  if (v183 >= 49)
                  {
                    unint64_t v184 = (v183 / 0x30uLL - 2) >> 1;
                    unint64_t v185 = v13 + 48 * v184;
                    uint64_t v186 = *(void *)(v185 + 24);
                    uint64_t v187 = *(void *)(v169 + 24);
                    if (v186 != v187)
                    {
                      v189 = *(char **)(*(void *)a3 + 344);
                      v188 = *(char **)(*(void *)a3 + 352);
                      v190 = v189;
                      v191 = v189;
                      if (v189 != v188)
                      {
                        do
                        {
                          if (*(void *)v191 == v186) {
                            goto LABEL_286;
                          }
                          v191 += 8;
                        }
                        while (v191 != v188);
                        v191 = *(char **)(*(void *)a3 + 352);
LABEL_286:
                        while (*(void *)v190 != v187)
                        {
                          v190 += 8;
                          if (v190 == v188)
                          {
                            v190 = *(char **)(*(void *)a3 + 352);
                            break;
                          }
                        }
                      }
                      if (v191 - v189 < v190 - v189)
                      {
                        uint64_t v242 = *(void *)(v169 + 16);
                        long long v238 = *(_OWORD *)v169;
                        long long v233 = *(_OWORD *)(v169 + 32);
                        do
                        {
                          v192 = (_OWORD *)v169;
                          unint64_t v169 = v185;
                          long long v193 = *(_OWORD *)v185;
                          long long v194 = *(_OWORD *)(v185 + 16);
                          *(_OWORD *)((char *)v192 + 27) = *(_OWORD *)(v185 + 27);
                          _OWORD *v192 = v193;
                          v192[1] = v194;
                          if (!v184) {
                            break;
                          }
                          unint64_t v184 = (v184 - 1) >> 1;
                          unint64_t v185 = v13 + 48 * v184;
                          uint64_t v195 = *(void *)(v185 + 24);
                          if (v195 == v187) {
                            break;
                          }
                          v197 = *(char **)(*(void *)a3 + 344);
                          v196 = *(char **)(*(void *)a3 + 352);
                          v198 = v197;
                          v199 = v197;
                          if (v197 != v196)
                          {
                            do
                            {
                              if (*(void *)v199 == v195) {
                                goto LABEL_297;
                              }
                              v199 += 8;
                            }
                            while (v199 != v196);
                            v199 = *(char **)(*(void *)a3 + 352);
LABEL_297:
                            while (*(void *)v198 != v187)
                            {
                              v198 += 8;
                              if (v198 == v196)
                              {
                                v198 = *(char **)(*(void *)a3 + 352);
                                break;
                              }
                            }
                          }
                        }
                        while (v199 - v197 < v198 - v197);
                        *(_OWORD *)unint64_t v169 = v238;
                        *(void *)(v169 + 16) = v242;
                        *(void *)(v169 + 24) = v187;
                        *(void *)(v169 + 32) = v233;
                        *(_DWORD *)(v169 + 39) = *(_DWORD *)((char *)&v233 + 7);
                      }
                    }
                  }
                }
              }
              while (v165-- > 2);
            }
            return;
          }
          unint64_t v16 = v15 >> 1;
          double v17 = (long long *)(v13 + 48 * (v15 >> 1));
          if ((unint64_t)v14 >= 0x1801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48 * (v15 >> 1)), a2 - 3, a3);
            uint64_t v18 = 3 * v16;
            double v19 = (long long *)(a1 + 48 * v16 - 48);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48), v19, a2 - 6, a3);
            uint64_t v20 = (long long *)(a1 + 48 + 16 * v18);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 96), v20, a2 - 9, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v19, v17, v20, a3);
            *(_OWORD *)v223 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&v223[16] = *(_OWORD *)(a1 + 32);
            long long v216 = *(_OWORD *)a1;
            long long v21 = *(long long *)((char *)v17 + 27);
            long long v22 = v17[1];
            *(_OWORD *)a1 = *v17;
            *(_OWORD *)(a1 + 16) = v22;
            *(_OWORD *)(a1 + 27) = v21;
            *(long long *)((char *)v17 + 27) = *(_OWORD *)&v223[11];
            *double v17 = v216;
            v17[1] = *(_OWORD *)v223;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48 * (v15 >> 1)), (long long *)a1, a2 - 3, a3);
          }
          --a4;
          if (a5)
          {
            uint64_t v23 = *(void *)(a1 + 24);
            uint64_t v24 = *(void *)a3;
            break;
          }
          uint64_t v25 = *(void *)(a1 - 24);
          uint64_t v23 = *(void *)(a1 + 24);
          if (v25 != v23)
          {
            uint64_t v24 = *(void *)a3;
            double v26 = *(char **)(*(void *)a3 + 344);
            double v27 = *(char **)(*(void *)a3 + 352);
            double v28 = v26;
            uint64_t v29 = v26;
            if (v26 != v27)
            {
              do
              {
                if (*(void *)v29 == v25) {
                  goto LABEL_16;
                }
                v29 += 8;
              }
              while (v29 != v27);
              uint64_t v29 = *(char **)(*(void *)a3 + 352);
LABEL_16:
              while (*(void *)v28 != v23)
              {
                v28 += 8;
                if (v28 == v27)
                {
                  double v28 = *(char **)(*(void *)a3 + 352);
                  break;
                }
              }
            }
            if (v29 - v26 < v28 - v26) {
              break;
            }
          }
          uint64_t v241 = *(void *)(a1 + 16);
          long long v232 = *(_OWORD *)(a1 + 32);
          long long v235 = *(_OWORD *)a1;
          uint64_t v67 = *((void *)a2 - 3);
          if (v23 == v67) {
            goto LABEL_107;
          }
          unint64_t v68 = *(char **)(*(void *)a3 + 344);
          uint64_t v69 = *(char **)(*(void *)a3 + 352);
          if (v68 == v69)
          {
            double v71 = *(char **)(*(void *)a3 + 344);
            uint64_t v70 = v71;
          }
          else
          {
            uint64_t v70 = *(char **)(*(void *)a3 + 344);
            while (*(void *)v70 != v23)
            {
              v70 += 8;
              if (v70 == v69)
              {
                uint64_t v70 = *(char **)(*(void *)a3 + 352);
                break;
              }
            }
            double v71 = *(char **)(*(void *)a3 + 344);
            while (*(void *)v71 != v67)
            {
              v71 += 8;
              if (v71 == v69)
              {
                double v71 = *(char **)(*(void *)a3 + 352);
                break;
              }
            }
          }
          if (v70 - v68 >= v71 - v68)
          {
LABEL_107:
            unint64_t v13 = a1 + 48;
            if (a1 + 48 < (unint64_t)a2)
            {
              uint64_t v75 = *(void *)a3;
              unint64_t v76 = a1;
              do
              {
                uint64_t v77 = *(void *)(v76 + 72);
                unint64_t v76 = v13;
                if (v23 != v77)
                {
                  long long v78 = *(char **)(v75 + 344);
                  long long v79 = *(char **)(v75 + 352);
                  long long v80 = v78;
                  long long v81 = v78;
                  if (v78 != v79)
                  {
                    do
                    {
                      if (*(void *)v81 == v23) {
                        goto LABEL_114;
                      }
                      v81 += 8;
                    }
                    while (v81 != v79);
                    long long v81 = *(char **)(v75 + 352);
LABEL_114:
                    while (*(void *)v80 != v77)
                    {
                      v80 += 8;
                      if (v80 == v79)
                      {
                        long long v80 = *(char **)(v75 + 352);
                        break;
                      }
                    }
                  }
                  if (v81 - v78 < v80 - v78) {
                    break;
                  }
                }
                v13 += 48;
              }
              while (v76 + 48 < (unint64_t)a2);
            }
          }
          else
          {
            unint64_t v13 = a1;
            do
            {
              do
              {
                uint64_t v72 = *(void *)(v13 + 72);
                v13 += 48;
              }
              while (v23 == v72);
              if (v68 == v69)
              {
                uint64_t v74 = *(char **)(*(void *)a3 + 344);
                uint64_t v73 = v74;
              }
              else
              {
                uint64_t v73 = *(char **)(*(void *)a3 + 344);
                while (*(void *)v73 != v23)
                {
                  v73 += 8;
                  if (v73 == v69)
                  {
                    uint64_t v73 = *(char **)(*(void *)a3 + 352);
                    break;
                  }
                }
                uint64_t v74 = *(char **)(*(void *)a3 + 344);
                while (*(void *)v74 != v72)
                {
                  v74 += 8;
                  if (v74 == v69)
                  {
                    uint64_t v74 = *(char **)(*(void *)a3 + 352);
                    break;
                  }
                }
              }
            }
            while (v73 - v68 >= v74 - v68);
          }
          long long v82 = a2;
          if (v13 < (unint64_t)a2)
          {
            uint64_t v83 = *(void *)a3;
            long long v82 = a2;
            do
            {
              uint64_t v84 = *((void *)v82 - 3);
              v82 -= 3;
              if (v23 == v84) {
                break;
              }
              long long v85 = *(char **)(v83 + 344);
              long long v86 = *(char **)(v83 + 352);
              long long v87 = v85;
              unint64_t v88 = v85;
              if (v85 != v86)
              {
                do
                {
                  if (*(void *)v88 == v23) {
                    goto LABEL_126;
                  }
                  v88 += 8;
                }
                while (v88 != v86);
                unint64_t v88 = *(char **)(v83 + 352);
LABEL_126:
                while (*(void *)v87 != v84)
                {
                  v87 += 8;
                  if (v87 == v86)
                  {
                    long long v87 = *(char **)(v83 + 352);
                    break;
                  }
                }
              }
            }
            while (v88 - v85 < v87 - v85);
          }
          while (v13 < (unint64_t)v82)
          {
            *(_OWORD *)v225 = *(_OWORD *)(v13 + 16);
            *(_OWORD *)&v225[16] = *(_OWORD *)(v13 + 32);
            long long v217 = *(_OWORD *)v13;
            long long v89 = *v82;
            long long v90 = v82[1];
            *(_OWORD *)(v13 + 27) = *(long long *)((char *)v82 + 27);
            *(_OWORD *)unint64_t v13 = v89;
            *(_OWORD *)(v13 + 16) = v90;
            *(long long *)((char *)v82 + 27) = *(_OWORD *)&v225[11];
            *long long v82 = v217;
            v82[1] = *(_OWORD *)v225;
            uint64_t v91 = *(void *)a3;
            do
            {
              do
              {
                uint64_t v92 = *(void *)(v13 + 72);
                v13 += 48;
              }
              while (v23 == v92);
              uint64_t v93 = *(char **)(v91 + 344);
              uint64_t v94 = *(char **)(v91 + 352);
              if (v93 == v94)
              {
                unint64_t v96 = *(char **)(v91 + 344);
                BOOL v95 = v96;
              }
              else
              {
                BOOL v95 = *(char **)(v91 + 344);
                while (*(void *)v95 != v23)
                {
                  v95 += 8;
                  if (v95 == v94)
                  {
                    BOOL v95 = *(char **)(v91 + 352);
                    break;
                  }
                }
                unint64_t v96 = *(char **)(v91 + 344);
                while (*(void *)v96 != v92)
                {
                  v96 += 8;
                  if (v96 == v94)
                  {
                    unint64_t v96 = *(char **)(v91 + 352);
                    break;
                  }
                }
              }
            }
            while (v95 - v93 >= v96 - v93);
            do
            {
              uint64_t v97 = *((void *)v82 - 3);
              v82 -= 3;
              if (v23 == v97) {
                break;
              }
              if (v93 == v94)
              {
                unint64_t v99 = v93;
                unint64_t v98 = v93;
              }
              else
              {
                unint64_t v98 = v93;
                while (*(void *)v98 != v23)
                {
                  v98 += 8;
                  if (v98 == v94)
                  {
                    unint64_t v98 = v94;
                    break;
                  }
                }
                unint64_t v99 = v93;
                while (*(void *)v99 != v97)
                {
                  v99 += 8;
                  if (v99 == v94)
                  {
                    unint64_t v99 = v94;
                    break;
                  }
                }
              }
            }
            while (v98 - v93 < v99 - v93);
          }
          unint64_t v100 = (long long *)(v13 - 48);
          BOOL v5 = v13 - 48 >= a1;
          BOOL v6 = v13 - 48 == a1;
          if (v13 - 48 != a1)
          {
            long long v101 = *v100;
            long long v102 = *(_OWORD *)(v13 - 32);
            *(_OWORD *)(a1 + 27) = *(_OWORD *)(v13 - 21);
            *(_OWORD *)a1 = v101;
            *(_OWORD *)(a1 + 16) = v102;
          }
          a5 = 0;
          *unint64_t v100 = v235;
          *(void *)(v13 - 32) = v241;
          *(void *)(v13 - 24) = v23;
          *(_DWORD *)(v13 - 9) = *(_DWORD *)((char *)&v232 + 7);
          *(void *)(v13 - 16) = v232;
        }
        uint64_t v240 = *(void *)(a1 + 16);
        long long v231 = *(_OWORD *)(a1 + 32);
        long long v234 = *(_OWORD *)a1;
        unint64_t v30 = a1;
        do
        {
          unint64_t v31 = v30;
          v30 += 48;
          uint64_t v32 = *(void *)(v31 + 72);
          if (v32 == v23) {
            break;
          }
          long long v33 = *(char **)(v24 + 344);
          long long v34 = *(char **)(v24 + 352);
          long long v35 = v33;
          long long v36 = v33;
          if (v33 != v34)
          {
            do
            {
              if (*(void *)v36 == v32) {
                goto LABEL_26;
              }
              v36 += 8;
            }
            while (v36 != v34);
            long long v36 = *(char **)(v24 + 352);
LABEL_26:
            while (*(void *)v35 != v23)
            {
              v35 += 8;
              if (v35 == v34)
              {
                long long v35 = *(char **)(v24 + 352);
                break;
              }
            }
          }
        }
        while (v36 - v33 < v35 - v33);
        unint64_t v37 = a2;
        if (v31 == a1)
        {
          unint64_t v37 = a2;
          if (v30 < (unint64_t)a2)
          {
            unint64_t v37 = a2;
            do
            {
              uint64_t v43 = *((void *)v37 - 3);
              v37 -= 3;
              if (v43 != v23)
              {
                id v44 = *(char **)(v24 + 344);
                long long v45 = *(char **)(v24 + 352);
                uint64_t v46 = v44;
                uint64_t v47 = v44;
                if (v44 != v45)
                {
                  do
                  {
                    if (*(void *)v47 == v43) {
                      goto LABEL_48;
                    }
                    v47 += 8;
                  }
                  while (v47 != v45);
                  uint64_t v47 = *(char **)(v24 + 352);
LABEL_48:
                  while (*(void *)v46 != v23)
                  {
                    v46 += 8;
                    if (v46 == v45)
                    {
                      uint64_t v46 = *(char **)(v24 + 352);
                      break;
                    }
                  }
                }
                if (v47 - v44 < v46 - v44) {
                  break;
                }
              }
            }
            while (v30 < (unint64_t)v37);
          }
        }
        else
        {
          do
          {
            do
            {
              uint64_t v38 = *((void *)v37 - 3);
              v37 -= 3;
            }
            while (v38 == v23);
            uint64_t v39 = *(char **)(v24 + 344);
            uint64_t v40 = *(char **)(v24 + 352);
            char v41 = v39;
            unint64_t v42 = v39;
            if (v39 != v40)
            {
              do
              {
                if (*(void *)v42 == v38) {
                  goto LABEL_36;
                }
                v42 += 8;
              }
              while (v42 != v40);
              unint64_t v42 = *(char **)(v24 + 352);
LABEL_36:
              while (*(void *)v41 != v23)
              {
                v41 += 8;
                if (v41 == v40)
                {
                  char v41 = *(char **)(v24 + 352);
                  break;
                }
              }
            }
          }
          while (v42 - v39 >= v41 - v39);
        }
        unint64_t v13 = v30;
        if (v30 < (unint64_t)v37)
        {
          uint64_t v48 = v37;
          do
          {
            *(_OWORD *)v224 = *(_OWORD *)(v13 + 16);
            *(_OWORD *)&v224[16] = *(_OWORD *)(v13 + 32);
            long long v49 = *(_OWORD *)v13;
            long long v51 = *v48;
            long long v50 = v48[1];
            *(_OWORD *)(v13 + 27) = *(long long *)((char *)v48 + 27);
            *(_OWORD *)unint64_t v13 = v51;
            *(_OWORD *)(v13 + 16) = v50;
            *(long long *)((char *)v48 + 27) = *(_OWORD *)&v224[11];
            *uint64_t v48 = v49;
            v48[1] = *(_OWORD *)v224;
            uint64_t v52 = *(void *)a3;
            do
            {
              uint64_t v53 = *(void *)(v13 + 72);
              v13 += 48;
              if (v53 == v23) {
                break;
              }
              unint64_t v54 = *(char **)(v52 + 344);
              uint64_t v55 = *(char **)(v52 + 352);
              double v56 = v54;
              uint64_t v57 = v54;
              if (v54 != v55)
              {
                do
                {
                  if (*(void *)v57 == v53) {
                    goto LABEL_61;
                  }
                  v57 += 8;
                }
                while (v57 != v55);
                uint64_t v57 = *(char **)(v52 + 352);
LABEL_61:
                while (*(void *)v56 != v23)
                {
                  v56 += 8;
                  if (v56 == v55)
                  {
                    double v56 = *(char **)(v52 + 352);
                    break;
                  }
                }
              }
            }
            while (v57 - v54 < v56 - v54);
            do
            {
              do
              {
                uint64_t v58 = *((void *)v48 - 3);
                v48 -= 3;
              }
              while (v58 == v23);
              uint64_t v59 = *(char **)(v52 + 344);
              double v60 = *(char **)(v52 + 352);
              unint64_t v61 = v59;
              long long v62 = v59;
              if (v59 != v60)
              {
                do
                {
                  if (*(void *)v62 == v58) {
                    goto LABEL_70;
                  }
                  v62 += 8;
                }
                while (v62 != v60);
                long long v62 = *(char **)(v52 + 352);
LABEL_70:
                while (*(void *)v61 != v23)
                {
                  v61 += 8;
                  if (v61 == v60)
                  {
                    unint64_t v61 = *(char **)(v52 + 352);
                    break;
                  }
                }
              }
            }
            while (v62 - v59 >= v61 - v59);
          }
          while (v13 < (unint64_t)v48);
        }
        long long v63 = (long long *)(v13 - 48);
        if (v13 - 48 != a1)
        {
          long long v64 = *v63;
          long long v65 = *(_OWORD *)(v13 - 32);
          *(_OWORD *)(a1 + 27) = *(_OWORD *)(v13 - 21);
          *(_OWORD *)a1 = v64;
          *(_OWORD *)(a1 + 16) = v65;
        }
        long long *v63 = v234;
        *(void *)(v13 - 32) = v240;
        *(void *)(v13 - 24) = v23;
        *(_DWORD *)(v13 - 9) = *(_DWORD *)((char *)&v231 + 7);
        *(void *)(v13 - 16) = v231;
        if (v30 >= (unint64_t)v37) {
          break;
        }
LABEL_80:
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*,false>(a1, v13 - 48, a3, a4, a5 & 1);
        a5 = 0;
      }
      BOOL v66 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*>(a1, v13 - 48, a3);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*>(v13, (uint64_t)a2, a3))
      {
        break;
      }
      if (!v66) {
        goto LABEL_80;
      }
    }
    a2 = (long long *)(v13 - 48);
    if (!v66) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v6)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v8 = *(void *)(a2 - 24);
      uint64_t v9 = *(void *)(a1 + 24);
      if (v8 == v9) {
        return result;
      }
      id v10 = *(char **)(*(void *)a3 + 344);
      uint64_t v11 = *(char **)(*(void *)a3 + 352);
      unint64_t v12 = v10;
      unint64_t v13 = v10;
      if (v10 == v11) {
        goto LABEL_10;
      }
      do
      {
        if (*(void *)v13 == v8) {
          goto LABEL_7;
        }
        v13 += 8;
      }
      while (v13 != v11);
      unint64_t v13 = *(char **)(*(void *)a3 + 352);
      do
      {
LABEL_7:
        if (*(void *)v12 == v9) {
          goto LABEL_10;
        }
        v12 += 8;
      }
      while (v12 != v11);
      unint64_t v12 = *(char **)(*(void *)a3 + 352);
LABEL_10:
      if (v13 - v10 < v12 - v10)
      {
        uint64_t v14 = (long long *)(a2 - 48);
        long long v15 = *(_OWORD *)a1;
        *(_OWORD *)long long v35 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v35[16] = *(_OWORD *)(a1 + 32);
        long long v16 = *(_OWORD *)(a2 - 21);
        long long v17 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a1 + 16) = v17;
        *(_OWORD *)(a1 + 27) = v16;
        long long *v14 = v15;
        v14[1] = *(_OWORD *)v35;
        *(long long *)((char *)v14 + 27) = *(_OWORD *)&v35[11];
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a2 - 48), a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a2 - 48, a3);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a1 + 144, a2 - 48, a3);
      return 1;
    default:
      uint64_t v18 = a1 + 96;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#1} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a1 + 96), a3);
      uint64_t v19 = a1 + 144;
      if (a1 + 144 == a2) {
        return 1;
      }
      int v20 = 0;
      break;
  }
  while (1)
  {
    uint64_t v21 = *(void *)(v19 + 24);
    uint64_t v22 = *(void *)(v18 + 24);
    if (v21 != v22)
    {
      uint64_t v23 = *(char **)(*(void *)a3 + 344);
      uint64_t v24 = *(char **)(*(void *)a3 + 352);
      uint64_t v25 = v23;
      double v26 = v23;
      if (v23 != v24)
      {
        do
        {
          if (*(void *)v26 == v21) {
            goto LABEL_19;
          }
          v26 += 8;
        }
        while (v26 != v24);
        double v26 = *(char **)(*(void *)a3 + 352);
LABEL_19:
        while (*(void *)v25 != v22)
        {
          v25 += 8;
          if (v25 == v24)
          {
            uint64_t v25 = *(char **)(*(void *)a3 + 352);
            break;
          }
        }
      }
      if (v26 - v23 < v25 - v23)
      {
        long long v34 = *(_OWORD *)v19;
        uint64_t v36 = *(void *)(v19 + 16);
        long long v37 = *(_OWORD *)(v19 + 32);
        uint64_t v27 = v19;
        while (1)
        {
          long long v28 = *(_OWORD *)(v18 + 16);
          *(_OWORD *)uint64_t v27 = *(_OWORD *)v18;
          *(_OWORD *)(v27 + 16) = v28;
          *(_OWORD *)(v27 + 27) = *(_OWORD *)(v18 + 27);
          if (v18 == a1) {
            break;
          }
          uint64_t v27 = v18;
          uint64_t v29 = *(void *)(v18 - 24);
          if (v21 != v29)
          {
            unint64_t v30 = *(char **)(*(void *)a3 + 344);
            unint64_t v31 = *(char **)(*(void *)a3 + 352);
            uint64_t v32 = v30;
            long long v33 = v30;
            if (v30 != v31)
            {
              do
              {
                if (*(void *)v33 == v21) {
                  goto LABEL_30;
                }
                v33 += 8;
              }
              while (v33 != v31);
              long long v33 = *(char **)(*(void *)a3 + 352);
LABEL_30:
              while (*(void *)v32 != v29)
              {
                v32 += 8;
                if (v32 == v31)
                {
                  uint64_t v32 = *(char **)(*(void *)a3 + 352);
                  break;
                }
              }
            }
            v18 -= 48;
            if (v33 - v30 < v32 - v30) {
              continue;
            }
          }
          goto LABEL_36;
        }
        uint64_t v27 = a1;
LABEL_36:
        *(_OWORD *)uint64_t v27 = v34;
        *(void *)(v27 + 16) = v36;
        *(void *)(v27 + 24) = v21;
        *(void *)(v27 + 32) = v37;
        *(_DWORD *)(v27 + 39) = *(_DWORD *)((char *)&v37 + 7);
        if (++v20 == 8) {
          return v19 + 48 == a2;
        }
      }
    }
    uint64_t v18 = v19;
    v19 += 48;
    if (v19 == a2) {
      return 1;
    }
  }
}

void std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*,false>(unint64_t a1, long long *a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 4);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*((double *)a2 - 5) < *(double *)(v10 + 8))
                {
                  *(_OWORD *)BOOL v118 = *(_OWORD *)(v10 + 16);
                  *(_OWORD *)&v118[16] = *(_OWORD *)(v10 + 32);
                  long long v110 = *(_OWORD *)v10;
                  long long v52 = *(a2 - 3);
                  long long v53 = *(a2 - 2);
                  *(_OWORD *)(v10 + 27) = *(long long *)((char *)a2 - 21);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 16) = v53;
                  *(long long *)((char *)a2 - 21) = *(_OWORD *)&v118[11];
                  *(a2 - 3) = v110;
                  *(a2 - 2) = *(_OWORD *)v118;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)v10, (long long *)(v10 + 48), a2 - 3);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v10, v10 + 48, v10 + 96, (uint64_t)(a2 - 3));
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v10, v10 + 48, v10 + 96, v10 + 144, (uint64_t)(a2 - 3));
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 1151)
          {
            unint64_t v54 = (long long *)(v10 + 48);
            BOOL v56 = (long long *)v10 == a2 || v54 == a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  uint64_t v59 = v54;
                  double v60 = *(double *)(v58 + 56);
                  if (v60 < *(double *)(v58 + 8))
                  {
                    uint64_t v61 = *(void *)v54;
                    *(_OWORD *)int v111 = *(_OWORD *)(v58 + 64);
                    *(_OWORD *)&v111[16] = *(_OWORD *)(v58 + 80);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      long long v63 = (_OWORD *)(v10 + v62);
                      long long v64 = *(_OWORD *)(v10 + v62 + 16);
                      v63[3] = *(_OWORD *)(v10 + v62);
                      v63[4] = v64;
                      *(_OWORD *)((char *)v63 + 75) = *(_OWORD *)(v10 + v62 + 27);
                      if (!v62) {
                        break;
                      }
                      v62 -= 48;
                      if (v60 >= *((double *)v63 - 5))
                      {
                        uint64_t v65 = v10 + v62 + 48;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_81:
                    *(void *)uint64_t v65 = v61;
                    *(double *)(v65 + 8) = v60;
                    *(_OWORD *)(v65 + 16) = *(_OWORD *)v111;
                    *(_OWORD *)(v65 + 27) = *(_OWORD *)&v111[11];
                  }
                  unint64_t v54 = v59 + 3;
                  v57 += 48;
                  unint64_t v58 = (unint64_t)v59;
                }
                while (v59 + 3 != a2);
              }
            }
            else if (!v56)
            {
              do
              {
                unint64_t v98 = v54;
                double v99 = *(double *)(a1 + 56);
                if (v99 < *(double *)(a1 + 8))
                {
                  uint64_t v100 = *(void *)v54;
                  *(_OWORD *)unint64_t v114 = *(_OWORD *)(a1 + 64);
                  *(_OWORD *)&v114[16] = *(_OWORD *)(a1 + 80);
                  long long v101 = v54;
                  do
                  {
                    long long v102 = *(v101 - 2);
                    long long *v101 = *(v101 - 3);
                    v101[1] = v102;
                    *(long long *)((char *)v101 + 27) = *(long long *)((char *)v101 - 21);
                    double v103 = *((double *)v101 - 11);
                    v101 -= 3;
                  }
                  while (v99 < v103);
                  *(void *)long long v101 = v100;
                  *((double *)v101 + 1) = v99;
                  *(long long *)((char *)v101 + 27) = *(_OWORD *)&v114[11];
                  v101[1] = *(_OWORD *)v114;
                }
                v54 += 3;
                a1 = (unint64_t)v98;
              }
              while (v98 + 3 != a2);
            }
            return;
          }
          if (!a3)
          {
            if ((long long *)v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 48 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)(v70 + 8) < *(double *)(v70 + 56))
                  {
                    v70 += 48;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  unint64_t v71 = v10 + 48 * v68;
                  double v72 = *(double *)(v71 + 8);
                  if (*(double *)(v70 + 8) >= v72)
                  {
                    uint64_t v73 = *(void *)v71;
                    *(_OWORD *)int v112 = *(_OWORD *)(v71 + 16);
                    *(_OWORD *)&v112[16] = *(_OWORD *)(v71 + 32);
                    do
                    {
                      uint64_t v74 = (_OWORD *)v71;
                      unint64_t v71 = v70;
                      long long v75 = *(_OWORD *)v70;
                      long long v76 = *(_OWORD *)(v70 + 16);
                      *(_OWORD *)((char *)v74 + 27) = *(_OWORD *)(v70 + 27);
                      *uint64_t v74 = v75;
                      v74[1] = v76;
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v77 = 2 * v69;
                      uint64_t v69 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 48 * v69;
                      uint64_t v78 = v77 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v70 + 8) < *(double *)(v70 + 56))
                      {
                        v70 += 48;
                        uint64_t v69 = v78;
                      }
                    }
                    while (*(double *)(v70 + 8) >= v72);
                    *(void *)unint64_t v71 = v73;
                    *(double *)(v71 + 8) = v72;
                    *(_OWORD *)(v71 + 16) = *(_OWORD *)v112;
                    *(_OWORD *)(v71 + 27) = *(_OWORD *)&v112[11];
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              int64_t v79 = v11 / 0x30uLL;
              do
              {
                uint64_t v80 = 0;
                *(_OWORD *)uint64_t v119 = *(_OWORD *)(v10 + 16);
                *(_OWORD *)&v119[16] = *(_OWORD *)(v10 + 32);
                long long v113 = *(_OWORD *)v10;
                unint64_t v81 = v10;
                do
                {
                  long long v82 = (_OWORD *)v81;
                  v81 += 48 * v80 + 48;
                  uint64_t v83 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  int64_t v84 = v83 + 2;
                  if (v84 < v79 && *(double *)(v81 + 8) < *(double *)(v81 + 56))
                  {
                    v81 += 48;
                    uint64_t v80 = v84;
                  }
                  long long v85 = *(_OWORD *)v81;
                  long long v86 = *(_OWORD *)(v81 + 16);
                  *(_OWORD *)((char *)v82 + 27) = *(_OWORD *)(v81 + 27);
                  *long long v82 = v85;
                  v82[1] = v86;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 3;
                if ((long long *)v81 == a2)
                {
                  *(_OWORD *)(v81 + 27) = *(_OWORD *)&v119[11];
                  *(_OWORD *)unint64_t v81 = v113;
                  *(_OWORD *)(v81 + 16) = *(_OWORD *)v119;
                }
                else
                {
                  long long v87 = *a2;
                  long long v88 = a2[1];
                  *(_OWORD *)(v81 + 27) = *(long long *)((char *)a2 + 27);
                  *(_OWORD *)unint64_t v81 = v87;
                  *(_OWORD *)(v81 + 16) = v88;
                  *(long long *)((char *)a2 + 27) = *(_OWORD *)&v119[11];
                  *a2 = v113;
                  a2[1] = *(_OWORD *)v119;
                  uint64_t v89 = v81 - v10 + 48;
                  if (v89 >= 49)
                  {
                    unint64_t v90 = (v89 / 0x30uLL - 2) >> 1;
                    unint64_t v91 = v10 + 48 * v90;
                    double v92 = *(double *)(v81 + 8);
                    if (*(double *)(v91 + 8) < v92)
                    {
                      uint64_t v93 = *(void *)v81;
                      *(_OWORD *)long long v106 = *(_OWORD *)(v81 + 16);
                      *(_OWORD *)&v106[16] = *(_OWORD *)(v81 + 32);
                      do
                      {
                        uint64_t v94 = (_OWORD *)v81;
                        unint64_t v81 = v91;
                        long long v95 = *(_OWORD *)v91;
                        long long v96 = *(_OWORD *)(v91 + 16);
                        *(_OWORD *)((char *)v94 + 27) = *(_OWORD *)(v91 + 27);
                        *uint64_t v94 = v95;
                        v94[1] = v96;
                        if (!v90) {
                          break;
                        }
                        unint64_t v90 = (v90 - 1) >> 1;
                        unint64_t v91 = v10 + 48 * v90;
                      }
                      while (*(double *)(v91 + 8) < v92);
                      *(void *)unint64_t v81 = v93;
                      *(double *)(v81 + 8) = v92;
                      *(_OWORD *)(v81 + 16) = *(_OWORD *)v106;
                      *(_OWORD *)(v81 + 27) = *(_OWORD *)&v106[11];
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (long long *)(v10 + 48 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x1801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48 * (v12 >> 1)), a2 - 3);
            uint64_t v15 = 3 * v13;
            long long v16 = (long long *)(a1 + 48 * v13 - 48);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48), v16, a2 - 6);
            long long v17 = (long long *)(a1 + 48 + 16 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 96), v17, a2 - 9);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(v16, v14, v17);
            *(_OWORD *)unint64_t v115 = *(_OWORD *)(a1 + 16);
            *(_OWORD *)&v115[16] = *(_OWORD *)(a1 + 32);
            long long v107 = *(_OWORD *)a1;
            long long v18 = *(long long *)((char *)v14 + 27);
            long long v19 = v14[1];
            *(_OWORD *)a1 = *v14;
            *(_OWORD *)(a1 + 16) = v19;
            *(_OWORD *)(a1 + 27) = v18;
            *(long long *)((char *)v14 + 27) = *(_OWORD *)&v115[11];
            long long *v14 = v107;
            v14[1] = *(_OWORD *)v115;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)(a1 + 48 * (v12 >> 1)), (long long *)a1, a2 - 3);
          }
          --a3;
          if (a4) {
            break;
          }
          double v20 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 40) < v20) {
            goto LABEL_12;
          }
          uint64_t v38 = *(void *)a1;
          *(_OWORD *)long long v105 = *(_OWORD *)(a1 + 16);
          *(_OWORD *)&v105[16] = *(_OWORD *)(a1 + 32);
          if (v20 >= *((double *)a2 - 5))
          {
            unint64_t v41 = a1 + 48;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= (unint64_t)a2) {
                break;
              }
              double v42 = *(double *)(v41 + 8);
              v41 += 48;
            }
            while (v20 >= v42);
          }
          else
          {
            unint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 48;
              double v40 = *(double *)(v39 + 56);
              v39 += 48;
            }
            while (v20 >= v40);
          }
          uint64_t v43 = a2;
          if (v10 < (unint64_t)a2)
          {
            id v44 = a2;
            do
            {
              uint64_t v43 = v44 - 3;
              double v45 = *((double *)v44 - 5);
              v44 -= 3;
            }
            while (v20 < v45);
          }
          while (v10 < (unint64_t)v43)
          {
            *(_OWORD *)uint64_t v117 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)&v117[16] = *(_OWORD *)(v10 + 32);
            long long v109 = *(_OWORD *)v10;
            long long v46 = *v43;
            long long v47 = v43[1];
            *(_OWORD *)(v10 + 27) = *(long long *)((char *)v43 + 27);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(long long *)((char *)v43 + 27) = *(_OWORD *)&v117[11];
            long long *v43 = v109;
            v43[1] = *(_OWORD *)v117;
            do
            {
              double v48 = *(double *)(v10 + 56);
              v10 += 48;
            }
            while (v20 >= v48);
            do
            {
              double v49 = *((double *)v43 - 5);
              v43 -= 3;
            }
            while (v20 < v49);
          }
          BOOL v4 = v10 - 48 >= a1;
          BOOL v5 = v10 - 48 == a1;
          if (v10 - 48 != a1)
          {
            long long v50 = *(_OWORD *)(v10 - 48);
            long long v51 = *(_OWORD *)(v10 - 32);
            *(_OWORD *)(a1 + 27) = *(_OWORD *)(v10 - 21);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 16) = v51;
          }
          a4 = 0;
          *(void *)(v10 - 48) = v38;
          *(double *)(v10 - 40) = v20;
          *(_OWORD *)(v10 - 21) = *(_OWORD *)&v105[11];
          *(_OWORD *)(v10 - 32) = *(_OWORD *)v105;
        }
        double v20 = *(double *)(a1 + 8);
LABEL_12:
        uint64_t v21 = 0;
        uint64_t v22 = *(void *)a1;
        *(_OWORD *)uint64_t v104 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v104[16] = *(_OWORD *)(a1 + 32);
        do
        {
          double v23 = *(double *)(a1 + v21 + 56);
          v21 += 48;
        }
        while (v23 < v20);
        unint64_t v24 = a1 + v21;
        uint64_t v25 = a2;
        if (v21 == 48)
        {
          long long v28 = a2;
          while (v24 < (unint64_t)v28)
          {
            double v26 = v28 - 3;
            double v29 = *((double *)v28 - 5);
            v28 -= 3;
            if (v29 < v20) {
              goto LABEL_22;
            }
          }
          double v26 = v28;
        }
        else
        {
          do
          {
            double v26 = v25 - 3;
            double v27 = *((double *)v25 - 5);
            v25 -= 3;
          }
          while (v27 >= v20);
        }
LABEL_22:
        unint64_t v10 = v24;
        if (v24 < (unint64_t)v26)
        {
          unint64_t v30 = v26;
          do
          {
            *(_OWORD *)uint64_t v116 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)&v116[16] = *(_OWORD *)(v10 + 32);
            long long v108 = *(_OWORD *)v10;
            long long v31 = *v30;
            long long v32 = v30[1];
            *(_OWORD *)(v10 + 27) = *(long long *)((char *)v30 + 27);
            *(_OWORD *)unint64_t v10 = v31;
            *(_OWORD *)(v10 + 16) = v32;
            *(long long *)((char *)v30 + 27) = *(_OWORD *)&v116[11];
            long long *v30 = v108;
            v30[1] = *(_OWORD *)v116;
            do
            {
              double v33 = *(double *)(v10 + 56);
              v10 += 48;
            }
            while (v33 < v20);
            do
            {
              double v34 = *((double *)v30 - 5);
              v30 -= 3;
            }
            while (v34 >= v20);
          }
          while (v10 < (unint64_t)v30);
        }
        if (v10 - 48 != a1)
        {
          long long v35 = *(_OWORD *)(v10 - 48);
          long long v36 = *(_OWORD *)(v10 - 32);
          *(_OWORD *)(a1 + 27) = *(_OWORD *)(v10 - 21);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
        }
        *(void *)(v10 - 48) = v22;
        *(double *)(v10 - 40) = v20;
        *(_OWORD *)(v10 - 21) = *(_OWORD *)&v104[11];
        *(_OWORD *)(v10 - 32) = *(_OWORD *)v104;
        if (v24 >= (unint64_t)v26) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*,false>(a1, v10 - 48, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*>(a1, v10 - 48);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*>(v10, (uint64_t)a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_33;
      }
    }
    a2 = (long long *)(v10 - 48);
    if (!v37) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsSleepStages>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsSleepStages>::_SampleRemainder*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 40) < *(double *)(a1 + 8))
      {
        long long v6 = *(_OWORD *)a1;
        *(_OWORD *)double v20 = *(_OWORD *)(a1 + 16);
        *(_OWORD *)&v20[16] = *(_OWORD *)(a1 + 32);
        long long v7 = *(_OWORD *)(a2 - 21);
        long long v8 = *(_OWORD *)(a2 - 32);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 48);
        *(_OWORD *)(a1 + 16) = v8;
        *(_OWORD *)(a1 + 27) = v7;
        *(_OWORD *)(a2 - 48) = v6;
        *(_OWORD *)(a2 - 32) = *(_OWORD *)v20;
        *(_OWORD *)(a2 - 21) = *(_OWORD *)&v20[11];
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a2 - 48));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a2 - 48);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>(a1, a1 + 48, a1 + 96, a1 + 144, a2 - 48);
      return 1;
    default:
      uint64_t v9 = a1 + 96;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_mergeTowardTime(double)::{lambda(HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder const&)#2} &,HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsTemporalBucketWeightedDiscrete<HDStatisticsTemporalBucketWeightedDiscreteParameters>,HDStatisticsTimeInterval>>>::_SampleRemainder*>((long long *)a1, (long long *)(a1 + 48), (long long *)(a1 + 96));
      uint64_t v10 = a1 + 144;
      if (a1 + 144 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    double v13 = *(double *)(v10 + 8);
    if (v13 < *(double *)(v9 + 8))
    {
      uint64_t v14 = *(void *)v10;
      *(_OWORD *)long long v19 = *(_OWORD *)(v10 + 16);
      *(_OWORD *)&v19[16] = *(_OWORD *)(v10 + 32);
      uint64_t v15 = v11;
      while (1)
      {
        uint64_t v16 = a1 + v15;
        long long v17 = *(_OWORD *)(a1 + v15 + 112);
        *(_OWORD *)(v16 + 144) = *(_OWORD *)(a1 + v15 + 96);
        *(_OWORD *)(v16 + 160) = v17;
        *(_OWORD *)(v16 + 171) = *(_OWORD *)(a1 + v15 + 123);
        if (v15 == -96) {
          break;
        }
        v15 -= 48;
        if (v13 >= *(double *)(v16 + 56))
        {
          uint64_t v18 = a1 + v15 + 144;
          goto LABEL_12;
        }
      }
      uint64_t v18 = a1;
LABEL_12:
      *(void *)uint64_t v18 = v14;
      *(double *)(v18 + 8) = v13;
      *(_OWORD *)(v18 + 16) = *(_OWORD *)v19;
      *(_OWORD *)(v18 + 27) = *(_OWORD *)&v19[11];
      if (++v12 == 8) {
        return v10 + 48 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 48;
    v10 += 48;
    if (v10 == a2) {
      return 1;
    }
  }
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsSleepStages const&)>::~__func()
{
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsSleepStages const&)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1F1726ED0;
  return result;
}

void std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsSleepStages const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F1726ED0;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsSleepStages const&)>::operator()(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsSleepStages const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1},std::allocator<void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addStatisticsFromFinishedBucket<HDStatisticsSleepStages>(HKStatistics *,HDStatisticsBucket<HDStatisticsSleepStages> const&)::{lambda(HDStatisticsSleepStages const&)#1}>,HDStatisticsSleepStages const& ()(HDStatisticsSleepStages const&)>::target_type()
{
}

void *std::__function::__value_func<HDStatisticsSleepStages const& ()(HDStatisticsSleepStages const&)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveAddSample(uint64_t a1, double *a2, int a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 640))
  {
    if ((a3 & 1) == 0)
    {
      objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a4, 3, @"Cannot configure statistics collection calculator engine with a sample if we cannot merge up to the sample's start date");
      return 0;
    }
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_configureForStartTime(a1);
  }
  double v8 = a2[1];
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9)
  {
    if (*(unsigned char *)(a1 + 640))
    {
      double v10 = -1.79769313e308;
    }
    else
    {
      double v10 = *(double *)(a1 + 176);
      double v12 = *(double *)(a1 + 120);
      if (v10 <= v12) {
        double v10 = -1.79769313e308;
      }
      if (v10 < v12) {
        double v10 = *(double *)(a1 + 120);
      }
    }
  }
  else
  {
    double v10 = *(double *)(a1 + 176);
    if (v10 <= *(double *)(a1 + 120)) {
      double v10 = -1.79769313e308;
    }
  }
  if (v10 <= v8)
  {
    if (v9 && a3) {
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_advanceToTime(a1, v8);
    }
    HDStatisticsCollectionEngine<HDStatisticsSleepStages>::addSample(a1 + 112, a2, a3);
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_notifyForCurrentBucket(a1);
    return 1;
  }
  else
  {
    double v13 = objc_msgSend(MEMORY[0x1E4F28C18], "hk_dateIntervalWithStart:end:");
    uint64_t v11 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 128))(a1, v13, a4);
  }
  return v11;
}

void sub_1BD196550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_advanceToTime(uint64_t a1, double a2)
{
  if (*(double *)(a1 + 128) <= a2)
  {
    uint64_t v4 = a1 + 112;
    uint64_t v5 = a1 + 120;
    do
    {
      uint64_t v6 = *(void *)(a1 + 616);
      uint64_t v7 = *(void *)(a1 + 608);
      if (v6 == v7)
      {
        uint64_t v22 = 0;
        uint64_t v15 = *(void **)(a1 + 40);
        uint64_t v16 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceReferenceDate:a2];
        double v8 = [v15 dateIntervalContainingDate:v16 index:&v22];

        HDStatisticsBucket<HDStatisticsSleepStages>::_updateSourceOrder(v5);
        HDStatisticsBucket<HDStatisticsSleepStages>::_mergeThroughTime(v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_statisticsFromFinishedBucket(a1, v5);
        uint64_t v17 = v22;
        double v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v19 = v18;
        double v20 = [v8 endDate];
        [v20 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsSleepStages>::resetToBucket(v4, v17, v19, v21);
      }
      else
      {
        double v8 = [*(id *)(a1 + 40) dateIntervalAtIndex:*(void *)(a1 + 112) + 1];
        HDStatisticsBucket<HDStatisticsSleepStages>::_updateSourceOrder(v5);
        HDStatisticsBucket<HDStatisticsSleepStages>::_mergeThroughTime(v5, *(double *)(a1 + 128));
        uint64_t v9 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_statisticsFromFinishedBucket(a1, v5);
        double v10 = [v8 startDate];
        [v10 timeIntervalSinceReferenceDate];
        double v12 = v11;
        double v13 = [v8 endDate];
        [v13 timeIntervalSinceReferenceDate];
        HDStatisticsCollectionEngine<HDStatisticsSleepStages>::advanceBucket(v4, v12, v14);
      }
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_didChangeBucket(a1, v9);
      if (v6 != v7) {
        _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_notifyForCurrentBucket(a1);
      }
    }
    while (*(double *)(a1 + 128) <= a2);
  }
}

void sub_1BD19675C(_Unwind_Exception *exception_object)
{
}

void HDStatisticsCollectionEngine<HDStatisticsSleepStages>::addSample(uint64_t a1, double *a2, int a3)
{
  uint64_t v5 = a1 + 8;
  double v6 = *(double *)(a1 + 8);
  double v7 = a2[1];
  double v8 = a2[2];
  unint64_t v9 = *((void *)a2 + 3);
  int v10 = *((unsigned __int8 *)a2 + 32);
  char v11 = *((unsigned char *)a2 + 33);
  if (v6 - v7 >= 0.01)
  {
    if (v8 - v7 - (v6 - v7) < 0.01)
    {
      int v10 = 0;
      char v11 = 0;
      unint64_t v9 = 0;
      double v8 = 0.0;
      double v6 = 0.0;
    }
  }
  else
  {
    double v6 = a2[1];
  }
  double v12 = *a2;
  double v13 = *(double *)(a1 + 16);
  double v14 = v13 - v6;
  double v15 = v8 - v6 - (v13 - v6);
  if (!*(_DWORD *)(a1 + 36))
  {
    if (v15 < 0.01) {
      goto LABEL_10;
    }
    if (v14 >= 0.01) {
      goto LABEL_14;
    }
LABEL_13:
    char v18 = v11;
    int v17 = v10;
    unint64_t v16 = v9;
    double v19 = v8;
    double v13 = v6;
    goto LABEL_47;
  }
  if (v14 < 0.01) {
    goto LABEL_13;
  }
  if (v15 >= 0.01)
  {
LABEL_14:
    double v19 = v8;
    unint64_t v16 = v9;
    int v17 = v10;
    char v18 = v11;
    double v8 = *(double *)(a1 + 16);
    if (!v10) {
      goto LABEL_47;
    }
    goto LABEL_15;
  }
LABEL_10:
  unint64_t v16 = 0;
  int v17 = 0;
  char v18 = 0;
  double v13 = 0.0;
  double v19 = 0.0;
  if (!v10) {
    goto LABEL_47;
  }
LABEL_15:
  double v58 = v6;
  double v59 = v8;
  std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>(a1 + 312, v9, v9);
  unint64_t v20 = *(void *)(a1 + 112);
  if (v20 != *(void *)(a1 + 104) || *(uint64_t *)(a1 + 128) > 0)
  {
    double v21 = v58;
    double v22 = v59;
    if (v58 < *(double *)(a1 + 48))
    {
      double v23 = *(double *)(a1 + 8);
      if (v58 >= v23) {
        double v23 = v58;
      }
      *(double *)(a1 + 48) = v23;
    }
    if (v59 > *(double *)(a1 + 56))
    {
      double v24 = *(double *)(a1 + 16);
      if (v24 >= v59) {
        double v24 = v59;
      }
      *(double *)(a1 + 56) = v24;
    }
    if (!a3) {
      goto LABEL_29;
    }
    goto LABEL_26;
  }
  v25.f64[1] = *(float64_t *)(a1 + 16);
  double v21 = v58;
  double v22 = v59;
  v25.f64[0] = v58;
  v26.f64[0] = *(float64_t *)(a1 + 8);
  v26.f64[1] = v59;
  int8x16_t v27 = (int8x16_t)vcgtq_f64(v26, v25);
  v26.f64[0] = v58;
  *(int8x16_t *)(a1 + 48) = vbslq_s8(v27, *(int8x16_t *)(a1 + 8), (int8x16_t)v26);
  if (a3)
  {
LABEL_26:
    if (v21 < *(double *)(a1 + 16))
    {
      HDStatisticsBucket<HDStatisticsSleepStages>::_mergeThroughTime(v5, v21);
      double v21 = v58;
      double v22 = v59;
      unint64_t v20 = *(void *)(a1 + 112);
    }
  }
LABEL_29:
  unint64_t v28 = *(void *)(a1 + 120);
  if (v20 >= v28)
  {
    uint64_t v30 = *(void *)(a1 + 104);
    unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v30) >> 4);
    unint64_t v32 = v31 + 1;
    if (v31 + 1 > 0x555555555555555) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v28 - v30) >> 4);
    if (2 * v33 > v32) {
      unint64_t v32 = 2 * v33;
    }
    if (v33 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v34 = 0x555555555555555;
    }
    else {
      unint64_t v34 = v32;
    }
    if (v34)
    {
      unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDStatisticsBucket<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_SampleRemainder>>(v34);
      double v21 = v58;
      double v22 = v59;
    }
    else
    {
      uint64_t v35 = 0;
    }
    unint64_t v36 = v34 + 48 * v31;
    unint64_t v37 = v34 + 48 * v35;
    *(double *)unint64_t v36 = v12;
    *(double *)(v36 + 8) = v21;
    *(double *)(v36 + 16) = v22;
    *(void *)(v36 + 24) = v9;
    *(unsigned char *)(v36 + 32) = v10;
    *(unsigned char *)(v36 + 33) = v11;
    *(_WORD *)(v36 + 40) = 0;
    *(unsigned char *)(v36 + 42) = 0;
    unint64_t v29 = v36 + 48;
    unint64_t v39 = *(char **)(a1 + 104);
    uint64_t v38 = *(char **)(a1 + 112);
    if (v38 != v39)
    {
      do
      {
        long long v40 = *((_OWORD *)v38 - 3);
        long long v41 = *((_OWORD *)v38 - 2);
        *(_OWORD *)(v36 - 21) = *(_OWORD *)(v38 - 21);
        *(_OWORD *)(v36 - 48) = v40;
        *(_OWORD *)(v36 - 32) = v41;
        v36 -= 48;
        v38 -= 48;
      }
      while (v38 != v39);
      uint64_t v38 = *(char **)(a1 + 104);
    }
    *(void *)(a1 + 104) = v36;
    *(void *)(a1 + 112) = v29;
    *(void *)(a1 + 120) = v37;
    if (v38) {
      operator delete(v38);
    }
  }
  else
  {
    *(double *)unint64_t v20 = v12;
    *(double *)(v20 + 8) = v21;
    *(double *)(v20 + 16) = v22;
    *(void *)(v20 + 24) = v9;
    *(unsigned char *)(v20 + 32) = v10;
    *(unsigned char *)(v20 + 33) = v11;
    *(_WORD *)(v20 + 40) = 0;
    unint64_t v29 = v20 + 48;
    *(unsigned char *)(v20 + 42) = 0;
  }
  *(void *)(a1 + 112) = v29;
  if (*(unsigned char *)(a1 + 33))
  {
    unint64_t v42 = HDStatisticsBucket<HDStatisticsSleepStages>::_canonicalSourceIDForSourceID(v5, v9);
    HDStatisticsBucket<HDStatisticsSleepStages>::_statisticsForSource(v5, v42);
  }
LABEL_47:
  if (v17)
  {
    unint64_t v43 = *(void *)(a1 + 504);
    unint64_t v44 = *(void *)(a1 + 512);
    if (v43 >= v44)
    {
      uint64_t v46 = *(void *)(a1 + 496);
      unint64_t v47 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v43 - v46) >> 3);
      unint64_t v48 = v47 + 1;
      if (v47 + 1 > 0x666666666666666) {
        std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v49 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v44 - v46) >> 3);
      if (2 * v49 > v48) {
        unint64_t v48 = 2 * v49;
      }
      if (v49 >= 0x333333333333333) {
        unint64_t v50 = 0x666666666666666;
      }
      else {
        unint64_t v50 = v48;
      }
      if (v50) {
        unint64_t v50 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<HDRawQuantitySample>>(v50);
      }
      else {
        uint64_t v51 = 0;
      }
      unint64_t v52 = v50 + 40 * v47;
      unint64_t v53 = v50 + 40 * v51;
      *(double *)unint64_t v52 = v12;
      *(double *)(v52 + 8) = v13;
      *(double *)(v52 + 16) = v19;
      *(void *)(v52 + 24) = v16;
      *(unsigned char *)(v52 + 32) = v17;
      *(unsigned char *)(v52 + 33) = v18;
      unint64_t v45 = v52 + 40;
      uint64_t v55 = *(char **)(a1 + 496);
      unint64_t v54 = *(char **)(a1 + 504);
      if (v54 != v55)
      {
        do
        {
          long long v56 = *(_OWORD *)(v54 - 40);
          long long v57 = *(_OWORD *)(v54 - 24);
          *(_WORD *)(v52 - 8) = *((_WORD *)v54 - 4);
          *(_OWORD *)(v52 - 24) = v57;
          *(_OWORD *)(v52 - 40) = v56;
          v52 -= 40;
          v54 -= 40;
        }
        while (v54 != v55);
        unint64_t v54 = *(char **)(a1 + 496);
      }
      *(void *)(a1 + 496) = v52;
      *(void *)(a1 + 504) = v45;
      *(void *)(a1 + 512) = v53;
      if (v54) {
        operator delete(v54);
      }
    }
    else
    {
      *(double *)unint64_t v43 = v12;
      *(double *)(v43 + 8) = v13;
      *(double *)(v43 + 16) = v19;
      *(void *)(v43 + 24) = v16;
      *(unsigned char *)(v43 + 32) = v17;
      unint64_t v45 = v43 + 40;
      *(unsigned char *)(v43 + 33) = v18;
    }
    *(void *)(a1 + 504) = v45;
  }
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_notifyForCurrentBucket(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 642))
  {
    *(unsigned char *)(a1 + 644) = 1;
  }
  else
  {
    *(unsigned char *)(a1 + 644) = 0;
    uint64_t v2 = (void (**)(id, void *))_Block_copy(*(const void **)(a1 + 96));
    if (v2)
    {
      uint64_t v4 = v2;
      id v3 = (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
      if (v3) {
        v4[2](v4, v3);
      }

      uint64_t v2 = v4;
    }
  }
}

void sub_1BD196CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void HDStatisticsCollectionEngine<HDStatisticsSleepStages>::advanceBucket(uint64_t a1, double a2, double a3)
{
  unint64_t v9 = 0;
  int v10 = 0;
  uint64_t v11 = 0;
  std::vector<HDRawQuantitySample>::__init_with_size[abi:ne180100]<HDRawQuantitySample*,HDRawQuantitySample*>(&v9, *(const void **)(a1 + 496), *(void *)(a1 + 504), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 504) - *(void *)(a1 + 496)) >> 3));
  HDStatisticsCollectionEngine<HDStatisticsSleepStages>::resetToBucket(a1, *(void *)a1 + 1, a2, a3);
  double v6 = v9;
  double v7 = v10;
  if (v9 != v10)
  {
    double v8 = v9;
    do
    {
      HDStatisticsCollectionEngine<HDStatisticsSleepStages>::addSample(a1, v8, 1);
      v8 += 5;
    }
    while (v8 != v7);
  }
  if (v6)
  {
    operator delete(v6);
  }
}

void sub_1BD196DA0(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void HDStatisticsCollectionEngine<HDStatisticsSleepStages>::resetToBucket(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v8 = a1 + 40;
  objc_storeStrong((id *)(a1 + 520), *(id *)(a1 + 40));
  *(double *)(v8 - 32) = a3;
  *(double *)(v8 - 24) = a4;
  *(double *)(v8 + 24) = a3;
  *(void *)(v8 + 72) = *(void *)(v8 + 64);
  *(_OWORD *)(v8 + 88) = 0u;
  *(_OWORD *)(v8 + 104) = 0u;
  *(_OWORD *)(v8 + 120) = xmmword_1BD330210;
  *(void *)(v8 + 136) = 0;
  *(_OWORD *)(v8 + 144) = xmmword_1BD330220;
  *(void *)(v8 + 160) = 0;
  *(_OWORD *)(v8 + 168) = xmmword_1BD330230;
  *(void *)(v8 + 184) = 0;
  *(_OWORD *)(v8 + 192) = xmmword_1BD330240;
  *(void *)(v8 + 208) = 0;
  *(_OWORD *)(v8 + 216) = xmmword_1BD330250;
  *(void *)(v8 + 232) = 0;
  *(void *)(v8 + 240) = 0x7FFFFFFFFFFFFFFFLL;
  if (*(void *)(v8 + 264))
  {
    unint64_t v9 = *(void **)(a1 + 288);
    uint64_t v10 = *(void *)(a1 + 296);
    *(void *)(a1 + 288) = a1 + 296;
    *(void *)(v10 + 16) = 0;
    *(void *)(a1 + 296) = 0;
    *(void *)(a1 + 304) = 0;
    if (v9[1]) {
      uint64_t v11 = (void *)v9[1];
    }
    else {
      uint64_t v11 = v9;
    }
    if (v11)
    {
      double v12 = (void *)v11[2];
      if (v12)
      {
        double v13 = (void *)*v12;
        if ((void *)*v12 == v11)
        {
          void *v12 = 0;
          while (1)
          {
            double v15 = (void *)v12[1];
            if (!v15) {
              break;
            }
            do
            {
              double v12 = v15;
              double v15 = (void *)*v15;
            }
            while (v15);
          }
        }
        else
        {
          for (v12[1] = 0; v13; double v13 = (void *)v12[1])
          {
            do
            {
              double v12 = v13;
              double v13 = (void *)*v13;
            }
            while (v13);
          }
        }
        std::__tree<long>::destroy(v11);
        for (uint64_t i = (void *)v12[2]; i; uint64_t i = (void *)i[2])
          double v12 = i;
        uint64_t v11 = v12;
      }
    }
    std::__tree<long>::destroy(v11);
  }
  objc_storeStrong((id *)v8, *(id *)(a1 + 520));
  *(void *)(a1 + 504) = *(void *)(a1 + 496);
  *(void *)a1 = a2;
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_didChangeBucket(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(unsigned char *)(a1 + 644))
  {
    if (v3)
    {
      id v6 = v3;
      uint64_t v4 = _Block_copy(*(const void **)(a1 + 96));
      uint64_t v5 = v4;
      if (v4) {
        (*((void (**)(void *, id))v4 + 2))(v4, v6);
      }

      id v3 = v6;
    }
    *(unsigned char *)(a1 + 644) = 0;
  }
}

void sub_1BD196FA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE38_collapsedPendingInvalidationIntervalsERb_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = [a2 startDate];
  id v6 = [v4 startDate];
  uint64_t v7 = [v5 compare:v6];

  return v7;
}

void sub_1BD197028(_Unwind_Exception *a1)
{
  id v4 = v3;

  _Unwind_Resume(a1);
}

uint64_t _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveInvalidateInterval(id *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 13);
  if (WeakRetained)
  {
    if (v5
      && (_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_currentBucketInterval((uint64_t)a1),
          (uint64_t v7 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      uint64_t v8 = [v5 endDate];
      unint64_t v9 = [v7 startDate];
      if (objc_msgSend(v8, "hk_isAfterDate:", v9))
      {
        uint64_t v10 = [v5 startDate];
        uint64_t v11 = [v7 endDate];
        char v12 = objc_msgSend(v10, "hk_isBeforeOrEqualToDate:", v11);
      }
      else
      {
        char v12 = 0;
      }

      double v13 = _Block_copy(a1[12]);
      if ((v12 & 1) == 0) {
        operator new();
      }
    }
    else
    {
      double v13 = _Block_copy(a1[12]);
    }
    *((unsigned char *)a1 + 640) = 1;
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 3221225472;
    v27[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke;
    v27[3] = &unk_1E6308FF8;
    id v15 = v5;
    id v28 = v15;
    id v16 = v13;
    id v29 = v16;
    (*((void (**)(id *, void *))*a1 + 9))(a1, v27);
    if (v5)
    {
      int v17 = [v15 startDate];
      [v17 timeIntervalSinceReferenceDate];
      _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_configureForStartTime((uint64_t)a1);
    }
    else
    {
      (*((void (**)(id *))*a1 + 4))(a1);
      id v15 = (id)objc_claimAutoreleasedReturnValue();
    }
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2;
    v21[3] = &unk_1E6309060;
    double v24 = a1;
    id v5 = v15;
    char v26 = 1;
    id v22 = v5;
    float64x2_t v25 = a1;
    id v23 = WeakRetained;
    uint64_t v14 = (*((uint64_t (**)(id *, void *, uint64_t))*a1 + 14))(a1, v21, a3);
    char v18 = _Block_copy(v16);
    id v19 = a1[12];
    a1[12] = v18;
  }
  else
  {
    objc_msgSend(MEMORY[0x1E4F28C58], "hk_assignError:code:format:", a3, 3, @"Unable to invalidate interval: no data source available.");
    uint64_t v14 = 0;
  }

  return v14;
}

void sub_1BD197478(_Unwind_Exception *a1)
{
  MEMORY[0x1C187B8A0](v4, 0x10F1C4045BC4A20);
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke(uint64_t a1, void *a2)
{
  id v10 = a2;
  if (!*(void *)(a1 + 32)) {
    goto LABEL_11;
  }
  id v3 = [v10 endDate];
  uint64_t v4 = [*(id *)(a1 + 32) startDate];
  char v5 = objc_msgSend(v3, "hk_isBeforeOrEqualToDate:", v4);

  if ((v5 & 1) == 0)
  {
    id v6 = [v10 startDate];
    uint64_t v7 = [*(id *)(a1 + 32) endDate];
    char v8 = objc_msgSend(v6, "hk_isAfterOrEqualToDate:", v7);

    if ((v8 & 1) == 0)
    {
LABEL_11:
      uint64_t v9 = *(void *)(a1 + 40);
      if (v9) {
        (*(void (**)(uint64_t, id))(v9 + 16))(v9, v10);
      }
    }
  }
}

void sub_1BD19765C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  char v5 = [*(id *)(a1 + 32) startDate];
  [v5 timeIntervalSinceReferenceDate];
  uint64_t v7 = v6;

  char v8 = [*(id *)(a1 + 32) endDate];
  [v8 timeIntervalSinceReferenceDate];
  uint64_t v10 = v9;

  uint64_t v11 = *(void **)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(v4 + 8));
  uint64_t v13 = *(void *)(a1 + 32);
  v30[0] = MEMORY[0x1E4F143A8];
  v30[1] = 3221225472;
  v30[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3;
  v30[3] = &__block_descriptor_57_e24_B52__0d8d16d24q32B40__44l;
  char v32 = *(unsigned char *)(a1 + 64);
  v30[4] = v7;
  v30[5] = v10;
  uint64_t v31 = *(void *)(a1 + 56);
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4;
  void v29[3] = &__block_descriptor_40_e8_v16__0d8l;
  v29[4] = v31;
  uint64_t v14 = [v11 collectionCalculator:WeakRetained queryForInterval:v13 error:a2 sampleHandler:v30 mergeHandler:v29];

  if (v14)
  {
    uint64_t v15 = *(void *)(a1 + 56);
    if (v15 != v4)
    {
      id v16 = [*(id *)(a1 + 32) endDate];
      [v16 timeIntervalSinceReferenceDate];
      if (*(void *)(v15 + 40))
      {
        double v18 = v17;
        while (*(double *)(v15 + 120) < v18)
        {
          id v19 = [*(id *)(v15 + 40) dateIntervalAtIndex:*(void *)(v15 + 112) + 1];
          HDStatisticsBucket<HDStatisticsSleepStages>::_updateSourceOrder(v15 + 120);
          HDStatisticsBucket<HDStatisticsSleepStages>::_mergeThroughTime(v15 + 120, *(double *)(v15 + 128));
          unint64_t v20 = _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_statisticsFromFinishedBucket(v15, v15 + 120);
          double v21 = [v19 startDate];
          [v21 timeIntervalSinceReferenceDate];
          double v23 = v22;
          double v24 = [v19 endDate];
          [v24 timeIntervalSinceReferenceDate];
          HDStatisticsCollectionEngine<HDStatisticsSleepStages>::advanceBucket(v15 + 112, v23, v25);

          if (v20)
          {
            char v26 = _Block_copy(*(const void **)(v15 + 96));
            int8x16_t v27 = v26;
            if (v26) {
              (*((void (**)(void *, void *))v26 + 2))(v26, v20);
            }
          }
          _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_didChangeBucket(v15, 0);
        }
      }
    }
  }
  return v14;
}

void sub_1BD197908(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  double v7 = *(double *)(a1 + 32) - a6;
  if (v7 >= 0.01)
  {
    if (a7 - a6 - v7 >= 0.01)
    {
      int v8 = 1;
      a6 = *(double *)(a1 + 32);
    }
    else
    {
      a2 = 0;
      int v8 = 0;
      a6 = 0.0;
      a7 = 0.0;
    }
  }
  else
  {
    int v8 = 1;
  }
  double v11 = a5;
  double v12 = a6;
  double v13 = a7;
  uint64_t v14 = a2;
  char v15 = v8;
  char v16 = 0;
  if (*(unsigned char *)(a1 + 56))
  {
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveAddSample(*(void *)(a1 + 48), &v11, a3, a4);
    }
  }
  else
  {
    double v10 = *(double *)(a1 + 40) - a6;
    if (v10 >= 0.01)
    {
      if (a7 - a6 - v10 >= 0.01) {
        a7 = *(double *)(a1 + 40);
      }
    }
    else
    {
      int v8 = 0;
    }
    double v12 = a6;
    double v13 = a7;
    char v15 = v8;
    if (v8) {
      return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveAddSample(*(void *)(a1 + 48), &v11, a3, a4);
    }
  }
  return 1;
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE28_primitiveInvalidateIntervalEP14NSDateIntervalPU15__autoreleasingP7NSError_block_invoke_4(uint64_t a1, double a2)
{
}

void _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_mergeToTime(uint64_t a1, double a2)
{
  if (*(unsigned char *)(a1 + 640)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_configureForStartTime(a1);
  }
  if (*(void *)(a1 + 40)) {
    _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_advanceToTime(a1, a2);
  }
  if (*(double *)(a1 + 128) > a2)
  {
    HDStatisticsBucket<HDStatisticsSleepStages>::_mergeThroughTime(a1 + 120, a2);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(double *)(a2 - 32) < *(double *)(v10 + 8))
                {
                  uint64_t v129 = *(void *)(v10 + 32);
                  long long v113 = *(_OWORD *)v10;
                  long long v121 = *(_OWORD *)(v10 + 16);
                  long long v52 = *(_OWORD *)(a2 - 40);
                  long long v53 = *(_OWORD *)(a2 - 24);
                  *(_WORD *)(v10 + 32) = *(_WORD *)(a2 - 8);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 16) = v53;
                  *(_WORD *)(a2 - 8) = v129;
                  *(_OWORD *)(a2 - 24) = v121;
                  *(_OWORD *)(a2 - 40) = v113;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v10, (double *)(v10 + 40), (double *)(a2 - 40));
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, a2 - 40);
                break;
              case 5uLL:
                std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, v10 + 40, v10 + 80, v10 + 120, a2 - 40);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 959)
          {
            unint64_t v54 = (void *)(v10 + 40);
            BOOL v56 = v10 == a2 || v54 == (void *)a2;
            if (a4)
            {
              if (!v56)
              {
                uint64_t v57 = 0;
                unint64_t v58 = v10;
                do
                {
                  double v59 = v54;
                  double v60 = *(double *)(v58 + 48);
                  if (v60 < *(double *)(v58 + 8))
                  {
                    uint64_t v61 = *v54;
                    long long v114 = *(_OWORD *)(v58 + 56);
                    uint64_t v122 = *(void *)(v58 + 72);
                    uint64_t v62 = v57;
                    while (1)
                    {
                      uint64_t v63 = v10 + v62;
                      long long v64 = *(_OWORD *)(v10 + v62 + 16);
                      *(_OWORD *)(v63 + 40) = *(_OWORD *)(v10 + v62);
                      *(_OWORD *)(v63 + 56) = v64;
                      *(_WORD *)(v63 + 72) = *(_WORD *)(v10 + v62 + 32);
                      if (!v62) {
                        break;
                      }
                      v62 -= 40;
                      if (v60 >= *(double *)(v63 - 32))
                      {
                        uint64_t v65 = v10 + v62 + 40;
                        goto LABEL_81;
                      }
                    }
                    uint64_t v65 = v10;
LABEL_81:
                    *(void *)uint64_t v65 = v61;
                    *(double *)(v65 + 8) = v60;
                    *(_OWORD *)(v65 + 16) = v114;
                    *(_WORD *)(v65 + 32) = v122;
                  }
                  unint64_t v54 = v59 + 5;
                  v57 += 40;
                  unint64_t v58 = (unint64_t)v59;
                }
                while (v59 + 5 != (void *)a2);
              }
            }
            else if (!v56)
            {
              do
              {
                unint64_t v98 = v54;
                double v99 = *(double *)(a1 + 48);
                if (v99 < *(double *)(a1 + 8))
                {
                  uint64_t v100 = *v54;
                  long long v117 = *(_OWORD *)(a1 + 56);
                  uint64_t v125 = *(void *)(a1 + 72);
                  long long v101 = v54;
                  do
                  {
                    long long v102 = *(_OWORD *)(v101 - 3);
                    *(_OWORD *)long long v101 = *(_OWORD *)(v101 - 5);
                    *((_OWORD *)v101 + 1) = v102;
                    *((_WORD *)v101 + 16) = *((_WORD *)v101 - 4);
                    double v103 = *((double *)v101 - 9);
                    v101 -= 5;
                  }
                  while (v99 < v103);
                  void *v101 = v100;
                  *((double *)v101 + 1) = v99;
                  *((_WORD *)v101 + 16) = v125;
                  *((_OWORD *)v101 + 1) = v117;
                }
                v54 += 5;
                a1 = (unint64_t)v98;
              }
              while (v98 + 5 != (void *)a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v66 = (v12 - 2) >> 1;
              int64_t v67 = v66;
              do
              {
                int64_t v68 = v67;
                if (v66 >= v67)
                {
                  uint64_t v69 = (2 * v67) | 1;
                  unint64_t v70 = v10 + 40 * v69;
                  if (2 * v68 + 2 < (uint64_t)v12 && *(double *)(v10 + 40 * v69 + 8) < *(double *)(v70 + 48))
                  {
                    v70 += 40;
                    uint64_t v69 = 2 * v68 + 2;
                  }
                  double v71 = *(double *)(v10 + 40 * v68 + 8);
                  if (*(double *)(v70 + 8) >= v71)
                  {
                    unint64_t v72 = v10 + 40 * v68;
                    uint64_t v73 = *(void *)v72;
                    uint64_t v123 = *(void *)(v72 + 32);
                    long long v115 = *(_OWORD *)(v72 + 16);
                    do
                    {
                      unint64_t v74 = v72;
                      unint64_t v72 = v70;
                      long long v75 = *(_OWORD *)v70;
                      long long v76 = *(_OWORD *)(v70 + 16);
                      *(_WORD *)(v74 + 32) = *(_WORD *)(v70 + 32);
                      *(_OWORD *)unint64_t v74 = v75;
                      *(_OWORD *)(v74 + 16) = v76;
                      if (v66 < v69) {
                        break;
                      }
                      uint64_t v77 = (2 * v69) | 1;
                      unint64_t v70 = v10 + 40 * v77;
                      uint64_t v78 = 2 * v69 + 2;
                      if (v78 < (uint64_t)v12 && *(double *)(v10 + 40 * v77 + 8) < *(double *)(v70 + 48))
                      {
                        v70 += 40;
                        uint64_t v77 = v78;
                      }
                      uint64_t v69 = v77;
                    }
                    while (*(double *)(v70 + 8) >= v71);
                    *(void *)unint64_t v72 = v73;
                    *(double *)(v72 + 8) = v71;
                    *(_OWORD *)(v72 + 16) = v115;
                    *(_WORD *)(v72 + 32) = v123;
                  }
                }
                int64_t v67 = v68 - 1;
              }
              while (v68);
              int64_t v79 = v11 / 0x28uLL;
              do
              {
                uint64_t v80 = 0;
                uint64_t v130 = *(void *)(v10 + 32);
                long long v116 = *(_OWORD *)v10;
                long long v124 = *(_OWORD *)(v10 + 16);
                unint64_t v81 = v10;
                do
                {
                  unint64_t v82 = v81;
                  uint64_t v83 = v80 + 1;
                  v81 += 40 * (v80 + 1);
                  uint64_t v84 = 2 * v80;
                  uint64_t v80 = (2 * v80) | 1;
                  int64_t v85 = v84 + 2;
                  if (v85 < v79 && *(double *)(v82 + 40 * v83 + 8) < *(double *)(v81 + 48))
                  {
                    v81 += 40;
                    uint64_t v80 = v85;
                  }
                  long long v86 = *(_OWORD *)v81;
                  long long v87 = *(_OWORD *)(v81 + 16);
                  *(_WORD *)(v82 + 32) = *(_WORD *)(v81 + 32);
                  *(_OWORD *)unint64_t v82 = v86;
                  *(_OWORD *)(v82 + 16) = v87;
                }
                while (v80 <= (uint64_t)((unint64_t)(v79 - 2) >> 1));
                a2 -= 40;
                if (v81 == a2)
                {
                  *(_WORD *)(v81 + 32) = v130;
                  *(_OWORD *)unint64_t v81 = v116;
                  *(_OWORD *)(v81 + 16) = v124;
                }
                else
                {
                  long long v88 = *(_OWORD *)a2;
                  long long v89 = *(_OWORD *)(a2 + 16);
                  *(_WORD *)(v81 + 32) = *(_WORD *)(a2 + 32);
                  *(_OWORD *)unint64_t v81 = v88;
                  *(_OWORD *)(v81 + 16) = v89;
                  *(_WORD *)(a2 + 32) = v130;
                  *(_OWORD *)a2 = v116;
                  *(_OWORD *)(a2 + 16) = v124;
                  uint64_t v90 = v81 - v10 + 40;
                  if (v90 >= 41)
                  {
                    unint64_t v91 = (v90 / 0x28uLL - 2) >> 1;
                    double v92 = *(double *)(v81 + 8);
                    if (*(double *)(v10 + 40 * v91 + 8) < v92)
                    {
                      uint64_t v93 = *(void *)v81;
                      uint64_t v109 = *(void *)(v81 + 32);
                      long long v106 = *(_OWORD *)(v81 + 16);
                      do
                      {
                        unint64_t v94 = v81;
                        unint64_t v81 = v10 + 40 * v91;
                        long long v95 = *(_OWORD *)v81;
                        long long v96 = *(_OWORD *)(v81 + 16);
                        *(_WORD *)(v94 + 32) = *(_WORD *)(v81 + 32);
                        *(_OWORD *)unint64_t v94 = v95;
                        *(_OWORD *)(v94 + 16) = v96;
                        if (!v91) {
                          break;
                        }
                        unint64_t v91 = (v91 - 1) >> 1;
                      }
                      while (*(double *)(v10 + 40 * v91 + 8) < v92);
                      *(void *)unint64_t v81 = v93;
                      *(double *)(v81 + 8) = v92;
                      *(_WORD *)(v81 + 32) = v109;
                      *(_OWORD *)(v81 + 16) = v106;
                    }
                  }
                }
              }
              while (v79-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 40 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x1401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40 * (v12 >> 1)), (double *)(a2 - 40));
            uint64_t v15 = 5 * v13;
            char v16 = (double *)(a1 + 40 * v13 - 40);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40), v16, (double *)(a2 - 80));
            double v17 = (double *)(a1 + 40 + 8 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 80), v17, (double *)(a2 - 120));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)v16, (double *)v14, v17);
            uint64_t v126 = *(void *)(a1 + 32);
            long long v110 = *(_OWORD *)a1;
            long long v118 = *(_OWORD *)(a1 + 16);
            long long v18 = *(_OWORD *)v14;
            long long v19 = *(_OWORD *)(v14 + 16);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v14 + 32);
            *(_OWORD *)a1 = v18;
            *(_OWORD *)(a1 + 16) = v19;
            *(_WORD *)(v14 + 32) = v126;
            *(_OWORD *)unint64_t v14 = v110;
            *(_OWORD *)(v14 + 16) = v118;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)(a1 + 40 * (v12 >> 1)), (double *)a1, (double *)(a2 - 40));
          }
          --a3;
          if (a4) {
            break;
          }
          double v20 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 32) < v20) {
            goto LABEL_12;
          }
          uint64_t v38 = *(void *)a1;
          long long v105 = *(_OWORD *)(a1 + 16);
          uint64_t v108 = *(void *)(a1 + 32);
          if (v20 >= *(double *)(a2 - 32))
          {
            unint64_t v41 = a1 + 40;
            do
            {
              unint64_t v10 = v41;
              if (v41 >= a2) {
                break;
              }
              double v42 = *(double *)(v41 + 8);
              v41 += 40;
            }
            while (v20 >= v42);
          }
          else
          {
            unint64_t v39 = a1;
            do
            {
              unint64_t v10 = v39 + 40;
              double v40 = *(double *)(v39 + 48);
              v39 += 40;
            }
            while (v20 >= v40);
          }
          unint64_t v43 = a2;
          if (v10 < a2)
          {
            unint64_t v44 = a2;
            do
            {
              unint64_t v43 = v44 - 40;
              double v45 = *(double *)(v44 - 32);
              v44 -= 40;
            }
            while (v20 < v45);
          }
          while (v10 < v43)
          {
            uint64_t v128 = *(void *)(v10 + 32);
            long long v112 = *(_OWORD *)v10;
            long long v120 = *(_OWORD *)(v10 + 16);
            long long v46 = *(_OWORD *)v43;
            long long v47 = *(_OWORD *)(v43 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v43 + 32);
            *(_OWORD *)unint64_t v10 = v46;
            *(_OWORD *)(v10 + 16) = v47;
            *(_WORD *)(v43 + 32) = v128;
            *(_OWORD *)unint64_t v43 = v112;
            *(_OWORD *)(v43 + 16) = v120;
            do
            {
              double v48 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v20 >= v48);
            do
            {
              double v49 = *(double *)(v43 - 32);
              v43 -= 40;
            }
            while (v20 < v49);
          }
          BOOL v4 = v10 - 40 >= a1;
          BOOL v5 = v10 - 40 == a1;
          if (v10 - 40 != a1)
          {
            long long v50 = *(_OWORD *)(v10 - 40);
            long long v51 = *(_OWORD *)(v10 - 24);
            *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 16) = v51;
          }
          a4 = 0;
          *(void *)(v10 - 40) = v38;
          *(double *)(v10 - 32) = v20;
          *(_WORD *)(v10 - 8) = v108;
          *(_OWORD *)(v10 - 24) = v105;
        }
        double v20 = *(double *)(a1 + 8);
LABEL_12:
        uint64_t v21 = 0;
        uint64_t v22 = *(void *)a1;
        long long v104 = *(_OWORD *)(a1 + 16);
        uint64_t v107 = *(void *)(a1 + 32);
        do
        {
          double v23 = *(double *)(a1 + v21 + 48);
          v21 += 40;
        }
        while (v23 < v20);
        unint64_t v24 = a1 + v21;
        unint64_t v25 = a2;
        if (v21 == 40)
        {
          unint64_t v28 = a2;
          while (v24 < v28)
          {
            unint64_t v26 = v28 - 40;
            double v29 = *(double *)(v28 - 32);
            v28 -= 40;
            if (v29 < v20) {
              goto LABEL_22;
            }
          }
          unint64_t v26 = v28;
        }
        else
        {
          do
          {
            unint64_t v26 = v25 - 40;
            double v27 = *(double *)(v25 - 32);
            v25 -= 40;
          }
          while (v27 >= v20);
        }
LABEL_22:
        unint64_t v10 = v24;
        if (v24 < v26)
        {
          unint64_t v30 = v26;
          do
          {
            uint64_t v127 = *(void *)(v10 + 32);
            long long v111 = *(_OWORD *)v10;
            long long v119 = *(_OWORD *)(v10 + 16);
            long long v31 = *(_OWORD *)v30;
            long long v32 = *(_OWORD *)(v30 + 16);
            *(_WORD *)(v10 + 32) = *(_WORD *)(v30 + 32);
            *(_OWORD *)unint64_t v10 = v31;
            *(_OWORD *)(v10 + 16) = v32;
            *(_WORD *)(v30 + 32) = v127;
            *(_OWORD *)unint64_t v30 = v111;
            *(_OWORD *)(v30 + 16) = v119;
            do
            {
              double v33 = *(double *)(v10 + 48);
              v10 += 40;
            }
            while (v33 < v20);
            do
            {
              double v34 = *(double *)(v30 - 32);
              v30 -= 40;
            }
            while (v34 >= v20);
          }
          while (v10 < v30);
        }
        if (v10 - 40 != a1)
        {
          long long v35 = *(_OWORD *)(v10 - 40);
          long long v36 = *(_OWORD *)(v10 - 24);
          *(_WORD *)(a1 + 32) = *(_WORD *)(v10 - 8);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 16) = v36;
        }
        *(void *)(v10 - 40) = v22;
        *(double *)(v10 - 32) = v20;
        *(_WORD *)(v10 - 8) = v107;
        *(_OWORD *)(v10 - 24) = v104;
        if (v24 >= v26) {
          break;
        }
LABEL_33:
        std::__introsort<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*,false>(a1, v10 - 40, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, v10 - 40);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(v10, a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_33;
      }
    }
    a2 = v10 - 40;
    if (!v37) {
      continue;
    }
    break;
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(double *)(a2 - 32) < *(double *)(a1 + 8))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        long long v7 = *(_OWORD *)a1;
        long long v8 = *(_OWORD *)(a1 + 16);
        __int16 v9 = *(_WORD *)(a2 - 8);
        long long v10 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
        *(_OWORD *)(a1 + 16) = v10;
        *(_WORD *)(a1 + 32) = v9;
        *(_OWORD *)(a2 - 24) = v8;
        *(_OWORD *)(a2 - 40) = v7;
        *(_WORD *)(a2 - 8) = v6;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a2 - 40));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>(a1, a1 + 40, a1 + 80, a1 + 120, a2 - 40);
      return 1;
    default:
      uint64_t v11 = a1 + 80;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsRelative<HDStatisticsCombined<HDStatisticsDiscrete,HDStatisticsTimeInterval>>>::_addPendingSamples(std::vector<HDRawQuantitySample> &,NSError * {__autoreleasing}*)::{lambda(HDRawQuantitySample const&,HDRawQuantitySample const&)#1} &,HDRawQuantitySample*>((long long *)a1, (double *)(a1 + 40), (double *)(a1 + 80));
      uint64_t v12 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (1)
  {
    double v15 = *(double *)(v12 + 8);
    if (v15 < *(double *)(v11 + 8))
    {
      uint64_t v16 = *(void *)v12;
      long long v21 = *(_OWORD *)(v12 + 16);
      uint64_t v22 = *(void *)(v12 + 32);
      uint64_t v17 = v13;
      while (1)
      {
        uint64_t v18 = a1 + v17;
        long long v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(_WORD *)(v18 + 152) = *(_WORD *)(a1 + v17 + 112);
        if (v17 == -80) {
          break;
        }
        v17 -= 40;
        if (v15 >= *(double *)(v18 + 48))
        {
          uint64_t v20 = a1 + v17 + 120;
          goto LABEL_12;
        }
      }
      uint64_t v20 = a1;
LABEL_12:
      *(void *)uint64_t v20 = v16;
      *(double *)(v20 + 8) = v15;
      *(_OWORD *)(v20 + 16) = v21;
      *(_WORD *)(v20 + 32) = v22;
      if (++v14 == 8) {
        return v12 + 40 == a2;
      }
    }
    uint64_t v11 = v12;
    v13 += 40;
    v12 += 40;
    if (v12 == a2) {
      return 1;
    }
  }
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke(void *a1, uint64_t a2)
{
  id v3 = (void *)a1[5];
  uint64_t v4 = a1[6];
  BOOL v5 = (void *)a1[4];
  uint64_t v6 = [v5 dateInterval];
  void v9[4] = v4;
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2;
  v10[3] = &__block_descriptor_40_e24_B52__0d8d16d24q32B40__44l;
  v10[4] = v4;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3;
  v9[3] = &__block_descriptor_40_e8_v16__0d8l;
  uint64_t v7 = [v3 collectionCalculator:v5 queryForInterval:v6 error:a2 sampleHandler:v10 mergeHandler:v9];

  return v7;
}

void sub_1BD19868C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_2(uint64_t a1, uint64_t a2, int a3, uint64_t a4, double a5, double a6, double a7)
{
  uint64_t v10 = *(void *)(a1 + 32);
  v14[0] = a5;
  v14[1] = a6;
  v14[2] = a7;
  *(void *)&v14[3] = a2;
  char v15 = 1;
  uint64_t v11 = [MEMORY[0x1E4F1C9C8] distantFuture];
  [v11 timeIntervalSinceReferenceDate];
  BOOL v16 = v12 <= a7;

  return _HDConcreteStatisticsCollectionCalculatorImplementation<HDStatisticsSleepStages>::_primitiveAddSample(v10, v14, a3, a4);
}

void sub_1BD198730(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZN55_HDConcreteStatisticsCollectionCalculatorImplementationI23HDStatisticsSleepStagesE25queryForInitialStatisticsEP32HDStatisticsCollectionCalculatorPU15__autoreleasingP7NSError_block_invoke_3(uint64_t a1, double a2)
{
}

void sub_1BD198EC8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__163(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__163(uint64_t a1)
{
}

uint64_t statistics::StatisticsEngine::StatisticsEngine(uint64_t this)
{
  *(void *)this = &unk_1F1726FA0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 24) = 0;
  *(_DWORD *)(this + 48) = 0;
  return this;
}

{
  *(void *)this = &unk_1F1726FA0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 24) = 0;
  *(_DWORD *)(this + 48) = 0;
  return this;
}

void statistics::StatisticsEngine::~StatisticsEngine(statistics::StatisticsEngine *this)
{
  *(void *)this = &unk_1F1726FA0;
  id v3 = (void **)((char *)this + 24);
  std::vector<std::unique_ptr<statistics::Interval>>::__destroy_vector::operator()[abi:ne180100](&v3);
  uint64_t v2 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  PB::Base::~Base(this);
}

{
  uint64_t vars8;

  statistics::StatisticsEngine::~StatisticsEngine(this);

  JUMPOUT(0x1C187B8A0);
}

uint64_t statistics::StatisticsEngine::StatisticsEngine(uint64_t this, const statistics::StatisticsEngine *a2)
{
  *(void *)this = &unk_1F1726FA0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 32) = 0;
  *(void *)(this + 40) = 0;
  *(_DWORD *)(this + 48) = 0;
  if (*((unsigned char *)a2 + 48))
  {
    uint64_t v2 = *((void *)a2 + 2);
    *(unsigned char *)(this + 48) = 1;
    *(void *)(this + 16) = v2;
  }
  if (*((void *)a2 + 1)) {
    operator new();
  }
  if (*((void *)a2 + 3) != *((void *)a2 + 4)) {
    PB::PtrVector<statistics::RawQuantitySample>::emplace_back<statistics::RawQuantitySample const&>();
  }
  return this;
}

uint64_t statistics::StatisticsEngine::operator=(uint64_t a1, const statistics::StatisticsEngine *a2)
{
  if ((const statistics::StatisticsEngine *)a1 != a2)
  {
    statistics::StatisticsEngine::StatisticsEngine((uint64_t)v10, a2);
    int v3 = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a1 + 48) = v15;
    int v15 = v3;
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v6 = v12;
    *(void *)(a1 + 8) = v11;
    *(void *)(a1 + 16) = v6;
    uint64_t v11 = v5;
    uint64_t v12 = v4;
    long long v7 = *(_OWORD *)(a1 + 24);
    *(_OWORD *)(a1 + 24) = v13;
    long long v13 = v7;
    uint64_t v8 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = v14;
    uint64_t v14 = v8;
    statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)v10);
  }
  return a1;
}

uint64_t statistics::swap(uint64_t this, statistics::StatisticsEngine *a2, statistics::StatisticsEngine *a3)
{
  int v3 = *(_DWORD *)(this + 48);
  *(_DWORD *)(this + 48) = *((_DWORD *)a2 + 12);
  *((_DWORD *)a2 + 12) = v3;
  uint64_t v5 = *(void *)(this + 8);
  uint64_t v4 = *(void *)(this + 16);
  uint64_t v6 = *((void *)a2 + 2);
  *(void *)(this + 8) = *((void *)a2 + 1);
  *(void *)(this + 16) = v6;
  *((void *)a2 + 1) = v5;
  *((void *)a2 + 2) = v4;
  uint64_t v7 = *(void *)(this + 24);
  *(void *)(this + 24) = *((void *)a2 + 3);
  *((void *)a2 + 3) = v7;
  uint64_t v8 = *(void *)(this + 32);
  *(void *)(this + 32) = *((void *)a2 + 4);
  *((void *)a2 + 4) = v8;
  uint64_t v9 = *(void *)(this + 40);
  *(void *)(this + 40) = *((void *)a2 + 5);
  *((void *)a2 + 5) = v9;
  return this;
}

uint64_t statistics::StatisticsEngine::StatisticsEngine(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  uint64_t v4 = (void **)(a1 + 24);
  *(void *)a1 = &unk_1F1726FA0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a2 + 48) = 0;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 16) = v5;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  std::vector<std::unique_ptr<statistics::Interval>>::__vdeallocate(v4);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  return a1;
}

uint64_t statistics::StatisticsEngine::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    statistics::StatisticsEngine::StatisticsEngine((uint64_t)v10, a2);
    int v3 = *(_DWORD *)(a1 + 48);
    *(_DWORD *)(a1 + 48) = v15;
    int v15 = v3;
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v4 = *(void *)(a1 + 16);
    uint64_t v6 = v12;
    *(void *)(a1 + 8) = v11;
    *(void *)(a1 + 16) = v6;
    uint64_t v11 = v5;
    uint64_t v12 = v4;
    long long v7 = *(_OWORD *)(a1 + 24);
    *(_OWORD *)(a1 + 24) = v13;
    long long v13 = v7;
    uint64_t v8 = *(void *)(a1 + 40);
    *(void *)(a1 + 40) = v14;
    uint64_t v14 = v8;
    statistics::StatisticsEngine::~StatisticsEngine((statistics::StatisticsEngine *)v10);
  }
  return a1;
}

uint64_t statistics::StatisticsEngine::formatText(statistics::StatisticsEngine *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  uint64_t v5 = *((void *)this + 1);
  if (v5) {
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v5 + 32))(v5, a2, "currentBucket");
  }
  if (*((unsigned char *)this + 48)) {
    PB::TextFormatter::format(a2, "currentBucketIndex");
  }
  uint64_t v6 = (uint64_t *)*((void *)this + 3);
  long long v7 = (uint64_t *)*((void *)this + 4);
  while (v6 != v7)
  {
    uint64_t v8 = *v6++;
    (*(void (**)(uint64_t, PB::TextFormatter *, const char *))(*(void *)v8 + 32))(v8, a2, "remainders");
  }

  return MEMORY[0x1F4147498](a2);
}

uint64_t statistics::StatisticsEngine::readFrom(statistics::StatisticsEngine *this, PB::Reader *a2)
{
  unint64_t v2 = *((void *)a2 + 1);
  unint64_t v3 = *((void *)a2 + 2);
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    while (1)
    {
      uint64_t v8 = *(void *)a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3) {
        break;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)a2 + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_31;
        }
      }
LABEL_20:
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      unint64_t v19 = v11 >> 3;
      if ((v11 >> 3) == 3) {
        PB::PtrVector<statistics::RawQuantitySample>::emplace_back<>();
      }
      if (v19 == 2) {
        operator new();
      }
      if (v19 == 1)
      {
        *((unsigned char *)this + 48) |= 1u;
        unint64_t v20 = *((void *)a2 + 1);
        unint64_t v21 = *((void *)a2 + 2);
        uint64_t v22 = *(void *)a2;
        if (v20 > 0xFFFFFFFFFFFFFFF5 || v20 + 10 > v21)
        {
          char v29 = 0;
          unsigned int v30 = 0;
          uint64_t v25 = 0;
          if (v21 <= v20) {
            unint64_t v21 = *((void *)a2 + 1);
          }
          while (1)
          {
            if (v21 == v20)
            {
              uint64_t v25 = 0;
              *((unsigned char *)a2 + 24) = 1;
              goto LABEL_45;
            }
            unint64_t v31 = v20 + 1;
            char v32 = *(unsigned char *)(v22 + v20);
            *((void *)a2 + 1) = v31;
            v25 |= (unint64_t)(v32 & 0x7F) << v29;
            if ((v32 & 0x80) == 0) {
              break;
            }
            v29 += 7;
            unint64_t v20 = v31;
            BOOL v14 = v30++ > 8;
            if (v14)
            {
LABEL_41:
              uint64_t v25 = 0;
              goto LABEL_45;
            }
          }
          if (*((unsigned char *)a2 + 24)) {
            uint64_t v25 = 0;
          }
        }
        else
        {
          char v23 = 0;
          unsigned int v24 = 0;
          uint64_t v25 = 0;
          while (1)
          {
            unint64_t v26 = v20 + 1;
            *((void *)a2 + 1) = v20 + 1;
            char v27 = *(unsigned char *)(v22 + v20);
            v25 |= (unint64_t)(v27 & 0x7F) << v23;
            if ((v27 & 0x80) == 0) {
              break;
            }
            v23 += 7;
            unint64_t v20 = v26;
            BOOL v14 = v24++ > 8;
            if (v14) {
              goto LABEL_41;
            }
          }
        }
LABEL_45:
        *((void *)this + 2) = v25;
      }
      else
      {
LABEL_31:
        uint64_t result = PB::Reader::skip(a2);
        if (!result) {
          return result;
        }
      }
      unint64_t v2 = *((void *)a2 + 1);
      unint64_t v3 = *((void *)a2 + 2);
      int v4 = *((unsigned __int8 *)a2 + 24);
      if (v2 >= v3 || v4 != 0) {
        return v4 == 0;
      }
    }
    char v15 = 0;
    unsigned int v16 = 0;
    unint64_t v11 = 0;
    if (v2 > v3) {
      unint64_t v3 = v2;
    }
    while (v3 != v2)
    {
      unint64_t v17 = v2 + 1;
      char v18 = *(unsigned char *)(v8 + v2);
      *((void *)a2 + 1) = v17;
      v11 |= (unint64_t)(v18 & 0x7F) << v15;
      if ((v18 & 0x80) == 0) {
        goto LABEL_20;
      }
      v15 += 7;
      unint64_t v2 = v17;
      BOOL v14 = v16++ > 8;
      if (v14) {
        goto LABEL_31;
      }
    }
    int v4 = 1;
    *((unsigned char *)a2 + 24) = 1;
  }
  return v4 == 0;
}

uint64_t statistics::StatisticsEngine::writeTo(uint64_t this, PB::Writer *a2)
{
  unint64_t v3 = (void *)this;
  if (*(unsigned char *)(this + 48)) {
    this = PB::Writer::writeVarInt(a2);
  }
  int v4 = (const PB::Base *)v3[1];
  if (v4) {
    this = PB::Writer::writeSubmessage(a2, v4);
  }
  uint64_t v6 = (const PB::Base **)v3[3];
  uint64_t v5 = (const PB::Base **)v3[4];
  while (v6 != v5)
  {
    long long v7 = *v6++;
    this = PB::Writer::writeSubmessage(a2, v7);
  }
  return this;
}

BOOL statistics::StatisticsEngine::operator==(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 48))
  {
    if ((*(unsigned char *)(a2 + 48) & 1) == 0 || *(void *)(a1 + 16) != *(void *)(a2 + 16)) {
      return 0;
    }
  }
  else if (*(unsigned char *)(a2 + 48))
  {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a2 + 8);
  if (v4)
  {
    if (!v5 || !statistics::StatisticsBucket::operator==(v4, v5) && *(void *)(a1 + 8) | *(void *)(a2 + 8)) {
      return 0;
    }
  }
  else if (v5)
  {
    return 0;
  }

  return PB::PtrVector<statistics::RawQuantitySample>::operator==((uint64_t *)(a1 + 24), a2 + 24);
}

unint64_t statistics::StatisticsEngine::hash_value(statistics::StatisticsEngine *this)
{
  if (*((unsigned char *)this + 48)) {
    uint64_t v2 = *((void *)this + 2);
  }
  else {
    uint64_t v2 = 0;
  }
  unint64_t v3 = (statistics::StatisticsBucket *)*((void *)this + 1);
  if (v3) {
    unint64_t v4 = statistics::StatisticsBucket::hash_value(v3);
  }
  else {
    unint64_t v4 = 0;
  }
  uint64_t v6 = (statistics::RawQuantitySample **)*((void *)this + 3);
  uint64_t v5 = (statistics::RawQuantitySample **)*((void *)this + 4);
  if (v6 == v5)
  {
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = *v6++;
      v7 ^= statistics::RawQuantitySample::hash_value(v8);
    }
    while (v6 != v5);
  }
  return v4 ^ v2 ^ v7;
}

uint64_t statistics::StatisticsEngine::makeCurrentBucket(uint64_t this)
{
  if (!*(void *)(this + 8)) {
    operator new();
  }
  return this;
}

double HDOntologyFeatureDefaultMinimumTimeToLive()
{
  int v0 = [MEMORY[0x1E4F2B860] isAppleInternalInstall];
  double result = 2592000.0;
  if (v0) {
    return 604800.0;
  }
  return result;
}

void sub_1BD19F790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableUserDomainConceptCollectionReadFrom(void *a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  unint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        unint64_t v17 = objc_alloc_init(HDCodableUserDomainConcept);
        [a1 addConcepts:v17];
        if (!PBReaderPlaceMark() || (HDCodableUserDomainConceptReadFrom((uint64_t)v17, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableSyncStateVersionedDataReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  unint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 100)
      {
        uint64_t v24 = PBReaderReadData();
        uint64_t v25 = *(void **)(a1 + 8);
        *(void *)(a1 + 8) = v24;
      }
      else if (v17 == 2)
      {
        unint64_t v26 = objc_alloc_init(HDCodableSyncStateOrigin);
        objc_storeStrong((id *)(a1 + 16), v26);
        if (!PBReaderPlaceMark() || (HDCodableSyncStateOriginReadFrom((uint64_t)v26, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else if (v17 == 1)
      {
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 28) |= 1u;
        while (1)
        {
          uint64_t v21 = *v3;
          unint64_t v22 = *(void *)(a2 + v21);
          if (v22 == -1 || v22 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v22 + 1;
          v20 |= (unint64_t)(v23 & 0x7F) << v18;
          if ((v23 & 0x80) == 0) {
            goto LABEL_35;
          }
          v18 += 7;
          BOOL v14 = v19++ >= 9;
          if (v14)
          {
            LODWORD(v20) = 0;
            goto LABEL_37;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_35:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v20) = 0;
        }
LABEL_37:
        *(_DWORD *)(a1 + 24) = v20;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD1A3B44(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__164(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__164(uint64_t a1)
{
}

uint64_t HDCodableVerifiableDataReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  unint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        uint64_t v24 = PBReaderReadString();
        uint64_t v25 = 24;
      }
      else
      {
        if (v17 != 2)
        {
          if (v17 == 1)
          {
            char v18 = 0;
            unsigned int v19 = 0;
            uint64_t v20 = 0;
            *(unsigned char *)(a1 + 32) |= 1u;
            while (1)
            {
              uint64_t v21 = *v3;
              unint64_t v22 = *(void *)(a2 + v21);
              if (v22 == -1 || v22 >= *(void *)(a2 + *v4)) {
                break;
              }
              char v23 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
              *(void *)(a2 + v21) = v22 + 1;
              v20 |= (unint64_t)(v23 & 0x7F) << v18;
              if ((v23 & 0x80) == 0) {
                goto LABEL_34;
              }
              v18 += 7;
              BOOL v14 = v19++ >= 9;
              if (v14)
              {
                uint64_t v20 = 0;
                goto LABEL_36;
              }
            }
            *(unsigned char *)(a2 + *v5) = 1;
LABEL_34:
            if (*(unsigned char *)(a2 + *v5)) {
              uint64_t v20 = 0;
            }
LABEL_36:
            *(void *)(a1 + 8) = v20;
          }
          else
          {
            uint64_t result = PBReaderSkipValueWithTag();
            if (!result) {
              return result;
            }
          }
          continue;
        }
        uint64_t v24 = PBReaderReadData();
        uint64_t v25 = 16;
      }
      unint64_t v26 = *(void **)(a1 + v25);
      *(void *)(a1 + v25) = v24;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

__n128 HDStatisticsAverageSampleDuration::splitSampleAtTime@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_WORD *)(a2 + 72) = 0;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a1;
  *(_OWORD *)(a2 + 16) = v3;
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  return result;
}

long long *HDStatisticsAverageSampleDuration::splitSampleAtTime(long long *result, uint64_t a2, int a3, double a4)
{
  unint64_t v4 = result + 2;
  if (!*((unsigned char *)result + 32)) {
    goto LABEL_5;
  }
  double v5 = *((double *)result + 1);
  BOOL v6 = v5 <= a4;
  if (a3) {
    BOOL v6 = v5 < a4;
  }
  if (!v6)
  {
    long long v7 = *result;
    long long v8 = result[1];
    *(_WORD *)(a2 + 32) = *((_WORD *)result + 16);
    *(_OWORD *)a2 = v7;
    *(_OWORD *)(a2 + 16) = v8;
  }
  else
  {
LABEL_5:
    unint64_t v4 = (unsigned char *)(a2 + 32);
  }
  *unint64_t v4 = 0;
  return result;
}

uint64_t HDStatisticsAverageSampleDuration::applyMaskToSample(uint64_t result, double **a2)
{
  uint64_t v2 = *a2;
  long long v3 = a2[1];
  if (*a2 != v3)
  {
    double v4 = *(double *)(result + 8);
    while (v4 >= *v2)
    {
      if (v4 < v2[1])
      {
        *(unsigned char *)(result + 32) = 0;
        return result;
      }
      v2 += 2;
      if (v2 == v3) {
        return result;
      }
    }
  }
  return result;
}

uint64_t HDStatisticsAverageSampleDuration::addSample(uint64_t this, const HDRawQuantitySample *a2)
{
  double v2 = a2->var2 - a2->var1;
  uint64_t v3 = *(void *)(this + 8);
  if (v3)
  {
    uint64_t v4 = v3 + 1;
    double v2 = *(double *)this + (v2 - *(double *)this) / (double)v4;
  }
  else
  {
    uint64_t v4 = 1;
  }
  *(double *)this = v2;
  *(void *)(this + 8) = v4;
  return this;
}

__n128 HDStatisticsAverageSampleDuration::updateMostRecentSample(__n128 *this, const HDRawQuantitySample *a2)
{
  if (!this[3].n128_u8[0] || (result.n128_u64[0] = this[1].n128_u64[1], result.n128_f64[0] <= a2->var1))
  {
    __n128 result = *(__n128 *)&a2->var0;
    __n128 v3 = *(__n128 *)&a2->var2;
    this[3].n128_u16[0] = *(_WORD *)&a2->var4;
    this[1] = result;
    this[2] = v3;
  }
  return result;
}

double HDStatisticsAverageSampleDuration::unarchive@<D0>(HDStatisticsAverageSampleDuration *this@<X0>, uint64_t a2@<X8>)
{
  *(_WORD *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(void *)(a2 + 8) = *((void *)this + 3);
  double result = *((double *)this + 12);
  *(double *)a2 = result;
  uint64_t v4 = *((void *)this + 14);
  if (v4)
  {
    double result = *(double *)(v4 + 8);
    uint64_t v5 = *(void *)(v4 + 16);
    *(int8x16_t *)(a2 + 16) = vextq_s8(*(int8x16_t *)(v4 + 24), *(int8x16_t *)(v4 + 24), 8uLL);
    *(double *)(a2 + 32) = result;
    *(void *)(a2 + 40) = v5;
    *(unsigned char *)(a2 + 48) = 1;
  }
  return result;
}

void HDStatisticsAverageSampleDuration::archive(int8x16_t *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 112) = 0;
  uint64_t v4 = (uint64_t *)(a2 + 112);
  *(void *)(a2 + 160) = 0;
  *(void *)a2 = &unk_1F171B978;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  uint64_t v5 = this->i64[1];
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = v5;
  uint64_t v6 = this->i64[0];
  *(_DWORD *)(a2 + 204) = 65;
  *(void *)(a2 + 96) = v6;
  statistics::Statistics::makeMostRecentDatum(a2);
  v7[0] = &unk_1F17206F8;
  int v11 = 127;
  int8x16_t v8 = vextq_s8(this[1], this[1], 8uLL);
  v7[1] = this[2].i64[0];
  v7[2] = this[2].i64[1];
  __int16 v9 = 0;
  char v10 = 0;
  statistics::RawQuantitySample::operator=(*v4, (uint64_t)v7);
  PB::Base::~Base((PB::Base *)v7);
}

void sub_1BD1A65BC(_Unwind_Exception *a1)
{
  statistics::Statistics::~Statistics(v1);
  _Unwind_Resume(a1);
}

id HDPredicateForContainerIdentifierAndDatabaseScope(uint64_t a1, uint64_t a2)
{
  void v13[2] = *MEMORY[0x1E4F143B8];
  __n128 v3 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v4 = _HDSQLiteValueForString();
  uint64_t v5 = [v3 predicateWithProperty:@"container_id" equalToValue:v4];

  uint64_t v6 = (void *)MEMORY[0x1E4F65D00];
  long long v7 = [NSNumber numberWithInteger:a2];
  int8x16_t v8 = [v6 predicateWithProperty:@"database_scope" equalToValue:v7];

  __int16 v9 = (void *)MEMORY[0x1E4F65D08];
  v13[0] = v5;
  v13[1] = v8;
  char v10 = [MEMORY[0x1E4F1C978] arrayWithObjects:v13 count:2];
  int v11 = [v9 predicateMatchingAllPredicates:v10];

  return v11;
}

void sub_1BD1A70CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t __Block_byref_object_copy__165(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__165(uint64_t a1)
{
}

void sub_1BD1A7DF4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1BD1A8008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__166(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__166(uint64_t a1)
{
}

void sub_1BD1A81D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1A83B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1A859C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1A8750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1A8904(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1A8AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *health::VirtualFilesystem::defaultVirtualFilesystem@<X0>(void *a1@<X8>)
{
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F1727340;
  result[3] = &unk_1F1727260;
  *a1 = result + 3;
  a1[1] = result;
  return result;
}

void *health::POSIXMappedFileExtent::POSIXMappedFileExtent(void *this, uint64_t a2, uint64_t a3, void *a4)
{
  this[1] = a2;
  this[2] = a3;
  *this = &unk_1F1727110;
  this[3] = a4;
  return this;
}

{
  this[1] = a2;
  this[2] = a3;
  *this = &unk_1F1727110;
  this[3] = a4;
  return this;
}

void health::POSIXMappedFileExtent::~POSIXMappedFileExtent(health::POSIXMappedFileExtent *this)
{
  *(void *)this = &unk_1F1727110;
  munmap(*((void **)this + 3), *((void *)this + 2));
}

{
  uint64_t vars8;

  health::POSIXMappedFileExtent::~POSIXMappedFileExtent(this);

  JUMPOUT(0x1C187B8A0);
}

uint64_t health::POSIXMappedFileExtent::bytes(health::POSIXMappedFileExtent *this)
{
  return *((void *)this + 3);
}

uint64_t health::POSIXFile::POSIXFile(uint64_t this, int a2)
{
  *(void *)this = &unk_1F1727138;
  *(_DWORD *)(this + 8) = a2;
  return this;
}

{
  *(void *)this = &unk_1F1727138;
  *(_DWORD *)(this + 8) = a2;
  return this;
}

void health::POSIXFile::~POSIXFile(health::POSIXFile *this)
{
  *(void *)this = &unk_1F1727138;
  health::POSIXFile::close((uint64_t)this);
}

{
  uint64_t vars8;

  health::POSIXFile::~POSIXFile(this);

  JUMPOUT(0x1C187B8A0);
}

void health::FormatString<int &,char *>(std::string *a1, std::string *a2, char **a3, char **a4)
{
  v4[0] = a4;
  v4[1] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<int &,char *>(a2, a1, 0, v4);
}

void sub_1BD1AA7EC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatString<unsigned long &,long long &,int &,char *>(std::string *a1, std::string *a2, char **a3, char **a4, char **a5, char **a6)
{
  v6[0] = a6;
  v6[1] = a5;
  v6[2] = a4;
  v6[3] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<unsigned long &,long long &,int &,char *>(a2, a1, 0, v6);
}

void sub_1BD1AA854(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *health::POSIXFile::mmap@<X0>(health::POSIXFile *this@<X0>, char *a2@<X1>, char *a3@<X2>, void *a4@<X8>)
{
  unint64_t v17 = a3;
  char v18 = a2;
  long long v7 = mmap(0, (size_t)a3, 1, 2, *((_DWORD *)this + 2), (off_t)a2);
  if (v7 == (void *)-1)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    uint64_t v11 = *__error();
    unint64_t v12 = std::system_category();
    char v13 = __error();
    BOOL v14 = __error();
    int v15 = strerror(*v14);
    health::FormatString<unsigned long &,long long &,int &,char *>(&v16, (std::string *)"Error occurred attempting to mmap {0} bytes at {1}: {2} {3}", &v17, &v18, (char **)v13, &v15);
    MEMORY[0x1C187B620](exception, v11, v12, &v16);
    __cxa_throw(exception, MEMORY[0x1E4FBA2F0], MEMORY[0x1E4FBA220]);
  }
  int8x16_t v8 = v7;
  double result = operator new(0x38uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F1727390;
  result[4] = a2;
  result[5] = a3;
  result[3] = &unk_1F1727110;
  result[6] = v8;
  *a4 = result + 3;
  a4[1] = result;
  return result;
}

void sub_1BD1AA9B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
}

void sub_1BD1AAA10()
{
}

void health::FormatString<long long &,int &,char *>(std::string *a1, char **a2, char **a3, char **a4)
{
  v4[0] = a4;
  v4[1] = a3;
  v4[2] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<long long &,int &,char *>((std::string *)"Error occurred while attempting to truncate file to length {0}: {1} {2}", a1, 0, v4);
}

void sub_1BD1AAA74(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::POSIXFile::close(uint64_t this)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(this + 8) != -1)
  {
    uint64_t v1 = this;
    int v2 = 3;
    int v27 = 3;
    while (1)
    {
      this = close(*(_DWORD *)(v1 + 8));
      if (!this) {
        break;
      }
      if (*__error() != 4)
      {
        _HKInitializeLogging();
        __n128 v3 = (NSObject **)MEMORY[0x1E4F29F18];
        uint64_t v4 = *MEMORY[0x1E4F29F18];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_FAULT))
        {
          int v15 = *__error();
          std::string v16 = __error();
          unint64_t v17 = strerror(*v16);
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)&buf[4] = v15;
          LOWORD(v29) = 2082;
          *(void *)((char *)&v29 + 2) = v17;
          _os_log_fault_impl(&dword_1BCB7D000, v4, OS_LOG_TYPE_FAULT, "Unexpected errno value for file close: %d %{public}s", buf, 0x12u);
          uint64_t v4 = *v3;
        }
        std::string::basic_string[abi:ne180100]<0>(v26, "false");
        std::string::basic_string[abi:ne180100]<0>(v25, "close");
        std::string::basic_string[abi:ne180100]<0>(v24, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDVirtualFilesystem.cpp");
        uint64_t v5 = __error();
        uint64_t v6 = __error();
        *(void *)buf = strerror(*v6);
        health::FormatString<int &,char *>(&__p, (std::string *)"Unexpected errno value for file close: {0} {1}", (char **)v5, (char **)buf);
        health::_HDAssertImplementation<std::logic_error>((uint64_t)v4, (uint64_t)v26, (uint64_t)v25, (uint64_t)v24, 137, (uint64_t)&__p);
      }
      if (!--v2)
      {
        _HKInitializeLogging();
        long long v7 = (NSObject **)MEMORY[0x1E4F29F18];
        int8x16_t v8 = *MEMORY[0x1E4F29F18];
        if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29F18], OS_LOG_TYPE_FAULT))
        {
          int v12 = *__error();
          char v13 = __error();
          BOOL v14 = strerror(*v13);
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&buf[4] = 3;
          LOWORD(v29) = 1024;
          *(_DWORD *)((char *)&v29 + 2) = v12;
          WORD3(v29) = 2082;
          *((void *)&v29 + 1) = v14;
          _os_log_fault_impl(&dword_1BCB7D000, v8, OS_LOG_TYPE_FAULT, "Reached max retry count (%d) for file close: %d %{public}s", buf, 0x18u);
          int8x16_t v8 = *v7;
        }
        std::string::basic_string[abi:ne180100]<0>(v22, "false");
        std::string::basic_string[abi:ne180100]<0>(v21, "close");
        std::string::basic_string[abi:ne180100]<0>(v20, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDVirtualFilesystem.cpp");
        char v10 = __error();
        uint64_t v11 = __error();
        char v18 = strerror(*v11);
        memset(&v19, 0, sizeof(v19));
        *(void *)buf = &v18;
        *(void *)&long long v29 = v10;
        *((void *)&v29 + 1) = &v27;
        health::FormatImplementation<int const&,int &,char *>((std::string *)"Reached max retry count ({0}) for file close: {1} {2}", &v19, 0, (char ***)buf);
        health::_HDAssertImplementation<std::logic_error>((uint64_t)v8, (uint64_t)v22, (uint64_t)v21, (uint64_t)v20, 142, (uint64_t)&v19);
      }
    }
    *(_DWORD *)(v1 + 8) = -1;
  }
  return this;
}

void sub_1BD1AADD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28,uint64_t a29,int a30,__int16 a31,char a32,char a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45)
{
  if (a39 < 0) {
    operator delete(__p);
  }
  if (a45 < 0) {
    operator delete(a40);
  }
  if (*(char *)(v45 - 113) < 0) {
    operator delete(*(void **)(v45 - 136));
  }
  if (*(char *)(v45 - 89) < 0) {
    operator delete(*(void **)(v45 - 112));
  }
  _Unwind_Resume(exception_object);
}

int *health::POSIXFilesystem::open@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  char v4 = a3;
  uint64_t v8 = a3 & 1;
  if (*(char *)(a2 + 23) >= 0) {
    __int16 v9 = (const char *)a2;
  }
  else {
    __int16 v9 = *(const char **)a2;
  }
  uint64_t v10 = open(v9, (a3 >> 1) & 2 | ((a3 & 1) << 9) | (32 * ((a3 >> 1) & 1)), 384);
  if ((v10 & 0x80000000) != 0)
  {
    if (v8 || (double result = __error(), *result != 2))
    {
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v15 = *__error();
      std::string v16 = std::system_category();
      unint64_t v17 = __error();
      char v18 = __error();
      uint64_t v24 = strerror(*v18);
      health::FormatString<std::string const&,int &,char *>(&v25, (std::string *)"Error occurred opening file at '{0}': {1} {2}", (char **)a2, (char **)v17, &v24);
      MEMORY[0x1C187B620](exception, v15, v16, &v25);
      __cxa_throw(exception, MEMORY[0x1E4FBA2F0], MEMORY[0x1E4FBA220]);
    }
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    uint64_t v11 = v10;
    if (!_HDIsUnitTesting)
    {
      int v12 = fcntl(v10, 63);
      if ((v12 & 0x80000000) == 0 && v12 != 2 && fcntl(v11, 64, 2) == -1)
      {
        std::string v19 = __cxa_allocate_exception(0x20uLL);
        uint64_t v20 = *__error();
        uint64_t v21 = std::system_category();
        unint64_t v22 = __error();
        char v23 = __error();
        uint64_t v24 = strerror(*v23);
        health::FormatString<std::string const&,int &,char *>(&v25, (std::string *)"Failed to set protection class when creating file at '{0}': {1} {2}", (char **)a2, (char **)v22, &v24);
        MEMORY[0x1C187B620](v19, v20, v21, &v25);
        __cxa_throw(v19, MEMORY[0x1E4FBA2F0], MEMORY[0x1E4FBA220]);
      }
    }
    double result = (int *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, v11);
    if ((~v4 & 0xC) == 0) {
      return (int *)(*(uint64_t (**)(void, void))(*(void *)*a4 + 56))(*a4, 0);
    }
  }
  return result;
}

void sub_1BD1AB114(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
    if ((v18 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v18)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v17);
  goto LABEL_6;
}

void health::FormatString<std::string const&,int &,char *>(std::string *a1, std::string *a2, char **a3, char **a4, char **a5)
{
  v5[0] = a5;
  v5[1] = a4;
  v5[2] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<std::string const&,int &,char *>(a2, a1, 0, v5);
}

void sub_1BD1AB1C4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

int *health::POSIXFilesystem::unlink(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) >= 0) {
    __n128 v3 = (const char *)a2;
  }
  else {
    __n128 v3 = *(const char **)a2;
  }
  double result = (int *)unlink(v3);
  if (result)
  {
    double result = __error();
    if (*result != 2)
    {
      uint64_t v10 = (char **)a2;
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v6 = *__error();
      long long v7 = std::system_category();
      uint64_t v8 = __error();
      __int16 v9 = __error();
      uint64_t v11 = strerror(*v9);
      health::FormatString<std::string const&,int &,char *>(&v12, (std::string *)"Error occurred unlinking file at '{0}': {1} {2}", v10, (char **)v8, &v11);
      MEMORY[0x1C187B620](exception, v6, v7, &v12);
      __cxa_throw(exception, MEMORY[0x1E4FBA2F0], MEMORY[0x1E4FBA220]);
    }
  }
  return result;
}

void sub_1BD1AB2CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
    if ((v18 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v18)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v17);
  goto LABEL_6;
}

void *health::POSIXFilesystem::fileWithDescriptor@<X0>(int a1@<W1>, void *a2@<X8>)
{
  double result = operator new(0x28uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F17273E0;
  result[3] = &unk_1F1727138;
  *((_DWORD *)result + 8) = a1;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void *health::InMemoryMappedFileExtent::InMemoryMappedFileExtent(void *result, uint64_t a2, uint64_t a3, void *a4)
{
  result[1] = a2;
  result[2] = a3;
  *double result = &unk_1F1727190;
  uint64_t v4 = a4[1];
  result[3] = *a4;
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

{
  uint64_t v4;

  result[1] = a2;
  result[2] = a3;
  *double result = &unk_1F1727190;
  uint64_t v4 = a4[1];
  result[3] = *a4;
  result[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void health::InMemoryMappedFileExtent::~InMemoryMappedFileExtent(health::InMemoryMappedFileExtent *this)
{
  *(void *)this = &unk_1F1727190;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

{
  std::__shared_weak_count *v1;

  *(void *)this = &unk_1F1727190;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

{
  std::__shared_weak_count *v1;
  uint64_t vars8;

  *(void *)this = &unk_1F1727190;
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }

  JUMPOUT(0x1C187B8A0);
}

uint64_t health::InMemoryMappedFileExtent::bytes(health::InMemoryMappedFileExtent *this)
{
  return **((void **)this + 3);
}

uint64_t health::InMemoryFile::InMemoryFile(uint64_t result, void *a2)
{
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)double result = &unk_1F17271B8;
  uint64_t v2 = a2[1];
  *(void *)(result + 24) = *a2;
  *(void *)(result + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(result + 40) = 0;
  return result;
}

{
  uint64_t v2;

  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)double result = &unk_1F17271B8;
  uint64_t v2 = a2[1];
  *(void *)(result + 24) = *a2;
  *(void *)(result + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  *(_DWORD *)(result + 40) = 0;
  return result;
}

void *health::InMemoryFile::write(health::InMemoryFile *this, uint64_t a2, const unsigned __int8 *__src, size_t __n)
{
  int v4 = *((_DWORD *)this + 10);
  if (v4 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Read-only file.");
    goto LABEL_21;
  }
  if (v4 == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "File has been failed.");
LABEL_21:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  unint64_t v9 = __n + a2;
  uint64_t v10 = (unint64_t *)*((void *)this + 3);
  unint64_t v11 = *v10;
  unint64_t v12 = v10[1];
  unint64_t v13 = v12 - *v10;
  if (__n + a2 > v13)
  {
    unint64_t v14 = (v9 & 0xFFFFFFFFFFF00000) + 0x100000;
    if (v10[2] - v11 < v14)
    {
      if ((v14 & 0x8000000000000000) != 0) {
        std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v15 = (char *)operator new((v9 & 0xFFFFFFFFFFF00000) + 0x100000);
      std::string v16 = &v15[v13];
      if (v12 != v11)
      {
        unint64_t v17 = ~v11 + v12;
        do
        {
          char v18 = *(unsigned char *)--v12;
          v15[v17--] = v18;
        }
        while (v12 != v11);
        std::string v16 = v15;
      }
      unint64_t *v10 = (unint64_t)v16;
      v10[1] = (unint64_t)&v15[v13];
      v10[2] = (unint64_t)&v15[v14];
      if (v11) {
        operator delete((void *)v11);
      }
    }
    std::string v19 = (unint64_t *)*((void *)this + 3);
    unint64_t v11 = *v19;
    unint64_t v20 = v19[1] - *v19;
    if (v9 <= v20)
    {
      if (v9 < v20) {
        v19[1] = v11 + v9;
      }
    }
    else
    {
      std::vector<unsigned char>::__append(v19, v9 - v20);
      unint64_t v11 = **((void **)this + 3);
    }
  }

  return memcpy((void *)(v11 + a2), __src, __n);
}

void sub_1BD1AB718(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

size_t health::InMemoryFile::read(health::InMemoryFile *this, unint64_t a2, unsigned __int8 *__dst, size_t a4)
{
  if (*((_DWORD *)this + 10) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "File has been failed.");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  uint64_t v4 = **((void **)this + 3);
  unint64_t v5 = *(void *)(*((void *)this + 3) + 8) - v4;
  BOOL v6 = v5 > a2;
  size_t v7 = v5 - a2;
  if (!v6) {
    return 0;
  }
  if (v7 >= a4) {
    size_t v8 = a4;
  }
  else {
    size_t v8 = v7;
  }
  memcpy(__dst, (const void *)(v4 + a2), v8);
  return v8;
}

void sub_1BD1AB7C8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::InMemoryFile::mmap(health::InMemoryFile *this@<X0>, unint64_t a2@<X1>, size_t a3@<X2>, void *a4@<X8>)
{
  size_t v8 = (std::__shared_weak_count *)operator new(0x30uLL);
  v8->__shared_owners_ = 0;
  v8->__shared_weak_owners_ = 0;
  v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727430;
  unint64_t v9 = (void **)&v8[1].__vftable;
  std::vector<unsigned char>::vector(&v8[1].__vftable, a3);
  uint64_t v10 = **((void **)this + 3);
  int64_t v11 = *(void *)(*((void *)this + 3) + 8) - v10;
  if (v11 > a2)
  {
    if (v11 >= (uint64_t)(a3 + a2)) {
      int64_t v11 = a3 + a2;
    }
    if (v11 != a2) {
      memmove(*v9, (const void *)(v10 + a2), v11 - a2);
    }
  }
  unint64_t v12 = operator new(0x40uLL);
  v12[1] = 0;
  v12[2] = 0;
  void *v12 = &unk_1F1727480;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  v12[4] = a2;
  v12[5] = a3;
  v12[3] = &unk_1F1727190;
  v12[6] = v9;
  v12[7] = v8;
  atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  *a4 = v12 + 3;
  a4[1] = v12;

  std::__shared_weak_count::__release_shared[abi:ne180100](v8);
}

void sub_1BD1AB91C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t health::InMemoryFile::size(health::InMemoryFile *this)
{
  if (*((_DWORD *)this + 10) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "File has been failed.");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  return *(void *)(*((void *)this + 3) + 8) - **((void **)this + 3);
}

void sub_1BD1AB9B0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::InMemoryFile::truncate(health::InMemoryFile *this, unint64_t a2)
{
  if (*((_DWORD *)this + 10) == 3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "File has been failed.");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  uint64_t v2 = (unint64_t *)*((void *)this + 3);
  unint64_t v3 = v2[1] - *v2;
  BOOL v4 = a2 >= v3;
  size_t v5 = a2 - v3;
  if (v5 != 0 && v4)
  {
    std::vector<unsigned char>::__append(v2, v5);
  }
  else if (!v4)
  {
    v2[1] = *v2 + a2;
  }
}

void sub_1BD1ABA64(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::InMemoryFilesystem::open(uint64_t **a1@<X0>, long long *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, long long **a5@<X8>)
{
  uint64_t v10 = a1 + 1;
  unint64_t v20 = a2;
  int64_t v11 = std::__tree<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(a1 + 1, (void **)a2, &v20);
  unint64_t v13 = (long long *)v11[7];
  unint64_t v12 = (std::__shared_weak_count *)v11[8];
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v13)
  {
    unint64_t v14 = v12;
LABEL_5:
    *a5 = v13;
    a5[1] = (long long *)v14;
    return;
  }
  if (a3)
  {
    uint64_t v15 = (std::__shared_weak_count *)operator new(0x30uLL);
    v15->__shared_owners_ = 0;
    v15->__shared_weak_owners_ = 0;
    v15->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727430;
    v15[1].__shared_owners_ = 0;
    v15[1].__shared_weak_owners_ = 0;
    v15[1].__vftable = 0;
    char v18 = v15 + 1;
    std::string v19 = v15;
    ((void (*)(long long **__return_ptr, uint64_t **, long long *, uint64_t, uint64_t, std::__shared_weak_count **))(*a1)[4])(&v20, a1, a2, a3, a4, &v18);
    unint64_t v13 = v20;
    unint64_t v14 = v21;
    unint64_t v20 = 0;
    uint64_t v21 = 0;
    if (v12)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
      if (v21) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v21);
      }
    }
    if (v19) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
    }
    if (v13)
    {
      unint64_t v20 = a2;
      std::string v16 = std::__tree<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v10, (void **)a2, &v20);
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v17 = (std::__shared_weak_count *)v16[8];
      v16[7] = (uint64_t)v13;
      v16[8] = (uint64_t)v14;
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v17);
      }
    }
    goto LABEL_5;
  }
  *a5 = 0;
  a5[1] = 0;
  if (v12)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
}

void sub_1BD1ABC1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  _Unwind_Resume(exception_object);
}

void health::InMemoryFilesystem::unlink(void *a1, void **a2)
{
  uint64_t v2 = a1 + 2;
  unint64_t v3 = (void *)a1[2];
  if (v3)
  {
    BOOL v6 = a1 + 2;
    do
    {
      char v7 = std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v3 + 4, a2);
      if (v7 >= 0) {
        size_t v8 = v3;
      }
      else {
        size_t v8 = v3 + 1;
      }
      if (v7 >= 0) {
        BOOL v6 = v3;
      }
      unint64_t v3 = (void *)*v8;
    }
    while (*v8);
    if (v6 != v2
      && (std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, (void **)v6 + 4) & 0x80) == 0)
    {
      unint64_t v9 = (void *)v6[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          unint64_t v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        int64_t v11 = v6;
        do
        {
          uint64_t v10 = (void *)v11[2];
          BOOL v12 = *v10 == (void)v11;
          int64_t v11 = v10;
        }
        while (!v12);
      }
      if ((void *)a1[1] == v6) {
        a1[1] = v10;
      }
      unint64_t v13 = (uint64_t *)a1[2];
      --a1[3];
      std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v13, v6);
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<health::InMemoryFile>>,0>((uint64_t)(v6 + 4));
      operator delete(v6);
    }
  }
}

void health::InMemoryFilesystem::createFileForPath(uint64_t *a1@<X4>, void *a2@<X8>)
{
  BOOL v4 = operator new(0x48uLL);
  v4[1] = 0;
  v4[2] = 0;
  *BOOL v4 = &unk_1F17274D0;
  uint64_t v6 = *a1;
  size_t v5 = (std::__shared_weak_count *)a1[1];
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  void v4[3] = &unk_1F17271B8;
  v4[4] = 0;
  v4[5] = 0;
  v4[6] = v6;
  v4[7] = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    *((_DWORD *)v4 + 16) = 0;
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  else
  {
    *((_DWORD *)v4 + 16) = 0;
  }
  *a2 = v4 + 3;
  a2[1] = v4;
}

void health::POSIXFilesystem::~POSIXFilesystem(health::POSIXFilesystem *this)
{
}

void health::InMemoryFile::~InMemoryFile(health::InMemoryFile *this)
{
  *(void *)this = &unk_1F17271B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1F17271B8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }

  JUMPOUT(0x1C187B8A0);
}

void health::InMemoryFilesystem::~InMemoryFilesystem(health::InMemoryFilesystem *this)
{
  *(void *)this = &unk_1F17272F0;
  std::__tree<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>>>::destroy(*((void **)this + 2));
}

{
  uint64_t vars8;

  *(void *)this = &unk_1F17272F0;
  std::__tree<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>>>::destroy(*((void **)this + 2));

  JUMPOUT(0x1C187B8A0);
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  size_t v5 = (char *)a1[1];
  BOOL v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    char v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      std::vector<std::unique_ptr<statistics::Interval>>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    BOOL v12 = &v7[v11];
    unint64_t v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      unint64_t v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      size_t v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void std::__tree<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>>>::destroy(a1[1]);
    std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<health::InMemoryFile>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<health::InMemoryFile>>,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

void std::__shared_ptr_emplace<health::POSIXFilesystem>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727340;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<health::POSIXFilesystem>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727340;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C187B8A0);
}

uint64_t std::__shared_ptr_emplace<health::POSIXFilesystem>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void health::FormatImplementation<int &,char *>(std::string *a1, std::string *a2, std::string::size_type a3, char ***a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    long long v29 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v29 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v29 = i + 2;
    int v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v21 = 0;
      unint64_t v22 = i + 3;
      do
      {
        long long v29 = v22;
        uint64_t v21 = (v20 - 48) + 10 * v21;
        int v23 = *v22++;
        int v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      long long v29 = v22;
      if (*(v22 - 1) == 125) {
        health::FormatterParameters<0ul,int &,char *>::formatOptionsAtIndex<int &,char *>(v21);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_47;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v25, (const char **)&v29);
  BOOL v12 = v29;
  if (*((void *)&v25 + 1))
  {
    if (*((void *)&v25 + 1) == 1)
    {
      unint64_t v13 = **a4;
      std::string __p = v13;
      if (v13) {
        unint64_t v13 = (char *)strlen(v13);
      }
      unint64_t v31 = v13;
      long long v32 = v25;
      long long v33 = v26;
      long long v34 = v27;
      uint64_t v35 = v28;
      unint64_t v14 = (char *)*((void *)&v26 + 1);
      if (*((void *)&v26 + 1) <= (unint64_t)v13) {
        unint64_t v14 = v13;
      }
      if ((_BYTE)v26) {
        char v15 = v14;
      }
      else {
        char v15 = v13;
      }
      health::FormatImplementation<int &,char *>(v29, a2, &v15[a3 - v8], a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v16 = a2;
      }
      else {
        std::string v16 = (std::string *)a2->__r_.__value_.__r.__words[0];
      }
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(&v25, (unsigned char *)v16 + a3 - v8, (uint64_t)&__p);
      goto LABEL_37;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_47:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::TypeFormatter<int &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[1], (uint64_t)&v25);
  unint64_t v17 = (char *)BYTE7(v32);
  if (SBYTE7(v32) < 0) {
    unint64_t v17 = v31;
  }
  char v18 = (char *)*((void *)&v26 + 1);
  if (*((void *)&v26 + 1) <= (unint64_t)v17) {
    char v18 = v17;
  }
  if ((_BYTE)v26) {
    unint64_t v17 = v18;
  }
  health::FormatImplementation<int &,char *>(v12, a2, &v17[a3 - v8], a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string v19 = (char *)a2;
  }
  else {
    std::string v19 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v25, &v19[a3 - v8], (const void **)&__p);
  if (SBYTE7(v32) < 0) {
    operator delete(__p);
  }
LABEL_37:
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BD1AC53C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,int &,char *>::formatOptionsAtIndex<int &,char *>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1AC600(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<unsigned long &,long long &,int &,char *>(std::string *a1, std::string *a2, std::string::size_type a3, char ***a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    long long v33 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)&v29, (const char **)&v33);
        BOOL v12 = v33;
        switch(*((void *)&v29 + 1))
        {
          case 0:
            health::TypeFormatter<unsigned long &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[3], (uint64_t)&v29);
            unint64_t v13 = (char *)BYTE7(v36);
            if (SBYTE7(v36) < 0) {
              unint64_t v13 = v35;
            }
            unint64_t v14 = (char *)*((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= (unint64_t)v13) {
              unint64_t v14 = v13;
            }
            if ((_BYTE)v30) {
              unint64_t v13 = v14;
            }
            health::FormatImplementation<unsigned long &,long long &,int &,char *>(v12, a2, &v13[a3 + v8], a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              char v15 = (char *)a2;
            }
            else {
              char v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_41;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[2], (uint64_t)&v29);
            char v18 = (char *)BYTE7(v36);
            if (SBYTE7(v36) < 0) {
              char v18 = v35;
            }
            std::string v19 = (char *)*((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= (unint64_t)v18) {
              std::string v19 = v18;
            }
            if ((_BYTE)v30) {
              char v18 = v19;
            }
            health::FormatImplementation<unsigned long &,long long &,int &,char *>(v12, a2, &v18[a3 + v8], a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              char v15 = (char *)a2;
            }
            else {
              char v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_41;
          case 2:
            health::TypeFormatter<int &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[1], (uint64_t)&v29);
            std::string v16 = (char *)BYTE7(v36);
            if (SBYTE7(v36) < 0) {
              std::string v16 = v35;
            }
            unint64_t v17 = (char *)*((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= (unint64_t)v16) {
              unint64_t v17 = v16;
            }
            if ((_BYTE)v30) {
              std::string v16 = v17;
            }
            health::FormatImplementation<unsigned long &,long long &,int &,char *>(v12, a2, &v16[a3 + v8], a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              char v15 = (char *)a2;
            }
            else {
              char v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_41:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v29, &v15[a3 + v8], (const void **)&__p);
            if (SBYTE7(v36) < 0) {
              operator delete(__p);
            }
            if (v8) {
              goto LABEL_44;
            }
            return;
          case 3:
            int v20 = **a4;
            std::string __p = v20;
            if (v20) {
              int v20 = (char *)strlen(v20);
            }
            uint64_t v35 = v20;
            long long v36 = v29;
            long long v37 = v30;
            long long v38 = v31;
            uint64_t v39 = v32;
            uint64_t v21 = (char *)*((void *)&v30 + 1);
            if (*((void *)&v30 + 1) <= (unint64_t)v20) {
              uint64_t v21 = v20;
            }
            if ((_BYTE)v30) {
              unint64_t v22 = v21;
            }
            else {
              unint64_t v22 = v20;
            }
            health::FormatImplementation<unsigned long &,long long &,int &,char *>(v33, a2, &v22[a3 + v8], a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              int v23 = a2;
            }
            else {
              int v23 = (std::string *)a2->__r_.__value_.__r.__words[0];
            }
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(&v29, (unsigned char *)v23 + a3 + v8, (uint64_t)&__p);
            if (!v8) {
              return;
            }
LABEL_44:
            health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_65;
        }
      }
      long long v33 = i + 2;
      int v24 = i[2];
      if ((v24 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v25 = 0;
        long long v26 = i + 3;
        do
        {
          long long v33 = v26;
          uint64_t v25 = (v24 - 48) + 10 * v25;
          int v27 = *v26++;
          int v24 = v27;
        }
        while ((v27 - 58) >= 0xFFFFFFF6);
        long long v33 = v26;
        if (*(v26 - 1) == 125) {
          health::FormatterParameters<0ul,unsigned long &,long long &,int &,char *>::formatOptionsAtIndex<unsigned long &,long long &,int &,char *>(v25);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_65:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    long long v33 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BD1ACA30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned long &,long long &,int &,char *>::formatOptionsAtIndex<unsigned long &,long long &,int &,char *>(uint64_t a1)
{
  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    unint64_t v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3) {
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
    }
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1ACB54(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::TypeFormatter<unsigned long &,void>::TypeFormatter(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v12);
  uint64_t v5 = v12;
  if (*(unsigned char *)(a3 + 16)) {
    *(void *)((char *)&v13[2] + *(void *)(v12 - 24)) = *(void *)(a3 + 24);
  }
  if (*(unsigned char *)(a3 + 32)) {
    *(void *)((char *)&v13[1] + *(void *)(v5 - 24)) = *(void *)(a3 + 40);
  }
  unint64_t v6 = (const std::ios_base *)((char *)&v13[-1] + *(void *)(v5 - 24));
  std::ios_base::fmtflags v7 = *(char *)(a3 + 52);
  if (v6[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v6);
    std::string::size_type v8 = std::locale::use_facet(v10, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 32);
    std::locale::~locale(v10);
  }
  v6[1].__fmtflags_ = v7;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v13, v10);
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  *(_OWORD *)a1 = *(_OWORD *)&v10[0].__locale_;
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = *MEMORY[0x1E4FBA418];
  *(void *)((char *)&v13[-1] + *(void *)(v12 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v13[0] = MEMORY[0x1E4FBA470] + 16;
  if (v14 < 0) {
    operator delete((void *)v13[8]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v15);
  return a1;
}

void sub_1BD1ACDC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, char a13)
{
  std::locale::~locale(&a10);
  std::ostringstream::~ostringstream((uint64_t)&a13);
  if (*(char *)(v13 + 23) < 0) {
    operator delete(*(void **)v13);
  }
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<health::POSIXMappedFileExtent>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727390;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<health::POSIXMappedFileExtent>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727390;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C187B8A0);
}

uint64_t std::__shared_ptr_emplace<health::POSIXMappedFileExtent>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void health::FormatImplementation<long long &,int &,char *>(std::string *a1, std::string *a2, std::string::size_type a3, char ***a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    long long v31 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v31 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v31 = i + 2;
    int v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v23 = 0;
      int v24 = i + 3;
      do
      {
        long long v31 = v24;
        uint64_t v23 = (v22 - 48) + 10 * v23;
        int v25 = *v24++;
        int v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      long long v31 = v24;
      if (*(v24 - 1) == 125) {
        health::FormatterParameters<0ul,long long &,int &,char *>::formatOptionsAtIndex<long long &,int &,char *>(v23);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_57;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  uint64_t v12 = v31;
  if (*((void *)&v27 + 1))
  {
    if (*((void *)&v27 + 1) != 1)
    {
      if (*((void *)&v27 + 1) == 2)
      {
        uint64_t v13 = **a4;
        std::string __p = v13;
        if (v13) {
          uint64_t v13 = (char *)strlen(v13);
        }
        long long v33 = v13;
        long long v34 = v27;
        long long v35 = v28;
        long long v36 = v29;
        uint64_t v37 = v30;
        char v14 = (char *)*((void *)&v28 + 1);
        if (*((void *)&v28 + 1) <= (unint64_t)v13) {
          char v14 = v13;
        }
        if ((_BYTE)v28) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = v13;
        }
        health::FormatImplementation<long long &,int &,char *>(v31, a2, &v15[a3 + v8], a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string v16 = a2;
        }
        else {
          std::string v16 = (std::string *)a2->__r_.__value_.__r.__words[0];
        }
        health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(&v27, (unsigned char *)v16 + a3 + v8, (uint64_t)&__p);
        goto LABEL_47;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_57:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    health::TypeFormatter<int &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[1], (uint64_t)&v27);
    int v20 = (char *)BYTE7(v34);
    if (SBYTE7(v34) < 0) {
      int v20 = v33;
    }
    uint64_t v21 = (char *)*((void *)&v28 + 1);
    if (*((void *)&v28 + 1) <= (unint64_t)v20) {
      uint64_t v21 = v20;
    }
    if ((_BYTE)v28) {
      int v20 = v21;
    }
    health::FormatImplementation<long long &,int &,char *>(v12, a2, &v20[a3 + v8], a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string v19 = (char *)a2;
    }
    else {
      std::string v19 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
  else
  {
    health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[2], (uint64_t)&v27);
    unint64_t v17 = (char *)BYTE7(v34);
    if (SBYTE7(v34) < 0) {
      unint64_t v17 = v33;
    }
    char v18 = (char *)*((void *)&v28 + 1);
    if (*((void *)&v28 + 1) <= (unint64_t)v17) {
      char v18 = v17;
    }
    if ((_BYTE)v28) {
      unint64_t v17 = v18;
    }
    health::FormatImplementation<long long &,int &,char *>(v12, a2, &v17[a3 + v8], a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string v19 = (char *)a2;
    }
    else {
      std::string v19 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v19[a3 + v8], (const void **)&__p);
  if (SBYTE7(v34) < 0) {
    operator delete(__p);
  }
LABEL_47:
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BD1AD220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,long long &,int &,char *>::formatOptionsAtIndex<long long &,int &,char *>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1AD30C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<int const&,int &,char *>(std::string *a1, std::string *a2, std::string::size_type a3, char ***a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    long long v52 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v52 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v52 = i + 2;
    int v42 = i[2];
    if ((v42 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v43 = 0;
      unint64_t v44 = i + 3;
      do
      {
        long long v52 = v44;
        uint64_t v43 = (v42 - 48) + 10 * v43;
        int v45 = *v44++;
        int v42 = v45;
      }
      while ((v45 - 58) >= 0xFFFFFFF6);
      long long v52 = v44;
      if (*(v44 - 1) == 125) {
        health::FormatterParameters<0ul,int const&,int &,char *>::formatOptionsAtIndex<int const&,int &,char *>(v43);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_108;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v48, (const char **)&v52);
  uint64_t v12 = v52;
  if (!*((void *)&v48 + 1))
  {
    uint64_t v54 = 0;
    long long v53 = 0uLL;
    std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v57);
    unint64_t v17 = v57;
    if ((_BYTE)v49) {
      *(void *)((char *)v59 + *((void *)v57 - 3) + 8) = *((void *)&v49 + 1);
    }
    if ((_BYTE)v50) {
      *(void *)((char *)v59 + *(v17 - 3)) = *((void *)&v50 + 1);
    }
    char v18 = (const std::ios_base *)((char *)&v57 + *(v17 - 3));
    std::ios_base::fmtflags v19 = SBYTE4(v51);
    if (v18[1].__fmtflags_ == -1)
    {
      std::ios_base::getloc(v18);
      int v20 = std::locale::use_facet(v55, MEMORY[0x1E4FBA258]);
      ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 32);
      std::locale::~locale(v55);
    }
    v18[1].__fmtflags_ = v19;
    std::ostream::operator<<();
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v58, v55);
    long long v53 = *(_OWORD *)&v55[0].__locale_;
    uint64_t v54 = v56;
    uint64_t v57 = (void *)*MEMORY[0x1E4FBA418];
    *(void **)((char *)&v57 + *((void *)v57 - 3)) = *(void **)(MEMORY[0x1E4FBA418] + 24);
    uint64_t v58 = MEMORY[0x1E4FBA470] + 16;
    if (v62 < 0) {
      operator delete(__p);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x1C187B850](&v63);
    int v47 = SHIBYTE(v54);
    if (v54 >= 0) {
      size_t v21 = HIBYTE(v54);
    }
    else {
      size_t v21 = *((void *)&v53 + 1);
    }
    size_t v22 = *((void *)&v49 + 1);
    if (*((void *)&v49 + 1) <= v21) {
      size_t v22 = v21;
    }
    if ((_BYTE)v49) {
      size_t v23 = v22;
    }
    else {
      size_t v23 = v21;
    }
    health::FormatImplementation<int const&,int &,char *>(v12, a2, v23 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      int v24 = a2;
    }
    else {
      int v24 = (std::string *)a2->__r_.__value_.__r.__words[0];
    }
    int v25 = (char *)v24 + a3 + v8;
    if ((_BYTE)v49)
    {
      uint64_t v26 = *((void *)&v49 + 1);
      unint64_t v27 = *((void *)&v49 + 1) - v21;
      if (*((void *)&v49 + 1) > v21)
      {
        if (!v48)
        {
          if (v21)
          {
            if (v47 >= 0) {
              long long v33 = &v53;
            }
            else {
              long long v33 = (long long *)v53;
            }
            memmove((char *)v24 + a3 + v8, v33, v21);
          }
          if (v26 != v21)
          {
            size_t v34 = (size_t)v24 + v21;
            do
            {
              *(unsigned char *)(v34 + a3 + v8) = BYTE4(v51);
              ++v34;
              --v27;
            }
            while (v27);
          }
          goto LABEL_58;
        }
        if (v48 == 1)
        {
          unint64_t v35 = v27 >> 1;
          if (v27 >= 2)
          {
            if (v35 <= 1) {
              uint64_t v36 = 1;
            }
            else {
              uint64_t v36 = v27 >> 1;
            }
            do
            {
              *v25++ = BYTE4(v51);
              --v36;
            }
            while (v36);
          }
          if (v21)
          {
            if (v47 >= 0) {
              uint64_t v37 = &v53;
            }
            else {
              uint64_t v37 = (long long *)v53;
            }
            memmove(v25, v37, v21);
          }
          if (v27 != v35)
          {
            unint64_t v38 = v27 - (v27 >> 1);
            uint64_t v39 = &v25[v21];
            if (v38 <= 1) {
              unint64_t v38 = 1;
            }
            uint64_t v40 = -(uint64_t)v38;
            do
              *v39++ = BYTE4(v51);
            while (!__CFADD__(v40++, 1));
          }
          goto LABEL_58;
        }
        if (v48 != 2)
        {
LABEL_58:
          if ((SHIBYTE(v54) & 0x80000000) == 0) {
            goto LABEL_72;
          }
          long long v29 = (void *)v53;
LABEL_71:
          operator delete(v29);
          goto LABEL_72;
        }
        if (*((void *)&v49 + 1) != v21)
        {
          do
          {
            *v25++ = BYTE4(v51);
            --v27;
          }
          while (v27);
        }
      }
    }
    if (v21)
    {
      if (v47 >= 0) {
        long long v28 = &v53;
      }
      else {
        long long v28 = (long long *)v53;
      }
      memmove(v25, v28, v21);
    }
    goto LABEL_58;
  }
  if (*((void *)&v48 + 1) != 1)
  {
    if (*((void *)&v48 + 1) == 2)
    {
      uint64_t v13 = **a4;
      uint64_t v57 = v13;
      if (v13) {
        uint64_t v13 = (char *)strlen(v13);
      }
      uint64_t v58 = (uint64_t)v13;
      v59[0] = v48;
      v59[1] = v49;
      v59[2] = v50;
      uint64_t v60 = v51;
      char v14 = (char *)*((void *)&v49 + 1);
      if (*((void *)&v49 + 1) <= (unint64_t)v13) {
        char v14 = v13;
      }
      if ((_BYTE)v49) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v13;
      }
      health::FormatImplementation<int const&,int &,char *>(v52, a2, &v15[a3 + v8], a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v16 = a2;
      }
      else {
        std::string v16 = (std::string *)a2->__r_.__value_.__r.__words[0];
      }
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(&v48, (unsigned char *)v16 + a3 + v8, (uint64_t)&v57);
      goto LABEL_72;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_108:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::TypeFormatter<int &,void>::TypeFormatter((uint64_t)&v57, (uint64_t)a4[1], (uint64_t)&v48);
  unint64_t v30 = BYTE7(v59[0]);
  if (SBYTE7(v59[0]) < 0) {
    unint64_t v30 = v58;
  }
  unint64_t v31 = *((void *)&v49 + 1);
  if (*((void *)&v49 + 1) <= v30) {
    unint64_t v31 = v30;
  }
  if ((_BYTE)v49) {
    unint64_t v30 = v31;
  }
  health::FormatImplementation<int const&,int &,char *>(v12, a2, v30 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v32 = (char *)a2;
  }
  else {
    uint64_t v32 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v48, &v32[a3 + v8], (const void **)&v57);
  if (SBYTE7(v59[0]) < 0)
  {
    long long v29 = v57;
    goto LABEL_71;
  }
LABEL_72:
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BD1AD9D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,std::locale a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  __cxa_free_exception(v32);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,int const&,int &,char *>::formatOptionsAtIndex<int const&,int &,char *>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1ADAF4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<std::string const&,int &,char *>(std::string *a1, std::string *a2, std::string::size_type a3, char ***a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    unint64_t v31 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    unint64_t v31 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    unint64_t v31 = i + 2;
    int v22 = i[2];
    if ((v22 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v23 = 0;
      int v24 = i + 3;
      do
      {
        unint64_t v31 = v24;
        uint64_t v23 = (v22 - 48) + 10 * v23;
        int v25 = *v24++;
        int v22 = v25;
      }
      while ((v25 - 58) >= 0xFFFFFFF6);
      unint64_t v31 = v24;
      if (*(v24 - 1) == 125) {
        health::FormatterParameters<0ul,std::string const&,int &,char *>::formatOptionsAtIndex<std::string const&,int &,char *>(v23);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_57;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v27, (const char **)&v31);
  uint64_t v12 = v31;
  if (*((void *)&v27 + 1))
  {
    if (*((void *)&v27 + 1) != 1)
    {
      if (*((void *)&v27 + 1) == 2)
      {
        uint64_t v13 = **a4;
        std::string __p = v13;
        if (v13) {
          uint64_t v13 = (char *)strlen(v13);
        }
        long long v33 = v13;
        long long v34 = v27;
        long long v35 = v28;
        long long v36 = v29;
        uint64_t v37 = v30;
        char v14 = (char *)*((void *)&v28 + 1);
        if (*((void *)&v28 + 1) <= (unint64_t)v13) {
          char v14 = v13;
        }
        if ((_BYTE)v28) {
          uint64_t v15 = v14;
        }
        else {
          uint64_t v15 = v13;
        }
        health::FormatImplementation<std::string const&,int &,char *>(v31, a2, &v15[a3 + v8], a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string v16 = a2;
        }
        else {
          std::string v16 = (std::string *)a2->__r_.__value_.__r.__words[0];
        }
        health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(&v27, (unsigned char *)v16 + a3 + v8, (uint64_t)&__p);
        goto LABEL_47;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_57:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    health::TypeFormatter<int &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[1], (uint64_t)&v27);
    int v20 = (char *)BYTE7(v34);
    if (SBYTE7(v34) < 0) {
      int v20 = v33;
    }
    size_t v21 = (char *)*((void *)&v28 + 1);
    if (*((void *)&v28 + 1) <= (unint64_t)v20) {
      size_t v21 = v20;
    }
    if ((_BYTE)v28) {
      int v20 = v21;
    }
    health::FormatImplementation<std::string const&,int &,char *>(v12, a2, &v20[a3 + v8], a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::ios_base::fmtflags v19 = (char *)a2;
    }
    else {
      std::ios_base::fmtflags v19 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
  else
  {
    health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, (uint64_t)a4[2], (uint64_t)&v27);
    unint64_t v17 = (char *)BYTE7(v34);
    if (SBYTE7(v34) < 0) {
      unint64_t v17 = v33;
    }
    char v18 = (char *)*((void *)&v28 + 1);
    if (*((void *)&v28 + 1) <= (unint64_t)v17) {
      char v18 = v17;
    }
    if ((_BYTE)v28) {
      unint64_t v17 = v18;
    }
    health::FormatImplementation<std::string const&,int &,char *>(v12, a2, &v17[a3 + v8], a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::ios_base::fmtflags v19 = (char *)a2;
    }
    else {
      std::ios_base::fmtflags v19 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(&v27, &v19[a3 + v8], (const void **)&__p);
  if (SBYTE7(v34) < 0) {
    operator delete(__p);
  }
LABEL_47:
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BD1ADE98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string const&,int &,char *>::formatOptionsAtIndex<std::string const&,int &,char *>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1ADF84(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<health::POSIXFile>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F17273E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<health::POSIXFile>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F17273E0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C187B8A0);
}

uint64_t std::__shared_ptr_emplace<health::POSIXFile>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727430;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727430;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C187B8A0);
}

void std::__shared_ptr_emplace<std::vector<unsigned char>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<health::InMemoryMappedFileExtent>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727480;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<health::InMemoryMappedFileExtent>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F1727480;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C187B8A0);
}

uint64_t std::__shared_ptr_emplace<health::InMemoryMappedFileExtent>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t *std::__tree<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, void **a2, long long **a3)
{
  unint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  std::ios_base::fmtflags v7 = a1 + 1;
  std::string::size_type v8 = a1 + 1;
  if (!v5) {
    goto LABEL_10;
  }
  std::ios_base::fmtflags v7 = a1 + 1;
  while (1)
  {
    while (1)
    {
      std::string::size_type v8 = (uint64_t **)v5;
      size_t v10 = v5 + 4;
      if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a2, (void **)v5 + 4) & 0x80) == 0) {
        break;
      }
      uint64_t v5 = *v8;
      std::ios_base::fmtflags v7 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if ((std::operator<=>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(v10, a2) & 0x80) == 0) {
      break;
    }
    std::ios_base::fmtflags v7 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  int v11 = *v7;
  if (!*v7)
  {
LABEL_10:
    uint64_t v12 = *a3;
    uint64_t v13 = (uint64_t *)operator new(0x48uLL);
    v18[0] = v13;
    v18[1] = v6;
    char v19 = 0;
    char v14 = (std::string *)(v13 + 4);
    if (*((char *)v12 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v14, *(const std::string::value_type **)v12, *((void *)v12 + 1));
    }
    else
    {
      long long v15 = *v12;
      v13[6] = *((void *)v12 + 2);
      *(_OWORD *)&v14->__r_.__value_.__l.__data_ = v15;
    }
    v13[7] = 0;
    v13[8] = 0;
    char v19 = 1;
    uint64_t *v13 = 0;
    v13[1] = 0;
    void v13[2] = (uint64_t)v8;
    *std::ios_base::fmtflags v7 = v13;
    std::string v16 = (uint64_t *)**a1;
    if (v16)
    {
      *a1 = v16;
      uint64_t v13 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
    int v11 = (uint64_t *)v18[0];
    v18[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,void *>>>>::reset[abi:ne180100]((uint64_t)v18);
  }
  return v11;
}

void sub_1BD1AE2B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<health::InMemoryFile>>,void *>>>>::reset[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<health::InMemoryFile>>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void std::__shared_ptr_emplace<health::InMemoryFile>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F17274D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<health::InMemoryFile>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F17274D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1C187B8A0);
}

uint64_t std::__shared_ptr_emplace<health::InMemoryFile>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

uint64_t HDCodableWorkoutConfigurationReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  BOOL v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    std::ios_base::fmtflags v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          char v18 = 0;
          unsigned int v19 = 0;
          uint64_t v20 = 0;
          *(unsigned char *)(a1 + 48) |= 1u;
          while (1)
          {
            uint64_t v21 = *v3;
            uint64_t v22 = *(void *)(a2 + v21);
            unint64_t v23 = v22 + 1;
            if (v22 == -1 || v23 > *(void *)(a2 + *v4)) {
              break;
            }
            char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
            *(void *)(a2 + v21) = v23;
            v20 |= (unint64_t)(v24 & 0x7F) << v18;
            if ((v24 & 0x80) == 0) {
              goto LABEL_47;
            }
            v18 += 7;
            BOOL v15 = v19++ >= 9;
            if (v15)
            {
              uint64_t v20 = 0;
              goto LABEL_49;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_47:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v20 = 0;
          }
LABEL_49:
          uint64_t v43 = 8;
          goto LABEL_58;
        case 2u:
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v20 = 0;
          *(unsigned char *)(a1 + 48) |= 2u;
          while (2)
          {
            uint64_t v28 = *v3;
            uint64_t v29 = *(void *)(a2 + v28);
            unint64_t v30 = v29 + 1;
            if (v29 == -1 || v30 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v31 = *(unsigned char *)(*(void *)(a2 + *v7) + v29);
              *(void *)(a2 + v28) = v30;
              v20 |= (unint64_t)(v31 & 0x7F) << v26;
              if (v31 < 0)
              {
                v26 += 7;
                BOOL v15 = v27++ >= 9;
                if (v15)
                {
                  uint64_t v20 = 0;
                  goto LABEL_53;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v20 = 0;
          }
LABEL_53:
          uint64_t v43 = 16;
          goto LABEL_58;
        case 3u:
          char v32 = 0;
          unsigned int v33 = 0;
          uint64_t v20 = 0;
          *(unsigned char *)(a1 + 48) |= 8u;
          break;
        case 4u:
          *(unsigned char *)(a1 + 48) |= 4u;
          uint64_t v38 = *v3;
          unint64_t v39 = *(void *)(a2 + v38);
          if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v40 = *(void *)(*(void *)(a2 + *v7) + v39);
            *(void *)(a2 + v38) = v39 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v40 = 0;
          }
          *(void *)(a1 + 24) = v40;
          continue;
        case 5u:
          uint64_t v41 = PBReaderReadString();
          int v42 = *(void **)(a1 + 40);
          *(void *)(a1 + 40) = v41;

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v34 = *v3;
        uint64_t v35 = *(void *)(a2 + v34);
        unint64_t v36 = v35 + 1;
        if (v35 == -1 || v36 > *(void *)(a2 + *v4)) {
          break;
        }
        char v37 = *(unsigned char *)(*(void *)(a2 + *v7) + v35);
        *(void *)(a2 + v34) = v36;
        v20 |= (unint64_t)(v37 & 0x7F) << v32;
        if ((v37 & 0x80) == 0) {
          goto LABEL_55;
        }
        v32 += 7;
        BOOL v15 = v33++ >= 9;
        if (v15)
        {
          uint64_t v20 = 0;
          goto LABEL_57;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_55:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v20 = 0;
      }
LABEL_57:
      uint64_t v43 = 32;
LABEL_58:
      *(void *)(a1 + v43) = v20;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableRoutineLocationRequestReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  BOOL v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    std::ios_base::fmtflags v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        char v17 = 0;
        unsigned int v18 = 0;
        uint64_t v19 = 0;
        *(unsigned char *)(a1 + 12) |= 1u;
        while (1)
        {
          uint64_t v20 = *v3;
          unint64_t v21 = *(void *)(a2 + v20);
          if (v21 == -1 || v21 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v22 = *(unsigned char *)(*(void *)(a2 + *v7) + v21);
          *(void *)(a2 + v20) = v21 + 1;
          v19 |= (unint64_t)(v22 & 0x7F) << v17;
          if ((v22 & 0x80) == 0) {
            goto LABEL_29;
          }
          v17 += 7;
          BOOL v14 = v18++ >= 9;
          if (v14)
          {
            LODWORD(v19) = 0;
            goto LABEL_31;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_29:
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v19) = 0;
        }
LABEL_31:
        *(_DWORD *)(a1 + 8) = v19;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD1B1690(_Unwind_Exception *a1)
{
  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v4 - 88));
  _Unwind_Resume(a1);
}

void sub_1BD1B2B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BD1B7AF0(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 72));
  _Unwind_Resume(a1);
}

uint64_t statistics::Interval::Interval(uint64_t this)
{
  *(void *)this = &unk_1F1727540;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

{
  *(void *)this = &unk_1F1727540;
  *(_DWORD *)(this + 24) = 0;
  return this;
}

void statistics::Interval::~Interval(statistics::Interval *this)
{
  PB::Base::~Base(this);

  JUMPOUT(0x1C187B8A0);
}

double statistics::Interval::Interval(statistics::Interval *this, const statistics::Interval *a2)
{
  *(void *)this = &unk_1F1727540;
  *((_DWORD *)this + 6) = 0;
  if ((*((unsigned char *)a2 + 24) & 2) != 0)
  {
    double result = *((double *)a2 + 2);
    *((unsigned char *)this + 24) = 2;
    *((double *)this + 2) = result;
    char v2 = 3;
    if ((*((unsigned char *)a2 + 24) & 1) == 0) {
      return result;
    }
    goto LABEL_5;
  }
  char v2 = 1;
  if (*((unsigned char *)a2 + 24))
  {
LABEL_5:
    double result = *((double *)a2 + 1);
    *((unsigned char *)this + 24) = v2;
    *((double *)this + 1) = result;
  }
  return result;
}

uint64_t statistics::Interval::operator=(uint64_t a1, const statistics::Interval *a2)
{
  if ((const statistics::Interval *)a1 != a2)
  {
    statistics::Interval::Interval((statistics::Interval *)&v6, a2);
    int v3 = *(_DWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 24) = v8;
    int v8 = v3;
    long long v4 = *(_OWORD *)(a1 + 8);
    *(_OWORD *)(a1 + 8) = v7;
    long long v7 = v4;
    PB::Base::~Base((PB::Base *)&v6);
  }
  return a1;
}

double statistics::swap(statistics *this, statistics::Interval *a2, statistics::Interval *a3)
{
  int v3 = *((_DWORD *)this + 6);
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  *((_DWORD *)a2 + 6) = v3;
  uint64_t v4 = *((void *)this + 2);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((void *)a2 + 2) = v4;
  double result = *((double *)this + 1);
  *((void *)this + 1) = *((void *)a2 + 1);
  *((double *)a2 + 1) = result;
  return result;
}

double statistics::Interval::Interval(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F1727540;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 8) = result;
  return result;
}

{
  double result;

  *(void *)a1 = &unk_1F1727540;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  double result = *(double *)(a2 + 8);
  *(double *)(a1 + 8) = result;
  return result;
}

uint64_t statistics::Interval::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    long long v7 = &unk_1F1727540;
    int v3 = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a2 + 24) = 0;
    int v9 = *(_DWORD *)(a1 + 24);
    long long v4 = *(_OWORD *)(a1 + 8);
    long long v5 = *(_OWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 24) = v3;
    *(_OWORD *)(a1 + 8) = v5;
    long long v8 = v4;
    PB::Base::~Base((PB::Base *)&v7);
  }
  return a1;
}

uint64_t statistics::Interval::formatText(statistics::Interval *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  char v5 = *((unsigned char *)this + 24);
  if (v5)
  {
    PB::TextFormatter::format(a2, "end", *((double *)this + 1));
    char v5 = *((unsigned char *)this + 24);
  }
  if ((v5 & 2) != 0) {
    PB::TextFormatter::format(a2, "start", *((double *)this + 2));
  }

  return MEMORY[0x1F4147498](a2);
}

uint64_t statistics::Interval::readFrom(statistics::Interval *this, PB::Reader *a2)
{
  unint64_t v2 = *((void *)a2 + 1);
  unint64_t v3 = *((void *)a2 + 2);
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 < v3 && v4 == 0)
  {
    do
    {
      uint64_t v8 = *(void *)a2;
      if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
      {
        char v15 = 0;
        unsigned int v16 = 0;
        unint64_t v11 = 0;
        if (v2 > v3) {
          unint64_t v3 = v2;
        }
        while (v3 != v2)
        {
          unint64_t v17 = v2 + 1;
          char v18 = *(unsigned char *)(v8 + v2);
          *((void *)a2 + 1) = v17;
          v11 |= (unint64_t)(v18 & 0x7F) << v15;
          if ((v18 & 0x80) == 0) {
            goto LABEL_20;
          }
          v15 += 7;
          unint64_t v2 = v17;
          BOOL v14 = v16++ > 8;
          if (v14) {
            goto LABEL_26;
          }
        }
        int v4 = 1;
        *((unsigned char *)a2 + 24) = 1;
        return v4 == 0;
      }
      char v9 = 0;
      unsigned int v10 = 0;
      unint64_t v11 = 0;
      while (1)
      {
        unint64_t v12 = v2 + 1;
        *((void *)a2 + 1) = v2 + 1;
        char v13 = *(unsigned char *)(v8 + v2);
        v11 |= (unint64_t)(v13 & 0x7F) << v9;
        if ((v13 & 0x80) == 0) {
          break;
        }
        v9 += 7;
        unint64_t v2 = v12;
        BOOL v14 = v10++ > 8;
        if (v14) {
          goto LABEL_26;
        }
      }
LABEL_20:
      if ((v11 & 7) == 4)
      {
        int v4 = 0;
        return v4 == 0;
      }
      if ((v11 >> 3) == 2)
      {
        *((unsigned char *)this + 24) |= 1u;
        unint64_t v2 = *((void *)a2 + 1);
        if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > *((void *)a2 + 2)) {
          goto LABEL_30;
        }
        *((void *)this + 1) = *(void *)(*(void *)a2 + v2);
      }
      else
      {
        if ((v11 >> 3) != 1)
        {
LABEL_26:
          uint64_t result = PB::Reader::skip(a2);
          if (!result) {
            return result;
          }
          unint64_t v2 = *((void *)a2 + 1);
          goto LABEL_33;
        }
        *((unsigned char *)this + 24) |= 2u;
        unint64_t v2 = *((void *)a2 + 1);
        if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > *((void *)a2 + 2))
        {
LABEL_30:
          *((unsigned char *)a2 + 24) = 1;
          goto LABEL_33;
        }
        *((void *)this + 2) = *(void *)(*(void *)a2 + v2);
      }
      unint64_t v2 = *((void *)a2 + 1) + 8;
      *((void *)a2 + 1) = v2;
LABEL_33:
      unint64_t v3 = *((void *)a2 + 2);
      int v4 = *((unsigned __int8 *)a2 + 24);
    }
    while (v2 < v3 && !*((unsigned char *)a2 + 24));
  }
  return v4 == 0;
}

uint64_t statistics::Interval::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  char v4 = *(unsigned char *)(this + 24);
  if ((v4 & 2) != 0)
  {
    this = PB::Writer::write(a2, *(double *)(this + 16));
    char v4 = *(unsigned char *)(v3 + 24);
  }
  if (v4)
  {
    double v5 = *(double *)(v3 + 8);
    return PB::Writer::write(a2, v5);
  }
  return this;
}

BOOL statistics::Interval::operator==(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a1 + 24) & 2) != 0)
  {
    if ((*(unsigned char *)(a2 + 24) & 2) == 0 || *(double *)(a1 + 16) != *(double *)(a2 + 16)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a2 + 24) & 2) != 0)
  {
    return 0;
  }
  BOOL v2 = (*(unsigned char *)(a2 + 24) & 1) == 0;
  if (*(unsigned char *)(a1 + 24)) {
    return (*(unsigned char *)(a2 + 24) & 1) != 0 && *(double *)(a1 + 8) == *(double *)(a2 + 8);
  }
  return v2;
}

uint64_t statistics::Interval::hash_value(statistics::Interval *this)
{
  if ((*((unsigned char *)this + 24) & 2) != 0)
  {
    double v1 = *((double *)this + 2);
    if (v1 == 0.0) {
      double v1 = 0.0;
    }
    if (*((unsigned char *)this + 24)) {
      goto LABEL_3;
    }
LABEL_9:
    double v2 = 0.0;
    return *(void *)&v2 ^ *(void *)&v1;
  }
  double v1 = 0.0;
  if ((*((unsigned char *)this + 24) & 1) == 0) {
    goto LABEL_9;
  }
LABEL_3:
  double v2 = *((double *)this + 1);
  if (v2 == 0.0) {
    double v2 = 0.0;
  }
  return *(void *)&v2 ^ *(void *)&v1;
}

void sub_1BD1BECD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  _Block_object_dispose((const void *)(v40 - 176), 8);
  _Block_object_dispose(&a40, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__167(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__167(uint64_t a1)
{
}

void sub_1BD1BFAE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__168(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__168(uint64_t a1)
{
}

void sub_1BD1BFE40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1C0054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1C03D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1C075C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1C0B50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1C1224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1C15E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1C2C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1C3630(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::DataStore(uint64_t a1, long long *a2)
{
  v3[0] = 0;
  v3[1] = 0;
  return health::DataStore::DataStore(a1, a2, v3, 0);
}

{
  void v3[2];

  v3[0] = 0;
  v3[1] = 0;
  return health::DataStore::DataStore(a1, a2, v3, 0);
}

uint64_t health::DataStore::DataStore(uint64_t a1, long long *a2, void *a3, int a4)
{
  void v9[4] = *MEMORY[0x1E4F143B8];
  double v5 = (std::__shared_weak_count *)a3[1];
  v7[0] = *a3;
  v7[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  health::BlockAccessFile::BlockAccessFile(a1, a2, v7, a4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  *(_OWORD *)(a1 + 864) = 0u;
  v9[0] = &unk_1F17275F0;
  v9[1] = a1;
  v9[3] = v9;
  health::BlockAccessFile::performReadTransactionWithLambda(a1, (uint64_t)v9);
  std::__function::__value_func<void ()(health::BlockAccessFile::ReadTransaction const&)>::~__value_func[abi:ne180100](v9);
  if (!*(void *)(a1 + 864))
  {
    v8[0] = &unk_1F1727670;
    v8[1] = a1;
    v8[3] = v8;
    health::BlockAccessFile::performWriteTransactionWithLambda(a1, (uint64_t)v8);
    std::__function::__value_func<BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__value_func[abi:ne180100](v8);
  }
  return a1;
}

void sub_1BD1C4098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__value_func[abi:ne180100](va);
  health::TransactionalFile::~TransactionalFile(v4);
  _Unwind_Resume(a1);
}

void *health::DataStore::performReadTransactionWithLambda(uint64_t a1, uint64_t a2)
{
  v3[4] = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1F1727700;
  v3[1] = a1;
  void v3[2] = a2;
  v3[3] = v3;
  health::BlockAccessFile::performReadTransactionWithLambda(a1, (uint64_t)v3);
  return std::__function::__value_func<void ()(health::BlockAccessFile::ReadTransaction const&)>::~__value_func[abi:ne180100](v3);
}

void sub_1BD1C4198(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(health::BlockAccessFile::ReadTransaction const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t health::DataStore::checkIntegrity(uint64_t a1, uint64_t a2)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  v6[0] = &unk_1F1727800;
  v6[1] = a2;
  v6[3] = v6;
  health::BlockAccessFile::checkIntegrity(a1, (uint64_t)v6);
  std::__function::__value_func<BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::~__value_func[abi:ne180100](v6);
  v5[0] = &unk_1F1727890;
  v5[1] = a1;
  v5[2] = a2;
  v5[3] = v5;
  health::BlockAccessFile::performReadTransactionWithLambda(a1, (uint64_t)v5);
  std::__function::__value_func<void ()(health::BlockAccessFile::ReadTransaction const&)>::~__value_func[abi:ne180100](v5);
  return 1;
}

void sub_1BD1C427C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  std::__function::__value_func<void ()(health::BlockAccessFile::ReadTransaction const&)>::~__value_func[abi:ne180100](&a17);
  if (a2 == 1)
  {
    uint64_t v24 = *(void *)__cxa_begin_catch(a1);
    a10 = *(void *)(*(void *)(v24 - 8) + 8) & 0x7FFFFFFFFFFFFFFFLL;
    a9 = (*(uint64_t (**)(void))(v24 + 16))();
    health::FormatString<char const*,char const*>((std::string *)&__p, (const char **)&a10, (const char **)&a9);
    uint64_t v25 = *(void *)(v21 + 24);
    if (v25)
    {
      (*(void (**)(uint64_t, void **))(*(void *)v25 + 48))(v25, &__p);
      if (a16 < 0) {
        operator delete(__p);
      }
      __cxa_end_catch();
      JUMPOUT(0x1BD1C424CLL);
    }
    std::__throw_bad_function_call[abi:ne180100]();
  }
  _Unwind_Resume(a1);
}

void health::FormatString<char const*,char const*>(std::string *a1, const char **a2, const char **a3)
{
  v3[0] = a3;
  v3[1] = a2;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<char const*,char const*>((std::string *)"Integrity checking failed due to caught exception: {0} {1}", a1, 0, v3);
}

void sub_1BD1C43FC(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void *health::DataStore::rebuildIndex(health::DataStore *this)
{
  v2[4] = *MEMORY[0x1E4F143B8];
  v2[0] = &unk_1F1727910;
  v2[1] = this;
  v2[3] = v2;
  health::BlockAccessFile::performWriteTransactionWithLambda((uint64_t)this, (uint64_t)v2);
  return std::__function::__value_func<BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__value_func[abi:ne180100](v2);
}

void sub_1BD1C449C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *health::DataStore::enumerateObjectTreeForInspecting(uint64_t a1, uint64_t a2)
{
  v3[4] = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1F1727A20;
  v3[1] = a1;
  void v3[2] = a2;
  v3[3] = v3;
  health::BlockAccessFile::performReadTransactionWithLambda(a1, (uint64_t)v3);
  return std::__function::__value_func<void ()(health::BlockAccessFile::ReadTransaction const&)>::~__value_func[abi:ne180100](v3);
}

void sub_1BD1C4534(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(health::BlockAccessFile::ReadTransaction const&)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void health::DataStore::checkIntegrityForInspecting(uint64_t a1, uint64_t a2)
{
  v26[4] = *MEMORY[0x1E4F143B8];
  if (*(char *)(a1 + 327) < 0) {
    std::string::__init_copy_ctor_external(&v22, *(const std::string::value_type **)(a1 + 304), *(void *)(a1 + 312));
  }
  else {
    std::string v22 = *(std::string *)(a1 + 304);
  }
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = HIBYTE(v22.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = v22.__r_.__value_.__l.__size_;
  }
  double v5 = v20;
  std::string::basic_string[abi:ne180100]((uint64_t)v20, size + 4);
  if (v21 < 0) {
    double v5 = (void **)v20[0];
  }
  if (size)
  {
    if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v6 = &v22;
    }
    else {
      uint64_t v6 = (std::string *)v22.__r_.__value_.__r.__words[0];
    }
    memmove(v5, v6, size);
  }
  strcpy((char *)v5 + size, "-wal");
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v7 = &v22;
  }
  else {
    long long v7 = (std::string *)v22.__r_.__value_.__r.__words[0];
  }
  int v8 = stat((const char *)v7, &v19);
  st_size_t size = v19.st_size;
  if (v21 >= 0) {
    unsigned int v10 = (const char *)v20;
  }
  else {
    unsigned int v10 = (const char *)v20[0];
  }
  int v11 = stat(v10, &v17);
  if (v8) {
    uint64_t v12 = -1;
  }
  else {
    uint64_t v12 = st_size;
  }
  off_t v13 = v17.st_size;
  if (v11) {
    off_t v13 = 0;
  }
  uint64_t v14 = v13 + v12;
  uint64_t v18 = v14;
  if (v14 < 0)
  {
    v23[0] = (uint64_t)__error();
    v23[1] = (uint64_t)&v22;
    memset(&__p, 0, sizeof(__p));
    health::FormatImplementation<std::string &,int &>((std::string *)"HFD file [{0}] size cannot be determined (error {1}).", &__p, 0, v23);
    std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::operator()(*(void *)(a2 + 24), 0, 0, 0, (uint64_t)&__p);
  }
  else
  {
    if (v14) {
      goto LABEL_31;
    }
    health::FormatString<std::string &>(&__p, (std::string *)"HFD file [{0}] is empty.", (uint64_t)&v22);
    std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::operator()(*(void *)(a2 + 24), 0, 0, 0, (uint64_t)&__p);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
LABEL_31:
  v26[0] = &unk_1F1727AA0;
  v26[1] = a2;
  v26[3] = v26;
  health::BlockAccessFile::checkIntegrity(a1, (uint64_t)v26);
  std::__function::__value_func<BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::~__value_func[abi:ne180100](v26);
  uint64_t v25 = 0;
  char v15 = operator new(0x20uLL);
  *char v15 = &unk_1F1727B20;
  v15[1] = a1;
  v15[2] = &v18;
  v15[3] = a2;
  uint64_t v25 = v15;
  health::BlockAccessFile::performWriteTransactionWithLambda(a1, (uint64_t)v24);
  std::__function::__value_func<BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__value_func[abi:ne180100](v24);
  if (v21 < 0) {
    operator delete(v20[0]);
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v22.__r_.__value_.__l.__data_);
  }
}

void sub_1BD1C47D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v15 - 161) < 0) {
    operator delete(*(void **)(v15 - 184));
  }
  if (*(char *)(v15 - 137) < 0) {
    operator delete(*(void **)(v15 - 160));
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::operator()(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v7[0] = a3;
  v7[1] = a4;
  int v6 = a2;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, int *, void *, uint64_t))(*(void *)a1 + 48))(a1, &v6, v7, a5);
}

void health::FormatString<std::string &>(std::string *a1, std::string *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<std::string &>(a2, a1, 0, &v3);
}

void sub_1BD1C4900(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::DataStore::_checkBlockIntegrity(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7)
{
  uint64_t v16 = a3;
  uint64_t v17 = a4;
  if (a4 + a3 > a6)
  {
    health::FormatString<std::string &>(&__p, (std::string *)"HFD block [{0}] is not strictly within file bounds.", a5);
    std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::operator()(*(void *)(a7 + 24), 2, a3, a4, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  if (health::BlockAccessFile::isBlockUsingFreeSpace(a1, (uint64_t)&v16, a2))
  {
    uint64_t v13 = v16;
    uint64_t v14 = v17;
    health::FormatString<std::string &>(&__p, (std::string *)"HFD block [{0}] is using space that is marked free.", a5);
    std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::operator()(*(void *)(a7 + 24), 3, v13, v14, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1BD1C4A08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *health::DataStore::ReadTransaction::ReadTransaction(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = a4;
  result[3] = a4;
  result[4] = a2;
  result[5] = a3;
  return result;
}

{
  *uint64_t result = 0;
  result[1] = 0;
  result[2] = a4;
  result[3] = a4;
  result[4] = a2;
  result[5] = a3;
  return result;
}

void health::DataStore::ReadTransaction::_pointerForObject(health::DataStore::ReadTransaction *this@<X0>, ObjectIdentifier *a2@<X1>, uint64_t a3@<X8>)
{
  long long v6 = *((_OWORD *)this + 2);
  long long v7 = this;
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v6, a2, 0, v4);
  if (v5)
  {
    *(_OWORD *)a3 = *(_OWORD *)(health::Optional<health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v4)
                              + 16);
    *(unsigned char *)(a3 + 16) = 1;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(unsigned char *)(a3 + 16) = 0;
  }
}

BOOL health::DataStore::ReadTransaction::retrieveBytesWithIdentifier(uint64_t **this, health::RawBuffer *a2, ObjectIdentifier *a3)
{
  health::DataStore::ReadTransaction::_pointerForObject((health::DataStore::ReadTransaction *)this, a3, (uint64_t)v12);
  int v5 = v13;
  if (v13)
  {
    long long v6 = this[3];
    long long v7 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)v12);
    uint64_t v8 = *v7;
    uint64_t v9 = v7[1];
    health::RawBuffer::RawBuffer(v11, *(unsigned __int8 **)a2, *((void *)a2 + 1));
    health::BlockAccessFile::ReadTransaction::retrieveBlock(v6, v8, v9, (uint64_t)v11);
  }
  return v5 != 0;
}

uint64_t health::DataStore::ReadTransaction::objectExistsForIdentifier(health::DataStore::ReadTransaction *this, ObjectIdentifier *a2)
{
  long long v5 = *((_OWORD *)this + 2);
  long long v6 = this;
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v5, a2, 0, &v3);
  return v4;
}

void *health::DataStore::ReadTransaction::enumerateIdentifiersForObjectType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 40);
  v9[0] = *(void *)(a1 + 32);
  v9[1] = v4;
  v9[2] = a1;
  v8[0] = a2;
  v8[1] = 0;
  v7[0] = a2;
  v7[1] = -1;
  uint64_t v6 = a3;
  bzero(v10, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(a1 + 16), v9[0], v4, (uint64_t)v10);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateValuesInRange<health::DataStore::ReadTransaction::enumerateIdentifiersForObjectType(long long,std::function<void ()(health::DataStore::ObjectIdentifier)>)::$_0>(v9, 0, (uint64_t)v10, (uint64_t)&v6, v8, v7);
}

uint64_t health::DataStore::WriteTransaction::WriteTransaction(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = a3;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = a4;
  *(void *)(a1 + 72) = a4;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)a4;
  long long v5 = *(_OWORD *)(a4 + 16);
  long long v6 = *(_OWORD *)(a4 + 32);
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a4 + 48);
  *(_OWORD *)(a1 + 96) = v5;
  *(_OWORD *)(a1 + 112) = v6;
  std::deque<health::BlockPointer>::deque((char **)(a1 + 136), (void *)(a4 + 56));
  return a1;
}

{
  long long v5;
  long long v6;

  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a4;
  *(void *)(a1 + 24) = a4;
  *(void *)(a1 + 32) = a2;
  *(void *)(a1 + 40) = a3;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = a4;
  *(void *)(a1 + 72) = a4;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)a4;
  long long v5 = *(_OWORD *)(a4 + 16);
  long long v6 = *(_OWORD *)(a4 + 32);
  *(unsigned char *)(a1 + 128) = *(unsigned char *)(a4 + 48);
  *(_OWORD *)(a1 + 96) = v5;
  *(_OWORD *)(a1 + 112) = v6;
  std::deque<health::BlockPointer>::deque((char **)(a1 + 136), (void *)(a4 + 56));
  return a1;
}

uint64_t health::DataStore::WriteTransaction::storeBytesWithIdentifier(health::DataStore::WriteTransaction *this, const void *a2, unint64_t a3, __n128 *a4)
{
  uint64_t v18 = a2;
  unint64_t v19 = a3;
  long long v23 = *((_OWORD *)this + 2);
  uint64_t v24 = (char *)this + 48;
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v23, a4, 0, v21);
  if (v22)
  {
    uint64_t v7 = *(void *)(health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v21)
                   + 24);
    uint64_t v8 = (health::DataStore::WriteTransaction *)((char *)this + 80);
    uint64_t v9 = health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v21);
    unint64_t v10 = *(void *)(v9 + 16);
    unint64_t v11 = *(void *)(v9 + 24);
    if (v7 == v19) {
      return health::BlockAccessFile::WriteTransaction::updateObject<health::ByteRange<void const,unsigned long long>>((uint64_t)v8, v10, v11, (uint64_t)&v18);
    }
    health::BlockAccessFile::WriteTransaction::freeBlock((uint64_t)v8, v10, v11);
    unint64_t v14 = v19;
    unsigned __int8 v13 = v8;
  }
  else
  {
    uint64_t v8 = (health::DataStore::WriteTransaction *)((char *)this + 80);
    unsigned __int8 v13 = v8;
    unint64_t v14 = a3;
  }
  unint64_t v15 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v13, v14);
  unint64_t v17 = v16;
  health::BlockAccessFile::WriteTransaction::updateObject<health::ByteRange<void const,unsigned long long>>((uint64_t)v8, v15, v16, (uint64_t)&v18);
  v20.n128_u64[0] = v15;
  v20.n128_u64[1] = v17;
  return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v23, a4, &v20);
}

void health::DataStore::WriteTransaction::removeObjectWithIdentifier(health::DataStore::WriteTransaction *this, ObjectIdentifier *a2)
{
  long long v7 = *((_OWORD *)this + 2);
  uint64_t v8 = (char *)this + 48;
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v7, a2, 0, v5);
  if (v6)
  {
    uint64_t v4 = health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v5);
    health::BlockAccessFile::WriteTransaction::freeBlock((uint64_t)this + 80, *(void *)(v4 + 16), *(void *)(v4 + 24));
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::removeValueForKey((uint64_t *)&v7, a2);
  }
}

BOOL health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::removeValueForKey(uint64_t *a1, void *a2)
{
  uint64_t v4 = a1[2];
  bzero(v6, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v4 + 24), *a1, a1[1], (uint64_t)v6);
  return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_removeValueForKey((uint64_t)a1, 0, a2, a1, (uint64_t)v6) != 2;
}

BOOL health::DataStore::WriteTransaction::renameObjectWithIdentifier(health::DataStore::WriteTransaction *this, ObjectIdentifier *a2, __n128 *a3)
{
  long long v14 = *((_OWORD *)this + 2);
  unint64_t v15 = (char *)this + 48;
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v14, a2, 0, v12);
  if (!v13)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::out_of_range::out_of_range[abi:ne180100](exception, "Existing object not found when attempting to rename.");
    uint64_t v8 = (struct type_info *)off_1E62F22B8;
    uint64_t v9 = (void (*)(void *))MEMORY[0x1E4FBA1D0];
    goto LABEL_6;
  }
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v14, a3, 0, &v10);
  if (v11)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to rename an object would result in a collision.");
    uint64_t v8 = (struct type_info *)MEMORY[0x1E4FBA328];
    uint64_t v9 = (void (*)(void *))MEMORY[0x1E4FBA1B0];
LABEL_6:
    __cxa_throw(exception, v8, v9);
  }
  long long v5 = (__n128 *)health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v12);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v14, a3, v5 + 1);
  return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::removeValueForKey((uint64_t *)&v14, a2);
}

void sub_1BD1C4F98(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *health::operator<<(void *a1)
{
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)"{", 1);
  uint64_t v1 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v1, (uint64_t)", ", 2);
  double v2 = (void *)std::ostream::operator<<();

  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v2, (uint64_t)"}", 1);
}

void std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::~__func()
{
}

void *std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F17275F0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F17275F0;
  a2[1] = v2;
  return result;
}

double std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v4 = 0x348424146;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  int v5 = 68;
  uint64_t v6 = 68;
  health::TransactionalFile::ReadTransaction::readObjectAtOffset<health::BlockAccessFile::BlockAccessFileHeader>(*a2, (uint64_t)&v4, 0);
  double result = *(double *)&v8;
  *(_OWORD *)(v2 + 864) = v8;
  return result;
}

uint64_t std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::target_type()
{
}

void std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__func()
{
}

void *std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1F1727670;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F1727670;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  bzero(v8, 0x223uLL);
  uint64_t v4 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength((health::BlockAccessFile::WriteTransaction *)a2, 547);
  uint64_t v6 = v5;
  health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(a2, v4, v5, (uint64_t)v8);
  *(void *)(v3 + 864) = v4;
  *(void *)(v3 + 872) = v6;
  *(_OWORD *)(*(void *)(a2 + 24) + 40) = *(_OWORD *)(v3 + 864);
  health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockAccessFileHeader &>(*(health::TransactionalFile::WriteTransaction **)(a2 + 16), *(void *)(a2 + 24), 0);
  return 1;
}

uint64_t std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1,std::allocator<health::DataStore::DataStore(std::string const&,std::shared_ptr<health::VirtualFilesystem>,health::TransactionalFile::OpenMethod)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::target_type()
{
}

void *std::__function::__value_func<BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0,std::allocator<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::~__func()
{
}

__n128 std::__function::__func<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0,std::allocator<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F1727700;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0,std::allocator<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F1727700;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0,std::allocator<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = 0;
  _OWORD v5[2] = a2;
  v5[3] = a2;
  uint64_t v2 = *(void *)(a1 + 16);
  long long v6 = *(_OWORD *)(*(void *)(a1 + 8) + 864);
  uint64_t v3 = *(void *)(v2 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)v3 + 48))(v3, v5);
}

uint64_t std::__function::__func<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0,std::allocator<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0,std::allocator<health::DataStore::performReadTransactionWithLambda(std::function<void ()(health::DataStore::ReadTransaction const&)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::target_type()
{
}

void std::__function::__func<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0,std::allocator<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__func()
{
}

__n128 std::__function::__func<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0,std::allocator<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F1727780;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0,std::allocator<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F1727780;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0,std::allocator<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::operator()(uint64_t a1, long long *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  v8[0] = 0;
  v8[1] = 0;
  void v8[2] = a2;
  v8[3] = a2;
  long long v9 = *(_OWORD *)(v3 + 864);
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = a2;
  char v13 = a2;
  long long v4 = a2[1];
  long long v14 = *a2;
  long long v15 = v4;
  long long v16 = a2[2];
  char v17 = *((unsigned char *)a2 + 48);
  std::deque<health::BlockPointer>::deque(v18, (void *)a2 + 7);
  uint64_t v5 = *(void *)(*(void *)(a1 + 16) + 24);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v5 + 48))(v5, v8);
  std::deque<health::BlockPointer>::~deque[abi:ne180100](v18);
  return v6;
}

void sub_1BD1C55E4(_Unwind_Exception *a1)
{
  std::deque<health::BlockPointer>::~deque[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0,std::allocator<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0,std::allocator<health::DataStore::performWriteTransactionWithLambda(std::function<BOOL ()(health::DataStore::WriteTransaction &)>)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::target_type()
{
}

void std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::~__func()
{
}

void *std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F1727800;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F1727800;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::operator()(uint64_t a1, int *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  int v7 = *a2;
  uint64_t v8 = *a3;
  uint64_t v19 = *a4;
  uint64_t v20 = v8;
  std::string::basic_string[abi:ne180100]<0>(&v16, "Unknown");
  if (v7 == 1)
  {
    if ((v18[2] & 0x80000000) != 0)
    {
      uint64_t v17 = 21;
      uint64_t v11 = v16;
      long long v9 = (char *)v16 + 21;
    }
    else
    {
      long long v9 = v18;
      void v18[2] = 21;
      uint64_t v11 = &v16;
    }
    qmemcpy(v11, "Free Space Corruption", 21);
  }
  else
  {
    if (v7) {
      goto LABEL_12;
    }
    if ((v18[2] & 0x80000000) != 0)
    {
      uint64_t v17 = 14;
      uint64_t v10 = v16;
      long long v9 = (char *)v16 + 14;
    }
    else
    {
      long long v9 = (char *)&v17 + 6;
      void v18[2] = 14;
      uint64_t v10 = &v16;
    }
    qmemcpy(v10, "Corrupt Header", 14);
  }
  *long long v9 = 0;
LABEL_12:
  uint64_t v12 = *(void *)(a1 + 8);
  v21[0] = a5;
  v21[1] = (uint64_t)&v19;
  _OWORD v21[2] = (uint64_t)&v20;
  v21[3] = (uint64_t)&v16;
  memset(&__p, 0, sizeof(__p));
  health::FormatImplementation<std::string &,long long &,unsigned long &,std::string const&>((std::string *)"{0}: [{1}, {2}] {3}", &__p, 0, v21);
  uint64_t v13 = *(void *)(v12 + 24);
  if (!v13) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, std::string *))(*(void *)v13 + 48))(v13, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if ((v18[2] & 0x80000000) != 0) {
    operator delete(v16);
  }
  return 1;
}

void sub_1BD1C5858(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::target_type()
{
}

void health::FormatImplementation<std::string &,long long &,unsigned long &,std::string const&>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    char v31 = i;
    if (*i != 123) {
      break;
    }
    int v11 = i[1];
    if (v11 != 123)
    {
      if (v11 != 42)
      {
        health::FormatOptions::FormatOptions((uint64_t)v27, (const char **)&v31);
        uint64_t v12 = v31;
        switch(v28)
        {
          case 0:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[3], (uint64_t)v27);
            unint64_t v13 = v34;
            if ((v34 & 0x80u) != 0) {
              unint64_t v13 = v33;
            }
            unint64_t v14 = v30;
            if (v30 <= v13) {
              unint64_t v14 = v13;
            }
            if (v29) {
              unint64_t v13 = v14;
            }
            health::FormatImplementation<std::string &,long long &,unsigned long &,std::string const&>(v12, a2, v13 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v15 = (char *)a2;
            }
            else {
              long long v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_50;
          case 1:
            health::TypeFormatter<long long &,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v27);
            unint64_t v18 = v34;
            if ((v34 & 0x80u) != 0) {
              unint64_t v18 = v33;
            }
            unint64_t v19 = v30;
            if (v30 <= v18) {
              unint64_t v19 = v18;
            }
            if (v29) {
              unint64_t v18 = v19;
            }
            health::FormatImplementation<std::string &,long long &,unsigned long &,std::string const&>(v12, a2, v18 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v15 = (char *)a2;
            }
            else {
              long long v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_50;
          case 2:
            health::TypeFormatter<unsigned long &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v27);
            unint64_t v16 = v34;
            if ((v34 & 0x80u) != 0) {
              unint64_t v16 = v33;
            }
            unint64_t v17 = v30;
            if (v30 <= v16) {
              unint64_t v17 = v16;
            }
            if (v29) {
              unint64_t v16 = v17;
            }
            health::FormatImplementation<std::string &,long long &,unsigned long &,std::string const&>(v12, a2, v16 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v15 = (char *)a2;
            }
            else {
              long long v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
            goto LABEL_50;
          case 3:
            health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v27);
            unint64_t v20 = v34;
            if ((v34 & 0x80u) != 0) {
              unint64_t v20 = v33;
            }
            unint64_t v21 = v30;
            if (v30 <= v20) {
              unint64_t v21 = v20;
            }
            if (v29) {
              unint64_t v20 = v21;
            }
            health::FormatImplementation<std::string &,long long &,unsigned long &,std::string const&>(v12, a2, v20 + a3 + v8, a4);
            if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              long long v15 = (char *)a2;
            }
            else {
              long long v15 = (char *)a2->__r_.__value_.__r.__words[0];
            }
LABEL_50:
            health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v27, &v15[a3 + v8], (const void **)&__p);
            if ((char)v34 < 0) {
              operator delete(__p);
            }
            if (v8) {
              health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
            }
            return;
          default:
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
            goto LABEL_62;
        }
      }
      char v31 = i + 2;
      int v22 = i[2];
      if ((v22 - 48) > 9)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
      }
      else
      {
        uint64_t v23 = 0;
        uint64_t v24 = i + 3;
        do
        {
          char v31 = v24;
          uint64_t v23 = (v22 - 48) + 10 * v23;
          int v25 = *v24++;
          int v22 = v25;
        }
        while ((v25 - 58) >= 0xFFFFFFF6);
        char v31 = v24;
        if (*(v24 - 1) == 125) {
          health::FormatterParameters<0ul,std::string &,long long &,unsigned long &,std::string const&>::formatOptionsAtIndex<std::string &,long long &,unsigned long &,std::string const&>(v23);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
      }
LABEL_62:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    char v31 = i + 1;
    char v9 = 1;
    ++i;
LABEL_7:
    ++v8;
  }
  if (*i) {
    goto LABEL_7;
  }
  std::string::resize(a2, a3 + v8, 0);
  if (v8)
  {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BD1C5CD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,long long &,unsigned long &,std::string const&>::formatOptionsAtIndex<std::string &,long long &,unsigned long &,std::string const&>(uint64_t a1)
{
  if (!a1 || a1 == 1 || a1 == 2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  else
  {
    uint64_t v3 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    exception = v3;
    if (a1 == 3) {
      std::runtime_error::runtime_error(v3, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(v3, "Parameter index out of bounds.");
    }
  }
  __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1C5DFC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>@<D0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X3>, uint64_t a5@<X4>, _OWORD *a6@<X8>)
{
  if (*(_WORD *)(a3 + 544))
  {
    signed int v12 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a3, a4);
    uint64_t v13 = (a2 + 1);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKeyInChildAtIndex<health::DataStore::ObjectIdentifier>(a1, v13, a3, v12, a4, a5, (uint64_t)v16);
    if (BYTE8(v17) || *(unsigned __int16 *)(a3 + 544) - 1 <= v12)
    {
      long long v15 = v16[1];
      *a6 = v16[0];
      a6[1] = v15;
      double result = *(double *)&v17;
      a6[2] = v17;
    }
    else
    {
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKeyInChildAtIndex<health::DataStore::ObjectIdentifier>(a1, v13, a3, (unsigned __int16)(v12 + 1), a4, a5, (uint64_t)a6);
    }
  }
  else
  {
    double result = 0.0;
    *(_OWORD *)((char *)a6 + 25) = 0u;
    *a6 = 0u;
    a6[1] = 0u;
  }
  return result;
}

double health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKeyInChildAtIndex<health::DataStore::ObjectIdentifier>@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned int a4@<W3>, void *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  if (*(unsigned __int16 *)(a3 + 544) <= a4)
  {
    std::string::basic_string[abi:ne180100]<0>(v30, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v29, "_valueForKeyInChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v28, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v27);
    health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v30, (uint64_t)v29, (uint64_t)v28, 158, (uint64_t)&v27);
  }
  if (!*(unsigned char *)(a3 + 546))
  {
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(v23, a1, a2, a3, a4);
    health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_valueForKey<health::DataStore::ObjectIdentifier>(a1, a2, v23, a5, a6);
    return *(double *)&v16;
  }
  uint64_t v11 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, a4);
  uint64_t v12 = *(void *)(v11 + 16);
  uint64_t v13 = *(void *)(v11 + 24);
  uint64_t v14 = *(void *)(a1 + 16);
  bzero(v23, 0x222uLL);
  long long v25 = 0u;
  long long v26 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v14 + 16), v12, v13, (uint64_t)v23);
  if (!v24) {
    goto LABEL_19;
  }
  uint64_t v15 = health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::indexForKey((uint64_t)v23, a5);
  if (!HIDWORD(v15))
  {
    unint64_t v18 = (_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v23, (unsigned __int16)v15);
    long long v16 = v18[1];
    *(_OWORD *)a7 = *v18;
    *(_OWORD *)(a7 + 16) = v16;
    *(_DWORD *)(a7 + 32) = 0;
    goto LABEL_18;
  }
  switch(a6)
  {
    case 2:
      if (HIDWORD(v15) != 2) {
        goto LABEL_19;
      }
      unint64_t v20 = (_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v23, (unsigned __int16)v15);
      long long v16 = v20[1];
      *(_OWORD *)a7 = *v20;
      *(_OWORD *)(a7 + 16) = v16;
      *(_DWORD *)(a7 + 32) = 2;
LABEL_18:
      *(unsigned char *)(a7 + 40) = 1;
      return *(double *)&v16;
    case 1:
      if (HIDWORD(v15) == 1)
      {
        unint64_t v19 = (unsigned __int16)v15;
LABEL_17:
        unint64_t v21 = (_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v23, v19);
        long long v16 = v21[1];
        *(_OWORD *)a7 = *v21;
        *(_OWORD *)(a7 + 16) = v16;
        *(_DWORD *)(a7 + 32) = 1;
        goto LABEL_18;
      }
      if ((unsigned __int16)v15 < v24 - 1)
      {
        unint64_t v19 = (unsigned __int16)v15 + 1;
        goto LABEL_17;
      }
LABEL_19:
      *(void *)&long long v16 = 0;
      *(_OWORD *)(a7 + 25) = 0u;
      *(_OWORD *)a7 = 0u;
      *(_OWORD *)(a7 + 16) = 0u;
      return *(double *)&v16;
    case 0:
      goto LABEL_19;
  }
  return *(double *)&v16;
}

void sub_1BD1C611C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 137) < 0) {
    operator delete(*(void **)(v1 - 160));
  }
  if (*(char *)(v1 - 113) < 0) {
    operator delete(*(void **)(v1 - 136));
  }
  if (*(char *)(v1 - 89) < 0) {
    operator delete(*(void **)(v1 - 112));
  }
  if (*(char *)(v1 - 65) < 0) {
    operator delete(*(void **)(v1 - 88));
  }
  _Unwind_Resume(exception_object);
}

void health::_HDAssertImplementation<health::btree_access_error>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  *(_OWORD *)char v37 = 0u;
  long long v38 = 0u;
  int v9 = backtrace(v37, 20);
  uint64_t v10 = backtrace_symbols(v37, v9);
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v35);
  uint64_t v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v35, (uint64_t)"Critical Error: ", 16);
  int v12 = *(char *)(a5 + 23);
  if (v12 >= 0) {
    uint64_t v13 = a5;
  }
  else {
    uint64_t v13 = *(void *)a5;
  }
  if (v12 >= 0) {
    uint64_t v14 = *(unsigned __int8 *)(a5 + 23);
  }
  else {
    uint64_t v14 = *(void *)(a5 + 8);
  }
  uint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, v13, v14);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"\n", 1);
  long long v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v35, (uint64_t)"Failed assertion '", 18);
  int v17 = *(char *)(a1 + 23);
  if (v17 >= 0) {
    uint64_t v18 = a1;
  }
  else {
    uint64_t v18 = *(void *)a1;
  }
  if (v17 >= 0) {
    uint64_t v19 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    uint64_t v19 = *(void *)(a1 + 8);
  }
  unint64_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, v18, v19);
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"' in '", 6);
  int v22 = *(char *)(a2 + 23);
  if (v22 >= 0) {
    uint64_t v23 = a2;
  }
  else {
    uint64_t v23 = *(void *)a2;
  }
  if (v22 >= 0) {
    uint64_t v24 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v24 = *(void *)(a2 + 8);
  }
  long long v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, v23, v24);
  long long v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"' at ", 5);
  int v27 = *(char *)(a3 + 23);
  if (v27 >= 0) {
    uint64_t v28 = a3;
  }
  else {
    uint64_t v28 = *(void *)a3;
  }
  if (v27 >= 0) {
    uint64_t v29 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v29 = *(void *)(a3 + 8);
  }
  unint64_t v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, v28, v29);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)":", 1);
  char v31 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)"\n", 1);
  if (!v9)
  {
    free(v10);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v36, &v34);
    std::runtime_error::runtime_error(exception, &v34);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F171BDC0;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, *v10);
  health::HDDemangleBacktraceLine();
}

void sub_1BD1C63FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  a21 = *MEMORY[0x1E4FBA418];
  *(uint64_t *)((char *)&a21 + *(void *)(a21 - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  a22 = MEMORY[0x1E4FBA470] + 16;
  if (a35 < 0) {
    operator delete(a30);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&a38);
  _Unwind_Resume(a1);
}

void *health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(void *a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5)
{
  if (*(unsigned __int16 *)(a4 + 544) <= a5)
  {
    std::string::basic_string[abi:ne180100]<0>(v31, "index < node.childCount");
    std::string::basic_string[abi:ne180100]<0>(v30, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v29, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Child index out of bounds.", &v28);
    health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v31, (uint64_t)v30, (uint64_t)v29, 137, (uint64_t)&v28);
  }
  if (a3 >= 64)
  {
    std::string::basic_string[abi:ne180100]<0>(v27, "depth < kMaximumRecursionDepth");
    std::string::basic_string[abi:ne180100]<0>(v26, "_interiorChildAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v25, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Maximum recursion depth reached.", &v24);
    health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v27, (uint64_t)v26, (uint64_t)v25, 138, (uint64_t)&v24);
  }
  unint64_t v9 = a5;
  uint64_t v10 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5);
  uint64_t v11 = *(void *)(v10 + 16);
  uint64_t v12 = *(void *)(v10 + 24);
  uint64_t v13 = *(void *)(a2 + 16);
  bzero(a1, 0x223uLL);
  double result = (void *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(uint64_t **)(v13 + 16), v11, v12, (uint64_t)a1);
  if (*((_WORD *)a1 + 272))
  {
    double result = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, v9);
    if (*a1 <= *result && (*a1 < *result || a1[1] < result[1]))
    {
      std::string::basic_string[abi:ne180100]<0>(v23, "child.children[0].key >= node.children[index].key");
      std::string::basic_string[abi:ne180100]<0>(v22, "_interiorChildAtIndex");
      std::string::basic_string[abi:ne180100]<0>(v21, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
      health::FormatString<>((std::string *)"Child node's smallest key is < parent's key", &v20);
      health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v23, (uint64_t)v22, (uint64_t)v21, 144, (uint64_t)&v20);
    }
    if (*(unsigned __int16 *)(a4 + 544) - 1 > (int)a5)
    {
      uint64_t v15 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)a1, *((unsigned __int16 *)a1 + 272) - 1);
      double result = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a4, a5 + 1);
      if (*v15 >= *result && (*v15 > *result || v15[1] >= result[1]))
      {
        std::string::basic_string[abi:ne180100]<0>(v19, "child.children[child.childCount - 1].key < node.children[index + 1].key");
        std::string::basic_string[abi:ne180100]<0>(v18, "_interiorChildAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v17, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
        health::FormatString<>((std::string *)"Child node's largest key is >= parent's next key", &v16);
        health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v19, (uint64_t)v18, (uint64_t)v17, 146, (uint64_t)&v16);
      }
    }
  }
  return result;
}

void sub_1BD1C67E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a32 < 0) {
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

void std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1>,void ()(health::BlockAccessFile::ReadTransaction const&)>::~__func()
{
}

__n128 std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1>,void ()(health::BlockAccessFile::ReadTransaction const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F1727890;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1>,void ()(health::BlockAccessFile::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F1727890;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1>,void ()(health::BlockAccessFile::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t *a2)
{
  v16[4] = *MEMORY[0x1E4F143B8];
  v12[0] = 0;
  v12[1] = 0;
  uint64_t v13 = a2;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(v5 + 872);
  uint64_t v9 = *(void *)(v5 + 864);
  uint64_t v10 = v6;
  uint64_t v11 = v12;
  std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v15, v4);
  bzero(v14, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(v13, v9, v6, (uint64_t)v14);
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::verifyInteriorNode((uint64_t)v14);
  std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v16, (uint64_t)v15);
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_checkInteriorNodeIntegrity((uint64_t)&v9, 0, (uint64_t)v14, (uint64_t)v16);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v16);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v15);
  uint64_t v7 = *(void *)(a1 + 16);
  v16[0] = &v9;
  v16[1] = v7;
  _OWORD v16[2] = a2;
  std::string::size_type v8 = v11;
  bzero(v14, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>((uint64_t *)v8[2], v9, v10, (uint64_t)v14);
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>((uint64_t)&v9, 0, (uint64_t)v14, (uint64_t)v16);
}

void sub_1BD1C6B24(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100]((void *)(v1 - 88));
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100]((void *)(v1 - 120));
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1>,void ()(health::BlockAccessFile::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1>,void ()(health::BlockAccessFile::ReadTransaction const&)>::target_type()
{
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::verifyInteriorNode(uint64_t result)
{
  unsigned int v1 = *(unsigned __int16 *)(result + 544);
  if (v1 >= 0x12)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Node contains too many values!");
    goto LABEL_13;
  }
  if (v1 >= 2)
  {
    uint64_t v2 = result;
    unint64_t v3 = 1;
    while (1)
    {
      uint64_t v5 = *(void *)result;
      unint64_t v4 = *(void *)(result + 8);
      uint64_t v6 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](v2, v3);
      if (*v6 < v5) {
        break;
      }
      if (*v6 <= v5 && v6[1] <= v4) {
        break;
      }
      __n128 result = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](v2, v3++);
      if (v3 >= *(unsigned __int16 *)(v2 + 544)) {
        return result;
      }
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Node values are out of order!");
LABEL_13:
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  return result;
}

void sub_1BD1C6D48(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_checkInteriorNodeIntegrity(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  unsigned __int16 v24 = 0;
  if (*(_WORD *)(a3 + 544))
  {
    uint64_t v7 = result;
    unsigned __int16 v8 = 0;
    uint64_t v9 = (a2 + 1);
    do
    {
      __n128 result = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v8);
      uint64_t v10 = *(void *)(v7 + 16);
      if (*(void *)(result + 16) != *(void *)v10 || *(void *)(result + 24) != *(void *)(v10 + 8))
      {
        if (*(unsigned char *)(a3 + 546))
        {
          uint64_t v11 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v24);
          bzero(v20, 0x222uLL);
          long long v22 = 0u;
          long long v23 = 0u;
          health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v10 + 16), *(void *)(v11 + 16), *(void *)(v11 + 24), (uint64_t)v20);
          if (v21 >= 0x12u)
          {
            exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(exception, "Node contains too many values!");
            goto LABEL_22;
          }
          if (v21 >= 2u)
          {
            uint64_t v12 = v20;
            unint64_t v13 = 1;
            while (1)
            {
              uint64_t v15 = *v12;
              unint64_t v14 = v12[1];
              std::string v16 = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v20, v13);
              if (*v16 < v15) {
                break;
              }
              if (*v16 <= v15 && v16[1] <= v14) {
                break;
              }
              uint64_t v12 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v20, v13++);
              if (v13 >= v21) {
                goto LABEL_16;
              }
            }
            exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(exception, "Node values are out of order!");
LABEL_22:
            __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
          }
LABEL_16:
          uint64_t v18 = (void *)std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v26, a4);
        }
        else
        {
          health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(v20, v7, a2, a3, v24);
          health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::verifyInteriorNode((uint64_t)v20);
          std::__function::__value_func<void ()(std::string const&)>::__value_func[abi:ne180100]((uint64_t)v25, a4);
          health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_checkInteriorNodeIntegrity(v7, v9, v20, v25);
          uint64_t v18 = v25;
        }
        __n128 result = (uint64_t)std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v18);
      }
      unsigned __int16 v8 = ++v24;
    }
    while (*(unsigned __int16 *)(a3 + 544) > v24);
  }
  return result;
}

void sub_1BD1C7100(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void sub_1BD1C7150(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1BD1C7160(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100]((void *)(v1 - 160));
  _Unwind_Resume(a1);
}

void health::FormatString<unsigned short &,char const*>(std::string *a1, std::string *a2, const char **a3, const char **a4)
{
  v4[0] = a4;
  v4[1] = a3;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  health::FormatImplementation<unsigned short &,char const*>(a2, a1, 0, v4);
}

void sub_1BD1C71C4(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void health::FormatImplementation<unsigned short &,char const*>(std::string *a1, std::string *a2, std::string::size_type a3, const char ***a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    long long v48 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v48 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v48 = i + 2;
    int v38 = i[2];
    if ((v38 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v39 = 0;
      long long v40 = i + 3;
      do
      {
        long long v48 = v40;
        uint64_t v39 = (v38 - 48) + 10 * v39;
        int v41 = *v40++;
        int v38 = v41;
      }
      while ((v41 - 58) >= 0xFFFFFFF6);
      long long v48 = v40;
      if (*(v40 - 1) == 125) {
        health::FormatterParameters<0ul,unsigned short &,char const*>::formatOptionsAtIndex<unsigned short &,char const*>(v39);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_95;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v44, (const char **)&v48);
  uint64_t v12 = v48;
  if (*((void *)&v44 + 1))
  {
    if (*((void *)&v44 + 1) == 1)
    {
      unint64_t v13 = **a4;
      long long v53 = v13;
      if (v13) {
        unint64_t v13 = (const char *)strlen(v13);
      }
      uint64_t v54 = (uint64_t)v13;
      v55[0] = v44;
      v55[1] = v45;
      std::locale v55[2] = v46;
      uint64_t v56 = v47;
      unint64_t v14 = (const char *)*((void *)&v45 + 1);
      if (*((void *)&v45 + 1) <= (unint64_t)v13) {
        unint64_t v14 = v13;
      }
      if ((_BYTE)v45) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = v13;
      }
      health::FormatImplementation<unsigned short &,char const*>(v48, a2, &v15[a3 + v8], a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string v16 = a2;
      }
      else {
        std::string v16 = (std::string *)a2->__r_.__value_.__r.__words[0];
      }
      health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(&v44, (unsigned char *)v16 + a3 + v8, (uint64_t)&v53);
      goto LABEL_59;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_95:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  v49[1] = 0;
  uint64_t v50 = 0;
  v49[0] = 0;
  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v53);
  int v17 = v53;
  if ((_BYTE)v45) {
    *(void *)((char *)v55 + *((void *)v53 - 3) + 8) = *((void *)&v45 + 1);
  }
  if ((_BYTE)v46) {
    *(void *)((char *)v55 + *((void *)v17 - 3)) = *((void *)&v46 + 1);
  }
  uint64_t v18 = (const std::ios_base *)((char *)&v53 + *((void *)v17 - 3));
  std::ios_base::fmtflags v19 = SBYTE4(v47);
  if (v18[1].__fmtflags_ == -1)
  {
    std::ios_base::getloc(v18);
    std::string v20 = std::locale::use_facet(v51, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 32);
    std::locale::~locale(v51);
  }
  v18[1].__fmtflags_ = v19;
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)&v54, v51);
  *(_OWORD *)long long v49 = *(_OWORD *)&v51[0].__locale_;
  uint64_t v50 = v52;
  long long v53 = (const char *)*MEMORY[0x1E4FBA418];
  *(const char **)((char *)&v53 + *((void *)v53 - 3)) = *(const char **)(MEMORY[0x1E4FBA418] + 24);
  uint64_t v54 = MEMORY[0x1E4FBA470] + 16;
  if (v58 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1C187B850](&v59);
  int v43 = SHIBYTE(v50);
  if (v50 >= 0) {
    size_t v21 = HIBYTE(v50);
  }
  else {
    size_t v21 = (size_t)v49[1];
  }
  size_t v22 = *((void *)&v45 + 1);
  if (*((void *)&v45 + 1) <= v21) {
    size_t v22 = v21;
  }
  if ((_BYTE)v45) {
    size_t v23 = v22;
  }
  else {
    size_t v23 = v21;
  }
  health::FormatImplementation<unsigned short &,char const*>(v12, a2, v23 + a3 + v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unsigned __int16 v24 = a2;
  }
  else {
    unsigned __int16 v24 = (std::string *)a2->__r_.__value_.__r.__words[0];
  }
  long long v25 = (char *)v24 + a3 + v8;
  if ((_BYTE)v45 && (v26 = *((void *)&v45 + 1), unint64_t v27 = *((void *)&v45 + 1) - v21, *((void *)&v45 + 1) > v21))
  {
    if (v44)
    {
      if (v44 == 1)
      {
        unint64_t v31 = v27 >> 1;
        if (v27 >= 2)
        {
          if (v31 <= 1) {
            uint64_t v32 = 1;
          }
          else {
            uint64_t v32 = v27 >> 1;
          }
          do
          {
            *v25++ = BYTE4(v47);
            --v32;
          }
          while (v32);
        }
        if (v21)
        {
          if (v43 >= 0) {
            unint64_t v33 = v49;
          }
          else {
            unint64_t v33 = (void **)v49[0];
          }
          memmove(v25, v33, v21);
        }
        if (v27 != v31)
        {
          unint64_t v34 = v27 - (v27 >> 1);
          uint64_t v35 = &v25[v21];
          if (v34 <= 1) {
            unint64_t v34 = 1;
          }
          uint64_t v36 = -(uint64_t)v34;
          do
            *v35++ = BYTE4(v47);
          while (!__CFADD__(v36++, 1));
        }
      }
      else if (v44 == 2)
      {
        if (*((void *)&v45 + 1) != v21)
        {
          do
          {
            *v25++ = BYTE4(v47);
            --v27;
          }
          while (v27);
        }
        goto LABEL_52;
      }
    }
    else
    {
      if (v21)
      {
        if (v43 >= 0) {
          uint64_t v29 = v49;
        }
        else {
          uint64_t v29 = (void **)v49[0];
        }
        memmove((char *)v24 + a3 + v8, v29, v21);
      }
      if (v26 != v21)
      {
        size_t v30 = (size_t)v24 + v21;
        do
        {
          *(unsigned char *)(v30 + a3 + v8) = BYTE4(v47);
          ++v30;
          --v27;
        }
        while (v27);
      }
    }
  }
  else
  {
LABEL_52:
    if (v21)
    {
      if (v43 >= 0) {
        std::string v28 = v49;
      }
      else {
        std::string v28 = (void **)v49[0];
      }
      memmove(v25, v28, v21);
    }
  }
  if (SHIBYTE(v50) < 0) {
    operator delete(v49[0]);
  }
LABEL_59:
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BD1C77F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,uint64_t a22,uint64_t a23,std::locale a24,uint64_t a25,uint64_t a26,char a27)
{
  __cxa_free_exception(v27);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,unsigned short &,char const*>::formatOptionsAtIndex<unsigned short &,char const*>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1C78E4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (*(_WORD *)(a3 + 544))
  {
    if (*(unsigned char *)(a3 + 546))
    {
      uint64_t v6 = *(void *)(a3 + 16);
      uint64_t v7 = *(void *)(a3 + 24);
      uint64_t v8 = *(void *)(a1 + 16);
      bzero(v25, 0x222uLL);
      long long v27 = 0u;
      long long v28 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v8 + 16), v6, v7, (uint64_t)v25);
      if (v26)
      {
        unint64_t v9 = 0;
        unint64_t v10 = 0;
        uint64_t v11 = 0;
        do
        {
          uint64_t v12 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v25, v9);
          uint64_t v13 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v25, v9);
          uint64_t v14 = *v12;
          if (v9 && v14 <= v11 && (v14 < v11 || v12[1] <= v10))
          {
            std::string::basic_string[abi:ne180100]<0>(v30, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v36, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v35, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v34);
            health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v30, (uint64_t)v36, (uint64_t)v35, 382, (uint64_t)&v34);
          }
          unint64_t v10 = v12[1];
          health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(int,health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17> const&,health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1} const&,health::bplustree::EnumerationDirection)const::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer const&)#1}::operator()(a4, v12, *(void *)(v13 + 16), *(void *)(v13 + 24));
          ++v9;
          uint64_t v11 = v14;
        }
        while (v9 < v26);
      }
      else
      {
        uint64_t v14 = 0;
        unint64_t v10 = 0;
      }
      uint64_t v18 = *((void *)&v28 + 1);
      for (uint64_t i = v28; ; uint64_t i = v33)
      {
        uint64_t v19 = *(void *)(a1 + 16);
        if (i == *(void *)v19 && v18 == *(void *)(v19 + 8)) {
          break;
        }
        bzero(v30, 0x222uLL);
        long long v32 = 0u;
        long long v33 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v19 + 16), i, v18, (uint64_t)v30);
        if (!v31)
        {
          std::string::basic_string[abi:ne180100]<0>(v36, "leaf.valueCount > 0");
          std::string::basic_string[abi:ne180100]<0>(v35, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(&v34, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v29);
          health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v36, (uint64_t)v35, (uint64_t)&v34, 392, (uint64_t)&v29);
        }
        for (unint64_t j = 0; j < v31; ++j)
        {
          uint64_t v21 = v14;
          size_t v22 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v30, j);
          uint64_t v23 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v30, j);
          uint64_t v14 = *v22;
          if (*v22 <= v21)
          {
            BOOL v24 = *v22 >= v21 && v22[1] > v10;
            unint64_t v10 = v22[1];
            if (!v24)
            {
              std::string::basic_string[abi:ne180100]<0>(v36, "key > lastKey");
              std::string::basic_string[abi:ne180100]<0>(v35, "_enumerateLeaves");
              std::string::basic_string[abi:ne180100]<0>(&v34, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
              health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v29);
              health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v36, (uint64_t)v35, (uint64_t)&v34, 396, (uint64_t)&v29);
            }
          }
          else
          {
            unint64_t v10 = v22[1];
          }
          health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(int,health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17> const&,health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1} const&,health::bplustree::EnumerationDirection)const::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer const&)#1}::operator()(a4, v22, *(void *)(v23 + 16), *(void *)(v23 + 24));
        }
        uint64_t v18 = *((void *)&v33 + 1);
      }
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(v30, a1, a2, a3, 0);
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(a1, (a2 + 1), v30, a4);
    }
  }
}

void sub_1BD1C7C28(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 129) < 0) {
    operator delete(*(void **)(v1 - 152));
  }
  if (*(char *)(v1 - 105) < 0) {
    operator delete(*(void **)(v1 - 128));
  }
  if (*(char *)(v1 - 81) < 0) {
    operator delete(*(void **)(v1 - 104));
  }
  if (SLOBYTE(STACK[0x277]) < 0) {
    operator delete((void *)STACK[0x260]);
  }
  _Unwind_Resume(a1);
}

void health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(int,health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17> const&,health::DataStore::checkIntegrity(std::function<void ()(std::string const&)>)::$_1::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1} const&,health::bplustree::EnumerationDirection)const::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer const&)#1}::operator()(uint64_t a1, void *a2, uint64_t a3, size_t a4)
{
  uint64_t v23 = a3;
  size_t v24 = a4;
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>(*(uint64_t **)a1, a2, 0, &v20);
  if (!v22)
  {
    uint64_t v10 = *(void *)(a1 + 8);
    v19.__r_.__value_.__r.__words[0] = (std::string::size_type)&v23;
    v19.__r_.__value_.__l.__size_ = (std::string::size_type)a2;
    memset(&v25, 0, sizeof(v25));
    health::FormatImplementation<health::DataStore::ObjectIdentifier const&,health::BlockPointer &>((std::string *)"Value retrieval failed for {0}: enumerated value {1} but lookup failed.", &v25, 0, (uint64_t *)&v19);
    uint64_t v11 = *(void *)(v10 + 24);
    if (!v11) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v11 + 48))(v11, &v25);
    if ((SHIBYTE(v25.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_11;
    }
    unint64_t v9 = (void *)v25.__r_.__value_.__r.__words[0];
    goto LABEL_10;
  }
  health::Optional<health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::get((uint64_t)&v20);
  if (v23 != v21[0] || (size_t v6 = v24, v24 != v21[1]))
  {
    uint64_t v7 = *(void *)(a1 + 8);
    health::Optional<health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::get((uint64_t)&v20);
    v25.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
    v25.__r_.__value_.__l.__size_ = (std::string::size_type)&v23;
    v25.__r_.__value_.__r.__words[2] = (std::string::size_type)a2;
    memset(&v19, 0, sizeof(v19));
    health::FormatImplementation<health::DataStore::ObjectIdentifier const&,health::BlockPointer &,health::BlockPointer &>((std::string *)"Value retrieval failed for {0}: enumerated value {1} but lookup value is {2}.", &v19, 0, (uint64_t *)&v25);
    uint64_t v8 = *(void *)(v7 + 24);
    if (!v8) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v8 + 48))(v8, &v19);
    if ((SHIBYTE(v19.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_11;
    }
    unint64_t v9 = (void *)v19.__r_.__value_.__r.__words[0];
LABEL_10:
    operator delete(v9);
LABEL_11:
    size_t v6 = v24;
  }
  if (v6)
  {
    if (v6 >> 20 <= 4)
    {
      std::vector<unsigned char>::vector(&v25, v6);
      health::RawBuffer::RawBuffer(&v19, (unsigned __int8 *)v25.__r_.__value_.__l.__data_, v25.__r_.__value_.__l.__size_ - v25.__r_.__value_.__r.__words[0]);
      uint64_t v12 = *(uint64_t **)(a1 + 16);
      uint64_t v13 = v23;
      uint64_t v14 = v24;
      health::RawBuffer::RawBuffer(v18, (unsigned __int8 *)v19.__r_.__value_.__l.__data_, v19.__r_.__value_.__l.__size_);
      health::BlockAccessFile::ReadTransaction::retrieveBlock(v12, v13, v14, (uint64_t)v18);
      uint64_t v15 = (void *)v25.__r_.__value_.__r.__words[0];
      if (v25.__r_.__value_.__r.__words[0])
      {
        v25.__r_.__value_.__l.__size_ = v25.__r_.__value_.__r.__words[0];
LABEL_19:
        operator delete(v15);
      }
    }
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 8);
    health::FormatString<health::DataStore::ObjectIdentifier const&>((std::string *)"Target block for {0} has 0 length", (uint64_t)a2, &v25);
    uint64_t v17 = *(void *)(v16 + 24);
    if (!v17) {
      std::__throw_bad_function_call[abi:ne180100]();
    }
    (*(void (**)(uint64_t, std::string *))(*(void *)v17 + 48))(v17, &v25);
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v15 = (void *)v25.__r_.__value_.__r.__words[0];
      goto LABEL_19;
    }
  }
}

void sub_1BD1C7F34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (*(char *)(v16 - 33) < 0) {
    operator delete(*(void **)(v16 - 56));
  }
  _Unwind_Resume(exception_object);
}

uint64_t health::Optional<health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::get(uint64_t result)
{
  if (!*(unsigned char *)(result + 40))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempt to get the value from an invalid optional.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  return result;
}

void sub_1BD1C7FE0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier const&,health::BlockPointer &,health::BlockPointer &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  std::string::size_type v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    std::string v29 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 + v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    ++v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    std::string v29 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    std::string v29 = i + 2;
    int v20 = i[2];
    if ((v20 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v21 = 0;
      char v22 = i + 3;
      do
      {
        std::string v29 = v22;
        uint64_t v21 = (v20 - 48) + 10 * v21;
        int v23 = *v22++;
        int v20 = v23;
      }
      while ((v23 - 58) >= 0xFFFFFFF6);
      std::string v29 = v22;
      if (*(v22 - 1) == 125) {
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&,health::BlockPointer &,health::BlockPointer &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&,health::BlockPointer &,health::BlockPointer &>(v21);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_55;
  }
  health::FormatOptions::FormatOptions((uint64_t)v25, (const char **)&v29);
  uint64_t v12 = v29;
  if (v26)
  {
    if (v26 != 1)
    {
      if (v26 == 2)
      {
        health::FormatString<unsigned long long const&,unsigned long long const&>((std::string *)"({0}: {1})", *a4, *a4 + 8, &__p);
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
        }
        std::string::size_type v14 = v28;
        if (v28 <= size) {
          std::string::size_type v14 = size;
        }
        if (v27) {
          std::string::size_type size = v14;
        }
        health::FormatImplementation<health::DataStore::ObjectIdentifier const&,health::BlockPointer &,health::BlockPointer &>(v12, a2, size + a3 + v8, a4);
        if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v15 = (char *)a2;
        }
        else {
          uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
        }
        goto LABEL_43;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_55:
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    health::FormatString<unsigned long long const&,unsigned long long const&>((std::string *)"({0}: {1})", a4[1], a4[1] + 8, &__p);
    std::string::size_type v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v19 = v28;
    if (v28 <= v18) {
      std::string::size_type v19 = v18;
    }
    if (v27) {
      std::string::size_type v18 = v19;
    }
    health::FormatImplementation<health::DataStore::ObjectIdentifier const&,health::BlockPointer &,health::BlockPointer &>(v12, a2, v18 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v15 = (char *)a2;
    }
    else {
      uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
  else
  {
    health::TypeFormatter<health::DataStore::ObjectIdentifier const&,void>::TypeFormatter((uint64_t)&__p, a4[2], (uint64_t)v25);
    std::string::size_type v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v16 = __p.__r_.__value_.__l.__size_;
    }
    std::string::size_type v17 = v28;
    if (v28 <= v16) {
      std::string::size_type v17 = v16;
    }
    if (v27) {
      std::string::size_type v16 = v17;
    }
    health::FormatImplementation<health::DataStore::ObjectIdentifier const&,health::BlockPointer &,health::BlockPointer &>(v12, a2, v16 + a3 + v8, a4);
    if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v15 = (char *)a2;
    }
    else {
      uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
    }
  }
LABEL_43:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v25, &v15[a3 + v8], (const void **)&__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, v8, v9 & 1);
  }
}

void sub_1BD1C8374(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&,health::BlockPointer &,health::BlockPointer &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&,health::BlockPointer &,health::BlockPointer &>(uint64_t a1)
{
  if (a1 && a1 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v2 = exception;
    if (a1 == 2) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v2 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v2, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v2, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1C8468(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<health::DataStore::ObjectIdentifier const&,health::BlockPointer &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    char v27 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    char v27 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    char v27 = i + 2;
    int v18 = i[2];
    if ((v18 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v19 = 0;
      int v20 = i + 3;
      do
      {
        char v27 = v20;
        uint64_t v19 = (v18 - 48) + 10 * v19;
        int v21 = *v20++;
        int v18 = v21;
      }
      while ((v21 - 58) >= 0xFFFFFFF6);
      char v27 = v20;
      if (*(v20 - 1) == 125) {
        health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&,health::BlockPointer &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&,health::BlockPointer &>(v19);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_45;
  }
  health::FormatOptions::FormatOptions((uint64_t)v23, (const char **)&v27);
  uint64_t v12 = v27;
  if (v24)
  {
    if (v24 == 1)
    {
      health::FormatString<unsigned long long const&,unsigned long long const&>((std::string *)"({0}: {1})", *a4, *a4 + 8, &__p);
      std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      std::string::size_type v14 = v26;
      if (v26 <= size) {
        std::string::size_type v14 = size;
      }
      if (v25) {
        std::string::size_type size = v14;
      }
      health::FormatImplementation<health::DataStore::ObjectIdentifier const&,health::BlockPointer &>(v12, a2, size + a3 - v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = (char *)a2;
      }
      else {
        uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_33;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_45:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::TypeFormatter<health::DataStore::ObjectIdentifier const&,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v23);
  std::string::size_type v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v16 = __p.__r_.__value_.__l.__size_;
  }
  std::string::size_type v17 = v26;
  if (v26 <= v16) {
    std::string::size_type v17 = v16;
  }
  if (v25) {
    std::string::size_type v16 = v17;
  }
  health::FormatImplementation<health::DataStore::ObjectIdentifier const&,health::BlockPointer &>(v12, a2, v16 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = (char *)a2;
  }
  else {
    uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
LABEL_33:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v23, &v15[a3 - v8], (const void **)&__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BD1C8788(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,health::DataStore::ObjectIdentifier const&,health::BlockPointer &>::formatOptionsAtIndex<health::DataStore::ObjectIdentifier const&,health::BlockPointer &>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1C8854(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<char const*,char const*>(std::string *a1, std::string *a2, std::string::size_type a3, const char ***a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    std::string::size_type v26 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    std::string::size_type v26 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    std::string::size_type v26 = i + 2;
    int v17 = i[2];
    if ((v17 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v18 = 0;
      uint64_t v19 = i + 3;
      do
      {
        std::string::size_type v26 = v19;
        uint64_t v18 = (v17 - 48) + 10 * v18;
        int v20 = *v19++;
        int v17 = v20;
      }
      while ((v20 - 58) >= 0xFFFFFFF6);
      std::string::size_type v26 = v19;
      if (*(v19 - 1) == 125) {
        health::FormatterParameters<0ul,char const*,char const*>::formatOptionsAtIndex<char const*,char const*>(v18);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_37;
  }
  health::FormatOptions::FormatOptions((uint64_t)&v22, (const char **)&v26);
  if (*((void *)&v22 + 1))
  {
    if (*((void *)&v22 + 1) == 1)
    {
      uint64_t v12 = *a4;
      goto LABEL_17;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_37:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  uint64_t v12 = a4[1];
LABEL_17:
  uint64_t v13 = *v12;
  v27[0] = v13;
  if (v13) {
    uint64_t v13 = (const char *)strlen(v13);
  }
  v27[1] = v13;
  long long v28 = v22;
  long long v29 = v23;
  long long v30 = v24;
  uint64_t v31 = v25;
  std::string::size_type v14 = (const char *)*((void *)&v23 + 1);
  if (*((void *)&v23 + 1) <= (unint64_t)v13) {
    std::string::size_type v14 = v13;
  }
  if ((_BYTE)v23) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = v13;
  }
  health::FormatImplementation<char const*,char const*>(v26, a2, &v15[a3 - v8], a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v16 = a2;
  }
  else {
    std::string::size_type v16 = (std::string *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,char const*>(&v22, (unsigned char *)v16 + a3 - v8, (uint64_t)v27);
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BD1C8AF8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,char const*,char const*>::formatOptionsAtIndex<char const*,char const*>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1C8BA0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<health::DataStore::rebuildIndex(void)::$_0,std::allocator<health::DataStore::rebuildIndex(void)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__func()
{
}

void *std::__function::__func<health::DataStore::rebuildIndex(void)::$_0,std::allocator<health::DataStore::rebuildIndex(void)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F1727910;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::DataStore::rebuildIndex(void)::$_0,std::allocator<health::DataStore::rebuildIndex(void)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F1727910;
  a2[1] = v2;
  return result;
}

BOOL std::__function::__func<health::DataStore::rebuildIndex(void)::$_0,std::allocator<health::DataStore::rebuildIndex(void)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::operator()(uint64_t a1, uint64_t a2)
{
  v22[4] = *(uint64_t **)MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 8);
  v18[1] = 0;
  v18[0] = 0;
  uint64_t v19 = (uint64_t *)a2;
  uint64_t v20 = a2;
  uint64_t v5 = *(void *)(v3 + 872);
  v17[0] = *(void *)(v3 + 864);
  uint64_t v4 = v17[0];
  v17[1] = v5;
  v17[2] = v18;
  bzero(v16, 0x223uLL);
  uint64_t v6 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength((health::BlockAccessFile::WriteTransaction *)a2, 547);
  uint64_t v8 = v7;
  health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(a2, v6, v7, (uint64_t)v16);
  v15[0] = v6;
  v15[1] = v8;
  v15[2] = v18;
  v22[0] = v15;
  bzero(v21, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(v19, v4, v5, (uint64_t)v21);
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>((uint64_t)v17, 0, (uint64_t)v21, v22);
  char v9 = (_OWORD *)(v3 + 864);
  unsigned __int8 v14 = 1;
  long long v13 = *(_OWORD *)(v3 + 864);
  *(void *)(v3 + 864) = v6;
  *(void *)(v3 + 872) = v8;
  v22[0] = (uint64_t *)&unk_1F1727980;
  v22[1] = (uint64_t *)&v14;
  void v22[3] = (uint64_t *)v22;
  health::DataStore::checkIntegrity(v3, (uint64_t)v22);
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100](v22);
  int v10 = v14;
  if (v14)
  {
    uint64_t v11 = *(void *)(a2 + 24);
    *(void *)(v11 + 40) = v6;
    *(void *)(v11 + 48) = v8;
    health::TransactionalFile::WriteTransaction::storeObjectAtOffset<health::BlockAccessFile::BlockAccessFileHeader &>(*(health::TransactionalFile::WriteTransaction **)(a2 + 16), *(void *)(a2 + 24), 0);
  }
  else
  {
    *char v9 = v13;
  }
  return v10 != 0;
}

void sub_1BD1C8DE4(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(std::string const&)>::~__value_func[abi:ne180100]((void *)(v1 - 104));
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStore::rebuildIndex(void)::$_0,std::allocator<health::DataStore::rebuildIndex(void)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::rebuildIndex(void)::$_0,std::allocator<health::DataStore::rebuildIndex(void)::$_0>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::target_type()
{
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t **a4)
{
  if (*(_WORD *)(a3 + 544))
  {
    uint64_t v5 = result;
    if (*(unsigned char *)(a3 + 546))
    {
      uint64_t v6 = *(void *)(a3 + 16);
      uint64_t v7 = *(void *)(a3 + 24);
      uint64_t v8 = *(void *)(result + 16);
      bzero(v25, 0x222uLL);
      long long v27 = 0u;
      long long v28 = 0u;
      __n128 result = health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v8 + 16), v6, v7, (uint64_t)v25);
      if (v26)
      {
        unint64_t v9 = 0;
        unint64_t v10 = 0;
        int64_t v11 = 0;
        do
        {
          uint64_t v12 = (__n128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v25, v9);
          long long v13 = (__n128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v25, v9);
          int64_t v14 = v12->n128_u64[0];
          if (v9 && v14 <= v11 && (v14 < v11 || v12->n128_u64[1] <= v10))
          {
            std::string::basic_string[abi:ne180100]<0>(v30, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v36, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v35, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v34);
            health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v30, (uint64_t)v36, (uint64_t)v35, 382, (uint64_t)&v34);
          }
          unint64_t v10 = v12->n128_u64[1];
          v30[0] = v13[1];
          __n128 result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey(*a4, v12, v30);
          ++v9;
          int64_t v11 = v14;
        }
        while (v9 < v26);
      }
      else
      {
        int64_t v14 = 0;
        unint64_t v10 = 0;
      }
      uint64_t v18 = *((void *)&v28 + 1);
      for (uint64_t i = v28; ; uint64_t i = v33)
      {
        uint64_t v19 = *(void *)(v5 + 16);
        if (i == *(void *)v19 && v18 == *(void *)(v19 + 8)) {
          break;
        }
        bzero(v30, 0x222uLL);
        long long v32 = 0u;
        long long v33 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v19 + 16), i, v18, (uint64_t)v30);
        if (!v31)
        {
          std::string::basic_string[abi:ne180100]<0>(v36, "leaf.valueCount > 0");
          std::string::basic_string[abi:ne180100]<0>(v35, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(&v34, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v29);
          health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v36, (uint64_t)v35, (uint64_t)&v34, 392, (uint64_t)&v29);
        }
        for (unint64_t j = 0; j < v31; ++j)
        {
          int64_t v21 = v14;
          long long v22 = (__n128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v30, j);
          long long v23 = (__n128 *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v30, j);
          int64_t v14 = v22->n128_u64[0];
          if ((int64_t)v22->n128_u64[0] <= v21)
          {
            BOOL v24 = (int64_t)v22->n128_u64[0] >= v21 && v22->n128_u64[1] > v10;
            unint64_t v10 = v22->n128_u64[1];
            if (!v24)
            {
              std::string::basic_string[abi:ne180100]<0>(v36, "key > lastKey");
              std::string::basic_string[abi:ne180100]<0>(v35, "_enumerateLeaves");
              std::string::basic_string[abi:ne180100]<0>(&v34, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
              health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v29);
              health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v36, (uint64_t)v35, (uint64_t)&v34, 396, (uint64_t)&v29);
            }
          }
          else
          {
            unint64_t v10 = v22->n128_u64[1];
          }
          v36[0] = v23[1];
          __n128 result = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey(*a4, v22, v36);
        }
        uint64_t v18 = *((void *)&v33 + 1);
      }
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(v30, result, a2, a3, 0);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(v5, (a2 + 1), v30, a4);
    }
  }
  return result;
}

void sub_1BD1C91F4(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 137) < 0) {
    operator delete(*(void **)(v1 - 160));
  }
  if (*(char *)(v1 - 113) < 0) {
    operator delete(*(void **)(v1 - 136));
  }
  if (*(char *)(v1 - 89) < 0) {
    operator delete(*(void **)(v1 - 112));
  }
  if (SLOBYTE(STACK[0x277]) < 0) {
    operator delete((void *)STACK[0x260]);
  }
  _Unwind_Resume(a1);
}

void std::__function::__func<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1},std::allocator<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1}>,void ()(std::string const&)>::~__func()
{
}

void *std::__function::__func<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1},std::allocator<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1}>,void ()(std::string const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F1727980;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1},std::allocator<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1}>,void ()(std::string const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F1727980;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1},std::allocator<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1}>,void ()(std::string const&)>::operator()(uint64_t result)
{
  **(unsigned char **)(result + 8) = 0;
  return result;
}

uint64_t std::__function::__func<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1},std::allocator<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1}>,void ()(std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1},std::allocator<health::DataStore::rebuildIndex(void)::$_0::operator() const(health::BlockAccessFile::WriteTransaction &)::{lambda(std::string const&)#1}>,void ()(std::string const&)>::target_type()
{
}

void std::__function::__func<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0,std::allocator<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::~__func()
{
}

__n128 std::__function::__func<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0,std::allocator<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F1727A20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0,std::allocator<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F1727A20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0,std::allocator<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::operator()(uint64_t a1, uint64_t *a2)
{
  v9[0] = 0;
  v9[1] = 0;
  v9[2] = a2;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = *(void *)(v3 + 872);
  v8[0] = *(void *)(v3 + 864);
  v8[1] = v5;
  void v8[2] = (uint64_t)v9;
  uint64_t v7 = v4;
  bzero(v10, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(a2, v8[0], v5, (uint64_t)v10);
  return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>((uint64_t)v8, 0, (uint64_t)v10, (uint64_t)&v7);
}

uint64_t std::__function::__func<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0,std::allocator<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0,std::allocator<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0>,void ()(health::BlockAccessFile::ReadTransaction const&)>::target_type()
{
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  if (*(_WORD *)(a3 + 544))
  {
    uint64_t v5 = result;
    if (*(unsigned char *)(a3 + 546))
    {
      uint64_t v6 = *(void *)(a3 + 16);
      uint64_t v7 = *(void *)(a3 + 24);
      uint64_t v8 = *(void *)(result + 16);
      bzero(v25, 0x222uLL);
      long long v27 = 0u;
      long long v28 = 0u;
      __n128 result = health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v8 + 16), v6, v7, (uint64_t)v25);
      if (v26)
      {
        unint64_t v9 = 0;
        unint64_t v10 = 0;
        uint64_t v11 = 0;
        do
        {
          uint64_t v12 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v25, v9);
          uint64_t v13 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v25, v9);
          uint64_t v14 = *v12;
          if (v9 && v14 <= v11 && (v14 < v11 || v12[1] <= v10))
          {
            std::string::basic_string[abi:ne180100]<0>(v30, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v36, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v35, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v34);
            health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v30, (uint64_t)v36, (uint64_t)v35, 382, (uint64_t)&v34);
          }
          unint64_t v10 = v12[1];
          __n128 result = std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::operator()(*(void *)(*(void *)a4 + 24), (uint64_t)v12, *(void *)(v13 + 16), *(void *)(v13 + 24));
          ++v9;
          uint64_t v11 = v14;
        }
        while (v9 < v26);
      }
      else
      {
        uint64_t v14 = 0;
        unint64_t v10 = 0;
      }
      uint64_t v18 = *((void *)&v28 + 1);
      for (uint64_t i = v28; ; uint64_t i = v33)
      {
        uint64_t v19 = *(void *)(v5 + 16);
        if (i == *(void *)v19 && v18 == *(void *)(v19 + 8)) {
          break;
        }
        bzero(v30, 0x222uLL);
        long long v32 = 0u;
        long long v33 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v19 + 16), i, v18, (uint64_t)v30);
        if (!v31)
        {
          std::string::basic_string[abi:ne180100]<0>(v36, "leaf.valueCount > 0");
          std::string::basic_string[abi:ne180100]<0>(v35, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(&v34, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v29);
          health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v36, (uint64_t)v35, (uint64_t)&v34, 392, (uint64_t)&v29);
        }
        for (unint64_t j = 0; j < v31; ++j)
        {
          uint64_t v21 = v14;
          long long v22 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v30, j);
          uint64_t v23 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v30, j);
          uint64_t v14 = *v22;
          if (*v22 <= v21)
          {
            BOOL v24 = *v22 >= v21 && v22[1] > v10;
            unint64_t v10 = v22[1];
            if (!v24)
            {
              std::string::basic_string[abi:ne180100]<0>(v36, "key > lastKey");
              std::string::basic_string[abi:ne180100]<0>(v35, "_enumerateLeaves");
              std::string::basic_string[abi:ne180100]<0>(&v34, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
              health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v29);
              health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v36, (uint64_t)v35, (uint64_t)&v34, 396, (uint64_t)&v29);
            }
          }
          else
          {
            unint64_t v10 = v22[1];
          }
          __n128 result = std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::operator()(*(void *)(*(void *)a4 + 24), (uint64_t)v22, *(void *)(v23 + 16), *(void *)(v23 + 24));
        }
        uint64_t v18 = *((void *)&v33 + 1);
      }
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(v30, result, a2, a3, 0);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::enumerateObjectTreeForInspecting(std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>)::$_0::operator() const(health::BlockAccessFile::ReadTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(v5, (a2 + 1), v30, a4);
    }
  }
  return result;
}

void sub_1BD1C9844(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 129) < 0) {
    operator delete(*(void **)(v1 - 152));
  }
  if (*(char *)(v1 - 105) < 0) {
    operator delete(*(void **)(v1 - 128));
  }
  if (*(char *)(v1 - 81) < 0) {
    operator delete(*(void **)(v1 - 104));
  }
  if (SLOBYTE(STACK[0x277]) < 0) {
    operator delete((void *)STACK[0x260]);
  }
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(health::DataStore::ObjectIdentifier const&,health::BlockPointer)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v5[0] = a3;
  v5[1] = a4;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, void *))(*(void *)a1 + 48))(a1, a2, v5);
}

void health::FormatImplementation<std::string &,int &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    long long v27 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    long long v27 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    long long v27 = i + 2;
    int v18 = i[2];
    if ((v18 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v19 = 0;
      uint64_t v20 = i + 3;
      do
      {
        long long v27 = v20;
        uint64_t v19 = (v18 - 48) + 10 * v19;
        int v21 = *v20++;
        int v18 = v21;
      }
      while ((v21 - 58) >= 0xFFFFFFF6);
      long long v27 = v20;
      if (*(v20 - 1) == 125) {
        health::FormatterParameters<0ul,std::string &,int &>::formatOptionsAtIndex<std::string &,int &>(v19);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
    goto LABEL_45;
  }
  health::FormatOptions::FormatOptions((uint64_t)v23, (const char **)&v27);
  uint64_t v12 = v27;
  if (v24)
  {
    if (v24 == 1)
    {
      health::TypeFormatter<int &,void>::TypeFormatter((uint64_t)&__p, *a4, (uint64_t)v23);
      unint64_t v13 = v30;
      if ((v30 & 0x80u) != 0) {
        unint64_t v13 = v29;
      }
      unint64_t v14 = v26;
      if (v26 <= v13) {
        unint64_t v14 = v13;
      }
      if (v25) {
        unint64_t v13 = v14;
      }
      health::FormatImplementation<std::string &,int &>(v12, a2, v13 + a3 - v8, a4);
      if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v15 = (char *)a2;
      }
      else {
        uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
      }
      goto LABEL_33;
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
LABEL_45:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)&__p, a4[1], (uint64_t)v23);
  unint64_t v16 = v30;
  if ((v30 & 0x80u) != 0) {
    unint64_t v16 = v29;
  }
  unint64_t v17 = v26;
  if (v26 <= v16) {
    unint64_t v17 = v16;
  }
  if (v25) {
    unint64_t v16 = v17;
  }
  health::FormatImplementation<std::string &,int &>(v12, a2, v16 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = (char *)a2;
  }
  else {
    uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
LABEL_33:
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v23, &v15[a3 - v8], (const void **)&__p);
  if ((char)v30 < 0) {
    operator delete(__p);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BD1C9C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &,int &>::formatOptionsAtIndex<std::string &,int &>(uint64_t a1)
{
  if (a1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v1 = exception;
    if (a1 == 1) {
      std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
    }
    else {
      std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    }
  }
  else
  {
    uint64_t v1 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v1, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v1, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1C9D2C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void health::FormatImplementation<std::string &>(std::string *a1, std::string *a2, std::string::size_type a3, uint64_t *a4)
{
  uint64_t v8 = 0;
  char v9 = 0;
  for (uint64_t i = (char *)a1; ; ++i)
  {
    char v25 = i;
    if (*i == 123) {
      break;
    }
    if (!*i)
    {
      std::string::resize(a2, a3 - v8, 0);
      if (v8)
      {
        health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
      }
      return;
    }
LABEL_7:
    --v8;
  }
  int v11 = i[1];
  if (v11 == 123)
  {
    char v25 = i + 1;
    char v9 = 1;
    ++i;
    goto LABEL_7;
  }
  if (v11 == 42)
  {
    char v25 = i + 2;
    int v16 = i[2];
    if ((v16 - 48) > 9)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format string- missing numeric value.");
    }
    else
    {
      uint64_t v17 = 0;
      int v18 = i + 3;
      do
      {
        char v25 = v18;
        uint64_t v17 = (v16 - 48) + 10 * v17;
        int v19 = *v18++;
        int v16 = v19;
      }
      while ((v19 - 58) >= 0xFFFFFFF6);
      char v25 = v18;
      if (*(v18 - 1) == 125) {
        health::FormatterParameters<0ul,std::string &>::formatOptionsAtIndex<std::string &>(v17);
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Invalid format options reference: Must be of form {*<index>} but no trailing '}' found.");
    }
LABEL_35:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  health::FormatOptions::FormatOptions((uint64_t)v21, (const char **)&v25);
  if (v22)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
    goto LABEL_35;
  }
  uint64_t v12 = v25;
  health::TypeFormatter<std::string &,void>::TypeFormatter((uint64_t)__p, *a4, (uint64_t)v21);
  unint64_t v13 = v27;
  if ((v27 & 0x80u) != 0) {
    unint64_t v13 = (unint64_t)__p[1];
  }
  unint64_t v14 = v24;
  if (v24 <= v13) {
    unint64_t v14 = v13;
  }
  if (v23) {
    unint64_t v13 = v14;
  }
  health::FormatImplementation<std::string &>(v12, a2, v13 + a3 - v8, a4);
  if ((a2->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v15 = (char *)a2;
  }
  else {
    uint64_t v15 = (char *)a2->__r_.__value_.__r.__words[0];
  }
  health::FormatOptions::justifyNativeValueOfLength<std::__wrap_iter<char *>,unsigned long long &>(v21, &v15[a3 - v8], (const void **)__p);
  if ((char)v27 < 0) {
    operator delete(__p[0]);
  }
  if (v8) {
    health::CopyFormatSectionToResult(a1, a2, a3, -v8, v9 & 1);
  }
}

void sub_1BD1C9FBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  __cxa_free_exception(v23);
  _Unwind_Resume(a1);
}

void health::FormatterParameters<0ul,std::string &>::formatOptionsAtIndex<std::string &>(uint64_t a1)
{
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  uint64_t v3 = exception;
  if (a1) {
    std::runtime_error::runtime_error(exception, "Parameter index out of bounds.");
  }
  else {
    std::runtime_error::runtime_error(exception, "Requested parameter is not an FormatOptions instance.");
  }
  __cxa_throw(v3, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_1BD1CA05C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::~__func()
{
}

void *std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F1727AA0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F1727AA0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  return 1;
}

uint64_t std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_0>,BOOL ()(health::BlockAccessFile::IntegrityError,long long,long long,std::string const&)>::target_type()
{
}

void std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::~__func()
{
}

__n128 std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F1727B20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F1727B20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v21[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 8);
  long long v5 = *(_OWORD *)(a2 + 16);
  v17[0] = *(_OWORD *)a2;
  v17[1] = v5;
  v17[2] = *(_OWORD *)(a2 + 32);
  char v18 = *(unsigned char *)(a2 + 48);
  std::deque<health::BlockPointer>::deque(v19, (void *)(a2 + 56));
  uint64_t v6 = *(void *)(v4 + 864);
  uint64_t v7 = *(void *)(v4 + 872);
  std::string::basic_string[abi:ne180100]<0>(__p, "Object Store");
  unint64_t v8 = **(void **)(a1 + 16);
  std::__function::__value_func<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::__value_func[abi:ne180100]((uint64_t)v21, *(void *)(a1 + 24));
  health::DataStore::_checkBlockIntegrity(v4, (uint64_t *)v17, v6, v7, (uint64_t)__p, v8, (uint64_t)v21);
  std::__function::__value_func<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::~__value_func[abi:ne180100](v21);
  if (v16 < 0) {
    operator delete(__p[0]);
  }
  std::deque<health::BlockPointer>::~deque[abi:ne180100](v19);
  v14[0] = 0;
  v14[1] = 0;
  v14[2] = a2;
  uint64_t v9 = *(void *)(v4 + 872);
  v13[0] = *(void *)(v4 + 864);
  v13[1] = v9;
  void v13[2] = (uint64_t)v14;
  v11[0] = v4;
  v11[1] = a2;
  long long v12 = *(_OWORD *)(a1 + 16);
  bzero(v20, 0x223uLL);
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>((uint64_t *)a2, v13[0], v9, (uint64_t)v20);
  health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1::operator() const(health::BlockAccessFile::WriteTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>((uint64_t)v13, 0, (uint64_t)v20, (uint64_t)v11);
  return 1;
}

void sub_1BD1CA388(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  std::__function::__value_func<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::~__value_func[abi:ne180100]((void *)(v26 - 104));
  if (a25 < 0) {
    operator delete(__p);
  }
  std::deque<health::BlockPointer>::~deque[abi:ne180100](v25);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1,std::allocator<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1>,BOOL ()(health::BlockAccessFile::WriteTransaction &)>::target_type()
{
}

uint64_t std::__function::__value_func<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1::operator() const(health::BlockAccessFile::WriteTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  if (*(_WORD *)(a3 + 544))
  {
    uint64_t v5 = result;
    if (*(unsigned char *)(a3 + 546))
    {
      uint64_t v6 = *(void *)(a3 + 16);
      uint64_t v7 = *(void *)(a3 + 24);
      uint64_t v8 = *(void *)(result + 16);
      bzero(v25, 0x222uLL);
      long long v27 = 0u;
      long long v28 = 0u;
      __n128 result = health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v8 + 16), v6, v7, (uint64_t)v25);
      if (v26)
      {
        unint64_t v9 = 0;
        unint64_t v10 = 0;
        uint64_t v11 = 0;
        do
        {
          long long v12 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v25, v9);
          uint64_t v13 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v25, v9);
          uint64_t v14 = *v12;
          if (v9 && v14 <= v11 && (v14 < v11 || v12[1] <= v10))
          {
            std::string::basic_string[abi:ne180100]<0>(v30, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v36, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v35, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v34);
            health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v30, (uint64_t)v36, (uint64_t)v35, 382, (uint64_t)&v34);
          }
          unint64_t v10 = v12[1];
          __n128 result = health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1::operator() const(health::BlockAccessFile::WriteTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(int,health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17> const&,health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1::operator() const(health::BlockAccessFile::WriteTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1} const&,health::bplustree::EnumerationDirection)const::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer const&)#1}::operator()(a4, (uint64_t)v12, *(void *)(v13 + 16), *(void *)(v13 + 24));
          ++v9;
          uint64_t v11 = v14;
        }
        while (v9 < v26);
      }
      else
      {
        uint64_t v14 = 0;
        unint64_t v10 = 0;
      }
      uint64_t v18 = *((void *)&v28 + 1);
      for (uint64_t i = v28; ; uint64_t i = v33)
      {
        uint64_t v19 = *(void *)(v5 + 16);
        if (i == *(void *)v19 && v18 == *(void *)(v19 + 8)) {
          break;
        }
        bzero(v30, 0x222uLL);
        long long v32 = 0u;
        long long v33 = 0u;
        health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v19 + 16), i, v18, (uint64_t)v30);
        if (!v31)
        {
          std::string::basic_string[abi:ne180100]<0>(v36, "leaf.valueCount > 0");
          std::string::basic_string[abi:ne180100]<0>(v35, "_enumerateLeaves");
          std::string::basic_string[abi:ne180100]<0>(&v34, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
          health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v29);
          health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v36, (uint64_t)v35, (uint64_t)&v34, 392, (uint64_t)&v29);
        }
        for (unint64_t j = 0; j < v31; ++j)
        {
          uint64_t v21 = v14;
          uint64_t v22 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v30, j);
          uint64_t v23 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v30, j);
          uint64_t v14 = *v22;
          if (*v22 <= v21)
          {
            BOOL v24 = *v22 >= v21 && v22[1] > v10;
            unint64_t v10 = v22[1];
            if (!v24)
            {
              std::string::basic_string[abi:ne180100]<0>(v36, "key > lastKey");
              std::string::basic_string[abi:ne180100]<0>(v35, "_enumerateLeaves");
              std::string::basic_string[abi:ne180100]<0>(&v34, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
              health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v29);
              health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v36, (uint64_t)v35, (uint64_t)&v34, 396, (uint64_t)&v29);
            }
          }
          else
          {
            unint64_t v10 = v22[1];
          }
          __n128 result = health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1::operator() const(health::BlockAccessFile::WriteTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(int,health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17> const&,health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1::operator() const(health::BlockAccessFile::WriteTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1} const&,health::bplustree::EnumerationDirection)const::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer const&)#1}::operator()(a4, (uint64_t)v22, *(void *)(v23 + 16), *(void *)(v23 + 24));
        }
        uint64_t v18 = *((void *)&v33 + 1);
      }
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(v30, result, a2, a3, 0);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1::operator() const(health::BlockAccessFile::WriteTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(v5, (a2 + 1), v30, a4);
    }
  }
  return result;
}

void sub_1BD1CA7D8(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 129) < 0) {
    operator delete(*(void **)(v1 - 152));
  }
  if (*(char *)(v1 - 105) < 0) {
    operator delete(*(void **)(v1 - 128));
  }
  if (*(char *)(v1 - 81) < 0) {
    operator delete(*(void **)(v1 - 104));
  }
  if (SLOBYTE(STACK[0x277]) < 0) {
    operator delete((void *)STACK[0x260]);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateAllValues<health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1::operator() const(health::BlockAccessFile::WriteTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1}>(int,health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17> const&,health::DataStore::checkIntegrityForInspecting(std::function<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>)::$_1::operator() const(health::BlockAccessFile::WriteTransaction const&)::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer)#1} const&,health::bplustree::EnumerationDirection)const::{lambda(health::DataStore::ObjectIdentifier const&,health::BlockPointer const&)#1}::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v20[4] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)a1;
  uint64_t v8 = *(void *)(a1 + 8);
  char v10 = *(unsigned char *)(v8 + 48);
  long long v12 = *(_OWORD *)(v8 + 16);
  long long v11 = *(_OWORD *)(v8 + 32);
  v17[0] = *(_OWORD *)v8;
  v17[1] = v12;
  v17[2] = v11;
  char v18 = v10;
  std::deque<health::BlockPointer>::deque(v19, (void *)(v8 + 56));
  health::FormatString<health::DataStore::ObjectIdentifier const&>((std::string *)"HFD object [ID: {0}]", a2, &__p);
  uint64_t v13 = *(void *)(a1 + 24);
  unint64_t v14 = **(void **)(a1 + 16);
  std::__function::__value_func<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::__value_func[abi:ne180100]((uint64_t)v20, v13);
  health::DataStore::_checkBlockIntegrity(v9, (uint64_t *)v17, a3, a4, (uint64_t)&__p, v14, (uint64_t)v20);
  std::__function::__value_func<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::~__value_func[abi:ne180100](v20);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return std::deque<health::BlockPointer>::~deque[abi:ne180100](v19);
}

void sub_1BD1CA9B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  std::__function::__value_func<BOOL ()(health::DataStore::IntegrityError,health::BlockPointer,std::string const&)>::~__value_func[abi:ne180100]((void *)(v16 - 88));
  if (a15 < 0) {
    operator delete(__p);
  }
  std::deque<health::BlockPointer>::~deque[abi:ne180100](v15);
  _Unwind_Resume(a1);
}

void *health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateValuesInRange<health::DataStore::ReadTransaction::enumerateIdentifiersForObjectType(long long,std::function<void ()(health::DataStore::ObjectIdentifier)>)::$_0>(void *result, int a2, uint64_t a3, uint64_t a4, void *a5, uint64_t *a6)
{
  if (*(_WORD *)(a3 + 544))
  {
    long long v11 = result;
    unsigned int v12 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a3, a5);
    if (*(unsigned char *)(a3 + 546))
    {
      uint64_t v13 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a3, v12);
      uint64_t v14 = *(void *)(v13 + 16);
      uint64_t v15 = *(void *)(v13 + 24);
      uint64_t v16 = v11[2];
      bzero(v17, 0x222uLL);
      long long v18 = 0u;
      long long v19 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v16 + 16), v14, v15, (uint64_t)v17);
      return health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateValuesInRange<health::DataStore::ReadTransaction::enumerateIdentifiersForObjectType(long long,std::function<void ()(health::DataStore::ObjectIdentifier)>)::$_0>(v11, (uint64_t)v17, a4, a5, a6);
    }
    else
    {
      health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(v17, (uint64_t)v11, a2, a3, v12);
      return (void *)health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateValuesInRange<health::DataStore::ReadTransaction::enumerateIdentifiersForObjectType(long long,std::function<void ()(health::DataStore::ObjectIdentifier)>)::$_0>(v11, (a2 + 1), v17, a4, a5, a6);
    }
  }
  return result;
}

void *health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_enumerateValuesInRange<health::DataStore::ReadTransaction::enumerateIdentifiersForObjectType(long long,std::function<void ()(health::DataStore::ObjectIdentifier)>)::$_0>(void *result, uint64_t a2, uint64_t a3, void *a4, uint64_t *a5)
{
  uint64_t v8 = result;
  unint64_t v9 = *(unsigned __int16 *)(a2 + 544);
  if (*(_WORD *)(a2 + 544))
  {
    unint64_t v11 = 0;
    while (1)
    {
      __n128 result = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v11);
      if (*result > *a4 || *result >= *a4 && result[1] >= a4[1]) {
        break;
      }
      if (++v11 >= *(unsigned __int16 *)(a2 + 544))
      {
        unint64_t v11 = v9;
        break;
      }
    }
    unsigned int v12 = *(unsigned __int16 *)(a2 + 544);
  }
  else
  {
    unsigned int v12 = 0;
    unint64_t v11 = 0;
  }
  if (v11 >= v12)
  {
LABEL_16:
    uint64_t v15 = *(void *)(a2 + 568);
    uint64_t v16 = *(void *)(a2 + 576);
    uint64_t v17 = v8[2];
    if (v15 != *(void *)v17 || v16 != *(void *)(v17 + 8))
    {
      bzero(v33, 0x222uLL);
      long long v35 = 0u;
      long long v36 = 0u;
      __n128 result = (void *)health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v17 + 16), v15, v16, (uint64_t)v33);
      if (v34)
      {
        unint64_t v18 = 0;
        unint64_t v19 = 0;
        uint64_t v20 = 0;
        while (1)
        {
          uint64_t v21 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v33, v18);
          __n128 result = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v33, v18);
          uint64_t v22 = *v21;
          if (v18 && v22 <= v20 && (v22 < v20 || v21[1] <= v19))
          {
            std::string::basic_string[abi:ne180100]<0>(v38, "key > lastKey");
            std::string::basic_string[abi:ne180100]<0>(v44, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(v43, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v42);
            health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v38, (uint64_t)v44, (uint64_t)v43, 382, (uint64_t)&v42);
          }
          if (v22 > *a5) {
            break;
          }
          unint64_t v19 = v21[1];
          if (v22 >= *a5 && v19 > a5[1]) {
            break;
          }
          __n128 result = (void *)std::function<void ()(health::DataStore::ObjectIdentifier)>::operator()(*(void *)(*(void *)a3 + 24), *v21, v21[1]);
          ++v18;
          uint64_t v20 = v22;
          if (v18 >= v34) {
            goto LABEL_36;
          }
        }
      }
      else
      {
        uint64_t v22 = 0;
        unint64_t v19 = 0;
LABEL_36:
        uint64_t v26 = *((void *)&v36 + 1);
        uint64_t v25 = v36;
LABEL_37:
        uint64_t v27 = v8[2];
        if (v25 != *(void *)v27 || v26 != *(void *)(v27 + 8))
        {
          bzero(v38, 0x222uLL);
          long long v40 = 0u;
          long long v41 = 0u;
          health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v27 + 16), v25, v26, (uint64_t)v38);
          if (!v39)
          {
            std::string::basic_string[abi:ne180100]<0>(v44, "leaf.valueCount > 0");
            std::string::basic_string[abi:ne180100]<0>(v43, "_enumerateLeaves");
            std::string::basic_string[abi:ne180100]<0>(&v42, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
            health::FormatString<>((std::string *)"Empty leaf encountered during enumeration.", &v37);
            health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v44, (uint64_t)v43, (uint64_t)&v42, 392, (uint64_t)&v37);
          }
          unint64_t v28 = 0;
          while (1)
          {
            uint64_t v29 = v22;
            unsigned __int8 v30 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v38, v28);
            __n128 result = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[]((uint64_t)v38, v28);
            uint64_t v22 = *v30;
            if (*v30 <= v29)
            {
              BOOL v31 = *v30 >= v29 && v30[1] > v19;
              unint64_t v19 = v30[1];
              if (!v31)
              {
                std::string::basic_string[abi:ne180100]<0>(v44, "key > lastKey");
                std::string::basic_string[abi:ne180100]<0>(v43, "_enumerateLeaves");
                std::string::basic_string[abi:ne180100]<0>(&v42, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
                health::FormatString<>((std::string *)"Out of order keys during btree enumeration.", &v37);
                health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v44, (uint64_t)v43, (uint64_t)&v42, 396, (uint64_t)&v37);
              }
            }
            else
            {
              unint64_t v19 = v30[1];
            }
            if (v22 > *a5) {
              break;
            }
            if (v22 >= *a5 && v19 > a5[1]) {
              break;
            }
            __n128 result = (void *)std::function<void ()(health::DataStore::ObjectIdentifier)>::operator()(*(void *)(*(void *)a3 + 24), *v30, v19);
            if (++v28 >= v39)
            {
              uint64_t v26 = *((void *)&v41 + 1);
              uint64_t v25 = v41;
              goto LABEL_37;
            }
          }
        }
      }
    }
  }
  else
  {
    while (1)
    {
      uint64_t v13 = (uint64_t *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v11);
      __n128 result = (void *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a2, v11);
      if (*v13 > *a5) {
        break;
      }
      if (*v13 >= *a5)
      {
        unint64_t v14 = v13[1];
        if (v14 > a5[1]) {
          return result;
        }
      }
      else
      {
        unint64_t v14 = v13[1];
      }
      __n128 result = (void *)std::function<void ()(health::DataStore::ObjectIdentifier)>::operator()(*(void *)(*(void *)a3 + 24), *v13, v14);
      if (++v11 >= *(unsigned __int16 *)(a2 + 544)) {
        goto LABEL_16;
      }
    }
  }
  return result;
}

void sub_1BD1CAF14(_Unwind_Exception *a1)
{
  if (SLOBYTE(STACK[0x25F]) < 0) {
    operator delete((void *)STACK[0x248]);
  }
  if (*(char *)(v1 - 129) < 0) {
    operator delete(*(void **)(v1 - 152));
  }
  if (*(char *)(v1 - 105) < 0) {
    operator delete(*(void **)(v1 - 128));
  }
  if (*(char *)(v1 - 81) < 0) {
    operator delete(*(void **)(v1 - 104));
  }
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(health::DataStore::ObjectIdentifier)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = a2;
  v4[1] = a3;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, void *))(*(void *)a1 + 48))(a1, v4);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_removeValueForKey(uint64_t a1, int a2, void *a3, uint64_t *a4, uint64_t a5)
{
  if (!*(_WORD *)(a5 + 544)) {
    return 2;
  }
  uint64_t v5 = (a2 + 1);
  if (*(unsigned char *)(a5 + 546)) {
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_removeValueForKeyWithLeafChildren(a1, v5, a3, a4, a5);
  }
  else {
    return health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_removeValueForKeyWithInteriorChildren(a1, v5, a3, a4, a5);
  }
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_removeValueForKeyWithLeafChildren(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, uint64_t a5)
{
  if (!*(_WORD *)(a5 + 544))
  {
    std::string::basic_string[abi:ne180100]<0>(v71, "node.childCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v70, "_removeValueForKeyWithLeafChildren");
    std::string::basic_string[abi:ne180100]<0>(v69, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Attempt to remove from empty interior node.", &v68);
    health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v71, (uint64_t)v70, (uint64_t)v69, 749, (uint64_t)&v68);
  }
  unint64_t v9 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a5, a3);
  uint64_t v10 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v9);
  unint64_t v12 = *(void *)(v10 + 16);
  unint64_t v11 = *(void *)(v10 + 24);
  uint64_t v13 = *(void *)(a1 + 16);
  bzero(v64, 0x222uLL);
  long long v66 = 0u;
  long long v67 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v13 + 24), v12, v11, (uint64_t)v64);
  unint64_t v14 = health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::indexForKey((uint64_t)v64, a3);
  if (HIDWORD(v14)) {
    return 2;
  }
  if ((unsigned __int16)v14 >= 0x11uLL)
  {
    uint64_t v15 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v72, "index < Length");
    std::string::basic_string[abi:ne180100]<0>(__p, "deleteElementAtIndex");
    std::string::basic_string[abi:ne180100]<0>(v77, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
    health::FormatString<>((std::string *)"Index out of bounds.", &v76);
    health::_HDAssertImplementation<std::out_of_range>(v15, (uint64_t)v72, (uint64_t)__p, (uint64_t)v77, 65, (uint64_t)&v76);
  }
  memmove(&v64[2 * (unsigned __int16)v14], &v64[2 * (unsigned __int16)v14 + 2], 512 - 32 * (unsigned __int16)v14);
  --v65;
  health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v12, v11, (uint64_t)v64);
  if (v65 >= 9u)
  {
    uint64_t v16 = (_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v9);
    if (*v16 != v64[0])
    {
      uint64_t v17 = (_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v9);
      *uint64_t v17 = v64[0];
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a4, a4[1], a5);
    }
LABEL_22:
    BOOL v29 = v9 == 0;
    return !v29;
  }
  if (!v65)
  {
    uint64_t v25 = *(void *)(a1 + 16);
    uint64_t v27 = *((void *)&v67 + 1);
    uint64_t v26 = v67;
    if (v67 != *(_OWORD *)v25)
    {
      bzero(v72, 0x222uLL);
      long long v73 = 0u;
      long long v74 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v25 + 24), v26, v27, (uint64_t)v72);
      long long v73 = v66;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v67, *((uint64_t *)&v67 + 1), (uint64_t)v72);
      uint64_t v25 = *(void *)(a1 + 16);
      uint64_t v26 = *(void *)v25;
    }
    long long v28 = v66;
    if (v66 != __PAIR128__(*(void *)(v25 + 8), v26))
    {
      bzero(v72, 0x222uLL);
      long long v73 = 0u;
      long long v74 = 0u;
      health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v25 + 24), v28, *((uint64_t *)&v28 + 1), (uint64_t)v72);
      long long v74 = v67;
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v66, *((uint64_t *)&v66 + 1), (uint64_t)v72);
      uint64_t v25 = *(void *)(a1 + 16);
    }
    health::BlockAccessFile::WriteTransaction::freeBlock(*(void *)(v25 + 24), v12, v11);
    health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::deleteElementAtIndex(a5, v9);
    --*(_WORD *)(a5 + 544);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a4, a4[1], a5);
    if (*(_WORD *)(a5 + 544)) {
      goto LABEL_22;
    }
    return 3;
  }
  unsigned int v19 = *(unsigned __int16 *)(a5 + 544);
  if (v19 < 2) {
    return 3;
  }
  uint64_t v56 = a4;
  unsigned int v20 = v19 - 1;
  unsigned __int16 v21 = v9 - (v20 == v9);
  BOOL v22 = v20 == v9;
  if (v20 == v9) {
    unsigned __int16 v23 = v9;
  }
  else {
    unsigned __int16 v23 = v9 + 1;
  }
  unsigned __int16 v52 = v23;
  unsigned __int16 v53 = v21;
  if (v22)
  {
    uint64_t v24 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v21);
    unint64_t v31 = v11;
    unint64_t v32 = v12;
    unint64_t v12 = *(void *)(v24 + 16);
    unint64_t v11 = *(void *)(v24 + 24);
    long long v33 = (uint64_t *)&v62;
    unsigned __int16 v34 = (uint64_t *)&v63;
    unint64_t v63 = v12;
    unint64_t v62 = v11;
    long long v35 = v72;
    long long v36 = (void **)v64;
  }
  else
  {
    unint64_t v63 = v12;
    unint64_t v62 = v11;
    uint64_t v30 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v23);
    unint64_t v32 = *(void *)(v30 + 16);
    unint64_t v31 = *(void *)(v30 + 24);
    long long v33 = (uint64_t *)&v60;
    unsigned __int16 v34 = (uint64_t *)&v61;
    long long v35 = (void **)v64;
    long long v36 = v72;
  }
  unint64_t v54 = v32;
  unint64_t v55 = v31;
  unint64_t v61 = v32;
  unint64_t v60 = v31;
  uint64_t v37 = *(void *)(a1 + 16);
  bzero(v72, 0x222uLL);
  long long v73 = 0u;
  long long v74 = 0u;
  health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v37 + 24), *v34, *v33, (uint64_t)v72);
  uint64_t v38 = *((unsigned __int16 *)v35 + 272);
  uint64_t v39 = *((unsigned __int16 *)v36 + 272);
  __int16 v40 = v39 + v38;
  if ((unsigned __int16)(v39 + v38) > 0x11u)
  {
    unsigned int v44 = v38 + v39 + 1;
    if (v38 <= v44 >> 1)
    {
      unsigned int v48 = v44 >> 1;
      unsigned int v49 = (unsigned __int16)(v48 - v38);
      uint64_t v50 = (unsigned __int16)(v48 - v38);
      health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v35, v38, (uint64_t)v36, 0, v50);
      if (v49 >= 0x12)
      {
        uint64_t v51 = *MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(__p, "startingIndex + count <= Length");
        std::string::basic_string[abi:ne180100]<0>(v77, "deleteElementsInRange");
        std::string::basic_string[abi:ne180100]<0>(&v76, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
        health::FormatString<>((std::string *)"Delete would overflow array bounds.", &v75);
        health::_HDAssertImplementation<std::out_of_range>(v51, (uint64_t)__p, (uint64_t)v77, (uint64_t)&v76, 72, (uint64_t)&v75);
      }
      memmove(v36, &v36[4 * v50], 544 - 32 * v50);
      *((_WORD *)v35 + 272) = v48;
      __int16 v47 = *((_WORD *)v36 + 272) - v50;
    }
    else
    {
      if ((unsigned __int16)(v38 - (v44 >> 1)) >= 0x12u)
      {
        uint64_t v45 = *MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(__p, "index + count <= Length");
        std::string::basic_string[abi:ne180100]<0>(v77, "insertSpaceForElementsAtIndex");
        std::string::basic_string[abi:ne180100]<0>(&v76, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
        health::FormatString<>((std::string *)"Array too small for requested space.", &v75);
        health::_HDAssertImplementation<std::out_of_range>(v45, (uint64_t)__p, (uint64_t)v77, (uint64_t)&v76, 87, (uint64_t)&v75);
      }
      uint64_t v46 = (unsigned __int16)(v38 - (v44 >> 1));
      memmove(&v36[4 * v46], v36, 544 - 32 * v46);
      health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v36, 0, (uint64_t)v35, *((unsigned __int16 *)v35 + 272) - v46, v46);
      *((_WORD *)v35 + 272) = v44 >> 1;
      __int16 v47 = *((_WORD *)v36 + 272) + v46;
    }
    *((_WORD *)v36 + 272) = v47;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v12, v11, (uint64_t)v35);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v54, v55, (uint64_t)v36);
    *(_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v53) = *(_OWORD *)v35;
    *(_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v52) = *(_OWORD *)v36;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *v56, v56[1], a5);
    BOOL v29 = v53 == 0;
    return !v29;
  }
  health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v35, v38, (uint64_t)v36, 0, v39);
  *((_WORD *)v35 + 272) = v40;
  *(_OWORD *)(v35 + 71) = *(_OWORD *)(v36 + 71);
  health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v12, v11, (uint64_t)v35);
  health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::deleteElementAtIndex(a5, v52);
  --*(_WORD *)(a5 + 544);
  *(_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v53) = *(_OWORD *)v35;
  health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *v56, v56[1], a5);
  uint64_t v41 = *(void *)(a1 + 16);
  uint64_t v42 = (uint64_t)v35[71];
  uint64_t v43 = (uint64_t)v35[72];
  if (v42 != *(void *)v41 || v43 != *(void *)(v41 + 8))
  {
    bzero(__p, 0x222uLL);
    long long v58 = 0u;
    long long v59 = 0u;
    health::BlockAccessFile::ReadTransaction::retrieveObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(uint64_t **)(v41 + 24), v42, v43, (uint64_t)__p);
    *(void *)&long long v58 = v12;
    *((void *)&v58 + 1) = v11;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v35[71], (uint64_t)v35[72], (uint64_t)__p);
    uint64_t v41 = *(void *)(a1 + 16);
  }
  health::BlockAccessFile::WriteTransaction::freeBlock(*(void *)(v41 + 24), v54, v55);
  if (*(unsigned __int16 *)(a5 + 544) >= 9u) {
    return 1;
  }
  else {
    return 3;
  }
}

void sub_1BD1CB8BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (*(char *)(v19 - 137) < 0) {
    operator delete(*(void **)(v19 - 160));
  }
  if (*(char *)(v19 - 113) < 0) {
    operator delete(*(void **)(v19 - 136));
  }
  if (*(char *)(v19 - 89) < 0) {
    operator delete(*(void **)(v19 - 112));
  }
  if (a19 < 0) {
    operator delete(a14);
  }
  _Unwind_Resume(a1);
}

uint64_t health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_removeValueForKeyWithInteriorChildren(uint64_t a1, int a2, void *a3, uint64_t *a4, uint64_t a5)
{
  if (!*(_WORD *)(a5 + 544))
  {
    std::string::basic_string[abi:ne180100]<0>(v56, "node.childCount > 0");
    std::string::basic_string[abi:ne180100]<0>(v55, "_removeValueForKeyWithInteriorChildren");
    std::string::basic_string[abi:ne180100]<0>(v54, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    health::FormatString<>((std::string *)"Attempt to remove from empty interior node.", &v53);
    health::_HDAssertImplementation<health::btree_access_error>((uint64_t)v56, (uint64_t)v55, (uint64_t)v54, 847, (uint64_t)&v53);
  }
  unsigned int v10 = health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::childForKey(a5, a3);
  unsigned int v11 = v10;
  long long v52 = *(_OWORD *)(health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v10)+ 16);
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(a1, a2, a5, v10, v51);
  uint64_t v12 = health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_removeValueForKey(a1, (a2 + 1), a3, &v52, v51);
  if (v12 <= 1)
  {
    uint64_t v13 = (_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v10);
    if (*v13 != v51[0])
    {
      unint64_t v14 = (_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v10);
      _OWORD *v14 = v51[0];
      health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a4, a4[1], a5);
    }
    BOOL v15 = v10 == 0;
    return !v15;
  }
  uint64_t v16 = v12;
  if (v12 == 2) {
    return v16;
  }
  if (v12 != 3)
  {
    uint64_t v17 = *MEMORY[0x1E4F29F18];
    std::string::basic_string[abi:ne180100]<0>(v50, "result == RemovalResult::MergeRequired");
    std::string::basic_string[abi:ne180100]<0>(v49, "_removeValueForKeyWithInteriorChildren");
    std::string::basic_string[abi:ne180100]<0>(v48, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/HDBPlusTree.hpp");
    LODWORD(v46[0]) = v16;
    health::FormatString<int>((std::string *)"Unexpected removal result {0} after handling non-merge cases.", (int *)v46, &__p);
    health::_HDAssertImplementation<std::logic_error>(v17, (uint64_t)v50, (uint64_t)v49, (uint64_t)v48, 871, (uint64_t)&__p);
  }
  int v18 = *(unsigned __int16 *)(a5 + 544) - 1;
  if (*(_WORD *)(a5 + 544) == 1) {
    return 3;
  }
  unsigned __int16 v19 = v10 - (v18 == v10);
  if (v18 != v10) {
    LOWORD(v10) = v10 + 1;
  }
  unsigned __int16 v45 = v10;
  if (v18 == v11)
  {
    uint64_t v20 = health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, (unsigned __int16)(v11 - (v18 == v11)));
    uint64_t v43 = *(void *)(v20 + 24);
    uint64_t v44 = *(void *)(v20 + 16);
    unsigned __int16 v21 = (unint64_t *)&v52;
    BOOL v22 = v46;
    unsigned __int16 v23 = (unsigned __int16 *)v51;
    unsigned __int16 v24 = v19;
  }
  else
  {
    uint64_t v43 = *((void *)&v52 + 1);
    uint64_t v44 = v52;
    unsigned __int16 v21 = (unint64_t *)(health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, (unsigned __int16)v10)+ 16);
    BOOL v22 = v51;
    unsigned __int16 v23 = (unsigned __int16 *)v46;
    unsigned __int16 v24 = v10;
  }
  unint64_t v26 = *v21;
  unint64_t v25 = v21[1];
  health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::_interiorChildAtIndex(a1, a2, a5, v24, v46);
  uint64_t v27 = *((unsigned __int16 *)v22 + 272);
  uint64_t v28 = v23[272];
  __int16 v29 = v28 + v27;
  if ((unsigned __int16)(v28 + v27) > 0x11u)
  {
    unsigned int v31 = v27 + v28 + 1;
    if (v27 <= v31 >> 1)
    {
      unsigned int v42 = v31 >> 1;
      int v36 = (v31 >> 1) - v27;
      unsigned int v37 = (unsigned __int16)((v31 >> 1) - v27);
      uint64_t v38 = (unsigned __int16)v36;
      health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v22, v27, (uint64_t)v23, 0, (unsigned __int16)v36);
      BOOL v39 = v37 >= 0x12;
      uint64_t v34 = v26;
      uint64_t v35 = v25;
      if (v39)
      {
        uint64_t v40 = *MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v60, "startingIndex + count <= Length");
        std::string::basic_string[abi:ne180100]<0>(v59, "deleteElementsInRange");
        std::string::basic_string[abi:ne180100]<0>(v58, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
        health::FormatString<>((std::string *)"Delete would overflow array bounds.", &v57);
        health::_HDAssertImplementation<std::out_of_range>(v40, (uint64_t)v60, (uint64_t)v59, (uint64_t)v58, 72, (uint64_t)&v57);
      }
      memmove(v23, &v23[16 * v38], 544 - 32 * v38);
      *((_WORD *)v22 + 272) = v42;
      unsigned __int16 v33 = v23[272] - v38;
    }
    else
    {
      if ((unsigned __int16)(v27 - (v31 >> 1)) >= 0x12u)
      {
        uint64_t v41 = *MEMORY[0x1E4F29F18];
        std::string::basic_string[abi:ne180100]<0>(v60, "index + count <= Length");
        std::string::basic_string[abi:ne180100]<0>(v59, "insertSpaceForElementsAtIndex");
        std::string::basic_string[abi:ne180100]<0>(v58, "/Library/Caches/com.apple.xbs/Sources/HealthKit/HealthKit/HealthDaemon/Database/Migration/HFDtoSQLite/HighFrequencyData/Utility/HDStaticArray.h");
        health::FormatString<>((std::string *)"Array too small for requested space.", &v57);
        health::_HDAssertImplementation<std::out_of_range>(v41, (uint64_t)v60, (uint64_t)v59, (uint64_t)v58, 87, (uint64_t)&v57);
      }
      uint64_t v32 = (unsigned __int16)(v27 - (v31 >> 1));
      memmove(&v23[16 * v32], v23, 544 - 32 * v32);
      health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v23, 0, (uint64_t)v22, *((unsigned __int16 *)v22 + 272) - v32, v32);
      *((_WORD *)v22 + 272) = v31 >> 1;
      unsigned __int16 v33 = v23[272] + v32;
      uint64_t v34 = v26;
      uint64_t v35 = v25;
    }
    v23[272] = v33;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v44, v43, (uint64_t)v22);
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v34, v35, (uint64_t)v23);
    *(_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v19) = *(_OWORD *)v22;
    *(_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v45) = *(_OWORD *)v23;
    health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a4, a4[1], a5);
    BOOL v15 = v19 == 0;
    return !v15;
  }
  health::StaticArray<health::bplustree::LeafNode<health::DataStore::ObjectIdentifier,health::BlockPointer,health::BlockPointer,17>::ValueEntry,17ul>::copyElementsFromArrayToIndex((uint64_t)v22, v27, (uint64_t)v23, 0, v28);
  *((_WORD *)v22 + 272) = v29;
  health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), v44, v43, (uint64_t)v22);
  health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::deleteElementAtIndex(a5, v45);
  --*(_WORD *)(a5 + 544);
  *(_OWORD *)health::StaticArray<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>::ChildEntry,17ul>::operator[](a5, v19) = *(_OWORD *)v22;
  health::BlockAccessFile::WriteTransaction::updateObject<health::bplustree::InteriorNode<health::DataStore::ObjectIdentifier,health::BlockPointer,17>>(*(void *)(*(void *)(a1 + 16) + 24), *a4, a4[1], a5);
  health::BlockAccessFile::WriteTransaction::freeBlock(*(void *)(*(void *)(a1 + 16) + 24), v26, v25);
  if (*(unsigned __int16 *)(a5 + 544) >= 9u) {
    return 1;
  }
  else {
    return 3;
  }
}

void sub_1BD1CC010(_Unwind_Exception *a1)
{
  if (*(char *)(v1 - 161) < 0) {
    operator delete(*(void **)(v1 - 184));
  }
  if (*(char *)(v1 - 137) < 0) {
    operator delete(*(void **)(v1 - 160));
  }
  if (*(char *)(v1 - 113) < 0) {
    operator delete(*(void **)(v1 - 136));
  }
  if (*(char *)(v1 - 89) < 0) {
    operator delete(*(void **)(v1 - 112));
  }
  _Unwind_Resume(a1);
}

void sub_1BD1CCD20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__169(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__169(uint64_t a1)
{
}

void sub_1BD1CD990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1CF4D0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1BD1D2258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t __Block_byref_object_copy__170(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__170(uint64_t a1)
{
}

void sub_1BD1D4038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose((const void *)(v63 - 208), 8);
  _Block_object_dispose(&STACK[0x260], 8);
  _Block_object_dispose(&STACK[0x290], 8);
  _Unwind_Resume(a1);
}

void sub_1BD1D49C4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1BD1D6AB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D6D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D6D88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id HDLocationSeriesDataEntityAllProperties(void)
{
  v2[12] = *MEMORY[0x1E4F143B8];
  v2[0] = @"series_identifier";
  v2[1] = @"timestamp";
  v2[2] = @"latitude";
  v2[3] = @"longitude";
  v2[4] = @"altitude";
  void v2[5] = @"speed";
  v2[6] = @"course";
  v2[7] = @"horizontal_accuracy";
  v2[8] = @"vertical_accuracy";
  v2[9] = @"speed_accuracy";
  v2[10] = @"course_accuracy";
  v2[11] = @"signal_environment";
  int v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:12];

  return v0;
}

void sub_1BD1D6EDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D713C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D71C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D73E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D74A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D75A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D7654(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D78D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D7B88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D7C54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D7D38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D7F48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D8130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D822C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D8360(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D843C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D8560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD1D8648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __cxx_global_array_dtor_3()
{
  uint64_t v0 = 0x24u;
  do
  {

    v0 -= 3;
  }
  while (v0 * 8);
}

BOOL HDCodableSampleOriginCollectionReadFrom(void *a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = objc_alloc_init(HDCodableDevice);
        [a1 addDevice:v17];
        if (!PBReaderPlaceMark() || (HDCodableDeviceReadFrom((uint64_t)v17, a2) & 1) == 0) {
          goto LABEL_30;
        }
LABEL_25:
        PBReaderRecallMark();

        goto LABEL_27;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_27:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    uint64_t v17 = objc_alloc_init(HDCodableContributor);
    [a1 addContributor:v17];
    if (!PBReaderPlaceMark() || (HDCodableContributorReadFrom((uint64_t)v17, a2) & 1) == 0)
    {
LABEL_30:

      return 0;
    }
    goto LABEL_25;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t _HDAddProfileAuthorizationTable(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = [a2 unprotectedDatabase];
  uint64_t v6 = [v5 executeUncachedSQL:@"CREATE TABLE IF NOT EXISTS profile_authorization (ROWID INTEGER PRIMARY KEY AUTOINCREMENT, source_bundle_id TEXT NOT NULL UNIQUE, status INTEGER NOT NULL, date_modified REAL NOT NULL)", a4 error] ^ 1;

  return v6;
}

uint64_t _HDAddCarePlanAndGoalRecordSamplesTables()
{
  return 0;
}

uint64_t _HDMovedCoverageOutOfFuture()
{
  return 0;
}

uint64_t _HDAddDeviceRecordSamplesTable_0()
{
  return 0;
}

uint64_t _HDAddMedicalHealthTable()
{
  return 0;
}

uint64_t _HDAddMedicalHealthConcreteRecordTables()
{
  return 0;
}

uint64_t _HDAddMedicalHealthLabResultTable()
{
  return 0;
}

uint64_t _HDAddEncounterRecordTable()
{
  return 0;
}

uint64_t HDRawQuantitySample::splitAtTime@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>, double a4@<D0>)
{
  double v5 = *(double *)result;
  double v4 = *(double *)(result + 8);
  double v6 = *(double *)(result + 16);
  uint64_t v7 = *(void *)(result + 24);
  char v8 = *(unsigned char *)(result + 32);
  char v9 = *(unsigned char *)(result + 33);
  double v10 = a4 - v4;
  double v11 = v6 - v4 - (a4 - v4);
  if (a2 != 1)
  {
    if (v11 < 0.01) {
      goto LABEL_6;
    }
    if (v10 >= 0.01)
    {
LABEL_9:
      double v17 = v5 * (v10 / (v6 - v4));
      char v15 = *(unsigned char *)(result + 32);
      double v14 = v5 - v17;
      double v5 = v17;
      double v16 = a4;
      goto LABEL_10;
    }
LABEL_8:
    char v15 = 0;
    a4 = *(double *)(result + 16);
    double v14 = *(double *)result;
    double v16 = *(double *)(result + 8);
LABEL_10:
    uint64_t v12 = *(void *)(result + 24);
    char v13 = *(unsigned char *)(result + 33);
    goto LABEL_11;
  }
  if (v10 < 0.01) {
    goto LABEL_8;
  }
  if (v11 >= 0.01) {
    goto LABEL_9;
  }
LABEL_6:
  uint64_t v12 = 0;
  char v13 = 0;
  double v14 = 0.0;
  a4 = *(double *)(result + 16);
  char v15 = *(unsigned char *)(result + 32);
  double v16 = 0.0;
  double v6 = 0.0;
  char v8 = 0;
LABEL_11:
  *(double *)a3 = v5;
  *(double *)(a3 + 8) = v4;
  *(double *)(a3 + 16) = a4;
  *(void *)(a3 + 24) = v7;
  *(unsigned char *)(a3 + 32) = v15;
  *(unsigned char *)(a3 + 33) = v9;
  *(_DWORD *)(a3 + 34) = *(_DWORD *)(result + 34);
  *(_WORD *)(a3 + 38) = *(_WORD *)(result + 38);
  *(double *)(a3 + 40) = v14;
  *(double *)(a3 + 48) = v16;
  *(double *)(a3 + 56) = v6;
  *(void *)(a3 + 64) = v12;
  *(unsigned char *)(a3 + 72) = v8;
  *(unsigned char *)(a3 + 73) = v13;
  return result;
}

double HDRawQuantitySample::splitAtTime(__n128 *a1, __n128 *a2, int a3, __n128 a4)
{
  double v5 = a1->n128_f64[1];
  double v4 = a1[1].n128_f64[0];
  double v6 = a4.n128_f64[0] - v5;
  double v7 = v4 - v5;
  double v8 = v7 - v6;
  if (a3 == 1)
  {
    if (v6 >= 0.01)
    {
      if (v8 >= 0.01) {
        goto LABEL_9;
      }
      goto LABEL_6;
    }
LABEL_8:
    a4 = *a1;
    __n128 v9 = a1[1];
    a2[2].n128_u16[0] = a1[2].n128_u16[0];
    *a2 = a4;
    a2[1] = v9;
    a1[2].n128_u8[0] = 0;
    return a4.n128_f64[0];
  }
  if (v8 >= 0.01)
  {
    if (v6 >= 0.01)
    {
LABEL_9:
      double v10 = v6 / v7 * a1->n128_f64[0];
      a2->n128_f64[0] = a1->n128_f64[0] - v10;
      a2->n128_u64[1] = a4.n128_u64[0];
      a2[1].n128_f64[0] = v4;
      a2[1].n128_u64[1] = a1[1].n128_u64[1];
      a2[2].n128_u16[0] = a1[2].n128_u16[0];
      a1->n128_f64[0] = v10;
      a1[1].n128_u64[0] = a4.n128_u64[0];
      return a4.n128_f64[0];
    }
    goto LABEL_8;
  }
LABEL_6:
  a2[2].n128_u8[0] = 0;
  return a4.n128_f64[0];
}

uint64_t HDRawQuantitySample::applyMask(uint64_t result, double **a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2 != *a2)
  {
    double v4 = *(double *)(result + 16);
    double v5 = *(double *)(result + 8);
    double v6 = v4 - v5;
    if (v4 - v5 >= 0.01)
    {
      double v7 = v3 + 1;
      double v8 = 0.0;
      do
      {
        __n128 v9 = v7 - 1;
        if (*v7 > v5)
        {
          double v10 = *v9;
          if (*v9 >= v4) {
            break;
          }
          if (v10 > v5)
          {
            if (v4 < v10) {
              __n128 v9 = (double *)(result + 16);
            }
            double v8 = v8 + *v9 - v5;
          }
          if (*v7 >= v4) {
            double v11 = (double *)(result + 16);
          }
          else {
            double v11 = v7;
          }
          double v5 = *v11;
        }
        uint64_t v12 = v7 + 1;
        v7 += 2;
      }
      while (v12 != v2);
      double v13 = v4 - v5;
      BOOL v14 = v5 < v4;
      double v15 = -0.0;
      if (v14) {
        double v15 = v13;
      }
      double v16 = v8 + v15;
      if (v16 <= 0.0) {
LABEL_24:
      }
        *(unsigned char *)(result + 32) = 0;
      else {
        *(double *)__n128 result = v16 * *(double *)result / v6;
      }
    }
    else
    {
      while (v5 >= *v3)
      {
        if (v5 < v3[1])
        {
          *(void *)__n128 result = 0;
          goto LABEL_24;
        }
        v3 += 2;
        if (v3 == v2) {
          return result;
        }
      }
    }
  }
  return result;
}

BOOL HDRawQuantitySample::operator==(uint64_t a1, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a2 + 32);
  if (!(*(unsigned __int8 *)(a1 + 32) | v2)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 32)) {
    BOOL v4 = v2 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  return !v4
      && *(unsigned __int8 *)(a1 + 33) == *(unsigned __int8 *)(a2 + 33)
      && *(double *)a1 == *(double *)a2
      && *(double *)(a1 + 8) == *(double *)(a2 + 8)
      && *(double *)(a1 + 16) == *(double *)(a2 + 16)
      && *(void *)(a1 + 24) == *(void *)(a2 + 24);
}

void sub_1BD1DB8A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__171(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__171(uint64_t a1)
{
}

void sub_1BD1DC13C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1BD1DFAF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  _Block_object_dispose(&a49, 8);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a61, 8);
  _Block_object_dispose((const void *)(v61 - 240), 8);
  _Block_object_dispose((const void *)(v61 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1BD1E1834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_1BD1E29F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1BD1E6298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose((const void *)(v29 - 176), 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1E7924(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1BD1E97F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1EB984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1ECB30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  uint64_t v19 = va_arg(va2, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va2, 8);
  _Unwind_Resume(a1);
}

uint64_t HDEntityCategoryForKeyValueCategory(unint64_t a1)
{
  if (a1 > 4) {
    return -1;
  }
  else {
    return qword_1BD340930[a1];
  }
}

uint64_t __Block_byref_object_copy__172(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__172(uint64_t a1)
{
}

void sub_1BD1EEF94(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1BD1EF494(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1F03C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1BD1F0B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD1F431C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__173(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__173(uint64_t a1)
{
}

void sub_1BD1F970C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BD1F9FA0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1BD1FA5D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__174(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__174(uint64_t a1)
{
}

uint64_t HDCodableHealthObjectReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  BOOL v4 = (int *)MEMORY[0x1E4F940E0];
  double v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  double v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 40;
        goto LABEL_26;
      case 2u:
        unsigned __int16 v21 = objc_alloc_init(HDCodableMetadataDictionary);
        objc_storeStrong((id *)(a1 + 24), v21);
        if PBReaderPlaceMark() && (HDCodableMetadataDictionaryReadFrom(v21, a2))
        {
          PBReaderRecallMark();

LABEL_43:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }

        return 0;
      case 3u:
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = 32;
LABEL_26:
        BOOL v22 = *(void **)(a1 + v19);
        *(void *)(a1 + v19) = v18;

        goto LABEL_43;
      case 4u:
        *(unsigned char *)(a1 + 48) |= 1u;
        uint64_t v23 = *v3;
        unint64_t v24 = *(void *)(a2 + v23);
        if (v24 <= 0xFFFFFFFFFFFFFFF7 && v24 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v25 = *(void *)(*(void *)(a2 + *v7) + v24);
          *(void *)(a2 + v23) = v24 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v25 = 0;
        }
        *(void *)(a1 + 8) = v25;
        goto LABEL_43;
      case 5u:
        char v26 = 0;
        unsigned int v27 = 0;
        uint64_t v28 = 0;
        *(unsigned char *)(a1 + 48) |= 2u;
        while (2)
        {
          uint64_t v29 = *v3;
          uint64_t v30 = *(void *)(a2 + v29);
          unint64_t v31 = v30 + 1;
          if (v30 == -1 || v31 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v32 = *(unsigned char *)(*(void *)(a2 + *v7) + v30);
            *(void *)(a2 + v29) = v31;
            v28 |= (unint64_t)(v32 & 0x7F) << v26;
            if (v32 < 0)
            {
              v26 += 7;
              BOOL v15 = v27++ >= 9;
              if (v15)
              {
                uint64_t v28 = 0;
                goto LABEL_40;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v28 = 0;
        }
LABEL_40:
        *(void *)(a1 + 16) = v28;
        goto LABEL_43;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_43;
    }
  }
}

void sub_1BD1FE334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1BD1FEF34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__175(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__175(uint64_t a1)
{
}

uint64_t HDCodableSleepScheduleReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  BOOL v4 = (int *)MEMORY[0x1E4F940E0];
  double v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    double v7 = off_1E62EF000;
    char v8 = &OBJC_IVAR___HDCodableCategoryDomainDictionary__domain;
    unsigned int v9 = (int *)MEMORY[0x1E4F940B8];
    unint64_t v10 = &OBJC_IVAR___HDCodableCategoryDomainDictionary__domain;
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v11 = 0;
      unsigned int v12 = 0;
      unint64_t v13 = 0;
      while (1)
      {
        uint64_t v14 = *v3;
        unint64_t v15 = *(void *)(a2 + v14);
        if (v15 == -1 || v15 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v16 = *(unsigned char *)(*(void *)(a2 + *v9) + v15);
        *(void *)(a2 + v14) = v15 + 1;
        v13 |= (unint64_t)(v16 & 0x7F) << v11;
        if ((v16 & 0x80) == 0) {
          goto LABEL_12;
        }
        v11 += 7;
        BOOL v17 = v12++ >= 9;
        if (v17)
        {
          unint64_t v13 = 0;
          int v18 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v18 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v13 = 0;
      }
LABEL_14:
      if (v18 || (v13 & 7) == 4) {
        break;
      }
      switch((v13 >> 3))
      {
        case 1u:
          uint64_t v20 = v8;
          unsigned __int16 v21 = v10;
          BOOL v22 = v7;
          id v23 = objc_alloc_init(v7[287]);
          objc_storeStrong((id *)(a1 + 48), v23);
          if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v23, a2))
          {
            PBReaderRecallMark();

            double v7 = v22;
            unint64_t v10 = v21;
            char v8 = v20;
            continue;
          }

          return 0;
        case 2u:
          char v24 = 0;
          unsigned int v25 = 0;
          uint64_t v26 = 0;
          *(_WORD *)(a1 + v8[939]) |= 0x40u;
          while (1)
          {
            uint64_t v27 = *v3;
            unint64_t v28 = *(void *)(a2 + v27);
            if (v28 == -1 || v28 >= *(void *)(a2 + *v4)) {
              break;
            }
            char v29 = *(unsigned char *)(*(void *)(a2 + *v9) + v28);
            *(void *)(a2 + v27) = v28 + 1;
            v26 |= (unint64_t)(v29 & 0x7F) << v24;
            if ((v29 & 0x80) == 0) {
              goto LABEL_109;
            }
            v24 += 7;
            BOOL v17 = v25++ >= 9;
            if (v17)
            {
              uint64_t v26 = 0;
              goto LABEL_111;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_109:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v26 = 0;
          }
LABEL_111:
          BOOL v93 = v26 != 0;
          uint64_t v94 = v10[940];
          goto LABEL_136;
        case 3u:
          char v30 = 0;
          unsigned int v31 = 0;
          uint64_t v32 = 0;
          *(_WORD *)(a1 + v8[939]) |= 0x400u;
          while (2)
          {
            uint64_t v33 = *v3;
            unint64_t v34 = *(void *)(a2 + v33);
            if (v34 == -1 || v34 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v35 = *(unsigned char *)(*(void *)(a2 + *v9) + v34);
              *(void *)(a2 + v33) = v34 + 1;
              v32 |= (unint64_t)(v35 & 0x7F) << v30;
              if (v35 < 0)
              {
                v30 += 7;
                BOOL v17 = v31++ >= 9;
                if (v17)
                {
                  uint64_t v32 = 0;
                  goto LABEL_115;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v32 = 0;
          }
LABEL_115:
          BOOL v93 = v32 != 0;
          uint64_t v94 = 61;
          goto LABEL_136;
        case 4u:
          char v36 = 0;
          unsigned int v37 = 0;
          uint64_t v38 = 0;
          *(_WORD *)(a1 + v8[939]) |= 0x800u;
          while (2)
          {
            uint64_t v39 = *v3;
            unint64_t v40 = *(void *)(a2 + v39);
            if (v40 == -1 || v40 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v41 = *(unsigned char *)(*(void *)(a2 + *v9) + v40);
              *(void *)(a2 + v39) = v40 + 1;
              v38 |= (unint64_t)(v41 & 0x7F) << v36;
              if (v41 < 0)
              {
                v36 += 7;
                BOOL v17 = v37++ >= 9;
                if (v17)
                {
                  uint64_t v38 = 0;
                  goto LABEL_119;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v38 = 0;
          }
LABEL_119:
          BOOL v93 = v38 != 0;
          uint64_t v94 = 62;
          goto LABEL_136;
        case 5u:
          char v42 = 0;
          unsigned int v43 = 0;
          uint64_t v44 = 0;
          *(_WORD *)(a1 + v8[939]) |= 0x200u;
          while (2)
          {
            uint64_t v45 = *v3;
            unint64_t v46 = *(void *)(a2 + v45);
            if (v46 == -1 || v46 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v47 = *(unsigned char *)(*(void *)(a2 + *v9) + v46);
              *(void *)(a2 + v45) = v46 + 1;
              v44 |= (unint64_t)(v47 & 0x7F) << v42;
              if (v47 < 0)
              {
                v42 += 7;
                BOOL v17 = v43++ >= 9;
                if (v17)
                {
                  uint64_t v44 = 0;
                  goto LABEL_123;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v44 = 0;
          }
LABEL_123:
          BOOL v93 = v44 != 0;
          uint64_t v94 = 60;
          goto LABEL_136;
        case 6u:
          char v48 = 0;
          unsigned int v49 = 0;
          uint64_t v50 = 0;
          *(_WORD *)(a1 + v8[939]) |= 0x20u;
          while (2)
          {
            uint64_t v51 = *v3;
            unint64_t v52 = *(void *)(a2 + v51);
            if (v52 == -1 || v52 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v53 = *(unsigned char *)(*(void *)(a2 + *v9) + v52);
              *(void *)(a2 + v51) = v52 + 1;
              v50 |= (unint64_t)(v53 & 0x7F) << v48;
              if (v53 < 0)
              {
                v48 += 7;
                BOOL v17 = v49++ >= 9;
                if (v17)
                {
                  uint64_t v50 = 0;
                  goto LABEL_127;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v50 = 0;
          }
LABEL_127:
          BOOL v93 = v50 != 0;
          uint64_t v94 = 56;
          goto LABEL_136;
        case 7u:
          char v54 = 0;
          unsigned int v55 = 0;
          uint64_t v56 = 0;
          *(_WORD *)(a1 + v8[939]) |= 0x80u;
          while (2)
          {
            uint64_t v57 = *v3;
            unint64_t v58 = *(void *)(a2 + v57);
            if (v58 == -1 || v58 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v59 = *(unsigned char *)(*(void *)(a2 + *v9) + v58);
              *(void *)(a2 + v57) = v58 + 1;
              v56 |= (unint64_t)(v59 & 0x7F) << v54;
              if (v59 < 0)
              {
                v54 += 7;
                BOOL v17 = v55++ >= 9;
                if (v17)
                {
                  uint64_t v56 = 0;
                  goto LABEL_131;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v56 = 0;
          }
LABEL_131:
          BOOL v93 = v56 != 0;
          uint64_t v94 = 58;
          goto LABEL_136;
        case 8u:
          char v60 = 0;
          unsigned int v61 = 0;
          uint64_t v62 = 0;
          *(_WORD *)(a1 + v8[939]) |= 0x100u;
          while (2)
          {
            uint64_t v63 = *v3;
            unint64_t v64 = *(void *)(a2 + v63);
            if (v64 == -1 || v64 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v65 = *(unsigned char *)(*(void *)(a2 + *v9) + v64);
              *(void *)(a2 + v63) = v64 + 1;
              v62 |= (unint64_t)(v65 & 0x7F) << v60;
              if (v65 < 0)
              {
                v60 += 7;
                BOOL v17 = v61++ >= 9;
                if (v17)
                {
                  uint64_t v62 = 0;
                  goto LABEL_135;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v62 = 0;
          }
LABEL_135:
          BOOL v93 = v62 != 0;
          uint64_t v94 = 59;
LABEL_136:
          *(unsigned char *)(a1 + v94) = v93;
          continue;
        case 9u:
          char v66 = 0;
          unsigned int v67 = 0;
          uint64_t v68 = 0;
          *(_WORD *)(a1 + v8[939]) |= 8u;
          while (2)
          {
            uint64_t v69 = *v3;
            unint64_t v70 = *(void *)(a2 + v69);
            if (v70 == -1 || v70 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v71 = *(unsigned char *)(*(void *)(a2 + *v9) + v70);
              *(void *)(a2 + v69) = v70 + 1;
              v68 |= (unint64_t)(v71 & 0x7F) << v66;
              if (v71 < 0)
              {
                v66 += 7;
                BOOL v17 = v67++ >= 9;
                if (v17)
                {
                  uint64_t v68 = 0;
                  goto LABEL_140;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v68 = 0;
          }
LABEL_140:
          uint64_t v95 = 32;
          goto LABEL_157;
        case 0xAu:
          char v72 = 0;
          unsigned int v73 = 0;
          uint64_t v68 = 0;
          *(_WORD *)(a1 + v8[939]) |= 0x10u;
          while (2)
          {
            uint64_t v74 = *v3;
            unint64_t v75 = *(void *)(a2 + v74);
            if (v75 == -1 || v75 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v76 = *(unsigned char *)(*(void *)(a2 + *v9) + v75);
              *(void *)(a2 + v74) = v75 + 1;
              v68 |= (unint64_t)(v76 & 0x7F) << v72;
              if (v76 < 0)
              {
                v72 += 7;
                BOOL v17 = v73++ >= 9;
                if (v17)
                {
                  uint64_t v68 = 0;
                  goto LABEL_144;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v68 = 0;
          }
LABEL_144:
          uint64_t v95 = 40;
          goto LABEL_157;
        case 0xBu:
          char v77 = 0;
          unsigned int v78 = 0;
          uint64_t v68 = 0;
          *(_WORD *)(a1 + v8[939]) |= 1u;
          while (2)
          {
            uint64_t v79 = *v3;
            unint64_t v80 = *(void *)(a2 + v79);
            if (v80 == -1 || v80 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v81 = *(unsigned char *)(*(void *)(a2 + *v9) + v80);
              *(void *)(a2 + v79) = v80 + 1;
              v68 |= (unint64_t)(v81 & 0x7F) << v77;
              if (v81 < 0)
              {
                v77 += 7;
                BOOL v17 = v78++ >= 9;
                if (v17)
                {
                  uint64_t v68 = 0;
                  goto LABEL_148;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v68 = 0;
          }
LABEL_148:
          uint64_t v95 = 8;
          goto LABEL_157;
        case 0xCu:
          char v82 = 0;
          unsigned int v83 = 0;
          uint64_t v68 = 0;
          *(_WORD *)(a1 + v8[939]) |= 2u;
          while (2)
          {
            uint64_t v84 = *v3;
            unint64_t v85 = *(void *)(a2 + v84);
            if (v85 == -1 || v85 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v86 = *(unsigned char *)(*(void *)(a2 + *v9) + v85);
              *(void *)(a2 + v84) = v85 + 1;
              v68 |= (unint64_t)(v86 & 0x7F) << v82;
              if (v86 < 0)
              {
                v82 += 7;
                BOOL v17 = v83++ >= 9;
                if (v17)
                {
                  uint64_t v68 = 0;
                  goto LABEL_152;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v68 = 0;
          }
LABEL_152:
          uint64_t v95 = 16;
          goto LABEL_157;
        case 0xEu:
          char v88 = 0;
          unsigned int v89 = 0;
          uint64_t v68 = 0;
          *(_WORD *)(a1 + v8[939]) |= 4u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v90 = *v3;
        unint64_t v91 = *(void *)(a2 + v90);
        if (v91 == -1 || v91 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v92 = *(unsigned char *)(*(void *)(a2 + *v9) + v91);
        *(void *)(a2 + v90) = v91 + 1;
        v68 |= (unint64_t)(v92 & 0x7F) << v88;
        if ((v92 & 0x80) == 0) {
          goto LABEL_154;
        }
        v88 += 7;
        BOOL v17 = v89++ >= 9;
        if (v17)
        {
          uint64_t v68 = 0;
          goto LABEL_156;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_154:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v68 = 0;
      }
LABEL_156:
      uint64_t v95 = 24;
LABEL_157:
      *(void *)(a1 + v95) = v68;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD2031AC(_Unwind_Exception *a1)
{
}

void sub_1BD203DDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v10 - 120), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__176(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__176(uint64_t a1)
{
}

void sub_1BD204A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD205AF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__177(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__177(uint64_t a1)
{
}

void sub_1BD205D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD20607C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2089C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD208B84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD208E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1BD2097FC(_Unwind_Exception *a1)
{
  operator delete(v2);
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(a1);
}

void sub_1BD209AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, ...)
{
  va_start(va, a8);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD209D40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD209E18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD20A008(_Unwind_Exception *a1)
{
  double v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1BD20A088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD20A1D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD20A44C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD20A8AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>>>::__deallocate_node(*(id **)(a1 + 16));
  int v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>>>::__deallocate_node(id *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      int v2 = (id *)*v1;
      std::deque<HDRawQuantitySample>::~deque[abi:ne180100]((uint64_t)(v1 + 3));

      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

uint64_t std::deque<HDRawQuantitySample>::~deque[abi:ne180100](uint64_t a1)
{
  int v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      int v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 51;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 102;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      double v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t **std::__hash_table<std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,std::__unordered_map_hasher<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringHash,HDStringEqual,true>,std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringEqual,HDStringHash,true>,std::allocator<std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>>>::find<NSString * {__strong}>(void *a1, id *a2)
{
  unint64_t v4 = [*a2 hash];
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  uint64_t v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (uint64_t i = *v10; i; uint64_t i = (uint64_t **)*i)
  {
    unint64_t v12 = (unint64_t)i[1];
    if (v12 == v6)
    {
      if (std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringEqual,HDStringHash,true>::operator()[abi:ne180100](i[2], *a2))return i; {
    }
      }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

uint64_t std::__unordered_map_equal<NSString * {__strong},std::__hash_value_type<NSString * {__strong},std::deque<HDRawQuantitySample>>,HDStringEqual,HDStringHash,true>::operator()[abi:ne180100](void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  int8x8_t v5 = v4;
  if (v3 == v4)
  {
    uint64_t v6 = 1;
  }
  else if (v4)
  {
    uint64_t v6 = [v3 isEqualToString:v4];
  }
  else
  {
    uint64_t v6 = 0;
  }

  return v6;
}

void sub_1BD20AC8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD20B014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t __Block_byref_object_copy__178(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__178(uint64_t a1)
{
}

unint64_t HDCurrentSyncVersionForSyncEntity(void *a1)
{
  if (objc_opt_respondsToSelector())
  {
    return [a1 currentSyncVersion];
  }
  else if (objc_opt_respondsToSelector())
  {
    return (unint64_t)[a1 supportedSyncVersionRange] >> 32;
  }
  else
  {
    return 0;
  }
}

uint64_t __Block_byref_object_copy__179(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__179(uint64_t a1)
{
}

void sub_1BD20C1A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1BD20C39C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD20D558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
}

void sub_1BD20E400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
}

uint64_t __Block_byref_object_copy__180(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__180(uint64_t a1)
{
}

void sub_1BD213804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

void sub_1BD214028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD214290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t _HDWorkoutSessionCanReplaceSession(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  int8x8_t v5 = [v3 startDate];

  uint64_t v6 = [v4 startDate];
  uint8x8_t v7 = (void *)v6;
  if (v5) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v6 == 0;
  }
  uint64_t v9 = v8;
  if (v5 && v6)
  {
    uint64_t v10 = [v4 startDate];
    char v11 = [v3 startDate];
    uint64_t v9 = objc_msgSend(v10, "hk_isAfterOrEqualToDate:", v11);
  }
  return v9;
}

void sub_1BD2166E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2168A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1BD2185A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2186BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD218BFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void sub_1BD218D64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD218F8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD219104(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD219218(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BD2192C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2198DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD21A7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1BD21ABAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1BD21ACB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD21ADAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__function::__value_func<BOOL ()(health::DataStore::WriteTransaction &)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1BD21AE74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD21AF64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD21B11C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL23_HDSortedMigrationStepsP7NSArrayIP23HDDatabaseMigrationStepE_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  uint64_t v6 = [v4 finalSchemaVersion];
  uint64_t v7 = [v5 finalSchemaVersion];
  if (v6 < v7) {
    uint64_t v8 = -1;
  }
  else {
    uint64_t v8 = v7 < v6;
  }

  return v8;
}

void sub_1BD21B264(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL23_HDSortedMigrationStepsP7NSArrayIP23HDDatabaseMigrationStepE_block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  uint64_t v6 = [v4 finalSchemaVersion];
  uint64_t v7 = [v5 finalSchemaVersion];
  if (v6 < v7) {
    uint64_t v8 = -1;
  }
  else {
    uint64_t v8 = v7 < v6;
  }

  return v8;
}

void sub_1BD21B2E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL23_HDSortedMigrationStepsP7NSArrayIP23HDDatabaseMigrationStepE_block_invoke_3(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 schemaName];

  if (v4) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = [v3 finalSchemaVersion] == *(void *)(a1 + 32);
  }

  return v5;
}

void sub_1BD21B35C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZZZ65__HDDatabaseMigrator_performHFDMigrationToVersion_handler_error__EUb_EUb0_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZZZ65__HDDatabaseMigrator_performHFDMigrationToVersion_handler_error__EUb_EUb0_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE7__cloneEv(uint64_t a1)
{
  int v2 = (char *)operator new(0x30uLL);
  *(void *)int v2 = &unk_1F1727EC0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZZZ65__HDDatabaseMigrator_performHFDMigrationToVersion_handler_error__EUb_EUb0_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE7__cloneEPNS0_6__baseIS9_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F1727EC0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL _ZNSt3__110__function6__funcIZZZ65__HDDatabaseMigrator_performHFDMigrationToVersion_handler_error__EUb_EUb0_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEEclES8_(uint64_t **a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  long long v26 = xmmword_1BD32D1F0;
  long long v28 = *(_OWORD *)(a2 + 32);
  uint64_t v29 = a2;
  v4.n128_f64[0] = health::bplustree::Tree<health::BlockAccessFile::ReadTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v28, &v26, 0, v30);
  if (!v31) {
    goto LABEL_10;
  }
  health::DataStore::ReadTransaction::_pointerForObject((health::DataStore::ReadTransaction *)a2, (ObjectIdentifier *)&v26, (uint64_t)&v28);
  if ((_BYTE)v29)
  {
    BOOL v5 = *(uint64_t **)(a2 + 24);
    uint64_t v6 = (uint64_t *)health::Optional<health::BlockPointer>::get((uint64_t)&v28);
    uint64_t v7 = *v6;
    uint64_t v8 = v6[1];
    uint64_t v32 = 0;
    unint64_t v33 = 8;
    v27.n128_u64[0] = (unint64_t)v30;
    v27.n128_u64[1] = 8;
    health::BlockAccessFile::ReadTransaction::retrieveBlock(v5, v7, v8, (uint64_t)&v27);
    uint64_t v9 = v32;
    if (v33 <= 0x3FF) {
      uint64_t v10 = (uint64_t *)v30;
    }
    else {
      uint64_t v10 = v32;
    }
    uint64_t v11 = *v10;
    uint64_t v32 = 0;
    if (v9) {
      MEMORY[0x1C187B880](v9, 0x1000C8077774924);
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  if (v11 >= *a1[1])
  {
    *a1[2] = 0;
    return 1;
  }
  else
  {
LABEL_10:
    *a1[2] = (*(uint64_t (**)(__n128))(*a1[3] + 16))(v4);
    uint64_t v12 = a1[1];
    long long v28 = *(_OWORD *)(a2 + 32);
    uint64_t v29 = a2 + 48;
    health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::valueForKey<health::DataStore::ObjectIdentifier>((uint64_t *)&v28, &v26, 0, v30);
    if (v31)
    {
      BOOL v13 = *(void *)(health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v30)
                      + 24) == 8;
      uint64_t v14 = health::Optional<health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::LookupResult>::operator->((uint64_t)v30);
      uint64_t v15 = (health::BlockAccessFile::WriteTransaction *)(a2 + 80);
      unint64_t v16 = *(void *)(v14 + 16);
      unint64_t v17 = *(void *)(v14 + 24);
      if (v13)
      {
        health::BlockAccessFile::WriteTransaction::updateObject<long>((uint64_t)v15, v16, v17, *v12);
      }
      else
      {
        health::BlockAccessFile::WriteTransaction::freeBlock((uint64_t)v15, v16, v17);
        unint64_t v23 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v15, 8);
        unint64_t v25 = v24;
        health::BlockAccessFile::WriteTransaction::updateObject<long>((uint64_t)v15, v23, v24, *v12);
        v27.n128_u64[0] = v23;
        v27.n128_u64[1] = v25;
        health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v28, (__n128 *)&v26, &v27);
      }
    }
    else
    {
      uint64_t v19 = (health::BlockAccessFile::WriteTransaction *)(a2 + 80);
      unint64_t v20 = health::BlockAccessFile::WriteTransaction::_requestBlockOfLength(v19, 8);
      unint64_t v22 = v21;
      health::BlockAccessFile::WriteTransaction::updateObject<long>((uint64_t)v19, v20, v21, *v12);
      v27.n128_u64[0] = v20;
      v27.n128_u64[1] = v22;
      health::bplustree::Tree<health::BlockAccessFile::WriteTransaction::BPlusTreeConfiguration<health::DataStore::ObjectIdentifier,health::BlockPointer>>::setValueForKey((uint64_t *)&v28, (__n128 *)&v26, &v27);
    }
    return *a1[2] == 0;
  }
}

void sub_1BD21B684(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x438];
  STACK[0x438] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

uint64_t _ZNKSt3__110__function6__funcIZZZ65__HDDatabaseMigrator_performHFDMigrationToVersion_handler_error__EUb_EUb0_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE6targetERKSt9type_info(uint64_t a1, uint64_t a2)
{
  if (std::type_info::operator==[abi:ne180100](a2, (uint64_t)&_ZTIZZZ65__HDDatabaseMigrator_performHFDMigrationToVersion_handler_error__EUb_EUb0_E3__0))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *_ZNKSt3__110__function6__funcIZZZ65__HDDatabaseMigrator_performHFDMigrationToVersion_handler_error__EUb_EUb0_E3__0NS_9allocatorIS2_EEFbRN6health9DataStore16WriteTransactionEEE11target_typeEv()
{
  return &_ZTIZZZ65__HDDatabaseMigrator_performHFDMigrationToVersion_handler_error__EUb_EUb0_E3__0;
}

uint64_t health::BlockAccessFile::WriteTransaction::updateObject<long>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = 0;
  unint64_t v13 = 8;
  v10[0] = v11;
  v10[1] = v11;
  std::locale v10[2] = 8;
  v9[0] = a4;
  health::SerializationBuffer::appendRaw<unsigned long long>((uint64_t)v10, v9);
  if (v13 <= 0x3FF) {
    uint64_t v7 = v11;
  }
  else {
    uint64_t v7 = v12;
  }
  health::RawBuffer::RawBuffer(v9, v7, v13);
  health::BlockAccessFile::WriteTransaction::updateBlock(a1, a2, a3, (uint64_t)v9);
  uint64_t result = (uint64_t)v12;
  uint64_t v12 = 0;
  if (result) {
    return MEMORY[0x1C187B880](result, 0x1000C8077774924);
  }
  return result;
}

void sub_1BD21B7E4(_Unwind_Exception *a1)
{
  unint64_t v2 = STACK[0x428];
  STACK[0x428] = 0;
  if (v2) {
    MEMORY[0x1C187B880](v2, 0x1000C8077774924);
  }
  _Unwind_Resume(a1);
}

BOOL HDCodableRoutineLocationVisitReadFrom(uint64_t a1, uint64_t a2)
{
  long long v3 = (int *)MEMORY[0x1E4F940E8];
  __n128 v4 = (int *)MEMORY[0x1E4F940E0];
  BOOL v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      if ((v10 >> 3) == 2) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        *(unsigned char *)(a1 + 24) |= 1u;
        uint64_t v18 = *v3;
        unint64_t v19 = *(void *)(a2 + v18);
        if (v19 <= 0xFFFFFFFFFFFFFFF7 && v19 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v20 = *(void *)(*(void *)(a2 + *v7) + v19);
          *(void *)(a2 + v18) = v19 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v20 = 0;
        }
        unint64_t v23 = &OBJC_IVAR___HDCodableRoutineLocationVisit__entryTime;
LABEL_32:
        *(void *)(a1 + *v23) = v20;
        goto LABEL_33;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_33:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    *(unsigned char *)(a1 + 24) |= 2u;
    uint64_t v21 = *v3;
    unint64_t v22 = *(void *)(a2 + v21);
    if (v22 <= 0xFFFFFFFFFFFFFFF7 && v22 + 8 <= *(void *)(a2 + *v4))
    {
      uint64_t v20 = *(void *)(*(void *)(a2 + *v7) + v22);
      *(void *)(a2 + v21) = v22 + 8;
    }
    else
    {
      *(unsigned char *)(a2 + *v5) = 1;
      uint64_t v20 = 0;
    }
    unint64_t v23 = &OBJC_IVAR___HDCodableRoutineLocationVisit__exitTime;
    goto LABEL_32;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD21C310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__181(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__181(uint64_t a1)
{
}

void sub_1BD21D17C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
}

void sub_1BD21F020(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_1BD21FAE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t __Block_byref_object_copy__182(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__182(uint64_t a1)
{
}

void sub_1BD221110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1BD221D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD22339C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__183(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__183(uint64_t a1)
{
}

id HDDoseEventUUIDsFromCodableObjectCollection(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  if ([v1 hasGeneratedObjectCollection])
  {
    id v16 = v1;
    long long v3 = [v1 generatedObjectCollection];
    __n128 v4 = [v3 medicationDoseEvents];

    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    id v5 = v4;
    uint64_t v6 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v6)
    {
      uint64_t v7 = v6;
      uint64_t v8 = *(void *)v18;
      do
      {
        for (uint64_t i = 0; i != v7; ++i)
        {
          if (*(void *)v18 != v8) {
            objc_enumerationMutation(v5);
          }
          unint64_t v10 = (void *)MEMORY[0x1E4F29128];
          uint64_t v11 = [*(id *)(*((void *)&v17 + 1) + 8 * i) sample];
          uint64_t v12 = [v11 object];
          unint64_t v13 = [v12 uuid];
          char v14 = objc_msgSend(v10, "hk_UUIDWithData:", v13);
          objc_msgSend(v2, "hk_addNonNilObject:", v14);
        }
        uint64_t v7 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
      }
      while (v7);
    }

    id v1 = v16;
  }

  return v2;
}

uint64_t statistics::QuantitySampleAttenuationEngineSample::QuantitySampleAttenuationEngineSample(uint64_t this)
{
  *(void *)this = &unk_1F1727F80;
  *(_DWORD *)(this + 44) = 0;
  return this;
}

{
  *(void *)this = &unk_1F1727F80;
  *(_DWORD *)(this + 44) = 0;
  return this;
}

void statistics::QuantitySampleAttenuationEngineSample::~QuantitySampleAttenuationEngineSample(statistics::QuantitySampleAttenuationEngineSample *this)
{
  PB::Base::~Base(this);

  JUMPOUT(0x1C187B8A0);
}

uint64_t statistics::QuantitySampleAttenuationEngineSample::QuantitySampleAttenuationEngineSample(uint64_t this, const statistics::QuantitySampleAttenuationEngineSample *a2)
{
  *(void *)this = &unk_1F1727F80;
  *(_DWORD *)(this + 44) = 0;
  char v2 = *((unsigned char *)a2 + 44);
  if ((v2 & 8) != 0)
  {
    uint64_t v4 = *((void *)a2 + 4);
    char v3 = 8;
    *(unsigned char *)(this + 44) = 8;
    *(void *)(this + 32) = v4;
    char v2 = *((unsigned char *)a2 + 44);
    if ((v2 & 1) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  char v3 = 0;
  if (*((unsigned char *)a2 + 44))
  {
LABEL_5:
    uint64_t v5 = *((void *)a2 + 1);
    v3 |= 1u;
    *(unsigned char *)(this + 44) = v3;
    *(void *)(this + 8) = v5;
    char v2 = *((unsigned char *)a2 + 44);
  }
LABEL_6:
  if ((v2 & 2) != 0)
  {
    uint64_t v6 = *((void *)a2 + 2);
    v3 |= 2u;
    *(unsigned char *)(this + 44) = v3;
    *(void *)(this + 16) = v6;
    char v2 = *((unsigned char *)a2 + 44);
    if ((v2 & 0x10) == 0)
    {
LABEL_8:
      if ((v2 & 4) == 0) {
        return this;
      }
LABEL_12:
      uint64_t v8 = *((void *)a2 + 3);
      *(unsigned char *)(this + 44) = v3 | 4;
      *(void *)(this + 24) = v8;
      return this;
    }
  }
  else if ((v2 & 0x10) == 0)
  {
    goto LABEL_8;
  }
  char v7 = *((unsigned char *)a2 + 40);
  v3 |= 0x10u;
  *(unsigned char *)(this + 44) = v3;
  *(unsigned char *)(this + 40) = v7;
  if ((*((unsigned char *)a2 + 44) & 4) != 0) {
    goto LABEL_12;
  }
  return this;
}

uint64_t statistics::QuantitySampleAttenuationEngineSample::operator=(uint64_t a1, const statistics::QuantitySampleAttenuationEngineSample *a2)
{
  if ((const statistics::QuantitySampleAttenuationEngineSample *)a1 != a2)
  {
    statistics::QuantitySampleAttenuationEngineSample::QuantitySampleAttenuationEngineSample((uint64_t)&v8, a2);
    int v3 = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 44) = v13;
    int v13 = v3;
    uint64_t v4 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v11;
    uint64_t v11 = v4;
    long long v5 = *(_OWORD *)(a1 + 8);
    *(_OWORD *)(a1 + 8) = v9;
    long long v9 = v5;
    LOBYTE(v3) = *(unsigned char *)(a1 + 40);
    *(unsigned char *)(a1 + 40) = v12;
    char v12 = v3;
    uint64_t v6 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v10;
    uint64_t v10 = v6;
    PB::Base::~Base((PB::Base *)&v8);
  }
  return a1;
}

double statistics::swap(statistics *this, statistics::QuantitySampleAttenuationEngineSample *a2, statistics::QuantitySampleAttenuationEngineSample *a3)
{
  int v3 = *((_DWORD *)this + 11);
  *((_DWORD *)this + 11) = *((_DWORD *)a2 + 11);
  *((_DWORD *)a2 + 11) = v3;
  uint64_t v4 = *((void *)this + 4);
  *((void *)this + 4) = *((void *)a2 + 4);
  *((void *)a2 + 4) = v4;
  uint64_t v5 = *((void *)this + 1);
  *((void *)this + 1) = *((void *)a2 + 1);
  *((void *)a2 + 1) = v5;
  double result = *((double *)this + 2);
  *((void *)this + 2) = *((void *)a2 + 2);
  *((double *)a2 + 2) = result;
  LOBYTE(v3) = *((unsigned char *)this + 40);
  *((unsigned char *)this + 40) = *((unsigned char *)a2 + 40);
  *((unsigned char *)a2 + 40) = v3;
  uint64_t v7 = *((void *)this + 3);
  *((void *)this + 3) = *((void *)a2 + 3);
  *((void *)a2 + 3) = v7;
  return result;
}

double statistics::QuantitySampleAttenuationEngineSample::QuantitySampleAttenuationEngineSample(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F1727F80;
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a2 + 44) = 0;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  double result = *(double *)(a2 + 16);
  *(double *)(a1 + 16) = result;
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  return result;
}

{
  double result;

  *(void *)a1 = &unk_1F1727F80;
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a2 + 44) = 0;
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  double result = *(double *)(a2 + 16);
  *(double *)(a1 + 16) = result;
  *(unsigned char *)(a1 + 40) = *(unsigned char *)(a2 + 40);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  return result;
}

uint64_t statistics::QuantitySampleAttenuationEngineSample::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v11 = &unk_1F1727F80;
    int v3 = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a2 + 44) = 0;
    uint64_t v4 = *(void *)(a2 + 32);
    char v5 = *(unsigned char *)(a2 + 40);
    uint64_t v6 = *(void *)(a2 + 24);
    int v16 = *(_DWORD *)(a1 + 44);
    uint64_t v14 = *(void *)(a1 + 32);
    long long v7 = *(_OWORD *)(a1 + 8);
    long long v8 = *(_OWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 44) = v3;
    *(void *)(a1 + 32) = v4;
    *(_OWORD *)(a1 + 8) = v8;
    long long v12 = v7;
    LOBYTE(v3) = *(unsigned char *)(a1 + 40);
    *(unsigned char *)(a1 + 40) = v5;
    char v15 = v3;
    uint64_t v9 = *(void *)(a1 + 24);
    *(void *)(a1 + 24) = v6;
    uint64_t v13 = v9;
    PB::Base::~Base((PB::Base *)&v11);
  }
  return a1;
}

uint64_t statistics::QuantitySampleAttenuationEngineSample::formatText(statistics::QuantitySampleAttenuationEngineSample *this, PB::TextFormatter *a2, const char *a3)
{
  PB::TextFormatter::beginObject(a2, a3);
  char v5 = *((unsigned char *)this + 44);
  if (v5)
  {
    PB::TextFormatter::format(a2, "endTime", *((double *)this + 1));
    char v5 = *((unsigned char *)this + 44);
    if ((v5 & 2) == 0)
    {
LABEL_3:
      if ((v5 & 0x10) == 0) {
        goto LABEL_4;
      }
      goto LABEL_12;
    }
  }
  else if ((*((unsigned char *)this + 44) & 2) == 0)
  {
    goto LABEL_3;
  }
  PB::TextFormatter::format(a2, "sampleValue", *((double *)this + 2));
  char v5 = *((unsigned char *)this + 44);
  if ((v5 & 0x10) == 0)
  {
LABEL_4:
    if ((v5 & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
LABEL_12:
  PB::TextFormatter::format(a2, "shouldContributeToCount");
  char v5 = *((unsigned char *)this + 44);
  if ((v5 & 4) == 0)
  {
LABEL_5:
    if ((v5 & 8) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_13:
  PB::TextFormatter::format(a2, "sourceID");
  if ((*((unsigned char *)this + 44) & 8) != 0) {
LABEL_6:
  }
    PB::TextFormatter::format(a2, "startTime", *((double *)this + 4));
LABEL_7:

  return MEMORY[0x1F4147498](a2);
}

uint64_t statistics::QuantitySampleAttenuationEngineSample::readFrom(statistics::QuantitySampleAttenuationEngineSample *this, PB::Reader *a2)
{
  unint64_t v2 = *((void *)a2 + 1);
  unint64_t v3 = *((void *)a2 + 2);
  int v4 = *((unsigned __int8 *)a2 + 24);
  if (v2 >= v3 || v4 != 0) {
    return v4 == 0;
  }
  while (1)
  {
    uint64_t v8 = *(void *)a2;
    if (v2 > 0xFFFFFFFFFFFFFFF5 || v2 + 10 > v3)
    {
      char v15 = 0;
      unsigned int v16 = 0;
      unint64_t v11 = 0;
      if (v2 > v3) {
        unint64_t v3 = v2;
      }
      do
      {
        if (v3 == v2)
        {
          int v4 = 1;
          *((unsigned char *)a2 + 24) = 1;
          return v4 == 0;
        }
        unint64_t v17 = v2 + 1;
        char v18 = *(unsigned char *)(v8 + v2);
        *((void *)a2 + 1) = v17;
        v11 |= (unint64_t)(v18 & 0x7F) << v15;
        if ((v18 & 0x80) == 0) {
          goto LABEL_21;
        }
        v15 += 7;
        unint64_t v2 = v17;
        BOOL v14 = v16++ > 8;
      }
      while (!v14);
LABEL_19:
      uint64_t result = PB::Reader::skip(a2);
      if (!result) {
        return result;
      }
      unint64_t v2 = *((void *)a2 + 1);
      goto LABEL_57;
    }
    char v9 = 0;
    unsigned int v10 = 0;
    unint64_t v11 = 0;
    while (1)
    {
      unint64_t v12 = v2 + 1;
      *((void *)a2 + 1) = v2 + 1;
      char v13 = *(unsigned char *)(v8 + v2);
      v11 |= (unint64_t)(v13 & 0x7F) << v9;
      if ((v13 & 0x80) == 0) {
        break;
      }
      v9 += 7;
      unint64_t v2 = v12;
      BOOL v14 = v10++ > 8;
      if (v14) {
        goto LABEL_19;
      }
    }
LABEL_21:
    if ((v11 & 7) == 4) {
      break;
    }
    switch((v11 >> 3))
    {
      case 1u:
        *((unsigned char *)this + 44) |= 8u;
        unint64_t v2 = *((void *)a2 + 1);
        if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > *((void *)a2 + 2)) {
          goto LABEL_31;
        }
        *((void *)this + 4) = *(void *)(*(void *)a2 + v2);
        goto LABEL_51;
      case 2u:
        *((unsigned char *)this + 44) |= 1u;
        unint64_t v2 = *((void *)a2 + 1);
        if (v2 > 0xFFFFFFFFFFFFFFF7 || v2 + 8 > *((void *)a2 + 2)) {
          goto LABEL_31;
        }
        *((void *)this + 1) = *(void *)(*(void *)a2 + v2);
        goto LABEL_51;
      case 3u:
        *((unsigned char *)this + 44) |= 2u;
        unint64_t v2 = *((void *)a2 + 1);
        if (v2 <= 0xFFFFFFFFFFFFFFF7 && v2 + 8 <= *((void *)a2 + 2))
        {
          *((void *)this + 2) = *(void *)(*(void *)a2 + v2);
LABEL_51:
          unint64_t v2 = *((void *)a2 + 1) + 8;
          *((void *)a2 + 1) = v2;
        }
        else
        {
LABEL_31:
          *((unsigned char *)a2 + 24) = 1;
        }
        break;
      case 4u:
        *((unsigned char *)this + 44) |= 0x10u;
        unint64_t v2 = *((void *)a2 + 1);
        if (v2 >= *((void *)a2 + 2))
        {
          BOOL v21 = 0;
          *((unsigned char *)a2 + 24) = 1;
        }
        else
        {
          int v20 = *(unsigned __int8 *)(*(void *)a2 + v2++);
          *((void *)a2 + 1) = v2;
          BOOL v21 = v20 != 0;
        }
        *((unsigned char *)this + 40) = v21;
        break;
      case 5u:
        *((unsigned char *)this + 44) |= 4u;
        unint64_t v22 = *((void *)a2 + 1);
        unint64_t v2 = *((void *)a2 + 2);
        uint64_t v23 = *(void *)a2;
        if (v22 > 0xFFFFFFFFFFFFFFF5 || v22 + 10 > v2)
        {
          char v28 = 0;
          unsigned int v29 = 0;
          uint64_t v26 = 0;
          if (v2 <= v22) {
            unint64_t v2 = *((void *)a2 + 1);
          }
          while (1)
          {
            if (v2 == v22)
            {
              uint64_t v26 = 0;
              *((unsigned char *)a2 + 24) = 1;
              goto LABEL_56;
            }
            unint64_t v30 = v22++;
            char v31 = *(unsigned char *)(v23 + v30);
            *((void *)a2 + 1) = v22;
            v26 |= (unint64_t)(v31 & 0x7F) << v28;
            if ((v31 & 0x80) == 0) {
              break;
            }
            v28 += 7;
            BOOL v14 = v29++ > 8;
            if (v14)
            {
              uint64_t v26 = 0;
LABEL_55:
              unint64_t v2 = v30 + 1;
              goto LABEL_56;
            }
          }
          if (*((unsigned char *)a2 + 24)) {
            uint64_t v26 = 0;
          }
          goto LABEL_55;
        }
        char v24 = 0;
        unsigned int v25 = 0;
        uint64_t v26 = 0;
        do
        {
          unint64_t v2 = v22 + 1;
          *((void *)a2 + 1) = v22 + 1;
          char v27 = *(unsigned char *)(v23 + v22);
          v26 |= (unint64_t)(v27 & 0x7F) << v24;
          if ((v27 & 0x80) == 0) {
            goto LABEL_56;
          }
          v24 += 7;
          unint64_t v22 = v2;
          BOOL v14 = v25++ > 8;
        }
        while (!v14);
        uint64_t v26 = 0;
LABEL_56:
        *((void *)this + 3) = v26;
        break;
      default:
        goto LABEL_19;
    }
LABEL_57:
    unint64_t v3 = *((void *)a2 + 2);
    int v4 = *((unsigned __int8 *)a2 + 24);
    if (v2 >= v3 || v4 != 0) {
      return v4 == 0;
    }
  }
  int v4 = 0;
  return v4 == 0;
}

uint64_t statistics::QuantitySampleAttenuationEngineSample::writeTo(uint64_t this, PB::Writer *a2)
{
  uint64_t v3 = this;
  char v4 = *(unsigned char *)(this + 44);
  if ((v4 & 8) != 0)
  {
    this = PB::Writer::write(a2, *(double *)(this + 32));
    char v4 = *(unsigned char *)(v3 + 44);
    if ((v4 & 1) == 0)
    {
LABEL_3:
      if ((v4 & 2) == 0) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else if ((*(unsigned char *)(this + 44) & 1) == 0)
  {
    goto LABEL_3;
  }
  this = PB::Writer::write(a2, *(double *)(v3 + 8));
  char v4 = *(unsigned char *)(v3 + 44);
  if ((v4 & 2) == 0)
  {
LABEL_4:
    if ((v4 & 0x10) == 0) {
      goto LABEL_5;
    }
LABEL_10:
    this = PB::Writer::write(a2);
    if ((*(unsigned char *)(v3 + 44) & 4) == 0) {
      return this;
    }
    goto LABEL_11;
  }
LABEL_9:
  this = PB::Writer::write(a2, *(double *)(v3 + 16));
  char v4 = *(unsigned char *)(v3 + 44);
  if ((v4 & 0x10) != 0) {
    goto LABEL_10;
  }
LABEL_5:
  if ((v4 & 4) == 0) {
    return this;
  }
LABEL_11:

  return PB::Writer::writeVarInt(a2);
}

BOOL statistics::QuantitySampleAttenuationEngineSample::operator==(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a1 + 44) & 8) != 0)
  {
    if ((*(unsigned char *)(a2 + 44) & 8) == 0 || *(double *)(a1 + 32) != *(double *)(a2 + 32)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a2 + 44) & 8) != 0)
  {
    return 0;
  }
  if (*(unsigned char *)(a1 + 44))
  {
    if ((*(unsigned char *)(a2 + 44) & 1) == 0 || *(double *)(a1 + 8) != *(double *)(a2 + 8)) {
      return 0;
    }
  }
  else if (*(unsigned char *)(a2 + 44))
  {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 44) & 2) != 0)
  {
    if ((*(unsigned char *)(a2 + 44) & 2) == 0 || *(double *)(a1 + 16) != *(double *)(a2 + 16)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a2 + 44) & 2) != 0)
  {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 44) & 0x10) != 0)
  {
    if ((*(unsigned char *)(a2 + 44) & 0x10) == 0 || *(unsigned __int8 *)(a1 + 40) != *(unsigned __int8 *)(a2 + 40)) {
      return 0;
    }
  }
  else if ((*(unsigned char *)(a2 + 44) & 0x10) != 0)
  {
    return 0;
  }
  BOOL v2 = (*(unsigned char *)(a2 + 44) & 4) == 0;
  if ((*(unsigned char *)(a1 + 44) & 4) != 0) {
    return (*(unsigned char *)(a2 + 44) & 4) != 0 && *(void *)(a1 + 24) == *(void *)(a2 + 24);
  }
  return v2;
}

uint64_t statistics::QuantitySampleAttenuationEngineSample::hash_value(statistics::QuantitySampleAttenuationEngineSample *this)
{
  if ((*((unsigned char *)this + 44) & 8) == 0)
  {
    double v1 = 0.0;
    if (*((unsigned char *)this + 44)) {
      goto LABEL_3;
    }
LABEL_14:
    double v2 = 0.0;
    if ((*((unsigned char *)this + 44) & 2) != 0) {
      goto LABEL_6;
    }
LABEL_15:
    double v3 = 0.0;
    if ((*((unsigned char *)this + 44) & 0x10) != 0) {
      goto LABEL_9;
    }
LABEL_16:
    uint64_t v4 = 0;
    if ((*((unsigned char *)this + 44) & 4) != 0) {
      goto LABEL_10;
    }
LABEL_17:
    uint64_t v5 = 0;
    return *(void *)&v2 ^ *(void *)&v1 ^ *(void *)&v3 ^ v4 ^ v5;
  }
  double v1 = *((double *)this + 4);
  if (v1 == 0.0) {
    double v1 = 0.0;
  }
  if ((*((unsigned char *)this + 44) & 1) == 0) {
    goto LABEL_14;
  }
LABEL_3:
  double v2 = *((double *)this + 1);
  if (v2 == 0.0) {
    double v2 = 0.0;
  }
  if ((*((unsigned char *)this + 44) & 2) == 0) {
    goto LABEL_15;
  }
LABEL_6:
  double v3 = *((double *)this + 2);
  if (v3 == 0.0) {
    double v3 = 0.0;
  }
  if ((*((unsigned char *)this + 44) & 0x10) == 0) {
    goto LABEL_16;
  }
LABEL_9:
  uint64_t v4 = *((unsigned __int8 *)this + 40);
  if ((*((unsigned char *)this + 44) & 4) == 0) {
    goto LABEL_17;
  }
LABEL_10:
  uint64_t v5 = *((void *)this + 3);
  return *(void *)&v2 ^ *(void *)&v1 ^ *(void *)&v3 ^ v4 ^ v5;
}

void sub_1BD227528(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
}

uint64_t __Block_byref_object_copy__184(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__184(uint64_t a1)
{
}

uint64_t HDCodableTinkerPairingRequestReadFrom(uint64_t a1, uint64_t a2)
{
  double v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 48;
          goto LABEL_42;
        case 2u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 24;
          goto LABEL_42;
        case 3u:
          char v20 = 0;
          unsigned int v21 = 0;
          uint64_t v22 = 0;
          *(unsigned char *)(a1 + 80) |= 2u;
          while (2)
          {
            uint64_t v23 = *v3;
            unint64_t v24 = *(void *)(a2 + v23);
            if (v24 == -1 || v24 >= *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v25 = *(unsigned char *)(*(void *)(a2 + *v7) + v24);
              *(void *)(a2 + v23) = v24 + 1;
              v22 |= (unint64_t)(v25 & 0x7F) << v20;
              if (v25 < 0)
              {
                v20 += 7;
                BOOL v14 = v21++ >= 9;
                if (v14)
                {
                  LODWORD(v22) = 0;
                  goto LABEL_48;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            LODWORD(v22) = 0;
          }
LABEL_48:
          *(_DWORD *)(a1 + 56) = v22;
          continue;
        case 4u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 16;
          goto LABEL_42;
        case 5u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 32;
          goto LABEL_42;
        case 6u:
          char v26 = 0;
          unsigned int v27 = 0;
          uint64_t v28 = 0;
          *(unsigned char *)(a1 + 80) |= 1u;
          break;
        case 7u:
          uint64_t v17 = PBReaderReadData();
          uint64_t v18 = 40;
          goto LABEL_42;
        case 8u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 64;
          goto LABEL_42;
        case 9u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 72;
LABEL_42:
          uint64_t v32 = *(void **)(a1 + v18);
          *(void *)(a1 + v18) = v17;

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v29 = *v3;
        unint64_t v30 = *(void *)(a2 + v29);
        if (v30 == -1 || v30 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v31 = *(unsigned char *)(*(void *)(a2 + *v7) + v30);
        *(void *)(a2 + v29) = v30 + 1;
        v28 |= (unint64_t)(v31 & 0x7F) << v26;
        if ((v31 & 0x80) == 0) {
          goto LABEL_50;
        }
        v26 += 7;
        BOOL v14 = v27++ >= 9;
        if (v14)
        {
          uint64_t v28 = 0;
          goto LABEL_52;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_50:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v28 = 0;
      }
LABEL_52:
      *(void *)(a1 + 8) = v28;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD22B2BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BD22F6AC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Unwind_Resume(a1);
}

void sub_1BD22FE04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2306A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__185(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__185(uint64_t a1)
{
}

id HDUserDomainConceptEntityPredicateForConceptsWithCreationDateBefore()
{
  uint64_t v0 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v1 = objc_msgSend(NSNumber, "numberWithDouble:");
  double v2 = [v0 predicateWithProperty:@"creation_date" lessThanValue:v1];

  return v2;
}

void sub_1BD230D74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDUserDomainConceptEntityPredicateForPropertyType(uint64_t a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F65D00];
  double v2 = [NSNumber numberWithInteger:a1];
  double v3 = [v1 predicateWithProperty:@"user_domain_concept_properties.property_type" equalToValue:v2];

  return v3;
}

uint64_t HDUserDomainConceptEntityPredicateForConceptUUID(uint64_t a1, int a2)
{
  if (a2) {
    uint64_t v2 = 1;
  }
  else {
    uint64_t v2 = 2;
  }
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"uuid" value:a1 comparisonType:v2];
}

void sub_1BD231924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD233250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
}

__CFString *HDStringFromUserDomainConceptEntityInsertMethod(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) >= 3)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%ld)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E630BCE0[a1 - 1];
  }

  return v1;
}

__CFString *HDStringFromUserDomainConceptEntityInsertResult(unint64_t a1)
{
  if (a1 >= 4)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%ld)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E630BCF8[a1];
  }

  return v1;
}

id HDUserDomainConceptEntityPredicateForConceptsWithTypeIdentifiers(void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v3 = v1;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v12;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        char v8 = HDUserDomainConceptEntityPredicateForConceptsWithTypeIdentifier(*(void **)(*((void *)&v11 + 1) + 8 * i));
        objc_msgSend(v2, "addObject:", v8, (void)v11);
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }

  unsigned int v9 = [MEMORY[0x1E4F65D08] predicateMatchingAnyPredicates:v2];

  return v9;
}

id HDUserDomainConceptEntityPredicateForConceptsWithTypeIdentifier(void *a1)
{
  void v13[2] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(v1, "code"));
  uint64_t v4 = [v2 predicateWithProperty:@"type" equalToValue:v3];

  uint64_t v5 = [v1 schema];
  if (v5)
  {
    uint64_t v6 = (void *)MEMORY[0x1E4F65D00];
    long long v7 = [v1 schema];
    char v8 = [v6 predicateWithProperty:@"schema" equalToValue:v7];
  }
  else
  {
    char v8 = [MEMORY[0x1E4F65D48] isNullPredicateWithProperty:@"schema"];
  }

  unsigned int v9 = (void *)MEMORY[0x1E4F65D08];
  v13[0] = v4;
  v13[1] = v8;
  uint64_t v10 = [MEMORY[0x1E4F1C978] arrayWithObjects:v13 count:2];
  long long v11 = [v9 predicateMatchingAllPredicates:v10];

  return v11;
}

uint64_t HDUserDomainConceptEntityPredicateForConceptUUIDs(uint64_t a1)
{
  return [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"uuid" values:a1];
}

id HDUserDomainConceptEntityPredicateForMedicalCoding(void *a1)
{
  void v13[2] = *MEMORY[0x1E4F143B8];
  id v1 = (void *)MEMORY[0x1E4F65D08];
  id v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = a1;
  uint64_t v4 = [v3 codingSystem];
  uint64_t v5 = [v4 identifier];
  uint64_t v6 = [v2 predicateWithProperty:@"medical_coding_system.string" equalToValue:v5];
  v13[0] = v6;
  long long v7 = (void *)MEMORY[0x1E4F65D00];
  char v8 = [v3 code];

  unsigned int v9 = [v7 predicateWithProperty:@"medical_coding_code.string" equalToValue:v8];
  v13[1] = v9;
  uint64_t v10 = [MEMORY[0x1E4F1C978] arrayWithObjects:v13 count:2];
  long long v11 = [v1 predicateMatchingAllPredicates:v10];

  return v11;
}

id HDUserDomainConceptEntityPredicateForMedicalCodingSystem(void *a1)
{
  id v1 = (void *)MEMORY[0x1E4F65D00];
  id v2 = [a1 identifier];
  id v3 = [v1 predicateWithProperty:@"medical_coding_system.string" equalToValue:v2];

  return v3;
}

id HDUserDomainConceptEntityPredicateWithCodingCollection(void *a1)
{
  id v1 = (void *)MEMORY[0x1E4F65D08];
  id v2 = [a1 codings];
  id v3 = objc_msgSend(v2, "hk_map:", &__block_literal_global_596);
  uint64_t v4 = [v1 predicateMatchingAllPredicates:v3];

  return v4;
}

id __HDUserDomainConceptEntityPredicateWithCodingCollection_block_invoke(uint64_t a1, void *a2)
{
  v10[1] = *MEMORY[0x1E4F143B8];
  id v2 = (objc_class *)MEMORY[0x1E4F65D68];
  id v3 = a2;
  id v4 = objc_alloc_init(v2);
  [v4 setEntityClass:objc_opt_class()];
  uint64_t v5 = HDUserDomainMedicalCodingEntityPredicateForCoding(v3);

  [v4 setPredicate:v5];
  uint64_t v6 = (void *)MEMORY[0x1E4F65D00];
  v10[0] = @"udc_id";
  long long v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v10 count:1];
  char v8 = [v6 predicateWithProperty:@"udc_id" comparisonType:7 subqueryDescriptor:v4 subqueryProperties:v7];

  return v8;
}

uint64_t HDUserDomainConceptEntityPredicateForConceptsWithAnchorAfter(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"sync_anchor" greaterThanValue:a1];
}

void sub_1BD2343E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _HDSyncAnchorPropertyForType(unint64_t a1)
{
  if (a1 >= 6)
  {
    id v2 = [MEMORY[0x1E4F28B00] currentHandler];
    id v3 = [NSString stringWithUTF8String:"NSString * _Nonnull _HDSyncAnchorPropertyForType(HDSyncAnchorType)"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"HDSyncAnchorEntity.m", 69, @"Invalid anchor type %ld", a1);
  }
}

void _HDSyncAnchorUpdateOptionsForType(unint64_t a1)
{
  if (a1 >= 6)
  {
    id v2 = [MEMORY[0x1E4F28B00] currentHandler];
    id v3 = [NSString stringWithUTF8String:"NSUInteger _HDSyncAnchorUpdateOptionsForType(HDSyncAnchorType)"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"HDSyncAnchorEntity.m", 93, @"Invalid anchor type %ld", a1);
  }
}

void _HDSyncAnchorUpdateDatePropertyForType(unint64_t a1)
{
  if (a1 >= 6)
  {
    id v2 = [MEMORY[0x1E4F28B00] currentHandler];
    id v3 = [NSString stringWithUTF8String:"NSString * _Nonnull _HDSyncAnchorUpdateDatePropertyForType(HDSyncAnchorType)"];
    objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", v3, @"HDSyncAnchorEntity.m", 81, @"Invalid anchor type %ld", a1);
  }
}

void sub_1BD236504(_Unwind_Exception *a1)
{
}

uint64_t __Block_byref_object_copy__186(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__186(uint64_t a1)
{
}

void sub_1BD2380AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
}

void sub_1BD238898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t HDCodableRacingClusterReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  long long v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    unint64_t v18 = v10 >> 3;
    switch((v10 >> 3))
    {
      case 1u:
        uint64_t v19 = PBReaderReadData();
        uint64_t v20 = 80;
        goto LABEL_46;
      case 2u:
        uint64_t v19 = PBReaderReadData();
        uint64_t v20 = 88;
        goto LABEL_46;
      case 3u:
        *(unsigned char *)(a1 + 100) |= 1u;
        uint64_t v23 = *v3;
        unint64_t v24 = *(void *)(a2 + v23);
        if (v24 <= 0xFFFFFFFFFFFFFFF7 && v24 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v25 = *(void *)(*(void *)(a2 + *v7) + v24);
          *(void *)(a2 + v23) = v24 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v25 = 0;
        }
        *(void *)(a1 + _Block_object_dispose(&STACK[0x418], 8) = v25;
        goto LABEL_78;
      case 4u:
        char v26 = 0;
        unsigned int v27 = 0;
        uint64_t v28 = 0;
        *(unsigned char *)(a1 + 100) |= 4u;
        while (2)
        {
          uint64_t v29 = *v3;
          uint64_t v30 = *(void *)(a2 + v29);
          unint64_t v31 = v30 + 1;
          if (v30 == -1 || v31 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v32 = *(unsigned char *)(*(void *)(a2 + *v7) + v30);
            *(void *)(a2 + v29) = v31;
            v28 |= (unint64_t)(v32 & 0x7F) << v26;
            if (v32 < 0)
            {
              v26 += 7;
              BOOL v15 = v27++ >= 9;
              if (v15)
              {
                LODWORD(v2_Block_object_dispose(&STACK[0x418], 8) = 0;
                goto LABEL_66;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v2_Block_object_dispose(&STACK[0x418], 8) = 0;
        }
LABEL_66:
        uint64_t v48 = 32;
        goto LABEL_71;
      case 5u:
        char v33 = 0;
        unsigned int v34 = 0;
        uint64_t v28 = 0;
        *(unsigned char *)(a1 + 100) |= 2u;
        while (2)
        {
          uint64_t v35 = *v3;
          uint64_t v36 = *(void *)(a2 + v35);
          unint64_t v37 = v36 + 1;
          if (v36 == -1 || v37 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v38 = *(unsigned char *)(*(void *)(a2 + *v7) + v36);
            *(void *)(a2 + v35) = v37;
            v28 |= (unint64_t)(v38 & 0x7F) << v33;
            if (v38 < 0)
            {
              v33 += 7;
              BOOL v15 = v34++ >= 9;
              if (v15)
              {
                LODWORD(v2_Block_object_dispose(&STACK[0x418], 8) = 0;
                goto LABEL_70;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          LODWORD(v2_Block_object_dispose(&STACK[0x418], 8) = 0;
        }
LABEL_70:
        uint64_t v48 = 16;
LABEL_71:
        *(_DWORD *)(a1 + v4_Block_object_dispose(&STACK[0x418], 8) = v28;
        goto LABEL_78;
      case 6u:
        uint64_t v19 = PBReaderReadData();
        uint64_t v20 = 64;
        goto LABEL_46;
      case 7u:
        uint64_t v19 = PBReaderReadString();
        uint64_t v20 = 56;
LABEL_46:
        uint64_t v39 = *(void **)(a1 + v20);
        *(void *)(a1 + v20) = v19;

        goto LABEL_78;
      case 8u:
        unsigned int v21 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 72), v21);
        if (!PBReaderPlaceMark() || !HDCodableSyncIdentityReadFrom((uint64_t)v21, a2)) {
          goto LABEL_80;
        }
        goto LABEL_54;
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        goto LABEL_24;
      case 0x14u:
        unsigned int v21 = objc_alloc_init(HDCodableRacingMetrics);
        uint64_t v40 = 48;
        goto LABEL_52;
      case 0x15u:
        unsigned int v21 = objc_alloc_init(HDCodableRacingMetrics);
        uint64_t v40 = 24;
LABEL_52:
        objc_storeStrong((id *)(a1 + v40), v21);
        if PBReaderPlaceMark() && (HDCodableRacingMetricsReadFrom((uint64_t)v21, a2))
        {
LABEL_54:
          PBReaderRecallMark();
LABEL_55:

LABEL_78:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_80:

        return 0;
      default:
        if (v18 == 30)
        {
          char v41 = 0;
          unsigned int v42 = 0;
          uint64_t v43 = 0;
          *(unsigned char *)(a1 + 100) |= 8u;
          while (1)
          {
            uint64_t v44 = *v3;
            uint64_t v45 = *(void *)(a2 + v44);
            unint64_t v46 = v45 + 1;
            if (v45 == -1 || v46 > *(void *)(a2 + *v4)) {
              break;
            }
            char v47 = *(unsigned char *)(*(void *)(a2 + *v7) + v45);
            *(void *)(a2 + v44) = v46;
            v43 |= (unint64_t)(v47 & 0x7F) << v41;
            if ((v47 & 0x80) == 0) {
              goto LABEL_73;
            }
            v41 += 7;
            BOOL v15 = v42++ >= 9;
            if (v15)
            {
              uint64_t v43 = 0;
              goto LABEL_75;
            }
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_73:
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v43 = 0;
          }
LABEL_75:
          *(unsigned char *)(a1 + 96) = v43 != 0;
        }
        else
        {
          if (v18 == 100)
          {
            PBReaderReadData();
            unsigned int v21 = (HDCodableSyncIdentity *)objc_claimAutoreleasedReturnValue();
            if (v21) {
              [(id)a1 addEligibleClusterUUIDs:v21];
            }
            goto LABEL_55;
          }
LABEL_24:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
        }
        goto LABEL_78;
    }
  }
}

void sub_1BD23ADB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD23B1C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

uint64_t __Block_byref_object_copy__187(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__187(uint64_t a1)
{
}

void sub_1BD23BDA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__188(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__188(uint64_t a1)
{
}

void sub_1BD23E174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
}

void sub_1BD23E4B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BD23F150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD240668(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD241C9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD242BB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BD244B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BD245148(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1BD245700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2 == 1)
  {
    id v13 = objc_begin_catch(exception_object);
    char v14 = objc_msgSend(MEMORY[0x1E4F28C58], "hk_error:format:", 3, @"%@");
    -[HDWorkoutSessionServer _queue_generateError:](v12, v14);
    id v15 = v14;
    int v16 = v15;
    if (v15) {
      v15;
    }

    objc_end_catch();
    JUMPOUT(0x1BD2453ECLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1BD245B2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1BD246080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t __Block_byref_object_copy__189(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__189(uint64_t a1)
{
}

void sub_1BD250240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
}

__CFString *HDDataAggregationRequestModeToString(uint64_t a1)
{
  if (a1 == 1)
  {
    id v2 = @"exclusive";
  }
  else if (a1)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"unknown(%ld)", a1);
    id v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v2 = @"inclusive";
  }
  return v2;
}

void sub_1BD253564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
}

void sub_1BD257090(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 184), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__190(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__190(uint64_t a1)
{
}

void sub_1BD25A5D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__191(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__191(uint64_t a1)
{
}

void sub_1BD25AC14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD25AE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD25B17C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD25BB00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a38, 8);
  _Block_object_dispose(&a42, 8);
  _Block_object_dispose(&a46, 8);
  _Block_object_dispose(&a50, 8);
  _Block_object_dispose(&a54, 8);
  _Block_object_dispose(&a60, 8);
  _Block_object_dispose(&a66, 8);
  _Block_object_dispose(&a72, 8);
  _Block_object_dispose(&STACK[0x228], 8);
  _Block_object_dispose((const void *)(v72 - 248), 8);
  _Block_object_dispose((const void *)(v72 - 200), 8);
  _Block_object_dispose((const void *)(v72 - 168), 8);
  _Unwind_Resume(a1);
}

void sub_1BD25C028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD25C76C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  _Block_object_dispose(&a44, 8);
  _Block_object_dispose((const void *)(v44 - 232), 8);
  _Block_object_dispose((const void *)(v44 - 200), 8);
  _Block_object_dispose((const void *)(v44 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1BD25EC3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__192(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__192(uint64_t a1)
{
}

void sub_1BD260844(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 248), 8);
  _Block_object_dispose((const void *)(v1 - 216), 8);
  _Block_object_dispose((const void *)(v1 - 184), 8);
  _Unwind_Resume(a1);
}

id HDLogicalOrderSourceEntityPredicateWithDataType(void *a1)
{
  uint64_t v1 = (void *)MEMORY[0x1E4F65D00];
  id v2 = objc_msgSend(NSNumber, "numberWithInteger:", objc_msgSend(a1, "code"));
  id v3 = [v1 predicateWithProperty:@"data_type" equalToValue:v2];

  return v3;
}

id HDLogicalOrderSourceEntityPredicateWithSourceIDs(uint64_t a1)
{
  uint64_t v1 = [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"sources.ROWID" values:a1];
  id v2 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"sources.deleted" notEqualToValue:MEMORY[0x1E4F1CC38]];
  id v3 = [MEMORY[0x1E4F65D58] compoundPredicateWithPredicate:v1 otherPredicate:v2];

  return v3;
}

uint64_t HDCodableSectionDataReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        uint64_t v12 = *(void *)(a2 + v11);
        unint64_t v13 = v12 + 1;
        if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
          break;
        }
        char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v13;
        v10 |= (unint64_t)(v14 & 0x7F) << v8;
        if ((v14 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v15 = v9++ >= 9;
        if (v15)
        {
          unint64_t v10 = 0;
          int v16 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v16 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v16 || (v10 & 7) == 4) {
        break;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v18 = PBReaderReadString();
          if (v18) {
            [(id)a1 addStringValues:v18];
          }

          continue;
        case 2u:
          char v20 = 0;
          unsigned int v21 = 0;
          uint64_t v22 = 0;
          *(unsigned char *)(a1 + 44) |= 1u;
          while (2)
          {
            uint64_t v23 = *v3;
            uint64_t v24 = *(void *)(a2 + v23);
            unint64_t v25 = v24 + 1;
            if (v24 == -1 || v25 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v24);
              *(void *)(a2 + v23) = v25;
              v22 |= (unint64_t)(v26 & 0x7F) << v20;
              if (v26 < 0)
              {
                v20 += 7;
                BOOL v15 = v21++ >= 9;
                if (v15)
                {
                  uint64_t v22 = 0;
                  goto LABEL_51;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v22 = 0;
          }
LABEL_51:
          uint64_t v43 = 8;
          goto LABEL_56;
        case 3u:
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v22 = 0;
          *(unsigned char *)(a1 + 44) |= 4u;
          while (2)
          {
            uint64_t v29 = *v3;
            uint64_t v30 = *(void *)(a2 + v29);
            unint64_t v31 = v30 + 1;
            if (v30 == -1 || v31 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v32 = *(unsigned char *)(*(void *)(a2 + *v7) + v30);
              *(void *)(a2 + v29) = v31;
              v22 |= (unint64_t)(v32 & 0x7F) << v27;
              if (v32 < 0)
              {
                v27 += 7;
                BOOL v15 = v28++ >= 9;
                if (v15)
                {
                  uint64_t v22 = 0;
                  goto LABEL_55;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v22 = 0;
          }
LABEL_55:
          uint64_t v43 = 24;
LABEL_56:
          *(void *)(a1 + v43) = v22;
          continue;
        case 4u:
          *(unsigned char *)(a1 + 44) |= 2u;
          uint64_t v33 = *v3;
          unint64_t v34 = *(void *)(a2 + v33);
          if (v34 <= 0xFFFFFFFFFFFFFFF7 && v34 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v35 = *(void *)(*(void *)(a2 + *v7) + v34);
            *(void *)(a2 + v33) = v34 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v35 = 0;
          }
          *(void *)(a1 + 16) = v35;
          continue;
        case 5u:
          char v36 = 0;
          unsigned int v37 = 0;
          uint64_t v38 = 0;
          *(unsigned char *)(a1 + 44) |= 8u;
          break;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v39 = *v3;
        uint64_t v40 = *(void *)(a2 + v39);
        unint64_t v41 = v40 + 1;
        if (v40 == -1 || v41 > *(void *)(a2 + *v4)) {
          break;
        }
        char v42 = *(unsigned char *)(*(void *)(a2 + *v7) + v40);
        *(void *)(a2 + v39) = v41;
        v38 |= (unint64_t)(v42 & 0x7F) << v36;
        if ((v42 & 0x80) == 0) {
          goto LABEL_58;
        }
        v36 += 7;
        BOOL v15 = v37++ >= 9;
        if (v15)
        {
          uint64_t v38 = 0;
          goto LABEL_60;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_58:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v38 = 0;
      }
LABEL_60:
      *(unsigned char *)(a1 + 40) = v38 != 0;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

uint64_t HDCodableMedicalIDMedicationReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      if ((v10 >> 3) == 1)
      {
        uint64_t v17 = PBReaderReadString();
        uint64_t v18 = *(void **)(a1 + 8);
        *(void *)(a1 + _Block_object_dispose(&STACK[0x418], 8) = v17;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

__CFString *HDStringFromHDHFDDatabaseFailureType(uint64_t a1)
{
  uint64_t v2 = a1 - 1;
  id v3 = @"corruption";
  switch(v2)
  {
    case 0:
      goto LABEL_37;
    case 1:
      id v3 = @"transactionError";
      break;
    case 2:
      id v3 = @"fileAccessError";
      break;
    case 3:
      id v3 = @"BTreeCorruption";
      break;
    case 4:
      id v3 = @"OutOfRangeError";
      break;
    case 5:
      id v3 = @"OtherException - historical";
      break;
    case 6:
      id v3 = @"logicError";
      break;
    case 7:
      id v3 = @"runtimeError";
      break;
    case 8:
      id v3 = @"ioException";
      break;
    case 9:
      id v3 = @"systemException";
      break;
    case 10:
      id v3 = @"notFoundError";
      break;
    default:
      if (@"corruption" == (__CFString *)100)
      {
        id v3 = @"unknownException";
      }
      else
      {
        objc_msgSend(NSString, "stringWithFormat:", @"Unknown failure type (%ld)", @"corruption");
        id v3 = (__CFString *)objc_claimAutoreleasedReturnValue();
LABEL_37:
      }
      break;
  }
  return v3;
}

void sub_1BD2641BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 144), 8);
  _Block_object_dispose((const void *)(v27 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__193(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__193(uint64_t a1)
{
}

void sub_1BD265360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,id location)
{
  objc_destroyWeak(v29);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1BD2665F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose((const void *)(v31 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__194(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__194(uint64_t a1)
{
}

void sub_1BD2701D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose((const void *)(v31 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__195(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__195(uint64_t a1)
{
}

void sub_1BD270CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD27260C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1BD272D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 112), 8);
  _Unwind_Resume(a1);
}

id HDSleepScheduleEntityPredicateForWeekday(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = (void *)MEMORY[0x1E4F65D00];
    uint64_t v2 = _PropertyForWeekday(a1);
    [v1 predicateWithProperty:v2 value:MEMORY[0x1E4F1CC38] comparisonType:1];
  }
  else
  {
    id v3 = HKSleepScheduleWeekdayArrayFromWeekdays();
    uint64_t v2 = objc_msgSend(v3, "hk_map:", &__block_literal_global_234);

    [MEMORY[0x1E4F65D08] predicateMatchingAllPredicates:v2];
  id v4 = };

  return v4;
}

__CFString *_PropertyForWeekday(uint64_t a1)
{
  if ((HKSleepScheduleWeekdaysIsSingleDay() & 1) == 0)
  {
    uint64_t v5 = [MEMORY[0x1E4F28B00] currentHandler];
    uint64_t v6 = [NSString stringWithUTF8String:"NSString * _Nullable _PropertyForWeekday(HKSleepScheduleWeekdays)"];
    objc_msgSend(v5, "handleFailureInFunction:file:lineNumber:description:", v6, @"HDSleepScheduleEntity.m", 171, @"Only one weekday can be converted to property: %ld", a1);
  }
  if (a1 > 15)
  {
    id v3 = @"saturday";
    id v4 = @"sunday";
    if (a1 != 64) {
      id v4 = 0;
    }
    if (a1 != 32) {
      id v3 = v4;
    }
    if (a1 == 16) {
      return @"friday";
    }
    else {
      return v3;
    }
  }
  else
  {
    uint64_t result = 0;
    switch(a1)
    {
      case 1:
        uint64_t result = @"monday";
        break;
      case 2:
        uint64_t result = @"tuesday";
        break;
      case 4:
        uint64_t result = @"wednesday";
        break;
      case 8:
        uint64_t result = @"thursday";
        break;
      default:
        return result;
    }
  }
  return result;
}

id __HDSleepScheduleEntityPredicateForWeekday_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = _PropertyForWeekday([a2 integerValue]);
  id v4 = [v2 predicateWithProperty:v3 value:MEMORY[0x1E4F1CC28] comparisonType:1];

  return v4;
}

id HDSleepScheduleEntityPredicateForWeekdayBeforeDate(uint64_t a1, void *a2)
{
  void v10[2] = *MEMORY[0x1E4F143B8];
  id v3 = (void *)MEMORY[0x1E4F65D08];
  id v4 = a2;
  uint64_t v5 = HDSleepScheduleEntityPredicateForWeekday(a1);
  v10[0] = v5;
  uint64_t v6 = HDSampleEntityPredicateForStartDate(3);

  v10[1] = v6;
  long long v7 = [MEMORY[0x1E4F1C978] arrayWithObjects:v10 count:2];
  char v8 = [v3 predicateMatchingAllPredicates:v7];

  return v8;
}

void sub_1BD279544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t _HDLocationSeriesIdentifierForHFDKeyV1()
{
  return 0;
}

uint64_t _HDLocationSeriesIdentifierForHFDKeyV2()
{
  return 3;
}

uint64_t _HDQuantitySampleSeriesIdentifierForHFDKeyV0()
{
  return 1;
}

uint64_t _HDQuantitySampleSeriesIdentifierForHFDKeyV1()
{
  return 2;
}

uint64_t _HDTemporarySampleHistoryIdentifierForPersistentID()
{
  return -1;
}

void *_HDSampleHistoryDescriptionForObjectType@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = std::string::basic_string[abi:ne180100]<0>(a2, "Unknown Series");
  switch(a1)
  {
    case 0:
      if (*((char *)result + 23) < 0)
      {
        result[1] = 20;
        uint64_t result = (void *)*result;
      }
      else
      {
        *((unsigned char *)result + 23) = 20;
      }
      *((_DWORD *)result + 4) = 691107368;
      id v4 = "Location Series (v1)";
      goto LABEL_19;
    case 1:
      if (*((char *)result + 23) < 0)
      {
        result[1] = 21;
        uint64_t result = (void *)*result;
      }
      else
      {
        *((unsigned char *)result + 23) = 21;
      }
      uint64_t v5 = "Quantity Samples (v0)";
      goto LABEL_16;
    case 2:
      if (*((char *)result + 23) < 0)
      {
        result[1] = 21;
        uint64_t result = (void *)*result;
      }
      else
      {
        *((unsigned char *)result + 23) = 21;
      }
      uint64_t v5 = "Quantity Samples (v1)";
LABEL_16:
      *(_OWORD *)uint64_t result = *(_OWORD *)v5;
      *(void *)((char *)result + 13) = *(void *)(v5 + 13);
      uint64_t v6 = (char *)result + 21;
      goto LABEL_20;
    case 3:
      if (*((char *)result + 23) < 0)
      {
        result[1] = 20;
        uint64_t result = (void *)*result;
      }
      else
      {
        *((unsigned char *)result + 23) = 20;
      }
      *((_DWORD *)result + 4) = 691172904;
      id v4 = "Location Series (v2)";
LABEL_19:
      *(_OWORD *)uint64_t result = *(_OWORD *)v4;
      uint64_t v6 = (char *)result + 20;
LABEL_20:
      *uint64_t v6 = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t HDCodableFitnessFriendWorkoutReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  uint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = off_1E62EF000;
    char v8 = &OBJC_IVAR___HDProfile__healthRecordsAccountExistenceNotifier;
    unsigned int v9 = &OBJC_IVAR___HDProfile__healthRecordsAccountExistenceNotifier;
    unint64_t v10 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v11 = 0;
      unsigned int v12 = 0;
      unint64_t v13 = 0;
      while (1)
      {
        uint64_t v14 = *v3;
        uint64_t v15 = *(void *)(a2 + v14);
        unint64_t v16 = v15 + 1;
        if (v15 == -1 || v16 > *(void *)(a2 + *v4)) {
          break;
        }
        char v17 = *(unsigned char *)(*(void *)(a2 + *v10) + v15);
        *(void *)(a2 + v14) = v16;
        v13 |= (unint64_t)(v17 & 0x7F) << v11;
        if ((v17 & 0x80) == 0) {
          goto LABEL_12;
        }
        v11 += 7;
        BOOL v18 = v12++ >= 9;
        if (v18)
        {
          unint64_t v13 = 0;
          int v19 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v19 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v13 = 0;
      }
LABEL_14:
      if (v19 || (v13 & 7) == 4) {
        break;
      }
      switch((v13 >> 3))
      {
        case 1u:
          unsigned int v21 = v9;
          uint64_t v22 = v8;
          uint64_t v23 = v7;
          id v24 = objc_alloc_init(v7[287]);
          objc_storeStrong((id *)(a1 + 120), v24);
          if PBReaderPlaceMark() && (HDCodableSampleReadFrom((uint64_t)v24, a2))
          {
            PBReaderRecallMark();

            long long v7 = v23;
            char v8 = v22;
            unsigned int v9 = v21;
            continue;
          }

          return 0;
        case 2u:
          uint64_t v25 = PBReaderReadData();
          uint64_t v26 = v8[292];
          goto LABEL_80;
        case 3u:
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v29 = 0;
          *(_WORD *)(a1 + v9[293]) |= 0x200u;
          while (2)
          {
            uint64_t v30 = *v3;
            uint64_t v31 = *(void *)(a2 + v30);
            unint64_t v32 = v31 + 1;
            if (v31 == -1 || v32 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v33 = *(unsigned char *)(*(void *)(a2 + *v10) + v31);
              *(void *)(a2 + v30) = v32;
              v29 |= (unint64_t)(v33 & 0x7F) << v27;
              if (v33 < 0)
              {
                v27 += 7;
                BOOL v18 = v28++ >= 9;
                if (v18)
                {
                  uint64_t v29 = 0;
                  goto LABEL_84;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v29 = 0;
          }
LABEL_84:
          uint64_t v71 = 80;
          goto LABEL_101;
        case 5u:
          *(_WORD *)(a1 + v9[293]) |= 2u;
          uint64_t v35 = *v3;
          unint64_t v36 = *(void *)(a2 + v35);
          if (v36 <= 0xFFFFFFFFFFFFFFF7 && v36 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v36);
            *(void *)(a2 + v35) = v36 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v37 = 0;
          }
          uint64_t v72 = 16;
          goto LABEL_112;
        case 6u:
          *(_WORD *)(a1 + v9[293]) |= 0x100u;
          uint64_t v38 = *v3;
          unint64_t v39 = *(void *)(a2 + v38);
          if (v39 <= 0xFFFFFFFFFFFFFFF7 && v39 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v39);
            *(void *)(a2 + v3_Block_object_dispose(&STACK[0x418], 8) = v39 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v37 = 0;
          }
          uint64_t v72 = 72;
          goto LABEL_112;
        case 7u:
          *(_WORD *)(a1 + v9[293]) |= 0x40u;
          uint64_t v40 = *v3;
          unint64_t v41 = *(void *)(a2 + v40);
          if (v41 <= 0xFFFFFFFFFFFFFFF7 && v41 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v41);
            *(void *)(a2 + v40) = v41 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v37 = 0;
          }
          uint64_t v72 = 56;
          goto LABEL_112;
        case 8u:
          *(_WORD *)(a1 + v9[293]) |= 0x80u;
          uint64_t v42 = *v3;
          unint64_t v43 = *(void *)(a2 + v42);
          if (v43 <= 0xFFFFFFFFFFFFFFF7 && v43 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v43);
            *(void *)(a2 + v42) = v43 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v37 = 0;
          }
          uint64_t v72 = 64;
          goto LABEL_112;
        case 9u:
          char v44 = 0;
          unsigned int v45 = 0;
          uint64_t v29 = 0;
          *(_WORD *)(a1 + v9[293]) |= 8u;
          while (2)
          {
            uint64_t v46 = *v3;
            uint64_t v47 = *(void *)(a2 + v46);
            unint64_t v48 = v47 + 1;
            if (v47 == -1 || v48 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v49 = *(unsigned char *)(*(void *)(a2 + *v10) + v47);
              *(void *)(a2 + v46) = v48;
              v29 |= (unint64_t)(v49 & 0x7F) << v44;
              if (v49 < 0)
              {
                v44 += 7;
                BOOL v18 = v45++ >= 9;
                if (v18)
                {
                  uint64_t v29 = 0;
                  goto LABEL_88;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v29 = 0;
          }
LABEL_88:
          uint64_t v71 = 32;
          goto LABEL_101;
        case 0xAu:
          *(_WORD *)(a1 + v9[293]) |= 4u;
          uint64_t v50 = *v3;
          unint64_t v51 = *(void *)(a2 + v50);
          if (v51 <= 0xFFFFFFFFFFFFFFF7 && v51 + 8 <= *(void *)(a2 + *v4))
          {
            uint64_t v37 = *(void *)(*(void *)(a2 + *v10) + v51);
            *(void *)(a2 + v50) = v51 + 8;
          }
          else
          {
            *(unsigned char *)(a2 + *v5) = 1;
            uint64_t v37 = 0;
          }
          uint64_t v72 = 24;
LABEL_112:
          *(void *)(a1 + v72) = v37;
          continue;
        case 0xBu:
          uint64_t v25 = PBReaderReadString();
          uint64_t v26 = 88;
          goto LABEL_80;
        case 0xCu:
          char v52 = 0;
          unsigned int v53 = 0;
          uint64_t v29 = 0;
          *(_WORD *)(a1 + v9[293]) |= 0x20u;
          while (2)
          {
            uint64_t v54 = *v3;
            uint64_t v55 = *(void *)(a2 + v54);
            unint64_t v56 = v55 + 1;
            if (v55 == -1 || v56 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v57 = *(unsigned char *)(*(void *)(a2 + *v10) + v55);
              *(void *)(a2 + v54) = v56;
              v29 |= (unint64_t)(v57 & 0x7F) << v52;
              if (v57 < 0)
              {
                v52 += 7;
                BOOL v18 = v53++ >= 9;
                if (v18)
                {
                  uint64_t v29 = 0;
                  goto LABEL_92;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v29 = 0;
          }
LABEL_92:
          uint64_t v71 = 48;
          goto LABEL_101;
        case 0xDu:
          char v58 = 0;
          unsigned int v59 = 0;
          uint64_t v29 = 0;
          *(_WORD *)(a1 + v9[293]) |= 0x10u;
          while (2)
          {
            uint64_t v60 = *v3;
            uint64_t v61 = *(void *)(a2 + v60);
            unint64_t v62 = v61 + 1;
            if (v61 == -1 || v62 > *(void *)(a2 + *v4))
            {
              *(unsigned char *)(a2 + *v5) = 1;
            }
            else
            {
              char v63 = *(unsigned char *)(*(void *)(a2 + *v10) + v61);
              *(void *)(a2 + v60) = v62;
              v29 |= (unint64_t)(v63 & 0x7F) << v58;
              if (v63 < 0)
              {
                v58 += 7;
                BOOL v18 = v59++ >= 9;
                if (v18)
                {
                  uint64_t v29 = 0;
                  goto LABEL_96;
                }
                continue;
              }
            }
            break;
          }
          if (*(unsigned char *)(a2 + *v5)) {
            uint64_t v29 = 0;
          }
LABEL_96:
          uint64_t v71 = 40;
          goto LABEL_101;
        case 0xEu:
          uint64_t v25 = PBReaderReadString();
          uint64_t v26 = 96;
          goto LABEL_80;
        case 0xFu:
          uint64_t v25 = PBReaderReadString();
          uint64_t v26 = 104;
          goto LABEL_80;
        case 0x10u:
          char v64 = 0;
          unsigned int v65 = 0;
          uint64_t v29 = 0;
          *(_WORD *)(a1 + v9[293]) |= 1u;
          break;
        case 0x11u:
          uint64_t v25 = PBReaderReadString();
          uint64_t v26 = 128;
          goto LABEL_80;
        case 0x12u:
          uint64_t v25 = PBReaderReadString();
          uint64_t v26 = 136;
LABEL_80:
          unint64_t v70 = *(void **)(a1 + v26);
          *(void *)(a1 + v26) = v25;

          continue;
        default:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
      }
      while (1)
      {
        uint64_t v66 = *v3;
        uint64_t v67 = *(void *)(a2 + v66);
        unint64_t v68 = v67 + 1;
        if (v67 == -1 || v68 > *(void *)(a2 + *v4)) {
          break;
        }
        char v69 = *(unsigned char *)(*(void *)(a2 + *v10) + v67);
        *(void *)(a2 + v66) = v68;
        v29 |= (unint64_t)(v69 & 0x7F) << v64;
        if ((v69 & 0x80) == 0) {
          goto LABEL_98;
        }
        v64 += 7;
        BOOL v18 = v65++ >= 9;
        if (v18)
        {
          uint64_t v29 = 0;
          goto LABEL_100;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_98:
      if (*(unsigned char *)(a2 + *v5)) {
        uint64_t v29 = 0;
      }
LABEL_100:
      uint64_t v71 = 8;
LABEL_101:
      *(void *)(a1 + v71) = v29;
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD27DB90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__196(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__196(uint64_t a1)
{
}

void sub_1BD27FB7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1BD280C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__197(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__197(uint64_t a1)
{
}

void sub_1BD281170(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1BD282CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
}

void sub_1BD286A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__198(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__198(uint64_t a1)
{
}

id HDSimpleGraphDatabaseNodeEntityPredicateForIdentifier(uint64_t a1, uint64_t a2)
{
  id v3 = (void *)MEMORY[0x1E4F65D00];
  id v4 = [NSNumber numberWithLongLong:a1];
  uint64_t v5 = [v3 predicateWithProperty:@"rowid" value:v4 comparisonType:a2];

  return v5;
}

uint64_t HDSimpleGraphDatabaseNodeEntityPredicateForIdentifiers(uint64_t a1)
{
  return [MEMORY[0x1E4F65D10] containsPredicateWithProperty:@"rowid" values:a1];
}

id HDSimpleGraphDatabaseNodeEntityPredicateForAttributeType(uint64_t a1, uint64_t a2)
{
  id v4 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v5 = +[HDSQLiteSchemaEntity disambiguatedSQLForProperty:@"attribute_type"];
  uint64_t v6 = [NSNumber numberWithLongLong:a1];
  long long v7 = [v4 predicateWithProperty:v5 value:v6 comparisonType:a2];

  return v7;
}

id HDSimpleGraphDatabaseNodeEntityPredicateForAttributeValue(void *a1, uint64_t a2)
{
  id v3 = (void *)MEMORY[0x1E4F65D00];
  id v4 = a1;
  uint64_t v5 = +[HDSQLiteSchemaEntity disambiguatedSQLForProperty:@"value"];
  uint64_t v6 = [v3 predicateWithProperty:v5 value:v4 comparisonType:a2];

  return v6;
}

id HDSimpleGraphDatabaseNodeEntityPredicateForAttribute(uint64_t a1, void *a2)
{
  id v3 = (void *)MEMORY[0x1E4F65D58];
  id v4 = a2;
  uint64_t v5 = HDSimpleGraphDatabaseNodeEntityPredicateForAttributeType(a1, 1);
  uint64_t v6 = HDSimpleGraphDatabaseNodeEntityPredicateForAttributeValue(v4, 1);

  long long v7 = [v3 compoundPredicateWithPredicate:v5 otherPredicate:v6];

  return v7;
}

id HDSimpleGraphDatabaseNodeEntityPredicateWithoutAttribute(uint64_t a1, void *a2)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  id v3 = (objc_class *)MEMORY[0x1E4F65D68];
  id v4 = a2;
  id v5 = objc_alloc_init(v3);
  [v5 setEntityClass:objc_opt_class()];
  uint64_t v6 = (void *)MEMORY[0x1E4F65D58];
  long long v7 = (void *)MEMORY[0x1E4F65D00];
  char v8 = [NSNumber numberWithLongLong:a1];
  unsigned int v9 = [v7 predicateWithProperty:@"attribute_type" equalToValue:v8];
  unint64_t v10 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"value" equalToValue:v4];

  char v11 = [v6 compoundPredicateWithPredicate:v9 otherPredicate:v10];
  [v5 setPredicate:v11];

  unsigned int v12 = (void *)MEMORY[0x1E4F65D00];
  v17[0] = @"node_id";
  unint64_t v13 = [MEMORY[0x1E4F1C978] arrayWithObjects:v17 count:1];
  uint64_t v14 = [v12 predicateWithProperty:@"rowid" comparisonType:7 subqueryDescriptor:v5 subqueryProperties:v13];

  uint64_t v15 = [MEMORY[0x1E4F65D08] negatedPredicate:v14];

  return v15;
}

id HDSimpleGraphDatabaseNodeEntityPredicateForNodesRelatedToSubjectID(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = +[HDSQLiteSchemaEntity disambiguatedSQLForProperty:@"subject_id"];
  id v4 = [NSNumber numberWithLongLong:a1];
  id v5 = [v2 predicateWithProperty:v3 equalToValue:v4];

  return v5;
}

id HDSimpleGraphDatabaseNodeEntityPredicateForNodesRelatedToObjectID(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = +[HDSQLiteSchemaEntity disambiguatedSQLForProperty:@"object_id"];
  id v4 = [NSNumber numberWithLongLong:a1];
  id v5 = [v2 predicateWithProperty:v3 equalToValue:v4];

  return v5;
}

id HDSimpleGraphDatabaseNodeEntityPredicateForNodesWithRelationshipType(uint64_t a1)
{
  uint64_t v2 = (void *)MEMORY[0x1E4F65D00];
  id v3 = +[HDSQLiteSchemaEntity disambiguatedSQLForProperty:@"relationship_type"];
  id v4 = [NSNumber numberWithLongLong:a1];
  id v5 = [v2 predicateWithProperty:v3 equalToValue:v4];

  return v5;
}

BOOL HDCodableClinicalContactReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      switch((v10 >> 3))
      {
        case 1u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 8;
          goto LABEL_27;
        case 2u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 16;
          goto LABEL_27;
        case 3u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 24;
          goto LABEL_27;
        case 4u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 32;
          goto LABEL_27;
        case 5u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 40;
          goto LABEL_27;
        case 6u:
          uint64_t v17 = PBReaderReadString();
          uint64_t v18 = 48;
LABEL_27:
          int v19 = *(void **)(a1 + v18);
          *(void *)(a1 + v1_Block_object_dispose(&STACK[0x418], 8) = v17;

          goto LABEL_28;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
LABEL_28:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          break;
      }
    }
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

__CFString *HKStringFromStateSyncMergeResult(unint64_t a1)
{
  if (a1 >= 4)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Unknown (%d)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E630D8D8[a1];
  }

  return v1;
}

BOOL HDCodableWorkoutZonesAssociationReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3) {
        break;
      }
      if (v17 == 2)
      {
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 24;
LABEL_26:
        char v20 = *(HDCodableSyncIdentity **)(a1 + v19);
        *(void *)(a1 + v19) = v18;
LABEL_27:

        goto LABEL_29;
      }
      if (v17 == 1)
      {
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 16;
        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_29:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    char v20 = objc_alloc_init(HDCodableSyncIdentity);
    objc_storeStrong((id *)(a1 + 8), v20);
    if (!PBReaderPlaceMark() || !HDCodableSyncIdentityReadFrom((uint64_t)v20, a2))
    {

      return 0;
    }
    PBReaderRecallMark();
    goto LABEL_27;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD28D73C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__199(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__199(uint64_t a1)
{
}

void sub_1BD28E140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_1BD290828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
}

__CFString *NSStringFromHDProtectedDataOperationState(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) >= 8)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"HDProtectedDataOperationStateUnknown-%ld", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E630DAE8[a1 - 1];
  }

  return v1;
}

uint64_t HDCodableAuthorizationRequestMessageReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    long long v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      int v16 = v10 & 7;
      if (v15 || v16 == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v18 = v10 >> 3;
      if ((int)(v10 >> 3) > 9)
      {
        if (v18 == 10)
        {
          if (v16 != 2)
          {
            char v41 = 0;
            unsigned int v42 = 0;
            uint64_t v43 = 0;
            while (1)
            {
              uint64_t v44 = *v3;
              unint64_t v45 = *(void *)(a2 + v44);
              if (v45 == -1 || v45 >= *(void *)(a2 + *v4)) {
                goto LABEL_69;
              }
              char v46 = *(unsigned char *)(*(void *)(a2 + *v7) + v45);
              *(void *)(a2 + v44) = v45 + 1;
              v43 |= (unint64_t)(v46 & 0x7F) << v41;
              if (v46 < 0)
              {
                v41 += 7;
                BOOL v14 = v42++ >= 9;
                if (!v14) {
                  continue;
                }
              }
              goto LABEL_70;
            }
          }
          uint64_t result = PBReaderPlaceMark();
          if (!result) {
            return result;
          }
          while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4) && !*(unsigned char *)(a2 + *v5))
          {
            char v29 = 0;
            unsigned int v30 = 0;
            uint64_t v31 = 0;
            while (1)
            {
              uint64_t v32 = *v3;
              unint64_t v33 = *(void *)(a2 + v32);
              if (v33 == -1 || v33 >= *(void *)(a2 + *v4)) {
                break;
              }
              char v34 = *(unsigned char *)(*(void *)(a2 + *v7) + v33);
              *(void *)(a2 + v32) = v33 + 1;
              v31 |= (unint64_t)(v34 & 0x7F) << v29;
              if (v34 < 0)
              {
                v29 += 7;
                BOOL v14 = v30++ >= 9;
                if (!v14) {
                  continue;
                }
              }
              goto LABEL_51;
            }
            *(unsigned char *)(a2 + *v5) = 1;
LABEL_51:
            PBRepeatedInt64Add();
          }
          goto LABEL_54;
        }
        if (v18 == 11)
        {
          if (v16 != 2)
          {
            char v35 = 0;
            unsigned int v36 = 0;
            uint64_t v37 = 0;
            while (1)
            {
              uint64_t v38 = *v3;
              unint64_t v39 = *(void *)(a2 + v38);
              if (v39 == -1 || v39 >= *(void *)(a2 + *v4)) {
                break;
              }
              char v40 = *(unsigned char *)(*(void *)(a2 + *v7) + v39);
              *(void *)(a2 + v3_Block_object_dispose(&STACK[0x418], 8) = v39 + 1;
              v37 |= (unint64_t)(v40 & 0x7F) << v35;
              if (v40 < 0)
              {
                v35 += 7;
                BOOL v14 = v36++ >= 9;
                if (!v14) {
                  continue;
                }
              }
              goto LABEL_70;
            }
LABEL_69:
            *(unsigned char *)(a2 + *v5) = 1;
LABEL_70:
            PBRepeatedInt64Add();
            continue;
          }
          uint64_t result = PBReaderPlaceMark();
          if (!result) {
            return result;
          }
          while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4) && !*(unsigned char *)(a2 + *v5))
          {
            char v22 = 0;
            unsigned int v23 = 0;
            uint64_t v24 = 0;
            while (1)
            {
              uint64_t v25 = *v3;
              unint64_t v26 = *(void *)(a2 + v25);
              if (v26 == -1 || v26 >= *(void *)(a2 + *v4)) {
                break;
              }
              char v27 = *(unsigned char *)(*(void *)(a2 + *v7) + v26);
              *(void *)(a2 + v25) = v26 + 1;
              v24 |= (unint64_t)(v27 & 0x7F) << v22;
              if (v27 < 0)
              {
                v22 += 7;
                BOOL v14 = v23++ >= 9;
                if (!v14) {
                  continue;
                }
              }
              goto LABEL_36;
            }
            *(unsigned char *)(a2 + *v5) = 1;
LABEL_36:
            PBRepeatedInt64Add();
          }
LABEL_54:
          PBReaderRecallMark();
          continue;
        }
      }
      else
      {
        if (v18 == 1)
        {
          uint64_t v19 = PBReaderReadString();
          uint64_t v20 = 56;
          goto LABEL_38;
        }
        if (v18 == 2)
        {
          uint64_t v19 = PBReaderReadData();
          uint64_t v20 = 64;
LABEL_38:
          unsigned int v28 = *(void **)(a1 + v20);
          *(void *)(a1 + v20) = v19;

          continue;
        }
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD295C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t __Block_byref_object_copy__200(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__200(uint64_t a1)
{
}

HDKeyValueDomain *HDMirroredWorkoutSessionKeyValueDomainWithProfile(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [[HDKeyValueDomain alloc] initWithCategory:0 domainName:@"MirroredWorkoutSession" profile:v1];

  return v2;
}

uint64_t HDCodableWorkoutSessionGlobalStateReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  id v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  long long v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        int v16 = *(unsigned __int8 *)(a2 + *v5);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    int v16 = *(unsigned __int8 *)(a2 + *v5);
    if (*(unsigned char *)(a2 + *v5)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    if (v16 || (v10 & 7) == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 72) |= 2u;
        while (1)
        {
          uint64_t v21 = *v3;
          uint64_t v22 = *(void *)(a2 + v21);
          unint64_t v23 = v22 + 1;
          if (v22 == -1 || v23 > *(void *)(a2 + *v4)) {
            break;
          }
          char v24 = *(unsigned char *)(*(void *)(a2 + *v7) + v22);
          *(void *)(a2 + v21) = v23;
          v20 |= (unint64_t)(v24 & 0x7F) << v18;
          if ((v24 & 0x80) == 0) {
            goto LABEL_54;
          }
          v18 += 7;
          BOOL v15 = v19++ >= 9;
          if (v15)
          {
            uint64_t v20 = 0;
            goto LABEL_56;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_54:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_56:
        uint64_t v42 = 16;
        goto LABEL_61;
      case 2u:
        *(unsigned char *)(a1 + 72) |= 4u;
        uint64_t v26 = *v3;
        unint64_t v27 = *(void *)(a2 + v26);
        if (v27 <= 0xFFFFFFFFFFFFFFF7 && v27 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v27);
          *(void *)(a2 + v26) = v27 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v43 = 24;
        goto LABEL_70;
      case 3u:
        char v29 = 0;
        unsigned int v30 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 72) |= 8u;
        while (2)
        {
          uint64_t v31 = *v3;
          uint64_t v32 = *(void *)(a2 + v31);
          unint64_t v33 = v32 + 1;
          if (v32 == -1 || v33 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v34 = *(unsigned char *)(*(void *)(a2 + *v7) + v32);
            *(void *)(a2 + v31) = v33;
            v20 |= (unint64_t)(v34 & 0x7F) << v29;
            if (v34 < 0)
            {
              v29 += 7;
              BOOL v15 = v30++ >= 9;
              if (v15)
              {
                uint64_t v20 = 0;
                goto LABEL_60;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v20 = 0;
        }
LABEL_60:
        uint64_t v42 = 32;
LABEL_61:
        *(void *)(a1 + v42) = v20;
        goto LABEL_71;
      case 4u:
        *(unsigned char *)(a1 + 72) |= 0x10u;
        uint64_t v35 = *v3;
        unint64_t v36 = *(void *)(a2 + v35);
        if (v36 <= 0xFFFFFFFFFFFFFFF7 && v36 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v36);
          *(void *)(a2 + v35) = v36 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v43 = 40;
        goto LABEL_70;
      case 5u:
        *(unsigned char *)(a1 + 72) |= 0x20u;
        uint64_t v37 = *v3;
        unint64_t v38 = *(void *)(a2 + v37);
        if (v38 <= 0xFFFFFFFFFFFFFFF7 && v38 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v38);
          *(void *)(a2 + v37) = v38 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v43 = 48;
        goto LABEL_70;
      case 6u:
        *(unsigned char *)(a1 + 72) |= 1u;
        uint64_t v39 = *v3;
        unint64_t v40 = *(void *)(a2 + v39);
        if (v40 <= 0xFFFFFFFFFFFFFFF7 && v40 + 8 <= *(void *)(a2 + *v4))
        {
          uint64_t v28 = *(void *)(*(void *)(a2 + *v7) + v40);
          *(void *)(a2 + v39) = v40 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + *v5) = 1;
          uint64_t v28 = 0;
        }
        uint64_t v43 = 8;
LABEL_70:
        *(void *)(a1 + v43) = v28;
        goto LABEL_71;
      case 7u:
        char v41 = objc_alloc_init(HDCodableWorkoutActivity);
        objc_storeStrong((id *)(a1 + 56), v41);
        if (!PBReaderPlaceMark() || (HDCodableWorkoutActivityReadFrom((uint64_t)v41, a2) & 1) == 0) {
          goto LABEL_73;
        }
        goto LABEL_52;
      case 8u:
        char v41 = objc_alloc_init(HDCodableWorkoutEvent);
        [(id)a1 addEvents:v41];
        if PBReaderPlaceMark() && (HDCodableWorkoutEventReadFrom((uint64_t)v41, a2))
        {
LABEL_52:
          PBReaderRecallMark();

LABEL_71:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }
LABEL_73:

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_71;
    }
  }
}

void sub_1BD299C4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD29A124(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD29A300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  _Unwind_Resume(a1);
}

void sub_1BD29A700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43)
{
}

__n128 std::deque<HDQuantitySampleAttenuationEngineSample>::push_back(void *a1, uint64_t a2)
{
  id v4 = (char *)a1[1];
  id v5 = (char *)a1[2];
  unint64_t v6 = (v5 - v4) >> 3;
  if (v5 == v4) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 102 * v6 - 1;
  }
  unint64_t v8 = a1[4];
  unint64_t v9 = a1[5] + v8;
  if (v7 == v9)
  {
    if (v8 < 0x66)
    {
      unint64_t v23 = (char *)a1[3];
      uint64_t v24 = (uint64_t)&v23[-*a1];
      if (v6 >= v24 >> 3)
      {
        if (v23 == (char *)*a1) {
          unint64_t v25 = 1;
        }
        else {
          unint64_t v25 = v24 >> 2;
        }
        unsigned int v65 = a1 + 3;
        *(void *)&long long v63 = std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v25);
        *((void *)&v63 + 1) = v63 + 8 * v6;
        *(void *)&long long v64 = *((void *)&v63 + 1);
        *((void *)&v64 + 1) = v63 + 8 * v26;
        unint64_t v62 = operator new(0xFF0uLL);
        std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_back(&v63, &v62);
        for (uint64_t i = (void *)a1[2];
              i != (void *)a1[1];
              std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_front((uint64_t)&v63, i))
        {
          --i;
        }
        uint64_t v28 = (char *)*a1;
        long long v29 = v64;
        *(_OWORD *)a1 = v63;
        *((_OWORD *)a1 + 1) = v29;
        if (v28) {
          operator delete(v28);
        }
        goto LABEL_36;
      }
      if (v23 != v5)
      {
        *(void *)&long long v63 = operator new(0xFF0uLL);
        std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_back(a1, &v63);
LABEL_36:
        id v4 = (char *)a1[1];
        unint64_t v9 = a1[5] + a1[4];
        goto LABEL_37;
      }
      *(void *)&long long v63 = operator new(0xFF0uLL);
      std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_front((uint64_t)a1, &v63);
      char v41 = (void *)a1[1];
      id v5 = (char *)a1[2];
      uint64_t v43 = *v41;
      uint64_t v42 = (char *)(v41 + 1);
      uint64_t v11 = v43;
      a1[1] = v42;
      if (v5 == (char *)a1[3])
      {
        uint64_t v47 = (uint64_t)&v42[-*a1];
        if ((unint64_t)v42 > *a1)
        {
          uint64_t v48 = v47 >> 3;
          BOOL v15 = v47 >> 3 < -1;
          uint64_t v49 = (v47 >> 3) + 2;
          if (v15) {
            uint64_t v50 = v49;
          }
          else {
            uint64_t v50 = v48 + 1;
          }
          uint64_t v51 = -(v50 >> 1);
          uint64_t v52 = v50 >> 1;
          unsigned int v53 = &v42[-8 * v52];
          int64_t v54 = v5 - v42;
          if (v5 != v42)
          {
            memmove(&v42[-8 * v52], v42, v5 - v42);
            uint64_t v42 = (char *)a1[1];
          }
          id v5 = &v53[v54];
          uint64_t v22 = &v42[8 * v51];
          goto LABEL_14;
        }
        if (v5 == (char *)*a1) {
          unint64_t v55 = 1;
        }
        else {
          unint64_t v55 = (uint64_t)&v5[-*a1] >> 2;
        }
        uint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v55);
        uint64_t v32 = &v31[8 * (v55 >> 2)];
        char v34 = &v31[8 * v56];
        char v57 = (uint64_t *)a1[1];
        id v5 = v32;
        uint64_t v58 = a1[2] - (void)v57;
        if (v58)
        {
          id v5 = &v32[v58 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v59 = 8 * (v58 >> 3);
          uint64_t v60 = &v31[8 * (v55 >> 2)];
          do
          {
            uint64_t v61 = *v57++;
            *(void *)uint64_t v60 = v61;
            v60 += 8;
            v59 -= 8;
          }
          while (v59);
        }
LABEL_32:
        unint64_t v40 = (char *)*a1;
        *a1 = v31;
        a1[1] = v32;
        a1[2] = v5;
        a1[3] = v34;
        if (v40)
        {
          operator delete(v40);
          id v5 = (char *)a1[2];
        }
      }
    }
    else
    {
      a1[4] = v8 - 102;
      uint64_t v12 = *(void *)v4;
      unint64_t v10 = v4 + 8;
      uint64_t v11 = v12;
      a1[1] = v10;
      if (v5 == (char *)a1[3])
      {
        uint64_t v13 = (uint64_t)&v10[-*a1];
        if ((unint64_t)v10 > *a1)
        {
          uint64_t v14 = v13 >> 3;
          BOOL v15 = v13 >> 3 < -1;
          uint64_t v16 = (v13 >> 3) + 2;
          if (v15) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14 + 1;
          }
          uint64_t v18 = -(v17 >> 1);
          uint64_t v19 = v17 >> 1;
          uint64_t v20 = &v10[-8 * v19];
          int64_t v21 = v5 - v10;
          if (v5 != v10)
          {
            memmove(&v10[-8 * v19], v10, v5 - v10);
            id v5 = (char *)a1[1];
          }
          uint64_t v22 = &v5[8 * v18];
          id v5 = &v20[v21];
LABEL_14:
          a1[1] = v22;
          a1[2] = v5;
          goto LABEL_35;
        }
        if (v5 == (char *)*a1) {
          unint64_t v30 = 1;
        }
        else {
          unint64_t v30 = (uint64_t)&v5[-*a1] >> 2;
        }
        uint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v30);
        uint64_t v32 = &v31[8 * (v30 >> 2)];
        char v34 = &v31[8 * v33];
        uint64_t v35 = (uint64_t *)a1[1];
        id v5 = v32;
        uint64_t v36 = a1[2] - (void)v35;
        if (v36)
        {
          id v5 = &v32[v36 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v37 = 8 * (v36 >> 3);
          unint64_t v38 = &v31[8 * (v30 >> 2)];
          do
          {
            uint64_t v39 = *v35++;
            *(void *)unint64_t v38 = v39;
            v38 += 8;
            v37 -= 8;
          }
          while (v37);
        }
        goto LABEL_32;
      }
    }
LABEL_35:
    *(void *)id v5 = v11;
    a1[2] += 8;
    goto LABEL_36;
  }
LABEL_37:
  unint64_t v44 = *(void *)&v4[8 * (v9 / 0x66)] + 40 * (v9 % 0x66);
  __n128 result = *(__n128 *)a2;
  long long v46 = *(_OWORD *)(a2 + 16);
  *(void *)(v44 + 32) = *(void *)(a2 + 32);
  *(__n128 *)unint64_t v44 = result;
  *(_OWORD *)(v44 + 16) = v46;
  ++a1[5];
  return result;
}

void sub_1BD29AAB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p)
{
  operator delete(v11);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_1BD29ADA4(_Unwind_Exception *a1)
{
  std::deque<HDQuantitySampleAttenuationEngineSample>::~deque[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void sub_1BD29B080(_Unwind_Exception *a1)
{
  std::__split_buffer<std::__thread_id *>::~__split_buffer(v1);
  _Unwind_Resume(a1);
}

void *std::deque<HDQuantitySampleAttenuationEngineSample>::__append_with_size[abi:ne180100]<std::__deque_iterator<HDQuantitySampleAttenuationEngineSample,HDQuantitySampleAttenuationEngineSample const*,HDQuantitySampleAttenuationEngineSample const&,HDQuantitySampleAttenuationEngineSample const* const*,long,102l>>(void *a1, void *a2, long long *a3, unint64_t a4)
{
  uint64_t v4 = a4;
  unint64_t v9 = (char *)a1[1];
  unint64_t v8 = (char *)a1[2];
  uint64_t v10 = (v8 - v9) >> 3;
  if (v8 == v9) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = 102 * v10 - 1;
  }
  unint64_t v12 = a1[4];
  uint64_t v13 = a1[5];
  unint64_t v14 = v13 + v12;
  unint64_t v15 = v11 - (v13 + v12);
  BOOL v16 = a4 >= v15;
  unint64_t v17 = a4 - v15;
  if (v17 != 0 && v16)
  {
    if (v8 == v9) {
      unint64_t v18 = v17 + 1;
    }
    else {
      unint64_t v18 = v17;
    }
    if (v18 % 0x66) {
      unint64_t v19 = v18 / 0x66 + 1;
    }
    else {
      unint64_t v19 = v18 / 0x66;
    }
    if (v19 >= v12 / 0x66) {
      unint64_t v20 = v12 / 0x66;
    }
    else {
      unint64_t v20 = v19;
    }
    if (v19 <= v12 / 0x66)
    {
      for (a1[4] = v12 - 102 * v20; v20; --v20)
      {
        uint64_t v26 = (void *)a1[1];
        uint64_t v29 = *v26;
        unint64_t v27 = (char *)(v26 + 1);
        uint64_t v28 = v29;
        a1[1] = v27;
        if (v8 == (char *)a1[3])
        {
          uint64_t v30 = (uint64_t)&v27[-*a1];
          if ((unint64_t)v27 <= *a1)
          {
            if (v8 == (char *)*a1) {
              unint64_t v38 = 1;
            }
            else {
              unint64_t v38 = (uint64_t)&v8[-*a1] >> 2;
            }
            uint64_t v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v38);
            char v41 = &v39[8 * (v38 >> 2)];
            uint64_t v42 = (uint64_t *)a1[1];
            unint64_t v8 = v41;
            uint64_t v43 = a1[2] - (void)v42;
            if (v43)
            {
              unint64_t v8 = &v41[v43 & 0xFFFFFFFFFFFFFFF8];
              uint64_t v44 = 8 * (v43 >> 3);
              unint64_t v45 = &v39[8 * (v38 >> 2)];
              do
              {
                uint64_t v46 = *v42++;
                *(void *)unint64_t v45 = v46;
                v45 += 8;
                v44 -= 8;
              }
              while (v44);
            }
            uint64_t v47 = (char *)*a1;
            *a1 = v39;
            a1[1] = v41;
            a1[2] = v8;
            a1[3] = &v39[8 * v40];
            if (v47)
            {
              operator delete(v47);
              unint64_t v8 = (char *)a1[2];
            }
          }
          else
          {
            uint64_t v31 = v30 >> 3;
            BOOL v32 = v30 >> 3 < -1;
            uint64_t v33 = (v30 >> 3) + 2;
            if (v32) {
              uint64_t v34 = v33;
            }
            else {
              uint64_t v34 = v31 + 1;
            }
            uint64_t v35 = &v27[-8 * (v34 >> 1)];
            int64_t v36 = v8 - v27;
            if (v8 != v27)
            {
              memmove(&v27[-8 * (v34 >> 1)], v27, v8 - v27);
              unint64_t v8 = (char *)a1[1];
            }
            uint64_t v37 = &v8[-8 * (v34 >> 1)];
            unint64_t v8 = &v35[v36];
            a1[1] = v37;
            a1[2] = &v35[v36];
          }
        }
        *(void *)unint64_t v8 = v28;
        unint64_t v8 = (char *)(a1[2] + 8);
        a1[2] = v8;
      }
    }
    else
    {
      unint64_t v21 = v19 - v20;
      uint64_t v22 = a1[3] - *a1;
      if (v19 - v20 <= (v22 >> 3) - v10)
      {
        if (v21)
        {
          while (a1[3] != a1[2])
          {
            *(void *)&long long v106 = operator new(0xFF0uLL);
            std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_back(a1, &v106);
            --v19;
            if (!--v21)
            {
              unint64_t v8 = (char *)a1[2];
              goto LABEL_79;
            }
          }
          for (uint64_t i = 0; i != v21; ++i)
          {
            *(void *)&long long v106 = operator new(0xFF0uLL);
            std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_front((uint64_t)a1, &v106);
            unint64_t v8 = (char *)a1[2];
            if (&v8[-a1[1]] == (char *)8) {
              uint64_t v69 = 101;
            }
            else {
              uint64_t v69 = 102;
            }
            uint64_t v70 = v69 + a1[4];
            a1[4] = v70;
          }
          unint64_t v20 = v19;
        }
        else
        {
LABEL_79:
          uint64_t v70 = a1[4];
        }
        for (a1[4] = v70 - 102 * v20; v20; --v20)
        {
          uint64_t v71 = (void *)a1[1];
          uint64_t v74 = *v71;
          uint64_t v72 = (char *)(v71 + 1);
          uint64_t v73 = v74;
          a1[1] = v72;
          if (v8 == (char *)a1[3])
          {
            uint64_t v75 = (uint64_t)&v72[-*a1];
            if ((unint64_t)v72 <= *a1)
            {
              if (v8 == (char *)*a1) {
                unint64_t v82 = 1;
              }
              else {
                unint64_t v82 = (uint64_t)&v8[-*a1] >> 2;
              }
              unsigned int v83 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v82);
              unint64_t v85 = &v83[8 * (v82 >> 2)];
              char v86 = (uint64_t *)a1[1];
              unint64_t v8 = v85;
              uint64_t v87 = a1[2] - (void)v86;
              if (v87)
              {
                unint64_t v8 = &v85[v87 & 0xFFFFFFFFFFFFFFF8];
                uint64_t v88 = 8 * (v87 >> 3);
                unsigned int v89 = &v83[8 * (v82 >> 2)];
                do
                {
                  uint64_t v90 = *v86++;
                  *(void *)unsigned int v89 = v90;
                  v89 += 8;
                  v88 -= 8;
                }
                while (v88);
              }
              unint64_t v91 = (char *)*a1;
              *a1 = v83;
              a1[1] = v85;
              a1[2] = v8;
              a1[3] = &v83[8 * v84];
              if (v91)
              {
                operator delete(v91);
                unint64_t v8 = (char *)a1[2];
              }
            }
            else
            {
              uint64_t v76 = v75 >> 3;
              BOOL v32 = v75 >> 3 < -1;
              uint64_t v77 = (v75 >> 3) + 2;
              if (v32) {
                uint64_t v78 = v77;
              }
              else {
                uint64_t v78 = v76 + 1;
              }
              uint64_t v79 = &v72[-8 * (v78 >> 1)];
              int64_t v80 = v8 - v72;
              if (v8 != v72)
              {
                memmove(&v72[-8 * (v78 >> 1)], v72, v8 - v72);
                unint64_t v8 = (char *)a1[1];
              }
              char v81 = &v8[-8 * (v78 >> 1)];
              unint64_t v8 = &v79[v80];
              a1[1] = v81;
              a1[2] = &v79[v80];
            }
          }
          *(void *)unint64_t v8 = v73;
          unint64_t v8 = (char *)(a1[2] + 8);
          a1[2] = v8;
        }
      }
      else
      {
        if (v22 >> 2 <= v21 + v10) {
          unint64_t v23 = v21 + v10;
        }
        else {
          unint64_t v23 = v22 >> 2;
        }
        unint64_t v24 = v10 - v20;
        uint64_t v108 = a1 + 3;
        if (v23) {
          unint64_t v23 = (unint64_t)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v23);
        }
        else {
          uint64_t v25 = 0;
        }
        *(void *)&long long v106 = v23;
        *((void *)&v106 + 1) = v23 + 8 * v24;
        *(void *)&long long v107 = *((void *)&v106 + 1);
        *((void *)&v107 + 1) = v23 + 8 * v25;
        do
        {
          long long v105 = operator new(0xFF0uLL);
          std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_back(&v106, &v105);
          --v21;
        }
        while (v21);
        uint64_t v103 = -102 * v20;
        uint64_t v104 = v4;
        if (v20)
        {
          uint64_t v48 = (void *)a1[1];
          uint64_t v49 = (char *)v107;
          do
          {
            if (v49 == *((char **)&v107 + 1))
            {
              uint64_t v50 = (char *)*((void *)&v106 + 1);
              uint64_t v51 = (void *)v106;
              if (*((void *)&v106 + 1) <= (unint64_t)v106)
              {
                if (v49 == (char *)v106) {
                  unint64_t v57 = 1;
                }
                else {
                  unint64_t v57 = (uint64_t)&v49[-v106] >> 2;
                }
                uint64_t v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry,std::default_delete<health::TransactionalCache<unsigned long long,health::FilePage>::CacheEntry>>>>(v57);
                uint64_t v61 = v49 - v50;
                BOOL v60 = v49 == v50;
                uint64_t v49 = &v58[8 * (v57 >> 2)];
                if (!v60)
                {
                  uint64_t v49 = &v58[8 * (v57 >> 2) + (v61 & 0xFFFFFFFFFFFFFFF8)];
                  uint64_t v62 = 8 * (v61 >> 3);
                  long long v63 = &v58[8 * (v57 >> 2)];
                  do
                  {
                    uint64_t v64 = *(void *)v50;
                    v50 += 8;
                    *(void *)long long v63 = v64;
                    v63 += 8;
                    v62 -= 8;
                  }
                  while (v62);
                }
                *(void *)&long long v106 = v58;
                *((void *)&v106 + 1) = &v58[8 * (v57 >> 2)];
                *(void *)&long long v107 = v49;
                *((void *)&v107 + 1) = &v58[8 * v59];
                if (v51) {
                  operator delete(v51);
                }
              }
              else
              {
                uint64_t v52 = (uint64_t)(*((void *)&v106 + 1) - v106) >> 3;
                if (v52 >= -1) {
                  uint64_t v53 = v52 + 1;
                }
                else {
                  uint64_t v53 = v52 + 2;
                }
                uint64_t v54 = *((void *)&v106 + 1) - 8 * (v53 >> 1);
                unint64_t v55 = &v49[-*((void *)&v106 + 1)];
                if (v49 != *((char **)&v106 + 1))
                {
                  memmove((void *)(*((void *)&v106 + 1) - 8 * (v53 >> 1)), *((const void **)&v106 + 1), (size_t)&v49[-*((void *)&v106 + 1)]);
                  uint64_t v49 = v50;
                }
                uint64_t v56 = &v49[-8 * (v53 >> 1)];
                uint64_t v49 = &v55[v54];
                *((void *)&v106 + 1) = v56;
                *(void *)&long long v107 = &v55[v54];
              }
            }
            *(void *)uint64_t v49 = *v48;
            uint64_t v49 = (char *)(v107 + 8);
            *(void *)&long long v107 = v107 + 8;
            uint64_t v48 = (void *)(a1[1] + 8);
            a1[1] = v48;
            --v20;
          }
          while (v20);
        }
        unsigned int v65 = (void *)a1[2];
        uint64_t v4 = v104;
        while (v65 != (void *)a1[1])
          std::__split_buffer<std::__state<char> *,std::allocator<std::__state<char> *>>::push_front((uint64_t)&v106, --v65);
        uint64_t v66 = (char *)*a1;
        long long v67 = v107;
        *(_OWORD *)a1 = v106;
        *((_OWORD *)a1 + 1) = v67;
        a1[4] += v103;
        if (v66)
        {
          operator delete(v66);
          unint64_t v8 = (char *)a1[2];
        }
        else
        {
          unint64_t v8 = (char *)v67;
        }
      }
    }
    uint64_t v13 = a1[5];
    unint64_t v9 = (char *)a1[1];
    unint64_t v14 = a1[4] + v13;
  }
  char v92 = &v9[8 * (v14 / 0x66)];
  if (v8 == v9) {
    unint64_t v93 = 0;
  }
  else {
    unint64_t v93 = *(void *)v92 + 40 * (v14 % 0x66);
  }
  *(void *)&long long v106 = &v9[8 * (v14 / 0x66)];
  *((void *)&v106 + 1) = v93;
  __n128 result = std::__deque_iterator<HDQuantitySampleAttenuationEngineSample,HDQuantitySampleAttenuationEngineSample*,HDQuantitySampleAttenuationEngineSample&,HDQuantitySampleAttenuationEngineSample**,long,102l>::operator+=[abi:ne180100](&v106, v4);
  uint64_t v95 = *((void *)&v106 + 1);
  if (v93 != *((void *)&v106 + 1))
  {
    long long v96 = (char *)v106;
    do
    {
      if (v92 == v96) {
        uint64_t v97 = v95;
      }
      else {
        uint64_t v97 = *(void *)v92 + 4080;
      }
      if (v93 == v97)
      {
        uint64_t v97 = v93;
      }
      else
      {
        unint64_t v98 = v93;
        do
        {
          long long v99 = *a3;
          long long v100 = a3[1];
          *(void *)(v98 + 32) = *((void *)a3 + 4);
          *(_OWORD *)unint64_t v98 = v99;
          *(_OWORD *)(v98 + 16) = v100;
          a3 = (long long *)((char *)a3 + 40);
          if ((long long *)((char *)a3 - *a2) == (long long *)4080)
          {
            long long v101 = (long long *)a2[1];
            ++a2;
            a3 = v101;
          }
          v98 += 40;
        }
        while (v98 != v97);
        uint64_t v13 = a1[5];
      }
      v13 -= 0x3333333333333333 * ((uint64_t)(v97 - v93) >> 3);
      a1[5] = v13;
      if (v92 == v96) {
        break;
      }
      unint64_t v102 = *((void *)v92 + 1);
      v92 += 8;
      unint64_t v93 = v102;
    }
    while (v102 != v95);
  }
  return result;
}

void sub_1BD29BB04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__deque_iterator<HDQuantitySampleAttenuationEngineSample,HDQuantitySampleAttenuationEngineSample*,HDQuantitySampleAttenuationEngineSample&,HDQuantitySampleAttenuationEngineSample**,long,102l>::operator+=[abi:ne180100](void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = (void *)*result;
    unint64_t v3 = a2 - 0x3333333333333333 * ((uint64_t)(result[1] - *(void *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      unint64_t v5 = 101 - v3;
      unint64_t v6 = &v2[-(v5 / 0x66)];
      *__n128 result = v6;
      unint64_t v4 = *v6 + 40 * (102 * (v5 / 0x66) - v5) + 4040;
    }
    else
    {
      *__n128 result = &v2[v3 / 0x66];
      unint64_t v4 = v2[v3 / 0x66] + 40 * (v3 % 0x66);
    }
    result[1] = v4;
  }
  return result;
}

double std::__for_each_segment[abi:ne180100]<std::__deque_iterator<HDQuantitySampleAttenuationEngineSample,HDQuantitySampleAttenuationEngineSample const*,HDQuantitySampleAttenuationEngineSample const&,HDQuantitySampleAttenuationEngineSample const* const*,long,102l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<HDQuantitySampleAttenuationEngineSample,HDQuantitySampleAttenuationEngineSample const*,HDQuantitySampleAttenuationEngineSample const&,HDQuantitySampleAttenuationEngineSample const* const*,long,102l>,std::__deque_iterator<HDQuantitySampleAttenuationEngineSample,HDQuantitySampleAttenuationEngineSample*,HDQuantitySampleAttenuationEngineSample&,HDQuantitySampleAttenuationEngineSample**,long,102l>>>(uint64_t *a1, unsigned char *a2, uint64_t *a3, unsigned char *a4, uint64_t a5)
{
  unint64_t v5 = (void ***)a5;
  uint64_t v7 = *(void ***)a5;
  unint64_t v8 = *(char **)(a5 + 8);
  if (a1 == a3)
  {
    unint64_t v20 = a4;
  }
  else
  {
    unint64_t v9 = a3;
    uint64_t v10 = a1 + 1;
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<HDQuantitySampleAttenuationEngineSample const*,std::__deque_iterator<HDQuantitySampleAttenuationEngineSample,HDQuantitySampleAttenuationEngineSample*,HDQuantitySampleAttenuationEngineSample&,HDQuantitySampleAttenuationEngineSample**,long,102l>,0>(&v25, a2, (unsigned char *)(*a1 + 4080), v7, v8);
    unint64_t v12 = (void **)*((void *)&v26 + 1);
    uint64_t v11 = (void **)v26;
    *unint64_t v5 = (void **)v26;
    v5[1] = v12;
    if (v10 != v9)
    {
      uint64_t v22 = a4;
      unint64_t v23 = v9;
      unint64_t v24 = v5;
      do
      {
        uint64_t v13 = 0;
        uint64_t v14 = *v10;
        BOOL v16 = (char *)*v11++;
        unint64_t v15 = v16;
        while (1)
        {
          int64_t v17 = 0xCCCCCCCCCCCCCCCDLL * ((v15 - (char *)v12 + 4080) >> 3);
          if ((uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((4080 - 40 * v13) >> 3)) >= v17) {
            unint64_t v18 = v17;
          }
          else {
            unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((4080 - 40 * v13) >> 3);
          }
          if (v18) {
            memmove(v12, (const void *)(v14 + 40 * v13), 40 * v18);
          }
          v13 += v18;
          if (v13 == 102) {
            break;
          }
          unint64_t v19 = (char *)*v11++;
          unint64_t v15 = v19;
          unint64_t v12 = (void **)v19;
        }
        v12 += 5 * v18;
        if ((char *)*(v11 - 1) + 4080 == (char *)v12) {
          unint64_t v12 = (void **)*v11;
        }
        else {
          --v11;
        }
        unint64_t v9 = v23;
        unint64_t v5 = v24;
        void *v24 = v11;
        v24[1] = v12;
        ++v10;
      }
      while (v10 != v23);
      a4 = v22;
    }
    a2 = (unsigned char *)*v9;
    unint64_t v20 = a4;
    uint64_t v7 = v11;
    unint64_t v8 = (char *)v12;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<HDQuantitySampleAttenuationEngineSample const*,std::__deque_iterator<HDQuantitySampleAttenuationEngineSample,HDQuantitySampleAttenuationEngineSample*,HDQuantitySampleAttenuationEngineSample&,HDQuantitySampleAttenuationEngineSample**,long,102l>,0>(&v25, a2, v20, v7, v8);
  double result = *(double *)&v26;
  *(_OWORD *)unint64_t v5 = v26;
  return result;
}

void *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<HDQuantitySampleAttenuationEngineSample const*,std::__deque_iterator<HDQuantitySampleAttenuationEngineSample,HDQuantitySampleAttenuationEngineSample*,HDQuantitySampleAttenuationEngineSample&,HDQuantitySampleAttenuationEngineSample**,long,102l>,0>(void *result, unsigned char *__src, unsigned char *a3, void **a4, char *__dst)
{
  unint64_t v6 = a4;
  uint64_t v7 = __src;
  unint64_t v8 = result;
  if (__src == a3)
  {
    unint64_t v9 = __src;
  }
  else
  {
    unint64_t v9 = a3;
    unint64_t v6 = a4 + 1;
    uint64_t v10 = (char *)*a4;
    while (1)
    {
      int64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((v10 - __dst + 4080) >> 3);
      unint64_t v12 = (uint64_t)(0xCCCCCCCCCCCCCCCDLL * ((v9 - v7) >> 3)) >= v11 ? v11 : 0xCCCCCCCCCCCCCCCDLL * ((v9 - v7) >> 3);
      if (v12) {
        double result = memmove(__dst, v7, 40 * v12);
      }
      v7 += 40 * v12;
      if (v7 == v9) {
        break;
      }
      uint64_t v13 = (char *)*v6++;
      uint64_t v10 = v13;
      __dst = v13;
    }
    __dst += 40 * v12;
    if ((char *)*(v6 - 1) + 4080 == __dst) {
      __dst = (char *)*v6;
    }
    else {
      --v6;
    }
  }
  *unint64_t v8 = v9;
  v8[1] = v6;
  void v8[2] = __dst;
  return result;
}

uint64_t std::deque<HDQuantitySampleAttenuationEngineSample>::~deque[abi:ne180100](void *a1)
{
  uint64_t v2 = (void **)a1[1];
  unint64_t v3 = (void **)a1[2];
  a1[5] = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      unint64_t v3 = (void **)a1[2];
      uint64_t v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 51;
  }
  else
  {
    if (v5 != 2) {
      goto LABEL_9;
    }
    uint64_t v6 = 102;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    uint64_t v7 = *v2++;
    operator delete(v7);
  }

  return std::__split_buffer<std::__thread_id *>::~__split_buffer((uint64_t)a1);
}

void sub_1BD29C978(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__201(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__201(uint64_t a1)
{
}

id HDAttachmentReferencePredicateForUnsynchronizedReferences()
{
  v6[2] = *MEMORY[0x1E4F143B8];
  uint64_t v0 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"type" equalToValue:&unk_1F17EF0A8];
  uint64_t v1 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"cloud_status" equalToValue:&unk_1F17EF0A8];
  uint64_t v2 = (void *)MEMORY[0x1E4F65D08];
  v6[0] = v0;
  v6[1] = v1;
  unint64_t v3 = [MEMORY[0x1E4F1C978] arrayWithObjects:v6 count:2];
  unint64_t v4 = [v2 predicateMatchingAllPredicates:v3];

  return v4;
}

id HDAttachmentReferencePredicateForUnsynchronizedTombstones()
{
  v6[2] = *MEMORY[0x1E4F143B8];
  uint64_t v0 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"type" equalToValue:&unk_1F17EF0C0];
  uint64_t v1 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"cloud_status" equalToValue:&unk_1F17EF0A8];
  uint64_t v2 = (void *)MEMORY[0x1E4F65D08];
  v6[0] = v0;
  v6[1] = v1;
  unint64_t v3 = [MEMORY[0x1E4F1C978] arrayWithObjects:v6 count:2];
  unint64_t v4 = [v2 predicateMatchingAllPredicates:v3];

  return v4;
}

id HDAttachmentReferencePredicateForObjectAndSchemaIdentifier(uint64_t a1, void *a2)
{
  void v11[2] = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (void *)MEMORY[0x1E4F65D00];
  id v4 = a2;
  unint64_t v5 = [v3 predicateWithProperty:@"object_identifier" equalToValue:a1];
  uint64_t v6 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"schema_identifier" equalToValue:v4];

  uint64_t v7 = (void *)MEMORY[0x1E4F65D08];
  v11[0] = v5;
  v11[1] = v6;
  unint64_t v8 = [MEMORY[0x1E4F1C978] arrayWithObjects:v11 count:2];
  unint64_t v9 = [v7 predicateMatchingAllPredicates:v8];

  return v9;
}

uint64_t HDAttachmentReferencePredicateForAttachmentIdentifier(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"attachment_identifier" equalToValue:a1];
}

id HDAttachmentReferencePredicateForNonTombstoneAttachmentIdentifier(uint64_t a1)
{
  uint64_t v7[2] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"attachment_identifier" equalToValue:a1];
  uint64_t v2 = [MEMORY[0x1E4F65D00] predicateWithProperty:@"type" notEqualToValue:&unk_1F17EF0C0];
  unint64_t v3 = (void *)MEMORY[0x1E4F65D08];
  v7[0] = v1;
  v7[1] = v2;
  id v4 = [MEMORY[0x1E4F1C978] arrayWithObjects:v7 count:2];
  unint64_t v5 = [v3 predicateMatchingAllPredicates:v4];

  return v5;
}

uint64_t HDAttachmentReferencePredicateForReferenceIdentifier(uint64_t a1)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"identifier" equalToValue:a1];
}

void sub_1BD2A0550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A069C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A0764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A081C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A093C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A09DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A0ABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A0B7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A0C0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A14AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A1654(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A1768(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A182C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A1900(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A19EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A1AB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A1B54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A1C14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A1D24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A1EC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A1FF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A2218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A2490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_1BD2A29F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2A2E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__202(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__202(uint64_t a1)
{
}

void sub_1BD2A6AE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v16 - 120), 8);
  _Unwind_Resume(a1);
}

void sub_1BD2A73D4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__203(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__203(uint64_t a1)
{
}

void sub_1BD2A7D18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2AA7F0(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    objc_end_catch();
    JUMPOUT(0x1BD2AA538);
  }
  _Unwind_Resume(a1);
}

void sub_1BD2AA800(_Unwind_Exception *a1)
{
}

void sub_1BD2AA818(uint64_t a1, int a2)
{
  if (a2) {
    objc_terminate();
  }
  JUMPOUT(0x1BD2AA824);
}

void sub_1BD2AAE6C()
{
}

void sub_1BD2AD488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2ADC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  _Block_object_dispose(&a24, 8);
  _Block_object_dispose(&a28, 8);
  _Block_object_dispose((const void *)(v28 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1BD2AEB74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
}

uint64_t __Block_byref_object_copy__204(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__204(uint64_t a1)
{
}

BOOL HDCodableObjectAssociationReadFrom(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      if (*(unsigned char *)(a2 + *v5)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        if (v9++ >= 9)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3) {
        break;
      }
      if (v17 == 2)
      {
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 16;
LABEL_26:
        unint64_t v20 = *(HDCodableSyncIdentity **)(a1 + v19);
        *(void *)(a1 + v19) = v18;
LABEL_27:

        goto LABEL_29;
      }
      if (v17 == 1)
      {
        uint64_t v18 = PBReaderReadData();
        uint64_t v19 = 8;
        goto LABEL_26;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_29:
      if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
        return *(unsigned char *)(a2 + *v5) == 0;
      }
    }
    unint64_t v20 = objc_alloc_init(HDCodableSyncIdentity);
    objc_storeStrong((id *)(a1 + 24), v20);
    if (!PBReaderPlaceMark() || !HDCodableSyncIdentityReadFrom((uint64_t)v20, a2))
    {

      return 0;
    }
    PBReaderRecallMark();
    goto LABEL_27;
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD2AFBCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9)
{
  if (a2)
  {
    if (a2 == 2)
    {
      id v10 = objc_begin_catch(exception_object);
      _HKInitializeLogging();
      uint64_t v11 = *MEMORY[0x1E4F29FA8];
      if (os_log_type_enabled((os_log_t)*MEMORY[0x1E4F29FA8], OS_LOG_TYPE_FAULT))
      {
        uint64_t v12 = *(void *)(v9 + 32);
        LODWORD(a9) = 138543618;
        *(void *)((char *)&a9 + 4) = v10;
        WORD6(a9) = 2112;
        *(void *)((char *)&a9 + 14) = v12;
        _os_log_fault_impl(&dword_1BCB7D000, v11, OS_LOG_TYPE_FAULT, "caught exception (%{public}@) attempting to create client object with codable %@", (uint8_t *)&a9, 0x16u);
      }
    }
    else
    {
      objc_begin_catch(exception_object);
    }
    objc_end_catch();
    JUMPOUT(0x1BD2AFB98);
  }
  _Unwind_Resume(exception_object);
}

void sub_1BD2B7334(_Unwind_Exception *a1)
{
}

void sub_1BD2B7C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__205(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__205(uint64_t a1)
{
}

id HDQuantitySampleStatisticsEntityPredicateForMinValue(uint64_t a1, void *a2)
{
  void v8[2] = *MEMORY[0x1E4F143B8];
  v8[0] = @"min";
  v8[1] = @"quantity";
  unint64_t v3 = (void *)MEMORY[0x1E4F1C978];
  id v4 = a2;
  unint64_t v5 = [v3 arrayWithObjects:v8 count:2];
  uint64_t v6 = [MEMORY[0x1E4F65D00] predicateWithCoalescedProperties:v5 value:v4 comparisonType:a1];

  return v6;
}

id HDQuantitySampleStatisticsEntityPredicateForMaxValue(uint64_t a1, void *a2)
{
  void v8[2] = *MEMORY[0x1E4F143B8];
  v8[0] = @"max";
  v8[1] = @"quantity";
  unint64_t v3 = (void *)MEMORY[0x1E4F1C978];
  id v4 = a2;
  unint64_t v5 = [v3 arrayWithObjects:v8 count:2];
  uint64_t v6 = [MEMORY[0x1E4F65D00] predicateWithCoalescedProperties:v5 value:v4 comparisonType:a1];

  return v6;
}

id HDQuantitySampleStatisticsEntityPredicateForMostRecentValue(uint64_t a1, void *a2)
{
  void v8[2] = *MEMORY[0x1E4F143B8];
  v8[0] = @"most_recent";
  v8[1] = @"quantity";
  unint64_t v3 = (void *)MEMORY[0x1E4F1C978];
  id v4 = a2;
  unint64_t v5 = [v3 arrayWithObjects:v8 count:2];
  uint64_t v6 = [MEMORY[0x1E4F65D00] predicateWithCoalescedProperties:v5 value:v4 comparisonType:a1];

  return v6;
}

id HDQuantitySampleStatisticsEntityPredicateForMostRecentStartDate(uint64_t a1, void *a2)
{
  void v8[2] = *MEMORY[0x1E4F143B8];
  v8[0] = @"most_recent_date";
  v8[1] = @"start_date";
  unint64_t v3 = (void *)MEMORY[0x1E4F1C978];
  id v4 = a2;
  unint64_t v5 = [v3 arrayWithObjects:v8 count:2];
  uint64_t v6 = [MEMORY[0x1E4F65D00] predicateWithCoalescedProperties:v5 value:v4 comparisonType:a1];

  return v6;
}

id HDQuantitySampleStatisticsEntityPredicateForMostRecentEndDate(uint64_t a1, void *a2)
{
  void v15[3] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = NSString;
  id v3 = a2;
  id v4 = +[HDSQLiteSchemaEntity disambiguatedDatabaseTable];
  unint64_t v5 = +[HDSQLiteSchemaEntity disambiguatedDatabaseTable];
  uint64_t v6 = +[HDSQLiteSchemaEntity disambiguatedDatabaseTable];
  uint64_t v7 = HDSQLOperatorForComparisonType();
  char v8 = [v2 stringWithFormat:@"(IFNULL((%@.%@ + %@.%@), %@.%@) %@ ?)", v4, @"most_recent_date", v5, @"most_recent_duration", v6, @"end_date", v7];

  v15[0] = @"most_recent_date";
  v15[1] = @"most_recent_duration";
  v15[2] = @"end_date";
  uint64_t v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v15 count:3];
  id v10 = (void *)MEMORY[0x1E4F65D78];
  id v14 = v3;
  uint64_t v11 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v14 count:1];
  uint64_t v12 = [v10 predicateWithSQL:v8 overProperties:v9 values:v11];

  return v12;
}

id HDQuantitySampleStatisticsEntityPredicateForMostRecentDuration(uint64_t a1, void *a2)
{
  void v15[3] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = NSString;
  id v3 = a2;
  id v4 = +[HDSQLiteSchemaEntity disambiguatedDatabaseTable];
  unint64_t v5 = +[HDSQLiteSchemaEntity disambiguatedDatabaseTable];
  uint64_t v6 = +[HDSQLiteSchemaEntity disambiguatedDatabaseTable];
  uint64_t v7 = HDSQLOperatorForComparisonType();
  char v8 = [v2 stringWithFormat:@"(IFNULL(%@.%@, (%@.%@ - %@.%@)) %@ ?)", v4, @"most_recent_duration", v5, @"end_date", v6, @"start_date", v7];

  v15[0] = @"most_recent_duration";
  v15[1] = @"end_date";
  v15[2] = @"start_date";
  uint64_t v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v15 count:3];
  id v10 = (void *)MEMORY[0x1E4F65D78];
  id v14 = v3;
  uint64_t v11 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v14 count:1];
  uint64_t v12 = [v10 predicateWithSQL:v8 overProperties:v9 values:v11];

  return v12;
}

void sub_1BD2BA408(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

__CFString *HDStringFromPeriodicActivityResult(unint64_t a1)
{
  if (a1 >= 4)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"unknown(%ld)", a1);
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v1 = off_1E630E688[a1];
  }

  return v1;
}

id HDECGEntityPredicateForPrivateClassification(uint64_t a1, char a2)
{
  id v3 = (void *)MEMORY[0x1E4F65D00];
  id v4 = [NSNumber numberWithUnsignedInteger:a1];
  unint64_t v5 = _HDSQLiteValueForNumber();
  if (a2) {
    [v3 predicateWithProperty:@"private_classification" equalToValue:v5];
  }
  else {
  uint64_t v6 = [v3 predicateWithProperty:@"private_classification" notEqualToValue:v5];
  }

  return v6;
}

id HDECGEntityPredicateForPublicClassification(uint64_t a1, int a2)
{
  switch(a1)
  {
    case 1:
      uint64_t v2 = &unk_1F17EADD0;
      if ((a2 & 1) == 0) {
        goto LABEL_12;
      }
      goto LABEL_16;
    case 2:
      uint64_t v2 = &unk_1F17EADE8;
      if (a2) {
        goto LABEL_16;
      }
      goto LABEL_12;
    case 3:
      uint64_t v2 = &unk_1F17EAE00;
      if (a2) {
        goto LABEL_16;
      }
      goto LABEL_12;
    case 4:
      uint64_t v2 = &unk_1F17EAE18;
      if ((a2 & 1) == 0) {
        goto LABEL_12;
      }
      goto LABEL_16;
    case 5:
      uint64_t v2 = &unk_1F17EAE30;
      if (a2) {
        goto LABEL_16;
      }
      goto LABEL_12;
    case 6:
      uint64_t v2 = &unk_1F17EAE48;
      if ((a2 & 1) == 0) {
        goto LABEL_12;
      }
      goto LABEL_16;
    default:
      if (a1 != 100)
      {
        uint64_t v2 = &unk_1F17EADB8;
        if (a2) {
          goto LABEL_16;
        }
LABEL_12:
        if (a1 != 100)
        {
          unint64_t v5 = [MEMORY[0x1E4F65D08] predicateWithProperty:@"private_classification" notEqualToValues:v2];
          goto LABEL_21;
        }
LABEL_13:
        id v3 = (void *)MEMORY[0x1E4F65D08];
        uint64_t v4 = 4;
        goto LABEL_20;
      }
      uint64_t v2 = &unk_1F17EAE60;
      if (!a2) {
        goto LABEL_13;
      }
LABEL_16:
      if (a1 == 100) {
        uint64_t v4 = 5;
      }
      else {
        uint64_t v4 = 1;
      }
      id v3 = (void *)MEMORY[0x1E4F65D08];
LABEL_20:
      unint64_t v5 = [v3 predicateWithProperty:@"private_classification" values:v2 comparisonType:v4];
LABEL_21:
      return v5;
  }
}

id HDECGEntityPredicateForAverageHeartRate(uint64_t a1, void *a2)
{
  id v3 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v4 = NSNumber;
  unint64_t v5 = (void *)MEMORY[0x1E4F2B618];
  id v6 = a2;
  uint64_t v7 = [v5 _countPerMinuteUnit];
  [v6 doubleValueForUnit:v7];
  double v9 = v8;

  id v10 = [v4 numberWithDouble:v9];
  uint64_t v11 = [v3 predicateWithProperty:@"average_heart_rate" value:v10 comparisonType:a1];

  return v11;
}

id HDECGEntityPredicateForSymptomsStatus(uint64_t a1, char a2)
{
  id v3 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v4 = [NSNumber numberWithInteger:a1];
  unint64_t v5 = _HDSQLiteValueForNumber();
  if (a2) {
    [v3 predicateWithProperty:@"symptoms_status" equalToValue:v5];
  }
  else {
  id v6 = [v3 predicateWithProperty:@"symptoms_status" notEqualToValue:v5];
  }

  return v6;
}

void sub_1BD2BDAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__206(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__206(uint64_t a1)
{
}

void sub_1BD2BE058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2BF81C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__207(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__207(uint64_t a1)
{
}

void sub_1BD2C0BCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2C4624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

uint64_t HDCodableObjectTypeSourceOrderReadFrom(uint64_t a1, uint64_t a2)
{
  id v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) >= *(void *)(a2 + (int)*MEMORY[0x1E4F940E0])) {
    return *(unsigned char *)(a2 + *v5) == 0;
  }
  uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
  while (2)
  {
    if (*(unsigned char *)(a2 + *v5)) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    char v8 = 0;
    unsigned int v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = *v3;
      uint64_t v12 = *(void *)(a2 + v11);
      unint64_t v13 = v12 + 1;
      if (v12 == -1 || v13 > *(void *)(a2 + *v4)) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
      *(void *)(a2 + v11) = v13;
      v10 |= (unint64_t)(v14 & 0x7F) << v8;
      if ((v14 & 0x80) == 0) {
        goto LABEL_12;
      }
      v8 += 7;
      BOOL v15 = v9++ >= 9;
      if (v15)
      {
        unint64_t v10 = 0;
        uint64_t v16 = *v5;
        int v17 = *(unsigned __int8 *)(a2 + v16);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
    uint64_t v16 = *v5;
    int v17 = *(unsigned __int8 *)(a2 + v16);
    if (*(unsigned char *)(a2 + v16)) {
      unint64_t v10 = 0;
    }
LABEL_14:
    int v18 = v10 & 7;
    if (v17 || v18 == 4) {
      return *(unsigned char *)(a2 + *v5) == 0;
    }
    switch((v10 >> 3))
    {
      case 1u:
        char v20 = 0;
        unsigned int v21 = 0;
        uint64_t v22 = 0;
        *(unsigned char *)(a1 + 60) |= 1u;
        while (1)
        {
          uint64_t v23 = *v3;
          uint64_t v24 = *(void *)(a2 + v23);
          unint64_t v25 = v24 + 1;
          if (v24 == -1 || v25 > *(void *)(a2 + *v4)) {
            break;
          }
          char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v24);
          *(void *)(a2 + v23) = v25;
          v22 |= (unint64_t)(v26 & 0x7F) << v20;
          if ((v26 & 0x80) == 0) {
            goto LABEL_49;
          }
          v20 += 7;
          BOOL v15 = v21++ >= 9;
          if (v15)
          {
            uint64_t v22 = 0;
            goto LABEL_51;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_49:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v22 = 0;
        }
LABEL_51:
        *(void *)(a1 + 32) = v22;
        goto LABEL_62;
      case 2u:
        char v27 = 0;
        unsigned int v28 = 0;
        uint64_t v29 = 0;
        *(unsigned char *)(a1 + 60) |= 2u;
        while (2)
        {
          uint64_t v30 = *v3;
          uint64_t v31 = *(void *)(a2 + v30);
          unint64_t v32 = v31 + 1;
          if (v31 == -1 || v32 > *(void *)(a2 + *v4))
          {
            *(unsigned char *)(a2 + *v5) = 1;
          }
          else
          {
            char v33 = *(unsigned char *)(*(void *)(a2 + *v7) + v31);
            *(void *)(a2 + v30) = v32;
            v29 |= (unint64_t)(v33 & 0x7F) << v27;
            if (v33 < 0)
            {
              v27 += 7;
              BOOL v15 = v28++ >= 9;
              if (v15)
              {
                uint64_t v29 = 0;
                goto LABEL_55;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v29 = 0;
        }
LABEL_55:
        *(unsigned char *)(a1 + 56) = v29 != 0;
        goto LABEL_62;
      case 3u:
        uint64_t v34 = PBReaderReadData();
        uint64_t v35 = *(void **)(a1 + 40);
        *(void *)(a1 + 40) = v34;

        goto LABEL_62;
      case 4u:
        if (v18 == 2)
        {
          uint64_t result = PBReaderPlaceMark();
          if (!result) {
            return result;
          }
          while (1)
          {
            uint64_t v37 = (unint64_t *)(a2 + *v3);
            unint64_t v38 = *v37;
            unint64_t v39 = *(void *)(a2 + *v4);
            if (*v37 >= v39) {
              break;
            }
            uint64_t v40 = *v5;
            if (*(unsigned char *)(a2 + v40)) {
              break;
            }
            if (v38 > 0xFFFFFFFFFFFFFFF7 || v38 + 8 > v39) {
              *(unsigned char *)(a2 + v40) = 1;
            }
            else {
              *uint64_t v37 = v38 + 8;
            }
            PBRepeatedDoubleAdd();
          }
          PBReaderRecallMark();
        }
        else
        {
          uint64_t v42 = *v3;
          unint64_t v43 = *(void *)(a2 + v42);
          if (v43 <= 0xFFFFFFFFFFFFFFF7 && v43 + 8 <= *(void *)(a2 + *v4)) {
            *(void *)(a2 + v42) = v43 + 8;
          }
          else {
            *(unsigned char *)(a2 + v16) = 1;
          }
          PBRepeatedDoubleAdd();
        }
        goto LABEL_62;
      case 5u:
        char v41 = objc_alloc_init(HDCodableSyncIdentity);
        objc_storeStrong((id *)(a1 + 48), v41);
        if (PBReaderPlaceMark() && HDCodableSyncIdentityReadFrom((uint64_t)v41, a2))
        {
          PBReaderRecallMark();

LABEL_62:
          if (*(void *)(a2 + *v3) >= *(void *)(a2 + *v4)) {
            return *(unsigned char *)(a2 + *v5) == 0;
          }
          continue;
        }

        return 0;
      default:
        if ((PBReaderSkipValueWithTag() & 1) == 0) {
          return 0;
        }
        goto LABEL_62;
    }
  }
}

void sub_1BD2C6C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1BD2C6DB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2C7070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2C71B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2C7464(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1BD2C77F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  uint64_t v21 = va_arg(va1, void);

  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);

  _Unwind_Resume(a1);
}

void sub_1BD2C7CB8(_Unwind_Exception *a1)
{
  operator delete(v2);

  _Unwind_Resume(a1);
}

void sub_1BD2C7FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_1BD2C8690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1BD2C8E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_1BD2C9164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1BD2C9300(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<long,std::hash<long>,std::equal_to<long>,std::allocator<long>>::__erase_unique<long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v4 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v4 = (*(void *)&v2 - 1) & a2;
  }
  unint64_t v5 = *(void ***)(*a1 + 8 * v4);
  if (!v5) {
    return;
  }
  id v6 = *v5;
  if (!v6) {
    return;
  }
  uint64_t v7 = *(void *)&v2 - 1;
  while (1)
  {
    unint64_t v8 = v6[1];
    if (v8 == a2) {
      break;
    }
    if (v3.u32[0] > 1uLL)
    {
      if (v8 >= *(void *)&v2) {
        v8 %= *(void *)&v2;
      }
    }
    else
    {
      v8 &= v7;
    }
    if (v8 != v4) {
      return;
    }
LABEL_17:
    id v6 = (void *)*v6;
    if (!v6) {
      return;
    }
  }
  if (v6[2] != a2) {
    goto LABEL_17;
  }
  unsigned int v9 = (void *)*v6;
  if (v3.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v2) {
      v8 %= *(void *)&v2;
    }
  }
  else
  {
    v8 &= v7;
  }
  unint64_t v10 = *(void **)(*a1 + 8 * v8);
  do
  {
    uint64_t v11 = v10;
    unint64_t v10 = (void *)*v10;
  }
  while (v10 != v6);
  if (v11 == a1 + 2) {
    goto LABEL_36;
  }
  unint64_t v12 = v11[1];
  if (v3.u32[0] > 1uLL)
  {
    if (v12 >= *(void *)&v2) {
      v12 %= *(void *)&v2;
    }
  }
  else
  {
    v12 &= v7;
  }
  if (v12 == v8)
  {
LABEL_38:
    if (v9)
    {
      unint64_t v13 = v9[1];
      goto LABEL_40;
    }
  }
  else
  {
LABEL_36:
    if (!v9) {
      goto LABEL_37;
    }
    unint64_t v13 = v9[1];
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v14 = v9[1];
      if (v13 >= *(void *)&v2) {
        unint64_t v14 = v13 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v14 = v13 & v7;
    }
    if (v14 != v8)
    {
LABEL_37:
      *(void *)(*a1 + 8 * v_Block_object_dispose(&STACK[0x340], 8) = 0;
      unsigned int v9 = (void *)*v6;
      goto LABEL_38;
    }
LABEL_40:
    if (v3.u32[0] > 1uLL)
    {
      if (v13 >= *(void *)&v2) {
        v13 %= *(void *)&v2;
      }
    }
    else
    {
      v13 &= v7;
    }
    if (v13 != v8)
    {
      *(void *)(*a1 + 8 * v13) = v11;
      unsigned int v9 = (void *)*v6;
    }
  }
  void *v11 = v9;
  *id v6 = 0;
  --a1[3];
  operator delete(v6);
}

void sub_1BD2CA554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t HDCodableMedicalUserDomainConceptReadFrom(uint64_t a1, uint64_t a2)
{
  uint8x8_t v3 = (int *)MEMORY[0x1E4F940E8];
  unint64_t v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      int v16 = v10 & 7;
      if (v15 || v16 == 4) {
        break;
      }
      if ((v10 >> 3) == 2)
      {
        if (v16 == 2)
        {
          uint64_t result = PBReaderPlaceMark();
          if (!result) {
            return result;
          }
          while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4) && !*(unsigned char *)(a2 + *v5))
          {
            char v21 = 0;
            unsigned int v22 = 0;
            uint64_t v23 = 0;
            while (1)
            {
              uint64_t v24 = *v3;
              unint64_t v25 = *(void *)(a2 + v24);
              if (v25 == -1 || v25 >= *(void *)(a2 + *v4)) {
                break;
              }
              char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v25);
              *(void *)(a2 + v24) = v25 + 1;
              v23 |= (unint64_t)(v26 & 0x7F) << v21;
              if (v26 < 0)
              {
                v21 += 7;
                BOOL v14 = v22++ >= 9;
                if (!v14) {
                  continue;
                }
              }
              goto LABEL_33;
            }
            *(unsigned char *)(a2 + *v5) = 1;
LABEL_33:
            PBRepeatedInt64Add();
          }
          PBReaderRecallMark();
        }
        else
        {
          char v27 = 0;
          unsigned int v28 = 0;
          uint64_t v29 = 0;
          while (1)
          {
            uint64_t v30 = *v3;
            unint64_t v31 = *(void *)(a2 + v30);
            if (v31 == -1 || v31 >= *(void *)(a2 + *v4)) {
              break;
            }
            char v32 = *(unsigned char *)(*(void *)(a2 + *v7) + v31);
            *(void *)(a2 + v30) = v31 + 1;
            v29 |= (unint64_t)(v32 & 0x7F) << v27;
            if (v32 < 0)
            {
              v27 += 7;
              BOOL v14 = v28++ >= 9;
              if (!v14) {
                continue;
              }
            }
            goto LABEL_45;
          }
          *(unsigned char *)(a2 + *v5) = 1;
LABEL_45:
          PBRepeatedInt64Add();
        }
      }
      else if ((v10 >> 3) == 1)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = *(void **)(a1 + 32);
        *(void *)(a1 + 32) = v18;
      }
      else if ((PBReaderSkipValueWithTag() & 1) == 0)
      {
        return 0;
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

void sub_1BD2CDA04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__208(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__208(uint64_t a1)
{
}

void sub_1BD2CE8E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2CF2E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2D0540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void sub_1BD2D0744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2D0EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__209(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__209(uint64_t a1)
{
}

id HDCachedQueryMetadataEntityAllProperties()
{
  v2[11] = *MEMORY[0x1E4F143B8];
  v2[0] = @"query_identifier";
  v2[1] = @"source_id";
  v2[2] = @"generation_number";
  v2[3] = @"max_anchor";
  v2[4] = @"last_query_start_index";
  void v2[5] = @"last_query_end_index";
  v2[6] = @"last_updated_date";
  v2[7] = @"creation_date";
  v2[8] = @"build_version";
  v2[9] = @"anchor_date";
  v2[10] = @"interval_components";
  uint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:11];

  return v0;
}

void sub_1BD2D4A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id HDCachedQueryMetadataEntityPredicateForQueryIdentifierAndSource(uint64_t a1, void *a2)
{
  v15[2] = *MEMORY[0x1E4F143B8];
  uint8x8_t v3 = (void *)MEMORY[0x1E4F65D00];
  id v4 = a2;
  unint64_t v5 = [v3 predicateWithProperty:@"query_identifier" equalToValue:a1];
  id v6 = (void *)MEMORY[0x1E4F65D00];
  uint64_t v7 = NSNumber;
  uint64_t v8 = [v4 persistentID];

  unsigned int v9 = [v7 numberWithLongLong:v8];
  unint64_t v10 = [v6 predicateWithProperty:@"source_id" equalToValue:v9];

  uint64_t v11 = (void *)MEMORY[0x1E4F65D08];
  v15[0] = v5;
  v15[1] = v10;
  unint64_t v12 = [MEMORY[0x1E4F1C978] arrayWithObjects:v15 count:2];
  char v13 = [v11 predicateMatchingAllPredicates:v12];

  return v13;
}

uint64_t __Block_byref_object_copy__210(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__210(uint64_t a1)
{
}

void sub_1BD2D5080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2D52BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2D5618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t HDCodableTinkerOptInResponseReadFrom(uint64_t a1, uint64_t a2)
{
  uint8x8_t v3 = (int *)MEMORY[0x1E4F940E8];
  id v4 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v5 = (int *)MEMORY[0x1E4F940C8];
  if (*(void *)(a2 + (int)*MEMORY[0x1E4F940E8]) < *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]))
  {
    uint64_t v7 = (int *)MEMORY[0x1E4F940B8];
    do
    {
      if (*(unsigned char *)(a2 + *v5)) {
        break;
      }
      char v8 = 0;
      unsigned int v9 = 0;
      unint64_t v10 = 0;
      while (1)
      {
        uint64_t v11 = *v3;
        unint64_t v12 = *(void *)(a2 + v11);
        if (v12 == -1 || v12 >= *(void *)(a2 + *v4)) {
          break;
        }
        char v13 = *(unsigned char *)(*(void *)(a2 + *v7) + v12);
        *(void *)(a2 + v11) = v12 + 1;
        v10 |= (unint64_t)(v13 & 0x7F) << v8;
        if ((v13 & 0x80) == 0) {
          goto LABEL_12;
        }
        v8 += 7;
        BOOL v14 = v9++ >= 9;
        if (v14)
        {
          unint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(a2 + *v5);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + *v5) = 1;
LABEL_12:
      int v15 = *(unsigned __int8 *)(a2 + *v5);
      if (*(unsigned char *)(a2 + *v5)) {
        unint64_t v10 = 0;
      }
LABEL_14:
      if (v15 || (v10 & 7) == 4) {
        break;
      }
      unint64_t v17 = v10 >> 3;
      if ((v10 >> 3) == 3)
      {
        uint64_t v20 = objc_alloc_init(HDCodableError);
        objc_storeStrong((id *)(a1 + 8), v20);
        if (!PBReaderPlaceMark() || (HDCodableErrorReadFrom((uint64_t)v20, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
      else if (v17 == 2)
      {
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 28) |= 1u;
        while (1)
        {
          uint64_t v24 = *v3;
          unint64_t v25 = *(void *)(a2 + v24);
          if (v25 == -1 || v25 >= *(void *)(a2 + *v4)) {
            break;
          }
          char v26 = *(unsigned char *)(*(void *)(a2 + *v7) + v25);
          *(void *)(a2 + v24) = v25 + 1;
          v23 |= (unint64_t)(v26 & 0x7F) << v21;
          if ((v26 & 0x80) == 0) {
            goto LABEL_35;
          }
          v21 += 7;
          BOOL v14 = v22++ >= 9;
          if (v14)
          {
            uint64_t v23 = 0;
            goto LABEL_37;
          }
        }
        *(unsigned char *)(a2 + *v5) = 1;
LABEL_35:
        if (*(unsigned char *)(a2 + *v5)) {
          uint64_t v23 = 0;
        }
LABEL_37:
        *(unsigned char *)(a1 + 24) = v23 != 0;
      }
      else if (v17 == 1)
      {
        uint64_t v18 = PBReaderReadString();
        uint64_t v19 = *(void **)(a1 + 16);
        *(void *)(a1 + 16) = v18;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
    }
    while (*(void *)(a2 + *v3) < *(void *)(a2 + *v4));
  }
  return *(unsigned char *)(a2 + *v5) == 0;
}

id HDQuantitySampleEntityPredicateForQuantity(uint64_t a1)
{
  int8x8_t v2 = (void *)MEMORY[0x1E4F65D00];
  uint8x8_t v3 = _HDSQLiteValueForNumber();
  id v4 = [v2 predicateWithProperty:@"quantity" value:v3 comparisonType:a1];

  return v4;
}

uint64_t HDQuantitySampleEntityPredicateForCount(uint64_t a1, uint64_t a2)
{
  return [MEMORY[0x1E4F65D00] predicateWithProperty:@"count" ifNullValue:&unk_1F17EF2A0 value:a2 comparisonType:a1];
}

void sub_1BD2D9554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__211(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__211(uint64_t a1)
{
}

void sub_1BD2DA6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2DC41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose((const void *)(v71 - 152), 8);
  _Block_object_dispose(&a65, 8);
  _Block_object_dispose(&a71, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2DD6FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2DF1D4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1BD2E0A8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1BD2E1130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose(&a40, 8);
  _Block_object_dispose(&a44, 8);
  _Block_object_dispose((const void *)(v44 - 216), 8);
  _Block_object_dispose((const void *)(v44 - 168), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__212(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__212(uint64_t a1)
{
}

void sub_1BD2E2DB4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 256), 8);
  _Unwind_Resume(a1);
}

void sub_1BD2E3B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__213(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__213(uint64_t a1)
{
}

uint64_t sub_1BD2E45F0()
{
  return MEMORY[0x1F40E34A0]();
}

uint64_t sub_1BD2E4600()
{
  return MEMORY[0x1F40E34E8]();
}

uint64_t sub_1BD2E4610()
{
  return MEMORY[0x1F40E3530]();
}

uint64_t sub_1BD2E4620()
{
  return MEMORY[0x1F40E4540]();
}

uint64_t sub_1BD2E4630()
{
  return MEMORY[0x1F40E4550]();
}

uint64_t sub_1BD2E4640()
{
  return MEMORY[0x1F40E4DA8]();
}

uint64_t sub_1BD2E4650()
{
  return MEMORY[0x1F40E52E0]();
}

uint64_t sub_1BD2E4660()
{
  return MEMORY[0x1F40E5388]();
}

uint64_t sub_1BD2E4670()
{
  return MEMORY[0x1F40E53B0]();
}

uint64_t sub_1BD2E4680()
{
  return MEMORY[0x1F40E53C8]();
}

uint64_t sub_1BD2E4690()
{
  return MEMORY[0x1F40E53F8]();
}

uint64_t sub_1BD2E46A0()
{
  return MEMORY[0x1F40E5448]();
}

uint64_t sub_1BD2E46B0()
{
  return MEMORY[0x1F4188670]();
}

uint64_t sub_1BD2E46C0()
{
  return MEMORY[0x1F41886A0]();
}

uint64_t sub_1BD2E46D0()
{
  return MEMORY[0x1F41886B0]();
}

uint64_t sub_1BD2E46E0()
{
  return MEMORY[0x1F4186CB0]();
}

uint64_t sub_1BD2E46F0()
{
  return MEMORY[0x1F4186CF8]();
}

uint64_t sub_1BD2E4700()
{
  return MEMORY[0x1F4186D60]();
}

uint64_t sub_1BD2E4710()
{
  return MEMORY[0x1F40E78D0]();
}

uint64_t sub_1BD2E4720()
{
  return MEMORY[0x1F40E78D8]();
}

uint64_t sub_1BD2E4730()
{
  return MEMORY[0x1F40E78E0]();
}

uint64_t sub_1BD2E4740()
{
  return MEMORY[0x1F40E78E8]();
}

uint64_t sub_1BD2E4750()
{
  return MEMORY[0x1F40E6000]();
}

uint64_t sub_1BD2E4760()
{
  return MEMORY[0x1F40E6190]();
}

uint64_t sub_1BD2E4770()
{
  return MEMORY[0x1F40E61D8]();
}

uint64_t sub_1BD2E4780()
{
  return MEMORY[0x1F4183880]();
}

uint64_t sub_1BD2E4790()
{
  return MEMORY[0x1F41839B0]();
}

uint64_t sub_1BD2E47A0()
{
  return MEMORY[0x1F4183A38]();
}

uint64_t sub_1BD2E47B0()
{
  return MEMORY[0x1F4183A80]();
}

uint64_t sub_1BD2E47C0()
{
  return MEMORY[0x1F4183E80]();
}

uint64_t sub_1BD2E47D0()
{
  return MEMORY[0x1F40E6338]();
}

uint64_t sub_1BD2E47E0()
{
  return MEMORY[0x1F40E6370]();
}

uint64_t sub_1BD2E47F0()
{
  return MEMORY[0x1F4183E98]();
}

uint64_t sub_1BD2E4800()
{
  return MEMORY[0x1F4183EC8]();
}

uint64_t sub_1BD2E4810()
{
  return MEMORY[0x1F4183F38]();
}

uint64_t sub_1BD2E4820()
{
  return MEMORY[0x1F4183FA8]();
}

uint64_t sub_1BD2E4830()
{
  return MEMORY[0x1F41886C0]();
}

uint64_t sub_1BD2E4840()
{
  return MEMORY[0x1F41886E0]();
}

uint64_t sub_1BD2E4850()
{
  return MEMORY[0x1F4188700]();
}

uint64_t sub_1BD2E4860()
{
  return MEMORY[0x1F40E7960]();
}

uint64_t sub_1BD2E4870()
{
  return MEMORY[0x1F41870E0]();
}

uint64_t sub_1BD2E4880()
{
  return MEMORY[0x1F4184640]();
}

uint64_t sub_1BD2E4890()
{
  return MEMORY[0x1F41847C0]();
}

uint64_t sub_1BD2E48A0()
{
  return MEMORY[0x1F4184820]();
}

uint64_t sub_1BD2E48B0()
{
  return MEMORY[0x1F4184978]();
}

uint64_t sub_1BD2E48C0()
{
  return MEMORY[0x1F4184B18]();
}

uint64_t sub_1BD2E48D0()
{
  return MEMORY[0x1F4184B20]();
}

uint64_t sub_1BD2E48E0()
{
  return MEMORY[0x1F4184CE8]();
}

uint64_t sub_1BD2E48F0()
{
  return MEMORY[0x1F4184CF0]();
}

uint64_t sub_1BD2E4900()
{
  return MEMORY[0x1F4184D80]();
}

uint64_t sub_1BD2E4910()
{
  return MEMORY[0x1F4184E38]();
}

uint64_t sub_1BD2E4920()
{
  return MEMORY[0x1F4184E68]();
}

uint64_t sub_1BD2E4930()
{
  return MEMORY[0x1F4184EC8]();
}

uint64_t sub_1BD2E4940()
{
  return MEMORY[0x1F4184ED8]();
}

uint64_t sub_1BD2E4950()
{
  return MEMORY[0x1F4184EF0]();
}

uint64_t sub_1BD2E4960()
{
  return MEMORY[0x1F4184F28]();
}

uint64_t sub_1BD2E4970()
{
  return MEMORY[0x1F4184F30]();
}

uint64_t sub_1BD2E4980()
{
  return MEMORY[0x1F4185050]();
}

uint64_t sub_1BD2E4990()
{
  return MEMORY[0x1F4185298]();
}

uint64_t sub_1BD2E49A0()
{
  return MEMORY[0x1F41852B0]();
}

uint64_t sub_1BD2E49B0()
{
  return MEMORY[0x1F4185350]();
}

uint64_t sub_1BD2E49C0()
{
  return MEMORY[0x1F4185368]();
}

uint64_t sub_1BD2E49D0()
{
  return MEMORY[0x1F4185370]();
}

uint64_t sub_1BD2E49E0()
{
  return MEMORY[0x1F4185380]();
}

uint64_t sub_1BD2E49F0()
{
  return MEMORY[0x1F4185388]();
}

uint64_t sub_1BD2E4A00()
{
  return MEMORY[0x1F4185398]();
}

uint64_t sub_1BD2E4A10()
{
  return MEMORY[0x1F4185758]();
}

uint64_t sub_1BD2E4A20()
{
  return MEMORY[0x1F4185768]();
}

uint64_t sub_1BD2E4A30()
{
  return MEMORY[0x1F4185A40]();
}

uint64_t sub_1BD2E4A40()
{
  return MEMORY[0x1F4185B90]();
}

uint64_t sub_1BD2E4A50()
{
  return MEMORY[0x1F4185DE0]();
}

uint64_t sub_1BD2E4A60()
{
  return MEMORY[0x1F4185E00]();
}

uint64_t sub_1BD2E4A70()
{
  return MEMORY[0x1F4185E08]();
}

uint64_t sub_1BD2E4A80()
{
  return MEMORY[0x1F4185E10]();
}

uint64_t sub_1BD2E4A90()
{
  return MEMORY[0x1F4185E18]();
}

uint64_t sub_1BD2E4AA0()
{
  return MEMORY[0x1F4185EB0]();
}

uint64_t sub_1BD2E4AB0()
{
  return MEMORY[0x1F4185EF8]();
}

uint64_t sub_1BD2E4AC0()
{
  return MEMORY[0x1F4186318]();
}

int AAByteStreamClose(AAByteStream s)
{
  return MEMORY[0x1F41792A8](s);
}

ssize_t AAByteStreamPRead(AAByteStream s, void *buf, size_t nbyte, off_t offset)
{
  return MEMORY[0x1F41792B8](s, buf, nbyte, offset);
}

ssize_t AAByteStreamWrite(AAByteStream s, const void *buf, size_t nbyte)
{
  return MEMORY[0x1F41792C0](s, buf, nbyte);
}

AAByteStream AAFileStreamOpenWithFD(int fd, int automatic_close)
{
  return (AAByteStream)MEMORY[0x1F4179340](*(void *)&fd, *(void *)&automatic_close);
}

CFArrayRef ABAddressBookCopyPeopleWithName(ABAddressBookRef addressBook, CFStringRef name)
{
  return (CFArrayRef)MEMORY[0x1F40D39D0](addressBook, name);
}

ABAddressBookRef ABAddressBookCreateWithOptions(CFDictionaryRef options, CFErrorRef *error)
{
  return (ABAddressBookRef)MEMORY[0x1F40D39D8](options, error);
}

ABRecordRef ABAddressBookGetPersonWithRecordID(ABAddressBookRef addressBook, ABRecordID recordID)
{
  return (ABRecordRef)MEMORY[0x1F40D39E0](addressBook, *(void *)&recordID);
}

CFTypeRef ABMultiValueCopyValueAtIndex(ABMultiValueRef multiValue, CFIndex index)
{
  return (CFTypeRef)MEMORY[0x1F40D39E8](multiValue, index);
}

CFIndex ABMultiValueGetCount(ABMultiValueRef multiValue)
{
  return MEMORY[0x1F40D39F0](multiValue);
}

ABMultiValueIdentifier ABMultiValueGetIdentifierAtIndex(ABMultiValueRef multiValue, CFIndex index)
{
  return MEMORY[0x1F40D39F8](multiValue, index);
}

CFTypeRef ABRecordCopyValue(ABRecordRef record, ABPropertyID property)
{
  return (CFTypeRef)MEMORY[0x1F40D3A08](record, *(void *)&property);
}

ABRecordID ABRecordGetRecordID(ABRecordRef record)
{
  return MEMORY[0x1F40D3A10](record);
}

AEAContext AEAContextCreateWithEncryptedStream(AAByteStream encrypted_stream)
{
  return (AEAContext)MEMORY[0x1F4179400](encrypted_stream);
}

AEAContext AEAContextCreateWithProfile(AEAProfile profile)
{
  return (AEAContext)MEMORY[0x1F4179408](*(void *)&profile);
}

void AEAContextDestroy(AEAContext context)
{
}

int AEAContextSetFieldBlob(AEAContext context, AEAContextField field, AEAContextFieldRepresentation representation, const uint8_t *buf, size_t buf_size)
{
  return MEMORY[0x1F4179420](context, *(void *)&field, *(void *)&representation, buf, buf_size);
}

int AEAContextSetFieldUInt(AEAContext context, AEAContextField field, uint64_t value)
{
  return MEMORY[0x1F4179428](context, *(void *)&field, value);
}

AAByteStream AEADecryptionRandomAccessInputStreamOpen(AAByteStream encrypted_stream, AEAContext context, size_t alloc_limit, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)MEMORY[0x1F4179438](encrypted_stream, context, alloc_limit, flags, *(void *)&n_threads);
}

AAByteStream AEAEncryptionOutputStreamOpen(AAByteStream encrypted_stream, AEAContext context, AAFlagSet flags, int n_threads)
{
  return (AAByteStream)MEMORY[0x1F4179440](encrypted_stream, context, flags, *(void *)&n_threads);
}

uint64_t ASServerURLForAssetType()
{
  return MEMORY[0x1F412F560]();
}

uint64_t ASSetAssetServerURLForAssetType()
{
  return MEMORY[0x1F412F568]();
}

uint64_t AnalyticsIsEventUsed()
{
  return MEMORY[0x1F4113888]();
}

uint64_t AnalyticsSendEvent()
{
  return MEMORY[0x1F41138A0]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1F41138B8]();
}

uint64_t BackgroundTaskAgentAddJob()
{
  return MEMORY[0x1F410C0A0]();
}

uint64_t BackgroundTaskAgentCopyJob()
{
  return MEMORY[0x1F410C0A8]();
}

uint64_t BackgroundTaskAgentInit()
{
  return MEMORY[0x1F410C0B0]();
}

uint64_t BackgroundTaskAgentRemoveJob()
{
  return MEMORY[0x1F410C0B8]();
}

uint64_t BiomeLibrary()
{
  return MEMORY[0x1F410C8D0]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  return (CFStringRef)MEMORY[0x1F40D77D0](type_id);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x1F40D7860]();
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  MEMORY[0x1F40D7928](theDate);
  return result;
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D08]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

Boolean CFPreferencesAppSynchronize(CFStringRef applicationID)
{
  return MEMORY[0x1F40D7E90](applicationID);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

Boolean CFPreferencesGetAppBooleanValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE0](key, applicationID, keyExistsAndHasValidFormat);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE8](key, applicationID, keyExistsAndHasValidFormat);
}

void CFPreferencesSetAppValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID)
{
}

void CFPreferencesSetValue(CFStringRef key, CFPropertyListRef value, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
}

Boolean CFPreferencesSynchronize(CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return MEMORY[0x1F40D7F10](applicationID, userName, hostName);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

uint64_t CKDatabaseScopeString()
{
  return MEMORY[0x1F40D62F0]();
}

uint64_t CKStringFromAccountStatus()
{
  return MEMORY[0x1F40D6490]();
}

uint64_t CKStringFromDeviceToDeviceEncryptionStatus()
{
  return MEMORY[0x1F40D6498]();
}

uint64_t CKStringFromPartition()
{
  return MEMORY[0x1F40D64B0]();
}

CLLocationCoordinate2D CLLocationCoordinate2DMake(CLLocationDegrees latitude, CLLocationDegrees longitude)
{
  MEMORY[0x1F40DB5A0](latitude, longitude);
  result.longitude = v3;
  result.latitude = v2;
  return result;
}

uint64_t CacheDeleteRegisterInfoCallbacks()
{
  return MEMORY[0x1F410DCF0]();
}

uint64_t GSSystemRootDirectory()
{
  return MEMORY[0x1F411CA28]();
}

uint64_t HDDiagnosticStringFromDate()
{
  return MEMORY[0x1F411D490]();
}

uint64_t HDDiagnosticStringFromDuration()
{
  return MEMORY[0x1F411D498]();
}

uint64_t HDIsUnitTesting()
{
  return MEMORY[0x1F411D4A0]();
}

uint64_t HDSQLOperatorForComparisonType()
{
  return MEMORY[0x1F411D4A8]();
}

uint64_t HDSQLiteBindBooleanToProperty()
{
  return MEMORY[0x1F411D4B0]();
}

uint64_t HDSQLiteBindDataToProperty()
{
  return MEMORY[0x1F411D4B8]();
}

uint64_t HDSQLiteBindDateToProperty()
{
  return MEMORY[0x1F411D4C0]();
}

uint64_t HDSQLiteBindDoubleToProperty()
{
  return MEMORY[0x1F411D4C8]();
}

uint64_t HDSQLiteBindFoundationValueToStatement()
{
  return MEMORY[0x1F411D4D0]();
}

uint64_t HDSQLiteBindFoundationValuesToStatement()
{
  return MEMORY[0x1F411D4D8]();
}

uint64_t HDSQLiteBindInt64ToProperty()
{
  return MEMORY[0x1F411D4E0]();
}

uint64_t HDSQLiteBindNullToProperty()
{
  return MEMORY[0x1F411D4E8]();
}

uint64_t HDSQLiteBindNumberToProperty()
{
  return MEMORY[0x1F411D4F0]();
}

uint64_t HDSQLiteBindSecureCodingObjectToProperty()
{
  return MEMORY[0x1F411D4F8]();
}

uint64_t HDSQLiteBindStringToProperty()
{
  return MEMORY[0x1F411D500]();
}

uint64_t HDSQLiteBindStringToStatement()
{
  return MEMORY[0x1F411D508]();
}

uint64_t HDSQLiteBindToProperty()
{
  return MEMORY[0x1F411D510]();
}

uint64_t HDSQLiteBindUUIDToProperty()
{
  return MEMORY[0x1F411D518]();
}

uint64_t HDSQLiteColumnAsBoolean()
{
  return MEMORY[0x1F411D520]();
}

uint64_t HDSQLiteColumnAsBytes()
{
  return MEMORY[0x1F411D528]();
}

uint64_t HDSQLiteColumnAsData()
{
  return MEMORY[0x1F411D530]();
}

uint64_t HDSQLiteColumnAsDate()
{
  return MEMORY[0x1F411D538]();
}

uint64_t HDSQLiteColumnAsDouble()
{
  return MEMORY[0x1F411D540]();
}

uint64_t HDSQLiteColumnAsInt64()
{
  return MEMORY[0x1F411D548]();
}

uint64_t HDSQLiteColumnAsNaturalType()
{
  return MEMORY[0x1F411D550]();
}

uint64_t HDSQLiteColumnAsNumber()
{
  return MEMORY[0x1F411D558]();
}

uint64_t HDSQLiteColumnAsString()
{
  return MEMORY[0x1F411D560]();
}

uint64_t HDSQLiteColumnAsUUID()
{
  return MEMORY[0x1F411D568]();
}

uint64_t HDSQLiteColumnBytesLength()
{
  return MEMORY[0x1F411D570]();
}

uint64_t HDSQLiteColumnIsNonNull()
{
  return MEMORY[0x1F411D578]();
}

uint64_t HDSQLiteColumnIsNull()
{
  return MEMORY[0x1F411D580]();
}

uint64_t HDSQLiteColumnWithName()
{
  return MEMORY[0x1F411D588]();
}

uint64_t HDSQLiteColumnWithNameAsArrayOfClass()
{
  return MEMORY[0x1F411D590]();
}

uint64_t HDSQLiteColumnWithNameAsBoolean()
{
  return MEMORY[0x1F411D598]();
}

uint64_t HDSQLiteColumnWithNameAsData()
{
  return MEMORY[0x1F411D5A0]();
}

uint64_t HDSQLiteColumnWithNameAsDate()
{
  return MEMORY[0x1F411D5A8]();
}

uint64_t HDSQLiteColumnWithNameAsDouble()
{
  return MEMORY[0x1F411D5B0]();
}

uint64_t HDSQLiteColumnWithNameAsInt64()
{
  return MEMORY[0x1F411D5B8]();
}

uint64_t HDSQLiteColumnWithNameAsInteger()
{
  return MEMORY[0x1F411D5C0]();
}

uint64_t HDSQLiteColumnWithNameAsNaturalType()
{
  return MEMORY[0x1F411D5C8]();
}

uint64_t HDSQLiteColumnWithNameAsNonEmptyString()
{
  return MEMORY[0x1F411D5D0]();
}

uint64_t HDSQLiteColumnWithNameAsNumber()
{
  return MEMORY[0x1F411D5D8]();
}

uint64_t HDSQLiteColumnWithNameAsObject()
{
  return MEMORY[0x1F411D5E0]();
}

uint64_t HDSQLiteColumnWithNameAsObjectWithClasses()
{
  return MEMORY[0x1F411D5E8]();
}

uint64_t HDSQLiteColumnWithNameAsString()
{
  return MEMORY[0x1F411D5F0]();
}

uint64_t HDSQLiteColumnWithNameAsURL()
{
  return MEMORY[0x1F411D5F8]();
}

uint64_t HDSQLiteColumnWithNameAsUUID()
{
  return MEMORY[0x1F411D600]();
}

uint64_t HDSQLiteColumnWithNameIsNull()
{
  return MEMORY[0x1F411D608]();
}

uint64_t HDSQLiteComparisonTypeForPredicateOperator()
{
  return MEMORY[0x1F411D610]();
}

uint64_t HDSQLiteEntityCreateTableSQL()
{
  return MEMORY[0x1F411D618]();
}

uint64_t HDSQLiteEntityEnumerateColumns()
{
  return MEMORY[0x1F411D620]();
}

uint64_t HDStringFromContentProtectionState()
{
  return MEMORY[0x1F411D628]();
}

uint64_t HDStringFromGatedActivityResult()
{
  return MEMORY[0x1F411D630]();
}

uint64_t HDStringRepresentationForRecipientIdentifier()
{
  return MEMORY[0x1F40E7A10]();
}

uint64_t HKActivityMoveModeToString()
{
  return MEMORY[0x1F40E7A18]();
}

uint64_t HKAllCollectibleTypesWithStoreDemoModeEnabled()
{
  return MEMORY[0x1F40E7A20]();
}

uint64_t HKAppleIrregularRhythmNotificationsAlgorithmVersionForPrivateVersionString()
{
  return MEMORY[0x1F40E7A78]();
}

uint64_t HKAuthorizationIdentifiersFromSharingAuthorizations()
{
  return MEMORY[0x1F40E7AA8]();
}

uint64_t HKAuthorizationStatusAllowsReading()
{
  return MEMORY[0x1F40E7AB0]();
}

uint64_t HKAuthorizationStatusAllowsSharing()
{
  return MEMORY[0x1F40E7AB8]();
}

uint64_t HKAuthorizationStatusToString()
{
  return MEMORY[0x1F40E7AC0]();
}

uint64_t HKBitPatternCastSignedToUnsignedInt64()
{
  return MEMORY[0x1F40E7AE8]();
}

uint64_t HKBitPatternCastUnsignedToSignedInt64()
{
  return MEMORY[0x1F40E7AF0]();
}

uint64_t HKCloudSyncFullSyncReasonToString()
{
  return MEMORY[0x1F40E7B20]();
}

uint64_t HKCloudSyncOptionsToString()
{
  return MEMORY[0x1F40E7B28]();
}

uint64_t HKCloudSyncReasonToString()
{
  return MEMORY[0x1F40E7B30]();
}

uint64_t HKCompareIntegers()
{
  return MEMORY[0x1F40E7B40]();
}

uint64_t HKCompareUUIDBytes()
{
  return MEMORY[0x1F40E7B48]();
}

uint64_t HKConditionallyRedactedHeartRhythmString()
{
  return MEMORY[0x1F40E7B50]();
}

uint64_t HKConnectedGymSourceName()
{
  return MEMORY[0x1F40E7B58]();
}

uint64_t HKCopyQueryDescription()
{
  return MEMORY[0x1F40E7B60]();
}

uint64_t HKCoreMotionSupportsEstimatedWorkoutEffortForActivityType()
{
  return MEMORY[0x1F40E7B68]();
}

uint64_t HKCreateConcurrentDispatchQueue()
{
  return MEMORY[0x1F40E7B90]();
}

uint64_t HKCreateConcurrentDispatchQueueWithQOSClass()
{
  return MEMORY[0x1F40E7B98]();
}

uint64_t HKCreateSerialDispatchQueue()
{
  return MEMORY[0x1F40E7BA0]();
}

uint64_t HKCreateSerialDispatchQueueWithQOSClass()
{
  return MEMORY[0x1F40E7BA8]();
}

uint64_t HKCreateSerialUtilityDispatchQueue()
{
  return MEMORY[0x1F40E7BB0]();
}

uint64_t HKCurrentLocaleCountryCodeIfUnknown()
{
  return MEMORY[0x1F40E7BB8]();
}

uint64_t HKCurrentSchemaVersionForShardIdentifier()
{
  return MEMORY[0x1F40E7BC0]();
}

uint64_t HKDataCollectionTypeToString()
{
  return MEMORY[0x1F40E7BC8]();
}

uint64_t HKDataTypeRequiresAuthorization()
{
  return MEMORY[0x1F40E7BD0]();
}

uint64_t HKDataTypeRequiresPerObjectAuthorization()
{
  return MEMORY[0x1F40E7BD8]();
}

uint64_t HKDateMax()
{
  return MEMORY[0x1F40E7BF0]();
}

uint64_t HKDateMin()
{
  return MEMORY[0x1F40E7C00]();
}

uint64_t HKDefaultAggregationIntervalForType()
{
  return MEMORY[0x1F40E7C08]();
}

uint64_t HKDefaultCollectionLatencyForType()
{
  return MEMORY[0x1F40E7C10]();
}

uint64_t HKDefaultMaximumSeriesDurationForType()
{
  return MEMORY[0x1F40E7C18]();
}

uint64_t HKDefaultObjectValidationConfiguration()
{
  return MEMORY[0x1F40E7C20]();
}

uint64_t HKDefaultObjectValidationConfigurationIgnoringAllOptions()
{
  return MEMORY[0x1F40E7C28]();
}

uint64_t HKDefaultOntologyServerBaseURL()
{
  return MEMORY[0x1F40E7C30]();
}

uint64_t HKDiagnosticStringFromDate()
{
  return MEMORY[0x1F40E7C58]();
}

uint64_t HKDiagnosticStringFromDuration()
{
  return MEMORY[0x1F40E7C60]();
}

uint64_t HKDiagnosticStringFromUUID()
{
  return MEMORY[0x1F40E7C68]();
}

uint64_t HKDispatchAsyncOnGlobalConcurrentQueue()
{
  return MEMORY[0x1F40E7C78]();
}

uint64_t HKElectrocardiogramSymptomsStatusFromPrivateElectrocardiogramSymptoms()
{
  return MEMORY[0x1F40E7CA0]();
}

uint64_t HKFeatureFlagBloodOxygenSaturationEnabled()
{
  return MEMORY[0x1F40E7CE0]();
}

uint64_t HKFeatureFlagWorkoutSeriesAggregation()
{
  return MEMORY[0x1F40E7CE8]();
}

uint64_t HKFeatureIdentifierIsProvidedBySleepDaemon()
{
  return MEMORY[0x1F40E7CF0]();
}

uint64_t HKFeaturePropertiesChangeNotificationForFeatureIdentifier()
{
  return MEMORY[0x1F40E7CF8]();
}

uint64_t HKHealthKitFrameworkBundle()
{
  return MEMORY[0x1F40E7D10]();
}

uint64_t HKHeartRateMotionContextForPrivateHeartRateContext()
{
  return MEMORY[0x1F40E7D40]();
}

uint64_t HKImproveHealthAndActivityAnalyticsAllowed()
{
  return MEMORY[0x1F40E7D50]();
}

uint64_t HKIntersectionDayIndexRange()
{
  return MEMORY[0x1F40E7D60]();
}

uint64_t HKIsDeprecatedPropertyType()
{
  return MEMORY[0x1F40E7D68]();
}

uint64_t HKIsFitnessTrackingEnabled()
{
  return MEMORY[0x1F40E7D70]();
}

uint64_t HKIsHeartRateEnabled()
{
  return MEMORY[0x1F40E7D78]();
}

uint64_t HKIsKnownOntologyShardIdentifier()
{
  return MEMORY[0x1F40E7D80]();
}

uint64_t HKIsUnitTesting()
{
  return MEMORY[0x1F40E7D88]();
}

uint64_t HKIsValidUserDomainConceptPropertyValueType()
{
  return MEMORY[0x1F40E7D90]();
}

uint64_t HKLocalDeviceHardwareSupportsWristTemperatureMeasurements()
{
  return MEMORY[0x1F40E7D98]();
}

uint64_t HKLogAnalytics()
{
  return MEMORY[0x1F40E7DA8]();
}

uint64_t HKLogAssertions()
{
  return MEMORY[0x1F40E7DB0]();
}

uint64_t HKLogConceptIndex()
{
  return MEMORY[0x1F40E7DC0]();
}

uint64_t HKLogHealthOntology()
{
  return MEMORY[0x1F40E7DC8]();
}

uint64_t HKLogInfrastructure()
{
  return MEMORY[0x1F40E7DD0]();
}

uint64_t HKLogMedication()
{
  return MEMORY[0x1F40E7DD8]();
}

uint64_t HKLogSafeDescription()
{
  return MEMORY[0x1F40E7DE8]();
}

uint64_t HKLogSharing()
{
  return MEMORY[0x1F40E7DF0]();
}

uint64_t HKMetadataAliasRangesForKey()
{
  return MEMORY[0x1F40E7E10]();
}

uint64_t HKMetadataAliasesForKey()
{
  return MEMORY[0x1F40E7E18]();
}

uint64_t HKNSOperatingSystemVersionFromString()
{
  return MEMORY[0x1F40E7E28]();
}

uint64_t HKNSOperatingSystemVersionIsUnknown()
{
  return MEMORY[0x1F40E7E30]();
}

uint64_t HKNSOperatingSystemVersionString()
{
  return MEMORY[0x1F40E7E38]();
}

uint64_t HKNSOperatingSystemVersionsEqual()
{
  return MEMORY[0x1F40E7E40]();
}

uint64_t HKNotificationDomainIsDeprecated()
{
  return MEMORY[0x1F40E7E58]();
}

uint64_t HKObjectAuthorizationStatusForNumber()
{
  return MEMORY[0x1F40E7E80]();
}

uint64_t HKObjectForNanoPreferencesUserDefaultsKey()
{
  return MEMORY[0x1F40E7E88]();
}

uint64_t HKObjectValidationConfigurationWithOptions()
{
  return MEMORY[0x1F40E7E90]();
}

uint64_t HKOntologyShardSchemaTypeForShardIdentifier()
{
  return MEMORY[0x1F40E7E98]();
}

uint64_t HKOxygenSaturationLowBarometricPressureThresholdQuantity()
{
  return MEMORY[0x1F40E7EA0]();
}

uint64_t HKProgramSDKTokenAtLeast()
{
  return MEMORY[0x1F40E7EC0]();
}

uint64_t HKPromptForLegacyPerObjectAuthorizationDuringQueries()
{
  return MEMORY[0x1F40E7EC8]();
}

uint64_t HKRollingBaselineConfigurationForQuantityType()
{
  return MEMORY[0x1F40E7EE0]();
}

uint64_t HKSafeObject()
{
  return MEMORY[0x1F40E7EE8]();
}

uint64_t HKSelectedAuthorizationModeToString()
{
  return MEMORY[0x1F40E7EF0]();
}

uint64_t HKSemanticVersionFromString()
{
  return MEMORY[0x1F40E7EF8]();
}

uint64_t HKSensitiveLogItem()
{
  return MEMORY[0x1F40E7F00]();
}

uint64_t HKSeriesBuilderStateToString()
{
  return MEMORY[0x1F40E7F20]();
}

uint64_t HKSharingAuthorizationsFromAuthorizationIdentifiers()
{
  return MEMORY[0x1F40E7F28]();
}

uint64_t HKShowSensitiveLogItems()
{
  return MEMORY[0x1F40E7F30]();
}

uint64_t HKSleepDaySummaryQueryOptionsStringRepresentation()
{
  return MEMORY[0x1F40E7F38]();
}

uint64_t HKSleepDaySummarySampleTypes()
{
  return MEMORY[0x1F40E7F40]();
}

uint64_t HKSleepScheduleWeekdayArrayFromWeekdays()
{
  return MEMORY[0x1F40E7F48]();
}

uint64_t HKSleepScheduleWeekdayFromWeekdayComponent()
{
  return MEMORY[0x1F40E7F50]();
}

uint64_t HKSleepScheduleWeekdaysIsSingleDay()
{
  return MEMORY[0x1F40E7F58]();
}

uint64_t HKSleepScheduleWeekdaysMake()
{
  return MEMORY[0x1F40E7F60]();
}

uint64_t HKSourceOptionsForAppleDevice()
{
  return MEMORY[0x1F40E7F68]();
}

uint64_t HKStateOfMindAssociationFromDomain()
{
  return MEMORY[0x1F40E7F80]();
}

uint64_t HKStateOfMindKindFromReflectiveInterval()
{
  return MEMORY[0x1F40E7F88]();
}

uint64_t HKStaticSyncOptionsToString()
{
  return MEMORY[0x1F40E7FA8]();
}

uint64_t HKStringForMessageDirection()
{
  return MEMORY[0x1F40E7FB0]();
}

uint64_t HKStringForNotificationStatus()
{
  return MEMORY[0x1F40E7FB8]();
}

uint64_t HKStringForSharingStatus()
{
  return MEMORY[0x1F40E7FC0]();
}

uint64_t HKStringForSharingType()
{
  return MEMORY[0x1F40E7FC8]();
}

uint64_t HKStringFromBool()
{
  return MEMORY[0x1F40E7FD0]();
}

uint64_t HKStringFromFailableBooleanResult()
{
  return MEMORY[0x1F40E7FD8]();
}

uint64_t HKStringFromHKOntologyPruneOptions()
{
  return MEMORY[0x1F40E7FE0]();
}

uint64_t HKStringFromMedicalRecordCategoryType()
{
  return MEMORY[0x1F40E7FF0]();
}

uint64_t HKStringFromOntologyFeatureRequestOptions()
{
  return MEMORY[0x1F40E7FF8]();
}

uint64_t HKStringFromOntologyUpdateReason()
{
  return MEMORY[0x1F40E8010]();
}

uint64_t HKStringFromOptionalBooleanResult()
{
  return MEMORY[0x1F40E8018]();
}

uint64_t HKStringFromProfileType()
{
  return MEMORY[0x1F40E8020]();
}

uint64_t HKStringFromQoS()
{
  return MEMORY[0x1F40E8028]();
}

uint64_t HKStringFromUserDomainConceptPropertyType()
{
  return MEMORY[0x1F40E8030]();
}

uint64_t HKStringFromUserDomainConceptPropertyValueType()
{
  return MEMORY[0x1F40E8038]();
}

uint64_t HKStringFromUserDomainConceptStoreChangeType()
{
  return MEMORY[0x1F40E8040]();
}

uint64_t HKStringFromUserDomainConceptStoreMethod()
{
  return MEMORY[0x1F40E8048]();
}

uint64_t HKStringFromWorkoutCondenserReason()
{
  return MEMORY[0x1F40E8050]();
}

uint64_t HKSyncProtocolVersionToString()
{
  return MEMORY[0x1F40E8058]();
}

uint64_t HKSynchronizeNanoPreferencesUserDefaults()
{
  return MEMORY[0x1F40E8060]();
}

uint64_t HKWeakConceptLinkTypes()
{
  return MEMORY[0x1F40E8070]();
}

uint64_t HKWithAutoreleasePool()
{
  return MEMORY[0x1F40E8080]();
}

uint64_t HKWithUnfairLock()
{
  return MEMORY[0x1F40E8088]();
}

uint64_t HKWorkoutBuilderConstructionStateToString()
{
  return MEMORY[0x1F40E8090]();
}

uint64_t HKWorkoutSessionServerStateFromSessionState()
{
  return MEMORY[0x1F40E80B8]();
}

uint64_t HKWorkoutSessionStateFromServerState()
{
  return MEMORY[0x1F40E80C0]();
}

uint64_t HKWorkoutSessionStateToString()
{
  return MEMORY[0x1F40E80C8]();
}

uint64_t HKWorkoutSessionTypeToString()
{
  return MEMORY[0x1F40E80D0]();
}

uint64_t IDSCopyForDevice()
{
  return MEMORY[0x1F4122BB8]();
}

uint64_t IDSCopyIDForDevice()
{
  return MEMORY[0x1F4122BD0]();
}

uint64_t IDSCopyIDForEmailAddress()
{
  return MEMORY[0x1F4122BD8]();
}

uint64_t IDSCopyIDForPhoneNumber()
{
  return MEMORY[0x1F4122BE0]();
}

uint64_t IDSCopyRawAddressForDestination()
{
  return MEMORY[0x1F4122C10]();
}

IOReturn IOPMAssertionCreateWithDescription(CFStringRef AssertionType, CFStringRef Name, CFStringRef Details, CFStringRef HumanReadableReason, CFStringRef LocalizationBundlePath, CFTimeInterval Timeout, CFStringRef TimeoutAction, IOPMAssertionID *AssertionID)
{
  return MEMORY[0x1F40E8F70](AssertionType, Name, Details, HumanReadableReason, LocalizationBundlePath, TimeoutAction, AssertionID, Timeout);
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  return MEMORY[0x1F40E8FA8](*(void *)&AssertionID);
}

uint64_t MGCancelNotifications()
{
  return MEMORY[0x1F417CDD0]();
}

uint64_t MGGetStringAnswer()
{
  return MEMORY[0x1F417CE38]();
}

uint64_t MGRegisterForUpdates()
{
  return MEMORY[0x1F417CE60]();
}

uint64_t NRRawVersionFromString()
{
  return MEMORY[0x1F41306E0]();
}

uint64_t NRWatchOSVersionForLocalDevice()
{
  return MEMORY[0x1F41306F8]();
}

uint64_t NRWatchOSVersionForRemoteDevice()
{
  return MEMORY[0x1F4130700]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1F40E7010](aClassName);
}

NSString *NSHomeDirectory(void)
{
  return (NSString *)MEMORY[0x1F40E7110]();
}

void NSLog(NSString *format, ...)
{
}

uint64_t NSRequestConcreteImplementation()
{
  return MEMORY[0x1F40E7228]();
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1F40E7280](aClass);
}

uint64_t NSStringFromHKDayIndexRange()
{
  return MEMORY[0x1F40E80E0]();
}

uint64_t NSStringFromHKNotificationDomain()
{
  return MEMORY[0x1F40E8100]();
}

uint64_t NSStringFromHKNotificationInstructionAction()
{
  return MEMORY[0x1F40E8108]();
}

uint64_t NSStringFromHKOnboardingCompletionCountryCodeProvenance()
{
  return MEMORY[0x1F40E8110]();
}

NSString *__cdecl NSStringFromProtocol(Protocol *proto)
{
  return (NSString *)MEMORY[0x1F40E7298](proto);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x1F40E72B0](aSelector);
}

uint64_t NSWeekdayComponentFromHKSleepScheduleWeekday()
{
  return MEMORY[0x1F40E8118]();
}

uint64_t PBDataWriterWriteBOOLField()
{
  return MEMORY[0x1F4147190]();
}

uint64_t PBDataWriterWriteDataField()
{
  return MEMORY[0x1F41471B0]();
}

uint64_t PBDataWriterWriteDoubleField()
{
  return MEMORY[0x1F41471C0]();
}

uint64_t PBDataWriterWriteInt32Field()
{
  return MEMORY[0x1F41471E0]();
}

uint64_t PBDataWriterWriteInt64Field()
{
  return MEMORY[0x1F41471F0]();
}

uint64_t PBDataWriterWriteStringField()
{
  return MEMORY[0x1F4147220]();
}

uint64_t PBDataWriterWriteSubmessage()
{
  return MEMORY[0x1F4147230]();
}

uint64_t PBDataWriterWriteUint32Field()
{
  return MEMORY[0x1F4147240]();
}

uint64_t PBDataWriterWriteUint64Field()
{
  return MEMORY[0x1F4147248]();
}

uint64_t PBReaderPlaceMark()
{
  return MEMORY[0x1F4147268]();
}

uint64_t PBReaderReadData()
{
  return MEMORY[0x1F4147278]();
}

uint64_t PBReaderReadString()
{
  return MEMORY[0x1F4147280]();
}

uint64_t PBReaderRecallMark()
{
  return MEMORY[0x1F41472A0]();
}

uint64_t PBReaderSkipValueWithTag()
{
  return MEMORY[0x1F41472A8]();
}

uint64_t PBRepeatedDoubleAdd()
{
  return MEMORY[0x1F41472F0]();
}

uint64_t PBRepeatedDoubleClear()
{
  return MEMORY[0x1F41472F8]();
}

uint64_t PBRepeatedDoubleCopy()
{
  return MEMORY[0x1F4147300]();
}

uint64_t PBRepeatedDoubleHash()
{
  return MEMORY[0x1F4147308]();
}

uint64_t PBRepeatedDoubleIsEqual()
{
  return MEMORY[0x1F4147310]();
}

uint64_t PBRepeatedDoubleNSArray()
{
  return MEMORY[0x1F4147318]();
}

uint64_t PBRepeatedInt64Add()
{
  return MEMORY[0x1F4147398]();
}

uint64_t PBRepeatedInt64Clear()
{
  return MEMORY[0x1F41473A0]();
}

uint64_t PBRepeatedInt64Copy()
{
  return MEMORY[0x1F41473A8]();
}

uint64_t PBRepeatedInt64Hash()
{
  return MEMORY[0x1F41473B0]();
}

uint64_t PBRepeatedInt64IsEqual()
{
  return MEMORY[0x1F41473B8]();
}

uint64_t PBRepeatedInt64NSArray()
{
  return MEMORY[0x1F41473C0]();
}

uint64_t PLLogRegisteredEvent()
{
  return MEMORY[0x1F4145D90]();
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  return MEMORY[0x1F40F6DD8](attributes, result);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return MEMORY[0x1F40F6DE0](query, result);
}

OSStatus SecItemDelete(CFDictionaryRef query)
{
  return MEMORY[0x1F40F6DE8](query);
}

CFDataRef SecKeyCopyExternalRepresentation(SecKeyRef key, CFErrorRef *error)
{
  return (CFDataRef)MEMORY[0x1F40F6E40](key, error);
}

SecKeyRef SecKeyCopyPublicKey(SecKeyRef key)
{
  return (SecKeyRef)MEMORY[0x1F40F6E70](key);
}

SecKeyRef SecKeyCreateRandomKey(CFDictionaryRef parameters, CFErrorRef *error)
{
  return (SecKeyRef)MEMORY[0x1F40F6EE0](parameters, error);
}

CFTypeID SecKeyGetTypeID(void)
{
  return MEMORY[0x1F40F6F58]();
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return MEMORY[0x1F40F70F0](rnd, count, bytes);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return MEMORY[0x1F40D9438]();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return MEMORY[0x1F40D9450]();
}

uint64_t _HDDateForSQLiteValue()
{
  return MEMORY[0x1F411D638]();
}

uint64_t _HDQuantityForSQLiteValue()
{
  return MEMORY[0x1F411D640]();
}

uint64_t _HDSQLiteBindArrayToProperty()
{
  return MEMORY[0x1F411D648]();
}

uint64_t _HDSQLiteValueForData()
{
  return MEMORY[0x1F411D650]();
}

uint64_t _HDSQLiteValueForDate()
{
  return MEMORY[0x1F411D658]();
}

uint64_t _HDSQLiteValueForNumber()
{
  return MEMORY[0x1F411D660]();
}

uint64_t _HDSQLiteValueForQuantity()
{
  return MEMORY[0x1F411D668]();
}

uint64_t _HDSQLiteValueForString()
{
  return MEMORY[0x1F411D670]();
}

uint64_t _HDSQLiteValueForUUID()
{
  return MEMORY[0x1F411D678]();
}

uint64_t _HDUUIDForSQLiteValue()
{
  return MEMORY[0x1F411D680]();
}

uint64_t _HKActivityCacheDateComponentsFromDate()
{
  return MEMORY[0x1F40E8128]();
}

uint64_t _HKBackgroundAndSedentaryPrivateHeartRateContexts()
{
  return MEMORY[0x1F40E8138]();
}

uint64_t _HKCacheIndexFromDateComponents()
{
  return MEMORY[0x1F40E8158]();
}

uint64_t _HKCalculateWorkoutDuration()
{
  return MEMORY[0x1F40E8160]();
}

uint64_t _HKCategoryTypesForSymptomsBitmask()
{
  return MEMORY[0x1F40E8168]();
}

uint64_t _HKCategoryValueSleepAnalysisAsleepValues()
{
  return MEMORY[0x1F40E8170]();
}

uint64_t _HKCategoryValueSleepAnalysisDefaultAsleepValue()
{
  return MEMORY[0x1F40E8178]();
}

uint64_t _HKCategoryValueSleepAnalysisIsAsleep()
{
  return MEMORY[0x1F40E8180]();
}

uint64_t _HKCloudSyncObserverStatusToString()
{
  return MEMORY[0x1F40E8188]();
}

uint64_t _HKGenerateDefaultUnitForQuantityTypeWithVersion()
{
  return MEMORY[0x1F40E81B0]();
}

uint64_t _HKInitializeLogging()
{
  return MEMORY[0x1F40E81B8]();
}

uint64_t _HKLogDroppedError()
{
  return MEMORY[0x1F40E81C0]();
}

uint64_t _HKLogDroppedErrorWithReason()
{
  return MEMORY[0x1F40E81C8]();
}

uint64_t _HKLogPersistedSignposts()
{
  return MEMORY[0x1F40E81D0]();
}

uint64_t _HKLogSignpostIDGenerate()
{
  return MEMORY[0x1F40E81D8]();
}

uint64_t _HKLoggingActionCompletion()
{
  return MEMORY[0x1F40E81E0]();
}

uint64_t _HKMetadataKeyIsPrivate()
{
  return MEMORY[0x1F40E81E8]();
}

uint64_t _HKPausedIntervalsWithWorkoutEvents()
{
  return MEMORY[0x1F40E81F0]();
}

uint64_t _HKStatisticOptionsAverageSampleDuration()
{
  return MEMORY[0x1F40E81F8]();
}

uint64_t _HKStatisticsOptionAttenuateSamples()
{
  return MEMORY[0x1F40E8200]();
}

uint64_t _HKStatisticsOptionBaselineRelativeQuantities()
{
  return MEMORY[0x1F40E8208]();
}

uint64_t _HKStatisticsOptionPercentile()
{
  return MEMORY[0x1F40E8210]();
}

uint64_t _HKStatisticsOptionPresence()
{
  return MEMORY[0x1F40E8218]();
}

uint64_t _HKStatisticsOptionSleepStages()
{
  return MEMORY[0x1F40E8220]();
}

uint64_t _HKUnitPreferencesVersionToUnitDictionaryForQuantityType()
{
  return MEMORY[0x1F40E8228]();
}

uint64_t _HKValidDataTypeCode()
{
  return MEMORY[0x1F40E8230]();
}

uint64_t _HKWorkoutActivityNameForActivityType()
{
  return MEMORY[0x1F40E8240]();
}

uint64_t _HKWorkoutActivityTypeIsRouteable()
{
  return MEMORY[0x1F40E8250]();
}

uint64_t _HKWorkoutActivityTypeIsValid()
{
  return MEMORY[0x1F40E8258]();
}

uint64_t _HKWorkoutCanonicalActiveHoursUnit()
{
  return MEMORY[0x1F40E8260]();
}

uint64_t _HKWorkoutCanonicalBriskMinutesUnit()
{
  return MEMORY[0x1F40E8268]();
}

uint64_t _HKWorkoutCanonicalDistanceUnit()
{
  return MEMORY[0x1F40E8270]();
}

uint64_t _HKWorkoutCanonicalEnergyBurnedUnit()
{
  return MEMORY[0x1F40E8278]();
}

uint64_t _HKWorkoutCanonicalFlightsClimbedUnit()
{
  return MEMORY[0x1F40E8280]();
}

uint64_t _HKWorkoutCanonicalMoveMinutesUnit()
{
  return MEMORY[0x1F40E8288]();
}

uint64_t _HKWorkoutCanonicalSwimmingStrokeCountUnit()
{
  return MEMORY[0x1F40E8290]();
}

uint64_t _HKWorkoutCanonicalUnitForGoalType()
{
  return MEMORY[0x1F40E8298]();
}

uint64_t _HKWorkoutConfigurationWithActivityTypeAndMetadata()
{
  return MEMORY[0x1F40E82A0]();
}

uint64_t _HKWorkoutDistanceTypeForActivityType()
{
  return MEMORY[0x1F40E82A8]();
}

uint64_t _HKWorkoutGoalTypeAcceptsQuantity()
{
  return MEMORY[0x1F40E82C0]();
}

uint64_t _HKWorkoutGoalTypeIsValidForGoal()
{
  return MEMORY[0x1F40E82C8]();
}

uint64_t _HKWorkoutSessionLocationTypeName()
{
  return MEMORY[0x1F40E82D0]();
}

uint64_t _HKWorkoutSessionServerStateToString()
{
  return MEMORY[0x1F40E82D8]();
}

uint64_t _HKWorkoutSwimmingLocationTypeName()
{
  return MEMORY[0x1F40E82E0]();
}

uint64_t _IDSCopyIDForEmailAddress()
{
  return MEMORY[0x1F4122DB8]();
}

uint64_t _IDSCopyIDForPhoneNumberWithOptions()
{
  return MEMORY[0x1F4122DC0]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t PB::TextFormatter::beginObject(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x1F4147448](this, a2);
}

uint64_t PB::TextFormatter::format()
{
  return MEMORY[0x1F4147458]();
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2)
{
  return MEMORY[0x1F4147460](this, a2);
}

{
  return MEMORY[0x1F4147488](this, a2);
}

uint64_t PB::TextFormatter::format(PB::TextFormatter *this, const char *a2, double a3)
{
  return MEMORY[0x1F4147468](this, a2, a3);
}

void PB::Base::~Base(PB::Base *this)
{
}

uint64_t PB::Reader::recallMark()
{
  return MEMORY[0x1F41474C0]();
}

uint64_t PB::Reader::read()
{
  return MEMORY[0x1F41474D0]();
}

uint64_t PB::Reader::skip(PB::Reader *this)
{
  return MEMORY[0x1F41474E0](this);
}

uint64_t PB::Reader::placeMark()
{
  return MEMORY[0x1F41474E8]();
}

uint64_t PB::Reader::Reader(PB::Reader *this, const unsigned __int8 *a2)
{
  return MEMORY[0x1F41474F0](this, a2);
}

uint64_t PB::Writer::writeVarInt(PB::Writer *this)
{
  return MEMORY[0x1F4147520](this);
}

uint64_t PB::Writer::writeSubmessage(PB::Writer *this, const PB::Base *a2)
{
  return MEMORY[0x1F4147530](this, a2);
}

uint64_t PB::Writer::write()
{
  return MEMORY[0x1F4147540]();
}

uint64_t PB::Writer::write(PB::Writer *this)
{
  return MEMORY[0x1F4147550](this);
}

uint64_t PB::Writer::write(PB::Writer *this, double a2)
{
  return MEMORY[0x1F4147558](this, a2);
}

uint64_t PB::Writer::Writer(PB::Writer *this)
{
  return MEMORY[0x1F4147578](this);
}

void PB::Writer::~Writer(PB::Writer *this)
{
}

std::string *__cdecl std::locale::name(std::string *__return_ptr retstr, const std::locale *this)
{
  return (std::string *)MEMORY[0x1F417E400](retstr, this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E438](this, a2);
}

{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E440](this, a2);
}

{
  return (std::logic_error *)MEMORY[0x1F417E450](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4B8](this, a2);
}

{
  return (std::runtime_error *)MEMORY[0x1F417E4D0](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4D8](this, a2);
}

void std::runtime_error::~runtime_error(std::runtime_error *this)
{
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

std::regex_error *__cdecl std::regex_error::regex_error(std::regex_error *this, std::regex_constants::error_type __ecode)
{
  return (std::regex_error *)MEMORY[0x1F417E550](this, *(void *)&__ecode);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x1F417E628](this, __pos, __n1, __s, __n2);
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

std::system_error *__cdecl std::system_error::system_error(std::system_error *this, int __ev, const std::error_category *__ecat, const std::string *__what_arg)
{
  return (std::system_error *)MEMORY[0x1F417E708](this, *(void *)&__ev, __ecat, __what_arg);
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1F417E860]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E880]();
}

{
  return MEMORY[0x1F417E890]();
}

{
  return MEMORY[0x1F417E898]();
}

{
  return MEMORY[0x1F417E8A0]();
}

{
  return MEMORY[0x1F417E8B0]();
}

{
  return MEMORY[0x1F417E8C0]();
}

{
  return MEMORY[0x1F417E8C8]();
}

{
  return MEMORY[0x1F417E8D0]();
}

std::random_device *__cdecl std::random_device::random_device(std::random_device *this, const std::string *__token)
{
  return (std::random_device *)MEMORY[0x1F417E908](this, __token);
}

void std::random_device::~random_device(std::random_device *this)
{
}

std::random_device::result_type std::random_device::operator()(std::random_device *this)
{
  return MEMORY[0x1F417E918](this);
}

std::regex_traits<char>::char_class_type std::__get_classname(const char *__s, BOOL __icase)
{
  return MEMORY[0x1F417E960](__s, __icase);
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

const std::error_category *std::system_category(void)
{
  return (const std::error_category *)MEMORY[0x1F417E9E0]();
}

void std::condition_variable::notify_all(std::condition_variable *this)
{
}

void std::condition_variable::wait(std::condition_variable *this, std::unique_lock<std::mutex> *__lk)
{
}

void std::condition_variable::~condition_variable(std::condition_variable *this)
{
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

std::string *__cdecl std::__get_collation_name(std::string *__return_ptr retstr, const char *__s)
{
  return (std::string *)MEMORY[0x1F417EAA8](retstr, __s);
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x1F417ECE0](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x1F417ECE8](this);
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1F40C9B60](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

char *__cxa_demangle(const char *lpmangled, char *lpout, size_t *lpoutlen, int *lpstatus)
{
  return (char *)MEMORY[0x1F417EF58](lpmangled, lpout, lpoutlen, lpstatus);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

double __exp10(double a1)
{
  MEMORY[0x1F40C9B90](a1);
  return result;
}

uint64_t __strlcpy_chk()
{
  return MEMORY[0x1F40C9CD8]();
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

uint64_t _swift_stdlib_reportUnimplementedInitializer()
{
  return MEMORY[0x1F4186388]();
}

uint32_t arc4random(void)
{
  return MEMORY[0x1F40CA3A8]();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1F40CA3C0](*(void *)&__upper_bound);
}

uint64_t archive_entry_copy_pathname()
{
  return MEMORY[0x1F417DFD8]();
}

uint64_t archive_entry_free()
{
  return MEMORY[0x1F417DFF0]();
}

uint64_t archive_entry_new()
{
  return MEMORY[0x1F417DFF8]();
}

uint64_t archive_entry_pathname()
{
  return MEMORY[0x1F417E000]();
}

uint64_t archive_entry_size()
{
  return MEMORY[0x1F417E058]();
}

uint64_t archive_errno()
{
  return MEMORY[0x1F417E078]();
}

uint64_t archive_error_string()
{
  return MEMORY[0x1F417E080]();
}

uint64_t archive_read_data_block()
{
  return MEMORY[0x1F417E0A8]();
}

uint64_t archive_read_disk_can_descend()
{
  return MEMORY[0x1F417E0C0]();
}

uint64_t archive_read_disk_descend()
{
  return MEMORY[0x1F417E0C8]();
}

uint64_t archive_read_disk_new()
{
  return MEMORY[0x1F417E0D8]();
}

uint64_t archive_read_disk_open()
{
  return MEMORY[0x1F417E0E0]();
}

uint64_t archive_read_disk_set_metadata_filter_callback()
{
  return MEMORY[0x1F417E0E8]();
}

uint64_t archive_read_extract2()
{
  return MEMORY[0x1F417E108]();
}

uint64_t archive_read_free()
{
  return MEMORY[0x1F417E110]();
}

uint64_t archive_read_new()
{
  return MEMORY[0x1F417E118]();
}

uint64_t archive_read_next_header()
{
  return MEMORY[0x1F417E120]();
}

uint64_t archive_read_next_header2()
{
  return MEMORY[0x1F417E128]();
}

uint64_t archive_read_open_filename()
{
  return MEMORY[0x1F417E140]();
}

uint64_t archive_read_support_filter_all()
{
  return MEMORY[0x1F417E158]();
}

uint64_t archive_read_support_format_all()
{
  return MEMORY[0x1F417E180]();
}

uint64_t archive_write_add_filter_gzip()
{
  return MEMORY[0x1F417E1C0]();
}

uint64_t archive_write_data()
{
  return MEMORY[0x1F417E1D8]();
}

uint64_t archive_write_disk_new()
{
  return MEMORY[0x1F417E1E8]();
}

uint64_t archive_write_disk_set_options()
{
  return MEMORY[0x1F417E1F0]();
}

uint64_t archive_write_free()
{
  return MEMORY[0x1F417E208]();
}

uint64_t archive_write_header()
{
  return MEMORY[0x1F417E210]();
}

uint64_t archive_write_new()
{
  return MEMORY[0x1F417E218]();
}

uint64_t archive_write_open_filename()
{
  return MEMORY[0x1F417E230]();
}

uint64_t archive_write_set_format_pax_restricted()
{
  return MEMORY[0x1F417E250]();
}

int backtrace(void **a1, int a2)
{
  return MEMORY[0x1F40CA4F8](a1, *(void *)&a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return (char **)MEMORY[0x1F40CA508](a1, *(void *)&a2);
}

void bzero(void *a1, size_t a2)
{
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x1F4181558](cls);
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

long double cos(long double __x)
{
  MEMORY[0x1F40CB8A8](__x);
  return result;
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return (dispatch_block_t)MEMORY[0x1F40CB9C0](flags, block);
}

intptr_t dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CB9F8](block, timeout);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x1F40CBA60](identifier, flags);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1F40CBA88]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBAC0](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return (const char *)MEMORY[0x1F40CBBD8](queue);
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1F40CBC30](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1F40CBC40](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1F40CBC50](dsema, timeout);
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1F40CBC98](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1F40CBD30](when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return MEMORY[0x1F40CBD40](when, delta);
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

int dup(int a1)
{
  return MEMORY[0x1F40CBDF8](*(void *)&a1);
}

uint64_t dyld_get_active_platform()
{
  return MEMORY[0x1F40CBE10]();
}

uint64_t dyld_get_base_platform()
{
  return MEMORY[0x1F40CBE18]();
}

uint64_t dyld_version_token_at_least()
{
  return MEMORY[0x1F40CBF18]();
}

uint64_t dyld_version_token_get_platform()
{
  return MEMORY[0x1F40CBF20]();
}

void exit(int a1)
{
}

long double exp2(long double __x)
{
  MEMORY[0x1F40CBFE8](__x);
  return result;
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1F40CC058](*(void *)&a1, *(void *)&a2);
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x1F40CC1A0](__x, __y);
  return result;
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

int ftruncate(int a1, off_t a2)
{
  return MEMORY[0x1F40CC2F0](*(void *)&a1, a2);
}

int getpagesize(void)
{
  return MEMORY[0x1F40CC480]();
}

long double log(long double __x)
{
  MEMORY[0x1F40CC878](__x);
  return result;
}

long double log10(long double __x)
{
  MEMORY[0x1F40CC880](__x);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1F40CC8F8](*(void *)&a1, a2, *(void *)&a3);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x1F40CCB80](ptr);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

uint64_t mmapFileDescriptor()
{
  return MEMORY[0x1F40D6528]();
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1F40CD028](*(void *)&token);
}

BOOL notify_is_valid_token(int val)
{
  return MEMORY[0x1F40CD048](*(void *)&val);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x1F40CD050](name);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1F40CD060](name, out_token, queue, handler);
}

uint64_t nw_endpoint_copy_dictionary()
{
  return MEMORY[0x1F40F2E48]();
}

nw_endpoint_t nw_endpoint_create_host(const char *hostname, const char *port)
{
  return (nw_endpoint_t)MEMORY[0x1F40F2EA8](hostname, port);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1F4181638](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x1F4181640](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1F4181660](a1);
}

{
  MEMORY[0x1F4181668](context);
}

{
  return (void *)MEMORY[0x1F4181670]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181678](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1F4181680](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1F4181688]();
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_rethrow(void)
{
}

void objc_exception_throw(id exception)
{
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1F4181728](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1F4181748](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1F4181758](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1F4181780](location);
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F4181798](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1F41817A8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1F41817B8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1F41817C0]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1F41817C8]();
}

uint64_t self
{
  return MEMORY[0x1F41817D0]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1F41818B0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1F41818B8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C0](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F41818C8](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1F41818D0](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1F4181A18](location, obj);
}

void objc_terminate(void)
{
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1F4181A40](a1);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1F40CD550](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1F40CD560](log, ptr);
}

uint64_t os_state_add_handler()
{
  return MEMORY[0x1F40CD570]();
}

uint64_t os_state_remove_handler()
{
  return MEMORY[0x1F40CD578]();
}

void os_unfair_lock_assert_not_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x1F40CD818](__x, __y);
  return result;
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CD830](*(void *)&__fd, __buf, __nbyte, a4);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1F40CDB30]();
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CDBC0](*(void *)&__fd, __buf, __nbyte, a4);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return (void (__cdecl *)(int))MEMORY[0x1F40CE030](*(void *)&a1, a2);
}

long double sin(long double __x)
{
  MEMORY[0x1F40CE058](__x);
  return result;
}

int sqlite3_bind_blob(sqlite3_stmt *a1, int a2, const void *a3, int n, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1F4181F90](a1, *(void *)&a2, a3, *(void *)&n, a5);
}

int sqlite3_bind_blob64(sqlite3_stmt *a1, int a2, const void *a3, sqlite3_uint64 a4, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1F4181F98](a1, *(void *)&a2, a3, a4, a5);
}

int sqlite3_bind_double(sqlite3_stmt *a1, int a2, double a3)
{
  return MEMORY[0x1F4181FA8](a1, *(void *)&a2, a3);
}

int sqlite3_bind_int(sqlite3_stmt *a1, int a2, int a3)
{
  return MEMORY[0x1F4181FB0](a1, *(void *)&a2, *(void *)&a3);
}

int sqlite3_bind_int64(sqlite3_stmt *a1, int a2, sqlite3_int64 a3)
{
  return MEMORY[0x1F4181FB8](a1, *(void *)&a2, a3);
}

int sqlite3_bind_null(sqlite3_stmt *a1, int a2)
{
  return MEMORY[0x1F4181FC0](a1, *(void *)&a2);
}

int sqlite3_bind_text(sqlite3_stmt *a1, int a2, const char *a3, int a4, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1F4181FE8](a1, *(void *)&a2, a3, *(void *)&a4, a5);
}

int sqlite3_create_function_v2(sqlite3 *db, const char *zFunctionName, int nArg, int eTextRep, void *pApp, void (__cdecl *xFunc)(sqlite3_context *, int, sqlite3_value **), void (__cdecl *xStep)(sqlite3_context *, int, sqlite3_value **), void (__cdecl *xFinal)(sqlite3_context *), void (__cdecl *xDestroy)(void *))
{
  return MEMORY[0x1F4182120](db, zFunctionName, *(void *)&nArg, *(void *)&eTextRep, pApp, xFunc, xStep, xFinal);
}

void sqlite3_result_blob(sqlite3_context *a1, const void *a2, int a3, void (__cdecl *a4)(void *))
{
}

void sqlite3_result_error(sqlite3_context *a1, const char *a2, int a3)
{
}

const unsigned __int8 *__cdecl sqlite3_value_text(sqlite3_value *a1)
{
  return (const unsigned __int8 *)MEMORY[0x1F4182458](a1);
}

int sqlite3_value_type(sqlite3_value *a1)
{
  return MEMORY[0x1F4182468](a1);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return MEMORY[0x1F40CE138](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1F40CE188](*(void *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

uint64_t swift_allocError()
{
  return MEMORY[0x1F41863E0]();
}

uint64_t swift_allocObject()
{
  return MEMORY[0x1F41863E8]();
}

uint64_t swift_allocateGenericClassMetadata()
{
  return MEMORY[0x1F41863F0]();
}

uint64_t swift_arrayDestroy()
{
  return MEMORY[0x1F4186410]();
}

uint64_t swift_beginAccess()
{
  return MEMORY[0x1F4186430]();
}

uint64_t swift_bridgeObjectRelease()
{
  return MEMORY[0x1F4186440]();
}

uint64_t swift_bridgeObjectRelease_n()
{
  return MEMORY[0x1F4186448]();
}

uint64_t swift_bridgeObjectRetain()
{
  return MEMORY[0x1F4186450]();
}

uint64_t swift_bridgeObjectRetain_n()
{
  return MEMORY[0x1F4186458]();
}

uint64_t swift_checkMetadataState()
{
  return MEMORY[0x1F4186460]();
}

uint64_t swift_dynamicCast()
{
  return MEMORY[0x1F41864B8]();
}

uint64_t swift_dynamicCastUnknownClass()
{
  return MEMORY[0x1F4186508]();
}

uint64_t swift_endAccess()
{
  return MEMORY[0x1F4186518]();
}

uint64_t swift_errorRelease()
{
  return MEMORY[0x1F4186528]();
}

uint64_t swift_errorRetain()
{
  return MEMORY[0x1F4186530]();
}

uint64_t swift_getAssociatedConformanceWitness()
{
  return MEMORY[0x1F4186538]();
}

uint64_t swift_getAssociatedTypeWitness()
{
  return MEMORY[0x1F4186540]();
}

uint64_t swift_getDynamicType()
{
  return MEMORY[0x1F4186568]();
}

uint64_t swift_getExistentialMetatypeMetadata()
{
  return MEMORY[0x1F4186588]();
}

uint64_t swift_getExistentialTypeMetadata()
{
  return MEMORY[0x1F4186590]();
}

uint64_t swift_getGenericMetadata()
{
  return MEMORY[0x1F41865E0]();
}

uint64_t swift_getObjCClassFromMetadata()
{
  return MEMORY[0x1F41865F8]();
}

uint64_t swift_getObjCClassMetadata()
{
  return MEMORY[0x1F4186608]();
}

uint64_t swift_getObjectType()
{
  return MEMORY[0x1F4186610]();
}

uint64_t swift_getTupleTypeMetadata2()
{
  return MEMORY[0x1F4186650]();
}

uint64_t swift_getWitnessTable()
{
  return MEMORY[0x1F4186680]();
}

uint64_t swift_initClassMetadata2()
{
  return MEMORY[0x1F4186688]();
}

uint64_t swift_initStackObject()
{
  return MEMORY[0x1F41866A8]();
}

uint64_t swift_isUniquelyReferenced_nonNull_native()
{
  return MEMORY[0x1F4186700]();
}

uint64_t swift_once()
{
  return MEMORY[0x1F4186728]();
}

uint64_t swift_release()
{
  return MEMORY[0x1F4186758]();
}

uint64_t swift_retain()
{
  return MEMORY[0x1F4186770]();
}

uint64_t swift_slowAlloc()
{
  return MEMORY[0x1F4186798]();
}

uint64_t swift_slowDealloc()
{
  return MEMORY[0x1F41867A0]();
}

uint64_t swift_unknownObjectRelease()
{
  return MEMORY[0x1F41867E0]();
}

uint64_t swift_unknownObjectRelease_n()
{
  return MEMORY[0x1F41867E8]();
}

uint64_t swift_unknownObjectRetain()
{
  return MEMORY[0x1F41867F0]();
}

uint64_t swift_unknownObjectRetain_n()
{
  return MEMORY[0x1F41867F8]();
}

uint64_t swift_unknownObjectWeakAssign()
{
  return MEMORY[0x1F4186840]();
}

uint64_t swift_unknownObjectWeakDestroy()
{
  return MEMORY[0x1F4186858]();
}

uint64_t swift_unknownObjectWeakInit()
{
  return MEMORY[0x1F4186860]();
}

uint64_t swift_unknownObjectWeakLoadStrong()
{
  return MEMORY[0x1F4186868]();
}

uint64_t swift_willThrow()
{
  return MEMORY[0x1F41868E0]();
}

long double tan(long double __x)
{
  MEMORY[0x1F40CE420](__x);
  return result;
}

uint64_t tcc_identity_create()
{
  return MEMORY[0x1F415CCF0]();
}

time_t time(time_t *a1)
{
  return MEMORY[0x1F40CE588](a1);
}

int unlink(const char *a1)
{
  return MEMORY[0x1F40CE5E0](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x1F40CE608](*(void *)&a1);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

xpc_object_t xpc_activity_copy_criteria(xpc_activity_t activity)
{
  return (xpc_object_t)MEMORY[0x1F40CE978](activity);
}

xpc_activity_state_t xpc_activity_get_state(xpc_activity_t activity)
{
  return MEMORY[0x1F40CE990](activity);
}

void xpc_activity_register(const char *identifier, xpc_object_t criteria, xpc_activity_handler_t handler)
{
}

void xpc_activity_set_criteria(xpc_activity_t activity, xpc_object_t criteria)
{
}

BOOL xpc_activity_set_state(xpc_activity_t activity, xpc_activity_state_t state)
{
  return MEMORY[0x1F40CE9D0](activity, state);
}

uint64_t xpc_copy_entitlement_for_self()
{
  return MEMORY[0x1F40CED30]();
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x1F40CEE20](keys, values, count);
}

xpc_object_t xpc_dictionary_create_empty(void)
{
  return (xpc_object_t)MEMORY[0x1F40CEE30]();
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return (xpc_object_t)MEMORY[0x1F40CEE40](original);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEE80](xdict, key);
}

double xpc_dictionary_get_double(xpc_object_t xdict, const char *key)
{
  MEMORY[0x1F40CEEB8](xdict, key);
  return result;
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEC8](xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return (const char *)MEMORY[0x1F40CEEF0](xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x1F40CEEF8](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x1F40CEF10](xdict, key);
}

uint64_t xpc_dictionary_send_reply()
{
  return MEMORY[0x1F40CEF20]();
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_double(xpc_object_t xdict, const char *key, double value)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

BOOL xpc_equal(xpc_object_t object1, xpc_object_t object2)
{
  return MEMORY[0x1F40CF040](object1, object2);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1F40CF148](object);
}

uint64_t xpc_set_event()
{
  return MEMORY[0x1F40CF250]();
}

void xpc_set_event_stream_handler(const char *stream, dispatch_queue_t targetq, xpc_handler_t handler)
{
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x1F40CF2C8](xstring);
}

uint64_t xpc_transaction_exit_clean()
{
  return MEMORY[0x1F40CF2F0]();
}

uint64_t xpc_transaction_try_exit_clean()
{
  return MEMORY[0x1F40CF300]();
}

uint64_t objc_msgSenduint64_tForKeyPrefix_profile_date_error_(void *a1, const char *a2, ...)
{
  return MEMORY[0x1F4181798](a1, seluint64_tForKeyPrefix_profile_date_error_);
}